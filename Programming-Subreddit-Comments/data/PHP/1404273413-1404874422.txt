IMO PHP isn't the best tool (not even close to being the best) for desktop environments and is way better suited for web development.
There are places and times when `@` can be used constructively.
This is a programming subreddit. I give specs.
Examples?
Not only is that hardly relevant, but no one has cared, or will ever care.
Symfony isnt meant to be super simple right off the bat. Its complex because it allows for a lot of flexibility. On the same coin, why does flexibility have to come from an API. If the configuration is robust, and well documented (which IMO is the real issue, that symfony is working on), how is it worse? 
This thread has been linked to from elsewhere on reddit. - [/r/SubredditDrama] [Is a 12-core Xeon enough to get smooth webpage scrolling? The code warriors at /r/PHP amicably discuss.](http://np.reddit.com/r/SubredditDrama/comments/29mikd/is_a_12core_xeon_enough_to_get_smooth_webpage/) *^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote ^or ^comment. ^Questions? ^Abuse? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag)* 
&gt;So you check the input against a whitelist AND use prepared statements? Yes, if I'm only expecting alphanumerics, I make sure the data is only alphanumeric. If I'm expecting quotes too, I make sure it's only alphanumeric and quotes, etc. Furthermore if I'm expecting a name, I make sure it's a single string of alphas with no spaces. If an email, I make sure it matches the email schema, so on and so on. &gt;Is this not overkill? Absolutely not. In addition to protecting against injection it protects you against XSS vulnerabilities as well as improper usage of your application. Every single user should be treated as potentially malicious by your application. &gt;Sure you should know the type of data you expect but sometimes you WANT to give them the freedom to use quotes etc, correct? Of course, but you always make sure they can only use what you want them to use as intended. It's better to risk being too overbearing than risk being too light. Annoyed users are recoverable, leaked user data or a hacked site may not be.
It may not be the best, but it does let you avoid learning yet another language.
And the 3 line Yaml for that is pretty clean and straight forward too. So, its really just a personal preference and heavily subjective....?
/cringe... Doing one bad thing to avoid other bad things is not a good thing.
Except it's YAML - another language construct (specifically the configuration keys) that needs to be learned, in addition to annotations and other pseudo languages that make the framework work. So if you want to avoid unnecessarily verbose PHP, your options are another language, or annotations (also another language) This is not just personal preference and heavily subjective. Symfony is in fact, more complex than Laravel, and requires developers to do more wiring and configuring up front, and learn additional pseudo-languages (YAML, annotations, which config keys are "special" and have underscores, PHP code written as a string, random symbols in config key values...) It's all very messy, and doesn't do anything you can't do in another framework using the knowledge of PHP you already have.
Why the giant font?
Yaml is extremely easy to learn.... And like another guy said here, i've spent more of my time in the code, than the configuration. It's only messy if you make it messy. It also doesn't require you to do anything. You can decide to use Yaml, XML, annotations, or NONE of them. The stuff isn't that hard, just need to read docs. Lot easier now than it used to be.
This is beyond my peasant coding skills but I really like that the author explained why the example was wrong and showed and explained a better way to complete the task. Much better than just picking random things from stuff I've written. 
I worked in agencies for ten years, but now I work for a major online travel company. I prefer where I am now. The work is more interesting and challenging, less client side work, which I don't excel at, more career prospects and much higher pay.
Not sure if you mean working in-house vs freelancing or freelancing for agencies vs freelancing for direct clients. If freelancing for agencies versus direct clients, I definitely prefer working for agencies. The rate is lower, but they provide a lot more projects and have an idea of how it works, although they can also be terribly amateurish too.. Random customers though are more likely to have crazy needs and no specification at all. You also need to handle the whole process, specifications, design, development, etc. while for an agency, I only work on development.
Actually I had the same issue in my laptop and was not able to read the article. But I was running my laptop (Athlon quadcore with 6gb) in power saving mode because of overheating. I was also running 2 virtual machines in the background. So I thought the lag was due to these. But other sites was working fine though. Was not able to read the article because of this. Actually I was also downloading a torrent in the background. I don't get the people that are attacking you. Edit: Tried again. No change..
Actually specs are relevant when you are complaining about performance, and so I don't see anything wrong with /u/neoform3 mentioning the specs.
In this instance, just mentioning that you have a high end desktop is fine, because no one even asked
I wrote kiosks for events on WAMP stacks. Users would sign up for the website at the event, and I created an "export" function for an admin that would create a .sql dump, zip it up, and allow them to upload all of the users that registered for their site at the event. This was a year or two before iPhones/Smart Phones made it big, so most people didn't notice the delay. They would simply get home and see an email later that night after the admin uploaded them into the system.
About the same chance as winning lotto. You might be OK with an ORM, but there are just way too many differences between sql implementations for this to be a reality.
http://www.php.net/manual/en/function.fopen.php#refsect1-function.fopen-errors Some functions return false or provide methods to check for errors, you don't need these in your logs if you handle those conditions correctly in code.
It's not convenient to set up, but once your project is set up, working with Symfony is an absolute joy. 
If this is the sort of thing we shower praise all over people for now, we're in trouble. We spend more time discussing PHP's shortcomings (and by extension, the community shortcomings) that very few people are interested in discussing anything of real substance. Instead we continue to rehash the same well publicized things we've been rehashing for years and it continues to have no real impact on anything. Articles that talk about mistakes people make in PHP are a dime a dozen. ...and really guys, a popup modal? That just makes me close the window and leave me with an impression that your site is garbage.
Please let me introduce you to my ex-coworkers ... Developers can be as lazy as anyone else and get comfort in their habits. The problem sometimes become only apparent when they start looking for a new job.
If you want to check whether a variable containing a PCRE regex is valid or not, the only way I've found to do it is to attempt a `preg_match` but use @ to suppress any potential warning.
Is it a lot less efficient than using array_map ?
Loops are *more* efficient than `array_map()` since they're inline.
Not sure if it's intentional or not, but #10 is fixed by implementing `__isset`. http://3v4l.org/5hEak Good article!
I've experienced all three variants, so here is my not so humble opinion. **Freelancing** Pro: Can be incredibly fulfilling. If you are lucky you can pick and chose the projects you like. You normally earn quite a bit more money then when you work for "the man". You can control your own time and can build your private life easily around your work and vice versa. Con: Can be incredibly frustrating, because most of the times you have to wear multiple hats. You will not only be a programmer, you will be customer manager, akquisitioner, tester, maybe designer, help-line etc. etc. If your customers suck (either because they are evil or just because they have no technological knowledge) that can be quite frustrating. Also, you will HAVE to control your own time and if you are bad at it (as I was) you will either work way too much, sacrificing your private life and your social circles, or you won't do enough and will be in perpetual crunchtime. **Working for a web agency** Pro: regular income is a nice thing to have. Having not to deal with (too many) customers directly, but having dedicated people for that is fine. But sometimes they aren't very techsavvy either, which will lead to "I don't want to know what the problem, just make it work". Con: You are working for "the man". If you have a reaaaally successful project it isn't very likely that the benefits will trickle down to you. Also, designers get all the praise as their stuff can be easily recognized, programmers often are just a "Oh yeah, he writes that stuff" sidenote. Also, if you agency is working like mine was it is a "work from project to project to project" thing and if there are no projects layoffs and other stress factors are not so uncommon. **Working for a company with their own project(s)** Caveat: That's the situation I'm in now. I've worked for this company that is a big porn supplier in europe for about a year now. Pro: You work more or less continuously on the same project. That means you get intimately familiar with the code which, in my opinion, is nice. Hopefully your company is okay with trying new stuff, so that you don't only have to work on legacy code but can try new paradigms. Better yet, they hopefully have no problem with mayor refactorings. Since you have one or more defined projects the company income should be a given thing, so no fear of layoffs there. Con: You work on the same project. If you prefer ever changing themes and challenges this is maybe not for you. Beyond that I have not much to say against it. The last year I've worked here I've been way happier then in any of my previous jobs, never mind if I were salaried or freelancing. Hope this helps a bit.
Yeah it's annoying how prevalent and accepted this is. I usually just type "fuckoff" or another bogus email into the box.
&gt; pre-defined "sanctioned" queries whut This happens somewhere on the planet?
If you can remember to reverse the condition, you can remember to type `==` I haven't made this mistake for years. Honestly I'm more likely to forget a semicolon.
Congratulations.
I prefer using SplFileObject to try to open a file and then catching the RuntimeException that it throws if it can't.
Thank you. Yoda conditionals are still retarded.
Also if you are writing and article about practices make sure your queries are escaped.
It might be final incorrectly. But inheritance is terribly overused. It leads to unnecessary coupling, and to violations of the Single Responsibility Principle. There's a whole host of other techniques, like composition, messaging, decoration, strategy pattern, etc, that are usually better choices than inheritance. If inheritance is your only tool , then yes, every final class is going to look wrong.
There is just as much attacking coming from him, as going the other way. In regards to your loading. How long did you wait to read the article?
Thanks for taking the time to write that. I've just started working for an agency, I was working for a company with their own projects before. I've not been at this agency long though so I'll have to see how my experience after some time. Thanks for the insight. :)
I think I might just be too worried about the potential lack of work if I were freelancing. How do you deal with that and ensure you have work?
Er.... This is not what this subreddit is for
Yes, but can you do cake php?
What if someone can find the hash by sniffing packets between two servers? Should we use SSL for it?
if the subsites are on other domains then i still too would vouch for oauth especially cause oauth server/client is not so difficult to implement in wordpress
Try to keep it that way. Depending on the size of your agency sooner or later someone will come to you and say something like "You know computers, right? Surely you can help Judy with her E-Mail problem?!". It's all downhill from there on out!
Yeah, in the long run it is really dependent of the company you work for anyway. There are miles and miles of differences between companies even if they work in the same sector.
&gt; How long did you wait to read the article? Waited until it is completely loaded....But scrolling is not at all responsive. Seems like other people also are [having issues]( http://np.reddit.com/r/SubredditDrama/comments/29mikd/is_a_12core_xeon_enough_to_get_smooth_webpage/) 
If you know how to code why do you need a tutorial? 
Wordpress has not future, because it's already dead – sad part is that some people just won't let go of the dead...
&gt; 22% of websites running on WordPress from the linked source: &gt; WordPress is now powering 14.7% of the top million websites in the world
I have yet to meet developer who doesn't passionately hate WordPress and everything it stands for.
nice that you thought about ignored fields, very useful.
So? The majority of web servers won't update to it for many years to come. Especially if it has super breaking changes.
&gt; PHP is often derided and excluded on programmer hubs like Hacker News, and many programmers scoff at working with a pre-built platform, especially one fundamentally based around PHP. Pretty sure they're scoffing at the WP codebase, not just any platform built on PHP.
It's literally impossible to do an atomic file delete in PHP. So if (file_exists($file) &amp;&amp; is_writable($file)) { unlink($file); } could raise an error, which is impossible to prevent. For example, if the file gets deleted between the `is_writable` and the `unlink` calls. So it's acceptable to do: if (file_exists($file) &amp;&amp; is_writable($file)) { @unlink($file); } 
PDO isn't *always* the best fit. It has a little more overhead than mysqli, and small simple apps don't really benefit from it. That said, I think the mysqli API sucks. PDO is much better to work with.
Still doesn't make it right. Especially since it's trivial to just do `$key =&gt; $value`. After all, which is more obvious what it does: foreach ($a as &amp;$b) { $b = $b + 1; } vs foreach ($a as $key =&gt; $value) { $a[$key] = $value + 1; } I think the bottom one is more readable, since it's obvious where the assignment is happening, without needing to look at the details. And that's not even getting into the problem with references themselves (which is really well documented). So I recommend avoiding them unless absolutely necessary.
As always [phptherightway](http://www.phptherightway.com/).
I personally don't care for wordpress eventho I use it at work (pays for the bills) but why is it so hated? ( I personally don't like how heavy it is and how the platform is trying to be morphed into a CMS that has way too many overcomplicated stuff).
The only scenario I could imagine is if the php file was somehow dynamically generated by the application itself, and facilities like apc_stat are set to 0 (not checking file modification times etc). 
Mirrors my experience as well. I've worked at a digital agency, in a communication department, and on a web product. Things I'd add: *Web Agency* - Great way to make contacts at lots of organizations, which can help if you ever make the jump to freelance. - Once a project is done, you may never hear or work on it again. Other projects, usually the not-so-good ones can live on for years much to your surprise. - The good ones will sponsor and/or send people to conferences, camps, and encourage you to be active in the community. - If the digital agency decides to specialize in, ooh, say drupal/wordpress/joomla because that's what clients are asking for, that's what you'll be learning and working on. - Lots of pressure for developers to be billable. Hard to make/find/argue for time to make big process improvements, learn new skills outside of a project, etc... - Working on something new/interesting requires finding a client that wants to do it or making the case to spend precious non-billable time. *Freelance* - You'll also have to deal with legal issues like registering to be an LLC, having and preparing a standard contract for each project - You handle invoicing, and bugging clients to pay you. - You'll have to handle some accounting/bookkeeping, and the tax consequences of running a business. *At a single product/site company* - Can be easier to leave work at the office. In my experience crunch time/death marches are less frequent. - You and your team can be seen as a trusted expert - The organization may not be set up to offer perks like telecommuting, remote work, splash cash on laptops, etc. - In my particular experience, this is where I was exposed to a lot more technologies (mainly because the agency I worked at previously focused on CMSes). So here I learned about handling online video, scaling sites, ecommerce, etc... 
Try to figure out a way to make passive income. Also you have to network, network, network.
&gt; ...and really guys, a popup modal? NoScript my friend, makes the site run so much better.
I [complained](http://www.reddit.com/r/PHP/comments/29kfc4/10_most_common_php_mistakes/ciltpcc) about the same thing and my comment's at +7, go figure.
If it's a standalone site, I'd use a framework, most likely [Laravel](http://www.laravel.com), because I can get things up and running extremely quickly with it. I'd start by creating an ORM class for galleries and images, and then simple [repositories](http://msdn.microsoft.com/en-us/library/ff649690.aspx) for each. Next up, I'd create several service classes: * UserSessionService - handles user registration, login, and logout * AccessControlService - handles checking whether a particular user can manage a particular image * ImageFileService - handles creating and deleting image files * ImageService - handles standard CRUD operations for images Lastly, I'd build out the controllers (that mostly just pass data to the service classes) and views for the images. 
This is one of those things I also find myself doing after doing a bit of Haskell. For some things it can make the code a lot simpler....
Definitely a winner, that one -- used it in Symfony projects before. I wish the standard ECMA5 JSON.parse could handle references. There's an underscore plugin I believe that can restore references in objects parsed from JSON.
What do you mean by 'they are inline'? I am asking because I cannot imagine how a loop can be 'inlined' in the same sense functions can be inlined...
This is a bad example of applying Haskell knowledge to other languages. Like many functional languages, Haskell has *tail recursion*: once compiled, there won't be any recursion. PHP will recurse, and that is costly. Try to run `render_delimited(array_fill(0, 2000, 'Bob'));`. In my case, the output was: PHP Fatal error: Allowed memory size of 134217728 bytes exhausted (tried to allocate 72 bytes) To programm better, one needs to understand the concepts used by the language, as well as its ecosystem. Here is a much saner (yet untested) implementation for PHP: function render_delimited(array $strings) { $count = count($strings); if ($count === 0) { return ''; } else if ($count &lt; 3) { return implode(' and ', $strings); } else { $last = array_pop($strings); return implode(', ', $strings) . ' and ' . $last; } }
I do look forward to the day when we can just put everything in annotations and not have to write any actual code ;-)
When a function is inlined, the logic comprising that function directly replaces the function call itself. Loops do not *become* inlined, they *are* inline since they occur in the same scope -- they're not "called". It just means that the code block doesn't call out to another function but continues procedurally.
Thanks for your reply! Yes it is a standalone. So far I can authentificate users have an active sessions etc... It is built in an OOP pattern. However I do not have controllers for the views... worked with regular mixed php / html pages. Good or bad idea, I don't really know. I will try it like you suggested for the classes structures. Would the framework bring anything additional if I already have the backend to authentificate users (register log in; db connection etc) 
I don't think it's as bad as you think, as long a you start with compatibility in mind. You can isolate and abstract around SQL implementation differences as part of the architecture and clean up in places that need it. I wrote a small open source blogging/image board platform, originally developed against SQLite and it was shockingly trivial to add Postgres and MySQL once I was done - I did no testing during primary development against the latter. Of course if you're jumping in thinking of MySQL only and using all sorts of known MySQL specific constructs, then sure it's a lost cause. But there are many software out there that are cross-db compatible (whether using PDO or other abstraction layer). The other side of of this, too, is if your software uses PDO calls and I try to run it against, for example Pg when it was written with MySQL in mind, then at least I have a chance to run it and try to track down and tweak queries that don't work. Using mysql_* calls, the code won't even get past the connect().
This is a great point; the memory overhead of recursion is a point that I semi-intentionally left out of this post. This sort of technique would obviously have to be applied only with an awareness of how the code will actually be used, or control the limits "by hand" by adding something like if ($count &gt; MAXIMUM_SIZE) { throw SomeException(); }
&gt; However I do not have controllers for the views... worked with regular mixed php / html pages. Good or bad idea, I don't really know. Generally considered bad, because you end up with tons of repeated code all over the place or having business logic run in the same files as your presentation logic. &gt; I will try it like you suggested for the classes structures. Would the framework bring anything additional if I already have the backend to authentificate users (register log in; db connection etc) A "full stack" framework of any kind will allow you to manage your URL structure much more easily, and provides lots of other services (validation, view templates, that sort of thing). Essentially it keeps you from solving a bunch of problems that other people have already solved. I'd definitely look into using a framework - the one I mentioned in my previous comment is relatively easy to learn and provides a lot of functionality you'd otherwise have to implement yourself. Personally, I'd almost never roll my own authentication package due to the potential for security flaws. You might want to look into something like [Aura.Auth](https://github.com/auraphp/Aura.Auth).
Kinda freaky that we have a Judy as it happens.
&gt; You may have heard about namespace in PHP. But what exactly namespace? What is the behind story of namespace? How it works or why we have to use namespace? Has Anyone Really Been Far Even as Decided to Use Even Go Want to do Look More Like?
goodluck :) Dont let this discourage you :)
It's hated because 9 times out of 10, it's used for more than what it was designed to be: a simple blog with minimal code-level customization. Instead, clients want a website with *some* content entry, web agencies think that they'll save a bunch of time and money by using wordpress, and then get fucked when the client wants *some* content entry ON TOP OF full blown custom content with complex business rules, ecommerce , social media (forums etc). And on top of that, they often want custom URI schemes, custom breadcrumb behavior, dynamic layouts etc. You can download a WP theme framework which helps alleviate some of those problems, but then the client wants one thing that requires diving deep into someone else's interpretation of wordpress architecture, and finding out how to extend it (if you can), or straight up modify it... Wordpress is a pain in the ass. All of the sites I've ever built in Wordpress, all the time I spent fighting Wordpress's URI structure assumptions, sidebar / widget behavior, custom post types and taxonomies.... I could have built much faster in Laravel or Codeigniter.
You should always use SSL for anything that has to do with authentication.
`user_folder` is doing some strange things: $user = readdir(...) ... if(isset($user)) $user will always be set. You are also going to be trying to `mkdir(file_ext_strip('.'))` and `mkdir(file_ext_strip('..'))` So is the point to create a directory for every file in that folder? i.e. `./CSV/abc.csv` needs a `./CSV/abc/`? In `function date_folder` `$user_folder` is undefined. I don't understand what you're trying to achieve, but I don't think that you have it.
If you're a professional java developer I'd recommend symfony. Use their documentation as your source. 
Once upon a time I had a PHP file who's output was a date sensitive JavaScript. Had the JavaScript header and everything. Took a while to figure out why the script stopped working when we turned on APC.
We actually have a site that doesn't work with opcode caching. The site does make use of several eval() calls due to the way the code is stored and executed. Without going into too much detail we have a content management system that utilizes "hooks" in the content to load external code to handle things like dynamic content (charts, etc) that are programmatically generated. We have discovered that code included via the eval calls get's cached in very weird ways which ends up displaying the wrong information in the wrong location. For instance we have a script that does dynamic charts. The processing and display logic is the same, just the underlying information is different (which comes from a database). For some reason... it just goes nuts when we enable op code caching. The only way we were aware that it was a problem was during testing of the op code cache on the dev server. Even then it was a couple of days before we actually noticed the issue since it was rather subtle. The information was there, only on closer inspection did you realize that it was actually the wrong data. So we have to exclude certain files from the op code cache to avoid this issue. The code is relatively light weight, so it isn't a huge problem with the performance of the site compared to other areas. 
http://phptherightway.com is an excellent resource. If you learn best by doing, check out a micro-framework like Silex to get started (it's based on Symfony so bonus). If you're looking for hands on instruction, we're working on a course just like that - PHP for Programmers but haven't scheduled it yet. http://www.phparch.com/training/ We do have an Advanced PHP course that skips the basics of programming. *We: I'm one of the owners of php[architect]
Yes except it works... sometimes. I've tried using it 4 times (separate projects) and I succeeded only once. There are so many bugs and gotchas, it's really unusable in my opinion.
Something to consider is this: In an agency, the agency is likely to be paid by its client by the hour. Because of this, there is a limit to the value you can bring to the company while serving as a developer. This will likely cap out your salary growth at a certain point. For a company that produces a product, if you are awesome you may be able to bring much more value to the company and therefore reap a greater salary.
Last week, I interviewed two PHP developers each claiming ~4 years of experience. One of them uses `mysql_query`, the other uses CodeIgniter's DB driver based on `mysql_query`. FML.
That is quite a confidence boost I am getting from these responses. As I always think I am not really that good at this.
You're going to need explicitly define the criteria for what constitutes similarity between two stores. The you're going to need to find a way to turn that similarity into an algorithm that doesn't require you to reevaluate the similarity score for every store every time you want to check. 
I guess Impostor Syndrome is a thing, but I do not really like feeling coky or over confident. Also when I am looking at what other people are doing, and compare with the day to day stuff that I end up doing I end up feeling that I am just playing around.
By honeypot method do you mean hiding a form field with CSS and rejecting forms submitted with that field filled? Because that's been the most effective method for me. Granted it wouldn't work for anyone targeting your site *specifically*, but it works for 99% of the bots out there.
I've been using it for a little bit more than a year and didn't encounter any problems that were solely the library's fault. It also offers a decent number of options and customization posibilities.
I get the point you're trying to make, but I don't think you quite grasp the entire concept you're trying to explain either. Arrays are *often* used when classes would be better served for the purpose, but sometimes arrays are a better choice in the scope of the function they're being used in. Your entire article could have been replaced with the sentence from your conclusion: "Arrays are not evil but should only be used when a collection of data has no associated behaviour." and made much more meaningful sense.
I completely agree. I was just giving a scenario
A simple CAS system could solve this same issue. OAuth wouldnt make it any easier than CAS
You owe me like a bag of brain cells, I could feel them dying while trying to read your sentence! 
And it wasn't working because Opcache cached the content of the outputted javascript?
It doesn't matter is someone finds the hash. The hash will be different with every request, so unless they know the private key, it'd be a huge undertaking to brute force it. E.g if you're trying to login user hello@example.com, with password "mypassword", and your private key is "areallyobscurestring", you'd create the hash: $timestamp = time(); $hash = sha1('hello@example.com' . 'mypassword' . 'areallyobscurestring' . $timestamp); In your request to the API you send the username, password, timestamp and hash. Not the private key. When verifying the request on the other server, you recreate the hash with the data provided and the private key stored in a configuration file already on the server. If the hashes match, it's a valid request, if not it isn't. As ThePsion5 says, SSL will help prevent packet sniffing. There are already millions of WordPress websites on the internet that don't use SSL, but that's not a defence or a valid reason not to use SSL yourself.
Did you purposefully not add an email field to the users table?
Hi, Sounds logical. I guess we also need to implement a similar hashing algorithm for responses, incase they send a fake JSON response to client application and attempt to log. We'll definitely use SSL, but should we do anything else beyond them, such as whitelisting domains?
I'm not familiar with Wordpress at all. I wanted to create a subdomain in the same server as wordpress app and develop a basic auth API myself by using Wordpress' users table. (I'm sure it is named as users but it is WP we're talking about here so it could be different. :p) I'm not exactly sure where the other apps will live in since I'm the newest dev in this startup. It could be in the same environment or completely different environments, but I guess I'll develop it the way they can live in different environments, so it will be better for us in the long run. By the way, WP login will allow oAuth providers, so they will be able to login WP using oAuth. It is just we need some kind of API system to inform both sides. (e.g we don't directly need oAuth, rather something that informs our applications when user logs using oAuth providers.) Do we need to implement oAuth on client websites too? Doesn't oAuth consider it as a whole different website? Sorry, I used oAuth providers in the past, but I don't know how I can use oAuth in this case. What kind of workflow do I need? If oAuth has alot more benefits than a basic CAS (which we can develop pretty quickly) I would research on it and implement the feature using oAuth. 
Two possible ways to do this. - The first, store the product IDs in the session. This'll be the items in their cart for the duration of their session. - And secondly, store the product IDs in the database associated with a user ID. This'll be a persistent shopping cart.
`php_flag engine off` in the upload directory. This will prevent executable scripts from running if someone manages to upload something. However, it isn't the only way to compromise a site.
No, this is just the data storage. Every time you open a page you create a new shopping cart class instance. Then you look in the session or DB if there are product IDs in there. If so, load those products from the database and put them in the shopping cart. From there on you can add pages that add/remove items from the cart.
I think i understand this, but I'm lost on how to take that idea into php language. gonna try my best though 
When you talk about having to change code in 7 distinct spots to get from the database to the UI... is that the project I think it is?
Prepared statements use placeholders to replace the values in the query. Just look up some PDO examples and you'll see.
Yes, the placeholder names are mapped to the array keys. The leading colon in each array key is optional iirc; my experience has been that it's best to leave it out.
Not quite in the same way
Have a table where each row is an item in a person's cart then to get all the item's a person's cart do something like this: $sql = "SELECT * FROM shopping_cart_inventory WHERE customer_id = :customer_id"; $stmt = $dbh-&gt;prepare($sql); $stmt-&gt;execute(array( 'customer_id' =&gt; $user_id )); $user_id should be the logged in person's user id as stored in the database.
Never, ever, EVER insert external (or even internally stored) data into a raw query. That's how you get SQL injection. Always used bound parameters (what pmjones showed you).
This would be the use case. 
Laravel isn't a framework I'd recommend starting with, but I guess it's one of the simpler ones...
By learning and improving while developing actual applications. These two ideas don't need to be mutually exclusive. Good programmers don't wake up one day and proclaim they know everything. The learning process never actually ends for any of us.
Expanding on /u/SkepticalMartian's response: I find that the best way to learn is to implement something *real* — so I evaluate what's available, including things I don't yet know, when choosing how to write something new.
I would just like to say, good job at this. I didn't check out the first one, and skipped a lot in the 2nd one, but good work so far. Keep it up. And seriously guys, everyone needs to remember, we all started some where, and I am sure we all didn't sound like complete masters when we started... but sharing knowledge is key. nice work
That's even worse :|
Exactly. Works great.
After my initial book learning, and tinkering, all of my new skills have come from real world experience. Sometimes it's stepping out of my comfort zone to work with a new library or implement some required functionality for a client (using longitude and latitude to provide users with location radius search results from a database was a fun learning experience), other times it's just realizing that I've been doing something inefficiently and doing some research to learn how to do it better.
&gt; my experience has been that it's best to leave it out. Why? I don't remember seeing any PDO documentation that does not use the leading colon. It is best to stick to standards and it also improves readability by clearly differentiating the place holders from the rest of the query.
&gt; PDO does not quote any thing (unless you are running emulated prepared statements) So like, everybody who uses MySQL and leaves PDO at its defaults? The default is for ATTR_EMULATE_PREPARES to be turned on, which causes PDO to quote the data itself and not use MySQL's native parameterised query support: https://bugs.php.net/bug.php?id=54638
Judy is the devil! THE DEVIL, I SAY!!!
I honestly don't get why "()" poses such a big issue for you when your final implementation actually works exactly the same way. What you are creating here is basically some weird syntactic sugar; actually adding more code than is necessary by keeping the methods private and adding the usage of __get(). 
Every project I do I try to do at least three things new or better than the last one. Since we bust out so many projects, its easy to do something different on each one. Just start with something simple; like "I really want to make this db connection function more efficient" or write a class to do common tasks. Most things really will help build and solidify your skills with practice and repetition. 
Do you leave PDO at it's defaults? Does any one here do that? I thought it was standard practice to turn off emulated prepared statements when initializing pdo. Any way, that is not the point. The point is the statement in question conveys wrong information on how placeholders and prepared statements really work.
I sure hope Bobby Tables doesn't comment on your site. 
Before using Doctrine, i never even knew this was a thing, so yeah, people do. And I'm sure I'm not the only one... His statement doesn't really seem to provide wrong information, if the bug still exists, then PDO is quoting the placeholders, is it not? By definition of the word "default", his statement was correct
&gt;Parameter identifier. For a prepared statement using named placeholders, this will be a parameter name of the form :name http://php.net/manual/en/pdostatement.bindparam.php
 &lt;?php function print_things($links = null) { if (!is_array($links)) { $links = array( array("link"=&gt;"#", "text"=&gt;"Special Page"), array("link"=&gt;"#", "text"=&gt;"About Me"), array("link"=&gt;"#", "text"=&gt;"Contact Me"), ); } $html = "&lt;ul&gt;" foreach ($links as $link) { $html .='&lt;li&gt;&lt;a href="'.$link['link'].'"&gt;'.$link['text'].'&lt;/a&gt;&lt;/li&gt;'; } $html .= "&lt;/ul&gt;"; return $html; } echo print_things(); Probably more then you need but eh.
Hmm, Hardly mentioned anywhere else, including the [execute](http://www.php.net/manual/en/pdostatement.execute.php) page. I've personally never used bindParam either...
I see, I just feel for a forum, email is a must, but then again it can def be used without.
I think he is fine
Thank you so much!
Have you tried http://www.php.net/manual/en/book.curl.php
nonononononono Dont. Echo. HTML. Rule one of proper design. Keep your HTML (views) and your PHP code (controllers/models) seperate! The above poster almost has it right, though. You do infact keep your menuitems in an array and build the menu from that: Somewhere in a config file or a controller: &lt;?php $menuItems = array( array( 'url' =&gt; '#home', 'name' =&gt; 'Homepage' ), array( 'url' =&gt; '#help', 'name' =&gt; 'Help' ), array( 'url' =&gt; '#about', 'name' =&gt; 'About us' ) ); You then pass $menuItems to the menu page, and use it there to build the menu. This way you don't mix your application's logic (getting the menu items, doing stuff with them, doing some other logic for that page, ...) with the application's presentation (html/css). &lt;div class="menu"&gt; &lt;ul&gt; &lt;?php foreach($menuItems as $menuItem) { ?&gt; &lt;li&gt;&lt;a href="&lt;?= $menuItem['url'] ?&gt;"&gt;&lt;?= $menuItem['name'] ?&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;/div&gt; There are 2 seperate files.
Also look into Yii2 it's another excellent framework with more momentum behind it than laravel.
I think as long as you have something simple it should work OK. For example, the latest bug I met was an association to a class hierarchy, i.e. a House has several Animals (collection) which can be Cat or Dog (sub-classes) -&gt; doesn't work. This is not too weird, but yet not the simple use case. Another example of something really frustrating: camel case gets converted to snake case (`userName` -&gt; `user_name`) and there's no option to prevent that. You would have to rewrite every property of all your object to fix that. That issue has been opened and requested for a long time, but there is still no fix.
In general I wouldn't recommend starting with a framework. It's good to understand the raw language first.
there is definitely a lack of good laravel tutorials out there, so keep going! i bet there will be a lot of viewers in the long run coming from the search engines.
That link was very enlightening, thanks!
This looks pretty good, But please, just buy a simply dekstop mic, would help so much on the voice in this series, unless you already recorded it. Quality is fine, nice and sharp. :)
I took it with a grain of salt that since he was asking how to output html he isnt using a MVC framework and doesnt know much OOP programming so considering is and the fake that he is using wordpress, him actually getting your example to work would probably cause him to ask 10 more questions, asking how to fit a MVC logic into wordpress, which would just involve him making the array anyways and just passing the foreach loop all in the same file, case wordpress, so he will prob just put it into a theme index.php file or header file. so yeah. also if you want to technical you example is using the wrong syntax. &lt;div class="menu"&gt; &lt;ul&gt; &lt;?php foreach($menuItems as $menuItem): ?&gt; &lt;li&gt;&lt;a href="&lt;?= $menuItem['url'] ?&gt;"&gt;&lt;?= $menuItem['name'] ?&gt;&lt;/a&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;/div&gt; if you want to do it that way you should use the alternate syntax for looping structures.
All you really had to say was "WordPress." 
If you do decide to rebuild the application using a framework ([Silex](http://silex.sensiolabs.org) and [Laravel](http://laravel.com) are my goto's) then there will most likely be a file upload implementation you can work with, which will appear in the docs of whatever framework you decide to use. If you want to just build ontop of your existing application, then I'd build an image class to do the processing. On the upload, you'll need to normalise the filenames before writing to disc (id assume you're doing this, or storing on S3?) and potentially using something like [Imagemagick](http://www.imagemagick.org/) to limit the size if quality isn't a requirement. Then it's just a case of storing the filename in the db with a user id, and doing a where call in the DB to get each users images for the gallery. Whichever way you do decide to go, it may be advisable, even if it's just a side project, that you do try and redevelop the application using a Framework. The initial time taken will be quite large, but once you get to use controllers and views in the correct way, the amount of code you use will decrease, and you'll end up with a much more organised application, and best of all, you'll hopefully learn something new, which is always a good outcome. EDIT: Just remembered about [Imagine](https://imagine.readthedocs.org/en/latest/)! If you aren't using a framework, use this. It's installable via composer!
Hey, I am currently working on a solution to implement location radius based search. You mind sharing your solution?
Thanks for your reply! Cool, I did not know Imagine. I did not use a framework at first because I started learning PHP not too long ago so I thought it would be good to understand the basics before using "premade" classes. Also thinking I'd be overhelmed by all the library knowing I would use a small amount of them. Now I do think about re-doing it with a framework in the future... just not sure when as I feel like I would stop this developpement in the middle to start from scratch again...? I have seen Laravel recommended a lot, but what about Symfony? Thought it was the most used framework? Thanks again!
Sounds interesting to me too!
Using a framework doesn't lessen learning the language itself. You are still building in the constructs provided by the language. You simply don't need to worry about lower-level things that will probably trip you up the first time through. imo it is better beginners use a decent framework. Think of it like training wheels. You don't need to know how to build a router, just understand its purpose and move on. Then later once you understand the language well you can try your hand at building your own.
Old Snowflake here is a dedicated troller of mine. I could say "the sky is blue" and he'd argue the shade and tone.
You should always keep logic out of the view the best you can. I'd let a loop slide, but no logic. 
Sorry to break it to you, but this is a bad implementation of a model in CI for the following reasons: a) You should never catch get or post variables in a model, you controller should catch and validate them and pass them to your model. i.e. this method: function update_data() { $name=$this-&gt;input-&gt;post('name'); $id=$this-&gt;uri-&gt;segment(3); $array = array('name' =&gt; $name); $this-&gt;db-&gt;update('users', $array); } Should be something like: /** * method to select data from user's table * * @param Integer $id ID of a user to update * @param String $name name to update * @return array */ function update_data($id, $name) { $update_data = array( 'name' =&gt; $name ); $this-&gt;db-&gt;where('id', $id); // you forgot to put the where clause in your update statement $this-&gt;db-&gt;limit(1); //assuming that because you are updating by Primary key, you will only update one row $this-&gt;db-&gt;update('users, $update_data); //return rows affected for example's sake return $this-&gt;db-&gt;affected_rows(); } b) Your select method has a pointless foreach loop (from what I can see) function select_data() { $this-&gt;db-&gt;select('*'); $this-&gt;db-&gt;from('users'); $q = $this-&gt;db-&gt;get(); foreach($q-&gt;result_array() as $row) { $users[] = $row; } return $users; } It might perform better if it worked without the foreach like: /** * method to select data from user's table * * @return array */ function select_data() { $fieldNames = array('id','name'); return $this-&gt;db -&gt;select($fieldsNames) // it is bad pactise to use Select *, so i put the field names in an array -&gt;from('users') -&gt;get()-&gt;result_array(); } c) I personally think it is neater instead of using the string 'user' when using select('id')-&gt;from('users'), I would put a constant in the class so that you can use select('id')-&gt;from(self::TABLE_NAME). This would also allow you to easily extend this class for another table that has a similar structure. d) I disagree with returning $this-&gt;db-&gt;result_array(); (dispite using it in the example above!). Instead I would use $this-&gt;db-&gt;result($className); where $className is the name of a loaded class that will work as an entity. CodeIgniter does support this. I hope this helps :-)
Does this help? Not OP but have done this before and remember the googling of it. http://blog.voltampmedia.com/2011/12/17/php-implementation-of-haversine-computation/
Models should store business logic, not capture input. Fully agree with irvingswiftj.
I guess that suggests that there's an ideal size of project for your learning, based on what size/kind of team you work in?
1) Nope it simply doesn't work https://github.com/schmittjoh/serializer/pull/238 2) Yes now that you mention it I remember using that kind of solution in a project. But it's really stupid IMO that to get a default behavior we have to override part of the library.
It's empty.
No, thanks. I'll look into it.
I don't know about .htaccess but you could perhaps enforce password-based authentication on your (I assume) local SMTP server. You would have to configure the CMSes to supply this username and password but in the end it would be impossible for a script to do &lt;?php mail('everyone@everywhere.com','One weird trick','&lt;a href="http://spam.com"&gt;Click here&lt;/a&gt;');
You should be able to use Imagine to at least get the image/gallery concept of your application complete, which is what you want for now. As I don't know on the details of the project (timescales etc) I can't really say whether the rewrite would be beneficial before you finish, however from what I gather I'd say finish your project anyway you can, and then go back and redo it. I learned to code in the same way, so I fully admire the way you've went about the project, and you will no doubt have learned a lot. The main reason for using Frameworks and such really, is that is stops, as you mentioned, re-inventing the wheel and all of that stuff. Also, security benefits are also a bit part of using a framework, as you're benefiting from everyone elses experience. Symfony now, is really just a lot of components which you can pull into your project to meet different needs, such as one for Security, one for the command line, etc etc. Some frameworks like Silex, use Symfony under the hood, essentially doing the work of stitching some of the components together for you, as that can be quite time consuming doing it yourself. Now, other people may disagree on this, but I wouldn't use Laravel until you have more experience. Although that sounds like a weird point, as I really do like using Laravel, the issue is the learning curve. There's a lot you need to know, and if you want to know how something works you need to dig through so much code, plus you'll be doing some functions without actually knowing how they work. Although there isn't a problem you then get box yourself into only being able to build projects in X framework, which can be a problem (This was happening to me with Drupal in my first job) if you want to freelance or anything like that. To get back to the point, I'd advise you potentially work on V2 of the app using Silex. Now, on the base level, you can use Silex purely for its routing, which if you look at the docs is really easy, then, you can essentially add the code from your existing project into the routes. After you've got it working again, try using Twig, which should mean you can remove some of your code with that, and so on. If you want to have controllers for your features you can. When I work with Sliex, I always extend the core components within my own namespace to give me more control of the project. I've always been a big fan of Silex for its ease, and the fact you can use as little or as much of it as you like. I hope this makes sense, but if you have any questions, feel free to ask
You could use a compression stream wrapper like so: &lt;?php readfile('php://filter/zlib.inflate/resource=http://example.org/my_gzip_file.gz'); See [stream wrappers](http://www.php.net/manual/en/wrappers.php.php) and [compression filters](http://www.php.net/manual/en/filters.compression.php) for more information.
it might be a good way to learn how not to php. but writing a cmd from scratch with hardly any php experience is a worse option. 
Echoing what everyone else has said... Learning and actual work balance themselves. When I encounter problems or challenges in my actual work, I learn how to fix them and prevent them in the future. Once you get past a certain point in your programming career, books, tutorials, and articles about your chosen language rarely have wisdom to impart beyond what you already know. Past that point, the most useful knowledge is gained when you encounter a problem that you can't solve by googling or asking a coworker. When you find those problems, you have to dig and understand all the parts involved, and you often have to find or build your own solution.
 if (get_permalink() == "http://myurl.com/thispagethatiwant") { echo 'hi'; }
You will take some concept that is new to you and incorporate it at a superficial level in an existing application. For example, if you are using Laravel and you are new to dependency injection, you should go through the process of figuring out the bindings and resolving your objects out of the container. You may want to write some tests simulating a mocked login user or something along those lines. I personally have a problem with having someone paying me to learn or improve a software development skill, i.e. if I spec I want to use phpspec for everything I wouldn't even consider charging a client to pay me to learn it.. but if you are happy to eat the hours as a growing pain and being able to say "Hey I used PHPSpec and here's what I did with the project, caught this many bugs etc, at no additional charge to the client" then I would consider that time well spent. That said testing always pays off in the short term.. and especially in the long term.. ESPECIALLY for an internal app you are maintaining until it or parts of it are rewritten. You can also go overboard given scope budget etc. with some of the stuff out there if you want to live in the reality distortion field of facebook/google and even laracasts to a smaller extent and the way they develop software vs how others do it. Pain / Gain / Readability = $value . 
&gt; ine for a one-off app, and as you say, it's quick to develop, but good luck using it for a long term, big project. This is not true at all. I don't even know how you came to this conclusion. What matters is how you write your own code. I'm in the middle of a MASSIVE matrix multi-tenancy Laravel project and Laravel has not once gotten in my way. If I have shit code, it's because I wrote shit code, not because it's built in Laravel. &gt; It's glorious. But only if you understand what is going on. Funny, I said something similar about Joomla to one of my colleagues. "Im sure Joomla is great if you understand what's going on". But because understanding what's going on in Joomla is like pulling teeth, it's not very fun software to develop for. It's kind of a pain in the ass in fact. &gt; or PHP code (as you call it, through the API) That's not as I call it. I don't do much, if any, configuration in Laravel. I just write code. That's the point. I don't HAVE to configure a bunch of stuff (nor do I have learn a crazy set of conventions) because I have a flexible, clean, robust, and intuitive API available to me.
I have always a dummy project where I try and investigate new techs, tips &amp; ticks. Sometimes these techs are deployed on production projects. Before to use dbdeploy, phing, phalcon, etc... on production projects, I test it before on dummy projects :) I work with my dummy project out of office between 1 and 4 days per week.
:) Yes, read the Note: you can return an Exception object without throw it. 
Thanks. I see from your original post that you put the logic in the controller and send it to the view. However, I don't know what the code is to actually do that, making the example a little confusing. I want to use best practices and "Dont. Echo. HTML." but the MVC approach seems incomplete, whereas the echo HTML "just works". This is probably why there's so much bad PHP out there. Getting it to work trumps best practices when you're learning. Hope I don't come off as snide or anything, just want to understand the right way to do things.
How is it more powerful than writing your own code in a framework that DOESN'T try to over-configure everything?
Guessing you're using WordPress? the_title() doesn't return anything, it just echoes the current post's title. Change your call to get_the_title() and it should save correctly.
Thanks for the very good information! I know we can trust what you say is highly accurate, however, I'm having a hard time applying the info you give with OP's question... &gt; [...] if the vast majority of your code is compatible with the highest level of optimization then it makes more sense to blacklist a single file or files, than turn optimizations down for a whole application. How can we tell if our code is compatible with the highest optimization level? If I somehow learned that it wasn't compatible, how would I go about finding which file(s) I should blacklist?
As far as I understand it, OpCache doesn't cache the output, it just caches the opcodes that generate the output. In other words, if you have a script that returns the current time, enabling OpCache shouldn't affect the returned value. I could very well be wrong on that, but I've been using the OpCache for a few years now and haven't noticed any actual output being cached.
Thank you for your answer, very interesting, but I yet fail to see why would anybody NOT want their file to be optimized by opcache. A guy mentioned that he had a file that outputted date dependent javascript, but I don't understand why it doesn't work with opcache enabled. I would think that opcache takes in consideration that sometimes the output of a file depends on the time it's called. He does mention he was using APC though
One thing I try to do as a programmer is never be afraid to throw away code you've written if the benefits are good. In fact, it's usually a form of the [Sunk Cost Fallacy](http://en.wikipedia.org/wiki/Sunk_cost_fallacy). But I don't think it's too late.
thanks that worked!
thanks, but it was a wordpress issue. i had to use get_the_title
Seconded. [Check this page out, regarding the_title](http://codex.wordpress.org/Function_Reference/the_title). Also, [this page regarding get_the_title](http://codex.wordpress.org/Function_Reference/get_the_title). Note the difference in usage: &lt;?php the_title(); // echoes the title ?&gt; &lt;?php $title = get_the_title(); echo $title; // echoes the title ?&gt;
Postgresql has some handy [extensions](http://johanndutoit.net/2013/01/07/searching-in-a-radius-using-postgres.html) for doing that.
Well, it only worked because of this stupid apache trick: AddType application/x-httpd-php .js &lt;?php header("content-type" "text/javascript"); echo '&lt;script type="text/javascript"&gt;'; // ..... some code echo 'var date = ' . date() ';'; // ... some more code echo '&lt;/script&gt;'; ?&gt; The date never changed because it was cached. It was old code... I didn't come up with the black magic. 
I run two startups. What I do is that there are a few days after every week or so when I'm just doing sales or content marketing, which allows me to slip in time to learn a new language/framework. The best way to learn being to think of a very simple but fun idea in said language/framework. Once you "start", it pretty much snowballs as you start exploring the new thing and within a few weeks you're quite proficient as you add new features and tweaks
Also make the .htaccess file read-only so it won't get blown away or neutralized by the attacker (assuming they only have write access to the dir via some upload script vulnerability...if they have shell access, you're SOL). Or better, set that php_flag in a &lt;location&gt; tag in your apache vhost config so they can't override it, if you have that level of access.
Why not just do this rather than using the reference? $myArray = array(1, 2, 3); foreach($myArray as $key =&gt; $value) { $myArray[$key] = $value + 1; }
You're joking, right? This tutorial is the how-to on the worst practices ever.
We have just post basic guestbook, how its work. So what was issue in it. If you let us we will correct from our end.
It's just guestbook example for the beginners, now guestbook has been in feedback form.
Please delete this whole mess. You generally do nothing the right way and should learn before you try to teach others.
Can you please correct me, which part i need to correct my side
Its a tough balance. Its interesting how some folks learn new stuff and then include it in production, then learn some other new stuff and include it in production. Cannot image what it is like to maintain all their newly learnt code and bits and pieces of different frameworks/tools etc. Typically theres lots of opportunity in companies with fragmented bits and pieces of technology. For me, I spend on average about 10-12 hours additional time per week learning new stuff, sometimes via google articles, sometimes reading the latest books using Safari Books online, sometimes just reading Reddit articles and blogs seeing how the cool kids are doing things. I only bill 30 to 40 hours per week so this gives me time to dedicate to learning new stuff, and creating simple learning projects (or just doing the admin stuff that comes with running a company). 
Good point.
Urgh, if you want to teach people how to code, at least try and teach them what decent code [looks like](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md).
Get a new calendar, for starters.
hi Alpinecoder thanks for the response, i have already mentioned its for the beginner. So need to understand the basic level. How its works. Anyway we will take your suggestion.
Most of my projects I work on alone or sometimes with one other person (aside from a project manager). So I have a lot more flexibility in if I want to do the same old stuff or try something new. I think that small projects (pamphlet sites for instance) don't offer much room for enhancement of your skills, but a standard size site could give you that opportunity to do at least one thing outside your comfort zone. I suppose I am suggesting that there is a minimum size project that is more suited to learning. Even if working in a large team, you are responsible for your part and you have a little leeway enhance your bit of the project. 
You're passing a list of dom nodes to `query`, when `query` takes a single dom node.
&gt;Forget about Wordpress if you want to learn PHP, the code is horrific It is horrific, but the guy wants to be a freelancer, and wordpress work is ~40% of freelance jobs.
I know but why is the $tables-&gt;length giving me a zero?
&gt; PS: From what I heard it's pretty easy to write php as procedural but it's hard to be pro and use it as OOP and for that you have to use frameworks. (no idea if this is true) No this isn't true. The OOP syntax is no more complex than Java's (simpler, in a lot of ways). The hard part is the same thing that's hard about Java: doing it cleanly with good architecture. It's easy to write sloppy OOP code in any language, it's hard to write it WELL.
ahh that's what it's called!
Java 8 has lambdas now.
Thanks, looks great!
Yes, you mentioned it's for a beginner, but why does that mean you shouldn't teach them the right way to write code? Seems to me like that makes it even more important to make sure the code you're presenting is written in a clean, logical and modern fashion. There's no point in teaching someone how to write code as it was written 15 years ago, and if you don't know how to write code in a more modern way, then you shouldn't be attempting to teach others (IMHO). 
Thank you for taking the time to write this!!! You have convinced me, I spent the afternoon looking at Laravel and realized a lot of stuff that I use were done better! I will now stop development on my homemade app and restart and Laravel and continue from there. (shouldn't be too long now that I kind of know what I want plus have a great tutorial to start the registration and users part again with Lara). I understood the underlying principles of a framework (at least the basics) by doing my own classes and everything so now I am feeling better to go with it. BIG plus, it will force me to use MVC which I did not so far and when I will need to swap between languages it will be great! The app will need more tools like calendar management &amp; co..so I am not done yet....this is a side project aside from work and I have set my deadline for end of this month for the "basic" functions and an alpha version...styling not really included...I will do my best to stick to the deadline but being a sideproject it's hard to be 100% on it! Will have more questions coming for sure :P
[Here's a good visualization](http://blog.codinghorror.com/a-visual-explanation-of-sql-joins/) to help understand joins. Basically, what you're doing is searching the `skills_matches` table (I'd personally rename it `user_skills` since that makes more sense) for the skill id and returning the associated skill and user data. SELECT sm.*, skills.*, users.* FROM `skills_matches` sm LEFT JOIN `skills` ON skills.id = sm.skillid LEFT JOIN `users` ON users.id = sm.userid WHERE sm.skillid = ?; I doubt the above will work as-is due to ambiguous naming of results, but it should help explain the concept a bit. You're selecting from the `skills_matches` table based on `skillid` and then joining the skills table to that result using the `skillid` from the `skills_matches` table and `id` from the `skills` table. Then you do a similar joining for the user information and the `users` table and `userid`. Good luck with your work and I hope this helps some.
I'd point out in your query the `*` is slightly ambiguous, since it will return all columns from both tables. So you'd probably want to do `users.*` or explicitly select `user.column1, user.column2`.
Yeah, I mentioned that. I don't know what fields he wants to use though, so * it is.
I see, Thanks!
Indeed, that's why I want to go into Wordpress too.
ok, thanks. I think I will pick Laravel for the moment to see how it is. Plus it's the only one I heard of :). 
 if( $_SERVER['REQUEST_URI'] == '/path/to.file' ){ // show the html }
Take a look at http://www.phptherightway.com/ to get up to speed on the latest development practices and tools we use in the PHP world. Also I recommend the IDE [PhpStorm](http://www.jetbrains.com/phpstorm/) or Netbeans, and use [Vagrant](http://www.vagrantup.com/) for your VM environment (no sense in cluttering your local machine with server tools). Edit: One more thing, if you're looking for a great templating engine try out [Twig](http://twig.sensiolabs.org/).
Ok, thanks! I'll check that out and Vagrant seems interesting. 
Okay, press Ctrl + A, or Cmd + A if you are on a mac and then hit Del. Then go read a few tutorials about basic security, database connectivity and UI and UX. Then try writing a beginners tutorial again.
Because you've found zero td elements relative to the `$tables` element returned from your previous query.
As far as i can tell it's from a beginner and for nobody.
The $tables-&gt;length is for the table query not the the td query
WordPress for Dummies is probably beneath you since you are already a developer, but Professional WordPress is probably a good place for your to start if you are looking for a book to read. http://webdevstudios.com/wordpress/books/ For other resources: the WordPress codex for function references/etc, checkout the IRC channels to find developers to bug, you can read wptavern.com and poststat.us for community info, http://pippinsplugins.com/ has a lot of series on plugin development. Also look for the "handbooks" on the Codex for the areas you are interested in.
I agree with that sentiment, but I do wish you'd chosen a better example.
Oh shoot I almost forgot the most important tool, [Packagist](https://packagist.org/)/[Composer](https://getcomposer.org/doc/00-intro.md) for dependency management and autoloading.
http://theunraveler.com/blog/2012/php-annotations-are-a-horrible-idea/
Check out symfony 2. Especially if you like oop. Http://symfony.com
callItAHunchButIThinkYouWillBeGladYouMadeTheSwitch.
For someone who doesn't know PHP, jumping into Symfony would be very difficult
Thank you this worked out perfectly, just edited the select to only return the information I need. How would I now go about storing the results into an array an echoing them? 
&gt; Using a framework doesn't lessen learning the language itself. Do you define _beginner_ as someone new to PHP, or to programming in general? Sure you'll learn the syntax, you'll learn what seperation of concerns means etc., but will you learn _why_ things are like that? &gt; You are still building in the constructs provided by the language. It's literally learning to use a framework. You'll be working within the frames of that framework, making pieces for it. Sure you'll get to know the syntax for creating classes, what objects are (sort of), but for a complete beginner, it might be hard to translate this experience to something _outside_ of that framework. &gt; You simply don't need to worry about lower-level things that will probably trip you up the first time through. Personally I like the "learn it the hard way" approach. Something now working like you thought it would? Check the manual! Is it still not working? Check StackOverflow! etc. You not only learn about some quirks with the language, but how to find information/answers as well. This is something we all do, all the time, might as well start early. &gt; You don't need to know how to build a router, just understand its purpose and move on. Yeah I agree with this, but maybe it would be better to start out simple and take it from there? Starting out with a seperate file for each page: it's ugly, likely very messy, and really just a pain. But say you did that: you now have an understanding of how http://example.com/about.php and http://example.com/contact.php are two different "pages". So now say you want to create dynamic content: this is what PHP is all about, is it not? You'll start learning something like MySQL, great! Getting down and dirty with pure SQL is something you should be able to do, so abstracting it away behind an ORM seems counterproductive to me. Now you move on to something like a login system: something you very quickly encounter a need for. You look it up on StackOverflow, and they talk about sessions and cookies, but what're those? Well you look that up in the manual (see how learning to do this early is great?), and after fiddling around with it, you realize you'll need a `session_start()` on every single page, and you notice that you did that with your database connections as well: it's a pattern! But it's not simply a pattern, it's repetition, it's more work. I don't know if it's a cliche, but I feel like the "programmers are lazy by nature" thing is great, it echoes ["don't repeat yourself"](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself) and ["keep it simple, stupid"](https://en.wikipedia.org/wiki/KISS_principle#In_software_development) which is pretty essential. But as I said: you notice a pattern, a pattern you don't want, what do you do? You try to fix it. You end up learning about `include`, and create some kind of `init.php` file which you include on all of your pages. You now have a single place of instantiating your database connection, starting your session, all that stuff. Awesome! Well, now you notice another pattern: you include this file on all of your seperate pages. It's not that big of a deal, but hey, we're lazy, right? So you now know what `include` is and realize that it can help you out in this situation, somehow. So you likely know what your "index" page is already and if not: you search around (the internet is lovely). You create an `index.php` which includes your `init.php` and then evaluates which page the user wants to access via. a `GET` parameter. It's essentially a giant switch statement now, it's still a little messy, it's still more work than really needed. So you start thinking about a dynamic way of including the pages, essentially making `?page=$PAGE` include `$PAGE.php` (or maybe an array of `$PAGE =&gt; $file`, something like that). You now have a front controller! Your new system however, comes at a cost: the ugly URL. You've noticed other websites use stuff like http://example.com/contact, and you decide you _want that_, so what do you do? You look it up! You end up fiddling with something like `.htaccess` (as most beginners will likely use Apache), and you achieve those lovely URLs, everything is great! With time, you'll be learning all kinds of stuff, and eventually run into the concept of a "router". You recognize what it does, and you decide you want that: _what do you do?_ Sorry that went on for way longer than I thought, but do you see the progression here? You now have someone who not only knows the syntax of the language, but also how to use SQL, sessions, cookies, and mod_rewrite. But most importantly: you now have a developer who's constantly learning, constantly expanding. They didn't start out with a frame, they just had the canvas, and now they're slowly moving towards the edge, where the frame would usually be located, and then even further, if they want to. Just as a sidenote: I personally prefer Symfony2.
I was a Java developer over 10 years ago. Now when it comes to quick web apps, I use PHP. I would and could go back to Java if the need arose. A LAMP server is easier and less expensive to spin up than a JBoss, Websphere or Weblogic server any day. I was building java web apps before Spring and Hibernate came into play. We used a Data Access Object pattern and it worked well back then. It was fast but required a good amount of code. I use the same pattern with PHP. Sure, it may be more work, but there's less to maintain in the long run. IMHO frameworks are more susceptible to exploit because the code is out there for deep analysis. I feel safer rolling my own. That said, take the patterns you know from Java and apply them to PHP where you can. While concepts like injection might not be an obvious option, a lot of the OOP principles are there. If you you need a framework, go for it. But you didn't need one when you first started writing Java code. Disclaimer: Not trying to start a war here, it's just my opinion. Maybe I'm just old and stupid
Which you're then passing to the second query. But that's irrelevant, because `$tables` is a DOMNodeList.
Sometimes trying to optimise code breaks stuff. https://bugs.php.net/bug.php?id=65845 - the optimizer breaks the code. https://bugs.php.net/bug.php?id=67481 - opcache has been confused about which file is which. Being able to just exclude a file is much better than having to disable the whole of opcache.
Not if you're coming from a java background
I think you will get better results if you actually explain how your pages are laid out instead of asking people to guess at possible situations, can you better explain your situation
Good luck working in a team with that attitude.
&gt; IMHO frameworks are more susceptible to exploit because the code is out there for deep analysis. I feel safer rolling my own. I'm baffled... i'd actually advice precisely the opposite; prefer (carefully chosen) vendor code over that which you roll yourself! It'll be better tested, more thoroughly debugged &amp; battle-hardened by constant use by many other devs. Also, from a business perspective, the cheapest code is the code that you don't write! Projects like Symfony2, Zend2 (etc) have effectively decades of effort put into them - it is extreme hubris to assume that you can build more robust components without investing a similar amount of time. I actually agree with the rest - and would recommend Symfony2 with Doctrine as a good fit for a developer experienced with Java.
 laracasts.com is worth checking out. 
Hooray, phptherightway is finally a valid answer to something! (All too often it gets recommended to newbie programmers.)
Parts of WP are object-oriented, notably, the main database abastraction class: http://codex.wordpress.org/Class_Reference/WP_Query It's slowly being modernized, but the dev team's philosophy is 100% compatibility. I.E. the burden should be on the developer instead of the end user (client / admin user).
Agreed. It took me forever to realize that the annotations were the actual Exar code.
Java application about e-learning? Do you work at Trivantis, by chance?
Dunno if it would be useful for you, but this helped myself a bit. It was things that i "knew", but as i never rly faced some of the problems, i didn't really learned them. http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html I use laravel, not symfony, but the article is very broad/basic.
They already did this and it's called [Oracle Apex](http://en.wikipedia.org/wiki/Oracle_Application_Express). Funny enough, it was originally just called HTML DB. They seriously wanted me to use it at my job.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Oracle Application Express**](https://en.wikipedia.org/wiki/Oracle%20Application%20Express): [](#sfw) --- &gt;__Oracle Application Express__ (Oracle APEX, previously named Oracle HTML DB) is a [software](https://en.wikipedia.org/wiki/Software) [development environment](https://en.wikipedia.org/wiki/Integrated_development_environment) running inside the Oracle database. Oracle Application Express is free of charge and can be run inside Oracle Database Express Edition (also free product). During installation of Oracle Database Express Edition, Oracle APEX is installed by default, however Oracle APEX can be installed in any other Oracle Database Editions for free. If Oracle APEX is running inside Oracle Database Express Edition the functionality is limited by limitation of Oracle Database Express Edition ( - e.g. CPU limit or memory limit). &gt; --- ^Interesting: [^Oracle ^Database](https://en.wikipedia.org/wiki/Oracle_Database) ^| [^Oracle ^Corporation](https://en.wikipedia.org/wiki/Oracle_Corporation) ^| [^Oracle ^Forms](https://en.wikipedia.org/wiki/Oracle_Forms) ^| [^SQL*Plus](https://en.wikipedia.org/wiki/SQL*Plus) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cio1vpe) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cio1vpe)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
OTOH, while rolling his own code is likely to have many more problematic security holes, the *value* of somebody exploiting those security holes is dramatically reduced. If you can leverage an exploit in Wordpress/Drupal/Rails/Django, then you've got a *lot* of servers to target. Assuming that he's defended against the truly common attack vectors (sql injection/CSRF/XSS), then he might be 'safer' by obscurity. It certainly doesn't help if he's the victim of a targeted attack, but it definitely changes his attack surface and vulnerability profile. Finally, lets not kid ourselves into thinking that the number of people using a codebase, or even the number of developers working on a codebase = better security. The only thing that really matters is how many security conscious, security savvy people you have looking at the code trying to break it in nefarious ways to harden it. Look no further than the heartbleed bug for an example. It wasn't until you had some dedicated experts seeking an exploit that the bug was found.
Kind of a side question - can you explain a bit why a templating system is better than just doing it in php in the first place? I have used Smarty in a few apps, for the sole reason of allowing non coders the ability to generate templates - for a CMS. It did not work out well at all as Smarty is not simple enough for them. I would imaging for something only developers touch, there must be some other reason for a templating engine vs sticking to MVC pattern with minimal or no logic at all in the view other than echoing..
This is a big question that can quickly turn into a flame war, but I'll try give you a quick explanation. As I see it, there are two camps in the PHP world—those who prefer native PHP templates and those who prefer compiled template languages. Compiled templates languages offer a completely new syntax (it's not PHP) that has been geared specifically to templating. From escaping, to inheritance, to simplified control structures, it's all designed to make templates better. PHP certainly works for templating, in fact that's more or less how it started. However, it's grown into something much more than this, and what we have today is a much more mature, object oriented language. And while templating hasn't necessarily become worse in PHP, it hasn't improved much either. And, as developers start enjoying the benefits of compiled template languages, the limitations of PHP in this area become a little more apparent. Nonetheless, many developers still prefer PHP for templating. It's what they know, and they're fast at it. No compiling or caching to deal with, and no learning a new syntax. And that's really why I created Plates. I wanted to give developers who preferred PHP templates some of the features being offered in compiled templates. Hope that explains it!
"Finally, lets not kid ourselves into thinking that the number of people using a codebase, or even the number of developers working on a codebase = better security." Rails, with thousands of people looking at it, still has exploitable bugs. More precisely, there's bugs being found in helper libraries (yaml parsers, etc) that someone writing their own code very likely would't be building for themselves in the first place. Frameworks provide a lot of good, but also often provide a larger attack surface that simply wouldn't be there in a home-grown by-hand set of code. From a pure security standpoint, it's not as cut-and-dried as people like to make it seem. The Zend2 example - well... if they really cared about security as much as people claim framework authors do, they'd ship working modules with demonstrated 'best practices' examples of common security use-cases - user registration, login, lost password reset, etc. You're left to your own devices to try to figure out how to do something that is pretty fundamental to the secure operation of any site (and which is a pretty common scenario for most web apps). We don't get usable, battle-tested, documented code for user registration, but hey, here's some encryption and hashing libraries - go build something yourself. This is but one contributing factor as to why Wordpress will continue to dominate the development landscape in PHP for a long time to come.
Honestly - I think the big advantage to Plates (and I have used your ideas in my mini template engine - so kudos for your fine work here) is it's **NOT** compiled into another set of PHP template files from a side-language. It's one overhead I like to avoid and would rather stick to "pure PHP" templates like you do. How I tackled this (and it's really only a saving of a few keystrokes) I proxy my template methods like $this-&gt;escape()/$this-&gt;section() into closures just before I require() the template file/partial in question. $e = function($text) { return $this-&gt;myPrivateEscMethod($text); }; $partial = function($args) { return $this-&gt;myPrivatePartialMethod($args); }; require($pathToATemplateOrPartial); Then it's just &lt;?= $e($value); ?&gt; in a template - but it's all really just yak shaving of bytes.
Well since those variables are inside a private method - they don't go global, so no conflict. Downside being the pull up/tear down (Garbage collection) of these closures on each template/partial include - but I doubt this is a major overhead/CPU burn.
Understood, they're inside the template object's private render method, but if you expand your template variables so that they're also in the local scope, they could theoretically conflict, no? &lt;a href="&lt;?=$link?&gt;"&gt;Link&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;?=$link('home')?&gt;&lt;/li&gt; &lt;/ul&gt;
&gt; For example, in order to use PHP templates for a controller action with Symfony, one must declare that the returned value should be rendered with a template in the following way: Please, PLEASE tell me that this is not true. Please tell me that all of the people who rave about Symfony are not this bat shit insane. This gives PHP a worse reputation than Wordpress.
&gt; Disclaimer: Not trying to start a war here, it's just my opinion. 
Formatting, use of better practices, 1. You are using outdated methods to teach users. MySqli isn't being thrown under the bus, and its good thing you used it. But try using things like binding paramters and other more secure functions built into PHP that will save you from the simplest forms of SQL attacks. 2. Formatting and code readability is HUGE. If I was a beginner, I would look at this code and be overwhelmed. Where does the conditionals end, why is this here, is this apart of this, does this end here? If seasoned people don't want to read it, a beginner will probably walk off. 3. The database is not built for a guest book. Check the types for these columns. Varchar shouldn't be used to hold things like a comment, INT should not be used for datetime and IP addresses. 4. You aren't catching points where a part of your code can fail, what does a user do if you failed inserting the comment into the DB? All you have done previously is validate types and do some trimming and real escape strings. In all honesty, this seems like a beginner level php and DB interaction. Its not on the level of "I'd rather go play out in the street", or necessarily bad, its great for a beginner. But you have to understand that as a coder attempting to teach someone how to build applications, in possible real life situations, this may be detrimental. Not everyone can necessarily teach others how to code, but don't let that deter you from trying. Keep building your own personal skills in coding and keep practicing.
I'm pretty sure the answer is no. Unless you can modify OriginalClass? Is that an option here? Also - are you saying you want to call Parent::Form(), then do your stuff - then call Parent::form() again??
"They must just be haterz, lol"
 thought the same. Seriously, the issue with Wordpress is **not** the UI. that's fine. Maybe a little cluttered, but not a big problem. It's simple, has all the options available. Not an issue. It's the backend that's a clusterfuck.
Can't modify OriginalClass. And I don't need to call it, and then do stuff again. I just need to append an item to an array in parent::form() and then have it run like normal. So maybe my order of process is wrong in the example.
TL;DR: The future of wordpress is the past. We'll update the admin interface so that it looks a bit more contemporary, but ignore the cesspit of a codebase because backward compatibility. I've been working more with wordpress recently and my views have changed slightly. There are a lot of people and a lot of cases where "getting some shit on the screen" is the most important (or more particularly only important) factor. Wordpress is good for that. But if you care about the "how", or have an interest in engineering and architecture, if you need to extend things and want a stable base, or if you just care about the means as well as the end - Wordpress is not an option.
&gt; Wordpress, so can you point me what are the best tutorials about Wordpress ? Wordpress is a clusterfuck of terrible code. If you're not from a PHP background it will honestly make you think PHP is bad. It's not, it's just that wordpress is the very worst of 2006 PHP. &gt; PS: From what I heard it's pretty easy to write php as procedural but it's hard to be pro and use it as OOP I'd argue that's the same as anything. Essentially you're saying "Basic stuff is easy, but harder stuff is hard". Well... yeah. Given that you have experience with Java I don't think you'll struggle like many new to PHP do. You might just find some things don't quite work as fully as you expect. &gt; and for that you have to use frameworks. (no idea if this is true) This is simply not true. OOP PHP is entirely possible with or without frameworks. Frameworks merely simplify and enhance common requirements and design decisions (CRUD, authentication, etc). I recommend using frameworks, by the way. Laravel might be one that serves you well. It has a good and pretty simple ORM built in called Eloquent.
The problem with spreading that opinion is that via the fallacy of confirmation bias you are providing others with justification for the idea that writing your own libraries and frameworks will result in applications that are more secure than those built using common open source projects which is patently false. You may be able to create a single library without any vulnerabilities but the likelihood of you creating a production application with less vulnerabilities than one built on tested and hardened open source code is slim to none. Why does it matter to me? Every day thousands of applications are exploited and added to a growing list of vectors for launching layer 7 DDoS attacks and it's irresponsible developers that aren't following industry standards and conventions making that possible. You may not be trying to start a war, but you've got a gun in your holster, try to be responsible when using it.
If you're looking for an ORM framework for PHP, Doctrine is pretty standard (I believe it's the default ORM layer for Symfony), and uses similar syntax to Hibernate. Their ORM framework is pretty good, but their "document" mapping solution for MongoDB (Doctrine ODM) was still a little buggy as of a few months ago.
Interesting stuff. Ty
You have a point and I agree. And I thought about playing with PHP first with no framework at all and this is what I'm going to do but I don't want to spend to much time like this. After I want to check some frameworks, pick one and learn it. Thanks for the information !
no :) 
zeroseoul thanks for the response, I hope you have not gone thru the code fully, INT data type i have mentined fo timestamp and for ip address also i have mentioned Beginner. For beginner level if you are going to put all the levels at one place he cann't able go through all the level so step by step. Anyway thanks for your comments.
Not sure i understand what they are saying, but i doubt it gives a worse reputation, if its true.
http://www.phptherightway.com/ http://symfony.com/doc/current/contributing/code/standards.html
hhmhhhmmm
lvl-1
lvl-2
level-1
You can parse the original file and extract the $var, even reapply changes made in the function or well.. just rewrite the function.
thanks
lvl-3
lvl-4
lvl-5
lvl-6
lvl-6 2
level-2
I think that's a really really bad idea. The thing with PHP templates is that it's PHP. The layer you want to introduce is **magic**, it's not just PHP anymore. That's so confusing. Why would `&lt;?=` behave differently than `&lt;?php echo`? How come calling non-existant methods work (your suggestion of forwarding `layout` to `$this-&gt;layout` for example)? How can the short tags work even though they are deprecated and probably disabled on the server? How could you explain all that to people that don't care about the details? Magic is always very bad, because you need to understand how the magic works to know how to use it. &gt; 100% native PHP templates Nope, this is PHP code, but it doesn't execute. It's not portable to another PHP templating engine. Plates wouldn't be a PHP templating engine anymore.
Bullshit. That's the best we've got for now and it works. It's being used everywhere with success.
Easiest transition: - Spring -&gt; Symfony - Hibernate -&gt; Doctrine There are some differences of course but you'll find what you are used to. You (probably) know how to write correct OO code, so with those frameworks/library it will be very familiar. Just remember to add the `$` at the beginning of the variables :p
Thanks for the advise! No will try to rush the basics of this app and later can see to make things better looking at other methods of coding. But I do love the fact that a lot of those classes are the same as what I defined on "my own" (with a tutorial) for the user authentication &amp; sign up part. Doesn't feel too magic yet just a lot better organized. Also the model / view is new to me so it is nice to see
Nice analysis, although I'm pretty sure most of these projects use PascalCase and not camelCase for class names and camelCase for method names.
I see more people say about Symfony because I come from Java Spring so I will definitely check that out. Thanks!
There are a ton of the scripts already written. You are trying to reinvent the wheel.
Can you please point me in some direction? I was unable to find any for my particular problem. :( Thank you!
:'( don't be sad!
&gt; I think that's a really really bad idea. The thing with PHP templates is that it's PHP. Good, someone with some strong opinions on this! I actually very much understand the arguments you raise. But, I am trying to solve a problem here, so let me fight back a little, if for nothing else thoroughness. &gt; The layer you want to introduce is magic, it's not just PHP anymore. That's so confusing. True, but magic isn't a boolean, rather a scale. Plates already uses "magic" a little, in that it uses objects to define Templates. Templating was certainly not the original intention when objects were added to PHP, but it works nicely, so we use it. &gt; Why would `&lt;?=` behave differently than `&lt;?php echo?` A few reasons. First, you need a way to output raw data still, so leaving `&lt;?php` untouched leaves developers the freedom to handle those variables however they want. Second, parsing `&lt;?php`, which could be multi-line blocks of code would probably be very difficult. Third, PHP actually sets itself up nicely for this with the short echo tag `&lt;?=`, which has the sole purpose of outputting content in a template. &gt; How come calling non-existant methods work (your suggestion of forwarding layout to $this-&gt;layout for example)? Simply trying to cleanup templates by removing `$this`. By removing it, they have the appearance of standard functions (totally valid PHP), but behind the scenes actually become object methods, and have all the benefits of being object methods. &gt; How can the short tags work even though they are deprecated and probably disabled on the server? Actually they're not deprecated, at least I see no sign of this on php.net. They are a legitimate option available to PHP developers (if they so choose to enable them). &gt; How could you explain all that to people that don't care about the details? Magic is always very bad, because you need to understand how the magic works to know how to use it. I find this a difficult question to answer. Most people don't understand all the behind-the-scenes details about how Plates works either. What they care about is that it works. If someone does care about these details, they can learn about them (via the documentation) and understand Plates' unique way of handling things. Otherwise, they can go about their business, and things will just work. &gt; Nope, this is PHP code, but it doesn't execute. It's not portable to another PHP templating engine. Plates wouldn't be a PHP templating engine anymore. I find this very interesting, and I think you're getting at an important issue. Should portability really be a goal with Plates? Because right now, it's certainly not. The second you use one of it's functions, ie. `$this-&gt;layout('template')`, that template just became a Plates template. Yes, it's PHP still, but you're not going to be able to drop it into another templating engine. I don't see that as a goal, because that would basically handcuff the project to the point of being useless. Rather, when a developer chooses to use a library, they understand that the code their writing has a certain attachment (dependency) to it. What's nice about Plates is that you're working with regular PHP, so the syntax is the same, and you can utilize all the functions and control structures you're already familiar with. The proposed compiled Plates templates will absolutely execute, if that's what you needed for some reason. But it would take a little effort—in the exact same way it would if you tried to execute regular Plates templates outside of Plates. So where is the line? What magic is acceptable, and what magic isn't? What dependencies are acceptable, and what aren't? I get that I'm pushing this line, but let's be honest about the liberties that we've already taken with our PHP templates.
Stop.
If it's just about the magnitude, you can make a log() function on the amount to get the magnitude. You'd then have to compare all the magnitudes you think are important and average those out. that should give you a value that should tell you how similar other shops are to the one you compared it with. just from the top of my head. That's probably how I'd approach it. For larger sets of shops, saving them in a database might be a good idea. 
What
SELECT *, SUM(Horse1, Horse2, Horse3, Horse4, Horse5, Horse6) AS HorseSum FROM Data WHERE TableID = 1 $record['HorseSum'];
A lot of effort on bug fixes... I often wonder about time to fix bugs due to shoddy foundation vs a complete rewrite with current php as a reference.
Almost certainly this would cause more bugs than it would fix.
Are you seriously suggesting to do a complete rewrite of anything in order to remove all bugs? Besides Release Candidates are explicitly meant for fixing bugs and nothing else. And third, I'm not sure if you noticed it, but the changelog in the link is for the whole 5.6, since Alpha 1.
TL;DR you can force PHP to segfault or dump memory with two lines: &lt;?php $PHP_SELF = 0xdeadbeef; phpinfo(INFO_VARIABLES);
 &lt;?php if (isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) === 'xmlhttprequest') { header("Content-Type: application/json"); echo json_encode($myArray); exit; } else { // do your html stuff }
Seems like a horrible idea and you will be alienating any potential users.
is that simple? Cool! I was fearing that something like that would output the xml/Json embedded in html code or something.
Better to check `$_SERVER['HTTP_ACCEPT']` and send the header `Accept: application/json` with your request. 
To clarify the impact of this: This is **not** a remotely-exploitable vulnerability. It requires that the attacker can already execute arbitrary PHP code. Nobody will be able to remotely steal your SSL key with this (but you can steal your own key if you like!)
https://packagist.org/search/?q=youtube
I can't download it. Anyone else struggling?
PHP in itself doesn't return any html, so if your code returns xml, that's what'll be returned.
One of the user fields Facebook's Graph API will provide you with is 'verified', which if I remember correctly is when a user connects a mobile number or credit card to their account. You could check against this field if you really want to be sure.
What about shared hosting environments? Would this allow the ability to steal all other customers SSLs on that server?
I'm afraid there's no real good answer to this; look carefully is all I got ... Using your usual debugging method should lead you to the anomoly, as it normaly would. This should give you a file most of the time, of course as the article suggests the symptoms may not be obvious, which is why have to be careful ... 
I have no idea how shared hosting typically works, but I would assume that PHP will usually be appropriately jailed.
&gt;I would mark it accordingly and the user would have to earn the Gold Star by getting positive feedback from other users. Here's my $0.02 on the functionality of it. You have to give an incentive for other users to give positive feedback, otherwise it will be a slow and arduous process, and one I personally wouldn't go through myself. I'll also throw it out there that I don't personally have a Facebook account. It's one thing to use Facebook as a sort of SSO system, but to require it for the use of your site is - for me at least - an instant "Nope". You also have to consider that a lot of people (myself included, even if I had a Facebook account) might not want their Facebook account tied to whatever service you offer, so the lack of an alternative signup option would be the first turn-off, and the heavy reliance upon the Facebook account would be another.
There is merit to this argument, however (anecdotally) i've not found this to be the case in reality. Good framework / library code will occasionally have security vulnerabilities - but these are rarely low-hanging fruit and instead be a consequence of the complexity of interaction between the many moving parts. In contrast the home-spun code i've worked on tends to have trivial XSS, SQL injection (etc) bugs all over the show - a bunch of stuff that doesn't have to be targetted (and infact can be automatically found).
After reading this thread yesterday on my phone, I was just coming here to suggest that it be capable of being turned on and off. I'm currently using Plates as a templating solution for a small project where using a framework and its templating engine (like Blade or Twig) would be major overkill and I really, really like it's simplicity and ease of use. I also like the idea of having the option to use compiled templates, but currently, for my project at least, it's not a necessity, and I would be concerned that the extra configuration required would be a hassle. Thanks for offering the best of both worlds.
I don't think there's anything in the language that makes PHP inherently a poor choice; however given the state of the ecosystem I do agree that right now it is a poort choice.
Preach the Word my brother!
Cool, glad to hear you like Plates and thanks for your feedback, much appreciated!
Quite possibly, yes, if they're all loaded under the one web server process.
Good points, thanks for answering thoroughly. The questions I raised in the second paragraph were rhetorical though, I knew the answers (I've read the issue when you first posted it on Twitter). Those are the kind of questions users might ask themselves. For example: &gt; Why would &lt;?= behave differently than &lt;?php echo? Do you imagine the level of WTF for some users? Other example on how a user might react: &gt; Why does the function `layout()` work in the templates, but not in my controllers? Isn't Plates supposed to be raw PHP? Good point about portability, I don't think too that it's really a goal given every templating engine has its own tricks. Here are my 2 cents about all this: I've been a long time advocate of PHP as a templating engine, simply because that's what PHP is. But then I've tried good alternative such as Twig for example, and what really made a difference is all the little helpers and shorter/nicer syntax. When balanced with the fact of learning a new language (which is really a pain), it's still a big plus. So I clearly understand your goal: make it easier and more secure to write templates. But to me the solution are templates like Twig and so. That's probably not what you want to hear ;) But I totally respect what you are trying to do.
I'm not sure if any of two last methods has ever work before.
http://clip-bucket.com/ http://www.phpmotion.com/ http://www.phprevolution.com/ If you need more, message me back and I can help you find some more.
Nice summary on service containers. I think the examples you give are a little weak though, and they demonstrate how rules are meant to be broken. I'd even argue that getting too hung up on following every rule is an anti-pattern. For instance the likelihood of reusing your Symfony controllers in another framework is pretty slim. In fact you can reuse most of the classes from one framework in another, but you would almost never reuse controllers. They are a type of [mediator pattern](http://en.wikipedia.org/wiki/Mediator_pattern). They practically exist to be tightly coupled to the framework in order to promote loose coupling between the framework classes. You could put a lot of effort into writing your controllers to avoid using the container class directly, but that's a waste of time.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Mediator pattern**](https://en.wikipedia.org/wiki/Mediator%20pattern): [](#sfw) --- &gt; &gt;In [Software Engineering](https://en.wikipedia.org/wiki/Software_Engineering), the __mediator pattern__ defines an object that encapsulates how a set of objects interact. This pattern is considered to be a [behavioral pattern](https://en.wikipedia.org/wiki/Behavioral_pattern) due to the way it can alter the program's running behavior. &gt;Usually a program is made up of a large number of [classes](https://en.wikipedia.org/wiki/Class_(computer_science\)). So the [logic](https://en.wikipedia.org/wiki/Logic) and [computation](https://en.wikipedia.org/wiki/Computation) is distributed among these classes. However, as more classes are developed in a program, especially during [maintenance](https://en.wikipedia.org/wiki/Software_maintenance) and/or [refactoring](https://en.wikipedia.org/wiki/Refactoring), the problem of [communication](https://en.wikipedia.org/wiki/Communication) between these classes may become more complex. This makes the program harder to read and [maintain](https://en.wikipedia.org/wiki/Software_maintenance). Furthermore, it can become difficult to change the program, since any change may affect code in several other classes. &gt;With the __mediator pattern__, communication between objects is encapsulated with a __mediator__ object. Objects no longer communicate directly with each other, but instead communicate through the mediator. This reduces the dependencies between communicating objects, thereby lowering the [coupling](https://en.wikipedia.org/wiki/Coupling_(computer_science\)). &gt; --- ^Interesting: [^Behavioral ^pattern](https://en.wikipedia.org/wiki/Behavioral_pattern) ^| [^Mediation](https://en.wikipedia.org/wiki/Mediation) ^| [^Earth ^System ^Modeling ^Framework](https://en.wikipedia.org/wiki/Earth_System_Modeling_Framework) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ciomwzd) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ciomwzd)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
Im just finishing my first major Symfony project and im ashamed to say that i injected the service container into EVERYTHING. Well, not everything, but its a learning experience and I’m not going to do that again now that I understand it more. 
Just an FYI, don’t use the mysql_ functions, they’re old as dirt and geting removed really soon. http://www.php.net/manual/en/function.mysql-select-db.php
You're totally right about the controllers – in fact, I have one article that states that exact much about how controllers are supposed to be tightly coupled to frameworks.
Aura/Di + traits = no need for passing containers around. It may be an abuse of traits, but that's so handy to just have to add use Database; to your class definition to get your database setup thanks to a setter and a config of the DI.
Noticed the update to that post. With java-style annotations, or python-style decorators, seems like comment-based approaches will no longer be needed.
When it comes to injecting the container you can make a differentiation between "framework" and "component". The reason Symfony injects the container into controllers is because controllers are framework classes and are application specific, ie. they'r not reusable components. However with other elements, such as general purpose components and or libraries, you don't want to inject a container, ever, because these parts are supposed to be reusable. In other words, you write your business logic as a set of POPO's with dependency injection endpoints (such as setLogger, etc.). Then in the case of Symfony you create a bundle that has a Composer dependency of your POPO library and this bundle defines the dependency model through the configuration (services.yml). 
Great, now instead of being coupled to your container, you are… coupled to your container!
I hadn't really thought about it until now, but I suppose controllers can be seen as an extension of the service container since so much of what controllers do is gathering together dependencies and wiring them together. But controllers are the only type of class/pattern where passing the whole container makes sense. The one important reason for using a service container that you didn't cover in your post is unit testing. I've learned the hard way over the years that mocking the entire container -- because the class you're working with requires the entire container -- is a real pain in the butt. Maybe service containers + unit testing could be another post?
It sure can! I'll write about that, for sure. Thanks for the thoughts!
You shouldn't be thinking about containers, but about dependency injection itself. And required dependencies should be injected through the constructor. Your object shouldn't be allowed to exist in a "corrupted" state, i.e. without its *required* dependencies. Setters are for optional dependencies. As a user of your class, I don't want to look for every trait you use, then through every setter method, and guess which one I need to call and which one I don't. Constructors exist for a reason.
Just tested and you're right with variable strings, `($string){0}` and `($string)[0]` both fail. I guess because parenthesizing things makes them a separate expression. However, `$string{0}` works and its pretty common to use the curly brackets to indicate that it's a string offset and not an array offset. I guess with string literals this doesn't really matter since the string is right there so there's no confusion.
Does this mean if you are on Ubuntu 10.04 LTS you aren't getting security updates backported?
But it feels so good to rip that container out and replace it with clear dependencies.
Maybe a better question would have been how should I validate users with minimal effort from the user? I suppose I could opt for additional verification methods. Facebook saves me time and logic and since users who aren't verified don't lose any functionality (only a mark of "be careful trusting this user") and have to trudge through a few reviews to earn the trust me badge. 
Facebook definitely streamlines it, and I'm not suggesting to not use Facebook as a validation method. I'm just suggesting to not use it as your *only* validation method. 
Yes and no. Yes, because Canonical themselves backport updates. Often those updates will come from 5.4/5.5 if possible. No, because there's only so much Canonical and their maintainers can do if PHP themselves refuse to support 5.3 and fix bugs in 5.3. If you're still on 10.04, you should note that in 2015 it will no longer be supported at all. You should really make an effort to move to 14.04 LTS if possible.
As far as I am concerned, this "just fake an Apache request!" is an absolute non-starter. I am developing several web apps, some/many I interact with perhaps once now I need to dump their PHP environment each and set the superglobals up?? Capture and produce $_POST and whatnot? Please. The problem with xdebug is the slowness but as slow as it is, it's at least usable. phpdbg, as far as I am concerned is not usable. Please do correct me if I am wrong here, though.
Docblocks can help solve that. &lt;?php /** * Class User * @property Logger $logger */ class User { private $logger; public function __construct(Container $container) { $this-&gt;logger = $container['logger']; } } There are always going to be trade-offs with design patterns. I think too many developers forget that. Coupling in one area can give flexibility in another.
Just because there exists a class does not make it object-oriented. Calling `WP_Query-&gt;the_post()` populates global variables, making them available to global static function calls.
Docblocks won't prevent your less disciplined colleague from also extracting the database and the cache service when nobody's looking.
Under a modern CPanel and CloudLinux setup, sure. And any setup where PHP is run through CGI or FastCGI shouldn't be vulnerable either. But with CPanel's dso configuration option, and similar options in many other shared hosting panels, PHP scripts can run using PHP as an Apache module. There are still a few bad hosts out there advocating mod_php in shared environments for performance reasons, believe it or not, as if the only alternative was still spawning a CGI interpreter for every request. There are more that simply don't realise the security implications.
The problem is with precedent. If you allow passing in the container *at all* you have set the precedent for the receiver to essentially unlimited access to the container. Code review *can* help to mitigate this but it's much easier to fight up front than after the fact (if not, legacy code wouldn't be such a hassle).
Don't waste your time with it.
Some times to takes doing things wrong to understand how it actually hurts your project. So you're probably a better developer for it! 
Using traits is fine, as long as every method in that trait corresponds to an interface. That way you're not tightly coupled to the trait but instead using the trait as a means of fulfilling the interfaces contract. 
A developer who abuses the container and ignores docblocks is going to create problems no matter what. If they don't understand responsibility how are they going to create useful classes in the first place?
Add a userscript with something like grease monkey or similar to kill that feature on the site
Can you see if you can call the php executable from the command line. something like /full/path/to/php.exe -v This command should show the php version. And another thing is that, if the installer is adding an environment variable, then you might have to open a new shell, I mean a new command line window to have the new variable. So you can also try opening a new command line window and try to run it from there.
I think that WAMP doesn't install php as a system service, which you need to run composer. Install php and register it as an environment variable using the .exe from php.net
Eh.... Just use ctrl+f
Wait, / activated in-page search in Firefox? I just used Ctrl+/Command+F.
I agree with you; web sites should never override standard browser behavior. I'd prefer that they weren't even allowed to, but I understand that it's difficult to prevent this particular situation.
It's not the website doing it, it's Google Chrome. It wont work until you perform a search, then Chrome will figure out the URL parameters and enable that feature for the website.
As mentioned by TocasLaFlauta, I'd add a userscript to the page that removes the event listener for that keybind. And yes, I absolutely hate it when sites hijack normally functionality. Let me scroll/type in peace, dagnabbit.
I'm able to do that command via the command line. I did not see PHP as an Environmental variable under system properties though. I have also had this issue using XAMPP as well.
Lorna Jane provides a [(paid) questions pack](http://www.lornajane.net/project/zend-certification-questions-pack) that I found useful for finding my blind spots. She also provides [(free) flashcards](http://www.lornajane.net/posts/2014/zend-certified-php-developer-5-5) (found at the bottom of the page) which are useful for memorising PHP functions.
Seems to be the same with XAMPP as well.
Can you please explain or point me somewhere I can read more about this browser behavior. My google search yielded no results...
http://chrome.blogspot.co.uk/2009/07/tip-quick-site-searches-with-omnibox.html If you visit chrome://settings/searchEngines you'll see a list of search engines its populated. I not sure how Fx does it, but I assume it's something similar.
Now that you mention it, it did say something about UAC and not being an admin account. I will re run the installation via an admin account and see how I go. I have finished up for the day, but if I continue to have any problems I will hit you up on Skype. Thank you :)
No, here is the piece of javascript that does this.. from http://www.php.net/cached.php?t=1403329231&amp;f=/js/common.js Mousetrap.bind("/", function(e) { if (e.preventDefault) { e.preventDefault(); } else { // internet explorer e.returnValue = false; } $("input[type=search]").focus() }); using the [Mouse trap](http://craig.is/killing/mice) library...
It would be more than useful if every convention showed an example.
PHP 5.3 has reached EOL on 20.06.2014 according to https://wiki.php.net/rfc/php53eol. However a last release on the 5.3 branch is planned, which contains a number of security fixes previously only applied to higher branches. That release will also announce the EOL.
&gt; Discontinued means you should not use it, or expect security updates. I'd say it is not that black/white. Like frozen-solid said, different OS distributions will offer support and maintenance for older PHP releases as stated in their update policies. This particular issue is right now [under discussion](http://marc.info/?t=140440915000002&amp;r=1&amp;w=2) whether a CVE number should be assigned to this bug. I'd anticipate it will get assigned a CVE number, and especially if so, vendors will backport the fix to their supported versions of PHP (as needed). As crazy it may sound, but heck, even PHP 5.1 will get [security patches](https://rhn.redhat.com/errata/rhel-server-errata-security.html) from Red Hat ;)
**YES**: You should not be using it in new projects, old projects *need* to be upgraded. It's not complicated. On php.net/releases I can download PHP4 if I like; that you can download it, even from somewhere prominent doesn't mean its a suitable candidate for use: It has been more or less abandoned, it is no longer included in the release cycle, doesn't get fixes applied. If that doesn't mean that it's discontinued, I dunno what does ... The more resistance is met, the more everyone keeps talking about it being okay to use unsupported software, the longer we will have to worry that our services are not safe. 5.3 is, *by any definition*, dead, treat it as such, move on, better things await you.
As mentioned, *it has reached EOL*, no two ways about it. We have no control over what versions are included in LTS distributions, moreover we make no commitment to those distributions to keep supporting abandoned versions after their EOL, we cannot, we do not have the man power. PHP is a moving target; the better you are at keeping your eye on the target, the safer, faster and more modern your applications wil have the capacity to be, it is as simple as that ... resist at your own peril. Use an LTS distribution if you like, but pester the crap out of package maintainers to keep their packages up to date, or get used to rolling your own builds of PHP and take responsability for using the latest and greatest yourself.
Obligatory [XKCD](http://xkcd.com/1172/). 
I don't disagree with you that people should move on, but it's definitely not dead by any definition as you claim. I'm a sysadmin, I urge clients to to run the latest version but at the same time clients ask me where it's been announced that PHP 5.3 does not get security fixes anymore. I tell them it's (probably) only a matter of time but otherwise I have no answer. The other comment even claims there will be another 5.3 release, how is that dead? This is a project problem, not a sysadmin or user problem. If it's dead as you claim announce it as such officially and stop blaming others. What's the hold up?
Vote and/or comment on the existing bug report at https://bugs.php.net/bug.php?id=67458
It hasn't even been a month since EOL for 5.3. Once again, *it is EOL*. The first release of 5.4 was 1st March 2012. The first release of 5.5 was 20th June 2013. I fail to see where "the hold up" is on our part; I'm seeing a sysadmin argue that something that **is EOL** should continue to be supported more than two years after a more suitable releease was available. So then, what's the hold up ?? Seriously, it's dead, you could have moved on any time in the last two years. and *definitely should have*. The time *is* now, stop resisting.
This is the wrong place to post. Try /r/PHPhelp 
this is the right place to post because I am not requesting help, I am sharing resources.
Oh, I meant as in its fine to inject the container into factory classes. 
Its done. Thanks for the link.
I dont have it installed seperately. Sorry if it came across that way.
&gt;What was the thought process behind this? That line was taken from another script, not written by me. I just know that my file doesn't get read, if I comment out that line. It seems like $xml is getting populated just as I'd like: print_r $xml: Array ( [Entry] =&gt; Array ( [0] =&gt; Array ( [Price] =&gt; 10.57 [Qty] =&gt; 4 [Code] =&gt; X12345 ) [1] =&gt; Array ( [Price] =&gt; 21.34 [Qty] =&gt; 7 [Code] =&gt; X55555 ) ) ) 
Not bad. It really does confuse me that Php lacks enums. Shit, Javascript too. Wonder what other major languages lack them... 
There is also [`eloquent/enumeration`](https://github.com/eloquent/enumeration). The advantages of `eloquent/enumeration` is that you can actually be type hint your methods accepting an enum: use Eloquent\Enumeration\AbstractEnumeration; final class HttpRequestMethod extends AbstractEnumeration { const OPTIONS = 'OPTIONS'; const GET = 'GET'; const HEAD = 'HEAD'; const POST = 'POST'; const PUT = 'PUT'; const DELETE = 'DELETE'; const TRACE = 'TRACE'; const CONNECT = 'CONNECT'; } class RequestHandler { function handleHttpRequest(HttpRequestMethod $method, $url, $body = null) { // handle request... } } $requestHandler-&gt;handleHttpRequest(HttpRequestMethod::POST(), 'http://example.org', 'body');
It's not EOL until the final EOL release has been made, which hasn't happened. While you may have tagged a branch as EOL, the final release is still incoming, and therefore has not truly met EOL as far as the users of your software are concerned. That's the point. Also, my comment was very clear that 5.3 would be supported at least by Canonical. That is the point of an LTS release. That all being said, as a user, PHP's biggest problem is that they constantly say it's our way or the highway and treat the best practices in enterprise as foolish and not worth their time. No, not every shop can roll their own builds of PHP. No, it's not as easy as you claim. The shop I work at is old, and it's a 6 month project to properly test our code on a new version, remove deprecated code, and update our servers. We don't have the time to dedicate to that every single year a new PHP version comes out. We depend on LTS releases in order to stay productive. Also, as far as Ubuntu 12.04 is concerned, we wouldn't if PHP cared about anyone but themselves. If they really wanted to insure that users of PHP 5.3 upgraded to 5.4, they should pay attention to the release windows of the major LTS releases of Linux. The PHP release window for major versions is unpredictable. 5.4 officially released less than a month after 12.04, and was delayed several months. If PHP had released a month earlier, and coincided their release with the largest Linux distribution, we wouldn't have this problem today. PHP only cares about themselves, which is just as potentially disastrous as OpenSSL only caring about themselves. For a HUGE majority of your users, PHP is treated like a part of the operating system, just like OpenSSL is/was. It gets upgraded alongside the rest of the OS and that's it. You can't say "just upgrade PHP sooner" because the only hard part of an upgrade is testing the code on a newer version of PHP. The PHP part is what I have to schedule months of time to make sure is right.
I hate to be the one that says this. Perhaps you're better reading the manual. http://www.php.net/manual/en/simplexml.examples-basic.php
Yet another one… Please check out what exist before creating a new one, it's just not helping, the ideal situation would be that everyone uses the same. https://github.com/myclabs/php-enum
Of course I checked out what exists, who do you think I am !?! I'm not confortable with instanciating enums, that's all. &gt; the ideal situation would be that everyone uses the same. Yeah, and they should use mine, not yours! Just trolling, yours is good too, but it is different, I considered it, rejected it and decided to implement another I saw in the SO post linked in my README. I hope you can forgive me.
Thanks! And don't worry, [it's coming](https://wiki.php.net/rfc/enum)
Oh, that's really good, didn't find that in my research. I like how you can use type hinting without instanciating your enums.
Untested, but I think you want something like [simplexml_load_file](http://www.php.net/manual/en/function.simplexml-load-file.php): // Loads report.xml into a class called Report $report = simplexml_load_file ( "report.xml", "Report" ); // Print the code of each entry in the report foreach ( $report-&gt;entry as $entry ) { echo $entry-&gt;code; // or price, or qty }
Did you checkout the readme? __callStatic() is implemented to make instantiation optional. &gt; who do you think I am !?! My guess? A random person on the internet.
Oh, I know, definitely not, but at least things are moving in that direction. When even one bad refactoring could break 50 million websites that might destroy the faith of your non-technical userbase, you have to take baby steps. Like I mentioned above, the long-standing mantra has always been to put the burden of change and compatibility on the developers' shoulders rather than the end-user. But, there's definitely a newer mentality aimed at encapsulation and separation of concerns since last year or so. For example, all new feature proposals for core are now being written as standalone plugins first to ensure that they work independently. On the front-end of things, all of their newer JS code is being developed with best practice methodologies, like Backbone, so there's definitely a push toward modernization.
::isValidName is too specific, name it ::isValidKey. And change ::getConstants() to ::getKeys() for consistency.
And at least in the olden days, single quote would activate a search mode that would only find link text. Not sure if that one can still be turned on.
You misunderstand me, I don't want it to be supported at all. I want it to be officially announced that PHP 5.3 is no longer supported, which hasn't happened yet. It should have been clearly posted on php.net, the download link on the front page should be removed and it should be listed on php.net/eol.php. All of that hasn't happened yet which make some people (not me) think it's fine to use 5.3. Instead of us telling people they should move on, why is it not done by PHP itself? This could easily be prevented by announcing it as no longer supported on php.net. My question stands, what's the hold up on that?
It's in an extension that you have to install, which kinds of defeats the point for something so basic.
I just tested it, so it does. That might be handy some day.
Forward slash is a long-standing shortcut for quick search, I think going back to the Unix days. Opera has used / for years, much quicker than Ctrl+F.
advertising own videos and sharing resources are bit different things ;3
Ragging on a guy for trying something new is not the way to progress a language. There might be others, shit apparently there is an SPL implementation (which as is the case with the majority of the SPL is hidden and never promoted), but that doesnt mean they get it right. This could be the one that does, so give the guy a break, atleast he is trying. 
Don't use this. Most regexes cannot properly validate email addresses. Valid email != existing email. Send an email with a link to click to verify email addresses.
Agreed there is no better way to validate than sending a confirmation email. I was just sharing a crazy long solution i found.
&gt; without instanciating your enums What do you think this does? `HttpRequestMethod::POST()`
Ah yeah, just as I thought. What's happening when you call $xml['Entry'] is one of two cases: 1: You have multiple Entry entries, the 'Entry' key contains all of them as an array 0...n 2: You have one Entry, the 'Entry' key contains an array of 'Price', 'Qty' and 'Code'. What you want here is counting the entries within 'Report'.
Why would you consider it ambiguous?
No, it isn't: &gt; * Date: 2010-05-21 &gt; * Status: Inactive Which is a real shame.
What do you think I implied ? &gt; without instanciating your enums (yourself, of course)
Oh... bummer
It's something I'd like to see as well. Maybe I'll try making an RFC for it once I get [bigints](http://wiki.php.net/rfc/bigint) over with.
Sadly SPLTypes, despite its name, is not part of Spl.
5.3 EOLs very soon. I think we're planning the last release atm.
If you specified PHP, you'd basically just be describing how the Zend engine works.
In this case he is doing both. Nothing wrong with that IMO.
Hmm, that might be a bug... Let me look into it. EDIT: Nikita's [Uniform Variable Syntax](https://wiki.php.net/rfc/uniform_variable_syntax#incomplete_dereferencing_support) RFC should fix this.
Do you have any prior experience with php whatsoever? Do you understand what Ajax is?
Maybe he needs a framework. Frameworks are cool. 
Require a credit card or PayPal account for all users. You don't have to charge but a penny to verify their credentials. Bonus: users who don't think your service is worth a penny, are not worth having anyway. Works coming and going, solves all your identity issues. 
If you are doing minimal backend stuff, you can just write your own processor class(es) in php, no reason for a framework. Otherwise +1 for Laravel as /u/wayspurrchen mentions.
I like [Slim]( http://slimframework.com/) myself.
Why not email validation? If they're providing an active email account and clicking a link in the validation email, they're more than likely a "person". How is a FB account more valid than an email account? You are going to find very few sign ups if you require a FB account.
Laughed at rails loonies. Maybe more people are trying PHP? I think they should rtfm. Maybe the use is increasing though... Lots of local tech colleges are now teaching PHP (bout time)
Oh i completely agree. I meant that without people spending their time developing solutions that solve problems with existing code, we’d never progress. Yes there are others that came before, but what if this is better than them all?
Silex is a great choice for what you're describing and its quite small. And there are lots of great posts on scaling up Silex as your app requires. 
Yes and yes.
I don't know. Thought you were concerned about the instantiation cost, not the syntax. 
I've actually just recently written an AJAX API using Silex. I chose it since the Symfony components are incredibly well-tested and used (plus the documentation is great), but I didn't need a full-stack framework. It's not failed me even slightly so far.
And there is no DLL available for windows, so this is not something that can be relied on. PHP did amazing things with the SPL, but its so half arsed and the docs are, lets face it, shit. So this solution gets my vote. 
What does this do that SplEnum lacks? http://www.php.net/manual/en/class.splenum.php
Thanks. I'll give that a go. Though the rest of the code is written with arrays in mind, so I'll have some re-writing to do.
Thanks. I'll give that a go. Though the rest of the code is written with arrays in mind, so I'll have some re-writing to do.
This function might work better than the json_encode/decode. http://stackoverflow.com/a/6167346
I think using a framework would still be beneficial. It's nice to have the structure that a framework provides, and things like routing, form handling (because even though it's AJAX forms can still be handled by most frameworks' form components), potentially authentication too etc.
Isn't everyone on Reddit.
http://api.symfony.com/2.5/Symfony/Component/HttpFoundation/JsonResponse.html I hardly see how Symfony is going to impede your ability to send a json object back. Really, you still need to validate on the backend side anyway for security reasons.
If you feel Symfony is too large for your project, then Silex would be a fantastic alternative - as you should have found from reading up on it. Everybody here seems to adore Laravel, but I think if you feel Symfony is too heavy, that may also be the case with Laravel. Realistically, knowing a little more about what your application will be actually doing (like, what features that could be provided by frameworks would your application will need) would help to narrow down your choices.
Easy installation.
&gt; When was the last time you saw a singleton in PHP? On Thursday, but that's only because I got Friday off. Symfony2 uses singletons like crazy, bad example. As an aside, PHP has language quirks and weaknesses, but that doesn't mean you can't apply design patterns to it. You can apply almost any pattern in any language. 
Are you suggesting Singletons are a good thing?
I found a great one on stack overflow that I use but I'm on mobile right now. Will link when I get back if I think of it.
There must be indeed :)
Is that a C extension or what?
Well, I mean relatively speaking. Comparing Silex and Laravel, there's a big difference - for a reason obviously, there is a lot more functionality available OOB in Laravel.
How about some people who are reading/ upvoting this hit the subscribe button in /r/learnphp? Maybe post and let people know that you're subscribed and you can help them. It's really that dead. I'm gonna message the moderator and see if he can relinquish his control over the sub. Update: Woot! He's giving me /r/learnphp which is consistent with all over the learn{language} subs. 
Ooh, that looks like it will do the job. My data doesn't use attributes, so nothing will be lost in the conversion. Thanks, I'll give it a go.
Symfony's service container allows for (usually) single instances to be used throughout an application via dependency injection, but it does not use singletons in the usual sense, where a class provides static access to an instance of itself. This is an important distinction because one is a very bad idea, and the other is very good!
Try [apigility](https://www.apigility.org/), it's based on ZF2 and basically is a framework for making APIs; which seems to be what you want!
Try /r/PHPHelp instead. It's linked in the sidebar. I help moderate it, but if you have any suggestions to make it more effective, give us a shout.
I messaged the guy who has /r/learnphp. He's still active. If he gives up the sub, would you want it? It's more consistent with the other educational subs that use /r/learn{language}. If he gives it to me, I don't mind giving it to you.
Ahh, that looks interesting... thanks!!
OP's not pushing his workaround as a standard or anything. It's an exercise that happens to solve a problem for him/her. If it helps other people, well good. I'd say that soapbox preaching is more detrimental to the community than someone exploring an existing solution. Software development certainly has no need for more elitism.
This community is quite active /r/learnprogramming
Thanks for response. I am working on a website w/200+ apps (if I consider each unique form an app). IMO, the problem w/everthing I have read on Symphony, Silex, Slim, Laravel, etc is that: a. They all want to control routing b.They all want to generate forms dynamically at request time IMO, both steps are "heavy" (costly) and don't need to be done. The form should be static and already rendered. If the content and forms are already rendered, routing is silly, I won't be changing API endpoints that often. To take it a step further, really I should be able to store apps / reuqest configs in a database, and have a PHP script auto generate a request object that will facilitate processing, so that I can spend all time on business logic. For example, a registration form: Configure app in DB (just basic info) Configure request in DB (accept POST, field email as string maxlength 100, field password string maxlength 100) =&gt; that should spit out a vendor\Request\Registration class. My app should just include the vendor\Request\Registration, validate (retunring error as JSON if invalid), and then process (insert and redirect).
You could simply forward people from the /r/learnPHP one over to /r/PHPHelp to ensure you capture all prospective learners.
If your main concern is things being 'heavy' then you could leverage caching to reduce that load significantly. I believe Symfony's routing component actually does have route caching, and of course you could cache a 'rendered' form, for instance, most template engines have some form of caching built in (e.g. Symfony uses Twig as standard while caches compiled templates). I'd argue that even if you don't change your API endpoints often, or even ever that routing is still useful. It's easier to product cleaner URLs and makes it easier to structure your application (i.e. using a front controller rather than `form1.php`, `form2.php`. As for your example, I would argue that using the DB would be heavier than dynamically creating forms on requests (then again, caching). If you were going to have a class dedicated to each form anyway then why have the information stored in the database? Keep in mind too, that although frameworks like Symfony are quite large, they are well made and only bring features into memory if they're used - you have a foundation that is tried and tested to work on that uses rock-solid components.
I would disagree. I for one, do not fancy Laravel.
Wow thanks for your contribution!
/r/learnprogramming , /r/learnjavascript, /r/learnpython... I'm afraid my OCD can't do that, Dave.
I don't either, that's not to say it's a bad framework by any means. Just I prefer other available options. All I mean though is that a huge portion of the PHP community here on Reddit seem to swear by Laravel.
*If* I wanted to moderate /r/learnphp, then the only reason I'd want to do that would be to "shutdown" /r/phphelp and "move" it to /r/learnphp (to consolidate everything), but we'd want the top mod (/u/SoBoredAtWork) onboard first.
&gt; the problem w/everthing I have read on Symphony, Silex, Slim, Laravel, etc is that: &gt; a. They all want to control routing &gt; b.They all want to generate forms dynamically at request time &gt; &gt; IMO, both steps are "heavy" (costly) and don't need to be done. The form should be static and already rendered. If the content and forms are already rendered, routing is silly, I won't be changing API endpoints that often. The routing in Symfony is cached in production mode, so that is hardly an issue (especially if you are going to have only a few routes). As for generating the form's view, you have the choice not to do that. Simply do not call `$form-&gt;createView()`. Hardly anything in Symfony is done *auto-magically*. You can customize the behavior at your will. &gt; To take it a step further, really I should be able to store apps / reuqest configs in a database, and have a PHP script auto generate a request object that will facilitate processing, so that I can spend all time on business logic. &gt; &gt; For example, a registration form: &gt; Configure app in DB (just basic info) Configure request in DB (accept POST, field email as string maxlength 100, field password string maxlength 100) =&gt; that should spit out a vendor\Request\Registration class. My app should just include the vendor\Request\Registration, validate (retunring error as JSON if invalid), and then process (insert and redirect). So wait... You are saying routing is heavy but then you want to move all this logic in the DB? Your concerns hardly make any sense. As for your `Registration` class, simply create a Doctrine Entity with the appropriate fields, add the appropriate validation annotations and create your form type. Your form is done. You don't need to use that formtype to then generate the view as long as your field name matches in your json request. Full stack frameworks like Symfony employ **LOTS** of caching and only load functionality when needed in order to perform as fast as micro-frameworks such as Silex.
&gt; So wait... You are saying routing is heavy but then you want to move all this logic in the DB? Your concerns hardly make any sense. Just to be more clear, I want the form fields (name, validation rules, mapping to DB, etc) stored in the DB. I would then run a PHP script (as part of a builder) that would pre generate the Request class that would handle the form. Think of it like a template for form requests insted of a web page.
[PHP CodeSniffer](https://github.com/squizlabs/PHP_CodeSniffer) has a few built in standards like the PHP-FIG Standard or PEAR these are usually a good starting point.
like what?
I know about the audio, and I'm working on it.
Same here, and yes, Reddit seems to be in love with it for now :)
Ehhhh, something like enums should have been a core feature multiple major versions ago. But this is still cool, I really should look at and use Spl more.
Why not give some actual examples? Otherwise it just seems like a bit of a rant For me personally, Im sick of seeing crappy code cut and pasted from some 2007 tutorial (usually why wont PHP sent email, or why is this query failing... then they paste php code instead of the actual sql).
Why the heck are you talking about elitism. This is about being constructive as a community. Scattering usage for something so basic is just too bad. It's not a big deal, it's good that people write good software. It's just that for these kind of things, let's try to work together. I'm sure that we could have had a successful unique and standard Enum library if there were less implementations. There's just too many implementations today for it to become useful.
What other frameworks do you prefer? If you could add why you prefer them that would be awesome.
The difference however is that it always returns the same instance for one enum value... ie.: `HttpRequestMethod::POST() === HttpRequestMethod::POST()`
Thanks for the response. It isn't about whether or not the person is real. It is more about do you only have one account OR if you have blemished record on this account, what is to keep said person from creating a new account? My end goal is accountability. 
It's easy to write without a framework. You just put together a site the customer wants. Then there are changes but hell, you can hack them on. Then there are a few more changes and before you know it you're terrified to touch the code. Any modification could bring the whole site down. You should have written tests but you didn't because they're a pain in the ass and so you just stare at your screen and start to cry...
Agreed - some examples would be good. If the issue is "why doesn't XXX work" or "look at this code, what's wrong?" there is a /r/PHPhelp which is better suited to the job. Maybe mods need to flick such posts over there?
Personally I think moderation needs to be a little stricter with some of these posts coming in. I get that people want to learn, and I'm all for that, but this reddit is not meant to be a support reddit and this is clear in the sidebar. As for "Rails loonies" I think that's a rather ignorant and disingenuous thing to say all on its own. Rails popularized many things which have made their way in to standard PHP practices. Just look how far frameworks have come since Rails became a big thing. You don't have to like Rails, but you should be at least willing to recognize that it's been good for the webdev community as a whole. Yes it's stupid when people who use Ruby rip on PHP, but it's equally stupid when we try to do the same thing.
Perhaps a needle/haystack thing: /r/phplearn
Yep, you're that guy. 
This is an unhelpful and condescending response. What was the point of this?
I was shooting the messenger, I have no beef with rails at all. There just seems to be a disproportionately loud and vocal sub class of rails folks who like to take pot shots at low hanging fruit. It's a waste of everyone's time, advances nothing in terms of discussion, and just plain feels bad to read people bickering about subject matter that is about equivalent to 'my F-150 can kick your Chevys ass!'. Hope you understand my motive, sorry if I offended anyone. Unless you're a rails loony -- then you should go die in a fire. 
To understand the background of the poster of the question. What part is condescending? I just wanted to give an answer without being too simplistic, or flying over anyone's head with too much information. 
Yes, it is very much like the audiophile sub. $30 skull candies with $50 DAC's is not audiophile. I've read, if not even started, similar types of post, asking for things like (how do I hook up my Play Station to my stereo) to be removed. But the mods are less than involved and thus the sub is 80% a pile of shit. 
Yes, gmail and twitter may have done so. But I think this function, in the context of php.net documentation pages, does more harm than good. Take the example of gmail. There is not much use for searching the text that is in page. Because the contents are short. Most often you are interested in the searching the mails themselves rather than the page contents. But take the case of the php.net. The user has probably done the search in google and arrived at the exact documentation page in php.net. Now this page can have a lot of content. For eg, take the documentation page for cURL extension. There are a lot of flags and options in those pages. So there is a lot of content in the page itself and with out text search it will be hard to find the info user is looking for. So most of the time, the user will have to use the in-page-text search, as opposed to the actual site search. This issue is worsened by the fact that you cannot search for flag constants from the php.net's search function. So I think the slash key should be returned to its default text search function by which it will be most useful.
Explain to me how PHP as a first programming language is a good thing (please, enlighten me). Most documentation is outdated, the majority of examples don't use namespaces, callbacks, or even classes. It's loosely typed which means that it's extremely forgiving, and you think that these attributes contribute to a strong first language to learn? At least C#/java forces the difference between floating point and non-floating point math...
&gt; Do you understand what Ajax is? Not sure if you're being condescending or have little experience.
Bro do you even prototype singleton factory builders in your front controller MVC visitor?
I was reading The Daily WTF and couldn't avoid it: http://thedailywtf.com/Articles/Rolling-Your-Own.aspx
Ouch, my brain...
This is what came to mind from "rails loonies" http://37.media.tumblr.com/tumblr_m6pb5vDOls1qetik7o1_1280.jpg
I tried to create a mental map of how that might work and now I'm bleeding out of both nostrils after being briefly trapped in some kind of feverish Java night terror. 
Then my work here is done.
&gt; web apps would have to be designed to use weird key combos that they were sure no browsers used. You are taking about web apps, but the discussion is about web pages. Or would you rather call the pages at php.net a 'web app'? I wouldn't, because all it is supposed to serve is content, not functionality. Right? So, it does not have to provide its own shortcuts, simply because it does not offer unique functionality. So I think there is no need to override standard interfaces.
&gt; There just seems to be a disproportionately loud and vocal sub class of rails folks who like to take pot shots at low hanging fruit There's a disproportionately loud and vocal subclass of PHP users who aren't very good at programming and spend a lot of their time discussing things like the speed difference between single and double quotes, and which editor is best, or writing articles which cover subjects that are already adequately covered in the manual. I can't seem to go an entire week without encountering some kind of thoughtless argument over a petty micro-optimization. On the other hand, this does not mean every person who uses PHP is a bad programmer. Anyway, I get your clarification. I just think the point was already made, and there was no real need for a broad-side shot at anyone.
I think the problem is we tend to put too much responsibility in templates. Why is the view receiving unsanitized data from our application in the first place? Why is it receiving data that isn't formatted or using template functions that could be [handled perfectly well by CSS](https://developer.mozilla.org/en-US/docs/Web/CSS/text-transform)?
Symfony actually has zero singletons. A singleton would create/return itself, that doesn't happen anywhere in the framework. 
Well, to be fair the language did have some catching up to do but I am super happy to see it in the state is in in today!
Read up on SQL injections. Don't suppress notices in development (quote string indexes). Offending snippet: $username=isset($_POST[username])?$_POST[username]:$_SESSION[username]; $password=isset($_POST[password])?$_POST[password]:$_SESSION[password]; $user=$db-&gt;query("SELECT * FROM login WHERE username='$username' AND password='$pwdhash'")-&gt;fetch(PDO::FETCH_ASSOC);
Hence the request for Bug Testers and Contributors, thanks, I'll get onto this ASAP.
What the fuck man. Do you realize you are completely imagining stuff. Just imagine for 5 seconds that I was talking to a very very good developer (picture anyone, Anthony Ferrara, Nikita Popov, …). Now does the phrase **really** say "If only you know enough to be a real developer"?? Seriously?? That's absolutely *not* what I said! I'm just saying this is too bad there is more and more implementation of the same thing because it's not helping the community. Myself I am guilty of this very thing sometimes. Looking around at existing packages is something we all should do, everytime. Now interpret whatever you want you don't seem to need help with that… And did you **read** the link I gave?? There's a whole paragraph at the top of the README that explains why this package was made. Have you read the thread? The Spl implementation is an extension that we have to install, it's not included in vanilla PHP. Now let's try to keep everything constructive, I am not saying anything about OP and his/her competences. I respect his work, he can do whatever he wants. &gt; How is OP, going through a good coding exercise to find his/her own solution and sharing the result of that exercise, "not helping"? Have you read the xkcd? http://xkcd.com/927/ It's not helping because people seing an enum implementation for the first time today, through this link, might use this implementation instead of any other existing one. It spreads the usage. It has been said before on reddit, not by me, but I completely agree with that: &gt; every package shared with the world should have a "Why?" section in its readme. OK now I've seen all the comments, my concerns don't seem to be shared by everyone, so I'll keep it low. But for fuck's sake don't talk about elitism or whatever because that's just absolutely not true.
It's in an extension that you have to install, not included in vanilla PHP (and no DLL for Windows). And it's not a core feature, it's just a workaround, just like in the link.
Most of the other enum implementations work that way, that's the main advantage of an enum vs a constant. Even [SplEnum](http://php.net/manual/en/class.splenum.php) work that way (type-hinting).
I think [the reflection to get the constants of the class](https://github.com/greg0ire/enum/blob/master/src/BaseEnum.php#L19) is much much slower than instantiating an object. I mean the instantiation cost is really negligible compared to the reflection, so performance wise instantiation shouldn't be a problem. (unless you instantiate thousands of enum, given the reflection call is cached)
Yeah, I think reflection is much slower than instanciation too (because there is probably a file access, and a parsing work to do), but : 1. as you said there is a cache system around it, which means if there is a cost, it gets negligible in the long run. 2. it is not used at all if you use the class for a comparison, like this : `if ($testedValue == MyEnum::myValue)` 3. we're really talking microseconds here. I think people will look at their SQL queries before considering a change in how they handle enums. 4. I ended up testing, and a call to `isValidValue` is not that slow on my machine. Only twice as slow as an instanciation with your library (but it's my machine and I have an SSD, and probably don't know how to write a good benchmark). 100 µs vs 50 µs. The code in case you would like to try it : &lt;?php require 'vendor/autoload.php'; use Greg0ire\Enum\BaseEnum; final class DaysOfWeek extends BaseEnum { const Sunday = 0; const Monday = 1; const Tuesday = 2; const Wednesday = 3; const Thursday = 4; const Friday = 5; const Saturday = 6; } $a = microtime(); var_dump(DaysOfWeek::isValidName('Humpday')); $b = microtime(); var_dump($b-$a); With your lib : &lt;?php require 'vendor/autoload.php'; use MyCLabs\Enum\Enum; /** * Action enum */ class Action extends Enum { const VIEW = 'view'; const EDIT = 'edit'; } $a = microtime(); $action = new Action(Action::VIEW); $b = microtime(); var_dump($b - $a); 
# **Symfony Components - Silex &amp; Symfony** It depends on what I'm developing, but generally it'll be either Symfony or Silex. Mainly because the Symfony components are incredibly well documented, well tested, widely used, and widely supported. The quality of the code is excellent and all of them work in very flexible and intuitive ways. For a bit of a learning exercise I followed Fabpots guide to building a framework on top of the Symfony components just to see how things were done, and as a result made my own framework with some similar features called Trident. From my experience developing Trident I found just how great the Symfony components are. Of course, Laravel is based on Symfony components too, but I prefer Symfony because of it's less opinionated nature. Once you have a base set of components / bundles that you've written to handle some basic tasks you can get going just as fast as you would with Laravel. Main reasons for me then: * Well documented * Well tested * Well supported * Huge community - lots of bundles created for it for a vast array of tasks. * Well written code that follows modern standards * Not opinionated * Easy to extend * Great CLI interaction too * They're backed by a company that's been around a long time. Symfony is there to stay. It even has LTS releases! * It's secure You could say a lot of that about Laravel, but I just prefer how Symfony is structured more. Makes sense to me. I think Symfony just offers more. If I want to make something that doesn't need all the features Symfony offers then I can just use Silex and still be using components I'm comfortable with. #**Other Options that I've considered** ## Phalcon I've tried Phalcon before and it's very cool, and it is extraordinarily fast. The documentation is great too, but you still miss out on some of the ease of debugging that being able to see PHP files gives you, unless you know C. My gripe with Phalcon is that there doesn't appear to have a big enough following behind it for me to jump on board fully. ## ZF2 I've had to work with ZF2 before at work, and it's a good framework - but I don't see why you'd pick it over something like Symfony. You get basically the same features, but with a smaller community, and worse documentation. It's very extendable, but then again, so is Symfony.
Look at the SO post linked in my README, I think there are 2 schools of thought : - the one that think it should be instanciated - the one that doesn't If you look at other language that do have an enum type, do they instanciate it ? - [java doesn't](http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html) - c doesn't, but it's a bad example, since it does not have classes - [c++ doesn't](http://stackoverflow.com/questions/2941890/c-enum-in-foreach) That's probably why I frown when I see an enum workaround that uses instanciation. I could say that your implementation does not count as an enum, but I think the truth is neither do. Both are workaround, not implementations. At least mine says so in its description.
People, chill, you can say whatever you want about my skills, `greg0ire/enum` is not my work, it is [Brian Clines'](http://stackoverflow.com/users/32536/brian-cline). Let me tell you what happened. I had done something similar to that, without the cache system, and was copying boilerplate from project to project, which is bad. I searched for a solution on SO, and found [this thread](http://stackoverflow.com/questions/254514/php-and-enumerations/254543). I read most answers, and found myself in agreement for Brian Cline's implementation because - It looked a lot like what I had come up with myself, only better - it had the most upvotes I then search for something like this on github and on packagist, found nothing and decided to package it myself (with Brian Cline's permission). I'm going to thank him in the README rightaway. So all I did in the end was - build the Composer package - write some tests - write a README
Might be an idea to look into how you would do that then. IIRC, Wamp has old versions of everything. Haven't used it in years now, just because I manage everything myself, but when I did use it, it has old versions of PHP and MySQL.
Seeing the code i would say, No!
I took a good look at it. Wow. - SQL Injection EVERYWHERE. There's not even 1 place where there's even an attempt of sanitizing it. Bad Level = 10^1000 - What is this??? You're rolling your own crypto and using a weak hash for passwords. Bad Level = 10^100 $tx='abcdefghijklmnopqrstuvwxyz!#$%^&amp;'; $i=strlen($tx); $t=''; $l=8; while($l&gt;0){ $z=rand(0,$i); $ul=rand(0,100); $t.=strtolower($tx{$z}); $l--; } $pwdhash=sha1($t); $q=$db-&gt;prepare("UPDATE login SET password='$pwdhash' WHERE email='$email'"); - Separations of concerns = 0. SQL mixed with Templates. Includes everywhere. Lack of classes. Bad Level = 5 - Everything is dumped in a "include" folder. No further separation. Bad Level = 4 - Globals... global everywhere. Bad Level = 4 - The only indices in your migrations are the incremental primary keys. Sorry mate, I have nothing good to say about your project. It might sound harsh but this is very irresponsible programming. It's 2014 and this reeks of PHP4 from 2001. Please put a notice that says "don't use this, it's insecure" while you fix it or something... Read this thoroughly: http://phptherightway.com Let me know if you need any more indicators. My advice: Scrap everything, use a solid modern framework (I think we're past over the "I'm making my framework to learn" part), Composer and PHP-FIG. At most, keep your CSS. Framework recommendation: Symfony, Zend, Laravel. 
&gt; You are taking about web apps, but the discussion is about web pages. Or would you rather call the pages at php.net a 'web app'? I wouldn't, because all it is supposed to serve is content, not functionality. Right? Web apps are just fancy web pages. &gt;So, it does not have to provide its own shortcuts, simply because it does not offer unique functionality. So I think there is no need to override standard interfaces. Is / really standard across browsers, or only in Firefox?
Aaaaaand... we are done here.
Or Drupal?
&gt;Web apps are just fancy web pages. Define 'fancy'... &gt;Is / really standard across browsers, or only in Firefox? It does not work in chrome. But [here is a thread](https://code.google.com/p/chromium/issues/detail?id=90) where a lot of people are asking for it..
I have something good to say. *StudioJunkyard* is the perfect name.
You should consider writing [real commit messages](https://github.com/StudioJunkyard/Libr8/commits/master) instead of just using the date.
There are some lighter frameworks out there that we call "microframeworks." If you like Symfony 2 but it feels a little heavy, check out Silex. It uses some Symfony components for routing and has some good practices to organize controllers. Another popular microframework is the Slim framework. The concept that makes MVC so good for development is the idea of "separation of concerns." This just means that you keep the different aspects of the software into their own discernible pieces. You can totally do this without a framework, a framework just helps you out. 
Honestly there are a lot of ways to answer this, but I think one thing you should keep in mind is how much work it takes to do a project in mvc from scratch: without a framework to start with, you're essentially going to be building a framework just to do mvc. For some projects that is actually desirable, but if your doing projects for a client who wouldn't take your professional advice to get a host with a modern version of php or have the PDO extension enabled, then I'm going to assume the projects you are building probably dont really call for having a new framework developed exclusively for that project. I will say it's a great learning experience to build your own framework, but to use that in a production setting for client work? You should really stick to a framework with good documentation, support for various versions of php and a community behind it. For both you and your clients sake :) There are a few good mvc frameworks for php, whichever one you work with is up to you, whatever suits you and your project requirements best is most likely the best option. Hope this helps! Edit: forgot a word. Edit 2: first paragraph 'just do mvc' -&gt; 'just to do mvc.' 
exactly, if there's something extremely small out there (slim seems like it might work for me) I'd like to use it. But Symfony clearly states that there is an end of life in a year or two (or at least out of support). And there's 10.3megs of files zipped in Symfony standard download. That seems ridiculous for the kinds of applications I make for small businesses and such. Though there may be a ton of useful functionality. I realize after I learn a bit more I may find Symfony to be the best option, but to learn I need something a lot less complex. And I'm with you on "separation of concerns", thats why I'm trying to learn MVC. Thanks for the input moonpi3 
right, I think I want to learn how to make my own MVC, or at least build on top of a very simple one to start. PHP-MVC seemed to be what I wanted because of its small footprint but the PDO thing killed it for me. I may just rewrite PHP-MVC to use MYSQLI and start there. Just wanted to see if there might be a better option.
so, to expand. a lot of non-profits seem to get hosting for free from companies, but it's bare bones type of account. They're not inclined to start a new line item on the budget for hosting - even if it's $10 a month. So it's just something I've been dealing with.
yeah, I thought about that, and may do in the future.
https://jream.com/lab looks promising
Thanks for the constructiveness of your comment. I'll be working on brushing up on skills. I come from the Old Skool way of coding (as you pointed out), originally in ASM which is a totally different kettle of fish. If I wasn't open to suggestions, I wouldn't have the project up on github, or posted here about it. It's all part of the learning process. A couple of questions though. Globals, are you meaning the vars being used directly in the SQL statements? I thought Globals meant vars being shared from script to script without having to use $_GET, $_POST, which that type of Globals is disabled so can't be used in both my local server, and live server. Or are you meaning something different? The Crypto, is as you pointed out, I didn't actually think of it as Crypto but rather just a password reset, then SHA1'd it, as I thought md5 was insecure. Correct me if I'm wrong?
Look at `django` (no really). It'll show you how simple MVC is. You'll then prob wish you where using python for your project. On the upside, if you cant, you'll find the simplest most elegant way to do MVC. I started with MVC on Magento. I then played with CodeIgniter and CakePHP. CodeIgniter was easy; don't remember CakePHP. I'd never do a web app in PHP again since I found out about django. Nothing against PHP, but django, it's just amazing. I've already written 3-5 projects in django that I've used between projects (good luck doing that in PHP). I'm not trying to sell you on django, considering this is a php subreddit. But, in every case (even with PHP opcode cache with XCache/APC) django has been significantly faster than PHP.
That's quite old, you should really aim to adopt some new standards. Honestly, just take the plunge and learn a framework. Something like Silex or Slim, they're small and easy to get going with. Otherwise, you're wasting your time by going back several years.
Where are you seeing end of life? Symfony is as thriving as ever, Sensiolabs got something like a million dollars in venture capital like 6 months ago, and their roadmap is planned out as far forward as 2019. At this point, the vast majority of the modern PHP ecosystem relies on Symfony in one way or another. (It's so well written that *everyone's* using their components. Also, I know the disk usage seems crazy (especially when you co wider that that's 90% plaintext sourcecode), but is 10mb really going to kill your server? It takes up a lot of space because it's written very verbosely. Every element of every component is well separated so that other developers can easily see see exactly what's going on and override functionality, as they should in a good application. I'm working on a project that's approaching 100mb of libraries, and we haven't even launched, but disk space is cheap, and the quality of the code and development time savings is unbelievable. Also, I don't think Symfony is *that* complex. There's a lot to it, but I went straight into learning it from scratch, and it went fine. What happens is that it starts out like a "magic black box", you write some simple code from tutorials, and automatically get all this great functionality (seemingly out of nowhere). But as you work on your project, you'll start figuring out exactly how all the components work, and it'll all make sense.
First off, I applaud your desire to take a back-to-basics approach, and focus more on the fundamental language + design patterns than a bunch of heavy frameworks. PHP is an especially web-focused language, but it's honestly been a giant hodgepodge of hackery only until very recently. The PHP community still often focuses on using 3rd-party solutions to solve problems that were really language issues we've since moved past. ...moving on You'll find it's tough to get a straight answer when asking about MVC, as there are two extremes people often fall into: the academics, who go on endlessly about what MVC "should" do, without giving any thought to actually making a useful application, and the short-sighted practical developers, whose only focus is on closing off their current issue as fast as possible, and invariably end up with views full of complex control logic, fat controllers full of business logic, and either a tiny model or dozens of tiny models + one "god object" that does nearly everything. I've found the key here is less about programming talent and philosophy, and more about project organization: everybody wants to program the "right" way, but make sure you schedule time for yourself to go back and review. Pair programming is also a good approach here - if you can't argue a decision (either on academic or practical grounds) with a colleague (or dev on IRC), then maybe you need to rethink your approach. **General** *Namespaces*: As you build out any large MVC application, your class names will start to get absurd if you don't. If you eventually start using some third-party libraries, you'll be very happy that you did. *Interfaces*: This is one that too many devs skip, but if you're building from scratch, it really shouldn't take significant time, and it gives you something you can refer to as you go. To list a couple features that really benefit from this, any permissions model (e.g. page + file permissions), or caching (e.g. deploy to one server with memcached, another with redis, and another where you cache objects to files -- a consistent interface here is a huge benefit.) *No Globals*: You sound like you have some experience already, but I'll put this in here for the benefit of others reading this list. Globals should be avoided like the plague. If your value absolutely cannot go into an object, there's an occasional use for static. **Model** *Composition over inheritance*: I'm putting this one first, because it's a technique frequently ignored in older PHP MVC frameworks you may use as a reference. The only class my model classes will extend is called "Model". If you end up with `class HistoricFictionBook extends FictionBook {}`, `class FictionBook extends Book {}`, `class Book extends ReadingMaterial {}`, `class ReadingMaterial extends Printed`, you're going to have a bad time. If you compose models from other models, you'll also avoid the 'god object' where you cram all your entire sites business logic. *Use prepared statements*: Never execute any query with user-supplied parameters directly. Prepared statements are both more secure and a very readable approach to querying your DB. *Use that __construct()*: I suppose this goes for other places too, but `new MyModel($params)` should give you something you can use right away. *async that mysqli/curl*: We're long past the time when every web application only pulled data from either the filesystem or the DB, and that DB was always on the same server. If you have a model which pulls data from a 3rd-party web service, you don't want the whole page to stop rendering while you wait. Big searches against the DB are another case for this, and if your app's on a cloud host with 10 PHP nodes and 1 mysql DB, you'll also want to make sure you get more data in fewer queries. *implements JsonSerializable*: Modern MVCs cannot be designed exclusively to render HTML. You may even want to write a jsonSerialize() upfront for every model (and have a default one in your Model class). This will not only help you write a much more dynamic site (and one you could easily stick Ember.js or Angular.js in front of to load models when you need them without rebuilding the whole page), but it will make it easy should you ever release a public API. **Controller** *Keep all routing logic in its own class*: You don't need anything near as big as symfony, but if I were building a new site, the router is the first thing I'd write. The router should handle everything that needs to decide which controller method to call, and how to extract parameters from the request. If you start deciding if a request should serve json or html inside each controller, you'll end up repeating yourself constantly and have a maintenance nightmare. *Keep them thin*: your controller will call the methods that implement business logic in the model, but shouldn't have that business logic itself. e.g. looking at the jsonSerialize() mentioned in the last section, your controller should simply say: `function getJson() { echo json_encode($this-&gt;mymodel); }`. This way, you're separating building the json, from responding to a web request for the json, which means you could easily write another 1-liner to save the json to disk, save it in a mongodb, stream it to a websocket, etc. *Use REST*: unless you have a compelling reason to use something else, do yourself a favour and use restful controller methods. GET, POST, PUT, DELETE should all do _something_ when called. **View** *Minimize or eliminate all mixed control flow logic*: PHP tried very hard to salvage an already bad approach, by giving us things like `if:`/`endif`, to try and make it more clear where we were in the control flow, but if you're getting confused you may just need to rethink your approach. If it's business logic, put it in the model, and if you're rendering different pages (e.g. 5 different pages for different users with different access levels), use the controller. If it must go in the view, put it at the top on the opening &lt;?php, not speckled throughout your HTML. *Don't mix &lt;?= ?&gt; throughout your javascript*: If your page needs to output some JSON, then `json_encode()` is your friend. Build an array in your PHP first, then simply encode it. The output is guaranteed to be valid json, and will escape accordingly. Too many people start out taking a JSON block, then swapping out one parameter at a time, until they have 30 parameters like: `var myJson = { "first": "&lt;?= addslashes($foo) ?&gt;", "other_thing": "&lt;?=htmlspecialchars($bar)?&gt;", "a_number": &lt;?= 123 ?&gt; };`, rather than build the json from an array `['first' =&gt; $foo, 'other_thing' =&gt; $bar, 'a_number' =&gt; 123]`. Going back to the last tip, this gets especially important when you use control logic in building your json. If you have mixed php/javascript to build that json, and you're using PHP conditionals throughout, it becomes a big mess. Keeping it as an array means you can `$myarr[] = `, `array_filter()`, `array_merge()`, etc. *Everyone has their own opinion on templates*: Don't let deciding what, if any, templating you should use stall your project at any point. If you're writing good MVC code, your entire application shouldn't hinge on the templating implementation you chose. If you're trying to keep your codebase as thin as possible, mixed PHP/HTML is fine, and so long as you didn't saturate your view with control flow logic (especially logic that echoes out end-tags), you should be able to validate the HTML in your text-editor. If it's critical that your HTML be completely standards-compliant, have no whitespace, etc., but you don't want a separate templating library, don't overlook DOMDocument as an option. It's a myth that it's "slow"; it uses ubiquitous, well-tested native libs; if you want to cache page fragments in-memory it serializes/deserializes very fast (so it's easy to push up pieces to Redis, for example.) You can write page templates out as XML (XML is faster to load and imho nicer to work with than HTML's inconsistent rules, also being able to say &lt;i /&gt; instead of &lt;i&gt;&lt;/i&gt; is handy when using fontawesome), and put a namespace on all the elements you want to load data into in PHP. DOMDocument will also take care of most of your escaping for you. On the other hand, its API is pretty daunting. As odd as it is to end a post about MVC with a defence of the much-maligned DOMDocument, hopefully if you made it that far down you found it somewhat useful :) 
no i hear you. that was actually a great explanation. I guess I get worried that there will be a major upgrade to Symfony. I have experienced this with Drupal and Joomla where the upgrade (or in some cases MIGRATION) is a project in and of itself. I have stuff I've written in 2008 that clients still use and are very happy with. It could be but doesn't need to be upgraded. It's simple, has no dependencies. AS long as PHP/Apache is upgraded its smooth sailing. Is it easy to go from one version of Symfony to the next? Any major code rewrites that you had to do? On Symfony's website it says Symfony 2.3 end of support is May 2016. I get that it may not be end of life but that stuff scares me. I feel like it's disingenuous to provide a service and turn around in 2 years and tell a client that they need to redo that whole project because the version we used is no longer supported and getting (what I assume to be) security and enhancement updates. 
that is one thing i really liked about Symfony, the caching built in.
ok thanks
One thing I am going to throw out there is offering to host your clients websites. You can get a basic VPS for a few buck more than it costs for shared hosting and you have full control. Then you can bill monthly for the VPS. I know a lot of hosting companies offer reseller discounts, meaning it would cost maybe $7-8 for a basic VPS, but you don't have to worry about the infrastructure itself. Anyways, back to the point, if you can host them yourself, you can use any framework, module, php version, etc that you want. There is no "One Framework to Rule them All", it is just the right tool for the job. If you have good relations with your clients, you can explain the benefits of VPS hosting and what it has to offer, and really push your clients to switch. Good luck.
&gt; Some PHP web hosting companies do not offer PDO and with clients... I kinda of thing your research there is extremely faulty. PDO *comes* with PHP, it's difficult to disable. And as for the drivers, every distro package installs the mysql PDO driver along side mysqli.... This is also a problem when thinking about how much popular PHP applications use PDO. Mysqli is a badly designed API, you're really really really should just use PDO, it's MUCH nicer.
Might be worth looking at the benchmarks at techempower http://www.techempower.com/benchmarks/ Most of the stuff I see shows PHP/Python being close, but for many of their benchmarks, PHP beating Python. For 'real world' scenarios, I don't put *too* much stock in these smaller benchmarks, but the 'significantly faster' part has not been my experience at all when speaking with colleagues who do more python than I do. I guess it depends on what 'significant' boils down to. 
I wrote on this earlier, but will reiterate here: you're putting your own professional development in jeopardy for the sake of not getting someone to spend an extra $120 for an entire year in their budget for modern hosting (digitalocean.com for $5/month would probably suit you fine). Part of being a professional is giving guidance and having your own standards. "free" hosting is worth exactly what they're paying for it. When something breaks on the web host (DNS goes down, slow transfers, etc) who will your client call? You or the web host? I'm being serious here, not facetious. If they will call the web host and work things out themselves, fine - let them stay with crappy outdated loss-leader hosting accounts - the companies don't give this away for free for nothing - they want upsells eventually. If, on the other hand, they're going to be calling you - which is what I see about 90% of the time - you should be insisting that they use something that meets your standards (VPS, host of your choice, etc). They can budget for it in the project contract. $120/year - most non-profits still spend more than that on coffee/travel/incidentals for their annual or quarterly board meetings. They need to grow up and be professional about their operation. $5/$10 complete VPS means there's no excuse for putting up with outdated crappy PHP hosting constraints. Sorry to double up on this, but it's a hot button issue for me.
Awesome. Thank you so much. This is great info. 
It's not about remembering. *Of course* we've all remembered that equality comparison is `==`. But sometimes our fingers don't get that second `=`. Yoda conditionals are a safety net, since the code will error or not compile (langs other than PHP) if you forget that second `=`
Just a project I started a few years ago and never really got around to finishing. It's been used before as part of a mustache template runtime evaluator and in test suites. Current issues: - Test coverage is okay but could definitely be improved (currently ~60%) - Symlinks - Proper support for perms/ACL If anyone's got any feedback or wants to contribute, go ahead.
I actually just looked at a couple of my clients hosts and it looks like I can just ask the host to enable PDO. DIdn't realize this before. However, for the most part I write with mysqli because I can write it without googling anything. PDO is probably the next thing after MVC that I'll tackle. Not that I don't use it but I should probably use it exclusively. But yea, I have a full time job and people just keep referring me clients for side projects. It's literally zero work. AS much as I'd like to say no to new clients, it's money that I don't have the way I look at it. I was taught that if you have the opportunity to work... then you work (depression era stuff from my grandparents probably). 
thanks. i did just kind of realize this. sometimes you just have to ask to turn it on via shared hosting. update php.ini
yoyo, It's all good. Web programming is another field completely because security is super important, when doing a web app, you have your users credentials at risk. $_GET and $_POST are super globals. They're alright to use, but I prefer to use a request class.. http://api.symfony.com/2.0/Symfony/Component/HttpFoundation/Request.html What I meant by global: sometimes I go in a file, and I see that you expect a variable named $config, for example.. but its not defined anywhere in the scope of this file. It's confusing. In your case, it's not really a global, but acting like it. You have a variable being defined in your config file and getting used everywhere... if you "forgot" and redeclare it somewhere, it would most likely break your app. Sign of a bad architectured app. Both SHA1 and MD5 are insecure. PHP has a password lib now, if not, you have this package: https://github.com/ircmaxell/password_compat Basically, right now, the good way for password would be bcrypt. By using password_* functions, it would be trivial to update the hash once bcrypt won't be strong enough anymore. 
True, the link you provide shows django as being very slow. That is weird though because CMS implementations I've built (in both PHP/Python) I've been able to pull out more concurrency with `django` than PHP; and that's not using `PyPy`. It could just be that I don't do long processing `views`; but either way significantly faster. You can also see at: http://benchmarksgame.alioth.debian.org/u64q/benchmark.php?test=all&amp;lang=python3&amp;lang2=php&amp;data=u64q that the languages are basically the same in performance (with `CPython`). I've been able to get 3-5x more performance using `PyPy`.
When people are *coming to you* you're in a position to put particular requirements in place. You're doing them no real favors by not making any attempt to modernize their system at all, you're just kicking the can down the road and leaving a bigger mess for someone else to clean up. If you have the opportunity to work, and you want to, then work. But bring a degree of professional standards to the process. If a client is not willing to use a modern hosting environment to allow you to provide the best service possible, move on. I'm not even sure my grandparents would have agreed with "do less than your best effort because someone hired you to do half-assed work" Possibly to put literal food on the literal table, sure, but at some point, you put your professional hat on and say "no more".
thanks for this. Extremely helpful. id mark this as "the answer" if i could
Ah cool, thanks for the info. I've been reading up on SQL Injection, and have been amending code to use bindParam and removing the vars from the SQL statements. I'll check out bcrypt for sure. I appreciate your help and suggestion.
BTW, considering the severity of my bad coding, I'm actually pleased I took the time to post this, and take on everyone's suggestions. I also installed a penetration testing application, and found more issue's, which I'll slowly work through.
On the surface of it, there is no real difference. You can use them both with your usual `fopen` and `file_get_contents` builtins. I believe that the implementation is truer to the behaviour of how these builtin functions behave with a unix FS. Some examples: - vfsStream simply [ignores handle modifiers](https://github.com/mikey179/vfsStream/blob/master/src/main/php/org/bovigo/vfs/vfsStreamWrapper.php#L253-L254) (except for `+`) - some effort has gone into showing [where errors were triggered](https://github.com/adlawson/vfs.php/blob/master/src/Logger/PhpErrorLogger.php#L53) in userland code - node types are represented [as `fstat` would see them](https://github.com/adlawson/vfs.php/blob/master/src/Node/StatInterface.php#L17-L29) rather than using [simple types](https://github.com/mikey179/vfsStream/blob/master/src/main/php/org/bovigo/vfs/vfsStreamContent.php#L21-L27) vfsStream works perfectly fine, but if you want to use it more with testing file system operations; the closer you are to a true environment the better.
Java and C++ (and any other language which has enums) absolutely create instance objects of the enums. Enums would be pointless without instances, and the examples you linked to show enum instances being created. Java: // Our enum. public enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } // Test class. public class EnumTest { // Here is the instance. Day day; // Passing the instance to the constructor. public EnumTest(Day day) { this.day = day; } // The main method. public static void main(String[] args) { // Here is where the instance is created. The Day.MONDAY call creates a // new instance of the enum. Day week_day = Day.MONDAY; EnumTest firstDay = new EnumTest(week_day); } } c++ // Our enum. enum Day { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } // Our main method. int main(int argc, const char* argv[]) { // Here is where the instance is created. The MONDAY call creates a // new instance of the enum. Day week_day = MONDAY; displayEnum(week_day); } // Passing the enum instance to a function. void displayEnum(Day d) { cout &lt;&lt; "Today is " &lt;&lt; d; } C# // Test class. public class EnumTest { // Our enum. enum Days { Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday } // Our main method. static void Main() { // Here is where the instance is created. The Days.Monday call creates a // new instance of the enum. Days week_day = Days.Monday; DisplayEnum(week_day); } // Passing the enum instance to a function. static void DisplayEnum(Days d) { Console.WriteLine("Today is {0} ", d); } } PHP: // Our enum. class Days extends SplEnum { const Sunday = 1; const Monday = 2; const Tuesday = 3; const Wednesday = 4; const Thursday = 5; const Friday = 6; const Saturday = 7; } // Here is where the instance is created. The `new Days(Days::Monday)` call creates a // new instance of the enum. $week_day = new Days(Days::Monday); displayEnum($week_day); // Passing the enum instance to a function. function displayEnum(Days $d) { echo "Today is {$d}"; } I could go on and on by giving examples from every language that supports enums, but the simple fact is every language supporting enums is designed so *instances* of the enum are created. The enum feature would not be very useful otherwise. Granted, in some of those languages the value of the instance is an integer, but the point is the compiler for each language enforces type correctness for you. You shouldn't be validating enum values manually. The StackedOverflow question doesn't really answer the question "How do you build an enum?" The author has solved OP's particular problem, which is "How do you encapsulate constants in a class?" The answer is a work around to PHP's lack of enum (though the author does suggest using SplEnum) and it's not a very *good* work around. So I'm sorry, there's only one school of thought on enums, and you're simply mistaken about the purpose they serve. All your code does is encapsulate constants into a class for the purpose of namespacing them. I like your code, but it's not an enum. It does the same thing as my [ConstantsTrait](https://github.com/headzoo/core/blob/master/src/Headzoo/Core/ConstantsTrait.php) trait, which is used by my [AbstractEnum](https://github.com/headzoo/core/blob/master/src/Headzoo/Core/AbstractEnum.php) class.
&gt; Some PHP web hosting companies do not offer PDO These hosts are total crap, and you will never have anything resembling a good experience with them.
Great work. But is there any reason you decided to write this despite the existence of [vfsStream](https://github.com/mikey179/vfsStream). I saw the difference that you mentioned in response to /u/wishcow. I am not actually asking about the difference, but about the reasons that drove you into writing this. Another thing, not sure if relavent, But I think there are some cases or some libraries that does not respect custom streams. For eg, you wont be able to open an sqlite database from a custom stream like this. So if the file that you want to mock is supposed to contain a sqlite database, you wont be able to use this.
I bet you're great at parties. 
good info. thanks
&gt; But Symfony clearly states that there is an end of life in a year or two Nope. You might be looking at Symfony 1. At any rate, you're going to face "support" issues with anything, the question is what is the quality of the code and who fixes the issues. With a popular framework, the code quality will be much higher and the number of bugs found and fixed will be as well. In other words, *you* don't have to fix the bugs or maintain a lot of the code. &gt;And there's 10.3megs of files zipped in Symfony standard download. So what? If you're only loading what you are using, it could be 100MB and it wouldn't matter.
Not every file in a library is loaded with every requests, but only those files that contain the Classes to service that particular request are loaded. 
Alright, he gave it to me. Talk to /u/soBoredAtWork and see if you can get him on board.
I agree 100% with mgkimsal on this. A client that can't afford a host is a client that should have at most a few plain HTML pages and a form that sends an email, because they clearly can't afford much of a site either. I've worked with a lot of clients like this and the end result of all of that is that they are the worst clients to work for. They are generally have the lowest budgets, the highest expectations, and they send more work your way that is the same. It turns into a never ending spiral of bottom feeding where you just do mundane shit over and over again not learning anything. They will pay the cost one way or another anyway. You want a cheap host? Ok, I'm going to charge you more because the cheap host is a pain to work with. You call me when your site is down? Yep, I'm going to bill you for that too. At that point you might as well have gotten a real host. The bottom line is if they can't afford $10 a month it isn't a business or non-profit, its a disaster fueled on hopes and dreams and you should stay away from it.
I have my moments... Related story: I had someone ask me to come to the store and help them choose a new computer. We get there and I then get told "I don't want an Acer or a Dell or an HP. June said Dells are not good, Carla said Acers are too hard to figure out, and I don't like HP". 80% of their inventory was one of those 3 brand names. I asked "why did you ask me here for an opinion and help?" Got some mumbled answer that didn't make much sense. Your post struck me as a bit similar. I see others have answered in probably somewhat more friendly terms, but... "I don't want to learn PDO"... rubs me the wrong way. I don't even care for it myself, but it comes from having used it for several years and understanding the pros and cons. You already acknowledged that you were against CSS, and now see benefit in it. The "no framework, no PDO" stance strikes me as very similar. Dig in to something and just *produce* with it for a while - you'll get your own opinions which will be far more useful to you than almost anything you can get from reddit posts (including my rants). 
I used to think like this, and I know my boss did. "Whatever keeps the business afloat". The thing is you have to have an end game. Just churning out brochure site after brochure site isn't an endgame, its a treadmill that you either have a heart attack on or you get off of it.
This plus if you're using the opcode cache everything is already in memory so its micro seconds away from being included.
Learning a framework is hard in comparison to just churning out code haphazardly with no conventions to adhere to. People usually seem to have an aversion to frameworks because they can instantly be productive without one. They just don't realize the trap they are setting for themselves. "Had I known then what I know now" my path would have been tremendously different and would have started with a Framework.
You can return the array and modify it (as long as the method isn't doing anything else). class OriginalClass { function form() { return ['stuff', 'more stuff']; } } class NewVersion extends OriginalClass { function form() { return array_merge(parent::form(), ['new values']); } } Or just create a property on the class and modify that.
Not quite... opcode caches still do a `stat()` call to determine if the file has changed so you still have the overhead of a systemcall for *every* file you include even if it's cached. With large projects or frameworks disabling time checking can lead to a noticeable speed-up.
There is also filesystem cache, which speeds things up (on Linux. I am pretty sure there is something similar in other OS's which can run PHP). 
Yes, sorry about that. Docs in development too. It's a PHP analog of Capistrano(i don't want to install ruby/gems for my php projects) and analog of Capifony (now i deploy my Symfony projects with Deployer). I'm looking to people who may be too interesting in creating and using tool like this. 
Everything about PHP, the filesystem, disk and everything between and around is highly optimized to make this fast. Opcode cache makes it even faster.
&gt; Define 'fancy'... Er, web pages with a lot of JavaScript.
You can turn that off though, and if you're running a production web server with it, you should have it turned off and just clear the cache manually when you change code. It makes it even faster!
You can and should also use the composer dump-autoload --optimized command for production which will create a class map which maps every known class to the file that contains it. This makes loading of any class file as fast as a hash table lookup. This is recommended for production sites. https://getcomposer.org/doc/03-cli.md#dump-autoload
Strange, I thought that was the default.
In reality, page load time is negatively impacted - just not by very much in most cases. There are ways that make it impact pages less though: * Lazy loading: Classes aren't loaded until you ask for them. * Opcode caching: If enabled, you don't necessarily even load a file from the filesystem, and if you want it won't even stat files to check for changes. * Standards allow for minimal processing, or using the optimised autoloader that Composer provides, you just use a classmap which takes almost all processing out of the equation. Also, consider the alternative. You'd just be requiring the files anyway, would you expect it to be slower / faster than composer? Would you expect it to be impacting the performance of your website significantly?
&gt; A comment that says place holders in a query is to "let pdo know what things to quotes for" was at 14 point at its highest. I know technically that isn't what happens, but surely that's a perfectly fine way to explain the concept?
What happened to the Stack Overflow link in the sidebar? I'm sure there was one at one point. And I know this is unpopular, but why not just encourage people to use SO instead of another subreddit? I mean, those subs are never going to be as good as SO for getting good, fast answers to questions.
Because the code being executed is crap?
Several things here: - **autoloading**: composer autoloads classes, which means only classes that are actually used in the current request are loaded - **finding files**: in production, use `composer install -o`; Composer will scan all files and build a class map, i.e. an array when the key is the class name, and the value is the file. Then to autoload a class, Composer can find the file name extremely fast since it's just accessing a value in an array - **requiring files**: PHP can cache some operations behind the `require` (reading and parsing the file, not actually running the code though), which is enabled by default since PHP 5.5 (that's what we call an opcode cache)
Could the mods of this subreddit change the description on the sidebar? Specifically: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help…
I am sure php.net does not qualify as a web app by that definition..
So, I'm going to agree with @ratbastid, I get what you are trying to do, but there is no docs, so it really doesn't do me any good at this point (there is not enough there to even give me an idea of why your solution is better than any of there other solutions), so I would have a hard time answering the question of wondering if "people would be interested". That said, I think that regardless of what you have built, I would not be interested. I like the idea of a "pure php" type deployment system, but I think that there are already so many deployments systems (Capistrano, deploy.io, Laravel Forge, Magallanes, etc) that exist, that another one further dilutes existing solutions. I think that is something that the PHP community (at large) needs, more "standards' for solutions. For example, when you deploy a Ruby project, you use Capistrano. What do we use for PHP? There are at least 5 projects that I know that do deployments. I think that we as a community need to back 1 solution (don't get me wrong, there is a time and place for forking a project, but we aren't at it). Composer has done an amazing job at bringing package management for PHP, and I think that we (the PHP community) need to start backing existing projects to make a standard (BTW, it's a two way street, certain project leaders, need to remove a certain appendage from a certain orifice as well). I truly applaud you for trying something new, it's good to try something new and experiment, and perhaps this may very well be a better, and very simple solution for deployment (which has many advantages of other more complicated solutions..*cough* *cough* Capistrano *cough*). But, there are already existing "pure PHP deployment solutions", maybe you could contribute your thoughts/code to existing projects, again, like Magallanes, or another deployment system? Just my thoughts.
|why **doesn't** composer autoloading significantly affect page load times Either way, your comment doesn't really contribute to the discussion.
Autoloading doesn't mean "load everything". It is a way for the system to load just what it needs to load only at the point at which it is needed, and no sooner. 
This is not a versus thing. We are not competing with them, we just feel that /r/learnphp would be more natural in capturing traffic. What do you think a percentage of the people asking questions here do? They type in /r/learnphp into their URL, see no one is there, and then come here. I know because I was guilty of this once upon a time. The natural capturing of traffic should relieve this subreddit of some unwanted questions.
You're technically right, but the service container provides the benefits of singletons, only one instance, but not the coupling that comes with invoking a static method on a set class. So, best of both worlds. 
PHP autoloaders load classes on a need only basis. If your code doesn't instantiate a specific class then the code file for that class will not be loaded into memory. The only thing the Composer autoload does is, make this autoloading process highly optimized. 
I'm one of those people, what is the setting called I need to disable on prod? And how do you manually clear the cache?
 &gt; Contributions are accepted via Pull Request, but passing unit tests must be included before it will be considered for merge. You can do my work for me, but first you have to rub Tabasco in your eyes. North Korea style development.
Yes since it's a class map for every class/every file. PSR-4 doesn't list every file, so nothing has changed regarding this.
Don't feed the troll.
Good point.
Ruh roh. Edit: I assumed you were kidding. If you're not, then I think there would have to be some compelling reason to change besides the name, especially since it already has subscribers.
`apc_clear_cache()` or `opcache_reset()` For APC setting the INI value `apc.stat = 0` will disable per-request stat. Opcache is a little bit smarter, you can use `opcache.validate_timestamps = 0` for similar behaviour to `apc.stat`, or tweak `opcache.revalidate_freq` (which defaults to 2 seconds)
Hey, other mod here. Please see my comment above. TL;DR: I don't really care, but don't really see the point in migrating over. I think the purposed of the subreddits needs to be better described.
its not that i dont want to learn pdo or a framework. I mentioned php-mvc which is a framework and it now have up and running. Prior to the post I specifically wanted something that used mysqli, partly because that's what I know best [can write this without looking things up]. The concepts are generally the same, the syntax is different and PDO has much better prepared statements among other things (PDO is generally better). I know this and I appreciate you trying to steer me toward the better option. Though whatever you want to say about mysqli, it's not like it doesn't work. Technically it's slightly faster performance-wise than PDO but I still agree PDO is better. As far as frameworks, I just wanted [for now] essentially the lightest framework possible to learn on. I'm a lot more interested in learning the design pattern than a framework at this point though to not re-invent the wheel, I wanted a slim framework to start from so as not to confuse myself with hundreds/thousands of files. But once I understand the design pattern (I understand the basics) and am able to apply it, I'll move on to choosing a framework that suits me best long term. I do appreciate your help. Me posting here should indicate that I want to learn these things. There's only so much time to learn, do my day job, complete side jobs and have an actual social life. I just need to learn on my own terms. I came around on CSS in the early 2000's, and while how I currently code is not as bad as putting &lt;font&gt; tags into HTML as I do separate a lot of presentation from business logic, I realize I do want to learn MVC and have wanted to for some time. So this is me doing that. I've learned a lot in the last two hours using php-mvc and I'm using PDO. So I'm hoping you'll be able to sleep tonight [jokes]. Thanks again
Reply: http://www.reddit.com/r/PHP/comments/29zmeh/rlearnphp_is_open_for_business/ciqa2ao
No, they won't. I've never heard of that convention and I would bet the vast majority of people haven't either. Putting "learn" on the front isn't something I wouldn't intuitively do, either; if I need help, I'm going to look for something with the word "help" in it. It's the first place to look for... well, help, in any application, language, anything. If I need a list of commands, first thing I do it try executing something with a --help flag, and a lot of times it works. "Learn PHP" sounds like it's for tutorials.
Well, how many times to go to just type in the URL in the first place? Not often, right? I'm sure you probably wouldn't do it unless you've recognized a pattern and are sure something's there. People are learning the naming convention from the other programming subreddits because they've recognized this pattern. I know that's what I did, anyways.
Is [this](https://github.com/RobinMalfait/Laravel-auto-form-generator) what you were looking for? I've never used it, but Googling "laravel 4 form generator" yielded that as the first result.
I [think](https://github.com/Anahkiasen/former) this might be what you're looking for might be wrong.
https://phpbestpractices.org/
I think I understand what it does? ... Does it allow me to run deploy.php to do my setup and install? I don't know... I peeked at a few commits and they look decently written. The documentation is lacking and doesn't tell me how I can use this in my upcoming projects. Id love to help and contribute but to what? Nothing states what you need help on. 
I understand. I'll write docs and come back to reddit late.
&gt; Since /r/phphelp[8] is not consistent, it’s very unlikely people will try to search for this subreddit as a uniformed resource. And since the only real reference to the sub is in our sidebar, it can be assumed /r/phphelp[9] is not as likely to be found by new people seeking help. I think this is a very shakey assumption; the primary reason is that new people looking for help aren't aware of conventions in the first place. Someone looking for basic help with PHP (which culturally, would often mean they're a new programmer) I'd say is extremely unlikely to be aware that help subreddits for other programming languages usually take any particular naming convention.
In the HTML, give the name attribute brackets to indicate it's an array (&lt;input type="text" name="foo[]"&gt;) and then you can reference them each in php as an array foreach ($_POST['foo'] as $bar) { echo $bar, '&lt;br&gt;'; } Wrote on my phone so I apologize for bad formatting
Is PHP your first language?
And actually, since I made you a mod, you can see it for yourself. Go to traffic stats in /r/learnphp and that's pretty much evidence of it. Learnphp was a dead sub, no one promoting it or anything and it generated 40+ uniques per month every month. And some months we almost got as high as 80.
It seems consistent with the naming conventions within php itself.
You can build a front-end without JS...
Ok, But how much more work is required by the autoloader if I do not use a classmap. For eg, if I am using psr-4 autoloading, then autoloader can easily infer the path to a class file from the classname and the top level directories specified in the composer.json file. So as I see it, the difference in processing is one hash-map lookpup (when using class maps) vs one hash map lookup + a string concatenation (with out class maps and using psr-4 autoloading). So what is the big deal? 
Did you really just go through this entire thread and downvote everyone regardless of what they were saying? Edit: You actually missed my comment above. Might want to go downvote that too.
&gt; Did you really just go through this entire thread and downvote everyone regardless of what they were saying? Edit: You actually missed my comment above. Might want to go downvote that too. I haven't downvoted anyone, except for that comment... This is what makes this sub terrible; quality like you provide.
Mmm-kay. I believe you did. Also, you used that semicolon incorrectly. It should have been a colon. The ellipses were incorrect as well.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
You don't need to know javascript to know HTML.
Not everyone uses the website. I use Redditr which doesnt have a sidebar…. just fyi
Like I said several times in this thread, the description of my repo reads and always read "A workaround for the missing php enum type". I never said and I don't think my code was an enum. Same thing for yours. And I agree Regarding the instance debate. I can't see how the things you show the code you provided are instances. But maybe I have the wrong definition of an instance. For me, an instance is an object create from a class. I sense you might have a broader definition but I can't imagine how you would describe that. EDIT: maybe I do. Maybe for you, an instance is something that has a type that is user defined.
I'm guessing that if you have many PSR-4 paths with the same prefixes set, then each would have to be tried to see if the file is under that one. But yes, doesn't sound like dumping would make PSR-4 autoloading much faster usually.
Oh OK, I thought learnphp was the new phphelp? That's the whole point of this post right?
Neither does the mobile site. But I think most people know that they need to look at that to see the rules for the sub.
Jeffery Way's Generators should do what you want. https://github.com/JeffreyWay/Laravel-4-Generators
No
&gt; What do you think a percentage of the people asking questions here do? They type in /r/learnphp into their URL, see no one is there, and then come here. I doubt more than a couple of people have ever done this. First you'd have to know that there are many other "learnX" subs, which I (as a long-time reddit user, and programmer of multiple languages) had no idea existed until it was brought up in this sub. Most people are likely to just search PHP in the search box or list of subs until they find something. Then maybe look at the sidebar to check the rules, where currently they would see phphelp (obviously this can now be changed to learnphp). The fact is, we are still getting newbie questions on /r/php so none of these solutions are currently working.
This looks promissing. I will definitely take a good look at this
Yes I'm using this already, perhaps I have overlooked some functionality. Thanks!
Some people need to realise there is such a thing as text being too big. The person who runs this blog is one of them.
I can't speak for the other platforms but the Drupal information here is completely wrong: * Low Learning Curve: no, Drupal is very hard to learn because the Drupal ecosystem is vast and it uses its own peculiar procedural API which is unlike any other platform. The future Drupal 8 version will be much easier to learn though. * Oversaturated Job Market: Drupal developers are in very high demand and it's hard to fill positions. I don't know a single Drupal developer who is not fully booked for months to come. * Low paying entry level jobs: No, because of the high demand even the entry level jobs are paying much better than average. * Drupal Developers are expected to be a Jack of All Trades – Frontend and Backend: Not at all, because Drupal is so complex it is highly specialized. You won't find practically anyone who is well versed in backend as well as frontend. Even those are highly fragmented.
And me. "web development" is such a broad term. Before I started using PHP, I had done HTML stuff by hand for about... a week. So yeah, I 'knew' some HTML, and had done some 'web' stuff, but I essentially learned the bulk of each in parallel. Simply having common includes to reuse snippets, even if I didn't quite know the best way to structure things, made experimentation much much faster than 'by hand' HTML. Per the note below, "building a front end" is a very loaded phrase. By just including an open html header, and repeating some table rows, then including a footer, you've 'built a front end' plenty useful for a variety of tasks. Progressive enhancement from those basics is how most people start, ime, and it's part of the reason PHP continues to be so insanely easy for people to pick up - take a block of HTML, insert some PHP, reload, see what happens, rinse, repeat. 
I like it, it's big.
Watch his quick video on it. I'm pretty sure he shows generating a form. 
Thing to remember - APC and Opcache have separate caches for each SAPI (so CLI, mod_php, fcgi). You can't just have a command-line script that calls `apc_clear_cache()`. Typical implementation is: 1. Command line script creates a file in the web folder * Something like `&lt;?php if ($_SERVER['REMOTE_ADDR'] === '127.0.0.1') { apc_clear_cache(); }` 2. Script makes a cURL request to that file. 3. Script deletes the file.
You can use [symfony form collection](http://symfony.com/doc/current/cookbook/form/form_collections.html)
Version 2 no longer generates forms by the way
I also tried to find something alike, but resorted to [anahkiasen/former](https://github.com/Anahkiasen/former) library. It's an awesome piece of work to quickly generate forms with twitter bootstrap structure complete with validation and the works. Definitely a timesaver.
Ah yup. See that in the readme. Please note that version 2 of this package removed support for a couple of generators, such as generate:form. If you'd like to continue using them, stick with version 1.1.
It's like people just googled "PHP enum" and pasted that without even researching it.
I like to do a jquery onclick that assembles an array or comma deliminated string for me to parse in php.
Zend is a crap framework, just because it's got a Java feel to it doesn't make it an enterprise framework, the fact is few use it and those who do really hate it. In my 10 years the only site I worked on that used Zend was a startup who failed because they couldn't find a developer who would touch that steaming pile of shit with a 10 foot pole. Also, large corporations rarely are creating new enough sites to require choosing a framework, most are updating an existing site which is usually custom built. Symfony is also crap, but popular crap. This is a framework you will find someone using and you will probably also get people who disagree with me here, which helps illustrate my point about why it's popular. The fact I think it's crap probably isn't shared by many, but noone can deny it's popular and gets the job done better than Zend. You are not wrong about laravel being new, but new companies start all the time and it's not impossible to find a company either using or wanting to use laravel. It has a huge amount of popularity which should say something about it actually being used. WordPress is fairly accurate, you missed the fact that WordPress is one of the shittiest written open source projects in existence, this is why "php elitists" hate it. There is no consistency to it and an insanely high amount of security vulnerabilities in it. Drupal isn't accurate at all, it's got a huge learning curve and a crappy api as well as some of the biggest wtf worthy design decisions like this: https://www.drupal.org/node/547518 Drupal can be flexible, but you run into the problem where some things end up being way harder to integrate than they should because of ideas not really thought out well enough. Also most work requires a bit if extra work to get things done compared to a framework. If you really wanted to show off a decent article find one that actually explains to people what a cms and framework are, rather than this shit that implies that everyone should learn zend for the money. 
Although this is PHP specific and i'm getting into Python i like the 'Sample Projects' checklist this can relate to any programming language so i'll see what i can check off on here. Obviously looking at the Python stuff i can't really comment on the stuff above it being PHP Specific :)
You should never be able to decrypt a user's password. Only use a one-way hash for storing passwords. You're looking for justification for terrible security decisions, but the correct answer is to fix your design. 
I haven't looked too deeply into Zend, but I'll call you out on saying Symfony is crap here. Especially when you go on to praise Laravel in the following paragraph (Laravel is built on top of Symfony). 
Came here to say this. Given how far out of whack this info is I don't have a lot of confidence in the rest :/
&gt; "The goal of this advice is to get the new developer into the job market faster." For this purpose, the article is okay in that it (1) attracted your attention, (2) offers *some* details about *some* specializing options, (3) encourages picking a specialty as a mechanism for learning, and (4 - most importantly) suggests practical activities for learning (the list at the end). I wish that this author had stressed the existence of communities for each of the specialties. For a new developer (new in general, new to a language, or new to a framework), the community of developers *may be* one of the most important tools for learning and for getting hired. (I say *may be* because some people are fine or better off on their own.) We have an amazing, helpful, and cordial community in the Magento world, and it has been a benefit to the developers and to the popularity of the framework itself. For selfish reasons I would also like to mention Magento (disclaimer: I work for eBay), though not as a starting point to learn PHP if you are new to PHP. There is a *lot* of opportunity for developers who know Magento, but the fact is that it has a unique and Java-esque approach to MVC with a lot of conventions which are tough to grasp while trying to learn a language. We (both the community and eBay) are working on the learning curve, especially for Magento 2, but flexible, module eCommerce for a broad audience is hard no matter the language or framework underneath it. For general ability in the language - in addition to the exercises listed at the end of the post, I'd recommend two more things: * Start preparing for Zend PHP certification. There's a lot of non-practical stuff in there, but it can be used as a comparison tool. * Do some code kata in PHP - especially with other developers! Good luck, and don't let the occasional negativity you find here and in various communities get to you. If someone can't offer anything but acerbic commentary on your efforts, then I hope it's easy for you to ignore them. 
Ubuntu does this quite frequently too... Symfony isn't stopping the development for their project, they are simply not supporting older versions. Which, really should be fine, as the LTS's should be bug free by EOS. 
I would definitely say don't start with Magento... Throws on a huge difficulty curve on top of the already difficult zend curve.
You sir.... You give PHP a bad name.
I am aware of the best practices for dealing with passwords. I'm not looking for justification I am looking for the best way to handle this and have come to the conclusion that there may not be a perfect way to do it. &gt; the correct answer is to fix your design. Okay what is a better design that accomplishes what I am trying to do? 
yes....?
Yeah, the text size was nearly perfect. I have a 24" monitor that sits about 2 feet away, and I'm constantly using the zoom feature to make text bigger. Even reddit is zoomed to 125% for me to be able to read it comfortably. 
That is sort of what I am doing but I am creating a user provider based on the crappy third party web application.
Not sure if you are able to fix the crappy system -- if so, just fix it. If not take a look at OAuth or something similar. Also, you can let people log in with a single use key - they hit a button, a URL is emailed to them, clicking on the URL will log them in and set a SESSION var, while that session var is active they are logged in. Closing the browse/tab will log them out (as well as a logout button,) to log back in they'd get another email. Not too bad if only done once a year. Otherwise just fix the crappy system. You could point the crappy one at the good database so they share authentication .... or crappy system could ask good system if USER is logged in. Kinda like OAuth does (like 'log in with Facebook') but this could all be done automatically using a bit of JQuery, 302 redirects etc.... AJAX request to 'is-user-logged-in.php' this then checks DB::users-&gt;last_logged_in (DATETIME) and if it is less than 1 hour ago - then return {logged_in: true} else redirect them to the login screen? Show the screen in an iFrame? Then repeat the ajax call?
Crappy system is a closed source proprietary java application. It does not integrate with any sort of identity management solution that is external to itself. Basically the only control over it that I have is that I can read/write to the database and I can embed stuff in the wrapper html. FYI - Closing a browser tab doesn't close a session, you usually need to exit the browser entirely to trigger that.
I figured i'd need to add more here about my opinion of symfony. First off, I like PHPUnit and am glad the entire community has rallied behind one testing framework, so nothing about that to mention for me here. Onto Symfony and Doctrine(and twig... since they all make up the "Symfony" experience). For starters, the fact symfony allows annotations, yml, AND php for configuring the same elements leads to all sorts of performance issues and unnecessary slowness. You literally NEED cache just to develop, i understand the point of cache to run your code faster in production, but if your framework requires a cache to load a page fast enough in development, it's time to rethink your priorities. Annotations should be nixed entirely in favor of either straight PHP or yml versions, based on what sensio felt was best for symfony. I've found projects that under certain conditions require 15-20 seconds per page load on my VM. This is a VM running from a Mac OS X host machine with an intel i7, 16gb ram and SSD... not a slow machine by any standard, but symfony cannot figure out their page load problems. I ended up solving said issues with help from the /r/symfony community here. Secondly, Doctrine. I understand they wanted to seperate the concerns between an entity and repository. I understand the logic behind it. But I don't personally agree with it. I feel it creates an unnecessary amount of work and restricts you from some awesome things you can do in laravel: User::find(1)-&gt;articles()-&gt;where('date', '&gt;', $someDate)-&gt;get(); Also with doctrine, I hate that you'll be using a findBy() repository call in your controller, only to discover that you need to add an extra parameter, but rather than x = y, you need x != y or x is not null. Now you must cut out the findBy call, make a new repository function, rebuild everything in a query builder, test, add your single where you wanted initially, and cry about wasting 45 minutes to add "field is null" to a query. It's completely bullshit to build so much into doctrine(query builder, DQL, etc) then completely fall flat on something like findBy. Thirdly, Twig. PHP at it's heart is a great templating language. Yet Sensio felt the need to look at python and copy their templating language and brand it as twig. Yes, there's some really cool stuff it adds in with blocks and things of that nature, but as Taylor Otwell showed us in laravel, the same can be done with a minor amount of syntactic sugar applied to straight php. So here we area again scratching our heads trying to remember the symfony version of that common command you wanted to run to manipulate the text of some variable.. only to realize, that it doesn't exist. Now go ahead and spend an hour googling, and implementing some silly class then including it in either an annotation, yml, or php somewhere(UGH) to have that class load, to respond to some random function call, to proxy to a regular php function so your twig code can now finally use some stupid function that should have existed anyway. Meanwhile the rest of the PHP world already moved onto and solved greater problems by just writing some damn php code in their views. Finally, forms. I realize these are an optional component, but they are a big part of many symfony projects and absolutely one worth mentioning. Anyone who's worked with forms can attest that the form library is insanely strict, so strict that it basically tells you to fuck off if you wanted to do something your own way. Forms embeds itself into so much of the process it breaks MVC 9 times over, and is just a huge mark against symfony. My last point about symfony, is actually a positive one: I've never seen another framework allow for you to seperate your own components into bundles in a sane and reusable way line symfony does. My hat's off to symfony for providing this ground work and it's something that I wish more frameworks would take note of(including laravel). However, I still stand by what I said, and I've now articulated my points.
I'm allowed to make if statement cock ups in comments :)
You slam on frameworks when you dont seem to have any experience using them. You seem to have given one look at Zend, and decided to sit in a corner and cry, instead of bucking up to a challenge and learning something. Zend 1 was a great framework to learn MVC, and Zend 2 has been a joy to learn. Symfony, the framework i've been using for the last 3 years, has been phenominal. The pieces are coded very well, and are a joy to use without the rest of the framework. Laravel is a house of cards made for people who don't want a challenge, and just want shit to get done fast, without care for growth. Hows that?
I talked in depth about my [problems with symfony in another comment on this thread here](http://www.reddit.com/r/PHP/comments/2a1a8q/so_you_want_to_be_a_php_developer/ciqpcup). Yes Laravel uses symfony components, but if you notice all my gripes with symfony don't exist with laravel. It solves number 1 easily, it doesn't use doctrine, twig, or forms, which solve the rest of my gripes. And I think it was a wise idea for laravel to adopt in components from another popular MVC framework. While I don't like how symfony works there's no denying it's well written, and Taylor Otwell saved himself a ton of time not having to write his own request/response library, or any other large number of libraries to make laravel. He was able to focus on more important things(eloquent and the query builder), which I think is part of what's allowed laravel to grow so quickly.
Two of the three things you mention (doctrine and twig) are things that would make laravel better. The pattern that Eloquent uses is a joke, and i still dont get why blade was made....
&gt;You slam on frameworks when you dont seem to have any experience using them. You seem to have given one look at Zend, and decided to sit in a corner and cry, instead of bucking up to a challenge and learning something. Zend 1 was a great framework to learn MVC, and Zend 2 has been a joy to learn. I've used many, and have assisted in writing one of the popular ones(at the time) myself, I'm not interested in divulging my identity, so I won't provide proof here. As I mentioned, I worked on a Zend project which was a startup. And now that I think about it, i've technically worked on two zend projects(1 was magento) though both were startups. Zend overcomplicates things and I have never found it to be a joy to work with. There is so much over engineering to solve simple problems that it seems to take 10 times longer to get anything done, especially when there aren't enough docs to actually help you figure out how to do what you wanted to do.. I've easily invested 6-8 months of full time work into these projects, and while I'm nowhere near expert, I've definitely used it enough to form an opinion. On top of this, zend has no real clear way of helping you write easier and cleaner code, it feels like 90% of the code you write is to wrangle zend into doing what you wanted to do anyway, rather than getting the hell out of your way so you can get shit done. &gt;Symfony, the framework i've been using for the last 3 years, has been phenominal. The pieces are coded very well, and are a joy to use without the rest of the framework. I've been using symfony over a year now as apart of my full time job, and [i made a pretty extensive post elsewhere in this thread regarding my problems with it](http://www.reddit.com/r/PHP/comments/2a1a8q/so_you_want_to_be_a_php_developer/ciqpcup). &gt; Laravel is a house of cards made for people who don't want a challenge, and just want shit to get done fast, without care for growth. You're welcome to your opinion, and I could see that being a problem on a larger site from an inexperienced developer, but it's by no means a fault in laravel. Laravel offers you the a[bility to utilize composer packages with out all the fuss of composer](http://laravel.com/docs/packages)(until you're ready for that stage of development). I don't see how it's the fault of the framework when people chose not to do that, just as it isn't symfony's fault if someone ignorantly wrote everything in their app folder and never made any bundles. &gt;Hows that? you're learning how reddit works, good job. I actually upvote you despite disagreeing with you, since you're contributing to a conversation.
again you are making statements with no real substance, you're just giving basic opinions with out a real why.. why should i even bother responding to this? Did you really want an answer or just want upvotes from people you think will agree with you?
You mention the **NEED** for a cache like it's something you have to set up and maintain just for development, when in reality, it's a folder where symfony dumps stuff, that you don't even have to care about, because it gets invalidated automatically (in the dev environment). The various configuration formats do not incur any kind of performance overhead, because they are cached after the first parse. 15-20 seconds for per page load is obviously exaggerated, especially on an i7 with an SSD. If that's real, that's a developer issue, not a framework issue. Link the /r/symfony thread. The form library allows customization in tons of places, it's very very far from strict. It's more like you are spreading bullshit than sharing your opinion.
&gt;You mention the NEED for a cache like it's something you have to set up and maintain just for development, when in reality, it's a folder where symfony dumps stuff, that you don't even have to care about, because it gets invalidated automatically (in the dev environment). The framework doesn't function with out caching working, that's a need. &gt;The various configuration formats do not incur any kind of performance overhead, because they are cached after the first parse. Until the random problems start happening and you have to clear cache again. The fellow devs on my team got sick of the symfony cache clear and wrote their own rm -rf app/cache/* command which works beautifully. &gt;15-20 seconds for per page load is obviously exaggerated, especially on an i7 with an SSD. If that's real, that's a developer issue, not a framework issue. It's not an exaggeration. Here's a [post from me from a month ago](http://www.reddit.com/r/symfony/comments/26a0i2/speeding_up_my_vm/) where I detailed my problem(and found my solution). If i'm making an outrageous claim to "win" an argument, then why do I have proof from a month ago? I had already stated i received help on this issue, including what subreddit i asked in. I'll also be happy to screencast it and prove to you the problem is real. &gt;The form library allows customization in a tons of places, it's very very far from strict. [Already answered a question on this one ](http://www.reddit.com/r/PHP/comments/2a1a8q/so_you_want_to_be_a_php_developer/ciqpuj2) &gt;It's more like you are spreading bullshit than sharing your opinion. Right, so far you're 0 for 3 trying to call out my claims. Who's the one spreading bullshit now? 
It handles it exactly like it's described in the docs. http://symfony.com/doc/master/cookbook/form/dynamic_form_modification.html#cookbook-form-events-submitted-data Before you complain that this is too complicated for you, link me how any other framework handles it.
Yeah, the framework needs a folder where it can write. If you have random problems popping up, you need to find out what the problem is in your environment. Your fellow devs having random problems != the problem is in the framework. If there were really randomly appearing cache clearing problems, the internet would be already full with it. The same goes for your load times problem. It seems it has more to with shared folders. It's unfortunate you encountered these kinds of problems, but they are very far from being general enough to declare the framework crap. I answered your question about the form library, you failed to read the docs.
After a quick Google to see how people handle the problem you've presented, it doesn't seem to hard to fix. I'm sure there's other cases where Symfony/Form may get in the way of itself but this one didn't seem so bad. I found [this article](https://www.adayinthelifeof.nl/2014/03/19/dynamic-form-modification-in-symfony2/) which explains how to use events to populate the data to load cities based off a state/province.
[Serious] I'd like to hear of why you say that about Drupal. I've not used Drupal, but have fiddled with Wordpress and worked with Joomla. I'm curious here. :)
No experience with Drupal, but I've heard from many that it's substantially better than Joomla and WordPress. But even if Drupal is 100x better to work with than WordPress, I would still rather get kicked in the head by a horse than work on a Drupal site.
&gt; UI/UX - Yes PM’s will expect you to also be a designer for some reason. And you're doing the exact same thing as your PM expecting designers to be expert in UX.
Pretty sure it does work without caching. It'd be slower, but it'd work. If you are clearing cache that often, you might be doing something wrong. And holy shit, you are blaming SYMFONY for the NFS issue? That would happen with a lot of frameworks.... Do you know why it happens? Not using NFS is definitely a developer issue. So, gonna go ahead and say you didnt negate any of his call outs. Still calling bullshit on you. 
Nothing new, heres something free and basic to get anyone started: http://sidigital.co/blog/disconnect-your-frontend-from-wordpress
Ok. that's a potentially valid reason. Whether its true or not all depends on the context. In situations where I used this solution it was perfectly called for due to the way the form was built. If you don't need/want validation before the form data is posted then of course you can just use a pure html solution. Am I still one of the minority who thinks you should write a response like that when you downvote someone for a reason like that? Anyway, I was actually referring to the comments above that called to "Downvote them all!" for helping someone. This may not be a support sub but in my mind a helpful response along with other posts directing the OP to a sub better suited for such questions is a good thing.
You have those benches on hand? Been on a team of 5, doing weekly pulls (once a week, one big pull, one cache clear), sounds like a DEVELOPER issue to me. Zend and Magento will have that issue, Laravel will have that issue. Any project that has a large number of dependencies will have that issue.
Check with legal of whole will be liable in case of a breakin. Make sure that **you** will not be liable, as you are storing the password. The vendor might and will claim that you have hacked their systems. Do not forget that people have been sued for access publicly available data via crafting the correct URL. 
The other issue is that it uses `__default` which doesn't work well with PSR's.
This gets discussed a LOT here. [Try a search.](http://www.reddit.com/r/PHP/search?q=best+framework&amp;restrict_sr=on)
&gt;Been on a team of 5, doing weekly pulls (once a week, one big pull, one cache clear), sounds like a DEVELOPER issue to me. what's this mythical world where you can survive pulling code once a week while 4 other developers are making their own changes? We'd have merge conflicts left and right if we weren't more persistent in doing our pulls. and as I said, the issues arise when we do pulls, so just because you have some magical bullshit workflow doesn't mean the issue doesn't exist. &gt;Zend and Magento will have that issue, Laravel will have that issue. Any project that has a large number of dependencies will have that issue. I've worked on some pretty large projects in my day, including working for a popular social network(no not facebook), laravel sites, kohana sites, magento, zend, etc. None of these sites had any issue working from the same computer using NFS. Laravel site had 50+ dependencies in composer, as we all know magento is a gigantic steaming pile of shit but still performed just fine. Custom social site with literally tens of thousands of files and all sorts of crazy stuff happening also performed perfectly well. Yet here comes symfony, and clearly it's the fault of my machine, and any other machine my coworkers use to setup our projects.
i have but the problem is different result
It depends what you are building. 
You're right, I didn't look to far into the code base. I stopped when I saw step 1 was to write "class x extends Eloquent". More importantly, look at how you are querying. You are using a static method to query. When I query, I use a dependency that was injected into my class, allowing me to not only be more clear about what my class does, but also let's me test it (dependency injection) via mocking it (if I choose to mock), and as a byproduct allows me to change my persistence engine to anything (flat files, xml, postgres, redis, whatever). This dependency that I inject that does my querying for me, is called a Gateway (or a Repository), and it allows me to create lots of different queries that select exactly the objects I want. In your case above, I would use a DQL statement (much like SQL - its ok to write out queries) to do it for me more efficiently. Using a static method is no different than this, no? &lt;?php $GLOBALS['users']-&gt;where('name', 'foobar')-&gt;get() Again, I'm not trying to bash the tool as "not good", "not worth using", etc. It's really just my personal preference, I like my code to be closer to the SOLID principles (wether thats a good or bad thing, is yet to be seen ;).
How big is the data? And is the framework expected to return a response for ALL requests? Because 1000+ sounds like a lot of requests.
HHVM is just a compiler/interpreter, it has no bearing on a framework. I think what you mean is Hack, the alternative / modified version of PHP that was designed for HHVM. According to the HHVM team, Hack is significantly faster than plain PHP on HHVM, so theoretically if you had a framework written in Hack, it would be faster than the same framework written in PHP - but again, that's based on what I've read from the HHVM team, so it would have to be tested/benchmarked.
&gt; You're right, I didn't look to far into the code base. I stopped when I saw step 1 was to write "class x extends Eloquent". &gt; You're making points that are invalid from your own lack of understanding of the framework. These aren't static function calls and the entire framework is very testable(and mockable) due to utilizing dependancy injection. If you want to have a serious discussion about this, you should really do some more research.
Wordpress and Joomla are *terrible* (sorry ircmaxell). Drupal is ahead of them both, especially in the basic areas, but it still has enough rope to hang you once you try to do something custom. Most of that is because it's a huge ball of wax with tons of third-party stuff of varying quality, so this is not all the core's fault, but still: ---- Drupal has a way for an admin/developer to build "Content Types" with custom "Fields" (think model classes and properties respectively) and get a ready-made interface to CRUD them, without writing any code, just by mickey-mousing through some backend screens. It's really convenient, but the flexibility has a price. Each attribute gets its own DB table. When you want to load a piece of content, you get a list of `JOIN`s that rivals the human centipede. And the returned row is represented by an `stdClass`, so you don't get any typehinting. Quick, was your property named `field_foo_bar` or `field_fuuuu_barf`? Oh, and if you reach 60+ fields in one Content Type, MySQL pisses its pants because it cannot join that many tables in one query. (I didn't actually do that. I saw it happen to an unfortunate guy on Stack Overflow.) What happens if you delete a piece of content that some other piece of content was using? The delete succeeds, and the second piece of content is left holding onto a node ID that no longer exists. That's right, foreign keys are a foreign concept (snark). But everything is still on MyISAM, so you can't use them anyway. Transactions? Come on, you're not running a bank here. ---- What happens when you want to make changes to those Content Types after deployment? Well, if you did what the books tell you and used the user-friendly interface to build your Content Types and their Fields, you need to install a third-party module for transferring them and cross your fingers that it will work as expected. Of course half the time it doesn't, because some of the custom Field types you use are provided by other third-party modules, and those don't know or care about the field transferring module. The right answer is to skip the user-friendly UI and build your types and fields programmatically, so you can add a new upgrade function to create them for you. ---- Drupal has a hook system that you can use to deal with callbacks. You don't need to actually register your callbacks though, when Drupal wants to run a hook, it takes the hook name, prefixes it with your module name and tries to call that function. So basically you have to know the names of all hooks that are ever called, and make sure you don't use any of them by accident. Did you install a new module? Better dig through the code to see what function names just got poisoned. The hooks are not explicitly registered, but a central index is still needed to make the performance bearable. Did you install a new module? Whoops, all your system caches are gone, have fun waiting for the core to scan *all* the module files for matching function names. ---- Drupal runs cron jobs through an HTTP request. Even if you have SSH and full control over your server, you still have to build a curl/wget job to ping a URL, and then the cron job intentionally limits itself to 240 seconds of run time. Do you have a lot of content to index? The Search module will index as many nodes as you ask, even if that leaves no time for other modules' cron tasks. Did cron actually run and complete last night? Check your logs. How do you tell which module it crashed on? You take a guess, there's no log to see when a specific module's cron task was called and how long it took. ---- Drupal 7 bundles jQuery 1.4. A third party module exists to allow you to override that with your own version. If you do that in the backend, nasal daemons show up randomly. Another third party backend module bundles its own jQuery 1.8 and doesn't play well with the aforealludedto module, so you have to patch one of them. Pick your poison. ---- Since you're not a reckless cowboy, you have a dev server, a test server, a staging server and a load-balanced production server farm... and then you need to copy some content from one to another and maintain relationships. * So you install a third party module to export/import content. * You watch it install a dependency module that gives each piece of content an UUID. In a column without a unique index. * You toss a coin to decide if you want to use a "deprecated" exporter, or an "experimental" one. * Finally you export the content and import it on the other server. * Then you watch the relationships go down the shitter anyway because one of the third-party modules doesn't register its hooks properly so its relationship data points to the same IDs the old server had. If you're lucky, they'll point to some random data that exists. If there's a full moon tonight, they'll point to nodes that don't exist. No foreign keys, remember. ---- So I said you have a load-balanced production server farm. If you are not a complete buffoon, you will minify your frontend CSS/JS. Drupal has a built-in tool to do that. But what if your site is complex and includes lots of styles, varying responsive designs, etc? The built-in minifier merrily squishes all the CSS together... and suddenly the client reports that the layout is broken in IE9. Congrats, the minifier tripped over the [4095 CSS rule limit](http://stackoverflow.com/questions/9906794/internet-explorers-css-rules-limits). Now you need to install another third-party module to work around that. The right answer might be to compress all the things during the build process, not to leave it to Drupal itself. On the other hand, Drupal can build separate concat+minified versions for each page, instead of a static monolith. Are you sure your statically-minified version includes all the CSS from the third-party modules that might be in use? ---- Source: A large part of my work over the last 18 months has been building and maintaining a Drupal multisite for a payment gateway. Not actually handling payments, thankfully, only the promotional sites. In that time, we have built multiple custom modules and we have modified 13 third-party modules to work properly. TL;DR: If I have to build another CMS-based site, I will still choose Drupal over any other alternative, but I will try to give the project to someone else first.
We preload the data, its around 2000+ data per user
This is rich coming from Lerdorf. PHP is one of the worst designed, poorly performing languages ever.
Weekly pulls...that's not normal for 5 devs. That's not normal for 2 devs.
Is Hack really faster than PHP running on HHVM? I didn't read about that, that's interesting, do you have some links?
What is Datomic?
&gt; 2000+ data I can't imagine what 9000+ data would do
I wouldn't list composition over inheritance as a hard-and-fast rule (I do, after all, extend `Model`), but in my experience composition is a better approach for designing models in an MVC. In composition, you're saying what your classes are "composed" of, instead of saying "this class is exactly like this, plus a few new things I'm adding". Let's look at birds as an example: an Eagle, Puffin, and Penguin can all 'extend' the 'Bird' type. Eagles and Puffins can both fly, but Penguins, can not, so let's make a new class with our fly() method in it: `class FlyingBird extends Bird { public function move() {$this-&gt;fly();} public function fly() {} }`. The poor penguin cannot fly, but he can dive underwater, so let's make him extend this: `class DivingBird extends Bird { public function move() { $this-&gt;dive(); } public function dive() {} }`. But, our Puffin can both fly and dive! We can't make him both, and often multiple-inheritance approaches lead to enormous quagmires, where method names conflict. While you certainly 'can' do this with inheritance, a much cleaner approach is to instead compose our birds with their movement types, so Dive and Fly would be off in their own classes. I think the big missing piece you're not seeing here is the `interface`, so you could say: interface Moveable { public function go($coordinates); } class Dive implements Moveable {} class Fly implements Moveable {} then in your code, you can say: public function move(Moveable $moveType) { $moveType-&gt;go('43.7, -79'); } Anyway, this examples getting a bit long so I may stop here before I end up writing another article inside a reddit comment. I recommend reading wikipedia for a really good intro article to the general concept: http://en.wikipedia.org/wiki/Composition_over_inheritance This article shows some good PHP examples: http://blog.ircmaxell.com/2012/12/response-private-methods-considered.html 
I think enums in C++ are just fancy integers with type safety being enforced by the compiler. The compiler probably treats them like constants and replaces them with numbers when creating the executable. It's probably not accurate to say C++ enums are instances. Things get a little more murky in other languages. Java and C# enums function exactly like objects. They have constructors and methods, and the variables are probably allocated the same way as other objects. It's safe to use the word "instance" when describing enums from those languages. Either way, the point of my comment was to point out a couple design changes you could make to your `BaseEnum` class to get more usage out of it. Instead of using `BaseEnum::isValidName()` to manually validate arguments, you could let the PHP runtime do the validation for you by using type hints. Plus (and this is a big deal) when using type hinting your IDE can auto-suggest one of the enum values as you're writing code, and the IDE will also point out any mistakes you made. I did a lot of profiling when I wrote my enum class, and there's little overhead when creating thousands of instances. So I think designing your enum to allow for instances would be worthwhile design choice.
To get to the obvious endgame here: Your question is bad and you should feel bad. If I were a mod, I'd delete it. You provided no requirements, nothing about the current or potential architecture, nothing about the data ("2000+ data per user"?!), nothing at all. My advice: let someone else in your organization who is capable of gathering and articulating requirements make this decision. If that is not an option, do some serious research before you make this decision because you will be stuck with it for a while most likely.
I'd assume he's referring to http://www.datomic.com/
I agree that Symphony, Zend, Laravel, etc. are rather heavy. Slim and Silex are a good lightweight choices. Almost all use the same routing architecture, which was inspired by Ruby/Sinatra. It's sound like you may be looking for an alternative routing structure (nice list here http://paul-m-jones.com/archives/5970). Perhaps something like HHMVC (PAC), which I think is a better routing system for single page app/ajax based sites. I believe CodeIgniter has a plugin, though I'm not a fan of CodeIgniter. I wrote my own simple HHMVC (PAC) based framework, since there weren't many options out there. Originally for supporting 50+ Facebook apps. Its called Basecoat and is available on github (https://github.com/shutterstock/basecoat). No real following, so something to take into account.
[I think I get your idea](http://www.youtube.com/watch?v=YPcLaO4ey4g)
HHVM generally runs PHP pretty darn fast too, and classes in Hack can even extend classes defined in PHP. I see hack as a more appropriate language when you care about things like strict data typing (even on the contents of Collections, the extra data models hack has instead of just Array.) Performance is not usually a good reason to migrate from PHP to hack, but it's an excellent reason to migrate from the Zend PHP engine to HHVM. Hack does include some early support for async (reads a little like Promises in ecma), so if your site is slow because it's often waiting on blocking code (and you can't just MSQLI_ASYNC or async curl your way around it), hack could help a lot. 
Some of the [new async stuff in hack](http://docs.hhvm.com/manual/en/hack.async.php) could be very useful for API's whith highly variable processing time per request. Also lambda's might become useful, but I don't personally see what stinks about the fairly expressive use ($var) syntax.
Thank you! I will try it! But my solution was made for users who has experience or build application with Zend Framework or other MVC system. If you develop it or connect it with other app you realize that the whole system will be stable if you use a popular PHP framework
Yes thanks for clearing that up I guess Datomic isn't the most popular database around however it has many excellent features and I want to spread the word to PHP developers.
If that's the case, I'd write a blog post on why people should switch from or start using Datomic rather than their existing choice.
This looks really nice and will give me a good excuse to try datomic. Just wondered if you can use the php library to do what is the more interesting queries in Datomic, ie the as-at or since queries on entities?
I'm sorry for answering in a comment! I was only awake for about 12 seconds and on my phone already, not paying attention to which subreddit this was posted in. *Walk of shame*
I wrote one and tried to shoehorn in most of the new hack features: https://github.com/warmans/hack-mvc It's not that different really. Mainly just more type-hinty.
#letmegooglethatforyou
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
Because it's a single threaded language; `pthread` in PHP is hardly the norm. You'd be hard pressed to find a default environment that supports it.
There are a few cases where it may multithread, but only cases where it's executing a native lib that uses parallelism, so it's that lib using the other cores and not PHP. 
From PHP docs: Reference of a $value and the last array element remain even after the foreach loop. It is recommended to destroy it by unset(). &lt;?php $a = array('a', 'b', 'c'); foreach ($a as &amp;$item) { echo "$item"; } echo "\n"; unset($item); // The important bit foreach ($a as $item) { echo "$item"; } echo "\n"; Returns: abc abc
You have a good explanation here: http://www.toptal.com/php/10-most-common-mistakes-php-programmers-make#common-mistake-1--leaving-dangling-array-references-after-foreach-loops
I like to fantasize about creating a 1:1 feature compatible framework port of the [Phalcon](http://phalconphp.com/en/) framework, written in Hack for HHVM and calling it *Halcón* (incidentally Spanish for Falcon) and then benching the two against each other. Yeah... ain't nobody got time for that.
&gt;The issue is that escaping is a template task. Why? Because how you escape content depends on context—where are you placing those variables? Do you have an example? I can't think of an instance where you *wouldn't* want your controller to escape all user inputs being sent to the view. Otherwise you're wide open to XSS. That creates an issue where there's no trust. The controller could be handing you plain Jane display data or it could be handing you a payload that will compromise the site. And now it's up to the template to try to muddle through which is which. &gt;Front-end developers (designers) are still developers, and with that comes a certain level of required knowledge around security. To an extent, but why are we betting our website security on it? I certainly wouldn't be comfortable delegating the issue. Many designers will have some development skills but it's not the specialty of most by a long shot. Just think of all the extra work there is now. Instead of writing the backend to be secure you have to review *every template* to make sure values are escaped. That doesn't make sense to me. Address issues at the lowest level, not the highest. And as I said, designers now have to know a lot more about the application. Where's this data coming from? Is it user supplied? Application created? Either?
&gt;I think designers are concerned with their HTML being broken by some template variable Do you have an example be? I'm having a hard time thinking of one on a proper MVC setup.
Ah that actually makes sense. So it copies the value to the reference which is pointing back to the array being iterated. 
Why not just run it on the standard vm and run it on hhvm and compare some basic benchmarks? Reimplementing bits in Hack will only speed things up (on average).
While I was designing a new version of my [Box](https://github.com/kherge/php-box) app, I developed this as the base for the new app. My thought was that it would make it easier for people to customize pretty much any part of the of the build phar process.
If you start doing this every time, I will love you.
&gt; Wordpress and Joomla are terrible Terrible for what, coding? Joomla uses OOP MVC, that right there makes everything easier to use. Try to build an ecommerce site and add an extra field to the checkout. Something that takes 15 mins in magento, joomla/virtuemart etc, can take hours in drupal. Most of the modules are crap, even the most popular ones. Ubercart is beyond terrible. Lots of people like you with opinions and no experience. I work at a development agency, we use whatever the client has or whatever is best for the job. Ive extensively used Wordpress, Joomla, Drupal, Magento, symphony, laravel, etc. Ive touched all three CMS forementioned in the last week alone, and know the strengths and pitfalls of each. Drupal is not programming friendly, and I would never use it. Joomla is not PHP-noob friendly, and I'd only wanna use it when I would like to write my own app/extension. Wordpress is easy enough to use for admins and developers, its probably the easiest to build simple sites. Anything more then a simple site and your just looking for a headache.
&gt; On top of this, zend has no real clear way of helping you write easier and cleaner code, it feels like 90% of the code you write is to wrangle zend into doing what you wanted to do anyway, rather than getting the hell out of your way so you can get shit done. ZF1, especially, was really anything but a framework. Calling something a "use at will" framework (a phrase that got used often) is an oxymoron. It was a library of a components of varying quality (some were really good, some ... not so much). ZF1 also was the only one with "framework" in its name, yet was so *not* a framework, "framework" defined as a prescribed way of using components designed to work together. There were few prescriptions about how to architect medium to large apps effectively in ZF1, and it always felt to me like people (myself too) were reinventing wheels that didn't need to be. ZF2 is ... a different beast. Haven't done enough with it recently to comment too much. 
You have to deal with all that bullshit and you think WordPress is terrible? Have you actually used WordPress? I've only dabbled in Drupal, but just your description of how the database is run is enough for me to turn and run very far away. You don't have to deal with any of that crap with WordPress. I never thought I'd find someone who thought WordPress and Joomla are terrible but then say Drupal is better. WordPress (*especially* from a client's perspective) is lightyears ahead of Drupal.
Depends on your workflow
Again, sounds like developer issues. If you don't have a solid workflow, where you are merging that frequently, you are doing something wrong. As for the second piece, i simply just call shenanigans.
I have made dozens of WordPress websites. Pretty much all of them are custom in some way or another. Despite what people will tell you, it's not bad at all. I've never felt restricted as a developer by WordPress itself and/or its API. WordPress is one of those things that developers love to hate because its source code is a rat nest, mainly because it was never intended (AKA, envisioned) to be a full-fledged CMS. So pieces were built upon more pieces into what it is today. But guess what, so is PHP itself. PHP is a language that *other* developers love to hate, and a lot of the reasons is because the API is a rat nest and full of inconsistencies.
they are, by definition, STATIC CALLS, that are "facades" or proxies really.... to a IOC. 
Yeah, some workflows have only 1 commit or 0. Single pulls a week is aberrant. You can be branching for every task and doing a bunch of merges, but that's also indicative of a people problem.
Please, please stop with this insanity of testing private methods – it's dumb.
This is the well known way of testing private methods.
I'm pretty happy with oxdbe as well. Though if you're on a mac I would still strongly suggest sequelpro if you're working with mysql.
You've hit the nail on the head of all of Drupal's weaknesses... ...and yet, it's still a million times better than just about anything else out there, sadly. Wordpress gives you so little that if you're building a large enough site, you might as well actually built it on a competent framework instead of bolting to the side of the spaghetti code mess that's Wordpress. Wordpress is just getting in your way. Joomla's MVC architecture is pretty decent, but the admin UI is a complete trainwreck and really difficult to customize or simplify. Also the lack of a "content types" concept in Joomla dooms it from the get-go. Drupal gives you enough for "free" that for most content management projects, it's difficult to justify a custom build. However, once you reach a certain threshold of complexity/scale, Drupal's maintenance pains really start to hurt. D8's configuration management hopes to at least reduce the multi-environment dev/stage/production pain.
Hey, these are awesome! Thanks!!
Well, if anyone would write Zephir =&gt; Hack compiler that could be possible )
Toad MySql Free edition is worth checking out, too.
I wish you all the best. 
That's what she said. LOL.
If you really needed to test it separately it would be public.
Indeed. I remembered it too and that was why I knew what to search. 
I own like 3 of their products and signed up to test, but I'm on Mac... No love. Last mac I'll ever own too.
Hiya! Looks really good even though I've never used Datomic before. Was just browsing through your code, had some suggestions: * [Change ``private`` class attributes to ``protected``](https://github.com/taywils/patomic/blob/master/src/Patomic.php#L10). This way if someone extends a class, they can override them easily. * [Don't wrap the status codes in double-quotes](https://github.com/taywils/patomic/blob/master/src/Patomic.php#L129) i.e. ``case 200:``
you just contradicted yourself. an IOC is a container of an object. Yes syntax wise it's a static call, but it's actually calling a method on an object not a class after all is said and done.
I didn't contradict anything. THe static calls are proxies to calls made by the IOC. That is what is wrong with Laravel. You are literally not making any sense, and I'm done trying with you.
again, depends on the project you are working on, and the project management style you are following. Not everyone follows the same style as you bud.
The answer is simple: don't use references. Problem solved ;-)
It's *zero* x D B E, by the way (hexadecimal)
Are you a bot? If so - keep it up bot :)
&gt; again, depends on the project you are working on, and the project management style you are following Repeating your experience doesn't change the oddity.
Ditto?
Again, you have no idea how laravel works, go research it and come back when you understand. 
Not sure what you're talking about. As usual.
so you pronounce it *zero exx dee beee*?
What you just said: "PHP is bad therefore it is okay that the rest of my stack is bad." The source code being a rat's nest is an entirely valid reason to say working with WP is a pain in the dick. It's hardly a defense against that claim. Drupal has its issues, but it's making big strides to correct them. WordPress still lets you, even encourages you to, edit code through a form (and if you think that is a good thing, you're a terrible dev).
Ugh.. any day I have to deal with Magento makes me want to quit my job. Partially because I'm not technically a programmer or developer but I get to do a lot of under the hood troubleshooting with it and it drives me nutters.
Just ask them to post in the other sub, and post there. Not that hard. Like /u/aikah said, the people answering these posts are the problem. Discouraging answers will help move it to another sub. If that gets me downvotes, so be it. Support doesn't belong in this sub &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC
I started converting my framework to Hack. The only benefit I see so far is type safety and speed. Here are a few examples: https://github.com/titon/framework/tree/master/src/Titon/Common
whatever. I didn't downvote anyone in this thread because I feel like (for the most part) everyone contributed to the conversation. If a point can be made and a person who needs help can be helped at the same time... I think that's the best scenario. 
Sorry. Let me rephrase: when it's already the job of the controller/model to supply output data what is the benefit of delegating part of that task to the view?
I prefer working with mysql via the shell and from bash. Been doing it that way for way too long to change now! 
Ah, well in that case, and assuming I understand what you mean... In the context of this discussion we're not talking about the view supplying any data or having any part in the responsibility of supplying any data. We're only concerned with the way the data is being displayed, which of course is a job for the view.
Thats going to suck when my code needs to be refactored to take advantage of this.
Ya I think that is the way that it is going. Probably that is about 2-3+ years out though. Phalcon 2.0 is estimated to be released in December and it is rewritten with Zephir (mostly). So give Zephir a chance to mature and HHVM to slow down a bit and it could happen. I think that Zephir could have a big future and I don't think that HHVM was released when they started it so that was a huge boost in potential with that.
I have never edited code through a form while working on a WordPress site.
And this is why something like a /r/learnphp is a good idea.
What's the problem associated with using it on a mac?
&gt; Lots of people like you with opinions and no experience. Actually, I work at a development agency as well, and I have worked a lot with Joomla, WordPress, Drupal, Typo3, Taesk, as well as built sites using frameworks or even from scratch. In my experiences, all those CMSs suck once your sites stop being trivial, but Drupal sucks a little less (or maybe I have learned what to avoid, who knows). I have dabbled very little in eShops, so I cannot comment on that. But I find Magento to be a much larger clusterfuck out of the gate, with its ten layers of nested classes, fucked up XML parser and code that tries to be reusable, but fails so hard. Though I haven't done enough with it to say if that impression is accurate.
&gt; You don't have to deal with any of that crap with WordPress. No, you don't. Instead you have to deal with an EAV-based metadata system that makes even those JOINs impossible, the douchenozzle known as The Loop with all its global state, `the_title()` vs `get_title()` nonsense, lack of architecture, shitty ancient code base that keeps leaking bugs like a sieve, and millions of idiotic tutorials teaching newcomers shitty and insecure practices, resulting in millions of insecure and shoddy plugins. Some elitists might even say it's the PHP of frameworks, and not in a good way.
Magento guy here. It's terrible sometimes and the learning curve is insane but I would use it over any other self-hosted ecommerce system.
A CMS lets you do *Content Management*. A web app does much more than that^1, and you will regret basing it on a CMS, especially a wannabe one like Wordpress. Frameworks like Symfony/Yii (or micros like Silex/F3 for certain cases) are more suitable, but they still have their learning curves and warts. You should start learning Symfony or some other popular framework if you want to go into that. ^1 The additional functionality depends on the business problem your app is solving, but it could be data analysis, report aggregation, mobile websites/native apps talking to your main system via your own APIs, integration with external systems (Zendesk, Dropbox, Mailchimp, Instagram, Twilio, ...). None of these things are related to Content Management and IMO, unless Content Management takes up &gt;70% of your entire app, you shouldn't base it on a CMS.
Oh, I fully believe that, since the alternatives include WooCommerce and OpenCart :) But it sounds like it is more a "least of all evils" than "the perfect solution for ecommerce".
I've been using Wordpress for almost 8 years for most of out client sites and with all the changes that have happened over the years I can't imagine using any other PHP framework -- and I have had the pleasure of working with the likes of Drupal, Joomla, and most other PHP CMSs that have popped up. Now that they have custom types, menu editing, a huge plugin ecosystem, hooks for everything and straightforward templates I don't understand the developer hate. There are some valid criticisms about core being a mess in spots and DB architecture being iffy but overall I think the hate comes from misinformation. It is constantly being improved and I have yet to run into any of the problems people complain about. We've done real estate listings, store locators with geocoding, integrations with Magento, massive news sites and much more. For most non-app sites it can be a great fit. A lot of the strikes against Wordpress seem more pragmatic than practical, but that's good. Wordless does need work to get even better and thankfully that work is being done. For clients, it's a dream to use and requires minimal training. I wouldn't say it's intuitive (you mean I just close the media pop up? There's no save button?) but after hundreds of sites we seem to average an hour or two tops for client training.
I get that... but I didnt see "dont help people or answer questions" in the sidebar. It's fine. I'm done with the topic if everyone else is... now I know that this is not a place to "be a good neighbor" or whatever.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to [##php on Freenode IRC](http://webchat.freenode.net/?channels=%23php).
I hope you does not understand the question are you never with this type of project
yes its dying because of the memory issue.
There's actually a pretty good argument to use private instead of protected, see [here](http://fabien.potencier.org/article/47/pragmatism-over-theory-protected-vs-private), for example.
Telling people to post in the support channel is being a good neighbor
I was like you - mysql console + bash. Now, 90% of 0xDBE fetures I'm using is code completion. Process of syncing with db will fetch all info about it so code completion is damn good - jetbrains dominate in that area. 
Thanks for your reply: &gt; If you try to return value from a generator php will error out with somethig like Yeah aware of that - cheers :D - just updated the Gist to show that this code does not run - just did this as a quick pseudo code example of where I'm at. &gt; Which calls the generator() method which calls the curl function with the callback. The problem is that the curl call never returns until all the data has been processed. Again - sorry should have been clearer - the $this-&gt;curlRequestThingy() is (would be) a wrapper to curl() which uses CURLOPT_WRITEFUNCTION which returns the HTTP response in chunks. Curl **does** return data in buffers/blocks if used this way - not the entire payload in a single response - which is what I'm after. &gt; If you are worried about the curl return eating up a lot of memory, then make the endpoint url to return the data in chunks. I see that there is curl option called CURLOPT_RANGE. Again - CURLOPT_WRITEFUNCTION takes care of this part. &gt; You may be able to use it to select the offset and size of the data you want the call to return. Now, you can abstract that into a generator. Agreed that would work - but them I'm making a tonne of individual HTTP requests to simulate chunking of the response - which is inefficient. Thanks anyway.
&gt; CURLOPT_WRITEFUNCTION which returns the HTTP response in chunks. Yes, it passes the chunks to the callback which is one level deeper in the call stack. Right? What you are trying to do is to return that chunk to a scope two or three levels up, which is not possible. top-level -&gt; generator -&gt; reqest-thingy -&gt; curl_exec(using write function) &lt;-&gt; (write function callable) See that the curl_exce calling the callable until all the data has been processed. What you are trying to do is to return to generator from write function callable. But generator is 3 levels higher in the call stack. Why not make curl directly to a file. That will solve all your problems.
Thanks for sharing the article, was an interesting read!
&gt;I really do not want to learn a "framework" like CakePHP. I would just like to learn the best way to do MVC in as simple a manner as possible. Unless someone can sell me on why to use a particular framework. You don't want to learn a framework but you want to learn how frameworks are built and build your own. At the end of the day you will have a framework, but it will be undocumented, lacking in features, and only you will understand how it works. Perhaps you should try to convince yourself why yours will be better than a mature, well documented framework like Symfony? If you want to learn about MVC frameworks, [this](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1) is an excellent ground up guide where the author of Symfony uses it's components to build Silex.
I think I am in a very similar range.. I'd like to know what people think.
&gt; Why not make curl directly to a file. That will solve all your problems. See OP - it would be for use like passing data directly to an XML parser like expat. &gt; Yes, it passes the chunks to the callback which is one level deeper in the call stack. Right? What you are trying to do is to return that chunk to a scope two or three levels up, which is not possible. Yeah I think I might have to let this one go - just feels like there is a pattern to cracking this nut :) Technically it doesn't feel like this couldn't be achieved somehow at a PHP construct/opcode level. Anyway - thanks for the replies.
This code snippet is useless. It has no description of what it's intended to do. If it's supposed to be a tutorial it should explain what the code is doing and why. Worse, it's using mysql_* - you know - the methods with big red deprecated warnings all over the place. This smells like blog spam (esp. given this contributors previous submissions) with no value.
&gt; How much am I worth? Salary or hourly wage? Whatever someone will pay you. Seriously, this depends as much on your location as it does on your skill levels and experience. Supply and demand are what really affect the market, jobs no less than products. Don't worry too much about what you're worth and try and get as much as you can. That is then what you're worth. As a random tip that I've found useful... recruiters can actually be your friend if you don't know they market. They DO know the market and have a vested interest in getting top dollar for you (because they're paid a percentage of that). **Good** recruiters will be a valuable partnership.
What the fuck is this and why is it news? **My experience of eating ramen.** Purchased ramen from shop. Tonkotsu ramen with extra chashu and no nori. You may like the nori. I do not like the nori. Ate the ramen. Mostly I ate noodles. Then I ate the soupy part. It was good.
I got a copy through the EAP, opened it, spent a few minutes inside and left it like a cheap saturday night hooker. Im sure for DBA’s its going to be good, but as a developer i need access to data as much as i need access to structure, so as i could only find the former, i didnt see more reason to carry on using it… Sequal Pro is buggy as fuck, but its still really good. 
The original Quickstart installation didn't show the commands. It was interesting to me so I shared.
Im not sure i would trust software by DELL, or that has a stereotypically cool (possibly autistic) cartoon frog as their mascot. http://imgur.com/It9lYE3
Warning if you use this code, there is a CSRF condition. echo $_GET['callback']; // BAD! You should never trust user input Better do a little filtering : echo preg_replace('/[^a-z0-9_]+/i', '', $_GET['callback']); 
This is the only valid answer you will (shuold) get. It depends on oh-so-many things. What country? What city? Best way to check what you're worth is to ask your friends that are in the bussiness what are they getting paid, best for it to be good / close friends as that will lower the chance of them bullshiting you and telling you how much they earn while in reality they earn 1/2 of that. If this will be your first job in an agency / corpo, don't expect to get paid big money. Don't expect to know everything and that you "can accomplish tons/basically anything in php/mysql+" because the chence that you're lying to yourself are very high - webdev is a very broad term that covers everything from 'hello world' to finances and big data. Start small, get a job, if after a few months you will feel that you're not getting paid enough - look for another job and now you will have a basic idea of how much you awnt to / should earn.
What's the added value to the built-in database features in PHPStorm?
No, she never said that.
The worst they can do is drop you on the spot because they think they can't pay you enough. I've had it happen.
Is the error in class one's constructor?
How is it better than MySQL Workbench?
Do you have a demo to show as well?
Personally (US resident), I look at the median wage for the job I'm applying for by location using the Bureau of Labor &amp; Statistics website, and that's exactly what I ask for. Of course, larger cities will skew the number for the rest of the state so it's always negotiable, but at least it's a solid starting point.
nvm, my autoloader is not showing error messages for some weird reasons. Some files were messing. 
Well at the moment as you can imagine making a CMS on my own, its a lot of work. My website [ilikeprograms.com](http://ilikeprograms.com) uses it. Other than that once I add a few more features that I have in mind I could start working on a Github pages which has some more info for it. I could really do with a live demo instance of it that gets reset everyday. SO I guess I dont really have a live demo, but it should take about 5-10 mins to clone it and get it running on a localhost. Assuming you know how to do that, all you need is Git/Composer to get started.
&gt; recruiters Yes on this! Made my job search so less painful when trying to relocate to a different city. Larger companies prefer recruiting agencies due to the pre-filtering they provide, even though they are quite costly. Beyond that, recruiters will help you find a job, but it's up to you to *get* the job. The one I worked with, they provide an assessment test, which (as much as everyone hates them) categorizes the programmer into a skill level: novice, advanced, a few more - there was a test for each language, too. As I mentioned before, it's up to you to *get* the job. It's not entirely about what you know (consider how many "non-programmers" are able to get programming jobs), but how you prepared you are. Go in with code samples and a portfolio site, and you'll be ahead of most of the other applicants. 
The OPs website is powered by it http://ilikeprograms.com/
Was tongue in cheek cause I'm jelly I wasn't picked and I blamed it on OS X.
I work primarily in Linux at work... Mostly in bash. I won't buy another mac because $3k on a suped up mbp retina was a dumb purchase :(
No. It's pointless and will only annoy potential customers. * + is a valid character that is not used for 'local tags' in the same way as GMail uses them on some providers. There are also other services that provide the same feature but use characters other than + * Even ignoring the thousands of mail redirection / temporary mail account services such as Mailinator, people can still sign up for multiple email accounts in minutes. * Many users (eg. freeserve, force9, people who own their own domains) frequently have catch-all accounts they use in the same way, which are impossible to catch or block in a similar manner. You'll just annoy people who either have a + in their normal email address or who legitimately use local tags for keeping track of where they signed up. Fun bonus feature to further frustrate your de-duplication attempts: GMail accounts also allow you to insert .'s anywhere before the @ sign - eg. post.master at gmail.com is the same as postmaster at gmail.com
They definitely openend up EAP to mac users. I'm running 0xDBE on my mac too. Took them a week or so to accept my appliance.
I just searched and I got an email in June that gmail routed to spam. Doh! 
Wow, thanks for the informative answer, and honesty about C++ enums. I think I would really consider this sort of thing / using your package for a side project, but I prefer the simpler design inside of my team, because it does not change their habits at all, and because I believe it will integrate better with the ORM I'm using (Doctrine) : if you end up having an object where there should be a string, I'm not sure how Doctrine will react. Regarding the performance, I believe you and anyway, the reflection system I'm using is probably sub-optimal, so that not what refrains me from using your package.
regarding #2, i think any sane email list reseller will strip the + and dedupe.
Great answer, that opened my eyes to a whole new way of looking at things. Thanks.
I understand the feeling. Though technical, I was there six years ago trying to find my way - before *any* documentation existed. There are some community resources available and you can feel free to reach out to me and to /r/magento.
The postmeta system in WordPress can be annoying but there are functions in the API to retrieve them so you don't have to write a single JOIN. You can also make your own custom tables in a WordPress install extremely easily if you have access to phpMyAdmin or something similar. Whenever I work on a site I always remove The Loop, but it's just, well, a loop. It's nothing special. Yes, WordPress has globals. I don't think it should be written off because of that, though. I don't see a problem between the_title() and get_the_title()*. One prints the value while the other returns it. That's just being familiar with the API. What do you mean by lack of architecture? Yeah, the codebase has problems, but it's never slowed me down from doing what I was tasked with doing. As for the tutorials... you can say that about anything. You know how many idiotic tutorials exist for PHP that teach newcomers shitty and insecure practices? I mean come on. I don't really care what elitists (about anything) have to say. I just know WordPress gets hate it doesn't deserve.
It would be awesome to have a demo to access the admin area of it.
hmmmmm I suppose I could change the password to login for like 30 mins sometime. Pm me and I will do that, im sure I can just backup the DB just incase :)
How do you define "the best"?
Removing plusses like that wouldn't be useful, since the OP's goal is one email account = one user (so they want example+a@gmail.com and example+b@gmail.com to be treated as the same email address for uniqueness purposes). What you'd do is remove the plus and everything up to the @ sign.
Auto loaders should use require
there is a study guide on their website. its pretty helpful. (I got my Zend Cert using it)
It's official. /r/PHP has formally descended into anarchy.
that's not unique, that's crippled... example+a and example+b are two different email-addresses. Especially on couples-email-adresses (i.e. john+anna@ vs. john+michelle@ vs. john+john@.... )
I mean for everyone that access the project, not just me :)
You could start by calculating your personal "minimum wage", where you can pay all your bills and have a decent lifestyle. double that number and you have a solid "base" for negotiations. and go for hourly rates if possible
How does this compare with the Symfony console component? Why wouldn't I just use that?
should you force "like on facebook to view this article"? you know the answer hopefully.... plain and simple no.
hi dracony its a easy one or not.
@aequasi08 is correct here, by definition class::method() is a static call. "But but but under the hood it..." doesn't matter to me. The principles I code by are violated by this code. It's personal preference. End of my participation in this discussion.
If you believe posts are not suitable for a subreddit, post a comment explaining your disagreement then hit the report link. Posting a dedicated post, especially without any explanation as to why you think this user should be banned, is unlikely to achieve anything useful and only serves to clutter up the subreddit.
What's the benifit with writing php code to the disk from a cms panel? Do you actually use that, and why?
Trace the request handling code path of a couple other major frameworks to get a birds-eye-view of how they work (edit: also, ignore the haters &gt;_&lt;)
This seems more suitable for r/learnphp or r/phphelp. 
In my CMS there are PageTypes (kind of like Controllers in MVC), Content Types (dumb data of definable structure) and Components (building blocks of pages that are in charge of pretty much everything that needs logic, like menus, galleries, lists, paginators and so on). Of these, PageTypes and Components have a class each that is generated (empty) after the creation of either of them in the admin panel (during development). Obviously these are accessible only by admins that have developer privileges and normally not to be trifled with in a production environment, but as the CMS is to me a tool not only in data-entry but in defining the information architecture during development, I would like to showcase that in the demo account as well.
Designer as in schema designer? I use [WWW SQL Designer](https://code.google.com/p/wwwsqldesigner/) which works with most major databases.
You could use one of the many cloud hosting providers and use their API to reset the machine every 30 minutes.
Framework should support API side
sure i will add it there
1) Figure out how you want things to work 2) Look at how other frameworks do similar things 3) Write the code to make it work the way you want to.
I personally use Digital Ocean (referral link: https://www.digitalocean.com/?refcode=cc66f598a536), look for a coupon code online and you'll get $10 free. Enough to keep a server running for 2 months. I'm pretty sure you can figure something out with their API, documentation is available here: https://developers.digitalocean.com/
Oh, gotcha, I misinterpreted the 'signed up to test' part.
Hey, I made a post about 2 hours again mentioning a CMS I had been developing for a few years. People asked about a demo and I was thinking your exact question haha. http://www.reddit.com/r/PHP/comments/2a4u6o/corvus_portfolio_cms/ Pretty funny timing, if you find a good answer im sure it can help us both out!
thanks dude i will check it
Yep, to a large extent, I wanted to build my own framework or build upon a skeleton framework. Not necessarily for production purposes but for understanding purposes. Once I had understood the basics I'd apply that thinking (or readjust that thinking) to a stable, featured, documented framework. Posting this question and getting these answers has been great for me in terms of understanding how I "should" go about doing these things. Thanks for the link. 
that doesn't make any sense. what API side?
Recruiters are not usually paid a percentage of your salary. The majority (of tech recruiters, anyway, may be different in different fields) are paid either a flat commission per position filled or a percentage of the spread - the **difference** between the employer's top rate and the actual salary. Obviously this creates an incentive for them to get you enough money to take the job but not a penny more than that. Source: Wife is a tech recruiter who gets paid flat commissions and has worked on a spread before.
If you only ask for the median you are never going to earn a good salary.
hahaha. Now that is funny. Do you have a link to yours, would probably be useful :p ?
Haven't published yet. It still needs a bit more polishing. Not that's going to be too shiny after that either, but still.
Where are you? How many years experience do you have? Based on those two it should be possible to give you a pretty decent range of salaries.
You are from India, right?
Ah right ok lol. Well when you do you should post a link!
&gt; writing php code to the disk from a cms panel? Doesn't WordPress let you do this? I remember editing theme code manually through the GUI.
Assuming you have some sort of ACL (Access Control List)/permissions in your CMS, you could add a 'demo' user and restrict the user to viewing parts of the CMS backend. Additionally, you could also allow the 'demo' user to edit parts of your database, but ignore saving the changes to the database/files using ACL/permissions.
Normally they are the same. `itrulia+skumbag@gmail.com` would redirect to `itrulia@gmail.com` same as with my personal email address or any work addresses I had so far.
I tell everyone, if your in the US go look up their state (or the state they'll be working out of) Labor Market Information Center (LMIC). Every state that I've seen has one and it will give you a very accurate break down of salaries for the state and any metropolitan areas in the state as well as your percentile (25%, 50%, 75%, 90%). This tends to be a lot more accurate than glass door since pretty much everyone has to report the LMIC statistics. My experience has been. Entry into the market will probably get you around the 25%-50% percentile depending on how good you negotiate, but after a year or two you can jump ship and move up to the 50%+ range.
So, so true. I'm only a student but I had another professional career before starting CS. I recently got a big National Science Foundation scholarship specifically because I have good soft skills that I learned while working. There are better programmars than me at school. But they don't communicate, don't work well in a group, aren't willing to research new methods to accomplish a task, I could go on. I'm a decent programmer, but I can lead a group better than anyone in my classes, and I'm flexible and willing to learn. This is what sets me apart.
Why do the people who post these questions always assume we'll magically know which country they're in?
likely somewhere between $40,000 and $200,000
I actually wasn't aware of that being a possibility. I was under the impression they only stripped the symbols they don't accept. Thanks for making it clear. In that case, it's really an interesting question. I think allowing multiple versions for registration, but applying bans to the unique-address could work. Kind of a "You can have multiples, as long as all of them behave"-rule. 
It's an irrelevant question, and quite frankly none of your business. I bet you wouldn't like it if your motives were questioned.
That's a good question. Put simply, it *is* the Symfony Console component, with the Symfony DependencyInjection component bolted on. If you look at `composer.json`, you'll noticed I call in both as dependencies. The reason you would want to use Scaffold would be for the benefits that the [dependency injection](http://en.wikipedia.org/wiki/Dependency_injection) pattern has to offer. It might be a bit overkill for smaller apps, though.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Dependency injection**](https://en.wikipedia.org/wiki/Dependency%20injection): [](#sfw) --- &gt; &gt;__Dependency injection__ is a [software design pattern](https://en.wikipedia.org/wiki/Software_design_pattern) that implements [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control) and allows a program design to follow the [dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle). The term was coined by [Martin Fowler](https://en.wikipedia.org/wiki/Martin_Fowler). &gt;An injection is the passing of a [dependency](https://en.wikipedia.org/wiki/Coupling_(computer_programming\)) (a service) to a dependent [object](https://en.wikipedia.org/wiki/Object_(computer_science\)) (a client). The service is made part of the client's state. Passing the service to the client, rather than allowing a client to build or find the service, is the fundamental requirement of the pattern. &gt; --- ^Interesting: [^Java ^Community ^Process](https://en.wikipedia.org/wiki/Java_Community_Process) ^| [^Spring ^Framework](https://en.wikipedia.org/wiki/Spring_Framework) ^| [^Inversion ^of ^control](https://en.wikipedia.org/wiki/Inversion_of_control) ^| [^Java ^Platform, ^Enterprise ^Edition](https://en.wikipedia.org/wiki/Java_Platform,_Enterprise_Edition) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cirmpgu) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cirmpgu)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
i think i worded it wrong sorry, i'm trying to pass the parameter value I get from $customer-&gt;href into user_metadata. when i do var_dump($customer-&gt;href); outside of the function i get the correct value, but when I do it inside of user_metadata I get null 
thanks but it gave back this: unexpected T_USE, expecting '{'
That doesn't mean that people were randomly trying the subreddit name to see if it existed. A lot of people probably searched PHP in the subreddit list.
And...? Even if this is the case, it still applies to the underlying argument. It doesn't matter how they found it, it matters that they did, so that we can capture their traffic and prevent them from coming to /r/php. And phphelp isn't even a result of a subreddit search for "php."
I knew this was coming... Lol
Can you even give it a tiny look? There's been a thread about that today!
Heroku?
No, I'm not using it, I'm aware of its existence (thank you for pointing it out BTW), but I don't like enums in the database, I find it too painful to update the schema on several hosts whenever I want to change it. [This article](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/cookbook/mysql-enums.html) lists other downsides at its beginning. My main goal when using this enum class is to have a method I can feed to the choice validator.
&gt;basically anything You are a decent candidate for a junior position. In the US between $30k-$50k depending on how big the market is. That said...work on communication skills. Nobody will hire you if they cant understand you.
When i built an app a while back i forked the code and created a distinct demo version with restricted functionality, then setup a cron to reset the database once an hour. Another idea might be to add lower permissions to the guest/demo user.
Thanks for the heads up. What change is it that breaks compatibility? 
Or just update doctrine, there is a new minor version that fixes the issue.
Elastic beanstalks are on 5.5. They are mostly what I use to toss up PHP apps.
If they didn't say, then they are in the U.S., because obviously everyone on Reddit is in the U.S.
So this is literally ALSO called ORM Designer... what's the difference. Personally I found ORM Designer to be cumbersome, and quite sub-par, especially given the huge price tag. Thanks for the idea but I'll stick to manually typing my annotations and gaining knowledge of the tools I use instead of masking it with pretty UI.
It does.
I actually agree with this completely. I almost never use references for non-objects which is why this caught me out. In this specific case I wanted to use a number of objects to incrementally update a large array of data so it seemed like a good choice but in retrospect just passing around the array would be clearer and less error prone.
There honestly isn't a big problem with this. If you want your code to be more portable between frameworks, you can move those dependencies into a registration service class, but at the end of the day, you need to get the data from somewhere if you want to display it. What you DON'T want to do is overcomplicate your code and go out of your way just to reduce the number of dependencies that give you data you need anyway. As long as your RegitrationController is strictly for registration (e.g. showing the form, and handling the form input), then your dependencies are fine. What's a problem is when you have a generic AccountController that has registration, login, logout, password reset, and tons of other things that have several responsibilities that not every controller action actually needs. Focused controllers with a "lot" of dependencies are fine. Unfocused controllers with a LOT of dependencies, are not. I wouldn't sweat it too much if I were you, but if you are concerned, just add a layer of abstraction, shove those dependencies into a registration service object, and then just use that registration service in your controller: $RegistrationService-&gt;loadFormData(); $RegistrationService-&gt;registerUser($input); But again, all that does is make your code slightly more portable if you switched frameworks, you're still passing the buck on the dependencies to a different abstraction (which is fine as long as you keep it focused). Just be wary of putting too much logic into controllers, simple data injection/retrieval is not a big deal.
Sry and noted
Thank you so much! Now I know where is my problem. Some of the controllers are too broad like the generic AccountComtroller. Now I need to narrow it down.
Several folks have started work on different bits and pieces, though I'm not sure how close any of them may be to what you are looking for. I've listed the ones I'm aware of in my Community Roundup posts: http://hhvm.com/blog/4811/hack-community-roundup http://hhvm.com/blog/5429/hack-community-roundup-2
It's been awhile since I've used MySQL workbench. Probably haven't used it since '09 or '10. But at that time WorkBench seemed pretty slow, it ate a lot of memory, and it would crash fairly regularly when updating fields. I haven't come across those 3 issues in sequelpro.
This sounds a lot like a really expensive commercial CMS that I've worked with in the past. Sounds great.
Thanks for the tutorial! Just for future reference, PHP provides a function 'preg_match', for matching against regular expressions which would be better in this instance than doing it clientside with JS. As you're AJAX'ing to your own PHP anyway, this would stop anyone getting round the email validity check and potentially exposing errors in production.
Sadly it's not that simple - 2.4.3 changes _many_ other things with the consequence of breaking a good chunk of the Doctrine extension ecosystem. Infact I dealt with this today by [forking 2.4.2 &amp; applying only the creation fix](https://github.com/ptlis/doctrine2/tree/fix-2.4.2). In any project we use doctrine in we're using this fork until the etxtensions we depend upon are all fixed. 
I work on the Hack team at Facebook. The answer to this question is somewhat subtle. Moving your PHP code from PHP5 to HHVM is likely to result in a significant speedup, as others have said. How significant depends on a ton of factors. If you're already IO bound, you may not see much at all; if you are closer to CPU bound, speedups of up to something like 5x have been reported, though you are likely to get something somewhere inbetween. You should go and try it on your own code, with a real workload -- HHVM has a bunch of factors, notably a larger startup time, that make it not do so well on microbenchmarks, but on real workloads it should outperform PHP5. For maximum benefit, refactoring your code to get things out of toplevel and into functions/classes will help a ton (we can't JIT code at toplevel), as will setting up [repo authoritative mode](https://github.com/facebook/hhvm/wiki/Running-PHP-programs-with-HHVM). But that's just plain PHP on HHVM, not Hack on HHVM. What speedup do you get from then converting your code to Hack? It depends on how you do the conversion, but the answer is, at least right now, "not very much". If you just go stick `&lt;?hh` at the top of every file, instead of `&lt;?php`, and fix any incompatibilities that [come up when you run the typechecker](http://docs.hhvm.com/manual/en/install.hack.bootstrapping.php), then your code will very likely perform the same as before. Hack and PHP code have the same runtime representation, so you haven't really changed much. If you do that, though, then you aren't taking full advantage of Hack! If you go in and start adding type annotations, you can build up more and more information for HHVM to use at runtime. *This* process is what can speed up your code -- HHVM can generate type-specialized (i.e., faster) code in a lot of circumstances where before it might have not been able to infer the type. Don't expect a huge speedup here either -- this is largely theoretical right now, and there are lots of places we can be taking better advantage of the type information to generate faster code. (We don't do much with return types at runtime right now, for example.) But this is the part that might help, and might help more as HHVM gets smarter. But of course, keep in mind that execution speed wasn't the point of Hack -- it was about developer efficiency. Any performance gain is probably not going to be worth the effort going from PHP on HHVM to Hack on HHVM. The gain in developer productivity, though, probably is. So does moving from PHP5 to HHVM speed up your code? Very likely. Does doing a quick conversion to Hack speed it up? No. Does adding more type annotations speed it up? Maybe a little, maybe more in the future, but that's not really the point.
Your Repos sound like dependencies of your Form, not your Controller. Inject them into your form library du jour and inject said form into the controller. The controller doesn't need to know what composes a form, as long as it has one. If the form changes, so be it, the controller's responsibilities do not.
I personally prefer using MySQL's enum type over strings because it provides type safety, eg MySQL will return an error when you try to insert an invalid value, which can save you from finding millions of rows in a database table that have "Monady" instead of "Monday". (Though you do have to turn on strict mode, which isn't a bad idea anyway) I believe data validation should be kept in the database and out of the application. &gt; Adding new values requires to rebuild the whole table, which can take hours depending on the size. That's what I hear most often from people who are avoiding the enum type, but that scenario isn't realistic. I've only had to update a schema because of changing enum values a few times, and updating a table with 50 million rows only takes 10 minutes. Enums in general don't change very often. Aside from some crazy cosmic event we're not going to gain an extra week day, or a new gender, or any of the fixed list of values enums are good for. Plus MySQL only uses a single byte to store enum values, which is considerably less than storing the values as strings. And if that wasn't great enough, MySQL also lets you cast enum values to indexes (eg sunday = 0, monday = 1, etc) which comes in handy from time to time. For instance you could query for users who's birthday came at the end of the week using `select * from users where birthday_week+0 &gt; 4` or get the day of the week they were born using `select birthday_week+0 from users`. Anyway, just some thoughts.
Don't want to be a dick but Wordpress is not a framework.
it depends. was pretty easy for me, you only need to get 50% correct to pass btw
I think it's time that we start enforcing the rules. Don't you think everyone? It's not like its not clearly written in the sidebar. So, for support questions like this, please visit /r/phphelp.
Its amazing to read that someone else had almost exactly the same problems like me. I ended up changing my job, then quitting the new one shortly after. Luckily I had some side projects earning me some money. I completely pulled myself of from PHP, tried some new languages, and after more than 6 months I started PHP again. Much happier, "cooler" and wiser, things I learned in other languages benefited me a lot while going back to PHP. At my all time low just changing projects did not cut it for me. I just could not look anymore at PHP without feeling to puke.
What do you charge as a freelancer?
i see, it's irrelevant to have a reason to create a complex system like a framework. especially because there is wide array of frameworks already build that you can choose from that satisfies 99% of project requirements. a lot of logic in you post.
Really, do you remember the name of that CMS?
It's up for me.
yeah, right you are, guess that was a quick one. searching twitter actually confirmed for me that packagist was down.
I also get this. My location is southeast Asia. Tried with one ISP down and the other is UP. Not sure what happens, but's it feel like my IP is blocked.
[Cascade CMS](http://www.hannonhill.com/index.html). Their site doesn't really tell you much about the product, but if you read through the [Technical Primer](http://help.hannonhill.com/kb/technical-primer/cascade-server-technical-primer) and read around the [KB](http://www.hannonhill.com/kb/index.html), you'll get a good feel for it. The key idea is that all content in the system is an XML document of some kind. A Data Definition is basically that XML document (along with some data on what fields it has for the users to customize). Then you can apply a Format to the Data Definition to get Cascade to render it out to pages in whatever way you want. And a Block is just a Data Definition + Format + Data combo that you can stick onto pages or anywhere else.
In Symfony2, i use doctrine then do app/console doctrine:schema:update --force
The end of days.
at least I feel like I'm coding in those "sucky" CMS. I rather write code, something a drupal developer never says.
This should be stickied.
So, where does the schema come from though?
Thnx, but if i hate something that is shitty foo, baz, bar, qux shit. Give me real life examples, it's easy to use Foo and bar when you fully understand thing :) 
First you define how the schema structured in PHP file that works like a model (in MVC terms). Then do that command above. Doctrine will generate the schema and make sure it match the file structure.
Interesting, I'll check this out. Cheers.
This isn't a great idea on production servers. Edit: I should say why. This can lead to data loss. Imagine moving an email field from the users table to a new email_addresses table. Doctrine can't figure out how that should be moved so will basically drop the column and make a new, empty table. So schema:update is handy on dev but be careful!
The best mechanism for this is to use Doctrine's Migrations, which integrate into Symfony via the DoctrineMigrationsBundle http://symfony.com/doc/current/bundles/DoctrineMigrationsBundle/index.html This lets you write classes that control how DB changes can be applied and rolled back, so you get the right level of control over what happens to old data.
Yii does that too. I think they both got the idea from Rails.
Its not for me, but phil sturgeon twitted that it was down for him earlier.
I've been eyeing phpmig. It allows you to define migrations and their undos, stores the DB version in the DB itself and automatically runs migrations that haven't been applied yet. https://github.com/davedevelopment/phpmig
I think this is more what I'm after, yeah. Just didn't really know what to look for! Had a look at the migration docs, and it is exactly what I was after I believe.
I don't really see any point using Doctrine anyway, I just embed SQL into my DB models. Less crap to break.
I love SQL Server Data Tools for this. All the DB objects are checked in like normal source code and then a deployment tool determines how to make the target database look like my code. I almost never need hand written migration scripts. Alas this is windows/sql server only.
&gt; yum downgrade php54 php54-* This is obviously CentOS/Redhat yeah? The title is a little misleading - it's a distro issue, not an "AWS overall" issue.
It would be cool if there was something like diff but for SQL. You give it a file containing your current structure and a file containing the new structure and it dumps a series of ALTER TABLE queries to run.
Using PHP for this is overkill - can be done fully in Apache/Nginx rewrites.
No, my point is that his or her reason(s) are irrelevant to the question being asked. Is there a good reason why you would decide to provide or withhold support based on the answer to your question?
The newest PHP releases actually reverted this patch, allowing un-serialization for internal PHP classes, but we still don't have a resolution path for 5.6. Therefore wait for 5.4.30 or 5.5.14 to be released for your distribution. Here's what is being affected (what you should check): * internal php classes being mapped as entities * classes extending internal php classes being mapped as entities * classes that implement the `Serializable` interface and are mapped as entities PHP 5.6 will probably break compatibility here, completely disallowing `ReflectionClass#newInstanceWithoutConstructor()` on internal classes (acceptable, but still a bc break, heh) or the un-serialization hack. I wrote https://github.com/Ocramius/Instantiator to work on the issue and have it fixed before 5.6 goes stable, but I think that the fans of `ArrayObject` inheritance will be forced to stop extending from it. Note that the bug also affects PHPUnit and other mocking frameworks, as well as other data-mappers similar to doctrine. My personal advice is that internal PHP classes shouldn't be used with inheritance anyway. See discussion threads http://marc.info/?t=140145049200001&amp;r=1&amp;w=2 and http://marc.info/?t=140311127000007&amp;r=1&amp;w=2 for more information about what is going on here. 
The fix only works for applications that **do not** use Entities extending `ArrayObject`, and given the bug reports in the last days, it seems like a lot of folks are still doing that.
Yes it is. OP created another post entitled *Which one is best PHP framework* before creating this one. It's very common for PHP beginners to be temped to build one themself when they're faced with learning a framework, thinking they will understand it better/will be easier. Unfortunately PHP is a tricky language where it's very easy to get things wrong, especially security-wise. Combine this with poor dev skills and you will get a really shitty pice of code that should not be deployed to production. Ever. I saw this many times, devs thinking they can build better than Zend/Symfony/Laravel/Your-fav-framework-here and screwing things up. And after they get fired/leave i'm supposed to clean up their shit, ending up rebuilding it from scratch most of the time.
Well, AWS's CentOS-ish AMI, which Amazon controls the package repo for.
Question: why shouldn't you upgrade PHP in production? You mean like, ever?
Thanks, that's really helpful. I believe packages are updated on AWS in March and September so will have to wait a bit. We use instance-without-constructor occasionally in tests so will have a look at that.
How do you find it? I've used Pagodabox, Fortrabbit and Heroku with varying levels of success.
They are still mirrors of the CentOS base repo though? At least that's the case for Canonical Ubuntu repos and their AMI base images.
Or even better with AWS - machines are part of a launch configuration on an elastic load balancer - adding new machines should re-build them up with new packages/application code and then just drop the old ones from the load balanced pool. No need for DNS switching.
For a laugh I entered http://www.downforeveryoneorjustme.com/ into http://www.downforeveryoneorjustme.com/
Haha! "If you can see this page and still think we're down, it's just you."
I would recommend that you familiarize yourself with the symfony/http-foundation component which is used by laravel. https://github.com/symfony/HttpFoundation The symfony HTTP Kernel is another poppular component which provides an architecture for transforming the aforementioned request objects into responses, which is of course the high level job of any web facing API. It provides an abstraction on top of HTTP (Request objects and Response objects) which you can use as an alternative to global variables $_REQUEST, $_GET, $_FILES, $_POST, etc. This component is very popular and underlies a number of different modern PHP frameworks and libraries (symfony, laravel, silex, etc.). I mention this because you said you are working on an API. I would also take a look at fractal, which is a library for creating REST APIs. https://github.com/thephpleague/fractal Phil Sturgeon is a dev on fractal and has some good blog posts about designing REST APIs http://philsturgeon.uk/blog/2014/05/restful-urls-actions-need-not-apply
There's a misunderstanding. Escaping in twig runs htmlspecialchars(). The major goal is to prevent injection into our pages from user supplied data. So why is the view, of all places, doing this critical action? Why are we not providing safe data to the view already? Why are we not already providing data formatted the way the view requires it? Why are we piggybacking logic into a place it just doesn't belong? Imagine you're just installed a third-party template for the CMS your client is using. Everything is fun until six months later when they start receiving XSS attacks. It turns out the template wasn't properly escaping a value on one of the search pages. Now you have to do a full source review to see if this was an isolated mistake or if the template is systematically vulnerable.
Skipper is the rebranded "ORM Designer 3" http://www.orm-designer.com/ I have to agree with your review of ORM Designer. I'll have to try out this new version to see if it is any better, but I have to say the $400 price tag is a huge investment for a product that will get used probably only at the beginning of a project edit: In trying out Skipper, I have to say it has vastly improved. I'm still not sold on the price, but importing existing projects works much better, setting up inheritance is not terrible, and adding fields and associations is a bit less cumbersome. The exporting format for annotations is still a bit wacky (just doesn't quite follow our coding standards) but that is a relatively small problem.
Dead easy from the command line tools. You do ‘eb init’ in your git repo and it asks you a bunch of questions including what tech stack you want and what region you want it in. eb init To get your AWS Access Key ID and Secret Access Key, visit "https://aws-portal.amazon.com/gp/aws/securityCredentials". Enter your AWS Access Key ID (current value is “blah blah blah"): Enter your AWS Secret Access Key (current value is “blah blah"): Select an AWS Elastic Beanstalk service region (current value is "US East (Virginia)"). Available service regions are: 1) US East (Virginia) 2) US West (Oregon) 3) US West (North California) 4) EU West (Ireland) 5) Asia Pacific (Singapore) 6) Asia Pacific (Tokyo) Select: (1 to 6): 1 Enter an AWS Elastic Beanstalk application name (current value is “MyApp"): MyApp Enter an AWS Elastic Beanstalk environment name (current value is “MyApp-staging"): MyApp-dev Select a solution stack (current value is "64bit Amazon Linux running Ruby 1.9.3"). Available solution stacks are: 1) 64bit Amazon Linux 2014.03 v1.0.3 running PHP 5.5 2) 32bit Amazon Linux 2014.03 v1.0.3 running PHP 5.5 3) 64bit Amazon Linux 2014.03 v1.0.3 running PHP 5.4 4) 32bit Amazon Linux 2014.03 v1.0.3 running PHP 5.4 5) 32bit Amazon Linux running PHP 5.3 6) 64bit Amazon Linux running PHP 5.3 7) 64bit Amazon Linux 2014.03 v1.0.3 running Node.js 8) 32bit Amazon Linux 2014.03 v1.0.3 running Node.js 9) 64bit Windows Server 2008 R2 running IIS 7.5 10) 64bit Windows Server 2012 running IIS 8 11) 64bit Amazon Linux 2014.03 v1.0.3 running Tomcat 7 Java 7 12) 32bit Amazon Linux 2014.03 v1.0.3 running Tomcat 7 Java 7 13) 64bit Amazon Linux 2014.03 v1.0.3 running Tomcat 7 Java 6 14) 32bit Amazon Linux 2014.03 v1.0.3 running Tomcat 7 Java 6 15) 32bit Amazon Linux running Tomcat 7 16) 64bit Amazon Linux running Tomcat 7 17) 32bit Amazon Linux running Tomcat 6 18) 64bit Amazon Linux running Tomcat 6 19) 64bit Amazon Linux 2014.03 v1.0.3 running Python 2.7 20) 32bit Amazon Linux 2014.03 v1.0.3 running Python 2.7 21) 32bit Amazon Linux 2014.03 v1.0.3 running Python 22) 64bit Amazon Linux 2014.03 v1.0.3 running Python 23) 32bit Amazon Linux running Python 24) 64bit Amazon Linux running Python 25) 64bit Amazon Linux 2014.03 v1.0.4 running Ruby 2.0 (Puma) 26) 64bit Amazon Linux 2014.03 v1.0.3 running Ruby 2.0 (Passenger Standalone) 27) 64bit Amazon Linux 2014.03 v1.0.3 running Ruby 1.9.3 28) 32bit Amazon Linux 2014.03 v1.0.3 running Ruby 1.9.3 29) 32bit Amazon Linux 2014.02 v1.0.1 running Ruby 1.8.7 30) 64bit Amazon Linux 2014.02 v1.0.1 running Ruby 1.8.7 31) 64bit Amazon Linux 2014.03 v1.0.0 running Docker 1.0.0 32) 64bit Amazon Linux 2014.03 v1.0.4 running Python 2.7 33) 64bit Amazon Linux 2014.03 v1.0.4 running PHP 5.5 34) 64bit Amazon Linux 2014.03 v1.0.4 running Node.js 35) 64bit Amazon Linux 2014.03 v1.0.4 running Ruby 1.9.3 36) 64bit Amazon Linux 2014.03 v1.0.4 running PHP 5.4 37) 64bit Amazon Linux 2014.03 v1.0.4 running Ruby 2.0 (Passenger Standalone) 38) 64bit Amazon Linux 2014.03 v1.0.4 running Tomcat 7 Java 6 39) 64bit Amazon Linux 2014.03 v1.0.4 running Python 40) 64bit Amazon Linux 2014.03 v1.0.1 running Docker 1.0.0 41) 64bit Amazon Linux 2014.03 v1.0.5 running Ruby 2.0 (Puma) 42) 64bit Amazon Linux 2014.03 v1.0.4 running Tomcat 7 Java 7 Select: (1 to 42): 1 Create an RDS DB Instance? [y/n] (current value is "No"): n then you can start the stack with ‘eb start’ eb status will let you see the server’s status clobber it with eb stop and deploy updates with git aws.push super easy.
Damn! These bug reports have been appearing for over a year now and noone did anything.
Sure, but plenty of people use something else. For instance, we use centos proper on AWS (and also compile PHP ourselves), and I know plenty of people use ubuntu. It should really be "don't upgrade PHP from the Amazon Linux repos if you use doctrine".
They say in the issue that its not a high priority. A possible work around is to not use PHPUnit autoloading mechanism. You could instead make your own bootstrapper that instantiates the proper PHPUnit classes and then `$suite-&gt;run()` them. They are accepting PRs for the issue, though. Perhaps you might find some time to alter the logic and submit a PR?
http://isitup.org
I [figured out the why](https://github.com/sebastianbergmann/phpunit/issues/529#issuecomment-48418945) for you.
You force that motherfucker! He's YOUR bitch! $fuzzi = new Bitch(); $fuzzi-&gt;setName('Marsellus Wallace'); $fuzzi-&gt;setId($user-&gt;create((object)(array)$fuzzi)); EDIT: But if you really want, we can have Mrs Wallace handle that: class MrsWallace extends User{ public function create(Bitch $user){ return parent::create((object)(array)$user); } } $fuzzi = new Bitch(); $fuzzi-&gt;setName('Marsellus Wallace'); $fuzzi-&gt;setId($mrs_wallace-&gt;create($fuzzi));
glad i'm not the only one...
Cool, replied to your comment there
now kiss
Okay, but how does the controller/model/whatever know what escaping strategy to use?
&gt; As a rule of thumb I would strive to type hint only interfaces or a callable. Yes. Code to an interface*, not an implementation *interface in the context of abstraction, not necessarily a PHP interface.
This is not true; the passing grade has never (and will never) be revealed. I believe it's based on a curve, so a certain top percentage of people pass... this may be set in stone based on the beta testing (I did beta for PHP 4 and 5 certs) or may be continuously updated. Source: I've known a number of people affiliated with the certification over the last 8 or so years (as author of php[architect]'s Zend PHP Certification Study Guide) and nobody has been willing to give me a single solid answer :P
I was chosen test on my mac and it works great. Not sure what problem there is.