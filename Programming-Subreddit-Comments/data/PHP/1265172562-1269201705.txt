Explain what you mean by eval() testing harness? EDIT: Woah there with the downvote. I could answer his question but I would like him to describe what is on his mind as I'm seeing "how do you build an X widget without X", which to me the easy solution is "If you don't have X, why are you trying to build X widget?" If he's being more general in asking "how does one build a testing harness without eval()", I can refine the question to what is essentially "how can you build PHPUnit without eval()" and the answer is "They already have," with a caveat. Glancing over the PHPUnit code reveals 8 hits for the keyword "eval(", 4 of which are either stripos() calls or PHP documentation for a method "getEval()". 1 of the function calls is for the PhptTestCase extension (a wrapper to run tests from an external testing library), 1 of the functions is to create a mock class (only in the event the mock class is not already declared), another call is to generate a mock class from a WSDL (again, an entirely optional route), and finally the last call is to create a skeleton test case in the event that "No tests found in class" exceptions are raised. Long and short of it: Use good object orientation (or functional) practices and learn reflection API and you don't need eval(). Personally I would argue against even the superficial use of eval() to enable the use of WSDL mock definitions instead of manually forming the mock, and can't attest to the reason it's used with the skeleton, but it's pretty clear the actual functional part of PHPUnit does not need nor does it use eval().
&gt; Some people own shitty hammers but they still can hang a picture. "Some people" can apparently build houses with their shitty tools as well... and that usually ends in a bad/sad way :)
Believe it or not, not everything on this here Internet needs to be engineered to industrial standards. Some people just need clubhouses and shacks.
I guess it's so people talk about it. If they did show the code and it was crap, they would have a lot less publicity.
Or maybe publishing something is normally done this way in a professional manner. Especially an initial release.
I don't care if it's what's usually done, it's still wrong.
Define fun.
Automatizing the whole process makes a lot more sense. After all, improving your translation algorithm over time results in gains over the whole codebase, while in case of a rewrite, you would end up in the same situation just a level "higher". And hand (brain) optimizing is very-very tedious and naturally only results in gains in very specific areas.
So, I have to write c++ code? no php? :s it is php but you have to write in c++. Would somebody please tell me what's going on?
no, you don't have to write in c++. have you even read the article? you write php, then it's translated to c++. update: but don't worry, it has no real value for you. the performance gain is negligible for normal use.
todays JIT compilers are already quite impressive. think of hotspot (JIT), LuaJIT (tracing JIT) or V8 (AOT-JIT\*). \* i don't completely get what V8 really is. can you call it an AOT compiler? JIT compiler? both?
The problem with JIT for PHP is that you'd need long running code to identify hotspots, trace them, then compile them, and most of the time the PHP app just ends before it'd even make sense for the JIT to trace something. However profiling/JIT could be used in conjunction with opcode caches, and that'd be awesome!
go schlossnagle, you can do it! edit: i agree, tracing may be somewhat useless for php. the most promising projects come out of the llvm corner; see roadsend and nuno lopes' llvm-pecl. otoh i actually don't care that much. for my projects at work php is fast enough, and if i want to do something fun is use javascript/node. so why bother ...
I'm not arguing against PHP. [One could even call me a fan](http://zendcon.com/2009/speakers#4054). I'm not even arguing against Drupal, I use and maintain Drupal installs. I argue against the overly liberal use of eval() in Drupal and the shortcuts many extension developers take by using eval() in their code. Though my, and pretty much every single developer of note in the PHP community, experience using eval() only opens up stability and security vulnerabilities and destroys your ability to debug a program. It's not about giving a user a shitty hammer or a nice hammer to build a house, it's more like giving them a stick of dynamite.
Pretty much every single open source project rolls out the same way. It takes some time to get the wiki, repos etc. ready for public consumption, especially if you are going to be getting the kind of traffic/interaction this one will. I guess Linus was the wrong when he announced Linux before releasing the code.
I don't get it. Isn't a session exactly like this, without the hassle?
The idea is the same (if sessions use cookies), only sessions rely on serverside storage. This technique doesn't. The objective of the article was to explain how a procedure like this works internally.
&gt; Pretty much every single open source project rolls out the same way. No, not at all. And even if that was the case... it's wrong. Also, who talked about a wiki? The repositories are obviously already here, just hidden, because they want to build up the hype.
The fact that they don't show the code and deliver very few information about the restrictions is indeed concerning.
If they are I/O bound and switching to C++ improves their performance, then they just don't know how to use PHP properly.
Really, PHP was announced before being released, Linux was announced before being released, Reddit was announced before being released. Shall I continue? Also, keep in mind projects that roll out as OS that get lots of eyeballs tend to start out in house, then get ported out to sites like sourceforge/github etc. The people working on the project may or may not be the ones that are tasked with opening up the repos. (In this case the repo exists internally it will be publicly hosted at github) these are all steps that take time - maybe not for you since you apparently don't have day to day tasks as well. But there is nothing uncommon or incorrect about what they are doing here. Shit, worst case, it will be available for consumption within the month. This is normal release cycle, especially for a first release of a project of this scope. Get over yourself.
I'm not sure why you created another PHP sub-reddit. PHP is quite quiet already. 
I'm currently working on a project using Solr. I'm new to Solr, but every day I'm surprised by yet another incredible feature. You can tweak it for incredibly fine grained control that just isn't possible using a relational database system. It was really the speed difference that made us choose it over MySql for live searching. All of the queries that would normally 1/10 second to 1 second to complete are all done now in milliseconds. As you say, the REST call does add to the time slightly, but that can also be optimized using cache headers and other methods. Even so, it's much quicker than the db calls that were being made. There is no way we're going to give up the built-in facetting, word stemming, synonym finder, foreign language support and the wonderful "more like this" feature to try and reinvent the wheel in the code.
You're probably right. I thought it was a good idea until someone pointed out that sites like stackoverflow.com and webdeveloper.com already have a much larger audience. So, yeah, it's probably a worthless subreddit. Oh well.
Well you're doing better than most of the PHP subscribers, they don't talk! If you need any PHP assistance I'd be happy to help.
Actually, I got all the help I needed on the [first post](http://www.reddit.com/r/PHPhelp/comments/axm8s/help_preg_matching_series_of_words/) in my crappy subreddit, lol. I never wanted to spam /r/PHP with php help because the description says that this is for "New(s) that relates to PHP, along with tutorials". Posting asking for help could potentially change this entire subreddit and I didn't want to do that... I appreciate your willingness to help though. Thank you.
I think, it's a good idea. I like the primary groups to be a place for interesting articles, not for questions. But maybe that's just me...
Citation needed. Publishing a repository, especially with git, takes a few seconds. If you look at github.com/facebook, you'll see they have some private repositories, they likely just have to click. There is no excuse. It's all marketing.
I like the idea and feel more comfortable asking questions there like you noted the other one should be more for new/discussion on the topic.
Agreed. That was the whole idea of it. Granted, there are other places with a larger audience for PHP question (forums, stackoverflow, etc)... but why not here too?
Does anyone know why that first post isn't showing up in the /r/PHPhelp subreddit?
I'm not impressed. The basic idea of the post is a server-stateless cookie protocol using HMACs to ensure authenticity. Instead of storing the user-id in a session, you store it in a signed cookie. So far so good... The replay-attack is the obvious problem and the authors claim to address it by adding $_SERVER["SSL_SESSION_ID"] to the hash. That value is a) changing (esp. once you start talking to a different server) and b) moves the server state-keeping to the SSL module. I don't think we've gained anything here.
The SSL session ID is the only setback of using this technique, yes. But can you point me to a more secure method? I haven't read/thought about any better.
It still amazes me that there are programmers who haven't used this. Whenever I set up a development environment this is one of the first things I install.
Stack Overflow.
I was wondering the same thing.
They said in the talk it would be released "later this week".
Hype.
The blog entry from Tuesday: &gt; As I'm sure there will be plenty of questions, starting this evening take a look at the [HipHop wiki][1] or join the [HipHop developer mailing list][2]. [1]: http://github.com/facebook/hiphop-php/wikis [2]: http://groups.google.com/group/hiphop-php-dev
Yep, but if you watched the talk they explained that it isn't up yet.
tl;dw :-) 40 minutes. And normally (outside Facebook) long talks are recorded before posting a blog entry. Very strange and confusing. And another strange thing: This isn't ready. It's just a beta. And they run 90% of Facebook with it?? But I'm still curious. I want to see if this runtime/framework for the generated C++ code could be used from other programming languages as well. And if the memory usage of generated HipHop code is less than running normal PHP.
Here I created *another* subreddit call r/PHP-suck-my-dick. It's where PHP programmers can come and give me head and I can blow it all over their faces. You're welcome.
There are two things I'm curious about: 1) Can the generated C++ code perhaps be used to compile an extension for regular php. 2) The type-inference engine.
Well, Facebook is not very concerned about quality. I've seen so many stupid bugs in production...
yes. hiphop couldn't be more irrelevant to 99,9% of php programmers, but people hype it as if it was disruptive.
@1: that would be interesting, but i heavily doubt it. * they don't get tired to stress the incompatibilities between existing extensions and the hiphop. * hiphop wraps a webserver etc. around the whole thing; though there may be the possibility to wrap the extension definitions around it instead. * i'm pretty sure type incompatibility between hiphop and the zend engine prevents it.
99.9% of php programmers are still oblivious to the fact that it exists. Regardless of hype, it's still cool.
Indeed, debugging the old **var_dump** way seems something from the caveman days and lets not forget profiling either.
I can see it. [edit], [pic](http://www.ubuntu-pics.de/bild/41000/screenshot_002_Oow3yv.jpg)
Really? All I get is the "there doesn't seem to be anything here" message no matter what tab (new, hot, top, etc) I click on. Strange.
Speaking of `var_dump`, even that is enhanced. No more do you see people wrapping `print_r`'s in `&lt;pre&gt;` tags.
The HipHop wiki link just redirects to github home. The code was supposed to be up on Tuesday but it sounds like they've missed the launch date. Probably for the best (maybe they found a serious bug?)
Something that makes my PHP execute a shitload faster on the server is anything but irrelevant to me. Maybe if you're a wordpress barista, okay, but there are people who use PHP for more serious things...
I'd love to, but I don't think it's possible. I came up with a similar idea like presented on that website for avoiding having to keep server-state (=sessions). I discarded the idea, because it was open to replay attacks. In order to avoid replay attacks the server side must keep state somehow. I don't see a way around it. If you see something like this that is truly stateless and secure against replay attacks make sure to point it out to me :-)
I got more out of the zend cast for installing php unit that I would ever suspect. I would love to see more of these. 
Where to get started using this if you're new to PHP?
This [devzone article](http://devzone.zend.com/article/2803) would be an excellent start.
* use PHP for something you should have written in C in the first place?
Ahahaa, okay, fair enough, I know that it's really my database (and probably more likely my inefficient queries) that are slow. But c'mon, it sounds like fun.
Point being that hiphop is not really a php-optimiser. It's a tool to convert your code to C++. Unless you actually want to program your web applications in C++, you have little use for that.
Will it not perform a similar task to an opcode cache, though, and possibly in a more efficient fashion?
Power 106.
Is there no easier way in trying 5.3 other than XAMPP?
nughhyeah. kind of. the result is somehow comparable. atm, php creates bytecode that is cached by php optimizers like APC. hiphop creates binaries that are stored. the entry point is different, though. php bytecode caches still go through the classical php path - apache, php, zendengine, etc. hiphop completely bypasses all this by extending the converted php app with their own webserver, if i read that right. on of the strenghts of bytecode caches is invalidation: if you replace the sources, you get the new app (most of the time, apc can be configured to use manual restarts for a bit of additional speed gain). hiphop makes you do the [compilation cycle dance](http://xkcd.com/303/) all over again.
i can't promise i won't bite, but if you're still interested ...
Do you think this could be used to compile PHP into binaries? I could see this becoming incredibly useful to many folk.
True enough, one of the reasons I love interpreted languages is the sheer ease of write --&gt; run that compiled languages will never be as good at.
Glad to hear you enjoyed the screencasts! I'm trying to be disciplined about putting up new content weekly.
that's nonsensical. afterwards you're always wiser, but even now C wouldn't be a viable option.
Time to call BS. All problems / bottlenecks / missed optimizations or migration issues aside, if switching to HipHop takes your typical response time down from say 130ms to 90ms, you're winning - http://www.useit.com/papers/responsetime.html . Google have shown this to be true in practice - http://mem.to/t/1c9E &gt; If you answered even one question with "No", then you don't need hiphop yet. You're right in saying HipHop isn't _needed_ by most sites happily chugging along with standard PHP just like you don't _need_ 100Mbps DSL to watch YouTube and read reddit. That doesn't stop them from being nice to have. From what facebook has said about it, there does seem to be a considerable performance advantage to be had from HipHop, _perhaps_ for little or no effort in rewriting code.
&gt; hiphop makes you do the compilation cycle dance all over again FUD. Given it hasn't been released yet, you can't say that. What's more it's very easy to imagine it can be made to behave like [JIT](http://en.wikipedia.org/wiki/Just-in-time_compilation) from a developers perspective, such as only doing work on PHP scripts which were changed or simply executed as part of a deployment process, in much the same way people use tools like yuicompressor i.e. you use the normal PHP runtime to develop against and assuming tests pass against HipHop, you're not ever aware of it. Do you think facebook would really use this if frustrates their own developers?
&gt; 99.9% of php programmers are still oblivious to the fact that it exists source?
When did you last write a PHP extension?
Years ago. I did however write a bunch of Cython code the other day.
It's an extrapolation from all the shit PHP code and thus coders/hobbyists out there.
Is this your site? If so can I make a suggestion on some different topic? I can't tell you how many times I rtfm and still find a lot of topics that aren't really gone over very much. And the knowledge base for Zend Framework isn't as great as I would hope for. I ask around on Stack Overflow or on zftalk but often the people at those places don't have the knowledge either. 
Bearing in mind that Cython's tagline is "a language that makes writing C extensions for the Python language as easy as Python itself" and assuming you are a pragmatic programmer with real world experience on projects with real budgets and deadlines, are you still seriously advocating web programming in C?
Totally, sometimes you need to get closer to the steel for mathematical or batch work. I assume you are a PHP developer, I do 95% of my development in high-level languages too. I'm just saying you might end up doing something random that can easily be compiled and forgotten about. I use C for some parsing tools mostly. I run a multi server real estate listings network.
sure thing... either here or on the zendcasts forum: http://www.zendcasts.com/forum
It's more sad that at the time of me posting this comment 8 people found this interesting enough to upvote.
extract() is not evil, it's potentially dangerous. There's no reason to believe they're doing extract($\_POST) or anything (I hope we all know the dangers of having register\_globals on). Within proper scope and in a carefully controlled context, extract() is a perfectly acceptable part of PHP.
Can you please tell me what the security issue is or are you do you just think everyone who is related to "security" are supposed to be infallible unlike the rest of us?
Not really a first look. Just a pointless second hand regurgitation of information. You can get all the information available in first hand form here: http://developers.facebook.com/news.php?story=358&amp;blog=1
The server should be configured not to show errors to the world.
Fair enough :)
If the name of the site/magazine/whatever has "world" in it, you know it's just a bunch of advertisements. 
Does it have subversion integration? I'm using Eclipse with PDT and subclipse currently... 
work on a project with more than a few files. 
lol.... agree. I tried to edit it years ago and what a nightmare.. 
 include($_GET['muhaha']);
Yup - http://netbeans.org/features/ide/collaboration.html
Hacking on it is one of the things I have to deal with on a daily basis. I would never do so voluntarily.
&gt; FUD. Given it hasn't been released yet, you can't say that. uh, if i spread fud i didn't intend to do it. you're right: i'm sure developement and testing still runs on the easily maintainable php/zend-stack. i also think not much changed for the FB devs, because they'll most likely have dedicated build-and-deployment cycles and teams, so the ordinary dev doesn't have to cope with it. still, hiphop and the zend stack work differently from the conventional php approach (interpreter/JIT module), and i'm pretty sure php would not be as popular today as it is if it always worked this way. no, hiphop is a very specialized solution for a yet unique problem. &gt; Do you think facebook would really use this if frustrates their own developers? to the contrary - they've made it clear they're trying to avoid frustrating their devs more than anything, e.g. by forcing them to code in c++ in the first place; hiphop itself is nothing else than a big excersize in don't-frustrate-the-devs, but it definitely comes at a cost.
What kind of ass-ignorant motherfucker uses Futura for their body copy? I had to edit the page in Firebug to make it legible. Much to my disappointment after that work, it turns out he's butthurt because Facebook shot down his compiler.
Database database database. XML is slow, especially when using large amounts of data (which a CMS will use).
I haven't worked with XML files specifically, but I did a lot of flat file stuff originally when I made small PHP scripts. I sort of doubt you'll see a performance difference on a small site. If we're talking about a professional host, the improvement my be minuscule on the flat file side. If we're talking about something that just can't handle a lofty database server, sure flat files might be preferable. The most annoying thing about flat files? Write permissions on a host you don't control. Yeah, this is probably beyond what you should care about as a programmer, but I know when I was dealing with PHP for the first time I never had a firm grasp on this. It's just one of the pluses of using MySQL or something. Usually, properly securing files containing database info is an awful, awful problem as well. &gt;_&gt; But going back to the argument of speed -- there is some benefit to using a database. There are lots of options for optimizing your database, perhaps code that has already been written that you might apply. I have sort of fallen out of the PHP scene a while ago, so maybe someone can fill in? Another option: abstract database calls and allow for multiple types and let the user chooose. PHP also supports SQLite, which is a flat file database with a lot of good functionality too.
XML really isn't intended for data archiving and retrieval. It's pretty much only good for transferring object state from one location to another. Sure you can query it with XPath, but it's clunky and not really an acceptable substitute for a relational database. If you dont want to go the MySQL route, there's always SQLite, which is surprisingly robust given its small footprint. SQLite is the primary storage mechanism for iPhone apps and AIR apps, and it is supported by default in most PHP distros. I'd go SQLite if I were you.
I cannot agree more, but I doubt this will be a good enough answer for the OP (having been there). Simplicity can be hard to convey
As lastkarrde said, but to get more specific: DBMS! DBMS DBMS DBMS DBMS DBMS. PGSQL, MySQL, MSSQL, Oracle, *SOMETHING*! DBMS' makes things incredibly fast mostly due to the below: # They're servers that try to reside the entire database or the most accessed stuff in memory. Memory is incredibly faster than standard hard drives and still marginally faster than solid state drives. This cuts down access time, especially if you communicate with the server over a named pipe or a local socket as there's no OS overhead for file access (but there is network overhead, but more on that later) # Indexes! If you properly index a normalized, well abstracted database then you will see nice speed increases when joining tables together or getting data based on its ID. These are things flat file databases simply cannot do, and something that SQLite is only now getting into (I THINK sqlite is only getting into this, i could be wrong). # Network overhead is usually better than disk overheard for stuff like databases. Don't get me wrong, for caching small amounts of data I enjoy having some sort of file with data serialized as the access time for the minute amount of data is quick. But this isn't data that is updated often. # When you get a decent sized database and want things faster, next step is Memcache. This serves as a volatile (as in, if its restarted all data is lost) sort of key-&gt;value storage in between the database and php (or whatever) to cache stuff that you would want to cache; be it complex queries that are used a lot, or whatever. If you write a CMS and expect concurrency (which is a huge deal) flat files are not going to be the solution.
Exactly: XML is for data transfer, databases are for data storage.
&gt; In my particular case, I wouldn't loose any functionality, but I can see gaining in terms of performance. A database will perform magnitudes better than an XML file or some home brewed, file based system that you can make up.
srsly?
It makes sense in some instances. I put together a CV recording application recently, and chose to store the CVs as XML. It allows a variable structure, allows changes to that structure over time, and keeps the number of tables down to a minimum. XSLT is used to transform the CVs into various forms for e-mailing, displaying, exporting etc. However, I did it for flexibility, not for performance.
SQLite? RDBMS that acts and queries (mostly) just like MySQL, but is portable, since it is a flat file.
How do you think this messes with template code like Smarty? Performance-wise, it appears to be a beast. 
I'm currently working on a site that needs both. User/logins/basic functionality is all SQL DB, but the content the users generate can be extremely complex and can be exported en masse to other non-web oriented programs. The XML gets stored in the DB as a large text at a "sectional" level to be compatible with the DTD. 
I tried something similar. Once your file reaches around 300k you lose speed compared to MySQL calls. Also, race conditions can be a problem especially if you use comments or track various stats.
Instead of using xml I'd recommend serializing the data to PHP includes that return an array, so videos_db.php would look like: return array("foo" =&gt; array("title" =&gt; "OMG Ponies", "file" =&gt; ... ); the benefit you get is that opcode caches like APC will make loading this file much faster than loading and parsing an xml file. Using a return will allow you to control how the data is loaded, for example: $videos = include "videos_db.php"; 
Way back when, I did what you are suggesting. It was born out of necessity because the 'data' came to us as very legible xml. The appeal was that we could look at a file and 'see' the data and the way it was structured led to a better overall understanding. It was good for human legibility, but not great from a systems perspective. When we found ourselves building xml 'indexes' to better access our xml 'records' (parsing big directories of flat files sucks), it became clear that we were losing performance on both sides. We built a very nice xml-&gt;sql import/export routine from scratch, way before simplexml or xmldom, and we were much happier. That said, I have made a light cms intended for static sites of 2-20 pages, which stores each page as xml, parses with one of several templates, and stores a static html page for display. It's fast, but I'm sticking with sqlite when I need lightweight, one-file databases in PHP. Hope this helps!
This is good advice, I don't know why you were downvoted.
You know what would help? A link to the blog you are talking about! ;)
I concur.
Doh. Thanks!
Good. I'm just starting to study Python and Django; I'll keep an eye on this
You should make one of your first posts why you would want to change in the first place.
maybe it should be written in django/python?
Excellent idea! It will probably consist of the following points: messy naming conventions, commercially backed (zend), no unifying framework (ruby has rails, python has django, php has CakePHP, Symfony, Zend Framework and CodeIgnitor) If you can think of any other points, please mention them! thanks.
I'll get to it :P I plan on converting one of my smaller client websites to django for practice, then writing a blog from scratch. I may use it for the site, but maybe not. I like using google's blogger.
Well, the things that you posted as negatives I see as positives. So I don't think I will be much help lol. You basically described php as a flexible, large business backed, with multiple framework options. The only people that wouldn't work for would be someone that has to have strict rules in order to not fail, people that believe that home grown projects are the only way, and people that cannot make up their minds.
**Messy Naming Conventions**: This can't be a positive thing. This blog post puts it nicely &gt;For example, if you want to convert special characters to HTML entities, you use the function htmlentities (Words glued together). If you want to do the opposite, you use its little brother function html_entity_decode. For some reason the words are now separated by underscores. Why is this bad? You know there is a function named strpad. Or was it str_pad? Every time you have to look up what the notation is or wait for an error to occur. Functions are case insensitive, so for PHP there is no difference between rawurldecode and RawUrlDecode. This is bad too, because both are used and because they look different, they will confuse the reader. **Commercially Backed**: The performance of PHP can be increased to 500% by using caching [benchmarks]. So why is caching not build into PHP? Because Zend, the maker of PHP is selling its own Zend Accelerator and of course, they don't want to cannibalize on there own commercial products. **Many Frameworks**: You're right, this can be good as well as bad. I just like one main framework that everybody uses. Anyway. I don't feel like starting a php vs django (or others) thread. I'll just take the top few arguments against php, and use them.
&gt; Commercially Backed: The performance of PHP can be increased to 500% by using caching [benchmarks]. So why is caching not build into PHP? Because Zend, the maker of PHP is selling its own Zend Accelerator and of course, they don't want to cannibalize on there own commercial products. This is not true. Zend Optimizer+ has been free for quite some time now. It's included in the free version of Zend Server. And APC will be bundled in PHP 6.0.
Okay, take that, turn it into 10 things and why Django is better and you have a good blog post :) I knew I could help lol. I suggest adding some reasoning behind your framework conclusion as well. As right now that is pretty weak sauce. 
I am not trying to convert people, I am helping people that want to convert. I've been a php developer for years, and dislike it enough to want to move on. Simple :)
&gt;Messy Naming Conventions: This can't be a positive thing. This blog post puts it nicely This is 2010, most people have an IDE that will give argument hints. This is such a non-issue it hurts. &gt;Commercially Backed Backed but not owned. Not all php internal devs are part of Zend. &gt;So why is caching not build into PHP? Because Zend, the maker of PHP is selling its own Zend Accelerator and of course, they don't want to cannibalize on there own commercial products. This is the worst kind of FUD ever. Zend isn't the "maker" of php, just a key player, but more to the point there are 5 or 6 different caching engines out there. If they were to choose one over the others it would devolve into a huge war, and doesn't make much sense anyways. &gt;Anyway. I don't feel like starting a php vs django (or others) thread. I'll just take the top few arguments against php, and use them. Thats fine, and I agree that flame wars on languages are pretty stupid. That being said if you're running a blog you should consider experimenting with things like fact checking rather than posting a few points you probably found on google that are clearly irrelevant.
I don't want to jump in and criticize you too, [but i will just leave this here](http://wiki.python.org/moin/WebFrameworks) :) I think Python might have even more serious frameworks than PHP has, it's just that there is one big well know option. Well that and the fact that PHP is already sort-of a framework in itself, where as you need to write much more code to just achieve the same thing in Python if you want to have a simple static website (when only using the tools that come build in)
@ naming conventions: a non issue? seriously? just because some lazy people use IDEs doesn't mean that its ok for the language to have horrible function names @ "fact checking before posting points that i found on google" i didn't start a blog on why to switch to django. i made a blog about how to do things in django using php's terms.
While I agree that the naming conventions are an issue to the more seasoned developers, calling people lazy because they use IDEs is so far detached from reality that I won't discuss it further. Now this idea on naming conventions. It's not a winnable battle. If the PHP devs somehow decide to have a proper naming convention for all their functions and proper arguments, this would require the majority if not all of the PHP developers to now learn and remember the difference between PHP $x that does this, and the PHP4/5 people will continue to use because this breaks compatibility with pretty much all applications written in PHP. You could argue that they could offer a backwards compatibility mode, which misses the point entirely. People will continue to use the BC mode because there just isn't a big demand to switch what has already been established in this language. They don't necessarily win having crappy naming conventions with the more conservative developers out there, but they will certainly do better sticking with what they have right now than changing everything for the sake of making a few people who will whine about something else in php to stop whining about naming conventions. That's fine that you made a blog in regards to django -&gt; php or whichever, but Zend Accelerator is FREE. As in, it doesn't cost any money. As in, it's still free. As in, I don't recall it ever costing money ever. If you're referring to Zend Guard, that's a different story, but ioncube doesn't sell their php compiling/encrypting software for free either. A simple case is that caching probably isn't needed for the majority of PHP sites on the web. Those that do need it, use it. You're completely misinforming the people that will be reading your blog on this particular issue, and that does more harm then it ever does good. Also, very few people work who work for Zend actually work on PHP5/6. Perhaps you should subscribe to the php.internals mailing list for some extended period of time and learn who's behind the scenes and that decisions are made.
if you want performance i have no idea how XML could be faster than a traditional RDBMS. xml just isn't built for speed, but for convenience.
i think it could be dangerous. apc is for rarely changing code - data != code in php. there could emerge caching problems; then you'd have stale data. also, is this size-efficient, or would apc start to throw out other, real code as soon as your php-data-files get too big? if data rarely changes, and there isn't much data to begin with, you may not notice the difference and definitely see a speed improvement. but still, i'm sceptical.
I like what your doing - people sharing their experiences with things is one of my favourite things to see. But, isn't "converting from PHP to Django" kind of like saying "converting from bricks to scaffolding"?
Regarding PHP, I find that it sucks a lot less after I started to use Doctrine and Symfony. All that ugly, stupid db (and other) code is now neatly swiped under the frameworks rug. 
You might find some inspiration in [this site](http://railsforphp.com/) (If you don't know it already). I found it quite useful for a Rails job I took last year.
Yeh, technically it should be "Converting from PHP to Python to you can use Django" but meh, I'm sure people will figure that soon enough.
PHPtoDjango sounds alot like conversion. It seems like you are comparing the benefits of a framework with a programming language, it would have been more fair to say CakePHP to Django, or just say Django FOR PHP developers.
The biggest thing people will find a problem is that there is no obvious url parsing or anything when you work with plain Python. Django is there to offer that rudimentary web framework to make Python more like PHP... but completely different at the same time.
I don't think using an IDE makes you lazy. There is a key rule at work here. Work smart and not hard. Your statement about using a IDE would be similar to me stating that I think construction workers should carry everything by hand instead of using a wheel barrow.
This is a good suggestion. I am not against someone doing this, just think that with some planning he could do a real good job. 
I use VIM.
I used Vim exclusively for 5 years. I learned PHP using VIM and it is a powerful tool. I use Zend Studio now. I can tell you that it saves time without a doubt. At one time I did some stats on my speeds using both systems. After the short adjustment period I improved by about 20%. The key is to not let anyone know that you are that much faster now so you don't get an increased work load.
One question: django is a framework, and PHP is a language? I tried out Django some time ago, to me it seemed very much a framework specifically directed at database driven sites. The reason I ventured into Django is that I have had good experience with Python. I've only done one minor thing (but important to me) in Python and I liked it. What I needed was something that let me do various computations while the final presentation wasn't important as results were created as finished reports in some downloadable format. My impression is that Django is not well suited for that type of tasks - at least it seemed to me that I had work against the logic of Django to make it work. Combined with the learning curve I gave up. Yeah I'm still looking for options to go python.
Okay I have thought it over. Here are some things I would like to see good videos about. Decorators, these are a strong part of the reasoning for using zend framework. But the documentation is sort of lacking. I would like to see how to create Custom Decorators. Using Dojo with Zend, the integration of something like this is great, I would like to see more advanced uses and explanations on the settings you can use and where to find out how to specialize it all.
Oh hungarian notation, how I despise thee!
love it, thanks
When I look at SOAP, I *don't* want to look at XML. In fact, I don't even want to know that XML is involved, just like a don't want to know about the cables and routers that lie between me and the SOAP destination. Is that even possible?
Unless you're expecting 3rd party apps to be connecting to your site and want an API based on a standard like SOAP, there is no reason to use it. Just communicate however you want. Personally, I just send delimited lists back and forth or just post variables. Google makes calls with certain parameters and gets javascript back that it just evals. 
rofl
Though interesting, the article's usage of PHP4-style class definition makes me cringe.
I used PHP4 style because it is the default for CakePHP bake console tool. You could say so in the original post, and I would appreciate and respond.
phpmailer?
No idea, but you can knock together a basic MTA in PHP in 45 minutes, rather than googling it! That said, wouldn't recommend doing so. You can connect to remote smtp servers natively.
You can authenticate to an external SMTP server with Zend Mail in about 5 lines of code or less (like, send mail via Google). [linky](http://framework.zend.com/manual/en/zend.mail.smtp-authentication.html)
"Test Mail Server Tool"? EDIT: I have it installed but can't find a linky right now. EDIT2: [Tada!](http://www.toolheap.com/test-mail-server-tool/)
This is the one you want. Zend Framework is great.
Swift Mailer is pretty slick.[link](http://swiftmailer.org/)
Do explain... What in cakephp doesn't make you cringe?
I always stick ssmtp on new machines, saves the hassle if configuring an MTA beyond the one option of "relay host". May be outside of the scope of op's request though.
This is what I've installed on my server and it works well, but like you say it may not be what Jadedknight is looking for.
this is what i use.
&gt; Though interesting, the article's **usage of PHP4-style class definition** makes me cringe. Please take notice that CakePHP isn't mentioned anywhere in my message. Also, to address your question: the "var" keyword in particular. It indicates a lack of understanding object-oriented programming fundamentals (using PHP4's antiquated "var" keyword to define properties, where access modifiers -- like *public*, *private*, or *protected* -- would have been more appropriate). Although it is an effort to ensure support in a PHP4 environment, it should be avoided (Zend does not provide updates to the PHP4 code-base, and PHP4 should be regarded as a dangerous security hole).
Another upvote for phpmailer. You can tell it to use a local 'sendmail' style mail server, a remote or local smtp server with or without authentication.
PHPMailer is a terrible piece of software. Check out the sourcecode... *shiver*.
SwiftMailer is incredibly well designed. Its source is worth analysing. 
It's funny because it has the word "fap" in it.
I never said it was good. But it was the first thing that popped into my head.
I don't worry about code over-optimization too much. It's nice to have this sort of thing in back of your mind while coding, but I don't spend valuable billable hours eeking a few more milliseconds out of loops and such. What with the Zend optimizer, eaccelerator, memcache and fine-grained output caching, you can write sloppy code that flies. Anyhow, isn't it usually the database connections that are the bottleneck in most apps? I've just started using Solr for my latest project, and MySql queries on a huge dataset (over 5,000,000 records) that would have taken .5 to 1.5 seconds to complete, are now done in &lt; .1 seconds! I'm loving it so far. Oh yea, and that comment about using single quotes vs. double quotes supposedly is no longer true in newer versions of php http://spindrop.us/2007/03/03/php-double-versus-single-quotes/ (that's not the only article that claims this)
Masturbation jokes aside, is Guru.com a good place to find work in PHP/etc? At first glance it looks much better than elance or rentacoder
Where's [Captain Obvious](http://www.reddit.com/user/CaptainObvious) when you need him most?
The class does not account for PHP's implicit call to __destruct() at the end of execution. If the object's close() method is called first, you will run into problems.
I honestly don't think it seems any better than either of those two, but it's been quite some time since I've used any of these. I just started up again recently after being laid off and knew Guru from some things I'd done at my previous job. It works sometimes, but like any freelance site everyone wants the world done for $50. I think it's easier to get jobs than RaC these days though.
I never said you said it was good ;) Seriously though, SwiftMailer is the way to go.
Sure! That's something I could probably claim responsibility for, as I used to do a good deal of game development. The habits for optimization from there have carried over into the other languages I use.
And as a follow-up, I just added something to our internal tracker to implement a singleton system for those of you who don't like globals. Thanks for the idea.
Honestly, I didn't get as far as to actually look at the code. When the examples (http://n2framework.com/training/) are written with intermixed PHP and HTML, with asp-style tags, I assume that the framework is of equal or worse quality, and therefore not worth my time. Feel free to tell me if I'm wrong, but feel more free to write some sensible examples.
I suppose that an understandable assumption. The code you see with mixed ASP-style tags are simply the first template system we packaged with the framework. Instead of wasting our time building something that's overkill like Smarty, we decided instead to simply build a system that changed &lt;% and %&gt; tags in a .tpl file to their &lt;?php and ?&gt; equivalents. We won't be changing our example as there's nothing we could do to make them more 'sensible' to someone who makes quick assumptions like yourself, but we are releasing an additional template engine with the next version of the framework. Thanks for the comment anyway.
The sample code is hideous. Very difficult to read - that might be worth improving if you want people to be interested in why you think you've created a better framework then the other ones out there like Kohana, Zend, CodeIgniter, CakePHP, etc.. &lt;% if(isset($message) &amp;amp;amp;amp;amp;&amp;amp;amp;amp;amp; $message !== '') : %&gt;&lt;br /&gt;
Also, if you're going to make a training page that contains a lot of code examples i would not use a 3 column layout. The code div cuts out like 10% of the code because you only have 505px to use
Hmm! We threw a WordPress install up for the Blogtorials, but I rarely work with WordPress. Guess I'll need to find a better plugin for syntax highlighting or including code on the posts. Thanks for the heads up!
What's the purpose? I mean - What didn't you like about existing frameworks? What is unique about n2?
Singletons are globals.
Was a little hard to determine if zewa was objecting to the use of variables in the global scope accessed using the 'global' keyword or if they just didn't like the idea of globally available entities. I took a guess and went with the first.
The system is actually built off of a framework I first had in PHP 4 from about 2001. The system had evolved a bit over the years, but I wasn't really satisfied with it anymore and wanted to start with a clean slate. As for what makes it 'unique', not really sure you could say any framework is 'unique' these days. We tried to concentrate on simplicity and extensibility so that we could easily adapt the system to whatever the situation required without too much effort. Beyond that, I honestly couldn't provide a much better answer. We didn't build it with the intent of making "the next great" PHP framework, we just wanted to upgrade our approach and share it with anyone who might be interested.
Aside from the use of globals, it looks interesting. You should look into PHP5.3's namespace feature, it would definitely help you organize your code.
We're all pretty well versed on the changes that have come through with 5.3+, but the more interesting question to me would be what you think could be improved with our organization through the use of namespaces? Just curious if you have some specific ideas or were making a general statement (none of the three of us are particularly interested/excited by the namespace addition to 5.3).
For one, separating the various forms of functionality (database access, event handling, logging, etc) into their respective logical grouping -- or, more specifically, classes and namespaces -- would help managing a large code-base. Secondly, taking advantage of the class auto-loading would ease file management.
Putting aside our distaste for PHP's implementation of namespaces, I think one thing that would limit us from doing this currently is our desire to continue being compatible with PHP 5.1+. I suppose it'd be easy enough to build a separate branch for the purpose of adding newly supported features like namespaces, but I just don't think it would be something worth doing. We try to keep a very small footprint with very specific naming conventions to make working around our classes a non-issue. The only implementation of namespaces I can think of us using would be to throw all of our current core classes into one big N2F namespace. Not a horrible idea, but for some reason it just feels like a superficial adjustment with a framework that is so small. The auto-load suggestion might be something we could add more immediately though, provided we find a place that it makes sense using the feature. Currently, we try to ensure that the only files included which aren't configured by the user are considered 'core' constructs, or classes/functions that the framework requires to work. Anything outside of that is easily configurable for auto-loading through the framework already. Furthermore, the main n2f_cls object allows for simple checking of loaded extensions (which I believe would be the only potential use in the framework of PHP's magical auto-load function) through the hasExtension() method. I suppose we could work that tiny feature around the auto-load function, I just wonder if it would be worth our trouble given how careful we already try to be with loading unnecessary files into scope. Either way, you've given us something to chat about (and probably argue about needlessly) the next time all three of us are on IRC. Thanks for the input! &gt; EDIT: Formatting
... Why? Why change &lt;% to &lt;?php ? Why not work with &lt;?php from the start ?
Your site navigation is really frustrating. Trying to get the info on your IRC or Forum means hitting the Community tab to open that subnav but then you have to make sure the mouse never leaves that subnav or it just disappears.
Not about the framework, but your website. Please do not use the navigation system you have ever again. At least allow people to click on the top-level navigation so that they don't lose the sub-level navigation if they move their mouse too much.
When we first started using a system that did this, we were working with a designer who refused to learn any PHP at all. This was the solution that we 'created' in order to trick them, and over the years we just ended up liking the setup. There's nothing stopping anyone from using it with &lt;?php of course, but we did throw in a few shortcuts like aliases and shortcuts for variable echo's.
I can see your point there. None of us are designers, so we just found a template on ThemeForest for the design. It is definitely a vast improvement over the previous design for the site, but you (and tedivm) both show that we could still do much better. Oh well, until we can interest someone in donating a bit of design work to the site, we'll have to just look around for another template or see if we can tweak the menu. It should be noted though that we tried to make the site as a whole pretty well planned out, so if you do click on something like the 'Community' tab, you'll be taken to a page with the sub-navigation links. It's not a solution to the navigation being dodgy, but it does at least make it possible to use the site without trying to grapple with the mouse-hover effect.
Well, the first would be irrational. If you need a global variable, then surely a global variable is the best bet. But your use of global variable seems a bit excessive to me. Is that really required?
&gt; We tried to concentrate on simplicity and extensibility so that we could easily adapt the system to whatever the situation required without too much effort. I'm sorry, but that's the declared goal of almost every single framework around. The problem is that it's ill defined - It can mean something different to everybody. If you really just want to be more productive, perhaps it would be a better idea to pick up an existing framework? I'm guessing that kohana or codeigniter would fit your tastes quite well.
use &lt;?= $blah ?&gt; (equivalent to &lt;?php echo $blah; ?&gt;)
Trust me, the problem isn't with the syntax highlighting. The examples are *terrible*. * Asp style tags are usually off by default. * You're using curly braces in template-code, instead of PHP's templating syntax. * Argh, I just read that you don't use asp-style tags for php, but just convert them with your own templater. Why!? PHP is a templating language already, you don't need to parse scripts and replace anything! It's an unnecessary added overhead. What other goodies await those willing to venture in a little further?
Not sure what you're apologizing for; as I stated in my response I don't really think any of the modern frameworks are 'unique' in any real sense of the word. You're probably right in saying that it's an ill-defined goal. For us, being flexible and simple started with not **requiring** any developer to agree with our way of thinking. All three of us never really jumped onto the MVC bandwagon, as we'd all been using a proper modular approach to separate our various application layers just fine before MVC exploded in popularity. We're realistic though, and know that MVC isn't a bad system, so with our framework we made sure (as I mentioned in the original post) that you could switch to being MVC-based without having to rewrite the core files (thus preserving your ability to apply updates). I suppose if I had to make the explanation brief, I'd say maybe a more accurate representation of our goal is to have a system that can go through the most change for the least amount of code. We're far from that goal of course, made a mistake building the template and database systems into the core area of the framework as an example, but I'd never make the mistake of claiming that our system is perfect in any way. With regard to 'being more productive' and switching to another pre-existing framework, I suppose that is technically an option if you put aside the lack of desire I have to use an MVC framework. I said before, I've been using this system and it's predecessor since 2001 in PHP 4. From what I can see, Kohana has been around since sometime in 2007 and CodeIgniter a year or two before Kohana. I'm not saying our framework is more mature than those, there are after all some great disparities in manpower behind our framework and the others, but I am just making sure you keep in mind the fact that though it is technically an option, it's not really one that makes sense for me personally. In those almost 9 years of use, the one major change I decided to go through was to make the system more readily available for anyone else who might find it useful. I'd hope that you, obviously being a well versed PHP developer, would be able to appreciate another PHP developer's desire to share with the community. If however, you still find that to be unproductive and/or a waste of my time, I think it'd be safe to say that we just have 'creative differences' which can't be resolved here on Reddit. ;) Having said all of that, I've said it to some of the other commenters here and I say it to you: Thank you **very** much for taking the time to give me feedback. Regardless of whether or not we can agree on anything, getting other perspectives on something is refreshing and can usually lead to some great advancements in a project. That's really all I'd hoped for when I posted the link.
Well of course. In previous versions of the framework we'd used that with the system by converting &lt;%$blah%&gt; to &lt;?=$blah?&gt;, but with the prospect of short_tags being deprecated or dropped in future versions of PHP, we went with switching &lt;%$blah%&gt; to &lt;?php echo $blah; ?&gt;. Additionally, with aliases, we were able to take things such as &lt;%header%&gt; and associate that globally or on a module-specific level with another .tpl file. Add this in with our caching system, and it's a fast 'template' system that doesn't require you to learn a new language if you already know PHP. If nothing else, we at least thought it *sounded* good! In the end though, as I said before, it all comes down to the one designer who changed how we did things forever (or rather at least until the present time).
I'd say that it is also irrational for developers to dislike global variables, but honestly in the 10 or so years I've been doing PHP I've never bothered to pay attention to anyone who's told me that global variables are bad. Using them everywhere can be messy, sure, but if you're any good you'll use them pretty sparingly and have cleaner applications as a result. On that note, I'm curious why you feel we use them excessively? From what I can remember (which is admittedly a bit of a crap shoot most days) we only have 3 global variables created by the core system: $n2f, $db and $cfg. Any beyond those three are done by the extensions which are something you can configure the inclusion of through the $cfg global. You can even use $cfg to disable the automatic inclusion of the database system, thus taking the number down to 2 (this has been a topic of discussion for us recently as we realized we shouldn't be including the database system as we do, but that's something to address in another version). I'm more than happy to receive criticism, just prefer to be able to understand why you feel that way so I can either address it or say we disagree.
I believe I just posted some more information regarding the asp-style tags and our 'template' system that might (or might not) explain the use of the tags further. We're currently working on releasing two additional template extensions with the next version, one a static extension which is based off of a project we did years ago, the other based off of [Tierra Templates](http://tierratemplates.com/). I agree with you on the added overhead statement actually, that's why I don't use most template systems that are around. I think this system is a good compromise between the evil of doing too much parsing (say, Smarty) and the evil of intermixing your business and presentation layers. I'm much more afraid of committing the second of those two sins, so I have this very simplistic template engine to take care of things. I'm not sure if I've ever referred to anything in our system as 'goodies' ever in the past 8-9 years it's been around. The system is built off of personal needs over time, but I didn't see any reason for not sharing with the world in case someone would find it useful. Won't work for everyone, of that I'm certain. ;) PS - If you don't like the template system, there's actually nothing saying you have to use it. The only thing the module system actually 'forces' you to use is the page.php file in each module. Beyond that, you're free to do whatever you like. [EDIT to add PS]
Just changed to the 'WordPress Classic' theme, should make things a bit wider for you.
&gt; I'm curious why you feel we use them excessively? Mind you - it's a birds-eye view, but I see a lot of static calls and calls to functions with side-effects, that aren't easily decoupled from application code. &gt; .. we only have 3 global variables created by the core system: $n2f, $db and $cfg. Sure, but both `$n2f` and `$cfg` are containers that can contain a lot of global state/side effects.
Thanks for the elaboration! Do you have a framework you prefer which you feel does a good job of allowing easy decoupling in this sense? I still think we'll probably end up agreeing to disagree, but if you know of someone that's done it really well I'm curious if nothing else.
Well, [I did build one myself](http://konstrukt.dk/), and I put quite a bit of effort into decoupling dependencies.
I like the documentation you've done, always good to have solid reference material. Looks like a very simple and sweet system too, well done! One thing that does become clear to me from looking through your site is that we really need to start concentrating more on our documentation than anything else. We've already mapped out the things planned for v0.3, but I think a lot of the feedback we've gotten would be different if we had more of the framework documented, including some examples of how to extend different parts. We aren't so arrogant that we'd ever say we have the best/final solution for PHP frameworks. Our little discussion is a perfect example of the fact that people can have different ideas on the proper way to do things, and I hope we continue having people like you and I who put their ideas out there for the community. Thanks again for the feedback and great job on that documentation.
Yeah, but there are already sites to cross reference php functions to python. I'm more interested in discussing the web stuff, which would be django related. Yes, a lot of it would technically python, but most people get the idea, or dont care.
I think there is a reason for developers of widely used PHP frameworks like cakePHP and code igniter still using php4.
Go download Zend Framework and yank out Zend_Auth. It's a great component for Authentication that comes with a few pre-baked adapters.
That's good to know. I had heard about Zend_Auth, but have never used the framework and was worried about trying to just rip out a component.
Zend\_Auth is very decoupled from the rest of the framework. Frankly, the entirety of Zend Framework is supposed to be decoupled, but realistically only a few are truly "decoupled." Zend\_Auth is one of those modules. Edit: Whoever the hell thought underscores were a good idea to represent italics in markdown should be shot.
I'm just getting into PHP frameworks. I assume Cake PHP has something like this?
I like the authentication class inside of [Flourish](http://www.flourishlib.com)
Thank you, i'll take a look!
They do, but I was concerned about having to use a whole framework, and being unable to de-couple the auth piece. Going to give the Zend class a try tonight.
ahah can't wait to try it out
I may do the same thing with CakePHP in the next few days. Let me know how it goes. 
I was just thinking about something like this today as I need to build a token authentication system for a web services API. I'd just want to build it on top of something that's already there. I looked into Kohana and building it on top of the auth module but the Kohana ORM sucks and that's what the Auth module uses. I would prefer to use something more robust like Doctrine, CoughPHP or even Propel, but then I need to rewrite the auth module. I guess I don't have a solution for you I'm just sharing my rather similar dilemma.
&gt; The final release is planned for late 2010 and will only supports PHP 5.3.2 So, it's only usable if you control the server. VPS, dedicated server. But why use PHP at all if I have a choice? You don't have a choice when a customer wants you to develop something that has to run on shared hosting. There's only PHP. Anything else is just pain. But shared hosting won't support PHP 5.3.x any time soon. 
Wow, sweet. Thanks for the share dude :)
Should checkout the NuSphere toolbar debug buttons. They must be almost exactly the same because: To actually start a debug session, you must pass a parameter XDEBUG_SESSION_START to the script by GET, POST, or cookie. and with NuSphere it is exactly the same, but the parameter is called: DBGSESSID= https://addons.mozilla.org/en-US/firefox/tag/NuSphere is open source.
&gt; But shared hosting won't support PHP 5.3.x any time soon. Except, you know, loads of places already do support PHP 5.3.1, including some of the biggest and most popular: Dreamhost and A2 Hosting.
Current PHP for current Debian: PHP 5.2.6 And good luck with your customers and moving them to popular providers in other countries. 
If you're willing to use a framework, the [dx_Auth](http://dexcell.shinsengumiteam.com/dx_auth/) library for CodeIgniter is great. I doubt if it could be uncoupled, but you could take a look. And CodeIgniter is very straight forward to pickup, especially if you know what you're doing. 
No one said you had to upgrade to Symfony 2. Symfony 1.4 will be supported for the **next 3 years**.
The move to 5.3 is coming within a few months or so I've heard. They said spring for sure. I use dotdeb packages for PHP 5.3, which is upto 5.3.1 atm
Wow what a troll. PHP is just fine or better for a lot of projects and developers. 
lol who uses symfony on a shared host? As a symfony-user, all my clients have enough budget to get themself a pretty decent VPS. Setting it up does not take more than 2 hours. That includes compiling php, lighttpd, mysql and setting up postfix. And they are always happy to know that they can control everything on their server.
Can someone explain why the xdebug helper addon disappeared?
So, what is new? Can anybody to give executive summary?
http://symfony-reloaded.org/fast
I don't use Symfony.
Debian doesn't upgrade packages. They are this way until the next release of Debian.
Symfony 2 is basically a code generation framework. For Hello World you write 100+ lines of code in several classes, then it generates 2700+ lines into cache. None of the other frameworks use caching to this extent. The "real world" benchmark adds a ridiculous number of routes and as I mentioned in this http://rad-dev.org/lithium/wiki/blog/thanksgiving-benchmarks , routing is one of the most expensive operations of any framework. Symfony2 implemented caching for this too which could easily be added to the other frameworks to make it more of a apples-apples comparison. Still, Symfony2 takes an interesting approach to the page controller (kernel) and plugin (bundle) concept. I could not find a true front controller in traditional MVC style. For me it seems like a lot of boilerplate code, but that seems to be part the goal of to make Symfony2 more explicit and less magical. Ultimately, Symfony2 does seem to build on the concepts in symfony1 with lots of upfront configuration generated into php code. Full disclosure: I am on the http://lithify.me team
Ah I see. I use Ubuntu, not sure if they do it differently
fclose is the way you want to end the night.
Lithium looks cool. I'm a Cake user, have been for a few years. PHP 5.3 is bringing some really cool stuff to the forefront. I'll mess around with Lithium. I didn't like how symfony had so much configuring in YML. I don't like being that far removed from the core code. But I guess you can't argue with that speed.
I've used nginx with php-fpm (fastcgi). Super fast, low memory
You can define your config in yaml, xml or php code. At the end of the day it's all "translated" into a PHP class and then cached, making it as fast as native PHP code.
The high memory of Apache has really been frustrating me. I've been using using Lighttpd &amp; fastcgi for the last 2 years and it handles a lot more requests with an even lower memory footprint than apache.
To be quite honest, it depends how you configure each. Out of the box lighttpd is faster/slimmer, however a proper apache 2.2 setup can roll just as strong, however it takes a bit of knowhow and isn't as much "plug and play". As to the CGI handler, it truly depends. Opcode cachers on PHP running in CGI/DSO mode can *WRECK* FastCGI. But, once again, "out of the box" fastcgi is faster assuming there's no opcode caching going on (a la xcache/Eacceleartor/etc). For what it's worth, the last time I pushed both of these two simultaneously side by side in varying configurations, it was a cluster for an ad agency. 1 LVS load balancer, 2 apache webservers and 1 standalone MySQL machine. Performance with Apache + XCache generated an avg load (blah blah yeah i know) of ~2-3 on the frontend webservers as to where lighttpd+Fcgid was hanging around 6-10. It should also be noted that lighttpd doesn't fully respect all of the random stuff that has been built for Apache or built upon the assumption that Apache is the default webserver, i.e., specific mod_rewrite rules that simply don't work and have no direct translation. Apache with no caching and no tuning put the load at around 60. This served ~5 million reqs a day of PHP pulling MySQL on every query and serving an ad/image. ymmv but really it comes down to what you know. :) 
Keep in mind that this article was posted August 1, 2006...
I've only used it for very basic, get stuff from the DB and feed a datagrid type of projects, making a form and feeding data into a db, so I haven't really dug deep into .NET or Visual Studio, I think its a good tool and it gets stuff done, still I'd rather work with PHP because I feel i have more freedom to do anything with code and pieces of information than i can with .NET and their restrictions.
What restrictions are there?
licences, has to be developped on a windows system
I shouldn't have said restrictions, more like complications? what I'm trying to say is that if you wanna do something specific a textfield that onMouseOver displays a div with an image, its kinda hard to do in .NET, where in PHP its just easier to code. But i guess in the end it comes down to experience and how familiar you are with the product.
i put this on my httpd.conf (back then when transitioning from php4 to php5): # php 4 &lt;IfDefine php4&gt; LoadModule php4_module "modules/php4/php4apache.dll" &lt;/IfDefine&gt; # for php 5 &lt;IfDefine php5&gt; LoadModule php5_module "modules/php5/php5apache.dll" &lt;/IfDefine&gt; then, to run apache with php 5: httpd -Dphp5 note: * put php.ini in the same dir as php4apache.dll/php5apache.dll for each respective version * i didn't install apache as a service * when not running as a service, it seems you have to kill apache to stop it (or at least up until now i don't know how to shut it down gracefully) * haven't try it myself but i think this can do: # for php 5.2 &lt;IfDefine php52&gt; LoadModule php5_module "modules/php52/php5apache.dll" &lt;/IfDefine&gt; # for php 5.3 &lt;IfDefine php53&gt; LoadModule php5_module "modules/php53/php5apache.dll" &lt;/IfDefine&gt;
What do you use to test the load... just top or something? just curious. 
exactly...there's all the 'complications'. But what I do like about it is that everything is done neatly and cleanly. Whenever you're working on a sufficiently large project, your html/javascript validation is bound to fail at one point or another. Not to mention js optimization...asp takes care of that stuff pretty good
and then ?
Oh, and we'll take some egg rolls too. 
ASP.NET ok, ASP.NET WebForms not ok, ASP.NET MVC ok. 
How is Apache winning? Lighttpd has almost the same performance but didn't fail 4 requests.
I'm the author of the linked article and I'm quickly dropping by to inform you, that the article is terribly outdated. I have written it back in 2006. By now, two new major releases of PHP have come out, which makes it highly likely that the numbers are way too low. Additionally, the application I was doing the benchmarks with isn't too well-suited for that as it was, at the time, badly CPU bound which might have skewed the results. Seeing all this renewed interest, I'll probably have to redo the benchmark. By now, I'd guess that lighty might be a bit faster in a less CPU bound application, but we'll see.
lol
I'm lost in binary hell getting this bitch off the ground; would have been a lot sweeter if they provided CentOS RPMs for some of the packages
not having much luck with the [ubuntu directions](http://wiki.github.com/facebook/hiphop-php/build-and-installing-on-ubuntu-910)... might be worth leaving this project for a month of two until it matures a little bit away from Facebook's internal structures.
http://us2.php.net/echo
First off, start looking through some handy tutorials on PHP from * [w3schools.com](http://www.w3schools.com/PHP/DEfaULT.asP), * [The PHP Manual](http://php.net/manual/en/tutorial.php), * and [Tizag](http://www.tizag.com/phpT/) I found that, after those tutorials, it helped to expand my knowledge of the language by envisioning a task I would like to accomplish with the language, then begin to research how I would go about completing the task. My first PHP project was to generate a signature image with the last 5 posts from my blog, it involved generating images, concatenating strings and quering MySQL databases from within PHP. I started by splitting the task into small logical 'bits', and then expanding and researching them, i.e. "I must first get the 5 posts from my blog" -&gt; "How does my blog store data?" -&gt; "MySQL" -&gt; "How do I access MySQL through PHP?" -&gt; "the MySQLi class" -&gt; "How does the classes' syntax operate?" etc. There is plenty of information on the internet regarding PHP, so simply googling '&lt;what I want to do&gt; +php' will turn up plenty of results that will help you with your tasks. [Stack Overflow](http://www.stackoverflow.com) and the [PHP Manual](http://www.php.net/docs.php) are two very useful resources to pay attention to in the results and to consult when you don't understand things. Good luck!
start with basics and then start with a framework like zend framework etc.
you're doomed. DOOOMED
nah not really
Not really helpful...
Thanks!
What can I do!?
Actually, questions like this have been asked many times already on reddit, perhaps have a search for them. GL HF
Just write stuff. Look up tutorials on database connections and queries and try to come up with something cool to do with that. It will most likely be of sucky quality, but you will learn. Rinse and repeat.
Don't use PHP.
A framework is the last place you want to start before knowing anything about programming methodologies and design patterns.
To add onto this, look at some of the questions on Stack Overflow, and try to work out what the code does. That'll help with general programming knowledge.
Why?
create a guestbook with mysql using php snippets you can find on internet including the phpdocs 
My advice is don't.
Not sure about the down-votes, but I would say definitely look at a framework (a goo done - get recommendations). When starting out you want to see how a decent application should be structured, and a framework can give you lots of code to look at and play with.
Why?
Hmm compiled all the required dependencies on debian etch but keep getting a compilation error when cmake-ing it. I'll try on centos right away.
Because PHP sucks as a platform and a programming language. I've been writing in it in since 3.0 and I still do. It's completely unfit for anything *but* web applications and quick shell scripts. It's loose, messy, has crappy memory management and a legacy of retarded engineering decisions geared towards low cost (= incompetent) development.
professional programmer here - I go to stackoverflow before I look on Google. it is truly a godsend for programmers!
Post any specific questions to the PHPHelp subreddit and I'll be glad to answer if I can.
And always be weary of the solutions you get from Google searches.
Helpful...
Thanks.
First, find something you want to achieve. You already know html/css so go for front-end to begin with. Start using an existing templating system, such as Joomla's (yes I'm gonna get bashed and downvoted for mentioning the "J-word" but it's just the right amount of PHP to begin with). Start by making a simple component that lists items in a database. Use the "Joomla Component Creator" to give you a kickstart and use the documentation on Joomla.org and PHP.net to help you along the way. You'll also probably need to refer to the documentation available free on the MySQL website. To begin with you might find this a little intimidating so I suggest you start with w3school's most basic php/mysql tutorials to get an idea of the fundamentals. I also highly recommend you start of with a good IDE (Netbeans PHP is my current recommendation) which will speed up your coding, reducing frustration in the beginning and maximizing efficiency as you get better.
I want to make web applications, so PHP seems perfect for me.
I asked for advice, troll elsewhere.
You might need to update cmake. cmake --version was telling me I had 2.6-patch 2 and I had some errors so I upgraded to version 2.6-patch 4 and it seemed to go fine.
I liked the lynda training videos.
Probably the best tip I could give, that a lot of PHP (all?) programmers don't fully remember has to be. **DO NOT TRUST THE USER. EVER.**
Check out existing code. A lot of programming tutorials will teach you how to write messy code that works, especially PHP tutorials. They're still worth checking out to get the basic concepts, but if you want to see what good/better code looks like, download the code for [CodeIgniter](http://codeigniter.com), [Zend Framework](http://framework.zend.com/), and [Recess](http://www.recessframework.org/) and see how they work. You'll only learn by doing, so just start making stuff. If you get stuck, ask for help on #phpc or a forum somewhere.
Bump for Tizag, it is written in plain language, and the examples are very simple to follow, but cover a lot of ground. I learned how to do left joins from there, hooray!
Remember security. When I was learning PHP I made a forum type thing, only I didn't think to sanitize any user input. Needless to say that within a week my site was completely owned. Never neglect the fact that your users are idiots or assholes (or both).
Everyone else is saying it, and it could not be said enough: never trust the user. It is akin to feeding Gizmo after midnight.
They tire me as well.
Learn a good MVC. Doesn't really matter which one; but learn one. FWIW I like symfony. 
symfony 2 looks great. I use CakePHP alot. I would recommend starting with CodeIgnitor, and then working your way up. That one has a low barrier of entry, from there it's easy to go from one framework to another. 
[Cherokee &lt;3](http://www.cherokee-project.com/)
Hey, I briefed over some of the comments here, and while I feel a number of them are useful and necessary, I think you need an actual hard copy book to start with, rather than jumping right the hell into the manuals. The book I started with, with absolute minimal programming experience (just some C++ classes in high school), is [Larry Ullman's PHP book](http://www.amazon.com/PHP-World-Wide-Web-Third/dp/0321442490/ref=sr_1_14?ie=UTF8&amp;s=books&amp;qid=1266801329&amp;sr=8-14). I started on the second edition, and it was everything I needed to get started programming with PHP and making dynamic applications. It should cover basics of MySQL and top the book off with regular expressions, which are absolutely necessary to any serious web developer, and he makes everything feel very accessible. After some months of that and programming, you would be ready to enhance your skills, and his follow up [Advanced PHP book](http://www.amazon.com/PHP-Advanced-Visual-QuickPro-Guide/dp/0321376013/ref=pd_sim_b_4) covers a lot of interesting and esoteric areas. It might be more than you need, but it does start off with some practical chapters in OOP and classes. In-between the two, he wrote a [MySQL and PHP combination book](http://www.amazon.com/PHP-MySQL-Dynamic-Web-Sites/dp/032152599X/ref=ntt_at_ep_dpi_1) that sort of acts as a stepping stone between the beginner's book and the advanced book, and it might actually be the most you need to program in PHP, but I found the Advanced book handy to use, and the first book I linked you was my personal guide and reference for about a year and a half as I grew in my skill set.
Once you start learning the basics of PHP, try to create something simple yourself. You can use references or tutorials, but don't just copy and paste code. Get in the habit of writing your code and learning the functions of PHP. The more trial and error you have, the more you'll learn. I've been writing PHP for about 8 years and I am still learning and loving it. There is nothing better than the sense of accomplishment you get by finishing something on your own.
On top of what the rest said, sites like http://bytes.com/topic/php/answers are invaluable. Helpful and kind community of IT experts. Give them a shout when you're stuck on some problem (small or large).
You'll encounter a lot of people like this (arguments with no evidence).
Wow I'm kind of shocked at all the bad answers here, I'm glad I didn't have to post your comment. To the OP: Don't start with a framework, an MVC, any of that mess. Just think of something small, maybe a guest book so people can enter their names that will display as a list, and write it yourself. Look at tutorials, but don't copy paste. It may seem small but you will be much more proud of yourself when it's written from scratch. I wrote a super simple tutorial a while back, aimed at people brand new to PHP, if you're interested: http://erulabs.com/?postid=14
I got hit with it a couple of weeks ago through a security hole somewhere in my app. I'm using CodeIgniter which disables the $_GET global altogether, so I'm uncertain as to how they got in - I think it was a file upload function which failed to validate the .txt file they got in with. 
&gt;See, back in the day some php developers were pretty stupid. unfortunately, a lot of them still are.
Jee, I hate this guy. A hugely arrogant asshole.
How about tell us what the "proper" way of fixing this is instead of being a huge douche
Well if you're going to use this method, parse the file name, check it doesn't contain double dots, limit it to alpha-numeric, or have a list of approved values it can be checked against. Why was he being a huge douche? The post seemed fine to me.
The horror here isn't the php shell that's uploaded, it's your shit php code getting exploited allowing that c99shell to be uploaded. Don't blame the symptom, blame the problem. 
Seriously! How dare this post not include everything you want. WTF is that about. Clearly, the author can read minds; he just chose not to listen to you. 
Oh. My. God. You hate me?!!?!!?? What will I ever do now that an Internet troll doesn't like me. Oh, woe is me, woe is me! So sad now...
Too true man. Too true.
I think the horror is the outcome of c99 being uploaded to a server.
In that case, why the emphatic response? However, unless you're Eric Lamb, I wasn't referring to you ;)
You have a habit of spitting the dummy out, huh?
The gist of the story seems to be: If you're not at least monitoring your site's files for changes (new or modified files) then you're playing with fire. If you need to allow the caller to make changes to the filesystem, restrict those changes to a non-web-accessible directory or at least make the directory's contents not-executable. 'cause it's not like PHP is the only exploitable language out there.
Is that what the kids are calling it these days? Maybe he should just swallow instead.
Yup, looks that way.
Because there are a million articles about it already? Seriously, if you don't know how to do user input filtering you shouldn't be programming for anything except yourself. Calling someone a douche for not babying you is absolutely ridiculous. Grow up.
Not to be mean, but you should really post your code somewhere so others can take a look at it and point our where you went wrong. Growing as a coder and all that. Not cleaning input is the biggest mistake in any webapp, since ie allows for so much crap to happen.
I did, on the CodeIgniter forums. I used its file upload library, which has mimetype validation, which is obviously flawed since my upload didn't allow .txt files.
Alas, I only have one upvote to give...
Great article!
From that code, you should just be able to do: $pagename = $row[0]['name']; (I believe)
The problem here is, that I'd need to get the name as a variable into the html. So I'd need a line like: $vars['pagename']= (Something that would just print the name) Also, I have no idea what your line means, but it doesn't look right to me. I can kind of read php, but no idea how to write it.
Interesting. It seems that my little framework has the potential to be hmvc. I my framework controllers are called commands and do one thing through a public method called doExecute() that method is called by the main system request controller when either a url is called, or a command it called from within another command or view file. All public commands are connected to urls defined in the router 'user/add|this/route/calls/this/command/as/well' =&gt; array( 'command' =&gt; 'Command_User_Add', 'response_type' =&gt; 'html', 'allow' =&gt; 'post,get' ) ... and so on So the object Command_User_Add does exactly that and only that. If i wanted to validate the password while adding a user, I'd call Command_User_Passowrd_Validate from within User_Add command. Now the issue, as raised in the article, is getting data to that command. This is how I address it System_Request_Call::command(array('command' =&gt; 'Command_User_Password_Validate), $data_array); I have two methods in System_Request_Call; url and command. If you use ::url() you can pass in a url and it will be based on the routing rules defined above. Its a fun little framework, easy to use even though it has a lot of bugs. The database layer sucks -- im working on this. And absolutely no documentation (what I wrote here is the most that you'll get for now) Check it out http://code.google.com/p/joshuatree/ 
I tried: $vars['pagename1']=mysql_query("select name from ".$site_prefix."_menu where (id='".$page_id."')"); But It doesn't give the name, it just gives "Resource id#*idnumber*" for some reason :S
guitarromantic is correct. You can use this: $result=mysql\_query("select name from ".$site\_prefix."_menu where (id='".$page\_id."')"); $row=mysql\_fetch\_array($result); $vars['page\_name']=$row[0]['name']; mysql\_free\_result($result); and now you can echo $vars['page\_name']; and it'll output the pagename. edit: also, I hate pasting code into reddit
&gt;it just gives "Resource id#idnumber" for some reason :S this is because mysql\_query doesn't return the data the query finds, it returns a handle to the result resource, so you can then pass that return value into a function like mysql\_fetch\_assoc to fetch rows etc.
Well, I did as you said, but just added another line to the existing code(I need that page_name somewhere else, so pagename2 is just for this): $result=mysql_query("select name from ".$site_prefix."_menu where (id='".$page_id."')"); $row=mysql_fetch_array($result); $vars['page_name']=print_pageName($page_name_id); $vars['pagename2']=$row[0]['name']; mysql_free_result($result); And than added that to the template, but it wouldn't show the full pagename but just the 1st letter. I tried to add your code: &lt;? echo $vars['pagename2']; ?&gt; to the bottom of the php file and also it shows just the 1st letter. 
maybe the problem is in $row[0]. I would do print_r($row) to be sure of the contents. Just my 2 cents
Ah - I wasn't sure if you were working with a single row or not. Change it to: $vars['pagename2'] = $row['name']; (the [0] part would have used the first row in the array, but since you only have one row it was using the first character of the result instead.)
[Er...](http://www.reddit.com/user/mithra62/submitted/)
Yay! That worked. Thank you very much. Thank you all very much ;) 
by the way, there's a subreddit for [php help](http://www.reddit.com/r/PHPhelp)
Thanks. Will go to the right place next time ;)
well, there's not very many subscribers to that subreddit, but it's probably worth trying there in the first case and then posting here if that fails :)
I posted this a day ago, [cheers](http://www.reddit.com/r/programming/comments/b50dz/scaling_web_applications_with_hmvc/)
Also, learn how to use a template system. Don't embed your HTML with your PHP! I like Smarty personally. (http://www.smarty.net/) But first learn your basics. PHP.net is your friend.
Oh yeah, and learn how to use PEAR (http://pear.php.net/). There documentation is not always the best, but dammit if they don't have some great classes.
This article has given me the impetus to throw away the training wheels (Code Igniter) and try a more grown up framework. So far I love it. To think of the hoops I was having to jump through to get a pseudo-HMVC structure working. I want to rewrite all my old CI stuff now!
If you want people to stay logged in on different computers, you need to setup a different session each time. that means, generate a new identifier every time and store them in an extra table, referencing your user table. Having the same identifier would be a huge security hole, like you said. so, create a new table, call it "session" if you like, it should contain the secret identifier and the user id. For extra security, you should also store the user's ip-address and his user-agent string ($\_SERVER['REMOTE\_ADDR'] and $\_SERVER['HTTP_USER_AGENT']) in the session and compare them on every request. this way even if someone gets to steal the identifier, he would have to use the same ip and same browser version to authenticate with it.
IP-address is bad, because many of the visitors are behind NATs.
Well, yes it would be if you gave out the session to everyone on the same IP. But that is not what bnr is suggesting ;)
ok well how about this ... IP address is bad, because many of the visitors could be behind banks of proxies, and coming in on a range of different IP addresses during the same session. Yes, unfortunately it happens quite a lot.
Think about this problem in layers. You have the server session layer first. That uses the cookie with a unique ID to identify one browser. That session may be destroyed after the browser is closed ("remember me" is not set) or it may be retained for longer (whether "remember me" is set or not). You may want to renew that session every week, which sets *limits* on how long a "remember me" can possibly last. You may also use IP addresses to discard the session if it looks like the user has suddenly moved or their browser type has suddenly changed, or you detect the slightest hint of SQL injection. You will probably not want to set one of these sessions up if the visitor is a search engine. On top of that is the application session. This uses the session defined on the server to store information, such as whether the user is logged in and whether they should be automatically logged out at any point. This layer of information is *kept on the server* - it has *nothing* to do with cookies and is *never* sent to the browser in any form. Think about those two layers and the solution may come to you. At the moment it sounds like you are mixing them up a little. You also don't want to share any of this information between computers. If there are settings that do need to be shared (e.g. default number of news items listed on the home page), then they are stored on the server against the user and not the session.
This - not because they're behind a NAT device. In particular AOL does this, or at least used to.
I personally think that the amount of knowledge available online for PHP is unmatched. At least when I looked about 2 years ago at ASP.NET I didn't think that it had nearly the amount of documentation and examples that I could find with PHP. In addition to this, quite a few products are built in PHP. So if you need to integrate something (like vBulletin) you would be mixing languages that wouldn't need to be mixed. (across the site not on a single page)
Symfony's tried-and-true [sfGuardPlugin](http://www.symfony-project.org/plugins/sfGuardPlugin) stores "remember me" hashes in a separate database table along with the corresponding user ID and, for auditing, the remote IP address. If requested, this hash will be [generated upon login and saved in a cookie](http://trac.symfony-project.org/browser/plugins/sfGuardPlugin/branches/1.3/lib/user/sfGuardSecurityUser.class.php#L90). On a successive visit while not logged in, an available cooking in the request is [checked against the database](http://trac.symfony-project.org/browser/plugins/sfGuardPlugin/branches/1.3/lib/sfGuardRememberMeFilter.class.php) and if a match is found the user is logged in. The weakness here appears to be a hash collision where one users spoofs the hash contained in another's cookie. You'd could have the same problem with session cookies, though, so the makeshift solution is likely to increase the hash length to a point where collisions are statistically negligible and be diligent in watching for abuse (e.g. the same host(s) attempting to brute-force a cookie match).
I'll probably implement this. Thank you.
Thank you, those links have been really helpful.
I totally agree...in terms of documentation and just general market dominance...PHP is the top. But I meant more in terms of technology....it just comes down to php being more low level than ASP.NET, and high-level languages are not always a bad thing, especially when you have spare resources. If you've got a decent IIS server and not a very large user base, I think ASP.NET would be the way to go.
Ext is pretty thick. Use it as your form/grid frontend, use PHP to generate your JSON responses that power Ext, use Doctrine as your ORM database abstraction.
This is exactly what I would suggest. I **love** ExtJS as a form builder, and Doctrine is a great helper for the backend database.
Aren't there licensing issues with ExtJS? I don't recall what the fallout of that discussion was a while back, just that there was one... Also, jQuery [can do ajax](http://api.jquery.com/category/ajax/).
The licensing stuff is all taken care of. Feels good man.
all. 
OMG! Ext looks like it should be a standard framework for PHP forms. OMG, I was just blown away at the examples.
The website says you can use it in your commercial site as long as the site is GPL'd and you release the source. Otherwise, you can purchase a license to use it. I second jQuery unless you need all of the extra bells and whistles of Ext (don't get me wrong I think Ext has some cool stuff).
A company I worked for used [Sajax](http://www.modernmethod.com/sajax/), it worked pretty well for them
json_encode($data) in a template? Presuming you can take a minimal path through your existing framework. If you are going to scale, you'll be wanting to run custom services to create your JSON. And then just use jQuery or ExtJS for the client.
&gt; It looks like jQuery is used more for UI look-and-feel... jQuery is used for manipulating the content of the page in all its forms. That's the broad goal, so don't think it is just for fancy screen widgets.
Document it. :)
I'll get started. I want to clean a lot of it as some design decisions do not make any sense (I dont want yall to call me stupid).
You might want to check the license out, OMG!
Check out http://www.recessframework.org/ Personally I use CakePHP for everything, with jquery handling any ajax/js on the page. jQuery makes it really easy to handle any returned data/manipulating the DOM, etc. Tons of plugins as well
I'll call you stupid for saying "yall" ;) Keep us informed please.
O-M-G, Becky. Did you look at her license? I was looking at http://php-ext.quimera-solutions.com
I think he was saying you should check out EXTjs's license. They are for pay (and a pretty high price tag at that) if you do anything other than GPL work.
The fancy screen widgets are more jQuery UI anyway.
Was implementing jQuery in CakePHP a pain in the ass? I know it's supposed to be well-supported in the next release but I heard it wasn't so easy to get into 2.x.x
Not at all, you just include jQuery in your "default" layout (the &lt;script&gt; include), and just use it as you normally would (in your templates, with event listeners, etc). I don't use the included AJAX stuff in Cake since that uses prototype... I like the flexibility of doing it myself anyway. http://vacentral.net/ I use Cake+jQuery on that, if you do view source, you can see how I did it with the my own .js file and listeners - basically doing it without all the magic that cake uses to put it in automatically
I'm a big fan of [Symfony/Doctrine](http://www.symfony-project.org/) but there is an enormously steep learning curve. AFAIK of all the real MVCs it's got the most code generation (admin page created by symfony based on the model, Database versioning/migration). The ORM stuff is really good for rapid prototyping, no wasted time altering models, you just change the database and tell symfony to remake the models based on your schema.
Also, there's a json/empty layout, which you can just do something like this in your controller: $this-&gt;layout = 'ajax'; echo json_encode($data); And then just called it as /controller/function and it will output that... so with jquery it's real simple
Awesome, thanks for that! My co-worked made it seem like such a hassle that I figured I'd wait until CakePHP 3 before I really got knee deep.
Not if it's an internal app.
What a petty tool.
A more productive approach would be to try to help the Yii guy get his page back. Deletionism is so retarded.
Regardless of his motivations (and he certainly seems biased), he seems to have a point. All the References are either to the kohana site or the trac page; The article is written like an advertisement.
I dont use Symfony, so I can't speak to it. Doctrine is easier to install, set up, use and performs better than Propel or any other home-brew abstraction I've used prior.
That is the problem I had with the article as well. I am all for Wikipedia entries for software and frameworks, but the information contained in the article should be objective, simple, based on facts, and should be useful for comparison to similar offerings for the purpose of assisting with informed decisions. It should not read like a sales pitch. It should not be rife with opinion and/or speculation. If the majority of external links point to a single source, they should be considered suspect. If an article falls within those guidelines, I can't see a reason for it to be rejected. If it does not, I can't see how anyone without a biased agenda would accept it. It is unfortunate that the people who are motivated enough to dedicate their time to providing a Wikipedia entry for a particular piece of software are burdened with a predisposed passion toward the subject of their writing. It can be very difficult to remain objective toward that which you are passionate about. At the same time, it is imperative, given the nature of the Wikipedia service and the expectations of its users, to remain objective or at least expect the editors or the community of users to enforce objectivity.
But shouldn't they be trying to fix the article rather then outright remove it? To me the article looks like a stub rather then a push at advertisement. Someone tried to get the article started and seems to have copy and pasted from kohana's pages. While this may lead to the article being a little biased at least it is a start and people are free to balance it out. 
Agreed.
...what? The problem is not what is being included but the fact it *can* be included in the first place. c99 is one of hundreds of very popular PHP shelled used by script kiddies. There are shells with AJAX and Web 2.0 templates for crying out loud.
I use jQuery for my Ajax requests, after switching from Xajax (xajax is pretty cool if used stricktly for ajax routines, very simple for the non-javascript programmer to get the hang of, using mostly just PHP). An app I am working on is created using Kohana framework (which is MVC). My ajax requests point to URL's such as site.com/admin/content/create/(integer at times, if using ORM). It actually works pretty smoothly, as I don't need an extra library to handle ajax and the effects I use within the app too (I prefer to keep things minimal). Everything seems to work quite well, and hopefully I will be able to release the project soon. It is yet another CMS, but built using Kohana with a backend that is intended to manage most controllers administratively (so I am also hoping that it will be useful for most all apps written with Kohana). On a side note, if anyone is interested in helping out, would love to have the extra help ;)
Thanks for the info. My project will eventually become a commercial app, so I will get a license of ExtJS if needed. But, *should* I go the ExtJS route, or can jQuery do the core of the work. I prefer not to have to write code to handle grid actions (sort, paging, etc.) and would rather have the functionality built-in like ExtJS. Is it worth writing my own code to do basic stuff like this? Do you have any examples of jQuery filling in a form or data grid from making an Ajax call for data? That's one of the things I love about .NET, you put in a grid widget and point it to your datasource (data class, stored proc, etc) and it creates the grid automatically without you having to create columns. Or, I create the columns and tell it which ones to hide and which one should be marked as the Primary Key field. I can then create a footer for the grid to input a new record. Paging is taken care of by the widget. But, I don't want to be tied to Microsoft.
I've been playing with phc, the C equivalent, and I really like it. Makes writting PHP modules braindead simple: http://www.phpcompiler.org/
They usually don't record video (at least at ZendCon), they record audio though. You can find select audio podcasts for ZendCon sessions (with links to respective slide shares if relevant) on the [Zend Developer Zone](http://devzone.zend.com/podcasts/zendconsessions). As for php|tek (tek-X this year) and the other large PHP conferences on the other side of the pond I'm not so certain.
Tek-X is hosting a series of webcasts for presentations that were not chosen for the conference but were still considered very good. As far as the talks themselves I am unsure I seem to remember them being recorded (atleast the audio portion) but I have not seen anything about where to view them later.
I really don't get this "webcast" concept. Why do I have to watch it at a specific time, rather than just download and watch it when I actually have time for it? Why can't I watch it on Linux? Why can't I watch the actual talks, rather than those that got filtered out?
I should note that it seems like php uk conference are going to make their talks available: &gt; We're also currently working on getting up videos, audio recordings and the slides from as many of the talks as possible - please be patient, as with the event itself, we are unpaid volunteers doing this for the PHP community and have our own lives to support that must take priority... http://www.phpconference.co.uk/thanks
&gt; I have no idea where to start install [wampserver](http://www.wampserver.com/en/) - it'll get you up and running quickly (I assume you're running windows...) &gt; any general programming advice would be welcome Start with some simple stuff like "guess the number" games, which will teach you about how to integrate web forms with PHP (a very, very, very common task). Now create a mySQL Users table and have people log in to play the game. Now read up on SQL injection and hack your game so you can play it without logging in, or so you can steal other user's details. Now secure your script so it's break-in-proof. Now make it an ajax game (still keeping the logic server-side) Now allow users to upload an avatar. Now read up on remote file inclusion and hack your game so you can upload and execute arbitrary PHP code. Now secure your script so it's hack-proof.
I get the webcast concept in that the people who are giving those talks will be giving them live at that time so you can interact with them during the questions segments. I don't know if they will be available to download after that. No Linux well that is lame and odd considering that during the PHP|codeworks con I know half of the organizers were running Linux themselves according to one of the organizers. It may be just a limitation in the webcast software they are using since they are teaming up with MS for it.
Most PHP Conferences will sell their DVDs while the presenters' slides are available freely on the authors' blogs. You have to find them though.
I thought the actual code would be in here somewhere. I'm always interested to see what other people's code looks like.
Well I'm not sure what we're supposed to say without the code.
Me too. Part of my learning process early on was to browse others code, like Joomla, Wordpress, etc. Everytime I do I learn something new, whether it's a small short cut or whatever. 
Find people you trust, that are also interested in the project and know how to code. What exactly are you trying to do?
Stop planning on releasing it as open source and go open a BitBucket/GitHub/Google Code and publish it. It's easier to attract open source contributers when you can actually say "go ahead and take a look, here's my current todo list if you wanna help." Saying you promise or are thinking about releasing it as open source opens the risk that you will just take their contributes and turn around and sell it right out from under them. Plus, contributing code to a project that's closed feels a lot like commercial work to me, especially when I'd want future employers to be able to see the code that I worked on. Once your software works, you can create a consulting software on the side offering your core contributors a stake/contracts, etc. To give an example of this, look at Drupal. A guy starts the project, then eventually when he notices it taking off and he's receiving contracts to help people set it up he starts up Acquia as a consulting firm to support companies that do Drupal work. **tl;dr** Release it as open source tonight, and remove any thoughts of pay scales and structures until you actually have something. You will be making your money most likely doing consulting and install work for your OSS, not in hosting.
That's the prob, I don't know anyone online that I actually trust. I mean, I'm sure after talking to people a few people I'm sure I could trust them in working on the project with me (and not turn around once we're at a stable release and distribute it as their own thing as something entirely different, or even start selling it off). What I have for the moment is actually a fairly neat little CMS. I know, just what the world needs, yet ANOTHER cms. But my whole centric idea was to work on and release and entire suite of apps, all of which would integrate seamlessly with it (as well as allow individual components to run stand alone). I have portions of the other projects started, but being one person it is kind of a slow process.
Ok, GoogleCode might be a good start. I'm not looking to make bank off the project, but I would like for it to support it's cost from hosting, etc (especially if it picks up to be fairly popular, I'm sure with extensions/etc downloads/traffic would be a considerable bandwidth problem). I will work on getting things to a point where I am confortable releasing on GoogleCode to start with and see what happens. Oh, one more thing. I currently have it licensed under the Apache 2 license. Any recommendations license wise, or do you think Apache2 is fine?
I would like to suggest GitHub as an alternative. I moved from googlecode to GitHub because of the social aspects - it is very easy for someone to "fork" your repository, make some changes, push it back to their repo and you can easily plug those changes into your repo.
Upvoted for the HPHP Comparison at the end. edit: other than that. I think the performance gain is not that much for a static class over a singleton. And don't forget: You'll lose the possibility to extend your class in future development if you decide to call it with a static (actually that's not quite true, but it will be harder and not as beautiful)...
&gt; You'll lose the possibility to extend your class in future development if you decide to call it with a static You lose that with a singleton as well.
The performance difference is a red herring. There's a very little overhead; That shouldn't affect your architectural choice. That said, you ignore another option, which is to just use a global instance. Essentially it's the same thing, but it's much easier to move from a global variable to a local variable, than it is to move from a static/singleton to a local variable. That's why I would usually prefer that.
How so?
You can extend it alright, but the client code will still be linked to the parent class - not the extending one. Unless you edit the code, but then you could do that with a static class as well.
You can't use `__call()` on static classes. `__callStatic()` is on PHP 5.3 now, but Symfony was developed for 5.2.
The reason why theay are using singletons instead of static classes in symfony is testability. On a singleton you can overwrite the instance-object, whereas a static class always behaves the same way.
I don't understand how that singleton call works. If there is only to be one instance during execution, then would it not have to make use of a global variable somewhere along the line to store that instance?
Is this like adding in new functions using mixins of a sort? I'm working with Silverstripe at the moment and it does this a lot. Plugin modules are able to extend the singleton objects using a mixin-style technique, and when you need a new object you just get a clone of that with everything already extended.
You are assuming linear inheritance. That is not the only way to extend an object beyond its base class.
While the single instance is shared (the same reference to it is returned each time you call `getInstance()`), you're still not creating a global variable in the process. It's stored as a static member inside the Singleton class. 
&gt; I will work on getting things to a point where I am confortable releasing on GoogleCode to start with and see what happens. Yeah, that's your problem right there. Get over it, your code will be slated whatever state it is in ;) Release early and release often is the mantra, in reality it takes balls of steel to actually do. No one wants to release buggy code. You just have to get over that feeling and post it.
&gt; (and not turn around once we're at a stable release and distribute it as their own thing as something entirely different, or even start selling it off). But with an open source licence they are free to do that. That's the WHOLE POINT of the freedom you are giving people. For example, I pay Redhat for linux.
No, it works by subclassing the singleton class and then injecting it into the singleton static field. Compare the two examples DummySingleton and DummyStatic: I could easily implement a DummySingleton::setInstance(DummySingleton $whatev), which would allow me to easily overwrite all the behaviour of the singleton, since every call gets tunneled through the getInstance() function. With the DummyStatic solution you are stuck with what you have and every static call is hardcoded to call exactly that function.
If you use a singleton pattern, the client code will always be hard coupled to the singleton instance. Class inheritance or composition makes no difference.
Yes, that's why a singleton is essentially a form of global variable.
What I have right now isn't so much buggy as it is incomplete. There are a few things missing that are ,eh, not so important but at the same time may be REALLY important to some people. Oh well, I will follow advice and just get the code up. I do have to find another name, as a fairly large company already uses the same name (although the name alone is a Hawaiian word).
I prefer sourceforge, but all of those sites work fine. 
This is what code review is for. Release it, review the code as it is submitted. 
Trust me when I say this, you want to release imperfect code. Imperfect code gives contributors somewhere to actually contribute, rather than a daunting shiny perfection they don't want to mess with. Toss some caveats about how "this is experimental, unfinished code, the API is not stable, etc" if it makes you feel better (actually probably for the best). But release the imperfect code. Most open source contributors are people who use a product, find a bug, and fix it themselves, feel good about fixing it, fix some more, then become a maintainer.
There are a lot of new features in PHP 5.3, Namespaces, phar, closures, lambdas, more magic functions, etc. [Simple explanation of what is new in PHP 5.3](http://www.webdigi.co.uk/blog/2009/what-is-new-in-php-53-for-php-amateurs/)
wait... what are you asking?
What exactly is your code setup right now? Individual PHP files for pages, massive include directories? I have found the easiest way to work with multiple developers is indeed to move to a Framework, keep your files simple (1 class per file), stick to the PEAR directory/naming structure, etc. So even though I haven't seen your setup, I would bet you would do better to move to an established framework. I would suggest Zend Framework only because I am personally familiar with it. Symfony, Kohana, Code Igniter, all of those are equally valid choices.
*individual PHP files for pages &amp; massive include directories?* Yes, although we do our best to keep that down.
Instead of teaching him straight PHP would it be better to get him somewhat acquainted with PHP and then move to a framework where both of us learn the new framework. If yes, which would you recommend.
:( Do yourself a favor and take the time now to move over to an established framework, follow their conventions to a T. If anything it'll force some good habits that you can deviate from late as you need it. If you want some sample code send me a private message and I can point you in a good direction or 2 as well as package up a small sample Zend Framework app for you to take a look at. Also consider [Doctrine](http://doctrine-project.org) for your database work. I can link to my blog a little later with some of my tutorials on how to work with them (especially Database Migrations/Versoining) **Edit** I make my suggestions as someone who used to do multi-developer PHP applications that were pretty ad-hoc, PHP file for each page, that made the jump to Zend Framework and Doctrine and haven't looked back.
I recently added a programmer to create a php website / program and started using Zend Framework at the time. What I can say is it will not be easy to teach them (or have them learn) both things at the same time. However, if you are starting a new project it would be worth it. 
Honestly, if he's got a background in C or Perl, he should be able to pick up PHP in a very short period of time. The flow control and "basics" of PHP are very C-like. As for swapping frameworks? Yes, this is perhaps a good time, make one of his tasks the porting of one to the other. I am a "Learn by Doing" person. I cannot learn a new language without having a task to do. your mileage may of course, vary.
Doctrine looks awesome, thanks for that link. Any tutorials or common pitfalls you have found would be great. As far as Zend Framework is concerned while I have not used it yet I have used Zend Studio and found it exceptionally slow. It would appear from what I am reading that if you want to use the Zend Framework then you should use Zend Studio as your IDE. Do you find that to be the case?
&gt; As far as Zend Framework is concerned while I have not used it yet I have used Zend Studio and found it exceptionally slow. It would appear from what I am reading that if you want to use the Zend Framework then you should use Zend Studio as your IDE. Do you find that to be the case? Absolutely not. I do all my project work in Netbeans, though I often dive into VIM to do some patching, sometimes Notepad++, depends on my mood. I personally don't like Zend Studio either and don't recommend it to my friends. &gt; Doctrine looks awesome, thanks for that link. Any tutorials would could recommend would be extremely helpful. Generally anything you can find :P I can't think of any off the top of my head and realize the [only one I've written](http://www.toosweettobesour.com/2009/10/20/doctrine-migrations-proper/) is more about the proper command order to do migrations rather than using doctrine. Check out the doctrine manual. The cookbooks should give you some ideas as well as the [downloadable sandbox](http://www.doctrine-project.org/download/1_2_1/sandbox/1/format/tgz) should get you started quick. [Other tutorials](http://weierophinney.net/matthew/archives/220-Autoloading-Doctrine-and-Doctrine-entities-from-Zend-Framework.html) can point you in the direction of how to integrate Doctrine with the Zend Framework if you choose to go that route, and I think I may finally sit down and write a blog post on how I handle integrating the two.
That makes a lot of sense actually. I have started a google code page (I have NO CLUE how to use GIT) and didn't care for it much, so started a source forge page. Will get an update once I get things ready.
Yea, another good point. It's understandable with Redhat though, not like you bought a copy of Ubuntu. I really wouldn't have a prob. unless it was taken and re-released as another free project without any changes or contributions. My issue is with a lack of experience releasing code, what to do when someone who is experienced rolls around with some LLC, snatches it up, hurries the fixes and puts it out as their own and knows how to market or get an audience to it? Would kinda defeat the point of releasing my code at this point?
You might want to take a look at [symfony](http://www.symfony-project.org/). Great doctrine integration ( [jwage](http://www.jwage.com/), the main doctrine developer, works for (sensio labs)[http://www.sensiolabs.com/en], the company that created symfony ) Plus it's awesome. Edit: Lots of active development, and a lot of good tutorials (but some are out of date, see point one) Oh, and I'm exclusively emacs/tramp/psvn.
One vote here for Symfony, it's really quite well put together and generally sane. 
Underscores have \_always\_ represented italics.
If you're developing public-facing sites that need security, speed, and organization then a framework is definitely a good idea. Although this is true, I would highly suggest that the new guy gets a good grasp on PHP before you pursue the framework option. The framework that I have had great luck with is [Kohana](http://kohanaphp.com). It's simple, easy to get up and running, and has an amazing community to go along with it. It takes advantage of PHP 5 and, thus, doesn't work with any prior PHP versions.
Check out CakePHP as well, less magic than symfony, works great. It's a bit faster. I've used that on a few huge projects. It doesn't use Doctrine, but it's the same concepts. 1.3 is coming out soon. I didn't like symfony so much because it was a bit too much going on behind the scenes, but I would use it now. They both have great code generation and ORM. Either/or wouldn't be a bad choice. Cake also has the bakery with user plugins/helpers/libraries, etc which can also speed up development quite a bit. My IDE is vs.php. I can't stand Zend.
Try both ways, using _memory\_get\_usage_ to check how much memory is used, then report back.
shit, damn I'm rusty. good idea!
What is your thoughts on Zend Framework, and why would you use Kohana over that? Edit: The framework, not the IDE.
While I've admittedly never developed as heavily in Zend Framework as I have Kohana, I have done a hefty amount of research on it. The general consensus is that Zend bigger, slower, and has a higher learning curve than Kohana.
To expand on my reply above/below, I'll explain what I really like about Kohana. Kohana doesn't force you to use particular naming conventions, database conventions, or anything else. If you want to use their libraries to interact with your database, that's fine, but if you don't want to for a particular model, that's fine too. It's incredibly light-weight and has a very intelligent design (helpers, libraries, models, views, controllers, hooks, etc.). It's fully customizable. If you think that a system class is missing something, you can extend it and add the functionality that you need without having to intrude on updates or the like. Security is another large factor. You can toggle a setting in Kohana that will allow global XSS attack filtering on all of your $_REQUEST superglobals. This means that you won't have to do all of this yourself. You can also choose not to use this option and do all of the filtering yourself to help performance. Those are just a few of the many reasons why I like it. Let me know if you'd like to know anything more about it!
I suspect that the performance difference depends on the types of keys your arrays use and how you want them handled. Your foreach loop acts a lot like array_push(), btw.
Learn by doing also.
Thanks for the replies, that is very informative.
It's probably not a problem unless you deal with really big datasets. foreach-ing is definitely going to be slower. 
You're welcome. If you do decide to go forward with Kohana make sure that you sign into the IRC channel with development questions that you can't find in the manual. There is always someone helpful on the channel and they're never belittling or condescending like some community users can be.
Doing a little more research about various frameworks I came across this [article](http://pablolivardo.wordpress.com/2009/08/12/kohana-vs-cake-vs-zend-vs-codeigniter-vs-symfony/) and was wondering your opinion on what she said. Not trying to pick on you, just trying to fully research this.
PHP is slow. It's a lot slower than you think it is because most of its slowness is avoided by implementing its whole library as C functions. To keep PHP fast use built-in functions whenever possible. It's rarely the wrong choice. Recently my employer was hiring PHP developers and I wrote a puzzle for them to solve. The puzzle was posted with the ad so it wasn't rushed during the interview. The idea was just to see what sort of algorithm they could come up with. One guy wrote a really nice algorithm, but it was implemented entirely in PHP. My version, which used built-in functions to do a lot of the work, was about 18x faster. I know this is anecdotal evidence, but I've done enough PHP work to have seen this pattern a lot. PHP's built-in functions seem to be relatively well-optimized.
A good page for comparisons is this: http://www.phpbench.com/ While it doesn't benchmark that specifically, you can use that same method above to run a quick benchmark. I would think the array_merge() is faster, since essentially that's running straight in C, instead of re-implementing that same functionality in PHP
To me it looks like the author got frustrated because he didn't have the knowledge to figure out what was going on in the code. I mean, let's be honest, it's not even an article with legitimate points. It simply rips on Kohana and provides no basis for comparison on any of the other ones. His summary for every framework other than Kohana is "Good documentation, examples and community support." Wow, very insightful when you say the same thing for EVERY SINGLE FRAMEWORK in the list. I'll be honest with you. Yes, I have had to go through the source code in Kohana on a few occasions to answer a few of my questions. I am currently running on the SVN trunk for my project, so there are parts that haven't been added to the manual and others that have been changed since the manual was created. Do I think this is a bad thing? Not at all. Frankly, if you're working with a framework you SHOULD have a grasp on what it's doing and how it works. Going through the source code is not as difficult as the author makes it out to be. Every system function is incredibly well documented and contains examples, descriptions, and detailed intent. As far as the magic methods point goes: Kohana does take advantage of this, but I don't think it goes overboard by any means. PHP's magic methods are there to help you and are great when they're used wisely, which is precisely what Kohana does. You won't see this in any framework that is built to work in PHP 4, since this feature didn't exist then. I tried using CakePHP for awhile, but I didn't like it. It had a very steep learning curve and tied you into conventions. Some people swear by it, but it wasn't for me.
I remember I got my start in php with Joomla. Just hacked around and learned so much through curiosity. 
Or, you know, stop worrying about micro-optimizations and worry about coding your site in a responsible and maintainable manner. The single line of array\_merge() makes your code more readable (or at least easy to understand the function), as well as handles the fact that the foreach loop will not merge like entries (hence it's array merge, not array concat). Later, when your site is actually up and running, and you find yourself being hit with performance problems, use Xdebug or some other profiling tool to find out what your real bottle neck is, which will 9 times out of 10 NOT be this section of code.
Indeed, thanks again for your detailed response. Seemed to me like a big example of "the grass is greener on the other side" but as it was one of the more popular links on the topic of PHP framework comparisons I thought it may have some merit (which it does, in a blown out of proportion kinda way).
Well, if you're *really* worried about memory usage, you should - in your foreach loop - make sure to unset the values from $b after you've set them. I.e. ($b as &amp;$val) { $a[] = $val; unset($val);} Unless you're doing it on function arguments, then copy-on-write will bite you. But that's just silly. array_merge is there for a reason, and you should use it. This is exactly the kind of micro-optimization that you should *not* do in PHP, simply because it makes no sense. Not to mention that your foreach-loop there, it *does not do what array_merge does*, so replacing code with that would break things. i.e. if you have non-numeric indices, array_merge will replace the existing keys with the new ones. **tl;dr:** Use array_merge. If your concern is memory, choosing the C-code over the PHP-code should always be right. 
**FTA**: *Or in other words  if your code was correct before upgrade, it will work fine with PHP 5.3 too* Yeah, that's kinda our problem. We've got several clients whose sites we took over from other developers who weren't exactly on top of their game. And these aren't small sites, we're talking huge codebases.
Static variables on subclasses get shared with their parents. I learned this the hard way.
I'm not sure it's worth getting hung up on the performance benchmarks on some blogs about various frameworks. If you implement proper caching (sql caching, memcache, output caching) then it all becomes somewhat irrelevant IMHO. Where's the logic in choosing a less-capable framework that's harder to learn, use or extend, just to save milliseconds on a virgin page call. Is it worth the time you'll waste otherwise? It's a classic [false economy](http://en.wikipedia.org/wiki/False_economy). (My boss's favourite pointy-haired management phrase of the moment)
If that happens to you then you have a successful open source project. When someone takes your project and improves it, **that's the whole point of open source**. You don't own it, you just contribute to it. From what you are saying, going GPL, LGPL or Apache is the wrong direction for you. You need to really think about open source and a community that you don't control and most of whom are activly hostile towards you. BTW I am lead programmer and project owner of open flash chart. BTW I assume LLC stands for Lucky Lucky Clover.
&gt; not like you bought a copy of Ubuntu Yes it is. Ubuntu is Linux, as Red Hat is linux. CentOS is the free version of Red Hat. We buy redhat for many reasons, too many to go into here. But lets just say we looked at Ubuntu (and all the other distros) before purchasing redhat for a few grand a year.
Don't use that, use [memory\_get\_peak_usage](http://ie.php.net/memory_get_peak_usage).
I personally have tried them all but I keep on going back to CakePHP since I can get my work done the quickest using it. It has great components built in and many more created by the community. I have never had a problem with speed and have created sites with 1000s of simultaneous users and millions of database transactions per month. The documentation now is excellent! Almost every part of the core is documented clearly in their cookbook as well as an awesome API. It makes life much easier if you follow their conventions but you are in no way limited to using them, it is quite simple to override and use your own. I would also suggest taking a look at lithium (li3) which is a based off of CakePHP but is PHP 5.3+ compatible.
What's quicker, C or PHP?
I'll admit to mulling it over but I don't know if /r/php is exactly the place to talk about it. ;)
A framework is certainly good for collaboration. It's also good if you all developers aren't experts on web and php. Zend Framework can be used as a full stack framework, but most of its components are very loosely coupled, so you can actually pick out some parts and use. Symfony have been moving in this direction recently, although I'd still say that (at least in concept), its components are tighter bound. Both of those frameworks have a high level of complexity, but they also have a high level of quality and they have very large communities and commercial support. If you want a "big" framework, one of those should be your pick. Kohana/Codeingniter are considerably less complex, but makes some tradeoffs to accomplish this. If you're building simpler web sites, I think they can be an excellent choice. If you're building something that is inherently complex, maybe they won't offer you as much. If you're building something more cms-y, you might also want to look at Drupal. There's a lot of reasons why you wouldn't want to use Drupal, but it is slowly moving from cms to framework and it has a very large community. If your project fits to it, it *might* be a good choice. That was my 5 .
A very valid point. I guess it's just really hard to decide what to use, they all have their pros/cons... I was hoping to eliminate a few off the list. :|
I use Drupal for all my CMS work. It's not perfect but it's only been getting better. Can't wait for D7. :) That being said, no Drupal does not fit the work we are doing now unfortunately. I could heavily modify it to make it work but it just doesn't seem worth it to me.
This guy knows what he's talking about. Worrying about stupid shit like this is just wasting your time and wasting the time of whoever will have to maintain your code. Array merge is clear in its purpose, and [it doesn't look like it matters anyway](http://www.reddit.com/r/PHP/comments/b8i2s/qq_i_dont_want_to_use_array_merge_seems_bad/c0lhr8v). Stop trying to reinvent functions that are written in C by doing it half-assed in php.
Have you considered going outside of PHP? I'm a CodeIgniter fanboy (yes, even over Kohana) and I do Drupal work fulltime, but if I had the chance, I'd switch to Django for almost everything. If you're just taking on a new guy who doesn't have any PHP experience, now would be a perfect chance. I won't elaborate until you say whether or not it's a possibility.
The key when choosing a framework is to try it out. Build a basic blog or something like that in your top 3 choices for frameworks. I was determined to like Kohana based on the community, stuff I've read, etc., until I did this and it changed my mind completely.
I tried to use Kohana, but gave up as some of the design descisions were a bit odd. I could get round them, but the default set up was not what I was looking for. I have developed a few sites using ZF, and the latest I ripped out the DB layer and used Doctrine. This is the total sweet spot for me at the moment. ZF 1.10 is svelte.
What design decisions in particular are you referring to?
With "built-in functions", do you mean the functions already included in php? Because even those are costlier than just not calling a function, for example, _$x===null_ is faster than _is\_null($x)_. Not that it matters unless you do lots and lots of null tests, of course.
[Zendcasts.com](http://www.zendcasts.com/tag/doctrine/) has some good video tutorials on integrating ZF and Doctrine. Plus you get an upvote for Netbeans over Zend Studio (aka, Eclipse with extra stuff). I recently made that switch and I find it loads easier to use. I used Netbeans a lot back in my Java days, so not sure why it took me so long to try it out with PHP.
Yes, I mean the included functions. Obviously, the less your code does, the better it is for performance. If you can have the interpreter do something ($x===null) then you're much better off than if you call a function to do the same thing. array_merge() is a good example of well-implemented C code that will execute faster than if you re-implement it in PHP. I know that for a small number of executions this sort of thing won't make a huge difference, but inside a large loop it will. It's good practice to always write things in a well-optimized manner, especially when doing so means writing less code so you gain the benefit of readability as well.
Congratulations: your startup is the first employer in this century to hire a programmer to work in a language s/he doesn't have three years of resume experience in. 
Well up until around 6.5/6.7 it really did suck for PHP. 6.7 was a major turning point in which it became awesome.
I'm fine with it, he is one of the smartest people I know and has a solid background in programming. We've known each other for years and he finally quit his job and came to work with me. I'd take him over someone we hired off of Craiglist with 10 years of PHP experience any day.
Yeah, I guess I should have specified/double checked. It will merge on key collisions obviously, which is a minor oversight on the OP's part. However oversights like this are why we don't reinvent the wheel. In seeking a submillisecond performance increase, the OP introduced a pretty serious bug by returning a new array that doesn't preserve key information.
I just started a new job, and the company is in the process of transitioning over to the zend framework. From what I've seen so far it's a really nice language, the Zend autoloader makes it really nice not needing to require libraries and stuff in every file and finding the file for an object is so simple because it's in the class name, but they can get ridiculously long... throw new Stdlib_Checkout_Processing_Command_Node_Abstract_Exception(); //ack! but at least I know that exception definition is in the exception.php file of the Stdlib/Checkout/Processing/Command/Node/Abstract/ folder
Thanks, you made me realize I was running an older version of Netbeans ;) Just upgraded to 6.8
I thought it represented emphasis and in my mind was a plain text representation of an underlined word.
It's a bunch of classes.
I'm a ZCE and a ZFCE, and I despise rails, if only for the community around it. I just had my first fling with Django, and I have to say...it's pretty frickin sweet.
Classes can be used in a lot of different scenarios, but one way that you should think of them is as being "objects". Say that I had a site that had a "user" database. I could have a class called "user" that stored all of the info for a particular user and had functions like "add", "update", "delete", etc. I'm kind of oversimplifying, but basically if you populated your user object, you could access its properties like $user-&gt;username, $user-&gt;age, $user-&gt;birthday...things like that. Then you could call the update() method to update the object based off of its data. Another way that you could use classes is by having helper classes that all perform similar tasks. For example, if I wanted to write a helper that handled validation related functions, I could create a Validation class with static methods and do things like Validation::digit($str) to check if the string is a valid digit. Does that make sense?
*cringes at browsing Wordpress code to learn things*
Please don't use global variables. It makes my head-spin just thinking about what a horrible mess it could turn into. Look into "dependency injection."
I know already said you don't want to use CodeIgniter, but here's a [pretty long tutorial](http://www.phpandstuff.com/articles/codeigniter-doctrine-from-scratch-day-1-install-and-setup) on CodeIgniter + Doctrine.
CakePHP is a really good framework to use. We are using it with 5 developers and can pump out a website in a week. What we do in the controllers is split each function into a seperate include files so we can all work on individual functions instead of wasting time waiting on each other to finish with a certain file. We really should set up an SVN, but it works for us. If I could ask, what languages does he know? As somebody who daily works on ASP, ASP.NET, and PHP I can tell you that although the syntax is different, the thinking behind it is all the same.
OOP is all about being able to reuse code you've already written and being able to change code without affecting other things. &gt;For example, if I have an "add friend" feature on a website, I could have 1 page that allows to add friends and in that case I'd use a simple function on that single page. OR if there are multiple ways and multiple pages that I can add a friend on (like facebook), I'd create an 'addFriend' class in a separate file, then use import to include it on any page I'd like. That's a good start to reusing your code, but it's just an import statement. OOP is a *style* of coding, and although people will put it up on a pedestal and proclaim it is the **only** way to code, that's not necessarily true in some cases. Pretend you were an engineer and were told to build 3 cars. Each one for a different terrain. You could **not** use OOP and build 3 different cars from scratch, each time designing a new gas tank, steering wheel, brake pedal, computer system, to suit the specific needs of each car. You may make one steer with 2 levers, one with a wheel, one with a keypad, etc. Each time someone drives one of those cars they have to learn how to use it's specific functions. If you were to use OOP, you would design one basic car (a car class what have you) which has all the basic functions like steering, braking, etc, and then customize them to suit the terrain afterwards. When someone uses your car, the gas, steering and braking are all the same because they were designed first. That's a crazy oversimplified version but pretty much what it's all about.
Sort of - a class is really a _collection_ of related functions (called 'methods' when they're in a class). So, using your example, you might have a 'User' class. In this class would be all the methods related to a user - getting information about them, setting information about them. Then, you can do things like this: $user = new User(24); // Assuming 24 is the user ID $user-&gt;setName('SoBoredAtWork'); $user-&gt;setInterests( array('PHP', 'reddit') ); $user-&gt;addFriend(67); // Assuming 67 is another ID Then on another page you might have $user = new User(24); echo "This users name is " . $user-&gt;getName(); echo "Their interests are " . implode( ',', $user-&gt;getInterests() ); echo "Current friends are " . implode( ',', $user-&gt;getFriends() ); setName, getName, setInterests, getInterests, addFriend and getFriends would all be _methods_ within your User class. Now let's say you get a friend to help you with a project which uses the User class. One beauty of OOP is your friend doesn't need to know what happens inside the User class. He can just load it, do $user-&gt;getFriends, and get the data he needs. _How_ it gets the friends doesn't matter to him, because you manage that in the object. It might come from a database, or from a flat file, or whatever, but it's not his concern. It's basically a way of neatly bundling up related functionality for easy use (and reuse). Of course, once you get into more advanced OOP, there are additional benefits with using it. [edit] Got a bit more time now, so want to explain another concept: extending objects. Extending a class means you 'merge' a basic class with a slightly more specialized class. Let's go back to your example of having a User class. Within your system, you might have 'members' who are ordinary users, and 'moderators' who have some sort of additional abilities - but both members and moderators have the same basic methods and properties. So, you create a User class which handles this basic functionality. If your user is a moderator, you then _extend_ that class with a Moderator class, and now your $user object has methods for handling a moderator. $user-&gt;getPermissions(); // Might get the sections this mod can edit, for example Your friend can now use the moderation methods, once again without concern for _how_ they work internally. 
If you want to understand how to use PHP's OOP learn a framework. Most are built with OOP and you have to use it in order to use the framework. I use Zend Framework, but the others are also good.
[How I learned about OOP.](http://www.lysator.liu.se/mud/lpc.html)
You should definitely get your team on source control. Just because it works for you doesn't mean that it's right.
[Wikipeida OOP] (http://en.wikipedia.org/wiki/Object-oriented_programming#Encapsulation) Their are two main points that you need to "get" in order to understand OOP: * encapsulation This means that you can only access the parts of an object that it will let you, which depends on where you are trying to acces it from. Read about private, protected and public * inheritance You have to make four classes, square, rectangle, triangle and circle; they share some methods (getArea, getWidth, flipVertically) but the implementations are not always the same (square and rectangle have the same implementation of getArea, but not so with triangle). What you want to do here is allow square and rectangle to use the same code for getArea so that it only exists in one place, so that if there is a change, you only have to make it in one place. So, you make a parent class Shape Triangle, Circle and Rectangle inherit from Shape. You put everything that they all use in Shape (getWidth is the same in all, it just returns the $shape::width variable), but they all have different getArea methods. Now, Square inherits from Rectangle (because they have the same getArea method, but Square has a different resize method, because it only takes one parameter) &gt; if I have an "add friend" feature on a website, I could have 1 page that allows to add friends and in that case I'd use a simple function on that single page. OR if there are multiple ways and multiple pages that I can add a friend on (like facebook), I'd create an 'addFriend' class in a separate file, then use import to include it on any page I'd like. You would probably want a class User that has a method addFriend($user), the idea there being that you have one user object and you pass it the other user object. 
we have source control, just not with the ability to work on the same file at the same time. We use sourcesafe because of our ASP.NET projects.
Okay. You should get on a source control system that allows this though. Your source control system should not dictate how you design your applications.
You can think of classes as a collection of functions and variables that work together. Other class can extend those classes to add functionality, while still being compatible with existing functions that take the base class (assuming the overrides of functions don't break it). class Person { public $name; public function __construct($name) { $this-&gt;name = $name; } } class HillBilly extends Person { public $accent; public function __construct($name, $accent) { parent::__construct($name); $this-&gt;accent = $accent; } public function is_funny_sounding() { if ($this-&gt;accent == "Southern" || $this-&gt;accent == "Newfie") { return true; } return false; } } $p1 = new Person("Ashley"); $p2 = new HillBilly("Jimbo", "Southern"); if ($p1 instanceof Person) { echo "p1 is a person"; } if ($p1 instanceof HillBilly) { echo "p1 is a Hillbilly"; } /** Output: * p1 is a person */ if ($p2-&gt;is_funny_sounding()) { echo "Sounds funny!" } /** Output: * Sounds funny! */ if ($p1-&gt;is_funny_sounding()) { echo "Sounds funny!" } /** Output: * ERROR!!!!!!!!!!! $p1 does not have that function */ Here we have a person class and a hillbilly class that extends the person class giving it new functionality. 
I also agree with burying_luck. Additionally I have used Kohana myself and found it quite vast but yet quite simple. It is a breeze to install and easy to develop for. Best of luck in your framework evaluation as I was once there myself. it came down to Symfony vs Kohana (complete opposite end of the spectrums).
It's a way of making the logical layout of your code reflect more accurately the logical layout of the problem you're trying to solve. A bunch of functions is flat, faceless - no indication how they fit together or what they can apply to. With OOP you can define the relationship between blocks of code - X contains a Y, Y is part of Z, P can be applied only to things of type Q, etc. That's the main concept I think.
Upvote! People don't realize the productivity benefits of source control until they start utilizing it. 
Most of Wordpress' code seems scattered and very disorganized, but I was curious as to how people were integrating plugin functionality. Finally I found Kohana and I think that is possibly one of the easiest ways to do it.
Yeah, the Wordpress code is an absolute disaster. I also use Kohana. =)
&gt; Polymorphism shouldn't be a new concept to anybody. You deal with it every day in the real world. There's more than one class of cat to skin, but you skin 'em the same way, even if the specific instance is completely new to you. Let's say for example you want to fuck a hole. You fuck all holes the same. You don't care if that hole happens to be a mouth, an ass, or a pussy, you're gonna fuck it the same way regardless. However, the mouth, pussy, or ass may respond differently to the fucking. http://www.kuro5hin.org/story/2006/3/14/175929/544
Right. In case it wasn't clear, I don't particularly endorse the use of global variables, but if you *must*, a proper global variable is better than a singleton or static class.
Imho, inheritance is a rather unimportant feature. You can write perfectly object oriented code without using class inheritance.
Might I make a suggestion about the website, the navigation to the complete show listings was practically invisible I didn't immediately see it so I resorted to finding the last page so I could start from the start. Wasn't until I a had finally found the start did I notice the navigation section wedged in there with stuff I subconsciously ignore (advertisments/tag cloud/social networking widgets/etc.)
You could work around that, should the need arise. class ParentSingle { static protected $instance = null; protected function __construct() { } static public function getInstance() { $name = get_called_class(); if(is_null($name::$instance)) { $name::$instance = new $name(); } return $name::$instance; } // additional functionality public function test() { echo get_called_class(); } } class ChildSingle extends ParentSingle { static protected $instance = null; } ParentSingle::getInstance()-&gt;test(); echo "&lt;br /&gt;"; ChildSingle::getInstance()-&gt;test();
 Whoa, I never knew about the get_called_class() function...
So would George Bush be a polymorphism of a hillbilly? Or is does he extend the hillbilly class? (I know, GWB jokes are old, but I still hate the guy)
This is where I learned about OOP in PHP http://www.killerphp.com/tutorials/object-oriented-php/ and what's nice is they also have videos :)
 implode($glue, $pieces)
No, those people tend to be fad followers. Or the only reason they can come up with for hating on PHP is inconsistent naming and parameter order or problems that existed way back in PHP 4.
It didn't until you asked me. Thanks a lot.
Doh, fixed! Thanks!
no
Only when they use that as a reason to think less of me as a programmer, as if my language choice somehow invalidates my ability.
Not really. While fun, PHP is generally pretty crappy as a programming language (I mean, Ive been using it for 10 years and I always need to consult the documentation because the function arguments are never consistent).
No, the less people that know it, the more the people that know it can charge. It isn't going anywhere any time soon.
Any books you can recommend on CakePHP? Amazon reviews for them are not so hot.
The way I see it, when you create a class, you're creating a new type of variable; except your variable doesn't just have one value, it can store lots - like creating a "dog" class, you can tell it to store a name, a weight, an age - all defined as strings and integers within the dog "object". In "$rover= New dog", "Rover" is the object, and "dog" is the *class* of object that I've written into a class file earlier. More than that, you can create functions within a class that do things. Like you can have a function in your dog array that, say, returns a multiplication of the dog's height and weight, if those were things you'd stored in your class and you had a reason to do that. There are more complicated things like polymorphism and inheritance (not actually that complicated), and this is obviously a very simple example, but maybe it helps. If it doesn't, forget it. Some dick spent six months of university telling me an object was like a car before it finally clicked. And if I've fucked up somewhere, someone yell out for god's sake.
Honestly I've never used a book for frameworks. Symfony are the only ones who offer books, but it doesn't make sense because they're constantly changing. For Cake, the best is the manual, (book.cakephp.org). It's got comments, etc, but I've been able to get through everything using that (model generation, using their ORM, sessions, etc). Cake actually doesn't allow (official) books on their manual because it's out of date as soon as it's printed. But I've printed out their cheatsheet which is helpful. I've been using symfony today to mess with writing an admin backend for a project who's front-end is in Cake. I ended up scrapping symfony and going with Cake. I didn't like symfony's docs so I could see how a book would help, but for getting up and running, well, Cake :)
Any personal doubts I ever had were dispelled when I realized facebook, the second largest website on the internet, runs php.
This should help [NSFW] http://www.kuro5hin.org/story/2006/3/14/175929/544
I just cash my paychecks and try to look sympathetic when they describe their search for work in other languages.
Yes, because I look up to PHP. sigh....
No. I don't use PHP because it's a great language, I use it because people request it (and it's quite easy).
My bad. But yes, switching proxies might be a problem.
I wonder why it's not statically translated
For front end views, yes. Although you should realize they are running their heavily customized/optimized PHP compiler dohicky. Their backend code is written in C++, Java, Python and Erlang.
Word up, the way PHP does overloading pissed me off just today, but I know I can fall back on it and make money when I can't get work writing python or embedded C or C# or whatever.
That's why they had to pretty much rewrite the PHP runtime?
That was helpful, thanks.
One thing I love about php is how you have to call the constructor of extended classes yourself, allowing you to set up extra things before the base class goes through its procedures.
No, I make a good living on PHP. PHP will be around for a long time and you can always find work. Seems like a pretty good language to me.
Nope. PHP allows me to own my own business and support myself. I'll get over the naming conventions.
Which would be a good thing to consider if you developed a website that got 1/1000th of the traffic facebook does.
It pays the bills. If you dont build your applications like shit and actually use OOP the way it is supposed to be implemented it runs perfectly smooth. (the reason facebook, yahoo, and many others rely on it)
...those problems still exist man
It's Canadian for Up
Nope, just as it doesn't really bother me that people look down on Macs, or using $editor\_of\_choice. I realize it's not a *great* language, but it's one I know and can [ab]use to do what I want. I won't religiously defend it - why bother? The language won't be insulted. I have started feeling guilty though about sometimes looking down on other languages myself.. like VB, even though I never used it.. so I *try* not to.
mixed **str_replace** ( *mixed* **$search** , *mixed* **$replace** , *mixed* **$subject** *[, int **&amp;$count** ]*) string **strstr** ( *string* **$haystack** , *mixed* **$needle** *[, bool **$before_needle** = false ]* ) I just get so confused with those two
I've put a lot of time and effort into PHP over the last several years, and lord knows it has its issues. But it puts food on the table, so I don't really care one way or another what people think. Maybe five years ago, I would've taken it personally when someone dissed my language, but I could care less now.
Yes, but only the way it bothers me that people look down on individuals of a certain national background or ethnic heritage. I'm bothered by closed-mindedness and us-vs-them sentiments more than I am about anything they say about the language. They really have no leg to stand on in regards to their complaints about the language. Yes, it's got a few problems, but any other language they advocate has problems that are just as bad, just different. Fact of the matter is it is the de facto technology that powers the internet and it's a powerful language. And many of the people who hate PHP actually hate the programmers who write bad PHP code, and not the language itself.
I don't have a problem with particular combination. There are a few functions I confuse, or forget their parameters. I can look them up in the docs though, so it's not that big a deal.
PHP's variables start with a "$" for a reason. :)
What's wrong with that? I wish more people would rewrite the PHP runtime, so long as they handled things in a compatible manner. More diversity in interpreters mean more choice, and some of them would be more resource-efficient.
&gt;I could**n't** care less now. FTFY
Yes, but I need to get over it. It was pretty sweet when a Java zealot (I have no problem with Java developers, but I do have a problem with developers who think Java is the solution for everything) got called on out on it though when he wouldn't stop complaining. Conversation went like this, and I am not embellishing: JavaDev: "PHP is crap. You don't have J2EE, you don't have JSR 168. You can't do anything in this language. Java has standards and provides an enterprise level piece of software." Manager: "How long have you been working on this project in Java?" JavaDev: "3 years." Manager: "How many people were developing for it?" JavaDev: "6" Manager: "How often did the [java-based] application go down?" JavaDev: "Don't know" Manager: "About once a week" Manager: "How many outside developers did you get to come provide portlets for the project?" JavaDev: "0" Manager: "Ok, so that was the past. Now, we have deployed the same application in PHP, running it in production with automatic failover and no outages yet, using only 2 developers, only 3 months of work, and we have a dozen outside developers lined up and ready to work with us." JavaDev: "Yeah, but PHP is crap."
&gt;inconsistent naming and parameter order **or** problems that existed way back in PHP 4. Apparently illiteracy is alive and well too.
No you just did some automatic regurgitation. There are other ways to take the statement. Five years ago he would have taken it personally, but now he has the capacity (he could) care less. **Edit:** Here, I drew a diagram: [http://imgur.com/EUUKR.jpg](http://imgur.com/EUUKR.jpg)
Lol, no. I look down on PHP and it's the only language I use. It really is a pretty shitty syntax. But whatever, it gets the job done.
So the param ordering issues don't still exist? I had to create a mnemonic to remember when to use array_walk v array_map as well as which order to pass the args.
Huh? You must be American. If you can care less, you still care. If you can not care less, you do not care. Understand?
No, because irrational and misplaced superiority complexes can easily be passed down the chain to the next less deserving. ASP programmers! HAHA! What a bunch of idiots. With their stupid &lt;% %&gt; tags and IIS servers. And don't even get me started on those Javascript guys! Then there are the smelly old COBOLlers. Why don't they all die already before they cause a Y3K bug and blow up the world with their CAPS LOCKS keys glued down and their weird moustaches. Yea... we "Pretty Home Page" developers are the man. 
Your logic has failed you.
Actually there are some reasons behind that. One of them being... $a = "Jim"; echo "My name isn't $a!"; I never use this ability personally as I find it ugly.
I roll my eyes and think "Lighten up, Francis"
To save you potential headache, ensure that magicquotes and registerglobals is off. If they are on, reverse it. These two functions will do that. function unregister_globals() { $register_globals = @ini_get("register_globals"); if ($register_globals === "" || $register_globals === "0" || strtolower($register_globals) === "off") { return; } // Prevents script.php?GLOBALS[key]=value if (isset($_REQUEST["GLOBALS"]) || isset($_FILES["GLOBALS"])) { exit("GLOBALS overwrite attempt detected"); } // Variables that shouldn't be unset $no_unset = array("GLOBALS", "_GET", "_POST", "_COOKIE", "_REQUEST", "_SERVER", "_ENV", "_FILES"); $input = array_merge($_GET, $_POST, $_COOKIE, $_SERVER, $_ENV, $_FILES, isset($_SESSION) &amp;&amp; is_array($_SESSION) ? $_SESSION : array()); foreach ($input as $key =&gt; $value) { if (!in_array($key, $no_unset) &amp;&amp; isset($GLOBALS[$key])) { unset($GLOBALS[$key]); } } } function remove_magic_quotes() { // php 6 no longer has set_magic_quotes_runtime so we only set it to false if it isnt if (get_magic_quotes_runtime()) { set_magic_quotes_runtime(false); } if (get_magic_quotes_gpc()) { $array = array(&amp;$_GET, &amp;$_POST, &amp;$_COOKIE); while (list($key1, $value1) = each($array)) { foreach ($value1 as $key2 =&gt; $value2) { if (!is_array($value2)) { $array[$key1][$key2] = stripslashes($value2); } else { $array[] = &amp;$array[$key1][$key2]; } } } } }
You must lack imagination. Despite the seemingly straight-forward notions there are other interpretations, and this is what I'm demonstrating beyond the typical FTFY response you learned. I'm speaking *capacity*. Even *in your example*, not being able to care less doesn't always imply not caring. "I couldn't care less about my girlfriend, I love her so."
I currently use PHP to make my living and support myself/brother/father on the income which I bring in. So if someone wants to trash talk on my ability to put bread on the table, let them, it's a free country until you feel the pain of having your face smashed in from giving your pompous opinions. Stick to what you know, and if the language which you use is not popular, you will feel it financially. Popular frameworks seem to make it even when they are shit, just ask RoR, i mean, twitter was started on it's back, and people are still using it, even though RoR has a very limited scope in its ability to bring large applications to bear. I guarantee to anyone wanting to know that Twitter is almost now completely written in some compiled language due to it's immense size. 
You guys are acting incapable of seeing past the "rule" you learned on reddit. He can now, care less, that someone has dissed his language, than he could before (before he would have cared a lot/taken it personally). Isn't that saying something? Isn't that an evolution of his position? *Edit:* Try this one: "I was really mad 5 minutes ago, but I could be less angry now". Or the converse in my reply to mahcuz. I'm not saying he *intended* to write this, I'm saying that it doesn't matter and that rather than spitting up something contrived as a concrete we should attempt intelligent (even if its creative or unusual) consideration.
It's "Personal Home Page" ;)
That method can actually be more user-friendly for non-programmers though. If you use more useful names, it becomes logical: $name = 'Jim'; echo "My name is $name!"; is more readable and understandable than $name = 'Jim'; echo 'My name is ' . $name . '!';
Not at all. As a tool, it gets the job done, and does it well (if it's well written...). I have to use classic ASP at work, which makes PHP look like TBTSSB.
People look down on PHP? I'm forced to code in .NET at work (c# thankfully, so it could be worse), i'd be in heaven if i could code PHP for a living, i have to do it in my spare time. If anything i look up to php coders
I prefer #2, because it's much more readable in my syntax colored editor.
Actually, it's PHP Hypertext Preprocessor nowadays. As in: Since 1997 "nowadays".
But .. it's an idiom - You shouldn't interpret it literally. *I couldn't care less* means *I don't care*.
No, language is more complex than that. A sentence can have a totally different meaning than its composite words. "I could care less" is just one example of this. Let me ask you this... Have you ever seen someone genuinely confused by what was meant by "I could care less"? Have you ever seen someone hear that and say--not sarcastically, not in a grammar-nazi way, but sincerely--"you could???" I'm willing to bet you haven't. Somehow, most people grasp the intended meaning immediately. By comparison, if I were to say, "I am not hungry at all" when I was starving, or "I voted for John McCain" when I voted for Obama, that would definitely lead to confusion. Lots of it. Something is clearly different about "I could care less" and something is being missed by the people who freak out about it.
I prefer sprintf('Hello, my name is %s and I am a %s', $name, $addiction)
Yeah, I getcha. I understand its common use, of course. I'm really just responding to the absoluteness of snarky FTFY's (or even more-so "You must be American to be this stupid") and critiquing our immediate response to these things and the type that will focus on the unimportant oversight rather than the message
I'm all like "yo PHP here's this business problem that needs to be solved fast" and PHP's all like "om nom nom". [Shameless plug to favourite bad ass framework](http://www.agavi.org)
Ah .. Yes, I suppose you're right. I don't think *mahcuz'* comments was meant to be belittling though. Now I'm curious - Is this a strictly British idiom?
Yes, I'm sure that Twitter wouldn't have any of the growth problems if they were using PHP. That's bullshit. Twitter had problems that were mostly bound to I/O and to their data model. And of course there is always possibility that RoR just wasn't right framework for Twitter, but saying that RoR is shit based on example of Twitter is like saying PHP is good because Facebook is using it.
print("Hello, my name = {$name}");
People? People that matter? Naaah.
I did J2EE development for 5 years and I mostly do PHP now. I figure the Java people are too busy fighting with their platform to bother talking about PHP. I quit my J2EE job just to get away from Java and Websphere. What a nightmare of downtime and terrible deployment options, and to think I actually thought it was good for some time! The PHP language sucks, but the platform is good and it's a great way to get things done quickly while maintaining equal or better scalability as Java at a far lower cost (both time and money). The best thing I can say about PHP is that it's just a language and it lets me pick and choose components and frameworks from a very large ecosystem. It's the stuff that's built for PHP that makes it so useful.
Twitter's frontend is still written in Ruby, as I gather; it's their backend which is in "some compiled language" (Scala). How is this any different from your PHP websites being backed by MySQL, which is written in "some compiled language" (C++)? Did you make a mistake in choosing to use PHP because you wouldn't write a production database directly in it?
You mean is_null() vs === null? PHP is known to have a terrible interpreter. There are a ton of places to make seemingly innocuous changes that will have drastic implications on execution speed. is_null() is about half the speed of ===null, but it's still so quick that it won't make a difference unless you're calling it tens of thousands of times. I'm in the habit of always trying to do the faster thing and maybe I can save 0.1 seconds per page load, but it's enough that I'm happy doing it. IMO, if you get lazy with execution speed then you'll get lazy everywhere.
Why not just switch away from PHP and use a language that is more resource effective? And maybe some consistency would be good.
those problems [inconsistent naming and parameter order] still exist man [and are worthy of criticism] I make a living writing php and those two issues trip me up too often. One thing that got me recently was the fact that the function to get the name of a class is get_class($obj_instance). Sure that is an okay name for the function, but without prior usage, would you have guessed get_class or get_class_name as the name of the func? I am thankful for php, and in many ways it has been my gateway programming drug. Why are people on the internet so quick to be so negative anyway? You'd never reply like that to my face
It's just perpetuated stupidity. Being a non-native English speaker, I haven't been subjected to much colloquial speech, and as such I *was* quite confused the first time I heard "I could care less".
God, I can't remember. Something to do with the way the global template inherited stuff from the actual view. I seem to remember it was all backwards compared to ZF. Also I'd been using PEAR:DB for my model layer and their DB stuff at the time was pathetic, but they had a new release in the pipeline. But, like I said I'm useing Doctrine which is wonderful.
Just because tons of people say "irregardless" doesn't make it a word.
In the sense that you can build objects, but that's like saying that you can drive a car with no tires. Yes, I guess you can, but why would you?
Irrespective of the use, many people will say it regardlessly.
Were you also confused when you heard "pardon me" or "fuck you"? I think the intended meaning of "I could care less" is quite clear, even to non native speakers. At least it was to me.
Why would I? Those are well established phrases. If you haven't heard it before, there is no reason *not* to think that "I could care less" is some kind of play on the usual saying.
I like the idea of Doctrine but, honestly, I'm a little intimidated by it. Ever since the early days with Front Page and Dreamweaver, auto generating code's a little scary to me.
Nope, I keep building the apps and cashing the checks.
Another one? I've been looking into the different PHP frameworks, and I'm stunned by how many there are: * CodeIgniter * Yii * DooPHP * Kohana * Symfony * CakePHP * QCodo * Solar * Zend FW * Radicore * Akelos * PradoSeagull * Mojavi * Phrame * Studs * Ethna * Agavi
Can someone give me some good reasons for the php hate? Besides mixing up function parameters, what else sucks?
Wow, I'd almost think you were my old boss, he finally gave up on Java and Websphere and went back to his home country. I just wish everyone could see what you said, which is that PHP is just and language that you can pick and choose to use for the right job.
printf prints to screen (why not call it echof?), while sprintf makes a sting. Is the overhead that comes with calling a function to print a string not that important? Is it less than or equal to than just doing echo "Hello, my name is {$name}"; ?
If any of you guys touch my stuff, I'll kill ya. I'm a killer. If any of you guys touch me, I'll kill ya. If any of you guys calls me Francis, I'll kill ya.
Classic ASP is still in production use? I know some companies have entire code bases written in the stuff, and don't want to upgrade for fear of breaking something, but come on! I had to code in classic ASP for my first web-dev job at $5/hour. The pay was horrible, but it wasn't nearly as bad as working with a MS Access DB and ASP pages.
I almost never have any code that writes directly to output so it's a matter of habit. Performance implications are miniscule - for me the more important thing is to be sure that a year from now a developer I don't know would be able to read my code without cursing me every minute.
Heh. I took 2 days to build my own. 
touch. touch. touch. touch. touch. touch. touch. Francis. . . . touch.
You need platform shoes. 
Better Edit: "I was really mad when that happened to me 5 years ago, but I could be less angry about it now (if it happened again)." Which is more like the original comment.
I remember it being my own Personal Home Page. 
&gt; "There are only two kinds of languages: the ones people complain about and the ones nobody uses." **Bjarne Stroustrup**
Yeah, I really would, but I think you're misinterpreting my tone. It wasn't "grr, hiss, insult" as much as "har, snark, joking".
Security Enhancements and Fixes in PHP 5.3.2: * Improved LCG entropy. (Rasmus, Samy Kamkar) * Fixed safe_mode validation inside tempnam() when the directory path does not end with a /). (Martin Jansen) * Fixed a possible open_basedir/safe_mode bypass in the session extension identified by Grzegorz Stachowiak. (Ilia) * Added support for SHA-256 and SHA-512 to php's crypt. * Added protection for $_SESSION from interrupt corruption and improved "session.save_path" check. * Fixed bug #51059 (crypt crashes when invalid salt are given). * Fixed bug #50940 Custom content-length set incorrectly in Apache sapis. * Fixed bug #50847 (strip_tags() removes all tags greater then 1023 bytes long). * Fixed bug #50723 (Bug in garbage collector causes crash). * Fixed bug #50661 (DOMDocument::loadXML does not allow UTF-16). * Fixed bug #50632 (filter_input() does not return default value if the variable does not exist). * Fixed bug #50540 (Crash while running ldap_next_reference test cases). * Fixed bug #49851 (http wrapper breaks on 1024 char long headers). Over 60 other bug fixes.
nope
No. See my other reply.
I never implied you were stupid. My apologies. Just I typically see this usage of the phrase by Americans.
* php 5.3 is out, maybe port it to namespaces ? * Haven't really look at your code much but it would be cool if you could do ...where('id &gt; :min and max_id &lt; :min + 10', array('min'=&gt;5)) 
Here's [a link to the announcement](http://www.php.net/archive/2010.php#id2010-03-04-1), and [a link to the full changelog](http://www.php.net/ChangeLog-5.php#5.3.2). 
I think you sold us. We'll probably be using CakePHP. -The new programmer.
I thought about 5.3, but that would cut out a lot of potential users. Namespaces, lambdas and all of the other advancements would make this a hell of a lot simpler to code I like that syntax, show me more examples
thanks when creating the link it was giving me a hard time about linking directly to the announcement. I didn't think to put it in the comments..
* Yes, but this is bad. Look at IE6. That abomination will stay until people or companies like Google (which already did or planned to) drop support for it. I actually implemented 3 different ways: Simple way (like yours) (basically call_user_func_array to sprintf after escaping) $builder = $db-&gt;build(); // returns Database\Builder $email = 'john@example.com'; $password = md5('12345'); $result = $builder-&gt;select('members')-&gt;where('email = %s and password = %s', $email, $password)-&gt;execute() Arrays $data = array('email'=&gt;$email, 'password'=&gt;$password); # where takes two parameters, array and [$separator = and] $result = $builder-&gt;select('members')-&gt;where($data)-&gt;execute() I don't know what this way can be called (I know it has been already) $data = array('name'=&gt;'john', 'email'=&gt;$email); $result = $builder-&gt;insert('members')-&gt;set('name = :name, md5_name = md5(:name), email = :email', $data); 
&gt; Improved LCG entropy This pains me if they're using an LCG for any crypto functions.... &gt; Added support for SHA-256 and SHA-512 to php's crypt. YAY :D (although I never use crypt) 
Most people complain for very stupid things. PHP is just a language (which i love) but if it does the job, then WHO THE **** CARES? The reason why Facebook hasn't rewritten their system (which is like 80% php or so (based on some interviews i've read)) is because it does the job! 
You nailed it so perfectly!
not only because it does the job, but also because their codebase is already too big to rewrite. you know joel spolskys saying: don't rewrite an application from scratch *ever*. a rewrite would take months - if not years - while they couldn't implement any new features. also, their programmers are php programmers - they'd have to re-train many of them. the question is: would they choose php again if they could rewrite fb from scratch?
What is wrong with Doctrine? I don't know how to link to the pages within this slideshow: http://www.slideshare.net/jwage/doctrine-2-not-the-same-old-php-orm but check out page 46, 56 (note how it returns a User object), page 57 shows something similar to what you are doing, 80 shows how you map an object to a table. Also take a look at: http://www.doctrine-project.org/documentation/manual/1_2/en/working-with-models#dealing-with-relations:updating-related-records http://www.doctrine-project.org/documentation/manual/1_2/en/dql-doctrine-query-language#magic-finders Hope that gives you some ideas of what we are currently using. Your project looks very promising :) but if you want people to pick it up you need to provide something better than the above (which shouldn't be that hard to do)
No, that's not a good analogy. Here's a better one: Class inheritance is training wheels for procedural programmers who are learning object oriented programming. In general, I think that class inheritance tends to make code less object oriented. Objects offer a level of indirection - Class inheritance does the opposite.
A couple of notes: Kore_Object::find('School') That's a bit verbose to my taste. Why not: kore_find('School') Much more elegant, imho. And what's the purpose of `execute` at the end? Make the object implement [`iterator`](http://www.php.net/~helly/php/ext/spl/interfaceIterator.html) and implicitly call `execute` on first use. This would give you something like this: $schools = kore_find('School')-&gt;where('%f = %s', 'school_name', 'PHP University'); I *do* like your `sprintf`-like syntax. I don't really think the method chaining adds to readability in this case: $user-&gt;set('school', $schools-&gt;first())-&gt;set('first_name', 'Mark')-&gt;save(); I would prefer `set` to return the second argument (value). Then there's the `save` method on `$user`, which means that you're implementing an active record pattern. I strongly prefer a gateway/entity design over this. Eg.: $user = kore('User')-&gt;create(); $schools = kore_find('School')-&gt;where('%f = %s', 'school_name', 'PHP University'); $user-&gt;set('school', $schools-&gt;first()); $user-&gt;set('first_name', 'Mark'); kore('User')-&gt;save($user); This keep side effects and state separate, which is generally a very good thing.
So you're cloning [Doctrine](http://www.doctrine-project.org/)?
Aw, c'mon! We're talking naming conventions here... *Naming conventions...* I mean, htmlentities() vs html\_entity\_decode(), wtf is up with that? You might create value with PHP, AND get a paycheck, but nothing's more important than naming conventions... nothing! Except for needle/haystack... Whoa, don't get me started... (disclaimer: Also a pro-PHP entrepreneur)
I've looked at Doctrine quite a few times and never really "got" it. It looks a lot like Kore!!11!! /sarc I guess in my continual search and study, I just never realized that Doctrine could fit what i wanted to do. Thanks, I'll look into it more. 
You'll be able to figure it out a lot quicker now that you have written an ORM yourself.
Yeah it is pretty verbose. I am using the Pear/Zend naming convention for classes and that can get hairy if you nest a lot of folders. Kore_Object methods are basic utility methods and return instances of other objects. So Kore_Object::find() retruns an instance of Kore_Object_Mapper. In this example, Kore_Object_Mapper calls methods from Kore_Database_Query_Type_Mysql (where(), field(), value(), limit(), etc). The execute() method is a member of Mapper. It sounds like a lot, but it isnt. It could be done as $user = new User(); $mapper = new Kore_Object_Mapper($user); $mapper-&gt;where(); $userS = $mapper-&gt;execute(); Its funny that you mention active record because when I first started this thing I wanted it to be a domain model and I was trying to design for it (I didnt like all of the extra work of creating mappers for each object). I believe that with minor modifications Kore could be used as such. The save method is just a wrapper for Kore_Object_Work. You could easily do $user = new User(); //do stuff with user $work = new Kore_Object_Work($user); $work-&gt;commit(); I think that the biggest tie to active record is that "field" members for User are defined when you define the object and you cannot add fields/values beyond that structure. I do think that it is necessary to be able to go beyond that structure, and I think that I have a solution for it. Each field type is an object, in User::set() I could add a generic field type if it doesnt exist in the defined fields and those wont be used when building a query. $user-&gt;set('field_not_defined', true); $user-&gt;get('field_not_defined'); //true $user-&gt;to('query'); //query doesnt include the field_not_defined field You dont like the chaining? I thought that it made things a lot easier to understand, especially with the way javascript is done today and its popularity. I have to give credit where credit is due, and I will note it in the actual code, but I copied my querying syntax from a [V8CGI module](http://code.google.com/p/v8cgi/wiki/API_Query) pretty much line for line. Thanks for you input
Yeah, I guess...
I have used several php frameworks. Codeigniter is by far my favorite. You can check out my review of [Codeigniter](http://www.montanaprogrammer.com/php-web-programming/the-best-php-framework/). The best thing that I like about Codeigniter is the incredible documentation.
I prefer X, you prefer Y, and someone else prefers Z. Is there an XYZ? Ah, well. We hackers work with what we're given, I suppose.
Based on most of the advice already commented here, my personal, humble, probably-sucky recommendation is to host the project on Google Code and use HG for source control if that's feasible for you, and SVN if it's not. Most people I know never use SVN directly on Google Code anyways. They use git-svn and similar things. However, I don't know most people... I'd also recommend using Ohloh along side Google Code to provoke interest in your project, find new developers, testers, and users, and it's also good for an overview of who's on your project, who's doing how much work, which programming languages everyone uses, how much your project is worth, etc. Wow, that was a keyboard full. I'll keep reading the comments to see if any of your plans change, but whatever you decide, please provide a clear notice to all of us here so that we can hop on the wagon and just get going :D
Gee, I suppose C isn't efficient just because some compiler does a shoddy job. The runtime is not part of the language.
'zactly. "How fast can I .. Oh, I'm done! Ok, let's code!"
If you want to avoid concatenation, you can do this: `echo "My name is {$name}!";` It's easier for newbies, and it stands out, and it has advantages over just putting `$name` inside a double-quoted string. You can access arrays or objects. e.g. `{$person-&gt;name[0]}`
Why is it harder to do in .NET? Should be the exact same code.
While I enjoy working in PHP because it just feels less restrictive, I still think ASP.NET is a great platform. The best feature of the .NET Framework, in my opinion, is its consistency. PHP probably has more documentation, but in .NET I am less likely to *need* documentation. Everything is consistently named, I never have to double check which order to place arguments, and Visual Studio makes writing code and re-factoring dead easy.
 &lt;h2&gt;Cache expired. Get Tags from DB!&lt;/h2&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt; Fail?
Looks interesting, I'm on the lookout for a simple framework to use in upcoming projects, might give this a try. Seems well designed.
Too bad about those inline adverts. If it wasn't for them, I might give it a try. There's something about a project that doesn't have enough confidence in itself that it will try and make a few cents off the back of accidental clicks that makes me wonder about the mindset of the developers. I think I'll wait a few months and see if I ever hear about this framework again. But hopefully by then I'll have moved on from PHP entirely. :)
&gt; You dont like the chaining? I thought that it made things a lot easier to understand, especially with the way javascript is done today and its popularity. Chaining can improve readability, but it depends on the context. I specifically don't like it used for setters - I would expect a setter to return the *value*. A setter method fulfills the same role as an assignment. Eg.: $a['x'] = 42; and: $a-&gt;set('x', 42); Have similar semantics. The first variation will return 42 and thus I would expect the same for the second.
Lots of MVC frameworks claim to be very light and very fast, but that tends to be before the applications actually get around to any functionality.
[Framework benchmarks are ridiculous](http://blog.astrumfutura.com/archives/421-PHP-Framework-Benchmarks-Entertaining-But-Ultimately-Useless.html).
Agreed, if I didn't already have my own in-house framework this would definitely be worth using. Seems WAY easier to use then some of the other frameworks out there (you know which one I'm thinking of). I was especially pleased with the GD and RESTful libraries. Looks like the license doesn't prevent me from using them outside of the framework (as long as you keep the copyright in the file), so I think I'll use those elsewhere.
The very fastest framework is the lack of a framework; it's a plain php file containing: echo 'hello';
i would have thought postgresql should be the preferred contender to mysql. anyone have any experience-gained-insight into mariadb that it may be a better solution than postgres?
Or an html file.
I still like nginx better
It's a fork of MySQL, and as such, there is already an awful lot of experience in using it. It is more a question of where it is heading next.
Postgresql is no doubt good in terms of features but in-terms of replication it is not very good. MariaDB is a drop-in replacement of mysql so has all the features of mysql already hence is stable. I have tried it on production db and it exactly behaves like mysql the only thing is I haven't tried the Maria Storage Engine.
Even if they can't collect together $5/month for a decent php web host, there are a lot free services available for open source software projects, with sourceforge being notable.
interesting idea, horrible name
And the cheapest housing is living outside under a bridge! You get none of the fancy benefits of things like, plumbing, electrical, heating, cooling, insulation, general protection from the elements, etc however, but, it's the cheapest!
Not to mention Postgres doesn't have phpMyAdmin, which should still work fine with mariaDB
Have you tried [phpPgAdmin](http://phppgadmin.sourceforge.net/)?
A flash nav makes me skeptical that they know what they're doing.
CUMP: ubuntu fanboy detected. Come on, Ubuntu as the server? Its just a puny clone of Debian with few closed-source services from Canonical. Debian has in server field everything that Ubuntu has plus one additional thing: stability. And mariaDB still has its own share of problems. Not production ready.
Not a good idea.
Not to take away from your point about sourceforge, but if you think there's such a thing as decent php hosting for $5/month that supports anything that gets significant traffic, you're sort of nuts. 
Hate to say it but I liked everything I read, then saw the "web 2.0" graphic and immediately wondered if this was a joke / parody site that just wasn't all that funny.
Putting aside the fact that I disagree with every component of that stack for a LAMP-killer candidate, the English is simply atrocious.
Agreed. Most servers won't even hit that theoretical maximum serve rate. And they never benchmark real-world usage. 
We run most of our stack of learning tools on Ubuntu servers, including a moodle install and several custom built apps. I think the only thing not running Ubuntu right now is the file server, but that was purchased as a device from a vendor. Our campus population is approximately 45,000 and we serve 71% of those people daily for course related work.
Form fields don't re-populate when there are errors, which is probably the first thing a form library should do. Not having the option of inline errors is also a bummer. Same for forcing the table layout, there doesn't appear to be a way to iterate through fields so you can present in a custom template. Where are custom validations? How do I populate a form with data for when the user is editing an existing object? Etc etc. Better than nothing I suppose, but it seems very very basic and wouldn't save much time.
I like the idea. I took a look at the code and have a suggestion You should try to componentize (is that a word) some of what happens behind the scenes. For instance, you have a huge switch statement to draw out the different form types. You could simply have them as their own objects that extend your master ContacularForm class -- class ContacularFormSimple extends ContacularForm -- I only suggest this so that when you get a userbase and they'd like to add diffrent types or validations or whatever, your codebase is setup to allow for it. 
FYI Ubuntu Server is as stable as Debian. More over if you want paid support its also available through cannonical. Its not about fanboyism, I have administered CentOS, Fedora, Suse and Debian servers and trust me Ubuntu causes the least pain out of all these because of APT and the huge community backing. And MariaDB can be used on production.
&gt; $code .= "&lt;td&gt;&lt;label for=\"".$field['name']."\"&gt;".$field['label'].$this-&gt;seperator." &lt;/label&gt;&lt;/td&gt;"; I'm new to php, i was looking through your code and wondering why concatenate the string rather than just put the variable inside. &gt;$code .= "&lt;td&gt;&lt;label for=' {$field['name']} '&gt; {$field['label']} {$this-&gt;seperator}&lt;/label&gt;&lt;/td&gt;"; 
I think the "powered by conactular" is a little over the top for a contact form. I'd let people either use it without the nag prompt by default, or make them buy it for five bucks.
It may well be faster, additionally I'd suggest: &gt;$code .= '&lt;td&gt;&lt;label for="'.$field['name'].'"&gt;'.$field['label'].$this-&gt;seperator.'&lt;/label&gt;&lt;/td&gt;'; Because then you don't need the escaped double quotes.
It needs to be faster, what with over 1000 enquires per second.
Must.. not.. belittle.. 
Making the code more modular seems like a good idea. Having extended classes that are initialised with the relevant form fields intact immediately would make added pre-set forms easier. Perhaps the same kind of change could work for the various validation methods perhaps, where the internals would instantiate a validator class of a certain type. That would certainly make it more easy to expand on. Good ideas, thanks.
Having the fields re-populate should be in there. I'll admit that is quite an oversight on my part. I've been thinking of having the function which retrieves the form have a parameter which specifies either table or CSS-based output. The population of data for when a user edits an existing object... interesting idea for a generic form system, but the focus of contact forms makes editing a non-issue. Yeap, it is very basic. I mainly built it up to save reinventing the wheel when web developers implement contact forms for clients. Since you can define custom fields, I think it fills the needs for most basic web contact form. Thanks for the ideas and opinions. Much appreciated.
haha, so you don't like it, fair enough. Please bear in mind, it is not supposed to be anything complex, new or amazing. The idea is just a simple way to chuck a contact form, with built-in validation, into a website with little effort and without reinventing the metaphorical wheel for each implementation.
That is mainly just a way to build links, self-promotion etc. However... I deliberately made it very easy to turn off with a single function call ($form-&gt;setAttribution(false)) which removes the message and the link.
I've come from the likes of C, C++ and Java mainly and I think the preference to concatenate is just a habit for me. Anyone know if there are any advantages to one method or the other?
There are none, don't listen to anyone who tells you there are. There have been countless benchmarks done to show that there's no noticeable speed gain.
The benchmarks don't show such a speed improvement, even at large sizes.
You mean, "reinventing the proverbial wheel". And, yes, for what it does, I suppose it does well (without actually using it - I checked out the source-code).
Somewhat ironically benchmarks have shown strings using double quotes are faster than those using single quotes - despite double quoted strings being parsed for variables. I really wouldn't worry about low-level optimisations like that.
Ah that makes sense, nice job making it easy to turn off.
&gt; I've been thinking of having the function which retrieves the form have a parameter which specifies either table or CSS-based output. Any plans for a fully customizable form template? I'd rather have an open-ended frontend component and a more structured backend framework to handle everything else than an all-in-one solution that restricts my options on layout and display.
A templating system sounds like a great idea. It would require a bit of reworking, but that would definitely make the system more flexible. It would also further separate the back-end from the front end which should certainly be done. Thanks for your feedback. Very useful. I'll see how I can add this in a future release.
They also needed a vowel.
Exactly.
Upvoted for Larry Ullman's books. I got the basic PHP book a while ago and never ended up reading it (had to learn too quick to read so just starting doing and learning by doing) but I picked it up last and flew through and while I ended up learning many of the concepts along the way, it's still teaching me a few things I missed and it's very well written and easy to follow along.
Why I hate the idea of active record: I was a programmer when there were a million ways of accessing a database. You could use x-base languages, or the proprietary MS weirdness for merging access and Visual Basic, or a million other things. Then along came SQL and you only needed to learn one language to access a database. Everyone was doing the same thing. Now, everyone is creating some form of DB abstraction that means you have to learn a thousand different sets of syntax to access a DB. If we can all agree on one specific active record, and it always returns data the same way for everything, then great, but then people will (almost without question) figure out ways to use that as a security hole, and then in ten years we will see arguments about this or that stupid framework that abstracts active record.
Its not "they" its "he". :) But its not just the vowel in Ubuntu that makes it gr8 in-fact OpenSuSE also has a Vowel so does OpenSolaris. 
I agree that there needs to be a standardization of active record implementations. 
Here's some advice I haven't seen mentioned yet. Whichever resource you use to learn, actually do the examples/tutorials. Don't just copy/paste or read them, actually type them out character by character. For bonus points, say the statements out loud and try to comprehend what you're telling the computer to do. It may seem tedious but will get you from nill to competence faster. Part of it is muscle memory, part of it involves debugging (especially because you'll likely make typos and have to go through your scripts to figure out what's going on/not going on) and part of it is comprehension instead of just seeing. 
More like a sub-reddit for your blog :P Interesting stuff though.
&gt; More like a sub-reddit for your blog :P This is a good point: Why can't PHP developers interested in Python and possibly Django take a look at r/django?
I do remember you posting about your new blog somewhere at r/php or on the web dunno. Also, even if your blog is indeed interesting, I doubt that this is the best way to promote it.
Go promote yourself somewhere else.
It's the reason the blog was created, because I have yet to find a lot of information for PHP developers moving to Python and Django. I don't make a cent on the blog, so its a shameless plug :P Just trying to help people.
Hey I bookmarked it, it's a good read for me since that is exactly what I am thinking about doing. Keep it up. :)
You sure you didn't accidentally do something inefficiently when creating it as OO? It's easy to get into a trap where, for instance, you make too many calls to a database when using OO. You want everything to be nice and reusable, but if each class is too general or poorly formed in how multiple classes relate to one another, they'll keep calling one another and slow the product. You either need to be ok with the extra time it takes, or create classes or subfunctions that are more specific (which usually means less code reuse). Of course, as you point out, PHP isn't exactly the best language for a blazing fast product. But still, related to the procedural code you upgraded from, it should be doable to get a similar execution time. Also, depending on how often it's run, 1.5x the old run time may just be an acceptable cost for easier code maintainability.
From the information you've given, it *does* sound like you over-engineered. You said it yourself: &gt; ... the whole works. It was beautiful. Its easy to say as the creator that you haven't over-engineered, and its a common pitfall experienced by all developers--rockstar or not. Beautiful code is not necessarily functional code as you've found and it all comes down to common sense. If you don't need it, don't develop it. If you don't need to make it an object: don't. Use the right tool for the job and make it as simple as possible, but no simpler.
&gt; You sure you didn't accidentally do something inefficiently when creating it as OO? I am pretty sure; my optimisations were things like instead of this: `for(...) { $dist = $this-&gt;calc_distance($p1,$p2); }` I did this: `for(...) { $dist = (actual distance calculation here); }` and instead of `$p1` being an instance of my `Point` object, I said something like `$p1 = array($p1-&gt;get_x(),$p1-&gt;get_y());` before the start of the loop, so that inside the loop I was just dealing with a simple array instead of my Point object. &gt; 1.5x the old run time may just be an acceptable cost for easier code maintainability. A very good point; most of the time you're mucking about with some html and your loops have &lt;50 iterations at most. In this particular case I'd ideally want up to a few hundred thousand iterations, and to run it as a web service, so a processing time of one second for twenty thousand iterations isn't too great. But in general I completely agree that a small performance hit is often worth the code-readability.
Did you do any profiling, by chance?
yeah, that is possible. Like I said I don't *feel* like it's over-engineered, but then I'm struggling to think of anything else I could put into an object. If there's nothing left to OOP-ise, that's often a sign you've gone too far...
I'm currently working on a Lisp-&gt;PHP compiler written in PHP (just got macros working, woo!). It uses objects heavily for pretty much everything, from the lexer and parser to the node tree, as well as some 'support' classes. Inheritance is very important, although I rarely seem to stick to access rules and just make most attributes public, with the assumption that outside access is read-only. The rewrite with Zend Engine 2 should have hopefully improved performance for OO features, although magic methods are still known to be slow. I noticed some of your optimisations were meant to reduce the overhead of calling an object's method. Have you tried comparing a procedural function with directly inserting the code (unless that's what you did)? Also, I've purposefully avoided copying PHP's object system in my project mentioned before. I might just implement a system where the code resembles OO-style but it all compiles down to non-OO code.
Not really, I just slapped `$start=microtime(true); doCode(); echo "ran in ".(microtime(true)-$start);` in a bunch of places and ripped likely-looking stuff out until it got faster :) What would you recommend?
I have been a PHP web developer for a number of years now, and on every web project I have worked on the application bottleneck has been something other than PHP. I've seen a lot of (mostly beginner) programmers worry about the speed of the PHP code, but in my experience the things that actually slow down a website are database connectivity, poor server configuration, or the limitations of the data center. I have however, seen website go down because of messy, hard to maintain, procedural code. I'm sure there are sites where PHP is the bottleneck AND the site gets enough traffic for that to be a problem, however those sites are the exception rather than the rule. A couple of quick suggestions for optimization: - If you aren't yet using a PHP accelerator such as APC, any other PHP optimization is probably a waste of time - Consider using Nginx + FPM instead of Apache for the server - Look into using something like http://framework.zend.com/manual/en/zend.cache.html for Caching 
&gt; Have you tried comparing a procedural function with directly inserting the code you mean comparing `function foo() { echo 1+2; }` `foo();` with `echo 1+2;` ? &gt; I might just implement a system where the code resembles OO-style but it all compiles down to non-OO code. neat idea!
Yep, that's what I meant, just to compare the overhead for method calls and regular function calls.
No I haven't tried that, I imagine we're talking 0.00x time differences there though. Still will be interesting to see, I'll write something tonight.
I agree in the general case that it's the DB that will slow your app down most of the time. In this case there's nothing but pure out-of-the-box PHP. I'll look into APC and those other links, thanks.
I use [Xdebug](http://xdebug.org/) and view the output in [KCachegrind](http://kcachegrind.sourceforge.net/html/Home.html). (Well, sometimes. Sometimes I just do `time php foo.php`. But it can be really enlightening to get that nice graphical view.)
I use OO with PHP only when it seems to fit. Usually procedural fits better (with anonymous functions). For me PHP is glue. It's not a language to write huge class libraries. If you need those, write it as an extension (e.g. PDO).
I use OOP almost exclusively, but I also use a lot of caching and other performance enhancing techniques. Don't try to guess your bottleneck. Install xdebug, profile your code, and see what it is that's causing the issue. You'd be surprised how often something like a function accidentally left inside a loop or something will be the source of your issues.
in general I agree, but this code really was small enough to guess; the method in question is about 50 lines, the inner loop (being run 40,000 times) is only 10 lines.
I'd recommend the first thing to do may be to take out any unnecessary ArrayObject or Iterator-implementing objects and bring them down to a more primitive array datatype. PHP screams with arrays and has fanatical utility--a great point to start optimizing. Furthermore, if you're calling object methods with the likes of call_user_func() or call_user_func_array(), you may want to address those pretty soon as well as they happen to be pretty slow functions to call.
Adding to this, you can go to route of SPL and prototype the functionality in PHP and then once you are satisfied with the interface you've developed, move it into an extension. 
thanks for the tip. The objects I had didn't implement any built-in interfaces though. The data-store objects simply contained arrays.
I still think profiling would be useful as the performance issue may be completely unexpected. I've got dozens of examples, but here's my favorite- I was working on a [javascript minifier](http://code.google.com/p/jshrink-/) written in PHP. When I ran it through normally performance was okay, but for some reason larger files had a ridiculous slow down. I figured it wasn't a big deal, put it behind some caching so we wouldn't have to minify each time, and thought that would take care of it. It didn't. Even though I had completely bypassed the minifier and was basically just outputting a (rather large) text file the performance was hideous. So I profiled. I won't lie, the results shocked me. Turns out the bottleneck was "echo". Yes, that's right, "echo". Apparently there is a [known bug](http://wonko.com/post/seeing_poor_performance_using_phps_echo_statement_heres_why) with php where large outputs will slow things down. This has to do with the use of Nagles Algorithm and the way it buffers output. The solution was simple- break the string up into smaller bits and echo those individually- but I certainly never would have figured it out without profiling.
If you're in a Windows dev environment, [WinCacheGrind](http://sourceforge.net/projects/wincachegrind/) is invaluable. But to reinforce brennen and others are saying, you can't slap in microtime() and assume something is your holdup in your code. It may or may not, the only way to know for sure is to do a few runs with profiling turned on and examine the profiling output. Sometimes you'll be surprised in what is bogging down your app.
We use OO for everything. The cost in terms of raw CPU speed is more than made up for by the improved code design and increased maintainability we've realized through OO. &gt; do you just wrap essentially procedural code in a class and call it OO? We try not to. It happens, though, especially if something needs to be complete and out the door yesterday.
&gt; my optimisations were things like instead of this: &gt; for(...) { $dist = $this-&gt;calc_distance($p1,$p2); } &gt; I did this: &gt; for(...) { $dist = (actual distance calculation here); } That should *really* not make a difference. If it does I'm assuming it's a complex calculation and simply compiling it may be taking longer. If that's the case, you can precompile your PHP to make it faster. I've never seen precompiling make a huge difference before (1.5s to 1s is a 33% drop, which is significant), but that may help. It's usually for if a site gets a boatload of hits to reduce server load. &gt; and instead of $p1 being an instance of my Point object, I said something like &gt; $p1 = array($p1-&gt;get_x(),$p1-&gt;get_y()); &gt; before the start of the loop, so that inside the loop I was just dealing with a simple array instead of my Point object. What's your point object like? The difference between storing and array and an object should be minimal. If your object has to run a lot of functions in order to construct, that may account for a little added time, but if it's just accessors/modifiers, those are pretty lean. You could try setting the object variables directly in the constructor instead of through a modifier and see if that helps at all. I think the big thing here is you're doing it so many times. Usually when you do OO your'e grabbing a variety of objects and pulling them all together. If you're calling the same object a hundred thousand times, I can see how doing it procedurally would be faster. EDIT: Forget the compiling thing... you said you tested the timing with microtime. That's post-compile.
How do you realize improved maintainability and code design? Is it just a gut feeling? Or have you just become better? Hard to tell, I guess. I might prototype API with OO approach, and when it's done, I usually try to implement it procedurally. I'm always surprised how much cleaner the procedural implementation is (in terms of code lines, efficiency and readability). Also, PHP has a data structure called array, and whole bunch of inbuilt functions to work with them (i.e. I see no reason to model data as classes). I think that from maintainability side, it's more of a story of discipline than actual way of writing the code. Heck, Linux kernel is mostly written in procedural C, and it seems to be maintainable (and I bet it is a bigger project than anything written in PHP).
&gt; How do you realize improved maintainability and code design? Is it just a gut feeling? Or have you just become better? Good question. I guess it's mostly a gut feeling. We haven't done a big procedural-vs-OO test here. However, every time I get to re-use an existing fully-functional object (through actual re-use or better yet through extension) I feel like I've saved tons of time and effort. We do have some procedural code here, and whenever I try to modify it I find myself having to re-learn the whole script. It might be that I'm comparing bad procedural code with better OO code, though.
Here's a fun one. Did you know that the longer the function name, the more time the script requires to run? Not just compile-time, run-time too. I just ran a quick test timing a really simple function (return $arg * 3) named Boobs vs the same function named Booooooooooooooooooooooooooooobs and found that the former required 25% less time to run (over 1000000 iterations). I think this demonstrates that it may be worthwhile to compile up an extension that adds your time-critical functions to PHP, 'cause it may not be possible to get past some of PHP's inherent speed limitations.
It's reassuring to know that I'm not the only one out there that uses words like 'Boobs' for testing. Another popular one I use is Poop.
Great! And there is nothing bad in gut feelings. That is what you usually use when you have a lot's of information and choices. That said, if you can make decision basing on gut feeling, you are usually on a safe ground (at least you have already plan b).
... heh. On our shared devel server: -bash-2.05b$ echo /tmp/poo* /tmp/poo /tmp/pooo /tmp/poooooo /tmp/poooooop /tmp/poooper /tmp/poop /tmp/poop.out.out /tmp/poop.php /tmp/poop9 all mine.
0% ... I'm bad.
I'd like to add that if anyone has tried xdebug and didn't like it try out xhprof http://mirror.facebook.net/facebook/xhprof/doc.html
My oh my sir, that is a lot of poop. On a more somber note: &gt; I've been fired from a marketing firm for forgetting to remove my test word 'Poopy' from a Fortune500 company's web-site (running on WebLogic, yikes). No one knew the word was there for like a week since 'Poopy' was not an actual product it only showed up in their glossary. A week later I told my boss after releasing the next update and removing the test word: she flipped out, told the client, and fired me that following Monday because word got around their (the client's) IT department resulting in someone digging up a cached copy of their web-site's glossary and passing it on to someone higher up the corporate ladder. I'm an idiot for using such a vulgar test word but I had no business working there (in a marketing firm), let alone no business editing 14,000-20,000 lines of XML. (seriously, there were about 3-4 XML files that long) In retrospect though, I'm glad it happened because now (then) I finally had a reason to learn Mercurial (or why version-control is important and how branching could have saved my ass) :P
I use "anus" and "caca" (poop in French).
This looks pretty good, I'll certainly have to check it out.
If you aren't using a PHP accelerator, that should be your #1 priority -- they can increase performance by 2-10 times with no downside.
One other note on optimization: If you optimize your code so that it can output a page 1,000 times a second, but your webhost's bandwidth maxes out at 100 requests per second you won't gain any real world performance benefits.
Or Apache/IIS for Windows; nginx isn't really mature for windows and builds for LigHTTPd/Cherokee are non-existant. Apache requires a lot of tweaking to get some decent performance, but it's not difficult to get it to perform with the best of them. (citation needed :))
I really don't think this matters. Did you know single quotes are faster than double quotes? These are negligible optimizations. I'll take a 30 character function name over a two character one if it's labelled better with the 30chr one.
I've used [Owl Intrantet](http://owl.anytimecomm.com/) with reasonable success. However, freezing up on large files is something you may need to [tweak php.ini for](http://www.radinks.com/upload/config.php) now matter what you use. 
Totally right, I'm with you on that. I'm just demonstrating the futility of trying to over-optimize PHP code. The language is not built for it.
http://code.google.com/p/jshrink-/downloads/list Howto download? :(
I use it where it makes sense. Some places OO make sense, some places procedural. All-in-all, I follow MVC style.
If you are writing applications or frameworks, and re-usable code, use OOP. If you are writing speed efficient scripts, throwaway scripts, backup scripts, etc, write procedural scripts. Same applies to architecture - if you want scalability and the ability to deal with masses of requests, tailor a custom architecture solution (nginx proxies, cassandra dbs, etc) to the problem. If you want a forum for your buddies, a merry LAMP set-up should suffice. PHP also sounds like a terrible solution for what you're doing - PHP is designed to run scripts that handle little data and return requests very quickly, or batch scripts. Data processing is never a great idea.
IIRC, with the single quotes thing, they're only faster if you have $vars inside them. Worst: `"Word: $blah\n";` Faster: `'Word: '.$blah.' ';` Fastest: `"Word: ".$blah."\n";` That said, generally I try and use `sprintf( "Word: %s\n", $blah );` I don't mind if it is fastest but it is a damn sight more organised. We can agree that good app design &gt; silly optimisations.
abcdefghijklmnopqrstuvwxyz();: 10000000 iterations took 27.73s at 360600.306/s abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz();: 10000000 iterations took 29.72s at 336516.638/s Sure, it's "faster"... but not enough to care, unless you're to Google level optimizations. http://github.com/gms8994/benchmark/blob/master/php/function_name_length.php 
Just grab the file listed there? It's just a php class, not a full minification suite- for that you may want to try something like [Minify](http://code.google.com/p/minify/).
No. This is just a stupid attempt to justify misuse of a common phrase. Nobody means it that way. It's as dumb as "for all intensive purposes", "second that emotion", etc... they're bastardizations of phrases someone heard incorrectly and started repeating incorrectly.. they're not "thought out variations" on the phrase...
again: nobody MEANS it that way.. it's not about the "Rule" you learned on reddit.. it's a commonly misused idiom.. Finding a way to justify that it's semantically "logical" doesn't make it any less of that.
$arr[] = 'foo'; should work fine...Can we see all of your code in it's entirety? Chances are what's wrong is not really on that line, but it's borking there. Look for an extra paren, squiggly bracket or stray quote/double quote if not edit: make sure to c/p it exactly if you do post it, don't cleaning anything up (besides sensitive info) 
The issue turns out to be that much earlier in the code, there was a multi-line echo using the [here document syntax](http://www.php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc), and the here document terminator had some whitespace preceding it to line it up with the start of the here document. So the code was: echo &lt;&lt;&lt;END Blah END; and should have been: echo &lt;&lt;&lt;END Blah END; That was on line 137 and the initial parse error doesn't occur until 188 inside a function call, which I found odd. I only discovered the error when using the Unfuddle repository browser for the code, and its syntax highlighter showed the error right away. So, anyone know who's maintaining Emacs' php-mode or knows enough elisp to modify it to account for here document syntax? Also, my co-worker will be getting an earful tomorrow morning about indenting that line (thanks svn blame).
When it gets to be something ridiculous like this, I tend to just rewrite the offending lines. No need to refactor or anything like that, just literally rewrite it. 9 times out of 10 it's something stupid that I did inadvertently and when I retype it I don't make the same mistake again.
Looks like the heredoc situation with php-mode is noted as early as [2003](http://forums.devnetwork.net/viewtopic.php?f=1&amp;t=9095&amp;start=0&amp;st=0&amp;sk=t&amp;sd=a). I see no major advantage to them and I want the code to migrate away from inline echos anyway (sarcastic hooray for PHP4 legacy code!), so hopefully I can pull all those out to avoid being bitten by that error. Also, would it be worth asking the PHP core team to have the parser "guess" and throw a warning if it thinks you're trying to end a heredoc but have whitespace preceding it? The eventual error thrown and the cause relate in no way and it doesn't seem like catching this error should be on the syntax highlighting capabilities of one's editor.
Yeah, that's my MO for most syntax errors that aren't immediately obvious. Sadly, not the case here.
PHP has what, now? Jokes aside, my company has dozens of sites run on PHP and only one has two places using subclasses as a poor man's closure, but other Han that, no.
There's an [interesting writeup somewhere on the internet](http://blog.libssh2.org/index.php?/archives/28-How-long-is-a-piece-of-string.html) in regards to, yes, whether or not there is a $var inside it. And I totally agree. &lt;3 sprintf :)
Am I the only one who thinks the Singleton pattern for a database class is a terrible idea? Factory please.
Cookies sent over HTTPS only would seem like something that would be difficult to replay.
I think the issue here is the overhead of function calls. Like instead of using accessor functions to get the coordinates of the point, if you made them public and used them directly($p1-&gt;x, $p1-&gt;y) it would be as fast as the array. Or, calc_distance($p1,$p2) would be just as slow as $this-&gt;calc_distance($p1,$p2). $this-&gt;calc_distance**s**($p1,$p2) would be fast if $p1 and $p2 are arrays of points and the function returns an array. 
I don't write a whole lot of php, but when I do my general rule is to write as little of it as possible. That means anything expensive will become a php extension. OO-wise, I don't use it beyond stashing code in classes to prevent namespace collision. If you really want to go with the whole "let's run a wonderful cathedral of PHP code on every single request to my server" approach, you should probably look into facebook php compilation thingy. they call it hiphop I think. 
If only the crappy program would not crash all the time! Have a look at webgrind if you're on windows. http://code.google.com/p/webgrind/
&gt; I'm not saying he intended to write this, I'm saying that it doesn't matter and that rather than spitting up something contrived as a concrete we should attempt intelligent (even if its creative or unusual) consideration. You've said nothing new and missed the point entirely, but thanks for the delayed and unnecessary contribution and downvotes. If it's any consolation, yes I knew/know the point you're making, of course. 
I think that might just complicate matters further. I don't really think it's the parser's job to guess that the programmer made a particular syntactical mistake. It should just fail, and leave it to the person to figure out exactly why it failed. In the future, if you have seemingly weird syntax errors, read *syntax error on line X* as: *syntax error somewhere between 0 and X*. You can pinpoint the exact location by removing/commenting out backwards from the reported position.
Function calls are quite expensive in php.
For a number crunching task like that, it might make sense to write the code procedurally, for performance reasons. In the general case though, I wouldn't really consider the performance cost. You need to have thousands upon thousands of objects/function calls before it makes sense to optimise them away. What are you doing this in php for anyway?
Why would you have 20 instances of your base class just because you're going to extend it? That makes no sense. It sounds to me like you want to implement some form of runtime polymorphism. If this is indeed what you want, you may want to have a look at [class_alias](http://www.php.net/manual/en/function.class-alias.php) and [create_function](http://www.php.net/manual/en/function.create-function.php) to help you on your way. However, this can get really messy and hard to debug and I would not recommend it unless you have a very very good reason not to define your classes in code. edit: I'm not trying to insult you, but are you sure you're not confusing "extending" with simply instantiating? Can you elaborate in what way your (possibly) extended classes differ from your base class?
`class_alias` seems to be the closest solution to what I'm looking for. Thank you very much.
&gt; What are you doing this in php for anyway? you are very correct; it's not really something that should be done in PHP (any recommendations for fast languages that interface well with PHP?) I think the overall feeling from this thread is that for what PHP is designed for (i.e. spitting out webpages from a database) its version of OO works very nicely. and for tasks like mine, PHP's not really the right language.
&gt; the whole "let's run a wonderful cathedral of PHP code on every single request to my server" approach yeah, this example is not designed as a web page templating object or something that's going to be running on every single request, it's a specific set of functions designed as a web service for people who know exactly what they're asking for, and who will expect it to take longer than usual.
&gt; For me PHP is glue. I agree, I want to move more towards this approach.
I like to mix up standard goto temp variable names with penis, cunt, tits and such, which usually results in things like *fooballs*, *temptits*, *icunt*, *filenamepenistits*, etc. It's a bad habit. Thank fuck none of my debug code has ever made it into production (...that I know of).
I came here fully expecting: T_PAAMAYIM_NEKUDOTAYIM
The links seem to be dead/wrong.
Encoding errors in your local file? Is it copied literally to the prod system? Are you using same versions of PHP (prod and local)?
Wow, that's a lot of code for a neural network. I have used (and written) [this alternative network](http://tremani.nl/open-source/neural-network/) - just one class, in one file. No nice GUI web interface, but I felt that wasn't really necessary at the time. I would say it is probably not necessary now, but it depends on your needs. If I can offer any advice: do the training in a 'native' (C, C++) neural network, and convert it to a PHP network later, if possible. Training a network takes a looooong time, and PHP is quite slow...
&gt; any recommendations for fast languages that interface well with PHP? Would C do? I concur with your conclusion.
yeah I've been wanting to learn more C. I just wondered if writing a php extension in C was the most efficient way of getting faster code into your php app.
I don't understand your question. What are you trying to accomplish? Can you show an example of the current code, that you are not satisfied with?
It most certainly is. The downside of it is that you need access to compile and install on the target server and you need to know C.
thanks again for your help. I'll definitely look into this. I know a little C, so hopefully it won't be too much effort, and it would be a great skill to learn.
Seconded. celtric: Perhaps I helped you by pointing you towards *class_alias* and *create_function*, but there probably is a better solution to whatever underlying problem is causing this need (if there even is a need) for runtime polymorphism.
When I've needed to extend a base class without reinstantiating it, I use a generic wrapper object. It is far from perfect, and some of the most twisted crap PHP has to offer, imo. Here is my implementation of generic wrapper: http://pastebin.com/sLFkdRPE Unfortunately, I don't have a great example that isn't proprietary. Basically, you use it as such: class Bar extends GenericWrapper { function print() { echo "wrapped sucka"; } } class Foo { function print() { echo "foo"; } } $foo = new Foo(); $foo-&gt;print(); // "foo" $foo = new Bar($foo); $foo-&gt;print(); // "wrapped sucka" This method has drawbacks. If you are trying to change an internal method that is called by another internal method, you need to extend teh calling method in your wrapper by adding a function like this: function callerMethod($args) { return ChildClass::callerMethod($args); } This keeps scope in the wrapper. So, uhm, its hacky, it works, and makes you feel a little badass when you use it. It has come in wicked, wicked handy for me from time to time, and I hope it will for you too. 
*Edit: I had a problem sending the comment. I've written it in a more simple way.* *Edit 2: sorry, I'm messing the formatting a bit. Hopefully it's readable now :S* **Original comment:** First of all, I'd like to make clear that I've changed my code to work with `class_alias` and it's now serving my purpose. Going to the example. Let's say that I have a directory with the following structure: * config/ * config/site_a/ * config/site_a/config.php * config/site_b/ * config/site_b/config.php * lib/ * lib/class_one.php * lib/class_two.php * lib/class_three.php When someone enters domain_a.com, there's an `index.php` that loads the libraries and the `config.php` of its config directory (in this case, `site_a`). This way I can host multiple domains with only one library (and all changes to the code affect in the same way to everyone). But, imagine one particular client needs a special feature. Let's say `class_two` has a method called `get_store_name()`, but `site_a` (that is, domain_a.com) needs additional checking to get a store name. In a language like Javascript I'd do the following: class_two.prototype.get_store_name = function() { whatever needs to be done }; But what in PHP? What I've done now is to name all classes `nameOfTheClass_default`, and automatically check if a `nameOfTheClass` has been created; if it's not, then create an alias.
So you want to have a common base class and *optionally* have a local class that inherits from the base class? In your instantiation logic, you could simply check if there is a local class - If yes, instantiate that; if no, instantiate the base class.
Thank you for your reply. I'm afraid it doesn't seem to solve directly my problem (or so I think so), but it's a very interesting piece of code and implements some things I had no idea they existed.
I don't think it would be too much to ask the parser to say, if you're in the middle of a heredoc block and you come across a token that looks suspiciously like the heredoc terminator but with some whitespace preceding it, throw a warning so the programmer knows something may be fishy with the heredoc block. As opposed to what happened here, where an error manifested itself 50 lines of code later, inside a different function, complaining about perfectly legal syntax (concating a string with a value in a super-global).
It blows me away how many people don't understand this. Having performance problems because of the sheer number of daily visitors is a problem everyone would like to have. I would gladly rewrite the PHP runtime if it meant I had the traffic of facebook.
I had a problem calling `class_two::method()`, which is solved with `class_alias`.
Thanks for the suggestions. Looks like our host doesn't allow us access to php.ini Looks like I will be setting up a spare box as an in house server to do this. Thanks!
Do you need something similar to mixins in Ruby? I'd look at the Yii Framework, they do something similar, which they call behaviors. http://www.yiiframework.com/doc/guide/basics.component -&gt; Component Behavior
And what when you actually want to output something that looks quite like the terminator? You would be getting warnings then.
Would have been much less gross sounding if they went with Arch. Right now it sounds like an abbreviation for how 4chan refers to women.
So if I understand this correctly, you have a central bit of controller code in location X that loads code from location Y based on domain name, which extends the base class located in X. May I ask why simply implementing this was no good?: // Location X class foo_base { private $name; public function __construct($name='NoName') { $this-&gt;name = $name; } public function get_store_name() { return $this-&gt;name; } } // Location Y class foo extends foo_base { public function get_store_name() { // Store-specific logic if ($this-&gt;name == 'YoName') { return $this-&gt;name; } else { return 'This store is not called YoName'; } } } edit: troelskn speaks the truth: Using classes as nothing more than a bag of static methods kind of defeats the purpose of OO.
Ah .. The problem is that you're using static class methods. You should instantiate your classes into objects, and use object methods. Using `class_alias`is a hack.
Perhaps an E_PARSE then? Something non-fatal that would alert the developer to the issue and maybe re-factor it. I don't know, maybe it's not a common enough occurrence, but from the outside looking in it seems straightforward enough to put some kind of notice out that the heredoc terminator might be misplaced.
The problem is you are declaring objects directly, you should be requesting instances through a factory. For example if you write: $u = new User(); $u-&gt;GetUserByID(1); This may work for all of your current implementations, but what if one client needs different authentication logic or different data storage for user details? Alternatively, you could write: $u = UserFactory::GetInstance()-&gt;GetUserByID(1); Now, the logic is not tied to a single class called "User". The factory may decide to load a different class instead. For example, it could decide to check if a client's website folder contains a custom user class "custom/CustomUser.php". The custom user class can extend the core User class, or implement a common interface so all user classes follow the same pattern and are interchangeable. If you use reflection, it is trivial to find all declared classes that implement an interface. If you don't want to hard-code logic for overriding core classes, you could always add events on your factory class to leave it up to the application. Assuming all client websites have a custom header or something, you could do this: UserFactory::GetInstance()-&gt;AddEventListener(UserFactory::CREATING_INSTANCE, function($factory) { $factory-&gt;instance = new CustomUser(); });
Basically because I have about 20 classes and growing, and I don't want to update all the config directories everytime I add a new class with lines like `class foo extends foo_base {}` to be able to use static methods. So, right now, my code runs more or less like this (overly simplified): &lt;?php function __autoload($class) { // Load file that contains {$class}_default load_library_class($class); // Classes have their own files, they are not found inside config.php // (it would be a mess to maintain) if (a_custom_version_of_the_class_exists($class)) { load_said_class_from_the_config_directory($class); } else { class_alias("{$class}_default", $class); } } output::plain_text("hello!"); ?&gt; What are the benefits? Well, I load every class on demand in a very transparent way, I don't unnecessary resources and, more importantly, my code keeps really simple and clean (at least that's my opinion). &gt; troelskn speaks the truth: Using classes as nothing more than a bag of static methods kind of defeats the purpose of OO. In a way, yes. But how else could I accomplish that?
I'm afraid what you're writing exceeds my programming knowledge. Excuse my ignorance but, aren't you making it too complex? In [my comment below](http://www.reddit.com/r/PHP/comments/bb1mt/is_there_a_way_to_extend_an_existing_class/c0lvaex) I try to show my approach and why it works for me. I really can't tell right now if that's what I'm looking for, I'll have to study your comment a few more minutes :P
Which is why testing how fast it takes a framework to echo 'hello' is silly.
It sounds like one issue is being caused because you are trying to do: foo::method1(); But behind the scenes, "foo" is actually "foo\_default" or "foo_custom" so method1() doesn't exist. Is this right? I would avoid static methods, or at least move them to a seperate class. SiteA::method1(); If the logic doesn't change client-to-client you could create a general helper class. Helper::method1(); Should work fine assuming you don't alias or rewrite the class name at runtime.
&gt; aren't you making it too complex? Depends on your frame of reference, I would rather have code that says "Find the correct instance of X" instead of code that says "Load X" but actually loads Y. Also, it is a common pattern for achieving what it sounds like you want to do. [Factory Method Pattern](http://en.wikipedia.org/wiki/Factory_method_pattern).
Sorry, I forgot to specify that the code below does run as expected and is indeed my final (so far) solution to the problem. I could separate static methods from the "normal" ones, but so far I haven't found any problem with the `class_alias` approach so I'd prefer to keep the code as simple and clean as possible. I'm aware that I express myself pretty awfully (sorry :( ), but basically what I've been trying to achieve is a standard system that can be changed at any point depending on which domain it is running, with the fewest modifications to the code while keeping the code as simple as possible. Thank you very much for your answers ;)
Your post doesn't explain why you're using static classes as opposed to instantiating your classes and using them as objects, but I understand what you're doing now. I think it would be worth your time to rewrite your code in a more object oriented fashion and take codewarrior's suggestion of using a factory class for this purpose of instantiating objects that may or may not have a customized version. It may seem a bit of a daunting task, depending on how many individualized versions of your classes exist, but in my experience doing so would benefit your code's maintainability in the long run. ---- You said codewarrior's post went over your head a bit, so I'll try to explain what he's saying: Say you have created a "Store" class, and other classes that inherit from it. What you do then, is create a "StoreFactory" class with a static method (usually called GetInstance) that returns an instance of a "Store" class. Inside that static method you can have logic similar to what you posted above, except instead of just loading the custom or default include, you return an instance of either the custom class (Store\_sitea, Store\_siteb, etc.) or the base class (Store).
What's the difference between that and overloading my files with lots of `class Y extends X {}`? They're all the same object, but some have methods modified. I mean, it's the philosophy behind Javascript, I don't know why it looks so unnatural in PHP. &gt; Also, it is a common pattern for achieving what it sounds like you want to do. Factory Method Pattern. Thank you for that link, there's a lot for the to learn yet :(
I don't think you can fully translate that JS idiom to PHP since in JS you are modifying instances and not classes. Also, JS has no concept of autoload which does all the magic behind the scenes (that I'm aware of). My JS is not great so I may be wrong about this. There's nothing wrong with extending X as many times as you want...but normally you don't have to use aliasing techniques to actually use the child classes. Another reason I wouldn't use aliasing is because another developer may not expect that behavior (with class_alias in the autoloader). However, your solution does sound sufficient for your needs. I'm not trying to dissuade you, just suggesting another option if you need it. :)
It crashes on you? I haven't had any instability issues in Windows 7 recently.
If you're running on Apache (and I'm sure other servers have ways to do this), you can *generally* create a .htaccess file and add: php_value upload_max_filesize &lt;max file size&gt;M You may want to tweak post\_max\_size as well: php_value post_max_size &lt;upload_max_filesize * 2&gt;M Something along those lines... \* Odd markup escaping... 
this guy is a complete idiot who has no idea what hes talking about. look at some of the other code hes written http://reddit.com/r/expertprogramming
&gt; what I've been trying to achieve is a standard system that can be changed at any point depending on which domain it is running Haha that is basically what factory classes do. They provide entry points so you can swap out which classes get loaded at runtime. However, I see what you are saying about keeping the code simple. It definitely looks better to just do $s = new Store() instead of $s = StoreFactory::GetInstance()-&gt;CreateInstance(). On the other hand, I think the latter is easier to understand (IMO) and more portable since it does not rely on __autoload which may not exist in other languages and may be confusing to someone reading your code or performing bugfixes.
**Usually** no downside. I don't have the code around anymore (previous job) but APC got really confused with some classes we had and returned the wrong cached code. The solution was to check for it (APC) and bail out :( (It wouldn't surprise if this was actually Magento again, but my memory is shady) Edit: NO WAIT, IT'S ALL COMING BACK TO ME NOW! It wasn't Magento, in fact, Magento was the reason I had APC installed. It did cause problems in our internal admin though. It was highly, overly, extremely dynamic in nature, and lots and lots of things happening behind the scenes. I was doing Magento-stuff, and my machine was starting to fail when developing new features for the admin. Sleuthing here and there turned out that the autoloader was doing really weird stuff (yeah, this is where stuff get shady again), and nothing seemed to fix it (not to mention that nothing seemed to actually *cause* the problem in the first place, it just wasn't loading the correct classes). Until I disabled APC, and the admin started running like a charm again. The solution was pretty much bailing out, but more along these lines: try { $foo = new Bar(); } catch ($e) { error_log("Disable your opcode-cache."); throw $e; } Which was sufficient, because it only happened in that one place, loading that one specific class. I'm sure we could have dug deeper and figure out exactly *WHY* APC was failing so badly on loading that, but in the end it was easier to just check that specific case and get on with our lives after a line of error-logging.
I just clicked the link myself and it has a list of two files (an older version and a knew one). When I click on the files they download. I'm not sure what problems you're seeing.
Hmm. There are usually ways to override values in php.ini. In some cases you can [override them in a .htaccess file](http://www.whenpenguinsattack.com/2006/01/20/how-to-override-phpini/). In other cases you can [add a php.ini to a the /cgi-bin dir](https://support.quadrahosting.com/kb-article-120-0,3,17.html).
http://php.net/runkit_method_add Please note the big red warning box.
&gt; Also, PHP has a data structure called array, and whole bunch of inbuilt functions to work with them (i.e. I see no reason to model data as classes). I think I agree.
&gt; Whoa whoa whoa, what the fuck is that code at the end of your comment? Some sort of hybridization of PHP and Javascript? You can't pass functions like that in PHP, and JS doesn't follow that object syntax. That code wouldn't validate in either language. [Anonymous closures](http://php.net/manual/en/functions.anonymous.php) were added in PHP 5.3 function test($fn) { echo $fn(22); } // Prints 66 test(function($n) {return $n*3; });
Thank you.. I will look into this as soon as I get a chance. I am very mostly experienced with HTML and CSS.. but I am new to using PHP and such. I have installed other scripts in the past, but none required much configuration. I love learning new stuff though, I appreciate the help!
The webhost my company is using is through ATT before the yahoo mix. According to the control panel it is MS Server 03 IIS . This console provides very little features compared to others I have used. Plus i seem to have zero customer support. I have been trying to get them to let me transfer our domain to a real host. 
Ouch. I've been in that situation before. Definitely need to change hosts. Good luck. :-)
Most of PHP MVC frameworks are totally object oriented. But that doesn't mean that they have to, it's more just that people are copying Java Frameworks, Rails etc. on PHP.
Yahoo as well
&lt;3 Cake
IMO this problem has gone away with IDEs which give you the parameters
Yep, there are places where I follow that basic format, but within there, so some thing totally procedurally, which could be split out into classes. Sometimes it just doesn't make sense to go completely OO. It just never made sense to me
That even PHP can't make singleton use not annoying :D good article though. 
Ok I successfully set up an apache server running php 5.3 The interface is loading, it successfully logs into our customer ftp. every file it transfers ends up corruped. i am using PhpWebFTP I adjusted all the options given here, I've looked around in the configs, but I can't seem to find anything that could suggest causing this. Any ideas?
That was a nice demonstration of the pattern in PHP. &gt;echo $$$$a; //Outputs 'The end'; I've found variable variables to be convenient, but please shoot me if you ever catch me taking it to this level ;) 
nice.
You can't split across multiple files. You could do something which we do for optimizing files for APC, is basically what C/C++ do with header files - we have a master include file called include_master_template.php. Inside that is: /path/to/include.php /path/to/another/include.php What happens is a script, when we move to stage, physically moves all these files into that one script and replaces them, and saves that file as include_master.php - which then gets included. APC can easily opcode cache this with only one check if it's been changed. There's about 40 files. We also have a script which caches that on dev. Anyway, my point is, perhaps you can have your files split: class myclass { &lt;path/to/some/function.php&gt; public function function_in_here() { // ... } } If that makes sense, then have a script include them all in... of course its really tricky but maybe you can come up with some other idea which is a bit saner. But I think it's close to impossible, if I understood correctly what you're trying to do
CodeIgnitor/CakePHP do something like this - except they check to see - they all extend from App_Controller - and there is a default one, which extends Controller. But the autoloader checks to see if a customzied one exists, and will include that as that App_Controller instead, not including the default one. SO you could do something like: include lib/base_class check if site_a/extended_class exists, if it does, include it if above doesnt, include lib/extended_class include your class, which is "class XYZ extends extended_class" This way you can stick with statics, but substitute in the proper parent class.
I have updated my post, and as I grow as a programmer I'll probably understand why are you both correct; right now I feel I need I have to *face* the problems I encounter in order to see the importance of your methodologies.Thank you for your comment ;)
Thank you a lot for your comments. As I've written above, I'm aware that I'm probably doing it wrong but I just can't see it yet. I'm afraid I'll have to continue testing my code until one day I say "oh, NOW I see why they were correct." Fortunately, I have a lot of fun learning from my errors :)
I didn't believe this, so I compiled 5.3 and tried it out: public static function getInstance() { static $instance = null; ... Seems it works as advertised. WTF?!? This means that the static variable in the function above belongs to the called class, not the declaring class. That's seriously counter-intuitive. At least it's counter to my intuition.
Oh, and I just checked - This seems to be the behavior for older versions of php as well. That's a case for some seriously hard-to-find bugs.
Yup, this behavior has been around for along time. It doesn't need to be a class method either. A regular function can have static variables too. &lt;?php function counter() { static $count = 1; echo $count++; } counter(); //1 counter(); //2 counter(); //3 It does offer a neat way to bring state into functions. Of course, like any feature, this can be abused. I often use it to memoize a function call (though it's bound at the function/class level and not to the instance, so you have to be certain that's what you want).
I realise that. What took me by surprise was that the function-local static belongs to the *called* class, rather than the *declaring* class. That's unlike `self::$foo` which belongs to the declaring class, just like it would in Java/C++. See: http://gist.github.com/327807
*loads a couple in the chamber*
Awesome article! I cant wait to slap this into my new framework (MVC, lol) code, regardless of whether or not a singleton is needed!
I get you now. It surprised me when I discovered it too. I did write up a long paragraph but decided I was going off track. I should have kept looking because it is indeed strange behavior. I initially suspected it was because I was testing on 5.3, but I just tested and found that 5.2 gives the [same results](http://codepad.org/l1N0nkZU). In this respect a method-level static variable is acting like static::$count, but somehow manages to not use late static binding.
Is there a setting for the transfer mode? Some "clients" will have an auto option, but a lot of times, they choose the wrong one. If these are archive/image files for the most part, you would probably be safe with binary mode. I will look into PhpWebFTP later this afternoon and see if there's anything funky about it.
it doesn't have an auto, but binary is set by default. I've done a little research and it seems that the problem may lie in another service or configuration within the webserver. Other people have had a similar issue with it on some servers, and no issues after moving it to another. But I can't seem to find anywhere what is different between them to cause this problem.
Hrm, somehow from the handful of words you wrote I inferred that you were denigrating frameworks :/ In any case, I agree, echoing hello is silly as a benchmark :)
If he's willing to deploy on top of Ubuntu, replication isn't a feature he's going to be needing.
you could try [float](http://www.w3schools.com/css/pr_class_float.asp) also, this has nothing to do with PHP.
This is actually more of a [web_design](http://www.reddit.com/r/web_design/) problem. Basically, you'll need to use the CSS float property. Something like this would get both on the same line. &lt;div&gt; &lt;div style="float:left;"&gt;Title&lt;/div&gt; &lt;div style="float:right;"&gt;Icon&lt;/div&gt; &lt;div style="clear:both"&gt;&lt;/div&gt; &lt;/div&gt;
Hi, There are a few things that you can do. The first thing you might want to look up is the difference between BLOCK and INLINE elements within CSS. I did a quick google and found this, and it looks ok: http://www.webdesignfromscratch.com/html-css/css-block-and-inline.php How I might do this is to make something like this: &lt;div class="row"&gt; &lt;img src="theimage.gif" alt="the image" /&gt; &lt;h2&gt;R.I.P.&lt;/h2&gt; &lt;div class="votes"&gt;&lt;?php whatever(); ?&gt;&lt;/div&gt; &lt;/div&gt; You can then style .row img, .row h2, and .row .votes to fit with how you want. I'd probably also look into FLOAT while you're boning up on CSS. I think most importantly, you should realize that this is a CSS issue, not a PHP one.
Click through all 10 of [these little tabs](http://www.barelyfitz.com/screencast/html-training/css/positioning/) and your life will change. Also, divs have style=display:block set by default spans have style=display:inline set by default There's also always "float:right" 
Is there a list of exploit strings that I can use for testing my own code? I feel it's pretty bulletproof at this point, but I would like to test against as many known exploits as possible so I can show my boss "Codebase v 2.3 has passed x number of known url fudgifications" etc. It makes the suits happy.
I'm all for kissing suited behinds. A classic XSS Cheat Sheet is the one found at [ha.ckers.org](http://ha.ckers.org/xss.html). If you're using Google Buzz, [this](http://kristian-hermansen.blogspot.com/2010/02/google-buzz-csrf-test.html) might be fun to try! I'll update the post with the ha.ckers.org link. Thanks for the tip.
That sounds a lot like the 'PHP safe-string' encapsulation class that was floating around on the web. Except more OO...
That was pretty complicated... just use prepared statements, htmlspecialchars(), and never put user input directly into an include path (fuck you PHP devs on that one). Edit: good advice on the XSRF side of it though, too bad there isn't a better solution for that. 
Also, [here](http://shiflett.org/articles/cross-site-request-forgeries) is another very good write up on CSRF - good further reading material with respect to OP's article.
dude, you were right, omg, thank you
This guy has never heard of regular expressions.
It's not a bad idea (and in fact, a very good idea) to also test the content of the data provided: testing if your "id" in _GET is actually a numeric value is important in my mind, even if it's a little extra time taken.
`htmlspecialchars` efficiently guards against XSRF. Unfortunately, some times you need to allow some level of formatting, and that's when it gets complicated.
&gt; htmlspecialchars efficiently guards against XSRF. No it doesn't. It guards against XSS. 
Have you tried [Mollify](http://www.mollify.org/)? Seems like it would fit the bill.
Take a look at this http://schmalls.com/blog/2007/10/return-to-prototype-based-programming-in-php. It may help if you're using php 5.3
This is the best thing I've heard about php since namespaces. An excellent decision by the developers.
It will really be something if PHP is the first widespread scripting language to get built in ICU support. Neither Python, Perl, nor Ruby (nor, of course, Javascript) have it afaict, only Java does.
Well, there is always a trade-off between re-doing something "right" and backwards compatibility and the decision is never easy. 
Just get a book and do. Seriously you won't learn through a class like you would by building some stuff. It will suck and you will be terrible at it for a while. Read stuff and make stuff that is all it takes.
Seriously, PHP is probably the easiest language to learn in the history of programming languages. http://lmgtfy.com/?q=php+tutorial http://php.net
I definitely want to build some stuff. But with a class you get assignments, which will structure the practice into easy to learn chunks. For some people the structure of a class helps.
tutsplus.com has a great list of [25 resources to help you get started with PHP](http://net.tutsplus.com/articles/web-roundups/25-resources-to-get-you-started-with-php-from-scratch/). It starts with links to getting started tutorials, and works it's way up to database connections, security, OOP, and even frameworks. I keep the link handy for new hires at work using PHP for the first time. 
If curiosity and self motivation isn't enough to learn programming then it probably isn't for you. Set your own goals, fuck around until you get it, if you don't get it set it aside for a while and try try again until you do. You have to be the one who wants to learn this stuff, not some teacher who wants you to learn this stuff, otherwise why bother. Edit: many books will walk you along step by step the process and necessary components of the things you will need to know to build a web app.
This looks like it could be perfect. So easy to use.. and knowing a lot of our customers this is the key. going to download it later and see what I can do with it. Thanks!
My terseness can be my undoing.
Lukas in all reality is a project manager. Project managers should not be project managers because of their coding skills in certain languages they should be project managers because they can organize people who do have the necessary skills in the languages required. One might argue that it is better to have someone who is less knowledgeable in a language gauge how ready it is for mass consumption by people who are less knowledgeable in said language.
[tizag.com](http://tizag.com) is a really good place to start from scratch, I got my start there, follow the PHP tutorials, get the fundamentals, then find something more in depth. Also, once you learn the basics of PHP consider a framework like Zend or Codeigniter.
Not really, there is a lot of shit on the web. especially when it comes to mysql/php design. Most of it is crap
By that logic all the simple examples given in textbooks are "crap". 
PHP is easy enough that a twelve year old can create something useful with it. Hence, much of the code on the web is written by and for that level of user. There are still sites I'm sure that assure you that "select \* from users where id = ". $\_GET['id'] .";" is a best practice. Heck, I wouldn't be surprised if Joe random PHP user still set register_globals. Take the time, pick a framework (I recommend Symfony but it's by no means the only good one) and resign yourself to a slower start. 
I highly recommend the php|architect training classes, taught by respected members of the community: http://www.phparch.com/training/ In addition, their magazine is always good quality: http://www.phparch.com/magazine/2010/february/ (Full Disclosure: I have written several magazine articles and a book for php|architect, as well as spoken at a number of their awesome conferences.)
This guy wants to "learn php" and you want him to start off with a framework. I guess if he already knows other languages, sure, but since he's having to ask this I assume he doesn't. 
[Learn to program in just 3 weeks!](http://www.geek.com/articles/chips/learn-to-program-three-weeks-20100312/)
I actually don't know about other languages. Hoping to eventually work my way up to understanding frameworks.
Interesting classes. Wish I was able to pay for them, but not at this time. Hoping to bootstrap train myself until I'm able to take some classes. I'm very motivated to learn.
A framework is essentially just a bunch of code that you re-use a lot. Typically they have lots of functionality for this use, and use good coding practices. The problem is that they are typically a little complicated if you don't understand the basics first. I recommend writing some simple websites first, get a feel for the syntax of the language. php.net is the best language resource I know of out of any language... it gives details information about any function or class, with comments from users. for instance, a function to get the length of a string: http://php.net/manual/en/function.strlen.php Beyond that, just go through some online tutorials and come up with a project for you to try and accomplish. Once you feel like you understand the basics, then feel free to look into frameworks, but most of them are object oriented so that's another hurtle for you to get over first if you don't know how OO works. Edit: Also, subscribe to this subreddit, this guy has some great programming basics for you: http://www.reddit.com/r/carlhprogramming/
If I may give you some advice that you maybe didn't want to hear - don't learn from WordPress code &amp; its plugins. I've seen some horrible stuff in there.
Thanks, I'll be on the lookout. My blog was the first thing that came to mind when it comes to my immediate uses for PHP outside of developing sites, etc.
I have to agree. While it certainly wouldn't hurt that he knew at least some C, I don't think it's strictly a requirement. Knowing PHP from the user side seems more relevant to his position, to me.
There are a couple of tutorials/articles on sitepoint, that might be a good starting point: http://articles.sitepoint.com/category/php-tutorials In particular there are the first couple of chapters of the book [Build Your Own Database Driven Web Site Using PHP &amp; MySQL](http://articles.sitepoint.com/article/php-mysql-tutorial).
Learn a different language with well defined programming structures and then adapt them to PHP.
I suggested a framework because starting from a blank .php file you end up reinventing the wheel and if you use the internet for guidance you'll have no way of evaluating if what you're doing is any good. Most frameworks do what's called MVC or Model View Controller. It's a simple way of separating 'make the page look like this' (view) from 'only let authorized users comment' (controller) from 'store it in a database with this schema' (model). Take a look at the [Symfony Jobeet walkthrough](http://www.symfony-project.org/jobeet/1_4/Doctrine/en/), it goes through building a real, useful project from start to finish. Don't worry about understanding it all at once but it'll give you an idea of what a framework buys you versus DIY. 
[w3schools](http://w3schools.com/php/default.asp) is a great place to start.
Join an OS PHP project. Have a look on sourceforge, etc., for projects that are looking for help. Then build friendships with other programmers on the project. Then ask for something to do. If you need help, ask your new friends. Learn what they already know. Also, have a look at sourcecode of well-designed projects (SwiftMailer, to name one). Learn by doing.
Also, join a helpful IT-professionals community. Making friendships with other *good* programmers is a good way of accumulating knowledge. One such community is bytes.com (we have a great PHP Q&amp;A / Article area - bytes.com/topic/php) 
Yea, but the backslashes sure look *ugly*
You can still gain from it, I've been a PHP dev for about 7 years and it made programming robots in C30 and GUIs in C# and various other shit (python, etc) a hell of a lot easier.
Always a great site. Only gripe is the terrible default flash video player. Other than that, I recommend to everyone I know who has any interest in ZF.
w3schools is terrible for teaching PHP, it's more like a super brief overview so you can decide if you want to learn PHP or not. IMO read a damn book.
i do agree about the brevity of w3schools, but in my defense, i did say a "great place to START".
This actually came in handy, if it worked. I get the following errors in example.php &gt;Notice: Undefined index: contacularform_submit in /var/www/html/sia/contacular.php on line 185 &gt;Notice: Undefined variable: output in /var/www/html/sia/contacular.php on line 281 &gt;Notice: Undefined index: HTTPS in /var/www/html/sia/contacular.php on line 548
This is working near flawlessly. Thank you very much for this discovery.
Glad to hear!
I concur - there was a lack of maturity in the writing style, the article's self-congratulatory tone, and the solutions presented.
It isn't really all that interesting at all.
No love for Cassandra?
I've found nginx better for special architectures for high volume sites, and apache still a good safe bet for your average server that has many sites.
Yeah. I wish nginx could load virtual-host files without having to restart. If it were integrated with cPanel/WHM, it would be great, since Apache is pretty bulky. Though I've found Apache with FastCGI is great for server load, my next experiment is just using nginx for static files, and passing the rest of Apache - in a reseller environment
Drupal's theme engine is extensible as you can see here http://drupal.org/project/theme+engines Perhaps you could try adding to it.
Neat idea, but eval() and "Last update: May 07, 2006" Meh.
Why would you want to use SQL when you don't need to?
why?
http://www.smarty.net - lots of people don't like it, but it gets the job done. 
Thanks for the tip. How do you like Drupal? Any quirks or other tips you can provide to make integration quicker?
Any insight on CMS's? I'd like to integrate what i've built into a CMS, or use a CMS that does what I want. Drupal seems to have a pretty extensible theme engine. What do you use?
CSS for look and feel, but actual CMS - none, unless you count wordpress + wp addons. Those that work well (e.g. for non-programmers) severely limit what programmers can do, or make changes convoluted. 
http://www.twig-project.org/
On the off chance anyone is considering using this for anything beyond novelty, please give [libxml](http://stackoverflow.com/questions/292926/) a look.
Recognize the bulk of drupal themeing work is nested templates. Drupal may end up rendering and splicing in at least 4 or 5 template files per request on a simple page with a few blocks and a content area, more on some of the more advanced sites. If you want to integrate this theaming engine in Drupal you'll want to optimize it as such (render quickly and repeatedly, Views will often use a node template several times as it loops through all the nodes its dropping into a list).
Use phptal and roll your own around it, maybe using a nice dal. 
Interesting, but I would prefer to use CSS selectors, like what jQuery uses.
phptal looks really cool. Thank you.
[Drupal 6 Themes](http://www.amazon.com/Drupal-Themes-Create-powerful-styling/dp/1847195660/ref=sr_1_1?ie=UTF8&amp;s=books&amp;qid=1268801593&amp;sr=8-1) should be really helpful. as should everything on http://drupal.org
Drupal's theme engine system could do what you describe. There was a great Smarty theme engine for 5.x but last time I checked it was no longer maintained.
for my projects (and i know of a big website that does it as well) I use XSLT. Best way to go it standard. 
Does nginx have a solution for replacement of .htaccess files - ie so I can use and edit rewriting rules without restarting the entire fucking server?
XSLT.
http://simplehtmldom.sourceforge.net/
Here you go: http://github.com/troelskn/csslib $query = new csslib_DomCssQuery($document); foreach ($query-&gt;select('.foo') as $node) { var_dump($node); } 
None of the CMSs are perfect, and many are bloated. You make a choice: live their flaws or spend and awful lot of time writing your own system, finally creating something with your very own flaws in.
[kohana](http://www.kohanaphp.com/) - It keeps all your code nice and modular. The entire system is very easy to learn and should take less then an hour. The framework is also lightweight. Example: **application/controllers/test.php** &lt;?php defined('SYSPATH') or die('No direct script access.'); class Test_Controller extends Controller { public function index() { $test = new View('test_content'); $test-&gt;message = 'Kohana rules on '; $test-&gt;now = date(DATE_RFC822); $test-&gt;render(TRUE); } } **application/views/test_content.php** &lt;?php defined('SYSPATH') or die('No direct script access.'); ?&gt; &lt;h2&gt;Welcome!&lt;/h2&gt; &lt;p&gt;&lt;?php echo $message.$now ?&gt;&lt;/p&gt; &lt;hr/&gt; 
Sexy.
If you want to traverse (well-formed) XHTML in PHP like it was SQL, use XPath instead. `SELECT href FROM a WHERE $class == "list"` becomes `//a[@class="list"]/@href`
Another contender: http://code.google.com/p/phpquery/
Sadly.. nope. Not yet. I hate the server restarts myself. For now, on my reseller server, I'm using nginx as a reverse proxy, so there's still htaccess there with Apache. On my own project servers, I'm using nginx alone. I think Cherokee web server might, I remember reading they were working on it
What exact advantage does using nginx as a reverse proxy have? Just saving CPU by using it for static files?
Check out [QueryPath] (http://querypath.org/)It's jQuery syntax for PHP.
First of all, the mysql_connect and the mysql_select_db I like to put in a separate file and do an include_once('db.php') type of thing when I need it. Reason being, if you change the password on your mysql account, do you really want to go through countless files to find where you've put your password? Also, why not use mysql_fetch_assoc() instead of mysql_fetch_row() so you don't have to go by number? If you add a field to your database, you don't have to go through all your code to make sure you're pointing to the correct index. It's generally pretty sloppy but those are the two points I have for now...
And memory. There's some benchmarks out there: http://www.joeandmotorboat.com/2008/02/28/apache-vs-nginx-web-server-performance-deathmatch/ But I've seen on my own server apache vs nginx a huge drop in CPU/memory
Uhm... good god... &gt; $ID = preg_replace($allowed, "", $_POST["ID"]); &gt; $query = "SELECT distinct school_code,last_name,first_name,test_id,test_date,exemption_code,score,ach_level FROM myhist where collection_code = 'feb1' and student_id = '$ID' order by test_date"; I dunno if this is secure or not.. you are def cutting it close. For security you should be using mysqli and the prepared statement. Or at least call mysql_escape_string on that shit.
&gt; &lt;input type="hidden" name="pass" value="', $pass, '"&gt; That's just plain old dumbass. you are aware you are sharing your DB password with the world like that... right?
 $allowed = "/[^a-z0-9]/i"; $pass = preg_replace($allowed, "", $_POST["pass"]); I would expect a variable named `$allowed` to contain allowed characters - Not disallowed ones. That's rather confusing. echo '&lt;form method="post" action="te (...) Why are you using POST method? You should use GET for retrieving/reading data and POST for manipulating data. mysql_connect Use [PDO](http://www.php.net/manual/en/book.pdo.php). The mysql extension is ancient and lacks important features, such as bound parameters. $query = "SELECT distinct school_code,last_name,first_name,test_id,test_date,exemption_code,score,ach_level FROM myhist where collection_code = 'feb1' and student_id = '$ID' order by test_date"; Instead of trying to clean up input with a regular expression, it's a much better strategy to escape input variables when embedding them in a query. An even better strategy is to use [bound parameters](http://www.php.net/manual/en/pdostatement.execute.php). echo '&lt;a href="testhistory.html"&gt;Return&lt;/a&gt;&lt;table cellpadding="3" border="1"&gt;&lt;tr&gt;&lt;td&gt;', SchoolCode, '&lt;/td (...) This code is not functional. You really should test your code before asking for feedback. That said, it seems that you are committing the very common error of forgetting to escape strings on output, thus making you prone to XSS type attacks and encoding problems. Whenever you echo out a random string, you need to escape it for the target context (html). Eg. use [`htmlspecialchars`](http://www.php.net/manual/en/function.htmlspecialchars.php) More generally, you should separate data base access (your model) from html (your presentation). At the very least, move the model code to the top of your script, and have the presentation code at the bottom.
Only adjustment I would say is use *require\_once* instead. That way if it fails to find the DB file it will kill the script require_once 'DB.php';
Turtles are cool, but not as much as platypuses. 
 $allowed = "/[^a-z0-9]/i"; $pass = preg_replace($allowed, "", $_POST["pass"]); No. No no. If you're not going to use PDO, at least do yourself the favor of using mysql\_real\_escape\_string to sanitize field input. Use sessions and a separate login-form, don't send user/pass back in the form as a hidden field. Don't intermix PHP and HTML like that. If you're not going to use a template engine, at least build your variables in one place and output the HTML in another (i.e. further down). Saves a lot of headache and time in the long run. Guessing wildly, wouldn't it be more interesting to ORDER BY test\_date DESC? $row[0], $row[1], $row[+Inf] will also be very annoying. Use mysql\_fetch\_assoc instead (again, if you're not going to use PDO). And so on I suppose. I have to say though, finally someone using legacy mysql that understands how mysql\_do\_something() or die("Heeyyoooo"); works.
I would assume he's using POST because he's sending username/psw in the form and doesn't want it in the url :p
Are you sure the fonts you're using are Unicode fonts? Which fonts are you having problems with, and which ones are working?
This will sound harsh, but I think you need to start over. Go read about proper input filtering in PHP, and at least, as others have recommended, use PDO for your queries. You may be better served by using something like Zend Framework's database abstraction classes, since it'll help catch some of the missing input escaping and such. This code is also littered with chances for undefined variables/offsets, and your echo line for your table header is, as best as I can tell, outputting undefined constants. If you're not seeing errors for these things then you need to adjust your `error_reporting` level with something like: error_reporting(2147483647); (You should also make sure that `display_errors` and `display_startup_errors` is on, because those options could be squashing your error messages as well) But above all-- if you're using `preg_replace` in lieu of a `mysql_real_escape_string` equivalent, you're a danger to yourself and those who will depend on whatever you're writing. I hope that doesn't sound rude, 'cause I don't mean for it to be mean-spirited. I just want to encourage you to take some time and learn more about some of this before you go any further. http://php.net/filter-input http://php.net/pdo http://framework.zend.com/manual/en/zend.db.adapter.html
If your source documents are HTML, make sure you've got the correct doctype defined. 
The page is on a internal network so I was thinking it would be ok if the user had access to their password. I guess I won't always be able to rely on that.
You may be right, but in that case he's fooling himself. If the data should be secured, he should use https instead.
Hey .. Cool you took the time to got through the different variations of `static`.
Yep. Unfortunately turns out to be a bit of a dry subject to write a blog post about. There were a few surprises though - it turns out that method-level static variables are completely messed up and could easily lead to bugs.
It will get saved to the brower's cache though. 
http://en.wikipedia.org/wiki/Hasty_generalization
Good advice, but just use error_reporting(E_ALL); 
this probably does not have much to with the font. can you use that same font with a different tool to render correctly? if you do, check to see if TCPDF offers options or arguments to set the string encoding and set it to UTF-8.
The reason for the large number is that it captures any and all possible error types both existing and future, regardless of what PHP decides to use for the values of any predefined constants, such as `E_ALL`. For example, in PHP 5.3, `E_ALL` does not include the new `E_STRICT` (which is silly, since, you know, `E_ALL` implies *all*). PHP's documentation suggests using 2147483647 as a way to ensure that you're seeing absolutely every error type. `E_ALL` will include `E_STRICT` in PHP 6.0, but I like knowing that 2147483647 sets all of the bits, regardless of whatever bad decisions they may make in the future. So, yes, normally I would agree with you, but since they've proven with 5.3 that `E_ALL` may not always include *everything*, I would still suggest using 2147483647. Documentation for the `error_reporting` runtime configuration directive: http://us3.php.net/manual/en/errorfunc.configuration.php#ini.error-reporting
Interesting, learned something new. Thanks!
Alright, hold on to your hat... There are only a couple fonts that come anywhere near covering a big chunk of Unicode. One is [Arial Unicode MS](http://en.wikipedia.org/wiki/Arial_Unicode_MS), and another is [Code 2000](http://en.wikipedia.org/wiki/Code_2000) and relatives. The fomer is a Microsoft thing (not free), and the latter is a shareware font which covers a big chunk of Unicode but isn't terribly high quality in several blocks. That said, when I say "a Unicode font," I'm not referring to how much of the Unicode codespace is covered by a glyph in that font, but rather, whether the glyphs are specified with Unicode code points. In order to understand the problem, you have to make sure you understand the differences between a font, a codepoint, and a glyph. If you have text which is encoded as Unicode, what you have is a bunch of bytes which are encoded in one of the "Unicode Transformation Formats" (UTF) -- mostly likely UTF-8 if your content is from the web. Now, whether those codepoints are legible on your machine depends on whether you have a font which contains the glyphs (crudely, a little picture of a letter) corresponding to those bytes. So for instance, if you go to http://my.wikipedia.org , you might see a bunch of little squares or question marks or something if you don't happen to have a Burmese font. But the text is encoded as Unicode of course. So now we get to the question of language identification: that's tricky. Are you trying to generate PDFs in arbitrary languages? Surely you have some idea of what languages your users will be producing content in? If you're embedding the fonts into the PDFs, you do have to know which languages are going to be there ahead of time. This is a good place to look up font support for particular languages: http://www.alanwood.net/unicode/index.html If you have a list of languages that you know you need to support I can try to help you out with specific (free) fonts too.
,    ,      . ,      .  .  .  ,         PHP 5.
Okay so, this part reveals a bit of a misunderstanding: &gt; Chinese big5 and traditional are realistically going to be the most common non-English languages/fonts used. I would say Russian is next on the list. You need to understand that encodings and languages are different animals. _Any_ language can be encoded in Unicode. It's also true to some extent that _many_ languages can be encoded in some of the legacy encodings, even the "smaller" ones, so for instance there's no problem whatsoever in representing [Rotokas](http://en.wikipedia.org/wiki/Rotokas_language) in Latin-1, since it has just six letters in its alphabet! But the mapping between languages and encodings is FAR more complexity than you want to think about, or even could think about, in the general case. I'd bet that most Russian users these days will be okay with Unicode encodings of their text -- some have even gone to [hilariously extreme efforts](http://en.wikipedia.org/wiki/File:Letter_to_Russia_with_krokozyabry.jpg) in the past to make sure that their text didn't turn into [](http://en.wikipedia.org/wiki/%D0%9A%D1%80%D0%B0%D0%BA%D0%BE%D0%B7%D1%8F%CC%81%D0%B1%D1%80%D1%8B)! To be honest I'm not an expert on PDFs and font embedding, so unfortunately I'm jsut going to have to punt and say that you should test with the languages you need to support. But I will say that you start with supporting UTF-8 with Unicode-encoded fonts that cover the languages you expect. Deal with complaints when the come up, either by biting the bullet and figuring out how to re-encode things on your server, or by educating your users about how to use Unicode fonts. Here's a link that may be of help: * http://www.w3.org/TR/i18n-html-tech-char/ * http://www.w3.org/International/questions/qa-what-is-encoding * http://www.w3.org/International/getting-started/characters Richard Ishida is the i18n (internationalization) lead at the W3C and homey knows his stuff. So if you search for him you will find links to a wealth of info. Good luck.
I can't speak for their PHP tutorials, but I liked [MyCodeTeacher's](http://mycodeteacher.com/) video tutorials on Cocoa. The PHP tutorials are no doubt just as good.
To do it like Youtube, you can have a easy PHP script which uploads the video, but then you need to convert it to a flv, then just play it using a simple flash player. Or you could try the HTML5 video route. -- edit -- ffmpeg can convert a lot of formats, that may be worth looking into.
Not that familiar with flash, not sure if on-the-fly flash conversion is do-able without selling my soul to Adobe.
I think you have two options: a) accept only flv videos (and set up a tutorial for your users and provide a free and easy to use program), or b) convert them yourself on your server. The first one is easy, they upload the files already encoded in a format you can read, and show them using a player (such as Flowplayer). The second one is a bit more messy but your users will upload more videos as it'll be easier for them. Problem is... Converting video files is *serious business*. You won't be allowed to run `ffmpeg` in a shared hosting and, in case you could, it'd be too server-consuming. So, basically if you have VPS or dedicated server, I'd suggest doing the following: * User uploads video * You check it's a compatible format * You encode it in the background with `ffmpeg` (can take some time depending on your server resources and the video size). * Once it's encoded in .flv, show it using Flowplayer or any other player of your choice.
Why not use YouTube's API to upload, convert and store the video? I believe Vimeo also has an API, and they have a professional account that allows you to do more resource-intensive tasks. The hardest part of this project will be the actual video conversion, so if you can offload that to an existing service, the final product will be cheaper and hopefully much more reliable and scalable. And since everything happens behind the scenes, your users never even need to know that a third party was involved.
I was just making a little app to work with these apis. Yeah they aren't hard to pick up on at all, check out both youtube and vimeo for API links.
[Flip Factory](http://www.telestream.net/flipfactory/features.htm) is pretty good, very customizable. Also very expensive.
I did something like this with ffmpeg. You can find the source here: http://bitbucket.org/wooptoo/quickstream/ or [get it zipped](http://bitbucket.org/wooptoo/quickstream/get/tip.zip) if you don't have mercurial installed. 
Please see http://denniskromhoutvandermeer.com/flatty/ And: http://pastebin.com/T1qCKK9d I started using php include instead of writing within the file itself. In iexplore it looks good but for some reason firefox is throwing up these weird chars. However, when I put the content in the file itself it displays fine, it only does this with the included content. Update: I got it fixed. it had something todo about mixed file encoding, DOS vs UNIX. Thanks though! 
Content-Encoding: gzip Turn that off in php and try again.