If you want to progress beyond a junior level position you should know higher-level programming concepts. Or in 5-10 years suddenly the industry shifts and PHP is irrelevant - what then?
Apology accepted, and good form. :-)
I can see the relevance in all of these questions. They're all pretty basic and I wouldn't hire someone who just told me "but I've never used that so why should I know?" - why should I hire someone who doesn't want to learn anything? It'd be one thing if you thought, "hmm, interesting, I didn't know that, I'd love to know more" instead of "this makes no sense and it's irrelevant to my personal experience with this language, so it's stupid to ask me." Obviously since this is a junior position, there is going to be a lot of training and learning involved. That's fine. It's being resistant to learning new things that will screw you, and that applies all the way up to senior positions. I'm not trying to come off as harsh, but the point of these questions isn't just to be pedantic and screw you over, it's also to gauge your willingness to seek out an answer and ask questions.
there were similar "trick" questions when I was taking the php zend certification exam... they are really relevant for hardcore backend developers, but in most they are there to check if you are php god. pro tip: download the php source code and study it, try to compile it in your brain lol.. then think about &lt;?php phpinfo() ?&gt;
Yes, `$a = 011` evaluates to `9`. A leading `0` in a literal [denotes an octal number](http://php.net/manual/en/language.types.integer.php#Syntax)
Not sure i'd agree with that either.
&gt; If you want to progress beyond a junior level position you should know higher-level programming concepts. If he's being interviewed for a junior level position, then they should be assessing his ability to function as a junior level programmer, not a senior level programmer; if he can already function as the latter, then he's overqualified for this position. The MySQL question isn't bad: he *should* know what would happen there, because it might come up, at least while debugging. The first two seem purely academic to me.
Seriously? This is being voted down? Some of you people are idiots.
This guy's right. You do need to be willing to learn(like everybody else I might add). However saying this in an interview is more of a semantics problem than a programming one. If you say "I have no clue, never used them before", it may give the wrong impression that you're unwilling to learn. Ideally speaking the candidate shouldn't be put in a position where wording(unrelated to programming itself) leads to the idea that he's lazy, stupid, etc. And I'm speaking from personal experience here. I did the same thing. I encountered things I didn't know and simply said "hey man, i don't know..." and that was it. Later did I figure out that wording IS actually important...
Very true, they should be testing his suitability for the current position, but at the same time, if they want to find an employee that is going to grow and learn and be with the company for a few years, they are also going to be looking for someone with a lot of potential and willingness to progress. It's one thing to hire for a junior-level person with the expectation that they will remain as such, but another thing to hire someone you know you want to invest in for the long term. That's the perspective I'm coming from.
You're questions are good ones too. I don't think that somehow makes the questions the OP posted bad though. A lot of your questions could be easily answered by someone who spent a bit of time googling those topics where nobody is going to prepare for arbitrary shit like lexical scoping rules, therefore those questions I think provide a strong litmus test for actual thorough understanding and knowledge vs. reciting information from fabpot's latest blog writeup.
&gt;&gt; Difference between strstr and stristr? &gt; Answer: who gives a fuck? Google it. If you have to google every function you encounter, you're probably going to be unaware of a few and end up reinventing the wheel at some point or hacking together some bullshit function that already existed in a superior state in the language. Plus Googling on the job doesn't look very professional. Everyone does it occasionally but if you're entirely reliant on it that's a problem. 
Yeah, I had to learn the hard way myself. Always present yourself as willing to learn and progress and people will be a little more forgiving about things you have not learned yet. Especially if they're interviewing for junior level.
Solution implies correctness. The op was not correct. Disgust was registered. It's not complicated.
Again, you're just wrong. Googling on the job is absolutely normal and to be expected. These are poor questions. A poor programmer could score highly on them and an excellent programmer could score poorly - that alone proves they are poor questions. There's no point remembering a bunch of functions. What's more important is whether you know how to break down a seemingly complicated problem into a simple solution that works now and can be easily maintained and expanded on in the future. Can you write clean code? Will your system still work in 2 years time, and will we still be able to build upon it then? If the business changes its mind, will the system be able to cope? Those are questions that matter, not stupid stuff like this.
If you ask 10 people that question you'll get 10 different answers. Here's the perfect example. A few days ago a colleague wrote a function to reverse a string. And it worked perfectly fine too. Then I pointed him to the strrev() function... My point is, unless you use a function a few number of times you'll probably forget it. But honestly, for trivial things one should always ask himself "Isn't there a function for that?". Odds are the answer is yes.
While I agree, I think a better metric for how willing he is to learn and progress would be to discuss passion projects and technologies he's taken the initiative to learn on his own (even if they're not directly applicable to the position).
Whatever you have to tell yourself..... And thanks for all the downvotes.
I guessed correctly. Massive troll.
Had almost the same experience once - in my case questions included similar weird examples from CSS and HTML. After a very stressful interview I got the job, so I hope that you will also get accepted!
How am I a troll dude. I simply replied to your shitty attitude with a comment on why you were getting downvotes. Stop being such a grouch. 
If the most of the other questions were normal you shouldn't worry, i don't think you'd be judged on the basis of these silly questions. The reason some people include such obscure things is to get a bit better insight into your experience as a developer. It doesn't mean you have to pass those, what it means is if you do pass those they might hold you to a higher regard (maybe). 
Shut up with your facts.
Googling doesn't make you look very professional? What? There's no way you know the entire mess that is PHP's built-in functions, at that point it's just pot-luck as to whether or not you have come across it before.
I would recomment some books and then - practice! Online classes are also good and you can benefit from the live interaction in them. These two books have high ratings : http://www.amazon.com/Programming-PHP-Kevin-Tatroe/dp/1449392776/ref=sr_1_4?ie=UTF8&amp;qid=1412540290&amp;sr=8-4&amp;keywords=learning+php and http://www.amazon.com/PHP-MySQL-Beginners-Mark-Lassoff/dp/0990402010/ref=sr_1_6?ie=UTF8&amp;qid=1412540290&amp;sr=8-6&amp;keywords=learning+php
Where do you live? Do you want a job?
Sorry about that! I think the issue I have with mcrypt, personally, is that it just seems dead. Last release was over two years ago and idk it just seems to me that outside of PHP mcrypt isn't widely used at all. And if it isn't widely used outside of PHP I just question how well vetted mcrypt really is. Really, I think OpenSSL is a better choice for symmetric ciphers. PHP &gt;= 5.3 has openssl_encrypt and openssl_decrypt. You can be confident those are vetted because OpenSSL is probably one of the most scrutinized software packages in the world. But mcrypt I think is still widely used (within the PHP world) because of inertia - not because of quality. Also, I guess it just touched a little nerve with me because... well consider Wordpress. It's helluva popular and it's subjected to a lot more security scrutiny than Joe Schmoe's blogging software. If we just go with what's popular and what's been the most vetted than Wordpress will forever reign supreme and there's no point in anyone ever writing a blogging software again. But I don't agree with that. Sometime's you gotta give the underdog a chance. phpseclib is used in, among other things, laravel (where I first heard of it). It'll never be as scrutinized as OpenSSL but it's not like it was written yesterday either!
Pro tip: If you have this issue, the error log will contain the line where the first output was made, making fixing these more easy. Disclaimer: I've been coding PHP professionally for 8 years, and learnt this just last week :(
I gave you perfectly acceptable responses, but you chose to ignore them. You clearly do not seem humble enough to consider others opinions, as you are proving right now. Go look up the definition of troll.
&gt;why should I hire someone who doesn't want to learn anything? And I wouldn't want to work for someone who assumes I should know everything.
Not what I said. There's a difference between already knowing and being willing to learn. 
ITT: I learn not hire 2/3 of this sub's members
There's certainly space for an e.g. PHP application compatibility group (to get a somewhat broader perspective). I'm not sure introducing the same formalism and constraints as the FIG had would be useful however. More importantly it's time to get rid of NIH and think a bit outside the box; occasionally take a peek at Python PEPs for reasoned standardization. But just don't unilaterally label things "standard". PFSR-3 is the only FIG outcome so far which benefits interoperability. PFSR-0/4 for instance is holding PHP back, as it was just intended to cement the big frameworks legacy directory schemes and torpedo proper PHAR support.
It's not about answering 100% correctly, it's is about failing in those question. Some interview tests are designed with the same objective as a medical test. It is about the TRUE/POSITIVE. If the company has many solicitudes, tests like this work for a great "diseased" discard mechanism. You see, it is true that "if you can answer all of them 100% correctly, it still tells you absolutely NOTHING about how good a programmer you are", but it is also true that if you don't score well it certainly tell you something about how bad a programmer you are.
Usually a cursory search of "how to ___ in PHP" will get you a function you need, or at least get you most of the way there, if you're not familiar. I find myself going back to the manual because sometimes even if I do know the function PHP's parameter order is wildly inconsistent, and sometimes behavior is as well. Like, knowing that array_shift() actually modifies the array you pass to it as well as returning the first value is a good thing to know. EDIT: There's a good question for mid-level - the difference between pass by value and pass by reference! ;)
Wrong. Those questions could all be answered incorrectly and you could still be an excellent programmer. 
Congratulations! My suggestion for Aura: Please attach importance to documentation.
strstr??? I read and write PHP everyday and I've never seen that used. I'm sure there are good uses for it, but knowing esoteric functions isn't a reason to think someone is a good programmer. I would have answered 'strstr' is a poorly named function. stristr is the case insensitive versions of it. If I were to use that function, it would only be in the context of a another well named function since I wouldn't expect someone to know what the function was without looking it up.
We also don't support the `:` syntax, it's `=&gt;`. I wanted to add that, but that failed ;)
Do you have examples? The quirkiness of CSS and HTML is very very relevant to getting your page to look right. You *need* to know the weirdness.
If you knew what `strstr` does you *should* be able to guess what `stristr` does, but `strstr` is pretty awful name for a function. I'm not sure I've ever used it personally in my 10 years, but I've come across it a few times.
&gt; arrays of arrays of arrays Ugh, don't remind me.
Probably because you aren't really a programmer - you just think you are.
Yeah, most of these are retarded. I fucking hate stupid interview questions that have nothing to do with how good you can be at solving real-life problems. Not to mention, Google is always there. You should be able to look things up. 
Anything that is knowledge based especially outside of the completely common is absurd on an interview and irrelevant. We as programmers have Google when we don't know something off the top of our head. Good software engineer interview should consist of intellectual questions that determine whether or not you are capable of logical thinking and problem solving. Syntax checking is done by the computer. Take a look at the type of questions that big companies in Silicon Valley such as Google ask, there not anything related to stupid intricacies of a particular language and in fact many times they will let you conduct the interview in whatever language you're comfortable with (I know from personal experience as well). Knowledge questions are stupid in an age where we can look up anything in seconds.
Noted. The individual library packages, which have been the main concentration, come with thorough narrative documentation in their README files. The `*_Project` packages, on the other hand, need more love in that regard.
The sorts of places that ask these kinds of questions tend to be horrible to work at. Run screaming in the opposite direction.
Junior Development interviews are less about finding out what you know about the language(s) and more about finding out how you go about solving a problem. Language specific questions are almost completely void due to the fact that once you understand one language or the basics of how a language works, you can learn any of them... To a point of course. 
And they should let you have access to php.net or Google while you are writing the code to be honest. Give you a handful of problems and 30 minutes to write some code and see what you come up with if you were in the actual work environment.
Pretty sure all php libraries are equal.
Here is the libray that I am using: https://github.com/jaxl/JAXL Generally good for anything that needs to send email-like messages to one or more users, but there is noneed to store the messages like email. Also, if there is a risk of repeated messages, it would quickly fill your inbox. With a XMPP/jabber messenger, you do not have that issue. repeated messages (like errors in a code loop) simply scroll up so to say.
I agree. They seem like really basic questions introduction questions. If that's all they asked then they're pretty poor questions, but it'd be a good start to work out the level of the person they were talking to. Scoping rules, number formats, very basic of basic database (inserting into a auto-increment column), and use of common string functions (`stristr` or `stripos`).
Perfect, thanks for that.. It's the project management of php that I am needing, not just the language skills.
No they don't say if you're a good developer, no interview questions can do that. But I'd be surprised that in 8 years you've never been bitten by a leading '0' in a number and wondered why, or never used `stristr` or `stripos` or the `i` modifier in a regex, or inserted a row into an auto-increment column?
I've used an i modifier in a regex quite often, but never as part of `stripos`. Never been bitten by a leading zero because the data I write isn't shit, and I guess I've been lucky enough to avoid shit data in legacy code thus far. And I've never inserted anything into an auto-increment column, no. Maybe I will in the future, but for every rare instance where something like that happens, I do other things 1,000 times over, which one would think would be more pertinent to a web dev position.
 &gt; Out of all of the possible questions they ask; "is this file syntax correct?" No, they asked if you understand scoping rules in PHP.
At least you had actual programming questions. One Web Developer job I applied for last year said that I'd have a couple of timed tests to complete as part of the interview process. The tests were actually generic 'fill in the bubble' ones relating to totally random subjects like matching old English definitions, word problems etc. The second test was finding spelling mistakes. Throughout the entire interview I never once was asked anything about my technical skills relating to the actual job they were seeking an applicant for. That was maddening.
Yes, but the probabilities are against that particular possible still excellent programmer, and sure there are many other candidates. Again, in the medical test analogy, what you are describing is a FALSE/POSITIVE.
[MVC stands for model-view-controller. MVC is a pattern for developing applications that are well architected, testable and easy to maintain](http://www.asp.net/mvc/tutorials/mvc-5/introduction/adding-a-controller). I guess the [ASP.NET MVC 5](http://www.asp.net/mvc/tutorials/mvc-5) guys are getting it wrong also. You completely misdirected the point of the *scope* of this post. Thank you.
&gt; I have never tried to insert something inside a freaking AI field. How is this possible? How do you keep unique ID of records in your tables?
Congrats on all that work! There are plenty of links in the blogpost, but which one will lead me to the documentation of "getting started with the framework"? I can only find links to GitHub projects.
Thank you. By the way have you seen https://leanpub.com/aurav2/read ?
/u/mnapoli https://leanpub.com/aurav2/read ;-) .
I've been professionally employed as a web developer for 3 years now. I had no idea what trying to insert a *NULL* value into an AI field would do because I, like OP, have never tried. I would imagine that it would do nothing unusual, because that's essentially what it does when you don't pass in a parameter for a sql insert, but then again I don't actually know. The reason that I hate programming "tests" like this is because it does nothing than check to see if you have obscure knowledge of a programming language. I like the tests that check to see HOW you think, not WHAT you know. You can sit me down and tell me to write a simple program in any language and I'll be able to do it, like most any other programmer worth his/her salt.
ELI5: Why is it so hard to implement threading in PHP? ***EDIT:*** After a little research, i've found /u/krakjoe's pthreads..... I'm itching to do something with this now....
You don't need to know what strstr is tell the difference from stristr. Many PHP string handling functions offer their case-insensitive version, including the popular strpos. Knowing alternative numerical representations isn't very practical for the daily junior web developer. But it would be a nice advantage to know it. But yea, they could have asked better questions for a Junior position imo.
Remember, though, this only applies to PHP code that doesn't close at all, so if you do things like wordpress: &lt;?php function this($that) { ?&gt; &lt;div something &lt;?php echo $that; ?&gt; something &lt;/div&gt; &lt;?php } and then don't close it is not "valid".
Not equal, just that one isn't better than any other.
Why not use something that has more flexibility and developers behind it? You can use [monolog](https://github.com/Seldaek/monolog) to ship off messages (including PHP errors) to a log server such as [Graylog2](http://www.graylog2.org/) or [ELK](http://www.elasticsearch.org/overview/) which is a combination of Elasticsearch (which Graylog also uses), Logstash and Kibana. You can also set it up to ship out and parse log files. So on a production system you can have it auto-parse audit, access, messages and other system log files and do whatever you want with it. They even make it flexible to add your own variables and ship out to 3rd party services.
Personally I just let my IDE take care of these differences in strstr (stristr) or parameter order of functions. These questions seem completely unnecessary, as for the first one if I wanted to know if someone understood local scopes, closures, anonymous functions, then I'd ask them (and probably in a different language that uses them more).
As with any skill, excellent programming requires two things: innate problem solving ability, and memorization of language minutiae. Problem solving questions are hard to write. A good example might be "sketch out the flow of a PHP script that validates input and ensures every input error is sent to the user." The answer would be to initialize an array of errors, perform validation, and push on to the array each time an error occurs. At the end, if the error array has more than zero members, send the errors to the browser and stop execution. The candidate would pass the question if they produced something resembling the above as their answer, and would not get deducted points for syntax errors or reinventing the wheel. But the questions posted by OP test language minutiae. It's the difference between a programmer using stristr('123aBc456', 'abc') versus strstr(strtolower('123aBc456'), 'abc') Obviously the first example is neater, and a programmer who pays attention to these little details is going to be more desirable to an employer. A programmer who reinvents the wheel (as shown in example #2 above) or doesn't memorize the syntax will produce working code, but by relying on their tools as crutches for their bad memory, they will not be efficient. It will take them a long time to solve a problem that an experienced programmer can solve quickly, because they will be caught up in the minutiae. Thing is, language minutiae can really only be mastered by spending a lot of time with a language. At Datto nearly everything is written in PHP, and I've done everything in PHP from chmod() to representation of IP addresses as 32-bit integers to Composer. For this reason, I and many of my colleagues often find it more desirable to hire those who do programming projects *for fun*, not because they were forced to. No college curriculum is going to expose you to a sufficient array of real-world problems. You've got to take on your own projects. Mine was a hardware asset manager for my home network with full DNS and DHCP support. It did everything from a captive portal, to generating config files, to carefully controlled scripts that take care of service reloads as root. It also integrated with the WiFi network to automatically authorize MAC addresses in the firewall when they authenticated with WPA Enterprise, and supported time-limited guest sessions. I had to do real programming in a whole bunch of languages but when it finally started to work it was awesome. It's still in use on my home network today. To do it, I needed to understand broad programming concepts like recursion and asynchronous callbacks, but also learned lots of little details along the way, like ip2long() and how to securely generate a password that changes daily at midnight. So that makes one of my favorite interview questions: "Tell me about a project you did or script you wrote on your own initiative that solved a problem in your daily life." Edits: grammar/clarity
You started out okay: &gt; If you have to google every function you encounter, you're probably going to be unaware of a few and end up reinventing the wheel at some point... Very true &gt; Googling on the job doesn't look very professional Aaaaand you lost it. If you know all of the answers all of the time, you're not challenging yourself and are stagnating. And since everyone else *is*, that means you're falling behind the curve. You're effectively stupider than you were yesterday just by virtue of staying at the same level.
I couldn't agree more. Knowing what to google and how to implement the information you received is what matters at the end of the day.
But why is it so hard to implement now, in the core. What is stopping it from being included.
Sounds interesting, never looked at monolog before The only issue for my preferred features that I would see form glancing over it is that it does not support any chat format except HipChat which again seems to work on a proprietary interface/client. I love Jabber as I have the impression that it's very versatile and easy to use along with a ton of existing clients and servers. My (probably poorly) written system is as of now only 300 lines, so definitely manageable by one person. I do not think it was ever meant for a large corporate production system that would justify dedicated log servers.
These are typical nonsense trivia interview questions with no practical value. I doubt I would accept an offer from a place like this, I can already tell the higher ups don't have their priorities straight. Just have a candidate provide a sample of their code and have them explain why they are proud of it. You instantly know their competence level and ability to explain technical things in a way that others can understand.
Both? Those were polar opposite statements lol
Ah cool thanks I missed that. I saw the link and I thought "meh" I don't want a book. So honest and (hopefully) constructive feedback here: A book, mehâ€¦ Why? First the navigation is really crappy, there's the summary on the top and then that's it. Also there's the price tag on the right, it doesn't look good for an "official" framework documentation. I'm sure some people will interpret that as "they are trying to make me pay for the framework documentation". Just to be clear, the content of the book looks really good! And the fact that there is a book that you can buy is good too! It's just that a documentation embedded in the website, searchable correctly and with nice navigation would serve the framework better. Cheers!
Hi! Interesting! Also a different approach on the subject to achieve a similar result: [Couscous](http://mnapoli.fr/Couscous/).
The GitHub project is here: https://github.com/piwik/ci-status You can install it on your own server or just use [ci-status.com](https://ci-status.com) if you don't want to bother.
Well the great thing about Monolog is it's all very modular. If you created something to ship off your current logs to Jabber you can do the same in Monolog. Just create a handler (/Monolog/Handler/) and if needed the formatter (/Monolog/Formatter/). It could pretty much look like this: use Monolog\Logger; use Monolog\Handler\JabberHandler; use Monolog\Formatter\JabberMessageFormatter; $logger = new Logger('messager'); $handler = new JabberHandler('LOGINHERE', 'PASSHERE', 'WHATEVERELSE...'); $handler-&gt;setFormatter(new JabberMessageFormatter('anything', 'you', 'need')); $logger-&gt;pushHandler($handler); $logger-&gt;addRecord(400, 'Off to see the Jabber, the wonderful jabber');
Maybe they were looking for answer like this.
did you just make this up?
Absolutely. My first instinct would be to use a regex for something like that. If that was more or less what they were looking for, then great. I do share the hesitation that the OP has, namely that this is more trivia than skill.
If you are working on a small project with three tables, you don't need to worry too much. The problems arise when you have a large system where good architecture and appropriate patterns become really important. With AR, the model class is responsible for both a) modelling a domain object and b) saving it to the DB and loading it back. Which means the model class gets mixed with methods like `beforeSave`, `afterSave` and `afterFind` to turn DB column values into your domain values and back (e.g. timestamps and datetimes converted to `DateTime`, complete with some timezone). This breaks the [Single Responsibility Principle](https://en.wikipedia.org/wiki/Single_responsibility_principle). Note: this is not a big deal for a small solution where your business logic is simple, but it tends to get worse as the system grows. If an attribute holds something more complex than a string/number (e.g. a `DateTime`, a custom `Money` class, etc.), you have to manually (un)stringify it using `beforeSave` and `afterSave` (or stow the original value away somewhere in an additional private property). * Are you sure those conversions are lossless (of course they should be, but are you certain, especially with datetime/timezones)? I've been bitten by (my own fault) fun bugs before where a `DateTime` was constructed with a local timezone, then (correctly, by design) saved and unstringified into a `DateTime` with UTC, and suddenly that entity's publication *date* is different than it was before... * What happens if there's an exception thrown between `beforeSave` and `afterSave` - what state is your model left in? Personally, I am not fond of a property that can be both a string and an object at different times. See also: [Martin Fowler - Patterns of Enterprise Applications](http://smile.amazon.com/dp/B008OHVDFM/).
The intention of this is to give a quick start (probably a five minute read) to learn how to use aura as a microframework with `aura/view` integrated. If you are looking for much better example consider looking at the code https://github.com/harikt/Aura.Blog/ or https://github.com/harikt/ghdocs . Thanks!
My guess would be a lack of desire to implement it, plus it ends up causing the vast majority of extensions to fail (as they are usually not "thread safe"). There are some extensions, ala pthreads, which allow for actual threading, but it's pretty rarely used afaik. 
&gt; A terrible programmer could score 100% answering these questions, and a great programmer could get them all wrong. While that is *conceivable,* it's not something I'd expect to be the norm across many applicants, and not how I'd want to gamble with my company's salaries and/or budget. When you look to hire someone, you're not looking for the outlier who flips all your expectations upside down. That *could* happen, but it's rare enough that it will cause you to spin your wheels relentlessly as you waste huge amounts of time trying to find that unicorn. When you hire someone, you are looking for someone who has *demonstrable* competency in areas that you care about. Someone who is a genius but cannot demonstrate it? Tough shit for them. And *not* tough shit for your company -- I know some of you will insist that "ha ha you screwed up your company" *must* be the case if you pass on a misunderstood genius. Unfortunately, there are no justice boners you can get here. It's just a lose for the candidate, and then the company moves on to *another* 100 fitting candidates and takes a pick, no downside for the company. Why? Because it's a buyer's market -- you will still get a damn good candidate even if you don't take "the one that got away." Good employees are not a scarce resource, and while *great* employees are more scarce, they're still out there in enough numbers to prefer them over discovering a unicorn. So if you want to hire a person who doesn't need to be trained on the basics of MySQL queries (and I'd suggest that how to make an auto-increment field... auto-increment... is pretty damn basic), then you ask a question that is obvious to anyone who has ever done it, but probably opaque to anyone who merely has book knowledge of SELECT/INSERT/UPDATE/DELETE (or maybe doesn't even have that). The person reviewing the responses will not have a guarantee that the candidate can put together the "most tight and speedy" SQL query you've ever seen, but now you know that there is some training you can skip, as they've done it once or twice or a thousand times. From there, you can then rely on references or further interviews to size up their skills and the competing applicants. And that's an important part. If you have salaried people who have big paychecks, you may not want them wasting salaried time to interview every possible candidate that walks through the door. So you screen them, sift the wheat from the chaff, maybe with a HR person or low-level employees. Next round? Well, maybe only 2 make it to the next round, but now those ones are at least qualified to some degree and are not a complete waste of time for the technical lead, manager, and VP to talk to. I understand that this sucks. But it is pretty damn prevalent in tech. So you can play ball or go home, but you probably can't change the game. Alternatively, I guess you could hold out for the rare exceptions -- but if you do that, expect lots of bad outcomes like what we see from OP, as you wait for that magic result. And speaking of the OP, I would assure you of two things: 1. You *will* get better. There is a saying that your first interview is "one to throw away." You do it for the experience. Maybe you do 2 or 3 for the experience. But pretty quickly you learn the language of interviews, and so long as you stay curious and bone up on the questions that threw you for a loop, you'll eventually plug all or most of the holes in your skill set, and get hired. 2. You *will* be frustrated by this again. Even at an older age. Tech moves fast. I was at one point with a single company for about 8 years. During that time, frameworks rose to popularity. However, I didn't have those when I started at the job 8 years prior, and I had built my own framework, and I loved it (one of my employees even got his name on a patent that emerged from our work), and saw no need for off-the-shelf frameworks. However, when I went out to look for my next job, even as a senior developer, I was blindsided by question after question about it. And some of these interviews were really difficult for me -- some little 20something fresh out of college asking about the framework he was taught in class, and I'm like "buddy I build this shit from my own brain" but *that* was the *wrong* fucking answer. He viewed that as extreme incompetence. So guess what? 3 failed interviews later, I know every god damn framework that exists in my field, and nailed the next interview. So don't beat yourself up for failing this interview. It's a learning experience, you'll recover, and do 1000x better next time. :) Good luck!
FYI : I have started to work on to render the book http://ghdocs.herokuapp.com/harikt/aurav2book/master/manuscript/index.md . Yes there are still a few issues :-) .
I've done PHP development for a while and have recently moved to using Node JS particularly using the MEAN stack (Mongo, Express, Angular, Node) the luxury of using the MEAN stack is everything is just one language, Javascript. Though it does come at a price.... The most frustrating thing when moving from PHP to Node was Callback Hell (hello Async). I had a hard time wrapping my head around callbacks especially when returning data from a multiple queries (needed to query SQLServer db). In the end I like it a bit more than PHP when it comes to syntax an using the same language between the front-end and back-end however there are many times where I think to myself "this could be done so much easier in PHP", so like most things it depends on the application and need. Like /u/ewanvalentine said it depends on needing an app that is asynchronous or performance critical. 
He's not saying he's never had AI fields he's saying he would let them, you know, self increment automatically as they are wont to do.
But those questions still don't tell you anything. Much better would be to set a programming challenge, and give the interviewee full access to an ide of their choice and Google and let them do their thing. I'm a senior dev who hasn't touched sql in nearly 3 years. Off the top of my head I'll probably fail most sql questions now, but give me access to google and I can answer questions like this in seconds. Much more interesting questions could focus on code quality. I personally use tdd for my projects, and this practice alone leads to much better code that is maintainable and easy to read. I'd also pick up the vast majority of bugs caused by the odd thing I don't know off the top of my head along the way. These questions are bad and are written by amateurs who think they're better than they are. I pretty much guarantee their code is a mess when it comes down to it. When I give interviews, I give the interviewee a laptop with full access to the Internet. I've written a single question that tells me far more about how they can program than any of these daft questions, I wrote some code that queries a database, pulls a bunch of users out and lists them in a table on the screen. The code produces the expected output but it's deliberately poorly written. I then ask them what they think is wrong with the code, and how they would refactor it. The answers to this question tell me far more about how they program than any question in the style of the above. You know you are asking bad questions when the person getting them right could be a liability to your team, and the person getting them wrong could be a major asset. I'd get most of these questions wrong off the top of my head, but I'm 100% certain I'm a far better programmer than the people who wrote them,
I don't have time for spare time projects as a I have a family life. I would also not be able to answer most of the dumb questions the op mentioned. I am however, a senior dev for the BBC, and prior to that spent 4 years as a senior dev for EA. I've written pages that have been seen by over 100 million people, and I can code rings around most people. But yet if you asked me those daft questions and judged me on that criteria, you'd be thinking I wasn't good enough. I've proven I am on a massive scale too many times - this just shows how terrible those questions are. I'd also be telling you I don't write programs in my spare time oh, and I expect to leave at the expected time every night too. I'd probably "fail" both interviews. Yet if you had me on your team I'd be a major asset and would dramatically improve the quality of your code. If the questions you are asking can rule out people of my experience and ability, you're not asking the right questions.
I can't help you with point 1, but for point 2 you should be able to set a width and omit the height - this will allow the height to be scaled automatically as required on a per image basis 
PHP has function scope, that's why
It's my understanding that threading already exists in the core, but hasn't been exposed to userland except in third-party extensions. If you require threading, have a look at the pthreads PECL extension. 
&gt; But those questions still don't tell you anything. They most certainly do. They're telling me exactly what I outlined in my post, and that is real, valuable information for a business. *You* may not value it, and you may not value it *so much* that you wish to insist that it delivers value to no one, but unfortunately or fortunately, you don't get to decide that for everyone else, and you can't bend them to your will. For the company in question, these are appropriate, and are written by a group of people who are trying to achieve *their own goals* rather than a goal that you deem appropriate for them. &gt; I'd get most of these questions wrong off the top of my head, but I'm 100% certain I'm a far better programmer than the people who wrote them, Unfortunately, you cannot demonstrate your competence in this test, so the company will drop you and lose nothing, because of the 100 other candidates who are just as good or better AND who can also pass this test. This was the point of my post. Of *course* some guru will exist who cannot answer the questions, but so what? Companies don't do interviews to find the exception to the rule. If a candidate can't demonstrate how good he or she is via this test, the job goes to someone else who is as good or better AND they can answer the questions. It's not enough to be good. You have to show it. Are the questions the ultimate in determining perfect candidates? No, but they're fine for a screening. Afterwards, they can take the dozen that make it through and do all the other stuff you insist is better -- asking more in depth questions or whatever. But they're not wasting hard questions on everyone, only the few who pass.
Hey /u/mnapoli . Nice :-) . The one drawback I find with gh-pages is you always need to fire and push to gh-pages. How are you versioning the docs ? In this approach the docs are read from the tags/ branches. Things are cached so hopefully it should work well. I was having something in mind when trying out this. How to render different repos documentation from a single place. Eg : The aura docs are in different repos, the website was in auraphp.github.com rendered via jekyll. Either we need to duplicate the work on both repos for documentation or at some place there will be no documentation. So the basic idea was to bring all the documentation to single place. Not sure how far it can be achieved. This is just a trial without discussing with /u/pmjones :-) . Experiments! ;-) . By the way see the book rendered http://ghdocs.herokuapp.com/harikt/aurav2book/master/manuscript/index.md ;-) . Need some what better navigation. Thinking about it.
Yes, which is why these questions show you nothing. In order to "show I'm good", I first need to be asked questions that can allow me to show it. Syntax questions and questions regarding specific functions are not the answer. Ask me about how to structure a program, or better yet, ask me to write a small program that lets me show what I can do. Questions like this are what amateurs with more confidence than ability write to test people. I've written questions in the past far superior to this, that will actually give good programmers a chance to stand out, and the poor ones who may happen to be able to answer the ops questions, fail and fall by the wayside. These questions tell you nothing, they are bad questions. Edit: &gt;Unfortunately, you cannot demonstrate your competence in this test, so the company will drop you and lose nothing, because of the 100 other candidates who are just as good or better AND who can also pass this test But that's my point. They WOULD be losing something - they'd be losing an excellent programmer who would improve their code base and raise the quality of their product in volumes. They would not know this because they are asking bad questions that can allow inferior programmers through - that's my entire point. They are asking questions that can mark poor programmers as "good" and excellent programmers as "bad". Terrible questions.
&gt; Yes, which is why these questions show you nothing LOL. OK, you're just going to keep repeating this. I'm done. Thanks for the discussion.
Yeah this would be my way to go too: * create a partial view with a foreach loop that itterates over all the urls and sets them up in the src-attribute of an img-tag (gallery.blade.php) &lt;div id="gallery"&gt; @foreach( $urls as $url ) &lt;img src="{{$url}}" /&gt; @endforeach &lt;/div&gt; * Create a route that calls makes use of the flickering api (instantiate, handshake, call methods, get response object [lets say it has urls to phtos]) Route::get('/call-to-flickr/{params}' function($params) { // do stuff with parameters $flickering = App::make.... $flickering-&gt;hjandshake()... // use parameters below $flickering-&gt;callMethod()... $results = $flickering-&gt;getResults(); return View::make('gallery')-&gt;with('urls', $results); }); * Call the Route via AJAX (with jQuery or vanilla JS) $.ajax({ url: //call-to-flickr/foo, }).done(function(){ /* append partial view to DOM somewhere you like */ }); Sorry I'm on the phone so I have a hard time to markdown properly
As I just edited in my above post: Edit: &gt;Unfortunately, you cannot demonstrate your competence in this test, so the company will drop you and lose nothing, because of the 100 other candidates who are just as good or better AND who can also pass this test But that's my point. They WOULD be losing something - they'd be losing an excellent programmer who would improve their code base and raise the quality of their product in volumes. They would not know this because they are asking bad questions that can allow inferior programmers through - that's my entire point. They are asking questions that can mark poor programmers as "good" and excellent programmers as "bad". Terrible questions. Yeah, I'm sorry, but it sounds like you're one of those poor programmers with an inflated sense of his own ability. I've met the type. They are the type who write questions like this. To put this into perspective - I am a senior dev at the BBC. I've been there for nearly 3 years now and have written pages viewed by over 100 million people. I've written excellent high quality code that scales, can adapt to changing circumstances and passes all the internal code reviews. I've trained and mentored less experienced developers with great results. Prior to the BBC I was a senior dev for EA and had similar luck there. I've improved every product I've worked on, and if you ask me to code up a program for you I can more than prove it. Yet these questions would rule me out at the first hurdle because I wasn't able to answer something off the top of my head that I could have googled and comprehended in less than 1 minute. It's you, my friend, who is doing it wrong. If a programmer that could raise your game and improve your product can be labelled as "not good enough" by your questions, and an inferior programmer who would write sloppy messy code that slows everything down can get through, it means it is you who is doing it wrong. Final edit: Yeah, I'll keep repeating it. It doesn't stop being true because you keep saying "no".
On the same note, the documentation should be free. I recommend using https://www.gitbook.io/ I should be very easy to move the current content to a GitBook
*sigh* Just when I thought I was out, they pull me back in. I'm really wanting to answer this as nicely as I can, but I'm having a hard time. Maybe someone else can jump in. I'm too frustrated. Here's my best shot: &gt; They WOULD be losing something - they'd be losing an excellent programmer... ...and *it doesn't fucking matter* because you are not a special fucking snowflake. There are a shit ton of others just like you, and you can be replaced. It doesn't matter that they lost an excellent programmer because *they still got an excellent programmer.* &gt; It's you, my friend, who is doing it wrong. You know what? Let's assume you're right. I'm doing it wrong. Hey, so is the company that the OP is frustrated about. So is the company that frustrated me in my first post in this thread. Oops, that company was Google. So, yikes. We now have big fucking companies who are doing it wrong. And there's a fucking ton of them. So you're right. You win. But you still didn't get the job. Have the moral victory. I'll take the paycheck.
Probably not much different than a do { }.
Can't be arsed with this. This is the final thing I will say on the subject: when I interview developers, I'm highly confident that I'm able to find out how good their code is, how maintainable it will be and how well they will do technically through the questions I ask them. People who won't do well are weeded out. All of the interviewees I've hired have done brilliantly, so I'm doing something right. And now I'll just ignore your responses if you're just gonna keep going round in circles. Good day kind sir.
Yep if you want to gather documentation from several repositories then I understand you building that ;) &gt; How are you versioning the docs ? The docs are in the repository, alongside the code. That way it's versioned with the code. So if I `couscous deploy` while I'm in master for example, it will deploy the documentation that is in master. For example PHP-DI's website runs with this: - a Markdown file: https://github.com/mnapoli/PHP-DI/blob/master/doc/getting-started.md - the online version: http://php-di.org/doc/getting-started.html
If you didn't go to PHPNW14, have a look at u/irxmaxell's slide deck on high perf PHP. Goes in to the basics of compilers and different PHP runtimes. http://www.slideshare.net/mobile/ircmaxell/high-performance-php-phpnw
Q: what are the sizes of your databases? Our prod db is 300mb zipped, 1.2gb unzipped (I think). Our FS is 20gb+. Running a full stack for Development is futile. What I did was take the prod db and shrink it to the bare bones, leaving a handful of test products. I dumped the DB and committed the file to git. It sits at 4.5mb unzipped. My local Dev runs the latest Debian GUI, which is the same OS on Production. All development happens in here (Virtual Box inside windows, because spotify). I've tried to match software locally as close as possible to prod. The only thing I can't match locally is the shared NFS, and the effect the loadbalancer has on local cache files. Other than that my local dev is a solid match for prod, and I have very few dev to prod failures.
Yeah, this is the wrong way to test, in my mind. strstr and stristr are basically the same str matching function, but optionally ignoring case sensitivity. But fundamentally, if an interviewer is asking you to memorize the manual for a language rather than show you know programming concepts (even in pseudocode), they're doing it wrong.
1) retarded 2) could be useful, you should know your numbers 3) ok, could be useful when using query builders or ORMs that map something into NULL 4) retarded, php has great documentation of string functions... who the fuck learns those by heart?
Why giving you those retarded questions instead of real life scenarios? Idiots!
Have you turned errors/exceptions into allies when it comes to debugging a big project? From my experience, I can see that the team makes use of try-catch and throws expections here and there, but this is completeley not standardised. We maintain a few big applications and don't have a direct access to deployment servers (infra team does). I'm looking for a way to improve the software quality and make life easier. Are there some patterns for triggering/stroing exceptions/errors ("the right way")? For example, I think that logging informational msgs would provide a good trace, but after few hours of QA testing, the file used for storing logs would grow to couple of GB. Another basic question - should I use trigger_error() or base everything on throwing exceptions? The amount of ignorance around this topic in our team makes wonder - is PHP lacking something (like a good toolset for error logging) or do we miss something important that can be a great help in the end.
It needn't be hard to be honest. I develop everything on (W|M|X)amp internally and then push to a private Bitbucket repo. I then use DeployHQ to automatically deploy my changes on the repo to the staging/live websites (staging is done automatically upon commiting, live is a manual process, just in case.) Databases are usually handled using migrations of some form, i.e. Laravel's migration.
Yes, I was looking for different versions support for documentation. Think version 1.0.0 came, 1.1.0 came, users may be interested in specific document than to read 1.0.0 or the master which don't have all the ones. Thank you for your time /u/mnapoli .
By the way /u/mnapoli I did rendered the http://ghdocs.herokuapp.com/mnapoli/PHP-DI/master/doc/getting-started.md and was able to read through the 3.x branches docs :-) .
yeah
I agree completly! In this case by weird I mean intentionaly confusing or not very practical. It was around 5 years ago, so I don't remember the specifics, but you had 4 answers and you had to choose the correct one. They presented me with css code examples that usually had some small errors in them (ie. list-style-position: outside vs list-position-style: outside vs list-position: inside). After doing half of them I honestly felt like I was going insane. I was interviewed by two people - on was sitting next to me, asking additional question, another, one was quiet and just taking notes. 
How do you create a UNIX Socket, and connect to it? I have a PHP sockets now running as a service, and it uses socket_connect to connect to, if I understand correctly, a TCP socket. However I'm told using unix.sockets is MUCH faster and more efficient. So until I get down to learning node.js, I would like to change my socket servers over to unix sockets. Right now I have one for chat which stores all chat it receives, and when a user calls for it, it sends new messages back to them. It posts to the database when a user sends a new message to the server. Can anyone give me an ELI5, or a good in-depth tutorial on how this works? It's funny, I work for a Web Development company as Quality Assurance, and I asked the developers here and no one has any idea how, haha.
&gt; PHP however does not obey to this rule, something I just found out by running it. Well I'm not hiring you then. See the hypocrisy and stupidity of the questions? Personally I would want a company to test me on my actual, *real world* knowledge, not some high-school trivia questions about octal/binary, syntax, etc. Whether you answer any or all of these questions correctly, they do absolutely nothing to determine what kind of developer you are. And that should be the aim of the interview questions; to add supporting documentation and evidence showcasing your knowledge, problem solving abilities and experience *in industry real-world applications.*
There's a difference in intent between errors and exceptions. Exceptions are thrown and intended to be caught. Errors on the other hand are not normally intended to be recoverable, but are primarily used for logging and halting further execution of your script. For the mostpart you'd want to use exceptions. To trigger an exception, you simply write `throw new &lt;Exception-type here&gt;`. I'd also recommend throwing an appropriate exception type rather than an instance of the general `Exception` class. For specific types, see the [SPL Exceptions](http://php.net/manual/en/spl.exceptions.php). To catch an exception, you simply write a catch block. You can also write multiple catches to perform different actions based on different exceptions: try { someFunctionCausingAnException(); } catch (SomeException $e) { ... } catch (SomeOtherException $e) { ... } catch (Exception $e) { ... } Any uncaught exception will bubble all the way up and cause a fatal error, halting the execution. You can set an [exception handler](http://php.net/manual/en/function.set-exception-handler.php) to catch and log these unhandled exceptions. If the file size of your logs become a problem, you could try implementing a buffered log (a log of a specific size) or implementing [log rotation](http://en.wikipedia.org/wiki/Log_rotation). If you're using logging to debug your code as you work with it, you might be better served by a proper debugger, such as [xdebug](http://en.wikipedia.org/wiki/Xdebug).
I see where you're coming from. Again, if I were an interviewer, I'd leave these as "bonus" questions after having asked him real questions that actually have something to do with the position he's applying to. I wonder if that was OP's case as well ? With that being said, I am not a professional developer nor am I an interviewer, so everything I said should be taken with a grain of salt.
Nice [press releases](https://www.reddit.com/user/Geeksforphp) you got there.
&gt; I manage/inherited a Joomla/Magento hybrid In case you need it /r/SuicideWatch 
I like to play a fun game in interviews which is that when it comes around time for me to ask questions, I ask them questions about the questions they asked. Things like "so how often in your code base are you using random code brackets, and why? Where are you using octal and what was the problem being solved?" Employers ought to prove their technical knowledge as well.
&gt; However the lead dev wants to create a map of templates and route uri's and have one function that maps those incoming routes with the templates in this array So the lead want's to reinvent the wheel and implement his own routing over what's built into symfony which can actually do what he wants anyway? You can add params to symfonys route file to the specific template needed, then write a generic controller and do as he asks. And when it comes to routes that need their own controller, then you'll just need to implement a non generic controller for it. plain as.
Whilst his reply was perhaps mostly unhelpful, he's got a point. A not-so-big-secret about web development is that *all* implementations of "MVC" in the request/response web application framework context have no relation to the original MVC pattern which was first used with smalltalk and to describe a pattern for developing user interfaces. It's a problem that has been wrestled with by web developers for a very long time. As best I can tell Rails popularised it for the web but really didn't implement it according to the pattern (because it would be borderline impossible to do so). Queue many years of [Semantic Deffusion](http://martinfowler.com/bliki/SemanticDiffusion.html) and the pattern name "MVC" is now pretty well useless. There are more recent attempts at describing the pattern we actually tend to use for the web - ADR, Command Pattern, and others. If you are interested in seeing something in modern web dev that works more like MVC, go check out something like ember-js, or cocoa (os x - edit: obviously not for writing websites...). These are more in keeping with what the original pattern intended. So yes, the ASP.NET MVC 5 guys **are** getting it wrong, technically speaking. And naming your framework after a pattern is potentially bothersome, if for no other reason than if you wish to adopt a new pattern, or chose a more appropriate name for the pattern you are using you end up with a difficult conversation.
I find that I do not really need to do this since I create my environments in a vagrant box.
[This example of wiring to Silex](https://github.com/reactphp/espresso) might be helpful, but it might be a big task to apply to Laravel.
Why do fancy pants coders often name there variables with a preceding underscore? $_query = '';
Have you considered using the FrameworkExtra Bundle, so you can create routes from the annotations on the controllers themselves? That makes it a little bit easier to make routes, and might sway them your way.
I think using "coupled libraries" in you code is not necessarily a problem at all. &gt; if you have to swap one out in your own code, you only have to worry about the one library, not about all the dependent libraries that it is coupled to (and all the dependent libraries they are coupled to). I mean if you use library A that is coupled to, say, Guzzle (it requires Guzzle to operate) and later on you decide to change the library A - if all is well, you don't have to worry at all about Guzzle, as it is hidden inside the library A (only A uses it as needed, you code is not touching Guzzle). You just swap A for something else and thats it (in terms of worrying about anything that's inside A). Having such tightly coupled libraries allows the libraries to be "plug-in" and they just work (in cases where something "completely different" is needed by the library, and making it work using a separate package makes sense, under the hood).
I love PHP in a special way, I really do. However, projects like this leave me asking "why?". There are so many things that already do this, and enough that do it better than I can concieve PHP ever doing it. (PowerDNs, BIND, etc.) I fully advocate projects like this as an academic exercise, but I truly hope that nobody uses it as a mission-critical component of their business (which is often what authoritative dns servers.are), which I can totally imagine happening. In most cases I recommend that nobody even host their own dns and just have it done through cloudflare, or maybe even some other large provider such as aws, rackspace, or even godaddy.
&gt; In reality, I'm a google aided problem solver. lol I work in IT and that amused me more than it should. I too am a Google aided problem solver. 
It was the way to mark class property as private before visibility modifiers were introduced in PHP (PHP 4.x and older). Some programmers still use this method, however PSR-2 standard disencourages that: &gt; Property names SHOULD NOT be prefixed with a single underscore to indicate protected or private visibility.
Yeah we did do a few prototypes, of three methods. His, mine and one in between. But the single function method took hours and it still didn't meet the requirements. Whereas using annotations and separate functions took minutes... And of course were readable, clear and easy to test. I think he would adopt whichever works best, he's very democratic, but we're just all at loggerheads over this one haha. Thanks for your help :)
So if I'm not wrong your lead wants to do something like this?? https://github.com/Sylius/SyliusResourceBundle http://docs.sylius.org/en/latest/bundles/SyliusResourceBundle/index.html 
I would say coding a simple interface would be the best approach however, if you didn't want to do that then my suggestions would be: * [sqlbuddy.com](http://sqlbuddy.com/) * [adminer.org](http://www.adminer.org/) * [phpMiniAdmin](http://phpminiadmin.sourceforge.net/)
&gt; You just swap A for something else and thats it (in terms of worrying about anything that's inside A). This can still be an issue if Library A leaks the an implementation of one of it's dependencies. Presumably, a well-engineered library would use an adapter, but I've seen a number of cases where that doesn't happen. Likewise, if you leak the implementation details of a particular package, you risk running into issue when you want to swap out the package at a later point in time.
Haha, yes :-), we are totally agree. This was an academic exercise at first, now this is just a tool to deploy development (such as debug) tools quickly and easily. And it perfectly fills such a role. But we are totally agree to not use this tool in a production environment! I personnally use this tool as a I said but [in CLI](http://hoa-project.net/Literature/Hack/Dns.html#In_command_line): $ hoa dns:resolve 'foo.*' to 1.2.3.4 '.*\.bar\..*' to 5.6.7.8 It helps a lot, particularly when testing (in my case).
AngularJS looks pretty awesome any chance you would be interested in this tiny project :) the db will only have one table with 10 fields 
Ha! I have a server on my network that all the devs used called devbox. The biggest difference is that I hook my staging environment to the production database rather than a snapshot. It's actually sitting right alongside production as a virtualhost. My thought process is to get staging to resemble production as close as possible.
Oh yeah actually, kind of! He was referring to just routes and calling an external API. This is like what he was referring to plus so, so much more. I think if we were trying to cut down duplication in all these other areas as well, it would be worth emulating this for sure. But it's just for routes so far (of which there won't be many of), so it hasn't felt worth it. I will take a close look through all this though, see if I can find some other uses cases or compromises I can draw from it. Cheers for the link! 
AngularJS is pretty awesome, I have way too little time to work on stuff like this unfortunately :)
And seeing as Github are apparently incompetent and can't provide read-only access to private repos, even then there's no way I'd give someone access.
This problem has been solved in a software-agnostic way for quite a while now. I wish everyone would stop making these "language version managers". See http://modules.sourceforge.net/ 
ServerA is a public facing server collecting sensitive data. This data needs to be consumed asynchronously by a server on a private network. ServerA cannot connect to ServerB, however, ServerB can connect to ServerA. 
Great article - it strikes a balance between the two extremes most other compiler articles hit, where it's either so dumbed-down that I learn nothing useful, or so detailed that the only people who could make sense of it are those who wrote the original article itself. I think this would be a great article for PHP devs looking to learn more about VMs in general.
Yes Wordpress solves business problems. There are millions of examples of poorly designed code that solves business problems. Just because it works does not mean it should be praised. Wordpress has chosen to value backwards compatibility over innovation and architecture. This has advantages when it comes to holding on to and gaining market share. It does not, however, mean that new programmers should look at the internals as examples of how to build new systems.
That's because if you understand programming logic and are able to read documentation, there is no reason not to be able to. I use plenty of PHP functions nearly daily but I still have to reference documentation, because, uh, that's what it's there for.
Which, of course, why not? That's what we are going to do in the real world. Half the time I can't remember which parameter is the timestamp or the format string in the date() function, but it's not something I couldn't figure out in a matter of seconds. That doesn't mean I can't build functional code.
Well. Still if you have two developers that answered all the other questions the same, you'd still lean towards the one that ALSO has the textbook answers? no? And actually knowing about braces in PHP isn't that textbook. 
These are really bad interview questions -- *unless* you stated on your resume that you can parse and execute PHP in your head.
So long as they can do more than just know textbook answers, probably. Being able to answer questions and build functional code are not strictly synonymous though. I'm bad at answering questions, especially during an interview, but everything makes sense in my head. It's getting others to believe that I guess I struggle with, until they work with me. I've been a PHP dev for over 8 years and have never used braces like that. I guess I never had the need to or worked on code that did.
Index.php and Notepad, make me feel like I am in the 90's
That's exactly what I said: these questions are for extra differentiation. Obviously they arent viewed as primary
Yes, I wasn't disagreeing with you. Just elaborating I guess. I talk a lot, so I type a lot.
"available svn versions" WAT svn? :|
&gt; The biggest difference is that I hook my staging environment to the production database rather than a snapshot. It's actually sitting right alongside production as a virtualhost. My thought process is to get staging to resemble production as close as possible. Uhh .. well .. it sure is *close*, I guess.
Can you explain your reasons for not wanting to use git on your servers?
The only thing to add to this is to use a migration system for your database, and run migrations when the code for them goes out.
You didn't answer my question though. Does the payload actually have to be encrypted to be used? You said server A is collecting sensitive info. Is that already using https? If the only reason you are using encryption is to transfer the payload from A to B, then why not use the existing encrypted pathway (https) to do that for you? Why go through the trouble of encrypting a payload for transport if the transport is already encrypted? Is Server A your server? Is Server B also your server? Is the connection from A to B trusted? Either via internal network or some other means. I presume you are putting code on both since you have access to create an openssl data and key file on one that gets consumed on the other. Why go through the headache of adding a PKI infrastructure when you don't need to? Edit: [Someone else said what I'm thinking](http://www.reddit.com/r/linuxadmin/comments/2hk3yp/open_source_gui_for_haproxy/ckvk7va) Unless you are doing all this work to learn how it works... then go right ahead. 
Apparently /u/krakjoe would say that the "thread safe" argument isnt true, after some research
How can I send more complex data to the client such as arrays?
This is part of the point I was trying to get at, thanks. As Ed Finkler says, "More code, more problems." The more "other" stuff you bring in, the more potential trouble you have.
Transit from ServerA to ServerB is not the main concern, the data cannot be stored on ServerA in plain text. ServerA runs a publicly accessible web site. It needs to temporarily store sensitive information to be picked up by ServerB. If the data was stored in plain text on ServerA and the server was compromised, the attacker would have access to the data. By encrypting the data before placing it on the file system (or msg queue or whatever), this will ensure that the data is safe even if the server is hacked. Granted, they may be able to alter the code to get the data before encryption, but this can be caught through auditing. If you're dealing with people's personal information, health data, credit card numbers, etc, don't leave the data sitting around unencrypted on public facing web servers. 
Pretty off, but still related to Hoa: Using http://hoa-project.net/En/Literature/Hack/Websocket.html how can I send more complex data such an array to the Clients instead of just a single string message?
The only real reason outside of personal preference to choose any of your listed frameworks over another would be market demand. If you're trying to increase your employability today, it probably goes : code ignighter, symfony, zend. In a year? Laravel, symfony,code ignighter. If you want to up your hip stats, laravel, symfony, go kill yourself. I usually make these kind of choices based on the level of activity within the user community. But then other times, it may be that I simply like the way it's written (aura, laravel). Basically, do what you want. No matter what you choose, someone on reddit will find a way to bash you for it. May as well use what makes your life easiest, and hit the ground running at that point. 
Spotify have a Linux client.
If you need to manage data between dev-staging-production environments in a Magento project then you may be interested in [MageFlow.](http://mageflow.com)
Can you give us some more info? Like which element, what have you tried so far, etc.
Do you use CIFS and folders for version control?
You do not want to accidentally nuke a production server by hitting a git hook. You want to make sure everything on staging is running along nicely, and have a [big "Lunch" button](http://bookofjoe.typepad.com/.shared/image.html?/photos/uncategorized/2007/05/22/jojokok.jpg) to start your rsync script. 
&gt; No matter what you choose, someone on reddit will find a way to bash you for it. TRUTH
Serialize it
Spotify ? 
If Symfony 2 is like Zend Framework 2, then I'm not going to use it.
No clue, haven't used ZF2. Just know theres a lot of jobs for both frameworks doing similar projects. SF2 was hard. But the more you do it the better it got.
&gt; Transit from ServerA to ServerB is not the main concern, the data cannot be stored on ServerA in plain text. OK.. you never mentioned that before. JWT will still encrypt it for you if you include a secret.
BUT, because the learning curve is so obtuse, there's good money in being a Symfony 2 dev (assuming you can find places that are using Symfony 2 and are hiring). But for your own personal projects, then Symfony 2 is likely unnecessarily cumbersome.
There's some overlap in features/solutions provided, but phpbrew and environment-modules seem to provide different sets of solutions. environment-modules does also provide the ability to switch between different versions, but it doesn't provide seem to provide too many other features (like downloading, installing, and configuring the modules). Its TCL-based [modulefiles](https://github.com/edf-hpc/environment-modules/blob/master/modulefiles/modules.in) provide its configuration, but may be a bit unfriendly to most PHP developers. On the other hand, phpbrew probably doesn't have the same level of work to make sure some things work in multiple shells: manual pages, library paths, conflicting commands, etc. Are those things important for a PHP developer? Are they important for Ruby, Node, Python, or Java developers? It may not be too complicated to manually download, configure, and compile a specific version of PHP. Perhaps it wouldn't be too bad to write and install the TCL modulefile that will modify the appropriate environment variables. Perhaps, for some, there's room for a tool that downloads, compiles, and configures a php installation with one command. tl;dr phpbrew offers some additional features (downloading/installing/configuring) while not requiring knowledge of TCL, compilation options, and system-specific details (like search paths and library locations). 
&gt; Symfony makes your fingers bleed why?
&gt; friendly community with eachother, it should be pointed out. As can be said with most communities 
CI has more market demand than symfony/zend? i had no idea....
&gt; Top news sites like The Washington Post and Bloomberg Politics (released today) receive their strength from WordPress. WordPress VIP. Which I highly doubt the codebase for VIP (which is closed source by the way) even resembles a hint of the codebase that is WordPress that we all know.
I think that's what "ZTS" is, but most installs do not come with that enabled.
Nobody can give you an answer to that question because nobody has ever used more than one framework. The rule is that you must write one app with some framework that is currently hip and then evangelize how much better this framework is than all the others without actually knowing any of the others. The only way to really know the real differences between two or more frameworks would be to write a rather substantial app in both or all of them and maintaining that app for a couple of years. There's room for making heroes here... but not gonna happen.
Yeah, but why not recommend a provider that doesn't regularly fuck people over ([A Small Orange](http://asmallorange.com/) for instance). There argument doesn't have to be "go it alone or choose godaddy", it could be "go it alone or go with a provider that can handle your needs reasonably".
Better than learning Pascal in college though! 
A bug in one of the last version of Laravel. If you try to delete a row with the ORM, it was deleting all the rows. It was on r/php 2 days ago. 
CI is antiquited. I use Yii2 and Laravel, that's where it's at these days. Pleasure to work with! 
HAHAHAHAHAHA.... ^^ok, ^^thanks
That is a horrible idea dude. You should avoid the `mysql_*` functions at all costs
I think he's referring to the fact that [the "mysql_" extension has been deprecated](http://php.net/manual/en/function.mysql-query.php) and that PDO or mysqli are the recommended extensions to use now. 
Yes, and no. Twig and blade are meta-languages built on-top of PHP and parsing them do have a bit of an overhead. However, after being parsed once a cached PHP copy of the template will be stored, saving the need to parse them again. So yes, the initial pass will be a bit slower, but subsequent calls will be as fast as PHP (since it is PHP). 
\*yawn\*
I've always wondered how one might properly stop implementation details from leaking without getting buried in adapters. The main culprits seem to be arrays and objects returned through method calls. For example, if use Symfony requests or sessions, then you basically are going to get Symfony's message bags as return values. Sure, you can technically make your code depend on an interface for instantiation and injection, but you'll still need to write potentially a dozen of adapters to adapt not only injections, but outputs as well. When half your code is adapters to satisfy just a single implementation, and you have to write just as many adapters to satisfy another implementation, then I would argue that decoupling is almost counter-productive :/
That is indeed a twitter shit storm (shitter twit storm?) Brandon Savage's comment I think was unnecessarily inflammatory. 
&gt; When half your code is adapters to satisfy just a single implementation, and you have to write just as many adapters to satisfy another implementation, then I would argue that decoupling is almost counter-productive :/ Depends on where the decoupling is. If it's in your own code, in the situation you describe, it might not be such a great idea. But in the packages consumed by your code, it might make sense to pick decoupled ones. (Notice the "might" in both sentences. ;-) Tradeoffs, tradeoffs. 
You probably meant http://phpthegoodparts.tumblr.com/
Maybe you should use hooks for deployment then ... 
You actually didn't give a reason. *"You shouldn't use git on production box because you shouldn't"* is **not** a valid argument, ya know.
Unix sockets are local only. Typical example is that mysql will start up a TCP socket (127.0.0.1:3306) as well as a UNIX socket (/tmp/mysql.sock or something). If you are on the machine running mysql, you can connect to the UNIX socket via the client and not incur any TCP overhead (and a few other bits). However, no one from outside that machine can connect to the socket -- it's more like a virtual file than a TCP socket.
harrumph.. thats what I learned in my first class in college.. :)
It'll be interesting to see how CI straddles the post-Composer era and what the steering committee come up with for a roadmap.
 __halt_compiler(); Quick DNS resolver. Why?
It might be worth to consider including a third server, used only for data encryption/decryption. This third server must be only accessible from server A and B (A can only use it to encrypt data, and B can (possibly) use it only to decrypt data). If the public facing server gets compromised, it can not be used to decrypt the data. The encryption server encrypts data given from server A (using, say, AES-256 HMAC-SHA-256 encrypt-then-mac) and returns the ciphertext. Server A only stores the ciphertext before it is transferred to server B. When server B needs to read the data, it sends the ciphertext to this third server and receives plain text. This way you have another layer of security (i.e. it is not a game over if server B gets physically stolen (as long as it holds only the ciphertexts and does not save plain texts stored on disk). Also worth to note that introducing this "third piece" may affect availability of the service (i.e. if the encryption server is down, then everything is halted). Anyway, it is important to not allow the public facing server to decrypt anything (whether this is achieved via this separate "encryption server" or public key operations).
Me too, fellow Pascalite 
Me too. We should make them a list! 
Look into capistrano, you might find it as promising as I do. 
Namespaces would be a start. Proper autoloading too..
I'm one of those few, who dislike composer. Seriously, why? why?
Better database migration would be my preference.
I wouldn't say Phalcon or Yii are "hot".
Why would you dislike Composer? It literally makes development in PHP so much easier. 
&gt; Laravel is only good if you write tests for deleting users Hahaha, somehow I feel responsible for this! :-)
&gt; Their impressive BCIT School of Computing and Academic Studies teaches CodeIgniter to 150 students a year. I feel so bad for them...
Oh..well, they shouldn't expect you to catch little errors like that. That's what your IDE is for. Sometimes the quiet one is taking notes on the other interviewer, not you. This happens a lot at big companies.
Yeah...that's my point. The `i` is obvious, I just don't know that they would accept "one is case insensitive, the other isn't but I don't know if its performing a search or what its return value is or what its args are"
Because i like to know what i have, and organize everything to my taste. Creating a json file, and then running a program that goes and download everything (gods know how many sh*t!) and puts there, on some folder he wants.......it's superior to me. I know i'm damned, and i'll probably use it, but i still don't like it and can't see the real benefits. Can you tell me the benefits of using composer?
Well it's conceivable that the OP mis-stated the question, but that is the question asked. Not "what does strstr do?" but "What is the difference between these two?".
Do you like committing all your dependencies to your repo?
I can't tell anything from that page. If you have a link to the source, and ideally the sire with some test posts / pages on it, I might be able to point you in the right direction.
Someone will laugh like me at it. Sound so funny in my mind. Edit: You are one of those. Obiviously.
Good point thanks, I've added a screenshot on the home page (and on the README on GitHub too): https://ci-status.com/
What kind of organisation are you looking to do with 3rd party libraries &amp; dependencies? The benefits of composer are that it downloads all the stuff that your app requires but you didn't write (or that you did write but is a separate library). Stuff that other people update and you want to click a button to get the latest bugfix. Do you use autoloading? Because that's one of the biggest advantages, no-config autoloading. How do you currently manage your dependencies?
I know that sucks :( Apparently they are working on it. We tried to be as reassuring as possible on the homepage.
It's enabled on Windows. I can't remember why, but there's some reason we don't enable it by default on other platforms.
I'm not necessarily a Laravel fan either, but CI _is_ outdated. No Composer, no real autoloading, no namespacing, no dependency injection, not really testable. Things like that. CI was great in it's day, but they've stayed behind when PHP improved. Other frameworks are simply more modern, with regards to best practices. 
It handles your dependencies better than you could ever hope to manage them.
I laughed :), Kinda like sheeples
trololol
Even then, its still slower than pure php/html, as its a whole nother class/file to load in, but, very very very very minimal.
Outdated doesnâ€™t mean that encourages tons of bad practices. I personally found CI pretty cool and clean and perfectly suitable for teaching the MVC paradign and simple patterns.
What's the benefits of apt-get on debian? What's the benefits of gems in Ruby? What's the benefit of npm in Node.js? What's the benefit of any package management system? Using Symfony HTTP Foundation and find out there's a bug somewhere and you need to update... But wait, you hadn't downloaded that tarball in a while, has there been some major changes since? But what if that package uses another package I have downloaded and stored in my precious location and it requires that to be updated? Oh lawdy I don't know what I am doing, lets spend the next 3 hours trying to make my stuff work again. Or `composer update` and worry about what matters, your application, not your dependencies. Plus autoloading bro. AUTOLOADING.
Guys I won't lie to you. Composer gives me such a broner. 
It's all going to be a string, but you can using a string formatted in such a way that it can be easily converted to a data structure by the receiver. JSON would probably be your best bet.
It just bothers me as a PHP developer that the community I love so dearly is stooping so low to mock users for using a framework. Sure Taylor has done some things differently and made people upset, but doesn't mean users of Laravel are wrong and using the framework is bad. I've built things in a lot of the major frameworks, I like parts of each, I dislike parts of many. No framework is better than another. (except any framework is better than CodeIgniter, as long as it uses up-to-date best practices and standards... PSR bro. P.S.R. gimme high five.) They all have their strengths and weaknesses, but they all can accomplish what you need. It's up to you to chose the one best fit for you and your project at hand. Hating on someone or singling them out because their choice of framework isn't your choice is detrimental to the community. We're all here for the same thing. Build kickass shit, and use gnarly tools that further the progress of our community and our skills. Bring it in bro, lets hug it out. 
I think it's worth mentioning that Codeigniter was a clean and minimalistic framework back in its day, that gave developers a huge boost in productivity and maintainable MVC code. I wouldn't use it anymore today simply because there are better and more up-to-date alternatives now. But by no means is CI a 'bad' framework.
Its not hating a tool per-se. Its just beacuse its pushed forward thanks to a strong marketing campaing without, IMHO, offering real benefits that others tools/framework etcc didnâ€™t already do. That framework just donâ€™t deserve that popularity.
I wouldn't say the project I used it for was small (around 15-20 tables, some of them containing a million+ rows), but I guess it's true that I needed to revert to writing raw SQL when dealing with the massive dataset (both for performance and because the data I wanted didn't translate to an active record). I'll look into doctrine 2, thanks!
Maybe the popularity is because it's easy as heck to use? I get a headache just looking at the setup of Symfony. I use Laravel because I can get up and going quickly, just like PHP. If I wanted 20 minutes of setup time, I'd go to Ruby or Python. 
But it's still better to teach something you can actually use. It's not really worth to start projects with CI.
I've worked with various programmers who were hired the way you describe - A senior-level asked me how to write an if-statement. A junior-level said it couldn't possibly have been her whose commit added \r\n newlines to the code. She was the only one using a Windows machine, but "I used touch to create new empty files on linux first and then copy them over to Windows before I start writing code." Perhps I expect too much from senior levels, let alone juniors. I understand not everyone can know everything, but the questions OP shared are pretty basic, and even a junior level should have some familiarity with the language used primarily in the position he or she is applying for. In fairness, the first question is probably a gotcha question, but the other three are perfectly valid questions. It's not as if the questions asked how PHP casts null and boolean values as array keys, how protected and private members are keyed when an object is cast to an array, or to identify EGPCS as the order super-globals are populated.
What is wrong with that? Its a good thing.... 
I've just launched a PHP/SQL application development tutorial for beginners, perhaps you'd like to give it a go? http://ilovephp.jondh.me.uk/ I'm a regular on Stack Overflow in the [php] tag, and I've generally found it hard to point PHP beginners in the right direction. Codecademy is good, but isn't enough to begin building applications. And PHP The Right Way is an excellent resource, but is too general and too complicated. Feedback on the tutorial is very welcome.
&gt; we all use code from other people, but to the point where you need a package manager Yes. Composer and other package managers do far more than simply download some libraries, and put them into a folder. You could do that yourself. Package managers handle the *entire dependency tree*. They download the libraries you need, and the libraries needed by those libraries, and the libraries needed by those libraries, and so on, and they do so in a version safe manner.
Symfony as excatly the same way to bootstrap a project... Iâ€™m pretty convinced that is by its campaing that attract beginner to mid devs without offering, again, real advanges. Is misleading and unfair. Its easy like any other frameworks if you learn how to bootstrap. Does not introduce any other simplification that werenâ€™t alerady in place. Except, maybe, for the use of vagrant throught homestead, but its not the framework. 
20min to setup Python? It's quicker to get up and running than PHP, and you have a more isolated environment.
In that case, perhaps don't use a framework. If it's for something small, why bother with one? They'll learn more about PHP proper by not using a framework. Also quicker to get into.
I'm not sure if I understand exactly what you want; but if you want to add text (like one dash) at the beginning of the text, you can simply add it: echo "&lt;td align='left'&gt;- " . $row['Producer'] . "&lt;/td&gt;";
I added some of that to CI...too bad I stopped using that pile of trash, lol!
You're assuming they use version control :p
People are missing this. At the time, it offered something that was just right.
I'd love to see anything written that is actually 100% de-coupled, I mean its all great in theory but we embrace the likes of composer for its packages that reduce the fluff (take that with a pinch of salt) you have to write. Yes, I agree its great to have the understanding and i'm sure it will be fun to have the time to write something that adhered to all the best practises in the world, but that rarely happens and even if it did it wouldn't last forever. When you decide to use a package, framework, class you've already made the choice to embrace it. Sure, with my future-proof-all-the-things hat on I could/should look at reducing the dev debt for future me/poor soul who takes on my stuff but that has to be balance with actually pushing the product, service or site forward. Maybe i'm just unlucky and most of my working experience has always seen getting things out the door and into the market being more important that worrying if in the future i'll want to switch out a dependency - man the product will likely pivot 10 times before that anyway and cause way more problems. But I do love to read them, really helps to understand concepts and pros and cons so I guess that's a plus!
You expressed an opinion that didn't bash on CI or praise Laravel. So you've been down voted into the nether. Since I posted this, we will dine in hell together. 
OMG, you're cute.
I haven't used composer in a project yet, and would like to get some experience with it but I haven't come up against a project that required more than one or two libraries (things like mail chimp's api, or paypal). Could you give me an example of some of the 60 dependencies that composer is managing for you?
As a BCIT student in the computing program taking PHP right now, this is pretty interesting. Don't really know what this mean for me but it is interesting to me nor the less. I have never used CI though, we were given the option to use any framework we wanted, I personally use Laravel like most of my colleges. Is CI a good framework and worth switching to from Laravel?
Emsai - that was exactly what I wanted... thank you so much Troymccabe - Sorry man. You're right...I flat out didn't read the side bar. I apologize.
I think I'm in a similar situation. We're in the process of moving to Amazon OpsWorks. This will take care if the replication of the production server for staging and development. We motivated to move here because we want it to be easy, fast and reliable to set up a dev server, even if it's just for a major feature release. Other than that our setup is pretty vanilla. Production branch and staging branches represent the virtual servers. We do mostly local development and test major features on a development server. Small changes go straight from local wamp to staging. Opted to use Beanstalk app over github because of price and deployment for minor sites. Using phpunit and selenium for testing. Lighthouse for tickets. I think that mostly covers it. 
In it's current form and my eyes no. It is rather old and outdated at this point. It's not a bad framework and was quite good back in the day. But PHP and frameworks have moved far beyond the current state CI is in.
I work with 3 environments: production, development and testing. I focus on backend coding and unit testing. I use the development environment along with a development database to create or fix features. This isolates the work from production environment where data are created by user who really care. I execute my tests using in the testing environment using a testing database and generally mocked services since it wipes pretty much everything on tear down. You want to keep your development data, so keep this isolated too. The production environment has specific error handling using error pages and is more fault tolerant. Most frameworks out there allow multiple setup based on an environment variable. I use Kohana, so that kind of approach is easy to implement in [the framework core](https://github.com/kohana/core/blob/3.3/master/classes/Kohana/Core.php#L22). Also, frameworks makes it easy to substitute services using configurations. If your app is hard to migrate, you will have a lot of problems. Technically, it shouldn't matter whether you app runs on a remote server or locally. I've dealt with app you had to dig in for hours before having anything running on a given computer. Code as less as possible and reuse code you thrust. Using a template engine like [Twig](http://twig.sensiolabs.org) is a very good idea as PHP ends up being way too verbose. Ugly code generally comes with bad software design: if you focus on code quality and design, you will get a good application and a nice programming experience. **TLDR**: Use a framework and stick with their best software designs and coding standards.
/u/adrianmiu documentation is free itself. No one is charging from users to read. And as it takes efforts to build one, it will be nice to support ie all :-) . No one is sponsoring the project, so we all do in our free times / the time that need to be doing something else :-)
And to make it clear, Wordpress only solves short-term business problems. In the long-term, it loads you up with so much technical debt that expanding upon it quickly adds up to needless expenses and instability. Once built a Wordpress site that had to integrate Constant Contact newsletter capture on registration, but display a specific form to do so. It also had to integrate with an ecommerce solution for digital downloads with silent registration &amp; newsletter signup on purchase (shitty, I know, but those were the requirements). And the initial transactional email for registration was sent out with Mandrill. To top it off, the page you registered from had change the wording of the registration form, and had to flag the Constant Contact API with a certain field value. That project also involved conditional behavior variation of the bread crumb trail, and a new URL structure that Wordpress could not support by default. There was also all kinds of other really complex sidebar/widget behavior BASED on the URLs, breadcrumbs, taxonomies, and content types that I had to do. It involved having to explain to the client why a plugin I had to use applied boolean ORs for tags/categories, and boolean ANDs for content. Literally had to draw Venn diagrams so the client could understand the behavior of a sidebar plugin. What took me close to 275 hours to implement using shitty Wordpress as a framework, I could have done in 80 hours in a real framework. That client built their entire online business on Wordpress, and if they ever want us to upgrade it or change it or add new features, it's going to be like a house of cards. Unless you are literally building a blog, and are perfectly ok living with the assumptions and constraints Wordpress puts on you, then there is no reason to use Wordpress. It will get in your way, and you'll never want to do maintenance work with that client ever again when you're done.
 &gt; They download the libraries you need, and the libraries needed by those libraries, and the libraries needed by those libraries, and... Fatal error: Allowed memory size of 536870912 bytes exhausted (tried to allocate 71 bytes) in phar:///usr/local/bin/composer/src/Composer/DependencyResolver/Solver.php on line 700 (but seriously, composer is great)
I haven't encountered that error before, but now it's my mission in life to make it happen.
I honestly had no idea that ASO was bought by EIG. I signed up with them when they were independent.
I was getting it all the time, without even a particularly complex composer.json file. [The issue is still open](https://github.com/composer/composer/issues/1898) so I guess it's not totally solved but I haven't had it since a few versions back.
Jeez, that's horrible. Composer really does need a lot of work. I mean, the *idea* behind Composer is great, but [it doesn't always work that well](http://www.reddit.com/r/ProgrammerHumor/comments/2ax96p/the_more_things_change_the_more_they_stay_the_same/).
Ha! The memory thing is the only real problem I've had and any time lost has been far outweighed by time saved so I can't complain.
Not sure if Phil Sturgeon is growing more level headed and less flamboyant or just being outdone by others now. He seemed like the only civil party in that Twitter debate. Hell is freezing over!
ORM or not, the proper way to handle database changes is with migrations. And if a migration system doesn't currently exist in your setup, well, you should still have one.
I've not had a chance to even start in that direction... Sadly...
Live is about 1.5GB unzipped, also(aside regular backups) seems to be the only solid record of all ecommerce transactions... Which was great when I found out that CS had been running some phone orders by hand through authorize and not marking it anywhere... and I got stuck trying to find why the authorize ledger didn't match ecomm and by how much... No dedicated accounting individual... I feel like whoever originally built this company decided to build it in reverse, "We're gonna sell our product online, we'll hire a product designer, customer service and management. Ecomm, Help Desk, and Finance will be last!"
Sure thing! So our app is a fairly large eCommerce website, originally written about 13 years ago in PHP4. Nowadays, the codebase is a nearly fully modern Symfony2 app running on PHP 5.5, however there are still some pages that are considered "legacy". A few libraries we utilize to make Symfony easier to use: * jms/security-extra-bundle * jms/di-extra-bundle To make building some user interfaces easier and quicker: * knplabs/knp-paginator-bundle * knplabs/knp-menu-bundle * friendsofsymfony/jsrouting-bundle * recaptcha/php5 * mopa/bootstrap-bundle * bmatzner/fontawesome-bundle * smarty/smarty (for those legacy pages I spoke of) We make heavy use of fixtures and migrations. Any commit in history can be checked out locally, and the database rebuilt and fully loaded with all necessary data required to run the site for that commit: * doctrine/doctrine-migrations-bundle * doctrine/data-fixtures * nelmio/alice Rest API support: * friendsofsymfony/rest-bundle * jms/serializer-bundle * nelmio/api-doc-bundle A few more helpful bundles we make great use of: * friendsofsymfony/user-bundle * sylius/taxonomies-bundle * sylius/settings-bundle * presta/sitemap-bundle * ekino/newrelic-bundle * lunetics/locale-bundle * oldsound/rabbitmq-bundle * doctrine/doctrine-cache-bundle * guzzle/guzzle * knplabs/gaufrette All of those can be found at packagist. We use a bunch others that are just too boring to list here. Of the 60 I referred to, about 10 are ones we've written ourselves. This lets us reuse them in other projects, as well as assign another team to work on and maintain those libraries. Our production website team can pull in the changes if we want to, by simply doing a composer update! For dev only, we use libraries such as phpunit, behat and other random debugging and code coverage type libraries. Everything installed, maintained and autoloaded by composer :)
Its kind of pointless. At that point you're looking at a framework rewrite because CI's core was focused on 5.2, if you want namespaces and all the nice 5.4+ goodies just use laravel/symphony. CI should be maintained for legacy issues and not used for any new serious projects.
Yeah, going from laravel to CI would be a big downgrade. Laravel takes advantage of numerous language features from php 5.3+ which CI could never do as it had to support the legacy php 5.2
Thanks for taking the time to list those out for me. 
I'm mostly solo at the moment for work related stuff, we're currently hunting for another to hopefully offload me so I can focus in one direction for once. I had been debating on starting on either vagrant or docker, and just started into puppet(without knowing Ruby :-/). Still fighting for some sort of a budget, but was thinking of switching off Puppet to Ansible since I see RackspaceCloud and DigitalOcean support, and use that for consistent development images.
Wouldn't you want to implement your own adapter layer to prevent this leakage from happening? That is, if you are using guzzle, you should have your own adapter layer that abstracts away guzzle, so when you do change away from guzzle you only need to update your guzzle adapter instead of everywhere you're using it. So if there is any leaks, it extends only to your adapter, and not further. 
Ok thanks, i just got into Laravel so I don't know a lot of what it can do i just thought I would go with it because it is so popular. Thanks
How about everyone stop bashing each other and just build cool shit together and help each other? You don't see Rails devs bashing Sinatra devs, or Django devs bashing Flask devs, etc.
I'm tempted to take my DockerFiles to create Debian PHP packages and adapt it to allow PHP-FPM to run in an isolated container, using the parent filesystem for PHP source files and expose it's FastCGI port back to parent host as well. Would make this sort of stuff really easy.
I hear this one all the time. They accomplish the organization of namespaces without them by nesting things inside classes. Whatever else namespaces give you as the end user, when they as the framework developers use them, I haven't noticed. I've used both code igniter and laravel extensively and haven't seen any benefit from namespaces over well named libraries. Laravel's super simple models and relationships totally win though. 
It makes you put a package name (which is usually something confusing and nothing to do with what the package does) in a file and then run composer update, which puts some unknown number of files somewhere. Then you still have to tell laravel to use them. Conversely, doing your own package management means you know what's going where and how it all connects up a little better. 
Yes, yes, yes and yes. The PHP exception system is great, try/catch/finally - having an alternative error system in PHP (granted, it was there before exceptions) is confusing, and makes it hard to trap routines/functions that fail further up the stack. This would be very, very much welcome for me personally. From the RFC it seems like it's a change that can't be enabled/disabled from php.ini? Would that possibly be an issue for some? 
This. Also, great user name. 
Rasmus Lerdorf also apparently gave CI praise, saying he liked it because out of all the frameworks, it seemed the least like a framework. Or something along those lines. I think he was referring to how flexible it was. 
Easier said than done, i'm afraid. Im not actually sure they don't. I don't spend time with them.
My skeptical half is thinking "a legacy framework has the backing of a third rate university". I'm all for competition, but it would take a lot to make up the ground they've lost to Laravel.
My favorite part of the article is where you **literally copied the description of every book on the list directly from Amazon** and then linked to it with your affiliate code. 
Just an FYI, generally when writing online you should use more descriptive links - if someone skimmed your article, they shouldn't just see a bunch of links that say "here". Same with search engines and screen readers. Instead of "it can be found [here](https://github.com/salsify/jsonstreamingparser)", use "you can find the [JSON Streaming Parser Package on Github here](https://github.com/salsify/jsonstreamingparser)"
Thanks for the feedback this is the first piece i have written I will fix that :) Trying to get better at writing something people will enjoy reading.
Has anyone move already?
The real problem here is that PHP also didn't get RAII right. I consider it a BC breaking change that code that previously wasn't caught by exception handlers now might be, and in particular I think the `obj-&gt;method()` example is precisely the kind of error that should not be catchable. I'm on the fence about this.
&gt; The real problem here is that PHP also didn't get RAII right. In what way? &gt; I consider it a BC breaking change that code that previously wasn't caught by exception handlers now might be That's a good point, which is why this is for PHP7. &gt; and in particular I think the obj-&gt;method() example is precisely the kind of error that should not be catchable. The `$obj-&gt;method() ` example should be catchable; how else would you be able to handle that gracefully? I prefer getting a nice error log, email notification, and displaying a friendly message to end users to the limited options that fatal errors provide. 
If thats the case I recommend Laracasts very very highly. You'll learn things even if you're an experienced developer. Well worth the $9 a month
Yes! Please! I thought this was a bit much for PHP 5.6, due to the backwards compatibility breaks (and the sheer change in handling errors in just a minor version), but this makes complete sense to me for PHP 7. My only gripe about this RFC in particular, is that all of the errors would be converted to a single type: `EngineException`. While I agree that there should be a common type of some sort, I don't think that using one generic exception for all types of engine errors makes a lot of sense. Part of the whole point of exceptions is to give a type that you can reference and interact with for different error cases. This one single exception would mean either parsing strings (dear god) or checking error codes against constants (not ideal). It would make a lot more sense to me to have separate exceptions that inherit from (or polymorphically type in some way to) a common exception type. For example, I'd much rather have a `NullPointerException` exception type when attempting to call a method on a null reference, than just some specially messaged `EngineExcepiont`. In other words, I'd much rather do this: $date_time = null; try { $date_time-&gt;getTimestamp(); } catch (NullPointerException $e) { // Handle exception } than this: $date_time = null; try { $date_time-&gt;getTimestamp(); } catch (EngineException $e) { if (strpos($e-&gt;getMessage(), 'non-object') !== false) { // kill me now.... // Must be a non-DateTime } else { throw $e; } } That's just one example. I'm sure you can see the other ways that this would be an improvement.
Windows simply does better with threads than it does with processes. Nobody noticed, but it's also the default build mode on travis - all PHP being tested on travis is using a thread safe interpreter. There is a little (theoretical and measurable) overhead if you use a thread safe interpreter on any platform, you shouldn't be using a thread safe interpreter at the frontend of your applications anyway ...
Interesting. I have never seen this before thanks. I will check out the free videos first and if it is useful I will buy in. Thanks for this it looks really promising. 
&gt; I consider it a BC breaking change that code that previously wasn't caught by exception handlers now might be That's actually fixable by making a new `BaseException` as a superclass of `Exception` and then having `EngineException` inherit from `BaseException`. That way `catch(Exception $e)`s sprinkled around old code would not catch the new `EngineExcpetion`s 
The point is: there is no good reason to use git on a prod server. The onus is on you to give me a good reason for doing so. Just because we can does not mean we should. But as I also said, YMMV. 
I like this in theory, but this RFC seems half done. First, one of the major issues this RFC had the last go around was addressing the fact that the reason certain things throw fatal errors is because they leave the engine in an inconsistent state, and bailing out immediately is the least bad option. Other languages do have exceptions for everythingâ€”including fatal runtime errorsâ€”so this problem is not insurmountable, but it's not addressed here. Second, this does nothing for the set of "errors" that are easily catchable without dealing with an inconsistent engine state: - E_WARNING - E_CORE_WARNING - E_COMPILE_WARNING - E_USER_WARNING - E_DEPRECATED - E_USER_DEPRECATED - E_NOTICE - E_USER_NOTICE - E_STRICT This seems like putting the cart before the horse: this RFC would be entrusting userland to make decisions that override what the engine thinks is bad news on the really dangerous stuff, but provide no runtime method for handling the safe stuff except `set_error_handler()` (which the RFC acknowledges is not ideal) and `@` (ugh). I'd rather see a more comprehensive solution that deals with non-fatals as well instead of merely treating exceptions as fatal errors that have a new error handler syntax. For example, provide an exception class for every type of error, and do something like: - do not kill script execution for certain exception classes, or - replace `error_reporting` (which will still have to exist after this RFC as-written because it doesn't address non-fatal errors) with an option to specify which exceptions should stop execution
I've been a PHP developer for over 10 years, and hiring people into my team is often very challenging. I'm going to try to give you some perspective from the other side. Sorry if I hurt your feelings along the way, I'm really trying to help. First the php community is more diverse then most other languages. I often need to ask questions like these to determine what kind of PHP developer I'm interviewing. &gt;&gt; Is this code valid? The answer. Yes, yes it is. I didn't know that because I don't go around throwing random brackets in my code... This first question is interesting. It catches two groups, people who are used to block scope (Perl, Java, C programmers) and people who have no idea what scoping is. Many PHP applicants are qualified, experienced, and knowledgeable developers from other languages who are looking for a fresh start in a new language. PHP has a lot of problems, but lack of job opportunities is not really one of them. Java, .net, Perl, Lisp, Haskel, C++ have their ups and downs, and PHP is accessible enough that I often interview developers who's core language is not PHP. That's fine, but I need to know how big an issue that will be. Not understanding scoping (question 1) is an indication the candidate may not understand PHP well enough. Yes the candidate may have mastered the basics but I dont want them to have to start a project over because they didnt know PHP doesn't allow multiple inheritance or thought 100 call max function depth is too small... &gt;&gt; $result = 11 + 011 + 0x11; On the flip side, Many PHP Candidates are not formally trained engineers at all. Some have backgrounds coming from the design side, graduating from wordpress templates and dreamweaver to using PHP to implement login and MySQL backends. Thanks to the wide availability of tools in the PHP ecosystem they can slap together rather impressive projects and many grow into fair coders, but they are not "schooled" They do not understand big O, they don't really grok binary or octal or hex, they might use classes, but their code isn't quite OO. Yes the candidate may be a clever coder, but until they level up some things are probably over the candidates' head like refactoring code for modularity or implementing a reusable framework. Both the previous groups would classify the other as completely impractical and describe themselves as "just get it done" problem solvers. &gt;&gt; What would be the result of trying to insert a NULL value inside an auto-increment column? PHP is a web application language. Web applications and SQL (particularly MySQL in PHP land) go hand in hand. If the candidate cannot answer a simple question about fields with default values, they may not have enough experience, or they may not have enough depth of experience. Yes, if the candidate is talented they can learn it on the job, but if I have my pick of candidates I see no reason to pay them to learn when others can answer my "trivia" questions. Failure to answer this question might mean 1. The Candidate has never written a schema from scratch, 2. The Candidate has never written or modified an ORM, 3. The Candidate has no idea what Normal forms are 4. The Candidate has will be bad at writing efficient queries or even judging what would be fast or slow 5. The Candidate primarily has experience from frameworks which provide their database out of the box of via GUI (eg: drupal, wordpress, Expression Engine) &gt;&gt; Difference between strstr and stristr? Many people here have been saying this is trivia, and reference material minutiae, and they are almost right. An example of a completely unfair trivia question would be, "What is the 3rd parameter of json_encode() ?" But how will the candidate look up strstr() if they don't know about strstr() in the first place ? Additionally, stristr() is a dead canary. if you don't recognize the "i" convention in stristr() then surely the candidate has never heard of stripos() and strpos() ? or str_ireplace() and str_replace() ? or any of the other functions in http://php.net/manual/en/ref.strings.php ? Nor the array functions at http://php.net/manual/en/ref.array.php ? A lot of basic PHP work is just string and array manipulation. What exactly have they been doing? Also, there is a lot of power in PHP's idioms, and they deserve respect. Nothing makes me sadder then when I see a new hire spend a day re-inventing ... array_map() or something. Again Yes, the candidate can learn all these "trivia" functions on the job, and no i do not expect anyone to study them. I want candidates to have learned them on the job ... elsewhere. That's what they call "work experience". This simple reference quiz informs me as to the candidates' relative experience. It takes time to learn and use these functions, and along the way you pick up instincts about how to debug a problems, how to solve challenges, and where hidden pitfalls may lie. The trivia questions are not the total analysis. Most important is the problem solving. And good google-fu is part of problem solving, but the trivia gives me a sense of a candidates' background and limitations, and they should be taken seriously.
Having anything enabled/disabled from php.ini is one of worst things in the language. It's time to break BC and do things properly, if it ever is going to happen.
Hey, I agreed his post was unhelpful - i was merely pointing out that the ASP.NET MVC naming is likewise wrong (the article you posted makes other errors, namely referring to templates as views, which is an entirely other class of problem). I was offering some fleshed out reasoning as to why /u/teresko was pointing out that you were not following "MVC". In truth *nobody* in this space does. At all. Not rails, not .NET MVC, not Laravel, not Symfony...none of them. I apologise if this was taken as me "misdirecting the sincerity" of your post. My intent was to provide clarification, nothing more. 
&gt; Fatal errors don't trigger destructors. The only reason RAII works is because destructors always run. Well that's the definition of a fatal error in every platform. Call abort() in a C++ program and destructors won't run either. &gt; But it isn't mentioned as a BC change. Except for the section titled "Backwards compatibility" in the RFC. &gt; If this happened to me I'd want to crash immediately because I dun goofed. Of course. But some typos you can catch with an exception or custom error handler but this one kind of typo you can't? Complete lack of consistency. And it would be helpful to get a full stack trace so you can find this error and fix it? Being able to catch it also allows for much more robust logging conditions. &gt; I especially don't want to accidentally continue because somebody stuck catch (Exception e) {} somewhere higher up in the hierarchy. Well it won't just continue; the stack will still unwind to that point. If you have a catch-all exception handler somewhere, you have exactly the same problems but for a smaller set of errors. It's not really a huge advantage that this one single class of errors is slightly different. &gt; I don't need to be able to display a friendly message for an error like this at all because an error like this should never have made it into production in the first place (yes, it happens; no, it shouldn't). This is a flawed argument at best. So if the error happens you want a blank page or stream ugly error messages to the client? How is that better in any way? 
Seems I'm started a troll, pointless thread. Autoload, Command Line, Facade are scary. Nobody want do justice to CI.
Just a way to embed short documentation/description in the command file without using reflection.
I agree. On the other hand IF you, as the builders of the project, want to get people to use your "stuff" should make the documentation as user-friendly as possible. GitBook is a good option. Anyway it's better than 1 long HTML file. As you may remember I've tried to contribute to Aura.Router ;-)
Haha, yeah... sorry about that. it was the only site I could find that really referenced the rocket stack, which considering how many sites they power I thought there would be more.
I'm afraid i have to agree, and I don't think this would, in its current state, make it through a vote. This and the lack of multiple exceptions worries me.
Now if only PHP would dump stack traces to the logs when exceptions occur (especially for uncatchable ones which can sometimes be hard to track such as OOM) (without having to use an extension such as xdebug). Throw in a method to clear the last error that occurred (the response of error_get_last()) and 2 major annoyances with PHP error handling will be fixed.
&gt; Seems I'm started a troll, pointless thread. You said that. &gt; Autoload, Command Line, Facade are scary. Nobody want do justice to CI. You don't need to touch that to learn MVC principles with Laravel.
Agreed. CI was great for many, many projects I worked on. It's just had it's time in the sun, and better alternatives came along, with new ways of doing things. Most people using CI these days are likely working on, or maintaining existing projects, so it's good to see it at very least getting an official home for a while, even if it only ends up being for bug/security updates, it's a welcomed improvement.
Warnings, Deprecated, Notices and Strict errors should not be Exceptions because these are cases where the code is able to continue doing what it was asked to do. Exceptions (as they work in PHP) are for cases where it's not possible to continue, and there's nothing sensible the code can do to resolve the situation.
It depends on what the plan is. You could have CI:Legacy, which is the current 5.2 compatible codebase. But then fork a new version that is PHP 5.6 compatible (ignoring all lower versions). By the time it's finished and gets into people's hands, it'll be acceptable to be 5.6+ only, and it'd mean it'll last for a significant amount of time.
At least he managed to avoid recommending anything with PHP6 in the title.
The real question is why? Why go through so much effort to create a "new" framework which looks nothing like the old CI (because it really cant look like the old and function like the new ones). Why do all that when there are already huge communities &amp; thousands of contributors behind more modern, mature frameworks? Seems like a waste of time to me. Maintain the framework for major bugs / security fixes and recommend something better for new projects. CI was my bread and butter for many years, but there is just a time where you need to let go. Just let CodeIgniter die.
I'm not opposed to having multiple, more specific exception classes. I hope the discussion will result in a set of classes we could use. The only thing I'd like to avoid is having a separate class for every single thing; instead it should be grouped into reasonable categories (so the number of exceptions should be closer to 5 than 50).
Very true - I was thinking more of it being a possible project for the BCIT students, but do agree - it's not worth it and there are tons more frameworks better suited to the job these days.
Don't disagree with you on this - just thought it was a relevant observation to make. 
No indeed you're right. Everyone should learn MVC from Laravel. No command line required, no additional bullshit required to bootstrap. You never be a junior/child like the Miss Agatha Trunchbull
Why doing a new ORM if we have Doctrine? Why doing a new framework if we have Symfony and Zend? There's always new points of view that can be an improvement in developing for Php. Codeigniter nowadays it's simplicity and fast execution times.
/u/krackjoe : any plans to include pthreads in core ??
I think this looks really silly and won't encourage clean code. Additionally, if you're doing this: switch ($x) { case 1: while ($y) // stuff default; // stuff } You're doing it wrong in so many ways.
You don't like it because you don't get it. Sorry, that was cheap. But seriously, you should educate yourself.
Yeah, maybe because i've never needed it, and don't understand why i should.
Sure, but it still amazes me that i should need something like this for PHP. I never had this for C, or Delphi, or java, or .net... I understand it's all part of collaborating, and converting php code in packages much like linux (But linux is an operating system, and php is a oo scripting language), but still, find it far too much for what php is
I , like u/I-am-Lying-right-now, never needed such amount of libraries. It makes sense, but maybe i'm more used to do my own stuff and rely on external libraries for tasks such as password hashing, mail sending and database wrappers....
PHP doesn't require a package manager. You can write a project without dependecies. It's your choice. However, projects that have third party dependencies benefit from having a package manager. PHP had one for the longest time called PEAR, but composer is better. Ruby, Node, Javascript all have package managers. 
Yes, sure. I know it's better than PEAR, but still, in my 14 years, i've never used such a thing for C, Delphi, Java or .NET
Its a matter of investments. Wins who shouts loudly. You are able to build cool stuff wheather, consistently and continuosly you have support and enhanchements. Not changing tool based on a trendy curve. Just speaking about the Laravel specific case. Edit: I'm just telling my POV, not bashing nobody. Except poorly expressed thoughts.
If it's not catchable, we're no better off than with the current fatal errors and this RFC would devolve into pointlessness. IMHO, as this is a major release, it would be acceptable to have EngineException inherit from Exception. 
This would be neat in views IMHO. &lt;?php foreach ($items as $item): ?&gt; &lt;h1&gt;... &lt;?php or: ?&gt; &lt;p&gt;No items ar... &lt;?php endforeach; ?&gt; 
&gt; Because i like to know what i have, and organize everything to my taste. You can still do that with Composer. Look at it this way, here's what you are doing now: - Download a package/library you need. - Look through all the files to check it's "to your taste". - Put the package in a location you like. - Include that package's autoloader, or write one yourself, or write "require_once" everywhere. - Every so often, go through all your packages, go to the website for each one and check if there's a new version. - Download the new versions and put them in your special locations. Depending on what your taste is, maybe you need to move individual files to specific locations instead of just a folder. - Optionally, check the packages are still "to your taste". - Make sure your autoloader still works, or update all your "require_once" statements. With Composer: - Include the Composer autoloader (once). - Add the packages to your JSON file. - Run composer update every so often to update all your packages. - Optionally, check the packages are still "to your taste". If not, search for another one and add that to Composer instead. Even if you're only using a few packages, Composer is still beneficial.
I think that the usage in views would likely be fairly limited, because of the following problem: &lt;?php if ($items): ?&gt; &lt;ul&gt; &lt;?php foreach ($items as $item): ?&gt; &lt;li&gt;&lt;?= $item ?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;?php else: ?&gt; No items! &lt;?php endif; ?&gt; Often the case with list elements and the case without list elements require different *surrounding* markup, so the `loop/or` syntax would not be applicable. 
&gt; If the error happens in development, I don't care because the environment will be configured to show all relevant information to track down the issue anyway. If the error happens in production, it is sign of a much deeper process issue (i.e., "why didn't you discover this sooner?") for which the ability to recover is nothing but a band-aid. You've obviously never worked on a major system with multiple developers before. You can cry "testing" and "QA process" and what-not, but the fact still remains, when you have multiple cooks in the kitchen, you will not always catch everything in development - especially when it comes down to maintaining legacy code where the original developers/stakeholders have moved on to greener pastures, and there is little to no documentation and/or unit tests. The fact of the matter is, *it happens, and often *it happens in production. Being able to gracefully handle ALL situations should always be a priority, whether it should or should not happen. Get off of your high horse man, and see that this will be a good thing for both developers and for end users. The "Fuck it, I'm going home" (i.e., immediately abort, because "it should never happen") attitude does nothing to bolster the development community.
What you've built here is a streaming parser and there's already a few good implementations for PHP, this one is great and has tests: https://github.com/salsify/jsonstreamingparser In terms of your project I'd say a few things: - No tests! - You're not following PSR-2 and instead using Laravel's conventions. Inside Laravel packages thats fine but if you're releasing framework independent code, follow PSR-2. - Strange indention. - Over use of `private` instead of `protected` (and a few instances where `public` should be `protected`). 
Yes, that's exactly how i work (I try to avoid require_once, and use the power of autoloaders), but my question is, how flexible is Composer? and how many MB of extra junk will i get with each "package"? (I did a quick test yesterday with Twitter bootstrap -i know it's not php, but it exists as a package-, and got about 90mb of useless junk) Thanks for the clarification!
I'm trying out Symfony, and the example demo makes me feel like I'm looking at [FizzBuzz Enterpise Edition](https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition/tree/master/src/main/java/com/seriouscompany/business/java/fizzbuzz/packagenamingpackage/impl). Two questions: 1. Is this the normal response to Symfony? 2. Do normal projects in Symfony require hundreds of lines across multiple files to do what appears to be relatively simple tasks? 
* run it through https://github.com/fabpot/PHP-CS-Fixer :-) * `private` makes it easier to encapsulate. If in doubt, go `private`. You can always make it `protected` later. You can't do that the other way round without a BC break.
to be clear, I'm not talking about the travis tests for php-src, I'm talking about the php binary provided by travis ... it is by default zts ...
&gt; First, one of the major issues this RFC had the last go around was addressing the fact that the reason certain things throw fatal errors is because they leave the engine in an inconsistent state, and bailing out immediately is the least bad option. Other languages do have exceptions for everythingâ€”including fatal runtime errorsâ€”so this problem is not insurmountable, but it's not addressed here. PHP will not be able to use exceptions for all E_ERRORs, in particular things like memory limit, OOM and timeouts cannot feasibly be converted. A conservative estimate is that we can turn 80% of the fatal E_ERRORs into exceptions. You can find a more detailed analysis in the previous discussion: http://markmail.org/message/gfdczr6zpgzynid4 &gt; Second, this does nothing for the set of "errors" that are easily catchable without dealing with an inconsistent engine state: There isn't much we can do about this. I don't like the current error handling mechanism, but we cannot possibly switch existing notices and warnings to exceptions, because it would be a huge backwards compatibility break. What we can do is start using more exceptions in the future (which is a primary target of this RFC) and maybe provide additional conveniences for handling notices and warnings (which is an orthogonal RFC - I'd love to hear ideas for *robust* mechanisms for "catching" warnings etc.)
&gt; how flexible is Composer? Flexible in what way? You list the packages you want in your config, then Composer downloads them. Not sure how the system could be any more/less flexible. If you're asking, can you get Composer to put each package in different locations, then no. But that's not a disadvantage, there is no point in doing that. &gt; and how many MB of extra junk will i get with each "package"? For the packages I've used, very little. Like a few readme files and stuff. Can't speak for every package - 90MB of junk for bootstrap is completely ridiculous. (Also not exactly sure why there would be a Composer package for bootstrap...)
All these questions are stupid and you probably don't want to work there. FWIW, 011 is octal, not binary.
 &lt;?php foreach ($items as $item): ?&gt; &lt;h1&gt;... &lt;?php endforeach; ?&gt; &lt;?php if (empty($items)): ?&gt; &lt;p&gt;No items ar... &lt;?endif; ?&gt;
No problem, my apologies for the rant.
I don't think Rasmus was being stupid here. He's a fan of lightweight things, he thinks it's silly to waste hundreds of milliseconds in a request starting up a full-stack framework.
I agree with you on the tests and PSR-2 it's something I need to get into the habit of. I will be writing some tests for it later but I needed to just get it finished currently. I also addressed jsonstreamingparser in my article and why I did not use it :p. As far as I know it's one of the only streaming php parsers that I could find.
I don't really mind fatal errors, as I consider them programming errors that are usually addressed at development time. But I'm not the most objective guy as I dislike exceptions in the first place and use them at a very last resort or when forced by a dependency api. I especially feel Exception handlers usually produce poorly feedback for a web app / api. I guess as PHP won't be an exception-less language like Go anytime soon I welcome improvements in this area. Edit : also the RFC refers to eval(). Why not simply kill eval() ?
Best of luck to BCIT! A huge refactoring on CI is absolutely necessary. Also, my opinion is that every PHP programmer should have known a few - at least - about CI. Maybe someday you'll need to fix an app made on Code Igniter. =)
If doing it yourself means doing it in PHP, then yeah...
&gt; You've obviously never worked on a major system with multiple developers before. Spare me. I'm even a victim of lousy process and could actually *benefit* from this change and I *still* don't want it in this form. &gt; Being able to gracefully handle ALL situations should always be a priority [...] The whole point of a fatal error is that the *most* graceful way of handling it is to give up (and if it isn't, it probably shouldn't have been a fatal error to begin with, but that's a completely separate discussion). I would much rather have a blank screen and sane data than a pretty dialog and corrupted data. $ ag --ignore-case --stats --php 'catch\s*\(Exception ' 180 matches PokÃ©mon catching is a real problem and upgrading PHP is not magically going to make developers more professional. There needs to be a class of errors that can save us from our own stupidity.
&gt;EDIT: For the curious, the company I work for is a 5 year old Ecommerce company that has outsourced their entire ecommerce existence to those "marketing" companies for the last 5 years... They don't really think they need a developer and I'm doubling as help desk and systems admin, all the while trying to clean up what these marketing companies have done.(Ugly code, no consistency, etc...) Find a new job. That's a nightmare. 1) You're doing three jobs for (what I assume) is one salary. 2) Your employer doesn't value the work enough to keep it in-house. 3) That codebase sounds like one of the circles of Hell. 4) A single developer is asking for trouble; who reviews your code? Who does QA? Get yourself a raise, change jobs.
My whole point is that there are situations where I really want to be able to reliably *not* recover\*, and that they are more than simply timing out and running out of memory. The specific implementation of this is unimportant to me as long as I can trust that no one will unwittingly, through ignorance or laziness, intercept such an error. In Java, for instance, you have to go out of your way to catch `OutOfMemoryError` because it doesn't inherit from `Exception` (but you *can* catch it, which is really [a little silly](http://stackoverflow.com/a/8729011/482758)). \*I am not opposed to recovering, per se. I just don't think this is the right way to do it (in fact, I think a single, global error handler for fatal errors might be a better solution).
&gt; The whole point of a fatal error is that the most graceful way of handling it is to give up (and if it isn't, it probably shouldn't have been a fatal error to begin with, but that's a completely separate discussion). Bullshit, plain and simple. That has to be the most ignorant statement I've ever read on the Internet, and I'm a redditor. There is a grand canyon sized difference between recovering from an error, and gracefully handling it. You seem to demonstrate over and over again that you do not understand this basic distinction. Even Microsoft's Blue Screen of Death is an example of gracefully handling the worst of errors by displaying a message, along with debugging information. This is graceful. When I use iAlien on my iPad, and trying to view content before the app just up and disappears without any sort of message is not user-friendly, and does not bolster confidence in the app. This is not graceful. Both are fatal errors; which would you prefer? To base your argument solely on the 'house of cards' analogy that there is a thriving ecosystem of badly designed software out in the wild is a fallacy, and only serves to hold PHP back in the dark ages where it does not belong. If you're using software that cannot handle a new feature in a major version upgrade, then do not upgrade. It is as simple as that. If there are features of the new version that you absolutely need, then you can a) fix said software, 2) contact the developers of said software and politely urge them to fix their shit, or iii) ditch said software for something more robust - btw, since you've demonstrated that you do not know, robust means that it is "able to withstand or overcome adverse conditions." ^[1](https://www.google.com/search?q=define+robust) &gt; I would much rather have a blank screen and sane data than a pretty dialog and corrupted data. Um, this makes no sense. If your data is so fragile that displaying a user-friendly error message would "corrupt" it, then I think you've got bigger problems with your software.
If you've never needed it, why would you dislike it? I'm building an app with Laravel. I write lots of boilerplate code, e.g. controllers, models, migrations etc. So in the cli I run `composer require-dev way/generators`. Composer does its stuff for a minute, and is ready. Now I run `artisan generate:migration create_posts_table --fields="title:string, content:text, image_id:integer, category_id:integer"` then `artisan migrate`. I now have a migration file ready to be committed to version control, and a table in the database. I can then run further generators for model and controller files. This is the kind of thing you can do with composer. With CI I had to download and extract the zip, put it in the right directory and it would all be in the project's VCS. 
Well. Whatever they do, I certainly want to be able to capture all errors in my application, log them to somewhere and then inform the user (using a correct 500 HTTP error code, in the design of my site) that some error condition has happened and the error has been logged. The more information I can get out of the error condition, the easier it will be to find out what the problem was and to subsequently fix it. If all error catching can happen at one central spot in an outermost `catch(WhateverItNeeds)`, that's certainly the most convenient way. If I have to register a shutdown function and try to piece information together from `error_get_last()` (losing the call stack in the process), then that's way less convenient. If I were to (likely accidentally) catch an `OutOfMemory` error somewhere else than in my outermost oh-shit handler, that's my and not the language designer's problem. Also, likely the script will terminate soon after anyways because when I'm memory starved, after catching that one error, I'm very likely to hit another OutOfMemory error, this time not inside of a too-generic `catch`, causing the script to terminate anyways.
Only thing is, that: - codeigniter is at best "average" when it comes to benchmarks - benchmarking frameworks is quite stupid activity to begin with CodeIgniter is not "lightweight". It's simply "bad". 
First off whoever put twitter bootstrap in packagist needs to be slapped so damn hard. That should be pulled in via Bower. If you don't want to use Node.js and Bower, then get it from a cdn, I prefer cdnjs.com Second, it all depends on the packages dependencies. You pull in something like Laravel it's going to pull in a lot of dependencies. But you pull it something small, your directory will be small. Also .gitignore that shit when you push to git. composer.lock committed is good enough, that will pull in the same versions of everything if you run composer install on it and not composer update (which updates the lock file.)
Java and .NET both have robust and popular package managers, and I would venture to guess Composer is modeled after projects like [Maven](http://maven.apache.org/). It all comes down to reusing components and rapid development. I'm not going to write my own HTTP library when they already exist. I'll just use [Guzzle](https://github.com/guzzle/guzzle). Guzzle isn't going to write it's own logger because plenty exist. It will just use [Monolog](https://github.com/Seldaek/monolog). Monolog isn't going to write it's own AWS library. It just uses [aws-sdk-php](https://github.com/aws/aws-sdk-php). aws-sdk-php isn't going to write it's own YAML parser. It just uses [symfony/Yaml](https://github.com/symfony/Yaml). And on, and on, and on.
&gt; In other words, I'd much rather do this: This is the wrong use of exceptions! They're supposed to be for exceptional situations and not used for program flow or logic. The correct code is simply: $date_time = null; if ($date_time) { $date_time-&gt;getTimestamp(); } else { // Handle null datetime } For EngineExceptions there should really be no reasonable reason to want to know exactly the type of error. The only reasonable course of action should be to log the error and cleanup. 
Yes? There are tons of dependencies out there, that people use. And i'd rather not deal with them by hand. Makes a lot more sense for a program to manage them, and the dependencies of the dependencies, while managing autoloading and everything.
And honestly, in my 10 years using Java (havent touched the others), the biggest wish i have, is that it had a better way to manage dependencies. The lack of a dependency manager gets users into the cycle of not using dependencies, and writing their own code, that someone else has already written. Ryan Weaver did an AWESOME talk on composer, at Symfony Live in SF (2012): http://symfony.com/video/26/the-wonderful-world-of-the-symfony-components-and-composer/English Honestly, before attending that talk, i didnt really care about composer, but it changed how i develop.
Sometimes its not. The symfony CLI takes those, and throws an exception. I'd love to be able to catch some of them.
eval still has business uses
Dude, and I thought the VBulletin / Joomla frankenstein I had to shit together was bad. But Magento / Joomla? ****runs away from desk screaming and flailing about as if covered in spiders****
Huh, I saw the discussion about the ternary operator and implicit isset() but not the outcome of the null coalescence operator. Neat!
&gt; framework (noun) \ËˆfrÄm-ËŒwÉ™rk\: a product with the business logic removed, but all of the assumptions left in To be more accurate, a product with no business logic, and a minimum of number of common/core assumptions to make the peripheral presentation and infrastructure layers that surround the business logic, easier to implement. 
Thanks!
Well, I am from India and I am attending a university here itself. I am studying Electronics and Communications Engineering. I have had 2 years of C++ and 1 Year of RDBMS, SQL and Networking in High School and College. I have worked with PHP developing small scripts and wordpress tweaks and feature enhancements. Yes, generally all the internships are on site, but previously while working on freelance sites, I requested people to make the positions as temporary. Working remotely for them made them pay less and they were quite happy about it. However, if someone is willing to hire for a Junior Developer position, I am up for it. I can't relocate because I have a degree which will finish in 2016. For intern positions, I can relocate for 6 months a year, like from January to April and July to October.
Fair enough. But still, even though converting them all to exceptions is a rather large BC break, if it's ever gonna happen at all, now (PHP 7) is the only time to do it.
Is there any fatal exception that isn't technically avoidable, if you make the right checks in the first place? For instance before attempting to call a func from a string, do a check first to `is_callable()` Anyhow a pretty welcome change to be able to catch fatals.
`__get` and `__set` are invoked when the property being poked either has bad accessibility to the caller, or when the property does not exist. They're magic fallbacks for missing things. Using them as catch-all getters and setters is a bad idea. If you aren't doing validation of the property on set, then why do you need a setter? If you *are* doing validation of the property on set, why are you bundling together all the different validation into a single function?
In the past, I've often written code like this: &lt;ul&gt; &lt;?php if ($items): ?&gt; &lt;?php foreach ($items as $item): ?&gt; &lt;li&gt;&lt;?= $item ?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;?php else: ?&gt; &lt;li&gt;No items!&lt;/li&gt; &lt;?php endif; ?&gt; &lt;/ul&gt; Granted, it's not the most symantic HTML, but it appears to be fairly common, and wouldn't have the issue you demonstrated above.
Getter and setter methods are useful for enforcing behavior onto single properties, whether it be access control, validation, stubbing for testing purposes, etc. The magic __get() and __set() methods are for implementing behavior across a class of property names, or for implementing specific design patterns using the class (like the [Decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern)). But, they're pretty scattershot, as McGlockenshire points out. They're only invoked if the property is otherwise missing. So if you wanted to use __set() for validation, for instance, the validation would be completely bypassed if you declared the property in the class definition. Magic methods also make it difficult to trace the flow of your program. Most of the time, individual getters and setters will be much more useful and clear than pushing a bunch of logic into the magic methods.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Decorator pattern**](https://en.wikipedia.org/wiki/Decorator%20pattern): [](#sfw) --- &gt; &gt;In [object-oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming), the __decorator pattern__ (also known as Wrapper, an alternative naming shared with the [Adapter pattern](https://en.wikipedia.org/wiki/Adapter_pattern)) is a [design pattern](https://en.wikipedia.org/wiki/Design_pattern_(computer_science\)) that allows behavior to be added to an individual [object](https://en.wikipedia.org/wiki/Object_(computer_science\)), either statically or dynamically, without affecting the behavior of other objects from the same [class](https://en.wikipedia.org/wiki/Class_(computer_science\)). &gt;==== &gt;[**Image**](https://i.imgur.com/8f1gMuu.png) [^(i)](https://commons.wikimedia.org/wiki/File:Decorator_UML_class_diagram.svg) --- ^Interesting: [^Python ^syntax ^and ^semantics](https://en.wikipedia.org/wiki/Python_syntax_and_semantics) ^| [^Object-oriented ^programming](https://en.wikipedia.org/wiki/Object-oriented_programming) ^| [^Aspect-oriented ^programming](https://en.wikipedia.org/wiki/Aspect-oriented_programming) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl311jw) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl311jw)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; I'd love to see anything written that is actually 100% de-coupled Im going to throw in a couple caveats here: * as stated, is 100% de-coupled * doesn't re-invent the wheel by re-implement functionality that already exists in another library * actually does something useful enough on its own given the above two requirements
Pretty much using them to make decorators that inherit the properties/behaviors of the things they are decorating, but through composition rather than actual inheritance. Beyond that using magic methods is generally problematic, make debugging harder, and reliance on them usually points to a design smell. 
Absolutely not worth switching to from Laravel unless you need your application to work on very old environments.
As long as it's using PHP-FIG and up-to-date standards, it shouldn't be too hard to pick up. That's the beauty of the FIG. 
I may be out of the loop now, what are some of frameworks that are considered better than CI nowadays?
&gt; One of the big questions my boss has is whether a developer would mind taking over a MVC framework I built specifically for the company. (I would explain why we didn't use Laravel / Symfony / Zend etc. but that's a whole post in itself). Curious to hear your reasoning. Personally I'd be a little put off up front but would reserve judgement until I got my feet wet with the framework, you just don't know what you don't know. Maybe you created the best MVC framework ever, who knows! It could also be a complete pile. Would just be a matter of trial and error. I'd be more hesitant to accept the job than if it was using a standard off-the-shelf framework but not completely opposed to the idea.
I would still consider the job but this would definitely make me cautious. Not because there's necessarily anything wrong with it but it could be reflective of the culture of "we write everything ourselves because it's best". When you are interviewing you have limited information and choice of tools is one of those pieces.
Edit: Looking into it, seems like you should be able to use $xmlDoc-&gt;getElementsByTagName('item')-&gt;length;
* laravel * symfony * yii2
Obviously there's a learning curve - but assuming the framework makes reasonable choices and is well documented the learning curve shouldn't be any worse than picking up any other framework you're not familiar with - so no, I don't think it would stop me taking the job on it's own. Probably would want to pick the brain of the person who wrote it before making any decisions... but there are plenty of places out there doing bespoke stuff, this is really no different.
&gt; The next major version currently being worked on looks like it might break backwards compatibility (again), by changing file structure / the way a lot of things are done. Apparently there will be a BC service provider which will allow your old code to run under Laravel 5. Have not seen it yet but clearly BC is a concern here given the install base of the framework. I'd wait and see what November brings before making assumptions...
the real question here: is it decoupled?
True, but it's more likely to get up to speed on a FIG based project then someone doing it all willy nilly.
You should be using a class and not a function. If you use a class, the context of the view is the classes "this" and you could add methods to persist data.
Well, when we started development there were a few main reasons we didn't use something off the shelf : - We needed to support multiple sites with interchangeable views / themes (primarily for international corporate websites). This is probably easier now, but choices were limited before. - It had to be really fast, so it needed some extensive server-side and client-side caching features - It didn't need to be as feature rich as Laravel (for example), but better than Slim. (This changed as the project evolved). To be honest, if I started this project now instead of 18 months ago I would have chosen an existing framework like Phalcon or Laravel because they've improved a lot since. 
Eventually, they *all* become "custom" frameworks. Even with a public framework, over time, enough idiosyncrasies get added throughout the models, controllers, and views, that it becomes significantly different from the original. Add to that, the installation may not be upgraded in sync with the published updates, so you get some drift. EDIT: As a followup, you would want to discover how amenable it would be to refactoring. The joke about "Is it decoupled" from /u/dcointipbot above notwithstanding, if there's wide use of service locator instead of dependency injection, or lots of globals/superglobals scattered around, you may want to consider the amount of work involved in making necessary changes later.
I would be put off unless you could show me actual code of an example request life cycle definition: 1. route definition 2. controller/action invocation 3. Injection of domain logic (e.g. do you have horrible coupling of the model to the controller like Cake 2x does?) 4. initializing a view and returning it as a response After working with Joomla's "MVC" structure, I now no longer implicitly trust MVC, and need proof a given tool's implementation is not a pungent shit pile of nasty route parsing, conflated directory structures, class responsibilities, and counter-intuitive naming conventions. That, and a cursory overview of the IoC container and how you're handling dependency injection (the "glue" of the framework). Really, the container and the router/dispatcher are the heart of the framework. If push comes to shove and the framework is shit, but the router and the container are decent, you can use just those two things to do everything you need in a fairly clean way.
Once I've been offered a job for a pretty large company in my area, that worked with their own framework. When I asked about why they use their own they also stated "it had to be really fast" as one of their reasons. They developed provisioning software for ISPs and for them every microsecond matters. They said they benchmarked their own code against most frameworks (even after stripping them down) and they concluded that their own code was better. I did not take the job for other reasons, but I just want to point out, your case is not as uncommon as you might think.
To expand on /u/chocslaw's answer: for($i=0; $i &lt; $xmlDoc-&gt;getElementsByTagName('item')-&gt;length; $i++) { â€¦ } should do the trick.
&gt; I now no longer implicitly trust MVC Not to derail the thread, but I'd be interested to hear more about this.
I've found __get() convenient when exposing model classes in twig templates so that I can use "model.prop" syntax instead of "model.getProp()". I still make sure the __get() magic method only work on properties that already have getters.
&gt; Magic methods also make it difficult to trace the flow of your program. I think this should be emphasized more. With explicit getters and setters and a smart IDE you can: click through a method to get to its class, use doc blocks to provide a return type for the method, see available public methods for a class using code-hinting, etc. You dont get any of that if you just use __get and __set. Because of this, using 3rd party libraries that use magic getters and setters is particularly annoying. They're called magic methods for a reason. Magic is the enemy of usability and maintainability.
Twig uses the Property Access component, so you can use `foo.property` anyway!
You shouldn't base such a decision on what framework they use (or don't use). You should base that decision on whether or not you'd like working there and whether or not they're adequately compensating you.
That OR statement for loops...it makes me happier than a pig in mud.
It wouldn't matter if CodeIgniter was picked up by Zend, Rasmus Lerdorf, or Facebook people would complain. Fanboys of their favorite PHP framework are going to bash it no matter what they did. Composer? I thought any PHP project could use the composer? Guess I'm wrong. Can't you just add it to the index.php and load PSR namespaced code in any PHP project? The CI dev version actually already includes a config settings to include the composer autoloader. Heck, you can even load CodeIgniter as a composer package if you like. The reason Laravel has "newer thinking" is because it's only been around since 2012 and in that time it's already dropped a version for a rewrite. Tell me is laravel 3 code compatible with version 4 framework? So how long has version 4 really been out? a year? If you write enterprise software that doesn't say "long term support" to me? I guess Laravel is more for the freelancers out there. You write the app and dash out the door with the cash. Then charge them a boat load of cash to upgrade (rewrite) there software every few years. Sure CI is "old" it's been around since 2006. CI 2 was released in 2011. Was there a PSR-FIG group? Was there Laravel? So then you wrote a app in CI2 and 3 years later you can download the latest 2.x version and it will run and they are still supporting it (that's called long term support). In that time frame Laravel put out version 3 and then rewrote the framework again for version 4. Hope you don't have any version 3 software written in it you need to support for the next 3 or 4 years. I guess the real test is when it's 6+ years old how backward compatible it is with it's "older" code. It's easy to says it's "fresh thinking" it's only been around a little more than a years.
Indeed, thanks.
Who are you
Yeah, i guessed that TWBS was a rare thing to be in composer...
I'm kinda shocked how slow it is to parse a 200MB JSON file with PHP (or so it seems). Shouldn't the default json parser already run rounds around files that can fit entirely in RAM? Of course streaming parsers are nice to have, but still...
I don't think there's a consistent way to detect the "or" case for a statement that can also contain assignments, like the `for` and `while` statements. You can do very little to create enormous bugs in those situations. The feature only really makes sense in the case of a `foreach` where there's always an known iterable and nothing more. Even in that situation it's not difficult or cumbersome to write your own "or" case. 
Actually, a company I work for now uses a custom made framework. It's actually MC without the V, since it's the backend API. After the original creator left, I took over managing the core of the framework, which was relatively easy to pick up. But we, as developers, spoke and we know that we shouldn't be making things ourselves anymore.
You don't need a for loop here, a foreach will work fine. The DomNodeList object you get from getElementsByTagName implements the Traversable interface, meaning you can iterate it using foreach. foreach ($dom-&gt;getElementsByTagName('foo') as $node) ...
I've used them where the validation rules and list of accepted properties for an object were defined in metadata. That way the same metadata was able to drive the validation in several different objects without having to hard code the rules into individual getters and setters.
/me snorts
Everything fine... but there are funny things which one can do with them. I have a small app where I use them in some view related code: function __get($name) { if (is_null(self::$instance)) { throw new \DomainException('Always use View::getInstance()'); } return (isset($this-&gt;data[$name]) ? $this-&gt;data[$name] : null); } function __set($name, $value) { if (is_null(self::$instance)) { throw new \DomainException('Always use View::getInstance()'); } $this-&gt;data[$name] = $value; } Yes, I know static is frowned upon. But I don't care in this case. The Object doesn't expose any public properties by itself. Why am I doing this? Because this view class is handling different types of views. For example one is PHP which does some tricks, one some templating or plain, and another json output where I then can simly return json_encode((object) $this-&gt;data). It could be also done different, but I like that it's easy and not much typing is involved.. eg $foo-&gt;bar = 1 instead of $foo-&gt;set('bar', 1)
I've used them when doing major updates on an old codebase. If you've inherited some code that relies on direct property access, but you need to update your class but still leave that property accessible, this is a good way to do it. Whatever your notions about how things 'should' be implemented, you can't control the code that's given to you, and `__get()` lets you avoid refactoring every possible place that accesses the property. This only matters for sufficiently complex/disorganized codebases, but here's a simplified example: code you inherit: &lt;?php class YeOldeClass { public $fullName; } Updated: &lt;?php class YeOldeClass { protected $firstName, $lastName; public function __get($name) { switch ($name) { case 'fullName': return $firstName . ' ' . $lastName; } } /* getters + setters for $firstName, $lastName, etc. */ } I really liked the built-in get/set in javascript, so I experimented with it a lot in PHP, but in general I find it's just not a good fit for the language. Like /u/dapple_man pointed out, it makes it hard to trace the flow of your program. When you get an exception stack, you'll just see it coming from __get(), which isn't as helpful as something like getFullName() would be. I occasionally use it for convenience properties calculated from existing properties (like the full name example above), so long as it's a really, really simple call. `__set()` I try to avoid, again mainly because it's a pain to debug (or even realize that it's an issue with your __set() in the first place). I like my function calls to be either very explicit (plain old declared functions), or implicit but with obvious conventions around their calls (e.g. `__construct()`). 
if you use @method doc blocks, you can declare any magic methods that are expected to be called from get/set.
Too bad the votes [aren't looking so good for it](https://wiki.php.net/rfc/loop_or) :(
It works only if `$items` is an array. Otherwise you'll get a warning.
"There are two kinds of startups: the ones that achieve some modest traction on top of a pile of code of which they are vaguely ashamed... and the ones that go out of business. Thatâ€™s it. No third kind." â€” Dan Milstein, Director of Product Development at Wingu I currently work for a nearly billion-dollar dot com that made a rather conscious decision to roll our own PHP framework. Do I love it? Do I think that it's the cat's pajamas? Not really. Do I think we'd be better off with one of the very popular off-the-shelf frameworks? It's actually very hard to say. If the team is small and the application is not tremendously complex, an off-the-shelf framework is going to save everyone time and therefore save the company money. You are essentially outsourcing a huge amount of the planning and maintenance to a large group of (hopefully) talented and experienced people. That's awesome. To be fair, my company uses a huge number of open source products where we have realized that same gain. However if your team is large and your application is complex (this describes us), you will likely wind up modifying or stretching the framework beyond its breaking point in ways that are as challenging to document and train new staff on as a custom framework would be. In conclusion, there is no absolute answer to the question of whether to use a framework or not. I think that in the PHP world, rolling your own system is a much more attractive prospect than with Python or Ruby, because PHP has inherent web transaction bindings that Python and Ruby lack right out of the box. It requires *almost no work* to build a basic MVC framework in PHP. Obviously the big frameworks have lots of other tools included, but PHP is so close to being a framework already, all it needs is routing, dispatching, and some class organization to pass the litmus test of sanity. I actually accepted this job before we even began the transition into an MVC design pattern. The platform was originally on the Microsoft stack and was translated directly into PHP in a very rote manner, so the code was very procedural. After about a year and a half I can say that over 90% of it follows an MVC pattern, which is really cool to see happen and a very satisfying accomplishment. I didn't hesitate to take the job because it was clear to me that the people working there were very smart and I wanted to be a part of that team because I knew that we could make the correct decisions about things like these and would be able to execute them properly, which I think we have, for the most part. You have to be satisfied when you leave work every day and whether the framework is homebrew or not is not important. Whether all of the code is shit is important, but as Dan Milstein said, no codebase is perfect. *Sorry, too busy making money!* Anyway, if everything were perfect, what exactly would your job consist of?
I don't know that the standard really makes a difference to the architecture quality directly, but it's an indicator that the author was reasonably standards-savvy.
What's weird is that even the author of the RFC voted against itâ€¦
This is true, and it's not really a bad thing. I have sites written on fair-sized CMSes that eventually start implementing plenty of content-management themselves too, so it's not a phenomenon restricted to frameworks. The big question is really, can you work on a larger-sized, more mature codebase? I know plenty of devs who can churn out small, standalone PHP products easily, but get completely lost when they're on a bigger project. Navigating an old, unfamiliar codebase is a skill in and of itself.
the built in parser is amazing! however 200MB makes it blow up and I personally feel like raising the memory limit is cheating because next thing you know it's a 500MB file and bam another exception. I am working on getting the time down to something much more reasonable now. I have an idea for getting it down to something closer to 12s but I'll update this post if I do. Working on it tonight :) As i said in the post PHP is not the optimal language for streaming parsing though. I want to write one in golang just for some interesting benchmarks.
`__get()` and `__set()` aren't great, but they do one thing--they reduce PHP's typographic clutter and verbosity. Compare the idiomatic PHP getter syntax: $address = &lt;&lt;&lt;END {$person-&gt;getFirstName()} {$person-&gt;getLastName()} {$street-&gt;getNumber()} {$street-&gt;getName()} {$city-&gt;getName()}, {$state-&gt;getName()} {$zip-&gt;getCode()} {$country-&gt;getName()} END; to the equivalent in Ruby, which uses [attribute accessors](http://www.rubyist.net/~slagell/ruby/accessors.html) to hide the implementation of getters and setters: address = &lt;&lt;END #{person.first_name} #{person.last_name} #{street.number} #{street.name} #{city.name}, #{state.name} #{zip.code} #{country.name} END The Ruby comes in at 75% character count, and IMHO is a much easier read. `__get()` and `__set()` can accomplish something similar: echo &lt;&lt;&lt;END {$person-&gt;first_name} {$person-&gt;last_name} {$street-&gt;number} {$street-&gt;name} {$city-&gt;name}, {$state-&gt;name} {$zip-&gt;code} {$country-&gt;name} END; Unfortunately `__get()` and `__set()` are troublesome for many reasons already mentioned. A better solution is something like the [Property Accessor Syntax RFC](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2).
Honestly, theres no reason Symfony couldn't solve 1 and 2, and as far as 3 is concerned, if you don't need the feature, don't use it. I'm sure the same could be said for ZF2 or laravel too. *Edit:* Downvote explanations appreciated 
A junior level developer could follow FIG to a T, but i still wouldn't trust their code.
But that junior level developer has a grasp on things. 
Ooh! Thank you! That's wonderful. I'll test it tomorrow. 
Fantastic! Thank you so much!
I'm afraid I don't quite follow. Is there an advantage to using foreach instead of for?
I'm still upset that the rfc didn't get the votes it needed.
ITT: People who don't actually have jobs as developers.
has a grasp on following a couple standards, that have no bearing on how an MVC/ADR framework should be built....
&gt; it could be reflective of the culture of "we write everything ourselves because it's best" Is this referring to developers choosing to write their own versions of things rather than use available third party packages? How should one go about asking interviewers questions to figure out where they stand on this sort of thing (without coming off as dick'ish/judgmental/bridge-burning, etc.)? 
1. Ask if the company writes their own in-house dev/IT management/WHATEVA tools. 2. If they don't, you have your answer. 2. If they do, ask a follow-up to see if all the tools are developed in-house. They might just make a few custom-built apps and use external solutions for everything else. 3. If they are all developed in-house, ask why. If there is some altruistic or hacker'esque reason, they'll love to yammer about it for a minute. If there is no reason other than "WE HIRE DEVS SO WE MAKE THEM DO DEV THINGS", that's can be pretty telling in and of itself. 4. ... 5. Profit
I like your username.
Yeah, i am new to PHP so i have no such issue, thanks I will stick to Laravel.
I've taken a number of jobs where I've had to do that.
If I were out of work and this was an option of course I would take it. Why not?
One use case that is often overlooked is the use of temporary tables, a very common thing in advanced MySQL usage â€” often used to avoid doing costly `OUTER JOIN`s. Do you allow for this? Also: MySQL shouldn't even be outside world accessible, if folks are in there they have already compromised your web server(s) and you're already screwed. I think this is a misguided idea.
upvote to infinity if I could
foreach is easier when you don't know the length of the array ahead of time such as in this case
This syntax is great. Why can't someone bring it up again? For PHP 7, maybe?
I already did.
This will also wreak havoc with connection pooling or connection reuse, as you'll now get one connection for each user / password combination in the pool.
I think one of the shortcomings with PHP's RFC voting system is that nah-sayers can't explain their position. Unless you follow the internals mailing list, you wouldn't know that some voters had issues with the implementation and not the concept. *Although I will say that some of those voting members hate OOP and vote against anything object-related.* 
The only time I've used __get, __set and even __call is for entity models. Before the days of me using Doctrine, I developed in Zend Framework 1, and they set it up so that __get and __set would map -&gt;attribute to $_data['attribute']; Figuring i could improve on this, I extended and over-ride those (and __call) to do the following. I mapped -&gt;attribute to getAttribute and setAttribute, respectively, and then used __call to make it so that if get/setAttribute didn't exist, simply perform the get/set on $data['attribute']. I then made it so that __get and __set would map _attribute directly to $_data['attribute'], bypassing this getter and setter. So why did I do this? Well, simply put I like the idea of being able to call $model-&gt;getAttribute() without manually defining the function, and then being able to override it later. So, say you have an empty user model. $user-&gt;getUsername(), $username-&gt;getPassword() and $username-&gt;setPassword($password) would all work by default, no defining needed. Then I'd define getPassword() to return "", so that you couldn't just pull someone's password like that, and setPassword($password) would hash the password and then pass it into _password. I think it was pretty cool. So why would I map -&gt;attribute to get/setAttribute? Well, I was maintaining old code that didn't use getters and setters, because the original programmers were knew to OOP, and this seemed like a good way to allow me to introduce getters and setters to legacy code without breaking compatibility. It also allowed future developers who might have been equally inexperienced to take advantage of getters and setters without knowing about it. Naturally, you could always access _attribute if you knew that you didn't want to go through the functions, because not everyone needs to be guided like that. Hopefully this will give you insight into one use of it. Any developers reading this, let me know what you think about my approach. I used this when I was the sole developer and maintainer of software, and haven't had a chance to see what other people thought of it
Your response was illuminating. Thank you.
If you never change anything, it will always be backwards compatible. I don't think anyone is bashing it because it didn't support things that didn't exist at the time, I think people are mostly pointing out that these days it just doesn't hold up to the developments in the entire echo system. I wrote [about this](https://philsturgeon.uk/blog/2012/12/5-things-codeigniter-cannot-do-without-a-rewrite) two years ago, and its still completely true now. 
Just curious why wouldn't you? My last gig was nothing but Symphony granted I didn't like it but it wasn't all that bad. I pined for Laravel the whole time too. Granted I'm not as a pro level to roll my tools so I've grown dependent on using everyone else's to generate results - which I guess can be bad. 
from following the php-internals mailing list I see it as very highly unlikely.... No they wont.
What's the *real* difference between update and delete (or even truncate)? If you update every field with junk you've effectively deleted every field. I don't think this sort of security is very valuable. Case in point, I once worked for a company that used to have users with different permissions for pretty much everything - it didn't stop them accidentally dropping an entire production db one day.
Custom framework is like new girlfriend - you will learn something new or you will kill yourself. After-all I would not care much. 
I'd be interested in hearing how the author (or anyone) thinks this provides security. All of these accounts are visible the second your code is compromised. Unless this is a strange attempt to mitigate SQL injection (e.g., can't perform an UPDATE during a SELECT), I don't see how it provides any security value.
Different access levels are useful if the clients are distributed and not to be trusted, for instance if you want to run clients on workstations that talk directly to the database. For web applications the access level is almost always better implemented in the application otsrof. 
/u/adrianmiu sorry I forgot. Thank you for your suggestion. I have been thinking about the same for quite sometime. I have been looking various places/searching different projects. But didn't find something that fits my needs. So I wrote something this weekend if you noticed this post http://www.reddit.com/r/PHP/comments/2ieue8/a_weekendend_project_inspired_by_viewdocs/ What about this : http://ghdocs.herokuapp.com/harikt/aurav2book/master/manuscript/introduction.md I think it is much better. Have a few things to fix / improve. As mentioned in the comments there * it can render from tags / branches * easy to write the markdown and push to github * navigation is one thing I need to improve / if there is any bug which can happen. When ever I get sometime I will push and improve things. And is open-source to hack and contribute ;-) . 
It's pretty clear that's gary.
Sometimes you can find data in Wikidata or Freebase. Sadly, wikidata does not have any data for this player. And Freebase (http://www.freebase.com/m/09hc0c) does not have /soccer/football_player/total_career_appearances filled in for this player. YMMV.
You can document the magic properties with @property in the class docblock to let your IDE know about them.
&gt; Sadly, wikidata does not have any data for this player. But you could use xpath to get it out :) //table[class="wikitable"]:first//tr:last then get the output of the second last 'th'. http://simplehtmldom.sourceforge.net/ 
@method is for magic methods, those are invoked with __call().
Yeah, i'm not sure i follow.. Why would you not want to work with a framework like these?
truer words have never been spoken
Not for the foreseeable future anyway .... it wouldn't make sense to bundle pthreads when the default build mode is not thread safe. There is some work underway to make better use of thread specifics, an upgrade to tsrm, if ever we were going to switch the default mode to zts (because it provides a robust execution environment, and is as fast as nts is today), I would push for pthreads to be included. This may not ever happen ...
This blog post is rather awesome - do these summary posts get written often? Don't have the energy to lurk internals - but a summary like this is excellent. EDIT: answered my own question - great!: http://blog.pascal-martin.fr/tag/internals@
Thanks! I try to write these digest once a month (usually, around the beginning of each month, about what has happened the month before). I've been doing so in French for almost 2 years, and since the beginning of this year in English.
Thanks :-) And by the way now the book also have a navigation. Simple one http://ghdocs.herokuapp.com/harikt/aurav2book/master/manuscript/introduction.md . Hope you will like the new way :-) . Thank you.
Pros: User friendly admin panel, easy to develop with once you know how to. Cons: All coding standards out the window, 2 classes per file, documentation lacks quite a bit at times. Admin panel can be slow. Modules are usually quite buggy (from my experience).
If you change that URL to format=json it might be easier to work with with [json_decode()](http://php.net/function.json-decode).
&gt;PHP would not known how to interpret that. PHP has no problem interpreting this if ($condition) if ($condition) // stuff else // stuff Why would it have a problem interpreting the same with a loop? The only real problem is backward compatibility with old code but considering that we are going from version 5 to 7 I don't think we should worry about things like that if we have to sacrifice readability
It's tricky but I think you can ask questions about the requirements of their framework/toolset. It might be that they did review alternatives and had a legitimate case. Maybe it does give them some really useful additional features. What I'm looking for is a positive environment not a specific toolset
Isn't that because a new RFC replaces it ? https://wiki.php.net/rfc/loop_else
Nah, that's an RFC from 2012. From the mail list it looks like Leigh became a fan of the idea proposed by Sara to let loops return the number of times it was executed e.g.: $n = foreach(...) {} 
OP would be better off using XPaths IMO. Edit: For future reference, the person I replied to had originally said that OP should convert the XML to JSON and then process that. My comment was a suggestion for skipping the conversion to JSON and getting the content without any extra manipulation.
I would be put off for these reasons : - Purely anecdotal but jobs I had where they weren't using a well know framework were the worst in terms of skill and culture. It seems not the case for yours, but it would made me cautious. - A custom framework undermines my market value for future job hunting. Especially in a world of clueless recruiters working with buzzwords. I learned Zend Framework six years ago and it gave me decent paid work for years and, if needed, would provide for a foreseeable future boring maintenance gigs that would pay the bills - I like open-source, the effort that goes in, the ecosystem it can generate, and I like to make contribution when I can, albeit usually small ones. TL;DR potential deal breaker.
All CMSes suck, I think rolling your own with an existing framework is probably the sweet spot if you're in need of a CMS (which you don't, in most cases, clients love the idea of a CMS but end up barely touching it in the end because it's too complicated).
Better solution IMO is to use backticks for code style e.g. `__get` and `__set` Outputs: `__get` and `__set`
I've had jobs with great colleagues, nice office and such. But they just had shitty code. It was really from one vulnerability to the next one and hoping the client don't get angry. That's why I left there. So yes, I look at their technology stack and part of that is framework (like I avoid Zend Framework). Let the downvoting begin...
I have to admit, I didn't even think that would work (and I have to test it to know to which "if" the "else" really corresponds) -- and I would definitely not like PHP to introduce any additional case like this one. Still, this means the "else" in my earlier examples would correspond either to the "if" or the "while", and you'd have no way (except using {} of course) to attach it to the other one -- like here the "else" answers the inner "if" and you have no way (except with {}) to make it answer the outer "if"
API seems slick, but it'd be even neater if it implemented a more optimized regular expression routing (as explained by [nikic](https://nikic.github.io/2014/02/18/Fast-request-routing-using-regular-expressions.html) and implemented by [FastRoute](https://github.com/nikic/FastRoute) and [PHRoute](https://github.com/joegreen0991/phroute)) Edit: working https instead of 404 http
I may be alone in that feeling so dont take it the wrong way but, why ? Isn't there already enough routing packages out there that this was necessary ? Hell there are nearly as much routing packages than container packages, and that's saying a lot. I appreciate the effort and it's always a nice excercise but, I â€“ again, personally â€“ don't really feel there is a need for it is there ? What does it do more or better than, say, symfony/routing, auraphp/Aura.Router or illuminate/routing ?
Importance of Yii Development services : Easy to create layered structured design :Simple error handling :Highly secured :Quality product development Etc These are quality of Yii, and thats y Yii framework is ppopular in the e commerce industry. 
It's definitely a negative. You basically have 3 types of frameworks in the PHP world:- Big; Flexible: Zend &amp; Symfony. Middle, on rails: Laravel Small; Flexible: Silex, Slim, etc. Simple question but if you can find reasons not to use the big or mid sized projects, why aren't you starting from an established micro?
Yeah, it started out as me just exercising my PHP muscle a few years ago but by itself it got a little exposure on GitHub and people started contributing - apparently there's a need for a super simple router like this. Most people are using the class for extremely simple prototypes where development speed is key. It's also used as a module in some WordPress libraries, afaik.
Okay thanks. Forgive my noobness... Would I do a separate foreach for every element? So : foreach ($dom-&gt;getElementsByTagName('title') as $item_title) {echo $title} foreach ($dom-&gt;getElementsByTagName('description') as $item_desc) {echo $title} 
Same.. I worked on a project that had a decent basic custom MVC framework. One of the things we added was a "data" class and in the constructor of each object you had a definition of the data types and validations for each property. The setter would validate the data and set the error flag and messages. After setting all the controller would ask the model if it was valid and if not then retrieve the errors and handle it. For what they needed it worked quite well. Since the setter was identical in all of the models it was in a ModelAbstract along with several other common methods.
Is the framework decoupled from the job? Good question.
Even the ones that don't suck, will next year.
A lot of angry people making assumptions is probably what got the push going behind the BC service provider :P
It's just a router with no other frameworks involved. I always like seeing people's takes on them.
I wouldn't really refer to a 10-sentence blog post as "article".
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Duck typing**](https://en.wikipedia.org/wiki/Duck%20typing): [](#sfw) --- &gt; &gt;In [computer programming](https://en.wikipedia.org/wiki/Computer_programming) with [object-oriented](https://en.wikipedia.org/wiki/Object-oriented_programming) [programming languages](https://en.wikipedia.org/wiki/Programming_language), __duck typing__ is a style of [typing](https://en.wikipedia.org/wiki/Type_system) in which an object's *[methods](https://en.wikipedia.org/wiki/Method_(computer_programming\)) and properties* determine the valid semantics, rather than its [inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming\)) from a particular class or implementation of an explicit interface. The name of the concept refers to the [duck test](https://en.wikipedia.org/wiki/Duck_test), attributed to [James Whitcomb Riley](https://en.wikipedia.org/wiki/James_Whitcomb_Riley) (see history below), which may be phrased as follows: &gt;When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. &gt;In duck typing, a programmer is only concerned with ensuring that objects behave as demanded of them in a given context, rather than ensuring that they are of a specific type. For example, in a non-duck-typed language, one would create a function that requires that the object passed into it be of type Duck, in order to ensure that that function can then use the object's walk and quack methods. In a duck-typed language, the function would take an object of any type and simply call its walk and quack methods, producing a run-time error if they are not defined. Instead of specifying types formally, duck typing practices rely on documentation, clear code, and testing to ensure correct use. &gt; --- ^Interesting: [^Type ^system](https://en.wikipedia.org/wiki/Type_system) ^| [^Groovy ^\(programming ^language)](https://en.wikipedia.org/wiki/Groovy_\(programming_language\)) ^| [^Alex ^Martelli](https://en.wikipedia.org/wiki/Alex_Martelli) ^| [^Python ^\(programming ^language)](https://en.wikipedia.org/wiki/Python_\(programming_language\)) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cl3rboq) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cl3rboq)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
The framework they use is a big consideration in determining whether you'd like working there or not, as well how much they should be paying you. If I had to work on Joomla / Magento / ShittyFrameworkX sites all day, vs Laravel / Symfony all day, I would want to be paid a minimum of $15,000 more/year to deal with other people's shit code. Double that if management's approach to Joomla / Magento / ShittyFrameworkX amounts to "yeah just slap a theme on there and install some plugins and you'll be done by next week", while you work endless overtime to meet unrealistic deadlines given how much you'll be fighting other people's technical debt to achieve what would be trivial in a real PHP framework. Imagine taking a job as a carpenter contractor and they expected you to build decks using a flat head screwdriver they provided...
PHP uses quantum memory for its variables, observing them changes their value. That's ok because quantom memory has web scale performance.
Are you using PHP 5.2 by any chance? DateTime was notoriously broken pre-5.3 and IIRC this was one of those bugs.
Never mind, someone on stackoverflow gave me a bit more info. I really appreciate your input! :)
you know you're in /r/php right? not /r/node, /r/orm, /r/ftpspecs, or /r/isoundbitter If you understand the needs of the community at-large, why don't you do it.
If you are writing threaded application in PHP you have picked the wrong language.
Very same here.
They push agenda and techniques I personally strongly disagree with and most of them are over engineered by nature. 100% of the time I will produce a product quicker, better optimized, with smaller code base, with a custom solution than any of these framework.
&gt; *Features* &gt; &gt; Full featured No. Just... no it isn't. Aside from the fact that "full featured" is a pretty meaningless term, this framework has glaring omissions. It would be more reasonably argued that this is a micro-framework rather than a framework, but even for a microframework this seems to be minimal. Not actually MVC at all, and missing a bunch of stuff. Which is fine, but you can't say "full featured" and also tiny. It just doesn't work. Also... no composer? No interest.
I'll give you the other side of the coin: I do not hire programmers which have only worked with open-source frameworks. From experience, they tend to drink the kool aid too much and are unable to think and operate outside of it. It's a big no no for me, I want programmers than can think for themselves, that understand why the current frameworks are overkill for 99.5% of website out there (they are). Framework developers are over engineers (that a bastard term I invented) by nature. Nothing wrong with it. Just that I find these frameworks do not solve any problem if you know what you are doing. I know PHP top to bottom, left and right, and firmly believe these framework are fundamentally flawed in that they try to present PHP for what it is not. I always get shit/downvoted for this opinion. But more than 15 years programming PHP, in very wide range of situations, has shown me that the only proper way to use PHP is to keep it as simple as possible: request comes in, route, get data, generate html, return. Nothing more, nothing less. For example that's my "framework" : https://github.com/Mikushi/Tachyon , it runs many applications out there and has been praised by all developers I've introduced to it because it's no bullshit and takes exactly 2min to learn, the rest of your application, standard PHP will do. My philosophy summarized somewhat here: http://microphp.org/#!/
From the description it provides security in the fact that a user can be created with the exact permissions it needs to access specific data. i.e. a read only user for read only operations to, as you suggested, mitigate injection and similar attacks. This was a normal thing to do to mitigate certain types of attacks 10 years ago... Now-a-days there are much better ways to mitigate the same attacks, such as using stored procedures. So yup, this is useless in a real world scenario.
It's my go-to CMS for most things. Been using it for over 5 years now, so I'm quite proficient. Their documentation, framework organization, and coding standards all need work. I'm in agreement there. However, in terms of making a the website administration highly usable for clients I haven't really seen another open source CMS that competes. I barely even give my clients training sessions - I just ensure all page and data management is documented and restricted.
It's correct though. Feature Detection is correct. 
I'm not saying anything about the quality or usefulness of the project ... just the marketing is a little goofy. #getoffmylawn
Well there's the problem.. we haven't deprecated brace-less blocks yet. ;-)
Doing a great job mate! You have made keeping track of internals a lot easier. It is much appreciated!
Alright, i guess that makes sense, but you are losing some of the benefits that using a popular framework like these provide.
There are lots of really big differences. An update won't remove the record, so you maintain referential integrity, avoid cascading deletes, don't affect table counts, and all kinds of other things. Dropping a table will prevent further inserts/updates and wreak all kinds of havoc that deleting records will not do. There is no functional difference between truncate/delete access, though, so I'd always group those together. The others should absolutely be separated.
A lot of things in PHP could be described as "odd".
Aren't there plenty of ways to grow even outside of the workplace?! Must the position to teach me new skills, or pad my resume -- or are there other ways to accomplish either outside of your primary job.
If you want to track MySQL errors and general php errors, these should be logged to a log file. You can then use a program like [LogStash](http://logstash.net/) to aggregate and parse logs. You'd need to aggregate logs assuming you have multiple database and web servers you're monitoring. I'm not sure what all is entailed with "tracker that does everything i want", but if you're tracking errors do it in a logger. 
Why? (I no longer work there, part of the reason for me leaving my Lead Dev position on the tube sites was the introduction of Symfony 2 on Youporn)
Awesome! Any live examples where it's being used? Would love to see it. :-)
I just fail to see a situation where PHP would need threading. PHP is a web language to make websites, and I really struggle to see the use case for threading on a website. On back office services? Sure, but I practically never use PHP for that, that's not its job.
So you code all the rest for configuration, forms sanitation &amp; validation, models &amp; db, migrations, authentication &amp; security, testing &amp; mocking, localization &amp; internationalization, views &amp; json/xml output, cache layers &amp; so on ?
Thanks, I appreciate this library, but the documentation is lacking for basic tasks. I've been reading through it and I don't even know where to begin in what I'm trying to accomplish.
You don't really need a library, I posted this a few months ago for someone else: http://www.reddit.com/r/PHP/comments/2gnrmd/ldaps_communication_protocolports/
Just tested on 5.4.1 and it's the same. Also, it appears that the __wakeup method is where the change occurs: $y = new DateInterval('P1Y'); $x = new DateInterval('P2Y'); echo ($y &gt; $x) ? "t" : "f"; //f $y-&gt;__wakeup(); echo ($y &gt; $x) ? "t" : "f"; // t but strangely, if you `$x-&gt;__wakeup()`, it goes back to 'f'. But the root of the problem is that DateInterval hasn't implemented any kind of comparison.
[Monolog](https://github.com/Seldaek/monolog) is great, especially combined with a service to manage the resulting log files.
http://www.clipgif.com http://www.embossify.com http://www.boticus.com plus many more still in BETA. 
- Configuration? Like there is anything to code there. - Form sanitation &amp; validation, short answer, yes, but I will admit I have Sublime Snippets for a lot of these. I prefer it that way, generate a **lot** less code that having a library. - Models &amp; db, I usually write a very very thin wrapper around PDO just to add cluster support, but PDO offers everything I need as far as DB goes, plus I insist on writing SQL myself, it's the most critical part of any application by a mile, I want to control it. Models, I actually do have a boiler plate class, my bad, that goes hand in hand with my thin wrapper for PDO, then it's pretty straight forward. - Migrations, of birds? I know what you mean, but seriously, how often do you migrate stuff? For database migration is use Flyway - Auth and security, that's a tricky one, depends what I need, but yeah, most of the time I take care of that myself. Security is more of a concern on the overall architecture and setup than inside PHP itself (because I know what not to do, and keep myself up to date). - Testing and mocking. I do use PHPUnit, and I realise it's a framework, but I thought it was implied we were talking MVC framework here, PHPUnit is not that. - Localization &amp; internationalization, in 15 years only had to do it once, on Pornhub. gettext/intl are there for that. - Views / Json / XML. I use straight HTML with PHP as "templates", they get called in the controller straight up. Json, well `echo json_encode()` is not sufficient for you? I fail to see what else do you need. - Cache layer. When I was at Pornhub, sure, written by hand, same as DB, I don't trust someone else to do a better job than me at caching **my** data. And to be honest, these days I have done a lot of websites that run on Redis as read data layer, it makes your life and code so much easier to deal with. Front-end cache is handled by my "framework" in the form of facilitating the addition of appropriate headers, I slap Varnish in front and call it a day. And a properly setup MySQL with a properly written PHP website can handle a lot of traffic on its own, you should be able to handle a million visit a day without a cache layer without sweating on a relatively small server. Keep in mind I'm a nutter and for me any use of PHP outside of making websites is not even worth discussing as I don't consider it the use case for PHP in any stretch. And for me websites are not complicated as far as application architecture and design goes (which is my actual expertise). I know I sound arrogant, and there is probably a touch of it there. But that has been my experience, and my career has been successful as a programmer (it's no longer my main occupation, I do code almost every day still), both on the web and in other domains. Application architecture is what I consider my "gift" if you will, what I'm good at, I didn't always think so, but my peers seem to agree and if I want to progress believing in myself is a key component.
You can authenticate them with Apache's LDAP module.
I installed a Sentry server on DO this week to log to with monolog and catch errors/exceptions. Best. Decision. Ever.
can't do it in php. so you're essentially saying use js instead.
I use Zend LDAP frequently for auth and it works fine: http://framework.zend.com/manual/1.12/en/zend.ldap.introduction.html
Can you explain the point of this to a noob?
The ZF2 implementation seems good too. http://framework.zend.com/manual/2.0/en/modules/zend.authentication.adapter.ldap.html I think I have a repo with the ZF1 implementation using a whitelist. The class was written 4 years ago though.
as far as I'm aware, BC service provider was mentioned around the exact same time as the restructure was announced.... 
You already noticed the irony. 
Related, but covers also the OS, device, â€¦ [device-detector](https://github.com/piwik/device-detector)
Interesting!
Have a look at [Piwik](http://piwik.org/), it's an open source alternative to Google Analytics and you can write plugins to add any behavior you want.
&gt; I installed a Sentry server on DO this week to log to with monolog and catch errors/exceptions. This. Sentry is the best!
+1 for Piwik, been using it since early version 1. Amazing product.
I'm a big fan of Piwik.
Tinker is a lovely feature when it can work with Boris - it reminds me very much of Rails' console. However, for all the trouble to get it working properly with MAMP I find it's easier to stick with Homestead. Homestead supports the good tinker out of the box, along with everything else Laravel can make nice of.
This [sentry](https://github.com/getsentry/sentry)? DO=DigitalOcean? Is sentry free if you install it yourself?
&gt; This sentry? That Sentry, and I am guessing DO is Digital Ocean for the OP. Sentry is indeed free if you install it yourself (the repo you linked to is the code that runs on the main site, and has a great install guide if you want to DIY.) EDIT: Here (https://github.com/rchampourlier/docker-sentry) is a docker setup that does what it says on the tin. Run Sentry inside docker containers \o/
Of course WordPress is a framework, just not a very good one.
&gt; I still don't quite get how they're different than a pre-made VM image. Check out http://developerblog.redhat.com/2014/05/15/practical-introduction-to-docker-containers/ notice the first box, where the "cat" command is ran in a docker container, and how fast it is to run? Docker containers start *really* quickly, and require only a very small amount of configuration to get services up and running inside them.
&gt; DO YOU EVEN COMPOSER.JSON???? Specifically, autoloading, not just composer.json, or even composer. Also, whats wrong with jquery 1.1.0.2? Finally: &gt; ADD MORE XML what?
Honestly? Looking through your code, this project will struggle to attract anyone. It's procedural, there's no autoloading, it relies on global variables, and will be a nightmare to maintain. I'd really recommend having a look at learning how object oriented programming works better, because whilst you're using classes, you're still implementing your code in an extremely procedural manner. It's just a big chain of includes. Have a look at implementing some good patterns that will help you write in the right way, for example [MVC](http://php-html.net/tutorials/model-view-controller-in-php/). There are also various frameworks like Symfony or Zend that can help push you in the right directions.
We use GA plus some custom stuff we've written ourselves. Look into Kissmetrics. We've used it in the past and I was pretty impressed with the reports that I could generate. It is a paid service though. We've also used Piwik as others here are recommending, definitely something to look into as well.
Don't look in [/models/funcs.php](https://github.com/alexweissman/UserFrosting/blob/master/models/funcs.php) &amp;#3232;_&amp;#3232;
Agreed. There are plenty of resources out there that will help you understand design patterns. If you're new to the concept, I would recommend [Head First: Design Patterns](http://www.amazon.com/Head-First-Design-Patterns-Freeman/dp/0596007124), it might be based on Java, but the examples are simple to understand and can mostly apply to PHP as well. When you feel like you've grasped the basic concepts of design patterns, you can move on to more advanced texts, like [Martin Fowler's Patterns of Enterprise Design](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420) - this is a great reference for a lot of the more common patterns. There is also [Refactoring: Improving the Design of Existing Code](http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672). These are great investments that will help you with any project you work on, and will help you if you decide to use a framework like Zend which uses design patterns very heavily.
FTFY: class SchroedingerDateInterval extends \DateInterval {} 
&gt; In other words, is this intended behaviour, or a bug? Can't comment on the intentions of anyone else's code, though I hear good intentions make [great pavement](http://en.wikipedia.org/wiki/The_road_to_hell_is_paved_with_good_intentions). FWIW, you could roll your own interval management class with [`strtotime()`](http://php.net/manual/en/function.strtotime.php) to do exactly what you'd like to do here*. \* Interestingly enough, `strtotime()`'s behavior changed in PHP 5.3 ...
Projects get large user bases by starting out as being something people want to use. This generally means they solve some problem reasonably well - or at least, they solve it better than similar solutions. They continue to remain popular if the userbase is attentive to it. Projects that haven't had any updates in a year tend to peter out and die, but projects that cater to their userbase usually flourish.
User account management and registration scripts are boring. That's also why reinventing the wheel there is commonplace for PHP. There's a neverending stream of blog posts about that, and newcomers are cobbling together these things insecurely+badly relentlessly. Which is of course where your niche is. While I'm also no fan of unreasoned namespacing and all-object-structuring, your code is getting a bit convoluted from following the opposite extreme. Though of course, it mostly concerns the UI code here, and its pretty interface and the feature list speak for themselves. I'm still unsure if you can attract many experienced developers for it, because it's just really just another implementation of common functionality. It's pretty, but not novel. It doesn't solve any of the hard problems (e.g. ad-hoc accounts, to allow for OpenID accounts as core concept, non-numeric user ids, alternative SSL client authorization, AJAX-based HTTP authorization), nor bend to an existing database table scheme (peek at PEAR LiveUser for historic interest). Your website and documentation are great. So you already had everything in place to attract co-developers. You could fix your Changelog (that you have one already puts you above of 90% of the typical github dump) to the established Changes::Spec format. Submit to [freshcode.club](http://freshcode.club/) then, make up a plausible restructuring question for [codereview.SE](http://codereview.stackexchange.com), mirror on Sourceforge (still somewhat relevant), dump on phptrends and packagist, and generally watch PHP forums/bulletin boards for interested new users, write more blog posts about it.
Different behavior on [HHVM](http://3v4l.org/H8XI5)
I feel you, at the company I work for, we're running 6y+ old webapps on CI. So far, nothing major to complain, we are using composer painlessly, we haven't touched CI guts at all, everything has been done extending it (OOP way). I'm sure I'm missing some good stuff from the newest things, and I'm sure I'll sure something like Laravel if I need to start a new thing. But for now, I can say that CI has been really good at keeping up the pace.
Piwik is fun, and lets you do interesting things like embed their widgets in your site if you want to view stats from within your app, or show your users certain subsets of data. I found that it buckles under load though unless you go in and tear out a bunch of the internals. Like... why is it the default to load all of the languages?
I've really enjoyed using Keen.io - they make it easy to record events in javascript or from php. You can create event types and data on the fly. You can view charts of your data which are embeddable elsewhere like your own dashboard or you can retrieve that data as JSON.
Inspired by Sinatra? Hmm, that's strange. It looks familiar... - Match Types - [AltoRouter](https://github.com/dannyvankooten/AltoRouter/blob/a7a6b99ac86c4e601a3611d43f755373efec5280/AltoRouter.php#L8-L15) - [Klein](https://github.com/chriso/klein.php/blob/46e8916d2d96eb9036ca0fcb21b984e6c240bdd4/src/Klein/Klein.php#L708-L716) - Route Compilation - [AltoRouter](https://github.com/dannyvankooten/AltoRouter/blob/a7a6b99ac86c4e601a3611d43f755373efec5280/AltoRouter.php#L243-L269) - [Klein](https://github.com/chriso/klein.php/blob/46e8916d2d96eb9036ca0fcb21b984e6c240bdd4/src/Klein/Klein.php#L707-L737) - Route Matching - [AltoRouter](https://github.com/dannyvankooten/AltoRouter/blob/a7a6b99ac86c4e601a3611d43f755373efec5280/AltoRouter.php#L198-L215) - [Klein](https://github.com/chriso/klein.php/blob/46e8916d2d96eb9036ca0fcb21b984e6c240bdd4/src/Klein/Klein.php#L518-L535) I mean, c'mon, even the comments... To be honest, it doesn't really matter. The code is open source and MIT licensed. [I wrote v2 of Klein][klein-v2-pr] over a year ago to improve the procedural library that the original Klein was. ... but damn, if you're going to be that shameless in your copying, you might want to at least throw a mention towards Klein. ;) ----------------------------------- **Edit**: I've since noticed that the project mentions Klein right in the `README.md`. Sorry for getting on the defensive. I must admit that it's definitely still funny that so much of the code is copy-pasta, though. ;) [klein-v2-pr]: https://github.com/chriso/klein.php/pull/92 [attribution-example]: https://github.com/Rican7/Paulus/tree/release/2.0.0#attributions
I can tell you this: base64_encode(sha1($password . $salt, true) . $salt); is not a secure method of storing passwords. Edit: And why do I see md5() everywhere?
well i do like one liner braceless blocks sometimes, but if it ever crosses into two lines.. out they come!
Question is still a bit unclear, are you trying to post the data into the database, or are you simply trying to echo out the data to be seen?
No problems. The strongest solution is [scrypt](https://github.com/DomBlack/php-scrypt). Otherwise, use PHP's [password_hash](http://php.net/manual/en/function.password-hash.php) As for MD5, I would just do a find and replace to change every MD5 to SHA256.
I'm assuming this is protection against malicious users? If not please correct me, but there is no point in referential integrity when all of your data has been updated with garbage. It doesn't help to know that user 22 has address 345 when their name is "0000000" and they live at "000000000000000". Of course you are correct about inserts/updates still being available, however isn't this a bit like having your entire house burn down and being happy the fire place still works?
Right now, I am trying to echo what is input into a form Long run, I want to store the inputed text from the form into a database that I can then query and echo onto the page
I would recommend googling basic form/form-to-database tutorials, this is all basic php tasks that have thousands of tutorials to do what you want. [Here I'll get you started, also, learn how to google, since this was the second post and probably could've saved you the hour you waited for this response.](http://www.w3schools.com/php/php_forms.asp)
On the HTML page called form.php, put this: &lt;form name="form_name" action="result.php" method="post"&gt; Address: &lt;input type="text" name="address" /&gt; &lt;/form&gt; On the result.php page (in the same directory), put this: &lt;?php echo $_POST['address']; ?&gt; If you entered "123 Main St" into the "Address:" form field on form.php, this would be your output: &gt; &gt; 123 Main St
Sending mails directly from your server is a baaad idea. Many times it will be marked as spam, other times they will simply get rejected and if a hacker somehow gain access, it will most likely use it as a spam source, which will get up in trouble. Try using a third party like Mandrill. 
its not, neither drupal or joomla
print_r($HTTP_POST_VARS); Or similar.
There are a lot of different websites where you can find people for the job, but /r/php is for sure **not** one of them.
"Yes I can go to freelancer, odesk and that, but I like to reach out to communities first, then job boards."
Thanks for some quite cool ideas :)
Pushing the error reports to the queue sounds reasonable. Anyway, I just checked one of our projects and turned out, that error logging is turned off on production. I asked why and the project leader said that writting to the log file was "killing the server". The log was a built into Yii framework mechanism. Something is obviously wrong here.
... and Slim and Limonade and ... ? :)
While I find the documentation to be adequate, there's almost too much of it. The search function on api.silverstripe.org is great, but only if Google has brought you to the correct version of the API. The lack of solid, real world examples of how to do something is probably the most off-putting. However, because every part of the core is heavily unit-tested, you can usually look to the unit tests to see how a particular piece of code is intended to be used. As for your initial question, your model is pretty much anything that extends DataObject. Model in MyThing.php: MyThing extends DataObject {}
Regardless of your quote, /r/php is not a place to post job listings.
I have a couple on some projects i'm working on....
Hey there, you're absolutely right which is why I am linking to klein.php in the first sentence of both the readme and the site. I used klein as a starting point when the code was still very procedural while I wanted to build a more object oriented router. This was over 2 years ago though. Haven't looked at v2 yet, will definitely do so! Not for copying it over into AltoRouter, by the way. Although it is within the rights of the MIT license. ;)
Since when is "one file" a pro to boast about ? If something crash I don't want to crawl through your 1000 line file. I don't care about size either, who still cares about it nowadays ? This isn't Javascript, use Composer and PSR your classes.
This is cool and all, but I'm not sure why it has to be included in the Symfony Twig Bridge. It seems to me like any Sf form theme aside from the default (ie: Bootstrap, Foundation, UI Kit, your own) should be inside your own project's resources or a separate download (Bootstrap Bridge?), not in the Twig Bridge
Ever heard of using /sarcasm to show you're being sarcastic?
Because the core can never be improved *that* much. PHP has no type safety, and because of that any zval can contain anything at any time. Since Recki-CT *requires* docblocks with type information, everything becomes much easier to optimize. This is mostly true for most type-safe systems.
" this means you can turn a limited subset of the PHP language into machine code at runtime." this means only very small parts can be optimized. if you optimize 1% of the code 100%. or you optimize 100% of the code 1%, you get the same result for much less work. And you now have to maintain, test, .... a PECL extension etc...
Many people may not have time outside the workplace (maybe you need to care for children, adults etc.). Any job vacancy for a professional developer should have at least some time put aside for developing your skills. 
&gt; "This is better than what's been done in core because this was done by us" This can't be serious ... &gt; What's the problem with making PHP run faster? No problem. The optimizations that have already been done in the master branch don't include a JIT, I'm simply advocating that we keep it that way. The current optimizations prove to me that it's not necessary. A JIT is an *extremely complicated* layer; introducing extreme complexity (JIT) into something that is already extremely complicated in it's own right (Zend) is *simply not appealing*. &gt; I dont want all the hassle of looking for what part of the code I should be converting to C or a PECL. Then simply don't, master (based on the next generation improvements) has made such good advances that you don't have to consider it, at all. Review my actual words again: &gt; I understand the attraction of running code directly on the CPU, I understand that even **while most of us don't need it**, none the less, we want our code to be as fast as physics and the engineering of the day will allow. I wasn't saying, at all, that we should not bother to continue improving PHP in order that we solve all our problems in userland. I am saying to this particular problem, of running code as fast as a CPU will allow (that isn't actually a problem for the vast majority) we can do better than dressing up Zend to look like HHVM.
Can't say I've ever experienced these problems when things are properly configured (e.g. the server is a permitted sender in the SPF record).
Yea, I made an edit after I noticed the attribution in the readme. :) Definitely check out Klein v2. I'm releasing 2.1 soon. ðŸ‘
Apparently, there is a [bug](https://bugs.php.net/bug.php?id=49914) that makes it difficult to compare two `DateInterval` objects in PHP like you can do with `DateTime` objects. In any case, the `var_dump` is, in fact, interfering in the state of the object and this is indeed a weird thing.
Exactly. Imagine back in the day those crazy people saying they invented a revolutionary new way of transportation. Then comes a guy and says: "Why? I am very happy with my horse." New technologies, new paradigms, everything revolutionary may be seen as "re-inventing the wheel" from time to time.
I could be wrong, but I believe it would be something like $x = $node-&gt;{'123column'}; Though I would just ultimately discourage you from naming your columns this way in the first place.
It works! :D Thanks a lot! I wouldn't name my colums with numbers as well, though I use a database coming from a different program. I ran into this issue today, but thanks to you the problem has been solved! :D Thanks a lot good sir/madam!
I wonder which framework might use the incorrect terminology.
Depends on you budget and what you're looking to track, and there are typically two types of tracking - application behavior (often called Application Performance Monitoring) and user behavior (often called just Web Analytics or Customer Analytics). Application behavior is for things like DB errors, load times, timeouts, etc - look at New Relic, Appdynamics, Splunk. On the user behavior side, if you're looking just for basic pageviews and clicks, then GA or Piwik will do. If you're actually looking at tracking events (like signups, purchases, etc), you need things like funnel analysis (e.g. see where your customers drop off and and where you can optimize), and cohort or retention analysis (e.g. see how groups of customers perform over time), then you'll need a real web analytics platform. I'm biased of course, but I think what we built at www.indicative.com is the best web &amp; mobile analytics platform out there currently - also we have a super generous free tier - if you have under 10,000 monthly visitors we're free forever.
&gt; I dont want all the hassle of looking for what part of the code I should be converting to C or a PECL. &gt; Then simply don't, master (based on the next generation improvements) has made such good advances that you don't have to consider it, at all. This is what I mean by the first sentence, the core has improved enough, and you dont seem to like it because it's too reminiscent of HHVM, while in your response you say it's actually not, since the improvements in core do *not* include JIT... Now i'm just getting confused :)
Don't forget that the reason many of us are looking to HHVM is the new features in hack, and the fact that the people leading PHP don't give a shit about what the rest of the community wants. Php needs to evolve if we want to evolve our image as developers beyond the shitty reputation we currently have. HHVM and hack are a solid move forward, and you can see the old guard getting nervous.
Agree. I get that Bootstrap is popular, but it's just that: popular. Something else might come along. It feels kinda funny to me, like we're tying Bootstrap officially to Symfony. What if you want to use something else, like /u/breper said, like Foundation or whatever? I feel like it would make more sense if you could add the Bootstrap/Foundation/WhatHaveYou theme as a composer dependency. But yeah, the PR's been merged. Should've weighed in when the discussion was still going :p Luckily they're not adding the .css and .js files. That would be entirely other grey area. 
&gt; Don't forget that the reason many of us are looking to HHVM is the new features in hack Understood, there's nothing we can really do about that ... &gt; and the fact that the people leading PHP don't give a shit about what the rest of the community wants I don't know from what perspective you view things ... before I say what I'm about to say; *I'm not attacking anyone*. From my point of view; to have an effect, to be a voting member on internals, takes no effort at all; all your community leaders need to do is actually get involved. If nobody in a position of leadership is involved in internals, then you will have no voice; that's clearly not the fault of the PHP project. &gt; HHVM and hack are a solid move forward That's a matter of opinion, opinions I don't care to discuss ...
Check out [The Pareto Principle](http://en.wikipedia.org/wiki/Pareto_principle). 80% of the load time of your page is caused by 20% of the code (in practice it can be much more severe, like 95%/1%). So this allows you to take those hot areas, compile them, and leave the rest of it running as PHP. Boom, most bang for your buck. And no, it's not 1%... It's more. Also: you don't need to maintain the PECL extension. You maintain the PHP code it compiles from. They on "build" (deploy), you compile it into an extension (`.so` file), and install it into your server. End of story. Not much work. 
&gt; This is what I mean by the first sentence, the core has improved enough, and you dont seem to like it because it's too reminiscent of HHVM Therein lies your error in trying to interpret what I was saying. To be clear, Zend today is nothing like HHVM. The purpose of the post is to introduce people to the idea that maybe the next thing for Zend doesn't have to be JIT, it's worth pursuing other optimizations that do not result in extreme complexity, but actually make things simpler.
One of the comments on the blog implies Laravel. **edit** yay for random downvotes.
I make no mention of frameworks.
Look at the commit though - https://github.com/lyrixx/symfony/commit/cfc04a6e8dd96c4a2dc7bf9d75c26afd5966ec0b - its basically someone (lyrixx) has taken the time to go through the current twig form templates and bootstrap-ise them. Thats all. If someone can be bothered, there could be one for Foundation, or any of the others. And then all you need to change in your app/config/config.yml is resources: ['foundation_layout.html.twig'] or whatever. It's a cool feature. It does feel a little bloaty, but Symfony never has been lightweight. And if it encourages developers to more readily adopt a framework, whichever that may be, then so much the better. Not that a framework is *the* solution to every problem, but that's a different can of worms ;)
what is the value of this book? are Desing Patterns for php related language of just wikipedia design patterns for php?
It's not necessarily the worst idea, but this is an area exceptions are designed for: try { $response = Cache::add("key", "value"); } catch(Exception $e){ //handle failed response } When throwing exceptions you can pass the code and a human-readable error message directly to any code that wants to investigate the failure.
While some may be quick to say that this is a direct strike on [Laravel](http://laravel.com/docs/4.2/eloquent#working-with-pivot-tables) (as pmjones may or may not have done in the past), there is a difference. Even in the RDBMS world - see the SQL Server documentation on [PIVOT and UNPIVOT](http://technet.microsoft.com/en-us/library/ms177410%28v=sql.105%29.aspx). A pivot generally refers to the reversing of columns and rows, as Paul explains in the article.
Exactly. This is part of their DX initiative, and it definitely speeds up development for anyone using bootstrap (while not affecting non-bootstrap users at all). Besides, it's not the kind of bloat that actually affects performance, just the install size, which to me is silly for anyone using a full scale framework to complain about. When you really need to optimize your app, you'll probably remove Twig anyway.
India PING!
Being a PHP newbie, I am struggling to understand the impact of this (Recki-CT) software. Whatever gets compiled into whatever, what can we expect from it at the end? I am assuming performance boost one, but how fast will this even load a wordpress page? 
Just the nsa applying some patches. Nothing to worry about citizen.
May I also offer this https://github.com/domnikl/DesignPatternsPHP as a well regarded resource of PHP design patterns ( and, of course, not a source of future book material )
Good God man, we get it! You're really coming off like a linguistics warrior who writes a little PHP code once in a while lately.
Whoa, I've never come across this before... Clear UML diagrams, warnings about anti-patterns, easily digestible examples. This is great. Thanks for the link. 
[A nod's as good as a wink to a blind bat](https://www.youtube.com/watch?v=jT3_UCm1A5I)
This isn't a useful approach if you're only distinguishing between success and failure - as /u/fieryprophet has already pointed out, that's what exceptions are for. Many years ago (and occasionally still for embedded programming, and other cases where resources are scarce) you'd see functions return values based on bit-flags, e.g. define ('SOME_STATUS', 0x1); define ('ANOTHER_STATUS', 0x2); define ('MORE_STATUS', 0x4); and then you could return multiple statuses by bitwise-ORing them together ( `return SOME_STATUS | MORE_STATUS;` ). You check the return value via bitwise AND ( `if ($return &amp; ANOTHER_STATUS)` ). As a convention, flags are much more common and flexible than descending integers. All that said, this is something few PHP developers need to bother with these days, since unless you're building and passing these returns millions of times per request, it's probably a microoptimization. If you absolutely need special response codes, and can't just catch an exception, you could use arrays and `list()` to return multiple values. Go and nodejs projects will do this for most functions (Go doesn't even have exceptions, and node is heavily reliant on callbacks, which make exceptions less useful). I suppose if you were using pthreads and were doing some async functional programming, that might make sense. A big advantage of this approach is that you're not getting some mysterious response object returned that you have to analyze and figure out -- the first element will either be the object you expect or null, and the second will always be an error message or null. e.g. function foo() { /* run some things */ return [$result, $message]; } list($myThingy, $err) = foo(); /* Do stuff with $err, if it's set */ It's unlikely most programmers will be working on anything where they'd need to do that, but the options there if it's a requirement. For the vast majority of work, make a function return either the object it's requesting or null (e.g. getCurrentUsers()), or true or false if it's a method that you'd expect to be boolean (e.g. isUserActive()), and in either case throw an exception if things failed and require a message. 
Sadly, no. It's been a year and the only explanation I can come up with is that they still don't know *how* the breach happened so they choose to remain silent about it. I'd love to hear other theories as well because if I'm right, it's just sad...
&gt; linguistics warrior Hey, I kind of like that. Maybe "Vocabulary Justice Warrior" (VJW) ;-)
Thanks for the honest feedback. I actually agree with you. I thought I could get away with a procedural system at first, but over the course of developing the project I've realized that we sorely need a more OOP approach. In particular, we need some sort of ORM for DB operations instead of writing a new function every time a table is altered. I feel like I've added quite a bit of structure and separation of layers already (DB, auth, validation, templating, api, etc), but I'm still not certain what exactly qualifies as an "MVC approach". I mean, we have a model (the DB and data transformations) which is fairly well separated from the rest of the code. We have the view, which consists of the frontend pages and the forms/tables APIs. The data API and templating/validation functions seem to me to fulfill the role of "controller". So, maybe I just need to separate these roles further, and genericize the code better via OOP? I'm purposefully staying away from building this on top of an existing framework, as part of the philosophy of the project. I want this system to be something that is ready to go "out of the box", and then easy for developers to modify to suit their applications. But, I don't know. Maybe a framework is the unavoidable end result of this kind of project.
No, not just malicious users; internal accidents, as well. With the record still there, most things could continue to function unimpeded. For example, maybe you're in the email marketing industry and your app allows you to send emails to a subscriber list, and link clicks are tracked by the app. Since user 22 still exists, his subscriber hits are still being recorded while you pull a backup and restore all his most recent personal details. If the record had been deleted, not only would those hits stop being tracked, but the users clicking on the links are now seeing error pages of some sort, it would break reports being pulled, as suddenly all the user's hits are gone due to a cascading delete, and all kinds of other day-ruining things.
Width logic in CSS, which is where widths ought to be defined.
If you're using Google Analytics only to track page views in an e-commerce site, you're wasting a lot of GA's potential! They have tools for ecommerce tracking that shows store performance, customer behavior and conversion, product performance, transaction history... * https://developers.google.com/analytics/devguides/collection/analyticsjs/ecommerce * https://developers.google.com/analytics/devguides/collection/gajs/gaTrackingEcommerce * https://support.google.com/analytics/answer/1009612?hl=en
&gt; A nod's as good as a wink to a blind bat Say n'more, sir! ;-)
Thank you for this! That's what I thought I just haven't had the time to really sit down with it and crank out the potential 
Those are separate examples. .oneplace is just to illustrate that your li.blogentry could be a child of different parents on different pages (or the same page), but have a different layout for the same html. e.g. &lt;div class="oneplace"&gt; &lt;ul&gt; &lt;li class="blogentry"&gt;This is blogentry #1!&lt;/li&gt; &lt;li class="blogentry"&gt;This is blogentry #2!&lt;/li&gt; &lt;li class="blogentry"&gt;This is blogentry #3!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="anotherplace"&gt; &lt;ul&gt; &lt;li class="blogentry"&gt;This is blogentry #1!&lt;/li&gt; &lt;li class="blogentry"&gt;This is blogentry #2!&lt;/li&gt; &lt;li class="blogentry"&gt;This is blogentry #3!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; The blogentry part is the same, so I can use the same template for it, even cache just that fragment separately. As soon as you start defining classes specifically for layout, you can't do that anymore: &lt;div class="oneplace"&gt; &lt;ul&gt; &lt;li class="blogentry col-md-3"&gt;This is blogentry #1!&lt;/li&gt; &lt;li class="blogentry col-md-3"&gt;This is blogentry #2!&lt;/li&gt; &lt;li class="blogentry col-md-3"&gt;This is blogentry #3!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;div class="anotherplace"&gt; &lt;ul&gt; &lt;li class="blogentry col-md-4"&gt;This is blogentry #1!&lt;/li&gt; &lt;li class="blogentry col-md-4"&gt;This is blogentry #2!&lt;/li&gt; &lt;li class="blogentry col-md-4"&gt;This is blogentry #3!&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; Including classes solely for layout is bad practice. It's just like saying `&lt;p class="red font-size-16 flashing font-helvetica"&gt;Some text&lt;/p&gt;`. Keeping HTML semantic is exactly why many elements have been dropped (e.g. `&lt;font&gt;`) and others were redefined so they weren't specifying layout anymore (e.g. `&lt;i&gt;` and `&lt;b&gt;`).
No, HTML defines the semantics to describe your content, not the 'structure' of the 'site'. &gt; ... HTML conveys meaning, rather than presentation ... ( http://www.w3.org/html/wg/drafts/html/master/dom.html#semantics-0 ) In my last example, the meaning of the html is "this is a list of blog entries", then supplies the content of each of those. Reading it again, I'd probably move the 'blogentry' out of li and define `&lt;ul class="blogentries"&gt;` instead, but that's a separate point. As soon as you start writing 'col-md-4', you're supplying presentation, not meaning. col-md-4 implies 'this should have a width of 1/3rd its container on medium-sized screens', which is quite clearly defining the layout. &gt; HTML does not describe the style and formatting of content, but only the content itself and its meaning. &gt; The creator of a web page can use CSS to define the appearance and layout of texts and other materials. Current best practices in web development encourage the use of CSS rather than explicit presentational HTML. https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Introduction
edit: Misunderstood, onboard, if we can flesh it out more
$items should be initialized and declared an array anyways. If it's not, your problem is bad practices - not needing more control structures.
Bad practice. Either throw an exception if it failed, or return an object if you need more than just confirmation that your function succeeded.
If you follow the link, this is the first thing the author says. And also he argues that there are cases where this is useful, e.g. gathering statistics about your visitors.
Except you shouldn't gather statistics like that. You use analytics tracking which should pull the relevant information with javascript. This will not only give you far more information, it'll also be far more accurate.
Seriously, click the link and read through the page. It uses javascript to pull information from browser. This is far better than Google Analytics, because it doesn't share information with Google and also gives you more data on individual hit.
If something prevented the method from completing its task, it should throw an exception. For something like `Cache::add()`, I can only think of one reason why the method would complete its task but not actually add anything to the cache (it's identical to the existing data). So the boolean return would indicate whether the cache actually changed.
You can even have a custom exception code which can be checked to determine what error occurred: class CacheException extends Exception { const DRIVER_OFFLINE = 1; const KEY_EXISTS = 2; } class Cache { public static function add($key, $value) { $error = true; if ($error) { // error throw new CacheException('Driver offline', CacheException::DRIVER_OFFLINE); } } } try { $response = Cache::add("key", "value"); } catch(Exception $e){ echo $e-&gt;getMessage(); //or use a switch to check the codes and react differently switch($e-&gt;getCode()) { case CacheException::DRIVER_OFFLINE : // do something break; case CacheException::KEY_EXISTS : // do something different break; } }
Not true. The *structure* of the site is a list of blog entries, the fact that they're being displayed in a grid is part of the presentation. You might want to change how that's displayed based on screen size, but it's still displaying the same data.
I've never, ever heard that type of table referred to as an association table. It's always been either relationship table or pivot table.
(/me nods) I've heard "association" and "relationship" and "join" -- if there is some independent or academic literature/website/article/etc somewhere that indicates "pivot" as a known or common term for that kind of table, I'd be interested to see it. EDIT: Specifically, I've heard it as "association" based on the pattern name [Association Table Mapping](http://martinfowler.com/eaaCatalog/associationTableMapping.html).
what was your theory?
That or serialize()
Ugh, codes. Use namespaces and the name of the exception. &lt;?php namespace Cache; class DriverOfflineException extends \Exception {} class KeyExistsException extends \Exception {} try { do_domething(); // throw new \Cache\KeyExistsException; } catch (\Cache\DriverOfflineException $e) { # do stuff } catch (\Cache\KeyExistsException $e) { # do other stuff } If you need to catch a particular family of exceptions, change how you're subclassing. For example: &lt;?php namespace Cache; class Exception extends \Exception {} class DriverOfflineException extends Exception {} class KeyExistsException extends Exception {} try { do_something(); // throw new \Cache\KeyExistsException; } catch (\Cache\Exception $e) { # do stuff }
Easy-peezy with Vagrant + VirtualBox
You can use virtualbox if you want, but I just use WAMP and my IDE of choice. Edit: I think I misunderstood the question. nevermind. 
As long as you don't attack youtubers who are in the hospital recovering from surgery...
I assume vbox = Virtualbox. Which system will you be virtualizing? And what do you compare against in your question? Are you comparing developing in Windows/Linux to Linux/Linux or Windows/Windows? If the latter, than every and anything should be better.
It does not matter in which type `$items` being declared at the start. First, We're not declaring something inmutable, nor PHP has statically typing support. Initializing will override it what you declared before. So, it is possible to initialize something as a variable, then convert it to array, and convert it to null in PHP, because PHP is a dynamically typed language. Second, sometimes you may not be sure about what type `$items` is going to be. For example, selecting some entries from database may return an `empty array`, but it may also return `NULL`. Both are perfectly valid and casts to `FALSE`, so you can do: if(!$items) ... foreach($items as $k =&gt; $v) ... This foreach will always work unless `$items` is an `object` or any other truthy value. Let's get back to our point. Although this will work perfectly and will never raise warnings on `null`/`empty array` difference if(!$items) ... foreach($items as $k =&gt; $v) ... doing this will raise warnings if the response is `NULL`. foreach($items as $k =&gt; $v) ... Therefore, doing this: &lt;?php foreach ($items as $item): ?&gt; &lt;h1&gt;... &lt;?php endforeach; ?&gt; &lt;?php if (empty($items)): ?&gt; &lt;p&gt;No items ar... &lt;?endif; ?&gt; is wrong on so many levels. Also, checking `falsyness` at the bottom is a bad practice. You're executing two statements here. This would be much better with an `else` block, because it will be much more performant since it'll simply `JMP` to the next line. Those are not microoptimizations, just plain knowledge. if (empty($items)) No items in array. else foreach($items as $k =&gt; $v) ... endforeach endif In the end, checking the falsyness and then executing the foreach is much better than executing foreach with no checks, then executing another if block. If PHP had inmutables or were statically typed, what the above example could make some sense. However, relying on data types on a dynamically typed language, especially a language like PHP where mixed function returns is so common? No, thanks. Feel free to continue downvoting.
I don't know exactly what you mean, whether you're talking about virtualizing a headless server or using the guest as a desktop, but I run Ubuntu LTS full-screen in VirtualBox on a Windows 7 Enterprise host all day every day and it's perfect. The host machine is a Core i7 with 8GB RAM, which certainly helps, but I basically don't use Windows: I have allocated the maximum allowable memory to VirtualBox and for all intents and purposes I can't tell that Windows is even there.
After spending a few days with it, it doesn't seem as scary now. It's a huge change from what I've been using previously, but that's because the thing I've been using previously is terrible. Turns out the demo it comes with is a lot larger than what's actually required to run it, so things seemed a lot saner once I removed a few extra files. Thanks all for the help!
That's true, but the savings often really aren't all that significant. So it becomes a question of "do i want to seem clever" or "do i want to write code that's easier to read".
I've a debian VM running under HyperV instead of Vbox, and it works great. I share folders between the VM and the host using samba without issues. The only problem I've had was to make my VM use the hosts VPN connection, HyperV doesn't support nat (or I haven't found out how to do it). I've fixed this installing VMware Player and using the Vmware network controller on my HyperV VM. It works :)
&gt; What makes way more sense, and bootstrap was designed specifically for this I agree it's better, but it's hard to say "bootstrap was design specifically for this" when it's not even documented. 
It's documented here: http://getbootstrap.com/css/#less The docs under 'components' list the classes you can use in your html, but that documentation is also applicable to less (or sass) via extends, e.g. instead of &lt;div id="introduction" class="jumbotron"&gt; You can say &lt;div id="introduction"&gt; #introduction:extend(.jumbotron all) {} They don't hold your hand for the less section, but the documentation is there. I'm guessing they're more explicit about giving examples defining the class attributes, because those who can use a css preprocessor generally could figure that out, but I don't think it would apply the other way around. I say it's designed specifically for this, because it's built on less. I'm sort of torn on how I feel about them making the class-attribute approach look like the standard approach. On the one hand, it's cost me many hours dealing with giant-sacks-of-divs html handed off by designers who don't know better. On the other hand, bootstrap looks really good and its popularity makes it a useful de-facto standard for certain layouts (progress bars, alert notifications, breadcrumbs, etc.) One glimmer of hope I'm seeing is more CMSes/frameworks packaged with built-in less/sass support. concrete5.7, for example, has you directly include .less files, and even lets you specify less variables as editable from the CMS itself (so you can go in and change a font, background colour, etc. from the cms dashboard). I don't expect everyone who just finished their HTML/CSS modules in CodeAcademy to install less, and setup a gruntfile to watch and render all their less. When your CMS can just specify a less file and handle processing it, the mixin/extend approach to bootstrap becomes way more accessible to everybody.
Rasmus has the right idea: &gt;interface Task { public function run(); } This is the sort of PSR addition that, in hindsight, I feel stupid for not realizing we needed. Task runners get defined constantly, and it really is just a matter of making sure we have a standard interface. edit: I realize this hasn't made it into the official PSRs, but going by https://github.com/php-fig/fig-standards/blob/master/bylaws/002-psr-naming-conventions.md , isn't the push to put 'Interface' at the end of interfaces? Personally I find it rather silly, but I've been doing it lately out of anticipation that it would be in the psr.
&gt; They don't hold your hand for the less section, but the documentation is there Yea, I don't mean entirely undocumented. But all the documentation pages use the `.col-md-6` style. Preprocessors are the standard for serious front end development these days, so personally I'd prefer to see the doc pages have more emphasis on sass and the mixins. Instead, everyone that tries Bootstrap for the first time learns to use `&lt;div class="col-md-6"&gt;` 
&gt; I'd prefer to see the doc pages have more emphasis on sass and the mixins You and me both; I think it's a matter of time before things reach that point, and in the meantime we're going to have a lot of cluttered HTML to wade through coming from other devs. 
It's great! We use vagrant &amp; virtual box at the office. The one draw back is that the network mount to our web folders is a bit laggy because of ExpandDrive &amp; Sublime Text 2 not updating the folder list all the time. It's part a caching issue and part doing everything over ssh. 
I'd add that using Chef (or your CM of choice) makes it even peezier
As much as people hate EXTJS. I really like their chart package. 
A follow up question: what are the compelling reasons to dev on osx rather than windows? After all, it's pretty easy to setup a VM and have a unix shell on windows. 
I use Statsd (from Etsy) and Graphite to display graphs of what's going on. I log lots of stuff like number of queries run, duration of queries, number of files loaded, memory used, page load times, error counts, etc. Statsd allow you to record multiple stats in 1 network call, so very little overhead. I create a "stats" class that code can register stats to record. In the destructor I put the network call to record the stats. This assures it's always recorded without explicitly calling a "save" method. It also happens after output is complete, so it should affect user page load times. Grafan is also a very good alternative to Graphite. 
Exactly. The MoopBootstrapBundle has been around for awhile - https://github.com/phiamo/MopaBootstrapBundle Also not sure why they didn't just suggest installing something like that in the docs instead.
You might get some better answers over on /r/javascript too.
http://puphpet.com
Id did add the Interface suffix: https://github.com/dracony/fig-standards/blob/master/proposed/task.md
I like `Callable` instead, for its simplicity. Does using a different interface bring any advantages?
There has not been a public announcement about it. But a while ago one of php.net servers was found out to be compromised: http://marc.info/?l=php-internals&amp;m=141198794815797&amp;w=2 &gt; Actually, some php.net machines have been compromised and prevent us from releasing 5.6.1. Rasmus replied that it was not a new breach, but just a box that was not properly cleaned up from the last breach: http://marc.info/?l=php-internals&amp;m=141199777820037&amp;w=2 He also mentioned that "All the source and binary releases along with git is safe". Really good news is that apparently no malicioucode has been injected into PHP source files and binaries. Such breaches can be difficult to track (depending what is exposed to the public internet from the compromised machine and so on), but hopefully they have been able to identify (at least have some clues) how in the first place it happened. But no official announcement, on the other hand, speaks they are not willing to talk about it or just don't know the exact details.
Email them, then. It may simply have been forgotten about.
If "newer" frameworks use all the 5.4+ goodies, it should have beaten CI hands down in performance. If it hasnt and seems never will, do you want to say php has become slower?
Respect for taking the criticism on the chin. Well, for example then, how do you expect people to use your project? It it's to expand into their own full system, then it needs to be easily extendible so they can add new functionality, change how it looks etc... No can do here - how do I add another page? An extra area for additional information? etc... If it's to integrate with existing systems, how? Do I need to have a completely separate GUI in order to use your user management? Say I want to change how your form's HTML is generated for my site, and wrap each element in a span. I've got to go into the models and change the html on every rendering method as it's assigned in php. Why not have some kind of rendering engine so that I can just create the data about the form elements in php (element type, values, etc...) and pass that into a view that generates the html based on the data we send it? This way we could easily have multiple templates for eg: horizontal rendering, column rendering, etc... Look at the MVC link I put in the previous comment. Each controller is its own class, each page is its own method within the controller. And the controller doesn't do much, it just acts as glue to request the correct data from a model, and assign that to a view. The only place that html is generated is in the view files. The only place that the business logic is defined is in the models. I'd really recommend getting a lot more au fait with how to write OOP code. Just throwing classes into procedural code doesn't change much. It can be a bit of a learning curve, but it's worth it.
We use [highcharts](http://www.highcharts.com/demo) on the client side. Its got lots of features and massive capabilities, and although it does look complicated, it can be stripped down to simple, compact graphs. These charts are dynamic, interactive and generated by javascript on the client side, but if you also want to generate static image versions in order to email them or whatever, it may seem like this option is not viable. However, if you checkout the [highcharts demo](http://www.highcharts.com/demo), you'll notice that there is an "export" button in the top corner of the graph. This will upload the graph data to highcharts, where they will generate a png/jpeg/svg version of the graph for you. Great! But what if you want to generate graphs on the server ready to send in an email, or download as an image? Happily, highcharts have made their server side generation code available as a node package, which when combined with phantomjs and a suitable webserver interface, can be used to create a self hosted highcharts server. I've put together a puppet config and a few bash lines to install and set up everything you need on a fresh install of CentOS (6.5 tested but should work on any recent version) You can find all this code here https://github.com/joegreen0991/highcharts-webserver Once set up, you could generate a graph with this data: {"xAxis": {"categories": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]}, "series": [ {"data": [29.9, 71.5, 106.4, 129.2, 144.0, 176.0, 135.6, 148.5, 216.4, 194.1, 95.6, 54.4]} ] } by URL encoding and sending as the infile parameter http://highcharts.example.com/?infile=%7B%22xAxis%22%3A+%7B%22categories%22%3A+%5B%22Jan%22%2C+%22Feb%22%2C+%22Mar%22%2C+%22Apr%22%2C+%22May%22%2C+%22Jun%22%2C+%22Jul%22%2C+%22Aug%22%2C+%22Sep%22%2C+%22Oct%22%2C+%22Nov%22%2C+%22Dec%22%5D%7D%2C+%22series%22%3A+%5B+%7B%22data%22%3A+%5B29.9%2C+71.5%2C+106.4%2C+129.2%2C+144.0%2C+176.0%2C+135.6%2C+148.5%2C+216.4%2C+194.1%2C+95.6%2C+54.4%5D%7D+%5D+%7D to generate the following graph: http://i.imgur.com/Obd8Jmn.png More info: https://github.com/highslide-software/highcharts.com/tree/master/exporting-server/phantomjs
Probably not.
It's up to you what IDE you want to use, and the fact you are questioning it reveals you know you are using something shit and dated. A lot of developers will use Sublime Text and PHP(Web)Storm, since they are by far the best for what they provide. I was 100% an ST developer until I took a weekend to learn PHPStorm (properly learn it,) and now I use it for all project work. I guarantee if you took the time to learn it you would also see why you shouldn't be using something as terrible as Dreamweaver.
It's impossible to sway someones opinion, all we can give is anecdotal evidence. I am tempted to start forcing a PHPStorm set-up for my developers because it is that good. If you want to use Dreamweaver, go for it, but if you were to come interview for a position at my work you wouldn't be considered more than a junior, whether that's what you'd define yourself as or not.
Try again. It may have been missed. Bear in mind, internals is the wrong mailing list.
I was a long time dreamweaver user, when I switched over to sublime text it felt like I was taking a really major step. Turned out it's not such a big deal, and all things considered I think I never went back because of a sum of small features. There are some that might've been in dreamweaver all along and I just didn't know but right now I cannot imagine life without them. One example is the ability to select multiple parts in code view and edit them at the same time. I hope this sort of helps, I know it is a kind of "1 persons" experience switching, but it may be similar in your case.
I'm currently using [C3](http://c3js.org/) alongside [D3](http://d3js.org/). Both are for developers really, there's nothing out of the box there. But what you get is fine grained control.
&gt; The interview position is a poor argument in my opinion, it is down to someones experience and someones code, not the IDE they use and I think that is very poor judgement if that sort of thing actually happens in your workplace, but lets ignore that anyway I run my own company and I do not worry about this. This is incredibly naive. I'm not trying to be rude but I look for developers that never stop learning new things. A developer that comes in to an interview and says 'I use Dreamweaver because it's what I'm used to' shows lack of ambition. A developers code is about 20% of the reason I hire them, hiring someone just on their experience and code is poor judgement, not the other way around. That's besides the point anyway. Read the features of PHPStorm on their website and if that isn't enough to show you why Dreamweaver is a terrible option, watch the series on PHPStorm over at laracasts.com. Of course, I'm only upping one IDE, when there are many many many options better than Dreamweaver, such as NetBeans, Sublime Text and even vim. 
It seems like you're building websites only using wordpress, so feel free to use any IDE you like and which fits your needs. Come back when you'll start building websites using Laravel or Symfony2, then we'll talk. I hope you got my point :).
1. If you a lot of WordPress development, try PHPStorm 8. It has autocomplete support for WP, making it much easier to remember if it was get_title() or get_the_title() 2. PHPStorm has support for Grunt 3. PHPStorm has file watchers, so it can automatically convert SCSS/SASS/LESS files to CSS, etc. Yes, I am a PHPStorm fan :) Tried it once and I never want to go back to Notepad++. I have never used Dreamweaver myself, so I can't comment on how it compares to either program.
Current proposal: https://github.com/dracony/fig-standards/blob/master/proposed/task.md Propsal meta: https://github.com/dracony/fig-standards/blob/master/proposed/task-meta.md
Use Chrome dev tools and notepad++, the actual WYSIWYG way of doing things. You can even go so far as to copy chrome's final processed CSS for elements which will includes browser renderings that would otherwise be different on different browsers, meaning it is as close as possible to what you want, regardless of which browser it is being viewed in. Fuck dreamweaver forever
I feeel DW does not give you full control of your code, and I just don't like it. I use Geany. And I freaking love it.
I think the biggest feature is it is my IDE, personal to me and does exactly what I need it to do, and more. It took me a full 2 days to set up because I customised it so much. The look, the feel, every shortcut, everything you can imagine can be customised down to the user. Add to that the amount of time saving you will notice with auto-complete, live templates, macros, code injection, multi-line editing and formatting, a way to press a single button and have your entire directory (or just a single file,) formatted down to the very standards you use and employ. I could go on forever. The last point is so valuable, because it allows people to code to whatever standard they want, and after a release I deploy the clean-up button and it will move brackets, statements, spaces, everything in to one format which I can send straight back in to git. 
I used to swear by dreamweaver - especially when used in conjunction with the Interakt toolkits (which later becam ADDT - Adobe Dreamweaver Development Toolset). I found that the ease with which I could create complex, dynamic frontends/backends allowed me to solve any problem I came across developing websites - and I learned a lot of PHP by modifying the code created by the plugins. However when I started a new job a few years ago I was put into a team which was developing sites using the CodeIgniter framework. After using codeigniter and the netbeans IDE my skills evolved increadibly rapidly, I was able to create better more efficient object oriented, MVC code and it has taken my coding skills to the next level - greatly increasing my earning potential as I can now go for more advanced, higher paying jobs. TLDR - leaving dreamweaver behind is like taking the training wheels off your bike, you learn to code better - and as a result make more money. 
I use Notepad++ (one liners, hacky quick-fixes you regret later), Sublime (write small changes and one or two unit tests) and Netbeans (full projects, PHP and Java). As you may have guessed, I think a full IDE like Netbeans can have it's downside, when you just want to watch a README, inspect an XML and so on. So use the right tool for the job (as always as a programmer...). However, here are my few key point which I _think_ are lacking in DW compared to Netbeans, Eclipse, PHPStorm, ...: * "Standard" stuff very well done: Syntax highlighting, Source Formatting, Code competition (also for your own code if properly annotated, even "magic" stuff like __invoke() and __call() works). * VCS integration: It's dead easy to watch the state of your VCS in an IDE, compare and merge, show diffs, automated integration in Bugtrackers and so on. * Code Refactoring and Generation: Inline/Outline Variables and Methods, Extract this, Implement that, Getter/Setter for variables etc. which - properly used - save a shitload of time, same goes for "clever" templates and code completion (with variables). * Debugger with Breakpoints: takes a while to set-up properly, but definitely worth the time and effort. * Remote Resources and Services: a lot of remote resources (databases, (web-)api's, ...) can be integrated and configured with a few simple steps. * Secondary tools integrated: so you like SASS or LESS? Here are your precompilers which run on save. You like smarty? Here is your syntax highlighting and preview. You miss something? Here is a plugin - or write your own. * For the sake of argument: open source (Netbeans / Eclipse).
Are you stupid? We all use what works best for us. You're no different.
No. This is just you thinking you're being clever by doing something stupid.
PHPStorm, but you can't take a look at a new IDE just for a couple of hours, you'll have to learn and master it, then you'll see the real benefits using that IDE, especially in big projects using huge frameworks. Laravel + PHPStorm is a good combination, you can sneak on some of the benefits here: https://laracasts.com/series/how-to-be-awesome-in-phpstorm (the author is still using sublime text for smaller projects, which indeed makes sense, like you're using dreamweaver for your wordpress stuff) What i like about PHPStorm 8.0: * composer/symfony console/grunt/vagrant/bower/nodejs integration * symfony2 plugin * dat auto completion! * live templates * quick code navigation (especially with codeglance plugin) * tree navigation in almost every menue (this means: as soon as you'll see a tree, like a file/method/class list, you can simply start typing the name you're looking for) * xdebug &amp; phpunit support (i dont know what you mean if you're talking about debugging, but dreamweaver does not have a xdebug support and without xdebug i bet you're still using print_r() or var_dump() for "debugging" :D) * deployment to a vagrant box is pretty easy over sftp (in bigger/symfony2 projects you dont want to use file shares or NFS, because its too slow) * easy version control with history, phpstorm provides even a local history so, in conclusion i would say, as long as you're just using wordpress and are not dependent on other tools, you can use whatever text editor you like, but as soon as your codebase and the libraries or tools you use will grow, you just dont want to miss a good IDE which integrates all the tools you need out of the box.
It's not narrow minded at all. I'm assuming you want to progress in your field, and with that progression comes an advancement in skill level, and an increase in the complexity of the applications you are building. You will get to a point of complexity where Dreamweaver will not work for you as it simply doesn't have the feature set of the more complete IDE's. Therefore, if you apply for a job in a company that builds complex, bespoke PHP applications and you tell them your IDE of choice is Dreamweaver, they will think that you are either incredibly inefficient or you have lied about your level of ability.
I haven't used dreamweaver in a while, since I had no need for an IDE for about a year. Currently, I'm actively using Phpstorm. The benefits that I could list about it are all present in DW as well, so they won't help you. (code templates, debugging). If you want my opinion, phpstorm just feels so... Nice. Dreamweaver just feels like I'm too close to the rest of Adobe suite than I want to be. 
Me too bro. Me too. 
I think as anybody else has said, Vagrant is your friend here. I use it everyday and I love it. I mean, I'm on a Mac, but the windows version works just as well. I like the unix shell too much to leave, and since I write PHP, I have no reason to go back to Windows again for dev, thank god!
How do you show someone you are efficient, when you aren't using the most efficient tools? Being able to code quickly is not the same as being efficient. It maybe that you can do the job twice as fast coding in Dreamweaver as I can in PhpStorm or Netbeans, but if you learned to use either of those yourself, you would be 4 times faster. You can not be more efficient, using a less efficient method.
Telerik, dev express, component one. There's a few others. Cost money though. 
It all depends on personal preference AND what you're working on. For example in my case I use Sublime Text for quick edits/small-scale applications and Netbeans for large projects. Sublime to me feels and looks wonderful and opens within seconds which is why I use it for such small things. Netbeans is a full IDE which has directory listings, a great amount of plugins to customise to my needs, Database connections and have multiple projects open at the same time. Netbeans takes a while to load initially and uses a huge amount of resources which is redundant when doing "small" things. That's not to say you can't do everything in the one editor/IDE but it just makes more sense to me on a personal level. As for the job interview, no one is going to judge you based on what IDE/editor you use, but they WILL expect you to learn/use an editor which they use in the work place. 
I agree. Exception types are far easier to catch and make debugging easier as well.
Try [Plotly](https://plot.ly). I've found it quite useful - they have support for almost all major languages.
Gotta go with d3 then. D3 will let you do what you're looking for with a very sane and familiar syntax, using tried and tested standards like CSS and js. Can be super simple or overwhelmingly complex, the choice is yours. 
I used Dreamweaver when I first started out. Now I use Sublime Text daily and I love it. Sublime is fast, lightweight, free (in a manner of speaking), so I can use it on all of the machines I interact with. It also has hundreds of user-contributed plugins that make the editor on par with or superior to Dreamweaver. With the [package manager](https://sublime.wbond.net), access to these plugins is just a CTRL + SHIFT + P away.
I have a project with a hundred class files scattered through a dozen different directories, plus template files, css, javascript, and tests. PHPStorm is really powerful when it comes to code completion, intellisense, etc, so not only does it keep me from making dumb mistakes like typos, it will tell me when, for example, I'm trying to use the return value of a function with no return statement, or if I have a class that doesn't correctly implement an interface, or if a typehint doesn't match. On top of that, PHPStorm is really smart about refactoring. If I want to move a class from one namespace to another, PHPStorm will scan my project and update any references to that class it finds (including references to the class name in strings, if you want it to). This saves me a massive amount of effort and frees me to make architectural decisions about the structure of my code without thinking "ugh, but I'll have to move all of these files...". And finally, PHPStorm's UI is amazingly customizable. Want to make it look like Netbeans? You're already most of the way there. Want to make it look like Sublime Text? Five minutes of configuration. It makes it really easy to optimize it for my specific workflow. All these things mean that using PHPStorm yields a solid productivity gain over almost any other IDE (Netbeans is probably comparable, but god it's *so slow*). Unless I've been in the dark for 4-5 years, Dreamweaver does precious little of that.
Dude, nothing is worse than Dreamweaver. What more do you need? Search the sub for discussions. Hit up YouTube. The sales pitches have already been made.
I have used [flotcharts](http://www.flotcharts.org/) quite a few times. I highly recommend it.
Thanks, I really like the look of this, but unfortunately I also need pie charts and bar charts, and it seems to only support lines/scatter
I'd say to check out Atom as well at atom.io, it and Sublime are pretty solid.
I just switched from google's charts to http://www.chartjs.org. Neat little charts with a pretty simple api. We don't have many requirements for charting, so this fit the bill nicely. 
I also started (and stayed) with Dreamweaver for a number of years when I first began creating websites. Honestly it was great for a number of years, but at some point I needed better features for integrating with source control systems, deployment systems, and debugging. Also, the price tag that came with Dreamweaver vs its better-equipped counterparts made it an easy choice to move on. I currently use WebStorm by JetBrains because I do a lot of node.js in addition to PHP work when I'm not working my full-time job as a .NET developer.
It's left over from when Dreamweaver was used for the WYSIWYG features. Then it shifted to bloat. I held on to Dreamweaver forever. Its autocomplete is fantastic and the integrated FTP worked great. Left for Notepad++ once I figured out how to set up the FTP part. Ditched that for PHPStorm when I job was more focused on pure PHP coding. So, Dreamweaver is viewed as what your aunt would use to make the community center website. It's not what professionals use. It's really not warranted if you only use the text editor portion. But then you hit the fact that it's pretty heavy/bloated for text editor when things like Brackets, Atom, and Sublime Text are available. Many with decent plugin support for stuff like Git. Back to PHPStorm. It's really great. I keep finding more and more useful things. Integration for xDebug, Vagrant, Grunt, Git, a built in terminal, automatic uploads, code snippets, framework integration, and so much more. It has a bit of a learning curve but it's really not awful. And it flattens out once you get a feel for how it does stuff. I have to imagine it's cheaper than Dreamweaver too. They even release their latest mostly-stable build - for free - that you can install alongside the primary release.
Is this safe? I've always had some troubles trying to implement my PHP vars into Javascript; so i've used lots of AJAX to solve that.
That is like saying that a NASCAR team should hire a guy as their primary driver, even though he sees no real merit in a NASCAR car and all the specialized equipment and tools that go with it and thinks he can win the race in his souped up Civic. 
If you actually use it as a WYSIWYG editor, Dreamweaver writes hideous code; if you're *not* using it as a WYSIWYG editor, you're wasting system resources on features that you're not using. There was a time when I used Dreamweaver basically as a text editor with a built-in FTP client, because that was my setup when I started learning in high school, but Sublime + WinSCP is lighter, and their features are better tailored for developers, whereas Dreamweaver tries to work for everyone and does a mediocre job on all fronts.
One upon a time, I also used Dreamweaver (4) for everything. I got sick of the bloat and the mistakes it would make for me - I make enough of my own. Worked with a couple different IDEs for a while, settled on PhpStorm for all the reasons everyone else has mentioned; it's decently quick, incredibly smart, 98% customizable in every way, and the sum of all the individual features makes it exponentially more powerful than Dreamweaver once you learn to use them all. One downside. There are SO MANY features. Expect a long learning curve as you gain proficiency with the software and its uses - two years in (as a hobbyist / side project use, mind you, not a full time developer) and I'm still learning how to use some parts of it. 
Dreamweaver is frustratingly close to being a good IDE but for like 10 years Adobe has been focused on adding more features instead of polishing the ones they have. The result is they ended up with some half assed implementations of desirable features. A prime example of this is when they implemented subversion support, not sure what they do now but for like 18 months I was stuck on a specific version of subversion because dreamweaver only supported that 1 version. Explaining to the rest of your non-dreamweaver using team that they can't upgrade their version control because you are using Dreamweaver isn't really doing wonders for Adobe's (or your own) reputation. Also, the things that initially attract people to Dreamweaver are all but useless in anything but the most basic environments. The design window can't handle includes with a variable in the path, the whole live preview thing doesn't have a way to set up environment variables or the ability to get past a login screen (maybe this is fixed as my last DW was CS 5). Then you go on to some of the missing features that more competent editors have like refactoring or user defined function hinting. Shit the first time I switched between git development branches in phpStorm had me dropping Dreamweaver faster than you can blink (and that is just 1 feature). I will say that I have found switching IDE's to be pretty easy for small projects and edits but for some reason on larger projects my focus becomes impaired and productivity definitely drops for several months. edit - I used Dreamweaver for 10 years, I even still have it loaded but 90% of my time is in phpStorm.
Can't remember all the keyboard shortcuts? Try pressing Alt+Enter with your cursor on various symbols. Little intelligent helper menus come up - which you can also customize on the spot if you want. There are dozens, possibly hundreds of context sensitive helpers here alone. Example: Press Alt+Enter on a string in a PHP file, get the options: Inject Language (treat the string contents as any of 40+ languages, including syntax coloring and helpers), Split String (split the string on the cursor and concatenate), Replace Quotes (intelligently swap between ' and ", including fixing quoted characters etc. This menu also handles spell checking, importing classes used in your code, and many more things. 
Started out with Dreamweaver long time ago. Switched to Sublime. Straight off the bat: 1) Ctrl + P: Let's me find whatever file I want to work on. 2) Ctrl + I -&gt; Word -&gt; Alt + Enter: Let's me search for a word in current file and select all occurences of it. I can then either replace the word, append, insert, delete and perform further actions. 3) Ctrl + Alt + P: Switch between projects. 4) Shift + Alt + 1/2/3~0: Multiple tabbed views inside Sublime make it easy to view and compare code. 5) Sublime packages: GitGutter, Code completion, SCSS auto build etc. Package control allows me to easily install/uninstall the packages that I need. 6) FTP integration if you need it. Otherwise, it's Git Push. These are the features that I like, off the top of my head. I have no idea if Dreamweaver is comparable in terms of features now. But, if it works for you and you can code without hassle, then why not? Else, I'd say give Sublime or PHPStorm a try.
Not sure you want to take the job from the guy who's going to judge you based on your IDE.
Here's how you can find out for sure. This is what I do for almost anything - software, cars, phones, etc. It is also what some reviewers do - use a gadget or a phone or a new version of Windows for a solid week or two so they can get an unbiased opinion. So for you: try another IDE for a short period of time. Not enough to set you seriously behind if you can't work with it, but long enough to get over the initial shock that it's different. PhpStorm comes with a 30-day trial. Install it, use it for two weeks. Do not load up Dreamweaver, even once, in that two weeks. Use ONLY PhpStorm. Explore it, get to know its features, get used to its interface. Hell, customize the interface to look like Dreamweaver if it makes you more comfortable; I did something similar. If after two weeks you still can't see any merit in changing, then you possibly don't need what PhpStorm has to offer, or are too much of an Adobe fanboy to see it, and you can go back to Dreamweaver. On the plus side, you will have gained some basic experience with it, so if you are ever hired into a job where the team uses something that is not Dreamweaver and expects you to do the same, you will be more prepared. 
I like this idea in general, but I'm not entirely sure that I like using`write()` and `writeln()` for output, it feels too opinionated toward command line implementations. Would something more event-oriented would be better? Maybe: interface Task { public function run(TaskListenerInterface $listener); } interface TaskListenerInterface { public function completed(TaskInterface $task, $context = null); public function failed(TaskInterface $task, $context = null); public function notified(TaskInterface $task, $context = null); } Hm...not really satisfied with that either though. I may just be overthinking it.
[Here you go](http://www.jetbrains.com/phpstorm/webhelp/transpiling-sass-less-and-scss-to-css.html) It's also possible scss&gt;css&gt;css.min and js&gt;js.min automatically with yui compressor :)
Why don't you just go try something else? I can't say much about Dreamweaver, because I stopped using it 15 years ago when it was obsolete then. 
I thought about doing that with events. But then we would need to standardize those events. There is no point in iterpolability if the task runner has no idea what events the task triggers. the other thing to consider here is that the standard must be possible to implement. A lot of the current existing task runners use an OutputInterface ( Symfony2 ), meaning they would be able to quickly adopt the standard. If an event structure , or something that is not already implemented anywhere is introduced, people may just ignore this PSR. 
What up, Homesite? Talk about a blast from the past.
I'm looking at someone elses code and I see things like: &gt; $i = round(0 + 0.25 + 0.25 + 0.25 + 0.25); &gt; $level = (int)$this-&gt;getSettings('levels'); &gt; if ($level &gt; round(0 + 1.6666666666667 + 1.6666666666667 + 1.6666666666667)) &gt; $level = round(0 + 1 + 1 + 1 + 1 + 1); &gt; while ($i &lt;= $level) Do I not know of a bug that was in older versions or does this person not know that **$i = 1;** would produce an int? Throughout pretty much the entire code ints are made from rounding even when it's just a 1 or 0 that never changes or to start. Ex: &gt; for ($i = round(0); $i &lt; count($payments); $i++) 
Check out this one, my friend made it http://www.jobberbase.com/
or BraincraftedBootstrapBundle. I've used both. They're both good although I prefer Braincrafted. http://bootstrap.braincrafted.com 
well, I guess that depends on where you want the complexity to be, in the engine or in userland...
Opened a file at random: [https://github.com/filipcte/jobberbase/blob/master/public/admin/page_categories.php](https://github.com/filipcte/jobberbase/blob/master/public/admin/page_categories.php) Is that a POST value directly inserted in a query?
that was one of the 4
 &lt;?php global $cache; 
maybe it's because it's in the admin area.
Doesn't matter. Unsanitized SQL. Not even once.
Indeed, it is only useful for small - simple snippet, this is not a good solution, I donâ€™t encourage you to use this method.
when you're ready, i won't have to.
You are right, now we usualy use restful, the api return data in json or xml format. We can use ajax to request them. It's best. In this article, I was just trying to say that we can use to request one small snippet simply. I have written in this article is clear I do not Encourage you to use this method. Thank for comment
&gt; procedural, no autoloading, namespace, using mysql_ just Well, jobberbase is one of those.
you should check out SFTP with Sublime
I have installed it before but it wasn't as user friendly as DW's FTP... like, does it upload the file I'm editing when I hit a hotkey? Cause that's all I ever really used in DW, haha :)
Creator also gets serious props for his [github avatar](https://avatars0.githubusercontent.com/u/259460?v=2&amp;s=400).
Implies that it is an Interface. Just like putting Abstract in front of an abstract class implies an abstract class. Being clear.
The other things is that a Task would usually have a single subscriber, which would be the some TaskRunner instance. This makes events even less needed. I guess tasks would be free to ask for some extended version of the OutputInterface, but such interfaces would definitely not fit the "minimal" idea and thus not be standardized.
Task runners are ran on the command line, almost entirely. It wouldnt make sense to not be opinionated towards command line implementations.
Watch the animation on the frontpage of the website: http://www.sublimetext.com/ It does a good job quickly showing how multiple selections is more useful than a standard find and replace. 
I've been using Komodo Edit for years. The best feature is that it checks the syntax against the PHP binary on your system as you type. It also has some decent theme options, supports remote editing over SFTP and pretty much knows every format out there.
on every save you can. When you configure your sftp-config.json you have to change the values... Something like this would work perfectly &gt; "save_before_upload": true, &gt; "upload_on_save": true, &gt; "sync_down_on_open": false, &gt; "sync_skip_deletes": false, &gt; "sync_same_age": true, &gt; "confirm_downloads": false, &gt; "confirm_sync": false, &gt; "confirm_overwrite_newer": false, So every time I save my file, that is when it gets uploaded
Looks great!
Okay, seriously. What happened that every post of OP has been downvoted even without any apparent reason? 
&gt; I find hacking 3rd party code very frustrating and usually the end result is disappointing and you end up wasting much more time than if you had coded from scratch to begin with You're using the wrong third party code.
Fair enough. At the end of the day, it's not tough to implement more event-oriented functionality on top of the existing PSR, I just think it would be neat to be able to take a single set of implementations of TaskInterface and plug them into different task runners. But a minimal PSR that gets accepted is still a hundred times better than an feature-rich one that isn't. Kudos for coming up with it.
I'm no security expert, but I'm pretty sure you'd want that ZIP file to be loaded over HTTPS. Still, cool functionality I wasn't aware of previously.
I propose the search for a more original name?
I started my career with Dreamweaver/Coldfusion like 15? years ago. Moved on to eclipse for a better IDE (code hinting/inspection). Then sublime b/c I hated the "bloat/lag" of eclipse and now finally PHPStorm. http://www.sublimetext.com/ The 6 screenshots on the home page should be more than enough to boost your daily productivity over dreamweaver. Let alone all the nice plugins available If you want an IDE, try PHPStorm (which as of 8 can do all of the sublime awesome tricks) https://www.jetbrains.com/phpstorm/features/ or go watch all of the demos https://www.youtube.com/watch?v=9DgY3ANj0Rk&amp;list=PLQ176FUIyIUZO_kDMzrwl3f13Jdpj1OIT Maybe Dreamweaver has gotten some upgrades and is no longer a shitty text editor with an unreliable WYSIWYG. Maybe not. I don't care. If you don't think the 6 screenshots of sublime or any of the features/demos show you how nice coding can be then stay with Dreamweaver No one will care what you use (except in some tech heavy cities where they will probably laugh behind your back after an interview if you admit to Dreamweaver) 
This is the internet. That doesn't apply here.
Let me clarify, I use third party code like libraries, third party libraries that are specialized in one function only and you don't have to edit anything, like for email or user login. What I don't recommend is using scripts like "classifieds", "listings", "real estate" and "jobs". So if you know the "right" third party scripts, tell us here what the OP asked, a job listings script, let's see what you have for us.
what year is it
Just what I get for trying to contribute to the community :(.
So that's what this is? "contributing"? 
This looks really nice - it's making Laravel a one stop shop for a significant number of good practices.
Really useful, thanks. I was hoping to avoid deploying node into production just for the charts. But I'll be checking out your VM shortly as it would be great to just throw it into cloud hosting, without any of my own sites infrastructure to worry about
keep on drinkin
Keep on hatin.
and that is what's sad. 
Has nothing to do with Elixir and more your constant trashing of Taylor and Laravel in general. We get it, you don't like him or the framework. Don't use it, but constantly commenting on threads talking about it with things such as "keep on drinkin" is getting played out.
I dont like him. Definitely true. The framework, is mostly good. There are pieces of it i'm not ok with, and you don't have to use them, I get that. The literal posting of EVERYTHING that happens in the laravel community to /r/php is getting played out too. None of the other frameworks are consistently posting everything that happens. But you are not much of one to talk about continuously posting on stuff. --- *edit* In fact, i though liferaft was a cool idea. And i'm excited to see symfony do something like it.
/u/JeffreyWay No need to @tag (deson't work in reddit, spelled it wrong, and it was already a reply to me) "nicer boy." If you have nothing nice to say..... Its so funny how defensive the laravel community gets. ONE person says he doesn't like the name, and you guys jump down his throat, and downvote.... But some guy calls him a cunt (which is unbelievably rude....) and he gets upvoted? You guys are quick to break your own morality code.
Heaven forbid people post about PHP on a PHP subreddit. 
You won't get any upvote for calling anyone hitler.
Just curious, what are the reasons for your dislike? 
And heaven forbid someone has a point of view that is the opposite of yours.
I didn't specifically say you did. *edit* why would this get downvotes?
Gotcha. Take care.
So why are you acting like an 8 year old?
Explain please.
Is it opt-in I wonder? or just part of what Laravel ships with now?
Grownups are respectful to one and other.
Of course it matters, what's the point in sanitizing a whole bunch of post variables if the admin area itself allows the user to manually insert things into the database, sanitizing or not? It's unproductive and redundant. Do things when it matters. When it doesn't matter, it's just silly.
Mr. Way, I would advice you to take you own advice and stop wasting your time with this mentality about "everyone needs to be nice", is futile. And for the record I am being nice, not using harsh words, is just that I not nice in the way you think as "people that are agree with me and everything that comes out of Laravel".
I said you were *acting* like one by being disrespectful to people. "The world isn't nice so I wont be nice" is the implication here. It's thoroughly childish. You wont get far with an attitude like that. You can be critical of people's work without being a dick about it. That, I think, is /u/JeffreyWay 's point.
&gt; I said you were acting like one Same thing. &gt; You wont get far with an attitude like that. Ok.
Naa I said not to be a cunt that's all :) whether he/ she is or not is open to your own interpretation. Fuck I should be a politician with this amount of spin 
telling someone not be be a cunt, implies that you think the person is a cunt.
Ah okay. Well I thought he was acting a bit cuntish. No one is at their core a cunt. I'm being a bit of a cunt now really and my double standards are so severely astonishing I'm surprised I haven't had more down votes, but quite frankly, I'm just not that bothered! 
This.
I literally find myself as Mariah Carey, but whatever works for you is ok.
I think your upvotes are because people know you're from the UK where the word cunt isn't so offensive. So they know you don't mean it offensively.
I upvoted you because when I read it, I was listening to Anal Cunt's ["I Thought Hitler Was Cool Until I Found Out He Didn't Drink"](https://www.youtube.com/watch?v=UZsMO0tiFBI)
Yeah its a jibe. To be honest I'm having a beer watching a re run of the great British bake off so I'm unfazed by the drama school kids 
`Callable` is an interface in the programming sense. We're saying that what is being passed must be runnable. If that's all the interface needs to define then Callable is fine. If we want it to be wider then a separate interface should be used. Using a separate interface definitely has its benefits. It allows the runner to handle polymorphism in different ways. It also makes it easier to document the interface if it's complex. However using a Callable type hint also has its benefits. It allows functions to be passed, which makes task composition really easy, and it reduces the requirement for tasks to implement a (potentially changing) userland interface. There may be other pros and cons that I haven't considered, so I'd be interested to hear them. (The `abstract` keyword provides extra semantics, it's not just about being implicit: it stops the class from being instantiated and can force child classes to implement methods.)
&gt; The admin area does not allow users to manually insert things into the database. That would be insanely irresponsible and dangerous. Holy shit, never do that. LOL, obviously you never heard of [wordpress](https://wordpress.org/plugins/sql-executioner/) You sound like a guy who follows some tutorials without really giving a thought on your own. And procedural is faster for the user and IMO, the user comes first, ego comes last. Procedural means I don't need to write classes on my own but I use native PHP classes and sometimes plugging in a third party class in my code, but that's about it.
When you say "third party code", the usual interpretation is ANY third party code. There's a big defence between that and trying to customize a entire application to suit your business needs - that gets ugly pretty quickly.
A task is more than just a callable. It needs a definition (arguably with validation), and a name, to be called from a TaskRepository. Any event that is expecting a Task interface, could need to know the name, and/or the definition.
I have built numerous plugins for wordpress sites and have written a library for building wordpress plugins / other types of complex functionality in the admin zone. So I know some things about wordpress. One of the things I know about Wordpress is that Wordpress always sanitizes user input. Not to say it doesn't have security problems, but unsanitized input is not one of them. The only way you can get around wordpress' default sanitizing behavior is when using $wpdb-&gt;insert() and the like. Well, or raw SQL. Of course, the codex strongly encourages developers to sanitize inputs using functions like -&gt;prepare() in that case because Wordpress does not want developers using the practices you advocate, not even close. If compiling speed was the only salient factor in web development, then maybe your argument that procedural code better suits the user would have some merit. But it's not, so it doesn't. EDIT: deleted a bunch of flamewar level bullshit
I mentioned wordpress because you said allowing SQL within the admin area is irresponsible but wordpress does just that. And not only wordpress, I'm sure a bunch other scripts allow that too. Sanitizing user input within an admin area that allows SQL doesn't make it more secure. And yes, someone programmed these classes, and I use them in part of my code, the rest of the code that come out of my fingers are pure procedural code. 
Check out Servers for Hackers: https://serversforhackers.com/
yeah i'm a subscriber. Haven't seen any editions that focus in on this
&gt; The only way you can get around wordpress' default sanitizing behavior is when using $wpdb-&gt;insert() and the like. **Well, or raw SQL**. I'm not ignoring and you haven't corrected anything, it's you who have agreed that Wordpress allows SQL execution within the admin area. 
Laravel is so much like Apple. It may be a great product but every new feature isn't THAT revolutionary. Twitter teasers and one-word package names that you can't tell what the package actually does. They really lay it on thick.
Ohhhhh boy. I only wrote that to acknowledge the fact that WP will execute any arbitrary code the developer inserts into its lifecycle. Admin or no. Of course, this is true of basically any code anywhere. So, that arbitrary code may very well contain insecure SQL. That doesn't mean insecure SQL is condoned by WP. Quite the opposite. I've already explained, WP's native CRUD-ly functions sanitize all inputs and the docs for `$wpdb` strongly encourage developers to use `prepare()` to sanitize all inputs. That's the part you were and are still ignoring. So unless I'm mistaken, your argument has become "any PHP that can be executed within the Wordpress admin area is secure and good." This has been fun but I'm going to leave it at that.
You are still missing the point or are ashamed to admit you're wrong and make no sense. Or maybe you haven't seen the link to the plugin I posted above, here it is again: https://wordpress.org/plugins/sql-executioner/ So let me know, what is the input sanitizing doing in the admin area if a simple plugin download directly **from the admin area** can let the user execute arbitrary SQL? By the way, unlike you, I'm not saying that allowing admin to execute sql is bad, I'm just saying that sanitizing input does nothing in these cases.
Keep up the hard work, it's always exciting to see new stuff like this! This also let to me purchasing the subscription too.
I've never once indicated that a person's "niceness" is contingent upon whether they support something that comes out of Laravel. What a strange thing to say... In turn, I would advise you to keep in mind that individuals work very hard on these tools that they release for free. And, when your only response to this hard work is some snarky comment about the name of the tool, well, once again, that's not very nice.
What the fuck is going on in here? Even africa has less red crosses than here
Ah, I see what you're saying. I didn't click that link before because I assumed it was just linking to wordpress. I would never install a plugin like that on any of my sites because it is an obvious security hazard. If for some reason I did need to install it, I'd set up permissions so that my clients couldn't access it. It's also a great example of why you should not let your clients install plugins unless they really know what they're doing and have signed off on the risk. But I suppose it must have a use case for certain situations, and hence it's on the plugin repo. So anyway - the argument you've been trying to make is this: 1) a wordpress plugin exists that allows execution of arbitrary SQL 2) therefore it's a complete waste of time to sanitize inputs in any admin backend on any website, or maybe just in Wordpress sites. A bit hard to tell. In either case, I don't think this warrants a counterargument. Have a good one.
&gt; And if you are good with gulp, it saves you maybe 10 minutes of setup And if you're not familiar with gulp then it might save you a few hours of reading docs &amp; ripping your hair out. It also gets more people using the tool which is a good thing overall. I don't get how you could not like it or at least appreciate its usefulness.
This will surely recover my PP
I never said i thought it was useless. And I don't think i made the implication that I don't think its useful. I said I was unimpressed, and that I didn't think it was a breakthrough, or amazing.
So there you again Mr. Way, you are the one labeling my previous comment as "snarky" and "not nice", and what you call nice maybe would be a submissive comment fill with a false and apathetic interest, like the typical and boring "nice work" that for example you would find published by most people on dribble without any relate insight nor will to contribute on any criticism or feedback for the work whatsoever? In fact, I was very serious about the proposal that I state previously, I think is very well legit to consider. For example sometime ago in r/elementaryos someone suggested to change the code name from the OS from ISIS to something else(if you are aware of the latest news you would know why) and my reasons for the proposal yet not as critical as the previous example, they are nagging me little since there have been so many library that are called "Elixir" like the one in python, the new functional language called by the same name, etc. That were my reasons believe or not. Ps: Even Shakira's brand perfume is called that, and that is a red flag that anyone shouldn't ever let pass :)
I got fed up with PHP as a whole for similar reasons. (Also, its dorky process model and spotty standard library.) It's playing catch up to where other languages were 15 years ago, and the Dunning-Kruger effect is very strong amongst the newer developers who only know PHP. (It also, as a language, makes it difficult to grow beyond CRUD-type apps as it's really not made for things like daemons.)
hadn't heard of this one. thanks
My thoughts exactly.
I imagine having a checksum would be a good choice for security purposes.
I haven't watched the Laracasts yet but the thing that puts me off about this is that it relies on two separate technologies: node, and gulp (really, node, npm, and gulp). I am a big proponent of using as few languages/technologies as possible when doing development for many reasons: portability, stability, and ramp-up time being chief among them. People of different skill levels often collaborate on projects, and the less stuff you require someone to set up and familiarize themselves with, the more useful they can be more quickly. Given that, we have tools like Assetic that handle this in PHP directly, eliminating the need for using node/npm/gulp entirely. However, Assetic isn't the most straight-forward tool in the world, but it does keep asset management confined to PHP. Thus it what would be really awesome is a php tool LIKE Assetic with the super clean, straight-forward, terse syntax and API and *just* the right amount of assumptions (that you can override anyway) that you see in Laravel.
If you used assetic you would understand why it's a bad choice compares to node, none of the compilers are as stable or as performant 
Just wait for the calls of "gender traitor!" against Spacekatgal. Or that yours is "the wrong kind of sexy" somehow.
This isn't related to what you are asking, but more of a question to someone who would know about doing this (my apologies if this irritates you OP): would you go about CURLing the page and then parsing it to pull out the data that OP is wanting to do?
No worries...and yes. If curling the page is what works that's fine. But yes...pretty much nailed it Edit: grammar
Not really appropriate to post my reasons.
There are actually at least 3 different task runners, written in PHP, and i think all (i know one) of them can handle assets moderately well. And the argument of "they don't do it well enough", is a lame argument... If they don't do it well enough, contribute to the libraries that do it, to make it better.
Has it occurred to you that maybe you're being accused of sexism because... you're being sexist? Seriously, though. People are remarkably quick to be defensive and remarkably slow to **think about what people are saying to them**. Try listening. You're finding other people's work online and taking that out of context (more on that shortly) to validate your views, but have you tried actually... listening? What you are right now is the owner of the Washington Redskins, saying that the team name is not racist. Seriously, the arguments are all the same. Instead of listening and being sensitive you're just stating your opinion. It's the same bullshit that people bring up so they don't have to give a shit about how other people feel. "Negro just means black.", "Hey, calling her sweetie is just a term of endearment!", "Jap is just short for Japanese.", "I'm not sexist, and my friend who is a woman agrees." As for Spacekatgal's game... you're actually not interested in why that's not the same thing, but I'm going to tell you anyway. For a start, I don't think they're remotely similar. While Revolution 60 uses female characters who are designed to be attractive, they're nowhere near as sexualised as your pouting, giant eyed, short skirted, round hipped, buxom fairy character with a sexy, breathless voice. If you can't see the difference there... Aside from that, and far more importantly, the characters in Revolution 60 are **characters**. They are in fact the main playable characters of the title. Your overtly sexy design is **pure decoration**. Do you not see how that's a problem? Do you not see how it's a problem that on a post on sexism in tech, your framework is the **first thing mentioned**? Do you not see how it's a problem that when a prominent female PHP developer tries to tell you that *she personally finds your marketing sexist* your response is to explain to her why she's wrong? Do you not see that... you know what? It's pretty obvious you don't. 
Is the end goal to get some coding done or to objectify women? It may seem like a little thing to you but it's the kind of things that alienates people that might otherwise use your framework; male or female. Honestly it's about context, the proper time and place for this kind of thing. R60 is a great game with strong female characters. The outfits build and add to their persona and build upon the characters. Having a skimpily clothed fairy doesn't add anything to some PHP code except cater to the male gaze. That cringeworthy audio recording isn't doing you any favors either.
Well put. Keep doing your thing - you've helped me (and many others) more than you know. 
Why???
It definitely does. I don't want to install node on my machine. Or java. Or python. I'm not the only person who has this point of view either. And just because you don't care, doesn't mean everyone doesn't care.
&gt; Again, this is a non-issue For you. Depending on the environment, node and npm can be a pain in the ass to install. &gt; Gulp does the job very well Yes it does, but why in the world does that mean that you HAVE to use gulp, or grunt. Competition is a good thing. If everyone just accepted what was given them, and didnt try to make something better, or question the status-quo, we'd still be living in the stone age. &gt; It would be ludicrous to force an inferior PHP-specific tool for no other reason than because it uses PHP The reason is because we don't want to install node. You keep missing that. And if its inferior, lets make it better. Theres no reason a JS application should be better at this than a PHP application. &gt; Thinking like that gives our entire community a terrible name. Making comments like this doesn't do much better. Or shitting all over other peoples opinions.
Then install them on a VM. Or are you suggesting that you're resistant to anything outside of the PHP world??? I'm so confused. You're a developer, right? Honest question. We use multiple languages and tools here. This isn't a weird thing. 
I'm on a VM with my stuff, and i STILL do not want to install node, JUST because i'm using grunt/gulp. That is a useless dependency for something like that. Less extreme, but solid analogy... You are saying i should Install the whole Symfony framework, just to use the Yaml package. I have side projects in python, Java, and node, so no, I'm not resistant to anything, but just because i can use multiple languages, doesn't mean i want to. I'm even more confused than you. The fact that you are getting upset that we don't like using node is bewildering.
I'm not the least bit upset. But, you just got done telling me that you don't want to install Python...and then you say that you have side projects in Python. Anyhow, you go ahead and make those PHP tools better. In the meantime, we'll stick with Node, the excellent Gulp, and its surrounding plugin ecosystem. As I said before, I couldn't care less about the fact that Gulp isn't built with PHP. Most developers will agree, I'd imagine. If you don't want to install Node, then don't use this tool. I'm going to bow out now. 
&gt; Python...and then you say that you have side projects in Python. ugh. You are not understanding out point. I'm gonna bold this, not to be rude, but to get my point across. **We do not want to have to install a second programming language just to handle our assets** ***Analogy:*** Having to install the ENTIRE Symfony2 Framework, just to use the Yaml component. I have no problems using python, or node, or java, or PHP... But i do not want to use them together in the same project. --- &gt; Most developers will agree, I'd imagine How could you possibly know that, and why would you make that assumption. &gt; If you don't want to install Node, then don't use this tool. I wasn't going to. But i believe I am allowed to make a bit of constructive criticism against this product.
The wrong kind of sexy!
The wrong kind of sexy!
&gt; I wasn't going to. But i believe I am allowed to make a bit of constructive criticism against this product. You certainly are. And you spent much of today doing so. Nice job. (P.S. Node can be used for lots of things.) Anyhow, like I said, I'm off for the night. Thanks for spending a lot of time today talking about why you don't like something I helped build. Oh well. I personally think it's quite cool, and hope people enjoy it.
If only things were that easy. To me, it's like a client saying "can we build Facebook?" and you saying "Yeah! You just need a login script with some way of posting status updates. Done! That's like an hour!". I used to be like you - as you get more experienced you appreciate the importance of never underscoping any project. It's a common trait for new or inexperienced developers who - yes - *can* do the job, but will take a lot longer when they get into it. [A bit like the Dunning-Kruger effect, actually.](http://en.wikipedia.org/wiki/Dunning%E2%80%93Kruger_effect)
You act like installing another programming language is a big fucking deal when it literally takes 30 seconds. They definitely made the right move using Gulp which is the best tool for the job. No point in using an inferior asset manager just because you don't want to install Node.
&gt; We do not want to have to install a second programming language just to handle our assets Then don't? Unless Laravel is forcing you to run "npm install" (and if it does, then that's silly), all you're going to have (as best as I can tell) is a gulpfile you can't run and a packages.json file you have no use for... and you can rm those I guess? The point is, how are you managing assets *right now*? One imagines you can just continue to manage your assets the same way into the future... the tool being there hardly creates any imposition or requirement to use it by itself does it? I would have prefered to have seen this gulp based asset pipeline be *entirely* opt in (something like php artisan elixer:init or some such), but if you can just avoid using it that's more or less the same. 
&gt; (P.S. Node can be used for lots of things.) I am fully aware of what node is capable of, but I'm not going to install it just to handle assets. That's counter productive. &gt; Thanks for spending a lot of time today talking about why you don't like something I helped build. If you can't take the criticism, particularly the constructive kind, then you should avoid building things. No one is perfect, and no one can build things perfectly. I think the general idea behind it is cool, but i think it should be tailored to one of the PHP task runners, instead of a JS one. 
&gt; Theres no reason a JS application should be better at this than a PHP application. There are no good reasons, but the situation is at the moment that there are at least 3 offerings in the node.js ecosystem which do this better than anything php has to offer. And many of the processing tools required to achieve this have no useful equivalents in php (take LESS for example, there is a first party node.js LESS compiler... so any time LESS changes, new features are added to the language etc, there's a compiler for it with no lead time, no idiosyncrasies etc). So whilst it may be straight forward to build the wrapping in PHP, making an equivilant would be a pretty massive undertaking...
&gt; Then don't? Unless Laravel is forcing you to run "npm install" I'm not going to. But i'm offering constructive criticism here. You don't seem to get that point. &gt; how are you managing assets right now? I use one of the PHP task runners.
If you can't tell the difference between basically attractive and highly sexualised imagery then you're dumber than a sack of hammers.
1. It doesn't literally take 30 seconds. 2. I don't want to install a separate language dependency, just to handle a single task. 3. Making the other tools better. Again, competition is good. Regardless where it comes from.
&gt; offerings in the node.js ecosystem which do this better than anything php has to offer All the more reason to work on the PHP ones. Lets make them better. There is already a LESS compiler for PHP. While it might not be super actively managed, getting more people using it would help improve the quality.
Really? You keep saying "be nice"..... yet you want me to inappropriately list my reasons for disliking someone? I have no desire to turn this into a personal rant on why i don't like someone, its petty, and again, inappropriate.
Its vague, and doesn't really describe what the tool does. At least, I assume thats what /u/afrobee was trying to say
Dracony has deleted his reddit post now, but anyway: https://twitter.com/AndreaFaulds/status/518554382850621441 https://twitter.com/dracony_gimp/status/520771528590630912
Laravel is **encouraging/endorsing** it. Not requiring it. And honestly, I think it would be better for the PHP community, if it encouraged the use of a PHP task runner, instead of a node one.
Fuck you pay me
&gt; All the more reason to work on the PHP ones. Lets make them better. And in the mean time I have bills to pay and clients who don't like delivery dates slipping because I could have used something that works really well but instead chose to use something that didn't. &gt; There is already a LESS compiler for PHP. While it might not be super actively managed, Major. Major problem. And what about SASS? CoffeeScript? TypeScript? cdnifying libraries? css3 prefix managers? javascript minifiers? The ecosystem you would have to compete with is enormous. Don't get me wrong... if this ecosystem existed for PHP then 100%, I'd use the pants of it... but it doesn't, and until it does I can't afford to use broken php on principle when I need to get work done. Not when a perfectly simple solution is right *there* that works amazingly well (speaking of Gulp, Grunt, Broccoli here, not Elixir). Should we make PHP stuff better - absolutely. Should we use broken PHP stuff while working nodejs solutions exist right now that do exactly what we need? I think not somehow.
thanks; i've been through a lot of tryings on merging my Javascript side and my php side without that much AJAX; and sometimes i've wrote some js lines using php, but always have been afraid of that
So it should be encouraging broken solutions in favour of ones which are known to work. Right. Got ya.. I'm afraid on this I will have to disagree.
&gt; And in the mean time I have bills to pay and clients who don't like delivery dates slipping because I could have used something that works really well but instead chose to use something that didn't. This is such a trite argument &gt; And what about SASS? yup &gt; CoffeeScript? Yup &gt; javascript minifiers Yup. ___ As for the rest, I'm not really sure, but thats not to say if they don't that someone couldn't make them. &gt; use broken php Its not broken. Stop being dramatic. &gt; Should we make PHP stuff better - absolutely. Your attitude in this post gives me the impression that you don't have time, and thus dont really care to make it better.
Sorry - I thought he was asking you for the reasons why you dislike Elixir. Feel free to carry on with not liking Taylor. Though, coming from someone who has gotten to know him over the last year or so, he's a cool guy. Things easily get misinterpreted online. Maybe it might be worth the effort to make friends - despite the fact that we're not in second grade, as you put it earlier. 
Like it or not, Gulp is the industry standard for this kind of asset management and task running. Insisting on a php solution instead of an industry-wide practise is foolishly insular.
If you're not using node then you're not using NPM, which means you're not using bower, or sass or... Honestly, I'm going to cut this short: if you're doing web development work and you are not using node tools, then you're probably shit at your job.
My attitude here is that we could use broken things (Ok, maybe not *entirely* broken. Objectively not as good as their nodejs counterparts perhaps?), or we could use proven things that get the job done now. Why should anyone wait around for, or contribute to developing pure PHP solutions to a solved problem? Sure some people enjoy doing that sort of thing and that's great. The day they come up with an solution that is as good I will gladly use it. Your argument is predicated on "It's not PHP so I'm going to be mad" and it really is mind boggling and confusing. But that's ok. Again, nobody is *forcing* you to use it. And it is doing the community *exactly zero harm* by having Laravel advocate this as it's preferred solution to this particular problem. &gt; As for the rest, I'm not really sure, but thats not to say if they don't that someone couldn't make them. They could make them. That they haven't and I need them now, and more importantly that they are available now is reason enough to use nodejs to solve this particular problem.
&gt; It doesn't literally take 30 seconds. Fucking does.
Incoming curses! No, it does not.
&gt; "It's not PHP so I'm going to be mad" I'm not mad, I'm just not happy they chose a node task runner. 
Yeah, I'll doubt I'll be using this myself, and it seems like... more stuff.
Right back atcha!
Dude, i get your argument. Stop repeating it. Its getting old. I don't agree with you. Leave it at that.
From what I've been able to deduce, you'll get 2 new files in the root of your project when you create your bare project. A Gulpfile and a packages.json file. It does not *appear* that Laravel will force an npm install on you at that point, so it's almost opt-in, save for the couple of dangling files in the project root. My personal preference (and something that was bandied about on twitter months back) would be that the addition of these files is managed via an artisan command so that it is completely opt-in. Having said that, opting out looks trivially simple.
Exactly. Very well put.
How difficult is it for someone from php background(not too much exp) to learn hhvm? 
Thanks for verifying that :)
Think of HHVM as an alternative to the "official" php interpreter. If you are comfortable setting that up, setting up HHVM shouldn't be that difficult. How feature complete or stable it is, I've no idea actually... Hacklang (some language features/extensions which facebook have written that are included in HHVM) is syntactically very similar to PHP from the looks, and seems to be a progressive enhancement, so if you've got a good grounding in PHP I wouldn't imagine it is too difficult.
I've heard association and join table. Only time i've heard pivot, is in regards to Spreadsheets.
Assetics works well though. "Why not use it" is a good question IMO. Edit: nevermind me I'm stupidâ€¦
I'd say ~2 hours for a fully functional script. And you may want to scrape game ids first - fully automate everything. Find a list of the days games - grab all the ids or just the teams your after - then scrape those id(s) for stats. Would just need to confirm that the game ended and hasn't already been inserted. 
Well, you *can* just refresh the page. In development, the PHP code would run, meaning your development cycle stays exactly the same as it is today. But when you deploy, you would compile it, meaning you get the benefits of performance in prod, with ease of development in dev...
Brief look at Assetic's github project, it has dependencies on ruby for sprockets, sass and compass as well as nodejs dependencies for uglify, coffee, stylus, nib, ember, typescript, less, handlebars and css auto prefixing... so where's the benefit? You are going to have external language dependencies anyway... why use a PHP solution that wraps up other solutions when you can just go straight to the source? 
Wow, lots of disrespect being thrown around here. This looks cool, not my cup of tea, but I think it'll probably appeal to at least 75% of laravel users, which is exactly what framework features are supposed to do.
The first question you have to ask is how NHL.com is gonna react when they find out your scraping their site.
http://stackoverflow.com/a/1055746
I'm generally not a fan of this kind of extraneous stuff being added to Laravel in V5. The new Cashier feature is a prime example - you're building a tie-in with a specific 3rd party vendor into the framework. I hope this isn't an indication that Laravel is catering to new, less experienced developers at the cost of performance and flexibility for those of us that love the framework and are perfectly comfortable using Composer to include vendor libraries.
Better solutions for what exactly? PHP is much maligned but there are a number of things which make it incredibly compelling in this space.
Afaik Grunt is an industry standard... At least we have more than one industry standards here.
I like ExtJS but the charts perform badly with even a modest amount of data.
Aside from how horrible is your code, this happens if indeed you unserialize from session an object without loading it's class. Try putting: use item; in Store.php, or something like that. At the moment you're not loading the item class in any way inside Store.php
What's up with these graphs? They say average for PHP is 143ms and if you try to read the graph avg. is about 200ms. And also graphs starting not from zero are great in the sense of marketing.
just to be clear with the other answers: you don't have to *learn* anything, except how to install it and configure the server. HHVM will run PHP code like PHP runs PHP code (except for a very few differences, very rare), but faster. Nothing changes in your code.
Sorry you are right -_- I thought assetic integrated sass &amp; less &amp; other kind of compiler implemented in PHP. I've only used the "merge assets" feature, so no JS dependencies for that.
I did something very similar recently in about half an hour. I built a Google SERPs scraper using Goutte : https://github.com/fabpot/goutte I think ~ Â£25 / $50 for the whole job would be more than enough.
&gt; if you're doing web development work and you are not using node tools, then you're probably shit at your job. if you are doing programming and if don't have phd from MIT, then you're probably shit at your job. 
&gt; Or java. Or python. Java is nice. :-(
why can't this tool be used without having to install the core and having to know what functions are available, why aren't the dependencies just being inverted so that everybody can use them?
You're right, its much faster then 30 seconds. "sudo apt-get install nodejs npm" Takes about 5 seconds? After that you go to the laravel directory, type "npm install" and from that point you can use "gulp" or "gulp watch" and everything works like it should.
&gt; If you a lot of WordPress development, try PHPStorm 8. It has autocomplete support for WP, making it much easier to remember if it was get_title() or get_the_title() NetBeans does this as well, very useful.
Maybe its the real twig this time, serving as a templating engine for php 
So we somehow now need a "sexy police" to analyze "sexy" stuff for sexism ?
This seems too good to be true. Are there any obvious shortcomings? Why would everyone not run this system?
There is an EventManager PSR =)
If you read the article you'll find out why. HHVM does boast some very impressive numbers, and compatibility, but it does require carefully rewriting portions of code that are incompatible. There is also the potential for subtle differences, and unknown places of incompatibility. So for developers who don't want to find out the hard way which methods are incompatible the switch over is difficult. For most web sites that aren't at Facebook or Wikipedia scale, the performance difference isn't worth the potential headache.
You have to install Node JS modules to allow Assetic compile coffee, minify css/js. The only thing it can do by itself is combine assets into one file and rewrite paths in CSS. So you're relying on Node already anyway. As someone who actually is using Assetic, I'd like to say this looks so much better. Fuck Assetic.
I would say it's commonly held to be the most offensive word in the language.
"Better solutions for what exactly?" &lt;-- Better Solutions for preparing a response and sending it to user. "number of things which make it incredibly compelling in this space." &lt;-- like what ??
Use exception system. You can add any data to your exceptions [by extending the base Exception class](http://php.net/manual/en/language.exceptions.extending.php) and this is exactly what it was designed for. Also you can define `$debug` variable in your config file, so that in dev environment exceptions are actually shown to you instead of your `Sorry, something went wrong on our end.` message.
Congratulations Wikipedia Team and HHVM Team! Also this topic reminded me that :) https://twitter.com/catrope/status/408018210529615872 https://lists.wikimedia.org/pipermail/wikitech-l/2013-December/073357.html
I've registered error functions https://gist.github.com/rzeka/9e6aab199a1dec671ec7 `$this-&gt;callError()` sets the right view template and `$this-&gt;view-&gt;render()` simply fires up it and `$this-&gt;log` is PSR3 logger. It logs everything to file Now in view, when I am in debug mode, I print `_error` messages. If not, there is nice error page
&gt; How do you deal with errors? Not well. Sometimes I just curl up in the fetal position and rock for hours.
What's the difference between using sentry and something like Loggly or LogEntries?
Exception -&gt; Monolog -&gt; Logstash (elasticsearch)
Yes, definitely "the wrong kind of sexy."
Cool, I didn't know those existed. Thanks!
That's actually pretty easy, a noob could set it up in an afternoon using [simplehtmldom](http://simplehtmldom.sourceforge.net/manual.htm). Then you could drop the results into [Firebase](https://github.com/eelkevdbos/firebase-php), get yourself a [Heroku PHP build pack](https://github.com/heroku/heroku-buildpack-php) and set up a cron job over there. 
Guzzle is a wrapper around curl (and other adapters) that has a much nicer API to use within PHP. There's lots more to it than that but that's the gist of it. Example... $client = new GuzzleHttp\Client; $response = $client-&gt;get('http://www.reddit.com/r/php'); $content = $response-&gt;getBody(); Then using something like Symfony's dom crawler you can do stuff like... $crawler = new Symfony\Component\DomCrawler\Crawler($content); $header = $crawler-&gt;filter('h1')-&gt;eq(0)-&gt;text(); var_dump($header); // Should dump a string containing the text of the first H1 element in the page (code just whipped up top of my head so probably doesn't work 100% as-is)
I don't understand what you mean. 
If you want to use this elsewhere, then fork it, change it to fit your framework/project structure, and have fun. 
Well you know, I appreciate honest feedback and try to avoid surrounding myself with sycophants ;-) &gt; how do you expect people to use your project? My primary audience is beginner/intermediate programmers who know PHP, but aren't familiar with the ecosystem of modern web development (frameworks, dependency managers, templating engines, etc). The idea is to give people a secure, well-designed skeleton system from which they can build what they need without too steep of a learning curve. You are correct, I haven't provided any documentation yet about adding pages, etc. I guess I have two routes that I can go with that: 1. Provide more documentation about how to implement new pages, and improve my own code design to make the process easier. 2. Go the Wordpress route and provide a frontend interface for adding content, etc. I guess even in this case, improving my codebase would help me and other developers. &gt; Why not have some kind of rendering engine so that I can just create the data about the form elements in php (element type, values, etc...) and pass that into a view that generates the html based on the data we send it? This is precisely what I am trying to do with the [bootsole templating engine](https://github.com/alexweissman/bootsole) that I started as sort of a daughter project. So, you can do exactly that - specify the field type, values, validation rules, and other attributes. But you are correct that (at the moment) it is still an extremely limited system. I will consider your suggestions for rebuilding the project with MVC classes. I guess my main concern is, will this make things too confusing for a novice developer? I don't mind a steep learning curve, but one of my primary objectives is to not inflict that on others ;-) Another takeaway I'm getting is that maybe I should refocus my efforts on a smaller part of the project, like Bootsole. I know there are a ton of other templating engines out there, but I haven't seen too many that are oriented towards today's ubiquitous form widgets (select2, switch, image uploader, etc). What do you think? And, thanks again for your constructive criticism, you've made a lot of excellent points.
Basically the same, except I push my errors to Sentry.
We have a massive legacy code base and I recently installed HHVM along side PHP-FPM and set up a subdomain in nginx to use it. All told that took under half an hour. The only issues we ran into were that it does not have msgpack, no big loss there, we just quickly swapped to using json. (we did not end up serializing as much data as we had thought we would). The other issue was that hhvm does not support case insensitive constants. Luckily they were only defined that way and we're always used all upper case. All told, it was very easy to set up. Most pages in which most of the time spent is waiting for mysql or redis to respond, the gains are minimal, but there, under 5%, maybe. Pages that have to process a lot of data do better. For example, we have one report page that gets 1.5M rows from mysql, and then aggregates it down and outputs an home table. This page saw a 25% gain, even with mysql being a 3rd of the time spent. That said, we will stick with regular php for our slew of command line scripts because HHVM seems to have 100ms+ startup time more than php. 
I haven't used Assetic in a while, but you never needed any Node or JS to compile/minify CSS/JS. There were minifiers written by Google in PHP that you could use. In fact it shipped with dozens of them written in PHP.
That went right over my head. I know Africa has a lot of red crosses... What red crosses are you referring to that you see here?