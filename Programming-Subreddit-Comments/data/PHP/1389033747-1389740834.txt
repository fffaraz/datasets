Buy a dedicated server.
Well, if that AppFog is cheap enough for you, I would say that if 50gb is bandwidth is good enough for you, you are probably making enough money for a bigger bandwidth server :)
Why is Laravel being given credit for DI in PHP?
I asked them if they can make a server with PHP 5.4 for people like me. They told me they can't break company rules for an individual.
"I'm not a guy who can install things via terminal using SSH." Learn how to. Get digital ocean or linode or similar, install virtualmin on it - it's one line from the shell to get started - then it's essentially a web control panel after that. But... I'd still suggest you get better at learning shell stuff to do basic server management, else you'll spend a whole lot of time trying to find a host that meets your needs and budget, vs just DIY.
Laravel works in public folder and keeps PHP files one folder above for security purposes, so it is impossible to run more than one Laravel instance on a shared web host. I tweaked Laravel source code a bit to get rid of public folder and moved all assets to the main directory. Now I can run different Laravel instances in different folders. It's not a good solution to tweak sources of the framework. My preferered solution would be creating different instances for each project via web service, so they wouldn't collide and I could give seperate PHP/MySQL instances with different settings for each project. Fortrabbit and Appfog supports this usage, for example.
Listen to the comment or the flair? Tough call.
Project will be listed on codecanyon. I don't know how many hits I will get in the first month, but it is pretty image heavy and it may easily exceed 50GB bandwidth. (And my little html5 game used like 10GB of resources the hour I posted it on /r/gamedev) Maybe I can optimise everything using Grunt or use a free CDN, not sure. 
The servers at my job still run 5.2.14.
&gt; As with all Aura libraries, it is completely independent from any other library package, so you don't get any surprise dependency downloads. That is an outdated attitude, please tell me why it matters when composer manages this automatically? &gt;The code has 100% unit-test coverage and fully documented. 100% unit-test coverage does not mean 100% absence of bugs. It does not even mean all code paths have been covered.
Depending on how risk averse a company is, remaining on older versions is often a good business decision, even if it makes life harder for its developers. Less likely to have undiscovered bugs or vulnerabilities, no downtime or accidental code breakage from upgrading. For personal development, using the most recent stable versions makes more sense, so as to remain up to date on technology and develop as quickly as possible. Downtime is insignificant, and it's actually valuable to discover bugs as it can give you standing in the community. Different aims, different solutions.
To be honest, he is one of the PHP developers that I can trust with my eyes closed. :)
what about a virtual server, then you have complete freedom
You're doing it wrong... In the document root you should store "front-end" files css/js which are already rendered... do you render these files with PHP on each request? (big no no). I've never said that I keep my template files in the document root. I mainly use mustache for templating, because PHP and other concerns should be kept separately. Templates are part of your delivery mechanism and it belongs with the framework files.
Iterators in PHP are really powerful in any paradigm you use, not just in functional programming. Often people have custom-made data structures that could benefit from implementing Iterator or IteratorAggregate that could then be used in conjunction with these techniques. Not all Iterators are guaranteed to be lazy; you have to write them that way. Generators can help, so pick whether a traditional iterator or a generator will work best for your specific case.
You will never be able to code a website similar to wikipedia. Set a more reasonable goal and you might get a better answer.
Question: Which RFC implements the 5.6 stuff you talk about?
https://wiki.php.net/rfc/use_function
On shared hosting? I would like to hear more about your structure. Can you tell me more about it?
One thing to keep in mind is that the PHP MongoDB driver is moving really quickly. Like a new stable release every month or two (11 in 2013) http://pecl.php.net/package/mongo That's an incredibly fast pace for me, testing against newest to file bug reports can be a big jump in versions. 
http://virtualmin.org IIRC - google for the GPL version if you want the free one. Keep it up to date - it has a 'these packages need to be updated' screen - and you'll be pretty close to where you need to be for decent security. Nothing is 100% secure. And you've got a host right not that will *not* update to PHP 5.4 or PHP 5.5, when there will be no more security updates for PHP 5.3 What other services on their servers are they not upgrading? You don't really know. Ignorance is not bliss. And if everything gets hacked.... you still have more to lose that they do.
[PHP docs cover it in detail](http://php.net/manual/en/language.namespaces.importing.php), but the short version is do this: use RedBean_Facade as R;
You mentioned demo projects. Create a VM when you need it (takes appx 5 minutes), keep it around for as long a you want. Most of the packages are straight from official repos, so make sure to keep versions up to date. If something ever happens to the server, you can destroy and reprovision within minutes.
The fact that it's been around since 2005 almost certainly makes it worse, not better, code. It would be a waste of time for me to look into this. There are already great frameworks like Zend, Symfony and Laravel, and these are established with developers and have proven themselves on large scale sites. Why would I drop all of that for a framework based on a poorly written shoddy system from 2005? Joomla has never been good from an architectural point of view. The very fact that you'd name it after a piece of crap is enough to prevent me from wanting to take a look. I'll stick to Zend, Symfony and Laravel, thanks.
fortrabbit, its free for dev sites
Shove all of those static assets on S3?
The two interfaces are representing two different classes with different behaviors. They might be similar and they might not. The idea is that the implementation could be from two totally separate sources. Sure, Laravel's errors and old data can both be handled by the "Session" facade, but that might not be how other frameworks handle it or even **want** to handle it.
If Joomla died and nobody used it anymore, nothing of any value would be lost.
I've said it before in this thread, and I'll say it again - You're letting old prejudices rule current decisions, and that's pretty closed-minded. If you want to limit yourself to whats popular now, instead of what's best (not claiming to be the best), then good luck to you and your future endeavors of constant change, seeking out whats "popular now". In my opinion, you as a developer would be better served to judge something based on the current merits of the thing in question, rather than on your assumptions about the thing. But what do I know?
So sites by NASA, ebay, Harvard University, Linux and MTV have no value? I think your perspective of "value" is a little lost.
Couple of errors in [docs](http://noodlehaus.github.io/config/). 1. Both php config files have a single quote before false for debug 1. Both php config files have security.security
We still run 5.1.6 on some servers. Those are getting upgraded sometime in the next year to 5.3.3 though.
It's not worth investing any time into something based on 9 year old shoddy code. If that makes me close minded, I'm close minded.
You know that you can just change the base path through the configuration files, right? I recently worked on a client project who had a terrible shared hosting set up: one cPanel account with many websites in the root folder, so if a site was called "myblogsite" it would be: /var/www/rootdomain.com/public_html/myblogsite so what I did was: /var/www/rootdomain.com/public_html/myblogsite-core That contained the core of laravel (everything except the public folder) Then in: /var/www/rootdomain.com/public_html/myblogsite placed the contents of the laravel public folder Then updated the configurations in bootstrap/paths.php (laravel core) and index.php (public folder) to point to the new locations. Super simple and you could run as many Laravel sites from a single shared hosting account this way... The way you're doing it is crazy, read this guide: http://driesvints.com/blog/laravel-4-on-a-shared-host That said if it's your own project **stop using shared hosting**. If you don't have enough control of the command line to set up php and nginx, you should spend some time learning, nowadays it's *so easy* there's no excuse not to. Spend a day learning, it will pay dividends.
Then you probably should stop coding anything except for node.js or Ruby, because PHP itself is based on PHP/FI, which was pretty shoddy, even for 1992!
I used to work for a well-known UK e-retailer whose website turns more than Â£1 million/day in revenue and *still to this day* runs on PHP 4.4 with MySQL 4.0. Beat that! :-)
Completely agree. It blows my mind how you can see the disaster of every IE browser...the hours each version has stolen from your life as a developer...and then turn around and go "yep, let's choose the dev stack from the company responsible for this never-ending source of torment." It's like a brutal collective case of Stockholm Syndrome.
this certainly made MY life easier. :D
A nicely built and very handy library by [Frank de Jonge](https://twitter.com/frankdejonge). I've been meaning to use it to build a storage facade for Laravel, but haven't got around to it yet. Maybe some day.
Man, sweet. I'm so close! So, to continue the subversion example, I would be using rpmforge. So I guess, if I understand correctly, I would drop rpmforge.pp in the manifests directory and then I would need to ensure that 1.7 is installed by adding the following somewhere: package { 'subversion' : ensure =&gt; '1.7' , } I got that from [this stack overflow thread](http://stackoverflow.com/questions/11614413/puppet-specifying-a-version-of-a-package-to-install), but I'm not totally clear on where I should put that. 
Since it has so far to go architecturally, and it _does_ power 3.8% of the web, I have a great chance to make a huge impact on the PHP ecosystem, which is pretty exciting for me. The other (actually the first reason why I started contributing in the first place) is we use the CMS for our clients at work, and I wanted to make that horrible experience better.
Seeing how so many different storage systems can be worked into one standard interface, I wonder if this could be the start of a new PSR? Would be awesome write an app or library to a standard storage interface, and then just drop in whatever implementation you'd like.
And then after a few months or even years, the sudden realization of having wasted sleepless nights on this. How recognizable.
Well look, good luck to you. At least you're putting in the effort and I'm sure it's very rewarding in a lot of ways. It's just not for me, but I do appreciate the work you're putting into it.
Thanks for that. I don't expect to stay with Joomla forever, but I want to make an impact while I'm here as well as learn a lot, so that's my goal.
Facade on facade, facadulous!
Yeah, there's some inception happening. Don't worry, I've got a totem.
Yeah - it's definitely needed. I would support such a proposal. There are a few different filesystem abstractions I know of that would benefit from it, that's for sure.
What is scripting?
http://fortrabbit.com/ http://digitalocean.com/
C# would probably teach you more about programming. You can then transfer that knowledge to php. 
XHTML?! HTML5 is just around the block. Don't bother to learn that.
I would properly go via this path * HTML (XHTML is just a "fancy" word for HTML with XML syntax - meaning close tags should always be there - so the X in XHTML does not give you any other extra, other than a nice html syntax) * CSS (so you can style your html - styling is not equals to designing but more equals to placing elements, well it can also be used to designing, but that really depends on where you will go) * javascript (imo its so nice to know this - just adding a tad extra to everything) * a server side technology, maybe C# or PHP - but really depends where you want to end - if its web developer at first, then yes C# and after that it does not take very long time to shift between languages - almost all the major languages have the same principles, the only differences is the actual code - but it is the principles of programming thats really important. * and in the same time when learning a server side technology, remember to also learn some SQL - you will regret if you misses that part. Jobwise, in europe it is so much easier to get a job if you know C# (guess its the same in the US?). Thats the way I would go, if I could go back - but my path was a bit different. Started with VERY basic HTML with tables (DONT DO THAT!) - then directly to classic ASP, and then added a database in form of a Access database. - But yes, thats about 18 years ago :)
As already mentioned, go with C#. I'd argue that it's generally better to go with a more statically typed language that forces object oriented programming and helps build a strong foundation. Once you have C# down (or rather, the concepts), you'll be able to build on that knowledge much more easily and pick up Java, PHP, JavaScript, etc. on your own. The reverse is much less likely. Not that PHP can't do object oriented programming or deal with types, but it's less likely that those points will be highlighted in the classroom.
We have the most recent three (5.5, 5.4, 5.3) installed on our shared hosting servers, I don't know why more hosts don't do it. It's as simple as changing .htaccess settings on your site to pick which PHP you want to use, really simple... I don't know any other hosts that do this off the top of my head, though. Best bet is a VPS where you can configure the environment however you want.
Just around the block? HTML5 has come and lapped the block many times over now.
I prefer outsourcing server security too, honestly. I run a vm on digitalocean for personal stuff, but i'd go with a hosting provider that actually takes care of the server and updates and such for clients.
That is complete nonsense. In any case, one would assume that a master's student already knows how to program (at least at the basic level that you seem to be alluding to).
Great news.
I thought MIS was management information systems, bachelors degree. But if you are correct and it is a masters then yes the students should know how to program already, in which case I don't really have an opinion.
I think it's what play writes do, when they write dialogue for the characters.
Don't use AppFog. Plain and simple. Their support is atrocious, they haven't added any features on their roadmap they were supposed to have completed now, don't support the latest versions of languages and since they got bought out they haven't gotten any better. My biggest fear is that they disappear altogether.
My apologies; I had never heard of that focus before now. I just assumed he meant a master's degree program in information systems.
Wow this is incredible. Fantastic work!
thanks for pointing these out dgod40. i've just merged in a pull request correcting these.
i see, i understand. a use case i've had before for callables was having to pull configuration from a central source, which isn't local. another case would be say parsing an unsupported file format, like YAML or XML. as long as the callable returns a hash, then we can use it.
Not sure what MIS means. If it means "Management Information Systems" as /u/UbuntuJon says then I'd guess you're not going to be a programmer yourself. In that case I'd say it doesn't really matter if both courses are any good. There are anti-PHP zealots out there and they have good points. Ultimately you can write unmaintainable and unsafe code in C#/.NET as well as in PHP, but the fact is it's a lot easier with PHP. Having said that, your course will hopefully teach you the main pitfalls and the rest comes down to reading up, staying current and learning from your own shitty code (and trust me, you *will* be writing some, no matter which one you choose, but it's all part of learning). It is a fallacy that PHP is not nearly as full-featured a language as C# is. It used to be, but the last few years this is not really the case anymore. The difference between C# and PHP comes down to flexibility. You're stuck on Windows with C# and you're stuck on .NET with C#. PHP offers you a lot more flexibility both in terms of the language itself, and in terms of what frameworks you can use, what tools you use to develop your software with, and on what platform you deploy your code. This is both an upside and a downside: right now a lot of cool things are happening in PHP land, just google PHP-FIG and HHVM. Frameworks seem to pop up out of nowhere and more than a few of them are excellent. Development tools range from Notepad++ and the excellent SublimeText editor to PHPStorm/Netbeans and other IDEs, both free and nonfree. PHP has a big market share on the Web. C# on the other hand seems (I'm not a real .NET aficionado so don't trust me 100% on this) more limited in its choice in software development tools, and many of them cost money, whereas a lot of good PHP development software is free-as-in-free-beer, and often open source as well. However, the C# tools are VERY good and so is ISS and the .NET framework and you basically get it all in a package. Microsoft are dedicated to building a strong framework that is as least as good as any PHP framework out there (although I guess it's rather bulky), and in teaching people about best practices in software development. C# and .NET's relative lack of flexibility makes you learn things the right way from the start. This is less the case with PHP, where you see a lot of folks who once made a contact form and taught themselves PHP from there and off they go calling themselves PHP developers. But if your course is any good, and you're attracted to PHP, just learn OOP and a good framework and you'll be fine, presumably your course will teach you the important stuff those contact form guys and gals don't know about. Some advice about learning web development in general and PHP in particular: * W3Schools is hugely overranked on Google. Use the Mozilla Development Network instead, they are usually just below W3Schools. * Learn about Firebug, the Chrome developer Tools, and Internet Explorer's F12 menu. * Stack Overflow is your friend. Build enough reputation to upvote. * Don't trust blogs that go "here's how you make an awesome dropdown in PHP and jQuery". Those tend to be your attic hobbyists, and I've seen examples that are downright wrong and unsafe. * Do trust books by publishers like APress and O'Reilly, especially if they are recent. * The newer the PHP version, the better. * Once you grok Object Oriented Programming, learn about design patterns. * Learn JavaScript better than a few snippets of code. *Then* learn jQuery, not the other way around if you can help it. * Learn about databases and learn about SQL injection **before** you write your first SQL query. Learn how to do JOINs, read about normalization and about indices. You'll learn to think about your data and about how its structure. Programming, especially in your field, is not usually about awesome algorithms: it's really all about storing data and retrieving it again. I thought databases were boring in school, but now I think designing table schemas is great fun and sometimes quite challenging. I have no idea if I've left anything out. Was fun writing this. Frankly I should be off to bed. Can you let us know which one you chose?
Are you var_dump()'ing $_POST or $_REQUEST? I've seen that facepalming trip-up several times, designers build a form as GET while dev is expecting POST. Dev's inspecting $_REQUEST out of habit and, well, this happens. Can you pastebin the entire HTML form? (Minus anything confidential, obviously.) [edit] Oh, derp: As I've always done it, the form field names should be like this, without indexing the array plan[]['payPlanId'] Not like this, plan[0]['payPlanId']
Data is being sent as POST and I'm trying to read it as $_POST. As I mentioned, I can read the array, as long as I don't try to access any individual fields. On your edit: I'll have to do some testing, but if I recall, leaving an index out of the form field names results in each form field getting it's own array index instead of grouping them by rows. so I would have something like plan[0]['payPlanId'], plan[1]['plan_id'], plan[2]['contact_id'] etc. Thanks for looking. **edit:** I was correct, removing the indices from the form produces an array like this: Array ( [0] =&amp;gt; Array ( ['payPlanId'] =&amp;gt; 47 ) [1] =&amp;gt; Array ( ['plan_id'] =&amp;gt; 2 ) [2] =&amp;gt; Array ( ['contact_id'] =&amp;gt; ) [3] =&amp;gt; Array ( ['forwarding_id'] =&amp;gt; ) [4] =&amp;gt; Array ( ['title'] =&amp;gt; Unlimited ) [5] =&amp;gt; Array ( ['description'] =&amp;gt; unlimited plan ) [6] =&amp;gt; Array ( ['price'] =&amp;gt; 9.99 ) )
MIS = Management Information Systems 
XHTML is required for the degree. 
As someone who had to go from PHP -&gt; C# it was no pick nick. I'd pick C# just to get Visual Studio over any other IDE now anyway though.
It looks like your array keys include the single quotes. What happens when you try the following? echo $_POST['\'plan\''][0]['\'payPlanId\''];
Actually, Vlad does serve a purpose(, though admittedly it might be not obvious). The intention is that Vlad instance would carry a Translator instance that would be used for all the tests. Thank you for your feedback. Will come back with more comments later in the day.
Holy crap! I *knew* it was something simple! Thanks a bunch!
This is what I have been hoping for since last year. Wanted to create one but didn't have the enough know-how nor time to do it. Thank you!
close your eyes and whisper "rasmus" three times, then the php will find you (takes 2-7 hours, leave your pager on).
I'm not hugely familiar with unpack, but it seems to work on binary strings, not text strings like you've got there. Is it possible you could explain your actual end goal instead? I can't help thinking there might be a more appropriate approach.
I would say: **neither**. PHP tutorials suck. Especially at explaining advanced concepts. You will likely end up using bad practices and not even be aware of that. C# is all about frameworks. You have a problem? There is a framework for that. Again, you are very likely to not gain anything beneficial. You would have better result while studying Perl or Python. Also, I kinda have to mention Java, which, while suffering from same issues as C#, has become the de-facto language of programming literature.
You have to repeat your unpack format for each byte of data you want to unpack. PHP has no way of knowing what the binary data is, so you are required to be explicit about the data boundaries, and what it is interpreting each position as. Notice the "'H2' x $len" part from the Perl code? You aren't using it in your PHP code. PHP has a str_repeat() function, but it doesn't allow for changing the name of each repetition. PHP's unpack() function requires that you name each field it is unpacking for you, lest you overwrite the returned data. Each field must be separated by a **/**. For those reasons, you can use a loop, like this. &lt;?php $str = 'abc123def456ghi'; $format = ''; $index = 0; $len = strlen($str); while($index &lt; $len) { $format = $format . 'H2c' . $index . (($index &lt; $len - 1) ? '/' : ''); $index++; } print "Format: '$format'\n"; foreach (unpack($format,$str) as $i) { print "$i\n"; } Edit: Oh god, I'm sorry about all the edits. I'm falling asleep at my desk.
So how would you suggest OP restructures the curriculum?
I don't know if it was first (I highly doubt it), but i would think that Symfony2 has had a lot more to do with it gaining traction. Especially with Fabien's initial set of articles about DI in 2009 http://fabien.potencier.org/article/11/what-is-dependency-injection
Reddit removing the line-breaks between paragraphs doesn't help to read. This might be friendlier to your eyes: https://gist.github.com/gajus/dc0b0ce1ca2b926f928c Original: I have read through your implementation, code and documentation: I don't like that you are passing (or even allow) rule parameters using string-json/query format: $validator-&gt;add('title', 'maxlength', '{"max": 100}'); $validator-&gt;add('title', 'maxlength', 'max=100'); This seem to encourage inconsistent/preferential use of the library, where writing a library should encourage standardisation. The same comment applies to the implementation of the syntactic sugar. All of your validation classes are limited to a single condition. I cannot make my mind yet whether this is a good thing or bad. It seem to make things simplier at the cost of adding verbosity (you will end up writing more rules). &gt; Single value validators should return true/false not a string that is a pointer to a message. I'd like you to articulate the above idea. What is the argument against returning a named identifier? Within the rules themselves, you are using typecasting (https://github.com/adrianmiu/sirius-validation/blob/master/src/Validation/Validator/Email.php#L14). This could result in unexpected behaviour.. you should be throwing an Exception if non-scalar value is received. There is ambiguity in the documentation: https://github.com/adrianmiu/sirius-validation/blob/master/docs/validator.md#messagetemplate. Because you allow custom (boolean) functions/methods as validator, it is unclear what error message will be used in case the validation fails. If I understand correctly the example, your validation objects are using states: $validationResult = $validator-&gt;validate($_POST); // TRUE or FALSE $messages = $validator-&gt;getMessages(); // array with all error messages It is fine to return a dedicated result object that would allow to deduct boolean validation state, error message name or type. However, using validator itself and relying on the last check to deduct the outcome is prone to error. More about the coding style, but the use of __toString ($validator-&gt;getMessage()) does lead to all sorts of unexpected behaviour... including problems with debugging (you cannot throw Exception from __toString as a very least). Not quite sure why are you using * to denote array selector (https://github.com/adrianmiu/sirius-validation/blob/master/src/Validation/Validator.php#L567), when foo[] selector on itself implies an array. One of the bigger shortcomings of your implementation, is that you make too many assumptions about the rule queue (https://github.com/adrianmiu/sirius-validation/blob/master/src/Validation/Validator.php#L534). It seems that whatever rule error will stop the validation chain for that selector, which is not always desisable. Also, the same shortcoming as in the current Vlad implementation: your library assumes that if value is not found, it is eq. to null (https://github.com/adrianmiu/sirius-validation/blob/master/src/Validation/Validator.php#L555). Where, null, might be a valid value on itself. On a bright side, I like the idea of: * RequiredWith, RequiredWithout, RequiredWhen. * Implementation of Validator::$wasValidated. * That Validator accepts traversable objects as well as arrays. I am also curious, where in practise, did you ever need Validator::addMessage() (https://github.com/adrianmiu/sirius-validation/blob/master/src/Validation/Validator.php#L592) ? Hope that any of these comments are of value. Thank you for your feedback. More critique is welcome. :-)
And code that just worked can give you fatal errors in the next version of the driver.
&gt;I'm not hugely familiar with unpack Then it might be time to stop talking.
Could you give a link of where to start? I've always used shared hosting so far, so I wouldn't even know where to look.
Amazon Web Services?
Regarding #7, why not simple recipients[][email]? Even then, I would advise against such form structure to begin with.
In Bolt we recently switched from this to [erusev/parsedown](https://github.com/erusev/parsedown).
Yes, because no one brings an YX Problem to Reddit. 
Ok, I was going to say "don't be mean" and "at least he's" trying but then I read the article and frankly it's just terrible. Basically it's an SEO fluff peice by someone who knows nothing about PHP
Agreed.
content is lifted from http://w3schools.in .... someone fixed the question and answer section for him ... that was nice of them, he should track them down and pay them really ...
I learned more about Service Location and Dependency Injection from the above two chunks of code than I did from OP's article, and the series linked within. My brain now says: "If the code reaches out for what it wants, it's Service Location" and "If the code gets handed what it needs, it's Dependency Injection"
I think the following should work too for this. $str = 'abc123def456ghi'; $hex_str = end(unpack('H*', $str)); $hex_arr = str_split($hex_str, 2); foreach ($hex as $i) print "$i\n";
Oh, wow, those interview questions and answers...
I'm on Ubuntu, middle-click seems to paste the clipboard.
No worries, you could still be correct :)
Neatly done.
Ah, just saw the OP already confirmed it was management info sys.
Templates do not belong in the document root. Nothing that isn't meant to be directly requested by a client belongs there. That's a pretty short list including: * Assets (images, fonts, CSS, JS) * Directly accessible web pages and scripts (not applicable if you use a front controller pattern) * Other publically downloadable files (e.g. PDFs) Generally speaking, it's possible to figure out what should be in your document root by moving everything out of it, and then moving things back in one at a time to fix 404 Not Found errors on the client until the app works again. Obviously this is a very naive and time consuming approach, and I'm only suggesting it as a learning exercise. Having said that, it's also possible to have *nothing* in the document root and still have a fully functioning app. That involves using a front controller for *everything*, though - including your assets. I don't recommend that approach, but knowing it's possible can be useful (e.g. maybe you need to restrict some set of images to users with a certain role).
I used to work for a company that (at that time) still used access 97 for some of its (mission critical) database systems.
You can use H* instead of calculating the length.
I'm glad it was helpful to you. Take it with a grain of salt, though. I don't consider myself an expert on programming patterns, but this is my current understanding of the difference. Re-reading what I wrote I realized I left out one obvious example, and that's what the code would look like without any IoC: class MyService { function __construct(){} function mailSomething($thing){ $mailService = new MailService('hostname', 'user', 'pass'); $mailService-&gt;sendMail($thing); } } This is considered bad practice as MailService is not a dependency that can be changed at run time. This makes it difficult to unit test and makes MyService less portable (if you try to use it in an application that doesn't use the MailService class for mail you can't easily replace it). It also requires you to do the initialization of the class within the service. This could be made a little better with DEFINE'd parameters or a factory method, but it's still not as flexible as IoC.
Amazon EC2 - It is easier than you think. Host your own. I do not work for Amazon but I am currently running about seven EC2 hosted sites - by myself.
Does this work with non-string data?
Neat! This was the solution I was trying to figure out last night. I always forget about sprintf when it matters.
Yes, * just uses the type provided until all the input is consumed.
Nice post/s. One thing I would add: don't use a pre-packaged *AMP stack like XAMPP or MAMP if you're on UNIX/OSX. OS X has Apache and PHP already built in so why not use it rather than have another instance running? Install MySQL and off you go. It is also far more similar to a production environment so will provide good practise to setting up a VPS or PaaS.
Hi. You need Javascript.
I can confirm this for both [HostGator](http://support.hostgator.com/articles/hosting-guide/hardware-software/php-5-4), as well as [1-and-1](http://help.1and1.com/hosting-c37630/linux-c85098/php-c37728/manually-set-the-version-of-php-using-an-htaccess-file-a614325.html). 
You should check out WebFaction, you get that balance of being able to completely customize your stack, while leaving the server security stuff to them. Just as an example, I've got PHP 5.4 over Apache, PHP-FPM 5.5/Nginx, a couple django/gunicorn apps, redis, and varnish. $9/mo, 30-days money-back (last I heard, at least...). And yeah, you'll want to get better on the command line. 
I highly recommend learning Laravel although Symfony is also a good choice as well (Laravel is built on many of the Symfony components). I've used Rails before and Laravel kind of mimics certain parts of Rails that makes it easy to learn. It's "basic" but highly configurable/customizable so you should be able to get something up and running in very little time. It's also now the most popular PHP repo on Github and is still growing in popularity since Laravel 4 is still relatively new.
&gt; We're happy to announce the 2.0.0-beta1 release of [Aura.Sql_Query](https://github.com/auraphp/Aura.Sql_Query/tree/develop-2), a database-connection-independent query builder. You can [download it](https://github.com/auraphp/Aura.Sql_Query/releases) directly or install via [Composer and Packagist](https://packagist.org/packages/aura/sql-query). &gt; &gt; ... &gt; &gt; If you like clean code, fully decoupled libraries, and truly independent packages, then [the Aura project](http://auraphp.com) is for you. You can download a single package and start using it in your project today, with no added dependencies.
If you're trying to make yourself as employable as possible the Zend &gt; Symphony &gt; Laravel
Thank you I'll give it a try. 
I thought I tried that and it didn't work but I guess it does. Fixed above. 
&gt; array unpack ( string $format , string $data ) The $data must be a string so if you had a network stream you would need to store all the data before use. 
Ah, good call. Don't know how I missed that.
With testing (as with most things) the simple/sensible approach is usually the correct one. That seems to be the gist of this article. Is something vastly easier to test by firing up a server specifically for this one test? Then do it. I'm generally of the opinion that you should get as much coverage as is possible/feasible from unit tests and cover the rest with integration tests. Is something hard to *unit-test*? That's a clue it needs refactoring. Cover it with integration tests and refactor it when you're able. Over time the natural progression (if you're diligent about testing your code) is to naturally get better at writing code that's easy to test the first time. Always remember: *the goal is working software, not 100% unit-test coverage.*
The quality of this project beats many other frameworks hands down. Really impressive for such a small dev group.
Is there something special about H in unpack? $str = 'abc123def456ghi'; $format = "N2c"; print_r(unpack($format,$str)); That automatically gives me c1, c2, etc... But H seems like you have specify the index yourself (line #11 above), otherwise you only get one element back? 
And also imho is a political decision too. The framework creators are not really advocating framework agnostic libraries, because one of their goals is to lock you into their framework...
That is terrible advice! If you're on PHP 5.5 or greater, just use [`password_hash`](http://us3.php.net/password_hash). If not, but still 5.3 or better, use the `password_hash` polyfill: [https://github.com/ircmaxell/password_compat](https://github.com/ircmaxell/password_compat). Otherwise, you should use [PHPass](http://www.openwall.com/phpass/)
The reason you're having this problem is because 5.3.3 is what many Linux distros are stuck on because this is what's available in the repositories. I'm primarily talking about Red Hat Enterprise and CentOS which a LOT of hosts use. I'm using this version on quite a few servers I have because it's supported by Red Hat at this time for both security and critical bug fixes... and just works for what I need it for. I require stability for my business and can't have the version changing on me too drastically and breaking something. You don't want to "manage" a VPS but you're missing out on a lot by not doing so, including the ability to upgrade/change/modify PHP literally however you wish. It isn't that hard, once you've set it all up there's very little to manage. I suggest thinking about it.
`5.3.7` to be precise. This really matters as many distros only have `5.3.3`
It's not an index, its how many "H"'s it should extract. If you want it to keep extract H's until the end of the data, use "H*". If you want 6 hex strings, use "H6".
The `crypt()` format is $&lt;algorithm code&gt;$&lt;salt&gt;[$&lt;hash&gt;], where the [] part is optional. The code for md5 is "1", so you would want '$1$' . $salt; By the way, since we're talking about hashing, these are the rules: - If you are building for PHP 5.2 or lower, use '$1$' (md5) as it's guaranteed to exist. - If you are building for PHP 5.3 to 5.3.6, use '$6$rounds=5000$' (sha512) (some formats have another dollar sign with additional data, like sha512) - If you are building for PHP 5.3.7, do what /u/lord2800 said
I'm not sure what difference you're talking about between "text" and "binary" strings in PHP. They're the same thing.
I believe this is because pack treats all integers with the same width of 32 bits. So, by saying N2, you're saying "grab two integers from this 8-byte string." It knows that, no matter what, the first 4 bytes are are a 32-bit wide integer, and the second 4 bytes are a 32-bit wide integer. With hex, the width of each value is unknown except by the repeater value you provide. The width is effectively arbitrary, and pack concatenates each byte returned. So that at least explains how repeater works. As for why PHP won't automatically index the value for you? Well, now we know how H2 operates versus N2. N can say "when I hit 32 bits, the next 32 bits is another value." H says "when I hit 8 bits, the next 8 bits are part of the same value." We would need a repeater for the repeater. That means, for a new index, we have to say "H2c/H2c." Well, why does the second "c" overwrite the first one? Why do we actually have to say "H2c0/H2c1" to get both values? It seems that that's an implementation detail, rather than a technical one. I found this reference that explains it: http://php.net/manual/en/function.unpack.php#12395. The "key" counter gets reset for each new type.
I switched to Rackspace, best decision ever (coming from Fortatrust dedicated box that always kept going down)
Good point. It takes a lot of time to learn how to write software well. I mean just consider what you need to learn. If you've never programmed, the basics can take time, and then you need to learn OOP, separation of data and display, you'll want to cover a design pattern or two (not forgetting MVC), DI, security, databases, and that's just the server side. Not to mention version control, debugging, build systems, etc.
You're right, there is no difference. The problem is that he (matt) doesn't know that.
I've known people who have never touched php in their lives before starting at Facebook, ranging up to people who had primarily worked with php in their personal projects/previous job. Knowing php (or any particular language) isn't very important at all. If you are comfortable with one language, you can generally pick up another without much issue. More important is general problem solving skills and approach when working on a project. You can teach someone a language, it is much more difficult to teach them how to break down a problem and figure out the best way to solve it. Not all engineering at Facebook uses php. While the front end is all php, there are a plethora of backend systems written in anywhere from java to python to c++ to erlang. If Facebook (or any large tech company) just targeted self proclaimed "php devs", they would fall apart.
I've been away from the PHP scene for a while, what is all this? What would I use an Includer or Autoloader for?
Doesn't PHP already have one built-in? What's wrong with it?
&gt; C# is all about frameworks. And PHP *isn't*? Ho-ho-hokay, buddy.
I just want to preface this with saying I'm no security expert, so take my advice with a good grain of salt. You can use a tool like Nessus to get some of the low hanging fruit. It's better at catching server configuration issues than coding issues though. Any competent PHP developer will be able to perform a basic security audit on the code base. It's part of our job to make sure we do everything in our power to not get hacked after all. That could mean a few hours work to point out any glaring security or architectural issues or it could mean a few days of auditing and fixing. I'd only go with a full audit from a specialist if you want high security. They're very good but it's not going to be cheap.
It does not matter what people here think on subject "PHP vs C#". What matters is what you are going to and want to learn on either of these courses. ***I suggest you to read course syllabus.*** If you then still dont know then best bet would be to trust your adviser. He is your adviser for a reason. 
Even then, you should skip trying to implement it yourself and just use PHPass. I can't describe how overly complex it was, trying to re-implement PHPass before I discovered it (and further, discovered password_hash!).
With hhvm you can write c inline. Not to mention fibbinanci runs about 80x faster in pure php. edit:// Found what I was thinking of, it was not a *inlining* C\C++. But it most certainly IS C++ compiled in with your PHP. You write your C++ in a .cpp file and then you define a "native" function in your php example: PHP (HHVM only obviously): &lt;&lt;__Native&gt;&gt; function finfo_file(resource $finfo, ?string $file_name = NULL, int $options = FILEINFO_NONE, ?resource $context = NULL): string; C++: static String HHVM_FUNCTION(finfo_file, CResRef finfo, CVarRef file_name, int64_t options, CVarRef context) { String fn; if (!file_name.isNull()) { fn = file_name.toString(); } return php_finfo_get_type( finfo, fn, options, context, FILEINFO_MODE_FILE, 0); } The result is as good as C++ in your PHP. You can find a bunch of examples of this in the HHVM repo, this specific example is from https://github.com/facebook/hhvm/tree/master/hphp/runtime/ext/fileinfo 
 echo exec(dirname(__FILE__).'/../fibonacci-c/bin/fibonacci '.$argv[1]); so, tl;dr would be: for small work, plain php is faster than that using php exec for implementation in compiled language. 
I work with my college to perform professional penetration tests with our security graduate students. We are much cheaper than typical firms since we are in academia, but we are just as thorough and being constantly hired from said firms. If you are interested in doing a contract with us, PM me and I can send you more information and pricing. 
That's not code from the library, it's an example of using it.
Take a look at their [Github page](https://github.com/Facebook), not a ton of PHP there...
Yes, but $contents was returned by $filemanager-&gt;listContents(). I believe that the previous poster is suggesting that method instead return an array of value objects rather than an array of arrays. e.g. If $object above were instead an instance of FileSystemObject as he suggests then you would have methods such as $object-&gt;getPath() and $object-&gt;getType() which I would also prefer since it's a bit more predictable, and your IDE's auto-complete would work with this as well. 
&gt;You can teach someone a language, it is much more difficult to teach them how to break down a problem and figure out the best way to solve it. You can teach someone to speak, but you cant teach them to say something great.
Don't get to the extreme and say "Mocks are bad!" either. Because that's not what the article is saying.
Try [gandi](https://www.gandi.net), I really like their PaaS offering (Gandi VPS), It might be a bit expensive for your needs though, but you can have all your 10 projects (and more) on a single VPS, if they are just "demos". Moving them to production is easy if you resell hosting space to your customers afterwards :). They don't provide unlimited bandwidth, but you should be wary of hosting companies making such claims. Bandwidth is not free (for now?).
I seem to remember a little while back reddit (or maybe it was Github) switched from pure PHP to PHP + Python or C or something and it had huge performance benefits (I've done loads of googling but can't seem to find the article where it was mentioned!)
Good catch. Fixed.
Simplistic approaches like this are far far from real use in everyday software development. Big deal C is faster than PHP for long run calculations. What else is new? Maybe those extra few ms can be scrapped, if you keep the C process in a loop, listening for numbers to crush on a socket, using something like ZEROMQ. That way there would be even less overhead. It would be great tough, if you showed a real use case where "C with PHP" is of any use, doing it the right way. As it stands, that article, brings no value to any dev that learned C way way way before PHP. 
Edit: Found it. See my first post edit: http://www.reddit.com/r/PHP/comments/1unlqa/why_you_should_use_c_with_php/cejwim3
Because the PHP version in Mac OS is generally out of date. The most current (in Maverick) is PHP 5.4, but Mountain Lion has 5.3 and Leopard (I think it is) had only 5.2. Relying on the OS to update your PHP version is a bad idea. Installing a stack is trivial and much easier to manage, configure, and update than the built in. Running something like Vagrant is an even better idea, but not something I can speak of myself.
I don't think there's a lot new in the notion that compiled C is faster than PHP for a lot of intensive applications. Worth pointing out that not everyone actually knows how to write C, nor is actually doing the kinds of application that would see any benefit from this. Little to offer here, IMO.
It's not necessarily "terrible" advice. Just out of date. Which is unfortunately one of the problems you have when dealing with learning from books.
This should be titled: "Why using PHP for things like calculating fibonacci sequences makes no sense." PHP has its place. Efficiency and speed are not its forte.
In most PHP applications, execution run-time is the last thing you need to worry about when it comes to performance.
/u/vbaspcppguy is incorrect. You cannot write inline C in HHVM. He was probably thinking about HHVM's ability to inline certain functions, meaning it statically evaluates the code and outputs simpler bytecode. An example is getters. A getter than always returns the same property will be inlined to just return that property (in the bytecode). This way, getters have zero performance penalty. Source: I've been working on HHVM
Github is ruby afaik
Reddit switched from Common Lisp to Python because there aren't very many up-to-date and well documented libraries in CL. Github is written in Ruby + Erlang.
Depends on how product is created. If it's created through a factory or resolved out of a sufficiently decent ORM, it remains a root aggregate that also lets you swap out its components as needed, without having to create them directly.
Edit: Found it. See my first post edit: http://www.reddit.com/r/PHP/comments/1unlqa/why_you_should_use_c_with_php/cejwim3 I was sort of right, sort of wrong. 
If you're looking for professional site auditing [Qualsys](http://www.qualys.com/) is one of the best I've worked with. Their tools are top notch and the we've had the lowest number of false positives with them. You can even run their [demo version](http://www.qualys.com/enterprises/qualysguard/web-application-scanning/) against your site if you want to see if it picks anything up. 
It isn't. It seems like it is because you don't understand the code. It's one of the dumber things I see you do all the time - throw your 2 cents in to threads you clearly know nothing about. You probably won't, but you should take this as friendly advice - if you don't know, just shut up and learn something.
No, even as "out of date" advice it's terrible. That was standard practice, *and standard practice was wrong*.
I would say it is incorrect to assume that people who work at Facebook have to work on PHP. Such a large scale system has multiple languages and runtimes working together From this slightly older Quora [answer](http://www.quora.com/What-programming-languages-are-used-at-Facebook), we can see that they use everything from C/C++ to Python to Ruby. They are also adding new languages like [D](http://dlang.org/) into their system. [Souce](http://www.drdobbs.com/mobile/facebook-adopts-d-language/240162694) So chances are, no fresh graduate knows everything but rather, they are picked for their ability learn and adapt fast
Are you talking about Phalcon, the PHP framework written as a C extension? (or whatever?)
10 years developer here. Switch to Python. ASAP.
You obviously didn't bother reading *any* of the pages you found on Google. What could possibly make you think that it would matter if it was a few years old? Has the 403 error changed in the past couple of years and I missed it? There are a number of reasons this could happen, not the least of which would be permissions on the directory or files not allowing Apache to read them. It could also be that you're trying to load the directory index, but there is no index file or Apache isn't configured to use the right one. Go back to Google.
I've never seen `unpack` in 7 or so years of doing PHP. That's not at all uncommon. I'm not saying it's useless, I'm just saying that I haven't done the sorts of actions that use it. Totally fine and I've learned something. BUT in my defence, the vast majority of times someone brings an "obscure"^1 function in to ask how to do something, they've actually just chosen a pants-on-head way to do something that can actually be done much more easily with more common, higher level functions. In my opinion, the response of "I'm not quite sure what your actual goal is here, can you explain it to me" is something that needs to be stated **far** more often here than it actually is. I'm well aware that in this case it is NOT an XY problem. I'm well aware that in this case I was WRONG. But far more often than not I will be right on this. And yes. Most of the time if people are talking about things I don't have a lot of experience in, I simply read. But I think that asking people to clarify their goal is overall a useful and reasonable thing to do, especially as my comment was the first, and people coming in might well get a better understanding from that response. And more importantly, there's no need for you to be an ass about it. 1 whether this is actually an obscure function or not is beside the point. edit: &gt; It's one of the dumber things I see you do all the time - throw your 2 cents in to threads you clearly know nothing about. Or just.. have a different opinion to you?
Check this one out: https://twitter.com/phpstorm/status/420597140386099200/photo/1
HHVM is pretty good at fibonacci though. Somebody should blog a benchmark about that. :)
Ah, I misunderstood. Thanks.
It's pretty easy too. If you're on Ubuntu: sudo apt-get install tasksel &amp;&amp; sudo tasksel From there, select LAMP stack. Follow the wizard. Then, sudo apt-get install php5-{modules you need} and a2enmod {modules you need} It's pretty easy
Argh...I just can't remember what site it actually was then...it was something to do with markdown and switching from PHP to C.... Looks like Reddit *does* use some C and Cython snippets, but not for markdown, just log parsing and some other small things: https://github.com/reddit/reddit/search?l=c&amp;type=Code
Hi, :) I created this because I wanted to use Gaufrette, but it gave me not-normalised results which rendered it useless for not wanting to change implementation code (which is what I want). So this came to be.
Also in the news: mops better than toothbrushes for scrubbing boat decks.
I don't get why you would start the whole thing with an interesting topic and then deviate to the standard useless benchmark that has zero use.
Your edit is still incorrect, those are specially generated files (note the `&lt;?hh` header), and they are only for use internally (they get compiled when compiling the HHVM binary). However, if you try to use the `&lt;&lt;__Native&gt;&gt;` keyword in your own code, the engine will throw a warning "Native functions/methods may only be defined in systemlib". That functionality is purely there for internal implementation of extensions/engine code.
Ok so first off. If you're going to add parameters like a file location to your url you're going to need to first start the url like this: index.php?map=... Then you also need to url encode the map value in the url with: urlencode() (http://us1.php.net/urlencode) when you get the variable with the $_GET, you'll want to also urldecode() the value. I'd probably call the $files1 as just $files and do the foreach loop as such: foreach($files as $file){...} If you have a double quote with php, depending on the variable (in this case $value), php will interpolate the value into the string automagically. http://www.php.net/manual/en/language.types.string.php ie: $value = "hello"; echo "$value world". This will output: hello world. So for your second echo statement do: echo "Map &lt;a href='index.php?map=$dir\$value'&gt;$value&lt;/a&gt;&lt;br /&gt;"; I'm not sure what you mean it keeps adding. Do you mean as you click on a map 'a' tag after the first pass, it keeps adding onto it? If that's the case, I'd consider setting a session (http://us1.php.net/manual/en/book.session.php) variable to track the initial base directory or something, in between subsequent calls, and use that for the base directory. Also, consider reading about the DirectoryIterator class: http://us1.php.net/manual/en/class.directoryiterator.php 
I might do a more detailed analysis later, but initial results indicate PHP 5.5 completes 10,000,000 sequences in 1.118 seconds on average, while HHVM completes the same # of sequences in 0.789 seconds on average, which is about 1.4x faster. I'm no expert at benchmarking scripts or HHVM though, so it might not be fully accurate. PHP Command: `php fib.php 10000000` HHVM Command: `hhvm -vRepo.Local.Mode=-- -vRepo.Central.Path=/var/share/fib -vEval.Jit=true fib.php 10000000` fib.php: &lt;?php function fib($n, $first = 0, $second = 1) { echo "Calculating {$n} numbers\n"; for ($i = 1;$i &lt;= $n - 1; $i++) { $final = $first + $second; # Next fib number $first = $second; $second = $final; } } fib($argv[1]); Note, if you don;'t use a function to perform the test, some of HHVM's optimization techniques won't work, as they don't apply to global code. 
Thanks you helped me very much.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help
Scumbag article: Title gives the impression that we're going to get a nice tutorial on how to write modules in C that PHP can call; Uses "exec" instead.
Phalcon is pretty amazing.
Correct. In Java (and maybe in .NET) You don't have to reference `$this` or `self` or anything like that when accessing class properties.
This is weird. I thought the whole purpose of Gaufrette is to abstract the functionality so you can swap filesystems. I need to build an upload handler that takes an uploaded file, validates it and, if valid, copies the result to a "container", which can be a directory on disc, mysql table, AWS bucket etc I would need a consistent API. Biased as you are, do you think your library is better suited for this purpose? 
wow good to hear @jtreminio . Hope you can also give some promotions when you talk about puppet ;) .
Wow, I had no idea references behaved that way. Very cool, but also rather unexpected.
&gt; but it never got anywhere I think it resulted into the `$a ?: null` syntax as far as I can remember the conference script. Don't think lazy evaluation was mentioned in that document, so it'd have killed the script either way. They should introduce short anonymous function instead... `() =&gt; new Foo` (maybe with braces, since PHP ain't good with them).
* I don't know what PHP version you are targeting for this library. If it's 5.3+ I recommend putting it in composer. * base85.class.php ... ew, please consider naming files according to psr4 use namespaces if 5.3+ is your target. * is null byte padding the only padding scheme available for base85? seems like that could cause problems if null bytes are legitimately tailing a binary string. consider supporting more padding schemes.
owasp.org take a look at the top 10, it gives you some things to look for.
Fuck `isset()` for testing array key existence, why not use `array_key_exists()`?
fyi, your link syntax is backwards -- you swapped the `[]`'s and the `()`'s -- that's why it's not being parsed correctly. Should be: [link text](http://...)
It really depends on what you're trying to achieve. If you care that the key exists and has a non-null value, then use `isset`. If you only care whether the key exists, regardless of value, then use `array_key_exists`. Source: Example #2 - http://us3.php.net/array_key_exists
facebook the site itself is written in php...
Yeah, I partially went with `isset` to support any `ArrayAccess` object. Might not be worth it though, considering it breaks on `null` values. I'll consider replacing it will `array_key_exists`, thanks. EDIT: Done. :)
Totally, there are major parts of the site that are written in php. I just wanted to point out that there are a lot of other technologies in play too. 
And now the OOP way! https://gist.github.com/aholmes/8319662
&gt; If you care that the key exists and has a non-null value, then use isset. More ridiculous nonsense -- use `array_key_exists($key, $list) &amp;&amp; !is_null($list[$key])`. `isset()` is blatant laziness that leads to unpredictable behavior. Being explicit is always better.
 ^ifsetor is a neat little function, but it seems wrong to call the behavior of print ifsetor($a, new Foo); a side effect. Programmers should understand that will instantiate the class before calling ^ifsetor.
Could you provide an example where using `isset($array['key'])` does not behaves as intended? Because I use it all the times (well, either `isset()` or `!empty()` in fact). Developers are lazy but it's a good thing ;)
If you're asking this question then a compiled framework is almost certainly a bad idea for your use-case. I highly recommend reading [ircmaxell's discussion on the subject](http://blog.ircmaxell.com/2012/08/thoughts-on-pecl-frameworks.html).
I was wondering what the performance would be like as a HHVM extension (presumably still outdoing JITed code), then found [this](https://github.com/phalcon/cphalcon/issues/1262). Seems like there's no intention of that.
&gt; there's a strong case to be made for this philosophy We'll just have to disagree on this point :) &gt; Can't knock Laravel for developers misusing it. IMO you *can* and *should* knock Laravel for developers developers for misusing it. It's the framework's job to prevent bad practices where possible ... otherwise what's the point? Every framework by virtue of its very existence is essentially saying "this is the correct way to write code." &gt; Laravel's IoC / DIC is pretty awesome. Good article. I'm glad to see that that it's possible to write quality code with Laravel (in contrast to most of the cruft I've seen).
&gt; Continuing our string of library package releases, today we have the 2.0.0-beta1 release of [Aura.Router](https://github.com/auraphp/Aura.Router/tree/develop-2). Given a URL path and a copy of `$_SERVER`, it will extract path-info and `$_SERVER` values for a specific route. You can [download it](https://github.com/auraphp/Aura.Router/releases) directly or install via [Composer and Packagist](https://packagist.org/packages/aura/router). &gt; &gt; ... &gt; &gt; [Attaching REST resource routes.](https://github.com/auraphp/Aura.Router/tree/develop-2#attaching-rest-resource-routes) The router can attach a series of REST resource routes for you with the `attachResource()` method. One call to that method with a resource name and base path will add named `browse`, `read`, `edit`, `add`, `delete`, `create`, `update`, and `replace` routes for you under that base path. Don't like the defaults on those? Set your own resource attachment callback with `setResourceCallback()`. 
Can't +1 this enough. It's totally solving the wrong problem. If your PHP web application is slow it's almost certainly due to synchronous blocking IO operations and not code execution speed. If your app really *is* CPU-bound then chances are you're Facebook and you already have HHVM in place.
You've already pointed it out: there's a difference between testing for array key existence and non-null values, but `isset()` makes no such distinction.
It's not a true replacement though. What is the behavior given the following example: echo "\nGitHub test\n"; echo "-----------\n"; $data = array( 'foo' =&gt; array( 'goo' =&gt; array( 'baz' =&gt; 'Ya got me!' ) ) ); $t = new Traverse($data); var_dump($t['foo']['bar']['baz']);
It prints "Ya got me!" Is that not what get_in() does? I'm not sure what I'm missing here.
.. but, how many lines of code does it have compared to Silex? you forgot to mention that part
Sure you can pick and load packages and autoload them via composer, but if you choose to go framework-less, you miss out on some good architecture decisions from the start. That's where a good microframework comes in, like Slim or Silex. 
Subtitled: *if you're capable of writing well-architected secure code right now ... otherwise you probably do still need a framework.*
Sorry - I should have pointed out the change. I changed the second level to 'goo' instead of 'bar', so that it was accessing a key that didn't exist. Your code does work when accessing as array: // Attempt to access nonexistent key via ArrayAccess var_dump($t['foo']['bar']['baz']); // prints NULL // Attempt to access non-existent key via object access var_dump($t-&gt;foo-&gt;bar-&gt;baz); // Thows notice "Trying to get proper of non-object http://d.pr/i/ouTg To fix this, maybe you could return `new stdClass` if the requested key isn't the last one in the sequence.
I meant when you don't care about null. Why bother to combine `array_key_exists` + `!is_null` instead of just `isset`?
Perhaps we read different articles: &gt; For newer developers, *itâs still best* to make use of established tools instead of ârolling your own.â `*` edited to be less of a jerk :)
Basically "you can assemble your own application layer from prebuilt packages". It's true. I'll still use Laravel or Silex for that though. I agree with this article but I feel like the more important distinction is that your models, services and repositories should not be tightly coupled to your application layer, be it a framework or whatever.
Aren't most frameworks set up that way anyway? I use Symfony and install the packages I want with Composer.
I guess I'm a little biased, but it seems like most modern frameworks already work like this. Laravel currently uses 23 of the "best" PHP community packages (Carbon, Whoops, Pheanstalk, Symfony, PhpSecLib, PaswordCompat, Predis, etc.) They are then glued together, and some of our own components that don't have quality community equivalents like Queues, Eloquent ORM, etc. are added to give you a cohesive, coherent foundation for a well organized project. I assume the same could be said for Symfony. You can pull in whatever you want, but using Symfony gives you a solid project structure to begin with.
To help you out, there's a grammatical error in one of your key sentences: &gt; **get-in** is a function takes a associative structure and a list of keys that represent the nested traversal. **get-in** is a function _that_ takes _an_ associative structure and a list of keys that represent the nested traversal. I assume it's because English isn't your first language. I had to read your sentence a couple times, as I kept breaking it up as: "get-in is a function." "takes.(?!)" "A associative..." I was confused. The _an_ fix is a freebie. ;)
See /r/phphelp
Provide some context for [syntax woes](http://stackoverflow.com/questions/18050071/php-parse-syntax-errors-and-how-to-solve-them). It's not clear what breaking means to you. Sounds like you're viewing an unparsed PHP source file in the browser. See /r/PHPhelp 
You should ask this on /r/phphelp But, just to answer part of your question, you have an incorrect structure for the `$_FILES` array. Try this: if (isset($_FILES['file_upload']['size'][0]) &amp;&amp; $_FILES['file_upload']['size'][0] &gt; 500000)
Yeah Symfony, Silex and Aura all work in exactly the same way as Laravel in this regard.
View source - it's probably all being parsed as HTML, and your browser is just showing the bit after the &gt;
I really would like to repost this question at /r/phphelp but you downvoted me that much that I'm not allowed to :/ This might help: Thats a part of my code: // Check filetype if($_FILES['file_upload']['type'] != 'image/jpg'){ die('Unsupported filetype uploaded.'); } // Check filesize if($_FILES['file_upload']['size'][0] &gt; 500000){ die('File uploaded exceeds maximum upload size.'); } // Check if the file exists if(file_exists('upload/' . $_FILES['file_upload']['name'])){ die('File with that name already exists.'); } When i execute the code, all i get is this output: 500000){ die('File uploaded exceeds maximum upload size.'); } // Check if the file exists ....... I know that this is not quite sexy written but I wanted to get it to work first.
Thanks for the response, I will take a look and see if any of those fit my needs. Does Symphony/Zend work even if I don't use their framework, just the components? I need to integrate into a custom site.
Assuming `ifsetor` would have been a language construct like `isset` is, and is lazy-evaluating (which does not exist in PHP), it wouldn't be evaluated unless that *branch* would be entered. But in real PHP...
I would recommend taking a look at the autoloading standards set forth by the PHP-FIG [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md) or [PSR-4](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md) This will help with the structure of the code hierarchy. You're doing pretty well on code formatting, although I also question why you have a blank line after every statement. For testing, I would recommend writing unit tests using the [PHPUnit Testing Framework](http://phpunit.de). What you have is good for functional testing, but it doesn't give you feedback or failure messages. PHPUnit is a great way to automate your testing which helps a lot while coding (you don't have to manually run all the tests to make sure a change doesn't break anything.) You can also take a look at [Codeception](http://codeception.com) which offers a full stack testing framework that covers unit testing, functional testing and acceptance testing. Hope that helps. Overall, I think you have some good concepts here. The fact that a lot of what you've written is already in place within other popular PHP frameworks shows that you have a good head about you and you understand how to solve common problems. Oh, and one more thing, you should also take a look at [Composer](http://getcomposer.org) for dependency management and [Packagist](http://packagist.com) for a collection of awesome code that you can use and learn from.
 if (idx($_FILES['file_upload']['size'], 0) &gt; 500000) Where `idx` is kind of a fancy Version of `isset($a['key']) ? $a['key'] : $default`. Never, ever write that variable twice anymore â¥ https://github.com/facebook/libphutil/blob/master/src/utils/utils.php#L38
You're starting each line with a comment, which means that the PHP that follows won't be interpreted by the server. The browser then sees the "&gt;" symbol as a closing tag symbol and shows everything than comes afterwards as plain text. Put your comments on different lines from your code, or put them after the code.
I think I missed the part where he made a strong case for the *advantages* of forgoing a good framework. Personally, I'd much rather live in a world where I'm asked to pick up maintenance of a site where everyone previously involved used the same **documented** and established framework rather than some tortuous hydra of multiple previous maintainers imaginations...
Good link. One of the top links in /r/php would help here as well - http://www.reddit.com/r/PHP/comments/1upjhn/functional_library_traversal/ Similar concept, but the code was borrowed from clojure and the function name is `get_in`
If I had to guess, OP is on Windows and some funky stuff is happening when committing/pushing to their Git Repo?
What webserver are you using? Are you using Apache? 
I would recommend [usercake](http://usercake.com/index.php) I used v1.0 extensively when I was a beginner and It really helped me to both understand PHP and feel like I was getting somewhere. The layout of the files and the code inside of them is easy to understand after reading through it. It is also easy to make modifications for your particular needs without digging through layers of abstract files and folders like other frameworks. Speaking of frameworks, this is not really one. Just a bunch of grouped php files and functions that make creating a website from scratch much easier. It has login/logout, signup, forgot password, email activations and a bunch of admin features to manage your users and which pages are public/private. It would seem a 3.0 version is in the works with a beta release on GIT january 9th. Enjoy!
That seems to support deep arrays. But I reckon most use-cases would be rather flat arrays, where such an implementation would bring some noticable overhead. At least if you had seen Facebook's Phabricator code base (for which that lib was created), `idx` gets used a *lot*.
As per usual I'll be doing my best to keep the community up to date about the evolution of this new PSR as we work on it. I'm gonna be the coordinator again, so I can put my skills of arguing on the internet to a good use once again. How do you lot feel about a HTTP Message PSR? This to me is one of the very reasons the FIG exists. Messaging is the first half of a HTTP Client PSR, which would completely remove the need for packages to build a zillion "HTTP Adapters" like poor old [Geocoder here](http://geocoder-php.org/Geocoder/). We've spent a lot of time getting things this far, but now we have PSR-1 and PSR-2 we have the coding standards that will be used for this HTTP Message PSR. That to me was one of the major benefits of having them exist in the first place. :) **Edit:** I am not calling it by a PSR number because following the workflow it won't get one until it passes its entrance vote. If it does pass then it'll be PSR-7, unless some other PSR comes out of nowhere before that. But, right now, technically it has no number. 
It's definitely needed. Do you know if any work been done on contacting the half dozen or so popular HTTP abstractions?
It's actually a copy-paste error from the previous post. Thanks for the fixes, they have been merged!
Yes you do!
The folks behind Buzz and Requests have been throwing in, with Michael who is the creator of Guzzle, so that has PHP's 3 most popular libraries covered. When this is in Draft stage I'll make sure we get a survey done of what methods and structures people are currently using. This might not be hugely beneficial, but we definitely wont be ignoring the others. :)
I don't think anybody assumes they have to rely on one single source for all the parts. If I am building an application with Laravel, I can obviously shove in bits of SF2 and ZF2, right? That much is fairly universally understood about components, regardless of Composer or anything else. I can shove PEAR code into my Lithium, great. And people know that they can use completely native PHP with just a few components included. That much is again (as far as I have seen) fairly well understood in the PHP community. So far these are both good things. What a lot of this article was saying however is that "This means you donât need a framework". A framework as we knew it to be between 2006 and 2012ish no longer really exists. You definitely don't need those. None of the modern frameworks are frameworks in that "classical" sense, so you are arguing against something that doesn't exist. The vast majority of the frameworks have become components and application layers, which seems to me to be exactly what you are suggesting is a good idea. So again, the meaning of "framework" probably means something to the pair of us, but when I read this article I see "Down with the framework, long live the framework!". :) Use whatever components you like, use whatever application layer you like. They've built some nice ones and you can build your own if you're any good at architecture. Sadly the VAST majority of beginners are not very good at architecture, so they probably shouldn't be trying to do that. As you say in this very article: "Iâll be the first to admit I donât want to compete with Matthew Weier OâPhinney in a battle of intellect; heâs smarter than I am.", so why are they replacing perfectly functional application layers with their own? Replacing sample application layers with your own is just potentially opening yourself up for a sea of issues, with very few benefits. You might be able to cut away some dependencies sure, but you are completely reinventing the wheel. [Reinventing the wheel can be great](http://blog.ircmaxell.com/2012/08/reinvent-wheel.html), but it's often not that useful, especially if you're trying to hit a deadline, are passing the work over to somebody else, are a beginner or are working with a beginner. Definitely not saying you should always use the framework sample applications, I'm just saying that "frameworks" aren't the devil. They've changed. Old framework bad, new framework good. Maybe it's just semantics at this point.
Having written extensive HTTP servers and clients myself I have serious concerns that this is standardizing quite a few implementation details that have no business being part of a standard. The `Message`, `Request` and `Response` interfaces are great and abstract RFC 2616 well. Standardizing these interfaces would have far-reaching benefits for the PHP community and I can't +1 them enough. However, enforcing anything beyond that is crossing the line from "standard" to "arbitrary proclamation" IMHO. Edit: the `Header` things are also really useful.
Both the API and the implementation feel like JavaScript somehow. In the sense that you're using similar tools, but there is a toolchain a quite bigger in PHP. There are a lot of ways of doing fluent interfaces, DSLs and "magic" in PHP, like accepting Closures as parameters. I've always been a fan of this, so I'll tell you what I would've done. The fluent interface with long closures is rarely good, and you need to provide some support for breaking that up. Instead of typing parameters as "Closure" as you did I would just check if they pass on [is_callable](http://php.net/is_callable). This way an user can point a custom method from one of his objects to the fluent interface. The fluent interface can be greatly improve acting as an index or configuration for more complex, structured code if needed. Considering the test exercise, I would considering automating more. You left a lot of lines commented which I think are for debugging. There are tools to automate the checking of different scenarios and outcomes (and you can create your own if you want). That would be a great exercise! Thanks for sharing your efforts =)
For the HTTP Request/Response interfaces is this not essentially a standard of how to represent a standard? HTTP Requests and Responses are already well defined in the HTTP specs. Would a standard implementation (i.e part of a PHP standard library) not be a much better idea than defining a specification where most of the implementations are going to be the same? For example, both Python and Ruby have HTTP Response/Request classes in their standard libraries.
I realise this you're probably conforming to the PSR coding practice* but please drop the 'Interface' from the name of every interface. Every piece of code that is ever written using these interfaces as the type-hints for their methods will be harder to read than if you don't use 'Interface' in the name. *This is one of the reasons why I hate defining universal coding style guides.
You don't *need* a framework, but deploying CodeIgniter when I'm starting any project where MVC makes sense (which is most of them, in practice) saves me from getting bogged down in architecture decisions and/or assembling various packages, while getting most of the boilerplate code out of the way for me. Sure, I don't need it -- I've still written more PHP without a framework than I have with, since I was stubborn to adopt them -- but how about giving me a reason why I shouldn't use one anyway?
I agree â when I first started using Laravel (started on 4) I couldn't believe what a genius you must be â how could one person write such a vast array of incredible code!? Then I realised your role is perhaps part curator and part architect - no less impressive, but different to how I assumed frameworks worked. Thanks for Laravel and your book by the way â both have changed the way I approach programming pretty much across the board!
Okay, sorry. I was really busy an hour ago. Now I can respond appropriately here instead of forcing people to click over ... I really like the proposal in general. Definitely a step in the right direction. Standardized interfaces for modeling HTTP messages and headers are useful. However, specifying interfaces for factories is way off-base for a standard. Instantiation is an implementation detail; we don't put `__construct` in interface definitions. By enforcing a standardized factory interface you're essentially providing a backdoor `__construct` method in the interface. The other philosophical issue I have is the requirement of a `StreamInterface` ... this again has nothing to do with HTTP and deals with how clients and/or servers must represent the entity body internally. Is it a a nice abstraction? Definitely. But it's an internal abstraction that has nothing to do with HTTP. There's nothing in RFC 2616 about streams. So in general the PSR is a very positive thing ... but enforcing arbitrary implementation details is something that needs to be addressed. `*` edited for brevity
I'm with /u/rdlowrey in that it's probably a bit to big for one PSR. Especially StreamInterface seems like a prime candidate for its own PSR. This would also reduce ambiguity if I claim my library follows PSR-X (known as HTTP Messages) but I only implement the StreamInterface.
"I ran an arbitrary benchmark comparing a compiled language against a interpreted language built on top of it and guess what? THE COMPILED LANGUAGE IS FASTER!"
Yawn, another unqualified person attempting to standardize PHP. My major beef with PSR-* is that members who are in part are responsible for creating PHP 'standards' are the same member that have horrible track record when it comes to PHP 5 adaptation, code quality and vulnerabilities. Just look at the list of member projects: http://www.php-fig.org/ Am I only one that remembers how shitty some of those products were?
Oh yeah absolutely we shouldn't be telling people how to instantiate stuff. We are a long way from that sort of conversation though, as at this point the conversation is: "Do we want a HTTP Message PSR or not". When it gets into Draft we can start to talk about this stuff more, and that sounds like it will be one of the first things to get chopped. :)
Who is unqualified? This PSR is being headed up by the creator of Guzzle. 
People fought and fought about FooInterface, Fooable, IterfaceFoo, FooI, for months. Nobody will ever win. One has been picked, so sticking with it sounds like a pretty good plan. Otherwise we'd have to either break PSR-3, change it (no) or have a different naming convention for this PSR. That sounds like exactly what happened to PHP to make strlen str_replace happen. Let's just keep personal opinions out of a naming convention and stick with the convention. For once. :)
I would argue that creating an HTTP client in PHP does not make you an expert in HTTP. Without looking at it, I would guess the new PSR is going to be based loosely on how Guzzle was architectured? Heh.
I wish I had the problem where it was time to think about using C. Nobody visits my sites.
My trick to remembering to put the square brackets first is having [this trance artist/song](http://www.youtube.com/watch?v=8_e1kJI7D28) pop in my head. Yeah, I know, barely makes sense. Start typing something I want to make a link, "square nova" pops in my head, and I use square brackets first.
I just have a general question about the StreamInterfaces and whatnot. If the StreamInterface is part of the HTTP PSR, and I (for one reason or another) decide fuck it, and implement my own StreamInterface in my code, would it generally be considered then that my project was not compliant with the HTTP PSR? I realize that "compliance" is a misnomer here, not like there's a governing body auditing or regulating any of this I'm just curious what the general consensus would be. My thought is simply that I'd like to be able to make my project compliant with the HTTP PSR for requests and responses but handle anything that relates to entity bodies however I wish. EDIT: That's not to say the StreamInterface / factories are bad, I can kind of see them being a separate PSR.
Ok certainly, making an HTTP client does not make an you expert in HTTP, but making a client that has been installed almost a million times makes me wonder who would be better at doing this. This PSR at this point has also had input from the folks behind Buzz and Requests, which are the other two most popular HTTP clients. And, of course, it has an eye towards HttpKernel. This is not simply a spec made from Guzzle, Guzzle will forced to change to adapt it. Any other questions? :)
Ah, I see! I didn't catch the "goo" part. Good call on returning stdClass. Off hand, I can't think of a way to determine if it's the last accessor or method in the chain without first returning Traverse objects, and then checking each key. Any ideas? It seems like a good exercise, anyway. Maybe it's better off without the accessor method, since that does kind of change the original scope of the problem, which was to access possibly non-existent keys, not object properties. Really, chaining accessors seems silly and crazy anyway. 
As I understand it, there is no problem using streams in this way, to solve this and similar issues. However, it **is** enforcing an implementation detail. If I want to make a project that doesn't use streams, I should be able to. As he put it, there is nothing about HTTP that requires streams. Bundling this in is sneaking (good) implementation details under the radar, and that's a bad thing when the goal is just to standardize interfaces. Leave the smart implementation details to the smart implementors. :-)
I'm pretty sure /u/jesse_dev is being snarky, but even so: (1) You wouldn't compare to Silex, you'd compare to Symfony Routing; and (2) a quick `cloc` of the two, minus tests, looks like Aura.Router at 566 and Symfony Routing at 2706. Not that that means much; I only brought it up because you asked.
phpBB don't have much relevant experience in building HTTP clients, but the guy who builds a HTTP client does, so he would be better at doing this than many people. I'm not sure what you were getting at there. :) What we are getting at certainly is more important than a circle jerk, but it can take a while to see why sure. Have you ever created a package and wanted to do HTTP interactions within it? * Are you going to file_get_contents and curl that yourself? Hell no, you're going to use a client that doesn't suck to work with. * Are you going to use Buzz, or Guzzle? * If you use Guzzle, does that mean some people will have Buzz AND Guzzle installed? That seems wasteful. * I guess you should build adapters for it. One adapter for Guzzle, Buzz, ZF HTTP, etc... That's a ballache. [This happens](http://geocoder-php.org/Geocoder/). This PSR is the first step in avoiding that needing to happen. Buzz, Requests, Guzzle, Aura, and all of the projects on the FIG will implement this, meaning instead of having to build (for the sake of argument) 10 drivers you only have to 1, then maybe another for native curl. That certainly cuts down the amount of code. What people do with their free time is up to them. If people on here want to jerk each other off them they can feel free, but the intentions of the PSR have merit and we'll be pushing ahead. :)
You're the only one making claims of "PHP expert" nonsense. The FIG is just a group of like-minded developers looking to standardize some things amongst themselves and their respective projects to aid in interoperability. If you don't like what they're sharing with the community, don't implement PSRs. If you just don't like that other developers *do* like these ideas, talk about them share them, implement them, etc. then ignore them. How hard is that?
As @afishnamedsquish pointed out, here is an example http://harikt.com/phpform/ how to integrate [Aura.Input](https://github.com/auraphp/Aura.Input) and [Aura.View](https://github.com/auraphp/Aura.View) ( only the view helpers are used). You can see the code over [github](https://github.com/harikt/phpform). You can also see the post http://harikt.com/blog/2013/05/21/standalone-forms-and-validation/ regarding how to integrate [Aura.Filter](https://github.com/auraphp/Aura.Filter) or any validation library you like.
Clearly spelling out how the body of a message can be used in an interface is the opposite of an implementation detail. Allowing messages to represent their payloads as any arbitrary data structure left up to implementations *is* an implementation detail.
Don't tell me what I need.
We are back to square one, using the same logic a guy creating a HTTP client might or might not know about HTTP standards. I have absolutely no problems with rolling my own basic cURL adapter for my application. There is absolutely nothing is wrong with that, not everybody wants to use a full blown library to make basic requests. You saying 'hell no' is a bit close minded. Like I said this will be used by the same people who proposed it and probably not going to matter to 99.999999% of PHP engineers but 100% to people who will review code and look if it follows this PSR so they can make a comment how a simple cURL adapter within application XYZ does not follow this over kill of an architecture. Just like 'programmers' here 'review' applications with 'OH I HAVE NO REAL COMMENT BUT YOU SHOULD BE USING PSR-XYZ LOLOL'. 
Yeah, that's true. Though, I'm not as concerned with the actual interfaces as I am that this proposal seems to be shadowing caching's early problems of biting off way too much at once. Personally, I'd like to see a one-interface-per-PSR approach taken for this and future proposals. It may be more convenient to say "PSR-X compliant" after the fact, but things would move *so much smoother and quicker* if we had, say, a RequestInterface PSR, a ResponseInterface PSR, and so on. The unanimously supported core would be passed easily and quickly. The hotly debated hitch-hikers could stay in limbo forever without holding up all the things.
Based on feedback, I removed the factories, so I think it's biting off much less now.
As mentioned many times we may not seeing session to save the errors. And the Validation itself can be part of another library. So you can inject a filter or validation library of another. I have achieved the same with the help of [Aura.Input](http://github.com/auraphp/Aura.Input) and [Aura.View](http://github.com/auraphp/Aura.View) helper to render the form. The plain old way example at http://harikt.co/phpform/ and source in github.
When people blindly jump on 'standard' circle jerk without understanding anything you have some sort of responsibility as author of a standard. I keep seeing stupid comments from people here who add absolutely no value to discussion when reviewing something. Every showcase will have a race of idiots checking if you are following PSR guidelines so they can go and write "looks good but you are not using PSR you should really use PSR because its PSR etc" and in most cases that would be the most useless contribution to the discussion. That being said, I think general concepts of PSR (currently) are good but I feel like it's getting too complicated.. following a specific standards that are a complete overkill for most of the simple cURL implementations (or requires you to depend and use a complicated library) is ridiculous. 
&gt; Unfortunately there is no "framework agnostic library repository" Sorry I want to disagree your assumption. You should really check http://github.com/auraphp . Every package is truly independent, and can be achieved the same result. See the form example http://harikt.com/phpform/ , source in github. &gt; Packagist should have been the place, each framework having to register for a "subdirectory" Yes I agree with this. Else when you search for filter you see a lot of bundles :)
Whether or not you like the PSR, you realize you sound like a huge dick, right? You didn't know who created the PSR yet you claimed the person who created it wasn't qualified. When you were informed who created it and the project he maintains, you didn't know who that was or much about the project. Now you're claiming people who code in PHP aren't capable of creating standards.
I'm speaking in general that some of people who are on board of general PSR produced applications that would make you question if they should be involved in a process of creating 'standards' that people drink like kool-aid. If this does not apply to this proposal, that's fine. But when first response attempts to tell me that they are qualified because A) they wrote a HTTP library in PHP B) it has a lot of downloads then I'm sorry but that does not sound to me that they are protocol experts. 
Ok. That would have been a better opener. Just FYI, I am an expert in the protocol :)
He doesn't even mention how C helped him with his project. Clearly this post written to draw traffic, no useful information is revealed.
It *implicitly* enforces the use of streams in all conforming implementations of HTTP messages. I don't disagree with the usefulness of streams in this regard. I just think the interface is too opinionated for a basic HTTP messaging PSR, and I'd rather see an extended set of interfaces for stream support (StreamableMessage/Request/Response) that define getBodyAsStream() and such. **Edit:** ...in a future PSR.
Oh you did it Paul :). Sometimes laziness is the key to success ;)
How would you suggest the body of a message be represented? As a string?
As previously noted (and in the post title, even), this is a *pre-draft proposal*. It is not a PSR, or even getting close to becoming one yet. It's a glorified suggestion, in other words. And if you've read all about it, you'll notice that it's currently catching a lot of flak for various reasons. As far as people parroting PSR support goes - what makes you think "PSR support" isn't a well-thought-out suggestion? Believe it or not, PSRs have a metric fuckton of community support right now that doesn't involve mindless bandwagoning. People like the direction PSRs are pushing the PHP dev ecosystem in. If you don't, that's your prerogative, but don't be a hater just because you see people suggesting that other people join the party.
You completely missed my point.
We're not there at all. No, you suggested that Michael doesn't know anything about HTTP and I suggested that his incredibly popular HTTP library might be a good indication that he does. It's not purely the fact that he made a HTTP library, but the supporting evidence of it being installed nearly a million times add credit to the fact that its not broken. Regardless of that, I am confident that he has expert knowledge of the HTTP specification because A) I've spoken to him enough to know he's not an idiot, and B) working for Amazon Web Services would certainly suggest he knows a thing or two about the web. The rest of this has gotten to the point of just being noise. You suggest that 99.999999% of devs would rather try to force Curl to do everything (OAuth 1.0 signatures are fun) instead of using a HTTP client, but that is just absolutely not based on fact. Go look on packagist to see how many package require these various HTTP clients, and see if I am right or wrong about saying its more than 0.000001% of developers. If you can't see the use, then you probably aren't the target audience. I've tried to explain its use, and you don't get it. That's ok, you probably don't need to use PSR-3 either unless you're building a logging package. Carry on. :)
I never said he does not know HTTP, HTTP is pretty complex having a person who is involved with it on more than writing a PHP client using wrappers that doo the actual logic would be a good idea right? That's fine if you can vouch for him, but obviously you will since you know him? What makes you an expert in the protocol to veto for him? I never said 99.999999999% will use cURL, I'm pointing out that you think that's the case due to your comment on how I would never use cURL directly .vs a library. Also, how many 'do all libraries' are there that would actually benefit from this PSR .vs projects that use cURL/PHP features to make small amount of requests application requires? Basically you will have thousands of latter that do not pass this PSR and need to be over engineered so the PSR 'kool aid' drinkers are not bashing it. 
Well, that would be the obvious/simple choice, yes. Off the top of my head (and with moderate sleep deprivation), an acceptable alternative might be to abstract the streamable stuff into the body itself: // PSR-http interface MessageBodyInterface { public function __toString(); } // future PSR interface StreamableMessageBodyInterface extends MessageBodyInterface { /* stream methods */ } But I haven't given that sort of approach much thought. It does leave the door open for elegantly abstracting multipart messages as part of MessageBodyInterface though (maybe an iterable getParts() or something, idk...).
Source?
Hi robhidalgo, coding is one thing, documentation is the other thing. You need both! 
What do you mean, source? I lifted the issue with them after reviewing the code when they first released it. They said that they would take a look at it, but apparently they haven't. The issue isn't some bug, it's that the throttling mechanism is misdesigned. 
I checked everything. There is no wrong HTML Tag. I uploaded the whole script to jsbin and you can see the exact same problem. http://jsbin.com/EleTUGa/2/edit The validator says that the &lt;? beginning of php is wrong. But I don't see whats wrong there :/
The observer pattern is normally best for these situations. You have one more dependency passed into the constructor, an EventManager, then at various points in the lifecycle of your entity you trigger events on the EventManager instance, some examples: $this-&gt;eventManager-&gt;dispatchEvent("beforeGet", $data); ... $this-&gt;eventManager-&gt;dispatchEvent("beforeSave", $data); ... $this-&gt;eventManager-&gt;dispatchEvent("afterSave", $data); etc. That way you can have other objects that listen to and act on various events without the Entity class needing to know the specific implementation.
Ok let met preface this by saying that a lot of this stuff comes down to personal style and preference, there's hardly a *right* way. Do what works for you until you realise why it doesn't work and then you can fix it and move on to something else and next time you'll know, but don't sit down for 3 hours over thinking it. In the example case you have provided, it is not common to pass something like the MyPdoObject to every instance of a model. More likely you have something like a BaseModel that Post extends. So your BaseModel knows how to find itself, save itself, delete itself, update itself, etc... and your Post inherits all that stuff by extending it. Of course your BaseModel would be making use of a "DatabaseHandler" sort of object to talk to the database. DatabaseHandler may be an implementation of "AbstractDatabaseHandler" or it may adhere to "DatabaseHandlerInterface". So in that case say you want to do caching transparently. You'd put together a "CachedDatabaseHandler" and let your BaseModel use that instead of the previous DatabaseHandler. Your CachedDatabaseHandler would look similar to the normal DatabaseHandler, except it would have some logic to hit the cache first. private function getStuffFromDatabase($stuff){ if (isCached($stuff)){ return getFromCache($stuff); } // Not cached grab a fresh one // blah blah } 
As an alternative to having domain models that are database aware, you could consider using Doctrine or one of the other ORMs. It implements the Mapper pattern and will help decouple your domain classes from the fetching/persisting functions (which can be implemented in a layer of service/repository classes). Once you have separated your concerns you can implement caching somewhere sensible, away from your domain model.
There is. I don't think it is the job of the blog post to "fetch itself" from the database. There should be an extra object to do this job, it's called an object repository, and abstracts aways the fetching from the DB / building of the data object. They're also sometimes called DAOs (for Data Access Object): $repository = new PostRepository($db_connection); $post = $repository-&gt;getById(1); Also, a post should not "display itself". That's not its job either. Apart from that, you might have several views of the same data model. The best way in my humble opinion would be to render it through views (in this case, templates): $template = new Template('post.phtml'); $template-&gt;assign('post', $post); $template-&gt;render(); Every class should do *one, and only one* thing. Data objects (as your Post class) should be doing business logic only. That is, the pure logic your app is suposed to do. In this case not much, as the posts don't "do" anything, they just contain all the information of a post to be rendered. I hope that helps! EDIT: As for the caching layer, well, you could implement it in the repository itself, or you could do an intermediate layer that does this job. This way they can be interchangeable and later on you can easily switch cache backend: $cache = new PostCache($repositry); $post = $cache-&gt;fetch(1); I like this approach better. Also consider where do you want to do the caching. At object level (like you're proposing), at template level (if the page is readily rendered and stored somewhere, you can skip the post loading), or outside your application (which is my favorite approach) as a HTTP cache which stores the whole page for a while.
Thanks for your comment. The example I provided was a very basic one to just illustrate the problem. I think I undestood most of your comment, by the way I don't know how I can manage the dependencies among those classes? In your example the model should depend on the CachedDatabaseHandler. But that class should depend also on the database object (that is going to use on a cache miss). This drives me nuts. I think so that I need some mechanism to instantiate correctly those classes with the right constructors args, so that they could be changed or tested easily. Correct? 
Thanks, I replied to GFandango below, I understand the concept, but if I want to use DI with constructor injection I can't figure out how I can resolve all the dependencies correctly and in a sane way.
Thanks for the idea on the mapper pattern, I didn't know it. My problem is more forma a design perspective rather than on choosing the right tool for the job. I'm reading a lot on doctrine and by reading also the mapper pattern it seems to me a great concept to apply to this scenario. As on my comments below the problem that next comes in is how to manage the dependencies.
Probably doesn't help at all, but I prefer a different naming paradigm. First, I follow the WordPress coding standards, so I never use camel casing. However, above that, I would name my function 'getPostById'. The function you use to cast the class is meaningless later on, it could be anything. Plus, what happens if you want to pull post tags? Categories? Attachments? Properly naming your functions can save you a lot of headache in the future.
As others have said, it will probably make sense to abstract MyPdoObject one level further into a Post-specific DAO and inject that. However, there are often cases where you want more than just the DB record to be cached; you want to cache the entire object. Moreover, the object may have different valid states and you want to cache each separately. An example might be if Post has extraneous fields that are only used for admin purposes, so you only populate those fields when it's being used in an admin context. You might cache one version for front-end use and another for admin use. To make the API simple and sane, you could use the factory pattern. Then your code looks more like this: $post = Post::get_instance_by_id($id); Note that I didn't inject the DAO object here. This is because the Post's constructor should be written to instantiate its appropriate DAO by default. We only pass the injected object when it needs to be different; e.g. for testing. Such a constructor looks like this: private $_dao = null; public function __construct($dao = null) { $this-&gt;_dao = $dao ?: new Post_DAO(); } The factory itself might look like this: public static function get_instance_by_id($id, $dao = null) { $cache_key = 'obj_post_id_' . $id; $cached_post = $memcache-&gt;get($cache_key); if ($cached_post) { return $cached_post; } else { $new_post = new self($id, $dao); $memcache-&gt;set($cache_key, $new_post); return $new_post; } }
I would split this into 2 layers for classes in your application, the domain model (depends on the data to populate it) and the repository layer (deals with fetching the data caching etc and will use doctrine to populate my domain model with data from the db). In your example the repository class would contain the getById function and would have whatever dependencies it needs to implement caching passed in the constructor (although Doctrine has caching built in). To go one step further use a factory class to new up the repository. This way the class repository dependencies are managed in one place. The domain model classes remain blissfully unaware (loosely coupled) of the repository classes :) Have a read of this - it goes through separating the layers of an application - http://kristopherwilson.com/2013/11/27/decoupling-the-framework/
You are lucky. I've seen monstrous apps built on top of well established, documented frameworks and easy to maintain apps build with a router on top of Smarty 
You write an interface whose only job is to fetch a post: interface PostFetcher { public function getById($postId); } Then have both the database class and the caching class implement PostFetcher: class FromDb implements PostFetcher { ... } class FromCache implements PostFetcher { ... } Link the two classes with a Chain of Responsibility pattern: class FromCache implements PostFetcher { private $nextFetcher; public function __construct(PostFetcher $nextFetcher) { $this-&gt;nextFetcher = $nextFetcher; } public function getById($postId) { if (/* post is in the cache */) { $post = /* get post from cache */; } else { $post = $this-&gt;nextFetcher-&gt;getById($postId); } return $post; } } The chain itself gets built in a Factory: class FetcherFactory { public class create() { return new FromCache( new FromDb() ); } } The constructor of your Post class would then take a PostFetcher, which you create with a FetcherFactory object. A bunch of other posters, like /u/camus2, make the good point that the Post shouldnât be fetching itself, though. That would ideally be the responsibility of a separate class. The patterns above, though, should help with the database/cache issue. And yes, an ORM like Doctrine would do all the fetching and caching for you. Then again, a CMS like WordPress would do all the post handling for you, but I donât think that's why you are asking your question. EDIT: s/class/cache/
Excellent use of chain of responsibility.
You're still confusing everything about this. This PSR will be useful for anyone who makes a package that interfaces with a http library. If they would like to support an unlimited number of libraries out of the box instead of just one, then they can type hint against this and be done. Don't take the "hell no" comment too seriously, it was jestful, but it is how things work these days. People use http clients, and a http client PSR would allow support for multiple instead of using adapters. That's the use. I don't care about the kool aid stuff, that has fuck all to do with us or our work.
I'm not the owner of the site nor do I know who this Brandon guy is. It came up on my RSS feed and I thought it was an interesting read. I also think it's unfair to say this is spam dressed up as an article. How many sites have articles and don't advertise their own products on the side? If it's okay for Sitepoint to do it, why is it not okay for this guy to do it? Just because it's a personal blog and not a company blog? The article itself has merit. While I don't completely agree with him that frameworks are not needed, I think he raised some good points. But I do agree with you that his products are overpriced and the quality is unknown.
&gt; I'm not the owner of the site nor do I know who this Brandon guy is. Ok, then I apologise. It seemed spammy because it seemed you were the owner 
Sure, nothing can stop some people making a dogs breakfast out of anything they touch, but in your case it's probably a bit easier to understand/fix a monstrous app on a documented framework rather than a monstrous app on top of some hideously bad foundation.
I just copy and pasted the contents of your file and ran it on my local server and I don't see the problem you're seeing. Are you sure your server has PHP installed? To check, create a blank document and just put in &lt;?php phpinfo(); ?&gt; Save it as phpinfo.php and load it in your browser.
i agree, working on my projects or solving problems may improve my Technics, but i'm talking about about if there is anything else i should learn about php, something like frameworks or something advanced ! 
http://www.php.net/manual/en/book.image.php http://www.php.net/imagick Or simply use [border-radius](https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius). 
Wow. Really, thanks, that was really clear and to the point!
And always http://www.phptherightway.com/
http://www.phptherightway.com/
Nothing teaches you more about wheels than reinventing them 10 different times.
So, what's a strategy pattern? &gt; is the design pattern I use the most when building applications in PHP This is more an example than an explanation.
Depends on what you consider "the basics", especially what you can pick up in 3 months. I'd say in no particular order, you'd want to learn about: * Learn the SPL * Learn RegExes * Learn about parsing and writing XML * Security - protect agains CSS, SQL injection, etc * Testing - Unit / Functional / Integration * Reviewing and Refactoring code (and tools like PMD that will help analyze code * Performance - profiling with xDebug, optimizing server performance, optimizing front end performance
I just wanted to say thanks for being flexible and that you're doing a good job incorporating concerns/issues. Obviously people only comment on the things they see as problems so most feedback sounds negative by default. It's easy to get defensive and take people's comments personally even when they (hopefully) aren't intended that way. I think the sheer volume of participation demonstrates the need for standardization in this area. I didn't realize until this thread that github is actually not an ideal place for aggregating discussion on something like this. My phone was blowing up with email notifications all night and it's difficult to focus on exactly what you want with comments littered all over the commit. This is probably my fault for commenting over at github first :)
Yep there are many ways to go about it and each have their own pros and cons that you'll discover over time, and more importantly on a case-by-case basis. For example here's just one example solution to the problem you described: - Create abstract class "BaseDatabaseHandler" Note in case you don't know, abstract class is a class that (typically) has some of its methods implemented but it also has some "abstract" methods which are not implemented in the abstract class, then another class must extend the abstract class to inherit the already-implemented shared functionality but it will also be required to implement those abstract methods that were not implemented. You cannot create an instance of an abstract class, you can only create instances of the "concrete" classes that extend the abstract one. For example BaseAnimal could have a move() function which is already implemented and makes the animal move, but it will have an abstract makeSound() function which each animal implements to make its own sound. (rough examples, sorry I'm sleepy) abstract class BaseAnimal { public function move($distance){ $this-&gt;location += $distance; } public abstract function makeSound() } class Dog extends BaseAnimal { public function makeSound(){ return "Woof woof!"; } } class Cat extends BaseAnimal { public function makeSound(){ return "Meow!"; } } So back to databases, - Create "DatabaseHandler" which extends BaseDatabaseHandler - Create "CachedDatabaseHandler" which extends "DatabaseHandler" (not BaseDatabaseHandler) - CachedDatabaseHandler "overrides" the "get" function of the DatabaseHandler - Now in the "get" function (whatever the function is to retrieve data from DB), CachedDatabaseHandler checks the cache, if the data is cached, it will fetch and return from cache, if it's not, it will call its parent to get a fresh copy from the database, cache it, and then return it. Here's example code: class DatabaseHandler extends BaseDatabaseHandler { // stuff public function query($query){ // execute query on DB and return results } } class CachedDatabaseHandler extends DatabaseHandler { public function query($query){ if (isCached($query)){ return getFromCache($query); } else { // Get the data from our parent (DatabaseHandler) $result = parent::query($query); saveInCache($query, $result); // cache for next time return $result; } } } As I said there are many different ways you can do it, what I have presented is just one way. Btw if you are not particularly interested in this stuff, there is always ready-made libraries available that you should be using to free yourself from ding this dirty work, but I suspect you want to learn the inner workings which is great. Also please note the examples may not be 100% correct I haven't verified anything and basically have written this in one go off the top of my head but you get the idea.
Is that Taylor Otwell wp theme?
I agree that the easiest thing would be to just remove the `__get` method, as it is outside the scope of the original problem. As for solving the problem while retaining `__get`, I haven't given it much thought, but as you said it would be a good exercise to attempt.
&gt; Learn the SPL &gt; Security - protect agains CSS, SQL injection, etc Definitely &gt; Learn RegExes &gt; Learn about parsing and writing XML Meh. As long as you understand the concept you can just look it up when needed. Assuming you've got the basis down and understand OOP, next. - Learn to use an IDE (NetBeans or PHPStorm) - Then learn some common design patterns. (Singleton, factory etc) - Once you've got those down go and learn Laravel &amp; Composer - Then learn to unit test, (PHPUnit)
You should at least be familiar with SimpleXml, DOM, XMLReader/Writer , their limitations and when to use each.
I liked it, very informative. Though I probably would have split it up into two articles to be honest.
Sounds like you need to ask in #phpbb or their support forums.
I think this list of top 10 referenced &amp; followed libraries is specially good for newbies. For people who are new to the language. It gives them a landscape of the relevant php packages. 
Thanks for the fixes. I did mention that it was both over engineered and an academic exercise. :) Edit: Thought about it. Going to rewrite the article to include system calls and exclude Firmata + NodeJS.
You don't *need* syntax highlighting.
 echo "&lt;img src='$imgLoc' style='border-radius:100%'&gt;"; ?
Sanitizing input really needs to be aware of the context where it will be rendered back out. That is, sanitizing something for HTML display maybe completely different than sanitizing it for XML, JSON, or as part of a url query string. Also, strip_tags isn't anywhere near fool proof, if you are allowing users to submit HTML content, you need to use something like HTML_Purifier to sanitize it. http://htmlpurifier.org/
This question comes up over and over again, and the answer is always the same: sanitize your input according to what it will be used for, NOT in a generic fashion that attempts to cover (poorly) all use cases. If you're looking to escape input for SQL, then use prepared queries with PDO, or if you absolutely have to use the SQL driver (which you really don't), via the correctly configured escaping mechanism provided (mysqli::real_escape_string, etc.) If you're looking to escape input for outputting to HTML and prevent XSS, then use htmlspecialchars(). Stripslashes shouldn't even be necessary on recent versions of PHP, as magic_quotes should be off. Use the tools for the uses cases they are designed for; do not expect a one-size-fits-all function to do anything but blow up spectacularly.
I disagree with this in that sanitzing input should not be aware of the output format - it should only be aware of where the content is being stored. You only escape for output when you actually output (eg. in the view, or the function that generates the CSV/XML/proprietary format file). If you try to escape for the output format when you receive the input, you'll end up being unable to use existing data for new output formats or creating a mess of double-escaped / unsuitably escaped content that's just as bad or worse than no input sanitization at all.
I'd go with PHP it's a lot easier to learn and gives you a good base towards learning other languages that also use a C based syntax, with C# you are using the..NET framework and will be restricted to doing things the Microsoft way. Ultimately it depends on what you want to do with your degree, keep in mind that a lot of popular CMS's such as Drupal and WordPress are written in PHP. 
As others have already pointed out, trying to create a "one size fits all" escaping method is doomed to failure in so many ways. For example, you run htmlentities, then strip_tags. If you string contains "&lt;a&gt;", htmlentities will change it to "&amp;lt;a&amp;gt;", then strip_tags has nothing useful to work with. stripcslashes is pretty much pointless in this context. All I need to do is add another slash. "\r" becomes "r", but "\\r" becomes "\r". magic_quotes_gpc and magic_quotes_runtime were removed in 5.4. Frankly, if you're still using a version of PHP that even has magic_quotes_gpc you should probably upgrade.
Start here: https://www.youtube.com/watch?v=QRmmISj6Rrw And get [XAMPP](http://www.apachefriends.org/en/xampp.html).
check out xampp http://www.apachefriends.org/en/xampp.html It'll set up and start a PHP server for you!
Koding looks pretty good; can I store all my files on that website and run it from there?
Yup, both sites are somewhat new, a little bit buggy, and experimental though so I'd make a backup somewhere else every now and then just in case. But they seem to work well for the most part.
Wow, thank you! That seems like a really good option! 
We (the FIG) are not able to define standard libraries for PHP, either in the core or as a defacto standard for people to use. It definitely shouldn't be our job either. Defining a standard for this based on common usage out there is a great way to get the ball rolling on that, and maybe it could be implemented as Spl in the future, who knows. But again, thats not for us to decide. :)
One thing that might be an issue if you use Koding and your script doesn't run and just gives you a blank white page or a 403 then right click on the script and check the file permissions on the file and also the folder the file is in. Set the file permissions to read for all for three, write for the owner only. Or chmod 644. and set the folder permissions to read/write/execute for owner, group, and everyone across the board or chmod 777 if you will. Otherwise I had issues.
No, I tried it, it really isn't evaluated (no notice generated). I'm very surprised about this.
Sorry, I wasn't clear when I wrote my reply. You're right you filter on input, escape on output. But depending on how the data coming in is going to be used, I wouldn't assume that should automatically strip tags or use htmlentities to sanitize everything. And having to use stripcslashes smells like magic quotes or something is enabled. Before storing it, you should be using your persistance layer's functionality for safely storing input. In 90% of the cases, this means using PDO's prepared statemens or PDO::quote() to handle input. You might be allowing some limited subset of HTML, or this may be going into a PDF, so you're better off escaping when you actually retrieve the string and output it.
I was looking for information on PHP namespaces as I like to acquire a good aesthetic knowledge before acquiring a working knowledge. During a Google session on the topic this informative article popped up. I personally think it's a good starting ground for namespace newbs like myself (although I think it's weird I've done a couple of Symfony sites and never thought about namespace structure until now). Even if you're seasoned I think you'll find it an informative and if somewhat entertaining read (note the "use" statement for Jon!).
Now that you explained it to me, it makes sense. Now I feel silly thinking that there should be one solution for all scenarios. I will now study different use-cases and try to learn the best practices. Thanks to you and others for explaining this to me.
xampp has a portable version . you could copy that to a pen drive and use that on your college computer and home computer. For learning I always suggest a complete resource like a book or video course instead of random tutorials on the internet. 
I understand it is not something the FIG can decide but considering the FIG represents a large segment of the PHP ecosystem I'd imagine that if a more encompassing standard library were to be implemented it would be a good place to start. If you look at the current implementations of HTTP Response, for example: https://github.com/guzzle/guzzle/blob/master/src/Guzzle/Http/Message/Response.php https://github.com/symfony/symfony/blob/master/src/Symfony/Component/HttpFoundation/Response.php https://github.com/zendframework/zf2/blob/master/library/Zend/Http/Response.php They all look awfully similar and essentially are just reinventing the wheel. Each of them are based off the exact same standard and you can't really get much deviation in functionality. It seems like a great candidate for something that should be part of a language's standard library, especially one that is primarily targeted at web development. I'm not saying this standard does not solve any problems, because it does. Rather I'm suggesting that is sort of a stop-gap solution and why not take it all the way?
At this point most of these packages are installable via composer into any project you would like to use them with regardless of what framework/platform you are using. So yes you can use Symfony components whether or not you use the full stack framework. Same with Aura and Zend.
Coding style guides exist for a reason. Too many people feel that the style guidelines are a matter of habit. They are not. They are a matter of clean implementation of the control structures of a particular language. They can certainly evolve, but each language has style guidelines that fit that language, and there is a reason for that.
In particular, any input that is supposed to be a number, you should validate that it is a number. If it's supposed to be a 5-digit number, you should ensure that it is a 5 digit number. \A[0-9]{5}\z Reject any request outright where the input is not valid, do not attempt to clean input. Your goal should be the maximum possible strictness on each parameter. Then as people say, you need to perform proper escaping for context. htmlspecialchars is not enough to prevent cross-site scripting, check the OWASP XSS Prevention Cheat Sheet. There are some places user input just can't ever go, and seven different contexts in an HTML page that have different escaping rules. As others say, only use parameterized prepared statements, never build your own SQL queries from scratch. In general, if you are using user input to build something in another programming language (SQL statement, HTML, LDAP search string, XPath) using a template or concatenation mechanism, you are going to be screwed. Any ID parameter that corresponds to a database record, you should verify that the user is allowed to do the specified action to that record.
This is very complementary to /u/pb8856 message. Also it can continue a bit further as the cache could be stored in plain-files / db / memory / whatever else. But OP now has all the pieces to figure how that works :)
Right. Making this standard turns those 3 into one. Once that standard exists it would be easier to potentially maybe turn it into something in the core of PHP perhaps. _If anybody links me to that fucking standards XKCD... so help me._
I knew of php namespaces but this was a nice way to really get in depth. Thanks for this! It was really fun to read
I want to learn more about how to make that choises good. Will it help me if i use something in which those choises are already made?
The great thing about silex is the freedom to make your own choices based on your needs with minimal restrictions and convention. Programming is an iterative process and trying things that don't work and adapting to the feedback you gain from making mistakes is the best way to find out what works for you. You should just have fun coding and do exactly what you need to make your application work without thinking to much about the architecture. You can always change and move stuff around as the project grows and you gain new insights. With that said you may want to check out [Silex Skeleton](https://github.com/silexphp/Silex-Skeleton) and [Silex Kitchen Sink Edition](https://github.com/lyrixx/Silex-Kitchen-Edition).
This is exactly the kind of thing my upcoming book, "Modernizing Legacy Applications in PHP", is designed to address. You can read about it and, if it strikes you as useful, sign up for notifications at &lt;http://mlaphp.com&gt;. In the mean time, you may wish to watch my talk about modernizing legacy apps. It might be useful in your situation. [It Was Like That When I Got Here](http://paul-m-jones.com/archives/2667) Hope that helps.
I've never seen Game of Thrones so it's pretty confusing.
I signed up for the list. Thanks for your input, and I look forward to it!
+1 again. Personally, I would love to see an standalone 'evented' stream PSR just as much as an HTTP one.
Been (actually still am) doing the same thing to our customer web interface. First things I'd recommend is going for a recent (5.3+) PHP version and autoloading using composer. After that the advice from /u/pmjones about making atomic changes but to the whole code base is very good. I'd also look at libraries. I started out by moving out the dependencies we already had to composer und updating them to the newest version. After that I'd think about new libraries. I'm a big fan of the Symfony2 components and I introduced quite a few of them. It has definitively been for the better of the code base, but expect to do more work than when you start out with the full stack since you'll have to do some of the assembly yourself. 
Oh, didn't catch the reference. Thank you!
what about $result[$key] vs $value? is $value inside that lambda function a reference or a copy which will be overwritten there, but not in the array?
There are some problems with your test script. `$test` is never an array of more than 0 elements. You would have to assign `$test` like so: `$test = array_fill(0, 10000, 'testdata');`. I'm guessing by your numbers that you did on your system, but haven't updated the source yet. Also put `$before = microtime(true);` _after_ you create the test array and just before the `foreach` loop. Otherwise you inadvertently add time to your first test. Even still, a test of 10000 on PHP5.4 yields usually less than one microsecond elapsed time for both tests for me, which more or less can just mean 0. Jump that up to 100000 elements and it becomes more obvious that `array_walk` ends up being either exactly equal or slower for me. Though tests like this will always vary by PHP version and system setup and won't always be precise. Altered test script that copies array elements to a new array: $testBase = array_fill(0, 100000, 'testdata'); echo "Test array count: " . count($testBase) . PHP_EOL; for($x = 0; $x &lt; 10; $x++ ) { echo "Test #$x" . PHP_EOL; /* foreach test */ $testCopy = array(); $before = microtime(true); foreach ($testBase as $key =&gt; $value) { $testCopy[$key] = $value; } $after = microtime(true); $dif = $after - $before; echo "foreach test ($before, $after): $dif" . PHP_EOL; /* array_walk test */ $testCopy = array(); $before2 = microtime(true); array_walk($testBase, function($value, $key) { $testCopy[$key] = $value; }); $after2 = microtime(true); $dif2 = $after2 - $before2; echo "array_walk test ($before2, $after2): $dif2" . PHP_EOL; } 
One of the reasons I wanted to use more "free" (for choices) framework like Silex.. to try different approaches, make some mistakes and learn how to do the things better. But i feel lost, i can't even start. I've read about some patterns but there are too many of them...
Thanks for replying! I just ran that code and I got this: Test array count: 100000 Test #0 foreach test (1389322399.59, 1389322399.69): 0.0992619991302 array_walk test (1389322399.7, 1389322400.57): 0.871760129929 Test #1 foreach test (1389322400.57, 1389322400.66): 0.090343952179 array_walk test (1389322400.67, 1389322401.6): 0.923146009445 Test #2 foreach test (1389322401.6, 1389322401.69): 0.0888679027557 array_walk test (1389322401.7, 1389322402.55): 0.855004787445 Test #3 foreach test (1389322402.55, 1389322402.64): 0.0915410518646 array_walk test (1389322402.66, 1389322403.68): 1.01812696457 Test #4 foreach test (1389322403.68, 1389322403.77): 0.0895729064941 array_walk test (1389322403.78, 1389322404.67): 0.891829013824 Test #5 foreach test (1389322404.67, 1389322404.76): 0.088623046875 array_walk test (1389322404.77, 1389322405.62): 0.846575975418 Test #6 foreach test (1389322405.62, 1389322405.71): 0.0910201072693 array_walk test (1389322405.72, 1389322406.59): 0.869386911392 Test #7 foreach test (1389322406.59, 1389322406.68): 0.0919940471649 array_walk test (1389322406.69, 1389322407.54): 0.848879814148 Test #8 foreach test (1389322407.54, 1389322407.63): 0.0889258384705 array_walk test (1389322407.65, 1389322408.49): 0.84405207634 Test #9 foreach test (1389322408.49, 1389322408.58): 0.0940108299255 array_walk test (1389322408.6, 1389322409.44): 0.839191913605 So does this mean that ``foreach()`` is faster after all?
Thank you. I had considered splitting this into two parts. But was not sure that each part would make sense as an independent article. 
me neither. But I don't think it matters. May be you will enjoy it more if you are familiar with the series. Which was the confusing part for you?
You may also need to include how you make your responses. Ie , do you use proper http response headers for indicating different response statuses?
Not sure that I understand what you mean?
Some info is incorrect. The only thing java import statement has in common with php is the name. In Java import * does not need to read all * files and parse and compile them. It merely indicates where to look for a class if it happens to be mentioned in the code. Has no effect on what gets compiled into the code. It will only take whatever user is actually using. Php is not a compiled language and if you put * it would actually have to read each file and compile it for each http request even if nothing from those files gets used. Which is extremely inefficient and thats why avoided.
Makes sense, thanks for the clarification. Python does something similar to the PHP "use" with their import, if I remember correctly. 
&gt;will list form for adding user why would you have your rest server build forms? It shouldn't be constructing UI elements - just do that on the client end.
How do you indicate success or failure? say for example ,PATCH or PUT to http://domain.com/users/123 updates user information of user with ID of 123 from form at http://domain.com/users/123/edit How will you indicate that the operation was a success or failure to the caller?
there is a nice table explaining what things should do here: http://en.wikipedia.org/wiki/REST#Vocabulary_re-use_vs._its_arbitrary_extension:_HTTP_and_SOAP also worth pointing out collections can be nested.. i.e /users/1/posts would be "a collection of posts belonging to the user in the users collection identified by 1" and the identifier needn't be an id. In many cases it is useful to use some other identifier (a name, a slug, a key etc). 
The voting instructions clearly state that those in favor of the proposal, but not of it being implemented in 5.6, should vote "No." So, that would be my guess.
Yeah. By the looks of it about 10x faster than `array_walk` in your case. In my case, it was only maybe less than 2x faster. I'm not sure why `foreach` is faster than `array_walk`, what's under the hood of `array_walk`, or if passing an anonymous function would cause even additional slowdown vs foreach. Someone familiar with PHP sourcecode would know better than I.
If I am understanding what you are saying there are a couple of problems with how you're going about things. First, md5 is a hashing algorithm, not an encryption method [and a flawed one at that](http://blog.didierstevens.com/2009/01/17/playing-with-authenticode-and-md5-collisions/). It still has a few uses, but you're not likely to need it. Hashing algorithms are one way. They are used to verify a value is the same as an existing one without storing the actual value. This is useful for checking passwords without storing the passwords themselves. Handling sensitive data such as payment information is a tricky challenge, and one that you should definitely defer to 3rd party services if you can. This is a short list of things you'll need if you are accepting credit cards on your site: * An SSL certificate from a company like Network Solutions or Verisign to secure the connection between your webserver and the user. * Most payment processors will have you generate yet another certificate for the secure communication between your server and theirs. * Most payment processors will require several bits of information to verify the payment and reduce fraud. These include things like the CVV2, billing address, IP address, and so on. You should also: * Never store credit card information on your servers. Pass the data on to the processor and do not retain it. * Be [PCI Compliant](https://www.pcisecuritystandards.org/security_standards/index.php). These are requirements recently set forth by credit card companies. If you fail to follow these guidelines your company/organization could be held accountable for any fraud/data theft. * Be very aware of web development security topics such as CSRF, XSS, SQL injection, etc. As you can probably see, this is a tremendous amount of work that is best left to those who specialize in it. Since you didn't specify exactly what type of payments you are accepting the requirements may be a bit different for you. The good news is there are a lot of companies out there who can do this on their servers without any liability on your part. Hope this helps
Okay now I am understanding a bit better. You can generate an md5 hash of the value using javascript before the form is sent but you can't always be sure the user has scripting enabled. To perform an md5 calculation before the form is submitted you can do something like this: &lt;form name="paymentForm" method="post" action="" onsubmit="return replaceMd5();"&gt; &lt;input type="hidden" name="md5" value="" /&gt; &lt;input type="text" name="amount" /&gt; &lt;input type="submit" value="Submit Form" /&gt; &lt;/form&gt; &lt;script type="text/javascript"&gt; function replaceMd5() { document.paymentForm.md5.value = md5(document.paymentForm.amount.value); return true; } &lt;/script&gt; You can also include some validation in the script like checking that it is a valid numeric value and show the user a warning message if not. If you return false in replaceMd5() the form will not be submitted. Note that the md5() function is a separate function. Here's an md5 hash implementation written in javascript: [http://www.myersdaily.org/joseph/javascript/md5.js](http://www.myersdaily.org/joseph/javascript/md5.js)
Ok just do 4 folders: controllers, models, views and one index.php and there you go! You will discover on your own if you need to add or change, remember you are doing it because of fun and learning not because you know everything from the beginning. Don't bother with patterns just put things where it belongs. 
So weird, I tried this but it didn't work so I posted it here. Maybe some stupid syntax error. Thanks for the help though. 
I've had the same dilemma a few months back, I've described my choices (and linked to the [code](http://github.com/bojanz/musicbox)) in a [blog post](http://bojanz.wordpress.com/2013/11/11/learning-php-development-with-silex). You might find it useful.
A very good point that hadn't crossed my mind! I guess the only way you could even shorted something like this is to declare (or directory GLOB) all namespaces and classes as part of an associative array and use a class method something along the lines of $this-&gt;loadnamespace($namespacename); which then calls include() /* or */ require() on the required namespace / class. How does that sound? (I haven't searched for attempts like this yet)
When you say "client end", do you mean use a javascript framework such as Ember to generate views etc?
I think it's a very interesting concept, but I'm not sure removing the null checking bloat would be a worthwhile trade for losing the ability to easily pinpoint null value sources and tightly coupling your project to these Some/None classes.
Considering the first example in which the author compares this: $user = $repo-&gt;find($id); if (!$user) { return null; } $address = $user-&gt;getAddress(); if (!$address) { return null; } return $address-&gt;renderText(); with this: return $repo-&gt;find($id) -&gt;map(method('getAddress')) -&gt;map(method('renderText')); I'd ***much*** rather use the first one. Few reasons: - You can see the ***purpose of the code*** just by looking at it, whereas for the second one you have to check the definitions of `map` and `method` to fully understand it. - First one can be used with auto-complete and documentation generators as you call the methods directly, whereas with the second one you pass a ***string argument*** for invocation! This is a big **no** for me.
Why not: return $repo-&gt;find($id) -&gt;getAddress() -&gt;renderText(); instead of return $repo-&gt;find($id) -&gt;map(method('getAddress')) -&gt;map(method('renderText')); (using `__call()`) Looks much clearer to me, and at least you get autocompletion and refactoring support.
It's also more typing. Not to mention the overhead of his method if that was used throughout your code. 
Good article
&gt; GET to http://domain.com/users/add will list form for adding user (this form will post to http://domain.com/users/ ) This isn't really REST. Making forms isn't what your API is for. It's a common way of handling the issue of how to run every request through an API, but it's not really very RESTful. 
Fatal errors are just that. They shouldn't be caught, they should end the application because something serious has gone wrong. If you're writing code that causes fatal errors, you're coding it wrong. 
People don't say not to call them multidimensional arrays for nothing. They are arrays of arrays (that don't necessarily have fixed length on their "dimensions" and can be used in many ways.) You can use array for building tree structure, e.g. HTML ($html['body']['div'][1]['p']['strong']) You can use them for grouping dates, e.g. $dates[2013][12][14]
Here's a practical example. Say you're displaying a list of people in your company, organized by department. You could populate an array for each department, or your code could return one data structure that looks like this: $employee_data = array( 'accounting' =&gt; array('Bill Jones', 'Peter Mann'), 'sales' =&gt; array('Fred Estair', 'David Lingrove'), 'management' =&gt; array('Lee Iococa', 'Tim Cook') ); In order to display this data, in PHP, you could write foreach ($employee_data as $department) { echo "&lt;h2&gt;$department&lt;/h2&gt;&lt;ul&gt;"; foreach ($department as $employee) { echo "&lt;li&gt;$employee&lt;/li&gt;"; } echo "&lt;/ul&gt;"; } Now you can add an arbitrary amount of departments or employees without having to change any of the code in your view (like the code above). To take the example even further, imagine each employee has more information about them than just a name. Say we add a phone number. Now you have $employee_data = array( 'accounting' =&gt; array( array( 'name' =&gt; 'Bill Jones', 'cellphone' =&gt; '512-555-1212'), // .... ) ); Which is an array of arrays of arrays.
Personally, I tend to use interfaces as a type of 'contract'. So for example, if I want to provide a set of basic requirements (methods) that all implementing classes must fulfil, but how the class implements those requirements is up to itself. On the other hand, if I would possibly like those implementing classes to inherit some behaviour, then I would use an abstract class. Cheers,
it's not possible, because expression engine's code is too messy. /thread
WOW ok, I think I've been misunderstood. I am talking about using [`__call()`](http://www.php.net/manual/en/language.oop5.overloading.php#object.call) to silently forward the method call to the wrapped object (if not null). So, I'm questioning the library's implementation, not just saying "let's use plain PHP" because I didn't get what the library was for.
In an interface you can ONLY define methods - you cannot implement them. You need a class to implement an interface's methods. Example interface: interface BillerInterface { public function billUser(User $user); } Notice how the "billUser" method does not contain any code but has a semi-colon at the end of the method declaration. This is because interfaces cannot define implementations for its methods. However, a class can: class StripeBiller implements BillerInterface { public function billUser(User $user) { $user-&gt;money -= 5; } } Notice how a class was needed to implement the BillerInterface's methods. At the end of the day, an interface is a contract that lists some required methods that a class must have if the class implements the interface. So in our example, the "StripeBiller" had to have the "billUser" method because it implemented "BillerInterface". Does that make sense?
Example: class NullObject { private $wrapped; public function __construct($wrapped = null) { $this-&gt;wrapped = $wrapped; } public function __call($name, $arguments) { if (! $this-&gt;wrapped) { return new NullObject(); } return call_user_func_array(array($this-&gt;wrapped, $name), $arguments); } } Now I can do: $foo = new NullObject(null); $foo-&gt;bar()-&gt;baz()-&gt;bam(); 
Can your IDE infer what __call is going to do in order to autocomplete the method name?
Brilliant, seeing this makes it easier to visualise and understand. Thank you.
Well if you type-hint your `$repo-&gt;find($id)` method with `@return User` autocompletion should work fine (because the IDE will think it's a User entity, not an `Option` object).
Sudoku is not tic-tac-toe right?
Interfaces have no implementation or behavior; they don't "do things," so obviously they can't be used in place of classes. They are meant to be used in combination with classes. The relationship between an interface and a class that implements that interface has nothing to do with "is a" (you may be thinking about inheritance vs. composition here - "is a" vs. "has a"). Let's look at an example: interface WriterInterface { public function write($data); // this doesn't "do stuff" yet } This is a complete interface. Notice how we don't actually do anything in the `write()` method? That's because interfaces only define method *signatures*, which are the "interface" to a class. It's a way of saying "any class that implements this interface will have the following methods." Classes must then *implement* the interface and provide the actual behavior in order to "do stuff": class MyWriter implements WriterInterface { public function write($data) { echo $data; // now we've "done stuff" } } **Why is this useful?** I'll spare you the computer science theory and leave that as a topic for you to research, but I'll give you a common example. Let's say that you want other developers to be able to create their own writers in the future, and you want those to be able to be used within your project. How on earth can your code possibly know what future 3rd party developers will create and how to use it? Well, that's where interfaces come in. We've defined our `WriterInterface`, and we will use that in our project anywhere we would have wanted to use `MyWriter`: class MyLogger { private $writer; public function __construct(WriterInterface $writer) { $this-&gt;writer = $writer; } public function log($message) { $this-&gt;writer-&gt;write($message); } } We now have a `MyLogger` class in our project that takes a writer object that complies with the `WriterInterface`, and uses that to log messages. We can now pass in instances of our `MyWriter` class, and it will simply echo logged messages. But... future developers can now also make *their own* writers: class ThirdPartyWriter implements WriterInterface { public function write($data) { file_put_contents('/path/to/some/file', $data); } } This 3rd party class implements the same interface, but provides different behavior (writes to a file instead of echoing to stdout): $myWriter = new MyWriter(); $myLogger = new MyLogger($myWriter); $myLogger-&gt;log('Hello World'); // echos "Hello World" to stdout $thirdPartyWriter = new ThirdPartyWriter(); $myLogger = new MyLogger($thirdPartyWriter); $myLogger-&gt;log('Hello World'); // writes "Hello World" to /path/to/some/file
Oh I see, not something I'd personal do though. 
An interface is good when you want to interact with multiple implementations of the same thing in the same way. In the example of the billing class, if you code to an interface and later you decide that Stripe sucks and you don't want anything to do with it, all you need to do is write another class which implements that interface and you wont have to change any of your application code. It's about flexability and making sure that each component of your application isn't too reliant on any other component. So when your coding to an interface you might say "I want to get all users". So your first step is to do this: class UsersController extends BaseController { public function __construct(DbUserRepositoryInterface $users) { $this-&gt;users = $users; } public function index() { return View::make('users.index', $this-&gt;users-&gt;getAll()); } } OK, that's great. With this your controller only cares about two things. First that you have an object $this-&gt;users, this is passed in via the constructor, Laravel's IoC container can do that for you. Second is that that $this-&gt;users has a getAll() method. How can we ensure that it does? Well, we injected a class that implements DbUserRepositoryInterface and we know that all classes that implement that class have that method, otherwise they would fail. So then all you'd need to do is: namespace Acme\Repositories; interface DbUserRepositoryInterface { /** * Make sure you document your interfaces properly. */ public function getAll(); } And: namespace Acme\Repositories; use User; class DbUsersRepository implements DbUserRepositoryInterface { /** * @inheritdoc * * Additional information. */ public function getAll() { return [ 'users' = User::all() ] } } And: App::bind('Acme\Repositories\DbUserRepositoryInterface', 'Acme\Repositories\DbUsersRepository'); With this approach if you want to chacge your database engine then it's as simple as creating another class and switching out the binding. Disclaimers: 1. I haven't tested this code at all, it's just somthing I quickly typed out. Proabably broken. 2. This is overkill a lot of the time. But it's a good thing to have knowledge of. **Edit:** Seems a bunch of people beat me to the punch. There ya go OP, that should be enough for anyone. ;)
other languages, like Python, throw exceptions upon fatal errors. It allows graceful degradation. 
sudoku is numbers 1-9 in a grid 9x9. Tic-Tac-Toe is also called naughts and crosses and played in a 3x3 grid 
&gt; Wrapping up this week's "one release a day" series is the 2.0.0-beta1 release of [Aura.Sql_Schema](https://github.com/auraphp/Aura.Sql_Schema/tree/develop-2). You can [download it](https://github.com/auraphp/Aura.Sql_Schema/releases) directly or install via [Composer and Packagist](https://packagist.org/packages/aura/sql-schema). &gt; &gt; The `Aura.Sql_Schema` package contains PDO-based tools to read table and column information from a database. If you already use PDO, or if your database abstraction layer of choice uses PDO under the hood, you can feed that PDO object to the _Schema_ object and start reading your table and column information. (Because it is typehinted to PDO, this means the _Schema_ can use an [Aura.Sql v2](https://github.com/auraphp/Aura.Sql/tree/develop-2) _ExtendedPdo_ object as well.) The package supports MySQL, PostgreSQL, SQLite, and Microsoft SQL Server.
Sure. But couldn't I also have... class Biller { public function __construct (BillingProvider $provider) { $this-&gt;provider = $provider; } public function billUser (User $user) { $this-&gt;provider-&gt;billUser($user, 25); } } class StripeBiller extends Biller { public function stripeStuff() { ... } } class PaypalBiller extends Biller { public function paypalStuff() { ... } } $stripeBiller = new StripeBiller(new StripeProvider); $paypalBiller = new PaypalBiller(new PaypalProvider); $stripeBiller-&gt;billUser($user); $stripeBiller-&gt;stripeStuff(); $paypalBiller-&gt;billUser($user); .. etc ... Doesn't that kind of accomplish the same thing as interfaces? You still have the "contract" in the parent class that changes implementation in each child class, depending on how they are instantiated. And to me.. a StripeBiller "is a" Biller. It is a type of Biller, just like a Car is a type of Vehicle. Maybe that's the thing that is confusing me. Does this make sense ... ? class Car implements VehicleInterface {} That seems weird to me.
Awesome talk. I wlll also be signing up.
I responded to one of the first posts, and I'm afraid it will get lost. [Could you take a look at it and tell me what you think?](http://www.reddit.com/r/PHP/comments/1uvuqd/help_me_out_with_classes_vs_interfaces/cem6ibg)
yes, and you can even define a method as abstract forcing your StripeBiller and PaypalBiller classes to implement that method, same as interface. Interfaces are useful because sometimes you want some classes to implement functionality that others dont but still extend the same base class A great example of when these can be useful is in models. You have some type of ORM, and all your models extend that ORM class. Now some of your models have an extra bit of common functionality, for example implementing a DecoratorInterface.. those models need a getDecorator() function. you can easily check if your model implements this pattern by using if ($object instanceof DecoratorInterface), which also forces your model class to implement any methods defined in DecoratorInterface. You can also implement multiple interfaces by separating them with a comma
I think MySQL can handle this just fine but you'll probably need to use some fairly complex, but not crazy, concepts with it. One concept that would likely help is embedded queries. Use an embedded query to filter the results of the table that's going to have 80k results per user by user id so that MySQL doesn't need to perform queries on all that data. As far as MySQL performing fast on 80k results I think is a non-issues. MySQL is designed to query against large sets of data and return results. That being said it's also important you are indexing things properly. Now for the user experience of having reports generated on a click of a button I think you might want to look into background processing so the user isn't waiting for the browser to reload a page to show a report. Take a look at Gearman for satisfying the background processing. I'd imagine the work flow of this to be "User clicks button to generate report" -&gt; "Server adds a high priority job to generate report" -&gt; "Job runs and dumps results of this report into a temporary table" -&gt; "Show the status of the report on the front end as being ready or done" -&gt; "User clicks on View Report link and is redirected to a view of the report." If you don't want to use Gearman or can't install some other piece of software on your server then use [iron.io](http://www.iron.io/). It's a third party web service you can use to run jobs over http. I've used it in a few personal projects and it worked out well. I don't represent iron.io and I'm sure there's other options. I've only ever used iron.io for this kind of problem though which is why I mentioned it here. Good luck.
Of course... each employee also has an array of systems they're allowed to access... $employee_data = array( 'accounting' =&gt; array( array( 'name' =&gt; 'Bill Jones', 'cellphone' =&gt; '512-555-1212', 'permissions' =&gt; array('Invoice Approval', 'Invoice Lodgement', 'Tax Records', 'Intranet' ) ), // .... ) ); And so on. There is no limit to how many levels you can store data on. Each layer adds what some might call a dimension. But essentially an array is a list. A multidimensional array is just a list of lists. It's not too different from a bulletpoint list that has other another bulletpoint list as one of its members. 1. This is an option 2. Another option 3. 1. Yes 2. No 4. The final option
So there really is a lot of overlap between uses for an interface or an extendable (or I guess abstract is better) class? Some cases might be doable with both, some with only one or the other. But the line between is kind of "foggy", is that fair to say?
yeah totally fair to say, however there really are some situations that can only be done one way or another. going on my earlier example, your ORM class could implement ArrayInterface allowing you to access your model like an array $posts['title'] for example. i'm also pretty sure an abstract class doesn't have to implement every method of a class it claims to implement, forcing you to implement those classes when you extend that abstract class.
Yes and no. You do have a "contract" of sorts by extending the parent class. However, there are some things you should notice: 1. You are now extending a class instead of implementing an interface. This means that you now how to worry about the Liskov substitution principle. In other words, the child class ("StripeBiller" in your example) must be able to do everything the parent class ("Biller" in your example) can do. You don't need to worry about this with interfaces as they do not have implementations - and therefore cannot break the Liskov substitution principle. 2. A class can only extend one other class. With interfaces, you can adhere to multiple contracts by implementing several interfaces. At the end of the day, you're the developer - it's your choice as to what you think is best.
My apologies. Looks like I didn't get your post! Good idea as well!
&gt;Can someone ELI5 no. If I have to explain anything to you like you're 5 you might want to consider a new hobby. A practical use for deep arrays? Creating a structure that mirrors a filesystem.
Silex is great for what it is, but the point of a microframework is to not do much. I haven't actually used it myself, I've used another microframework called Flight to do a fair bit of stuff. Any application has a number of things that it needs to do, and something like Silex takes care of one part of that, generally routing and autoloading. After that you'll want something else to take care of the other parts of the application. For example, you have no data. A common choice is to use an ORM like Redbean. That lets you simplify the process of getting data out of the database. $post = R::load('post', $id); Lot easier than having to write and manage long sql queries. The next thing you're going to have to do is some sort of templating. I think Silex probably has a basic template system built in, I know Flight did. But there are better ones. Twig is the most commonly used in this configuration. Using a setup like this lets you figure out from here... ok, what data am I going to need, what are my routes going to be, and what data needs to be in them. Then you can set about creating it one step at a time. That said, I actually don't favour this approach myself. It seems to me that if you want a microframework, an ORM, and a template engine you're better off with a full Framework, as you get a more seamless experience, better documentation of the interactions, and a lot of extra features. Using something like Symfony or (my preference) Laravel gives you an end-to-end framework that will do anything you need it to. Sure, in the case of Laravel especially, it's quite opinionated. But learning those opinions and the patterns used is a great experience. If you have different opinions you can always apply those opinions to other frameworks. Full frameworks are a great way to get stuff built quickly and effectively.
Cool. Thanks for the help!
Ok. Somehow I'm kind of thinking all of this like some kind of fighting game .. abstract class Weapon {} abstract class SingleHanded extends Weapon {} abstract class TwoHanded extends Weapon {} interface ThrowableInterface { public function throw() {}; } // so you know you can $user-&gt;weapon-&gt;throw(); interface ParryInterface { public function parry() {}; } // so you know you can $user-&gt;weapon-&gt;parry(); interface LongreachInterface { public function keepAtBay() {}; } class Dagger extends SingleHanded implements ThrowableInterface { protected $weight = 1; protected $damage = 2; } class Sabre extends SingleHanded implements ParryInterface { protected $weight = 5; protected $damage = 10; } // and then you could also test for one or two - handedness to see if $shieldAllowed = TRUE; class Staff extends TwoHanded implements ParryInterface, LongreachInterface {} // etc Classes are more what a thing is .. Interfaces are more what a things are expected to be able to do. That is probably not going to be accurate all the time, but it helps me picture it in my head.
that's an excellent example, it looks like you're understanding the power of interfaces!
You are fine using MySQL, it can handle that amount of data easily. Just make sure you are using it properly. Indexes are the biggest thing. edit: try this question with more details on your schema on /r/mysql or /r/sql
&gt; i feel like i need to do a step forward. Regarding this part of your statement, I would look to moving from CodeIgniter to another framework for this project, or for future expansion of your PHP skills. Suffice it to say that CodeIgniter is stuck and is not going to be a useful or competitive framework going forward. I think it would be hard for anyone to make an argument otherwise for the future of CodeIgniter. Fortunately for us, there are excellent options for frameworks these days. Also, look into possibly using the PHP framework as an API backend for display/consumption by a javascript powered front-end. There are plenty of options for that as well. I'm not sure if this is the kind of advice you were looking for, but in regards to your comment about wanting to take a step forward and based on your PHP experience, those are the suggestions I would make.
It is a little foggy I suppose (everything is situational in development) but I would say, as a rule of thumb, interfaces are more about ensuring reliable integration with other parts of the system. Think of them as definitions, they have no value themselves but when those definitions are widley understood it makes communication easier. Whereas abstracts are more about standardisation within a class heirachy. You could use them to ensure particular requirements are fulfilled, but it's more like: 1. You make a base class with a method of `destroyAllHumans();` 2. There are a few different classes that are required to identify humans but once you have them the method of destruction is essentially identical. 3. So in your base class define an abstract `aquireTargets();` method and now you can ensure that any of your child classes will be able to identify humans and you'll be able to rely on your base class for handling thier actual destruction. Now let's say a group of classes need to implement thier own method of destruction, they can still do that but you would have to override every instance in those classes or you would have to add another base class which overrides the base class. Adding annother level to the heiracy and there might be stuff in the original base class that you don't want in this implementation... Or you could just make another base class which does things entirely differently but still interacts with the wider system without much change. That is where you would use an interface. Have a read of [this](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design\)) and start using them, eventually it will click. **Edit:** Looks like you're getting the hang of it. Read that link if you haven't already though, it's a really important principle.
*A bit from linked Wikipedia article about* [***SOLID (object-oriented design)***](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design\)) : --- &gt;In computer programming, **SOLID** (**Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion**) is a mnemonic acronym introduced by Michael Feathers for the "first five principles" named by Robert C. Martin in the early 2000s that stands for five basic principles of object-oriented programming and design. The principles when applied together intend to make it more likely that a programmer will create a system that is easy to maintain and extend over time. The principles of SOLID are guidelines that can be applied while working on software to remove code smells by causing the programmer to refactor the software's source code until it is both legible and extensible. It is part of an overall strategy of agile and adaptive programming. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/rich97 can reply with 'delete' if required. Also deletes if comment's score is -1 or less.)* ^| [^(commands)](http://www.reddit.com/r/autowikibot/wiki/commandlist) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=acini&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/PHP/comments/1uvuqd/help_me_out_with_classes_vs_interfaces/cem8qye)
You may want to check the performance considerations for the PhpOption library: https://github.com/schmittjoh/php-option#performance-considerations
How about some hardware specs that this will be running on?
I'd like to see this added. I cant say I have a compelling need for it, but can see how it might be useful in future. I'd be interested to see how E_PARSE can invoke an exception handler though. It feels like it would be very difficult to implement reliably 
Your first argument is basically "I don't want to learn about `map`". Which is fine, I suppose. But it's clearly quite subjective. The second argument I do agree with. It is unfortunate that PHP's callable type forces you to pass around strings and arrays. That said, personally I'd much rather write this: -&gt;map(method('getAddress')) Than this: -&gt;map(function (User $user) { return $user-&gt;getAddress(); }) But the latter works too, and you even get IDE auto-completion with it.
So..what do you think about the article?
Warms my heart.
Chatty, hard to follow, first-draft, blog-tier shit material.
This would definitely be a possible variation. And it works quite well for method calls. The original is a lot more flexible though, because it works for *any* callable.
Hmm, doesn't look very artisan to me...
How useful and constructive. 
captain_obvious_here and erik240 give the best practical examples, and probably the most common typical use scenarios. Since you're learning how to program, you should try to start thinking like a programmer and understand that 'practical' uses also includes ways to be smarter about how you code. Here's a more advanced approach, which shows how you can use functions inside multidimensional arrays, so different functions may be referenced inside the same iterator if they have a similar purpose; maybe not the absolute smartest way to use these for a program small enough to paste in a comment (and I'd generally use stdClass for this, not array, but the principle's the same), but in large applications you can end up with similar requirements: $prices = [ 'ontario' =&gt; [ 'totalcost' =&gt; function($a) { return $a * 1.15 + 5; }, 'items' =&gt; [ 'shirt' =&gt; [ 'colour' =&gt; 'red', 'price' =&gt; 30 ], 'pants' =&gt; [ 'colour' =&gt; 'black', 'price' =&gt; 50 ] ] ], 'quebec' =&gt; [ 'totalcost' =&gt; function($a) { return $a * 1.09 + 8; }, 'items' =&gt; [ 'hat' =&gt; [ 'colour' =&gt; 'blue', 'price' =&gt; 10 ], 'gloves' =&gt; [ 'colour' =&gt; 'black', 'price' =&gt; 25 ] ] ] ]; foreach($prices as $name =&gt; $region) { echo "$name\n"; foreach($region['items'] as $item) { echo "Colour: {$item['colour']}, Price: {$region['totalcost']($item['price'])}\n"; } } Which gives: ontario Colour: red, Price: 39.5 Colour: black, Price: 62.5 quebec Colour: blue, Price: 18.9 Colour: black, Price: 35.25 edit : after writing, that above example's a bit odd, so here's something more in-line with what you'd see in practice (though too complex for me to bother actually making run as an example): $region = [ 'ontario' =&gt; [ 'shipping' =&gt; function($weight, $lat, $lng) { return $weight * some_distance_function($lat,$lng) * 4 + 5; }, 'tax' =&gt; function($price) { return $price * 1.13; } ] 'quebec' =&gt; [ 'shipping' =&gt; function($weight, $lat, $lng) { $current_shipping = function_to_get_shipping_from_quebecs_old_iseries_server(); return $weight * some_distance_function($lat,$lng) * 3 + $current_shipping; }, 'tax' =&gt; function($price) { return $price * 1.15; } ] ]; The idea here is that it's not only much more organized, but can be iterated through far more easily than having a bunch of different functions (e.g. calculate_ontario_shipping()), or a big switch inside some huge function (e.g. calculate_shipping($country,$weight,$lat,$lng)), which can work when you're switching something very simple, but aren't so clean if each case has extremely distinct logic. I should also mention that for more complex cases where you'd use these functions in many different places, you'd almost certainly move those functions out in to classes. This makes sense mostly when you need to fire off a bunch of quick functions.
Thank you.
&gt; Here's a practical example. Say you're displaying a list of people in your company, organized by department. You could populate an array for each department, or your code could return one data structure that looks like this: The employ probable has a could different phones that could be grouped as 'phones' =&gt; ['cell' =&gt; 'some number', 'office' =&gt; 'another number']
To be entirely honest, I'm a bit annoyed by the amount of Aura PHP promotion I'm seeing in /r/PHP. It seems like there is a submission for every single release of every single of it's sub-packages...
REST is generally just an API, there is no UI. The only data that is returned is raw data in either XML, JSON, or something else. REST is used to preform remote operations. Think of a REST API as a connection to your database that your frontend/website can use. For example, you would use an AJAX Post to domain.com/users/ to create a user.
It requires a TON of intimate knowledge of C, C++, and PHP. You can't write an "interpreter" for a language that you don't know inside and out...
They're not sub-packages; they are full packages in their own right. :-)
Rule of thumb: never use a project that uses Bootstrap 2.x.x for its documentation.
Ahh, so maybe I should back off my plans to post commit messages &amp; changelists directly here to /r/PHP?
What exactly is the goal of this project? I see a bunch of buzz words ("high-quality, well-tested, decoupled") which many other projects already accomplish. So what is the goal?
I finished a site using 2.3 just before 3 came out. FMR?
Thank you /u/nikic :p
I just recently noticed this switch and I've migrated from Codeigniter to Laravel. Unless you follow PHP general news, its easy to sit in your own little framework box and just keep trucking.
I know this theme :) I was just being mean :P
Thanks for your response. I can see how it can seem cleaner referencing like \Bob\Blog\Post but theres some part of me that says that this is wrong. It seems that this in a way makes \Bob\Blog\Post separate to \Bob\Blog in a way that \Bob\Blog_Post wouldn't be. It's hard to explain so it's probably just another one of those OOP head-twists I just need to get my head around.
From what I've understood you're asking about class Blog and class Blog_Post right? If I got it right than your question is why can't both classes be inside the same namespace like '\Bob', having then the classes to be file: *Blog.php* &lt;?php namespace Bob; class Blog {} file: *Blog_Post.php* &lt;?php namespace Bob; class Blog_Post {} or you could have the other approach file: *Blog.php* &lt;?php namespace Bob; class Blog {} file: *Blog\Post.php* &lt;?php namespace Bob\Blog; class Blog_Post {} Actually they're both right, however with namespacing I tend go for second approach since you are compelled to have a more organized structure where you have ...\&lt;topic_class&gt;\&lt;topic_specific_subclasses&gt; But this is my pov
A lot of companies that used to use Oracle for data warehousing are using Postgres these days. It scales about as well, does some things better, and does other things worse. But the price is definitely right. Later versions (9.1 and up) handle big data and replication better. There's some caveats you should research, such as in-depth explanations of how each data type actually works, how indexing works, and how locking works before you put "big" data into it. My day job has about 45 Tb of data in Postgres (and growing), another 80 Tb of data in Oracle, and another 300 Tb of data in our legacy sqlite solution that's getting sucked into Postgres. We're not moving the Oracle things into Postgres, but we are doing a lot more of our preliminary number crunching in Postgres and then dumping extracts of that data to Oracle for the reporting logic that the company's based on. Data processing language doesn't really matter (use whatever you're comfortable with) as long as your database is designed such that it's not going to be locked all the time. That way you can scale out horizontally to a number of nodes and use something like a Zookeeper cluster to manage them. It doesn't matter, if this is your scaling method, how much CPU you use or how 'fast' your code is as long as it is gentle to the database server. 
Although they're decoupled by interfaces, if multiple packages start to depend on the same basic ones they will be all coupled to a common set of abstractions. Considering that some of these new packages are very much like parts to build something larger, what can we expect from future packages? 
E_PARSE (and other compiler errors) most likely will stay in their current form. &gt;Some errors are easy to change to exceptions, others are more complicated. Some are impossible, like the memory limit or execution time limit errors. The E_CORE_ERROR type can't be converted to use exceptions because it occurs during startup (at least if used correctly). E_COMPILE_ERROR (and E_PARSE) currently also can't be converted to exceptions, due to concerns regarding global state modifications.
Try to think each namespace as a path on a tree. Using an analogy: "passwd" is not separated from "etc" in /etc/passwd, it's inside!
What's confusing you is probably the idea of why do you need classes and interfaces in the language? Well you probably don't. It's a high level language. Once you get into classes vs interfaces you've learned enough that everything is basically just fancy syntax. Somewhere down there the computer is still just running machine code that doesn't know anything about traits, classes, interfaces, or whatever and still does the exact same thing. You could use just classes and be fine or use just interfaces and be fine. Or don't use OOP at all and just use functions and be fine. You use a high level language because you want those things, not because you need them. However modern day wisdom is that interfaces are more versatile. You should avoid classic inheritance and almost always go the way of an interface and pass your objects around by their interface and not their type. There are exceptions though like when you want to provide default behavior for a class method where it makes sense which you can't do with interfaces. 
Being an asshat was evidently not a waste of your time however, and many other users above you astoundingly understood the meaning of his question and answered it with detailed, not demeaning, answers that are useful.
There is currently a specific fatal error which is meant to be caught (E_RECOVERABLE_ERROR). It's used when the program cannot continue (for whatever reason) but there is something the programmer can do about it. I'd much rather that be an exception rather than have to set an error-handler to pass it to an exception then handle the exception.
Why is that you already know you will query 80k results per user (what does that even mean?), but you have no idea how many users will be?
I'll assume this was a joke, and if so, it was actually kind of funny. :)
In my experience dealing with similarly sized data sets, MySQL has no problem keeping up. The bottlenecks always occur either in my php code that is doing calculations on the data, or in the browser itself trying to display such a large amount of information.
Odd that I ask a 'self deprecating' question to help with my understanding of an issue and get constructive and well reasoned responses. These same responses have helped me get a handle on this concept, which in turn will allow me to improve. Clearly, regardless of how effective this question turned out to be for my own education and learning style I should have refrained from asking it as to not waste your time. Or alternatively if you feel a question is a waste of your time don't expend the time and effort in writing meaningless responses that offer no benefit to no one.
Well nikic just answered this with an awesome blog post: http://nikic.github.io/2014/01/10/The-case-against-the-ifsetor-function.html Short version: &gt; there is way too much by-ref magic involved
Not merely well-tested, but 100% unit test coverage. Not merely decoupled, but completely independent (as in, no dependencies at all in any of the library packages -- unlike some other projects that *say* none of their packages have mandatory dependencies, but actually do). The goal, of course, is to provide good stuff to good developers.
That is how you treat kids then? Several people above gave good answers that actually helped OP on his way to become better at PHP. Some concepts are hard to understand without a real world example, and need to be explained in what might seem like a childish way. 
I think I get it now. Just because \Bob\Blog\Post is in it's own namespace it's still also in the parent namespace so from within the blog class I can call Blog\Post. Cheers for that, now I can embrace the part of me that's been looking forward to getting rid of underscores from all my class names.
Some of them definitely are like parts that can build something larger, but they each serve a purpose on their own without being tied into anything else. For example, do you have a DB abstraction layer that you like, but want to add on a query builder? Install [Aura.Sql_Query](https://github.com/auraphp/Aura.Sql_Query/tree/develop-2) (whether by Composer or by direct download) and feed its output to your DB layer. No need to use the [Aura.Sql](https://github.com/auraphp/Aura.Sql/tree/develop-2) package unless you think it fits your needs. As far as future packages are concerned, it seems likely to me that we'll end up providing a bound collection of some of the SQL libs into a DataMapper implementation, but that's a ways away. Of course, the Project packages already provide bound collections of the DI, router, dispatcher, etc. packages. See e.g. &lt;https://github.com/auraphp/Aura.Web_Project&gt; 
Yeah, but that throws notices if the variable isn't defined. Dare I say it? Prepend the @ like so: $y = @$x ?: -1
You'll see in the autoloading PSRs, the namespaces actually map directly to a path in your file system, so think of it like one. \Bob\Blog would be a directory for you to put all your Blog specific stuff. Depending on project size, putting everything in \Bob may quickly become unorganized. With \Bob\Blog\Post, Post isn't a separate namespace from Blog, it's actually contained within Blog! With \Bob\Blog_Post, Blog_Post is only contained within \Bob, and is not in a separate blog specific namespace. Also, if you're using PHP 5.3+ namespaces, I'd recommend against using underscores in them. I've seen this recently with PSR-4 not explicitly disallowing them, but it's a bit inconsistent to me being PSR-1 enforces class names be StudlyCaps.
Which is exactly what happens in C# if `x` is undefined. error CS0103: The name `x' does not exist in the current context
&gt; However modern day wisdom is that interfaces are more versatile. You should avoid classic inheritance and almost always go the way of an interface and pass your objects around by their interface and not their type. Aha. This is interesting. I guess this is because when you pass and object somewhere, you are really mostly concerned about what it is going to be able to do once it gets there? And if that is really the point, then interfaces are more versatile since you can use more than one? It just seems counterintuitive a bit, since I have only really got my head around OOP in the last 6 months. And all of the literature was classclassclass. A Car is a Vehicle. A Dog is an Animal. etc. And then interfaces come along and don't really fit into that whole paradigm, and tend to have more "esoteric" names. ie ComparableInterface, SeekableIteratorInterface.
I never said it was the right thing to do ;) only it's doable. 
But it's not doable.... you can't write code that says: If this function throws a fatal error, fix it by doing A,B, and C and continue
Hmmm. Getting rid of the graphics doesn't change affect it. It still only spits out the ID and ignores the shortcode command entirely.
What would be nice is if there was a language construct that did this instead of having to implement it in userland at all. Writing code to work around undefined variable warnings is a common enough pattern that the language should take it seriously.
Undefined variables are problems in every language - it's just PHP simply generates a notice and continues with `null`. If you meant undefined keys, well, for that you have the ternary operator. 
What about namespacing working like this? Bob:Blog:Post
I, uh, link an alternative, optimized version of the `array_get` function version at the end of the post, [libphutil's `idx`](https://github.com/facebook/libphutil/blob/master/src/utils/utils.php#L38). ^(Probably off-topic, but I don't really get why people are making such a fuss about this, it's a non-issue that's solved in many ways)
[the_sub_field() echos, you want to return](http://www.advancedcustomfields.com/resources/functions/the_sub_field/)
&gt;That is how you treat kids then? I wouldn't bother trying to teach a 5 year old anything about programming in the first place. I'm sure there are a few kids that may be capable of it but most simply can't. Regardless he isn't 5, and I shouldn't have to treat him like he is. "Explain to me like i'm 5" is stupid and doesn't need to be appended to anything.
So next time I a Laravel-specific post I'll be able to open up the comments and find a similar one from you on it too?
Do you have any real world examples? Cos I can't think of why we need to handle fatal errors this way. 
That's what PHP always does when you use something that isn't defined...
Hi, I've updated my gist accordingly, should have double-checked. Still though, there's not much of a speed improvement. Test array count: 100000 Test #0 foreach test (1389391096.48, 1389391096.64): 0.151771068573 array_walk test (1389391096.67, 1389391097.57): 0.90145111084 Test #1 foreach test (1389391097.62, 1389391097.77): 0.142551898956 array_walk test (1389391097.8, 1389391098.65): 0.842978000641 Test #2 foreach test (1389391098.69, 1389391098.86): 0.168001890182 array_walk test (1389391098.91, 1389391099.75): 0.839338064194 Test #3 foreach test (1389391099.78, 1389391099.95): 0.163151025772 array_walk test (1389391099.98, 1389391100.78): 0.796539068222 Test #4 foreach test (1389391100.81, 1389391100.96): 0.14604306221 array_walk test (1389391101, 1389391101.83): 0.827398061752 Test #5 foreach test (1389391101.86, 1389391102.01): 0.150604963303 array_walk test (1389391102.06, 1389391102.95): 0.889523029327 Test #6 foreach test (1389391102.98, 1389391103.13): 0.148963212967 array_walk test (1389391103.17, 1389391103.98): 0.801779031754 Test #7 foreach test (1389391104.01, 1389391104.16): 0.148635864258 array_walk test (1389391104.2, 1389391105.08): 0.874033927917 Test #8 foreach test (1389391105.12, 1389391105.27): 0.152107000351 array_walk test (1389391105.31, 1389391107.15): 1.8381049633 Test #9 foreach test (1389391107.19, 1389391107.53): 0.337182998657 array_walk test (1389391107.59, 1389391108.63): 1.04338407516
Ok, that makes sense. Maybe its just me, but I found it quite difficult to identify which sections were documenting existing behavoir, and which were proposing new.
If you had read the RFC you would have seen that many fatal errors can actually be converted to exceptions.
That's absurdly broad and messy for a goal. How does a project that's goal reads like a hollywood marketing statement have any kind of direction?
I think its not a common requirement, but I can think of a few times when it could be useful. Maybe you're upgrading through to a major php version, you'd like to log and collate all fatal errors so they can be studied later (with more detail than the standard error log provides). Or another scenario is if you've written a generic system which allows people to download third party plugins (written in PHP). You could then detect any errors in the plugin and disable it, or at least present a nice screen to the user saying 'hey, this plugin is screwed'. 
Nikic, I've been following your work on PHP since I saw the getters and setters RFC on the internals list ( https://wiki.php.net/rfc/propertygetsetsyntax-v1.2 ). I'm still frustrated it didn't pass. That aside, you're a phenomenal developer, and I want to have your babies. Keep up the good work. Two questions for you - where did you start your education for software engineering, and what resources do you use now to continue learning?
It's not like an object's type isn't important and you should never use subclasses. I mean a car is a vehicle and if most of the code for all vehicles is exactly the same then go ahead and use an abstract class. You can use both. Let me try to explain interfaces another way. Your classes are going to have some sort of interface regardless of if you write one or not. The only difference is if that interface exists only in your head or if you're going to let the compiler/interpreter know about it also. You already have an idea in your mind about how you want your classes to talk to each other. Say you're writing a game and you have an abstract class Animal and an abstract class Vehicle and other abstract classes for all the other things you want to draw on the screen. You might give them all a public draw method because regardless of what they are, they're things that can be drawn on the screen. So you've already created the interface in your head here at this point. You just haven't written the interface file to let the programming language know about it. The point of an interface is that you can go ahead and do that. Let the language know, hey all these things are drawable and they all have to have a public draw method and the language will enforce that contract for you. And if you do this and take the different things objects can do and abstract them out into interfaces many times there's no need for an abstract class or inheritance anymore. But when there is use it.
/u/FAD_ED commented with the answer
Laravel, been using it a week and it's awesome. 
Seems like a work-around solution for some sometimes obscure classes behind a fucking annoying registration wall. I won't be using it.
I'm pretty sure you aren't welcome here, sorry man. You gotta be using v3 if you want to hang with the cool kids.
You have been banned from /r/auraphp.
Turns out v3 has nothing to do with PHP.
That was a sad oversight on their part. And they will pay.
That did it! 6 hours of beating my head against the desk finally over! Thank you so much! 
Shit, I just wrapped up a project in 5.3. On a windows 2003 R2 server. We're a little behind. 
Yes, your rest api should only send and receive data from the client.
You're not alone there! One of the sites I've worked on for years is still running 5.3. We're pretty much tied to it without a ton of refactoring, sadly.
Ha, I thought this was a joke, but you're actually the mod.
AuraPHP is best PHP.
Yeah, just write code that doesn't have bugs. Seriously, if you don't take the time to read the link posted here... There's a whole section called **Motivation** that explains the why, here are some copy-pasting for you: &gt; The most obvious issue with fatal errors is that they immediately abort execution and as such cannot be gracefully recovered from. This behavior is very problematic in some situations. &gt; As an example consider a server or daemon written in PHP. If a fatal error occurs during the handling of a request it will abort not only that individual request but kill the entire server/daemon. It would be much preferable to catch the fatal error and abort the request it originated from, but continue to handle other requests. &gt; Another example is running tests in PHPUnit: If a test throws a fatal error this will abort the whole test-run. It would be more desirable to mark the individual test as failed, but continue running the rest of the testsuite. &gt; [...] &gt; If a fatal error occurs finally blocks will not be invoked. &gt; [...] the finally block will not be run and the lock is not released. &gt; [...] &gt; When a fatal error occurs destructors are not invoked &gt; [...] &gt; As both finally blocks and destructors fail in face of fatal errors the only reasonably robust way of releasing critical resources is to use a global registry combined with a shutdown function. &gt; [...] &gt; Exceptions provide an approach to error handling that does not suffer from the problems of fatal and recoverable fatal errors. In particular exceptions can be gracefully handled, they will invoke finally blocks and destructors and are easily caught using catch blocks. &gt; [...] &gt; Exceptions have the additional advantage of providing a stack trace. Or, you know, you could have taken some time to actually read the RFC.
better than 5.2
Thanks for taking the time. I think I've got it. An interface is essentially a "tag" that you can attach to an object that says "this can do X". The word "interface" is a bit misleading. I understand how it applies.. but in your example you wouldn't really think of "drawing" as an "interface". Or better said, the word "interface" kind of suggests something different. In real life it seems it could be something like a license or a permit or certificate that says someone has the ability to perform a certain task. A "health care professional", or its subclass, an "EMT" can both do first aid.. but so could a "lifeguard", which wouldn't be a subclass. So the first aid certificate is the promise that says "whoever holds this can do this task". It would be FirstAidInterface. They might all perform it a bit differently (an EMT would be faster, a lifeguard would be sexier), but you know for sure if they have a first aid certificate, they can fulfill the basic requirements of doing first aid.
Does everybody use "SomethingInterface"? Or could you just say "Comparable", or "SeekableIterator"?
To back up /u/djmattyg007 a bit: This week the Aura-specific posts have been one-a-day; in previous weeks it's been about one-a-week. It is my guess that Laravel-specific posting is at about that level.
Thanks for the SOLID material. I had heard about it, but hadn't really gotten into it. Some makes sense, but some is still above my head until I see it in action. But I think I have the basic concept of interfaces now!
Refactoring might not be (it really isn't) the accurate term to use in this case, really. There's a lot of, simply put.. bad code. Magic_quotes_gpc has made the other developers completely carefree about input validation. Nothing's escaped.. at all. If we were to move beyond 5.3, we'd have zero injection prevention. The effects of register_globals are also visible throughtout the codebase. Truth be told, the other developers are purely hobbyists that enjoy running a site but they don't care about code quality, security, etc. They're just happy if it works. It makes me sad :(.
You forgot no stack! You get the line + file, but calls to debug_backtrace wont give you what you would expect...
Sorry, there seems to be a misunderstanding. The article of this topic does not suggest that anywhere to only use packages of phpclasses. It even implements a composer plugin that depends on the composer-api package that is from Packagist. The option for disabling packagist is only for when you do not need any packages from there. packagist takes a lot of time downloading their indexes. If you do not need packages from packagist, you are wasting a lot of time during package installation. This is explained in this other article: http://www.phpclasses.org/blog/post/221-Speedup-Your-Web-Deployments-Using-Composer-to-Install-PHP-Classes-Packages.html
So give me a real world example. I've yet to see one. 
Yeah exactly. The word comes from the idea of this is a contract that enforces how you will "interface" or interact with a object. It's just an arbitrary fancy word someone picked. Try not to over think it.
Read the damn RFC! Or read what I already copy-pasted you! &gt; As an example consider a server or daemon written in PHP. If a fatal error occurs during the handling of a request it will abort not only that individual request but kill the entire server/daemon. It would be much preferable to catch the fatal error and abort the request it originated from, but continue to handle other requests. &gt; Another example is running tests in PHPUnit: If a test throws a fatal error this will abort the whole test-run. It would be more desirable to mark the individual test as failed, but continue running the rest of the testsuite. &gt; If a fatal error occurs finally blocks will not be invoked. [...] the finally block will not be run and the lock is not released. &gt; Exceptions have the additional advantage of providing a stack trace. -&gt; that means it's easier to debug (but you'll say that I should bug-free code right?) &gt; In particular exceptions can be gracefully handled You know, showing an error page instead of a blank page (in production, when @display_errors@ is disabled) jeez...
You can call it whatever you want and drop the word interface. It's just a naming convention. That means a common practice coders of that language or app use. In some languages you would just do an I at the start like IComparable or just drop it entirely and call it Comparable. When it comes to naming conventions and coding style it's not really important if the rule makes sense or is logical. What's most important is that everyone follows them. Even if they don't make sense it keeps everyone on the same page with the same style so everyone can read the code more easily. So if you're working on a project where all the other interfaces start with I then start all your interfaces with I. If you're working on a project where they all end in Interface then end all yours in Interface. Keep your code in the same style as the rest of the project. There is no right way when it comes to naming conventions. They're all just arbitrary made up crap. All that's important is that everyone on the project uses the same styles and naming conventions.
We just now moved to 5.4...Probably be another year before we go to 5.5
My company is still on 5.2 :( I want namespaces!!
I guess that is a matter of perception of people that are not aware of the facts. PHP Classes has over 1.2 million registered users. It grows at a pace of about 7000 new registered users a month. When you publish a new class in PHP Classes, the site sends a notification to over 300,000 subscribers, so they can come to the site and evaluate the package. This means it provides instance exposure to any author like no other site does. Furthermore initiatives like the PHP Innovation Award provides additional visibility, recognition and prizes to authors of innovative classes. Every month there are many nominees getting that for being innovative. http://www.phpclasses.org/winners/ These and other features motivate many authors to publish in PHP Classes.
Right, as well it should. But the linked article was all about avoiding that notice when you're not sure if the variable is defined. As code-smelly as the @ operator is, this is one case I could see it being used. 
Oh. Oh, that's bad, then. Damn. 
and "finally" that's a nice one too.
the bigger devil in 5.2 is ereg()
I'm not sure if you are aware that the site changed about 2 years ago to not require new users to do full registration to access any packages. Nowadays you can login automatically using your account GitHub, Stackoverflow, Google, Facebook, Microsoft, Yahoo, and more recently using your Reddit account. This means that you no longer need to create a new password or wait to verify your email address. Still authentication is only required for packages of authors that want to notify you when they update their packages. Not all packages require that. For instance this package does not require that you authenticate to view its code, download or even install with Composer: http://www.phpclasses.org/package/8429-PHP-Composer-plugin-to-install-JS-CSS-and-image-files.html Anyway, it is always up to you if you want use the site or not.
Here you go: https://developers.google.com/chart/
&gt;API No thanks.
Nah. Without namespaces you can't use composer for namespace autoloading which basically means you can't any of the decent frameworks (or other open source tools out there that require composer for dependencies) 
Wow... looks like I'm just about alone in getting to use 5.5 for work. I can guarantee you, its awesome. The finally block is a god send and ~~namespaces == pure joy~~ Traits are fucking **amazing**, short hand array syntax is also pretty nice for my fingers.
Transitioning from 5.4 to 5.5 isn't as difficult from 5.3 to 5.4
O yeah 5.5 is awesome :D
You're asking for trouble if you're relying on a third-party that can pull out at any time for core functionality. Who knows what will happen six months from now? Or maybe you blow up and now you're exceeding the API limits. It's unnecessary complication. You're better off having a simpler library that you can depend on on your own server(s).
It's alright, I don't find myself needing it often yet though
Composer is definitely the place to start. The concept is relatively simple once you understand it, but before you do it can be somewhat frustrating. Basically composer does a lot of things. I only really know how to do 2 (probably the only 2 most people will ever need to know) First, you define your external depending in it (which are registered at packagist, which usually is just a reference to the packages Github repository ). Each package you use also has its own dependencies, and those have some and so forth. Composer goes all the way down the dependency chain and gets all necessary packages for all your dependencies and their dependencies and so forth. It saves all those files into the vendor directory and creates a bunch of autoload files in vendor/composer (and one top level autoload file in vendor/autoload.php which grabs all the other autoload files). Now your application can simply include vendor/autoload.php you have access to all your dependencies. However, all those dependencies get namespace autoloaded. This simply means that composer assumes that the class SomeVendor\SomePackage\SomeClass is going to exist in the SomeVendor/SomePackage/SomeClass.php You can also autoload your own stuff by using the autoload: option in your composer.json file. If you don't know what autoloading is, think of the autoloader as container. Whenever you instantiate a class, php checks to see if anywhere in your .php file or other included files for a class definition, if it doesn't find one then it checks of you is registered in the autoloader, if it doesn't then it throws an error. Namespace autoloading is pretty much used by all packages (although composer supports autoloading individual files or classes). This is to avoid packages having class name collisions. Another benefit is that you aren't committing other people's entire packages to your projects repository (always remember to .gitignore the vendor directory. Hope you found this helpful and sorry if some of this was already known to you, I just like helping people since figuring this out just by reading documentation and Googling was long and tedious for me. 
No, you weren't. I was just plain wrong, my bad. Replaced with what 5.4 really has, which are traits and short array syntax.
What are you doing here... go to bed. Its late.
Note: It stopped being cool to hate on php when you walked into the php subreddit.
What about HighCharts? highcharts.com
SQL Injection @ 50 seconds. lol. -- edit: scratch that. SQL Injection every-fucking-where. OP, tell your friend that this is unacceptable. I can look past the non separation of concerns, the non autoloading, but SQL injection is a security thing. 
I've always liked [jpgraph](http://jpgraph.net/features/gallery.php)
The thing is that I really want to like PHP though. I cut my teeth on it. It was my first love. Moreover, it's super easy to deploy apps with. Have you tried deploying a Python app? It's not nearly as quick. You need to configure a WSGI server and then back proxy your actual server to it. With PHP? Just drop your app into a folder, tell your server where it's at (maybe install mod_php or a fastcgi manager if your server package didn't come with it pre-compiled). But then I read things like this and encounter all sorts of bugs like PHP casting values to other types arbitrarily because it thinks you want that. Or how about the fact that there's no actual routing built into PHP? With Flask, all I need to do is this: @app.route('/heres/where/I/want/my/route') def thing_my_route_does(): pass To get the same effect with PHP, I need to delve into URI rewriting. Regexes aside, that's a nightmare to do. PHP is a scripting language *designed for the web*. Yet it lacks something as basic as URI routing? All of my wut. Yes, I know Flask pulls its routing from werkzeug. I'm willing to give PHP a pass on the fact that it's not easy to write other sorts of scripts and programs with, since it has roots in the web and was designed as such. But let's talk about how it requires the `&lt;?` or `&lt;?php` tag at the beginning of the script for the interpreter to launch? Why? Why do we still need to do this? So we can freely intermix it with HTML? That road leads to nowhere but misery -- I've been down it. Or how about this LOL? &lt;?php echo '?&gt;'; ?&gt; When PHP encounters `?&gt;` in ANY context it ends. POOF! Processing terminated until it comes across another `&lt;?php`. Or namespaces? `\This\Shit\Is\Stupid`. OR EVEN BETTER: There's no namespace management. There's no import. There's just `__main__`. When you include a file, it just gets dumped into the current namespace. Yes, I know C (and probably others) does this to. I'd criticize this, but I don't have experience with C beyond hello world. Compare that to Python use of the standard dot notation for namespaces `package.package.module.class` and it's use of `import`. Unless you tell Python to dump everything into the current namespace, it won't. How about errors and exception handling? Why aren't they the same thing? What if I don't WANT PHP to blow up on a "fatal" error that I could recover from -- or at least serve a `500 Internal Server Error` page instead? And by that, I mean anything sort of an actual coding error (and that's not addressing the sometimes obtuse syntax errors the interpreter can toss). Or error silencing? `@` might do any number of things depending on environment variables and compiling options. HOWEVER. I'm really hoping that PHP6 rectifies many of these issues. I'd be willing to give PHP another shot. Don't get me wrong, there's several things that I like PHP for: short web apps, autoloading classes is pretty cool, easy deployment is awesome. It's incredibly easy to pickup and learn. It's come a long, long way since I started with PHP4. And it is the workhorse of the dynamic web. It's worth learning, in my opinion, for anyone involved with server side web development. But that doesn't mean I like it anymore.
Thank you /u/YellowSharkMT for all your contributions to auraphp.
For non-trivial code I'll always check first if there's a good quality library available. First things I look for is how recent the last update is, whether there are unit tests and if it's available via composer. If those three points look good I'll take it for a test ride. Even if none of the available options will work out I'll probably get a good idea of things to avoid in my own implementation. Edit: Overlooked that part. What I'll always never do is copy and paste some code. Except for the rare very clever snippet (mostly from blog posts) I strictly avoid this. Experience has thought me that over time and several refactors the licensing and author **will** get lost.
Hiding behind a "social-connection wall" is no better than hiding behind a "registration wall". It's actually either identically annoying, or more invasive.
May be it will good to know what you expect from the question asking the goal.
Got all that other than finally in 5.4.
They're mix-ins, which are how some languages fake multiple inheritance. They're a nice way to get most of multiple inheritance without dealing with the hard parts.
Check out the [usort() function](http://php.net/usort). You can use it to sort an array using a custom function. Check Example #2.
The lack of APC support is what's preventing us. The replacement only does bytecode caching, whereas apc allows user cache entries. 
You can use apcu[1] for the caching side of apc. [1] http://pecl.php.net/package/APCu
It should work, or you could use the php ssh bindings. Either way though, this sounds like bad mojo. The last thing you'd want is for your ssh credentials to be leaked. By putting them in your code and shoving that into production, that's exactly what you're asking for. A better solution would be to setup a task queue. The Windows box adds tasks, and the Linux box pops them from the queue. 
First, I try to avoid complex code, because complex code grows bugs. Usually you can do with something that is merely complicated. Secondly, reuse drives modern computing. If we didn't reuse others' parts, we'd still be computing like we did in the fifties. Thirdly, I don't write something unless I've got a good reason to. Good reasons include, but are not limited to: * There is no existing solution. * The existing solution is unmaintained and I don't wish to take ownership. * The existing solution is so unstable we can't rely on future behavior. * The existing solution is not performant enough. Fourth, I *never* copy and paste libraries. That's what submodules, dependencies, and that sort of thing are for.
IIS will always give you better performance than Apache or Nginx on Windows since it uses kernel mode subsystems (like HTTP.sys). I'd strongly recommend it. Microsoft's Web Platform Installer can install PHP for you. 
My previous workplace was running Windows Server 2003 with IIS 6. I had to do so many hacks to get stuff working properly in a .NET 4.0 app. Open source libraries aren't tested much with IIS 6 any more. 
This is kind of good advice, and kind of not. This sort of thing is probably best-practice for web apps these days, and is a good approach. But if the OP is having to learn a PHP framework and new technologies in order to achieve a result, throwing Ember/Angular/Backbone onto the pile is just going to make it even harder to make progress. 
Your response is full of disinformation. PHP doesn't cast values arbitrarily, or because "it thinks you want that." PHP's type juggling is fairly well understood and is a powerful tool in interpretted languages. http://www.php.net/manual/en/language.types.type-juggling.php Python even does this for some data types. &gt;&gt;&gt; a = 1 &gt;&gt;&gt; b = 1.1 &gt;&gt;&gt; type(a) &lt;type 'int'&gt; &gt;&gt;&gt; type(b) &lt;type 'float'&gt; &gt;&gt;&gt; a + b 2.1 Your routing example is not native to Python. Flask is a "microframework," according to their site, and routing is a component of it. You are not *required* to think about URL rewriting to do with this PHP or PHP frameworks. Most frameworks even include the .htaccess rules you need to route with "clean" URLs, if that's what you are after. PHP wasn't necessarily "designed for the web." It was written because Rasmus Lerdorf was lazy. In fact, even though PHP is most commonly used for websites, it is used for many other applications. URL routing being native in PHP makes as much sense as it being native in Python. PHP does not require the opening tag at the beginning of any files. PHP allows you to mix PHP with other data including text or HTML. Take that for what you will as a design consideration. You are mistaken in your closing tag example. $ cat test.php &lt;?php echo '?&gt;'; echo "--\n"; $ php !$ php test.php ?&gt;-- $ I believe backslashes were chosen for namespacing instead of dots because dot-notation would make the grammar ambiguous. How would you determine whether the strings between dots were constants or namespaces? It is better to choose a new separator than to change a major portion of the languages syntax. I am not an expert on parsing, however, so I may be mistaken about the ambiguous grammar. http://en.wikipedia.org/wiki/Ambiguous_grammar Your point about importing isn't entirely accurate. However you feel about this, the truth is that "use" imported files are scoped to the current file, and the inclusion happens at compile time. http://www.php.net/manual/en/language.namespaces.importing.php#language.namespaces.importing.scope You don't have anything to criticize about C, whose flaws are very well understood. I agree that PHP should utilize exceptions for all errors, however, consider that it isn't always possible to catch exceptions. In Python, if I have a syntax error in my main file, there isn't much I can do (that I'm aware of). $ cat test.py def $ python !$ python test.py File "test.py", line 1 def ^ SyntaxError: invalid syntax You can have your server send a 500 error page if PHP crashes. PHP doesn't need to be involved in this at all. PHP's error messages have been greatly improved. http://en.wikipedia.org/wiki/Scope_resolution_operator#PHP I don't believe there is a PHP 6 roadmap. https://wiki.php.net/todo/php55 https://wiki.php.net/todo/php56 https://wiki.php.net/todo/php60
I have some odd requirements outside of my control to support some Apache modules so I'll stick with that. There are also more people around my company that can help with an Apache issue. 
I use http://dygraphs.com/ on my companies intranet and find it excellent. I have also used Google chart in the past and found it easy to use and pretty good.
&gt; Or how about the fact that there's no actual routing built into PHP? With Flask, all I need to do is [...] Python doesn't have it built-in either. Flask probably just implements the application side of WSGI under the covers for you. &gt; I'm willing to give PHP a pass on the fact that it's not easy to write other sorts of scripts and programs with [...] Actually, it's dead simple to do non-web stuff in PHP; I'm not sure where you're getting this from. &gt; &lt;?php tag at the beginning of the script for the interpreter to launch? Why? Why do we still need to do this? So we can freely intermix it with HTML? That road leads to nowhere but misery -- I've been down it. You answered your own question. Not breaking 80% of the web is a pretty compelling reason. That said, there was [this RFC](https://wiki.php.net/rfc/phpp) a while back, but I've not heard any news about progress on that front. &gt; When PHP encounters ?&gt; in ANY context it ends. POOF! Eh... I won't say it *never* did this in the past, because I'm no PHP history buff, but it definitely doesn't do it in the current version. &gt; Or namespaces? \This\Shit\Is\Stupid. Stupid because there's something legitimately wrong with it, or stupid because it's different? I work with PHP all day every day, and the only time I ever give the namespace character any thought anymore is when I run across people's "why PHP sucks" posts. &gt; There's no namespace management. There's no import. As part of the language? No. As part of general, modern PHP development? Yes. Using namespaces and a PSR-0/4 autoloader (like the one that's generated by Composer) is all it takes. It might be more convenient to build something like this into the language, but I actually like that PHP doesn't try to be opinionated about where you put your code. &gt; How about errors and exception handling? Why aren't they the same thing? There is [another RFC](https://wiki.php.net/rfc/engine_exceptions) for this already. The vote failed for 5.6, as most of the core devs want to wait until 6.0.
It is possible to run your own copy of Packagist, or for smaller setups, something called 'satis'. Or, you can link to repositories directly in your composer.json. At my job, we use a modified version of satis which has all of our local code, as well as mirrors all our external repositories from packagist.
You should ask in javascript or webdesign subreddits because that isn't a job for PHP but for some javascript lib. You save resources and you don't need to send the data to google (or other third-partys).
The site already tells that to authors in the contribution rules and recommendations page. It is the first page that appears everytime they decide submit a package. The registration requirement is option. It is an option of the author because he is the one that created his code, so it must be his decision, not the site, nor the users. The site provides even an option to make all files accessible without login except for class files. This way users can see examples and documentation and only decide to login after they see if it the class is worth the registration effort. This is the option set for more packages. You see, authors that submit packages to PHPClasses are just human beings. They have dreams, hopes and wishes like everybody else. When you download a package as a registerered user you are basically saying: "your package is interesting, thanks for sharing". The authors can see the exact number of real users that found their packages interesting enough to bother to download as registered users. When you say that authors should abide from that wish to see many users downloading and implicitly thanking the author for sharing, you are just saying you do not care about the authors feelings. You may have not thought about it in that way, but think about it next time you think the registration to download is such a great burden.
i see. thanks for the tip. Will investigate.
FYI I had (huge) random performance problems in production with APCu and Doctrine :( We had to switch to Memcached.
I can recommend Redmine: http://www.redmine.org/
That's php, and it's okay for personal use? like in managing your laundry, to do lists, etc?
Oh oops, my fault. Didn't read correctly. Sorry. Maybe http://www.mytinytodo.net/? Multiple lists, tags, priorities. Should be enough for some real life todos and small work todos. :)
So would the api just get data from / insert data into the database, and then send that data to the js front end to process? 
I would like to bring your attention to https://bitbucket.org/xrstf/composer-php52
Exactly
This exactly. I'm one of 3 IT guys on staff and I was put in charge of pretty much the entire project. I hacked stuff together for 2 days before I even started development because it's so old and incompatible with things. 
Ah, right. Well, those are great too.
We've discussed this before - and I'm sure you've had this conversation many times with many people - but this is entirely opinion, so take it at face value. I hate everything about registering or handing over credentials in return for code. &gt; Many authors create useful packages and share them with other users. However most of the users never give anything back to those authors. They never say thank you, they never give feedback, they never report bugs. That is just open-source. Every community out there (PHP, Ruby, Python, Go, whatever) is thriving just fine without forcing users to register or connect to download code. &gt; Some users only get back to the author to ask for help in using, because they were not able to help themselves. Forcing a registration does not make it easier for the user to contact the author, that could still be optional or handled through a different medium. &gt; Some even complain about bugs that were fixed in newer versions, but they did not upgrade because they were not aware there was a new version. Notification services like [VersionEye](https://www.versioneye.com/) take care of that, but yes this is one of the only benefits I see. If registration were optional and this was offered as a feature then that would be great, you wouldn't need VersionEye (even though the way that service goes about doing it is drastically more useful). &gt; Some authors feel that many of these users are just being ungrateful and demanding. That's open-source, and your website doesn't change any of that. &gt; If you have other ways to effectively make up for the authors to address these concerns without letting them require the users to be authenticated to download, please let me know because I would certainly would like to hear about it. I don't see how your service addresses any of the concerns other than "providing a forum" and "letting users know about updates", nether of which have any reason to have a forced authentication wall. It also adds the complication of forcing users to use this branch of Composer with their username and password stored in plain text (which we have been through before and you don't seem to mind), which means that regardless of how they signed up they still need a password to use Composer. The whole thing seems ridiculous. Just remove the logins, allow users to tack on a API token OPTIONALLY so they can report their user account to PHPClasses and get notifications IF THEY WANT THEM and this whole idea becomes drastically less gross and complicated. This was the exact advice I gave you almost two years ago.
I have implemented a number of updates addressing most of the issues that you have raised, https://github.com/gajus/vlad. In case you wouldn't mind looking again.
A few people explained the benefits of keeping classes out of an extra nested namespace if you don't want it to be in there, so I will give a little sidenote. &gt; \Bob\Blog_Post This is technically PSR-0, because PSR-0 doesn't mind how you name your classes. The _ has semantic meaning though, which means the same thing as a \ character for PHP versions before PHP 5.3 which didn't have namespaces. In this scenario the _ is known as a "poor mans namespace". It would be really weird to see somebody mixing real and fake namespaces. &gt; \Bob\Blog\Post Perfectly PSR-0 again, but you're right that having it in its own namespace kinda sucks if you dont need it to be. Namespace choices are not the same as class naming choices, they are separate decisions. &gt; \Bob\BlogPost Tadaa... This is still valid for PSR-0, is now valid for PSR-1 and because it has dropped the fake namespaces it is completely ready for the new and improved PSR-4. 
What's wrong with using @{{ }} to actually output curly braces without having them parsed by Blade?
You sould really learn PHP before you rag on it.
The [`isort()`](https://github.com/facebook/libphutil/blob/master/src/utils/utils.php#L393) function will help you :)
Oh don't get the wrong idea, I've made literally zero contributions to the project, I just thought there should be a sub where folks could talk specifically about the Aura project.
&gt; Function autoloading If you don't need autoloading support at PHP-Level, you can always write your own symbol discovery and loading tool. https://github.com/AnhNhan/AnLang/blob/master/scripts/generate_symbol_list.php https://github.com/AnhNhan/AnLang/tree/master/src/AnLang/Utils/Symbols It generates a [`__symbol_map__.php`](https://github.com/AnhNhan/AnLang/blob/master/src/__symbol_map__.php) that you use like use AnLang\Utils\Symbols\SymbolLoader; // __symbol_map__.php is in the same folder SymbolLoader::setStaticRootDir(__DIR__); $symbolLoader = SymbolLoader::getInstance(); $symbolLoader-&gt;register(); // Autoload all functions in this project $symbolLoader-&gt;loadAllFunctions(); There are a few more utilities in the Symbol loader (it can do class-autoloading, too), as well as knows about the class hierarchy: // Never, ever forget to register your new console commands again :) $commands = SymbolLoader::getInstance() -&gt;getConcreteClassesThatDeriveFromThisOne('AnhNhan\Project\Console\AbstractCommand'); I may extract this little utility and put it in some Composer package if there's interest.
ProjectPier is a good choice: http://www.projectpier.org/
It's really frustrating that every time a new feature is added somebody has to say "What about this other thing I want?". Argument unpacking going in does not mean that getting/setter won't, there aren't a set number of features allowed.
I reuse and repurpose code. Unfortunately, in my current project(s) this is leading to redundancy, complexity and issues. For example, I have a project that started out as a one off. I grabbed the database abstraction library I built for another project, along with a debugging library and tweaked them a bit for this project. For example, I tailored it a bit more to the new project, and removed support for connecting to PostgreSQL and Oracle databases (new project was MSSQL, who needs Oracle or PG??). Fast forward to three years later. That one off project has become huge and has it's own spinoff utilities. When I did the first spinoff I took a copy of the main project and paired it down til I was left with the database abstraction layer, debugging lib, interface components and a few other common libraries (and css/js). I again customized it, built the util and all was well. Then the second spinoff came. And then the third. And now I have a collection of "one off" utilities (numbering 12 now) that are all based on a common origin, but each has their own little tweaks. That Oracle and PGSQL support I dropped years ago? I had to re-implement that when one utility had a need to interface with both MSSQL and Oracle. PGSQL? I ended up using that on my own end to do user management and access permissions (not even close to in scope on the original project). At this point I'm working on a project to consolidate everything into at least using a common shared set of libraries, but this is difficult to retroactively build when it didn't get built that way to begin with. Not to say reusing code is a bad thing by any means, but be careful to not let it get out of hand.
I've heard this one recommended elsewhere, so I'm going to look into it. Thanks. EDIT: and this is what I went with. Super easy to set up and use.
&gt;The last thing you'd want is for your ssh credentials to be leaked. By putting them in your code and shoving that into production, that's exactly what you're asking for. I thought about this but I forgot to mention that everything is on an intranet and the webpage is only accessible by a few white-listed IP addresses. The whole reason I'm looking for a solution is because the way we currently do this is the same as you explained in your last paragraph but the sys admin refuses to let me poll anything at an interval &lt;5 minutes... Currently the servers sync every 2 hours. A five minute delay after a user input instead of a 2 hour delay is a broken fix and I can't bring myself to do it. Since this will be done with ssh, shouldn't I be able to lock the Windows user down with chroot? If the user can only work in one directory, what are the risks if the ssh credentials for that user do get leaked (not a rhetorical question)? Edit: I'd love to hear any other ideas you have, this is just the first thing I thought of.
I'm hungover, anyone wanna break this down?
You can use composer without namespaces, it requires you to use the ugly underscore syntax to name your classes but it's supported
Oh man, this is fantastic news, I've always wanted this feature! Good work Nikita!
This is for personal use, aka projects in the home, while I will be doing some personal coding projects. I wanted a portal/project mgmt app, that could handle both.
Given the most recent discussion and vote about accessors, that's probably not going to happen in the foreseeable future.
I found it impossible to keep my phpclasses.org's packages up to date. These were added manually before github.com imports where allowed. Even know I haven't found a way to automatically push changes up. The system doesn't allow you to remove files or even delete packages. I finally gave up and just added a comment above each package recommending the user either doesn't use the library or to look for it on packagist for the latest version.
But 90% of the packages you want to autoload will require namespaces. 
Well yes I didn't consider that
I'm not hungover, and trying to figure out what this is, too. EDIT - Google to the rescue. [Here's what it is in Python.](http://hangar.runway7.net/python/packing-unpacking-arguments)
&gt; PHP Classes has over 1.2 million registered users. It grows at a pace of about 7000 new registered users a month. And yet with all that traffic the blog posts see almost nothing in terms of discussion and community engagement - I'm wondering how much engagement actually takes place on those "forums"( which it looks like every class has its own forum ) This is just what I can see observing the pages, I don't have any clue how much discussion is taking place or even how big the community actually is aside from guessing the number of classes posted there. If you don't mind me asking, how many threads have been posted in the last month compared to the number of user registrations/uniques? 
Thank you again for your comments. I've added composer.json and extended compliance with PSR. Regarding the DRY/array configuration. There is a reason why I am enforcing all test script in single array: http://codereview.stackexchange.com/questions/38911/what-are-the-drawbacks-of-dry-input-validation-configuration/38919?noredirect=1#comment65274_38919. To summarise, I am planing to extend the library to work together with JavaScript Vlad library implementation, which will accept JSON configuration, that can be exported using the later Test instance. I have however (I think) improved the array syntax. Do you find it more readable?
To avoid confusion "Vlad" is the name of the Package, while "Ay" (now "Gajus") was the name of the vendor.
Looks great. Just a few more tips (sorry): * Have you thought about conditional rules and rule dependencies? For example, how would I enforce "foo is required if bar is greater than 10"? * On first glance, it doesn't look like Vlad uses any PHP 5.5 features, so you might consider relaxing the dependency to PHP &gt;= 5.4 instead (I could have missed something, though) in `composer.json`. If you wanted to reach an even larger audience, it looks like you could also use the older array syntax (`array()` instead of `[]`) and open this up to PHP &gt;= 5.3 as well, but that's up to you. * You're missing an `ext-mbstring` dependency in `composer.json` (`Translate::getErrorMessage()` uses it). [Here's](http://getcomposer.org/doc/02-libraries.md#platform-packages) some info on PHP extension dependencies. * If you have unit tests, you should include them in the project. If you don't have any, you should definitely create some. Well-tested projects are typically more likely to be used. As far as the config syntax goes, you can store the rules internally as an array no matter what interface you use for configuration. For example, both of these syntaxes could have identical arrays within the `Test` instance: // current syntax: $test = $vlad-&gt;test([ ['foo', 'bar', 'baz'], ['not_empty', 'email'] ], [ ['qux'], ['required'] ]]); // builder pattern: $test = $vlad-&gt;test() -&gt;add('foo', ['not_empty', 'email']) -&gt;add('bar', ['not_empty', 'email']) -&gt;add('baz', ['not_empty', 'email']) -&gt;add('qux', ['required']); I don't think either is "better" - just different. I like syntaxes like the latter because it makes it very easy to see what's going on, and you can quickly tell exactly what rules apply to a given selector. It's nice to see your project coming along. I like the added translator component.
an interface is a contract, that forces a class to implement certain functionality, but it cannot define any logic whatsoever. a class can then "sign" this contract by implementing the interface and when it doesn't implement all the functions defined in the contract, it is not a valid class and usually the compiler/interpreter gives you an error.
Dear /r/php, Why are you so obsessed with micro-optimizations? Love, Igor
lol phpclasses.org
FWIW I've ended up on php classes.org a few times over the years. Each time I immediately clicked away when I was asked to login. Is composer *the* solution? Maybe. But one thing's for sure: the existing UI login requirement actively prevents me from using it at all.
Well that's kinda the point of them switching to use Composer as a delivery mechanism. They are after all a "repository of code", so PHP Classes is not at fault for the previous difficulty of the upgrade process. Using Composer is a great step forward and they absolutely don't need to shove all of their code on Packagist. I'm actually pretty grateful that it is NOT all being dumped onto Packagist. :)
This seems somewhat like asking all readers of my blog to register before I show them the article, because I want to see how much they care. What do I get out of that? Maybe a warm fuzzy glow inside, and a drastically increased bounce-rate.
* User Opinions and Authors Freedom of Choice You are right, this is entirely opinion, not something consensual. You have your opinion but you cannot assume that your opinion is the only one that is right. Other people have different opinions. Other than that, I built this site, so I am aware of challenges that you probably will not know until you build a similar site. Allow me explain. The PHPClasses site does not make any assumptions about authors' opinions. It just gives the contributor the control over how he wants to distribute his packages. If some authors want to require the user to be logged or not, the site respects that. That is called freedom of choice. * Addressing Author Needs When PHPClasses was started, Sourceforge already existed but it did not address some needs that PHPClasses addresses in terms of keeping track of the users of packages for authors that want that. Now that sites like GitHub exist, they address other needs but not the same as PHPClasses. Think about this, many packages published in PHPClasses were imported by authors from GitHub. If GitHub addressed those needs, authors would not be importing packages from there to PHPClasses. That is why PHPClasses grown and continues to grow. * Contacting Authors and Spam In the past, the site allowed users to contact authors without being registered. That caused complaints from authors that were being spammed. Requiring the users to be registered reduced spam. Still authors can expose their email addresses to non-logged users at their own risk. * Tracking User Downloads If a 1000 users download a package from an anonymous download site, when the package is updated with important fixes, VersionEye has no way to notify those 1000 users because it doesn't know who are they. Each of the users would have to register to VersionEye. Most users will not register to anything if they are not required. So 99.999% of those 1000 users will never register and be notified by VersionEye or anything similar. Look at GitHub and notice that the number of followers of each project is very small when compared to the number of users of the packages, which you don't know exactly what it is because it does not keep track of each user, as they are mostly anonymous. There are no miracles. * Making the Authors Happy You are right that no site changes the fact that many users are ungrateful and demanding, but at least keeping track of each user that downloads a package in PHPClasses, the site can build reasonably accurate popularity rankings that please many authors. * Reaching Out Hundreds of Thousands of PHP Users Instantaneously There is another powerful feature that is not mentioned in the requirements page. Each package has its own blog. When you publish an article in that blog, all users that have downloaded your package are notified by email so they can come and learn about what you wrote. This is powerful because it keeps you in contact with your audience. But it does not stop there. If you wrote an article that is generally useful to all users, even if it just about your package, you can mark the article as featured. Then the site will publish the article as part of the main site blog. This means the article is notified by email to about 375,000 users. That is an huge reach. No site provides this instantaneous reach and exposure for your PHP packages. Even JSClasses.org which is a much younger and smaller site can get you to reach over 12,000 users instantaneously. Most authors really appreciate this level of reach and exposure to their packages. * Password management and security As for user and password management, it is up to Composer developers to provide a better built-in solution. What was provided by the Composer plugin I developed is a temporary solution inspired on Stephan Hochdoerfer work. Still creating a simple JSON file with the repository user name and token is better than having to enter the password in the console manually all the time, which is what Composer requires without this plugin. If you are concerned with the security, remove that JSON file from the servers after you have installed your packages. It's that simple. * Conclusion Anyway, the bottom line seems to be that with your suggestions you just want to make PHPClasses equal to other sites, lacking of important features it provides to many happy authors. If your point is to make PHPClasses like other site, there would not be much reason to exist, as it is pointless to have another site that does the same as others. Phil, you are a smart guy. In my view usually you make perfectly reasonably criticisms that I appreciate. Now that I explained several things that you may have not been aware, I hope you can now understand better why PHPClasses is the way it is addressing the needs of authors that may have a different point of view than yours. If you have other criticisms and suggestions to continue to address those author needs, I continue to be interested to read.
Thanks so much. Use cases?
If you don't need interactivity chartjs.org is really good and easy to implement.
Perl has: `||=` and `//=` which basically do the same thing, and are used ALL the time. I wish PHP had something similar.
Give us an actual code sample you need help sorting so we can give you an appropriate response.
Packagist is incredibly crowded. The fact that generic libraries, framework-specific libraries and libraries that require entire frameworks to work at all, can be difficult to identify and pick apart, is making packagist increasingly frustrating to use. Something is missing it its package organisation, but I can't quite put my finger on what it is. 
I second JPGraph. A ton of options, and very flexible.
* Registration requirement option The PHPClasses does not impose anything on the authors. They created their code, so they decide how they want to distribute. If they want to make it available without the login requirement, they can. Some authors do that. I just made this class available to anonymous users because I felt it was the right way to do it in this case: http://www.phpclasses.org/package/8429-PHP-Composer-plugin-to-install-JS-CSS-and-image-files.html PHPClasses contributors are not stupid. They know that some people will not login to download. The site reminds them that everytime they submit a package. So the decision is conscientious. They know what they lose, but most importantly what they gain. There are plenty of gains to make the PHPClasses site very interesting for authors to publish there. * No appreciation from anonymous users When a user downloads a package anonymously, the site cannot track that user because the site has no way of knowing if that user is the same that downloaded the package on some other time. This makes it impossible to account the real number of users of a package. When the site tracks logged users that download packages, it can provide an accurate count of package users. If the same user downloads the package many times, it still counts as one. Many authors really appreciate user counts. That is a way of knowing how many users are implicitly thanking them for sharing their work. Anonymous users cannot contribute to thank authors for work that they share because they don't want to be bothered to register.
That's variadic parameters, a related but different thing than argument unpacking. Argument unpacking allows you to do something like that: function test($first, $second, $third, $etc) { // do stuff with those } // Then call the function by any of the following equivalent methods: test(1.0, '2', 3, 'etc'); test(...[1.0, '2', 3, 'etc']); $a = [1.0, '2', 3, 'etc']; test(...$a); It also can occur at any point in the function call, as long as the total number of arguments to the function matches the definition: $b = ['2', 3]; test(1.0, ...$b, 'etc'); 
It is your opinion. If you do not care about the number of unique users that downloaded your packages, that is OK. Just submit your packages and lift the registration requirement. That is an option that you control as an author. The PHPClasses site does not interfere in your decision. Now many authors really want the site to track the users that downloaded their packages. 1. One is that they want all users that download their packages to be notified by email when they update their packages, so they be aware and download the latest versions. 2. The other reason is that they want to know the exact number of unique users that downloaded their packages. It is a simple form of feedback that does not require much from the users. Furthermore this allows building acurate rankings of author popularity. Many authors really appreciate this because they know when they are getting better compared to authors after they submit more and better packages. http://www.phpclasses.org/browse/author/ If you do not value these things, that is OK, but many other authors appreciate that a lot. There are many other things derived from this that PHPClasses provides and makes it more fun for authors, but I am not going to detail them to keep this brief. Maybe you should try it to understand why exactly so many authors submit their packages there and appreciate the site so much.
Sorry, I may have not made it clearly how it works. Your blog is fine but it does not have 375,000 users that are notified by email when you post something interesting. In PHPClasses you do not ask any users to register to see your blog. It is public for all people even anonymous users. What you get if you publish a featured blog post is that the site notifies the users for you. Not only it provides huge exposure to your work, but it also does it free. How much would it cost if you ask MailChimp to notify 375,000 PHP users about your blog posts? What you get totally depends on the interest of the article for the users. It is pointless to write articles that are not interesting to great part of the users. Now if you write interesting articles, you get the same as if you post in your blog, except that you reach way much more people. Interesting articles get a lot of feedback that may be useful to improve your work further. You can also earn more perceived reputation. Depending on your goals this may get you better jobs, or even respect from authors that may end up voting on your work for the PHP Award, just to give one example. http://www.phpclasses.org/winners/ Phil, if this still does not make sense for you, that may be because you never submited your work to PHPClasses. There is much more going on in the site but it would take me ages to describe it in full here.
It totally depends on the interest of the packages for the users and the commitment of the authors to be helpful in the forums. Let me give you an example. This package here that I developed is having its forum permanently crowed. http://www.phpclasses.org/discuss/package/7700/
You can have a shared folder between host and virtual machine. Check out Vagrant: http://docs.vagrantup.com/v2/getting-started/synced_folders.html
This, use vagrant. And use something like capistrano to deploy the code to your production server(s)
Run a service on linux box that you can call from windows server when you need to update. That may be anything: apache php script, nodejs or java that listens on socket. 
Exactly, its the growing pains of any repository. During a lot of time I have heard people complaining about bad code in PHP Classes. The problem is not PHP Classes. That is just a reflex of the PHP community. There are some developers better than others. Some packages are good, others are too simple or buggy. You do not control that when you allow everybody to publish. At least PHP Classes has a rating system that helps to see which packages are more appreciated. There is also the Innovation Award that PHP Classes organizes since 2004. Being innovative does not mean being of good quality but often one thing is tied to the other, so awarded packages are often a good reference. But this all took a lot of time to develop. Many years and and thousands of lines of code were necessary to put this together. I do not need any public appreciation to carry on with my work in PHP Classes, but it is certainly very odd to see how aggressive and insensitive certain PHP developers are when they campaign against PHP Classes.
Interfaces are just a workaround for lack of multiple inheritance in PHP. Lucky that we now have traits. 
You heard if composer? Ironically Aura uses that too... Not the dependencies cause the problems, but the tools to manage them. If there are _no_ tools at all, yes, thats a mess. Even without composer you can still link it using your VCSs "submodules", or externals functionality, or even integrate them directly into your VCSs repository (think of statically linked). Just: It's not the concept, that makes you feel the pain, it is the way you are trying to deal with them.
Stuff like that made me want to give up on GUI tools altogether years ago and just do all my work through command line interface. There are like 10+ different dev boxes i need to go to at work, many on different VPNs or have to be accessed by jumping through other boxes. I laugh waching people at work bitch about it and harass admins to set up tunnels, sshfs, and public ip addresses, because they cant work without Netbeans or MySQL workbench. I just run my tmux,vim,tcpdump,multitail,etc through ssh command line and never have any problems.
I think that the AuraPHP team has a core issue they need to deal with asap: **how does this package help ME?** Everything they say is about how amazing AuraPHP is. 100% code coverage! Decoupled! No dependencies! That's ... great. But why should I care about that? How does it help me write an application? If I'm using the AuraPHP framework, then I'd use its built-in packages because I know they were built to work with each other. What's the benefit of decoupled and independent packages in this scenario? And vice versa. If I use another framework, then I'd use that framework's packages. Why would I try to figure out how to plug AuraPHP packages inside a Laravel project? Leaving ... custom apps/frameworks. Why would I choose to use AuraPHP's packages over something else, which has been out longer, is more mature, and is known to work well? Hint: the answer should not be because your code is higher quality via code coverage, decoupling, and no dependencies. So pls pls pls, go back and figure out proper goals. Figure out [WHY](http://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action.html).
Hey, please don't do this. /r/php is not a support reddit.
Why not share folders? &gt; Use SFTP to push code from your host OS to the virtual server. To view your project in a browser, you should be able to connect to the virtual server on your host OS via SSH. You're complicating things. Check out what I made, https://puphpet.com , customize it to your needs, choose NFS sharing. You're on Linux, you have an advantage over people on Windows, who can't use NFS. If the speed is still not to your liking, read this: http://mitchellh.com/comparing-filesystem-performance-in-virtual-machines It's worth it to plunk down extra monies for higher performance.
&gt; What demographic is phpclasses still popular with? Copy/paste/modify PHP "developers" that don't actually know how to code and just need something that they can make work in the most lazy way possible. Nobody else would be as unaware of their reputation as a cesspool of poorly-coded crap that you can't even tell is poorly coded without giving away your contact information. 
Check my response to the deleted reply. 
Thanks, for your response.
The same way you bill for anything else. Decide what your time is worth and charge.
You can't be expected to know every single thing, you need to figure out how some things work. That said, saying you "know" and can immediately jump into working with a framework when in reality you have never seen or touched it may be on the false and sleazy side. If you say, however, "I can create a webscraper that works with curl and beanstalked and etc etc" and you need to read a bit on how to get everything to jive together then that should all be billed as normal. Do you think a lawyer knows 100% of his specialty by memory? There's a reason all those lawyer commercials are filled with books - they reference them all the time.
Laravel's facades aren't true facades. They're something else, but I am not smart enough to know what their proper term would be. I highly agree with your article - it's well-written. One thing I would add is that using Laravel's static patterns ingrain bad habits into more junior/mid-level developers. If you are a developer who has never unit tested her code, and you start using Laravel where you see static calls everywhere that achieves the pretty fluid interface, you're going to want to continue to use this. You won't know that, normally, this is a code smell and that you should avoid static calls as much as possible. So you will be plugging along, quite happy with Laravel - but what happens with Laravel stops being the flavor of the month? All of a sudden you're using some other framework and applying what you already know to this new one, even if it may not have the facade structure setup. You end up writing tightly-coupled, hard (impossible) to test code! This is one of the biggest downsides, imo, of Laravel facades, and I think the community in general will pay for it down the road.
Don't think about it as how much time it takes you to get something done, think about how much your time is worth. You only have so much time, and you're exchanging it for money. If you're researching something for a job, you're on the job and I would definitely bill for that unless I had negotiated something specific with the client.
Your hourly rate is not for doing X, Y, and/or Z tasks only. It's an average rate for anything and everything that you'll be doing remotely related to the project. Whether that's chatting with the client, typing on your keyboard, or thinking on the toilet - it doesn't matter. Maybe you think your meetings are only worth $20/hr, your programming is worth $150/hr, and your research $75/hr. What are you going to do? Bill the client based on this? Give them an invoice with itemized labor? Nobody (and I mean **nobody**) is 100% productive 100% of their work day. Just be as productive as possible and charge your clients what you think your aggregated time is worth. It's really that simple.
I wouldn't say obsessed, try mildly interested?
That is totally not the case. All packages are reviewed before publishing. A detailed description is created by the moderator to describe what packages do. Also most packages you can see any documentation and examples without having to login. Furthermore other users can rate packages in terms of utility, consistency, examples, documentation, tests and video tutorials. If a package is good or bad it can be rated by other users and anybody can see the ratings before ever be prompted to login and download. That is way better than sites that do not require the users to login but do not have no moderator created descriptions nor user ratings. In those sites you have to be bothered to look in the code and author documentation to figure by yourself.
Given how difficult it was for you just to find the classes really used behind the facades, or also how to use the service without the facade (you had to write an adapter), this is clear that this pattern is really of no good on the long term. And given that Laravel doesn't make it easy to do without, I think I'll stay away from that.
Can you elaborate on why static calls are code smell?
I hope you don't mind me answering for someone else but I've always felt that static calls are essentially globals in that calls to them can be made anywhere without needing to explicitly depend on the class with the static method so then unit tests become more difficult. It is also trickier to mock calls to them without the callee being aware of it That isn't to say that static methods aren't useful though, just that it is highly dubious using them to avoid constructor calls
Not at all, thank you
The bad thing about static method calls is that they are dependencies that cannot be changed at runtime. And this has negative effects. For example, if I want to change some component by another implementation, with a static method call, simply I can't. Or If I want to unit test some code that has a static dependency, I cannot. In the case of Laravel, the static dependencies are being resolved by a __callStatic magic method that usually goes to the IoC container to retrieve the dependency. I think this has the worst of the worlds, because you end up by introducing a static dependency that cannot be changed at runtime added with the indirection caused by the direct use of a service locator. The worst of all, is that this style of programming is widespread all along the Laravel documentation site. And I'm starting to believe that this is due to a lack of knowing on how to properly use all the creational design patterns. At least, that's my sense.
I have had authors experience while developing [phpcomplete-extended-laravel](https://github.com/m2mdas/phpcomplete-extended-laravel#phpcomplete-extended-laravel) autocomplete plugin. Laravel's over-reliance of magic static `__call` method makes it hard to build tools around it. For example I can get the class of `cache` ioc by calling get_class($app-&gt;make('cache')); Which leads to [Illuminate\Support\Manager\CacheManager](https://github.com/laravel/framework/blob/master/src/Illuminate/Cache/CacheManager.php) class. But that's not the whole story. It seems that it is of [Illuminate\Support\Manager](https://github.com/laravel/framework/blob/master/src/Illuminate/Support/Manager.php) class. If you see the [_call()](https://github.com/laravel/framework/blob/master/src/Illuminate/Support/Manager.php#L131) method you will see that it will call method of what `$this-&gt;driver()` method returns. For `CacheManager` class it is of [StoreInterface](https://github.com/laravel/framework/blob/master/src/Illuminate/Cache/StoreInterface.php#L1) class. There are also some ioc classes whose `__call()` may call custom method based on argument. For example the [`__call` of `log` ioc](https://github.com/laravel/framework/blob/master/src/Illuminate/Log/Writer.php#L228) recreate method name and calls Monolog `add*` methods. Source inside Laravel is somewhat predictable. Imagine what happens if a smart `__call` abuser get hand of a project. As you see these little inconsistency makes it harder to make autocomplete tools. Although Laravel's facade system makes it easier to code, too much magic inside `__call` may make it difficult to maintain for large project.
Wow .. I am always surprised by amount of time that Laravel spends on marketing their crap. &gt; *"Static classes are not bad. They are just facades."* Take a bad practice, rebrand it, ship it. 
Looks like that project hasn't been updated in quite some time.
The facade pattern is something I completely understand the benefit of. 2006-2011/2012 was the "old framework" era. During that time there were always two real types of framework. The ones that catered to the lowest common denominator and those which just wanted developers to do things right. CodeIgniter. Technically rather shitty, singletons everywhere, but it was EASY for any developer to pick it up and smash out a website. Unit testing? You're fucking joking right? Symfony: Bootstrap everything, inject your dependencies, learn about services but you can unit-test the balls out of of it. That is extremely powerful, to have those two options. What Facade does for Laravel (and what people mean when they say "but its OOP underneath!) is that you don't need the two different styles of framework. The static facade stuff is very much what CodeIgniter, Kohana and FuelPHP always did (just a little more modern, and sitting on top of a grown-up codebase). You don't need to migrate your code when you learn, and you can take a project written by a noob and make it testable IF and WHEN you care. I am so happy that the PHP community is going through this "testing is AMAZING" thing and getting super upset about being writing non-testable code, but for beginners there are priorities. Trying to shove DiC, IoC, services, unit-tests, etc down their throat when they're just trying to learn how to validate a form and save the data is unfair. Did you forget about when you were a beginner?! :) Facade is great. If you know enough about why you hate it, then absolutely dont use it. If you don't know enough then keep on going, and when you finally learn why it's bad it's not that hard to remove yourself.
&gt; I've always felt that static calls are essentially globals You and a lot of really smart people. You are in good company. =)
What bothers me most about this, is that a `Facade` has a very defined meaning when talking about OOP. It's a [compositional pattern](http://sourcemaking.com/design_patterns/facade). Facade (as termed by Laraval) is a static service locator. Very much not compositional, and very much not what the traditional pattern was intended for. If we can't use consistent terminology, and not bastardize well defined words for other uses (and hence marketing speak), we will fail. 
&gt; static patterns ingrain bad habits into more junior/mid-level developers Preach the Word my brother.
You are right in the part that my article doesn't apply to this article much. Your application code can certainly be dependent on framework specific code and it would be mad to try and avoid it completely. Switching from Facade (static usage) to IoC (injected usage) does not make you any less reliant on framework specific code, you've just changed how you access that same code. People could write interfaces for everything they pass into their controllers so that they could make those dependencies a little less tight, but that would almost certainly be more work that is worth. But, definitely don't put any of this Facade code into framework agnostic Composer packages that you release unless they're in an adapter class. That would _suck_.
&gt; Personally though I just see this article as creating more work to avoid something that in the end doesn't seem all that important... In these days of composer, one of the justification for the existance of frameworks such as Laravel is that they encourage best practices. If a framework provide ways or encourages using anti-patterns like this, it is like working against that cause. 
We agree that a framework _should_ lead by example, for sure, but new developers do not know what is good for them. They will simply look at code in the examples, decide that it is too complicated, and move on to something else. That something else will probably be a static shitty mess, but they'll be happy they found something simple. This is why CodeIgniter was so popular for years. It was almost 90% bad practice, but nobody cared because they were busy writing code that worked well enough for them to get paid. "IoC is not just about testing" of course, but a lot of people just don't care about loose-coupling or maintainability either. They should if they are going to be good developers, but I know an awful lot of designers and business people who have been able to smash out sites with CodeIgniter and Laravel and make a lot of money doing so. Their products work, their customers are happy, everyone wins, and it's all static as hell. Now, when I come in to consult on those projects I'm angry and sad. I used to be REALLY sad when it was in CodeIgniter and there was nothing I can do about it, but now they can ask me to tidy things up a little and because Laravel offers both approaches all I have to do is switch a little code from static usage to an injected object. If Laravel did not offer Facades, people would build their own shitty static frameworks to do it. We'd have more Kohana-ish clones with static-only and there would be no upgrade path to sane testable code. Assuming that all developers can and should learn the most advanced methods immediately is generally unreasonable, and in my personal experience something that is more damaging to people than anything else. My main point is that beginners will do this stuff anyway, and letting them do it inside the same framework that can offer a solution to the very problems they are creating is immensely powerful. A learning curve that follows the user instead of a cliff-face is great for the PHP community in general.
can you post the php code?
I can certainly see the utility, yes. It's a tenable position. But `global` is easy too and no one is doing *that* in their framework code. The two aren't really any different. I guess I just don't agree that it's impossible to simplify good practices for the less experienced developer. And I'm not really sure the user with no discernible understanding of programming is the right demographic to be targeting with a framework in the first place. I believe firmly that no user should touch a framework before she has a firm grasp on a language. Anything else is asking for trouble. At the end of the day I think it's a lot like the robustness vs. correctness error handling debate. I simply prefer to error out if even the smallest thing goes wrong so that it can be fixed as soon as possible. Other people prefer to accept a small amount of error in their program in exchange for 100% uptime. You have to do what's right for you. Ideally you want zero errors in your program, but in real life that may or may not be possible. *Edit: added moar whitespace for readability*
Sure: &lt;code&gt;
I understand completely, and I am a supporter of the "learn the language, not the framework" idea. Unfortunately, again, a lot of people just don't care and want to make money. So while we have different opinions on what a framework should do and who it should cater to, I am simply happy that Laravel will give a helping hand to users of all levels and guiding them on their way to better code by snapping them up at the entry level and providing enough tools to help them grow. If Laravel wasn't doing it, somebody else would. :) The Laravel community and its resources are all very much about "inject stuff, static is bad" once you're in there and learning, it's simply people that look at it and shout THAT IS BAD that gets their backs up - and quite rightly so. People should all learn as much as possible and be as smart as possible and that'll make the world a better place. 
I wouldn't immediately discount Laravel for that. It's a fantastic framework and the fact that you have the option to use facades or not is great for people on all levels. My wish is that Laravel's docs equally emphasized injecting the dependencies rather than the use of facades. Also, shame on me for not looking at the docs recently. The [Facade Class Reference](http://laravel.com/docs/facades#facade-class-reference) would have been a big help before writing the article. Not sure when that got added.
&gt;From php.net, Unlike PDOStatement::bindValue(), the variable is bound as a reference and will only be evaluated at the time that PDOStatement::execute() is called. Because you are using a loop variable for binding, all the place holders will endup being evaluated to what ever value held by $keyword, at the end of the loop, where the query is being evaluated. So all you your AND statements end up checking against the last loop value. So I think replacing bindParam with [bindValue](http://www.php.net/manual/en/pdostatement.bindvalue.php) function will fix this.
http://pastebin.com/ru2ds9yw &lt;?php //dummy array $array = [ 1 =&gt; [ 'name' =&gt; 'Maths', 'parent_category_id' =&gt; NULL ], 2 =&gt; [ 'name' =&gt; 'Algebra', 'parent_category_id' =&gt; 1 ], 3 =&gt; [ 'name' =&gt; 'Expanding brackets', 'parent_category_id' =&gt; 2 ], 4 =&gt; [ 'name' =&gt; 'Factorising brackets', 'parent_category_id' =&gt; 2 ], 5 =&gt; [ 'name' =&gt; 'English', 'parent_category_id' =&gt; NULL ], 6 =&gt; [ 'name' =&gt; 'Shakespeare', 'parent_category_id' =&gt; 6 ] ]; // build an index of items; $index_of_items = []; foreach($array as $id=&gt;$item){ $parent_category_id=is_null($item['parent_category_id'])?'0':$item['parent_category_id']; if(array_key_exists($parent_category_id,$index_of_items)==false) { $index_of_items[$parent_category_id]=[]; } $item['id']=$id; $index_of_items[$parent_category_id][]=$item; } //recursive array building anonymous function $nesticles=function($parent_category_id)use(&amp;$index_of_items,&amp;$nesticles){ $children_categories=[]; if(array_key_exists($parent_category_id,$index_of_items)){ foreach($index_of_items[$parent_category_id] as $item){ $item['children_categories']=$nesticles($item['id']); $id=$item['id']; unset($item['id']); $children_categories[$id]=$item; } } return $children_categories; }; $desired=$nesticles(0); var_dump($desired); 
It's not enough there's an Aura post here every beta release? Do we really need one every commit?
&gt; you end up by introducing a static dependency that cannot be changed at runtime This is incorrect in terms of how Laravel uses statics and facades. Their usage of the pattern allows you to swap out the dependency at runtime very easily. You could even swap what's powering the `Input::get` between calls to `Input::get`. It's very flexible in that regard. However, it's confusing at best to those new to the practice. Note: I don't use Laravel (I'm actually an author of the Joomla Framework)
That fixed it. I'll be damn. Gold for you sir!
&gt; this is due to a lack of knowing on how to properly use all the creational design patterns I lolled.
&gt; I believe firmly that no user should touch a framework before she has a firm grasp on a language. Many Ruby developers started because of Rails.
What is your point?
I don't normally charge for educational time -- considering they came me to do a job and I told them that I'd be able to do it by taking the job. In only two instances will I charge; 1. The only reason why I need to read up is because of something they've done 2. They've requested something that is outside the stipulations of the working contract and we've mutually agreed to it. 
Do you remember that time that CodeIgniter called their Query Builder an "Active Record" for 7 years?
&gt; I am simply happy that Laravel will give a helping hand to users of all levels and guiding them on their way to better code by snapping them up at the entry level and providing enough tools to help them grow. I am not sure I think it will work that way. If you want them (not every one) to grow, you have to. 1. Force them to do things better way. 2. In a while they will see the advantages of doing so. 3. Now they have gained first hand experience regarding why it should be done so, and have made some progress. If a good, reputed framework lets them do things in a sub-optimal fashion, they have no immediate incentive or they cannot see any incentive for changing to the optimal way. They will resist any advice regarding the matter, because Laravel does this, So it should be fine, right? So this solution, as you mention, may lead to a less broken projects, but not to a less broken developer.
Thank you!
No, thank you! This is the first time I'm using the iterative method of adding parameters instead of the fixed :param method, so I had no idea that was even how bindParam even worked and that bindValue operated in a different way. I thought I was loosing my mind!
Generally worse. But that's cause they're elitist jerks. Rails is great! :D
 function getTreeWithRoot($root, $array) { $tree = []; foreach($array as $id =&gt; $info) { if($info['parent_category_id'] === $root) { $tree[$id]['name'] = $info['name']; $tree[$id]['questions'] = []; $tree[$id]['child_categories'] = getTreeWithRoot($id, $array); } } return $tree; } $array = [ 1 =&gt; [ 'name' =&gt; 'Maths', 'parent_category_id' =&gt; NULL ], 2 =&gt; [ 'name' =&gt; 'Algebra', 'parent_category_id' =&gt; 1 ], 3 =&gt; [ 'name' =&gt; 'Expanding brackets', 'parent_category_id' =&gt; 2 ], 4 =&gt; [ 'name' =&gt; 'Factorising brackets', 'parent_category_id' =&gt; 2 ], 5 =&gt; [ 'name' =&gt; 'English', 'parent_category_id' =&gt; NULL ], 6 =&gt; [ 'name' =&gt; 'Shakespeare', 'parent_category_id' =&gt; 6 ] ]; var_dump(getTreeWithRoot(null, $array));
So is having more inexperienced people writing code somehow a good thing? What's your point?
$_GET is an array, not a function. GET parameters are pretty much how the whole URL thing works, it's just usually "masked" for prettier and more readable addresses.
My point is frameworks are a great way for inexperienced developers to learn the intricacies of a language, without having to deal with all of them at the same time.
On a site like reddit a link to /r/php would usually be mapped to something like index.php?p=r&amp;subreddit=php . So you'd have a value of "php" for $_GET['subreddit'] . So any type of navigation will usually end up in a $_GET[] value in some form or another. Search queries, as you point out, should indeed also be done using $_GET. *note that reddit is written in python, and probably does routing completely differently than your typical php website. It's just an example.
&gt; My best guess is that the query would be submitted from a search form. Yes, exactly right. It is one of the ways of transferring data from a user form to the server. POST being the other common way (which is handled in PHP using $_POST[]).
Although the dependency can be swapped at runtime, continues to be a static dependency with the added indirection of using directly a service locator. For example, What happens to the base code if Laravel is pulled out? Trust me. It may seem flexible at the beginning. But it isn't.
Wow - impressive when you are turning to a PHP extension to squeeze all you can out of URL routing... :)
I have played with this idea ... there's not much to gain by doing this ... bottom line: if routing really is the bottleneck, you are doing it wrong ... PS. I don't think routing really is a bottleneck, it might be a bit slower than it could be in some of the popular frameworks, but _bottleneck_ is hard to see ...
Thanks, guys. I think I found my answer. http://en.wikipedia.org/wiki/Query_string, what I was failing to understand is how the query string works. It's making more sense now. Web forms[edit] The main use of query strings is to contain the content of an HTML form, also known as web form. In particular, when a form containing the fields field1, field2, field3 is submitted, the content of the fields is encoded as a query string as follows: field1=value1&amp;field2=value2&amp;field3=value3...
I agree with your point, as usual a single database/service/API hit would kill any real gain the route processing task would bring to the table. My comment/kudos below was more about the effort of going to write a PHP extension itself...
I still argue with collegues about this who haven't used anything but CI ...
Ya, I was going to say (but then got sidetracked) that this is more generic to how the web works rather than PHP. Looks like you've got the right idea. I just wanted to make sure you understand the difference between GET and POST. Web forms can use either, but POST data gets sent in the request body rather than in the URL as parameters. The reason is simple: GET requests are for querying a resource for something (hence the GET verb). POSTs are simply for submitting data to create or manipulate a resource. This is why, when you submit a form and then click the back button, the browser should always ask if you want to re-submit the form.
If you ever find yourself copying and pasting your OWN code between projects, remember that you can create your own Composer repositories, so you can centralize a code base even if it is private and used only by yourself / your team.
&gt; If that work (should) take someone experienced with it 10 hours to complete but you spend an extra 5 hours because of the amount of time going back and forth / searching documentation and common problems on stack exchange how much of that extra 5 hours do you bill. Someone experienced charges a higher hourly rate; one reason is because they don't have to look everything up. In the end, it shouldn't be surprising that the client will end up paying as much if not more to have a job done by someone who isn't sufficiently experienced to pull it off without learning time. Charge for all the time you spend on the project. As long as you represented your capabilities honestly, then they should be paying you for everything you need to do in order to get it done.
&gt; Pux is 48.5x faster than symfony router in static route dispatching, 31x faster in regular expression dispatching. (with pux extension installed) &gt; [...] &gt; With Pux PHP Extension support, you may load and dispatch the routes 1.5~2x faster than pure PHP Pux Trying to understand the details here: with the extension, you're (say) 35x faster than Symfony. But Pux without extension is 2x slower than itself with extension. What's the delta here? What's your speed _without_ extension, pure PHP, compared to current frameworks? Are you claiming to be 15x faster than Symfony _without_ the extension?
&gt; I believe firmly that no user should touch a framework before she has a firm grasp on a language. Anything else is asking for trouble. The thing I don't get when this argument is dragged out time and time again is that it somehow suggests that there are such a thing as developers in the wild who know a framework but don't know a language. This might be the case, but if it is it is only because we as experienced developers have allowed it to be the case. We have the ultimate power here. Don't employ shit developers. Don't accept pull requests from shit developers. Don't use projects and/or libraries written by shit developers. If we do that, who cares if some people learn a framework instead of a language? They become irrelevant. Basically this argument about framework devs vs "real" developers is made completely irrelevant by just not accepting shit. We don't need to set some arbitrary level of mastery to determine if someone is _allowed_ to use the extra productivity afforded by a framework. If someone has a basic understanding of OOP principles (even if they don't fully understand the language) and has demonstrated that they wont write utter shit then surely it makes more sense to get them using a framework that allows them to be more productive and ultimately deliver product sooner and provide clients/businesses more value?
Lol at that ridiculous and borderline idiotic benchmark... garbage.
If you think of the information being shown as each "unique" categories. Each probably has an id. Saving the unique identifiers for the content a user wants to see in the database would allow you to later check, and show that information to them when needed. 
Help an ignorant plebeian figure this out: What makes it borderline idiotic? I don't pretend to know much about benchmarking, but he's testing the requests per second Symfony versus Pux routing can handle. Isn't that the bottom line? Maybe memory consumption would be more accurate? Common sense tells me routing is a silly thing to focus on because it's far away from the bottleneck, but I'm not sure why the benchmark is "garbage" (then again, as I understand it, benchmarks are crazy hard to get right).
Just make it like Reddit, where they sign up or subscribe to certain feeds. If you have items in your database for the 'posts' or 'pieces of content' or whatever, then just make sure you have categories, and put a category id on said post or content, then a user can sign up to the category to get more posts like it.
I would say, make a settings table with each option that you think is relevant and make them a switch 1/0 and based off the users ID that should be stored in a cookie for reference between pages.
He did not publish exact code he is testing, the whole point of his test is to throw some bullshit numbers at visitors to show how 'fast' this is. Also he is doing more requests than needed so even 0.000001 difference will add up until the difference appears to be great. So if you have app 1 and app 2 with 0.1 execution difference, running a useless test 10000000 times will produce a claim of: 1000000 seconds faster! 
thanks for explanation, that makes a lot of sense!
The corresponding [Hacker News thread](https://news.ycombinator.com/item?id=7046313) has more on this. Specifically they point out the charts are misleading because it's a comparison of the router itself versus the full Symfony stack. Also it writes the cache to disk, which can cause its own issues.
Awesome. Can't wait to read it!
&gt; Sadly, I've seen several projects fail because "Static usage is quick and clean, and beginners love it". In 20 years, I've never seen a single project fail because of this. I call straight BS. Other than really hairy javascript, written by developers who didn't know english (people whine about no documentation, what about variable names that are bastardized cyrillic), there's no way static calls can cause a project to fail when you can wrap them at any time.
My response (and changes) based on the feedback here: http://taylorotwell.com/response-dont-use-facades/
Posted.
Sorry I should have added that the information is dynamic, and that it won't be just a static webpage showing different content, I wish to upload content to my site, let's say a post about food, but some users have not subscribed to posts about food. How can I let's say 'label' the post I put up on the site as food, therefore only users who subscribed to posts about food can see? Sorry if I am getting confusing or what not, but It's tough to put into words exactly what I am in need of. 
Or conversely, if your routing is the bottleneck you're doing it very, very right. Not that I think you could ever get your application that optimized...
I assume it's mux as in 'multiplex', which makes a bit of sense at least.
&gt; How can I let's say 'label' the post I put up on the site as food This is commonly called "tagging" or "tags". Slashdot.org uses this, as do many other sites. Twitter uses a slightly more elaborate system. You can create a tags table. Add a tags field to article creation. Parse the tags field, add new tags to the table. Allow subscribers to subscribe to tags they are interested in (or exclude tags they are not interested in). The system is up to you, but it's basically an additional load on your article list query since you join it to the tags table or do an asynchronous filtering...it's a heavy operation in practice. If you want to get fancy, you can have the article contextualized (scanned for keywords) using existing terms or a wider array of terms (like a noun dictionary) and suggest or auto-create tags + user defined tags. 
Made this change based on feedback from first article. Should make injecting the instances underlying Facades much simpler! Very beneficial for those who prefer to stick strictly to constructor injection.
Well yea... 5.4 has everything other than finally, generators and a few other fixes... that's sort of how "minor" revisions work (though its hard to call these minor revisions).
[Permalink to actual response, not blog frontpage.](http://taylorotwell.com/response-dont-use-facades/)
For me it depends on what it is - I know my base tools/frameworks well and have to refer very little to certain bits. If it involves a new/obscure API/Service I'll charge for it, but if it involves me hitting php.net I won't.
Personally, I'd write a small daemon in Python that gets those stats and opens and API for your PHP script to make calls to that. Opening up a shell (even if it's super secure etc. etc. etc.) seems really dirty/bad ideas brewing.
Hey, I have a quick question. I'm new to building websites, and I'm considering using Bolt for a site I'm doing. Basically I've built all the front-end of the site, and now I want to build it into a backend/CMS that will allow my client to manage her own content without diving into the code. My question: Where should I look for info about making the website (the site itself but not necessarily the CMS) multilingual? Bolt documentation? Symfony documentation? 
That wasn't really my point.. my point was that there seems to be an assumption that "framework only devs" who "don't know the language" are somehow causing damage. They can only cause damage if we as professionals let them. 
Here's the original article / discussion: http://www.reddit.com/r/PHP/comments/1v0p6h/stop_using_facades/
Bloody brilliant ( said with British stiff upper lip lol )
Lucky guy. Sadly, I do. And trust me, it can fail for topics like that. I've seen whole companies stop building product for a year to wait for the application to be rewritten from scratch, because the code messed up in such a way that developers can't build features at the pace business guys demanded. The reason was not following industry best practices, and take the "quick-and-dirty-way-because-the-focus-should-be-to-make-money-the-fast-as-we-can" way.
This is great and really appreciated, thanks. Is there a simple way to type-hint to interfaces too, without writing an adapter class?
I miss an explanation about why rely on static calls is a bad practice, the problematic it lies behind using them and why should be avoided.
&gt;Pux exists because we want to reduce the energy we use, produce lesser CO2 and make our environment better. Seriously?
Static calls are basically the global problem all over again. Sooner or later if you are over using static calls, you'll need state. So that state will also need to be static, now you have an over arching global state tied to that class name that can be accessed and changed globally. The other issue is that overusing static calls destroys two principles of good Object Oriented principles called [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29): in particular the Liskov Substitution Principle and the Dependency Inversion Principle. That is calling out a static call in a middle of a method, it makes it damn near impossible to swap out the underlying implementation with another implementation. Which makes reusing code much more difficult. It also makes testing much more difficult. The last part I'd like to highlight, though this has little to do with how Laravel uses it. Overuse of statics is a red light of not understanding OO principles. It basically allows authors to drip down into procedural thinking. Rather than keeping and manipulating state in objects, they are still trapped in procedural programming paradigm by maintaining state in global/yet namespaced containers.
*Here's a bit from linked Wikipedia article about* [***SOLID (object-oriented design)***](http://en.wikipedia.org/wiki/SOLID_(object-oriented_design\)) : --- &gt;In computer programming, **SOLID** (**Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion**) is a mnemonic acronym introduced by Michael Feathers for the "first five principles" named by Robert C. Martin in the early 2000s that stands for five basic principles of object-oriented programming and design. The principles when applied together intend to make it more likely that a programmer will create a system that is easy to maintain and extend over time. The principles of SOLID are guidelines that can be applied while working on software to remove code smells by causing the programmer to refactor the software's source code until it is both legible and extensible. It is part of an overall strategy of agile and adaptive programming. --- [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/cythrawll can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(*how to summon*: **wikibot, what is something?**) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/PHP/comments/1v2s1b/response_stop_using_facades/ceoc8bs)
Yes, This is what I don't get. They talk as if this issue is only relevant to testing the controllers classes, as if static calls cannot be made from anywhere else. Edited for clarity. 
You hear about it with testing because that's the most common place you'll run into issues with Liskov Substition Principle violations. but you'll run into the same problems when trying to reuse the classes in different contexts. Which is something you should strive for when developing code is making things reusable to prevent repetition. Also you'll find issues if you ever have contention between state changes in unrelated code if you're over using static state.
I'm guessing the typehint is an interface which is not something that can be instantiated anyway. So there must be some kind of mapping to the concrete class. Not sure where that happens though, and on my phone so it's hard to look. 
Yes, the auto-wiring magic comes for free, but you can configure the container to use a particular implementation for a particular service.
Yes. I know it. That's why I miss a formal explanation of all of that in the article. Mainly because someone could misuse the usage of static calls and think that it's a best practice, from the article, even out of the scope of Laravel.
I don't get it. Maybe I'm missing something, but here are the things that bother me. What's it do? Like, I get how it works, but what I don't really get is what difference it would make.... not... having... flat. It just seems to add little or no utility. In fact, what it seems to mostly add is ability to render templates. So it's not really for creating apps at all, it's just a template engine. In point of fact, I would think that about everything being done here could be done more effectively by just installing Twig. Also, the whole "quick flat apps" thing... I'm not sure that's such a good idea. I mean, we've moved in a front controller direction in general, and it just seems to me that there's actually a good reason for that. It makes smaller, more maintainable, more extendable apps. I'm just not seeing the benefit here. If anything, it seems like a few steps backwards.
The Magento1 routing system is incredibly complex but is incredibly extensible. It could certainly benefit from something like Pux.
This is my main gripe with Laravel. If the framework is being a bitch to work with in all IDE's, it's doing something wrong. The purpose of Facades is to make it easier to develop with, but then the whole framework is riddled with magic calls the editor cannot possibly guess the outcome of.
So will this mean we can essentialy bypass array_merge() with array() at least for non-key'ed arrays? $a = [1,2,3]; $b = [4,5,6]; $c = array_merge($a,$b); $d = array(...$a,...$b); var_dump($c == $d); // What would this output, true?
"Readability enhancers".
now show me how to configure it without the facade!
[CandyCane](https://github.com/yandod/candycane) is a port of RedMine to PHP, but laundry and to do lists don't really count as project management.
&gt; Route::get('/', 'HomeController@showWelcome'); why a string when you can avoid it?
I learnt C# before PHP. I am a PHP developer day to day, but I found that I learnt a lot about programming and computer architectural concepts in C#, where as in PHP you don't "really" need to know too much, PHP does ALOT for you. If you want to be a better developer, C# &gt; PHP
To avoid it, you would need to route to a callable. So, you can: - use a Closure within which you manually instantiate the HomeController and then call the showWelcome method - Manually instantiate the HomeController and then pass in that with the method as a callable `array($homeControllerInstance, 'showWelcome')` Neither of those are great options, simply because you lose the auto wiring magic of Laravel.
No, because it's not a generic word. It's a very specific pattern that was originally identified by the [Gang-Of-Four](http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612). It's a compositional pattern with a very specific relationship between the facade and those that do the work. Check out [sourcemaking](http://sourcemaking.com/design_patterns/facade) for a good free description of it. Laravel's system behaves more like a [proxy](http://sourcemaking.com/design_patterns/proxy), where one class is representing another (including some location or lazy instantiation components). A Facade, by very definition, is a simple abstraction of a complex system for limited use-cases. So no, what Laravel calls a Facade is most definitely **not** the Facade pattern. It's **maybe** a Proxy, but it's definitely not a Facade... 
&gt; Python needs the passwords to SSH to various machines to send commands. Do they? Can't you set them up to use SSH-keys? If so, they wouldn't need to know the password at all. 
If you want to know about auto-updating and security, you really should talk to Andrew Nacin, lead developer of WordPress. I spent a few hours talking to him about lots of things during the Joomla World Conference back in November, one of which was the new 3.7 WP auto update feature. We were reviewing numbers etc and I was simply blown away. Andy showed me stats from one batch of auto-updates. Over 900,000 WordPress installs attempted to autoupdate and all but 18 succeeded. That's a 0.00002% failure rate. Wow. Out of those 18 that failed, not a single one broke the users website. That's impressive. What WordPress lacks in OO architecture, it _more_ than makes up for in product stability and ease of updating. 
I wasn't sure of the correct verbage. I did finally try mytinytodolist, and it is really nice.
I wasn't saying it was a generic word, but rather that it follows the specific descriptions of the pattern as provided by Wikipedia. I wasn't sure where else to look for examples or definitions. Thanks for the link to SourceMaking. It does provide a clear outline and definition of the Facade Pattern. After reading that, I still think Laravel meets some of the items on the checklist, but not all. The main thing it doesn't do that is described in the pattern is the wrapping of multiple objects. Facade is a good generic term to describe what it's doing, but as you said, it doesn't follow exactly and specifically the Facade Pattern.
I am almost complete it I just have two more functionality deliverables I want to get done i.e. this and my FTP/SMTP for emails. I have no problem visualizing where I want to go with it, just don't know the right technologies/methods that will fit my project :/
It's either "0.00002" or "0.002%" ;-) Regardless, those are impressive numbers. I'll take a closer look at how they're doing things. Thanks. 
&gt;A facade is an object... Laravel facade is not an object. Right? They are just a set of namespaced functions. 
I did originally use wunderlist, but for fun, and entertainment value, I wanted something I could install on my pc. I do like Wunderlist, but in the months since have migrated to legal notepads, now I got an local my eyes only to do list system. Thanks for the help, and thanks for the smile :)
Ahh you're right. MOAR COFFEE!!!
$app-&gt;bind(...).
Well, I don't know about an adapter class. But you would at least have to register a binding so that the container knows which implementation of the interface you are wanting.
$app = new Illuminate\Foundation\Application;
No matter how I write this, it's going to be read as snarky, when my intent is only to illustrate. So: &gt; In the context of Laravel, Facades are what you are using when you make what appears to be a static call to a class. Calling a "static call to a class" a "Facade" when "in the context of Laravel" is like calling a "Yugo" a "Ferrari" when "in the context of GM." &gt; facades are syntactic sugar for service location Then they're "static service locators", not Facades. I mean, I get that you have settled on a particular terminology and feel justified in its use, but that's just not what a Facade is.
I would not agree, the Facade usually is created to merge several classes into one easy to use interface. Laravel's Facade doesn't do that. instead it mirrors a class' interface for the purpose of service location only. It's basically using the global namespace as a service locator. &gt; make a software library easier to use, understand and test, since the facade has convenient methods for common tasks; It makes objects software library easier to get ahold of, but it doesn't really make it any easier to use, makes it more complex to understand, and if misused makes it harder to test. &gt; make the library more readable, for the same reason; Static calls does NOT make it more readable. &gt; reduce dependencies of outside code on the inner workings of a library, since most code uses the facade, thus allowing more flexibility in developing the system; since facades usually only represent one object, it doesn't really do this either.
Ah, a fellow caffeine abuser! *raises cup*
I don't advertise it that much, but that's my perogative. That declaration is at the very start of the basic bootstrap file of a Laravel application. Every developer goes into that file to set their environments.
&gt;Andy showed me stats from one batch of auto-updates. Over 900,000 WordPress installs attempted to autoupdate and all but 18 succeeded. I'm curious as to how those stats were collected. Was that deduced from HTTP logs, or does wordpress call home upon downloading and installing an update? 
See what I mean? I'm addressing you directly in the first comment you make about the article, so that we can (hopefully) have a discussion about it, since I didn't see a comment space on your blog, and your first response is to disparage. EDIT: I see you edited your comment after I replied; probably "two ships passing" kind of thing. I'll do that same: &gt; I probably should have chosen a better name. /me nods Getting names right is one of the two hard problems. &gt; developers are smart enough to realize they were two different things. Maybe, maybe not. There'd be even less possibility for confusion by calling them what they are: static service locators. It may not sound as sexy, but it'll be more accurate. 
composer create-project laravel/laravel, open public/index.php and follow the include trail. Reading source code is a pretty useful skill.
I just came across a real world example today and it reminded me of this conversation. I created a script that should have been built into a phar archive. However the production system does not have phar (php 5.2, yes i know it's ancient, i'm the one upgrading all the systems). It would have been nice to catch that fatal error and be able to deal with it then. Yes, i know there are 100 ways to deal with this (class_exists), but that seems like a perfect area for an exception to be thrown and dealt with.
I'm sorry to disappoint you.
Well, if it doesn't call home when there's a failure, I suppose you could always check if the next update check contains the same version number as before the download of the update. The information is in the logs, it's only a matter of successfully interpreting it. 
Or, it could simply be that when there's never a "upgrade completed" ping, the server assumes the upgrade failed and the install got broken. 
That also crossed my mind, but wouldn't the table get really big, really quickly, and would that be an issue?
Sadly, Joomla does not. There have been many discussions about it over the years, but there is a vocal minority of tin-foil-hat wearers in our community thinking that the project could somehow abuse PHP version information. I'm in the process of creating a stats collection mechanism to distribute with Joomla, but until we offer a compelling reason to the end user to enable the feature, I don't think it will be enabled by many. Slightly off topic, but you can check out the start of my plugin / server stats combo here - http://jstats.dongilbert.net
Seconding that I don't see what this does that PHP doesn't already just... Do. If I need a templating engine, PHP already is one. 
It will only grow large if you have many user groups. If that's the case, you could optionally add a enum('allow', 'deny') field and implement basic permission inheritance for user groups, but by that point there's probably a simpler solution.
&gt; Figure out WHY. Thanks for the link. Good one. 
This is what I'm having trouble getting my head around, most of the fatal errors can be avoided as long as you code correctly. This was why I was asking for real world examples so that I could at least make my point. As you say, you could have used class_exists to check if the library exists, which you're supposed to. Another way to handle script failures is to fork child processes (http://uk3.php.net/pcntl_fork) and then check what error happened, if it died prematurely. 
Why?
Honestly i see this as a bit of an improvement in syntax (which is really most of what a language provides). Trying something and catching exceptions seems a bit nicer to me than checking for every error before hand. In this case i have to use class_exists, then make sure that it was actually the PHAR class and that it is actually doing what i want it to, rather than just try to do it and catch the exceptions i'm expecting, and let the rest fall further up. In the end improving the language and giving a person more freedom to code things in more intuitive ways only helps (I mean even Brainfuck is touring complete!). As for forking a process, I'm not going to touch that with a 9 foot pole for this. Forking a process to check for fatal errors seems WAY to complicated for a web facing program to do (not to mention all the headaches and complications that come with using it correctly)
Yeah, having exception handling for fatal errors seems to be what people want. I've only ever used forking in billing systems. To be honest I'd rather see stricter type hinting and return types. 
I don't understand. Route::get('/', function() { HomeController::showWelcome(); }); How is this not a great option? For starters, you get the benefit of knowing whether it will work or not before you run any tests because any decent IDE (or a well configured emacs/vim) will tell you whether or not these classes/methods even exist. Secondly, the code is cleaner, as it uses proper syntax. @ is PHP for "supress errors", not a class/method delimiter. So this string "HomeController@showWelcome" doesnt' really mean anything. Is showWelcome a static method or an instance method and by using @ does it supress errors? Who knows... Thirdly, I can't autocomplete strings into valid class or method names. Which means I need to refer to other files to figure it all out. Using this concept on a language that doesn't explicitly need it will make you lose all your sanity. I'm a PHP programmer or a Java programmer? Losing sanity hurts productivity. Simply put, PHP does not need strange, oddly formatted strings, to represent class or method names. It's simply an inconvenience that is only necessary in the languages that need it. PHP, python, ruby, etc, do not need it, so why use it?
&gt;stricter type hinting and return types. I agree on both accounts. However from the looks of the dev-scene neither one is coming until at least php 6. Until then at least we have code linting services that can parse PHPDoc blocks and warn us of incorrect types outside of program execution.
The reason that's not really an option is because you turn your controller into a simple function, instead of part of a class with injected dependencies. Laravel's IoC container can't inject your controller dependencies into a static call like that, so you're stuck with using Facade's inside of your controller method. (You can't use `$this` inside of a static method.) So it's overall not a very good solution.
Your call is static, and does none of the required controller instantiation. Also, "HomeController::showWelcome" is callable
Imagine you want to read data from different sources. Let's call them DataSource. A data source always needs two methods for our purposes: hasData and getData. Now imagine these data sources have nothing to do with one another: one source reads from a file in the hard disk, another one fetches data from a database, and a third one fetches it from an online API. Now the object which handles different sources doesn't need to know about the implementation details of every source. It just needs to call the defined methods, but it needs them to be in place. So it could go like this: interface DataSource { function hasData(); function getData(); } This defines how a data source should work. Now let's implement some of the data sources: class FileDataSource implements DataSource {...} class DatabaseDataSource implements DataSource {...} That's cool. You could also have different APIs, which have some common functionality, like building the HTTP connection, so now we could write the common basis for API-reading sources: abstract class ApiDataSource implements DataSource {...} And the specific implementations for the APIs: class GoogleApiDataSource extends ApiDataSource {...} class BingApiDataSource extends ApiDataSource {...} This specific API implementations don't explicitly implement the DataSource interface, but they do implicitly as their parent the abstract class ApiDataSource does. So, finally, our data consumer: class DataConsumer { function addSource(DataSource $source) {...} } Now addSource accepts *only* data sources. That's good, because you know they will have to implement the methods you need from them. In the future, you can add and remove data sources, but having a fixed interface (API), you know they'll be compatible.
Don't worry all the CI converts are used to it with CI's active record class.
Yes, `is_callable('HomeController::showWelcome')` is callable, but when using that as the syntax of a callable, the call is actually made statically as well. Same with passing two strings to the `array('Class', 'method')` type callable, it's made as a static call, without object construction. Source: Example #1 here - http://www.php.net/manual/en/language.types.callable.php
I agree. My "Also" comment was directed at the use of the anonymous function wrapping the static HomeController::showWelcome() call.
This isn't a job board. Please don't post these job postings here.
&gt; You said you played this, did you write the solution in C extension? &gt; Yes, of course ... if I hadn't it wouldn't be relevant would it !? &gt; Also this project didn't claim that routing is the bottleneck. &gt; On the hackernews thread, someone said that this is a good idea because "routing is the bottleneck" .... like I said, if that's the case you are doing it wrong; good routing, well thought out routing functionality will not need to be written as C. &gt; Pux is just to reduce the overhead of routing. &gt; I don't see it ... and I've explained why ...
Edit (added at the top because I felt it was quite important): Whatever mechanism you use, if you have RBAC, I suggest you to create a group for the non-authenticated users, because you can use the permissions to configure what they can do. (original message starts here) It all really depends on what you need. A powerful permission system could allow you to store not only boolean values but integer could also be of great use. For instance if you have a private messages module, maybe you want to limit how much conversations a user can create. Or for an upload system you could limit how much total data the user can upload (50 Mb), which also is an integer. Or if you have a discussion board (forum) you could have a numeric value to restrict a user posting 2 consecutive messages within a certain amout of time (to prevent "upping" a discussion). I like to handle all of that in the same permission system, because it really is that in the end. Combined with RBAC (Role Based Access Control), you end up having: "role_id", "name", "value". Role &amp; group are quite the same, it's just a matter of conventions: we usually speak of "group" when a user is only assigned one group and we usually speak of "role" when a user can be assigned several ones. Bonus: if you have a centralised category system (with or without hierarchy) you can even plug that in (but you need a good UI after that if you don't want to get lost).
Seems like you've been looking for a while already. Finding someone good is tough, though. I don't know if you're planning to do so, but you should go to the [PHP Benelux](http://phpbenelux.nl/) conference and/or send your developers.. If your company is good to work for, your developers will do the recruiting for you. Perhaps you should sponsor local PHP usergroups by hosting an event or supplying drinks? I know [SweetlakePHP](http://www.meetup.com/SweetlakePHP/) or [010PHP](http://www.meetup.com/010PHP/) would appreciate that. Getting involved in the community really pays off in the long run. 
We are actually considering using Embedded Composer to build an installer for the next generation Joomla CMS. Our current installer is complicated and a bit of a pain and replacing / extending it with Composer would be awesome.
RBAC is what you are looking for: http://en.wikipedia.org/wiki/Role-based_access_control They can be pretty complex to use/create, so might be a good idea to look around at other third-parties.
*Here's a bit from linked Wikipedia article about* [***Role-based access control***](http://en.wikipedia.org/wiki/Role-based_access_control) : --- &gt; &gt;In computer systems security, **role-based access control** (**RBAC**) is an approach to restricting system access to authorized users. It is used by the majority of enterprises with more than 500 employees, and can implement mandatory access control (MAC) or discretionary access control (DAC). RBAC is sometimes referred to as role-based security. --- [^(**Picture**)](http://i.imgur.com/7lQ0ak9.jpg) [^(image source)](http://en.wikipedia.org/wiki/File:RBAC.jpg) ^| [^(about)](http://www.reddit.com/r/autowikibot/wiki/index) ^| *^(/u/gearvOsh can reply with 'delete'. Will also delete if comment's score is -1 or less.)* ^| ^(**To summon**: wikibot, what is something?) ^| [^(flag for glitch)](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=bot%20glitch&amp;message=%0Acontext:http://www.reddit.com/r/PHP/comments/1v41ii/storing_users_permissions/ceomlg4)
Out of curiosity, I figured that I would have had to set up a cron job or something for Wordpress to automatically update itself, but I didn't. I presumed that what happened was that the main WP site 'pinged' my installation when a new version was out, triggering it to start the download / upgrade that way. Although now that I think about it I guess this 'reach out and upgrade' could be triggered by any visitor to the site. Is that how it does the update without a cron, or is something else going on that you could explain please?
Incorrect. We allow job postings if the job is telecommute and interesting.
It's a part of the documentation I read, and forget. The way accessing Facades works hides the implementating class behind it in such a way, my IDE isn't even able to resolve/autocomplete the class. I've been instantiating objects myself in the controller, however whilst writing them I realized this makes unit testing of my controllers much harder. Constructor injecting looks like the best option for use with Laravel. I agree the documents should note that this is the best practice. Perhaps its in place to create a pull requests for the docs which mention this? Out of scope of the Facade discussion, I really found Laravel a great framework to develop in. It doesn't get in my way and is very extensible.
Nice post. I agree it's more wise to deliver a solid architecture, rather than clamping on a design pattern.
Your local Wordpress install pings the main site, and that notifies it of any available updates. Not the other way round. 
That's a helpful addition. Thanx. Just out of curiosity (probably doesn't come up so often, but)... does a child class inherit the interfaces of it's parents?
job isn't telecommute, though (and requires knowledge of C#).
Here's at least one comment not related to performances: I don't like how controllers are resolved: $mux-&gt;get('/get', ['HelloController','helloAction']); Here, if I understand correctly, `$mux` will be responsible for instantiating the controller. This is not very good, it prevents making use of a dependency injection container (for example) to inject dependencies inside the controller. Symfony has the concept of "controller resolver", which let's you implement alternative if you want to customize how controllers are found and instantiated. *I know one could use anonymous functions, but in a real application that would be overkill*
The problem is I think this would be a pretty fundamental change on how Laravel is documented and taught. I think the decision should be determined by the Laravel community. Unfortunately until this is fixed I can neither recommend nor use Laravel, even though I think it's a solid framework underneath the facades, I feel that the practice that it teaches goes against some fundamental OO development principles that I do not wish to encourage. Maybe an all out fork would be a better idea....
Theoretically yes, sometimes they creep into views and models too. This stuff all makes "hack projects" so much easier. I go back and clean shit up when its making a little money. :)
I assume their static usage was different to this. If those projects were architected on top of "Static usage is quick and clean" then I can absolutely see that being a clusterfuck. If you're using Laravel and you decide to save a little time using the Facade instead of injecting shit then its not a MAJOR task at all to go through and IoC things into place. General static use !== Facade static usage, as the original article points out. :)
I can see a reason for that. However, Laravel has a great community and ecosystem already. It's pretty hard to fork that.
Can you expand on "it's not that hard to remove yourself."? I mean, I understand it's quite simple to inject the dependencies into the constructor of my classes, but if I am doing this into an app that initially used facades, don't I have to locate hundreds of facade calls and convert each and every one from {{Facade}}:: into $this-&gt;{{dependency_variable}}-&gt;?
I too have my own cms and have been considering writing an open source installer, not just to run updates but also for plugin installation. I've started spec'ing it out and to do it properly with security constraints, handling modification of files, chunking/patching modified files, file permissions, handling sql updates, interacting with repos etc, is a lot of work, but well worth a decent community effort. If you are thinking of making an open source component library yourself, count me in. Send me a pm or something as I would love to collaborate on it.
It is good to see discussions like this popping up, as Laravel has definitely fallen victim to rabid fanboyism from various members of the PHP community while the betas were progressing, which really prevented these from taking place. The use of 'facades' is one of the parts of Laravel that always rubbed me the wrong way (same with logic being within the routes, but that's a separate discussion). That's not to say it's not a great framework for many people. Taylor has done a great job making PHP more accessible for developers who may not be ready to dive into something as complex as say Symfony or Zend, and he should be commended for that.
One function you could use is usort. The second argument is a callback. There you can create your logic to compare the roles. An example being: $roles = array_flip(['admin', 'manager', 'user']); $users = usort($users, function($a, $b) use ($roles) { return strcmp($roles[$a['role']], $roles[$b['role']]); });
PHP is alright if you have to quickly grab some data from the database and put that into template. That's the purpose of PHP, nothing more.
I think (but I warn you, this is already "religious" territory), if you need to add "abstract" or "interface" to your identifier, then you are doing it wrong. It should be mostly obvious (or irrelevant) when you read it. Comparable is a great name for an interface. It's an abstract concept, it doesn't look like something you can instantiate. The same with seekable. They just guarantee features of the implementing classes. Functions which take these interfaces as parameters don't care sh*t what they are. Quicksort function takes your array of whatevers and just sort the shit out of them. As long as they are "comparable". This is great because the sorting code is written once and reused everywhere. Otherwise one could end up with "sortPeople" and "sortNumbers" functions. Anyways, I'd take "sort(*comparable)" over "sort(*ComparableInterface)" any day. 
RBAC+ LDAP = The One Proper Way ^tm use LDAP to store everything and anything about the users, and create groups to express roles. Add users to roles, and then query (at very high speed) which groups do any given user belong to. I make heavy use of array_intersect() to know if the user is allowed to reach a certain URL for example. LDAP is quite easy, has a ton of tutorials and code and is the way most serious software does users/perms. I use openDJ and it's small, rock solid and free (java, so it's cross platform). The usual suspects are openLDAP , apache DS, RedHat Directory Server etc.. Oracle, IBM, MSFT and everybody else have LDAP servers, free or not. There are lots of GUIs to manage them and most, if not all, are completely interoperable. IMHO of course :-)
Inspired on CakePHP's [Hash::nest()](http://api.cakephp.org/2.4/class-Hash.html#_nest) $ids = array_keys($array); $nested = $idMap = array(); foreach ($array as $id =&gt; $object) { $nested['children'] = array(); $parentId = $object['parent_category_id']; if (isset($idMap[$id]['children'])) { $idMap[$id] = array_merge($object, (array)$idMap[$id]); } else { $idMap[$id] = array_merge($object, array('children' =&gt; array())); } if (!$parentId || !in_array($parentId, $ids)) { $nested[$id] =&amp; $idMap[$id]; } else { $idMap[$parentId]['children'][$id] =&amp; $idMap[$id]; } } unset($nested['children']);
Big fucking deal.
if you're connecting via SSH, creating a SSH-Key is the way to go. [https://help.github.com/articles/generating-ssh-keys](https://help.github.com/articles/generating-ssh-keys)
Cool, I've been doing it wrong for the last decade. I'll have a think about my life.
There are two reasons to switch from Facade and its static calls, to DI and its injected objects. 1. That warm fuzzy feeling of having well separated code 2. Unit-testing If you're trying to unit-test that code, then you'll be doing it one method at a time. Each time you spot a static call, you can change that to the DI approach and make sure the test is green. So, that's not tough. Just doing it for the sake of it (without unit-testing) sounds like a massive waste of time, and mostly just code wankery. 
Except it's actually out of order in ascending. The example I gave is probably poor. I need to select how the data is sorted manually.
I was starting to look into this for a project myself and bookmarked this to read later. I never got to reading it so unsure of it's value but it may be a pointer in the right direction http://www.tonymarston.net/php-mysql/encryption.html **edit:** The other idea I had was to mcrypt the passwords with the user's password + string being the key so when they wanted to make changed they had to enter their password and that would unlock the encrypted data allowing access to the passwords
You're right, I meant to remove it when I replied! Thanks.
A valid point, but the big frameworks still want to be called full-stack frameworks, for business reasons.
Well, sooner or later they wont be able to exist. Composer and strong components as well as improvements to the core of the language will see to that.
This comment has been linked to in 1 subreddit (at the time of comment generation): * /r/programming: [The state of PHP: Laravel framework creator redefines what a Facade is ... because why not?](/r/programming/comments/1v568o/the_state_of_php_laravel_framework_creator/) ---- This comment was posted by a bot, see /r/Meta_Bot for more info.
Good post Phil, I think this topic shows we're heading in the right direction with much of the community moving away from full stacks. ZF1 was always a component library named as a framework as I think at the time there was no better naming convention, a basic bootstrap was provided but was fully extensible in the way we might throw together components now, the problem as you pointed out was package management, we even resorted to extending many of the base packages to provide small changes to fit our needs. The "build your own" mentality some of us have now has been a god send (at least to me) but I'd agree that this approach is not for everyone, you have to know your tools pretty well to execute it properly.
I strongly disagree with that. Composer is a dependency manager, for managing your applications dependencies. These dependencies are components, which need to be bootstrapped, initialized, etc. A framework ties all of that together. As I said, you'll either be building your own framework, or using existng ones, but these "sample application layers" are not going to vanish. 
Framework is defined as "an essential supporting structure of a building, vehicle, or object." If "object" is your app, then I don't see why components and libraries aren't also part of the essential structure of the app, and so must be considered part of the framework. Granted, you don't have to use the bundled ORM or other component, but the framework developer definitely intends the whole package to be used as a single framework to build your app with. Now, if you take something like Laravel and add some of your own or third party components, you've extended the original framework. The whole thing becomes the framework you've built your app on, a custom Laravel stack. Virtually every complex app will be a custom framework of some kind. I just don't buy that the architecture is the framework. It's only a small part of the code base used as the structure for your app.
The problem I have with a lot of framework perceptions is that frameworks are the future or that they're the best method for development. I can accept that not everyone wants to be a programmer but don't dissuade people from learning more than the minimum. 
I like that. Thank you!
Okay, thanks!
I found this two part article by Oracle about MySQL sharding and PHP: http://www.oracle.com/technetwork/articles/dsl/white-php-part1-355135.html 
I also found this article on load balancing: http://1wt.eu/articles/2006_lb/
What a load of shit. Seriously can we be done with this "php is just a template framework" fallacy?
I have to say I strongly agree. As great as Composer and modern frameworks are sometimes you just need to bang out a quick CRUD site without spending fucking hours trying to get Vagrant working before you even get to Composer, (I realise the two aren't required together of course, it's more the current correct way of developing I'm referencing). Despite what some high minded code purists think, I think there will always be a place for more 'full stack' frameworks, for both quick developing and beginners. What is interesting is the form they're going to take. Probably a small set core then options for pre-approved modular components that can also be installed that you know will just work. Similar to the jQuery setup I guess
I don't understand this PHP almost exclusive idea that everything needs to be broken down to bare minimums. Premature optimization KILLS projects. Trying to break something down something into just the parts you need sounds great, but then you need to add that feature, then this feature, then the next. All the sudden spaghetti code. You want to know why so many PHP devs are changing langauges? It's not because PHP has it's flaws. It's because every damn PHP coder thinks they know 'the best way' to organize their code, so when they come along to fix your crap they spend three days trying to find where you hid the files in the first place. The best thing frameworks do is standardize code structure imho.
That's what I got from the parent. I guess my question is: what triggers my Wordpress install to ping the main site? It's not a cron job, so is it a random page load triggered by a user visiting the site?
Yes, going more general in you arguments makes your classes more loosely coupled, which is a good thing. It makes code more reusable. I'd take it even further and say, don't couple objects at all if it's not necessary. For example, I'd take this: public function greet($name) {...} // name as string over this: public function greet(Person $person) {...} If I only need the name. Makes code more interchangeable and also easier to unit-test (less mocking around) [edit: and easy to refactor! Less dependencies.]. Like everything, don't take this too extreme. If you really need a certain class / type, do enforce it. Edit: interfaces provoke more coupling than primitive types, but less than classes. [ More coupling ] class &gt; interface &gt; primitive [ Less coupling ] The more specific the type you require to be passed, the more tightly coupled are those parts of the application.
Well you are wording this as "library good" "framework bad", which to me seems rather odd. If you implement a front controller at all,, then your requests are going into a black box. Use a router? Still a black box. Controllers? Yep. That's a framework. They're not good or bad.
My definitions: * Framework Reusable set of classes which give the developer the foundation(core) of a project. It's just boilerplate code. The business logic shouldn't depend on it. Can be reused for other projects. *Examples of stuff that belongs to a framework*: front controller, routing, session management, caching, form validation, template engine ... * Library Packed set of classes used for specific work. Usually does one thing. Is a project dependency and it's usage is project specific. *Examples*: file I/O library, image manipulation library, *some service* API library ... With all these modern frameworks and their loosely coupled components (the goal of PHP-FIG (I think)), one might get to a point where he can choose from a range of their components, and bundle them together to build a framework. 
I'm a bit confused, and this is a real comment/question, I don't mean to be a troll: You mean the *frame* that holds those components together is PHP?
I tried to use an analogy. Apparently it was bad. In this analogy PHP is probably "physics", but fuck it, I'm out.
Yeah that is great when you have fuck all code, then when it grows you're going to want to split that code out. When you want to split it out, you need a router and and controllers. And a base controller, which puts things into a folder structure. And that is a framework. :)
[This answer at Stack Overflow](http://stackoverflow.com/a/9685039/250259) explains in depth how to handle ACL.
You have been shadow-banned by Reddit: http://www.reddit.com/user/philipobenito /r/php had nothing to do with this, and we are unable to help you with this issue. You should contact the reddit admins to unban you.
I think accurately determining when a one-off project will actually be one-off is one of the traits of a mature engineer. Damn it's hard.
My condolences. PHP and many of the companies who use it will still be here waiting for you to escape the oppresive environment you're now subjecting yourself to.
&gt;Not a single person started programming at a level that you're expecting newbies to understand. It you don't have some sort of guidance, you might end up staying at the newbie level for years. This guidance is what we are all talking about. Lot of developers does not read much other than their frameworks documentation. Laravel has gained a lot of popularity by being user friendly. Now I hope it leverage its popularity to educate and advance its 'newbie' users. Not by restricting them by removing features, but by properly guiding them to better practices. Laravels documentation is the best place to do this. Where I work, no one reads forums like reddit or actively seek knowledge. Things like dependency injection and automated testing are 'unknown unknowns' to them, and most of them have been coding in PHP for the past 8-10 years. But they have to read the documentation of the framework they are using. There is no escaping that. Right? So if Laravel put some good advice in its documentation, it gets read by people who really need that. They might avoid it for a while. But as they are frequently exposed to these things, they might end up wanting to know more about these, and start learning on their own. It is the initial push, that Laravel, and only Laravel or something popular like that, can provide. &gt;Ship code and chill-the-fuck-out.. Shipping code is easy. Try maintaining that shit! 
Throwing in a another voice in favor of SSH Keys. If you've got SSH already on all the machines, it's a no-brainer. Python won't even need to know that the key exists, PHP won't need to hold any passwords, you just need the private key on the "master" (control machine) and public keys on the "slaves" (configuration receivers), and it will be able to SSH all day long without both public and private halves living on the same machine. You can set up unique keys for each machine you need to get into if that helps increase security. With an SSH config file, it's easy to say "log into this host with this specific key".
Yea, if you are a good programmer, you can limit the initial damage so that you can go back and 'clean shit up'. Because you know how to balance good practice and getting things done. But for someone less skilled, it might end up being unmaintainable to an extent that he may find himself at a dead end when the business requires him to change something. And the things like this, use static calls instead of constructor injection, how much time do you think it can save. I don't think it is much. It is often a matter of convenience than saving time. It is inconvenient to recall what couple of files you need to change and open them and add a couple of lines, than just issuing a static call. It really does not save much of anything worth saving.
Yeah so the point is when you've implemented all of those libraries to create an architecture then that is your framework. Your application layer is your framework with all of your domain/business/etc login in there. Still a framework. Still using libraries. Not at any point a weird black box.
Sure it can. I wanted to access an input variable in the pagination handler for an API, and that logic was in the base controller. My iPhone developer wanted me to get pagination done so we could hit the sprint deadline and shit out a dev build to use over the weekend. Injecting it would have required fucking around with the base controllers, and changing the signature for every single controller instantiation of which we had about 20. That sounded really fucking boring, so I shoved in a static call. My begat endpoint tests worked. The iPhone build worked. I refactored it later. It was an arse but I got there. Perfect. I talk about these things because they have happened. I'm not just making shit up. :)
Just to add to your original comment, WordPress does not just use "FTP brr", it uses several methods with fall-back including direct file and SSH (if enabled), the FTP part also includes 3 fallbacks in of itself (FTP ext, FTP socket and SFTP). I run lots of sites with no FTP access and direct file works like a charm. http://codex.wordpress.org/Filesystem_API
I hoped the point would be clear: educating developers as to why making (and believing) polarised comments about a generic and regularly misused term can be damaging.
Oddly, your example proves my point. You did the static call, NOT because the alternative will take a half day to complete or It is a change that might introduce new bugs, but because "That sounded really fucking boring". Right? So at the end, it has not really saved you much, but a bit of inconvenience. It is easy to overlook the refactoring later, if you end up doing some other urgent requirement which will take two or three days to complete. &gt;I talk about these things because they have happened. I'm not just making shit up. :) Same here :)
I said that implementing that one call as static instead of working out a way to inject it and have all my constructor signatures break saved me an hour or so, which helped me hit a deadline and get a build out. I think that is pretty important. That is saving time. You said it didn't save time. So it saves time. Because it saved me time. Because it was faster than doing it a slow way. And faster means quicker. Because quicker things take less time. 
TheDailyWTF community would enjoy this tutorial.
You use "another persons" as a very large part of your definition of a framework. When I helped build FuelPHP it was still a framework, even though I built a chunk of it. Why is the origin of the code such a large part of the definition of it? :)
I'm not sure I prefer that over using Guard, I prefer to just have PHPUnit tell me immediately when I click save if a test passed or not, instead of having to rerun stuff anyhow. http://blog.james-carr.org/2012/09/09/using-guard-phpunit-for-great-good/ That said I suppose this will do a better job of alerting me about tests that could fail due to a change that aren't directly related to the file I just edited, so that sounds cool.
&gt; These dependencies are components, which need to be bootstrapped, initialized, etc. Can't a DI container do that?
That's how I talk, I use a little artistic license to liven up what is otherwise a very mundane conversation. I understand the concept of technical debt. I understand that writing code well initially is better than writing bad code initially. You also understand that shortcuts are often handy in the interest of short-term gains in functionality, and can be revisited later. So I'd say we're done.
A framework should be, a directory structure and a documentation with guidelines regarding what should go where and how to build applications in a certain way. In otherwords, A framework should be a collection of concepts or ideas, that can be used build an application, instead of a collection of components. A framework should not be a collection of hacks and magic stuff, that will impress novices and helps to eliminate minor inconveniences that can save a line here, or creation of a file there. 
I am sorry If I annoyed you. Did I imagine teaching philsturgeon a thing or two about software development. No way! As this is a public forum, one which have taught me a great many things, I only argued with you for the sake of a novice programmer who might stumble upon this discussion, and take away that quick is always better from it. All the things I said, I know, you are well aware of them. 
There's a little more to bootstrapping a framework than simply initializing a DiC object. :)
Ha, thanks. Well, sorry for being annoyed. I mainly mean to point out there is a balance to doing all of this, which is by no means new or interesting to the majority of people. :)
It seems like you were trying to make a point with that second half, but I'm not sure what you were referencing. 
Thank you.
http://dev.mysql.com/doc/refman/5.0/en/string-functions.html#function_field SELECT * FROM USERS ORDER BY FIELD(role,'Admin','Manager','User')
&gt; high cde standarts should probably use a spellchecker.
Sad that people down vote you. Hipsters... people which never touched real code or tell work. Not understanding that the most important thing is speed of development, not speed of code which comes after a long list. And no, most sites keep around several thousand visitors per day..
no, you misunderstood. I was not asking if a framework can use a DI container to do its initialization. What I meant is that you don't need a framework to 'tie the components' together. It can be done using a DI container.
You mentioned exe, so I assume you have a focus on windows. And actually, in windows, there are far far far better ways to turn a php script into a self contained executable. PHP provides an embed SAPI, you link [statically] against that an EXE which initializes PHP using the embed SAPI (look it up, easy), fetches code from the resource section of the binary (again look it up, easy) and executes it (guess what?) So, that's how you really get a self contained executable, but what about forms you might ask ...well, for many many years, over in the far corner of PHP land, has been an extension named winbinder, it allows you to write native windows forms using PHP, comes with a form designer and is actually, very clever indeed. http://winbinder.org PHP was never meant for this, so winbinder gets ... well, no attention at all. This is the actual answer to the question: how to convert a php script into executable php desktop program, I find the original solution to be, just, horrible ...
&gt; A frame is a framework
&gt;A framework should be, a directory structure and a documentation with guidelines regarding what should go where and how to build applications in a certain way. If you document it well enough you can just turn that documentation into code. Why bother documenting how to build and handle routing when you can just build a router and document how to use it? &gt;hacks and magic stuff I hear you, but not completely understanding something doesn't make it bad. And a decent framework isn't striving to impress noobs, they are solving real problems - problems that you will also have to solve and your solution will look like magic to the guy that comes after you.
You sound paranoid tbh. The whole request/response concept is an extremely well understood pattern and there is no good argument against using a well tested library/framework to abstract that and call your code. If you're that against having third party code call your code then you wouldn't be able to use any event libraries. Semantics is getting in the way a little in this discussion. 
I do understand that *"the frame"* is the part that holds the components together, and *"components = components"*, yet you are describing what a frames *does*, not what a frame *is*. From my understanding (based on that analogy), the frame is the part that doesn't move, is rigid. If all the parts of the *"framework"* are in fact components, then what's the part that's rigid and doesn't change?
Yah sorry, was writing this at 3 am.
Oh I know you weren't saying that, but it's an unfortunate opinion I hear to often. Any contrary opinion is considered "Old school".
I posted the original "you don't need a framework" article on here, although I'm not the author nor did I agree entirely with the article, but I did think it was an interesting discussion and I'm glad to see your point of view on it. Although the semantics are still a bit muddy, I think most of us are starting to see what the role of a modern framework is in a packagist/composer PHP world
The anology is not great, but I get the point. I would compare frameworks with Drupal, Joomla, etc and component packages with the Drupal/Joomla plugins. This may sound strange, but Drupal and Joomla are frameworks. When you develop a plugin for Drupal, you are working within the Drupal framework. The main difference between Drupal and what we decide to call "frameworks" is that Drupal comes with pre-installed components that make it a specific framework for a content management system. Out-of-the-box, Drupal is an architectual framework with content management system functionality built into it. Where as something like Laravel does not do this, it just provides the architectual framework and what you build with it is up to you. With Drupal going toward Symfony, it will no longer be its own framework. It will be using the Symfony architectual framework with its own built-in packages which make it CMS ready Did I just make a mess of things?
You're not seeing the bigger picture. &gt;which routes requests to methods in controller classes How about, "which routes requests to **callables**". The router is a black box, it parses HTTP requests and calls some arbitrary code with a standard format for the standard parts of the request (body, query string, headers, etc). &gt;For another project you may want your controllers to be tested independently Controllers aren't really meant to be unit tested. They're a thin layer, you would use functional/behavioural/acceptance/buzzwordoftheweek testing there. The fact your "framework" has a router that calls your application code should have no impact on testing - in fact a well built framework will support this testing.
You could dynamically generate the SQL code for doing this.
back in the days, i loved ajaxchat. http://frug.github.io/AJAX-Chat/screenshots.html
The DiC (or rather *a* DiC) is one component like any other, that does the job it is designed to do. It does not make the framework, is not mandatory to create a framework, and is not itself a framework. It is damn useful and many frameworks use their chosen DiC at their core. 
If you view source code in your browser, what do you see on the data.addrows line? Do you get any JavaScript errors in your browser's error console?
Wouldn't the framework for a bike be more like the accepted designs for what a bike must do? Wheels (at least on), pedals/crank, steering, a frame, brakes (in my world, *always* brakes). Optional comments include gears, lights, panniers, a camera, GPS tracker (do get one of those, they are cool). Everything physical you see in a bike, including the frame, are components. You may swap your aluminium frame for a zero weight carbon fibre version, but you haven't changed the frameworkc for what that bike is. Edit: maybe the frame is the DiC, joining all the bits together. A coffee is the bootstrap. Okay, too far. 
Typically: routing, DI, bootstrapping, file architecture... that's almost it. Things that would go in the 'kernel'. Under Phil's definition, the framework is usually going to consist of one to two classes (routing and DiC) and the bootstrapping that enforces the architecture. (Including the config for that bootstrapping.)
I'd recommend this one too. Version 0.87 has just been released.
try this: http://www.php.net/manual/en/function.decbin.php It should get you to a string of the binary value. 
Already looked at that, it just gives me a new problem, how do i find the values set? anyways, i just found this, but it looks like a hack/not really sufficient: $x = 9124 ; $n = 1 ; while ( $x &gt; 0 ) { if ( $x &amp; 1 == 1 ) { echo $n, "\n" ; } $n *= 2 ; $x &gt;&gt;= 1 ; } // Will output... // 4 // 32 // 128 // 256 // 512 // 8192
To find the values, use str_split() to convert the string to an array and then use the position in the array to calculate the value.
&gt; PEAR instead of Composer Yeah...for some reason I'm not sold on that book.
Thanks, i ended up doing this: $n = 1; $bits_str = decbin($bitwise_value); $bits_array = str_split($bits_str); for($i = 0, $size = count($bits_array); $i &lt; $size; ++$i) { if ($bits_array[$i] == 1) { $result_array[] = $n; } $n *= 2; } print_r($result_array)
Yes. :)
That sentence had no relationship to anything previous in this conversation. If Bob makes a framework, he can call it a framework. I can also call it a framework. "Hey Bob, how's that framework you built working out?" "Not, bad, do you want to use it?" "Thanks!" "Hey this framework is great". It's still a framework. The definition does not change on your relationship to the code.
Well it turns out that Brandon just had no idea that SF2 and ZF2 used Composer, so the whole "Actually frameworks have changed and our understanding of the word should change to match it" thing was a massive waste of time, because the original article was built on a fallacy. Ahh well.
Stop. 
The hiphop virtual machine or HHVM for short
The seemingly random jumble of letters (Game of Thrones family names) used as namespaces and classes.
Simplest, most readable solution in the thread.
Why do you need objects in text processor?
I think you'll still get plenty out of the 3rd edition. As the name suggests, the main topic of the book is OO patterns and practices which is a general topic that doesn't really change with each version of PHP. I guess I agree that it would be nice if it talked about Composer rather than PEAR but that's a fairly small part of the book.
Ah, thanks! I'll check out. I found a project which already uses hack lang several weeks ago and I crawled a bit into the hhvm source code to get a clue about all the nice additional features. But a lot of stuff isn't released yet. There are a lot of functions disabled a missing preprocessor declaration FACEBOOK which currently hides the async version of libmysqlclient and such. 
Something you'll have to deal with in any printed work in technology is it being slightly outdated. This book has been around for a long time, but still relevant on giving you a good platform to base future learning and research. Any technology book you get is going to have to be supplemented with up to date data on the internet, in the manual, and better up to date tools. Composer is very much a new kid on the block in comparison to this book. Composer wasn't even a twinkle in it's author's eye when this book was written.
To me, the easiest solution would be to set up a cron job to run "git pull" on the server.
Why are his posts still visible here? What's the point of shadow banning if everyone can see the posts?
I manually approved his post. This has nothing to do with us and I don't know.
very funny
You obviously didn't read the requirements we have. ;-)
mixing and matching modular parts is no more unixy than a framework that standardizes those modular parts you start with. Typically frameworks divide tasks more clearly and as such are more unixy than just picking and choosing your own structure. With clear defined rules to follow you will always do a better job as opposed to 'well I think I'll put view logic here, but I just read a blog that says put it another place so I dunno' Not to mention the rule of optimization where frameworks are clearly more unixy than mixing and matching. In fact I can't even find a unix rule that says you should work with the bare minimum of anything.
Here's a tip that is extremely common these days: Use a front controller to handle all of your application requests, and make sure this is the only PHP file in your web root. The front controller should call into your business logic which is located outside of your webroot. A lot of times this is done in conjunction with a .htaccess file with pretty URLs. Here's an example layout: /web /index.php /css /js /img /app /[application logic here] The index.php file would be your front controller. Within it, you could make calls into your app folder. In your web server configuration, the document root would be the web folder. No outside access to the app folder would be allowed, since it is below the document root. There are definitely a couple of measurable advantages to the Front Controller pattern. It makes sanitation of variables very easy - there's only one place to do it. This also can prevent users snooping around in your webroot for unprotected folders and files to attack. Here's an excellent example: the [Symfony2 Framework front controller](https://github.com/symfony/symfony-standard/tree/master/web). As you can see, the web directory contains the only public facing files. In this case, the "app.php" file is actually used to serve up both application requests and static content (the static content is located within packages, such as [here](https://github.com/symfony/symfony-standard/tree/master/src/Acme/DemoBundle/Resources/public)). However, it is also perfectly okay to serve up static content from the web root, as in my example above. If you are interested in building your own front controller for your application, I would highly recommend learning about the [AuraPHP Components](https://github.com/auraphp). The [Http](https://github.com/auraphp/Aura.Http) + [Router](https://github.com/auraphp/Aura.Router) components would probably be most advantagous. You can use them together to parse an HTTP request and dynamically execute logic based on the request.
I'm specifically asking about the 4th edition that was released 1 month ago. 
The thing is, traits change or at least can change the way OO is handled in PHP. 
What is the point of a 4th edition then? The Gang of Four book is still on its first edition, yet it's not out of print.
care to provide some evidence to back up that claim?
My guess is he isn't good enough to find work so he spends his time trolling /r/php. 
All his comments on /r/php and /r/webdev are negative or neutral. That's commitment.
There's a fourth edition because consumers often buy programming books based on their year of release.
In your situation, I'd recommend Docker or lots of AWS mini instances in order to segregate your various sites. Doing so you can dramatically reduce the impact of a single host being compromised. You could continue to use a single MySQL server with multiple distinct users and schemas, or go a step further and have entirely separate mysql instances as well. You should also dig into Vagrant to automate the build of your infrastructure so it's easy to spin up new instances for each site without (almost any) hassle.
Sorry, I guess I shouldn't have said sites, I meant pages. There are many many pages of content.
I cannot see how your response is relevant to our discussion.
I would figure this is his reason: http://lol.i.trollyou.com/ Either way, he's just an idiot and best to just downvote and move on whenever he posts.
Thank you for the information. I'll have to read more about this.
I currently use Slim to handle all of my incoming requests (except say, js/css files) and send everything else to 404 (I use nginx). I would check out Docker, as you can set it up to isolate each one of your PHP applications in their own container. EDIT: If you only use this for internal company things, you could also look into using client side certificates for authentication so only clients with the correct cert could access them. Depends on how paranoid you want to be about it.
Both. During the course of developing you will almost be forced to learn the basics of PHP usually because you're experiencing a bug or need to do something that requires you to have more than a passing interest in it. This usually leads to research which turns up good resources that explains the part of the spec which applies to your current task. A quick Google search turns up lots of results. Of the ones I checked out [this one](http://www.tutorialspoint.com/http/) looks like it explains it the best.
Yes. If you point out that not everything is completely perfect then you'll be called everything under the sun.
I have a little Linux server on Digital Ocean. Pretty cheap, can run whatever I want. Accessible anywhere. Only down side is your campus may block ssh. If they don't, try that.
Thank you for your sterling feedback. I have to wonder if insulting a moderator is a smart move though. I mean, you might as well go and sucker-punch a baby bear in front of its mother.
What you can do is to always accept it by reference, but only change it, if wanted. However, there is no way to find out, whether the return value (if any) is actually used, or not function (&amp;$foo, $byRef = false) { $tmp = $foo; // avoid subsequent by-reference modifications $bar = do_something($tmp); if ($byRef) { $foo = $bar; return; // void } else { // Keep $foo as it is return $bar; } }
Have you instantiated the $mysqli object? In other news, you should use PDO instead of mysqli. http://us2.php.net/pdo
Yea I know w3schools is a bad resource and not associated with the w3 organization. Thanks for the advice!
I am not sure, if this one and Guard exclude each others. Guard: For running related Unit-tests during development This driver: Running integration tests, that are to slow, or to much to run on every "save", or for the CI.
It also focuses on practices, and when it comes to that I'd argue that PEAR is obsolete and Composer is a must-learn if you want to use other people's code (such as a modern framework!). Ever browsed Github for PHP libraries recently and noticed how many of them require Composer? I know I have. If this edition is only a month old, then Zandstra either has not agreed to it himself, or he hasn't been keeping up with the field for three years, and in the latter case I don't think he should be trusted as an expert on modern PHP practices.
I have done this in my connection.php file. Witch i have used befor and had it working.
The GoF book is applicable to basically any object oriented language, and those as a whole haven't changed much.
Throw a var_dump($mysqli) to determine if the object is set. If not, it might be losing scope by the time it reaches the script.
then you need to pass he mysqli object inside your function or (bad choice, bad php BUT it works: add global $mysqli; as the 1st line of your function
I think functions should be one-trick ponies. Also, I think functions should not depend on what the context of their call is. If anything, they should know about the object they're a method of and that's about it. Maybe they can know about variables in outside scopes like in JavaScript (not a fan of that happening in PHP either btw), but knowing what you're going to do with the return value? I don't even If you're going to pass control of your program to a function, and what that function does, depends on what you do outside of that function, then that's a recipe for unclear code, which goes against what functions are supposed to be used for, namely to be a single chunk of overseeable code that does a single thing, ~~and that returns a value~~ *(edit: maybe that's not really vital to the purpose of a function, sorry)*. Your functions should not have to concern themselves with what goes on around them. IMO, if you want two different behaviors, you should write two different functions, or simply have one call the other: function pretty_format($data) { // format data like a boss return $formatted_data; } function pretty_print($data) { echo pretty_format($data); } I think the `print_r` function is a great example because I think, and have always thought, it should return the formatted data instead of printing it. It does two things where it should be doing only one, that's always annoyed me to no end in the case of `print_r` because I find I'd like to do stuff with that string before printing it. Just because the `print_r` function was designed badly, doesn't mean more bad design is needed to get rid of other bad design.
Um, you're saying frameworks are bad because you may want to use a different router implementation for different projects? I'm saying the router should be able to handle the different projects - or more aptly, your project should be able to use any well designed router. At least that's what I thought.
knowledge of one is not required to develop with the other, but knowledge of both is a great asset to your ability to develop. Client side programming has to be done with Javascript while server side development has to be done with something like PHP. But where the web really shines is when the two work together. Using PHP to return JSON objects that you can manipulate in real time using Javascript is the way a lot of the web is going and can be very powerful. So, while you don't need to learn one before the other, I would recommend learning both. And as an addition to javascript, look into jquery. There are other frameworks out there, but jquery is by far my favorite.
This. The name Facade actually had me very confused! I'd heard about certain design patterns, and I know the gist of what a number of them do, including the Facade, but am not yet a ninja at OO design, and I was trying to understand the Facade in Laravel after reading the blog post Taylor responded to. I knew about DI, which is what the author of the first blog post was on about, but was not yet very familiar with IoC which is behind the Facade in Laravel, which made it even harder to grok what the Facade was supposed to be doing and why that blog author thought it should be avoided. It therefore took a while for me to sink in that the Facade in Laravel is not actually a Facade and now I think I sort of understand. But I would have gotten it earlier if I hadn't needed to remind myself all the time that this isn't actually a Facade, it's more of an Abstract Factory (right? :S). If people don't speak the same language, they're not going to understand one another.
Variables and objects set outside a function are not visible inside the function, so $mysqli isn't set when you try to use it. Since you are still learning the basics, spend your time learning PDO instead of mysqli. Veel veiliger!