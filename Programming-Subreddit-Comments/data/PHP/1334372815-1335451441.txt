WAOP? What's the O? Oracle?
On OSX: 1. IDE: Uh.. Sublime Text 2 I guess 2. MySQL Management: CLI normally, Sequel Pro if I want to save data to my computer quickly. 3. Versions if I'm doing SVN, CLI if I'm doing hg 4. I have the amazing app TotalTerminal (yes, I know Terminal2 is the bees knees but I *love* TotalTerminal) which I use with tmux to let me remote into my servers and program live using vi/nano.
It's not uncommon for mature frameworks with high performance to use dozens of includes per page build. Some may use significantly more. The performance impact is typically nominal given the amount of power most computers have available today. In cases where you need extremely high performance, you'll tend to offset the impact of includes using various caching strategies. So, includes should be fine for most circumstances. 
It's not Zen Coding, but the Zend IDE and Aptana (or Eclipse) have pretty good code completion features for the PHP part of your code. For the HTML parts, I'm not entirely certain how different Zen Coding is from using regular old HAML.
printf is your friend.
Thats sounds pretty wicked. I love Dreamweaver. Fullscreen would be a total added bonus. Filezilla I use here and there, along with Fetch, and Expandrive to mount my FTP's as folders on my desktop. Without the pesky "no write" rule for non SFTP ala Apple. 
I've changed environments many times, and I've decided that I actually prefer NOT to work with an IDE. Most recently, I've been using the following environment (on OS X): * Editor: MacVim (has a bit of a sharp learning curve, but once you learn it, you can manipulate text in AMAZING ways with Vim) * MySQL Workbench * Simple command line tools for version control (be it Git, SVN or Mercurial) If you are not already working with a centralized version control system (like CVS or SVN), I strongly recommend that you install and use either Git or Mercurial for local revision control * Xdebug (PHP extension for debugging) combined with MacGDBp (OS X client for Xdebug) * Google Chrome w/ built-in Web Inspector for CSS/JavaScript debugging and browser testing * VirtualBox w/ Windows 7 and IE9 for the occasional, pesky IE-specific bug 
what, they won't let you install an OS of your choice? Most of those programs run on linux.
I'm doing some freelance PHP work for a former employer right now. When I'm in the office, I'm using this computer that I'm pretty sure was there when I quit. That was back in 2006. It's pretty rough going from an i7 2600k, 8gb RAM with a decent mechanical keyboard to a decade old 32bit Athlon POS, 2gb RAM and the worst keyboard ever made. It wouldn't be a big deal if it were just a spare computer that they would have me use but, they actually have a developer using it when I'm not there.
OSX on a 2010 MBP, upgraded with an SSD. - TextMate 1.5 (not 2). I've starting to warm up to Sublime Text 2 thanks to SublimeCodeIntel, but there's still so many annoying little bugs and missing UI elements that I find myself switching back and forth. - Safari for primary development. Chrome and Firefox for testing. Every version of IE available through individual VirtualBox images. - Both Sequel Pro and phpMyAdmin (depends on what I need to do) for DB management - Cornerstone for SVN, Tower for Git, Transmit for SFTP - Apache, MySQL, PHP, xdebug installed from MacPorts, configured on a dynamic virtualhost setup that lets me just add a folder to /Apache to make a new site (after editing /etc/hosts). - Acorn for image editing [My work environment](http://i.imgur.com/33TRH.jpg).
This is a great project for getting started. Something that I always try to do, and it helps me a lot, is to get something built that I can interact with asap. It's a great way to keep your momentum. Boil the functionality down into the most basic parts you can while still having it do something. In this case it'd probably look like: * Upload a photo * Display all uploaded photos Then you can break it down into simple questions like: * How do I upload a photo with php? * How do I submit a form with a file? * How do I display an image on the server? * How do I keep track of the images that have been uploaded? * How do I get a list of those images to display? Once you have some functionality you can really start to build off it. Things like separate albums, users, sharing, private images, voting, tagging on and on and on.
Here's a [screenshot](http://i.imgur.com/6F4HG.png) of my setup, I'm on windows 7 * Editor: Sublime Text 2 * Terminal: Putty to my home linux box * Files: SAMBA share to my windows desktop from my linux box * MySQL: HeidiSQL (over a SSH tunnel) for data management, migrations for everything else * SVN: Git and GitHub for a remote and issue tracking * SASS &amp; UglifyJS for assets * Kohana PHP Framework And of course some pumping HardTrance or Hardcore mixes to keep me in the zone!
yeah, Oracle.
I do PHP development on Windows but not against IIS -- Apache all the way. But I deploy to Linux. It's pretty smooth.
As far as my understanding goes, Smarty isn't a framework.
Vim, phpMyAdmin and command line MySQL, and Git.
Looks very clean, I like it.
Phpstorm is brilliant. Where I work we used to have different people using different IDES. Some used Netbeans, while I used to use Zend Studio. My friend recommended Phpstorm to me so I gave it ago. Within a week everyone at our place was using it, and none of us have turned back in other a year.
SM2's Magic code completion, for one thing.
In 99% of the cases, you might be better off explaining to your client that the web isn't pixel perfect. The hours spent trying to achieve this are better spent on UX, accessibility, security, A-B tests,...
thanks for all the support guys. i ended up following a tutorial for lightbox that works really well
* Server: FreeBSD and Linux depending on the project. Workstations: FreeBSD, Linux, Mac OS X, and Windows, often at the same time (I use multiple PCs and laptops). * Deployed on multi-core boxes, Amazon, and VMs, depending on the project. Deployed on embedded devices as well. * I simply ssh into our development or production boxes and code directly using vim. Sometimes, I use sshfs or nfs to mount the filesystems into my local workstation and use gvim. * Chrome and Firefox. I don't use IE unless someone reports a bug. I use curl or wget for testing the app or API via CLI. Some of the PHP apps *are* CLI (i.e., we used PHP scripts to boot an entire custom OS). * CVS, SVN, Mercurial, and git, depending on the project. * Apache, lighttpd, and nginx, depending on the project. * MySQL, PostgreSQL, sqlite, and plain 'ol text file, depending on the project.
IDE: TopStyle (similar to HomeSite which I used before) MySQL: phpMyAdmin For uploading files I use "sitecopy" (with cygwin) which does everything automatic. For Mac "Komodo Edit" seems quite interesting.
Don't get it - just use the network tab in Chrome/Firefox? You can click the "record" button in Chrome to keep all the info between page requests, full details of requests/responses etc. Chrome's dev toolbar basically does it all for me :)
i have been looking into using git, i am starting to see the benefits/need to use something like that
i found that after posting some of my code and getting a decent number of comments that i was having to look at how long ago things were posted to find out what comment I was looking for. really like the site though! 
i edited it to a reasonable length-per-line manually
Interning. Don't judge me :) 1.IDE: PHPDesginer - Always crashes and makes me sad, but it's what they use. 2.Mysql: PHPMyAdmin 3.Quickedit: notepad++ 4.firebug, web developper 5. server access: winscp and putty 
1. Work/Home Ubuntu 11.10 1. IDE: Netbeans 7.1 1. MySQL Management: phpMyAdmin 1. VC work/home: SVN/git 1. *AMP server: vagrant 1. Quick edit: vim/gedit 1. Image manipulation: Photoshop/GIMP 1. Browser and addons: Google Chrome FirePHP; Firefox Firebug
OS( Windows 7 / XP / OSX) - IDE: Sublime2 - Version Control: Windows (Tortoise GIT/SVN) | OSX (Sourceforge/cli) - mysql cli - wamp / lamp / mamp setup . - various repo hooks to handle deploy. - custom error server to report and handle errors on prod deploys. - firefox /w firebug | chrome | safari | windows virtual images for ie 6, 7 and 8
I actually wrote ThePhig and it started just as a way to mess around and learn a bit more about php. It's probably not the most efficient but it was fun to work on. Unfortunately I haven't had time to continue development. Neat to see it show up on that website. I would definitely recommend creating a gallery if just to learn. 
Oh it quickly becomes essential. A few quick examples based on my own experiences: I'm currently working on an internal web application. I've been working on a new module for the past month but it's not finished yet. Last week I was asked to create some new reports on the current site. Using traditional non version control methods to do something like this would be a pain in the arse. I have a month's worth of (unfinished) changes to the system that I don't want users to be able to see or have any access to. At the same time I want to be able to change the existing site to have these new reports in it. With Mercurial this is trivially easy to do (I'm sure it's very similar in Git too, but Mercurial is what we use in work). I simply switch to my live branch locally, then make the changes I want with the new reports. At that moment in time I see the same version my users can see (so it's like going back in time a month before I started working on the new module). I then push these changes to my server repository (you can have loads of repos using the decentralised systems, but when I'm ready to push an update I push to the server). Login to the server via ssh and type this: hg pull hg update live That's it - that then updates the website with the new reports. Then on my local machine I merge the current live site with the new reports into my current development branch - this is so ridiculously easy to it's often simply a case of clicking "merge" in my version control software (I use SourceTree). All of a sudden, I now have two branches on my local machine - I've got my development branch, which now has the new reports in it + all the stuff I've been working on over the past month, and I have the live version of the site with the new reports, which I can switch to at any time. Fuck something up? Just go back in time and revert it. You can see all the changes you've made to literally every file on a line by line basis, really easy. Want to know how one file has changed over time? Most clients allow you to right click on a file and see the history for just that file. Working with other people is where it really shines too. First time I did this I couldn't believe how easy it was to merge our work together, and ever since I don't work on anything without version control. 
Ubuntu with a Windows XP VM: * IDE: Aptana * Text editing: Notepad++, vi * Debugging: FF + Firebug + FirePHP * DB mgmt UI: MySQL CLI &amp; [MySQL Mastro](http://www.sqlmaestro.com/products/mysql/maestro/) (has other flavours for other DB types, too - it's a truly awesome piece of software that doesn't get nearly the distribution it deserves, is decently priced and is good for both noobs and pros; I love the ERD diagramming capability especially) * VCS: git * Server: Ubuntu 10.04 + Apache2 + MySQL + Node.js 
On Windows 7 Ultimate 64bit 1. IDE: Eclipse for PHP Developers 3.02/Geany 2. MySQL Management: HeidiSQL/PHPMyAdmin 3. SVN: subversion (Tortoise SVN) 4. Dedicated Servers from NationaNet: CentOS 5 + Cpanel 5. Firebug in Firefox and built in console tools in Chrome and IE Most stable and productive development environment I have used in 13 years of PHP development 
Same here. I like it cuz I can run vim directly on the server instead of having to re-upload everything every time I make an edit. 
Like others said before me, watch out for the security holes it might open (LFI and RFI, deadly security holes that would allow the bad guy to backdoor your server). Make sure you have all the files you expect to include stored in an array, then check if the URL argument is inside that array before including it : $allowed = ['home', 'article', 'about']; /* the index page is not included in this array to avoid maximum execution time errors and black holes */ if(in_array($_GET['page'], $allowed)) { include $_GET['page'].'.php'; } else { /* Log the attempt and/or display scary message or something */ }
`include` isn't a function. [â˜†](http://www.netgunsmith.com/wp-content/uploads/2012/03/The-More-You-Know3.png)
No, no advantage, git is better. My employer only recently began to use git, so all of our old sites are still on SVN repos.
Look into [natcasesort](http://www.php.net/manual/en/function.natcasesort.php) too.
Meh that's really situational.. I understand what you are saying (and I agree - I've explained that to my clients many times and they get it) but I don't know about "99% of the cases".. Not every site is a Bootstrap site, and sometimes, especially if you're dealing with lots of design elements or multiple layers of assets and images, you really do have to get pixel-perfect layouts... So it's not about making sure your menu bar is exactly the right number of pixels away from the top as in the PSD, but making sure all your layered assets or images line up correctly.. Think video game sites, movie sites, etc... 
_Intype_, I remember that ... looks like they restarted development after not working on it for years. Will have to check it out once again.
Meldmerge looks interesting!
Not to mention that Charles can decode AMF requests if you need to debug any Flex/Flash apps (which is how I originally found Charles in the first place)
Wow I remember Homesite.. I was using that back in 1999/2000... That was a great program for its time.. 
I code in Windows 7, then run it on an Ubuntu Vbox (LAMP+phpMyAdmin) which has share-access to my local (Win7) code-projects folder, so it's "save &amp; refresh" w/ no delay. For the code-wranglin': 85% phpStorm (w/xdebug), 5% Dreamweaver, 10% assorted: Notepad++, vim, and nano. Version Control: Windows Explorer + Tortoise for both SVN and Git (and also msysgit / Git Bash), but since phpStorm does such a fine job on that front, I've been using them less. Also, I've come to prefer the Git Bash CLI over Tortoise Git... it just feels like I achieve my tasks quicker, versus using the GUI. Putty/Pageant for SSH, and lots of "tail -f /var/log/apache2/error.log". Firefox/Firebug for frontend stuff. And Python for the mundane tasks that can get scripted. **TL;DR:** If I had to sell you on just one thing: **phpStorm**. Best $100 I've ever spent.
OS X, PHP 5.3.something, MySQL 5.something, browsers, TextMate
By the way, this is a really good resource for Mercurial if you'd like to take a look :-) http://hginit.com/
It's got much better USB support.
Ooooo! I've still been using the early beta version. 
May help: http://ihaveabackup.net/2012/02/27/what-is-doctrine2-anyway/
I prefer CodeIgniter, Cake just seemed too rigid in it's methodologies. That has it's benefits but I wanted more flexibility. Also from benchmarks CodeIgniter is often faster. In most cases you wont notice a difference between the two though. Honestly if you can't decide just flip a coin and go with one. As long as you use a framework of some note then you can't really go wrong.
Whatever works for you! I just can't stand WinSCP or any of the sftp/ssh programs in windows.
i'll admit that interacting cross-platform isn't fun, and if i had my choice and we were an all linux shop, i'd work on linux. i'm not crazy. ;)
Sounds interesting but I doubt this "USB" stuff is going to take off. 
I'd choose CodeIgniter over Cake any day. But if you're learning a framework, I'd advise Kohana. As I grow as a developer, I find myself less and less enamored with how CI works and appreciating more and more Kohana's autoloading and overloading.
We built our commercial app (shameless plug: [Pancake Payments](http://pancakeapp.com) ) on CodeIgniter as it brings with it the strength of being the base of EllisLab's commercial offering, [ExpressionEngine](http://expressionengine.com). This means that active development on CodeIgniter will continue, which leaves us to concentrate on our app and not worry too much about the framework. There are some things that it doesn't do that we'd like, but the pros far outweigh the cons. That's just my two cents, take it as you wish. 
Not in OP's choice of options, but [Symfony2](http://symfony.com/) is supposedly very good. Some of the Symfony2 components will even be used as the core foundation for the upcoming Drupal 8 release.
Good job with that, ThePhig isn't too bad for the user. (I've used it a couple of times, never run it though). My own project for that end served no use to anyone but me and has since been lost to the sands. But there is something magical when a script you've been working on from a week goes from struggling to parse 100 lines in 30s to parsing 15k lines in 0.5s.
THis is relevant to my interests, I'm going to (hopefully) invest more time into building some PHP based things, I'm told the best way to learn is to do. I've looked at CodeIgniter, but I thought the tutorials I saw might be a bit out of date.
`$2y$` wasn't introduced until 5.3.7... So it wouldn't be portable (but I may attempt to implement a workaround)...
I use a lot of CakePHP. I like it because it has it's own ORM and lots of functionality built in. A lot has changed from 1.3 to 2.1 so if you're googling for help make sure you specify version 2 or you'll get a lot of useless info.
I saw blue text and thought "hey, im gonna be a good person and check their site"; but then i read the name.
No idea about the student discount, but it's worth a shot. I just prefer the Tower interface, mostly; I like having an actual file tree, which most other Mac git clients don't have, electing to just show a flat file list in the same way that git itself does. I also have to work with private git remotes that don't involve github. I'm not certain about this, but last I checked GitHub only worked with their own remote repos. Github's app is built with simplicity in mind, making it as easy as possible to keep your local repo synced with your github repo. There's a lot of git functionality that they leave out in the interest of that simplicity. The first version of it didn't even have a diff viewer for performing commits.
Aaaand... perhaps you forgot you were in the PHP subreddit? Fact is, some of the software I linked to actually performs as well or better than counterparts written in other languages (e.g. the HTTP server). And with PHP's adaptability, I think you could make better interfaces than you can with other languages (for these tools), and you could give them more features.
I've read this comment a few times now and I'm a bit lost... Did I do something wrong?
Ladies and Gentlemen... THIS is why I joined the [/r/php](/r/php) subreddit! I cannot thank you enough for all of this!! Looks really interesting!
Performance is a big deal, don't listen to anybody who tells you it isn't. If you're running any kind of shared hosting, including a VPS, performance is going to matter, especially when you need it the most ie: MONSTER traffic spikes. Optimize the shit out of your pages or get a dedicated server. 
Try them both if you can't decide! But to be honest, they both feel like PHP4 frameworks. Unless you're a complete beginner I'd recommend something newer. Like Laravel or Symfony 2. Or maybe FuelPHP, which kinda feels like an updated version of CodeIgniter.
I like the concept but requiring 42 files in 12 folders just to hash passwords seems like massive overkill. 
Isn't that written in Python?
Whats wrong with [PHPass](http://www.openwall.com/phpass/)
I've never programmed in any other server side language other than PHP. I've certainly thought about leaving PHP for ruby or python but I have not made the switch yet because 1) My primary website that I built and maintain, the site that provides 100% of my income, is already built in PHP 2) I decided I didn't want to leave PHP until I was proficient in one good (i.e. not CodeIgniter) PHP framework 3) When you're coding with the "best" of PHP, I actually think it's a fun language to develop in. You can get stuff up fast, and I love making stuff. From what I've seen so far, I think Yii represents the best of what PHP has to offer. I'm not qualified to tell you whether to choose PHP or Python but i started with PHP 4.5 years ago and after the learning curve this is as powerful and well engineered as I've ever seen it.
&gt; Weevely is a stealth PHP web shell that simulate telnet-like connection. It is an essential tool for web application post exploitation, and can be used as stealth backdoor or as a web shell to manage legit web accounts, even free hosted ones. 
Hey! I developed php-ircd, which you linked to twice (both my SF (1) and Github (3) repos for the same codebase). I wrote php-ircd when I was 14 and the entire logic is in two (rather large, collectively) PHP files. It is best summarized by the Github project description: "An IRC server written in sloppy PHP." It works and is pretty impressive for being written by a 14-year-old, but is nothing I'd use for an actual IRC network :P
But all the source code files end in .py
Why no bcrypt?!
&gt; We need a password hashing library, because although it's not too difficult to do it properly, people just don't seem to understand how to do it. This is where I have a problem. People should be obligated to learn how to do this. I think when you learn by relying on third party libraries or extensions, and rely on them, that you're overall skill and usefulness as a development is effected negatively. Sure, if you know how to do this and don't have the time or don't want to spend the time to write up some method of hashing/salting, then by all means, help yourself. But if you don't know how to do it/why to do it, then take the time to improve your skill and understanding. Look through the code, see what's going on and research rather than rely on using it.
You are correct, I don't see any PHP code (Even in the source files)
No, I'm fully aware that I'm in the PHP subreddit. My point was that though you have encountered many people who thought it "wasn't possible" to develop complex systems in PHP, the fact that it *is* possible doesn't say anything about the language. Pretty much any Turing-complete language can build whatever any other Turing-complete language. The more important question is what am I optimizing for? Development speed? Readability? Maintainability? Scalability? Memory use? CPU use? Once you've defined the requirements for your system, only then should you select a language to program in. My engineers and I might work in PHP, AS3, Javascript, Java, Python, C, C++, C#, Lua or ASM depending on the specific problem we're trying to solve. When people build systems in languages that are sub-optimal for that domain, it increases engineering costs. I can hardly imagine the millions of engineering dollars wasted at Facebook as people fight to get the PHP codebase there into a performant and extensible state. When a community of programmers become convinced that "their language" solves all problems, they are also less likely to become better programmers by learning about other languages. They will grow insular, stagnate in their professional development, and churn out terrible code. TL;DR; Any real programmer knows that it's possible to build (largely) anything in any Turing-complete language.
Really, with [`header()`](http://us3.php.net/manual/en/function.header.php), [`cURL`](http://us3.php.net/manual/en/book.curl.php), or [Sockets](http://us2.php.net/sockets), and the manual to [HTTP](http://www.w3.org/Protocols/rfc2616/rfc2616.html), [FTP](http://www.w3.org/Protocols/rfc959/), and other protocol standards, you can pretty much do all these and more. And, for local files, if you know the file structure, you can use any [filesystem function or extension](http://us3.php.net/manual/en/ref.filesystem.php) to manhandle that.
because md5 raw unsalted has been cracked for years, and the algorithm is so fast that any salted passwords won't take very long at all to crack.
You've got it backwards - Kohana *was* a fork of CodeIgniter, but v3 was rewritten from the ground up and no bears no resemblance at all with that framework.
anyone know of a rdp or vnc app in php?
&gt;When a community of programmers become convinced that "their language" solves all problems, they are also less likely to become better programmers by learning about other languages. Really? You don't think, I don't know, they might become **better** programmers at their preferred language? Would you like to be great at one language, or mediocre at several?
&gt; Weevely is a PHP web shell that provide telnet-like console to execute system commands and automatize administration and post-exploitation tasks. &gt; Just generate and upload the server PHP code on the target web server, and run Weevely client locally to transmit shell commands. It's a client for some gray-hat PHP code.
No it's not and no it doesn't. Your time is almost always better spent improving your product and simply upgrading your hardware instead. A VPS is not akin to shared hosting. This very site you're on (that's serving much more traffic than any product you will ever build) is hosted on virtual servers. Optimization is only useful when it's based off of profiling results. You can spend all of your time 'optimizing the shit' out of your application, but if you're not profiling it you're not making anything approaching effective use of your time, and have no way to really know if you've had any effect at all.
If you're using opcode caching you're not seeing nearly the performance improvement you could be if you're doing conditional includes. You should try and restructure your code to include all the files you will need unconditionally.
Well I had a function running on a page that was counting views and storing the data in a mysql database. One day I got an ass ton of traffic and my VPS couldn't handle it and I was getting a whole ton of error messages mostly saying mysql couldn't connect or failed. So... I went back and cut out everything from the page that wasn't absolutely necessary and the load on the server dropped considerably. Sooooooooooooooooooo... I dunno. Also how can you say a VPS isn't shared hosting? Your site is sharing a server somewhere with other sites. If you start using up abusive amounts of resources then your hosting company will get angry and cut you off. 
You're probably looking for something like OpenCV. No idea how well this is supported under php https://github.com/mgdm/OpenCV-for-PHP
Did you reply to the correct comment?
guess not, apparently i've been drinking too much
Crap, I was hoping to start developing a quick cash drawer script! Maybe JavaScript is a better choice anyways...
and btw, people make fun of this not because ruby/python have it solved but because in those languages the GIL is a known limitation whereas in PHP is a "feature"
Bcrypt is default but labeled blowfish; why not just call it bcrypt?
I'm sorry, did you misread OP's post as an argument for using any of those implementations for anything but fun?
Not so much for you I guess.
You wrote this at 14? That's impressive, I can't even come close to this.
I've interviewed a lot of programmers. The ones who have done PHP for 10 years are by far worse PHP programmers than the ones who have say, done C++ for 3 and PHP for 7. Learning a language teaches you... that language. Learning multiple languages teaches you different ways to think about problems. In addition to your trusty wrench, suddenly you know what a hammer is and what it's good for. You learn about wire strippers, power saws, and cutting torches. When presented with a problem, you no longer waste time thinking about how to solve it with a wrench. Can you honestly say from first-hand experience what sort of things PHP is good at, and what its limitations are? Is your programming ability defined as some fraction of the concepts and nuances of a single language? Better to know 20 languages (and IDEs, and associated libraries) at 85% than 1 at 95%. Generally, a 95% PHP programmer will write worse software than a 50% Java guy, anyway. Differences in the sort of people the languages attract, I guess.
Two web (HTTP) servers, one concurrent and the other non-concurrent : https://gist.github.com/949850
* Ubuntu 11.04 - don't like unity at all, but it's good enough * Kate text editor - the syntax highlighting is really good, it also has auto-completion * MySQL cli - prefer the rawness as opposed to a GUI
Just to clarify on Scroph's point, sort() returns TRUE if the sort operation was successful and FALSE if it wasn't (Maybe you tried sorting a non-array). This is why $array was equal to "1" after you called sort()
* OSX * Alfred (including powerpack. There's a license worth buying, people!) * custom PHP install with Apache vhosts * Firefox with firebug/webdev toolbar * iTerm2 + tmux * Vim in shell * DB management in shell * Git * Homebrew
Yes, but that does not at all mean that I used good coding practice. If your code looks like php-ircd's, you're probably also doing it wrong :)
I wrote my own class that uses sha512 with a unique salt per user (approx. 32 char salt) and 1000 iteration stretching. What would be the main benifit to switch to a library like this?
Is that PHP-GTK? If so, I'm sure the project would really love to hear that it's being used for something useful. I, myself, developed a [Hotel Reservation System](http://thefrozenfire.com/data/PHPROS.png) using PHP-GTK. It's pretty powerful.
Love the outgoing mail server. Might make a great way to test outgoing mail stuff without having to worry about the fuss of a real mail server on my Linux workstation when coding in PHP.
Major buzz kill. I was just about to do that.
Mamma mia!
And why, exactly, shouldn't you? *edit:* You guys are the kind of people that would have said "You shouldn't build an online email client, we have desktop clients" and "You shouldn't build an online office suite, we have offline office suites" and "you shouldn't build your own media player, we have Windows Media Player" and "You shouldn't make your own OS, we have Windows" and "You shouldn't make a music streaming website, we have radio". *edit2:* My point is that, (1), who are YOU to say that these are bad ideas or shouldn't be done, and (2) why do you come into the PHP subreddit (and more specifically *a topic I started*) and post NEGATIVE criticism when you could just as easily, I don't know, ***not do that***, and (3) Why are you giving orders? *(hint: Should is a loaded word)* I think that these are great ideas, and if you disagree, you can keep it to yourself.
* Linux * Terminal * Vim w/ some PHP extras * Sublime Text 2 w/ some PHP packages * Git for deployment
Because something something tool for the something something job
Sure, if that's how you make choices I cant say anything about that. We don't handle payments directly, you use whichever gateway you like, we help you get paid by your clients. However I can see how you would draw that conclusion by only looking at the the name. We've been trying Pancake App and Pancake Payments and being that we handle invoicing, project management, time tracking the "App" reference is probably more likely. We were featured in the February Issue of Inc Magazine so many people do take us very seriously. I really do appreciate your feedback as it's another point of view. Thanks for that. 
Our host had informed us that they would be doing some early morning Sunday maintenance and expected zero downtime... turns out there was a couple minutes worth. 
I've been working between the two frameworks for almost a year now. I was a developer for a CodeIgniter based open-source project and fell in love with it. It was easy to piece together, allowed for rapid development, and there was always a way to make anything you wanted work with light wrapper libraries and the well commented documentation. I went on to using it for many projects with no regrets and have seen projects based in it do amazing things. CakePHP is more like Ruby on Rails, if you're familiar with that. It doesn't have as much flexibility as CodeIgniter, but I enjoy working in it just as much due to how quickly you can develop a project (agile development). Using Cake's "bake" feature, you can pump out a quick wire-frame for a project and have most of the required view code assembled within a few seconds, which works really well for me as I can edit like there's no tomorrow. To someone starting out with frameworks in general (and only had these two to choose from), I'd recommend CodeIgniter due to the quality of documentation and the available code. If you have any experience with Rails, I'd recommend CakePHP. If you have experience with frameworks, I'd ask yourself what you want to do with it. Each has their own trade-offs (cake's strong-point is how quickly you can develop an application, but CodeIgniter's strong-point is how flexible the framework is). Now my rant is over, and 7 years of web experience says it won't be a crucial decision with whatever you start with. The only way you're going to be able to decide is to get your hands dirty with both in a project and decide what tool works the best for you. Frameworks are like opinions, everyone's own way is right. :P If you're still unsure after everything I've said, try CodeIgniter first. You won't have any problems figuring out how to do things. The CakePHP docs for v2.x are still a little incomplete and can cause headaches for obscure practices.
&gt;scripts that most people wouldn't think were possible with PHP This line indicates that the OP: * Has no understanding of computer science ... and/or ... * Is talking to people who mostly have no understanding of computer science Good programmers (regardless of language preference) understand that PHP is Turing-complete and can be used to build pretty much anything. But they also know that you should select the right tool for the right job. &gt;So, anyone have scripts that really show off the capabilities of PHP This line from the OP along with the first one suggested to me that this was a "Hey don't bother learning anything else -you can do it all in PHP" list, which I consider to be a detriment to the universe as a whole. If it's for fun, then fine. But there are a lot of impressionable junior programmers around that don't need to completely false notion in their head that becoming an expert in a single language and its technologies makes you a great programmer. I already have a hard enough time dealing with students who were told that becoming a Java expert was the end-all be-all of software engineering. No need to perpetuate that sort of thinking.
You're creating false dichotomies. Nobody has *ever* said "You shouldn't build an online email client.". *Lots* of people have said "You probably shouldn't build an online email client in PHP." You can build all of that in Java, C#, or Python and the software engineers that inherit it in the future to make it more scalable and performant won't hate their jobs. The software engineers I know at Facebook that works on the PHP side of things hates their life. Same for my friends at Zynga. They waste time on things like a PHP-to-C++ compiler because even with the best PHP engineers on the planet, it just isn't fast enough. The cost to maintain and optimize PHP at those companies is millions and millions and millions of dollars, and it will continue that way forever. I can build all of the listed things in ASM or Brainfuck. And I might do it if I'm bored, but I sure wouldn't suggest that they be used in a production environment or a project with more than one person. Hell, at least the ASM version would perform well.
Don't let me kill your buzz. There are tons of people out there willing to pay good money for guys to hit nails with wrenches, and there probably will be forever.
The fact that you even have to ask this question is the very reason. To be clear, I don't blame you for having to ask. Knowledge of PHP internals is something that is hidden from the people who use PHP, because they shouldn't have to know it to do the things PHP was designed for. PHP garbage collection was designed around the premise that scripts would be short lived. That memory leaks didn't matter as much, because a script would run, do its task and exit, thus freeing all its memory. PHP does not release memory once it is used during its runtime, it recycles it. This is the main problem with building long-run servers in php. Could you be extremely careful, and build something that in theory never used more memory than it needed? Sure. However, you can't count on every extension to do the same. PHP is also inherently slow when compared to other lower level languages. It has data structures that trade efficiency for flexability. Additionally, it has far too much built in to its core. This is a benefit for quick prototyping, but a liability for fast, efficient, and reliable code. The people who believe php can and should be used for anything and everything believe so because they don't understand how languages work at a fundamental level. There is a reason most daemons and server processes are written in low level languages - that reason is finer control over system resources. As you learn more about other languages, and their capabilities, you'll come to realize what many of us already know. There are lots of things you can do in PHP, but that doesn't always mean you should do it in PHP.
Just an update... I installed it and I've been doing some performance testing. I can't find a noticeable difference in speed when it's on vs. when it's off. There may be a slight difference, but I think activities like accessing the database are so much slower than the speed of actually executing PHP code, that APC doesn't necessarily make much difference in many cases.
I consider those bugs, and only by creating programs that expose those bugs can they be fixed. &gt;The people who believe php can and should be used for anything and everything I never said it **SHOULD** be used for everything, but I ***know*** it **CAN** be used for everything. You can use what you want, I can use what I want, and there is absolutely no point in trying to convince my I am wrong, and no point in me trying to convince you that YOU are wrong. **You wouldn't expect a Muslim to have much success converting a Christian** (or vice versa), would you? &gt;believe so because they don't understand how languages work at a fundamental level And people like YOU focus so much on classical programming that you become rigid and unable to adapt and **think outside the box**.
False dichotomy: "If you don't support PHP, then you don't support web apps." Those two things are not mutually exclusive. The tools do some of the same things. Some things they do better or worse than others. Some tools are more comfortable to use for short projects, others are more comfortable to use for long projects. My point was that you don't know anything about the tool you're using because you have nothing to compare it to.
You're attacking a Straw Man. Nobody is saying "You shouldn't" make web apps. People are saying "You shouldn't" build certain things in PHP when it is easier and faster to build more stable, maintainable, debuggable, scalable versions in other languages. Even if you've never used those languages before in your life. Besides, I could easily argue that PHP has held technology back in the long run by causing the accrual of billions of dollars in technical debt across the tech sector. Unless you've worked in several technologies, you're not really qualified to have an opinion about what PHP is good for and what it isn't, or what we would have built vs not. You know, it's perfectly legitimate to say "I want to program in PHP script because it's what I know, and I have no interest in learning about other technologies." There are thousands of PHP scripters out there writing awesome things and supporting their families with it, and that's probably not going to change for a really long time. But they could still write most of that stuff better/faster/cheaper in other languages. If they care or not is their business, and their employer's business.
5.3.2 is the maximum version of PHP available in apt on Ubuntu 10.10, which is still very popular as a VPS option.
&gt;My point was that you don't know anything about the tool you're usin You see, that's basically an insult, because of this: &gt;you don't know anything Regardless of how you try to pad it, that's the core of your argument. &gt;These are all tools that ***SHOULD*** be in your toolbox. That's telling people what to do, when it's none of your business how I program. If you don't like how others program, keep it to yourself and don't try to give people orders. It makes you seem like a pathetic "cyber bully" In essence, ***WHY ARE YOU EVEN POSTING IN THE PHP SUBREDDIT IF ALL YOU HAVE IS NEGATIVE CRITICISM***?
&gt; People are saying "You shouldn't" build certain things in PHP . &gt;you're not really qualified to have an opinion Do you even realise how arrogant and rude you sound? Trying to tell people on the internet what to do?
Chill out. Your comment sounded over the top, so I took it as sarcasm. But if you're serious, then I take it back and good luck to you. In the realm of programming, nothing is impossible. _I_ mentioned .Net and GUI's specifically for the Windows platform. My bringing this up is a tangent related to GUI's. Because with .Net, [you can generate forms](http://msdn.microsoft.com/en-us/library/system.windows.forms.aspx). No this doesn't sound ridiculous - or rather _shouldn't_ - because you're _supposed_ to be able to have full access to .Net assemblies via PHP's [DOTNET class](http://us.php.net/manual/en/class.dotnet.php). This means that, provided .Net is installed on the host system (and most of the time, it would likely be) you're _supposed_ to be able to create full GUI-based applications on Windows with just PHP and without any need for any extra extensions. But you can't, because PHP's DOTNET and COM classes are broken or incomplete. I don't know. They were as of last year. Maybe something changed and they got a new programmer heading that up. Also, [PHP-GTK](http://gtk.php.net) hasn't been updated in almost two years, with the last news mentioning it "now" works with PHP 5.2. And, I see no mention of any simple PHP extension, but rather that it is a standalone application package wrapping around PHP. Can you at least confirm it works out of the box with the very latest versions of PHP 5.3? And now, 5.4?
&gt;And people like YOU focus so much on classical programming that you become rigid and unable to adapt and think outside the box. Being adaptable, and "thinking outside the box" should mean that you get a few more languages under your belt so that you understand what is being said here instead of just dismissing it. You're getting defensive and angry where it serves no purpose. I'm not here to try to put you down, I'm here to try to help you understand that there is a reason experienced programmers do not reach for PHP when it comes to the sorts of things you're talking about.
You're not doing a great job representing PHP developers. Stop asking yourself what PHP can do, and ask yourself what it excels at compared to other technologies. Do you even know? How do you hope to be an expert if you don't? Other languages can have a cumbersome syntax, sure. But do you know why? Have you thought about what you gain and what you lose with such a syntax? Have you been on a project with dozens of programmers? Languages like C++/C#/Java are so strict and cumbersome because they allow you to write code that can't be used incorrectly by others. PHP and other untyped languages do not. Did you know that, though? There's a point where your team is large enough that the stricter, more structured languages actually overtake languages like PHP/JS/Python in terms of speed. Knowing when it is appropriate to use one vs the other is the mark of an experienced software engineer. We had a PHP service at work that took 12 large Amazon boxes to support our users. We had our senior PHP guy rewrite that specific service in Java (first Java he ever wrote) and after that the service took 2% of one box's resources. There are other services we run with PHP because they are simple and completely stateless and we could build them in a few minutes. Someday when you're out of school and in the workforce, if you want to rise through the software engineering ranks, you will be expected to make decisions about which technology to use. If all you can ever answer is "PHP", you will never get this job. So I ask you again: "Assuming everything is possible to build, what does PHP excel at?"
OSX/Windows7 (laptop [my sexy mac air]/desktop with many monitors) 1. IDE: Netbeans 2. MySQL: PHPMyAdmin 3. SVN: Github. 4. MAMP/WAMP 5. Balsamiq Mockups
It's a nice function, but it would have served better as a tutorial for the ZipArchive class.
...and what's the exception?
|I consider those bugs, and only by creating programs that expose those bugs can they be fixed. Then you understand nothing about computer science. It's all about trade-offs. *Ease of use vs. maintainability *Readability vs. performance *Memory vs. CPU etc There's no language that's good at everything. There's no algorithm that's good at everything. There's no data structure that's good at everything. This is basic computer science, it has nothing to do with "bugs" or things that can be improved/fixed in one language or another. Languages are more than their syntax.
Without knowing what stubFactory looks like, it's hard to say. Your catch blocks are in the wrong order, though; PHP will take the *first* catch() that matches--in this case, it's going to be the first block, because Zend_Http_Client_Exception necessarily extends Exception. Also, have you used set_exception_handler() anywhere?
Save the filenames to an array, like so: $files[] = array( 'filename' =&gt; $filename, 'modified' =&gt; filemtime($filename) ); Then sort it using a [user-defined comparison function](http://php.net/manual/en/function.usort.php).
I think a problem here in your line of reasoning is generalizing every case. &gt; Nobody has ever said "You shouldn't build an online email client." AT&amp;T once said ["you should not build the internet - no one will ever use it"](http://www.vanityfair.com/culture/features/2008/07/internet200807?printable=true&amp;currentPage=all). &gt; Lots of people have said "You probably shouldn't build an online email client in PHP." "Client"? PHP has the [IMAP library](http://www.php.net/manual/en/book.imap.php) to handle part of this. And if you know the standards of any special email service, you should be able to interact with them using [Streams](http://www.php.net/manual/en/intro.stream.php) or [Sockets](http://us.php.net/manual/en/intro.sockets.php). Or do you mean "server" or..? &gt; They waste time on things like a PHP-to-C++ compiler because even with the best PHP engineers on the planet, it just isn't fast enough. The cost to maintain and optimize PHP at those companies is millions and millions and millions of dollars, and it will continue that way forever. Sounds like this company is using the wrong technology for their _very_ unique case to satisfy the _immense_ demand. But this is a very rare case, as most average sites will not likely have to meet the same demands in PHP userland. 
while there is no denying that other languages are better at these things then PHP, your statement isn't entirely accurate. You can achieve finer grain control of the memory management. Here is a pretty cool pear package which attempts to address a lot of the issues. http://pear.php.net/package/System_Daemon
That isn't controlling memory management, it's just properly implementing a daemon. You can't gain any significant control over memory management in PHP. All memory in PHP is managed for you.
No, I've not used set_exception_handler(). Isn't this for custom/user-defined exception?
Usally it is up to the "user", but server side Virus checking on a file sharing side could be a "selling" point
Care to expand on that?
|AT&amp;T once said "you should not build the internet - no one will ever use it". Slightly more general than "you shouldn't build an online email client", but I understand your point just the same. |[online email] "Client"? I was directly quoting the OP. |Sounds like this company is using the wrong technology for their very unique case to satisfy the immense demand. But this is a very rare case, as most average sites will not likely have to meet the same demands in PHP userland. Of course. I was simply providing (as requested) a problem where core PHP simply isn't enough. That problem turned out to be Facebook. It's a common problem, actually: 1) A startup writes their app in PHP (because it's fast, or they don't want to pay for Java engineers, or whatever) 2) Performance begins to buckle as the app surges in popularity. 3) Armies of engineers are brought in to either rewrite the codebase in some language better suited to the task, or bring some semblance of sanity to the PHP code. Nobody can know that their app will need to serve millions of users a day, obviously. Here are a couple other switches: * Facebook: PHP -&gt; C++ (Programmers write in a subset of PHP, but Facebook translates it into C++ and runs the compiled C++ code) * YouTube: PHP -&gt; Python -&gt; Java Facebook uses other technologies for different parts of Facebook as well. Zynga uses PHP because Facebook only offered a PHP SDK at the time they started developing for that platform.
Yeah Cake a PHP 5 framework as of September last year
One thing he is missing: To create a Zip file, you need RAM. Compressing 5MB pictures needs at least additional 5MB memory from the memory space which PHP uses. So, compressing large or a lot of files will easily blow up your memory from the PHP process and the max. execution time. To do this more "fail save", use OS functions which can be called from PHP via system calls. Build those calls asynch and your are more save.
if you don't want to waste memory and want a fast compression you should use the OS zip command. 
short version. Create a form which is used to get the coords from the user. Then store those values into a Database table. The page which will display the google map, needs to include the Google Map Javasript ( https://developers.google.com/maps/documentation/ ). In this page you need to return the saved coords as JS variables. Those values will be then taken by the maps JS and the map will be displayed.
here is an example for the method Nicoon suggests: http://www.bitrepository.com/sort-files-by-filemtime.html
1. This really doesn't have anything to do with PHP. 2. [Do you ever look things up for yourself?](http://www.reddit.com/user/mexicanseafood/submitted/)
You also need a long global salt that gets mixed in with the final password hash as well. Then if they steal your database with all the unique user salts and hashes but they couldn't get your source code then they're still missing the global salt which will make it even more difficult to generate the matching hashes. Also in your code (seeing the attackers don't have this) you can modify how the final hash is generated. If the attacker knows most people just do hash(salt+hash) that's what they'll try first. Why do what everyone else does? You could do hash(salt + password + salt + globalSalt) or whatever combination you like. 
&gt; Symfony offers some advantages over the others: &gt; It is supported by SensioLabs &gt; It have a vibrant international community, which ensure its longevity Come on, really? CodeIgniter is supported by EllisLab and all of the bigger frameworks have big communities.
Think SQL Injection. If an attacker gets your password db, rate limiting isn't going to do a thing...
The benefit is that you're using approved, vetted algorithms. Writing your own algorithm is actually quite difficult, as it's SO easy to introduce collisions and actually make a far weaker algo than you think...
&gt;But then suddenly, it just stopped working. First of all, it didn't suddenly stop working. It doesn't work because you are replacing the newlines with an empty string. Secondly, if you simply want to replace newlines with &lt;br/&gt; tags, why not use the [built-in function](http://php.net/nl2br)? 
As said, i am still fairly new to PHP, and when i searched, the nl2br2 function was the first one that i could figure out how to use. But it worked earlier, with the exact same code as i am using now. I have tried $string = str_replace(array("\r\n", "\r", "\n"), "&lt;br/&gt;", $string); But it still doesnt work. But how to use the normal nl2br function then?
hhmm did not seem to work..
See which framework to choose for web development in PHP.
&gt;But how to use the normal nl2br function then? Are you serious? I just linked to the documentation, it contains several examples. 
The SMTP and POP3 protocols are fairly easy to work with by themselves, in my tech support years I often would access them via CLI to either check messages or compose a test message. It's all just text commands and parsing the text responses. These 2 pages [[1](http://www.yuki-onna.co.uk/email/smtp.html), [2](http://support.microsoft.com/kb/153119)] are basically all you need.
You could use glob to select the files you need in an array, then sort them by filemtime() like jumpunB and Nicoon suggested. Check out [this awesome example from the manual](http://www.php.net/manual/fr/function.glob.php#68939). Of course that's just one way (out of many) to do it.
I'm currently working on allowing multiple files, I think my approach is going to be similar to that of imgur albums. Tracking Edit history has been mentioned in the past and I have a ticket for it but I'm really not sure when I will tackle that one.
The ZF exception *is* a user-defined exception, just not yours in particular. Also, is your code namespaced? If so, you'd need to catch `\Exception` instead of `Exception`.
It's for a catch-all handler in case an Exception gets thrown that you haven't explicitly caught. As you've discovered, uncaught Exceptions are fatal, so using set_exception_handler() would be useful if you want to log this before your application exits. I only ask for the sake of covering bases. Is your stubFactory class available anywhere for review? It's probably where you're running into trouble.
IDE: Sublime Text 2, Smultron, vim MySQL Management: Sequel Pro SVN: command line, versions Dev Env: VMware Centos 6 VM basicly my VM is the same setup as my production server. 
&gt;There is also no try/catch for Exceptions. This is a bad function. ZipArchive doesn't throw exceptions, and even if it did you wouldn't want to catch the exception inside his custom zip function - that would be stupid and pointless.
thanks a lot.. have you heard anything about sajax or xajax? if so how would you compare them? It seems like everyone seems to be in favor of jquerie and I will most likely end up going that route but I can't find too much info about the two of them.
I'm curious about which font and color theme you're using for PuTTY. 
Try this: http://daylerees.com/category/laravel-tutorials/ He even made a book ;) Enjoy Laravel!
Way to act like an adult.
Nothing fro PHP directly. Like another user said, Tesseract can be used to read images at a decent rate. What you could do is have the user upload an image, then run a command-line Tesseract command through PHP and get the results back. For my internship project I wrote a web game where users would re-enter a pre-generated CAPTCHA (or variant of the CAPTCH system that computers couldn't read). Over time the system was able to "learn" what characters actually were. Another team developed a scanning program that could integrate with this and eventually our goal is to be able to read any text written in any language on any surface. Note that this is for a global manufacturing business, so it's not open source, but my part was relatively simple and would be easy to duplicate.
Not sure why someone downvoted this, as that suggestion worked perfectly. 
It seems like they are trying to fix things, but with all the issues no one really kept up or wanted to. Sometimes it's easier just to start clean...
the majority of the things that people want fixed don't really have any potential to support backwards compatibility. it's a pretty good example of a cluster-fuck.
&gt;I am not an adult. Clearly not. &gt;It is not your place to judge the way I choose to gather information. That's not why I asked. You've consistently been asking questions which would easily have been answered by looking them up for yourself by either googling or looking it up in the manual. You're never going to make it as a developer if you keep relying on other people to supply the information for you. There's a chinese proverb which fits perfectly in this situation: &gt;"Give a man a fish and you feed him for a day. Teach a man to fish and you feed him for a lifetime." There was a post in r/programming a couple of days ago about how to best mentor junior developers, and it essentially mirrors this sentiment: http://www.reddit.com/r/programming/comments/s9oce/how_to_mentor_a_junior_developer/ &gt;Please stop being such a fucktard my fellow redditor. And you stop being so defensive and jumping to conclusions.
Two words: Backwards compatibility. BC is a very big issue in PHP, that's why broken behavior can only be fixed over a long time. Also, the truth is that most things people bash about are non-issues in reality. Like the $needle, $haystack order. Sure, everyone complains, but in the end it doesn't really matter much.
Well, if you read the main article that seemed to have spawned the latest anti-PHP talk ([here](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/)) the case he makes for not fixing is that the designs it was built on are so inherently flawed that "fixing it" would essentially be forking in to a new language altogether. He also says that many of the things that would make it a slightly better design are rejected by the core devs. I agree that from a pure coding language point of view, PHP is flawed in many ways and I would never do any computer science with it. And if you are looking to become a better coder, in general, then I think you would want to also be learning another more "pure" language... like LISP or Smalltalk or something. From a practicality / business point of view, it has many advantages over "better" languages with how large a community exists surrounding it, how many PHP devs are on the market and how many business problems have already been solved with it. But yeah, I'd be curious how the core dev team would respond to this as well.
&gt; It is being fixed in some regards all the time, I disagree. *Bugs* are fixed. *Language problems* are unaddressed, and more often than not as of late, just piled onto.
&gt;you and i do not seem to be on the same level. Meaning what, exactly?
http://www.phpwtf.org/
I prefer code in Ruby or Python, but the true, like it or not, is that current PHP is not the same thing as PHP back in 1998. I think a lot of things are improved and after all PHP is a valid and interesting project and many companies simply love it.
People do try to fix it. However, php is a design by committee effort and any proposed changes need to make it past the committee. Often anything that breaks backwards compatibility has a near impossible time getting approved.
Back to acting like a five-year old again, I see. Fair enough, if you wish to be an asshole, that's your right. Don't cry when you get banned for violating the community guidelines. 
The company I work for made their own framework, would this be acceptable to your "having experience" clause? 
Usually what sucks are the "developers" who hack things together. Just because you can do something, doesn't mean you should. Not all PHP developers are terrible, it's just that PHP has a low cost of entry that we see more than languages like C would.
I would suggest you to try Symfony2. It's pretty efficient and once you get used to it, the development is pretty rapid.
and http://phpsadness.com/
You forgot Python - awsome.
Any language can turn into a cthuluian nightmare when you have inexperienced, or lazt programmers. Source control, architecture, bug tracking, testing, and peer reviews make the code quality better. It isn't really PHP's fault. It allows freeform coding in ways that are harder to achieve in more structured languages which encourage markup and code files to be segregated. It does have some strange behaviour in places but most languages have their quirks. 
You are completely right. Fixed. 
It has an ugly outdated design though. So many horrible function names, very dated OO,...
But Python wasn't created with teh intertubes in mind.
Compared to general purpose languages, PHP sucks. [It just does.](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/) It's the awkward syntax of Perl coupled with a severe lack of design foresight rolled into a language that punishes you for *not* writing bad code. But all of that is coming from the perspective of a general purpose language. PHP is not that. PHP is a language to make writing HTML easier. From the PHP 2.0 documentation (taken from the site previously linked): &gt;Once you start having separate operators for each type you start making the language much more complex. ie. you canâ€™t use â€˜==â€™ for stings [sic], you now would use â€˜eqâ€™. I donâ€™t see the point, especially for something like PHP where most of the scripts will be rather simple and in most cases written by non-programmers who want a language with a basic logical syntax that doesnâ€™t have too high a learning curve. PHP isn't intended for serious programming, and I would go so far as to say it's not intended for serious web app development. However, for what it's intended for (HTML templating, basic database/file io), it does the job without forcing users to learn a full-fledged language and all the stuff that entails. I mean, if someone asked me to make them a static portfolio website with a contact form, I would just do it in PHP and throw it on a $15/yr webhost instead of creating a whole WSGI app in Python.
On reason is backwards compatibility. If you wanted to change function names so that they were all standardized to use underscores between words, for instance, your fix to php would not work for almost any php code out there.
Nor was ruby. (or was it? I dunno.)
&gt; Additionally, if you asked them to write a quick php script, I'd be willing to bet that most couldn't because they've never actually used the language for anything. On the contrary, I only complain about languages that I 1. actually use (hence, have things that have bitten me) and 2. think are repairable.
Yes, but *why* do I need to go read the docs for such a simple operation? This is the real reason I prefer OO design in a language - `someString.split(',')` requires me to think less than `str_split(someString, ',')` (or is it `str_split(',', someString)`?).
Neither was Ruby.
Or strsplit() or splitstr() or split_str()?
I've been using PHP since 1997. I still have to check the docs on some of those. But I really don't care. The amount of time I spend doing that (a few seconds every few days: command-tab command-t php str_split enter) is piddling compared to the amount of time I save on deployment, not having to search for commercial components to solve every basic problem as in the .net ecosystem, and other areas where PHP excels.
Rewriting PHP would be a huge undertaking, and probably would not have a huge ROI. PHP is Good Enough, even if it isn't the greatest. The core dev team of PHP makes notoriously bad decisions, but that's only an ancillary reason. If you re-wrote PHP Zend would not be in the picture, and neither would the core devs.
http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ &lt;--the definitive guide
There's a few different things at play here. * The extent to which PHP "sucks" may be misleading. PHP is immensely popular. The sheer number of people using make it an insanely vocal community, where complaints people have about it are very visible. PHP may suck less than a more obscure language (language X) but you don't hear about that language so often. It's probably a similar effect to why you see a lot more complaints about Ubuntu than other distributions because of its popularity, even though there are dozens of smaller, obscure distributions with bigger problems or more issues. The popularity of PHP amplifies complaints about it. If PHP sucked as much as its reputation suggests, why aren't Python or Ruby (which get a fair amount of praise) way more popular? That may sound like an inflammatory question but it's actually an interesting thought exercise, as long as you're not tempted to go with the easy-out "people are stupid". While PHP has a lot of issues, it was built to be HTTP-native - it's primarily for websites. Its documentation is also top-notch, which helps make up, in part, for any inconsistency between different function names, arguments, etc. And it's familiar and easy to get started with. That is important too, as much as people may complain about it attracting too many noobs, that's necessary for a language that is popular. * It's a false assumption to assume that nobody is working on improving (or "fixing") PHP. Where does this assumption come from? People are working on it, and have been ever since PHP began. The more popular PHP gets, the more people have been working on it. To some extent, many serious problems with PHP that earned it a bad reputation have been or are in the process of being corrected already - Unicode support, short array syntax, function array dereferencing, file upload progress API. These are more recent examples, but improvements to PHP aren't a recent thing. Even back when PHP 5.x was first released, it brought about heaps of changes that the community had been clamouring for. You can't say they aren't trying and aren't actually improving things. * Backward compatibility means that some things are just going to stay the same. This includes awkwardly named core functions. If it makes you feel better, the inconsistent formatting of function names can mostly be attributed to PHP's earlier heritage: PHP combines and wraps many common C libraries from various sources and initially just copied the same function names for many (but not all). Since then, it's stayed that way due to backward compatibility all the way. It's too late to change. If you need it, get an editor with function name autocompletion. But backwards-compatibility is one reason that long-standing issues may be hard to fix at all. PHP devs have been willing to break backwards-compatibility when the stakes were high enough - such as to remove features that were truly insane or security/maintainability nightmares (removing magic quotes). Or even things that were potentially going to come back to bite them later architecturally (call-time pass by reference, object cloning, etc). There needs to be a balance between backwards-compatibility and fixing broken features, and no matter which compromise the PHP devs come up with, you can be sure that there'll be a backlash from one group of users or another.
Your location is important. In New Zealand, the prevailing PHP frameworks seem to be CodeIgniter and Silverstripe. Other frameworks seem to be acceptable here if they aren't relatively obscure - CakePHP and Zend, for example, are valued if you have them because it shows you can pick up other frameworks very easily.
http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ Read this. Though, a lot of points may not make sense to you until you have a few more years under your belt, and have shipped a few products. I would encourage you to learn something like C#/Java while you learn PHP. Each is good for different things, and knowing the limits of a language, where it excels, and where it falters is critical to becoming an experienced software engineer.
+1
Stephenson's Solitaire encryption routine...
Sorry but "all" hiphop is doing is transforming PHP code into C++. The developers at Facebook, from what I'm aware of, are not generally writing C++ code. So, Facebook *is* using PHP and your comment that PHP is not intended for "serious web app development" is clearly incorrect. The criticisms of PHP in your link is not critical of it's performance but of the language construct. Sure, it's not even close to the most elegant language ever designed but it's a capable language and that many, many popular websites and web applications are using it goes against all you have said, to repeat "PHP isn't intended for serious programming, and I would go so far as to say it's not intended for serious web app development". Drupal, Wordpress, MediaWiki are ALL very serious web apps.
&gt;Sorry but "all" hiphop is doing is transforming PHP code into C++. *Because PHP is not intended for such a high-traffic website.* &gt;So, Facebook is using PHP and your comment that PHP is not intended for "serious web app development" is clearly incorrect. Facebook using PHP does not mean it's the best course of action. By your logic, Twitter, Google, Reddit, Amazon, GitHub, and 37signals *not* using PHP is just as much evidence of its relevance as Facebook *using* PHP. I assume you see why that doesn't make much sense. &gt;The criticisms of PHP in your link is not critical of it's performance but of the language construct. Which doesn't discount my original statement. &gt;Drupal, Wordpress, MediaWiki are ALL very serious web apps. They're very *popular* web apps. Wordpress and MediaWiki are jumbled messes, so it's funny you're using them as examples of good PHP software. I haven't looked at Drupal lately to have an opinion on it. If you want great examples of PHP software, look at the Symfony framework and the Vanilla forums. They showcase some of the features of PHP like quickly getting full-featured sites up and running and a very small learning curve. In fact, the only reason Facebook uses PHP is because Zuckerberg originally wrote the thing in it due to him being able to throw a site up quickly, and it's *incredibly* tough to completely switch front-end languages when you're one of the biggest sites on the Internet. Like I said, PHP is great for small-to-medium sites because you can find many people who have some experience in it and it's easy to get a site running. However, once you get into the large-to-super-large range, I doubt you could find anyone who would say they *want* to use PHP.
All things considered, having experience in one of the better known public frameworks is probably better, but just being able to write disciplined code (not mixing view logic into models, that sort of thing) and work within a framework is fundamentally what I'm interested in, rather than exactly what it is.
I've only used on-site developed frameworks within PHP, but have extensively used Ruby On Rails
so is the apt comparison django, pylons, or whatever is the current python web framework hotness?
Denying that it's an issue does not make it a non-issue. There are costs involved with such inconsistencies.
You aren't looking too hard then :p I started using Ruby for systems scripting well before Rails was released. It's still popular for that purpose today. See: Chef &amp; Puppet
I would recommend CodeIgniter... not really because it's the best PHP framework, but because the lessons you learn working with it would translate over to other frameworks in languages like Java and Python. It's a pretty good, standard framework, and it doesn't do anything too language specific.
At that point, I think my bigger worry would be that you'd hate writing PHP all the time, rather than whether you understood how to write framework code. :)
I've been using chef with vagrant for a few weeks now. I feel that the popularity of Rails has brought Ruby itself more attention. I still feel that it will be under the Rails shadow for a while still though.
I'm with you. Personally, I think you can't TRULY hate anything about a language until you're intimate with it. For all the crap people complain about PHP, the thing that drives me up a wall is loose-typing, and having to jump through hoops to know if something is Null, '', False, or 0. Python pisses me off because I hate the goofy UTF string conversion and whitespace as syntax. On the other hand PHP drives me mad because it can't handle anything but UTF-8 properly. It takes me 5-20 minutes to write a button and listener in Java. And on and on it goes. The people you love are the ones who drive you furthest up the wall. The same goes for programming languages.
&gt; If PHP sucked as much as its reputation suggests, why aren't Python or Ruby (which get a fair amount of praise) way more popular? They're actually quite popular; it all depends on which crowds you listen to. From what I see, most new smallish sites (non-corporate monstrosities) are written in Ruby, Python, server-side Javascript, and other miscellaneous things; most PHP sites I see are working on older codebases. Personally, I program in PHP because that's what our website is written in. That's what our website is written in because it was the best choice in 2003 and rewrites of this scale are a Bad Idea without a really, *really* good reason. PHP may have many problems, but its still quite usable.
Amen. I use Ruby frequently, and despite working for a web shop, it's never for the web. Ruby is my Perl.
First of all. I think PHP is great as it is. I code all my small personal web projects with it. At work we use Spring for gargatuan complex projects. We already have Mack 18 wheelers. Why bother to try to convert Mini Caravell into one. We can have both!
These do seem like small nitpicks rather than overarching problems with PHP's design. Unless "lots and lots of small niggles" is *the* problem with PHP. A couple of years back in people had asked me what was wrong with PHP, I'd have tried to list bigger things, like: * Magic quotes (so broken that even if you don't use it, you may have to account/correct for it) * No real Unicode support * mod_php for Apache is inflexible and increases Apache memory usage * General language wishlists like lambdas (functions as objects) And the ever-popular: * Too many noobs use it and create horrible code. Apart from the inevitability that newbies will code in PHP, the other issues have already been fixed or can be fixed. By contrast, to take the top/latest "WTF" example from that phpwtf.org site: $a = array('7.1'); var_dump(in_array('7.10', $a)); // returns bool(true) To understand why this is the case, all you need to know is that *in_array* is doing a type-insensitive == comparison, not a === comparison. This is not unusual for dynamically-typed languages. If this is something to complain about, it's a complaint that could equally be levelled at other dynamically-typed languages who allow type-insensitive comparisons. The mechanics of it is that PHP, as part of a choice made a long time ago, when comparing strings using ==, will detect if two strings are "numeric" and if so will try to compare them as numbers. So different notations of the same number will pass. There were justifiable reasons for this at the time and if you want strict string-based matching, you *can* use ===. It's a design choice of PHP to favour type-insensitive matching though.
We have a ton of PHP that is about 7 or 8 years old, migrating it from PHP4 to PHP5 is hard. We have old plugins that keep breaking due to using old code (e.g. ancient Spaw editors) and we don't have the money or man power to fix this old code. A lot of the broken stuff isn't code we even wrote, it's from old contractors, things we've purchased from now defunct companies, old open source code that we can't upgrade simply ... etc. If they introduced a [break backward compatability] switch per page or per .php file, this may work for us. If they just abandon us devs who use old versions of PHP, then there is no reason for us to stay with PHP. My devs know Python, Ruby and clojure.... the PHP devs are in a hard place :) evolve too much and die, stay still and die...
Pray tell, what about the blog post did you find to be factually incorrect?
|Sorry but "all" hiphop is doing is transforming PHP code into C++. The developers at Facebook, from what I'm aware of, are not generally writing C++ code. Hundreds of (arguably) the best PHP programmers work for Facebook and they can't get it to perform well enough. Facebook would have switched if it were affordable to do so, but they had to settle for some C++ programmers saving the day. Make no mistake -when you hit a Facebook page it is a C++ executable running on the server. Nobody has ever intended for a multi-million-user web app to be built on PHP. A handful of small projects got started in PHP and then exploded in popularity. No serious system architect would recommend PHP for systems that complex and performance-critical (PHP programmers generally haven't read the source code for their language -how can they know anything about its performance?). What's more, no CTO would take you seriously if you did recommend PHP for something like that. Given perfect foresight, the engineers at Facebook would have selected something that scales better. PHP's use in ultra-high-traffic web apps is an *accident* at best. My buddies at Facebook are generally glad when they move from legacy PHP systems to new systems written in other languages. And then there's YouTube, who actually decided it was worth it to eat the cost and switch from PHP to Python to Java as their performance needs increased.
&gt; switch per page or per .php file You can actually run multiple versions of PHP on a single Apache instance using [FastCGI](http://blog.servergrove.com/2011/08/22/how-to-setup-multiple-php-versions-on-apache/) and you can even configure the virtualhost so you can change which version you use on a per project basis. It's just a little more tricky than using mod_php.
You don't really need those framework/wrapper things at all. Just use vanilla PHP and jQuery. Easy as. Get in and build something, that's the only way you'll learn. You can surf and read as much as you like but until you start building and debugging and making software it won't be valuable.
He makes a big list of behaviors and does a lot of handwaving. The majority of his complaints are unqualified assertions (which he even points out early on) and complaints about specific operations....for various reasons - The most common concern is that he doesn't approve. Naming of functions, behavior of the interpreter, etc. Don't cry that you can't change a variable's value in Language Y or Language Z's Hurhur is named incomprehensively and call it a definitive guide to why X sucks. Do you think a non-english speaker cares about these programmatic sigils at all? It's just a set of behaviors. The fact someone thinks they are inconsistent for what they want, is hardly a criticism. What I expect to see are random behaviors (inconsistency in operations), broken architecture...like traits are broken and how that serves to cause other failures, show me exploits that aren't 5 years old (jesus) or dependent on the built-in webserver (you can crash your own machine? that's amazing) Simple exploits that aren't changed in the interest of backward compatibility, is a broken culture and a broken language. Not to go too far offtopic but PHP, Ruby, Python don't have broken cultures and so the languages are pretty much sitting in their own niches.
I would make the language strongly typed. In all the arguments that PHP has its advantages, weak typing is never one of them.
Great points about Perl - I've previously been a "hater" for no good reason and I'm glad to read people coming to its defence because the more I think about it, the more I realise it mirrors my own experience in feeling the need to defend PHP against the constant onslaught of ill-informed groupthink. I have to take umbrage with this one point though: &gt;For large-scale or "enterprise" projects where you need to code defensively and security becomes a paramount concern, that's when it starts to show not its general uselessness but its being inappropriate for a particular task. Exercise just a smidgin of discipline and apply a small amount of knowledge applicable to all programming languages and disciplines I've ever seen, and PHP is no better or worse than anything else for enterprise development from a security/defensive programming standpoint. It's *always* the coder. PHP doesn't make it quite as easy to blow your own everything off as it used to (see register_globals), but a developer who interpolates unsanitised request parameters with SQL is just as dangerous in PHP as they are in any other language. The thing that makes PHP less appropriate for very complex enterprise applications is the lack of shared state - sometimes just keeping a small pool of objects available to all requests to read straight out of memory is so much faster, safer to synchronise, and easier to map in your head than PHP/APC. But that one thing aside, your main point is absolutely right: horses for courses.
This is a good post, but it's not what the OP is asking about.
Yeah, or I could just use a different language (which is what I did). I still like PHP for a small sprinkling of dynamic functionality on an otherwise static site. It's hard to beat in that case. But for nearly everything else (IMO) there are better ways that don't involve me pulling out my hair in clumps. I find this hand waving "it's really not a problem" thing funny. Is this what they call "Stockholm Syndrome"?
&gt;If you did, you could (optionally) use CSS3 + li and divs to display a 'table' (i.e. a grid layout) That's plain moronic. Tables are *designed* for handling tabular data. There's nothing wrong with using tables, provided you use it for the right thing (i.e. not layout). 
I wonder what kind of performance hit you'd get from something like: function str_position($haystack, $needle){ return strpos($needle, $haystack); }
I don't think there should be a keyword for loose typing, just omitting a type should be enough (just like type hinting is now). 
Agreed. I hate the language but because of it's heavy use and the fact things work .... just not well .... is why the language is far FAR from being fixed.
Fabric works just as well for PHP deployments as it does for Python.
&gt;maybe I was unclear, I was talking about http://www.pziecina.com/design/turorial_demos/css3_tablelayout.php and trying to give some encouragement. And what relevance does it have to this? &gt;We use tables for layout when they are simpler than 100 nested divs. Great, so not only do you use tables incorrectly, but you can't code properly using divs either. &gt;even if you're wrong - lol. How am I wrong? Tables are for tabular data. List items are for lists. Plain and simple semantics.
Interesting, but a bit of a shame he didn't bother to upgrade to the latest versions of the framework. Yii 1.1.4 is over 2 years old.
If someone else familiar with the latest Yii wants to update it, everything is on Github. Ran into snags trying to update one of the frameworks (can't remember which atm), so with limited time I didn't update them all myself.
Or at the very least allow primitives to be used as method parameter types.
I don't see how, for example, making strings and arrays easier to work with could be considered ruining PHP. PHP makes me a great living, but I'm under no illusions as to its many flaws. If it stands still as you would like, it will surely die.
did you read the example? It shows divs, nested, with table css attributes. IE6 and 7 don't support these, so you can either hack css2 with extra divs etc to work like css3 or just use a table. Tables have been (wrongly) used for layout since the dawn of the web. It's only the css police who care. None of my employees get confused with a hacky &lt;table&gt; for backward compatability, the internet doesn't explode, firefox doesn't cry, search engine spiders cope OK (of which we have written one.) You're wrong because you don't seem flexible enough to understand that the css spec isn't perfect, there are things that css can do, but that are ugly. This is where an old &lt;table&gt; can step in and fill the gap while everyone slowly upgrades to css3 browsers. Anyway, go live your life. Be happy. We'll never meet in real life (thank god!)
Oh look at that, their own framework came in first place. /cynicism
Why test CodeIgniter 1.7.2 and not CodeIgniter 2.1?
a hello world page for a benchmark test is the most worthless test imaginable of a framework. Get a real world test which actually attemps to insert, query, display, and delete records from a table. THEN tell me how these frameworks compare, your results would be entirely different. As it is now the only thing your testing is the minor overhead these frameworks put ontop of php itself. This is minimal compared to how they actually handle as a framework in a real world project.
What a surprise, the article on the Elefant site shows Elefant as the fastest! Who'da thunk it?
Thanks for sharing! This will come in very handy, the next time I'm about to use a full-fledged framework to build a "hello world"-application. 
Depends on the what the hash is. If it's salted and user-specific, it would make the URL unguessable; just still shareable. e.g. /files/md5('n0:pe' . md5($username . $email))/$file.jpg
The first three, off the top of my head: The namespace operator, before anything else. First of all, it's still recent, so it won't be so entrenched in the code. Damn near anything would be better than the escape token. Full Unicode support. It's 2012, not 1995. THREADING. Give me threads; not everything that runs in PHP does so from a Web gateway.
PHP is the wrong language to do this in. There's a module for Apache that interacts with either DB or prompt authentication that generates a time-limited, IP-based URL to files. I can't remember the name of it, but ask some Apache guys.
Isn't the "minor overhead" a good benchmark though? Frameworks all have a different way of performing "more complex" tasks and comparing them apples to apples may not be appropriate. Breaking it down to a simple "Hello, World" is a solid way to compare these frameworks in a fair way.
The old versions are these: Cake, CI, and Yii. I ran into trouble updating one since I'm not familiar. The code is on github so I'll gladly rerun the tests if someone else updates them. As to Elefant's version, there are zero core changes between 1.2 and the one used, since development only just started on a new version, and actually very few core changes are planned for the next version anyway. Just to clarify :)
Well, it is. Run the tests for yourself, the full source is provided.
It isn't a fair estimate. Take Kohana for example, I'm on their dev team. If you do a simple hello world example, and just echo the words "hello world" from a default controller, you are bypassing our database and database builder libraries, ORM, advance routing, views, cookie management, and any number of modules which are not enabled. Ultimately you may only execute somewhere in the neighborhood of 200 lines of code. There is over 42,000 lines of code committed to the project. In our case, we've rewritten several components which have netted performance increases, such as our database layer and routing. All this work means nothing in the grand scheme of a hello world test. Any framework that employes php autoloading for classes is going to function exactly this way. Classes that you don't call are not loaded, thus are not having any impact on performance. The minor "overhead" of the framework core itself is a drop in a pond compared to the other actual improvements a framework can make.
This article should explain all the differences, which should help you know if you are making the right choice for your application. [FastCGI vs SuPHP vs CGI vs Mod_PHP] (http://bit51.com/fastcgi-vs-suphp-vs-cgi-vs-mod_php-dso/ ) On additional thing to consider is which MPM apache module to use, [worker vs prefork] (http://brian.moonspot.net/2008/02/13/apache-worker-and-php/)
Like many, I would prefer String and Array objects to fix the annoying function inconsistencies once and for all. It can be done without sacrificing any backwards compatibility, so it's pretty lame it hasn't been done yet.
Except you didn't update any of the frameworks to recent versions, and for some reason you put your own framework in a completely separate repo, which could make a small difference.
You must be a blast to work with ;)
Ill take a look at that later today. Had to run into a longer than expected meeting right after posting this...
Hello world is a good indicator of a framework's overhead, since it tests the front controller, bootstrapping, routing, controllers, and how effectively it uses APC or other caching. I'll probably run similar tests against DB layers, views, etc later too.
My co-workers are extremely happy with me.
Fuel, kohana, laravel, silex, symfony, and fat free were all added (and are the latest) by myself, and I've stated I'd like assistance updating the others in their most optimal way. The reason I really hesitate to do it myself is that I'm not familiar with optimizing them all, and the difference between my attempt at running Symfony 2 and their own optimized version was literally a factor of ten apart. As for my own, it's separate because it needs to run in a document root by design, and that was easier to do by separating it out. The benchmark scripts are identical, and I documented exactly what was done to Elefant so it's clear I'm not doing anything fishy. Really, I just unzipped it, added a controller action for the test ad that's it.
But what I'm getting at is comparing Kohana's entire stack to Symfony's entire stack is not going to be a fair comparison. Kohana and Symfony do not have the same feature set and so comparing them is not going to be equivalent. Yes, you could find the common denominator across all of them. But doing that for twelve frameworks? It's going to be something close to a hello world app. Benchmarks are not the 'end all' of comparison. If a developer were to pick a project based solely on benchmarks, they could be making a huge mistake. A benchmark is just one more indicator in a huge list of features. But only taking the benchmark -- regardless of benchmark "completeness" -- into account would be rather useless, I think we'll both agree.
I've posted the code with a request that anyone familiar with the frameworks I didn't update from the original phomark code base update them and I'll update the test results. When I tried adding Symfony 2 myself, I couldn't get it past 10 req/s. then I found a version they provide that's pre-optimized for this and it was 10x faster. So I hesitate to make a similar mistake on those I'm equally unfamiliar with. The beauty of github is that it's easy for anyone else to pitch in those updates too, who have more knowledge of these frameworks.
You're right.
I get what you are getting at, that you cannot compare full stack to full stack. But you cannot compare a hello world to a hello world, it means nothing. It's like trying to say one car is faster than another only by looking at tires that are not even attached to said car. Most worthless test imaginable.
From my experience, there's a vast difference in just the overhead of the core frameworks themselves, both in terms of req/s and memory usage. That's why there is such a variance in the tests. So this is a pretty key element of the real-life framework performance.
Hehe I like your analogy-- but more like comparing the engines of the car. There are a lot more factors to take into account than just horsepower. Anyway, I do agree that hello world is probably not the optimal test, but it would be difficult for one or two people to have the required knowledge of all these frameworks to be able to write a solid test for each framework. What I'd like to see is a sort of competition-- get a bunch of people who profess a love for their favorite framework and have them implement the full stack of features (adhering to some kind of 'minimal set' of course) and then benchmarking those implementations against each other. A sort of 'at it's fullest potential, this is how it performs' kind of test.
Note: To the CakePHP, CodeIgniter and Yii folks, I will try to update to the latest versions today and re-run those. The others are all up to date, as I added them myself after forking the phpmark code base from google code over to github.
I agree, database benchmarks should be separate but are also important to know. Not every web request needs to hit the database after all. I want to do more tests to compare DB layers and view rendering after this.
Now you're just off topic :P We are arguing about benchmarks here! (I agree~~)
&gt;It sounds like you want to make PHP more like Java. Why would you want to do that? What's wrong with Java? With the additions in PHP5+, that's the general direction PHP has been moving (albeit slowly). &gt;but it would be neither PHP nor Java. Of course not, and that's not what the submission was about. This was a theoretical post about how we each would change PHP based on our own opinions. This isn't at all how I would expect PHP to turn out. &gt;it defaults to loose and has keywords, operators, and functions to be strict when explicitly instructed. While I appreciate that, it's quite limited and doesn't allow you to specify the type for, say, primitives and the like. &gt;Javascript is a good example of a language that supports that style without dropping the primitives (it automatically creates wrappers when a primitive is used in an object context). My point was that I want to be able to access properties and methods on stuff like integers, booleans, strings etc. as well. I don't really care about how it handles it under the hood. 
I think this problem was misnamed. He doesn't want to prevent hotlinking, he wants to make it so people can see only "their" images. 
Like the comment in linked SO post says, "readfile" would be quite enough. Doing imagecreatefromjpeg and then imagejpeg right after just increases CPU load and used memory unnecessarily.
If you are using .htaccess authorisation, you could probably use %{REMOTE_USER} in an apache rewrite rule. For example (untested): RewriteCond expr "! %{REMOTE_USER} -strmatch '*://%{HTTP_HOST}/game/images/%{REMOTE_USER}*'" RewriteRule ^/game/images - [F] Basically, if the subdirectory of "game/images" is not same as the username of the currently logged in user, then forbid access to "game/images" files and subdirectories. That said, I'd prefer to do it via PHP, like what noir_lord said.
cookie? ewww
I loved v1.0 of "e" AKA "TextMate for Windows". 2.0 seems buggy, but if you're on a Mac, Textmate can't be beat.
Implicit typecasting should only happen when the two values are of different types. "1" (the string) should NOT equal "1.0" (the string), even on loose (==) comparisons. It sounds like the main use case for such typecasting is when comparing two numeric (but string) input parameters. In all my years of PHP experience, this sounds like a very minor use case to me, and I'd be more than happy to just do explicit casting in those cases if it means avoiding all the horrible side effects of the current behavior. It feels just about as icky as magic quotes. As others have mentioned, having more native-feeling array-like objects would be nice, but I'm sure there are plenty of technical complexities to that. At the very least, standard array functions should accept ArrayIterator objects and call the respective methods. This way, our own functions could more easily accept either arrays or ArrayIterator objects without discrimination, just like they currently can with strings and objects with __toString methods. Others have also mentioned making strings full-fledged objects with properties and method equivalents of the current string functions. If this were done literally, I imagine it would result in a noticeable memory and performance hit. Rather, I think it would be sufficient to treat this more or less as syntactic sugar: strings can be stored in memory as they currently are, but the property/method *syntax* can basically map to normal function calls on the string value. So, we could write $mystring-&gt;length or $foo = $mystring-&gt;replace('-', '_') even though $mystring isn't actually a normal object in memory. Edit: Typo
yeah just saw this too i wrote the orginal text without urls on my phone on the way to home and just editet the post then. Then the session should be looked up and then show his image's as other suggested already 
Thanks I will look into this.
Quick update on CodeIgniter: I've [added 2.1.0](https://github.com/jbroadway/phpmark/commit/cce7a91767c4caa6a4a612f1a1ecd5fa88ad95f3) and ran a test comparing it against CI 1.7.2. I'm on a different machine (2010 iMac 3.06 GHz w/ 8 GB RAM, same versions of Apache and PHP) so I'll have to update the results later after running it on the same setup, but here are the results comparing CI 1.7.2 and CI 2.1.0: APC disabled: Run benchmark (y/n)? y Testing http://www.bench-base.lo/codeigniter-1.7.2/index.php Completed 5000 requests Finished 6370 requests Testing http://www.bench-base.lo/codeigniter-2.1.0/index.php Finished 3883 requests Document Path: /codeigniter-1.7.2/index.php Requests per second: 212.14 [#/sec] (mean) Document Path: /codeigniter-2.1.0/index.php Requests per second: 129.37 [#/sec] (mean) APC enabled: Run benchmark (y/n)? y Testing http://www.bench-base.lo/codeigniter-1.7.2/index.php Completed 5000 requests Completed 10000 requests Finished 10245 requests Testing http://www.bench-base.lo/codeigniter-2.1.0/index.php Completed 5000 requests Finished 9144 requests Document Path: /codeigniter-1.7.2/index.php Requests per second: 341.50 [#/sec] (mean) Document Path: /codeigniter-2.1.0/index.php Requests per second: 304.80 [#/sec] (mean) More updates to follow.
Just added CI 2.1.0. I'm not on the same machine so I can't update the page until I re-run the tests later tonight, but [here's a quick comparison of CI 1.7.2 vs CI 2.1.0](http://www.reddit.com/r/PHP/comments/se3wd/performance_benchmarks_comparing_12_php_frameworks/c4dd0jz) on my current machine.
Then you should rerun the Elefant test for version 1.2.0 and post those results (which should be same as the results for 1.3.0 like you said). Just to make sure no framework is tested on an unstable version.
Why not? There isn't a whole lot about the language that makes it specifically designed for web programming. It's Just a language. I write shell scripts with it all the time, as it has become my most fluent language, being a php web developer. Is it really all that different from writing ANYTHING with perl? It's not like writing scripts with CFM!
Just because a test could be better, doesn't mean this is useless. Also, hello world speed is not that important. For example, soon as I looked at the Elefant's homepage first two things I noticed are "templates" and "compiled templates", and considering my (indescribably horrible) experience with compiled templating engines I will never consider Elefant for actual use. But I still appriciate his testing.
Included Elefant 1.2.0-stable and ran a comparison against 1.3.0-master: APC disabled: Testing http://www.bench-elefant-1-2-0.lo/hello/world Completed 5000 requests Finished 8998 requests Document Path: /hello/world Requests per second: 299.80 [#/sec] (mean) Testing http://www.bench-elefant-1-3-0.lo/hello/world Completed 5000 requests Finished 8964 requests Document Path: /hello/world Requests per second: 298.78 [#/sec] (mean) APC enabled: Testing http://www.bench-elefant-1-2-0.lo/hello/world Completed 5000 requests Completed 10000 requests Completed 15000 requests Finished 15716 requests Document Path: /hello/world Requests per second: 523.86 [#/sec] (mean) Testing http://www.bench-elefant-1-3-0.lo/hello/world Completed 5000 requests Completed 10000 requests Completed 15000 requests Finished 16368 requests Document Path: /hello/world Requests per second: 514.14 [#/sec] (mean) As you can see, almost identical.
No prob. [Here are the updated Cake tests](http://www.reddit.com/r/PHP/comments/se3wd/performance_benchmarks_comparing_12_php_frameworks/c4ddgv2).
My templates are Handlebars/Mustache-inspired with a few extras to do Pull-based MVC from a view, but they compile to PHP via simple regexes like this: {{foo}} becomes &lt;?php Template::sanitize ($data-&gt;foo); ?&gt; You're free to use PHP in them and skip any Elefant-specific template-isms entirely, and the resulting templates are secure because the compilation step doesn't receive the actual data passed to the template, they happen entirely independently. That's why the compiled PHP is safe to run via a `require` statement. If that's not your cup of tea though, no prob. Just thought I'd clarify :)
When looking at frameworks, there are only two things that might make me ignore it: forced templating and forced ORM. Also, it doesn't help that you consider compiled templating the best feature of your framework.
awesome, thanks. i'm really surprised how slow cake still is at 2.1 (with APC on, i'm not really concerned about APC-off performance in production obviously)
Yii 1.1.4 vs 1.1.10 comparison: APC disabled: Testing http://www.bench-base.lo/yii-1.1.4/index.php Finished 4526 requests Document Path: /yii-1.1.4/index.php Requests per second: 150.84 [#/sec] (mean) Testing http://www.bench-base.lo/yii-1.1.10/demos/helloworld/index.php Finished 3798 requests Document Path: /yii-1.1.10/demos/helloworld/index.php Requests per second: 126.50 [#/sec] (mean) APC enabled: Testing http://www.bench-base.lo/yii-1.1.4/index.php Completed 5000 requests Completed 10000 requests Finished 10611 requests Document Path: /yii-1.1.4/index.php Requests per second: 353.70 [#/sec] (mean) Testing http://www.bench-base.lo/yii-1.1.10/demos/helloworld/index.php Completed 5000 requests Finished 9262 requests Document Path: /yii-1.1.10/demos/helloworld/index.php Requests per second: 308.73 [#/sec] (mean) 
Biggest one for me which is almost a daily occurrence is, having consistency in function signatures. (Too little too late however to actually make the changes in production)
You're not forced to use templates or my ORM. Database connections lazy-load, so you're free to use any ORM you want, just add it in a bootstrap.php file and you're good to go. For templates, you can use whatever you want as well, including plain PHP `&lt;?=$foo?&gt;` tags. To completely disable Elefant's internal templating/theming, just add `$page-&gt;layout=false;` to bootstrap.php and it will skip any automatic layout templating completely. And I'm not sure how you arrived at me considering my templates to be the best feature. I mention them under the 'Built for designers' section of the homepage, but to be honest I consider there to be a lot of good features :)
I know at least a few of the frameworks tested here are several versions behind. I don't really think these benchmarks are relevant today.
You mentioned compilation step when talking about not using templating, but now that you mentioned disabling it, great. Also, I didn't say you use ORM (from a cursory look through your docs, you only have PDO, which is not an ORM. Doctrine and Propel are ORMs) just that I don't like them at all. As for the last thing, go to your homepage. The very first thing explained is "compiled, ultra-fast templates". Not saying that's bad, its just a turn off for me.
did you have the Symfony2 reverse proxy cache enabled? The results look low if you did. Maybe the page was set to no-cache/private or something. I did a benchmark myself a while ago with and without the proxy cache on a simple blog-like application: https://github.com/warmans/Yaf-PHP-Example-Symfony2Equiv 
No problem. There's a lot of disagreement over templates (from pure PHP, logic-less like Mustache, some logic like Handlebars, or a reimplementation of PHP itself like Smarty ;), so fair complaint. I do have a Model class that provides some ORM capabilities, but yes the DB stuff is just a PDO connection manager and a few convenience functions on top of it. The connection manager handles lazy-loading as well as master/slave awareness for you though, which can be handy :)
Btw, about templating, one of the codebases we have to maintain uses custom invented templating system, with a special windows-only program which must be used to compile the template into executable PHP code. So, at work I have to use a VM just to run that one program, so I can compile the templates every time there is some minor change... Sure that is an extreme example (worse than even Smarty, which I also used to use), but since I see no advantage to any templating system ever, I'm opposed to all of them.
You mean like register globals thing? It does happen, just rarely.
Why would you do that? Just store the files in a directory that is not readable by web visitors, but IS readable by the web server.
For things PHP is used, I'd consider it a good thing that 7.1 and 7.10 are considered same by default. And of course, like weeeny said, there's always the third param for in_array, or ===.
That works. I forget that's a thing.
- yield - named parameters, and function / method overloading - utf-8 as default for every char processing function - jit compilation in a core - native support for web sockets (both the client and the server) - make extension development more straight forward
Don't. Most sane people have gotten over this idea in 2002. It just breaks the web when you do it.
On the creation of session with the end-user logging in, create $_SESSION['imgkeys'] as an empty array. Every time you want to src an image, first create a random hash using md5() paired with the filename and set that key in session. ($_SESSION['imgkeys'][$new_md5] = 'foo.jpg') ... then equivalently &lt;img src="/img.php?key=&lt;?=$new_md5?&gt;"&gt; Have img.php look in $_SESSION['imgkeys'] for the appropriate file name with $_GET['key'] ... session_start(); if (array_key_exists($_GET['key'], $_SESSION['imgkeys'])) { $filename = $_SESSION['imgkeys'][$_GET['key']]; header('image/jpeg'); echo file_get_contents('my/dir/structure/' . $filename); } else { http_response_code(403); echo '&lt;h1&gt;GET OUT.&lt;/h1&gt;'; //optional logging, maybe using whatever user_id you have available to you in session. } Before img.php's header(), optionally delete the session key with unset($_SESSION['imgkeys'][$_GET["key"]])--this will make it impossible to even reload the image outside of a page request first which may or may not be advantageous to you. Without deleting the session key, this method still ensures people can't go poking around guessing filenames by specifically authorizing every legitimate img src. Ideally, you are storing the images outside of the DocumentRoot as set up by apache for additional security. (alternatively, you could just name the files by whatever random key you have and store them in somewhere like (/images/a/f/1/af1e7....jpg with DirectoryIndex turned off in apache, but this absolutely necessitates a working db behind it, (no db? you're fucked!), it's more complicated to make and store the destination directory and pair the filename with the new key, and it doesn't prevent hotlinking.) 
There are three FastCGI's with PHP. * PHP-FPM * PHP's built-in FastCGI * Those FastCGI bash wrappers floating around using PHP-CLI or PHP-CGI I use PHP-FPM and nginx and I haven't missed anything from my Apache days.
I wonder what is stopping this from happening. I hear about backwards compatibility, but the part that I'm confused on is that features and functions are deprecated all the time. Can't PHP 6 be developed (revived) with none of the fluff from previous versions, and people will start using it gradually?
Thank you for bringing sanity into this thread.
I'll agree here. We can do it with objects, but not primitives.
AWK
I'd +1 this saying how great running on [PHP-FPM](http://php.net/manual/en/install.fpm.php) can be.
Is there a more advanced Hello World out there? Some project thats coded in each of these frameworks that could actually provide a decent brenchmarks? A simple Wiki website or Reddit clone perhaps?
I would remove all the extra SHIFT + KEY typing. It's just annoying. * `$` isn't needed if the parser is fixed to be a smart as other languages * `class::method()` would become `class.method()`
Perhaps a blog app that draws a handful of posts with a couple comments each from the same database schema, then rendered a very basic HTML page with that info using its preferred ORM/Model style and preferred view/template for the output. But I think I'd prefer knowing how each layer performs independently. I think I'd like a typical hello world for the controllers/routing/initializations, and at least two more for database access and templates. Hello world is also an okay test of what the framework's own impact will be for REST API calls too.
I mean one big sweeping change. Things like cleaning up the global namespace and actually designing the language rather than tacking everything on. Also utf8 support.
Coda and TextMate are names I hear thrown around a bit. When you want to use more powerful IDEs, take a look at PhpStorm as they have an OS X version.
I use vim when working in terminal, editing small scripts, and Sublime Text 2 when doing proper work.
True, true. Would be nice to have something like this for comparison I guess. The problem of course would be that, like desktop benchmarks, the producers of the frameworks target these ideal applications rather than the general use cases. The extreme example of this would be a single call API: &lt;?php $this-&gt;MakeBlog('Hello World'); ?&gt; ... and say "you only need one line of code to make a blog in Acmes Yet Another PHP Framework (AYAPHPF)". It must be the more optimal!
[BBEdit](http://www.barebones.com/products/bbedit/index.html?utm_source=thedeck&amp;utm_medium=banner&amp;utm_campaign=bbedit)! I've been using it for about the last fifteen years or so - I can't imagine working in anything else.
Coda and TextWrangler as a backup
I use TextMate, it's very powerful, however you can't really go wrong with many of the basic editors * Textmate * Sublime * TextWrangler * Coda * BBEdit I've slowly started to move across to [MacVim](http://code.google.com/p/macvim/) however, but quite a learning curve for those that haven't worked with vi(m). Personally most IDE's on OSX clunky, I guess due to the fact that they aren't a native OSX app.
It was just a few weeks ago that I noticed how much work my pinky finger gets while working with PHP.
I used to use Textmate but I've switched to Sublime Text 2 and love it.
Coda or Sublime Text 2
PHPStorm is excellent. Easily the best PHP-specific IDE I've used.
I already had BBEdit installed actually and couldn't get into it. There's nothing wrong with it per-say. I like that it focuses on simplicity instead of being big and bulky like Netbeans or XCode or Eclipse. I come from a Notepad++ background so I definitely prefer the "simple but effective" approach when it comes to an IDE. Maybe I'll give BBEdit another try. Do you by any chance know a way to change BBEdit so that when you highlight multiple lines and press TAB that they all tab over? 
PHPStorm and TextWrangler
i second this...best editor i have used
If you don't care about your data being leaked or compromised, why even hash them at all? Just put in your rate limiting and call it a day.
I know a **lot** of people love vim, but you *have* to buy into the vim paradigm for it to really pay off. Otherwise you're just going to be working far slower than if you used a nice GUI-based editor.
Up until about a year ago I did all my work on OS X exclusively and everything was done with Coda for the first few years and then PhpStorm after I learned how amazing it is. Now I'm on Linux (Elementary OS) and still using PhpStorm. Coda has some awesome plugins but nothing compares to the speed of PhpStorm and it's built in features (no idea how it's so fast considering it's all Java).
Emacs of course!
Sublime Text 2 all the way. Haven't found a better one yet!
Oh I can see [legitimate reasjOIJWEUHM](http://gifs.gifbin.com/1238157980_scanners_-_head_explosion.gif)
I want to give you a prize, but I only have a bumpvote :(
I hear some people use ketchup on their hashes.
There are many kinds of businesses, each with their own dynamic. I can only comments based on the kind of company that I work for... If anyone has a concern with anything that is going on, it is REQUIRED that they voice it. If they don't voice it, then we will either end up with a shitty product or a disgruntled employee with trust issues. Now, with that being said, you do need to pick and choose what you decide to bring up. Don't yell at someone for a shitty function name. Use your you best judgement. Also, be sure that you aren't just missing something. Seems as though a lot of new programmers (not saying that you're one of them) will think that a piece of code is shit iff (if and only if) they don't understand it. So my advice: get your ducks in a row. Make sure that you stand behind your comments and then present them. 
It's going to depend a lot on the current devs. It's going to be difficult to go into a new job and "change things up" without stepping on the toes of people that have been there longer than you, even if your ideas are more "pure". Frankly, it sounds like either a) the developers there are overworked and don't have time to do things the right way or b) they are incompetent. Trying to fix either one of those will likely mean damaging someone's ego. You're not going to be happy working in a place where nobody likes you. If you've been there for a month, you've probably gotten to know the personalities of the current devs. I would suggest determining which developers would be most likely to agree with you. Then pull them aside and speak with them privately. Have discussions about what would be best and come to a reasonable decision. In other words, start from the ground up instead of going into a meeting and trying to take control of everything. 
what makes it the "wrong tool"? I do plenty of things with php on the command line and it works just fine. Of course you can do it a plethora of other ways, it doesn't make them "right". This wrong vs right argument with computing that I hear lately is mostly a lot of circle jerking.
I did something like this but I just read the file names from the directory the classes were residing in. It also wasn't a forward facing app or rather clients didn't see just the site administrators.
I'd wouldn't jumping into WP hacks right away. If you need to build a WP site, try using a theme like Genesis/Revelations. It'll give you a lot of control over the content. As for PHP, there are a lot of great tutorials out there (check out nettuts.com) to get you started and on your way. Good luck!
My pardons -I should elaborate. Different languages are good at different things. It's possible to make pretty much anything in any Turing-complete language, and so there is a lot of overlap in language domains. Accurately understanding the rough edges of a language can only truly be accomplished by working from outside of that language's rough edges -that is to say one must: 1) Work with languages that address the same problem domain 2) Work with languages that address different problem domains Learning Python and C#, for example, will give you a reasonable foundation from which you can form validated opinions of PHP (and Python, and C#). Many experienced software engineers find PHP lacking both in and out of its domain. Why then, don't people fix it? The simple answer is that there's no reason to. If you judge PHP to be inadequate as a web scripting / templating language, then you can switch to Python or server-side Javascript at pretty much zero up-front cost. Likewise if you find PHP to be inadequate for your giant enterprise project with 100 programmers, C# and Java are more suited to it. If you find PHP to be suited to all your projects, then great -nothing really needs to change. TL;DR; There's no reason to overhaul an entire language when you can just... switch languages. People who dislike PHP stop using it if they have the opportunity. There's a whole universe of great programming languages out there and learning new ones is actually fun.
I disagree. You just have to show success or show in dollar and cents to get management to see the light. I have to admit, it's very difficult to change the culture of a company when you're the new guy. Try to shoot for minor victories.
It seems leaving the echo in is the only way I can produce anything. I'm also not sure if the else needs to be there? I don't understand PHP, it seems to 'loose' on it's syntax structure. I ask 1 question and get 20 different answers, very confusing/frustrating.
The only criticism of a language you accept as valid are randomness, broken architecture, and exploits? Here's "Hello world!" in Brainfuck, which has no randomness, broken architecture, or exploits: "++++++++++[&gt;+++++++&gt;++++++++++&gt;+++&gt;+&lt;&lt;&lt;&lt;-]&gt;++.&gt;+.+++++++..+++.&gt;++.&lt;&lt;+++++++++++++++.&gt;.+++.------.--------.&gt;+.&gt;." I therefore say that Brainfuck is immune to criticism as a language. Let's do the polite thing and assume that all Turing-complete languages are free of randomness, that most languages have a reasonable architecture, and that any exploits are few and far between. It's pointless to criticize languages on these points because no popular modern language should have any of these problems to begin with. We'll call it the Bare Minimum and not the High Bar. The issues *you* handwaved away are the only ones that are actually worth discussing. Consistency in naming, feature design, and API structure. Consistency and predictability in the interpreter/compiler. Non-English speakers who are skilled programmers do in fact care about "programmatic sigils". The naming *scheme* used by an API determines how easy it is to learn, even if the names themselves mean nothing to you. I can write code in an API I've largely never used before if the API is has consistent and sensible naming. Please don't bother trying to refute this unless you've used many APIs across many languages.
I have to agree here. 1 month? Unless you have been doing this stuff for over 10 years (i.e. major experience) don't. What you could do is, instead of a comprehensive document with everything in it (which would never work anyway) do *1* thing! Just 1! Pick some of those duplicate functions for example and propose to merge the code. If your ideas are accepted then go ahead and implement. Then for the next suggestion you'll have more credibility. If your ideas are rejected then you'll have to accept it. It's not your business after all. You are not responsible for success or failure, you are responsible for doing what you were hired to do. Never forget that - while you can, and should, offer advice on the success of the business, at the end you have to remember your own responsibilities. I got fired one time for doing something that ensured the success of the project, but simultaneously failing to perform my own duties. Don't make the same mistake.
Ah, I see what you mean. If this is only on the admin-side, then I would say you can go for it. I would absolutely still sanitize your incoming data to make sure the file/classnames exist before you toss them into the database.
I would do something like this, but would make sure you toss that &lt;b&gt;&lt;/b&gt; statement inside of an else statement or place an exit(); after those header tags.
I'm curious... * Are things being autoloaded, namespaced? * What about a front controller? * How about error handling, events/listeners? * Is there a business logic layer, or just one file with functions in it? * There version control? * Are tests being written? * Code review? * User stories, a uml of something, maybe a list of requirements? Is framework the right word, or are they bashing a whole bunch of code together to get something working?
Oh really? Neat! That's good to know. 
That's what I am sort of struggling with at the moment. But in order to do my job now, most things are broken already and there's very little documentation or examples. I figured it was something I could understand after a day or two, but everything is just so out of wack, it doesn't make any damn sense. I have tried to offer advice (like I said, I stopped not too long ago) but would get shot down.
What if I was very, very clear when/if I present my ideas or alternate code? I really could care less about "being #1" in anyone's eyes. I do want to work for a company that's working on a cool product; I just don't want to waste my time if in 9 months everyone's realized that we need a complete rewrite anyways.
Start looking for another ship to jump ship to, but in the meantime, what have you got to lose by doing your own thing? Is it something you can do alone, or do you have another dev with similar ideas as yours willing to help out? If they're unwilling to see things your way and allow you to do what you must, write your own amazing framework anyway, on your own time, and compete against them.
I don't care about function names. While they are certainly important to an extent, I am more concerned about the functionality itself, how the whole system works, and its flaws. There is no real separation of concerns, or even a logical layout files. No unit tests or tests of any kind, really. No examples. I don't know how they know it works - all the functionality I've tried to work with is just broken as fuck. I apologize if my syntax sounds odd, I am not a native english speaker - some of that maybe hard to read.
I have written a framework or two and have used other popular ones (Cake, Zend, Symfony). Now, of course, my frameworks were not as nice =) I have signed a contract with my company, so I can't really 'compete' with them afaik. I dont want to, to be honest. I want to be a part of the company, and help them create the product that they see in their heads..be part of something bigger, you know? In the meantime, however, I have other things to lean on. I have residual income from other sources, so I am not worried about money.
Never said that bro I said I would hear him out but at the end of day he's getting paid to do a job and if he doesn't like it its pretty simple, he can find another one.
Silverstripe does this, but AFAIK its only for mapping relationships within its ORM and initially building out the database. I don't particularly like it, but that's why I'm learning what makes it tick. I wouldn't write code that structurally depends on the content of a form submission, since a malicious user could change the values. If you weren't careful, an incorrect class submitted from an offline form submission (or even just changed with Chrome's 'Inspect Element' tool) could trigger a stack trace and expose technical information. Some other issues: it would be trickier to debug, and you'd probably suffer from a performance hit if your code relied on a database call all the time. 
and get fired there as well. if you have found a workplace that is willing to coddle you over every misgiving you have of their business plan then i guess you're in the right place for a guy like you. You guys mustn't get much done.
It's possible they simply have a different programing philosophy from you. After reading your other posts you have a choice now: Either you fit in - you accept what you have and the way they work and work quietly to make it better or you leave. If all you are doing is being constantly angry at the project then forget it, don't stay. Forget about making a huge change in the project. From what you write it will never happen. So either accept what you have or leave. Detroit doesn't sound like a great place to find jobs now, and you are happy with the pay. So perhaps you will simply have to accept it. I caution you about one thing though: If you are unable to quietly change things you will eventually learn bad habits. This is ok short term (under a year), but if it's longer than that bad habits will make it hard to find a new job. You can counteract this by programming for yourself as a hobby - including all the best practices you are not doing at work. Perhaps find an open source project you like and get heavily involved in it. This is also good experience though - you will need to be able to work with bad code.
No need to echo if just using HTML?
If you want to store classes/paths, use APC. Or something like memcached for distributed storage across multiple machines (although APC is faster). If you find no records in APC/Memcached, then insert them from a single loop. In this way you avoid the overhead of going to the database and extracting the record.
My first thought was "why are they creating a framework in the first place?" Creating a bespoke company CMS I can understand, but a framework?
There's too much history, too much things that keep the language from evolving (backward compatibility is a MUST for hundreds of thousands of companies). Best that could happen is a new project, with these features : * new language (we forget ALL about the past) * very similar C-like syntax, only with a few improvements (namespace operator shouldn't be the escape character, named parameters in functions, maybe get rid of the $ prefix for variables) * solid namespace policy for core functions * solid naming policy for functions * solid policy for function parameters order * UTF-8 as a default * PDO-like unified database-access layer with toggleable drivers * simple and efficient module API * simple debugging and profiling API * exceptions as the standard for error handling * MVC as a (toggleable) extension (see [YAF](http://www.laruence.com/yaf/)) * [KISS](http://en.wikipedia.org/wiki/KISS_principle) as a mandatory [tatoo on both hands](http://www.tvworthwatching.com/werts/night%20of%20the%20hunter%20poster.jpg) of every person willing to join the core team * ...
Not sure I agree. First, even though PHP was built for the web scripting/templating role you described, it's used for bigger things now and there's no reason the language can't change to suit that. Second, even restricted to that 'minor' role, it could still be improved in many ways.
The Zend/PHP tokenizer eats up a single CRLF or LF after each close tag. So those must indeed be subpar IDEs, as it would require two line breaks or an actual space at the end of the line etc.
It works best when paired with plugins such as NERDTree and Pathogen.
Have to agree with the above - if you aren't in a job where you're challenged (in a good way) your skills may deteriorate unless supplemented with a bit of open source work to keep your skills sharp and knowledge relevant. I did notice that you said they have no testing. Regardless of their coding quality, isn't the lack of testing a driving force in requiring functions and duplication to make stuff work the hard way? Maybe you can convince someone that a sprinkle of unit testing would make bugs harder to occur, require less work over time, and will help identify similar functions (to avoid recreating subtly different ones) that need refactoring (i.e. smaller pieces that can be recombined at will). I agree with others that trying to change the culture wholesale will likely fail. Sounds like there's a lot of complacency and it's possible that those in charge are a wee bit out of touch with their ground level staff if this is going unnoticed. Testing - pretty easy stuff, discourages random unchecked change, identifies dups and similar functionality, addictive, and it's very very easy to explain to even less experienced programmers as an obviously good thing. Might be one change you could achieve with minimal time cost (i.e. don't let it override your job responsibilities).
My motto is simply if you don't need it, don't add it. It's pointless to add more code that doesn't do anything.
it was announced that the new Drupal will be using Symfony 2 components, so having knowledge of Symfony 2 may be even more beneficial.
So what about includes? 
This is what happens when you mix a programming language with a templating system. IMO it's actually quite counter-productive to even *have* open/close tags. But hey, it's PHP... so yeah.
&gt;why no one tries fixing it? From what I understand of the situation, the core PHP dev team can be difficult to work with and aren't that good at coding. Thus, no one really bothers to try fix the issues because the codebase looks like shit. However, this may be just crap filtered down a long line of 'I heard it from so-and-so who heard it from so-and-so'. I've never really bothered to check because I believe that it doesn't really matter as long as you are comfortable with the language of choice. Leave the fanbois to whine and complain, you have a job to do :)
really..? newbie..? most modern frameworks have the very same recommendation.
Yes, really, newbie. Especially frameworks which implicitly or specifically target inexperienced user bases: [http://codeigniter.com/user_guide/general/styleguide.html#php_closing_tag](http://codeigniter.com/user_guide/general/styleguide.html#php_closing_tag) And yes, I'm derogatorily counting Zend and Symfony with in.
Any file you include in a PHP script is parsed as text from the beginning (that is, it won't execute as PHP until a "&lt;?php" tag is reached).
And most modern frameworks are written and used by newbies. Notice how they're all basically the same golden hammer, each slightly rephrased.
What? Not including the closing tag at the end of files is suggested EVERYWHERE. Adding it is a bad habit.
&gt; IMO it's actually quite counter-productive to even have open/close tags. [You're not the only one.](https://wiki.php.net/rfc/phpp)
If you do sysadmin work from parsing XML or content on other sites, you are doomed.
There's no advantage to having it validate either. It doesn't mean browsers render it any better.
I have known about this for years but choose not to do it. I've never have a problem with a closing tag, and I like the feeling of consistency that leaving it in gives me. Plus, it makes it easier to know that I'm looking at a complete file. If it's missing, I feel uneasy. Maybe the file didn't upload all the way. Maybe I accidentally removed a huge chunk of code. Seeing that closing tag there is a nice sanity check.
Thanks. I didn't know about that. 
I'd suggest in the example docs to demonstrate defining separate closures then using those as callbacks, vs inline closure definitions. For complex stuff, it'll get harder to read and test. Cool idea all the same...
That's not entirely true. IE will go into quirks mode if the HTML doesn't validate and quirks mode is really annoying to deal with plus parses slower. There are tons of advantages to validating HTML, none to using closing PHP tags at the end of files.
Nope. This is considered best practices (on PHP-only files) everywhere. And for a good reason! Some editors like to add whitespace at the end of the file, and this can break havoc, for example the "headers already sent", or worse, if you're programming APIs, whitespaces can break everything (believe me, I've seen it happening many times). The bugs introduced by these nasty whitespaces are VERY hard to find, you have to check all the included files to try and find the trailing piece of evil, and often it's not even clear how many files or which ones are included. NOPE.
The problem isn't that a good developer should catch a trailing whitespace error, it's that ANY developer can potentially introduce the error. If you're maintaining a framework or any multi-contributor project, the cleanest solution is simply to omit the ability to introduce the error. Alternatively you can do hooks and processes on your version control system to make sure there are no trailing spaces, but this is just MORE setup and introducing more complexity and room for errors. And let's say you're working with and supporting a project that someone else is expected to configure? Do you really want to go through all the bug reports of end-users who think YOUR software is broke, because their text-editor saved a white space at the end? 
There's been lots of chatter about it on [internals](http://markmail.org/thread/3qtptmts6eputikh) (that's just the most recent thread, there have been several).
Who doesn't like playing with their shit after they poop?!?!
Ah, I see it now. My English language parser failed this time.
Sublime Text 2 with prefixr and git plugins. 
Yes yes, indeed. You're right. And specifically for distributing *some* code I utilize the `--unclosed` conversion. There's no way I'm responding to folks who can't be bothered to google anyway, but I rather prevent the redundant annoyment there. But the ineptitude of others doesn't mean I have to adopt the simplistic coding style for my own code. Specifically if some of my apps depend on concatenatable include scripts for example. Which is why I see no point in adopting a workaround for a problem that I personally do not have. But now we had this discussion a dozen times here on reddit last year. And for some reason people always portray the close tag issue as the **sole** reason for headers already sent errors. Which it isn't. It's one out of half a dozen. Eschewing close tags avoids quite a significant percentage, but basically just delays the error discovery process. So, again, what's the obsession all about?
Care to elaborate on some of the other causes? I am fairly experienced but can't think of them off the top of my head. Thanks for the phptags tips. I wasn't aware of that. 
Good show mate!
I've done it in very specific scenarios, its not optimal and reflects poorly on the design, but it works. In one scenario I used it w/in a url router in a custom framework I wrote. I really increased execution time because when it queried the database for the template to load based on the URL it was able to autoload the class rather than doing a bunch of sql like it was before. I am not sure how scalable of a solution this is though.
PHP Manual says: &gt;If a file is pure PHP code, it is preferable omit the PHP closing tag at the end of the file. This prevents accidental whitespace or new lines after PHP closing tag which may cause unwanted effects because PHP will start output buffering when there is no intention from the programmer to send any output at that point in the script. http://php.net/manual/en/language.basic-syntax.phptags.php
It might be so, but it still gives me an uneasy feeling. Maybe it would be nice to be able to have pure php code files... 
I didn't downvote you, by the way.
Wow, what were the chances of seeing you here...
Why would you even make this comment? Someone gives good advice and your first reaction is to post a response in which you talk down to them? It seems you had something valuable to add to the OP's very reasonable advice, and it is unfortunate that it will be lost since it is hard to upvote a guy that seems to be more interested in insulting someone than constructively contributing to a useful conversation.
My guess is that you're being downvoted for the last sentence since you make a good point otherwise. This problem exists because PHP templates need an open and close tag and PHP classes/includes do not. It is a shame, but it is the reality.
That got ugly QUICK.
I see what you did there
What you did there. I see it.
Ha ha
Love me some Komodo IDE.
Regarding making a constructive discussion. It's still unanswered specifically why "many are not aware of" OPs advise. It seems every commentor here on reddit *does* have an opinion on it. So, is it news? If not, whom could it help? (My guess, as you probably noticed, was "newbies"). Does it reach the intended audience here? Will it solve *all* associated problems of the intended audience? -- Because you know, otherwise it's just another coding style reharsal amongst those in the know.
Nah. I'm too much of a perfectionist for that. :p
This is what really intrigues me about the whole language vs language debate. After 10 years of using php day in and day out, what problems are compelling enough to throw out 60-70% of what you know through PHP to start over and learn a new syntax(with its own oddities and quirks) and memorize a whole new set of APIs, classes, argument orders, and put all that back into muscle memory, not to mention having to learn an HTTP library on top of the new language to even be able to talk over HTTP. Is it the all-in-one frameworks that make this massive shift worth it? If it is, do you think that you can get by in a programming language by just learning a specific framework? I have been using php for about 6 years now and while I do use a mvc framework for most projects I cannot justify the downtime for my clients in learning a new language. Speed is king for me, if you have invested enough time to be very efficient with a given toolset, what part of the equation is great enough to unbalance the efficiency you gain by being an expert with that particular tool?
I guess. I just thought you may have meant to say "...written FOR and used by..." Either way, I don't have a dog in this fight.
Databases are fast because among other things, they implement indexes - something this doesn't seem to do. One might ask why you would use this over your current RDBMS or NoSQL option.
The concatenation is basically a poor mans phar://. During the dev stage I run them as ordinary include files, but for deployment a single blob is much easier. Again, it's certainly not a syntax error to omit the ?&gt;. Yet to me it feels akin to omitting { and } for single-line if blocks, just because the syntax was okay still. If you say collaboration in large projects, you mean you can't know the editor variance and knowledge level of all participants, right? Well obviously then it's simpler to agree on eschewing rather than postprocessing. Though you get more easily bitten in the butt by imported dependencies. &lt;?Which the aforementioned automatism would catch.?&gt;
Cake is very "slow" as in you can't process nearly the same number of requests per second as CI. This benchmark seems a bit outdated, but it still holds up to the real world testing I conducted when I was investigating the various php frameworks. [PHP-Framework-Benchmarks](http://www.elefantcms.com/wiki/PHP-Framework-Benchmarks) The only thing "slower" then Cake is the Zend Framework, as in, script execution takes much longer on full size projects then Cake(see Magento, though I don't entirely blame the speed of magento on the ZF). Hopefully they fix the speed issues with the new v2 that is coming out soon(already in beta). The functionality included in ZF is awesome but I am not going to deploy 7x the server resources to run it at scale. Luckilly, ZF is modular, and if you only need the Lucene search functionality for example, you can just grab those classes (plus a few utility classes, like the exception and base zend classes) and run it separate from the framework as a whole.
&gt;I don't use version control. Too much work. So much for the perfectionist angle. &gt;when I work on a website by myself, having backups of check-in is worth less to me than my time You miss the entire point of version control.
I investigated both of these frameworks a few years ago (back when CI was at version 1.6) and settled on CodeIgniter solely based on the controller structure and that I don't have to write confusing class inheritances or extra "routes" for my app to work. If I create a controller, the URLs map directly to the class name and function name of that controller. After that, you have near infinite freedom to construct you app the best way you can think of. That is the main reason I picked CodeIgniter over Cake. That and CodeIgniter can serve more requests per second on the same hardware versus CakePHP. Besides that, they both offer nearly the same functionality, but CodeIgniter does not force you into "it's" way of thinking. You are free to build out your sites as you see fit, with any combination of views, libraries, custom (regex) routes, etc.
&gt; So much for the perfectionist angle. Perfectionism is not doing things perfectly. It is doing things to your own standard of perfection. &gt; You miss the entire point of version control. Then what is the point of version control when it is being used by a team of one?
Initial view is that the basic idea is ok, but some of the details could easily be improved. These are what I picked out - Firstly, he's using the mysql_ functions when there are much better alternatives. Database sanitation/escaping isn't touched on, although in this case it doesn't matter so much as he is only allowing alphanumerics. Best practice is to always escape though. -Talking of the restriction to alphanumerics, there isn't really a reason to restrict password characters as long as your database is set up right. You should allow users to use whatever they want. - Using unsalted MD5.. really??? - Unnessary use of ternary operators e.g. (cond) ? 1 : 0; when returning a true/false value. - He uses 1/0 instead of true/false. I guess its a preference thing, but I prefer the boolean as its clear there are only two states. - You will get a notice I think when setting the md5 password variable if not logged in and that session key doesn't exist. - use of short tags (not a biggie though) My main issue with the tutorial is that there is no clear explaination of *why* things are being done how they are its just BAM! code! A solid introduction explaining the data flow would be invaluable.
&gt;Basically I need to find a way to pull a pdf file that is stored in a MySQL Database Why, oh, *why* are you storing a PDF in the database? &gt;and display it on a webpage $pdo = new PDO($dsn); $stmt = $pdo-&gt;prepare("SELECT pdf FROM mytable WHERE id = ?"); $stmt-&gt;execute(array($id)); $result = $smt-&gt;fetch(PDO::FETCH_OBJ); header("Content-Type: application/pdf"); echo $result-&gt;pdf; 
I agree... it makes me feel uneasy leaving out the closing tag.. it just feels incomplete. 
Just as a comment, Pacific Time works well for people in other time zones as your 8 am is my 10am. Considering I currently work 9-6 CST, that isn't much different than my normal schedule. If you were in Eastern time, working with people in PST would be tough unless they were early risers.
&gt;That was the only way i could think of doing this. Really? Well, I'm just putting this out there, but maybe you could have, oh, I don't know, saved it to the file system, considering that it is a *file*? That's why we have functions such as [move_uploaded_file](http://php.net/move_uploaded_file).
&gt; I don't use version control. Too much work. Since something like: hg init hg add * hg commit -m "Initial commit of site" ...or... git init git add * git commit -m "Initial commit of site" ...is too tough as an initial setup. I suspect the average person takes more time/effort in to setting up their editor or working environment than most need to do to get some form of version control working. 
&gt; most modern frameworks have the very same recommendation. You mean most modern **PHP** frameworks? /ponders Edit: Still, I'd be interested in a citation/reference/source, here.
Didn't say it was, but synchronizing (non-SCM) files across multiple servers is a lot more difficult than move_uploaded_file.
&gt; any citation for that? oh wait you're talking out of your ass as usual. stupid, amateurish, dumb, unaccomplished, cunt. With all due respect, your point would seem a bit more valid if you could refrain from name calling... Oh wait... *\*looks at username(s)\** ...suddenly makes all-the-more-sense, now. /sighs
&gt;Didn't say it was Certainly sounded like you implied it. &gt;synchronizing (non-SCM) files across multiple servers is a lot more difficult than move_uploaded_file. That completely depends on the architecture. &gt;move_uploaded_file I hope you realise that the above sentence read "function*s*" (plural) and "such as"? If you're trying to imply that I said that move_uploaded_file is a magic, catch-all function, then you're severely mistaken. move_uploaded_file is an example which I mentioned to illustrate a point, which is that its mere existence should make it clear that there are other ways of storing uploaded files other than the database. 
Sublime Text 2 on *every platform*, in my opinion. It is light years ahead of anything else I've used to date- also there are a shit-ton of plugins. 
&gt; It's not the same... there's literally no advantage to having closing PHP tag. I disagree. It's akin (and somewhat "opposite") things like [trailing commas](http://stackoverflow.com/questions/2829581/why-do-php-array-examples-leave-a-trailing-comma) in [arrays](http://www.php.net/manual/en/language.types.array.php) ... or, effectively a placeholder for additional content. More over, in other languages, it's generally considered "good form" to close your loops, end your statements cleanly, etc. The fact that the parser will barf or cause errors in the server and/or browser with pure whitespace, is, well... I find it a tad silly. To be more clear, perhaps there should be a file-level setting that simply says "ignore all extraneous whitespace" or "pure php file only" type... maybe something like: &lt;?PHP -*- coding: php-only -*- [...] ?&gt; 
That sounds like less of a timezone issue and more of an erratic work schedule issue to me.
Another reason to do this; some attacks will append code to the end of PHP files, surrounded by &lt;?php and ?&gt; tags, because it expected the file to close it's tag too or by HTML. Failing to close the tag will cause your site to crash if it gets hit by this, exposing the attack.
The fact that there's an open tag for the language is pretty strange in a world where we should rarely if ever actually embed code into a document. Short tags I can understand for templating, but actual code shouldn't need them at all (it should be in a separate file). It's a relic from the "hypertext preprocessor" days when that was the recommended usage.
See how you can easily read word documents and pdf files from PHP.
You're ignoring a lot of details. Installation, learning how to use version control, transitions between command line windows and editor windows, etc take up hours and hours of time. It takes me 10 minutes to setup my working environment from a fresh reformat.
The $, get rid of it. That's the single item I'd remove.
Personally I use Tmux with VIM. I have Textmate and Sublime Text 2 but really only use those if i'm working on something local on my box. Since 99.8% of work is on servers 1000's of miles from me.
That's your choice. Just be aware that the vast majority of professional programmers will strongly disagree with it. I would strongly recommend that you at least take the time to play with and understand something such as git, subversion, mercurial, or similar before completely discounting it.
Very true, I'm sorry for whoever was acting childish to you. However, most of the people that support the advances PHP is making, are the same people that have to deal with backward-compatibility issues which is why we are so glad to see the future PHP is bringing. In un-related news, you can still use the same PHP version you're using forever if you want. You can even continue to patch and update the source of your version long after PHP stops supporting it. No one says you have to update.
Sorry, but did you even *read* my entire response? Or understand what I had written?
&gt; You're ignoring a lot of details. Installation, learning how to use version control, transitions between command line windows and editor windows, etc take up hours and hours of time Yeah, you're right, to an extent. In all fairness, I've probably glanced over the idea (or "assumed") that most people that work in development environments probably have experience with source code control of some sort, just as part of their job... and the windows GUI folks probably can at least type in a URL/URI for their version control system (though, for command line windows, I guess I probably assumed that many would be using [Cygwin](http://cygwin.com/), and probably at least understand it). Of course, the linux folks can mostly "apt-get install" or "yum install" or "yast install" or the like. &gt; It takes me 10 minutes to setup my working environment from a fresh reformat. I used to have similar issue... of course, these days I basically just pull up a command prompt and: git/hg clone https://my.example.com/git/username/home ...but, in all fairness, I've also taken to jumping from client to client a bit, so "new" machines are a *not uncommon* occurrence for me -- and I needed to reduce my job-to-job startup time. (and yes, I still use Mercurial ... mostly because it's generally easier to push authenticated changes back to the server from obscure locations which may or may not like "strange" protocols or port numbers going out of their network (read: git, ssh, etc)... and I've not really taken the time to beat on a good http-push for my git server, yet. /smirk)
upvoted for calling me a "bragging prick". :D For the record, I have read a lot of comments - including the one that inspired me to make this post - that say things like "I wouldn't use this code because it isn't properly namespaced and doesn't follow my favorite naming convention".
How about this? function getAge($secs) { $strings = array( 31536000 =&gt; array('1 year ago', '%d years ago'), 2592000 =&gt; array('1 month ago', '%d months ago'), 86400 =&gt; array('1 day ago', '%d days ago'), 3600 =&gt; array('1 hour ago', '%d hours ago'), 60 =&gt; array('1 minute ago', '%d minutes ago'), 1 =&gt; array('just now', '%d seconds ago') ); foreach ($strings as $key =&gt; $value) { if ($secs &gt;= $key) { $val = floor($secs / $key); return sprintf($val &gt; 1 ? $value[1] : $value[0], $val); } } } And instead of doing this: $timestamp = time() - strtotime($rs[1]) - 25200; Do the following in SQL: SELECT UNIX_TIMESTAMP() - UNIX_TIMESTAMP(field) as age FROM mytable
&gt; skills: QR Codes What, like writing something like http://phpqrcode.sourceforge.net/ or just knowing how to install a library? &gt; skills: SMS Sending an email to a [SMS gateway](http://en.wikipedia.org/wiki/List_of_SMS_gateways) ? Or are you talking about two way transactional communication?
How does "I won't use that because it's not namespaced" equate to "you suck, I don't care if upgrading PHP on your server screws your clients, just do it"? I'm sure everyone, myself included, has to maintain some legacy code for some client somewhere. That being said, if I'm developing for a new client, or a new project, I will use PHP5.3 and the features it offers. And yes, if something isn't "properly" namespace ([PSR-0 spec](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md)), I typical won't use it, and here's why: PSR-0 namespacing almost guarantees there will be no collisions, code is separately maintained. I have no need to know about including files, *any* PSR autoloader will be compatible with said 3rd party library. Given it's PSR-0, I don't need to look at their code, I can use/create automatically generated API documentation. If it's a git repo I can autoload it with [composer](http://getcomposer.org) or as a git submodule. It makes integration and sharing code easy. While I will agree saying "I wouldn't use this code because it isn't properly namespaced" is a (wrong) negative comment; I'm sure they meant better. PSR is a format about collaboration. For too long the PHP community has had terrible NIH (Not Invented Here) syndrome where everyone re-invents the wheel. This push for PSR is meant to knock down entry barriers. While I typically won't use something (net new) that isn't PSR-0, I would politely encourage anyone creating something new to adopt the standard. 
&gt;TL;DR; The new features in PHP 5.3.x are awesome... some of us are stuck at 5.2.x for a number of reasons. Many hosting companies don't seem to have a problem offering multiple PHP versions, and even per-vhost php.ini configuration files. If you can't figure out how to do this, it's because you're not a very well educated sysadmin.
&gt;It makes it very easy to develop and test... I work along the branches to the point of release. Once I'm ready to push changes, I simply "merge to master" and the live site is published Meaning: Instead of editing and debugging the live copy, which can be a fiasco, he tests new features in different branches and when they are fully operational he merges those changes into the live copy.
&gt; just knowing how to install a library? Probably :P It's one of the things I was asked to include. I would guess just a general familiarity with how they work and how they are applied. &gt; are you talking about two way transactional communication? Precisely. One of the sites we're working on uses the Twilio api for SMS marketing.
Why would I want to watch videos as a tutorial? I can't copypaste code to try it out, I can't easily skim it through to see if I know it already, I can't easily go back and forth in itâ€¦ Additionally, I'd think video tutorials are more likely outdated or buggy since it's not that easy modifying them based on user comments. Maybe someone likes them, but I just don't get the point over well-formatted text + code examples on a page.
how would a host supporting 5.3 allow him to get original source code encoded for 5.1 to use or re-encode for 5.3 ?
I find it curious that you assume that my post was based on an air of superiority. I certainly didn't intend it. I just am not good at being humorous.
My servers are WHM. I am not sure that I can do that. I never claimed to be a super sysadmin... but I rarely have downtime or any serious issues. I am able to accomplish most of what I need done.
it's a socal thing. when i moved to san diego from the east and central timezones, i realized everyone one has an 'eh just chill out bro mentality.'
Personally, I'd send the raw dates/times, and have it converted to "xx hours ago" in Javascript on the client side. That way it caches more usefully and you can let your users' overpowered PCs do some of the work.
I'm not sure how that helps anything unless you royally screw up your project as you're working on it. Under no circumstance should that ever have to happen if you separate your concerns.
because copying and pasting code isn't a tutorial, it's called taking code and learning nothing ;)
I agree with this 99.99% of the time, but I have a story to tell where it bit a client in the ass. He hired a contractor that invariably screwed him and embedded a malicious script somewhere in the application that truncated the database tables with a specific GET parameter. He encrypted the code with this parameter which made the Truncate impossible to search for, and added it after a shitload of whitespace in a class file without a closing tag 
a lot
It seems set_exception_handler() has caught some of the exceptions while the authentication server is running, however, not when it is down.. Nonetheless, thanks for the information on this handler. I used: $handler = function($errno, $errstr, $errfile, $errline) { if ( E_RECOVERABLE_ERROR===$errno ) { throw new ErrorException($errstr, $errno, 0, $errfile, $errline); } return false; }; set_error_handler($handler);
What exactly are you trying to accomplish with your site? A tutorial or utility for using a custom framework? Or..?
Consider closing with /* End of file myscript.php */ Some big open source projects use this convention (phpBB comes to mind) to make it obvious if the file has been truncated in transit. I started doing it a while ago and it feels much more complete.
I'm sure that's not true. Sticking a `&lt;!DOCTYPE html&gt;` on the top will always force standards mode. "Validating" has nothing to do with it. Since that one's not true, what are these other "tons of advantages"?
Nope, if you include them at best nothing happens.
Send the raw timestamp info to the client and have a javascript format the display on the client-side.
As someone who has worked on a few custom frameworks, they're a bad idea from the start. What you should do is write your own code as best you can and start reading up on Yii, CakePHP, CodeIgniter or one of the many other well-made, mature frameworks available. The odds are high the custom framework will be scrapped in favor of one these sooner or later.
The class names that are being stored in the database are either loaded through a factory class or through some validation first then autoloaded. &gt;Is the user truly choosing a "class" - as in, is this some tool for developers, or is the user really choosing something else that happens to be implemented such that each option uses a different class for some purpose? Not sure what you mean, but the user is selecting a few classes from dropdowns that are later aggregated to perform an evaluation for a container class.
Damnit. I'm not even going to edit/correct it. That's my own self-punishment.
Well, it's much more complicated than the example I'm about to give, but let's say you have class named A and B. A takes a number X and applies formula A to it and returns the resulting number. B takes a number X and applies formula B to it and returns the resulting number. On the GUI side, the user gets to select whether A, or B, or both is applied to the given number. When the user is done selecting, the selected values get stored into the database as "A" or "B" or whatever the class name is for that given number. Say the user selects both A and B to apply to X. In another section of the code, when X needs to be computed, a call to the database retrieves all classes associated with X (in this case, A and B) Both class A and B are loaded via an ORM factory and then they operate on X, so something like: $arr = db_get_rows(X); foreach($arr as $v) array_push($classes, orm_factory-&gt;load($v)); $x = 1; $results = array(); foreach($classes as $v) { $results[] = $v-&gt;operate($x); } print_r($results); Now imagine expanding the number of classes the user gets to select. In this example, only A and B exists in the list but practically it can have a few hundred.
I really wish they'd build this natively into PHP. After using LINQ in .NET, then moving to PHP for my current job, it was a challenge not being able to easily query arrays for simple things like filtering out a value.
Ahh, OK, I misunderstood - I thought you were referring solely to deploying your application, it didn't register that you also meant "configure the whole server from scratch" as well, which as you say can be a bit of a pest with PHP. The pip/virtualenv thing you mentioned can be simulated reasonably well with composer (and it's quite easy to create your own repositories with any zipball package or github repo you please), but that project is still very much in active development and it can be a bit of a headache to keep pace with the refactoring they're doing while they settle on a structure. Nevertheless, it looks like a promising solution for that particular slice of the deployment problem pie.
Agreed. Video tutorials for programming are pointless, in my opinion. I watch design and audio video tutorials, those are great. But I don't want to hear someone blabbing about code, I'd rather read it.
Could of happened with a closing tag too. What's your point?
Hi there. You turned an otherwise civil thread into something uncivil. I have removed this comment, and you should consider yourself warned. We have a somewhat strict civility policy. Please keep it civil in the future.
I recommend using HTML to PDF , if you can. HTML is much easier to manage compared to all of the other pdf via php options. Basically, you would store content as html, and convert it to pdf as necessary. [dompdf](http://code.google.com/p/dompdf/) is pretty good.
"Google" ?
This is a bit like the difference between [file_exists](http://php.net/file_exists), and [is_readable](http://php.net/is_readable)/[is_writable](http://php.net/is_writable). The file_exists method only tells if you the file actually exists, but that doesn't mean you'll be able to open it and read from or write to it. So you might as well use is_readable/is_writable right from the start, and save yourself a headache.
As usual: It depends on the use case / scenario :)
And now pls: Something like this as a php module! (.so)
So you close PHP tags because you might add extra content after it at some point? Seriously? This is your argument for why you should use a closing tag? I fear you have bigger issues than closing PHP tags then.
My guess from your looking at your code, the error message, and the documentation for mysql_connect that your server has safe_mode enabled. http://php.net/manual/en/function.mysql-connect.php The relevant part: &gt; server &gt; The MySQL server. It can also include a port number. e.g. "hostname:port" or a path to a local socket e.g. ":/path/to/socket" for the localhost. If the PHP directive mysql.default_host is undefined (default), then the default value is 'localhost:3306'. **In SQL safe mode, this parameter is ignored and value 'localhost:3306' is always used.** &gt; username &gt; The username. Default value is defined by mysql.default_user. **In SQL safe mode, this parameter is ignored and the name of the user that owns the server process is used.** password &gt; password &gt; The password. Default value is defined by mysql.default_password. **In SQL safe mode, this parameter is ignored and empty password is used.** Edit your PHP.INI file and set safe_mode to off. 
http://en.wikipedia.org/wiki/Muphry's_law
10 years and you haven't discovered version control? wow. you have no idea the freedom afforded to one when one can literally fuckup the entire codebase and fix it with a simple checkout.
Lol, you're of the mindset that you can't screw up? I guess that makes unit/functional testing obsolete also?
Yes, with yield I mean just that (look C# for yield break and yield return). For sockets, I mean that right now it is not easy to write web socket servers with PHP (I know that you can write PHP script and execute it to start a server, but I'm looking more robust and easy way to do that). So called "realtime or live web" is looking to be the next big thing in web development. If PHP doesn't have the features to support it easily, people will move to Node.js or something else. PHP's shared nothing approach is a little bit against web sockets (that are usually long running server processes with communication channels kept open). So I don't know how to approach this problem, but the problem is that currently we don't have a nice and reliable way to write these live channels with PHP. Or do we?
I've always left it off, and in code reviews, I point them out to be removed. It's never had the chance to bite me in the ass. :)
Try a [phpinfo](http://php.net/phpinfo) page?
Correction: I don't want to learn new things when I don't need them.
Screwing up is different from completely obliterating your entire codebase.
No, no, NO! A million times no! Use interfaces or inheritance. Why on earth should I have to guess if a given class has a method defined? If class A is similar to class B but has an extra method, then B should extend A. If you have to call method A::foo() from elsewhere then A should implement an interface. Anything else is dubious design.
OCD isn't a good reason to develop a programming habit. In fact I'd say you're letting your weaknesses influence your work, which is no good for anyone.
and don't forget to remove that file after your problem is fixed. Going to www.somewebsite.com/phpinfo.php returns something on way too many sites, there is some valuable info for hackers in there.
What a horrible statement. The PHP devs purposely made the closing tag optional, and don't use it themselves. I guess the core devs are noobs too?
Argumentum ad verecundiam. It's astonishing how anal people here are about such a trivial syntax option. It's even more astonishing how everyone seems incapable of comprehending that it's just one out of a myriad of error causes. Not found the link? Couldn't be bothered to read? Should I use more bold or something?
If you don't mind being vulnerable to man-in-the-middle or replay attacks... You really need to do this with sessions, and have a private key (generated per-session, w/ timeout) passed along with the request to ensure that you aren't open to attacks.
You could head over to r/WebDev and explain your site a little bit and say that you're looking for testers. I did that once for a little browser based RPG I was building and was able to get a few people to test it for vulnerabilities. 
First of all, whether or not it works. Secondly, whether or not the mysql extensions are enabled. Once you got those cleared out, check your php.ini's error_reporting and display_errors. Finally, start debugging your scripts. Easiest way, at least for me, is to try to print nonsense at various points in the code. Other people might prefer checking the error log. 
1. Read about PDO or mysqli. Use it instead of the mysql_ functions. 2. You have no way to see if anything went wrong or if your query is running correctly. First, echo `$sql` to make sure that your SQL query is valid. Second, if you insist on using mysql_ functions (and this is only for debugging), change your query line to `mysql_query($sql) or die(mysql_error());` Also change your `mysql_connect()` and `mysql_select_db()` calls to the same format. That error info is invaluable. You will also want to validate and filter the input to prevent SQL injection. Again, consider PDO or mysqli instead. 3. In all likelihood, `$submit` is not actually a set variable. You probably want `$_POST['submit']` since it is part of your POST data. 4. 3 could have been figured out by adding an else block to make sure your code block is actually being executed.
I tried adding : $result = mysql_query($sql); if (!$result) { die('Invalid query: ' . mysql_error()); } But got the same result.
I cleaned it up some and posted it on my site. Leave a comment by clicking any line in the code; https://codetique.com/vhe73JaF
For one, it's pretty easy to mess up the entire project if you make a typo in a central class. For two, having a live site go down every few minutes while you're working on it and debugging it is pretty unprofessional. Sandbox branches with version control helps prevent this. For three, you can change multiple files in a branch. Then, if the feature doesn't work, you can just scrap the branch and not waste time scrubbing all traces of the feature out of your solitary copy of code.
Assuming everything is running on the same server, you could modify RoundCube to get the username from your session -- which would be more secure and more of a long-term solution.
You should read up on sql injection when you get a chance on wikipedia, after you get this working. Because, if I said something like this into three of the fields: ',(delete from news),concat(' '),' Your query now reads: INSERT INTO news VALUES (NULL, '',(delete from news),concat('','',''),'','') And assuming I work at it a little more to make the syntax valid I could do some serious damage to your database.
&gt;I guess the samples are quite old. If you need samples, just have a look at the PHP Manual. &gt;what is mysqli and pdo? MySQLi = MySQL Improved. PDO = PHP Data Objects. MySQLi is the successor of the mysql extension, and support a lot more features (most notably being prepared statements). PDO is a unified API for databases. It supports cubrid, sybase, firebird, ibm, informix, mysql, sql server, oracle, odbc &amp; db2, postgresql, sqlite and 4d. Personally, I find PDO to be easier to work with.
Yeah I have a lot of .net and vb and c# experience but just now dabbling in php. So I have a lot to learn and am very appreciative to all your help.
Thank you jim.
Go to fiver and pay people to upload a dozen or so posts?
Use the __call() magic method to deal with non existent methods? Because that's what I do...
thank you for your help, I appreciate it :-)
https://www.mturk.com/mturk/welcome Just be specific with the brief
Quick update: All frameworks have been updated to their latest versions on the site with the exception of CakePHP. I'm running into issues on the test machine with CakePHP and caching (any help would be appreciated :), but here are some stats on another machine comparing CakePHP 1.7 to 2.1: http://www.reddit.com/r/PHP/comments/se3wd/performance_benchmarks_comparing_12_php_frameworks/c4ddgv2
Well yes, it's too early still. [http://w3techs.com/technologies/details/pl-php/5/all](http://w3techs.com/technologies/details/pl-php/5/all) If you deploy on a custom setup, all is fine. But the majority is still bound by server reality. Maybe by next years it's feasible to utilize all new gimmicks. But for now that's the exception. To me anyway. I'm not only deploying to my own server. Regarding namespaces. I wouldn't touch that shit with a 10 foot pole anyway. It's the mark of low quality code. Self-proclaimed expert PHP coders don't quite often rationalize the use case for namespaces. In other eco systems it's by now well understood that they aren't meant for creating taxonomies.
Yes please. Publish a proper test. Right now that's a silly micro optimization meme. It's the tokenizer, not the parser, which sees (or not sees) PHP close tags. And it's hard to believe it would make a measurable blip with anything below a million include scripts.
I would also format your query like this : INSERT INTO news (`heading`,`body`,`date`,`auth`,`auth_email`) values ('$heading','$body','$date', '$auth','$auth_email'); make sure your Primary Key is auto increment , Not Null, Unsigned *Column names ,of course, can be whatever you named them.
I hadn't heard of [Composer](https://github.com/composer/composer) before; thanks for the mention.
Sorry, don't do that. You're just begging for SQL injection here, but besides that, with numbered indexes in a form submit some browsers might do things you're not expecting.
Ok so I have tried to make this work doing everything a beginner can to make it work. I am unable to make this work and now my code is completely screwed up. Would someone mind making my code work. Just a simple php script that will add a name, address, phone number, email, heading, news, so I can disect it and figure out how to make this work. I am simply over my head in code now and completely confused. Thanks.
I'd save it. If he wants to code like a novice for another 10 years, that's his problem.
Not exactly... but I generally do it "for consistency" at least. But I'd still not say there's "no" advantage to it (ie. arguing more of the absolute statement than anything else). &gt; I fear you have bigger issues than closing PHP tags then. And, why do so many people in this subreddit seem to like to resort to ad-hominem argument as-if it helps makes their point? It actually *weakens* your case (and subtracts from the overall value of the discussion, IMO)
I always declare my properties first and then use them. Also my main base class has __get and __set handlers that raise exceptions so it's impossible to use a property without first declaring it. It cuts down on accidental typos going unnoticed.
Ah, cool idea. I'll play around with that.
how am i not informed? i understand that PHP recommends you not close their opening tag. i understand that this is to prevent errors when PHP developers add whitespace accidentally after their closing tag and get confused on why they have output. you don't think PHP seems a little hackish? mysql_escape_string, mysql_real_escape_string, magic quotes, etc... all seem a little hackish to me.
&gt; I'd also consider not using a language in a production setting that feels the "best" way to solve a problem My statement has nothing to do with PHP, so your argument is moot. Pick any language you want, and give a developer a choice of two functions. Both do the same exact thing, but one sometimes crashes the program. What would you think of the programmer that picks the function that randomly explodes just because it has a cuter name? That's what this closing tag argument boils down to. "I use closing tags because they're cute!"
&gt; I think have to check if the controller has the barAction() method. Do you want to guess how I do that? Use the __call() magic method to deal with non existent methods. Please try to keep up. 
Where is *anything* declared? Looks like this script has been pulled out of the dark ages when *register_globals* was the default setting, and nobody had heard about SQL injection. It needs to be destroyed.
Yeah, mysql is obviously loaded -- you wouldn't get those errors if it didn't. It's just not accepting your hostname, username, or password values. At this point, I just recommend trying mysqli or PDO (the mysql extension is disgustingly out of date anyway) and seeing if that helps. 
 if($user) { die('user name already exists'); exit; } Auch, and if($err) { die('missing input'); exit; } Why not just use that 2 seconds and make a nice error handling. And in your messages::send(), you are actually doing some model stuff. I dont think it should be the controller to make and send the message, imo the controller should only send the message to a model which sends the messages. If you want to switch to fx emails instead of sms you only need to change the model, and actually you could make a abstract model so the user could select sms or email in the frontend. Something like this abstract class Model_Message { abstract public function sendmessage($message); } class SMS_Model extends Model_Message { public function sendmessage($msg) { // Do the SMS } } class Email_Model extends Model_Message { public function sendmessage($msg) { // Send email } }
If this is a known issue, and you're not comfortable going into the database yourself and manually changing the seeing, you may be forced to beg/pay someone to go in and change it for you. Choose wisely, they'll have access to your database.
Nah you don't need phpmyadmin, but it helps a bit to visualize. Join #phpc on Freenode and PM me and I'll try to help you out.
thaaaanks.
Don't use or die(). It's [problematic](http://www.phpfreaks.com/blog/or-die-must-die) at best.
For debugging purposes when you have code this simple, it's fine. He's not making production code for a large site, he's trying code from a book.
Perhaps if you can give us the context of its use, we can explain it to you?
Sessions are per-domain -- so if your email client is on a different domain then you won't see them.
Did some research: RoundCube doesn't use PHP sessions, it just sets the cookie's itself. Maybe this will helpful for you: http://blog.philippheckel.com/2008/05/16/roundcube-login-via-php-script/ 
this article if full of shit. it seems You haven't programmed in PHP very much
Hah, bummer. I wrote it a couple weeks ago too. :P
Good point on the sending. I come from a CI background which kind of encourages pretty fat controllers. But I honestly hadn't considered that.
You might not believe this but for me it's the second link when Googling for "RoundCube php". I didn't expect it find it.
True, it's a lot more clear this way. Although, you need to try to avoid column names being named the same as SQL keywords, in this example : body and date. A duct tape fix for it would be to put them inside backticks, but the best way is to avoid that in the first place. A code editor like Notepad++ can help you spot them by enabling SQL syntax highlighting.
Your Insert SQL is wrong, after "INSERT INTO news" you need to list off the columns to which you are inserting. IMO...Use CodeIgniter because it makes working with your databases much simpler and also more secure...Inserting into the table w/ CodeIgniter looks like this... $data = array( 'colname1' =&gt; $heading, 'colname2' =&gt; $body, 'colname3' =&gt; $date ); $this-&gt;db-&gt;insert('news', $data);
"Your Insert SQL is wrong" Incorrect - his SQL is perfectly valid (although certainly not ideal).
I put it on my site so people can leave more relevant line by line comments on your code. Click any line to leave a comment. https://codetique.com/OzxPJ1Us 
have you tried parse_url() function from php? http://php.net/manual/en/function.parse-url.php
&gt; time is a bigger priority for me. In certain contexts (also mentioned above), I would further argue the version control tends to be a *time saver* (especially in the long term). Sure, there's a bit of overhead, particularly if you're not exactly comfortable around it... but overall, *it's a good thing* - a **very** good thing.
[Here's my take on it, with regexes.](http://pastebin.com/0E1a85UC) * Call `get_imgur_ids($haystack)` to get an array of imgur image IDs found in the haystack. Same with `get_youtube_ids($haystack)`, but for YouTube video IDs. * Call `get_imgur_imgs($haystack)` to search the haystack for image IDs, then wrap them in `img` tags. Yada yada `get_youtube_iframes($haystack)` blah blah. The YouTube regex is more complex than I'd hoped it would be, and it overmatches somewhat, but it does cover a good number of edge cases. Probably not a good solution for input validation, as it will match several things that aren't valid YouTube URLs (`http://youtube.com/&amp;v=VIDEO_ID` springs to mind), but it should do OK for this.
You kind of hit on a bunch of points but none had anything to do with PHP, or the tutorials... that's kind of missing the point.
[/r/programminghorror](http://www.reddit.com/r/programminghorror) needs you.
vesperofshadow was actually suggesting that the OP put the column names in backticks, but failed to realize that reddit formats backtick-surrounded text as `monospace`. (To display a literal backtick, one may, of course, escape the backtick with a backslash: `\``.)
You **think** you don't need them. I've worked with people like you. They would sit there with 30 tabs open in notepad++ (again, thought they didn't need an actual IDE) not being able to shut any till they had finished what they were doing because that was the tracking system. One particular person also didn't use paramaterized queries, and for exactly the same reason as you: too much work. You are either very lazy or you are doing incredibly minimal coding.
Came here to say Aptana Studio 3... It's what I used when I was on a Mac at work...
Hey that's pretty cool with the backup script! Once with PHP on Ubuntu I wrote a script that moved all the photos and videos over a certain size on the whole HDD into a single folder with unique names. It was for backup purposes, LOTS of media, and it worked like a treat without any memory or timeout issues.
metal worker \m/
&gt; for consistency As opposed to the consistency of just not using it? Both are consistent, one is the exact same as the other except requires extra typing and in some extreme cases can cause issues if someone ends up being an idiot and adds actual space after it. &gt; And, why do so many people in this subreddit seem to like to resort to ad-hominem argument as-if it helps makes their point? Because it's a valid point. If you use closing PHP tags because you might as some point add content after it then you're mixing in presentation logic and that's a much bigger problem. It's not an ad-hominem argument, it apparently just went over your head what the actual problem was.
This is the funniest thing I've seen all week!
sorry bro but that was horrible... somebody wrote a library and is charging for it? PHP is opensource... is that your company? Free the data, free the knowledge, free all of it. They should be giving that away for free.. it's only code.
Someone has started the crowdtesting one. Lets do it.
&gt; Because it's a valid point. But the need to try to insult someone's exterior motives and/or life simply because you don't agree with them, even strongly, is *completely invalid.* You have, essentially, zero knowledge of my background, experience, or anything of the sort ... but feeling the need to call out "other issues" or tell say something is outside of my understanding is, essentially, trying to make yourself feel better by putting someone else down ... and only makes you look like an idiot. &gt; It's not an ad-hominem argument, it apparently just went over your head what the actual problem was. I think you need to look up the definition of [Ad hominem](http://en.wikipedia.org/wiki/Ad_hominem). As my father always said, "Every time you point the finger, there are generally three more pointing right back in your own direction."
I know exactly what you mean. God, what a pain in the butt that was. 
Are you serious? It's "only code"? Embed.ly is a very useful service and they have every right to charge for it.
To be fair the guy is a php developer and was making fun of that infamous article of last week.
That's the problem. You need Your own VPS
It's not hard to run a VPS. In this case, they set everything up for you.
I couldn't find any [alot](http://hyperboleandahalf.blogspot.pt/2010/04/alot-is-better-than-you-at-everything.html)'s
&gt; But the need to try to insult someone's exterior motives and/or life simply because you don't agree with them This is not so. It's a valid argument because it counters your argument that you use closing tags because you might want to add more content later on. This is a bad thing and as such is not a valid argument for using closing tags. By phrasing it as I did I actually didn't insult you, I assumed you would know that mixing business logic with presentation logic is a bad thing, I gave you credit. &gt; I think you need to look up the definition of Ad hominem. I did not attack you, I said that your argumentation for why to use closing tags was flawed as it showed far bigger problems. If you feel this is a slight against you then it's basically impossible to say anything you do is wrong...
How's about dropping a comment at the end of your file, like "//EOF" ? This might help to wean you off the old closing tag habit. 
http://pastebin.com/xBeaqHX5 Totally different.
&gt;I don't see why error_reporting is complex... It's because there are two ways to report an error: PHP's errors and Exceptions. The language uses these interchangeably. &gt;I also do not get stack traces by default when I work with Python. That seems like an issue with your install. &gt;But when I need to change variable type in Python I need to constantly think about variable types.... That would be the benefit. &gt;nobody compiles PHP on their own Lots of places compile PHP. Not everyone runs a LAMP stack on Debian. &gt;that's the point of @. Don't use @ and You will get warning.... It's heavily abused as a fix for poor programming instead of a debugging tool. &gt;of course it will return 0 if needle is found in position 0 and logically it will return FALSE if needle is not found... (side note: I'm not the article's author) This is a problem in combination with the language's weak typing. &gt;null is not a number so is not comparable with &lt; or &gt;. However, PHP compares them and determines it's less than -1. &gt;and what is problem with this? It's inconsistent with variables. &gt;You don't have to import or #include anything to get basic functionality... His issue is that it dumps code directly into your file akin to C's `#include`. &gt;Of course there should be ending for blocks because PHP does not enforce coding standards... It should enforce some sort of coding standard. I don't have an issue with PHP's `end` syntax; it's a templating language for HTML so of course it should have a way to block code without curly braces. But it's entirely too inconsistent in other ways.
I don't even know what I'm looking at. Why did you even include the __call() method? The language would have told you nonexistant() didn't exist, and using method_exists() would have been less expensive than throwing an exception. I think you're just trying to cover-up putting your foot in your mouth. Also, while some MVC frameworks promote the idea of each controller containing a single action, most of them don't. Are you honestly going to define an interface for every single controller in your application, to contain every single action method? What a maintenance nightmare.
[No thanks :(](http://www.reddit.com/r/PHP/comments/sfqwo/just_very_simple_tip_that_many_are_not_aware_of/c4dyeca)
Interesting, it seems I might be doing the same mistake as dennispedrie when in a seperate class I have a constructor function mainly for database connection, now I don't know if its creating extra connection each time or not because I thought since the parent function has already declared $this-&gt;db then that should create a single database connection. class Database{ /*** mysql hostname ***/ private $db_host = 'host'; /*** mysql username ***/ private $db_user = 'user'; /*** mysql password ***/ private $db_pass = 'randompass'; /*** mysql database ***/ private $db_database = 'databasename'; protected $dbh; function __construct() { try { $this-&gt;dbh = new PDO('mysql:host='.$this-&gt;db_host.';dbname='.$this-&gt;db_database, $this-&gt;db_user, $this-&gt;db_pass); /*** set the error reporting attribute ***/ $this-&gt;dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); } //End of Try catch(PDOException $e) { } //End of Catch } } class Parent extends Database{ /* func1(){ // Use $this-&gt;dbh to make a query } } class Child extends Parent { //Uses the same concept as above and does $this-dbh query } So my question is this worng, if it is then what method is best practice.
Yes, but this isn't supposed to replace databases or SQL. I wouldn't suggest for example, loading all rows from the database and then sorting or filtering with this; that would be ridiculously slow and would probably even run out of memory.
Suppose I'm writing a JavaScript plugin. Is it better to end every other statement with a semicolon or to end each statement with a semicolon? Consistency is a virtue.
I'm not covering anything up. You want to have a serious discussion now, instead of a pissing contest? I'll come back to the interface in a minute. Here's the thinking on why this is better in an OO sense. The controller object knows how to deal with situations where you call a nonexistent method. The logic is encapsulated within it. You should not have to look into an object to see if you can call a method, the object should be able to gracefully deal with the situation itself. This is object oriented. Looking in from the outside is little more than procedural. In terms of the interpreter both bits of code are probably checking the same object stack in the long run. In terms of design the Controller class is now less anemic. Back to the interface. I'm in no way saying you implement an interface for each controller listing each action. However, what if you want a controller class that servers up a normal HTTP request to a browser and another that would deal with REST requests? Sure, you could context switch in the init() like Zend can do, or you could instantiate a object of the needed type with the full knowledge that you will have the required method calls. e.g. for REST you must implement GET, POST, PUT and DELETE. And my foot is nowhere near my mouth.
I wouldn't if I knew adding a semicolon is optional, and the possibility existed that using semicolons would cause the script to crash.
Semicolons are mostly optional. There are times when not adding a semicolon can be problematic, but that usually isn't the case.
$pk has to be an array with values in it for it to work. $pk[1]; is how it works, it wont work for several variables like $pk1, $pk2... etc. just one that is an array that contains many values.
It doesn't have to be an array, but for the sake of clarity it's better if it is. It's hard to go back and see what your code is doing if you don't use an array. 
 echo ${'pk'.$xCount};
Of course it's not hard. But it is also not cheap and requires at least some linux administration skills.
I was super drunk when I wrote that... I will take back what I said and reconsider how I feel about it. Am looking at the site again now.
This. If you find yourself in a case where you think you need variable variables, it's generally better to refactor. ;)
I'm there!
Well wvenable, Thank You for your help to both me and dennispedrie. I really appreciate it. I'm gonna do some reading on this and then go back and correct my mistakes. This whole time I was thinking just because I inherited it, means it's not making multiple calls. Hopefully after I go back and fix it to singleton patteren + creating abstract functions, I'll see some improvements.
&gt; &gt; I think you need to look up the definition of Ad hominem. &gt; &gt; I did not attack you I disagree... or, at least, you seemed to feel it necessary to include (at least what would seriously appear as) slander-like subject matter outside the "real" disagreement. Eg. &gt; "I fear you have bigger issues than..." ...and... &gt; "...it apparently just went over your head..." I take these as mixed insults, and they have **nothing** to do with the discussion - serving only to insult or make yourself feel better about your own position / knowledge / self... and are classic *argumentum ad hominem* (ie. negating truth by pointing out characteristics/beliefs of the person arguing it). And really, it *seriously* detracts from what might have otherwise been a reasonable position -- it really only makes your own position appear less tenable.
Ok, I went back there and looked at it and it's not for me. 
can you remind us the article? I must've been missed it.
People keep telling you to use an array, but they're not really showing you an example. So basically, people are telling you to do this: $pk = array("First value", "Second value", "Third"); $size = sizeof($pk); for ($xCount = 0; $xCount &lt; $size; ++$xCount) { echo $pk[$xCount]; } Or even simpler: $pk = array("First value", "Second value", "Third"); foreach ($pk AS $item) { echo $item; } Whenever you have some naming structure where you're naming variables something like `$var1`, `$var2`, ..., `$varN` you're probably doing something wrong and should be using a different data type. Sometimes for simple coordinate systems, it's acceptable to name points like this, but within reason.
One place I've seen where a variable variable is exactly the correct solution: &lt;?php foreach($states as $statedata) { $$statedata = ''; } $$state = 'SELECTED'; print "&lt;option&gt;&lt;/option&gt;"; foreach($states as $statedata) { print "&lt;option ".$$statedata."&gt;".$statedata."&lt;/option&gt;"; } 
Sure: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/ For those that don't get my response to [deleted], I don't think he realized the article linked wasn't actually criticizing PHP.
Thanks for the tip! I have been writing PHP apps using CodeIgniter as my framework of choice lately (it's awesome) using a MVC approach, and they always recommend in their community to omit the closing PHP tag in controllers and models. Controllers and models are just PHP class files exactly like the ones in your post except designed to have a specific function. If there's any whitespace whatsoever after the closing tag of these classes, it causes errors in the application, which would be very difficult to track down, which is why the CodeIgniter community recommends to omit the closing PHP tags. I figured this was just a CodeIgniter thing, but I'm beginning to think that it's just one of those things about PHP in general. Great post.
Contact the IRS and ask about charging sales tax across state lines, and how much contracting work you can do in a year before having to charge sales tax. It's very much jurisdictional.
&gt; Contact the IRS That's like trying to have a conversation with a huge company that puts no money into customer service, and the phone system just leads you in circles.
Perl to open/save files isn't really necessary either, PHP is capable of these tasks. I made it as far as opening/saving remote files in tabbified ACE instances using js/ajax/php. You are right about "tools they know"... there are already remote editing tools, so the demand is low. I myself would be using Cloud9 or CodeAnywhere if either of them worked at my job.
Have you tried two files including each other?
if your file name is file1.php and you run: php -f file1.php 
You should be able to modify a file while it is in use, but the modification normally won't have an impact on the current program execution because it's already been parsed by the PHP engine. You might be able to run a script which includes fileA into fileB, have fileB modify fileA, then include fileA a second time.
This is what I was thinking. exec("php script2.php");
I think invoking the shell goes against the spirit of the question. Same with cron or other outside tools. Just an opinion m
This will open you up to wonderful possibilities like making an admin page with a textbox for file names and one for code. Who needs a secure FTP site when you can dynamically rewrite your pages. Or how about making the site "phone home" to your server to rebuild it's contents. There are a thousand ways you can abuse this code. Enjoy!
What the author is calling a â€œshorthand operatorâ€ is actually an example of [ternary statements](http://en.wikipedia.org/wiki/Ternary_operation).
If I where you I'd ditch PHP for this. I'd personally go with Python, or C(++) and look into [Genetic algorithms](http://en.wikipedia.org/wiki/Genetic_algorithm)
Ok, just for fun, I wanted to try this out. Not sure if this is what you're thinking... What happens: - writer.php loops 10 times, each time modifying the content of file.php - at the end of execution file.php has changed and is set to the last iterator point of writer.php [https://gist.github.com/2432539](https://gist.github.com/2432539)
Yes, you can create the PHP as a string and then [use eval()](http://php.net/manual/en/function.eval.php) to run it. **BE FOREWARNED:** eval() is exceptionally dangerous in the wrong hands. By using it, the author is opening the *possibility* that virtually any PHP code could be executed. (For example, `shell_exec("rm -rf .")` - Say g'bye to your files.) Frankly, you should *never* have to be using eval(), and should find another way to accomplish whatever you're doing. &gt; I've experimented a bit but I can't seem to be able to make changes to a file while it is in use. To the best of my knowledge, when a PHP file is run, the contents are copied into memory, parsed, possibly cached (depends on your setup) and any output is returned. You should be able to modify the contents, but the ability to will depend on your server's configuration (e.g. the user which PHP runs as) *and* the permissions set on the .PHP file. In any case, you shouldn't be storing static data in your PHP files: Data should either be stored in a database (such as MySQL or PostgreSQL) or to an external file. For example, if you had an array of data that you wanted to store and later modify, you could first store it to a .txt file (see [file_put_contents()](http://php.net/manual/en/function.file-put-contents.php) ) in JSON format (see [json_encode()](http://php.net/manual/en/function.json-encode.php) ), and later re-open the .txt file (using [file_get_contents()](http://php.net/manual/en/function.file-get-contents.php) ) and re-loading the array. (See [json_decode()](http://php.net/manual/en/function.json-decode.php) ) Best of luck.
While this is exactly the advice that I would give someone if I were trying to teach them programming, he was very clear that he was asking about the possibility of implementing a unique problem, regardless of its utility, and without specific application in mind. Don't let the "good practices" klaxons in your head prevent you from entertaining interesting problems or thoroughly reading what it is that's being asked.
I would not be happy if a member of my team started littering our code with these "shortcuts." Readability / maintainability trumps your "cleverness." While some of these may be valid in some circumstances, abusing the ternary operator will get you beaten with a telephone cord.
&gt; But you are of set mind that you already do everything perfectly ... I said that syntax errors aren't a problem. I didn't say that I don't commit them. PHP outputs an error and tells me exactly where it is. I find it, and I fix it. You have a good point with accidental assignment in conditionals, but I don't think that is an easy mistake to make once you've programmed for a while.
I have a config section in a script I wrote, and since I wanted to keep it all in one file (I'm obsessive about single-file everything :\ .) I did something like `file_put_contents(preg_replace('@one@','two',file_get_contents(__FILE__)));` and it worked fine. This was in v 5.4
Ternary's are great and all, but know when to use them or don't use them. Replacing these with every if statement will make me set fire to your house.
This worked for me on Mac OS X Lion... &lt;?php define('RUN_COUNT', 1); $lines = file(__FILE__); $lines[1] = "define('RUN_COUNT', " . (RUN_COUNT+1) . ");\n"; $updated_file = implode("", $lines); $fp = fopen(__FILE__, 'w'); fputs($fp, $updated_file); fclose($fp); After running it once (by typing **php test.php**) the file contains &lt;?php define('RUN_COUNT', 2); $lines = file(__FILE__); $lines[1] = "define('RUN_COUNT', " . (RUN_COUNT+1) . ");\n"; $updated_file = implode("", $lines); $fp = fopen(__FILE__, 'w'); fputs($fp, $updated_file); fclose($fp);
0666, not 777. Not that 777 would stop it from working, but it's Not Right, since it includes execute permissions.
Well, a very hacky way to do this with just one file could be this way... &lt;?php define("fluffy",0); define("extrafluffy",fluffy+1); echo extrafluffy; $file = file_get_contents('self.php'); $replace = 'define("fluffy",' . extrafluffy . ');'; $file = preg_replace('/define\("fluffy",(.*)\);/',$replace, $file); $file = str_replace('1;','$',$file);//the file was echoing 1; for dollar signs, not sure if just server quirk echo $file;//just shows you what would be written if you decide to write to self.php ?&gt;
What you're asking for does not make sense, though. There is no conceivable programmatic function that requires the code to actually modify itself. You should be able to do what you want by storing information to a file, and having your script do the appropriate thing based on that stored value. Can you give me any kind of description of what end result you want to achieve?
php shorthand operators bad coding habits and examples | Marian Zburlea Blog FTFY
My problem: I learn best by example, and seeing things done in practice. But I don't work on a team, and I have zero friends who are PHP competent. Most of the time, open source projects, kits or frameworks have atrocious documentation that I simply cannot learn from. I have no idea how version control works - I can't even begin to imagine it, and without someone to show me the way I'll pretty much never adopt it. Also, I hate command-lines with all my heart, so, the entire thing is *uuugggghhh*
0644 is less likely to make it writable. The "most writable" permission for a non-directory, non-executable is 0666. 0777 adds the execute bit for all users which should be irrelevant unless you are running it directly from the shell (with hashbang prefix in the file).
This works fine for me... &lt;?php $count = 1; print 'Count is ' . $count; // I moved this up here for clarity $fcontents = file_get_contents(__FILE__); $find = '$count = ' . $count; $replace = '$count = ' . ($count + 1); $fcontents = str_replace($find, $replace, $fcontents); $fp = fopen(__FILE__, 'w'); fwrite($fp, $fcontents); fclose($fp); ?&gt;
ORMs: - [Doctrine](http://www.doctrine-project.org/) - [Propel](http://www.propelorm.org/) Templates: - [Twig](http://twig.sensiolabs.org/) - [Smarty](http://www.smarty.net/) (warning: people will hate you for it) People will argue that PHP is already a template engine, but I tend to disagree. [This article sums it up nicely.](http://fabien.potencier.org/article/34/templating-engines-in-php) PHP includes an XML parsing library called [SimpleXML](http://php.net/manual/en/book.simplexml.php). IIRC Symfony also includes an XML parser, I know there's a YAML one so I'd assume there's an XML one. Testing: [PHPUnit](https://github.com/sebastianbergmann/phpunit/)
I would suggest [PHPTAL](http://phptal.org) as a template engine. Or you can use good ol' XSLT, but I really love PHPTAL a lot.
Stay in Ruby for your own sake, PHP is severely flawed. As a PHP dev myself (whos trying to migrate to Py) i suggest you read [this article](http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/). Anything in there is true, and in most of the cases, irrefutable.
[PHP Farm](http://cweiske.de/tagebuch/Introducing%20phpfarm.htm) might be what you are looking for to replace RVM If there is something like bundler that would be pretty awesome. I would like to know about it. For heroku, you could just use [heroku](http://www.quora.com/Is-there-anything-like-Heroku-I-can-use-for-a-PHP-site) I can't really comment on the rest as the work I do mostly doesn't need any outside libraries and I sorta just write my own templating code which tends to be similar to [smarty](http://www.smarty.net/crash_course) on implementation. Sublime is a great editor, but many have been using phpstorm recently. Good luck, and really the php docs online are amazing if you ever need help. 
Welcome aboard. My only suggestions are to not try to compare PHP to Ruby. They are different beasts and doing that will only frustrate you. Also try to learn the language a bit prior to jumping into a framework. Given your background you should be able to pick it up pretty quickly. Most of the constructs you mentioned are framework dependent. There are some stand alone options but you will probably want something more framework centric. When you do take the plunge into a framework just do some homework and you should find equivalents to what you are used to. Just about any of the frameworks you hear people talking about in here are good frameworks with solid active communities of quality devs, so just take your pick. 
I personally hate anything that's bracket-based .. potato potahto, I just want him to know options available. You can output anything you want with PHPTAL including json and plaintext .. probably not the best tool to do so, but you could.
He specifically said he's learning it for "work-related reasons", that makes it pretty clear that he doesn't have a choice in the matter. Also, [a LOT of that article is incorrect.](http://www.reddit.com/r/PHP/comments/s1zwr/php_a_fractal_of_bad_design/c4alojr)
Yip I've read it. I'm a little terrified. But php is hugely dominant where I am, and if I want to level up professionally I should know some. I'm not giving up on ruby, I just also want to be confident diving under the hood of the various hugely popular CMS packages used where I am. And my previous experience tells me that will be less painful if I get a general foundation making things myself in the language before hand.
PHPTAL sucks some serious balls. 
Thanks everyone! Wow, this subreddit is really helpful :)
This works too. It reloads itself until $count reaches the $max value setting, thereby creating the illusion of maintaining state. &lt;?php $max = 10; $count = 1; if ($count &lt; $max) { $fcontents = file_get_contents(__FILE__); $find = '$count = ' . $count; $replace = '$count = ' . ($count + 1); $fcontents = str_replace($find, $replace, $fcontents); $fp = fopen(__FILE__, 'w'); fwrite($fp, $fcontents); fclose($fp); $path = "http://" . $_SERVER['HTTP_HOST'] . $_SERVER['REQUEST_URI']; header('Location:' . $path); die(); } print $count; ?&gt;
Funny, I think you have *one of the more reasonable arguments* yet, here! &gt; I have zero friends who are PHP competent. Most of the time, open source projects, kits or frameworks have atrocious documentation that I simply cannot learn from. And, not surprisingly, there is *a ton* of **really** bad code out there (much of it can be seen in the comments section of php.net, even). So yeah, I can empathize. &gt; I have no idea how version control works I would agree that source code control can be a difficult thing to "get past" without some form of assistance... and yes, command line isn't for everyone (I'm an old unix-admin type, so GUIs almost tend to piss me off at times). However, [github](http://www.github.com/) , [Google](http://code.google.com/) and others have at least tried to take the difficulty of the distributed server out of the picture for folks (though you get to "live" with things being "public" or, to coin a phrase, "in the cloud"). There are also some reasonable GUIs available... most notably [Tortoise](http://code.google.com/p/tortoisegit/) (and there are varying clients for CVS, SVN, HG and GIT). Mostly, if you can get a client (eg. [Cygwin](http://www.cygwin.com/), it's really only a matter of going to the proper directory and typing "git init" -- and even that may be done from one of the GUIs out there. But yes, there is a bit more to it in working with it, and there are a few decent tutorials out there, if you're at least interested in *learning* about it.
The keyword being "abusing". Ternaries should only be used as replacements for if/else blocks that deal exclusively with setting the value of a single variable depending on a simple check.
You'd have to find memory locations of the file after it was interpreted and modify them there. You'd need knowledge of how and where the php interpreter created executable code in memory. Its hard enough to do in assembly on a single tasking box with absolute memory addressing, without trying to do it in a modern networked multitasking memory-protected environment.
And, finally, this one works by calling an include over and over. I edited this because I can't stop fussing with code until someone hands me something else to write. &lt;?php $max = 10; $count = 1; if ($count &lt;= $max) { $fcontents = file_get_contents(__FILE__); $find = '$count = ' . $count; $replace = '$count = ' . ($count + 1); $fcontents = str_replace($find, $replace, $fcontents); $fp = fopen(__FILE__, 'w'); fwrite($fp, $fcontents); fclose($fp); print 'Before ' . $count . '&lt;br&gt;'; include(__FILE__); print 'After ' . $count . '&lt;br&gt;'; // Notice this counterintuitive output } ?&gt;
this jargon's so thick you can stick a fork in it!
Statements like these are harmful to the development community. You are entitled to your opinion. *why does it suck some serious balls?*
do you mean like using something like file_get_contents and then sending that into an eval?
* rvm - [phpenv](https://github.com/CHH/phpenv) * rake - [phing](http://www.phing.info/)
Sorry, my bad, I edited before I noticed your reply and now have no clue what was there. As an example of twig/etc being easier to adjust to: {% for user in users %} * {{ user.name }} {% else %} No user have been found. {% endfor %} This is just like php, however &lt;tal:block repeat="foo bar"&gt;&lt;/tal:block&gt; isn't. Sure that's a pretty easy one to follow, hopefully it illustrates.
I guess it does but I don't see how the PHPTAL is not hard to follow -- it's a slightly different syntax, but that's a pretty easy one to learn. The above is *not* like PHP syntax. Granted, there are some similarities .. I admit that the TAL "datum data" is weird and should probably be reversed, but this is a product of Zope TAL rather than PHPTAL itself. I'm also not sure how twig works really / I've never used it, but in PHPTAL you can put the repeat on another element so it does not have to be wrapped.
I see some people say that you don't need a build process for PHP. Ignore those. rake -&gt; [pake](https://github.com/indeyets/pake/wiki) Alternatively, you could go phing, but pake is just too simple and awesome to bother with anything more complicated.
I'm all for crazy :-) 
 &lt;?php unlink(__FILE__); ?&gt;
Don't afraid him with VM, Linux, etc... Let him focus on the HTML and PHP. Just Install [MAMP](http://www.mamp.info/) and start working in what really matters.
yes hosting is 95% on linux if not more but if he just wants to learn to make website just let him do it on the mac itself he will proberly only need ftp acces for when he upload's his website
That's still ridiculous. *Look* at the operation you're performing! This is really, really, really easy code: &lt;?php foreach($states as $current_state) { print '&lt;option '. ($current_state == $state ? 'SELECTED' : '') .'&gt;'.$state.'&lt;/option&gt;'; } ?&gt; Feel free to expand the ternary operation into an if-block if it's too scary for you.
Don't bother with the virtual machine. MAMP is the way to go. There is zero benefit to running a virtual machine.
Don't touch PEAR with a 10 foot pole. It is nasty. It has bad documentation, and each package is maintained independently, so some stuff is good and others suck. I had to work with the database package (MDB2 ?) at work and wanted to shoot my face off.
The biggest trap new web programmers fall into when using PHP is that they mix their controller, model and view logic all together into one. Such as iterating over DB queries which generate HTML code. I've never seen this approach produce anything other then a total mess. So the most important thing I'd try to hammer into him would be to move his HTML out into their own files. Even if he is not using a full MVC framework, or has the controller and model code all mixed together, moving his HTML out alone will make his site waaaaaaaay simpler. If he doesn't have enough confidence to use a framework, then I'd maybe build a simple 'loadHTML' function for him, to make that bit easier.
I think more developers should understand CI, and see the benefits of running a tighter ship, especially PHP developers where it is so easy to get started with the bare minimum. That said, this article is extremely short and not really designed for beginners that don't know what these all are.
Thanks for the comment. The intention was to give a "hands on" approach to it, by understanding the example application and the job configuration. I think the article would've been huge if I tried to explain CI philosophy and phing from scratch, so I put links whenever possible to point to more detailed information. I'll try to make it more "beginner" friendly or maybe write another set of articles for those matters :)
I have no idea what you are trying to tell me
I would teach him PHP first before diving into this kind of sysadmin stuff. By "teach him PHP", I mean to teach him how to teach himself PHP, how to RTFM, where to find solutions for common problems, etc.
In the publish HTML reports section of the example image all of the paths are cutoff, could you post the full paths? Thanks. 
Sweet, thanks. Everything is working great now! Now the hard part of getting it to work on the horrid mess that is our code base. Thank god I don't have to code on it, I'm just the IT guy (who oddly enough is pushing for stuff like continuous integration, source control, and an actual deployment system). find . -name "*.php" | wc -l 2734 And all those php files are interwoven among thousands of image, html, and god knows what else kind of files. find . -type f | wc -l 99058 I honestly don't know how they actually manage(d) to work at all. Thankfully most of them are on version control (mercurial) and like it/realize it is better, but they still use it as more of a roll-off type system ie. they commit changes at the end of the day or when they are done with a "feature", they don't use branches at all, and they have like 3 different repositories that all get written to by various people/programs oh god the merge conflicts and cross merges are horrid. http://i.imgur.com/8MlLQ.png
lol did you go suck the moderator's cock and whine to them to get that post deleted. good luck, you little bitch! lol. hilarious that you got downvoted down to -7! Here's the post again: StoneCypher is a gigantic douche. I am surprised that r/php even puts up with his douchebaggery. It's not limited to reddit. He's a gigantic douche all over the web. - [Here](http://typophile.com/node/61920?page=2) he registered on a forum just to talk shit to someone. - [Here](http://www.pixelcoders.com/2010/02/27/embedded-no-exceptions/) he talks shit to someone about C++ and exceptions and runs away like a coward after he gets owned. The guy has serious issues. He's a blatant hypocrite and an unrepentant douchebag. If someone attacks him personally, he's quick to whine and accuse them of being petty. But take a look at his posts. All he does is attack people personally. Perhaps what is most amusing is his misconception that his English is somehow exemplary. In an argument he will focus on the other person's spelling and grammatical usage, all in an attempt to exhaust the other person by goading them to respond to points that are irrelevant to the overall argument. It's funny how he thinks that is English is amazing, because [here's a relatively new post](http://www.reddit.com/r/PHP/comments/g32qn/prepared_statements_binding_arrays/c1kse2p) where he gets called out and completely owned. It's a delight to read and succinctly describes him and his behavior. Want more examples of his douchebaggery? - [Here](http://www.reddit.com/r/ProgrammingNoLink/comments/iq572/superfast_way_of_getting_free_space_between/c26emms?context=3#c2644aa) he is, being a complete asshat to someone who hasn't even insulted him and who, in spite of insults, keeps engaging him politely. She even thanks him for setting her straight. What justifies this kind of behavior? As far as he is concerned, he can make attacks on any language and he is always right and justified. But you'll rue the day if you make a criticism against Erlang or PHP. According to him, PHP is the perfect language without any mistakes. Just take a look at his [epic bitch-fest in this thread](http://www.reddit.com/r/programming/comments/injii/and_why_exactly_did_you_want_to_move_away_from/). All throughout the thread you can see examples of standard StoneCypher douchebaggery. People disagree with him politely and he responds with vitriol and personal attacks. He insinuates that they are unskilled, that their English is terrible, and that they have no clue what they are talking about, while he has. It's an amazing display of hypocrisy to seem him screech about "language zealotry". Want another example? [Here's an example](http://www.reddit.com/r/programming/comments/injii/and_why_exactly_did_you_want_to_move_away_from/c25ew4i) of him talking to a Firefox developer and personally attacking him for no reason other than the fact that ~~he made some criticisms against PHP~~ he was trying to clarify as to why they chose Python over PHP, and the decision making that went into it. The things he says are just horrible. Really, I'm surprised that he doesn't want to back up [stackoverflow](http://en.reddit.com/r/PHP/comments/husl3/another_complex_mysql_query_question/c1yt3sa?context=3) (among other things) and the other is the creator of "scutil" and claims to have "helped write the fucking language [php]". What justifies this kind of ego? Try searching for him on the internet (by his real name; it's not too hard to find) and you won't find a single instance of him having contributed anything to PHP. If anything, all he has is his "scutil" library that he trots out every time as if it's some sort of proof of his awesome coding skills. It's a fucking utility library. Nothing amazing in the least. It's funnier how he uses it as a tool to bolster his argument. Really? Who gives a fuck if you wrote an Erlang library? It doesn't help you if your argument is already wrong. I believe it's just a tactic to force the other person on the defensive. I mean, it doesn't matter if you have a PhD in Astronomy. If you say that the moon is made of cheese and then you point out the numerous papers you've written in Astronomy, it still doesn't change the fact that the moon is not made of cheese. There's another thing he loves to do. It usually happens when he gets backed into a corner and knows that he is wrong. But he's too arrogant to admit it, so he'll deflect the argument by [saying that he won't answer your questions, because you didn't answer his questions](http://www.reddit.com/r/programming/comments/injii/and_why_exactly_did_you_want_to_move_away_from/c25glq7). But he'll never tell you what those questions are. I'm not the only one who thinks this guy is a complete asshole. Here is [another comment](http://www.reddit.com/r/programming/comments/b5rha/a_moderately_epic_rant/c0l3vd2) that says the same (they have a decent number of upvotes too). He has an interesting definition of what's right and wrong. He'll often complain about being downvoted, but then he'll do the same. Most of arguments hinge on the fact that he's right because "I do blah blah" or "I am blah blah" or "I know blah blah". He loves playing the victim. In conclusion, he's a gigantic douche. I'm also pretty sure that he's **full of shit** when he says that he had a hand in writing the PHP language. It's a lie he uses to try and make his arguments stronger. Like I mentioned before, I'm surprised that r/php and r/programming or even all of reddit puts up with him. He's a thinly-disguised troll. Once I used to think that he did have useful information, but what the hell is that of any use if you're a gigantic dick? He thinks he has free reign because of his karma, which he mostly got from two or three posts. Oh and that's another thing. He claims he doesn't care about karma, but talks about how his karma is so amazing all the time. He feels he can get away with being a gigantic cunt because at the end of the day, he still has net positive karma. I think the admins should seriously look at banning him or getting rid of him. Redditors don't deserve to be at the receiving end at this kind of unrepentant douchebaggery. Reddit will be a better place without him. **TL; DR;** StoneCypher is a douche and he's full of shit. EDIT: I am also not someone who was "caught wrong years ago". I encountered his horrible behavior much like others here. I've just made it a point to call him out for the bully that he is. He really should be banned.
You're welcome! Well, actually I have been in your exact situation. This article is kind of a "conclusion" after many months of work, trying different approaches to mantain legacy stuff and improve overall methodologies in php projects. There's old code that cant be saved, but at least you can improve lots of other stuff around it, like deployment, or start having some tests, and educate developers for the next project :) I would really like to hear some feedback about how this worked for you or if you have any improvements to it.
If you have to do this, it is because you chose the wrong data structure for your data.
It's possible, but I'm first curious what you're trying to do. This seems a bit odd, maybe there's a better way to do whatever you're trying to do?
Thanks for posting. Very helpful
an old NPR article http://blog.programmableweb.com/2009/11/11/content-portability-building-an-api-is-not-enough/
Not trying to troll, but why isn't shall suitable for passwords? 
Here's a great article explaining in detail why MD5 and SHA1 are not suitable for password hashing: http://www.warmenhoven.co/2012/03/06/do-not-use-md5-or-sha1-to-simply-hash-db-passwords/
I think they're nice to have on in the background personally. I'm currently doing some C++ work for uni (well, taking a Reddit break ;)) with a playlist of their videos playing on my other monitor. Even though my full attention isn't being given to it, I'm still picking up small details here and there.
It's not just the order, consider a conditional, the conditional is now dependant on the html syntax - that is, the block ends where the xml block ends rather than a clearly defined if/endif style. And add to that that this conditional is hard to spot because it looks *exactly* like every other attribute on the html element. I could understand it up to using simple variables, but anything more and it just seems to be attempting to fit a square peg into a round hole for no other reason than you like round holes. e: also it is like php - open close &lt;? vs {%, and the keywords are familiar to all programmers - if/else/for/end, and of course the block structure.
Well I prefer to just use html with minimal php. 
could not agree more, i never used it for years, but once i was shown it its a must in any development shop, especially the kind where you are working on many different types of projects. I am actually been working on my own CI system written in PHP that i hope to unveil in the next few months, hopefully you guys can give me some feedback once i feel its ready =)
Easiest would be to save both versions of the text, with and without tags. Or, if possible, only save with tags, and then only take out tags before displaying, or when needed.
I think you have to explain better what you hope to achieve. Otherwise your question doesn't make much sense. $string = "&lt;p&gt;hello, &lt;em&gt;my friend&lt;/em&gt;&lt;/p&gt;"; $string_stripped = strip_tags($string); echo $string; // wow! I did it! tags are back in!
I could save both versions of the text, one with and one without formatting, but that is more or less data duplication and I'm not a fan of something like this. I could also save the record with tags, then strip the out as it comes out of the database. As the article suggests, there are some problems with this. However small they may be. As an example, what happens when one of the html tags becomes deprecated? Another example is this gives me the ability to only inject certain tags back into the content.
Is commenting them out with html comment tags an acceptable solution? Edit: Nevermind, read the article.
It is the templating language of choice at work. I don't have to use it extensively but say once a week or so I will be battling it. Real world problems for me: * tal:block is not valid syntax and fucks up the parser (possibly a way around this?) * error descriptions are by far inferior to other systems * it is very very hard to read eg typically you define a variable per line, and a condition on another line, and then attributes individually for elements, however this is all done in one line attached to an element, and all looks exactly alike (highlighted as strings). Perhaps you can separate these all into blocks, but then you get divitis and scope issues. * it is not intuitive and something else I have to learn - I know what I want to do and how to do it in a dozen languages, but not this one, and the docs really aren't that great * it executes php (and yes people WILL use this feature) but does not execute exactly as php does * debugging becomes that much harder when you can't var_dump (sure that's all templating languages I guess, but still) That's off the top of my head. I just cannot grasp why anyone would want to implement a language as a series of strings attached to elements on an xml document. Can you give me a single reason why it is better than, say, standard php or twig? I'm doing a lot of defending of my position here and you aren't doing anything other than saying *you* **don't** have a problem (as opposed to having a problem with its non use. E: &gt;The if/endif style is also frowned upon significantly -- I personally don't like just because it seems spaghetti-like. Not really. Also that's not what is meant when referring to spaghetti code. These things are necessary in any dynamic template, spaghetti is more like mixing up controllers/views/models all over your code.
thank you for the comment :)
* I have never had a problem with `tal:block` at all, so I really don't know what you mean * The error reporting in the newest version of PHPTAL is clear -- the only difficulty I have had is knowing exactly where to insert a proper closing tag (but this is easy to avoid with proper indentation). The parser will accurately find the mismatched opening tag. Other than that, I have had no problem correcting errors in templates immediately. * This is a problem with style, not with TAL. If doing this does not match your style, just change it (e.g. don't define conditions, `define`s (which I rarely use) and attributes at once). You don't get "divitis" if you use the `tal` namespace on an element since it is not actually added to the DOM. The template itself may have this "problem," but again it's a matter of style. PHPTAL handles scope just like PHP does, except non-global variables are scoped only to the element they're defined on. * I will give you this one. It's not super-easy to learn. It took me a couple days of working with it to finally understand what I was doing, but I fell in love at that point. * Neither does twig. Perhaps people *will*, but where I work, we don't (except in a rare time when we use the cache). We have over 550 templates. Maybe 2 use "php:" * You *can* `var_dump`. As for advantages: * PHPTAL ensures that your input and output are well-formed. * Macros and Slots -- incredibly powerful * Variety of built-in output modes * Filters (I have a filter that parses the contents of all `&lt;tal:mardkown&gt;` elements as markdown and converts them to HTML -- much better for simple content than regular HTML). * Its somewhat limited capabilities force you to do logic (aside from simple conditionals and loops) outside of your templates (views). I consider this a very positive feature. * Since a template is just normal xml, you can look at a template before parsing (e.g. with sample data). This makes it a lot easier to bridge the gap between designer and developer if they are different people and is otherwise helpful for creating wireframes. * Continuing the "normal xml" point, this allows you to use a DTD on the template, or even do an xsl transform (yes, I *have* used these features).
Sorry for the long delay in reply -- I've just returned from two weeks vacation and I didn't log in to reddit once! Are you in Minneapolis or nearby?
You asked for my response, so I gave it to you. * PHPTAL does this even if you serve html * I'm sure they are, but it's still a good thing * Again, I'm not using another system * Filters exist outside of the template themselves, these would go in the PHP code. I don't see how it's convoluted -- if anything it's cleaner * This is the *best* reason to use templates. It's very easy to blur the line between business logic and the view. I've seen it done everywhere. `php;` lets you do that to, so you just have to be disciplined about it. Sometimes, it's just necessary (as I stated, the caching example, which is another advantage btw), but otherwise you can keep everything in the php code itself. You say it's the worst excuse, but I don't think you will find a person who would not argue in favor of fine grained separation of concerns. * Browser * I dont' know how you can possibly draw the conclusion that xml is dead in the web world. Perhaps you are talking about the fact that work on the XHTML 2.0 spec was discontinued, but that is a separate issue (and doesn't mean that the HTML people won, necessarily). For us xml-favoring people it is nice to be able to validate the template that goes in even if the output is not strict (but still valid).
I was asking for justification of cramming a templating *language* into an xml document - what are the advantages of this particular approach. It seems there are none except that you like xml. * It forces you to do this. This is not a good thing. If you choose to do this then there are other ways, the templating language should not be enforcing this! * Yes, but it's not unique to tal and not a benefit of xml templating. * I'm asking why xml templating is good, if all others do the same thing then you have no point to make in this case. * Why not just do it in code? Also, other templating systems do this, so again, no point in favor of cramming everything into an attribute string. * What I mean here is that in practice no system prevents it so claiming that as a reason is just hot air. I agree strongly about separation, but do not agree that having a half arsed attempt at enforcement in a template is a good thing. * Don't really understand why you don't render it * xml is fucking huge. I mean, AOL is still a profitable company, but it's dead, like I believe xml to be in todays web apps (outside the enterprise I guess). I think we're flogging a dead horse here, good to talk to you, I realise some of our (well I don't even know who wrote this code) practices were responsible for some of my dislike of tal, however my overall opinion has not changed.
Hi, thanks for the comment! I also started doing it with ant at first (a couple of years ago), and then even created my own custom maven2 plugins (which we are still using at the office, they even create the maven site and do lots of nifty stuff), but in the end using java based tools to manage a php project seemed suboptimal (at least when considering ant vs. phing)
The IRS is actually quite helpful and has many support staff ready to answer many of your tax-related questions.
It would actually be pretty trivial to have a SSH account to just load up a vim session instead of a bash shell. Could rent space or dev enviorments over SSH /idea
*Friend*, eh?
Anyone here experienced with Yii? Pros and cons vs. other frameworks?
Yeah, this is where I started. Could never get anything worth it
It's not a webserver if it doesn't accept any requests. To clarify, it's not that adding write access makes you insecure. It's that preventing write access adds an extra layer of security. Just two months ago a friend of mine had a brute force attack against his blog, performing around 500 logins, until it had managed to guess his login details. The attack then modified his PHP templates, injecting a back door into his scripts. If he had disabled write access, then that would have failed. The attack did fail however because the injected code used eval, which had been disabled. So the blog just crashed, which exposed that the attack had happened. The moral of the story is that good security has multiple layers, incase one of those layers doesn't work. Disabling write access is one of those layers.
Download the PHPass library to wherever you want. &lt;?php // Include PHPass library require_once 'includes/PasswordHash.php'; // Initialize the class, the first parameter is how "costly" the hash should be. More = more entropy, but it will take longer to compute $hasher = new PasswordHash(8, TRUE); // Hash the users password $password = $hasher-&gt;HashPassword($_POST['password']); // Then insert it into your users table or whatever... ?&gt; Then, when your users log in: &lt;?php // Include PHPass library require_once 'includes/PasswordHash.php'; // Initialize the class, the first parameter is how "costly" the hash should be. More = more entropy, but it will take longer to compute $hasher = new PasswordHash(8, TRUE); // Check the entered password with what's in the database // $row['password'] is coming from your database if (!$hasher-&gt;CheckPassword($password, $row['password'])) { // Failed login } // Proceed to log in the user ?&gt; I've simplified it a bit because I'm kinda in a rush but that should let you know how to use it. Note: PHPass automatically salts the password when it's generated, so you don't have to do that yourself.
You session is identified by a cookie saved in the user's browser. Cookies don't generally magically disappear. Just like you can leave reddit and come back and still be logged in, you can browse away from your website and come back and still have all of your session data. How long that cookie hangs around is controlled by the php.ini value [session.cookie_lifetime](http://www.php.net/manual/en/session.configuration.php#ini.session.cookie-lifetime). It defaults to '0', which as explained means it will persist until the user closes their browser, but could be different on your server.
That's great! Thank you.
Actually, make sure you pass `FALSE` as the second parameter of the constructor. If it is set to `TRUE`, PHPass will generate "portable hashes" (ie.: `md5` + some clever key strengthening) which isn't as secure: &lt;?php // Include PHPass library require_once 'includes/PasswordHash.php'; // Initialize the class, the first parameter is how "costly" the hash should be. More = more entropy, but it will take longer to compute $hasher = new PasswordHash(8, FALSE);
Yes I am, work/school in downtown mpls and I live in the north metro
Thanks for the replies guys! We don't necessarily need it to be linked to e-commerce as this can be something that's just provided to those who have already paid. So we send them out a link to the seating chart once they've bought their ticket or something similar. We will definitely be looking at our options - the wordpress plugins look like a good option, just seen this pop up on Google repositories - http://code.google.com/p/wp-lanparty/ - hoping this develops into something, I will be keeping a close eye on this! 
But it's not true. At best, you notice nothing and everything works because you were careful to encode your documents all in UTF8 w/o BOM and left no trailing whitespace after the close tag.
You'd generally want to make methods private when there's no reason to expose them for outside use, when they're just little internal helper methods that don't need to be used elsewhere. As long as you're using classes, you're not really polluting the global namespace, just overexposing your class's methods. \*promotes [/r/PHPhelp/](/r/PHPhelp)\*
Here's a good example I tend to use when showing off the use for that. You won't need to create a new object in order to run that function and can return either a static value or a new object. I use it commonly when trying to grab objects from a database, like users. class user { function fetch_by_id($thisID){ //Run code here if ( user exists ) return $userObject; else return false; } } $user = user::fetch_by_id(50); if ( $user != false ) { echo $user-&gt;name; } else echo 'User does not exist!'; 
In what situation would someone want to instantiate a class? As someone who codes primarily in Javascript this way of calling a method (syntax aside) that you just used is very familiar to me... insantiation not so much. If it's too complex an answer then feel free not to waste your time :P
Classes are nice because they can be used to create smaller instances of objects when using an array of data would be too intensive to manage. I can have everything self contained inside of it's own object class user extends DatabaseObject { function is_friend_of($thisUserID){ //Run code here to check to see if this specific user ($this-&gt;ID) is a friend of $thisUserID if ( true ) return true; else return false; } function fetch_by_id($thisID){ //Run code here if ( true ) return $newUserObject; else return false; } function URL(){ return BASEURL.'/members/view/'.$this-&gt;Nickname.'/'; } function fetchFriendCount(){ $friends = new user_grab(array('FriendOfUser'=&gt;$this-&gt;getInfo('ID'))); if ( $friends-&gt;Fetched != false ) { $this-&gt;Info['FriendCount'] = count($friends-&gt;Fetched); } else $this-&gt;Info['FriendCount'] = 0; } function fetchFriends(){ //Run code here to fetch other user objects $this-&gt;Friends = $friends; } } $currentUser = user::fetch_by_id(50); if ( $currentUser != false ) { $currentUser-&gt;fetchFriends(); //If this user has friends, then the $currentUser-&gt;Friends array would now contain an array full of friends } I can use the above code to run a basic user management system with obviously the main meat missing, but still may be enough to get a good idea of why you might want to use this. I can take an ID of a user and instantiate a class based around that user ID. From there, I have an object with it's own set of values and functions. I can call, for example, 'fetchFriends()' to return an array full of other user objects that my main object is 'friends' with. From there, I can call those exact same functions on those friends as I did my main user. If you were to manage a large amount of data using only functions you would spend a LOT of time repeating yourself. Hope that makes sense.. Edit: It's incredibly similar to Javascript Objects in that a PHP class essentially outlines an object with functions and variables tied to it. JS: http://w3schools.com/js/js_objects.asp PHP: http://php.net/manual/en/language.types.object.php 
http://wiki.hashphp.org/Storing_Passwords_Safely &lt;- history, reasons, implementation and further links on the topic.
What would be the syntax for passing an argument to an instantiation of a class? So if you instantiated the user class with a specific user ID... would it be simply: $a = new user(152); //for example
If a client calls functions that they're not supposed to it could in some situations invalidate the object state and cause unintended results (bugs). The solution is to make them private. The concept is called encapsulation and is related to the principle of least privilege. *edit * http://en.wikipedia.org/wiki/Encapsulation_(object-oriented_programming) * http://en.wikipedia.org/wiki/Principle_of_least_privilege.
The `COM` constructor takes a third option of the code page. Try setting it. Ref: http://us2.php.net/manual/en/class.com.php Also, try reading some of the comments on the page I linked. Maybe someone had a similar problem, or you'll get an idea.
`__`construct is often easier, because if your parent class has a constructor, but your subclass does not, you are not forced to call parent::__construct. With the PHP4-style constructor (matching the classname) every subclass must manually call the parents' constructor if it exists. If there's multiple levels of inheritance, this also means you need to always keep an eye on all the parent classes in the inheritance tree, to make sure you're not missing any constructors.
A caveat, thought, using the older method will not work in namespaced classes since 5.3.something. :)
Thanks for the reply, I'll have to have a go when I get in front of my dev box next. However I did play around with code pages originally and it didn't seem to influence the outcome one way or another. I will investigate again though as I understand the class better now.
It sounds like you have a class full of visual students, so it may be best to keep their learning experiences revolving around the frontend. A good way to approach this is to have them implement variables within their templates - $student_name, $school_name, etc, that they can sprinkle around where they want the information to be shown. This is simple enough that they can quickly pick up on, and gives them the tiniest taste of what is available in the development field.
Build something they can relate to. Php can do image editing on-the-fly. Give them a picture of you, and have them draw a moustache and glasses on it with php. Store data in a txt file on the server.(its the Wrong Way, but it'll demonstrate the principle). Make a simple message board with it by adding some text delimited by some markup. Have them design the markup. Get a database. PHP is a bit crap without one. Use one of the [free php-hosting](http://www.google.co.uk/search?client=opera&amp;rls=en&amp;q=free+php+hosting&amp;sourceid=opera&amp;ie=utf-8&amp;oe=utf-8&amp;channel=suggest#sclient=psy-ab&amp;hl=en&amp;client=opera&amp;hs=26K&amp;rls=en&amp;channel=suggest&amp;q=free+php+mysql+hosting&amp;oq=free+php+mysql+hosting&amp;aq=f&amp;aqi=g-c1g1g-m1&amp;aql=&amp;gs_nf=1&amp;gs_l=serp.3..0i7j0j0i5.2796.4858.0.7303.6.6.0.0.0.0.184.651.3j3.6.0.NTgEW2Pzy3A&amp;pbx=1&amp;bav=on.2,or.r_gc.r_pw.,cf.osb&amp;fp=e86f651cd3ea5a66) places. Do the message board, but properly. 
&gt;how do I get non-programming students excited about PHP? By getting them excited about programming. Now, programming isn't for everybody. You need to have to have two things: 1. A logical, analytical mind 2. Passion For people which are actually interested in learning, the second part will develop as they familiarize themselves with programming. I've gone entire (3-4 year) programmes with people which, at the end of it, hasn't learned a thing, and that's because they didn't understand it, or they didn't want to understand it (or both). To understand programming, you need to understand how logic works. Some people do, and should be able to apply it to programming, while others just simply doesn't. While you can teach logic to them, you cannot understand it for them, and unfortunately I haven't got a solution to change that. You could always try flowcharts and start out with a broad, generalized view, then divide it in to smaller and smaller steps, and see if they're able to follow it. If they are not passionate about learning how to program, they'll never pick it up outside of the classroom, and they won't retain the information they learn. I'd suggest that you try to find out why they applied for the course, and what they want to do with their lives. Based on their answers, you might be able to trigger their interest by something which hits close to home for them. 
Show them something neat you can build in it. I believe that everyone wants to make video games, and I often find that even very simple video games (say, chess with no computer player) are enough that the person can emotionally attach. &gt; they're just not thinking about new things to use programming for. These days, there isn't actually a whole lot serverside can do that clientside cannot. &gt; the students don't have access to a DB of any kind, so no storing data :( You don't need a database to store data. However, you also don't need a database to have a database: PHP has SqLite in the default install, which lets you run from a flatfile. http://php.net/sqlite
I would use the mail function and make a quick little program that can show students how to send text messages and emails through a form.
You have three levels of accessibility, all of which enable you to expose an API to consumers of your code in different ways. Private exposes nothing: if you want people to be able to extend your class but not access certain methods or properties, make them private. Protected exposes methods and properties to only things that inherit from your class, but not the outside world. This is especially useful if you want to define basic functionality and let subclasses define the rest. Public exposes methods and properties to everything, from anywhere. An example, let's use a car. A car has some private properties, like $fuelLevel. You don't want people to be able to arbitrarily mess with the fuel level-- even subclasses. But, you have a public method called addGasoline() that will increase the $fuelLevel. This way, consumers of your Car *must* use addGasoline() to add fuel to $fuelLevel. There is no (technically there is a way) to mess with $fuelLevel otherwise. Now, how do you start the car's engine? Well, let's expose a public method called startEngine(). This method calls a *protected* method called _startEngineWithStarter(). You don't want the outside world to just spin your starter at any time-- that would be bad. But, other subclasses of Car may want to override or adjust how _startEngineWithStarter() is used. class Car { public function startEngine() { $this-&gt;_startEngineWithStarter(); } protected function _startEngineWithStarter() { // ... } } Next, I have a hybrid car where the electric motor helps start the engine. If the electric motor can't start the car, it falls back to the traditional starter motor. So, we override the startEngine() method and call another method: _startEngineWithElectricMotor() -- yes, verbose method name, I know. The implementation of startEngine() looks something like this: class HybridCar extends Car { public function startEngine() { if (!$this-&gt;_startEngineWithElectricMotor()) { $this-&gt;_startEngineWithStarter(); } } protected function _startEngineWithElectricMotor() { // ... } } As you can see, careful use of different accessibility levels can be very useful. In the example above, if _startEngineWithStarter() were marked private, HybridCar would not be able to call that method. Since we marked it protected, HybridCar was able to use it as it pleased. edit: I am not good at the formatting, sorry.
There are many times that private is very useful. Making everything protected is unnecessary and usually a poor design decision. You want to limit how people can affect your class's internal operation; opening up parts where they should be able to affect the functionality in only the ways you intend.
Good writeup + are you really a pornhub dev? 
Was for 4 years, not anymore.
I've taught PHP programming for designers but thankfully there was also a DB course so I could teach them to build an actual application. Creating something useful is a huge motivator. I think the first thing to show them is how server side languages can save them development time. The basic stuff like showing how includes can make it easy to create common headers and footers across many pages. It starts to get more complicated when you want to show a page with an active menu item, etc. You could always have your students store the data in a file rather than a database. They could build a simple forum or address book. Even more advanced would be to use sqlite as the database -- it doesn't require a server. 
Turn them into a bunch of script kiddies and tell them they can pwn the internet with a few simple to make scripts.
So if I instantiate a class and pass it an argument such as... $a = new user($arg); and the constructor is set up to utilize an argument function __construct($arg) { // code } the argument will automatically pass to the construct? I ask because in the line "$a = new user($arg)" it simply looks like im passing an argument to the CLASS... which makes no sense to me.
What type of interactive design do you do? For example, if they're creating interactive games, they need save states somewhere. So they'd also need user accounts to link those save states to, and with them they can resume our current game session from any other browser (device) just by logging in.
I guess the more important question is - why insist on server side, much less PHP? Python or Ruby would be easier for them to pick up - but I'd recommend Javascript (especially with jQuery) to scratch the instant-gratification itch much quicker for the average learner.
Show them something that uses AJAX, where JS interacts with PHP on a closer level. The only thing that comes to my mind right now is a basic shoutbox that stores messages in a CSV file or something similar, I think it would be easy and fun to make. That or how to exploit common security holes in vulnerable PHP applications, everyone loves this leet haxxor stuff.
Show them how to make a porn site in PHP
Hey all, I joined the project a little while ago, and I'll be working to redesign the website. We figured it would be fun with a little community input, so please vote below on which of the following three versions of the logo you prefer: http://i.imgur.com/qVmDl.png ---- Edit: Made a new version in black and white: http://i.imgur.com/aJXxs.png Vote below. Feedback is, of course, welcome. 
Dotted
$afraid_to_show_it = false; if ($afraid_to_show_it == false) { echo "passion in my pants"; } // Wrong type of passion?
Came here to suggest this - SQLite is the answer! 
One of the goals I was trying to achieve was loose coupling: I don't want the Chart class to know about every mapper class that provides one of these lazy loaded properties. Your design would lead to most of the model classes in our codebase having multiple direct dependencies on our mapper classes.
Honestly you probably wont get any great feedback as this is not what most people use PHP for. It sounds like a decent solution to me though.
I have used both arrays and sql tables to store layered map data for games (Muds, Mushs) and for me the biggest issue was pathfinding for NPCs and Monsters. An array works well if this is a single player game, but if you are going to do multiplayer then a database would be a better way to go. Let me know if you figure out pathfinding and how you decided to do it.
Show them how to add a class="current" to navigation items with a php function. Simple, awesome for beginners, but make sure you break it down so they truly understand what's going on.
http://en.wikipedia.org/wiki/A*_search_algorithm You're welcome
Maybe split them into teams, and get them to code something that will compete against the other teams. Maybe to crack a password or something. Maybe points for the fewest lines of code, memory usage, no of variables assigned etc. get_file is a great resource, and you could get them to build apps that pull twitter feeds and other API data and compile into a nice looking page.
The great thing about PHP and other server-side scripting languages is that it's easy to write something and show off your work immediately, without having to send out executables and worry about system compatibility. The instant gratification is a pretty huge appeal. If they're interested in design, some of them probably build websites? I'm sure they'd appreciate the templating aspect, not having to hard code footers on every page and such. Start them off with server side includes, and then maybe add some code to show when the page was last updated, and go from there? 
Is your image parsed on every single call?
[This] (http://en.wikipedia.org/wiki/Pathfinding#Sample_algorithm) is how I was taught to find paths in my computer science courses. Which I think might be ideal for you and the OP's path solving problems. The [A* search algorithm] (http://en.wikipedia.org/wiki/A*_search_algorithm) might also be worth checking out.
* Your "remember me" still doesnt remember me. * On-site notifications instead/in addition of email notifications * Better way to recognise the language on home page. I would try the language's logo printed on the background. * Long comments on high code makes it very hard to follow the comment. [Example](https://codetique.com/vBysJBJd) on line 35.
Correct - it will pass that argument to the construct of that class.
Yes it is, currently it isn't really an issue since there's a very small group of players, but I know that this is something that would spiral into being kind of crazy. I'm just not sure how to proceed... To be honest I'm not 100% sure how phpGD works, but I'm loading in the image and using imagecolorat 49 times to get the color at each displayed location. 
I'm a little unsure of how I would enable caching since every time the player moves there's a new section of the map - do you mean I should cache results of the initial imagecreatefrompng call?
I'm not a programmer as such, I'm a graphic designer who spends most of his time building Flash games and the like. Two things really got me with PHP - ease of database connectivity and the ease of sending emails from a Flash interface. Then, once I was hooked, I figured out a http POST data file upload client for my company so clients can send us files up to 500MB without needing access to our FTP. Not glitzy or visual but really bloody useful things.
&gt;how do I get non-programming students excited about PHP? Please don't. There are enough non-programmers diluting the PHP community already. :) (disclaimer: I am half-joking, I figure it's ok because you already have a ton of helpful responses.)
1) How secure is using the sha512 crypt function as opposed using the sha256 hash function? (both salted of course) 2) What would be a good amount of rounds to use for a register/login script?
If you are doing this in the browser I would use [Javascript to generate maps](https://www.google.com/webhp?q=javascript+map+generator) instead of wasting server resources doing it. If you look on github there are a couple really [nice libraries](http://stravid.com/projects/mapgenerator/) out there. You can perhaps generate the array of map sets in PHP and store it server side and then just ask Javascript to create it on the frontend for each user.
Is your name Eric?
Oh I didn't realize the remember me wasn't working I'll get a ticket for that. Good idea with on-site notifications I'll start looking into setting something like that up. I'm not sure what you mean about the home page. Each little review box has the language on the bottom left in the background. It's faint but it's there. I see what you are saying about the comment text being long I'll look into shortening those comment blocks. Thanks for keeping up with the project you always give great feedback.
Sometimes I see comments and think that people subscribe to subreddits just to troll. It seems like a massive waste of time.
I'll just leave [this](http://www.amazon.com/Mastering-Regular-Expressions-Jeffrey-Friedl/dp/1565922573) here. Tools like the one at gskinner.com are handy, but they're definitely not a replacement for learning how regex works, and why. Until one has a solid grasp of how regex works, I'd recommend staying away from the community contributions. Assuming something works without understanding how to read it sometimes leads to bad things happening. I could probably have a field day in there, but I'll limit it to one example: # this regex from gkskinner.com promises to parse a URL # # As per the included documentation: # # get all the elements in a URL: # group 1: schema # group 2: domain # group 3: path # group 4: file # group 5: queries, variables and achors ^(?:(https?|ftp|file)://)?([a-z0-9-]+(?:\.[a-z0-9-]+)+)?(.*?)?(?:(\w+\.\w+)([^.]*))?$ However there are several problems with it because it is not written to be compliant with the RFC spec. First, it doesn't take in to account the entire format of a URL. http://foo:bar@baz.com is a valid url, but it captures "foo:bar@" as the path of the URL, and "baz.com" as the file. Similarly, using a port, such as: "http://baz.com:3000" - the regex matches :3000 as the path. Because of the way this regex is designed, with each part being optional, it can't actually fail to match unless the input string contains a newline. Even if the input is a URL that is extremely broken.
Woah, pick a naming convention, dude.
At the moment there are 15, but I will be adding more as players advance and more than likely I'll need to expand the main region. If it's more helpful, I can provide a link to the project in the question, I just didn't want it to be seen as spamming links to projects I'm working on.
Codetisssue*
Personally, while I have a decent grasp on RegEx and do often write it on the fly, I keep a "cheat sheet" with RegEx (RFC-complaint when possible) for things like URLs, emails, etc. There's just too much to potentially overlook.
&gt; But first the basics. All the more reason to use Python or Ruby?
Please don't.
Yep, I recently started using rubular.com along with regexpal.com
Top (new version)
The icon replacing the Q should be narrower, make them the same size as if it was a Q on that font. IMO.
thanks for these ... and bookmarked. :)
If you're using GD for this, you need to find a better way. Performance breaks down rapidly as the amount of processing GD needs to do increases (in my experience), and GD's performance is not very good in the first place. I would parse once, and store the results as a native PHP matrix (or any other native storage) so you are not converting between data formats on the fly.
If it's not set it will evaluate to false :)
You might want to use a tile set: http://roguebasin.roguelikedevelopment.org/index.php/Finding_graphical_tiles
Lol, sorry - was scratched together for the sake of demonstration.
Just out of curiosity, have you ever seen the RFC 822 compliant regex for describing email addresses? Check out this bad boy: http://www.ex-parrot.com/pdw/Mail-RFC822-Address.html
Oh, wow, goddamn. The one on my cheatsheet is nowhere near that long, though it does catch all manner of email address oddities. This one is just super-precise, I suppose. I'm definitely saving this, thanks. Fortunately most of my PHP work is done on a custom CMS I wrote, and I can just update my email validation function. :)
Show them how to use GET or POST to set variables that determine css classes that will alter the look of a page. 
The sarcastic answer is that statics make code hard to test, so use them if you want your code to be untestable. Really, I only use them any more in the singleton pattern and I'm doing that less and less for testing reasons. An abstract class is useful when you have a number of classes that have some shared functionality but also some specific functionality. Off the top of my head, an example might be a Shape class. If you're displaying shapes, they might all share a setColor and getColor method, but they'd need very specific getArea and draw methods. So in your abstract class, you can put the code for the first two methods and then just abstract methods for the latter two; this forces all subclasses to implement those methods.
[Read this book.](http://www.amazon.com/PHP-Object-Oriented-Solutions-David-Powers/dp/1430210117)
The best documentation for PHP is free on the official website. No books required! As far as variable passing, look at using POST over GET to get your data out of the URL. Make sure you are sanitizing your database inputs... Otherwise you'll eventually regret it when your scripts go production. Make sure to use mysql_real_escape_string() to sanitize variables before you use them in a query. Otherwise, your site will be all sorts of vulnerable. I'd be glad to offer up advice on any specific questions you may have other than the ones you asked here. Please reply to this so I get them, but ask here on the thread rather than PM so others can benefit and contribute. Cheers!
 $afraid_to_show_it = false; if (!$afraid_to_show_it) echo "passion in my pants"; Ftfy 
http://www.wiode.org/ is what you might be interested in. 
Not just that. So many people do it wrong that if you do it right, other things which may use that email address then run the risk of failing if you get a user that uses characters that are legal, but not often seen.
i just check to see if there's a @ in the string :)
I don't think there is, but I can help you if you got any questions :-)
you can use text files to store data. fopen, fwrite and fclose should do it..
Make a contest, like, who can make the most original dynamically generated image with GD or Imagemagick. I recall doing that sort of contest when I was just starting in an online forum, and some people came up with some really interesting stuff. I made a script that pulled the weather from a third party website and created a clock/weather widget. I was really proud of it at that time. Or tell them there is a hidden folder somewhere in their computers and they need to write a script that finds it reading directories and files, the one who finds it first wins.
Very well put. I use the strict operator probably 95% of the time - but you can get burned either way! Learn the difference and you'll know which to use
You are trying to use mysql_query 2 time (line 1 and 7), try to remove mysql_query one line 1 $sql = "INSERT INTO Student (student_id, student_rank, student_name, student_time, tutorial_id) VALUES ($_POST["student_id"], $rank, $_POST["student_name"], $times, 1)"; this is my best guess
Respect.
Thanks, tried that but it doesn't work. I think line 7 is just checking if it's there or not but not calling it. 
file_get_contents and use a cache?
SHA-X is fast and Blowfish is (adjustably) slow. The slowest algorithm should always be used for password storage.
Lines 1 and 7 conflict. On line 1, remove the mysql_query function and just leave the SQL string there. if (!mysql_query("INSERT INTO Student (student_id, student_rank, student_name, student_time, tutorial_id) VALUES ($_POST["student_id"], $rank, $_POST["student_name"], $times, 1)")) Personally, if the SQL statement will be true more than false, I'd remove the ! operator and have the true operator first. if (mysql_query($sql)) echo '1 record added'; else die('Error: ' . mysql_error()); 
This is off topic. Belongs on [/r/phphelp](http://www.reddit.com/r/phphelp)
Funny enough, I just posted an article on usage of bcrypt without having seen this article. Vote it up if it's helpful; the PHP community really needs to start adopting best practices. http://www.reddit.com/r/PHP/comments/spvba/secure_php_authentication_using_bcrypt_is_a_must/
Agreed. I find myself using non-strict for things like database return calls because they're likely to return NULL, FALSE, or 0 (for mysql_num_rows). I do so on purpose, as all three of these return values indicate failure to me. Essentially just know the caveats of using both options and you won't run into any problems. Where you get into trouble is not specifying any form of comparison, which defaults to non-strict, i.e.: // may return 0 rows updated if no values changed, indicating // failure even though nothing was wrong with the query if ($this-&gt;userModel-&gt;update($user_id, $formData)) { // successful update occurred } else { // an error occurred on update.. or a false negative // if no data was updated (return 0 = number rows updated) } In the above scenario, you should specifically be returning NULL or FALSE on failure and do a strict comparison to check for error conditions.
"using bcrypt is a must" - no it's not. I'm with [this guy](http://www.unlimitednovelty.com/2012/03/dont-use-bcrypt.html). Yes, using a slow hash is better than the `sha1` etc., but I don't agree on using bcrypt just because everyone keeps saying to use bcrypt. Like the article mentioned, there's other slow hashing algorithms out there. Read up and learn more about cryptography. You'll be a better programmer for it.
I think this might be the way to go for this. That way I can generate everything locally and hopefully even improve speed. By PHP matrix, I'm assuming you mean multi-dimensional array? 
Thanks for this, I was using bits of pieces of random free tiles I found on various bbs' but this will hopefully be much better
It's not that much more effort to change one line to: if ($dog instanceof Dog) { and your code will be so much easier to debug.
&gt;For those of you wishing to take things a step further, here's an implementation of PBKDF2 you can use with my source code: PBKDF2 is actually a less good option than bcrypt. If your system already implements it, then you're fine, since both bcrypt and PBKDF2 provides sufficient security. However, if you're starting out from scratch, you should probably choose the stronger of the alternatives. &gt;I'm not going to cover scrypt; give it a year or two before it starts hitting mainstream. scrypt is the best out of the three, but the reason that it isn't used in PHP development is because PHP lacks both implementation and bindings to it. scrypt &gt; bcrypt &gt; PBKDF2
Don't sweat it. That's why we're here.
Well you can't query their database to get their product info unless they have an API, which I doubt they do. And what do you mean "return true or not"? Based on what conditions? If you want to get the inventory list they have, you may have to download their HTML and parse through the HTML to get the data. This isn't a very good solution though.
I do agree that bcrypt works, just not the whole "use bcrypt end of story" mindset. I think we should be telling programmers to use better suited algorithms (which bcrypt most certainly is). I'm more in the education camp... learn what the problem is, not how to solve it "the one true way."
This may be idiotic, but I'll shoot anyways. Is there a reason we can't, say, hash a password with bcrypt then encrypt that hash with scrypt? Would that not solve the issue here? 
I'm not saying that using bcrypt is wrong (it isn't), and yes you can use bcrypt alone and be very well off. I just want to put the option out there to new (or learning) programmers that there are other options that might be a better fit for their situations.
Certainly. I just don't agree with the rest of what the guy said apart from that we should make educated decisions. For instance, he starts off by saying that PBKDF2 is better than bcrypt, which is not at all an accurate statement. As for education, I'd readily admit that I don't have a clue what a cryptological algorithm does on an implementation level... and that's fine! What's important is that I know of the basic security features of the algorithm (e.g. salts, work factors, memory access patterns etc.), that I listen to the recommendations of the security experts (which usually is grounded in published and peer-reviewed scientific papers), as well as being up-to-date with the developments in case a crypto would happen to break. 
Watch out for SQL injections, mysql_real_escape_string what's in $_POST or use PDO. Also, strings need to be put inside quotes when writing an SQL query, otherwise they'll be treated as column names. As for the actual problem, others have covered it : mysql_query would return TRUE or FALSE, meaning $sql will be a boolean, meaning putting it inside mysql_query in line 7 would probably trigger an error saying 'mysql_query expects parameter 1 to be string, boolean give in...' unless errors are silenced. For future reference, if you need to put an array inside an SQL query, you need to concatenate it or put it between curly braces : &lt;?php mysql_query('SELECT * FROM table WHERE something WHERE column = "'.$array['something'].'"'); mysql_query('SELECT * FROM table WHERE something WHERE column = "{$array['something']}"');
I would suggest trying something simple if you are getting a 500 error. Just try to echo something to the screen followed by a exit statement. Make sure you can actually access the file. echo "Got here"; exit;
I think using a fallback within a generic hashing function is dangerous. If you don't have bcrypt support, and then add it at a later date, passwords will silently break.
I never understood bcrypt is a must either. What is wrong with sha512 + per user salt + stretching?
Smultron 4. you can get it for $5 in the mac app store. it's super simple, lightweight, supports all os x lion features such as autosave, versions and icloud.. syntax coloring for many languages, snippets and commands. im not sure but it might even support autocomplete. you can search through documents with regular expressions too! it's simple but still powerfull! i'd totally recommend you to take a look it.
This looks pretty nice. I'll have to check it out more later, and maybe add it to my [Analog](http://github.com/jbroadway/analog) micro-logging framework. I'd be interested to know how this compares to [FirePHP for Chrome](https://github.com/andrewn/firephp-chrome)?
Never terribly smart, though.
Heredocs are useful for multi line strings, but you can also use multi line strings instead: &lt;?php $js = " function output( msg ) { alert( msg ) }; output( 'foo' ); "; ?&gt; &lt;script&gt;&lt;?= $js ?&gt;&lt;/script&gt; Personally I try to avoid heredocs. Large bodies of JS or HTML should be placed in views, but sometimes it's just unavoidable.
What part of completely cryptologically broken didn't you understand? It doesn't matter that you cannot brute-force attack it fast enough when you can instantly get a collision using a different technique. 
My interest was writing my own blog engine over a decade ago. Creation is a lot more interesting to many than destruction. What sort of script kiddie tools did you find in PHP? I wouldn't imagine they would deal much with actual socket connections, would they? I made a pretty great password cracker for twitter back in the day in PHP, but I am sure there are desktop solutions that are much better, and much better at handling proxies. 
If I understand your PBKDF2 script correctly, it basically does hash_hmac() hashing using sha256 (or another algorithm) for a certain number of iterations. You're still better off just using crypt() with Blowfish as the original link suggests since Blowfish is stronger and you can specify the "cost" parameter that you want for Blowfish (essentially the same idea as the $c iteration count used in that script. These scripts that use iterations of hash_hmac() just aren't necessary any more now that we have crypt() with Blowfish.
Awesome, thank you. I am going to integrate this into my CI site. I have the code working out of the box but get two error messages. The first is A PHP Error was encountered Severity: Notice Message: Undefined variable: post_string Filename: controllers/hp.php Line Number: 45 and the second 404 Page Not Found The page you requested was not found. For the above, is suppose to be trying to load a page? Thanks again
I don't see anything wrong with how I currently do it... or any advantage over how I do it anyway. Every user has their own unique 16 char salt The application has an array of 16 char salt values and I have a function that determines which one to use based on my super secret algorithm. I encrypt the password using the member salt + the fairly random salt using mcrypt (AES 256 bit). Can anyone explain to me why this is bad practice? I am asking because I don't know any reason why and would like to know. I see lots of people saying that hashing is better... I am curious as to why. NOTE: Most of my application to date have been on 5.2.x or lower for various reasons... just FYI.
If I understand your description of your method, hashing is better than encrypting because the problem with encrypting is if a hacker gains read access to your user database and PHP code, they'll be able to decrypt your passwords and login to your website as any user (and any other websites where the user used the same password). With good hashing, even if the hacker can view your user database and all your PHP code, they still don't have any easy way to determine any valid passwords to login to your website. (Which, really, is kind of an amazing thing!) Aside from being more secure, using crypt() is really really simple, so why make things any more complicated for yourself. (See my "simplified version" comment post).
Okay, thank you.
PS: We've heavily considered packaging a pre-configured VM application and providing it that way, but that really doesn't make my scheduled tasks any more portable, but instead just solves the problem of having to instruct somebody to set it up.
A couple of things: 1) wget has a built in timeout/retry function. From the man page "Wget has been designed for robustness over slow or unstable network connections; if a download fails due to a network problem, it will keep retrying until the whole file has been retrieved." Keep this in mind when using it. I have seen it bite people in the past. 2) Several commercial PHP applications require the user to install a cron script. Don't be afraid to use cron. It has a purpose, and it does it very well. 3) Consider migrating your scripts that are currently operating through the wget method you mentioned to stand alone CLI based scripts instead. Tying up a web process to do something that can easily be handled on the command line isn't very efficient (not to mention the overhead involved). Part of operating an application is understanding how to do simple system admin tasks. If you are still concerned about your user base not having enough skill to install the application, offer an additional "installation service" for an additional fee. It's a revenue generating service and only those who think they truly need it will actually use it.
Fantastic insight, thank you. 
Have you considered selling your solution "SaaS" (Software as a Service)? You maintain the server (and CRON jobs) on your server, and just sell access to your server running your application. You charge a setup fee and then monthly or yearly fee etc. SaaS has lots of benefits for you and the customer, but you'll have to modify your application to allow for multiple "shops"
For help on your homework, maybe you could do a little more study before asking a really general question. Then, post your code, or we'll all have to guess about how farked up your code really is.
I'm not sure what you're trying to do, but if you just want a &amp;copy; 1901 - 2012 type thing, this should work... &lt;?php echo '&amp;copy; 1901 - ' . date(Y); ?&gt; You would replace 1901 with whatever year you started your blog or website, and the date(Y) puts in the current year so it's always up to date. There are more advanced things you can do that check to see if the decades are the same (so you can do 2010-12) and stuff like that, but that's the most basic easiest one I can think of.
His original code does guard against falsey items like that, without the need of an instanceof. But if it does return something non-false, why should it be a Dog? It should return something you can use as a Dog, but it being a Dog is inconsequential. For example it could some kind of DogProxy or DogPromise if you couldn't return the actual Dog, or a DogWrapper that did logging or fixed underlying issues in the Dog class.
Just one point that wasn't in the other answers: if you mark a method private or protected, then you can't test it anymore. I mean unit tests of course. In some cases, it's a real pain, especially in TDD, when you have a method where unit tests would be useful, but you know that it should'nt be in the public API. There are (painful) workarounds using reflection on protected methods, but it isn't satisfactory.
Well speak of the devil. Today someone posted [TerraGen](https://github.com/MichelCarroll/PHP-TerraGen).
Thanks, didn't realize nowdoc's existed yet! Guess I don't have to use futuredoc's anymore...
Your sentence is too heavy to read. Break up the long sentences. Use question marks when asking questions. It's more human friendly that way.
End of the day there doesn't need to be any destruction. Some script kiddy examples can range from simple site scrapers, one that I wrote many eons ago that I still find useful would scrape a hip hop audio site and prepare a playlist that I could run locally, since the site itself didn't have such a feature. Or even small scripts to demonstrate site vulnerabilities to make intro web developers aware of how easy it is for someone to remotely inject data and why validation is a must etc.
&gt; It should return something you can use as a Dog, but it being a Dog is inconsequential. Sure, `getDog` could return a DogProxy or a FurryAnimal (in which case it's not very well named, but that's another conversation). My point was that at the point where you call `getDog`, you know what you're going to receive if the function is successful. Testing for that is, in my opinion, better than testing for an arbitrary thing that it shouldn't return.
Back in my day script kiddie was used mosty for people who used sub7/netbus type programs. Scraping is entirely different. Heck, I still write scrapers for downloading shows and whatnot. I still think on the image manipulation would be best for an *interactive design* class.
Sub7 and netbus were fun times apart from it installing a backdoor on calling home to the author for both host and client. I guess maybe my use of the word script kiddy was off, I just took it to mean writing simple and small scripts, instead of a full out compiled program / app
Alright, mind my ignorance: why would you need a console for PHP? Normally when I'm debugging and I need some form of output, I just use echo and *boom*, I've got my data. How would this offer any benefits?
My point isn't about testing that you got something back. That's fine if it can also return a false-like value. My point is about ensuring it definitely returned a Dog, which is not the same as checking for false-like. Again, in both static and dynamic languages I see that more as a failing in the design. Ideally the design should fit together, so type checks are not needed. It also means it can only work with that type, which makes the code less generic, and more rigid. This is a pain if you wanted to change it to 'getCat', and have it meow, as you'll have to change those instance checks too. I think the original comment's code, which started this whole debate, is better then your instance check.
One approach is to queue tasks up in a database and have them performed on page loads after set intervals of time. Of course this requires people to actually load the page often enough ;). You can either have them done behind the scenes as part of the page loading, or have them triggered by something on the page itself. The latter is preferable if a task is liable to take more than a few seconds. You can do this by either a ajax call or even just including the task as an image. OSTicket has in its footer: `&lt;img src="autocron.php" alt="" width="1" height="1" border="0" /&gt;` This produces a 1x1 transparent gif once complete. IIRC, WordPress does something like this also.
Nice! TIL
This is like the poor man's Xdebug. Also, you should really stop using echo and/or var_dump for debugging, because... that's not really debugging. Look up how to use Xdebug with your favorite IDE.
I understand using echo isn't debugging, but neither is this ChromePHP thing: it's just a console. That's my question: does a console actually have any benefits in PHP?
I'd do a search for PHP linters; there is a list of some [here](http://stackoverflow.com/questions/378959/is-there-a-static-code-analyzer-like-lint-for-php-files) on SO. Lots of editors also include plugins which will linters and custom scripts when you save, and some in real time in the editor.
PHP doesn't get compiled, but you can still build a full suite of unit, integration and selenium tests, as well as codesniffer, mess detector, and many other tests that get run before deploying to production. Phing is nice: http://www.phing.info/trac/
Ok, so is there a difference between these? echo &lt;&lt;&lt;_END derp _END vs ?&gt; derp &lt;?php edit: I mean is there a difference in PHP internals?
Sorry about the sentence length and punctuation. I've got an few answers to my questions.
Probably linting would be the way to go, I was just wanting something that would see if it would parse without error. Thanks for your help! Any of those that you would recommend?
Views? Sorry, still a novice with PHP.
I think there is some confusion. This is a chrome extension/library that lets you use the console built into Google Chrome. So basically it provides an interface to log to the console in php the same way you can do console.log() in javascript. It's a bit more elegant than putting var_dump() or print_r() calls around your code. That's all.
A view is an MVC term. MVC is about splitting your logic into three areas: models which handle your data (namely talking to the database), views which is your display code (usually dumb HTML where you give it the bits it needs to display, like a list of comments or a title), and controllers which handles requests and binds the other two together (gets data from POST/GET, passing it to the model to get out data, and then calls the appropriate view to display it). When done well, it typically makes your code dumb and predictable, which makes maintenance and adding stuff easier. For example if I asked you to change how a blog post is displayed on my site, you'll be able to guess that you only need to look at the blog views (perhaps in view/blog/post.php). If I asked you to change how blogs are stored, it'll be in the models. It can also make your code a little more modular. For example if I wanted to add JSON or RSS output for a component, you could use the same code as used by the HTML version. You'd just use a different view for displaying it. In an ideal world, it means you can easily drop into any MVC site and hit the ground running. Although in practice MVC, and the frameworks that use MVC structures, will not be able to easily solve all problems.
Thanks. Yeah it was originally built on its own because Chrome didn't support reading headers in extensions until Chrome 17, and the first version of the extension was released in August 2010. That being said, I'm sure they are pretty similar. I would like to think the code is a bit simpler/lighter.
do this: &lt;?php vardump( $link_id ); It's probably not set. Where is $link_id coming from? 
Woop woop. Downloaded and looking forward to trying it out!
Cron, and research using command line php scripts. Best solution for me. 
Frameworks tend to get around this by specifying the encryption method next to the hash. For instance, you might see something like this in your database: md5$fsd89y3j$e7061d66f9d00dda51a52549eb1d4747 where the hashing function, salt, and hash are separated by dollar signs. This way, if you decide to change your hashing function, old passwords will work and can be silently upgraded to the new/stronger one.
Plenty of attacks try to gain access to code first so they can inject their own. Once you've achieved this, you normally have full access to the site's DB (since the PHP site has access already). It also makes sense since most DB's refuse outside connections, so you'd either need to get into the site or into the server. DB settings for a site are also normally stored in plain text, so it's trivial to print out, in order to upload your own mysql query (or just get the site to dump the DB for you). In practice this could be done by getting into the admin section of the site and altering the PHP templates from there. I've personally seen multiple Wordpress blogs and SMF forums get hacked this way. It also allows you to open a permanent backdoor, so they can send arbitrary PHP code, and have more option in the long run. They could use your server to send out spam, participate in a DDOS attack, or take a snapshot of the DB again in 6 months time when you have more users. All still all from PHP. Plenty of people also run all their sites under the same user, so one site could alter the files of another, and do the same attack there. In short, once your into a site, security tends to be pretty lax.
The only variable you actually need is the *date('Y')* The other things like *home_url()* and *bloginfo('name')* are always the same. So you can actually hardcode them. I'm assuming you'll be using it on only one website and you're not distributing theme around for other persons to use. 
WebSocket will do it but support is lacking: http://en.wikipedia.org/wiki/WebSocket Otherwise you're looking at query intervals. I would set up a second domain and host the chat in an iframe. Cheap hosting just for the chat will do better than chat+site on the same hosting.
&gt;Otherwise you're looking at query intervals. That's not the only other option. For instance, you have [comet](http://en.wikipedia.org/wiki/Comet_%28programming%29), which holds the HTTP connections open so you can keep receiving data up to the point that you need to send something back, in which case it closes the connection, then re-opens, sends the data and keeps listening again. 
&gt; This is relatively standard, and installation instructions are pretty simple. ...except not all systems re-read /etc/cron-d, or even *use* /etc/cron.d. It really depends on how cross-platform you want to be ... but, for the most part you can use a chain of crontab / grep / sed / cat to do the edits on the fly, or just use puppet (or similar). Even then, you're not always guaranteed to end up with the "right" version of cron on a given system (helps when you "control" the systems, though).
&gt; What are some ways of accomplishing scheduled tasks or maintenance tasks that professional PHP developers regularly use in their mid to large scale applications? Most definitely outside the realm of the PHP Developer realm ... but, from a large scale sysadmin standpoint, using something like [puppet](http://www.puppetlabs.com/) can help with the packaging and distribution a bit, particularly for non-tool-savvy admins. If you go that route, it can things like remove the repository worries (ie. it can setup a use a defined repo) and deal with cron on individual systems. I'm all for PHP, but from a sysadmin standpoint, I'm also pretty big on "using the right tool for the job" and minimizing work/overhead (this is a "set and forget" type deal, for the most part). Downside here: puppet requires ruby, which can sometimes be a royal PITA to get setup. **Edit:** On a *small* scale (such as my home servers), I tend to just run my code out of a source code repository ... and have triggers on the client that can "pull to head" and deploy. So I have a script that runs every X minutes, checks for the presence of a file (or certain contents there-in), and does a "git pull origin master" or "hg pull ; hg update" if the file exists, then removes the file. Then I have a PHP script on a hidden URL (like http://www.example.com/admin/update_site.php) that allows me to login and "touch" that hidden file whenever I want/need to force it. You can also just have the source "always update," too, and remove the dependency from the server script.
That was what I was getting at.
If you are using PDO you can also do something like this: $rows = $queryHandle-&gt;fetchAll(); That will fetch the entire result set into an array for you that you can then iterate over.
There is nothing wrong with a loop! What is wrong is using the legacy mysql functions. Save yourself trouble by learning PDO, of mysqli. Also, as pointed out by another user, you should try to avoid making queries inside a loop, since there is overhead in making a query. Try to make the db do as much processing as possible before handing back the result. 
Mm, thank you!
I totally understand. Thanks for considering it, looking forward to that PM ;)
You gotta watch out when using large datasets though. If you want to do some long running process over every single row in a few-million-row dataset you'll almost certainly hit the memory limit with that one line. Those situations are pretty rare though - you don't do that kind of thing very often and when you do you'll find you're life is much easier if you pull the data out in chunks. Still I don't really think there is anything wrong with a loop. Looking at the PDO source code, all it's doing is a fetching every row in a while loop and returning that. Not really any different from doing it in your code (except it'll be faster written in C and all). **Edit:** for those interested, the PDO source: array_init(return_value); do { add_next_index_zval(return_value, data); MAKE_STD_ZVAL(data); } while (do_fetch(stmt, TRUE, data, how | flags, PDO_FETCH_ORI_NEXT, 0, 0 TSRMLS_CC));
I don't know about the downvotes, but yes, the connection is closed after a response. "Comet" can mean a few different things. There is streaming comet which keeps the connection open and could, for example, send back a multipart http response, hoping the browser fires onreadystatechange each time, but not all browsers do. There are a few ways to stream, but no one way is supported across the board. Long polling Comet is much more likely to work in your client's browser. You make an XHR, wait until the server has a response, receive the response and make a new request. 
For the benefit of whoever inherits your project later, please use an ORM such as Doctrine.
Depending on where you print, it might be unreadable in the HTML, so it's much easier to read it in the console. 
We have a few commercial php products, and require cron. We have cron run a cronjob handler of ours which then spawns whatever we need - it's been the best method for us.
Well, it doesn't quite have the three levels, but here's a db library with a query builder, that uses prepared statements for all the data: https://github.com/aviat4ion/Query
You can simulate that by doing : while($rows[] = mysql_fetch_assoc(result)); But still, PDO rocks and I recommand it over the mysql_ set of functions any day.
I would set up a test page to see if it's something in the pages before I chase down a configuration issue.
Just to clarify a bit what Nicoon is saying. The following is fine: $stmt = $dbh-&gt;prepare("SELECT forum.id, forum.title, forum.description, from forum order by forum.date"); $stmt-&gt;execute(); $row = $stmt-&gt;fetch(PDO::FETCH_BOTH); for ($j = 0 ; $j &lt; $row ; ++$j) { $id = $row[0]; $title = $row[1]; $desc = $row[2]; echo "&lt;a href=\"forum_topic.php?id=$id\"&gt;$title&lt;/a&gt;"; echo "&lt;br /&gt;"; echo $desc . "&lt;br /&gt;"; $row = $stmt-&gt;fetch(PDO::FETCH_BOTH); } This is not good: $stmt = $dbh-&gt;prepare("SELECT forum.id, forum.title, forum.description, from forum order by forum.date"); $stmt-&gt;execute(); $row = $stmt-&gt;fetch(PDO::FETCH_BOTH); for ($j = 0 ; $j &lt; $row ; ++$j) { $id = $row[0]; $title = $row[1]; $desc = $row[2]; $sub_stmt = $dbh-&gt;prepare("SELECT count(comments.comment_id) from comments where comments.ref_id = ?"); $sub_stmt-&gt;bindParam(1, $id); $sub_stmt-&gt;execute(); $sub_row = $stmt-&gt;fetch(PDO::FETCH_BOTH); $total_comments = $sub_row[0]; echo "&lt;a href=\"forum_topic.php?id=$id\"&gt;$title&lt;/a&gt;"; echo "&lt;br /&gt;"; echo $desc . "&lt;br /&gt;"; echo "Comments: " . $total_comments . "&lt;br /&gt;"; $row = $stmt-&gt;fetch(PDO::FETCH_BOTH); } Though the above gets you the results you want, it does so with lots of overhead to the database. As your app gains users, and the data in the database grows this will get noticeably slow. You should handle the sub-query in the original SQL statement with a union. Like this: $stmt = $dbh-&gt;prepare(" SELECT forum.id, forum.title, forum.description, count(comments.comment_id) FROM forum, comments WHERE comments.ref_id = forum.id ORDER BY forum.date "); $stmt-&gt;execute(); $row = $stmt-&gt;fetch(PDO::FETCH_BOTH); for ($j = 0 ; $j &lt; $row ; ++$j) { $id = $row[0]; $title = $row[1]; $desc = $row[2]; $total_comments = $row[3]; echo "&lt;a href=\"forum_topic.php?id=$id\"&gt;$title&lt;/a&gt;"; echo "&lt;br /&gt;"; echo $desc . "&lt;br /&gt;"; echo "Comments: " . $total_comments . "&lt;br /&gt;"; $row = $stmt-&gt;fetch(PDO::FETCH_BOTH); } 
An example for using an abstract class: https://github.com/aviat4ion/Query/blob/master/classes/db_sql.php 
Seeing as you want to treat the zones as objects, change its colour etc., you might want to look into [Scalable Vector Graphics](http://en.wikipedia.org/wiki/Scalable_Vector_Graphics). It is accessible via [Javascript](https://developer.mozilla.org/en/Gecko_DOM_Reference#SVG_interfaces). Note: you might need a polyfill for IE so you can translate SVG to VML. 
Please don't. 
Why? Are you going to hand-roll code to pull data from the database and map it to objects?
Mapping to objects is the part I never have understood. Is a function to get a set of results really so strange?
I think it would be like killing a fly with a shotgun.
It's possible that the session data is stored in a temp directory on the server that is being periodically cleaned, or the permissions to write to that directory have changed such that the session cannot be created. Have a look at [this page](http://php.net/manual/en/session.configuration.php) for more information. session.save_path is the one I have in mind as suspect.
The quality of this publication is, surprisingly, quite high.
Canvas doesn't give you the ability to use the shapes as objects, though. It's merely a drawing surface. 
If you want to be able to view the newline in Notepad you will need to use \r\n. This is because Windows uses CR\LF while Unix uses just CR and notepad is looking for CR/LF. Otherwise use an editor that can read just the CR along with CR/LF. [Source](http://en.wikipedia.org/wiki/Newline#Common_problems)
Which isn't debugging, it's logging.
If it's just for a hobby, I would recommend using image maps: http://www.w3schools.com/tags/tag_map.asp It's an OOOOOLD technology, but it works in pretty much every browser with zero overhead. Basically you just list coordinates of polygons on a single image. Those polygons become clickable / programmable. Polygons can be triangles, rectangles, or any irregular closed-loop shape. You would only need one image for your map, and just define the polygons on top of it. If you want to be serious about making a game, I would use canvas. Canvas is a drawing surface, so you'll have to do a lot more work to update the graphics / get user input, but overall it's probably the best bet for modern web-games in general.
Avaptech is involved in imparting six weeks/months industrial training in chandigarh to students of various colleges or universities.We Provide high quality live project based industrial training to students.Attend free demo and see the difference
&gt;while Unix uses just CR No: * Windows use CR+LF * Unix, Linux &amp; Mac OS X uses LF * Mac OS 9 used CR
Nothing the manual doesn't cover to be honest.
You could always use random number generation to allow probability, too. Essentially, you'd be creating a digital "dice" to roll on events. That way, if the goalkeeper has 9 defence and the attacking player has 10 attack, there's a chance the goalkeeper makes the save. That way, a users move could go something like this: Player::shoot($attackingPlayer, $defendingPlayer) { $attackingRoll = sixSidedDiceRoll(); $defendingRoll = sixSidedDiceRoll(); if(($attackingPlayer-&gt;shotSkill + attackingRoll) &gt; ($defendingPlayer-&gt;blockSkill + $defendingRoll)) { ++$teamRedScore; //insert code for "kick-off" here } else{ $defendingPlayer-&gt;possession = "true"; $attackingPlayer-&gt;possession = "false"; } }//end shoot() ...that way it's not *all* stats and it will feel more like a sports game than a compare/contrast game.
So finding a bug and fixing it is not debugging because I used an echo instead of a breakpoint? Thanks for clearing that up, I've been wondering about this for 30 years!!!
And for future projects you could store your sessions in the db.
I will not argue this just making a point, if I will get access to your db I will most probably get access to a lot of other things. Also related to updating the password in the db is the reason why I am bored to hell about these discussion about encrypting the password safe ... I suspect these started in the times where there was no shadow and keep on going, but in my opinion if somebody gets your database you are fucked anyway so why bother ... And as a note, md5 sucks, get something better ...
I'm made of ideas. ;) Honestly though, I'm getting big into php and gamedev simultaneously, so if you want any assistance on coding or algorithms at any time during your development cycle feel free to PM me. (blitzball was pretty fun in FFX)
Finally got an error out of it: **Warning: session_start() [function.session-start]: open(C:\Inetpub\wwwroot\phpscript\php\session\sess_o7cm18s40tia538pb8f57gs571, O_RDWR) failed: No space left on device (28)** I also noticed that session.gc_divisor was set to 1000, so I'm thinking garbage collection was rarely called to the point that the folder never deleted anything... but without being able to view the folder myself I don't know for sure.
I get your intentions, I'm just worried that the time delay from PHP parsing a user's action, MySQL recording the action, waiting for the other user's PHP to reparse, and PHP retrieving the action would prevent any sort of real time playing. You wouldn't want to use a time limit, because this could end up punishing users who have a bad internet connection. (From what I can remember!) Blitzball is mostly a turn based game, but players can still move around the rink freely in real time, right? You could figure out a way to make this movement a turn based action; otherwise you need to plan out a good way to keep the game running flawless. You might want to take a look at [this article discussing the connectivity issues in a real time game](http://stackoverflow.com/questions/90423/what-kind-of-issues-are-there-in-implementing-realtime-multiplayer-games).
&gt;There is no reasonable place where I can store that key without the possibility of me accessing it. At least, I can't think of any. Do you have suggestions? There should be JS libraries for encrypting/decrypting data client side. The information necessary to decrypt the data never has to leave their possession. If you need complex keys, you can generate a key file client side and have them save it. Otherwise, the reasonable place to story the information is in their head. &gt;IF I find a place to do that, it would mean that a password reset renders all user data encrypted so far meaningless. That's not very user friendly. Data encryption is not meant to be user friendly. Either they want maximum data security, or they want the ability to reset their password. You could offer an option to store their password encrypted with a 'master' key on your server, but then they are accepting the additional risk of that 'master' key being compromised and thus their data. You, of course, have access to their data at this point as well. &gt;I'd like the system / login to stay a bit simple. Too many steps and users will never finish the process. Two steps (login and decryption) shouldn't be too much to ask from users that want the peace of mind that you are not able to access their data.
You will have to get very creative for there to be absolutely no way for you decrypt the data. Which could be a nightmare if users start reporting bugs to you and you have no way of validating data. 
Hi, I am wondering what type of data I could pull from eBay and Amazon and how much that would cost in terms of a data license fee. Example: Pull 100,000 most popular sold eBay items (based on # of bids or view count) to determine average and median sales prices for those items. Store data in a table. 1. Is that possible and how hard is it? 2. Is there a license fee for this? Thanks
&gt; It is by far the most liked mini-game in the entire series No, that's triple triad.
If your controller matches then you'll get the 404 view if the function within the controller doesn't load a view.
I would play this, I always wanted to make a mobile app, the only problem I can think of is "Recruiting", and how you would keep teams random but play to peoples style. Good luck! I'll be watching. 
Ya I know but it still pisses me off. If I'm wrong or not getting the concept that's fine but please let me know what I'm not getting.
This error is what occurs when an exception is thrown after main() has exited, so yeah.. in any shutdown or exception handlers. The best option is to just *not throw exceptions* in those places... ;)
Uh, you don't write the classes they are generated. You only write methods when you need some domain logic.
What do the cron jobs do? If they're purely related to manipulating the database, and have no interaction with the file system, might be able to get away with relying on mysql's [event scheduler](http://dev.mysql.com/doc/refman/5.1/en/events.html). I've used it a few times and had no trouble, but it's not really applicable to situations where you have to call other scripts or create/delete files on the file system... you need to be able to define the task in SQL only.
You cannot throw or catch errors in the shutdown handler since php is shutting down. Also, register_shutdown_function() is run *every* page load before php terminates the script. This means it will run even when there is no error. Do not assume that it is. What you want to be doing is this: register_shutdown_function(function(){ $error = error_get_last(); if ($error !== null) { /* handle error */ } });
libunit.
Are you storing stuff in sessions? If you are, is there anything that is perhaps trying to write/load a serialized object/class to/from the session? Try the following: If you are writing a class, say a User model to the session, make sure that the class is specifically loaded prior to the session loading so it can be correctly "unpacked" by PHP Also, in your register_shutdown_function try adding: session_write_close();
But don't tell them that they compile the code to c++ because the performance is to bad. https://github.com/facebook/hiphop-php
Any more information about this ? @OP: thx for this nice function. You can have a look at my collection here: https://github.com/jumpin-banana/dolphin
The difference between your two examples is merely that I used a closure (introed in 5.3). I prefer closures since it doesn't create a useless global function. As for the other part, no, you *cannot* throw an exception in the shutdown handler. The new exception will be broken and cause a warning itself. Exceptions always carry a backtrace, but in the shutdown handler, there is no more backtrace..
I like the look of it. I agree with the other poster that camel case is the way to go though. I also noticed in the source code you're passing $conn by reference in MySQL_Util - this is pointless in PHP 5 and. And lastly are there update and insert methods that can take the table name an array of field names and values?
Agreed. The OP is not thinking whether this kind of security is actually necessary. If this data is so private that the mere glance of it would cause mass lawsuits, devastated girlfriends, and embarrassed priests, then maybe the data is not worth storing online. Plus, the kind of security you seem to want to provide will actually require a very complex, expensive infrastructure (if you really want every step of data transfer to be secure). Will your service fees pay for this kind of system? Will your users trust you? It's one thing for "no name brand" to boast of a secure system. It's another for "well known brand" to boast the same thing.
Read the [FAQ](http://simplehtmldom.sourceforge.net/manual_faq.htm). I use simple_html_dom a ton, and [it eats memory like a fat kid eats cake](http://simplehtmldom.sourceforge.net/manual_faq.htm#memory_leak). Get familiar with $html-&gt;clear();
Man I wish I knew the answer to this. I loved it. Able to easily mix DB backends with simple notifications for things like tickets at one of my jobs. Unfortunately it was a bitch to install because I had to compile it for my system. I remember reading somewhere (maybe Reddit) last year that it wasn't dead but perhaps moved on to another project/name. I can't seem to find that now though. 
Why would an HTML preparser need GTK anyway?
It seems to have been pulled already.
Curl and domdocument. 
No, since the content of $prefixes is displayed before the unit symbol. 