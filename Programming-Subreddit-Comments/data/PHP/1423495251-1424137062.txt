Not quite. That allows any type. What this proposes is to allow limited variation in types, but not obviously incorrect types. So, `"123"`, `123.0` and `123` might be accepted for an integer parameter in non-strict mode, but `new StdClass`, `null` or `fopen("data:text/plain,foobar", "r")` would not. This is what we already do for built-in/extension functions.
You should post in r/phphelp : http://www.reddit.com/r/PHPhelp 
Remember that Drupal 6 was written in aan age where PHP 4 was still actively used, and needed to work with the options available. Also, unlike PSR-3 and PSR-4 (which Drupal 8 follows) there are reasons why it won't follow PSR-2 - http://www.technosophos.com/content/when-standard-bad-standards-body - http://engineeredweb.com/blog/practical-problems-psr-2/ With regards to PSR-1, the Drupal Coding Standards are actually more strict, and not incompatible.
&gt; In other words, if tomorrow the authors of one of the numerous libraries I use in my projects were to start using type-hints, they could decide that my application, in which I sometimes have integer values in variables of string type, is not *worth* using their library — and that errors should be raised here and there! &gt; I don’t understand how this could be a good idea — or even a *viable* idea in anyway, for that matters! And yet, that is exactly how it's done in *all* languages which have scalar types. If accepted, this weird, scope-based "caller-gets-to-decide" thing would become a PHP-only WTF. And as we all know, PHP already has a lot of WTFs, we certainly don't need *more*.
It might not be good but it is not bad. The argument names becoming part of the public API is fine, it's just different. Many languages have named parameters and callbacks, you just have to be aware of what goes on when you mix the two in a dynamic way.
&gt; I don't think that me wanting to use strict types should affect how builtin functions behave. Enabling strict_types=1 is not really affecting how the functions behave, it is affecting what will happen if I try to call them with a crap value. I know thats a semantic one but its a big one. Saying "affect how builtin functions behave" sounds scary to those who don't know more, and not really accurate to what is happening. But yeah, numeric would be well handy. Hopefully that'll come later.
At least it's not Joomla.
Only the caller really gains anything from strict type hinting anyway. Loose type hinting guarantees that the callee will get an int or boolean or string or whatever. When I write a method, all I care about is wether I'm dealing with the right type. My IDE and static analyzers can safely assume that the int I requested is an int, whether it was born that way or cast into one at call. Strict type hinting guarantees that the caller has not made any type errors. If I accidentally pass a text input to `do_some_math(int $number)`, I don't want it to succeed just because someone chose "12345" as their password.
Setting it in the INI means: * No control in a shared hosting environment (so, you don't get a choice) * You'll break the libraries you're using (so, the library authors don't get a choice) * The behaviour is dependant on the environment (bad bad bad!) 
Enabling strict by default would make the language considerably more difficult for users in general. It would also make upgrades from 5.x almost impossible. **Edit:** This was unclear. If library/framework authors start using scalar type hints, then weak first will make it much easier for folks to jump onto a newer version of the PHP 7 based framework which may well be largely the same. But, if it is strict first then every single input to every method will need to be (int) or (string) fed, which would take for-bloody-ever to upgrade. This will slow down PHP 7 adoption and scalar usage in general, which sucks for the library developers and the whole community. Allowing those that understand the benefits of strict typing to enable it in their applications as and when they feel like doing it is a very powerful thing. I'll have it turned on all the damn time, but the average "I've been using this thing for a month" developer is not going to at all. I remember _hating_ that C would bitch at me about char[5] not being a string or whatever the shit. Let's not break PHP by doing that to beginners. 
Array type hints are already strict in PHP5.
OK, you say this is a massive problem, but... why? It's only one more line instead of two more lines, and having an ini setting would allow much more flexibility in cases where you wanted to use strict typing for a whole set of files. To be honest, in mosts cases I think it'd be a lot less modification to your files, if you wanted to take advantage of strict typing. How often are people only going to want strict mode for just a single file, compared to a whole project? Edit: I'm really quite curious who's going and downvoting every comment I'm making here. Genuinely trying to have an open discussion. But perhaps it's not worth the effort, this kind of negativity gets to me in the end.
That is not your job. As a library author you are responsible for declaring what inputs you would like and what you do with them from that point on. The caller is responsible for deciding if they would like to use weak or strict, as defaulting to weak is of course the smartest for the PHP community. Your wish to hold their hand (which PHP does anyway with notices) would lead to absolute confusion with different libraries acting differently in the same file, and that would be truly disgusting. 
Kinda. You would define type hints, but the type hints you define are neither weak or strict. Your library can be strict internally, but it is the caller of a function that decides if it should be weak or strict.
&gt; When I have to work on a bug in code that doesn't rely on Drupal features, I move it out to an external library. &gt; I'm also reformatting code to be more like PSR-2, because screw Drupal's coding standards. Just be careful you're not racking up more debt for the next guy. Not trying to troll you, but this is how codebases get *really* fucked up.
&gt; and that would be truly disgusting And yet, that's how it works with every other language and nobody seems to be disgusted with them?
It gives an error: $ php -a Interactive shell php &gt; function foo(array $bar){} php &gt; foo(2); PHP Catchable fatal error: Argument 1 passed to foo() must be of the type array, integer given, called in php shell code on line 1 and defined in php shell code on line 1 Catchable fatal error: Argument 1 passed to foo() must be of the type array, integer given, called in php shell code on line 1 and defined in php shell code on line 1 
I've seen this syntax suggested elsewhere which I'd prefer: function foo(int $bar) {} // strict function foo((int) $bar) {} // loose Keeps with the current schematics of using `(int)`. But, I can also see the benefits of forcing an entire file to be strict, instead of just specific sections.
Struggling to get my head around Interfaces properly, any advice in terms of when to use them, their benefits and so on? Also any resources to help read up on them would be grand. :)
I find that this is a good visual representation of the issue: http://martinfowler.com/bliki/DesignStaminaHypothesis.html I've passed that, along with the technical debt article, along with the Uncle Bob article, around my company (managers, PMs). Really, the best way to summarize it is this: "If you deliberately take shortcuts by implementing or using poorly written tools, those decisions come at a cost - that cost is slowing down development of new features for the sake of getting current features out the door"
How can you even tell which user is loaded on the page? Where are you storing/retrieving the clients session information. Is the 'Users' class loaded? I am going to honest with you- It's clear that you're building this completely from scratch. Thats ok if its strictly for learning purposes, but you should really be following industry standards and good design principles (ie. MVC). There are *a lot* of PHP frameworks out there that should suit your projects needs. You are going to run into A LOT of problems that most frameworks handle elegantly and *securely* for you. 
Not sure if trolling or genius. Thanks. :) 
&gt; If I need to open up a class to find out if its going to be weak or strict then PHP is dead to me. This is exactly why many people, including me, suggested different syntax for weak/strict hints (`(int)` for weak, `int` for strict) so you wouldn't have to open the file; you'd be able too see it from the function signature (via IDE auto-complete for example).
I really hope this RFC doesn't pass. I'm a big proponent of scalar typehints. I don't even care if it's strict or weak that gets implemented (though I have my personal preference). I just don't want another Frankenstein feature added to PHP, and that's exactly what this implementation is. No offense intended at Andrea; I think she did an excellent job at trying to come up with a solution to please everyone. Unfortunately, therein lies the biggest problem. Languages are too basic to please everyone. Trying to do so nets you php.ini and declare monstrosities (which we're supposed to be *getting rid of*, not adding more of).
OK I guess you're not talking about the standard library then. I can see that userland code switching to strict hints could be problematic, but I'm not sure I agree with the scale you are predicting. I mean, I don't think it's significantly more effort than any other backwards-incompatible change (switching to namespaces for example).
That's not a native function. I checked and the native functions give a *warning* when passing the wrong type, so they can't be using the array type hint.
To clarify in case you weren't sure: if you add a (for example) string type hint to your own function, inside that function the parameter will *always* be a string, whether we're using strict or weak type hints. The only difference is to the caller. There's a good argument to say, why should you care about what the user does with their code, as long as you're getting the correct types in your functions.
This might be a good one for /r/phphelp Does your server have cURL enabled? Check your error error log and look at the output of phpinfo()
Look at the error if (!$results = curl_exec($bb)) { die("error : ". curl_error($bb)); } curl_close($bb); // the rest .... Aside: 1. Stop using globals 2. The function is called "fetch", so it should just fetch the data, not manipulating the result with simplexml.
I'm with you. I don't know if you run PHPStorm, but it has a Drupal plugin and can reformat the whole project to something like itself if you want it to. I've been a Vim user for a while and PHPStorm is kind of blowing my mind lately.
I'll have to try checking it for errors. I've heard some others say that globals are bad too, but without an explanation. I already know what to do after fetch(), I just didn't include that in the question. (the function actually won't work on my local server without making a global variable inside of it) 
&gt; create_query($where, $order_by, $join_type='', $execute = false, $report_errors = true) This is an situation where an $options array might be appropriate. You can simply merge the defaults into the $options array using Array Union. &lt;?php function create_query($where, $order_by, array $options = array()) { // Merge in defaults. $options += array( 'join_type' =&gt; '', 'execute' =&gt; false, 'report_errors' =&gt; true, ); // code goes here } ---- from: http://php.net/manual/en/language.operators.array.php &gt; The + operator returns the right-hand array appended to the left-hand array; **for keys that exist in both arrays, the elements from the left-hand array will be used, and the matching elements from the right-hand array will be ignored.** (emphasis mine) 
It's called Zalgo text. ZALGO.
We'll see about that yet, the vote totals keep changing.
Objections fall into four camps: * PHP should always be weakly-typed only, because I say so (not naming names, but someone in particular said this) * PHP should only have strict scalar types (despite the fact this wouldn't line up with internal functions, and has BC issues) * You can't force the users of your API to use strict types * Supporting both behaviours is bad, somehow?
Good idea Sir Paul. 
This is what I teach my apprentices. This extended metaphor I created has helped a lot of people, with PHP or otherwise: Writing an OOP application is like writing a novel: 1. Classes are the scripts that an actor will follow. It tells the actor what to do. 1. Each class has functions (called methods), but these are much better described as Actions. 2. Most classes are meant to be instantiated into objects: These are the Actors. 4. By looking at the class' public methods, end-developers (the readers) will be able to quickly tell what that Actor will do, when asked (see: Encapsulation) or told to do (Top down/largely procedural coding) something. 5. An class' protected methods will describe what the Actor and his *children* and descendants can do. 6. A class' private methods will describe what only the Actor can do. 7. A class' *properties* describe, in summary, what an Actor can *know*, like their name or ID number. 2. Interfaces can be thought of as *Type Casting* role describers. By looking at the interface, one can quickly deduce that any Actor that implements a Type Casting will do the same actions as others who implement it... In practice, we have an app that needs to work with both a real-world 3rd party API and their test API, too. In this case, think of it like having the real actors but also having extras who can more or less mock everything the actors would do... and the basic actions are described by the interface. interface DomainAvailabilityInterface { public function query($domain); } class NameCheapAPI_DomainAvailablility implements DomainAvailabilityInterface { // The paid professionals... } class NameCheapAPI_Sandbox_DomainAvailablility implements DomainAvailabilityInterface { // The extras for helping others rehearse. } And then it's all tied together in the [DomainSearcher class](https://github.com/phpexpertsinc/domainsearch/blob/399d4bbc51e09ae60b30626fa9bc091b52364cf5/DomainSearcher.php). I hope this has been a most illuminating description for you.
Are you a complete fuckwit or just pretending? If "article is old" is seriously part of your critique, you need to step away from the keyboard....indefinitely.
waffle.io, looks interesting, thanks!
The problem with using docblocks is that this is perfectly valid PHP: /** * @param array $foo */ function() { } 
So is this: /** Always returns 2 */ function giveMeTwo() { return 1; } Of course docblocks are just comments - they don't influence code behavior (unless you explicitly try to read them), nor should they. Making a mistake in them is no different from making a mistake in documentation (except maybe more easily discoverable if warnings start popping up) I am only responding to that one specific point mentioned in the article. The one that claims that adding scalar typehints will improve an IDE's knowledge of the code and allow it to present the user with more useful information. Because all of that (and more) is already available and widely used in many libraries and frameworks. I wasn't talking about any other part of the article, or any other benefits/drawbacks of enforcing scalar typehints.
Well... both. First and foremost, I'm against the choice. I disagree with the notion that adding something to the language as a last resort - in order to reconcile a seemingly irreconcilable difference of opinion - is somehow a pragmatic middle ground. It's frightening, if you think about it. What's next? The community is divided about whether to add generics or not, so we add `declare(generics=1)` and pass that buck to the user, as well? This is a terrible way to design a language, and it further alienates PHP's primary user-base (newer/casual developers). Things should be *as simple as possible*, and a configurable language is anything but. Secondly, I'm against having to declare this per file. It's redundant, error-prone, and feels kludgy. I'm aware of the rationale, and I understand that it's the best option, but the best of multiple bad options is still bad. Lastly, I'm against the `declare` syntax, and would prefer `&lt;?php strict` or similar if this must go into the language. The scoping problems with `declare` are just gross.
When you plug a lamp into a power socket, does the lamp know anything about how electricity is generated? Does the lamp care if you are generating electricity yourself via solar energy or just getting it from the grid? No, all it knows is that it needs to draw power. It achieves this through an interface, the plug/wall socket. Everything going on behind the plug to generate electricity is being hidden from the lamp and you are completely free to change how you generate electricity as long as you conform to the same interface and continue supplying electricity through the wall socket, the lamp will still switch on. This is what an interface is good for, allowing you to completely change your implementation without the rest of your application having to change at all. The classic example is a logger, say you want to log every time a user does something into a text file. No problem, you create a Logger class, give it to the user and call a logToFileMethod() on it. That works, you're abstracting most of the heavy lifting. However, the text files have now become unmanageable and you want to switch to logging to a database. So you have to go into the User class and change all your method calls to logToDatabase(). That accomplishes the goal but it's pretty messy, especially if we start talking about more complex situations. Really though, the User should not care how you are doing your logging. That's not the User classes responsibility, all the User class needs to know is that it can log to something. So you make a LoggerInterface, your User class just tells people it needs some way of logging instead of any specific implementation. Then you could add 10 different methods of logging to your application without having to touch your User class at all. 
I won't name names either, but here's Zeev's reponse: http://news.php.net/php.internals/82163 It doesn't take long for his appeal to authority fallacy to make it in there.
What you're asking for is something called "Refactoring". Entire books and courses have been written on the subject. There's no single right answer (No two codebases are the same), but plenty of good techniques available, including moving from functional code to OO.
I'd suggest reading [*Refactoring*](http://martinfowler.com/books/refactoring.html) by Martin Fowler: it's really good at laying out the best ways to approach redoing an existing codebase. *Clean Code* by Robert C. Martin is also good primer in why object-oriented code can be more useful than procedural code, and how to translate what you already know to object-oriented concepts. Beyond reading, you should also look into adding full test coverage for your current codebase (should be straightforward for a functional design). That way, you can refactor parts of your existing application in an object-oriented way and know the correctness of it still stands without having to start from scratch. 
Unless they built it that way in order to hit a market deadline or for some other business benefit, what you have there isn't technical debt, it's just *a mess*. Technical debt is like financial debt. That's the metaphor here. You go to the bank and put yourself in debt for some reason (to buy a house or car, to fund a business enterprise, etc.). It's not something you do accidentally. Similarly, you might choose less than perfect software design to get to a certain deadline or to be first to market or for other perfectly legitimate business reasons, and you want to make sure you have plans to pay off the technical debt as rapidly as possible. Ignorance-borne messes like the one you've now got on your poor hands don't fit in the metaphor of technical debt.
I'm working with a contractor who writes HTML as individual echo statements and indents the echo statements based on the HTML. Example: echo("&lt;HTML&gt;"); FOUR SPACES echo("&lt;HEAD&gt;"); EIGHT SPACES echo("&lt;TITLE"&gt; stuff..")
Yeah, you told it on your earlier message. I liked how you wrote your reply in Zalgo text and wrote Zalgo at the bottom.
Location is critical. Interns in tech hubs (SF/Bay Area, etc) can easily earn a $60k salary = $5k/month. This ends up being roughly $30/hr.
Are you trying to convert a lot of old code, or is this more of a learning/concept exercise? Broadly speaking, the first steps to "modernize" would be: * Make it so that every PHP file does *only one* of these three things: 1. A script that is being executed by Apache because the user has gone there in their web-browser. 2. A template mixed with HTML whose only job is emitting the "right' HTML after the real work has already been done. 3. A class-definition... even if that class is nothing but a holder for a lot of static methods. * Separate out where each of those kinds of files live in directories * Make is so that you can *safely* `require_once()` *any* of your class-definition PHP files without doing anything beforehand or incurring any weird side-effects afterwards. This isn't particularly "OOP" yet, but it is an essential step of removing possible craziness in your code, so that you can minimize side-effects and start to organize how everything loads up. The next set of steps would be to move to a "front-controller" pattern, and to replace a lot of those `require_once`'s with an autoloading scheme.
I'm a big Jeffrey Way fan. I'm going through his old PHP Fundamentals Tuts+ course while doing some personal projects on the side as I learn. I love his way of teaching and I am eager to join Laracasts and learn more... but how much PHP should I know before starting Laravel? I want to learn Laravel but I also don't want to not understand what is going on. I plan on finishing his course then doing an OOP in PHP course, then maybe some experimentation... but most of all I want to keep learning and watching stuff—I really like it. PHP is not my first language, by the way (although it is my first back end one), and I already have OOP and some (small, but still) MVC-type experience. Thanks.
Didn't see that on the site until you pointed it out. Thanks!
I'd HIGHLY recommend [Laracasts](https://laracasts.com/). His videos really helped me get my head around proper OOP. Definitely worth the monthly subscription cost.
That's cool. I've always wanted to team-up with someone around my experience timeframe. If you want to do something together let me know. As you have read probably everyone has at-least 6+ minimum years of experience so, it's hard to get the motivation to participate in anything.
Pm me if you want. I'll go to bed right now, but surely tomorrow I'll respond :)
I can feel your pain
I think you can do it in slow steps. For me I start with basic function usage, then class usage. Let's say, I have certain logic, functionality, that I constantly re-use. For example, site navigation. create a class page, that has the function for different site/elemeents/navigation, and then include them in all your pages. Then $objectname-&gt;functioncall(); now the benefit of this, is that next time you need to make a change globally, you just change 1 file, instead of many. Then you can gradually create a library of essential functions. From html purifying, xss, sql-anti-injection, etc. So that anytime, you need to do xyz, you have the function code already written.
Classic /u/nikic coming in and teaching us all a thing or too. Kids amazing.
This.. Laracasts has great videos not only about Laravel. (But using Laravel is a decent intro to OOP too..)
Can you point to anything that explains classes and functions etc. and their hierarchy? How they're used? And not just for php but general OOP. I kinda get it when using php but JavaScript confuses me even more. 
In what programming world is Technical Debt not "quite" important in?
I've been reading through "PHP Objects, Patterns, and Practice" by Matt Zandstra from Laracast's recommended readings and I would highly recommend it as well. It goes into great detail on how objects work and how to design object-oriented solutions (not just solutions with objects). The examples on the book are very good and easy to understand as well. 
So... there are two major issues you are going to need to deal with. The first is that a lot of the common "workflow" kind of stuff is really a fairly specific *application* of OOP - MVC (Model View Controller). It might be best to start simple and learn what a class is, what an object is, what a property is, what a method is, what inheritance is, etc. Basic OO stuff. Then, the next step is to apply that to a small subset of your problem. For instance, let's say your form had a couple of fields for the submitter (First Name, email), and had a couple of fields for some other details (pet's name, age, gender, breed). So, then, whatever.php would basically do something like this class User { public $name; public $email; public function save() { db_insert($this-&gt;name, $this-&gt;email); //not real } } class Pet { public $name; public $age; public $gender; public $breed; public function save() { db_insert($this-&gt;name, $this-&gt;age, $this-&gt;breed); //not real } public function speak() { return "Roof! My name is" . $this-&gt;name . "!"; } } $user = new User(); $user-&gt;name = $_GET['user_name']; $user-&gt;email = $_GET['user_email']; $user-&gt;save(); $pet = new Pet(); $pet-&gt;name = $_GET['pet_name']; $pet-&gt;age = $_GET['pet_age']; $pet-&gt;breed = $_GET['pet_breed']; $pet-&gt;save(); print $pet-&gt;speak(); I'd then move on to a simple OO MVC framework - maybe something like CodeIgniter to start with. After that, probably something like Laravel. You can probably be pretty comfortable in a couple of weeks.
For beginning OOP, It's easy to go off the deep-end and get discouraged with all of the minutae, but I'd start simple. Both your examples include a variation of: - Connect to DB - Query DB - Close DB. This is a great place to "encapsulate" functionality. Does either script really need to know the details of opening &amp; closing a DB connection? No. All they should care about is creating a query, and getting a result. Think about how you would create a class that: 1. Accepts credentials and connects to a given database, storing that connection for later use. 2. Offers a way to perform queries on that connection 3. Closes the connection either on-demand, or when the object is destroyed (Usually by PHP once the script terminates.) Once you have a general purpose database class, things get interesting. You mentioned "Login" a couple times. I'm guessing the login process looks something like: 1. User submits a username/password 2. You run a SQL query against a users table and check the result. Again, this can be encapsulated into a class that you may use like this: $login = new UserLogin($database_connection); if($login-&gt;check($username,$password)){ //Do Whatever } Notice how we passed in something called "$database_connection"? Just like those scripts, the UserLogin class doesn't need to know or care about creating a database connection, it just needs one. This is is called "Dependency Injection", and it's incredibly powerful. - Something changed in the mysql libraries? Just update your database object and everything else keeps on working. - Want to write automated tests for your login class? Create a "Mock" database object that returns canned results for specific queries, and pass that in instead of the "real" one. At its core OOP is all about encapsulating complex tasks behind an interface, and then passing those objects around. That database class you created can now be used for whatever you want, User Authorization, Shopping Cart, Event Calendar, anything that requires database interaction. Once you wrap your head around encapsulation &amp; injection, everything else should be relatively straight-forward. 
"Shoddy Or Badly-Specified Construction". You can get the building up faster, but you'll pay more in maintenance and trouble adding to it. (Like all metaphors, it breaks at a certain point, I know.)
Well, I think my road block is two-sided; on one hand, I understand the concepts of objects and classes but after being told by so many people that OOP is such a better way to use PHP I have trouble understanding how it's anything more than just functions and code organization. I think I need to understand on a more refined level why and how it is better (other than code maintenance) in order to push my brain over the hump of doing what comes easy, i.e., procedural. On the other hand, every example i get of OO PHP through tutorials, books, and other sources uses real-world examples that don't do Jack squat for me -- i don't need to know how objects and classes are like a car or a book, i need code or descriptions of code that shows me login functionality, database connections and use, etc. (a few lovely redditors have commented on this very post with some code and/or descriptions kind of like this) and that's what i feel helps me the most. I don't want someone to build the code for me, i want some one to show me a little of how they would build a typical few parts of the code, to give me some actual meat to chew on. In the past, i haven't learned from creating some random hello world provided in a book, but by saying "this is what i need this website to do" and then going out and finding how to do this things, piece by piece. Does that help explain it?
As another side note, look into using Composer for managing dependencies on software libraries. Then, load up Guzzle and use that to make http requests instead of using the curl_* functions directly. Edit: I should also note that Guzzle does not require curl and will fallback if it's not available. You may want to test if it works in that case.
I've been using it in production since about a year ago, never regretted it for a moment. At the time lots needed to still be done, but at this point there is a lot of very accessible functionality implemented, and the code is a joy to work with. Very smart people in charge of the project, so things are constantly getting better/more elegant, and yes, that comes with change, but thanks to composer versions you can stick around the version you launch with until you're ready to upgrade. That help? Happy to discuss details.
&gt; which will only piss off the api user and gains you absolutely nothing as the function writer. How so? Do you mean that all the other languages out there with scalar types got it wrong, are pissing off their users and PHP is the shining beacon of "the right way" here?
http://www.yiiframework.com/doc-2.0/guide-input-file-upload.html 1) How did you initialized your form? You need to include ['options' =&gt; ['enctype' =&gt; 'multipart/form-data']] 2) Are you sing the FileValidator on your models rules? http://www.yiiframework.com/doc-2.0/yii-validators-filevalidator.html 3) Are you getting the instance of UploadFile? $model-&gt;image = UploadedFile::getInstance($model, 'image'); 4) Optional: You can use the -&gt;widget() method to load the FileInput widget http://www.yiiframework.com/doc-2.0/yii-widgets-activefield.html#widget()-detail
Thats good to know. Im looking for something thats easy to work with and fairly modern (read not magento or opencart) to start making ecommerce sites. The sites are nothing complex but for a while i have been turning down ecommerce work mainly due to the fact that existing solutions are poor and difficult to override. Im really looking for a minimal-ish framework that handles the ecommerce side where i can work freely above it and implement what i need. Symfony2 is my framework of choice at the moment so this seems like a good fit. In terms of versioning - whats the upgrading like? Do you find yourself locked to versions because of the amount of change per release will break / cause too many unexpected changes? I dont think it matters too much but good to know. Its good to hear its actually in use though, thank you.
If you like symfony2 framework, you have http://thelia.net/ Im testing it and seems nice.
Got a popup in my face after reading for 5 seconds: kthxbai
I'd start by learning how to write procedural code well, but no one ever does. They jump in OOP with the same linear mentality, putting class {} around things instead of &lt;?php ?&gt;. 
So... If we can do $this and $that we can ditch those complex design patterns and just glue everything together like JavaScript?
I've encountered this a few times when dealing with positions. I always ask for the frameworks they use in the day to day operations. CSS frameworks, JS frameworks, PHP/Ruby/Java/Etc, and what other tools they (generally) use. Most of the time I'm told they don't have a standard for the company. While I understand that sometimes this is normal it's a pretty solid red flag. Have you asked them about this sort of thing? My advice is to do so and whip up the system without frameworks. My guess is the person who reviewed your response was not a technical person or did not have access to / bother to read your readme you included.
Usually a test assessment should be done without any framework, unless it's explicitly required. Some developers are good at using frameworks but not as good at developing their owns tools. I did many assessments few months ago, and sometimes the answers are weird, you have to guess what the recruiter expects.
They responded on the email with what frameworks/libraries they use, and its pretty much non-existent. They use informed me they used jQuery and that's it. While the person I've been liaising with is a non-tech (company director), I know the senior dev there has reviewed my system, as they smashed it with attempted SQL injections.
There was no mention of using frameworks or not, I should of asked about this before I started building!
Have you used a framework? I know Laravel has this functionality almost 100% out of the box. I'd assume other frameworks have this or some sort of plugin that does. If that's not an option (though you probably should read up on frameworks and use them) then the process is really quite simple - just be diligent. You'll a database with a users table. The table will have at least three columns (more if you want more information such as last login, register date, etc. These are: - id (primary, auto inc) - username (unique) - password The password will need to be salted and hashed. You should read up on these. Suffice it to say that salting is essentially padding the string you want to hash. Hashing is 'encrypting' a password so that it isn't readable by humans who have access to your database. You will also need an html form and a session (which is dead simple to whip up a Google search should provide you with everything you need). &lt;form action='loginHandler.php' method='post'&gt; &lt;input type='text' name='username'&gt; &lt;input type='password' name='password'&gt; &lt;input type='submit'&gt; &lt;/form&gt; That will suffice but is not best. Salt your password input. It's possible to use a variety of things to do. I'll use foobar in this example case. $salt = 'foobar'; $password = $salt.$_POST['password']; //salting the password in a very basic example. $hash = crypt($password); You'll store the hash in the password column of the database for the user registering. Then you'll compare that to the input. Example: $pwFromDatabase = DB::getPassword($user); $password = crypt($salt.$_POST['password']); if($pwFromDatabase == $password) { //update last login //register session logic Session['username'] = $username; $authorized = true; } if($authorized) { //send user to target page. } else { //send user back (preferably with the username box filled in still, never the password. } Hope this at least gets your mind working for solutions. Do yourself a favor and really dig in and learn the best practices first. What I have included here is only a very basic example. While this solution proposed will work (the code is not checked for accuracy, nor is it complete) it is NOT fully up to par with everything more security concerned devs will recommend. Good luck! ---- Edit: Thanks for the gold you mysterious gilder you. :)
This is what I thought initially. However OP states that they developed the framework. I would imagine that'd more then demonstrate OP's abilities. The only thing I could see is if OP didn't provide access to the source code. Then again people are busy and probably don't care at all if the code was there or not, they just want a solution to flip through easily.
All source code was provided. Aside from using Silex/Doctrine, everything else was built by me (Not including the front end stuff!).
You have two classes that can be swapped interchangeably. Not from an execution/operational perspective, but from an API compatible perspective. To denote that aspect you can say that they both share the same interface, which you define it and which becomes a constraint. Example, you have some "DataObject" that has a format method, and you use it like: $data_object-&gt;format(new JsonFormat); // OR $data_object-&gt;format(new YamlFormat); One way you would implement `format` would be public function format($object_format) { if($object_format instanceof JsonFormat) { return $object_format-&gt;formatJson($this-&gt;some_internal_representation); } else if($object_format instanceof YamlFormat) { return $object_format-&gt;formatYaml($this-&gt;some_internal_representation); } else //exception or error } This would be bad for a few reasons: * if you want to add other format you'll have to modify the `format` method definition. This is not that bad sometimes when it's in your written code, but when you see it in a dependency you just make life harder for the end developer which will have to fork&amp;patch code for trivial extensions. * if you want to unit test the format method you'll have to stub the format classes * they do not follow the same invocation *interface* Now, if you change the format method to the signature `format(FormatInterface $object_format)` with the definition of (which both JsonFormat/YamlFormat will implement) : interface FormatInterface { public function format($some_internal_representation); } Then your format function on the "DataObject" becomes: public function format(FormatInterface $object_format) { return $object_format-&gt;format($this-&gt;some_internal_representation); } And you get easy extensibility and easier to test code (no stubs required) Some notes on the examples given: * Data objects might be considered by some a bad design practice * Sharing internal representation breaks the concept of encapsulation so you wouldn't do that * Interface suffix for interface names is a 2 sided dispute, some are against it, others are not :) The example was easier to write using those bad practices, and a mostly trivial (if not unrealistic) example **Edit:** Some people like to "program against an interface", which means they will define interfaces between object boundaries. That means that each time any object A calls a method on object B that method is defined as part of an interface. While that is generally a good practice, and mandatory for test driven development, I generally defer the creation of interfaces up until I have a swapable component. Simplifies code, but on the downside it will create backwards incompatible changes when the interface will be necessary. Your choice on the approach. However when writing code that is to be shared (modules/libraries) always stick to the "program against an interface" mantra, makes life easier for the end developer.
&gt; They responded on the email with what frameworks/libraries they use, and its pretty much non-existent If my past experience of handling this type of code is relevant, run. Run! and don't look back.
1. Do you know what your page generation times are? I did some tests on my localhost and they were in 500ms area. I am afraid that when I add 2000 products it will turn bad. 2. What payment gateways do you use? How reliable are those?
I've also seen the password hashing done in a loop. for ( $i = 0, $i = 65536, $i++ ) { $foo = crypt( $salt . $foo ); } 
Good try, Laravel CEO.
exactly, that's my point. The core could be split in two. The runtime-engine, written in C; and the php abstractions (aka SPL, PDO, and goodies) written with phalcon/zephir. 
Procedural programming is for amateurs, OOP is professional standard and practice. You cannot write procedural code well, because there's just no way to write good procedural code, it will always be spaghetti code however hard you try. Even if you write in a procedural language like C, a good program will appear modular, encapsulated and actually OO-like(just without classes and objects as C does not support these). Procedural programming is only good for absolute newbies learning fundamental coding concepts(such as variables, conditionals, loops, etc), since starting directly at OOP can be tough for many non-coders. However, it's a bad habit that every good programmer should get rid of, or better, never develop in the first place. 
Model's shouldn't be responsible for saving themselves to the database, it breaks the single responsibility principle and encapsulation. Edit: Spelling
A weak context, where strict checks are replaced by casting for your hinted function, implies the caller doesn't want to care about the type passed to that integer as long as there's a casting rule for it. Now, is that integer being used for something harmless like some "greater than zero" check, where string "10,000" becoming int 10 is trivial, or will it do something undesirable? The docs may say "DON'T PASS STRINGS TO THIS", then we are expecting the weak caller to check and remove corner cases before the casted call, or else. At that point I'm not sure why can't we just get plain strict typing and throw errors, instead of adding a weak mode with casting.
Aside from adding a composer.json so that it can be added to a project via the composer package manager, it would also be nice to see an example project with it in use.
I would recommend picking up: 1. [PHP Objects, Patterns and Practices.](http://www.amazon.com/Objects-Patterns-Practice-Experts-Source/dp/143022925X) It's a good book that covers the basic's of OOP with PHP. It also has a section dedicated to design patterns, and briefly covers things like unit testing, Reflection API, and best practices. 1. [PHP 5 Social Networking](http://www.amazon.com/PHP-Social-Networking-Michael-Peacock/dp/1849512388/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1423576644&amp;sr=1-1&amp;keywords=php+5+social+networking). The code in this book is a little old, but the idea is great. The entire book goes over the design and coding of a basic social networking site. You'll get to use the ideas you learned from my first recommendation to build a functioning site from the ground up. Now some of the practices in this book are old and no longer considered "best practices", but this can be seen as a plus, because it will give you the chance to go through legacy code and refactor it. 1. [Patterns of Enterprise Application Architecture](http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420/ref=sr_1_1?s=books&amp;ie=UTF8&amp;qid=1423576932&amp;sr=1-1&amp;keywords=martin+fowler+patterns+of+enterprise+application+architecture). Outside of the Gang of Fours book on design patterns, this is the best book out there. None of the code examples are written in PHP, but that's ok because this book will show you how all the pieces of a large scale code base fit together. This book is more about over all theory than anything else which is why I recommend it last. Also, it's kind of pricey. Outside of those books there are also some great resources on the internet that will show you how OO programmers think. [PHP Academy](http://youtube.com/user/phpacademy) has a bunch of great videos about building thing like a OOP login system and a basic MVC framework. Not all of the thing you will see in these videos are best practice, but they will at least help to give you some insight into the thought process. Also you can check out [these](http://www.sitepoint.com/author/agervasio/) articles on sitepoint. They have a lot of great php articles, but this author has written some of my favorites. Finally, learn the [SOLID](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) principles of OOP. These are indispensable if you want to understand how to "think in OOP terms". You could literally spend days googling this topic. Hope this helps and feel free to PM me if you have any questions. 
Wow... very well stated and informed reply.
This may be a poor way to learn OOP, but I thought I was clear that I agree--I DON'T need any more OO PHP tutorials. Mostly because of your point #3. As regarding point #2, for me, personal exploration of a method of coding involves trying things and figuring out problems through experimentation (and of COURSE I don't do that on a paid project), which you might call "guess" at things, but in all my personal past experience it's the best way I can, over time, achieve a "sound grasp of the fundamentals". I'm not looking for a shortcut or miracle or 24-hour turnaround, and I kind of resent the implication that I am, although I appreciate your trying to help. I'm looking for a hook to start working in a programming method foreign to me, not a lecture about why I'm asking the question wrong.
I use a self-hosted Redmine instance for the following features: * Git integration (try the github plugin) * Issue tracking, updatable by e-mail if you like * E-mail notifications * Time tracking * It's free and runs reliably
Umm I might be wrong here but isn't FTP/SCP/Dropbox/etc protocols not file systems?
Word. Yeah I love OOP and all, but for me, nothing comes close to OLAP SQL in terms of interesting, exciting, and fun. I feel like many can write code, but few can make real sense of big data... Sounds like you might be smart enough to do that, so that's my suggestion. Get your cube on.
Thanks!
Well, I'm setting it up like it's a static page and you're JavaScript. But I'm not asking for something runnable, and I'm even treating it like re-rendering the sorted output is a given. I'm asking them to talk me through how they'd approach sorting *as a problem*. Some of them talk their way to a bubble sort. That's maybe the best answer I've actually gotten. Hardly anyone can describe a quicksort or mergesort. I like to see that their thinking is clear, and maybe even a little optimized. If they have principles like "divide and conquer" in their gut. Like that. However, the problem is surrounded by enough distracting fluff (like re-rendering the DOM with the sorted data) that if they go straight there and avoid the nut of the problem, that tells me something about their thinking too...
Is abstracting away from the database a mistake? I don't see how this is different.
&gt; that tells me something about their thinking too I'm not sure I agree with that. All that 'distracting fluff' is literally just that, distracting fluff. You admitted that nobody would be doing it this way in the real world. If I was hiring somebody, proposed this problem, and they said "The best way to solve this problem is to query the right data, rather than sort it with Javascript." - I think I would accept that as an answer. I hate feeling like my time is wasted in interviews. This problem definitely feels like that. I guess in fairness, this problem could be rephrased as: "You have access to an API that doesn't give you options to sort the data. It comes sorted to you by last name as default. You need to sort the data by city, then last name." That is close enough to what you were wanting, and much closer to a real world scenario. Though, PHP has a crap ton of functions for array management, I don't know JS that well, but I imagine without the use of lodash or something, this task would be significantly easier in PHP.
What advantage does this have over [FUSE](http://en.wikipedia.org/wiki/Filesystem_in_Userspace)? And what does "vendor lock-in" have to do with anything?
Why would you still want to work for a company like that? You probably will not be able to further improve your skills. Publish your DI on github and sent out some more applications. There's still a lack of good developers out there.
Well I guess it's not really technically complete lock-in. But I've been meaning to switch from Cloudfiles to S3 for quite a while. This should make it quicker for me.
So, is redis in itself a databse, or a mysql plugin? And say, if I was to create a blog page where I would do `select title, slug from articles limit 50` now I am assuming since every page refresh runs the same query, redis could be used to cache the result/query for subsequent results? Is that roughly what it does?
I've switched from Apache to Nginx. There doesn't seem to be much need for Apache most of the time now unless you need a module that only it has. I'm about to personally switch to PostgreSQL. The built-in JSON support looks pretty cool, you can even index fields inside JSON. They're also working on some stuff to allow postgres to actually serve data over http, like couchdb does. So there's a few nosql type benefits without dropping SQL, which should be interesting.
It's neither a database nor mysql plugin. You could cache that, yes, but you will have to do caching by hand, putting your data into Redis on the first page load, and also you'll have to clear this cache when a new article is published. Think of MySQL as a hard drive and redis as RAM. And you have to manage both.
People will abstract away MySQL vs PostgreSQL, but they don't tend to abstract away MongoDB vs PostgreSQL. Instead they tend to offer two different abstractions tailored to each solution. The reason for it is simple. While they both do in fact store data, the differences between them are large enough to have serious performance ramifications. Here, let me draw an analogy. It's kind of like accessing a file on your local filesystem vs accessing it on a remote server via FTP. The performance implications are so wildly different that you're going to instead want two different abstractions so you don't fall into the trap of trying to get both to be performant using the same code (which won't happen).
At risk of wasting more of your time... I often take built-in sort() functions off the table. Let's say you only had comparison functions and array manipulation. Sort. Again, I don't expect running code. I expect insight into how this person thinks. BTW, some of my best guys totally couldn't do this, but gave it a college try and expended a little actual mental effort, even though they were ultimately unable to come up with a good solution. This isn't a "can you do it" pass/fail deal. It also serves as a sort of Kobyashi Maru--given something you never have to do in the real world, what do you do? Do you crumble? Do you refuse to play along? Do you bluff? Do you hunker down and try?
Just a guess: if you don't have control of the OS layer, or want portability (read: windows), FlySystem might provide this over FUSE?
You could cache your images in RAM in your app, with for instance Redis or Memcached ; or you could use a cache server in front of your app servern with for instance Varnish. Do you have any other requirements ?
+1. It can also be very useful in a hybrid cloud environment, where you have one app deployed on heterogeneous systems. 
The purpose of FUSE is to let you write filesystems without "control of the OS layer" assuming you mean kernel. If not, can you expand on this? Dokan, fuse4win (both abandoned, according to wikipedia), and DokanX give you FUSE on Windows.
I can't see any text, using Reddit News app. :o
It would help if you said what you were actually doing with the PHP. You should probably add composer to your list. And for a framework (if you need one) Symfony. 
Well i would go by assuming that if the fiePath is in DB then your are sure thats it exists on disk. you can run a cronjob to ensure it exists and update your db. Another option is If you are serving image files you can use nginx and try_files command. If the file is not found on the disk nginx uses first found occurrence (is like coalesce in mysql) http://nginx.org/en/docs/http/ngx_http_core_module.html#try_files
And yet, no one uses an API that treats OneDrive, SBM, SSHFS, and so on exactly the same. Not even unix, in which "everything is a file" does so. ioctl is a thing. You'll happily use them as distinct things, which is the point. Keep them distinct.
@filemtime() to check whether it exists and check its modified time at the same time. Then compare it to the HTTP request's If-Modified-Since header and just return 304 Not Modified without any content if the file hasn't been modified since. Otherwise serve the file. You could combine this by also forcing some short memory caching as suggested by /u/gou1
Invest in some good developers. If you don't have time for code review, you are doing it wrong. Empower the team to review the code themselves. Also, https://github.com/asm89/twig-lint
It seems to work only on PHP files but I take a look at custom rules. Thanks
Unfortunately that is beyond my power, I'm just the senior dev on the team.
You might want to adjust the [`realpath_cache_size`](http://php.net/manual/en/ini.core.php#ini.realpath-cache-size) and [`realpath_cache_ttl`](http://php.net/manual/en/ini.core.php#ini.realpath-cache-ttl) INI settings. I believe that this is precisely what you're looking for. EDIT: I should probably expand on why this is relevant. The realpath cache affects all of the methods you are using. The [`clearstatcache`](http://php.net/manual/en/function.clearstatcache.php) function lists the methods affected by the cache.
&gt; FUSE only works on Linux This is not true. https://github.com/BenjaminKim/dokanx
I agree with Redis or Memcached, as long as you are ok with adding to your stack. Luckily, it's easy enough to do in PHP because the libraries and support are there.
&gt; And yet, no one uses an API that treats OneDrive, SBM, SSHFS, and so on exactly the same. This is true on some level, but is usually abstracted from the user in the same way Flysystem would abstract it from the developer. You can mount a SMB or SSHFS drive with `mount`. There are GUI tools that do this for you as well. On Windows it's even more transparent what's happening. Hell, there are .NET libraries that abstract away network service details since we're talking about developers here. &gt; Keep them distinct. This is simply not necessary on every level. As a similar example, if you're writing PHP, you don't care about the CPU architecture and machine language instruction set. Quite simply, you're wrong.
Actually "permalinks" is what it's called from a CMS / Wordpress-y type of site's perspective. From an application coding perspective, it's called routing. Setting up your own router is fun and easy enough (there are many articles on the subject), or you can use an existing routing library. Both involve mod_rewrite if you are using Apache.
You're the senior dev on the team! You have all the power! You have the experience, you know what's up, and what's happening on your team. Step up, tell everyone what the state of things are, where things will go if it continues this way. Tell them what you need in order to Do It Right (tm).... Go get 'em :-) .
You could use Reflection to inspect the function's parameter positions and names: $func = new ReflectionMethod($listing, 'edit'); $data = array( 'id' =&gt; 1234, 'title' =&gt; 'Some Awesome Thing', 'firstName' =&gt; 'Joel' ); $args = array(); foreach ($func-&gt;getParameters() as $i =&gt; $parameter) { if (isset($data[$parameter-&gt;getName()])) { $args[$i] = $data[$parameter-&gt;getName()]; } } call_user_func_array([$listing, "edit"], $args); I've tested the code above, and it works.
call_user_func_array(array($listing, 'edit'), $data);
Because: * PHP is dynamically-typed (parameters lack a fixed type, and this also provides a better solution for supporting multiple types for a parameter) * PHP is weakly-typed (overloading on scalar types would be error-prone) * PHP has *actual* optional parameters (a better solution than faking them) * Having 20 different definitions of the same function which do different things or have different incomplete overlapping subsets of its functionality is horrible API design and overloading encourages it - this is one of the things I hate most when I'm using C#, Java or C++
&gt; @filemtime() Good call on this... thanks!
You could combine the file_exists() and filemtime() calls into one stat() call. As PHP caches file stat data, this may happen implicit under the hood already. So using one stat() may not reduce the load at all. What kind of SAN are you using? It may possible to increase the throughput by increasing the inode cache up to an amout that only the actual reads require disk access, the stats and lookups for the actual data inodes come from cache. But that is very dependend on your SAN and how your SAN is connected to the image servers.
I do, and many others. But it supports SFTP now too.
We used to do this, but instead moved all our images into an Amazon S3 bucket and retrieved it from there - with the AWS SDK for PHP you get the metadata back with the object (so you get filemtime), and for us it turned out to be both cheaper than keeping the SAN and performed better.
Many people do, unfortunately. So, a tool that makes deploying on those environments easier is welcome. 
In PHP 5.6, use the [unpacking operator](http://php.net/manual/en/functions.arguments.php#functions.variable-arg-list.new): $data = array( 'id' =&gt; 1234, 'title' =&gt; 'Some Awesome Thing', 'firstName' =&gt; 'Joel' ); $listing-&gt;edit(...array_values($data)); For PHP &lt;5.6, /u/nicoSWD's [suggestion](https://www.reddit.com/r/PHP/comments/2vfr9d/can_you_pass_an_array_instead_of_individual/coh94so) of [`call_user_func_array()`](http://php.net/manual/en/function.call-user-func-array.php) is more or less the same thing, though a bit more limiting in terms of expressiveness. Edit: changed `$listing-&gt;edit(...$data)` to `$listing-&gt;edit(...array_values($data))` to fix error [pointed out](https://www.reddit.com/r/PHP/comments/2vfr9d/can_you_pass_an_array_instead_of_individual/cohb84y) by /u/StiltonStilts below.
If you want to abstract your filesystem usage then use something that abstracts your filesystem usage. If you dont want to abstract your filesystem usage then dont use something that abstracts your filesystem usage.
The deployment tools you mentioned make maintaining FUSE installations trivial.
I agree with /u/scottchiefbaker, thanks for taking the time.
Not just a separate remote system, but also the same system, but as a different user. WordPress does this when updating and installing plugins, to make sure the files are not owned by the web service user, though obviously not using flysystem but the idea is solid. 
agreed
Missing that point, all day long.
What's the difference between S3 v2 and S3 v3? Why do they even offer both of these?
This isn't a good idea, this makes the order of the keys in the array significant. `call_user_func_array` ***does not respect parameter names***.
Redis is an in-memory nosql datastore, *edit* with persistence. People have referred to it as a data structure server, because you put data structures into it and you get them out. Key-value, hash, list, sorted/unique sets, pub/sub. Overall it's a very cool tool.
"Use a computer" lmao
&gt; It's order dependent, but the OP didn't say they wanted a named-parameter equivalent, just a way to map their array onto the parameters of the edit method call so they don't have to type out each of the array members twice. &gt; The example OP provided is that the array is there simply for identifying each of the 30 parameters sent to method, not that the array is being generated automatically. It's not order-dependant, it *doesn't work*, period. It throws a *catchable fatal error*. But even if it did work, it wouldn't be a good idea: you're producing unmaintainable code if you're providing string keys *and ignoring them*. I assume the OP would have just used `array_values()` if what you're describing is what they needed. &gt; since you silently your reply completely after I replied to this (one of the many reasons why I try to quote people's replies in my responses): I didn't silently edit it... but you just silently edited your reply to add in `array_values()`.
OP said he cant - he doesn't have access to the function to change it.
file_exists() is not the best solution if you want to touch the file system less, you should as you mention yourself just assume the file exists and try to read it and then handle the case where is does not.
&gt; I didn't silently edit it... You do realize when you edit a comment it says so in the header, right? I don't even understand why you'd feel the need to lie about that. I guess it comes from the same mindset of someone who flies off the handle when they see an easily-correctable error in code? I dunno, either way, you might want to consider cooling it.
&gt; You do realize when you edit a comment it says so in the header, right? If done after a minute or so. &gt; I don't even understand why you'd lie about that. I didn't lie. Maybe I misremembered, but I don't recall editing it. &gt; I guess it comes from the same mindset of someone who flies off the handle when they see an easily-correctable error in code. I'm not "flying off the handle". What you're proposing leads to unmaintainable code.
You're balls off the wall crazy and you're still editing your replies like mad. Get help man.
&gt; Would you at this point accept pseudo-code then? I'm happy with "Okay, geez. Whew. So first, I guess I'd run through the table and stash up the textContent of the td's into an array of arrays. Okay. Then... I guess I get myself a new empty array to save rows into, in order. Then I loop through the top level of my array of arrays, and find the one with a City value that's next higher than... Ooh, you know what, I need to keep track of where I am in the sorted output, so I gotta back up before my loop and declare a variable to be a sort pointer, and initialize it to an empty string...." That would be the beginning of a highly successful answer, right there. &gt; I would make it clear that this solution is a bad one, but if I absolutely had to do it this way, here's what I would do. I make it clear when asking the question that the solution will be a bad one. I say, "And if you ever actually do it that way, you're fired." There's no subterfuge here. I'm clear with people that the point isn't working production code, but that this is a tool to see how they think about data and programming solutions.
I use [ExpanDrive](http://www.expandrive.com/) everyday.
Have a look at Redis.
All of this is **very** fair then. I had actually said "verbal answer" before "pseudo-code" but figured since you said "built in sort functions are off the table" that you'd want something more code like. Given the new understanding, this isn't much of a waste of time at all. Critical thinking is definitely a major component to see how good somebody will be at a task like this, so disregard all my time wasting comments :). Also - very fair that you said "if you do it this way you're fired" :)
Try, curl_setopt( $curl_handle, CURLOPT_COOKIESESSION, true ); maybe..
Well you make a point, I agree that nothing is perfect, but its obvious OOP is a way better and organized design paradigm than procedural programming. My point stands that procedural programming is for amateurs, its only good for designers who build their personal sites mostly consisting of static HTML pages that only need embeded server-side code. Those people only want to build their personal home page(lol thats where PHP originally was called), and they have no need or even competence to learn OOP. For true programmers however, procedural programming offers absolutely no value at all, and it has no place in modern programming world. As you know OOP is more than just using objects in your code. Take transaction script as an example, it may use database objects but the approach itself is procedural, and therefore an anti-pattern. When you write a program with design and architecture in mind, you are already thinking the OO way, you already move away from the procedural mindset. Procedural programming does not come with any designs, its spaghetti code no matter how you view it. Of course, many PHP applications actually are a mix of procedural and OO, so it can be confusing as they follow some kind of design, but incomplete or inappropriate design. A good design, on the other hand, is effectively OO. Of course, writing classes {} does not make a good program, not even truly Object oriented unless the design approach is OO, but its a good starting point. You have to start at somewhere, and gradually you will learn to write OO code, step by step. At least, its way better than writing amateurish procedural code and be happy about that. In fact, teaching procedural programming to newbies can be a problem in future, since bad procedural habits can come back and bite you during your transition into OO world. If a programmer writes too much procedural code, they may develop bad programming practices that cannot go away easily. I know one such person myself, so I understand what I am saying. 
You're describing [EAV](http://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value_model) . I'm guessing you're already aware of this. I've personally implemented an EAV-based Model using Doctrine. It seems many people would doubt whether this is a good idea since Doctrine isn't Active Record. Regardless of whether it's the "right" way to do things, it can be implemented. Basically, you have the following parts to it: * Attribute Set table * Attribute table, stores data type and string ID * Attribute data tables, each with a different data type for the value column * Mapper table for Attributes and Attribute Set * Entity table with a foreign key to the Attribute Set table Thoughts ?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Entity–attribute–value model**](https://en.wikipedia.org/wiki/Entity%E2%80%93attribute%E2%80%93value%20model): [](#sfw) --- &gt; &gt;__Entity–attribute–value model__ (__EAV__) is a [data model](https://en.wikipedia.org/wiki/Data_model) to describe entities where the number of attributes (properties, parameters) that can be used to describe them is potentially vast, but the number that will actually apply to a given entity is relatively modest. In mathematics, this model is known as a [sparse matrix](https://en.wikipedia.org/wiki/Sparse_matrix). EAV is also known as __object–attribute–value model__, __vertical database model__ and __open schema__. &gt; --- ^Interesting: [^Diseases ^Database](https://en.wikipedia.org/wiki/Diseases_Database) ^| [^Magento](https://en.wikipedia.org/wiki/Magento) ^| [^Database ^model](https://en.wikipedia.org/wiki/Database_model) ^| [^Embedded ^database](https://en.wikipedia.org/wiki/Embedded_database) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cohf3c5) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cohf3c5)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I'd like to see your Dependency Injection component. That being said, yeah I would understand them not wanting you to use libraries and see how you tackle problems without them, but seeing that you build your own DI container, should give them a good hint, that you know about design patterns, SOLID and so on...
yep, i've gone about it in a slightly different way. I only have 3 tables. A table for Assets, a table for Attributes, and a join table for them (asset_attributes). Here's my attributes table schema Attributes =========== id | discr | string_value | decimal_value | bool_value Each of the *_value columns have the datatype specific to them. The "discr" column is a discriminator column. It contains strings like "string", "decimal", "bool". I've configured doctrine to use single table inheritance to use different attribute classes. For example, $asset-&gt;addAttribute(new DecimalAttribute("price", 1.99)); The constructor for each attribute class is responsible for casting that data to the correct type and doctrine knows based on the attribute class which column to place the value inside the attributes table. Does that make sense?
Yeah, I've used single-table inheritance quite a bit. I think your idea is interesting; although I'm not sure I agree with having a column for each data type. You asked for recommendations and I offered one.
&gt; It should be clear (or clearer) from the PHP syntax that using method overloads violates the single-responsibility principle Not so much. If you look at idiomatic code in languages with method overloading, they often use overloading as a way to supply default arguments. We do that all the time in PHP -- we just have default arguments. It's not a SRP violation -- and it only would be if the overloaded methods do completely different things. Which would be a dumb design decision. In other words, a language feature would not violate SRP, but a person's *use* of a language feature could.
You mean, 59:27 :P And yeah, it's sitting at 68.6% in favor. Edit: 60:28, back to 68.1% in favor.
Yet I've seen lots of models that do just that.
An API for a filesytem... something something file access being a part of basically every language... something something since ever.
Symfony isn't hot like it used to be. Laravel or Phalcon would be better choices. http://www.sitepoint.com/best-php-frameworks-2014/
Nah he should use jQuery.
I don't pick frameworks on the basis of how "hot" they are. Doing that will mean you're learning a new framework every year. I choose Symfony because it is good, mature and established.
How the f**k did that happen? A few hours ago it had a very disappointing 49:29 ... Hope it stays the way it is now.
I deployed it my staging server to *just* try it out. No configuration whatsoever. Thanks for the tip with Twig extension, I have a feeling it will help me with other projects. 
Even though it's for more advanced Id just use magneto
You mean the same rfc that seemed to be doomed just a couple of days ago appears to be passing now? By the way, doesn't this rfc state then when turning strict types on, functions/methods which are called from the file are affected rather than functions/methods defined in the file? Shouldn't it be the latter?
Although one could argue this: http://www.javacodegeeks.com/2013/01/the-builder-pattern-in-practice.html
I'll keep it in mind but don't you think it's a bit of an overkill?
With that logic, any library I make with methods typehinting _classes_ should also only be suggested, not strict. One big thing method arguments having typehints allow you to do are the ability to avoid having to manually write `if (!$arg instanceof ExpectedClass) throw new UnexpectedValueException;` at the beginning of every method. Naturally it is the library's maintainer's responsibility to decide how strict their methods are. So should be the case with scalar typehints. This currenly seems illogical and works the opposite to how class typehinting works. If this RFC passes, then unless people will all begin to use strict mode at the same time, hardly anyone will use it. Reasons being that people who would otherwise want to use strict mode in their library to relieve themselves of a lot of validation logic will think it's pointless if any non-strict consumer would invoke their methods, and someone trying to make a non-strict library typehinting strings that should accept any value including toString-able objects in hopes to provide flexibility to consumers won't actually be able to provide the flexibility at all, knowing that any consumer could have strict typing on, in which case the maintainer of the library may feel discouraged to bother with scalar typehints at all.
Nope. Redis is at its most basic a key-value store designed to reside entirely in memory. This makes it usable amongst other things as a caching solution but it does not make it a cache. That would to seriously underestimate its value. I would recommending reading this http://redis.io/topics/data-types and then in future, when you are trying to think of a solution to a problem, just remember this with lots of other stuff to see if it might one of the tools to help you solve a problem. But just a cache? Hardly. In general, my advice for a growing developer is to read about lots of stuff, remember it, so that when you are faced with a problem you can go "wait a minute, I read about X, maybe I can apply that to fix it". The problem is that if you study just 1 or 2 elements is that it is like seriously deeply studying the hammer. You will probably become an expert hammer user but every problem then starts looking like a nail. And worse, you might only think of hammers as being able to hammer in nails. And be at a loss to find a tool for the removing of nails.
You pretty much can't debug anything with curl if you don't setup a debug output of some kind. I like starting here: $dbg = fopen("debug.txt", "w"); curl_setopt($ch, CURLOPT_VERBOSE, TRUE); curl_setopt($ch, CURLOPT_STDERR, $dbg); There are countless reasons why it might fail, but having the debug output will help you (or us) find out why. I should add that javascript can also be a culprit. I've had to simulate some of the login JS in php to produce extra tokens that the site required. They do this to prevent the type of thing you're trying to do. Just because you've scraped the HTML form, doesn't mean that JS didn't modify it during submission and you're missing some fields. A good browser tool to use is Tamper Data to intercept the header data that your browser is generating during a manual login process.
This is what I was going to suggest. S3 just makes things easier.
I agree on that, but I want to create a responsive, nice looking web site and magento would be a nightmare for that kind of front end wouldn't it?
I love this, actually I am really hoping that this feature is added to php
Why not create a wrapper/data class, you collect the data you need into an instance of that class, do all the validation etc in that, then in that class call the function with 30 parameters and voila, from then on that nasty function is gone. You can then later replace it completely and keep the same wrapper. Passing in an array of 30 elements doesn't seem to be making the code any cleaner. 
Always try to stay on top of your language but only to the point of what is actually being used in production environments. njinx is not that different from Apache in configuration. Some may contest it but in most cases Apache serves your purpose. If you are in a dev house for sites you may have to run an njinx server, but you are probably not going to get so much traffic that warrants it. If you are in an enterprise org you they will have dedicated admins that dont program. mariadb vs Mysql follow the same rules as Apache vs njinx. NoSQL is a good thing to learn. As an overarching concept. You should understand the whys and hows, not every implementaton redis is memcached on steroids. But once again we are talking small performance gains unless you go enterprise level applications. docker - everyone should learn docker, from small orgs to big enterprise apps. It is the future. Vagrant is good for local testing depends on your situation and where you work. If you understand how to stand up a VM of any kind Vagrant is pretty easy. My suggestions: Ansible AngularJS or something like it. API driven websites are where things are headed. 
I'm not talking about the difference between weak and strict typing. I'm talking about interoperation problems between projects using strict, and ones not using strict. And by the way you can use instanceof with interfaces. But regardless, the purpose of my (simplified) analogy was supposed to demonstrate whose responsibility the strictness of [anything] has been in PHP, concluding the fact that it's been the function/methods' exposer who got to decide how strict which bit of his code is.
It's obviously a quite neat implementation, and the amount of existing adapters is astonishing. It's however less compelling with not being API compatible to *anything*. Horde/PEAR VFS would have made sense as base, or even method names in line with PHP (e.g. why `-&gt;deleteDir` instead of just `-&gt;rmdir`). And a modern VFS implementaton should at least prepare for versioned filesystems etc. One can still cater to the lowest common denominator by just padding out the banal adapters.
OOP at its most basic, the way it was introduced in 3.0 (and please don't jump down my neck if I get some details wrong, i am old and senile as should be clear from having worked with 3.0) is that OOP allowed you do combine function (methods) and variables (properties) together for related things. Take the most basic class probably everyone wrote 15 years ago. class DB { } In your procedural style, you probably have these variables: $password, $domain, $database. You probably also got a function like connect($database, password, $domain) in which you connect to the DB and handle any errors that might occur. You MIGHT already have split these variables and functions into a seperate file called db.php which you include from your whatever.php Good because now you can include db.php into any PHP file that needs database access and have all the variables and functions together. Handy right? (Please experienced DEV's that is how we did it back when Y2K seemed real, it is bad, it is hopelessly out of date and it created the web we know today). But what if you also accessed say an FTP server, it also would need a password variable. You could create one variable $db_password and one $ftp_password but does the entire program need to know the $password variable? No. What if you could combine functions and variables so they always belong to each other AND keep them seperate from others? That is where OOP at its most basic comes into play. class DB { $password = 'gsdfg'; function connect($this-&gt;password)} (this is not proper PHP) Now I can still connect to the DB, it still has the password variable it needs BUT it is seperate from the rest of the code. There is a LOT more to it but if you are getting started and are self-educated, it is a place to start without getting immidiatly bogged down into details that might make the learning curve seem like a vertical wall. So take a look at your existing code and see what parts are re-used, which can e grouped together and why that makes your code easier to maintain and understand.
Ecommerce is a complicated beast, and some of those complications will raise their ugly head as the site progresses. I would suggest using CMS like Magento or Drupal Commerce to handle your site. They have already tackled your major issues and your development and future support will be easier. 
I may be in the minority here, but this really doesn't seem like a feature I plan on using. The lazy typing of PHP is a nice feature, and makes coding some things quicker. I'm not against this, but it's also not a feature I'm really excited is going to land. Put me in the "meh" camp on this one.
I added this and immediately began seeing more verbose cookie data (2 additional lines in my cookie.txt file). The process now, however, takes me to the remote site (not on my localhost environment) with a hidden value appended to the URL like a query string value...
Well yeah, once it's complete I'll do both of those things. I was more asking what sorts of features people would like to see in a grid math library.
That sounds like what most sites will do when you POST data: redirect to another URL. You've got CURLOPT_FOLLOWLOCATION turned on so it follows, literally and figuratively.
Not entirely content with the implementation. I understand the motives, but still :/ Anyway, it's better than nothing
Can somebody post a link to a GOOD, MODERN way of reading the internals mailing list? I need to consume tears
59:28 :/
Strict types make it easier to reason about code. Sure we can use docblocks but comments often end up telling lies. With type hints I can look at a method signature and understand immediately what's expected, and get an error if I call it incorrectly, instead of PHP happily churning along giving whacked out results. The best part is you don't have to use it -- its completely optional. 
Me too. I'm hoping it can pass.
I wish they'd have to fill out a comment when voting no on an RFC. so that we, and especially the author, can understand why it was voted no.
It seems to be working. **needs more lobbying**
I set it to false and it still sent me to that page. I'll keep playing with it to see if maybe I'm just overlooking something because I'm getting pretty tired (getting late over here). I'll follow-up tomorrow if I figure anything out.
I think the API developer should be able to authoritatively define if he wants the interpreter to throw an error if it doesn't receive the type it wanted. Not just silently accept it just because, even if it converts it (it converts it, right? please tell me I understood correctly and it converts it). The implementation that is being voted is not bad per se, but it could be improved. Something like &lt;?php define(strict_types_permissive=1); // doesn't throw error but converts the data define(strict_types_permissive=0); // throws error. should be the default // here's the API code, not the code that consumes it. The code that consumes it is bound by // the rules set by the developer Still ugly, but in my opinion better
which is perfectly fine. The reason being it's specifically developed for your needs, you know what aspects of the performance implications you can deal with, and which you can't. There's a difference between abstracting away details (a projects need for data storage) and treating dissimilar things in the same manner (local file vs FTP file). The issue is that no 3rd party off the shelf component is ever going to be able to satisfy your needs unless they're extremely basic. Due to the very nature of the underlying "protocols", the implications of the FTP is going to be vastly different from the implications for the local filesystem. You're eventually going to run into those differences and if you're using a 3rd party component you have to hope they support whatever it is you're doing. And everytime that component tries to support that use case, it gets more complicated. Just grab an FTP library, an S3 library, and what have you. Implement what you need using *those* abstractions. You have more control, people unfamiliar with what you're doing can see it in the source code explicitly, and you don't have to accept the complexity of a 3rd party tool working at the wrong level of abstraction.
If thats so, then thank you and all lobbying people. I tried my share with sending a mail or two to internals but as an unknown there you seem hardly worth an reply.
Rather than executing the curl commands manually, consider using something like [Goutte](https://github.com/FriendsOfPHP/Goutte) which makes scraping much easier.
Does anyone have any experience with how this compares to [Gaufrette](https://github.com/KnpLabs/Gaufrette)?
Aura.Auth can help you with http://securepasswords.info/aura-for-php/ 
I didn't like the RFC at first, but after reading that I've changed my mind. He actually tried the patch, and we know Benjamin Eberlei is definitely not a "PHP4 FTW" type of guy, so that's definitely an interesting feedback…
No. You're not getting anything in the debug file because the permissions are incorrect for the directory/file. You should always get something. There is a lot of dialog info in there that you can used to debug the connection problem. Here is an example when using cURL's http protocol, but you get the idea. '&gt;' is sent from curl and '&lt;' is received. * About to connect() to cnn.com port 80 (#0) * Trying 157.166.226.26... connected &gt; GET / HTTP/1.1 &gt; User-Agent: curl/7.22.0 (i686-pc-linux-gnu) libcurl/7.22.0 OpenSSL/1.0.1 zlib/1.2.3.4 libidn/1.23 librtmp/2.3 &gt; Host: cnn.com &gt; Accept: */* &gt; &lt; HTTP/1.1 301 Moved Permanently &lt; Server: nginx &lt; Date: Wed, 11 Feb 2015 05:05:28 GMT &lt; Content-Type: text/html &lt; Transfer-Encoding: chunked &lt; Connection: keep-alive &lt; Set-Cookie: CG=US:--:--; path=/ &lt; Location: http://www.cnn.com/ &lt; X-UA-Profile: desktop &lt; &lt;html&gt; &lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;/title&gt;&lt;/head&gt; &lt;body bgcolor="white"&gt; &lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;/h1&gt;&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt; &lt;/body&gt; &lt;/html&gt; * Connection #0 to host cnn.com left intact * Closing connection #0 In this response you can see the cookies and the redirect header from cnn.com to www.cnn.com. cURL was not setup to follow so it closed the connection after the 301 error response.
POST headers don't have any URL redirect information, so there's nothing to follow. The response usually contains a url location to move to and if cURL isn't following that will show up in the debug info.
Thanks for the warning
Thanks! Have you ever tried to update php with the yum replace plugin by using a remi repo?
Nope o went for a fresh install when I upgraded
Imo more people from the no voters explained their reasoning on the list than the yes voters.
I think this is a step in a positive direction. Score another point for language improvement.
I've made this argument a few times, and I generally agree. The weak typing gives you proper type conversion and validation for free. Where I think the author misses the point is in thinking that the only solution is to cast. You can do your own proper type conversion and validation: This is his code: $status = $request-&gt;get('status'); // this is a string But more than likely strict-compatible frameworks would have something like this: // Raises an exception if status param isn't an integer $status = $request-&gt;getInteger('status'); // this is an int 
So turn on strict mode, which is also part of the RFC. Did you read it? Although even considering that, weak type casting is nothing new to PHP and you probably rely on it more than you realize. 
Your reply need more upvotes -- it's an actual solution to calling a function with a string-keyed array mapped to parameters by name. 
&gt; firewalld instead of iptables To make sure there is no confusion, firewalld is a tool to manage iptables. iptables is still there, you just shouldn't touch the rules directly if you're using firewalld to manage it.
I'm afraid in the wild that's not going to happen a lot when the user is not the same as the library writer. 
I'm really torn on this. I've wanted this sort of ability in PHP for years, but I'm absolutely flabbergasted that: - The RFC author would make what I can only surmise is a purposeful effort to design the WORST possible syntax for turning on strict mode. - The strict mode is enforced ONLY from the calling code. The second one is the biggest WTF for me. It's like they took the way Hacklang handles this and said "let's make it just worse enough that it no longer works consistently".
Yeah, my response would be something along the lines of "your DI container is more proof than the one page review site ever would be".
Yep, I use mpdf in my project, it works fine with images.
Oh I see! I thought it does not because it says "PHP class which generates PDF files from UTF-8 encoded HTML" thank you for your feedback!
Get that wrapper written! Like many projects, it was developed to meet a specific need, grew legs of its own, and is now kind of locked in to the interface it has due to being out in the wild. It's well structured though, so can easily be wrapped with an alternative interface if the desire is there. 
&gt; its obvious OOP is a way better and organized design paradigm than procedural programming. It isn't obvious to me. I'd take a well-designed C application over a C++ one any day. &gt; . For true programmers however, procedural programming offers absolutely no value at all, and it has no place in modern programming world. Well you keep saying that, I've really no idea why. I'm not sure you know what procedural programming is - it isnt linear, unencapsulated code of different kinds mixed together (this is sometimes called transactional). &gt; Take transaction script as an example, it may use database objects but the approach itself is procedural Again, you just arent using terms properly. If you orient your codes around objects, you have object oriented code. YOu just seem to be using the term 'procedural' to describe bad code. &gt; . When you write a program with design and architecture in mind, you are already thinking the OO way No you arent. When I think that way, I'm thinking functionally and then if I have to write OOP, I wince a little at how bad it is at expressing the standard abstractions of functional programs (eg. type variables). &gt; . If a programmer writes too much procedural code, they may develop bad programming practices that cannot go away easily. Again, I just dont think you know what procedural means, nor do I think you have any notion of what a good procedural design would be. You will be a *better* OOP programmer if you can program procedurally well, and in turn can program well in many paradigms. You improve as a programmer by knowing the design principles, abstracta and methodology of many paradigms. &gt; I know one such person myself I'm sure you know a person who isnt very good at programming. 
There is a lot wrong with that, but it's going to take you getting burnt by it a few times before you understand. "it's software" has never made anything a good idea.
can it convert icon / favicons to png ?
How would this be a permissions issue on my home machine running Windows 7 when the file isn't checked to read-only and I have admin rights for everything on the system? (Not saying you're wrong but just saying that if that's a permissions issue, I'd love to know how I could track it down to fix it.)
Right, so what happens when you want a whole project to be using strict typing? Added cruft in every single file.
Exactly, if the caller wants to get around strict mode they can always just manually cast to the correct type themselves.
You don't *have* to do anything. You could use a full blown shopping cart. You could also code a custom setup using APIs for PayPal, Amazon, Stripe, etc..
We manage a mix between CentOS 5, 6 and 7 servers right now. Getting adjusted to using systemd took a little while, but its pretty dandy once you're comfortable with it. Firewalld and the "ip" command took a little getting used to as well, but I'm starting to like it. I wish it shipped with a newer version of PHP than 5.4, but the Remi repos make up for it. I don't think I've run into any dependency issues like I had on CentOS 6.
About manual casting. It isn't about casting, it's about not to lost types of variables by some PHP WTF (like in case of array keys). Since weak mode used by default, i think that 95% of PHP community will use weak type hints and all be happy. But i wan't to use strict type hints in critical parts of my application. And option to decide without some pain from caller side as i think have most of benefits.
To be very precise, Redis actually is a caching solution, but not only. As they're introductory text says: &gt; Redis is an open source **advanced key-value cache and store**.
Why not build from source, I built pho 5.6.5/nginx1.6.2/mariadb5 all from src. But between remi/webtatic I would have to choose webtatic, as like you said it is very simple to work with, though I tried it only with centos6.5
Note: this solution requires the array to be in the right order. It's being used as a list but looks like a hashmap. Eg this won't work $data = array( 'title' =&gt; 'Some Awesome Thing', 'id' =&gt; 1234, 'firstName' =&gt; 'Joel' ); But this will: $data = array( 'title' =&gt; 1234, //not really title 'id' =&gt; 'Some Awesome Thing', 'foobar' =&gt; 'Joel' ); You have redundant code that looks like it's being used. It would be more maintainable to use comments, as then you know there is a chance they're wrong: $data = array( 1234, // id 'Some Awesome Thing', // title 'Joel' // first name ); 
This reminds me of [Glide](http://glide.thephpleague.com/) (a project of mine), but with WAY more options. Looks like a lot of work has gone into this project, nice job! Have you considered adding Composer support, and other more [modern PHP packaging](http://phppackagechecklist.com/) practices? You may find it gets a little more attention in the community if you did so.
Nice, I read about your project Glide a few weeks ago while studying stuff for CImage/img.php. And yes, moving on to a bit more proper code with composer, packagist, phpunit, travis, scrutinizer and phpdoc is the main issue for next milestone. Thats the way to go.
Weak types are still stricter than no types, too. If you mistakenly pass an object or an array, you'll get an error.
This is true: it would be nicer if we had safe casting functions. However, these casts are at least explicit and can be easily spotted for that reason. I'm pretty lazy though, a better developer might have used safer conversions of some form.
I don't think people should have to: people don't need to justify their position, and everyone repeating their reasons would be spammy. If it's a unique reason, it's probably come up on the mailing list.
Its important to note that in weak type mode, this RFC and patch isn't adding new behavior to PHP in terms of type juggling. In current PHP the following results in the integer 7 being put in $a $a = (int) "7 days until the new year"; This has been standard behavior for PHP since ... forever. Having two different methods of type coercion in one language would be insanity.
Well, for starters, don't get too hung up on 'best tools'. That's not really a thing. What tools you use is highly dependent on the parameters of a given project/application. There's no one definitive set of 'best tools' that you can throw at any given project that will achieve maximum results. Also, anyone telling you things like 'Nginx is better than Apache' without any context or concrete evidence is talking out of their ass. That being said, I would recommend bookmarking [highscalability.com](http://highscalability.com). It's a nice blog which often discusses infrastructures of popular web sites/apps and what they all deploy. You'll find that every single one varies greatly in how their systems are setup.
Is it redis similar to memcached?
Yes, but it's more capable.
For something like this, you'll want to ask #php on efnet.
The idea about custom headers based on whether the user is logged in or not and custom content for each user is correct. That's pretty much what you need to have it done. However your last bit about "php include portion" seems outdated. Most frameworks today don't work like that. The exact implementation will depend on the framework you choose (or your own architecture you implement yourself).
Somehow I see it terribly wrong when applied to a scalar typehint. When the casting is explicit, you know what to expect. When it's done automatically, we lose that security.
Which is rather strange. HTTP has no types, so everything by default is assumed to be a string, thus requiring "getInteger('user_id') : int" or a cast. A database query on the other hand has defined types by the database schema. If I request data using "fetchColumn('user_id') : mixed", I for sure expect an integer. Other languages always have those *AsInteger() because they do not have something like PHP's mixed type.
So, in a way, it is like a better version of PHP's stream wrappers?
&gt; languages such as Java and C# has an aweful lot of converting methods such as $connection-&gt;fetchColumnAsInteger(). I do This is something that will not be needed in PHP, since you still can cast it to whatever you want. The person who writes a method does not need to care about the format that the person who calles the code wants the data to be returned. He only needs to care about the type of data that he needs to return. For example: $request-&gt;getIdAsInteger() $request-&gt;getIdAsString() Doesn't make any since. At this moment the $request-&gt;getId() method probably will return an integer. Now consider the following code: $id = $request-&gt;getId(); What do we know about $id? If no return value is defined, we do not know anything. In the new situation we know for sure that $id is an integer. For the rest of the program this does not really matter. However, this makes it easier for the programmer to reason about the variable $id, because he knows that it is an integer. If he wants a string, he needs to convert it to a string. This is something that needs to be done in both cases, both with or without type conversion. The developer of the getId() method is the only one who is affected by defining the return type. He can decide to choose to not define a return type if he doesn't want to. So why would he define a return type? Well, mostly because if a string got returned instead of an integer, something didn't go as planned. Declaration of return types might automatically prevent this from happening in the first place. Bugs are thus detected earlier. Thus less bugs in your code. Everybody happy!
In some respects. I'm trusting my database to return valid values and I'm trusting my JS to input valid values. You probably shouldn't assume these things for some applications, but in my case it's not a problem.
The RFC is very permissive because it matches the permissive rules already in place for internal functions. I understand the desire to make it smarter but noboby can agree on how smart to make it. In my opinion it's pretty obvious what should and should not work but apparently I'm in the minority on that. 
You don't need type hinting at all if you can trust that every value is already valid! The entire point of type hinting is catch the places where the database returns the wrong type, JS produces invalid values, the user supplies the wrong value, or the code is incorrect. 
 declare(strict_types=0); $a = '7 years'; function foo(int $bar) { //do nothing at all } foo($a); My understanding is that that will throw notices. The function can't prevent it unless the hint is removed. I imagine some users will resort to `foo(@$a);`
I suppose the real problem is that I don't read the Internals mailing list... and the best way I've found to read it (other than subscribing) is to use MARC... which is, well... sadistic at best.
Agreed I just wanted to make clear it can do so much more then just caching. 
We write tests for controllers, but we write _integration tests_, not _unit tests_. We test all of our api endpoints and document what their response should be given specific inputs. We also test that the database is updated appropriately. In this way we test the whole application in concert as well as document exactly how the endpoints behave. This is considerably different from unit testing where the idea is to test code in complete isolation. From a TDD perspective, unit tests are a sensible place to start. Integration tests can be very nice to write first, as a way of specifying a feature, but you don't typically get the sort of incremental feedback loop you do in a unit testing scenario. In our shop, we emphasize integration tests over unit tests by a wide margin. Our policy dictates that every endpoint must have integration tests, but unit tests are left to the developer's discretion. Knowing that a particular method works as expected is very important, but knowing that all of our API endpoints are operating up to spec is, in our opinion, more important. I wrote an integration testing library that we use. It is available on github, but currently totally undocumented except for some example tests which can be seen here: https://github.com/whtevn/routest/blob/master/sample/tests/succeed/routest-test.js it's available on npm if you are interested. this is not intended to be a plug, just saying it exists and you can use it and its free. so that is kind of a plug, but whatever https://www.npmjs.com/package/routest
Itself really helpful to know I shouldn't be approaching php and JS the same wrt OOP. Thanks for the book recommendations also. 
Yes, this is my last class for college degree and while I personally would have used a framework or front controller approach there are 14 other developers that all need to be on the same page with the program patters and most only know how php includes works. 
[Imagick](http://php.net/manual/en/class.imagick.php) will work too.
&gt; Knowing that a particular method works as expected is very important, but knowing that all of our API endpoints are operating up to spec is, in our opinion, more important. oh yes thanks! I like this quote! I will try to write integration tests from now on! thank you very much!
Ic, can you elaborate what u mean by more capable than memcached?
I haven't used both, so it's better for you to just google it: https://www.google.com/search?q=redis+vs+memcached&amp;ie=utf-8&amp;oe=utf-8
My upgrade was a little bit brutal because we launched before the Components were split off, and the underlying data structures evolved quite a bit. We also have a lot of custom code that needed to be touched up, but overall it was a managable process. Having tests for your customizations helps figure out what's broken. Overall, the current version should put you in a much better spot.
&gt; I do not want to go down that road. I disagree personally I think that explicit is better than implicit. If we go down the optional type road it should be all or nothing. A half baked solution will piss off both sides. 
Very slick, but still loses the threading.
&gt; I want PHP to be like Java. The only reason most devs in this forum still use PHP is that PHP looks like Java.I mean Symfony or Doctrine exist because of the stricter features of PHP,not because it's weakly typed. PHP has always have been the poor's man Java. &gt; PHP tends to fall in the last category and boy do the theorist hate it for it. SF or Doctrine maintainers,these libs are far from a hack. The people that wrote them know their shit for sure. Wordpress is a mess because it wants to be backward compatible at all cost. Because wordpress targets cheap shared hosts.
It's interesting seeing [almost the same argument from Rasmus](http://marc.info/?l=php-internals&amp;m=142363667831311&amp;w=4), but coming to the opposite conclusion: &gt; But I still fear that people are going to want to be enable strictness everywhere and then they will quickly learn that they better cast stuff to be safe which makes the whole thing rather pointless. IMO, if you're voluntarily going to use strict typehints, and you *aren't* prepared to cast things when you don't *know* that they're the right type, you probably don't actually understand what you're asking for when you turn them on.
I went to a PHP meetup, a large one and they had three panels that were just trivia quiz's ... the experts would sign up to compete for prizes predicting what obscure results would be spit out of unusual situations PHP code can create. What shocked me is in a room of 80+ people, there was rarely consensus in the first couple minutes as the crowd tried to vote on who they thought was right (the experts would guess and crowd votes for whom is correct - then answer is shown). You would think a right answer would have a majority of the people or have people able to explain to the ones around them why before the answer is revealed? That alone tells me something about the code. Also, when you look at other people's code, how easy visually is it to read? I seen lamp/pearl/Ruby on Rails/.net/vba/foxpro/basic/cobal stuff used daily by medium sized companies and have to say Pearl or PHP is far and away the most cluttered code. Caveat, I've heard it all about the programmer, not the language makes the clutter - test people by seeing if they admit some languages require more symbols / keywords to get tasks done than others. Pearl and PHP are some of the most intense of these. 
If you've not got a good amount of experience with ecommerce sites, do not start off by rolling your own bespoke system or using some small framework plugin. You will end up with a mess. Pick something feature rich like Magento that you don't need to modify much and get well aquainted with how ecommerce works from a business and user perspective first. Once you've done a few of those, feel free to go bespoke if you really want to and the business requirements are complex enough. I know that doesn't really answer your question, but I feel way too many people fail to do this.
&gt; If a method "foo" makes use of the data returned by "fooProxy", when writing unit tests for "foo" I would stub "fooProxy" to return a wide variety of data which I then use to test "foo" (I believe). Yes, this is an example of when to use test mocks. Since, in your test, you are focusing on testing "foo", you can mock out what is returned by "fooProxy". You want to test for successes, failures, and any potential edge cases. &gt; So then the question is, when do I test fooProxy? You don't test fooProxy. It doesn't matter what kind of data is returned from it, not from a unit test perspective, and there is absolutely no logic directly in that method. Let me put it to you this way: what would you test in "fooProxy"? If anything, you'd pretty much duplicate the tests written for "$this-&gt;getDatabase()-&gt;query()". If you do that, not only are you raising the complexity of your test cases, but you are violating the DRY (don't repeat yourself) principle. And on top of that, you get zero benefit from the added test(s). --- As an aside, in my experience I've heard people exclaim that you must test all the things! That includes getters, setters, pass-throughs, etc. If you wanted to go that route, that's your perogative. However, keep this in mind when you're architecting your test framework: your tests should be real-world examples of how your application will work. When someone else looks at your tests, they should strongly correlate to how to use your code in the application. This is why everybody claims that tests are documentation. It's okay to create contrived tests using any number of dummy data. But, do it in a relevant way to how it should work within your application. When you cross over into testing unnecessary things, then your documentation becomes muddled and confusing. Not only that, but it helps you to remember how to use your own code. Thought exercise: raise your hand if you can dig up a 6-month old project and jump right back into coding it, without first having to re-read your code. Anyone? Anyone? Bueller? This cannot be stressed enough: Keep It Simple, Stupid. For the people you work with, the clients who employ you, and even for yourself. 
I agree. The language shouldn't protect a developer from themselves. If you try to use a feature, you should know how to use it prior to attempting to implement it.
What's your take on Symfony2 versus Laravel?
All these projects that rasmus mention wouldn't even want to enable strict types, and regarding Drupal String class, that's as simple as search &amp; replace
How would you live off $40k with a four year education loan?
Would you still advocate testing $this-&gt;getDatabase()-&gt;query() even if the query method (or hell, even the getDatabase object) is not part of your implementation (say...getDatabase is an instance of PDO)?
Or at least wouldn't enable them in such generic usage functions (there may be some core operations they want to type more significantly)
&gt; I guess he is just going to skim over the fact that thousands upon thousands of websites are running PHP right now. WordPress? PHP. Facebook? PHP. Wikipedia? You guessed it. &gt; You knock PHP, but suggest pearl is probably better? So wrong...I do both and they are horrible for syntex/symbols. I upvoted because you linked to neutral other reddits. EDIT: Found another with WAY more people 80,000 compared to 1,000 subscribers ... "/r/webdev" http://www.reddit.com/r/webdev/search?q=programming&amp;sort=relevance&amp;restrict_sr=on&amp;t=all
Also, as I brought up, the String class breakage only affects Drupal users migrating to PHP 7. Thanks to `class_alias`, it wouldn't affect existing PHP 5 users.
I personally would not write tests for features that are not under my control. This goes for both native PHP features, and userland features from other people (i.e., composer, github, etc). For, hopefully, most things, they should already be tested - native PHP has a feces-ton of tests already. If there is a userland library that doesn't have tests, I would argue not to use such a library. One could argue that business requirements might dictate using said library, and that's fine. When you write code, even for tests, you have to maintain said code - you are maintaining your code, right? That said, if I had to write tests for code that wasn't mine, that means that: 1. I would have to have a deep understanding of the code being tested 2. If that code were to change, even in a small fashion, more than likely my tests would be broken 3. Unless I'm a developer for said library, why should I spend my valuable time doing work that somebody else should have done? 3a. If it's an open source project, and you have to write those tests, consider contributing those tests to the project. I digress, as that's not the main point being made here; just a kindly suggestion. :) So, back to the original question, if query() is some other library that you didn't write, then no don't write tests for it yourself. This should already have been done. If there are no tests for that library, than strongly reconsider using said library, since it is untested, you have no reasonable source of confidence that it will work the way that you expect it to work. 
Ah then we agree.
&gt;If this vote passes, I plan on building a native compiler as a PECL extension to compile fully-strict-and-typed functions down to native code. **Not as a JIT** (doing it when the function's called), but at compile time when opcodes are generated. This has the potential to be *huge*, I'm really looking forward to what comes out of it.
This times 1,000! I work on a PHP Web App project that also make use of Domain Driven Design at its base, and over the years have learned that while unit tests are important and have their place, integration tests of the entire system (at API or HTTP response level) are essential!
&gt; As a developer I would expect that declaring strict typing at the top of my file would turn on strict typing for everything calling methods in that file. But that is exactly what happens: each line inside that file which calls a method uses strict typing for the parameters of that calls. You may mean "calling methods from that file", but that does not matter to your methods (in that file), they always get the right type.
~~I really wish there was a php.ini setting to enable it for everything, instead of a per-file `declare()` statement.~~ Edit: I take it back, it's clearly a terrible idea after listening to the opposition. 
Then you run into a situation where you write your code with hints but without strict mode, but haven't vetted it for correctness in strict mode, when someone goes and turns on strict mode PHP-wide. Then your code breaks and the user gets angry. Doing a per-file / per-block declare is a bit counter-intuitive, but probably the least offensive solution. Personally I'd have preferred different syntax for loose checks vs strict checks when declaring functions, but I'm apparently in the minority...
Absolutely! And a bunch of other minutia, but having the two just made sense.
It sounds like Flysystem isn't for you, and that's ok. The goals of the project misalign with what you want from software, so go ahead and don't use it. For people that DO want to interact with files anywhere on the internet in an identical fashion, they know where to come. :)
"no one uses an API that treats OneDrive, SBM, SSHFS, and so on exactly the same." and that's exactly what it does. 
I'm not familiar with the CURLINFO_HEADER_OUT option but it was blocking any output. I also noticed you called curl_exec multiple times by accident. I made some tweaks to the code to test it. I don't know what the expectations are for results because I don't have an account to test it. So I don't know if it works or not. It does connect, save/update cookies and repost the data/cookies as per your desire. However there can still be some javascript modifying the fields. I didn't investigate it. $url = 'https://valpo.qualtrics.com/ControlPanel/'; $t = '';//Hidden form element. $username = 'api_username'; $password = 'api_password'; $ua = 'test'; $cookie = realpath('cookie.txt'); $postdata = array( 'T' =&gt; '', 'Language' =&gt; 'EN', 'ThreeSixtyID' =&gt; '', 'RequiresCaptcha' =&gt; 'false', 'recaptcha_challenge_field' =&gt; '', 'recaptcha_response_field' =&gt; '', 'UserName' =&gt; $username, 'UserPassword' =&gt; $password.'' ); //REQUEST 1: Get the page... $dbg = fopen("debug.txt", "w"); $ch = curl_init(); //curl_setopt($ch, CURLINFO_HEADER_OUT, true); curl_setopt($ch, CURLOPT_COOKIESESSION, true ); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_VERBOSE, true); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_USERAGENT, $ua); curl_setopt($ch, CURLOPT_STDERR, $dbg); $output = curl_exec($ch); //following line runs curl again //if(!curl_exec($ch)){ // die('Error: "' . curl_error($ch) . '" - Code: ' . curl_errno($ch)); //}else{ // print curl_getinfo($ch, CURLINFO_HEADER_OUT); //} //Grab the hidden element value (this gets sent in the POST body below in our next CURL request)... $doc = new DOMDocument(); @$doc-&gt;loadHTML($output); foreach($doc-&gt;getElementsByTagName('input') as $input){ if($input-&gt;getAttribute('name') === 'T') $postdata['T'] = $input-&gt;getAttribute('value'); } $query = http_build_query($postdata);//Build the query string... //REQUEST 2: Log into the site... // keep connection alive //$ch = curl_init(); curl_setopt($ch, CURLOPT_COOKIESESSION, true ); curl_setopt($ch, CURLOPT_COOKIEFILE, $cookie); curl_setopt($ch, CURLOPT_COOKIEJAR, $cookie); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true); //curl_setopt($ch, CURLOPT_HEADER, true); //curl_setopt($ch, CURLINFO_HEADER_OUT, true); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $query); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_REFERER, $url); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_VERBOSE, true); curl_setopt($ch, CURLOPT_STDERR, $dbg); curl_setopt($ch, CURLOPT_URL, $url); $output = curl_exec($ch); //this runs curl again... //if(!curl_exec($ch)){ // die('Error: "' . curl_error($ch) . '" - Code: ' . curl_errno($ch)); //}else{ // print curl_getinfo($ch, CURLINFO_HEADER_OUT);/ //} print '&lt;pre style="border:1px solid red;padding:.5em"&gt;'; var_dump($output); print '&lt;/pre&gt;'; fclose($dbg); debug.txt looks like this with fopen option of "a" instead of "w" to catch both curl sessions (your GET and POST headers). You could also flush the file write buffer after each curl_exec() instead. For some reason calling curl_exec overwrites the stderr buffer each time. * About to connect() to valpo.qualtrics.com port 443 (#0) * Trying 23.221.46.246... * connected * successfully set certificate verify locations: * CAfile: none CApath: /etc/ssl/certs * SSL connection using AES256-SHA * Server certificate: * subject: C=US; ST=UT; L=Orem; O=QUALTRICS LABS INC; OU=Engineering; CN=*.qualtrics.com * start date: 2014-11-11 00:48:58 GMT * expire date: 2015-11-11 00:48:56 GMT * issuer: C=NL; L=Amsterdam; O=Verizon Enterprise Solutions; OU=Cybertrust; CN=Verizon Akamai SureServer CA G14-SHA1 * SSL certificate verify ok. &gt; GET /ControlPanel/ HTTP/1.1 User-Agent: test Host: valpo.qualtrics.com Accept: */* &lt; HTTP/1.1 200 OK &lt; Server: Apache &lt; Expires: Thu, 19 Nov 1981 08:52:00 GMT &lt; Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 &lt; Pragma: no-cache &lt; P3P: CP="CAO DSP COR CURa ADMa DEVa OUR IND PHY ONL UNI COM NAV INT DEM PRE" &lt; ServerShortName: wcp973 &lt; Content-Type: text/html; charset=UTF-8 &lt; X-EdgeConnect-MidMile-RTT: 19 &lt; X-EdgeConnect-Origin-MEX-Latency: 369 &lt; Date: Wed, 11 Feb 2015 20:07:38 GMT &lt; Content-Length: 8204 &lt; Connection: keep-alive &lt; Set-Cookie: CPSessID=s7h2qh4oa6rhsj57og6a68ovo6; path=/; secure; HttpOnly &lt; * Connection #0 to host valpo.qualtrics.com left intact * Re-using existing connection! (#0) with host valpo.qualtrics.com * Connected to valpo.qualtrics.com (23.221.46.246) port 443 (#0) &gt; POST /ControlPanel/ HTTP/1.1 User-Agent: test Host: valpo.qualtrics.com Accept: */* Referer: https://valpo.qualtrics.com/ControlPanel/ Content-Length: 173 Content-Type: application/x-www-form-urlencoded * upload completely sent off: 173out of 173 bytes &lt; HTTP/1.1 200 OK &lt; Server: Apache &lt; Expires: Thu, 19 Nov 1981 08:52:00 GMT &lt; Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 &lt; Pragma: no-cache &lt; P3P: CP="CAO DSP COR CURa ADMa DEVa OUR IND PHY ONL UNI COM NAV INT DEM PRE" &lt; ServerShortName: wcp980 &lt; Content-Type: text/html; charset=UTF-8 &lt; X-EdgeConnect-MidMile-RTT: 19 &lt; X-EdgeConnect-Origin-MEX-Latency: 465 &lt; Date: Wed, 11 Feb 2015 20:07:39 GMT &lt; Content-Length: 8246 &lt; Connection: keep-alive * Added cookie CPSessID="qufoelts9keg1fsalu36bgtqm1" for domain valpo.qualtrics.com, path /, expire 0 &lt; Set-Cookie: CPSessID=qufoelts9keg1fsalu36bgtqm1; path=/; secure; HttpOnly &lt; * Connection #0 to host valpo.qualtrics.com left intact As you can see this lets you look at I/O, cookies, post data separate from the HTML/etc. Good luck!
It's an adapter based filesystem abstraction which supplies broad support for filesystems allowing consuming code to be unaware of the implementation details surrounding it. ;)
So, in a way, it is like a better version of PHP's stream wrappers? ;)
The vendor lock-in happens when a large part of your application is aware of which filesystem it uses. Changing filesystems later on in a project can get difficult and expensive (hours spent on rewriting stuff).
Hi all, I'm Frank de Jonge, the guy behind this project. If you have any questions. Reply to this message and I'll do my best to address them as best as I can.
Hehe, my hate towards using stream wrappers for for these kind of things extends so far... I wouldn't even compare the two. Context: using stream wrappers for S3 access IMO only creates a (hidden) global scope and doesn't aid portability one bit. Testing solutions like VSF require you to always specify the whole path including root, which in turn also limits portability. ... tl;dr: I think so, yes.
Only if I have nothing else to do... and I always have something else to do. I unit test libraries, models, etc, and integration test the rest. Unit testing controllers isn't a bad thing to do, but it's not the first thing you need to worry about.
&gt; Context: using stream wrappers for S3 access IMO only creates a (hidden) global scope and doesn't aid portability one bit. Scope need not be hidden, we have stream contexts for that. &gt; Testing solutions like VSF require you to always specify the whole path including root, which in turn also limits portability. Fair point.
Any suggestions about hidden value elements that need to be submitted with the login data (i.e. - tokens)? Their form has a hidden token that I need to send with the login information, but to do that, I need to first scrape it from the page and then submit everything "in the same session." Unless I can do all that in one go, each request to their site will regenerate the token value (which is why I had the multiple curl_exec() functions... I mistakenly assumed that multiple curl_exec calls (like those I had) would equate to a single session of multiple requests, aka, grab the token first, then submit everything for login; but I see from what you wrote up how it works now and it makes much more sense to me). All that aside, thanks for your help on this. I wasn't expecting you to write all that up. You've been a major help and great teacher! :)
V3 of the AWS SDK is not yet released, some stuff is still missing even. People who integrate with the SDK directly are more likely to use V2. Because it's the same package, you're limited to use either V2 or V3. So only supplying V3 will basically disallow anybody who uses the current version of the sdk to use flysystem.
No idea, but people do it.
I am using the REST module to do it as a Web Service, and I've already set the memory option. Limiting it to below what ends up being the required amount will cause a large column of "Error" with a red background then a stack trace for each error. Not really pretty, but I know that's not Codeception's fault. It's my fault for writing tests in a way that requires nearly 2Gb of memory.
Hi, author of Codeception here. Similar issues happened to me when I was developing early functional tests with Doctrine1 and symfony1. It looks like your applications store data for each request and does not clean it after it ends. I can't propose you a better way than debug each memory consuming request and guess what data may persist between requests. The easy way is to switch from Laravel4 module to PhpBrowser. It is universal module and uses web server, so clean up will be done automatically. Btw, Laravel4 module does not require Db module. It can handle db connections using app['db']
good but i still waiting for array scalar type like in hhvm, ex: array&lt;int, string&gt; or string[int] 
Very much yes. Was actually thinking about this the other day.
Damn
Type safety is achieved, but for content safety some people may attempt stuff like: // Public function totallyNotHinted($value) { if (!is_numeric($value)) { sendSMSToSysadminAt3am(gettype($value)); burnCallersHouse(); ... } else { hinted($value); } } // Private function hinted(int $value) { ... } // User totallyNotHinted($value); Just to keep control of the casting.
Are you saying you want the value passed in to be an integer value, or you want an integer object (which would be passed by reference) to your function? I can't tell, and haven't followed the type debate enough to know which arguments people are making on this one.
 declare(strict_types=1); would be an incredible mistake for PHP.Pragmas are the root of all evil. The language behavior shouldn't change based on pragmas. It's not javascript in the browser where backward compatibility is mandatory. If i try to use a PHP 5.4 feature in PHP 5.1 it will result in an error. So no half backed solutions. Either PHP supports scalar types or it doesn't. 
This RFC really makes me wish the `::` symbol was the namespace resolver so that the group use could be something like `use My::namespace::{one, two, three}` but that's just my two cents. Regardless of the namespace syntax, I like it and it'll be a really nice addition.
I'd like to see a response to Rasmus's comment. It seems like a really important point.
You could ask the same question of php.net, nginx.org, etc.. I vaguely remember php.net being hacked a few years ago. I personally trust debian repositories more than building from source, because more eyes are looking at the former for production use. A quick apt-get upgrade to patch a recent security issue is much easier than rebuilding from source all over again. That's just my humble opinion though, there is no right answer.
If you have so many use statements that it's hard to manage then your class is probably doing too much! This RFC is almost the same as buying a bigger monitor so you can manage classes with thousands of lines :-) Ideally: * objects should mostly talk to other objects in the same namespace (this is "cohesion" at the class level, rather than at the more common method level) * objects shouldn't talk to too many other objects You can do things like this to help: * eliminate dependencies: pass in objects you need, rather than the tools to create them. * follow the Single Responsibility Principle and the Interface Segregation Principle to reduce the amount of similar work your object does. * use Event Dispatchers and Command Buses to send messages between objects so they're not coupled to each other.
Integers are scalars and scalars are not objects in PHP. Thus `$bla`s value is the value of the argument, after type juggling to integer, with type integer, not a reference to the original argument. (Maybe this is technically not perfectly right thanks to copy-on-write and internal data structures but I think it will explain the matter.)
then it will never happen.
Not a syntax I'm particularly interested in, but, as with all sugar, it's optional, so if people want this, I see no major reasons to not toss it in.
yesterday : thousands lines of 'require' and 'include' today : thousands lines of 'use' tomorrow : few lines of 'use', I hope :)
...then how would you concatenate values?
While I don't necessarily love the RFC, your point is like saying "no we shouldn't introduce functions or static methods because the proper way is …". Having many `use` statements happen, for many different reason, absolute rules don't make sense. Just one example: using an expression builder might make you import/use many classes, but that doesn't mean you code is wrong.
there are `seeRecord` `dontSeeRecord` from Laravel4 which works through the Eloquent. If you use it as ORM this may be enough for you )
I hate the trailing backslash, it doesn't look right. Removing the trailing backspace makes it look even more wrong. The backslash functionally works, but it's not as elegant of a syntax as it could be. From my dealings with C++ and Rust, I find the `::` syntax the most elegant.
+1 being forced to check outside the code to understand how the code will run is NOT a good strategy ... php.ini is just another global input to your program. If you're fine with `global` inside your functions and classes then php.ini is fine. Problem is, .ini is *even worse* because it's not actually in your program! It's some magical external thing that has no business making your calls blow up with errors. .ini = good for shared hosting services, but *terrible* for programmers. This is a major difference from stating *inside your code* that you want strict.
ImageMagick does installation right? We discourage such because it might be a hassle when our system is used on other operating systems. Tried FPDF but still fixing some issues.
Ungreppable.
Thats the beauty if the proposal, though. It supports scalar types no matter what. Self-documenting code and guaranteed input/output types happen regardless. We can *finally* end the docblock plague! But you get to choose without breaking any existing code (this is critical) if PHP warns you that you're doing something silly. It's the most PHP solution imaginable lol. The language will still allow you to shoot yourself in the foot if you want to, but at least now it would give you the ability to wear steel-toed boots ;)
&gt; Would it allow nesting? From the changelog and the revision history, it looks like it was considered and [removed](https://wiki.php.net/rfc/group_use_declarations?do=diff&amp;rev2%5B0%5D=1422797717&amp;rev2%5B1%5D=1423280389&amp;difftype=sidebyside): &gt; 0.4 - RFC was simplified: “nesting” voting option was removed
&gt; use Sia::Chandellier::{one, two, three, one, two, three, drink} Sorry couldn't resist 
Neither are aliases, though, and they're still useful.
7/4 Seriously? This guys are voting out anything good.
That would make some code flat-out not run on one machine that works fine on another, based on ini settings. It sounds good when you first think of it, but it's really quite terrible.
A security flaw in Wordpress? I find that very difficult to believe. 
Yep use Custom\Form\Elements {Text, Select, Password};
Which point specifically are you referring to?
Sorry, specifically the point he brings up about how enabling strict types would negatively affect native PHP function calls.
5.3 and 5.4 were fresh and exciting, very good advances of the ancient structure. 5.5 and 5.6 were meh, nothing memorable. if this continues php 7 will be bland and boring
I'm currently catchin flak from the people in the WP team I communicated with because I should/could "have handled it more professionally". EDIT: https://twitter.com/nacin/status/565708839916695555 Perhaps. But I have never claimed to be an infosec professional. I'm an infosec hobbyist. And I think the anger is warranted here. They need to get better, being nice isn't going to motivate change.
I must admit, as much as people love to hate on WordPress, the core didn't have any trivial remotely exploitable flaws that I could find. That isn't to say that I wouldn't find more if I dug deeper (e.g. misbehaved APIs that, in most plugins, would result in SQLi/XSS/RFI/RCE). I think the biggest problem they have is supporting older PHP right now. They're long overdue for a fork or refactor. Beyond that, they have enough market share for serious infosec people to hammer it regularly.
Tried That.. No response so far
&gt; to be an infosec professional I never cease to be surprise with how strongly people still feel an "InfoSec professional" who has sat on a vulnerability for eight months is still expected to just sit on it for more months in order to be "professional". 
Well scalar objects will be useful, one major problem I have with PHP is that not everything is an object, string and array for instance. With scalar object, you can write cleaner code as $str-&gt;length, $array-&gt;sort() as compared to using PHP's string and array functions, which are not even consistent when it comes to naming conventions. If Scalar objects can be further improved so that you can write "My string"-&gt;length and [2, 5, 4, 6]-&gt;sort() without declaring them in variables, its even nicer. 
And at the same time they are keeping mcrypt for php 7. Seriously, I hope we could organize and make another php flavor with all the cool things this guys are wasting
They are not mutually exclusive. A smart enough parser would be context aware and would know the difference between `"use foo.bar"` and `"$x = "foo"."bar"`.
Speculation: Easy to pick up and make a website for weak devs/prototypes (easy to abuse). Much of the hate for PHP is because this abuse is possible and exploited often.
Thank you. I also realized this just moments ago. I tried: 'value' =&gt; function($data){ $basepath = str_replace('\\', '/', Yii::$app-&gt;basePath).'/web/'; $path = str_replace($basepath, '', $data-&gt;file); return Html::a($data-&gt;file, $path, array('target'=&gt;'_blank')); } Now it works fine.
Thats actually a very interesting idea. When PHP 7 is released, I plan to experiment on implementing several missing features in PHP by adding them from PECL and GitHub. These are what I have in mind: 1. Scalar Objects(assuming its not going to RFC) - from GitHub 2. C# Property Accessors - from Github(rejected PHP RFC) 3. Anonymous and Nested Class - from Github(rejected PHP RFC) 4. HTTP 2(assuming it gets rejected by Internals) - from PECL/PHP RFC 5. Class casting to scalar - from Github(inactive PHP RFC) 6. Enum Language Structure - from Github(inactive PHP RFC) 7. Extended Keyword Support - from Github(rejected PHP RFC) 8. Operator Overloading - from PECL 9. Meta-programming(runkit) - from PECL 10. Multi-threading(pthread) - from PECL 11. Event - from PECL 12. Imagick - from PECL 13. Fully strict type native compiler(assuming anthony ferrara makes it) - from PECL Of course, this list is subject to change and not all of them can be implemented due to technical reasons. But anyway, if it actually works, I will see a way to maintain and distribute this build of PHP, maybe giving it a special version name. Once I get comfortable coding in C, I may be writing my own extensions, until then I will use what's already written. 
&gt; Fully strict type native compiler(assuming anthony ferrara makes it) - from PECL Good luck for you but that sounds like a nightmare, specially since almost everything on http request and the database responses are strings. Everyhing else sounds cool and i truly hope http2 doesn't get rejected too
Thanks, I will see how this goes. I think the major challenge is how to maintain and upgrade this custom build of PHP, but I guess I can just keep track with PHP RFC, and to add whatever is implemented from PHP internals if it's a useful feature(and it should, unless something like goto happens). For HTTP2, I am afraid its fate is doomed. In fact, if you have paid attention, it used to go to voting phase but was getting all kinds of negative feedback. Then the RFC author took it down and attempted to revise it, but I am still very pessimistic at it ever passing the voting stage. *sigh* 
I think this is very interesting. I am also interested in how this will affect performance. Will it make PHP a lot faster as type hinting is done at compile time? 
It's a lame excuse lazy developers give. Andrew Nacin is a prime example of a developer who is happy to blame someone else when he fucks up. Calling the reporter unprofessional for simply making an unresolved issue known about is pathetic. IMO more people need to be releasing zero-days. It forces them to update instead of constantly brushing issues under the rug.
http://markmail.org/message/67nff7mn4kqdbtfm#query:+page:1+mid:ilyl2xqylhae4qqf+state:results 
This vulnerability is also present in many PHP software products, such as Drupal and even for profit web control panels. It's not an uncommon issue. 
Yes, nearly impossible! /s I think part of this stems from people in the WP community still taking security not very seriously. This ranges from Nacin [downplaying it on Twitter](https://twitter.com/nacin/status/565708839916695555) to the people over in /r/wordpress, where they probably don't even know about this. 
Well said, and a good perspective, but doesn't really discuss the question itself (which is about what is percieved to be currently the nature of contemporary PHP).
Why not write directly in something like c#. I don't get all the "change the language to something else" hypes.... Especially since c# is now basically open source! 
IMHO, waiting 8 months before going public is completely unprofessional. Something like 2-4 weeks would have been way more appropriate.
Eh, the biggest problem I see with WP at this moment is that it is not "obviously secure", i.e., even extensive source code auditing doesn't produce a lot of confidence, because the codebase is too complicated and difficult to reason about. But then again, the same goes for most other popular PHP software.
&gt; PHP will die, but very slowly. If you are a programmer, you don't want PHP to be the only language you know when that happens. Or maybe you do, because there will be a lot of companies out there using PHP still. You'd be in a prime position. But to be honest, I don't see that PHP dying at the moment.
Its a bit strange but I quite like seeing a list of all the objects outside the current namespace that my class knows about.
Yep. I maintain a couple of plugins, and if I ever let a PHP 5.3 feature creep in, I get no end of tickets about it no longer working. I dream of creating a WP plugin with its list of composer dependencies (which would include other plugins). One day...but I suspect only after a fork. 
It'll likely never get refactored. The technical debt is too high, and even if they wanted to refactor, it would likely break plugins left and right. I'm still looking for a reliable replacement. Maybe there never will be one.
Think I'll take you up on that! PM coming your way! :)
The reality is that for every client who wants (and actually needs) a $60.000 webpage with complex business rules there are 30 clients that only want (AND NEED) a simple "Hey, our company exists, have a look at our products and call us!" $3000 webpage.
I see PHP as a powerful &amp; productive programming language for lean web app developement. You **can build robust apps with clean code**, thanks to all the great progress that has happened in the ecosystem over the past years. But when you need it, **you can also take shortcuts** ; one might see that as "bad code", "code smells", or "lol php is for noobs", I see it as a particularly productive feature when working in a professional environment. Because of its flexibility, you can also use PHP for all sorts of things related to web app dev. For instance I write all my CLI scripts in PHP, just because it's so convenient (hello Symfony\Console :) ). You can also write long lived deamons in you know what you're doing. And so on. Haters gonna hate obviously, this is the internets. But PHP rules when you know what you're doing.
&gt; supporting older PHP right now. I note in the ticket you added a patch a few months later that supported much more ancient versions of PHP - did you have any communication from them around this being necessary? 
In what format or field type is the "geburtsdatum" saved in the database?
Date type!
DATEDIFF( CURDATE( ) , b.geburtsdatum ) Thats what I tried, it gives me the days! Now I only need the birthday....
Definitely, just browse this reddit. And twitter is a good source too but it takes more time.
Yeah, I was told the original patch was no good because they needed to support 5.2 users on windows without mcrypt
That's what I do. But I'm not completely satisfied... :) 
I think there's a responsibility/common decency, aside from just being responsible about security updates - if you're managing OSS and you're going to tell someone "thanks for the patch but you'll need to do a lot more work to conform to xyz", there's an obligation to at least review that person's work once they do it. 
Disclosing an issue after 8 months is not unprofessional. It's overly generous to a fault. Actual real-life professionals are disclosing security vulnerabilities after 30 days. I'm actually quite impressed with your patience. Anyone sending "flak" your way is a disgrace. They should be sending "flak" towards whoever lacked the basic skillset to fix a critical vulnerability within 8 months for which there are already excellent open source solutions to (e.g. Anthony's RandomLib) that take all of a couple of minutes to include. Do let me know if there are any particularly public flakking and I will flak them for free in a blog post until they flakking cry. Flakking flakkers. 
* [Planet PHP](http://www.planet-php.net) (blog aggregator) * [Pascal Martin](http://blog.pascal-martin.fr/tag/english/) (summary's of PHP internals) * [nikic](http://nikic.github.io/) (internals developer) * [paidraic](http://blog.astrumfutura.com/) * [League of Extraordinary Packages members](https://philsturgeon.uk/api/2015/02/11/meet-the-league/) - a list of people to follow, essentially Podcasts: * [PHP Town Hall](http://phptownhall.com/) * Youtube: [Nomad PHP](https://www.youtube.com/channel/UCYHDBrzJ5o5d97KlCAUhICA) (web-based non-location-specific user group thingy) * Youtube: [PHP Rountable](https://www.youtube.com/channel/UCGypYIGHl6r3m3duW_5lO_g) * Youtube: [Kayla Daniels / #NoCapes](https://www.youtube.com/channel/UC1KGi4QcodA572IERfO3sUg) Youtube Conference Channels: * [PHP NW](https://www.youtube.com/channel/UCbnp95lhvGK1H7hs2TYQwFQ) * [Amsterdam PHP](https://www.youtube.com/channel/UCAzioonGTZRKIP7qB_-P15w) * [Dutch PHP Conference](https://www.youtube.com/channel/UCodMlAYBogpj5VxGVOrQ_7g) * [PHP Craft South Africa](https://www.youtube.com/channel/UCa9yGk-SwfQ89V2hrT-rMdg) * [PHP UK](https://www.youtube.com/channel/UCX06sx2WWYGny7b3XDUyFCQ) * [Sunshine PHP](https://www.youtube.com/channel/UC_LnivLeslUifdsAnCXgA_A) * [PHP Benelux](https://www.youtube.com/channel/UCt52674wehPyCk-MIxe1sZw) * [International PHP Conference](https://www.youtube.com/channel/UCfkn0LIp-bZwDsCSWJ_WBxg) Related post: [r/webdev: Other great webdev resources](http://www.reddit.com/r/webdev/comments/2mmyx2/other_great_web_dev_resources/) From the /r/php Wiki: [r/php: I want to be a better programmer](http://www.reddit.com/r/PHP/comments/a2l4o/i_want_to_be_a_better_programmer_what_are_your/)
I know, I already asked there, but there are no people ... I use this for my PHP Script..
&gt; Who the heck will need anything like 'goto' in modern programming era? It has its uses when done right. The Linux kernel uses them a lot, and that has to qualify as modern programming. goto is good for avoiding excessive indentation in error handling.
&gt; Remember that most of the people using PHP does not know any other general purpose language and had no apparent incentive to learn them. So these guys started looked at other general purpose languages and demanded features found in them with out or a very shallow understanding those features. This resulted in a kind of bastardization of the language, I think this started with the addition of classes to the language. This has been going on since then and has resulted in the Frankenstein of a language that PHP has become now. I don't see how PHP's classes are terribly out-of-place.
"replacement" that's 100% compatible with all existing plugins/themes? Not going to happen. But... there are dozens of decent blog/cms alternatives. The only real 'problem' is none of them have WP marketshare, and very likely nothing else every will. There may come a day when WP is the largest minority of installs in the CMS space, vs being the majority of installs, but I think that's a long way off.
if you want to limit the queries to females under 30 then obiously both conditions need to be part of your WHERE 
&gt; As a developer I would expect that declaring strict typing at the top of my file would turn on strict typing for everything calling methods in that file. That seems annoying and not necessarily intuitive. What if your object has one public method that needs to be weakly typed to deal with existing outside code, and everything else can be strict? You have to split it into two files?
I went ahead and jumped in. Should be interesting. As far as my thought process goes the only other complaint they can make is about quality of communication. If they're making a complaint about that to someones who's adamant to try to improve the platform with a valid point we might have bigger things to worry about that this issue.
[**@MattDunbar**](https://twitter.com/MattDunbar/) &gt; [2015-02-12 13:07:48 UTC](https://twitter.com/MattDunbar/status/565859816485027840) &gt; @nacin @voodooKobra @adamcaudill This goes beyond responsible disclosure and into the reporter trying to push a patch. Seems professional. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt; "that's not professional" That phrase sucks. Whenever I hear it, I always interpret it as "Someone did something I didn't agree with, but I can't actually express a legitimate reason why they shouldn't do that." e.g. Programmer who never has any customer contact doesn't wear a suit to work - oh how unprofessional. Someone has their job outsourced, can't be arsed to fly out to Bumfuck Nowhere to train the new people how to do his job - oh how unprofessional. Someone has announced a security hole in a software product 8 months after alerting the team and repeatedly trying to get them to fix it - oh how unprofessional. If you have a legitimate reason to disapprove of someones actions you should be able to express it a lot more clearly than just calling them 'unprofessional'.
I also have a few premium plugins, and one of my goals is to offer Composer support + repository access, if you are using Bedrock for example. Wonder how many customers will actually use it. :)
&gt; I was asking what is PHP's nature, and moreover, what features inherently fit in PHP's so-called nature and what do not. I answered about the nature of PHP, which is half of the question. Maybe my answer was not clear enough, but I implied that the feature choices come from that very nature. For instance "goto" is a pretty weird feature from a "clean code" point of view, but it is a shortcut feature (for the record I don't advocate or use goto, but I think it can explain why it was introduced). I think it also come from other factors. The nature of PHP might give the broad direction of the project, but it comes down to organization, people, etc. Looking at the discussions on internals (the good parts and the bad parts) might give an insight on that. Pascal Martin is publishing a montly "PHP internals wrap up" on its blog and IMHO it really helps understanding the project direction as well as the (understandable) obstacles a community-driven open source project might face: http://blog.pascal-martin.fr/ 
&gt; PHP will die, but very slowly. I LoL'd here ... we all are dying, slowly. Winter is coming. Yada yada. I just saw some IBM AS units front ending for a company that is using winNT. They were amazingly happy my copy of 1994 windows scripting tools from half priced books allowed me to barely cobble together a time syncing tool that would also move a text file to a directory to be picked up by their back end. It was all trash, but the cheapo who had me help with that weekend gig just bought a second jet, as the first was such a great financial investment ... he bragged about all the money he saved by bringing in a contractor twice a year for small changes rather than running the upgrade wars or keeping staff etc. More likely, what will happen is that PHP will develope higher end frameworks based on current ones (Laravel, CakePHP, Symfony2, etc), as there are already a crap ton of frameworks [Link](http://en.wikipedia.org/wiki/Comparison_of_web_application_frameworks). Some of these frameworks will be pretty wrappers that trick people who want "wysiwyg web coding" or the Purist ruby on rails crews in to thinking it's not PHP. ...but the joke will be on them &amp; they will have given in to the eventual world domination of PHP!!
I'm not sure he's looking for a defense of PHP...
Well yeah I know what you mean. But if PHP's nature is that it favors shortcut feature, then why does 'goto' fit in this category but 'group use declaration' does not(its RFC is failing so far)? Is there a standard? To me both offer shortcut approach to write less code, I just dont think there's even a consistency here. 
`&lt;selfpromotion shame="none"&gt;` https://resonantcore.net/blog - We intend to post (at least once a week, for the foreseeable future) an article about secure software development with an emphasis on PHP. `&lt;/selfpromotion&gt;`
For ease of use, I like the php form makers ... there's a paid one a company had last year that essentially would remember and template based on your previous ones - but would generate visual previews and display &amp; would apply css files to them in the preview so you could just show the end user.
yeah, of course goto is evil, most of the time. Unless you mean something else? I was just asking why 'goto' was implemented in PHP, while other features so much better, cleaner and useful than 'goto' are rejected. 
The other remark came from Slack. I'll ask the author if I can screencap and post it.
my idea is that you should use class/object. You have a single function which is way too long and hard to read.
Firstly, `goto` was probably never *considered*, just added at some point early on in PHP's history. If the decision had to be made today, it might or might not have been added. Secondly, you are blindly spouting the famous, and famously misquoted, "`goto` is evil"-mantra. `goto` is *good*, and difficult to replace, where `goto` is appropriate; it's just that it isn't often appropriate. Lastly, I despise C#'s property syntax and think precisely no language should attempt to emulate it.
Replied. And thanks :-)
he's mentioned it a few times, and each time it's a slightly different argument. I answered the one he put on my blog post. The other argument he's brought up is that "switching it on for WordPress/etc is going to cause a ton of errors". And I think that's unrealistic as this isn't something you're going to switch on in legacy code without refactoring. And it's not something you're going to switch on without testing.
You'd have an unhinted public method and pass the validated contents to a hinted private method. The hint won't do anything in a weak context and kind of be redundant after the validation, but it still would work on internal calls in a strict context or to optimize things.
Thanks for the kind words Phil! It's been heck of a lot of fun being involved in The PHP League. It's a great group of people, and that includes those outside of the leadership group, like [Ignace Nyamagana Butera](https://twitter.com/nyamsprod), [Joe Tannenbaum](https://twitter.com/joetannenbaum), [Scott Robertson](https://twitter.com/scottymeuk), [Graham Campbell](https://twitter.com/GrahamJCampbell), [Christopher Pitt](https://twitter.com/assertchris), [Ross Tuck](https://twitter.com/rosstuck), [Phil Bennett](https://twitter.com/philipobenito) and more!
Also, a bit of self-promotion on my part as well to throw [PHPDeveloper.org](http://phpdeveloper.org) into the list.
The exploits I've come across are all plugin or theme related. I haven't seen a core WP hack that wasn't brute force with crappy passwords with 'admin' user. Have you see others?
Did you read mine?
https://laracasts.com/series/laravel-5-fundamentals/episodes/5 Around the 3 minute mark: pull them in in the needed templates. Allthough this video covers Laravels blade it is fairly content with templating in general
Correct. And PSR-7 is going to do a lot to spread middlewares around the community in an interchangeable framework agnostic way. Pretty excited about that.
I've always thought WP should allow filtering plugins by PHP support versions prior to install or upgrade. This would allow developers to exclude users who aren't running a compatible version of PHP.
I definitely read your [comment](https://www.reddit.com/r/PHP/comments/2vk42m/scalar_types_and_php/coin36b). If you made another post, I'd be happy to read it.
&gt; I already go out of my way to turn combined use declarations into separate declarations. Why?
I completely understand your frustration and I agree with you. Their in-action speaks loud enough on its own. You probably don't need to call them out publicly on it (questionably competent, heads up asses) -- it's true but it doesn't help your cause. That aside I appreciate your relentless work on this and trying to get them to get them to treat you seriously. They should be thanking you for not selling a proof of concept to someone nefarious. I would suspect they weighed it by low probability vs. effort to fix (including backwards compatibility with 3rd parties). Their unprofessional 8+ month 'do nothing say-nothing' strategy gives them time to obsolete more PHP &lt;5.3 users and time to see if a hack appears in the wild. Unfortunately this type of problem is all too prevalent in any software product with a large user base. Often it isn't until the researcher releases a proof of concept/disclosure and the users freak out that organizations like this respond. And in many cases they don't respond until there are a lot of public exploits. Look how long it took Microsoft to take security seriously. PHP sessions. Etc.
Fyi, it looks like that tweet was deleted.
To be fair, he did it after a week and to someone other than the project he was complaining about. The OP didn't exploit the issue on someone's random wordpress install and waited months before disclosing it. Anyone who discloses after 90 days is a professional, honestly.
yeah, it's good stuff - I read up on PSR-7 stuff today, I love the idea of being able to switch things around and not be tied to one framework.
At a quick glance it appears that you are not setup to handle longer TLD's like .co.uk Also Completely agree with /u/Hall_of_Famer that this should be put into a class. If you really think its worth publishing out there you could even drop a composer.json in there and make it available for people to use in their own projects.
That's kinda what I figured, thanks for confirming!
Even if the claim that you handled this unprofessionally were true (which it isn't, by all accounts you tried everything you could to tell them) it would really be the pot calling the kettle black. Wordpress and its developers are anything but professional.
Yes, definitely use this. Hard work already done for you! &gt; composer require league/url
By the way, https://core.trac.wordpress.org/attachment/ticket/28633/28633_alt.patch New patch, prevents the 8KB entropy wasting problem that Stefan Esser raised.
Yep, that makes sense. Hadn't thought through the possible issues with an .ini directive.
You can also load your js at the end of the page, when you already know what you will be using. I usually seperate my JS-files into one that is used on every page (UI-navigation things usually) and others that are used for specific, complex tasks like wysiwyg-editors, uploaders, image-editors, etc. which are included when needed.
Thank you all for your help. In the end, I will be storing the javascript of my views under seperate files and load them using jQuery.getScript() to inject it in the page. 
Yes, but those aren't responses to the same thread ;)
&gt; Could we maybe tell PHP to treat the exact phrase and only the exact phrase &lt;?php strict as the initiation of strict mode, kind of like it has a special meaning for &lt;?=? That's actually the idea. So this works: &lt;?php strict But this doesn't: &lt;?php strict Although this does work (to avoid being too punishing): &lt;?php strict
&gt; Why are people complain about scalar type hints to the point that we have to introduce a new document mode? Because people are fine with scalar type hints, the disagreement is over their behaviour. Some people like one, some people like the other, why not have both? Better than pleasing only one group, or pleasing nobody.
Not really sure what do you mean. The dude just wanted to share something he thinks it's nice.. no need to be rude, just ignore it..
&gt; Valid point, although I don't consider it entirely unreasonable that unexpected things will happen if you try to run code meant for a major new version on outdated software. It's still a risk, though. Also, IDEs might take time to be updated and not recognise `&lt;?phps`. Plus, `&lt;?php strict` is more obvious than `&lt;?phps` is.
You'll need to put it in each file that you want calls and returns to act strictly in. That might not be every file. For example, a file that interfaces with input data a lot (maybe a controller that uses $_POST too much) might be a great place to keep it weak, then you use strict for all of your library / model / whatever code. It might be you want to be strict EVERYWHERE, but that just leads to you putting in a lot of typecasts, which is what weak is doing anyway. :)
Result: 20 of 20 100% Perfect!!! Time Spent 1:18
It would be nice, and not to mention quite a bit harder, if they had any kind of question about classes. :(
Christ. Even PHP 5.3 is EOL now.
This is ancient, it was written many years ago.
So do I do a foreach for this? I'm still not sure what to do.
Well I guess the question lies in whether it had classes years ago.
I'll second that. You do a wonderful job covering the entire PHP ecosystem. 
I think the answer really depends on the purpose of doing this. You can use a cron job for doing that, but that introduces more moving parts. I would probably lean towards your current way and daemonize the script using something like [this](https://github.com/shaneharter/PHP-Daemon). As for the issue of data storage, it depends on what you are doing with the data. Are you aggregating and using the data as a time series? If so, something like [InfluxDb](http://influxdb.com/) or [druid](http://druid.io/) is probably a better fit. Finally, instead of logging and storing the data yourself, why not just call the API when you need the exchange rates?
Used this today, it takes an array and builds you the query string, no need for urlencode. Just do http_build_query( array( 'param1'=&gt;'Value 1', 'param2'=&gt;'example@email.com' )); 
Best practice dictates that you load all of your JavaScript in a single file at the bottom of your page, right before the `&lt;/body&gt;` tag. If necessary, you may need to break your scripts into multiple bundles and load only the bundles relevant for the current page. RequireJS or CommonJS make this easy. Placing JavaScript directly in your view means you can't use [Content Security Policy](http://en.wikipedia.org/wiki/Content_Security_Policy) so don't ever do that.
It's the plugins. *Click-click-done* and you have a new feature. That doesn't mean it is not being held back by its legacy structure (which by today's standards, is an embarrassing tangle of spaghetti) but it works, works okay, and works cheaply.
Should I apply this patch manually to my existing wordpress sites on WP 4.1 , or is this something I should wait for via an auto update? Because I have like 150 of them and I'm worried about this!
Do the values need single quotes or can I just add 'name' =&gt; $name, ?
'name'=&gt;$name should work just fine.
What about `$x = "snap".foo.bar`?
Actually had a similar thought about it myself. Didn't take it as far as function/method parameters though.
From the browser's point of view, if the JavaScript will realistically run once during the session, it doesn't matter whether it's an external file or on the HTML page. What does matter, but only marginally, is where it's placed in the document if it's synchronous. The browser reads the page top to bottom. You really want the DOM to load ASAP and not get hung up reading the JS into memory. So put the JS at the bottom. What's absolutely critical with any JS though is that it minimizes DOM repaints/reloads, doesn't hold onto memory and/or waste resources. This is 1,000x more important than where and how you call it.
I think I misread something, also because someone mentioned http_build_query. What you use http_build_query for is to build a query string. But from what you seem to be asking you are talking about processing POST values. In that case have a look here: http://php.net/manual/en/reserved.variables.post.php. There are some examples on that page. Also have a look at this tutorial: http://www.w3schools.com/php/php_forms.asp Make sure you also read up on securing your form (tutorial on next page). Hope this helps, and sorry for the confusion!
You can do it with Laravel. layout.blade.php &lt;script src="//jquerycdn" type="text/javascript"&gt; @yield('page-jquery-scripts'); page.blade.php @extends('home.layout') @section('content') &lt;h2&gt;Hi&lt;/h2&gt; @section('page-jquery-scripts') &lt;script type="text/javascript" src="pageScripts/page.js&gt;&lt;/script&gt; @stop @stop Something like this. A better alternative would be hooking the view events and binding scripts on it on the fly. Event::listen('view.rendering', function($event, $view) { if(file_exists($view-&gt;name . '.js') { return $view-&gt;with('scripts', JS::load($view-&gt;name . '.js')); } return $view-&gt;with('scripts', null); }); However, this one is just an assumption. I don't know if Blade fires events, but you can find a way around it. This would force you do keep your javascripts in the same name as your view name, but would be much better, because since javascript files are seperate js files, you can lint/minify them for your taste, unlike embedded scripts. 
Just for clarification, I posted that because you are needlessly making three function calls plus performing string concatenation when you only need one function call and an array as input. Also, neither urlencode, http_build_query or trim is performing any kind of validation or sanitation. These are really two separate and distinct processes that will be entirely dependent on what your application is doing. For example, what are you even validating against? 
It still needs work. It doesn't handle all top level domains, e.g.: example.co.uk example.com.au It doesn't handle array query parameters, e.g: http://www.example.com.au/?foo[]=1&amp;foo[]=2&amp;foo[]=3
It's a blog tool. Don't kid yourself. Also, see: [https://en.wikipedia.org/wiki/Law_of_the_instrument](https://en.wikipedia.org/wiki/Law_of_the_instrument)
Mostly just spam and making sure all fields are required. So a basic if (!empty($name) || empty($phone) but it doesn't seem to pass after I implement this. I'm still at a very beginning level of php, so it's been tough getting help. For the HubSpot API, there's there is the string to process the form submission in HubSpot, then you're populating the variables and lastly using the curl function to pass the data and redirect to a new page. Here's the basic example of how it works in PHP. [Link](https://developers.hubspot.com/docs/methods/forms/submit_form)
Taken from the front page of Wordpress: "WordPress is web software you can use to create a beautiful website or blog." Anyone mashing it together to build applications when proper tools exist is just a darn fool.
I've gotten used to it, to me it looks like a directory separator, so it makes sense.
I've created one rest site with it and really like it. There are many options so it can be tough. I would recommend it with the caveat that it's easy to start putting logic into the view. You have to stick to the design pattern so moving to a newer version of the framework will be less painful. This is the book I used. It was great. http://learnzf.com/book/ 
I would hold off on jumping any sharks until at least the weekend. The complexity required to exploit this puts it squarely in the "is it even possible?" realm, so if an attacker can cobble together and unleash exploit code between now and their 4.1.1 or 4.2 release, you're probably already doomed anyway. I *think* they are making headway into reviewing the patch, and probably discussing other political stuff, in their #security room right now.
Why do you need mod_php? You can do nearly everything with fcgi that you can do with mod_php (if it is configured correctly, e.g. to pass HTTP authentication stuff along).
Saw this one a while back. It's not even the worst offender in that repository (or repositories by iRestful). EDIT: https://github.com/irestful/MultipleHashMapQueueMessageRetrieverCriterias/blob/master/MultipleHashMapQueueMessageRetrieverCriterias/Domain/MultipleHashMapQueueMessageRetrieverCriterias/Adapters/Exceptions/CannotConvertMultipleHashMapQueueMessageRetrieverCriteriaToMultipleQueueMessageRetrieverCriteriaException.php Class name is 105 characters long.
Check out their other repos...
Yep. It sucks a lot, but there is a very, very long tail of shared hosts that either don't support newer versions of PHP, or more commonly have hundreds of thousands and millions of users simply on older defaults. We're actively working on this by gathering up statistics and then going to each hosting company and helping them upgrade old sites. (In fact, this is a project being led by dd32, who has gotten other props in this thread.) We take this approach because we care a lot about our users, most of whom who don't even know what PHP is. We get a lot of flak for some segments of the PHP community, but many of them understand where we're coming from. (Some of them also heard me announce some of this at php[world] in November.)
The closest we've gotten in the last ~5 years or so is we've had a few XSS issues, but the nature of them (they're usually mitigated, limited, or tough to trigger) mean we haven't seen massive compromises as a result of WordPress core. Automatic updates mean we can update 10 million sites an hour, whenever we have a security issue to patch.
We very rarely patch run-of-the-mill SQLi/XSS/CSRF. It's almost always something way more creative these days, like SSRF or XXE. But do be somewhat assured when I say that yes, we've heard about and patched the newer stuff. All software has bugs, and sometimes that will be due to a careless action. I don't think that was this case; this code was originally written with [security community input](https://wordpress.org/news/2008/09/wordpress-262/) in 2008. If it needs to be updated, we're looking forward to [https://core.trac.wordpress.org/ticket/28633](resolving) that ticket.
I didn't have an issue with its disclosure. I just didn't like, after a long and tiring day personally, reading a harsh email on FD that went well beyond the facts, and finding out about it only because people had by then started sending me hate mail. That's not OK. Let me be clear: I'm not blaming /u/sarciszewski; he received the tiniest of flak from me because of what I described above (see more [here](https://core.trac.wordpress.org/ticket/28633#comment:25)); he and I have talked it out, are fine, and will continue to work on a possible adjustment here. I know /u/sarciszewski knows this part, but I wish everyone remembers there are humans behind every piece of software.
This has to be a joke... Is it a joke? 
&gt; the people over in /r/wordpress [The responses on /r/wordpress as are abhorrent as everything else in this discussion](http://imgur.com/48UvWg2). 
[It's](https://github.com/irestful/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/blob/master/dependencyinjection.json) [not](https://github.com/irestful/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/blob/master/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/Tests/Tests/Unit/Adapters/ConcreteMultipleHashMapQueueMessageRetrieverCriteriaAdapterTest.php) [nice](https://github.com/irestful/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/blob/master/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/Tests/Tests/Unit/Builders/ConcreteMultipleHashMapQueueMessageRetrieverCriteriaBuilderTest.php) [to](https://github.com/irestful/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/blob/master/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/Tests/Tests/Unit/Objects/ConcreteMultipleHashMapQueueMessageRetrieverCriteriaTest.php) [point](https://github.com/irestful/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/blob/master/ConcreteMultipleHashMapQueueMessageRetrieverCriterias/Infrastructure/Adapters/ConcreteMultipleHashMapQueueMessageRetrieverCriteriaAdapter.php) :)
[**@i0n1c**](https://twitter.com/i0n1c/) &gt; [2015-02-12 10:49:27 UTC](https://twitter.com/i0n1c/status/565825002722033664) &gt; @adamcaudill and the proposed patch eats up all the entropy of the system. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt; Do let me know if there are any particularly public flakking https://twitter.com/i0n1c/status/565830150995337216 
Please be a joke. :(
While I agree that testing with sufficient data is necessary, using REAL data is just asking for trouble. You definitely don't want that new bug you introduced to accidentally get stuck in a loop and blast 40,000 customers with emails all weekend long before anyone notices. Bummer. This is where seeder scripts come in handy. There's no reason you can't generate a working data set of realistic proportions in just a few minutes and it's a decent way to verify that some core functionality actually works.
&gt; ...but the joke will be on them &amp; they will have given in to the eventual world domination of PHP!! It'd be \**twitch*\* nice to have a framework/addon/library where PHP compiles to JS (looking at you: PHPJS) with full coverage. Oh OH! Have PHP natively parse CSS too. Heck, write everything in PHP! ~_~
In my mind I see a console or log somewhere that redundantly reads: ERROR (CannotConvertMultipleHashMapQueueMessageRetrieverCriteriaToMultipleQueueMessageRetrieverCriteria): Cannot convert multiple hash map queue message retriever criteria to multiple queue message retriever criteria!
They seem to be attempting to encode all the actual code inside filenames. That way, you save disk space by not having any contents in the files. If you don't think about it too closely, it makes complete sense.
Could you go into more detail about *why* you need to track the currency rates, and how you plan to use the data?
Using folders is more web-scale!
why not use hootsuite
&gt; website ***or*** blog. Yeah, no way could it be used for e-commerce, media management, social networks, forums, wikis or a host of other things that non-developers might want to be able to still use!
I'm assuming `foo` and `bar` are constants? It *still* shouldn't be a problem for a *context aware parser*. From that statement the parser could realize it is in a variable context and behave accordingly.
Uh, 5.5's generators were probably the single most powerful tool ever added to the language. Co-routines? Concurrent processing? These are a thing now in PHP. It's not sexy but I personally made encrypted stream transfers *much more secure* against eavesdropping and interception in 5.6. The fact that you know nothing about the huge number of improvements in these releases means PHP is getting something right -- there are tons of *very tangible* improvements being made constantly without code massively breaking in userland. Pretty short-sighted :/
Can you explain which http2 features you want that you don't have in userland that would cause you such great hardship by their absence?
It stopped being funny after some letters 
Well I was talking about HTTP2 extension, I guess we aint on the same page after all: https://wiki.php.net/rfc/pecl_http
No, I get that. What features from the extension are you looking for? I ask because I've been a voice against including it with the distribution and I'm interested in feedback as well as dispelling misconceptions if people have them.
Be happy it uses mysqli_* as opposed to mysql _*.
Why not suggest some?
:-) What can I say but thank you. Great review of the code, I'll check into your suggestions. Thanks again. 
Realistically, who runs core and a default theme and nothing else? Hell, I bet if you download 10 clients web directories at random and run avast free against it you'll find php scripts cleverly hiding away that some how ended up getting in. I've never seen this with clients with other CMSs - Core Wordpress is pretty damn good - but it's not real world.
Well Nikita Popov said that in the next version of scalar object, it will be much more powerful so you can call methods directly on scalar upon it's created: "MyString"-&gt;length() // will throw an error right now, but will work in next version. This way you do not have to store scalar in a temporary variable, it will be much better and your code can be effectively translated into (1+2)-&gt;toString() in PHP. 
use MultipleHashMapQueueMessageRetrieverCriterias\Domain\MultipleHashMapQueueMessageRetrieverCriterias\Adapters\Exceptions\CannotConvertMultipleHashMapQueueMessageRetrieverCriteriaToMultipleQueueMessageRetrieverCriteriaException; Nice. 
So when you said: &gt; I think this has been the story since PHP 5.6 release, unfortunately. You really meant this one unimportant syntactic sugar thing that started a vote today and actually nothing has been officially declined yet that you wanted. FYI return types have already been approved and that's one of the biggest additions to the language ever. You don't know it, but 7 is *really, really* fast. On par with HHVM.
So how would you go about generating cryptographically sound random numbers without `ext/mcrypt` in a meaningful cross-OS way? Spoiler alert: you wouldn't, and this is in no way affected by the mcrypt lib no longer being maintained. There is far more at play than you understand in every one of these decisions. Smart people have to make hard decisions with information you don't have, so please, spare me the description of vast linguistic catastrophe.
Very simple, straightforward, and readable. Great job! Starred.
Of course, the performance of PHP 7 is the most exciting feature I'd say. You should not jump to the conclusion that I do not know PHP7 is fast, I know it is. Its one important reason why I said I would build a custom version of PHP on top of version 7, not version 5. Regarding return types, I like the concept but the implementation actually annoys me. Id rather have this syntax: public string getHashCode(){}; rather than: public function getHashCode(): string{}; Kinda like this RFC was suggesting: https://wiki.php.net/rfc/returntypehint2 But thats just my opinion though, I hope one day they will make the function keyword optional, at least at class level. 
And you would break millions of greps in one fell swoop with your syntax. Again, more going on here than people realize. But cool, post a link to your php-src fork so we can all benefit from your work. I'll bookmark it right away.
Sorry, I dont have one on github yet, because PHP 7.0 stable version is not released at this stage, some features can still be added, and lots of things are subject to change. Also some PECL extensions will need to update to be PHP 7 compatible, it will not come very quickly. But I have a plan, and I know what I am doing. I do have a custom build with PHP 5.5 as base on my wamp server, I've been playing with scalar objects, metaprogramming and pthread lately and it's been magnificent. If you are interested, maybe I will post some articles on how elegant PHP can become of with those new OO features. Also I think you should not feel so offended or hurt by my comments. You know, its impossible to please everyone, and perhaps we just do things differently. I do not intend to start a war, I just want more alternatives and options. Although I've been a critic to some things about PHP, I still like it as a language. Otherwise, I will just walk away and use another language, than to actually consider improving it. 
Very good point. I've only ever used (pardon the pun) 1 composer package that had a use case for use function, so haven't yet come across needing to import lots of functions. Likely to be something that happens more in the future though.
Good point; I didn't consider the use function / use const need. I still believe having lots of use statements in a file is a sign that it may need attention.
Thanks fixed!
Composer is for anything that has PHP code, specifically classes that you intend to use, because installing a composer package automatically adds that package's classes to your autoloader. Bower is meant for front-end resources like CSS or JS. It has very few features outside of keeping track of version constraints and dependencies and downloading them appropriately. If you only have one external front-end resource dependency, maybe you'll prefer the lower overhead of getting it via a package manager you already use (such as Composer or NPM), but by the time you get more you may prefer using Bower to keep a separation between front-end and back-end dependencies. There is always some package overlap because package maintainers want to reach as wide an audience as possible, even if they are using "the wrong tool for the job".
For bootstrap use Bower. Composer is used for PHP packages
Yesterday I needed to make a [quick script](https://github.com/conradfr/MagentoCustomExport) to parse &amp; export a csv and by poking around I ended up using two of these packages and found them straightforward with decent documentation. I'll try to look at all of them later.
Composer is better than bower because it generates composer.lock file that tracks exact commit that is being used with current application. Then anyone can just checkout composer.lock and execute composer install to get exactly the same dependencies. Bower does not have this feature. This is why it's highly recomended to commit all libraries installed with bower. I think there is nothing better than composer for PHP. You shoud use bower for JavaScript only.
&gt; temporary file naming for example Allow me to consider a shared host where a user can predict those temp file names for other hosts. 
Never go full retard
Thanks for posting this, its very interesting to get to know so many awesome developers from PHP league. I know Chris Pitt, whos actively helping me with a project. I hope one day I can be as good as PHP league developers myself! 
The break down most people give on the PHP used by facebook is that it's basically a php framework that they compile like c++ or c# and thus since it's precompiled, it's not really PHP. I've read 20+ articles and no one really agrees what the definition is...I'm sure you and everyone else on here has an opinion &amp; we'll form another 20+ definitions in the next couple days!
Honestly, it was simply a learning process for me. Something to get used to testing, the tools you can use like Travis and Code Climate, and I wanted to make a router I guess XD It probably offers little if any advantage over other solutions. It's pretty fast, but could no doubt be faster if I cached the compiled routes somehow. I quite like the syntax. I am also thinking of adding what some other routers have which is "RESTful" routing, but I don't want the library to be too opinionated.
Argh! Thank you! I'm not sure why I couldn't find defined before. Thank you, for the kind words, and advice. ... time to make that MVC framework then ... I'm actually thinking of turning this into a Hack project, or at least making a Hack fork of this library, and then creating a middleware based framework in Hack while making various other components.
Good point with @throws. I've been told `defined()` would work too, for the constant check? I wanted to avoid reflection because I understand there is a performance penalty with using them, no?
Use PHPStorm
Check out http://www.datasift.com too, they can help with collecting and monitoring.
* Ease of use * Customer familiarity * Upgrades from existing sites You should get off your high horse, calling it a blog tool is distorting and oversimplifying the capability of it. Just because a tool exists for one purpose doesn't mean that's the tool you have to use to get the job done. Sometimes the hammer you have on hand is better than the nailgun you don't. Having worked with many CMS and e-commerce platforms, my customers all prefer WordPress.
&gt; For instance "goto" is a pretty weird feature from a "clean code" point of view, but it is a shortcut feature `goto` can lead to cleaner code, actually. If `while`, `if`, `for` and `switch` don't fit the problem you're trying to solve, better to use `goto` than some awful workaround.
It doesn't "cascade down". If you add the `define()` in a file, only the calls to type-hinted functions *directly in that file* will be strict. If you call a function that's in another file and that function calls type-hinted functions, those calls will be weak.
Good advice in general
&gt; If I start from scratch, and spend about 4 hours per day learning/training, do you know approximately/roughly how many months it might take for me to be able to have a decent/functional knowledge of PHP? It depends. Do you want to be able to mess around with Wordpress? 2-3 weeks, at most, to be able to do most things in it (other than write plugins). Do you want to mess around with something like Drupal? Maybe 4-5 weeks. Do you want to be able to properly use a framework? 3-4 years.
&gt; Unfortunately what I find is very beginner oriented. That's because CodeIgniter was very beginner-oriented. Any reason to not use a more modern framework that may more closely mimic what you may see in C#?
&gt; This would be no different to the declare syntax which the user can control. The declare syntax gets this right in that only the caller, not the callee has control over strict/weak behavior. Again, what's the point of enabling strict hints at the class/method level if they can be overridden by the caller? My other big issue with this is that individual method calls (and even individual parameters within a call) could be switched between weak or strict throughout a file. This would be very messy and confusing, IMO. The intent of declare is that the behavior would be uniform throughout a file.
5.4 is in security-only release schedule now. https://php.net/archive/2014.php#id2014-09-18-2 You should consider upgrading.
We use composer for both. We rebuild bootstrap and font awesome with our own less file pipeline... These packages are pretty stable even if they may lagg behind the official release by a few days... But we rarely ever use freshly released packages so the composer.lock file helps keep the team using the same version. Additionally by using composer on both.. We simplify everything by not having to use two package managers.
Rate limiting on an IP address can have downsides. IP addresses are not always static, you could have them sign up for the free service and just assign api keys for them to use.
...all THREE HUNDRED OF THEM.
Phil is gonna be maaaaaaad.
It's pretty much impossible to keep a determined user from abusing limits like these. Everything from the user is spoof-able and techniques to stop this kind of thing generally inconvenience or annoy other users more than anything it does to stop abusers. My advice would be to make sure you limit and preserve data that users grab from the API. Save every search for a span of time and reuse it before allowing users to make the same call over and over again. Instead of sending coordinates, use geolocation to look up the zip code and then check for cached data before making an api call to that derived zip code. This would also give you options if and when you run out of api calls - you could serve expired cache data, or serve data from a nearby zipcode that you have cached. 
Yes, we can agree :) Doing too much in one place is definitely a warning sign.
I'm on board with your points about classes doing too much, FWIW.
Pointing out the logical fallacies in your statements is not the same as "being mad." If you don't know what you're talking about expect to be called out for it. Use logic. Provide backup for your statements. The rest has no place in technical discussions.
Dude if you're going to ask a question about a user who is obviously asking for assistance, don't make a half-assed response to him by saying he should have asked it somewhere else. Tsk tsk
**PACKAGE** ,, ';; '' ____ || ; \ || \,---'-,-, || / ( o) || (o )__,--'-' \ || ,,,, ;'uuuuu'' ) ;; \ \ \ ) ) /\// '--' \'nnnnn' / \ \\ //'------' \ \\ // \ \ \\ // ) ) \\// | | \\ / | **ALL THE THINGS!**
I like the [phpacademy](https://www.youtube.com/user/phpacademy) youtube channel. For example, there's a "[Learn PHP](https://www.youtube.com/playlist?list=PLfdtiltiRHWFD41D_LDomY1Fb-O9MtFqq)" section to get you started.
why? BowerPHP is ported normal Bower from JS to PHP. BowerPHP is not tool like composer.
Yeah, I was never really particularly happy about this part. I'll do some benchmarks and see which seems best. Thanks for the advice /u/obbodobbo
A blog in 30 minutes? I can do it in 10
You can include an external file with apache to contain directives such as the ServerAlias's your needing here. You obviously want to be **super careful** with something like this if your application is able to write to a file that is controlling your webserver, but you could have wordpres write to a file and include it via ie: &gt; Include somedirectory/wordpress_hosts.conf
Create a user account system and require sign-up. Use an API key for each user to keep track of their use.
this seems like it will work, im going to give it a shot.. thanks!
We use just composer as well when we can. It's just too frustrating to have 2-3 package managers. There's no reason composer can't work for these situations.
I haven't read through the code, but why json and not array?
I see, its very interesting still. I am just a Hall of Famer by the username anyway. XD
JSON is Web 3.0, that's why.
Well how about stop making assumptions with this "internals so dumb zomg they ruin everything." nonsense yourself first? How are you not mad when you start to generalize and shut people down with a claim like this? If doing some things wrong = doing everything wrong in your opinion, or if certain people are not contributing = no one is contributing in your eyes, then I guess you really aint reasonable enough to have a civil discussion. 
JSONModel use associative arrays. Boxing and unboxing is left for the extension classes to define. Eventually ,-)
Well I didnt say I expect this in PHP core, I think you are mistaken a bit here. I am talking about a custom build PHP version(built upon PHP 7 when it will be released) that I will distribute and maintain myself. In this case, at least in a short run, there will be no need for changes to be approved by internals team, since there wont be an internals team unless it gets somewhat popular. If you actually see such potentials in my custom build of PHP, I'd appreciate this, but even I cannot say how it will be accepted beyond myself and a few other known developers and partner webhosts. On the other hand, I will be fully aware of when extensions like pThread, Imagick and HTTP get their new releases. When it happens, I will have a choice whether to update the extensions to the latest version, and release a sub-version of my custom build PHP. But thats way beyond the topic at this point, and at least I hope you now understand I aint talking about the actual PHP 7. 
Contributing is contributing. Whining doesn't serve anyone. If you have valid complaints propose *actual* solutions. Go fork php-src like you keep saying is the only way to solve this disaster of a language. Actions, not words. Github, not reddit.
Oh yeah, but the fact is that I never whined as if "internals so dumb zomg they ruin everything." In fact, if I truly feel this way, I wont be using PHP at all lmao. It is you who made this claim, and you thought I did, so perhaps you should take this 'whining does not serve anyone' attitude to yourself instead? 
&gt; I think this has been the story since PHP 5.6 release, unfortunately. &gt; Q: What has been rejected for PHP7 that you really wanted? &gt; A: [Nothing] particularly with PHP 7 yet ^ whining 
Agree -- there's never a reason not to program defensively. My point being that IP-based limiting isn't a feasible option unless you have extremely sophisticated network capabilities (e.g. you're google). Generally you need a more reliable way to tie access to a specific user. I wouldn't say it's passing the buck, though ... it's the only real option.
Conversion to/from json to other types? 
`readfile()` does not read the entire file into memory, it buffers the file and streams it to the client in the same manner as your script is attempting to do, except it does so natively.
Your github page says you're lying: composer require strident/router ~1.0 If you were doing it just as a learning process you wouldn't bother publishing it to packagist. Its okay, though you're in good company with the other 100+ routers 
Haha, putting it on Packagist also makes it easier for me to use :), besides, who knows, maybe someone actually would like to use it over the other 100? ;)
try https://bufferapp.com/ or the open source alternative http://circular.io/
Unless your app mandates that all resumes are formatted exactly the same and saved in the same format, there are many variables to consider. Document type (doc, pdf, odt) and resume format (name on left, name on right, address above or below name, format of years worked, etc.) are just two. If you're dealing with doc/odt it would be easy enough to parse all the text with an existing document reader library - there are several on packagist. If you're dealing with PDFs there are two scenarios - either parsing works perfectly, or all bets are off. Some PDF writers are notorious for writing each character as a separate object, instead of strings of characters, making it much more difficult to parse. Assuming you can correctly parse the text from the given document, you still need to detect the format used. You'll wind up with lots of functions to detect specific types of information... `if(is_address($line))`or `if(is_position($line))`... that kind of stuff. In my opinion, it would probably cause less headaches to use a third-party service with an API as /u/adamn90 suggested.
Thank you very much
this. Its way more inspirational to think of something, even a thing done a thousand times before, and build it by doing your own research. You will learn a lot about the tools you're using, and with the reading you do, it will inspire you to other projects that build on your experience. Until Bam! And one day you have an employable skill. Use the tutorials as a tool to accomplish your goals, not as a means to reach a goal in their own right.
Pretty cool, dude... I'll have to give this a try soon.
Excellent, thanks for the input. I'll keep you updated.
Probably not an option, but ... If your server has multiple virtual network cards, you could set up each multisite network as the "default site" on different network cards. Under this setup, you would have unique IP addresses for each of your network sites, and there would be no additional Apache configuration needed whatsoever to map a new site to the network, since they would already be segmented by IP.
Genuine question: why is method notation superior to function notation? Why is `sort($array)` inferior to `$array-&gt;sort()`?
This looks like a good suggestion. Not too expensive.
PHP 5.4 should not be used for new projects given it is approaching end of life this year. Saying "this only supports 5.5" isn't a restriction, it's common sense. Don't be a slave to the LTS distros.
As mentioned, you'll need something better than the IP address to identify a consumer. Once you have this token I'd recommend looking into Redis using this pattern: http://redis.io/commands/incr#pattern-rate-limiter
Thank you so much for your advice Anthony, it works. 
A lot of the time that is a bullshit handwave to shut down the conversation. "Named parameters is not the PHP way. You use a parameter bag or an array!" Yeah, those are two shit alternatives to using named parameters, because we don't have them. So... lets have them. The valid times this is used is a recent conversation, when people are asking for _only_ strict type hints. PHP has == and === for a reason, being that a lot of the time we're working with data that is close to what we expect but not quite. A database int field gives you `"1"` not `1`, which is annoying but hey, it still == 1. So, the whole weak and strict thing is "the PHP way," which is why we need weak and strict typing. Sometimes the argument makes sense. Sometimes it's overly abstract crap, because the person doesn't really have an actual point to defend their stance and doesn't want to say "I dont like it" or "I dont understand it."
There is an easy way around free tokens though, you can just signup for multiple tokens, essentially creating a pool of tokens that you can just cycle through. I'm not really sure how you prevent against that, perhaps tracking request/ip address ratios and investigate when a ratio becomes too high?
using the fxp/composer-asset-plugin you can have both. Example http://www.yiiframework.com/doc-2.0/guide-start-installation.html
Good work!!
use ansible
This this and this.
Pretty tired of the old "oh just another _________" comment/dismissal.. Who cares? Unless it's a carbon-copy with only a name change then shouldn't all new projects be considered as they may *gasp* offer something different or something in a new way? To always refer to some other project and neglect new ideas is not how you push a technology or innovation forward by any means. And fine, if it does in fact do everything the same as every other ________ out there has done before it then sure add it to the 100+ pile of others and move on. /rant off 
I like this idea, it actually helps and will complete the return type hinting feature. 
This is a no-brainer .. so it probably has a 50/50 chance of passing. 
Sadly this doesn't help, input gets split apart, everything before the problematic character is lost.
That's not true; in other languages namespaces do not resolve from the root. They always search the current namespace first and then work their way down the namespace hierarchy until they get to the root. This works great for compiled languages where all the classes and namespaces are known at compile time. But that is not the case in PHP. Namespaces are pure compile-time feature in PHP (all names are fully resolved when compiling a file) but loading files is done at run-time. It simply cannot be done any other way in PHP. 
In general the choice of framework doesn't matter. I say in general because there may be some specific cases where it might, but you've not elaborated on this. There are plenty of approaches to speeding up a site, regardless of the framework you are using. Firstly I'd start running explain on your database queries to see if there are any queries running slowly, or that could benefit from indexing. Next, look at expensive repeated db calls. Things like queries to generate menus and the like - and cache the results. There are a pile of other things you can do to optimise... burning down an entire project and rebuilding it in another framework is rarely the right move.
Okay,the site is basically a gallery. I handle photo uploads,the primary key is a unique id and another unique field is the md5 hash of the image file itself. I have a simple view where I just retrieve all the details of the image by searching using the md5 hash and then some joins using the unique ID field. This page takes 11 freaking seconds to load,resources are minimal and are loaded early. Note : The main thing is that this happens on the main server,works fine on my system. The server is IIS7.5. BTW how do I see slow running queries ? I have Adminer for an interface.
It definitely sounds like a database problem, probably a slow query. I personally use the Laravel Debug Bar for logging queries.
Looks like it,I tried [this](http://www.howtogeek.com/howto/programming/speed-up-your-web-site-with-mysql-query-caching/) but was presented with an error : **Error in query (1227): Access denied; you need the SUPER privilege for this operation** on executing SET GLOBAL query_cache_size = 8388608;
I fail to see how this is better than a try, throw, catch. Also this leaves room for someone to completely override the value of the error instead of just appending with '.='. I don't think this has any long term benefit personally.
 I'd rather get a cancer and die than I would become something like you. Anyway, you just won the internet so congratulations. Have a nice day.
Do you know what is the difference between "covariance and contravariance" and LSP (if there is any)? That wikipedia article you linked to is very interesting and much more detailed.
What about null? Is there any chance that we'll see RFC that bring us something like function findBar(int $id) : Bar? { if (isset($this-&gt;identityMap[$id])) { $this-&gt;identityMap[$id]; } return null; }
Named parameters require a massive effort to implement. Skipping parameters is trivial. There's a reason the RFC didn't go anywhere.
Theoretically it might violate LSP. But I'm not sure and may change it. If you aren't returning anything, it doesn't hurt to allow adding a return type on inheritance.
People mock internals, but it does often have fairly good reasons for rejecting things. We can't accept literally everything proposed.
Having it be `null` would allow this: function foobar(): null { $a = usually_returns_null(); return $a; } Also, we already use `void` in the manual for the same purpose.
If the function can't fully promise that the result will always be null, then it shouldn't mark the return type as null, right?
It's actually never a good argument that never makes sense. There is no agreed "PHP way" where we can take an idea, compare it to a specific list, and automatically disqualify it. In reality there is only "PHP has been this way to date" which is a statement always subject to change. Simply because something has always been a certain way, it never follows that it must always be this way. That is just a logical fallacy used to suppress ideas for whatever purpose it is used and it *should* be called out as such whenever it crops up. Case in point. If the scalar types RFC passes, then always having non-strict typing cannot be the PHP way. It has changed.
I understand your argument but as long a project does not makes use of any new language features "&gt;= 5.4" means that it will run without any problem using 5.5 or 5.6, too. Since PHP 5.4 is still supported with security updates I don't intent forcing a user upgrading to "&gt;= 5.5" without any reason, I'm not talking about a new project the project where I saw a refactoring option using this framework exists a little bit longer. After the support has been discontinued I have no problem forcing the user to use PHP 5.5 or greater ;) .
I think people mock internals because there is currently no sane way to TL;DR the reasoning behind their decisions, so they often appear arbitrary. It would be nice if RFCs contained an ongoing summary section of the major points from the debate/discussion.
Generally speaking, inheritance for game objects is an anti-pattern in game development. It will ultimately lead to unwieldy trees and the "diamond problem". I suggest going either the composition route, or using ECS (the latter being the most preferred).
They're supposed to, but not many do. I am a particularly bad offender at failing to cover discussions.
Don't modify internal functions yet. Oh, and: function foo() {} //returns NULL function bar() : void {} //"returns void" (triggers an error otherwise)
Can you elaborate on why it is impossible for a php function to return nothing? 
It would be really nice if "no"-votes had a short rationale attached. Some RFCs can have many different reasons for opposing.
Null is "I dont know what the answer is." Void is "There is no answer." They're different. :)
That's just the way the language was designed. A function always returns a value. In the case where one isn't returned explicitly, PHP returns `null` for you.
PHP generally doesn't create new programming concepts, but borrows them from other languages. As a result, PHP's nature is ephemeral and ever changing. In PHP 4, object oriented programming was not in PHP's nature. Now, it very obviously is. In PHP5, scalar type hinting of any sort was not in PHP's nature. In PHP7, it very likely will be. If you want to go further, PHP's nature is therefore open to interpretation, viewed through the lens of individual programmers with varied preferences, needs and programming language experience. It is not a singular entity that can be defined. Those who do attempt to define it will invariably end up in conflict with other programmers because there is no concensus about PHP's nature - it is ever changing. It's probably more constructive to see if PHP has any defining characteristics that are both probably permanent and also match the expectations of its users at a given time. For example, writing functional code outside of objects. Will that ever change? Do a significant number of users want it to change? I don't know for certain (my crystal ball is malfunctioning), but I would suspect no in both cases. We would reasonably expect an RFC to accomplish that to fall right out of the gate. In 2030, that might change, regardless of how a minority might view PHP's nature in 2015. Scalar typing does not meet the same examination right now. It's useful (in whatever strength you prefer), it keeps creeping into Internals (going back 8+ years), the RFC has attracted a voter turnout of almost 100, and it has kept Twitter alive for the past week. On a numbers basis alone, looking at the RFC voting to date, this is definitely not beyond PHP's nature. What does all this mean? It means that using the phrase "this is not in PHP's nature" is often provably false. It can be accurate, at a specific point of time, however that does not mean it will continue to be accurate. PHP will change. Its nature will change also.
The problem is that in PHP *there is an answer*. Having a `void` return type may lead people to believe that the actual mechanics are as [callcifer describes](http://www.reddit.com/r/PHP/comments/2vu7n7/rfc_void_return_type/col5n0k), which they are not, and probably never will. Is this an issue? Is it not? I personally think it's not an issue and this RFC should pass, as it makes the code more descriptive, but it's something I'd like to see discussed.
You can use cron to call your php or whatever script periodically. Then you can write a function to check if your script is already running so you don't get overlaps. You could call it every 5 mins but then make the script loop over and over so it essentially only needs to be called once but this way if you restart your app/server you only wait 5 mins for it to kick back in. This way the process is run by the server and not some user action.
You should make a cron job run script that grabs all NEW data from the db, does the calculations and stores them in a cache file for historical lookup or just store it in a database table. There is really no need to involve the database every time you look up old data that's already been calculated and only needs to be read in the future. Cron jobs are fairly simple to implement especially since you aren't working with file structure manipulation which can be temperamental depending on stack setup. PHP script, cron job run every day every __ mins/seconds. Pull new day, do calculation, save data. Something to consider is how long your script takes to run. You may want to have a couple of the same script running on separate cron jobs that way you can track their progress individually. 
We used php daemon in our own environment. For some reason would continuously chew up larger and larger amounts of memory. We ended up writing our own implementation. interface Daemon_Interface { /** * Returns the max number of processes this daemon will allow to be executed at once */ public function getMaxProcesses(); /** * Returns an array of items that can be processed via a child worker */ public function getQueue(); /** * Return's an item or items to process from the queue */ public function getProcessItem(&amp;$queue); /** * Execute the child worker processor * * @thread */ public function executeChildProcess($item); } This is the basic interface. And this is the basic [Daemon class](http://pastebin.com/7vL8VbeL) And finally you you need to implement a daemon .. [which may look like this](http://pastebin.com/X02fFdtq) Maybe it helps.. maybe not.. works perfectly for us. We use it alongside forever.js and cron together to make sure its always running. 
Side question re: &gt; the void return type does not become a reserved word, but is instead restricted from use in class and interface names How is this different from making something a reserved word? Where else would it not be able to be used if it was reserved as opposed to just the above restriction?
Are you specifying a codepage to use when initializing the COM object? The COM system uses a codepage to convert binary strings into particular encodings. For example, you could try to convert strings to UTF-8 before they are returned to userland code using the `CP_UTF8` codepage: $comObject = new \COM("ADODB.Connection", null, CP_UTF8); This might not help if the COM extension can't handle the null character either. [http://php.net/manual/en/class.com.php](http://php.net/manual/en/class.com.php)
I tried setting the code page to all avaliable options, but to no avail. Through some investigation I've found that it's passing control characters as a part of the data which need to be there. Unfortunately PHP, or the COM extension, is processing these characters instead of passing them back to the variable.
Function name, method name, property name, constant name...
Then I would guess the COM extension has a bug, since typically PHP couldn't care less if a string is full of control characters.
The Return Types RFC added *zero* new keywords or reserved words or pseudo-reserved words. By adding `void` it would have introduced such a change, which substantially increases the chances of it being rejected. Additionally, as you can see here, `void` is somewhat controversial. Furthermore, there are plenty of use-cases of return types even if you can't declare `void`. No, it was quite wise if I say so myself to not include `void` in the return types RFC. Full disclosure: I authored that RFC :)
It's not just a social one. Strict-only type hints cause a mess: you can't use them for existing code without breaking things, they don't match internal functions, they're unfriendly to beginners. Weak-only type hints are useless to you if exact types matter. But the social complexity is rather important as well. It's not fair to completely ignore the use case of a large portion of your userbase.
Looks like a bug in the COM extension. It uses the Win32 function [`WideCharToMultiByte`](https://msdn.microsoft.com/en-us/library/windows/desktop/dd374130%28v=vs.85%29.aspx) to convert OLE strings to strings. I'm no expert on the topic, but I would say that the bug is somewhere in [here](https://github.com/php/php-src/blob/fc33f52d8c25997dd0711de3e07d0dc260a18c11/ext/com_dotnet/com_olechar.c#L80-L91) when calling `WideCharToMultiByte`. Perhaps: length = WideCharToMultiByte(codepage, 0, olestring, -1, NULL, 0, NULL, NULL); should be: length = WideCharToMultiByte(codepage, WC_COMPOSITECHECK | WC_ERR_INVALID_CHARS | WC_NO_BEST_FIT_CHARS, olestring, -1, NULL, 0, NULL, NULL); Straight from the MSDN website: &gt; The application should specify WC_NO_BEST_FIT_CHARS and WC_COMPOSITECHECK with the specific value WC_DEFAULTCHAR to retrieve all possible conversion results. If all three values are not provided, some results will be missing. I would submit a bug to PHP or contact someone more knowledgeable than I.
If you added strict-only types, absolutely no existing code would break (as none of them use scalar type hints). And if internal functions are left unchanged, then that's a non-issue as well. As for "unfriendly to beginners" I'm sure that's a heated matter of opinion. That's not really a technical issue either. The fact that no one could agree on which implementation should be used demonstrates a lack of technical superiority for either choice. The RFC is merely a compromise because of this lack of agreement. What is a technical issue is adding a pragma to the language which has never had pragma's before and having two completely separate implementations of a fundamental feature. The RFC adds much more technical complexity. PHP internals development is well known to be very toxic and your solution might be the only choice that was ever going to succeed. 
If a function is hinted to return `null` it's never going to be able to return anything else, right? So any function hinted with `null` better not ever know what the answer is! (or if it did, it couldn't tell anyone). 
There is definitely some use cases where this would be really helpful. A cool feature would be if it could also create methods but from actual functions. Say I define a function test() somewhere and then tell the library to copy the code of the function called 'test' into the generated class. In the code generation libraries I used I always had to pass method bodies as huge string
Thank you. And it's very nice to hear the compliment.
There's codersclan.net, but it's not constant. Jobs come one every few days or so.
&gt; These functions do not return nothing; they return null. It's important to note that they *always* return null. Documenting `void` basically says they have no meaningful return value -- which is true. &gt; We can't create code contracts based on intent; that's just prettier docblocks. I don't see why not. If accepted, this RFC would be immediately used. It would trap errors where people attempt to return something for functions that declare they return nothing. IDE's can display errors if you use the return type. It all makes perfect sense. 
"Modes" vs. "Implementations" is really splitting hairs. 
I'm not really sure what you said as I'm a total php beginner. However you definitely gave me some stuff to Google that's for sure. It looks like the main discussion for this will take place [here](http://www.reddit.com/r/PHPhelp/comments/2vuvgu/object_inheritance/) as per /u/mbdjd 's suggestion so if you'd be so inclined to share your knowledge (albeit a bit more broken down mind you; i'm just not that skilled yet) I'd greatly appreciate it! :)
&gt; They implicitly produce NULL like any other PHP function that doesn't return a value. And that's why this is, IMHO, a bad RFC. I think void should only be added if it can behave properly, [like this](https://www.reddit.com/r/PHP/comments/2vu7n7/rfc_void_return_type/colfxyk). Yes, I know that means adding an actual void type, but that is the only sane way of doing this. Because your current proposal is just a glorified docblock.
&gt; Documenting void basically says they have no meaningful return value -- which is true. There is no reason to document that they return `void`. The concept of "no meaningful return value" is easily expressed by documenting a return value of `null` (as opposed to `mixed`), and it can be inferred by the reader that a function that always returns `null` is semantically equivalent to `void` without lying to them by claiming that it returns `void` (which PHP is incapable of). &gt; If accepted, this RFC would be immediately used. It would trap errors where people attempt to return something for functions that declare they return nothing. Hinting a return type of `null` would do the same thing without lying to the developer. There isn't a meaningful difference between "will always return null" and "returns nothing", anyway.
Internal functions not actually using their publicly documented signatures is such a PHP-specific WTF, it would actually be quite funny if it wasn't so sad :(
I agree that this is how is should theoretically work (except for lines 3-4, that's up for discussion), but at the same time I think the implications of such change would be too big to be covered by this RFC. I personally don't see people agreeing on PHP now having void functions (instead of null functions masked as void). But I may be wrong and the actual implementation could be feasible. Any internals person could comment about the complexity of this implementation?
&gt;I'd be laying on a beach sipping margaritas all day **while** commenting on reddit. FTFY
No, this RFC doesn't change what your function actually returns. This is still what you would get after it was implemented: function foo() : void {} var_dump(foo()); // null And that makes no sense. Now, if the RFC were to be modified such that using the return value of a `void` function in an expression context produced a catchable fatal error, then it might make sense. However, this would still lead to disparity between how PHP internal functions are documented to behave and how equivalent userland functions behave. And the only way to resolve that is breaking not-insignificant amounts of BC by changing all those `void` documented functions to produce the same catchable fatal errors when used in expression contexts.
Because PHP will still return `null` to the calling code for a function that's hinted `void`. The fact that you're unable to return anything explicitly from such a function does not change that. The only thing that can sufficiently abstract away that problem is if using `void` functions in expression contexts produced fatal errors.
&gt; Actually, there is a way to fix that without BC breaks. Simply update the documentation and replace all instances of void with null, which would actually fix the documentation, since PHP functions are not capable of not returning anything. And this is why I don't think `void` is a useful concept in PHP. A return type of `null` (as opposed to `mixed`) is semantically equivalent to `void` already, while simultaneously being technically accurate. IMO, allowing a return type of `null` in PHP would solve the same problems `void` tries to, without lying to the developer: function foo() : null {} var_dump(foo()); // null function foo(): null { return 123; // catchable fatal error } function foo(): null { return; // no error } function foo(): null { return null; // no error - this is the only case that differs from the RFC }
and by kill it you mean kill the process and restart it? not restart the server itself? as in once you kill the process the OS frees up any memory associated with that process?
Well, we can go round and round on what's better for users, but the fact of the matter (and only point worth considering, AFAIC) is that if this RFC were implemented, `void` functions would still return `null` values and that doesn't make sense.
&gt; but I think adding an actual void type would at most require a new field in the zval struct It wouldn't, you'd just prevent function calls to void functions in expressions. That causes problems, though.
Thanks for the suggestions. Will definitely look into it. But as I mentioned in my blog post, learning a new framework or extension wasn't feasible at because if tight timeline. So I decided to go with my own, quick implementation.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Entity component system**](https://en.wikipedia.org/wiki/Entity%20component%20system): [](#sfw) --- &gt;__Entity-component-system__ (__ECS__) is a [architectural](https://en.wikipedia.org/wiki/Software_architecture) pattern that is mostly used in game development. A ECS follows the [Composition over inheritance](https://en.wikipedia.org/wiki/Composition_over_inheritance) principle that allows greater flexibility in defining entities whereat every object in a game's scene is an entity (e.g. enemies, bullets, vehicles, etc.). Every Entity consists of one or more components which add additional behavior or functionality. Therefore the behavior of an entity can be changed at runtime by adding or removing components. This eliminates the ambiguity problems of deep and wide inheritance hierarchies that are difficult to understand, maintain and extend. Common ECS approaches are highly compatible and often combined with [Data-driven programming](https://en.wikipedia.org/wiki/Data-driven_programming) techniques. &gt; --- ^Interesting: [^Entity–relationship ^model](https://en.wikipedia.org/wiki/Entity%E2%80%93relationship_model) ^| [^Entity ^Framework](https://en.wikipedia.org/wiki/Entity_Framework) ^| [^Legal ^personality](https://en.wikipedia.org/wiki/Legal_personality) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+colhjvk) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+colhjvk)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I am 100% behind it from a userland-library point of view. It has the possibility to detect nasty errors in your code and makes it even more self documenting. Also, more "strictness" seems to be the way to go these days \*looking-over-to-the-other-rfc\*. However, as some also mentioned here and over at the mailing list, the *consistency* and *compatibility* with built-in PHP methods is really bad and this RFC does not address this issue properly. And this part bugs me the most: &gt;It accepts either an implicit return, or an explicit value-less return: &gt; function lacks_return(): void { // valid } lacks_return(); &gt; function returns_nothing(): void { return; // valid } returns_nothing(); &gt;However, it does not accept returning a NULL value: &gt; function returns_null(): void { return NULL; // Catchable fatal eerror: returns_null() must not return a value, null returned } returns_null(); As this seems counter intuitive to me: lacks_return() === null; // true returns_nothing() === null; // true returns_null() === null; // error, wtf?! A solution would be to prohibit reading (or writing in reference contexts) these return values. Which in the end is more annoying the programmer instead of helping him. One question here in the end: is this all done call or compile time? As compile time would be very nice and actually would provide a benefit, whereas call time would lead to hard to reproduce errors, when you just "sometimes" have a return value by accident, e.g. after migrating old codebases.
If `void` is to be a thing, then I agree, but the current RFC leaves this hole open, so I'd still protest it, as-written. However, we can skirt the problem entirely with a `null` return type, which would be superior to `void` in every way that I can think of.
Typing void in a docblock and returning with `return;` already behaves like returning null. With this RFC, moving the void from the docblock to the function signature doesn't change that behaviour.
intersting. Id imaging it would work like this, i would run the child process every 2 or 3 mins or so. it would do its calculations every iteration and then it would be killed and restarted. So the child process itself will never be running infinitely, just the parent. So that should be ok on memory. If i used cron scheduling or something, it could run the process over and over again, and the associated memory gets dumped at the end of each run. But if i understood you correctly, the Daemon process still needed killing after a couple of days due to its own memory hogging? how can this manage itself? as in, it sounds like i might need to have a scheduler restart the Daemon process, but then that scheduler may have its own memory hogging issues! 
No, not useless, but it's a half-way solution. It doesn't behave like how void should behave in any given language. That's why I was initially against (I'm for it after reading Anthony's post) your scalar types RFC as well, I'm so tired of seeing half way solutions get proposed as RFCs. PHP7 is the one big shot where the language could jump leaps and bounds ahead and finally become a somewhat properly designed language. People really shouldn't be scared of upsetting the status quo. After all, that's how real progress is made.
Out of curiosity, what don't you like about Smarty?
First of all, you should really run a blog through grammar checking before publishing it. It takes like 10 seconds. A lot of spelling and grammar mistakes throughout. I'm assuming this is an ESL issue, but it's still easy to do. It's just distracting. &gt; All good programmers I know are good because they loved what they did. Seems like a sample size issue. I know plenty that don't really like it and can code circles around me. &gt; You MUST participate in some free software projects. Egh? Strongly disagree there. Then we have these quotes: &gt; You are not a programmer if you have not read that book. Period. and &gt; (dont forget to first slap yourself for not knowing who Eric Raymond is and then googling his name) and &gt; (If you don't know who they are, do this 1. Slap yourself 2. Google their names). and &gt; And if you think this book is tough for you, please do not harbour any misplaced desires of being a good programmer and do not waste your time by reading this post further. It comes off as very condescending and aggressive. I realize it's an opinion piece, but still...the tone needs work, imo. Beginners are going to be put off by it and long time programmers are going to find it arrogant. Who's your target audience?
&gt; Another RFC can come along and fix that issue, if it needs fixing. RFCs are atomic, and we should not push one through if it doesn't make sense without further changes to be made in a hypothetical future RFC. I would say that's certainly the case with this RFC. &gt; Ultimately we could also just say void and null are equivalent the way that int and integer are equivalent. And just use which ever one expressing the intent better. Well, "always returns null" is semantically equivalent to "returns nothing". So, let's just give up on `void` and push for a `null` return type instead. It comes with all the same benefits, and none of the drawbacks.
It's not about "upsetting the status quo". It's about not breaking things. It's about consistency. It's all very well to say "a language should have XYZ feature" when it's a new language, when you have the freedom to change the rest of the language to work nicely with it. PHP doesn't have that freedom. Changes must be evaluated within the context of the rest of the language. We can't do massive breakages except in very limited circumstances. We shouldn't introduce things which interact poorly with other language features.
How is that any different to function foobar(): array { $a = usually_returns_array(); return $a; } ? 
&gt; See there's my objection. If adding a full-fledged, well-designed feature interacts poorly with other features that have been there since the PHP3 days, those features should get canned (or at least deprecated), not the new feature. But now you've broken loads of existing code and nobody will upgrade. Also, those features aren't necessarily "bad" or "wrong" or whatever. They may be well-designed, completely functional, good design decisions. That doesn't mean they interact well with a new addition. &gt; Also, please don't downvote just because you disagree. I don't care about the imaginary points, but I do care about actual discussion getting buried. Some points are reasonable, but I'm not convinced this discussion is. You're complaining that we have to maintain backwards-compatibility, essentially. That's not a useful contribution.
I think it's odd that a person who says he himself is not a good programmer, would offer tips for how to be a good programmer, with so much apparent certainty, and arguably, arrogance. 
Our daemons run for weeks. We only restart when we deploy an update. We also run about 15 daemons all using nearly the same daemon class posted. Each daemon consumes about 150k of memory. Our daemons also vary in how many children are executed. Some will continuously fork off 4-8 children.. some only 1. Were very pleased with our implementation to tell you the truth. It also sounds like your requirements are easily satisfied 
All of these braindead RFCs... from the spaceship &lt;=&gt; to *void* return types that are really nulls... I can only hope HHVM decides to break compatibility at some point and not implement ALL of these horrendously braindead ideas. Sheesh!
This is the only tenable solution without changing core PHP conventions since The Beginning, which may not be bad, but requires another RFC, not this hybrid logical fallacy.
One advantage of this, if they allowed overwriting all the values, is you could use it to implement source maps. If you create a language which compiles to PHP, you could override the file and line numbers of errors to map to the original source. 
I personally like monit because it can be instructed to kill and restart processes that go over defined resource limits. The logic of dealing with runaway processes is kept independent of the process itself.
&gt; You don't have to break any code, that's what deprecations are for. You could deprecate PHP n features in PHP (n+1) and remove them in PHP (n+2). This way, everyone gets years to upgrade their code. You're still breaking things. &gt; Properly designed languages might have the luxury of never ever breaking BC, but those like PHP with a horrible past should not shy away from breakages once or twice every decade, until all the cruft has been removed. Read what I said before: &gt; Also, those features aren't necessarily "bad" or "wrong" or whatever. They may be well-designed, completely functional, good design decisions. Who says these are incorrect features? &gt; No, I'm complaining about maintaining PHP 3 &amp; 4 features in 2015. That's the same thing. It's backwards-compatibility. PHP 3 and 4 features make up the vast majority of the language. &gt; That is even beyond long-term support. Why? Merely because something is old, does not mean it is unsupported. &gt; Nobody does that and when I look at internals, those who are vehemently against dropping PHP 4 features are, surprise surprise, people who have written those very comically-stupid features all those years ago Who said all these features are comically-stupid? You are assuming anything that conflicts with a new addition is a bad thing. That's not true at all.
Right, that's what's in the RFC is proposing. `return NULL;` throws an error on a function with a void return type.
If you're in a long running process, why not? 
Nobody's said anything yet about the bigger problem here, which is that you're working *for goddamn free*. Come on man, you might be pretty junior but that's no reason to not demand fair compensation, they are profiting off of your labor! Also what on earth is your living situation that you can even afford to work for free?
we do this by posting php closures to a queue using the excellent [SuperClosure] (https://github.com/jeremeamia/super_closure). the queue itself could be anything really, beanstalkd, rabbit, even mysql could work in some applications. the php worker just executes anything you push to the queue, which is pretty convenient: while(1) { $job = $this-&gt;pheanstalk-&gt;watch('default')-&gt;reserve(); try { $unserialized_task = unserialize($job-&gt;getData()); $unserialized_task(); $this-&gt;pheanstalk-&gt;delete($job); } catch (Exception $e) { $this-&gt;pheanstalk-&gt;bury($job); echo $e-&gt;getMessage(); } $memory = memory_get_usage(true); if($memory &gt; 5035144) { exit; } usleep(10); gc_collect_cycles(); } the worker process is kept alive with supervisord, which can spawn as many workers as you can spare processor cores. 
But I never advocated throwing it out! I said it show be replaced, slowly, over time, with well-defined and executed deprecation periods spanning *years*. Do you *honestly* believe that is unreasonable? You are one of the very few internals people willing to move the language forward, so please don't tell me you think that's not reasonable...
never a big fan of php for daemon related tasks... why not cronjobs? you mentioned that it takes no more than a few seconds to run. PHP's memory management is something you might have to worry about in daemons. If it must be a daemon, consider another language, Python is incredibly easy to learn. You can make a Python daemon that spins up instances of PHP processes that does the checking...
lol just wait til you have to maintain a legacy Smarty enterprise app built in the early 00's!!!
It's GPL'd, forget it. Better write from scratch with a less viral license. 
The caching is solid, but drop the filesystem and use redis or memcache (way faster). Also, anyone implementing this should abstract this into classes / methods so that they're not checking if a file exists every time they want to touch cache, etc. Finally- to anyone new to caching, take a look into Varnish + ESI. You'll see much bigger improvements.
&gt; This right here is why I unsubscribed from the internals mailing list and stepped away. Internals people (including /u/StiltonOnStilts) don't realize it, but this is exactly what pushes *a lot* of people from ever contributing to PHP. Personally, I'm familiar with Zend APIs and I maintain several proprietary PHP extensions, so I could *technically* contribute, but the very idea of having to defend my position over and over against the likes of Stas, Zeev or Andi and fighting back against the "we must be PHP 3 compatible!" rhetoric is enough to make me stay away. I know several people who feel exactly the same.
&gt; What about just leaving out the type to implicitly mean void? That doesn't look right to my eyes, I expect there to be a name there, but there isn't. &gt; If being explicit with a "void" return type is good, why not make void a reserved word and allow returning void explicitly? void is a pseudo-type (like C), you can't have a void value.
Doesn't `void` signal the intent better than `null`? 
No worries, feel free to press to your hearts content :) I was just amused by it, no big deal.
I love upstart - it's a shame it's getting canned in favour of systemd. Means probably a move to install supervisord. 
My reasoning here is that even though right now I'm not using a 5.5 feature, I don't want to prevent myself from doing so later. I started this project 3 days ago, so the implementation is still pretty fresh. Also I believe that new projects should be at least on 5.5, and I expect only new projects to use a new "framework/library" that was just released. I don't expect legacy application stuck on 5.4 to switch on a new micro-framework. And it's also about [sending a message](http://www.quickmeme.com/img/69/6965f101c112540f4f5154c0631551c5a3e1278af5b31a1f5fc762447a1b3234.jpg) ;)
Although the "yes" points are usually covered in the RFC itself.
Seems like systemd has most of the feature set of upstart covered. I personally don't have a dog in the system init race, but upstart certainly gets my jobs done and keep 'em running. Only annoyance for me is when an upstart job is depending on an old SysVinit job to have started (e.g. on CentOS beanstalkd is managed by SysV). Kind of a hassle to make that work reliably — or maybe I'm just doing it wrong. I'm not very familiar with supervisord but from what I can glean from its website it looks very neat and probably more suitable for OP's tasks than the system init.
You realize that Python memory management works essentially the same as PHP, right?
Using Doctrine Cache would have gotten you to the same result probably even faster. I mean it's just a matter of calling `$cache-&gt;set()` and `$cache-&gt;get()`.
&gt; where did I contradict that? You said "ensures it returns an array", I thought you meant it returns an array regardless. &gt; Why require returning a useless value? Never said an explicit return is required. This would be fine: function foobar(): null { dosomething(); } Null is always returned when there is no explicit return, why bother with a pointless 'void'?
There's a good video that discusses this stuff here: https://www.youtube.com/watch?v=4LyWoJLrj34#t=1235
I think implementing caching from scratch is a code-smell, given how many other frameworks and libraries are already out there.
The main issues are implementation-related, but I'm optimistic they can be resolved (I'm the RFC author). My main concern is I'll miss a few spots in 7 and they'll need to be cleaned up in 7.0.x/7.1/8.0.
I like to imagine the reasoning is [something like](https://en.wikipedia.org/wiki/Rorschach_(comics%29): &gt; The "modern" PHP frameworks are extended gutters and the gutters are full of blood and when the drains finally scab over, all the vermin will drown. The accumulated filth of all their abstractions and namespaces will foam up about their waists and all the FIG members and ex-Rails developers will look up and shout "Save us!"... and I'll look down and whisper "No." 
I have 10 - 15 scripts that run periodically as often as once per minute. I would recommend using a cron job with a lock file that prevents multiple instances from running simultaneously. Then just have it start once per minute or however often it needs to run. Otherwise if you leave it running forever in a loop PHP doesn't seem to free up memory as it runs (maybe it does but it never appears to in anything I've done) and you'll eventually run out of memory. It will crash hopefully before it causes your server to thrash. But if it doesn't prepare to ened to reboot periodically.
I don't know if I am missing the point, but why not cache the generated result? For example, use a super light weight while loop script to exec() invoke the 40 seconds script, cache it into another database, so each time it finishes the execution, the output gets cached, and memory gets freed. Because exec() starts a new process, each time the big script runs, and consumes memory, it will not affect the parent script. We use Gearman to queue up time range and scrape a large API using this method, and the parent script runs for weeks without having to restart.
Well Id say its necessary to wait till the voting is completely finished, since with the way it currently stands, a lot of things can change still. Still 4-5 days to go, we will see. 
Before that, they might consider suppprting appostrope charecter. "I should=E2=80=99ve done this a long time ago"
Hence added post script to the blog post. As I said, only motive of the blog post was to make those people understand concept of caching who doesn't have any idea about caching. :-)
looks good. thanks for sharing.
I agree. My implementation is dirty. There should be a proper abstraction to caching methods, so that your code is maintainable and changing your caching algorithm doesn't make you pull your hairs. My examples were plainly for explanations of how one can implement caching inside their applications. :-) 
memcache or APC will not work AFAIK. But you can use similar techniques like I explained in blog posts, it only needs you to have write permissions in cache directory.
First lets start with why you are trying to compile from source? Is this just for fun or are you trying to solve another issue?
This is an email/MIME thing, not a PHP thing... although that list viewer could probably parse the characters to display in a better format. `E2 80 99` is the UTF-8 hex for a right single quote. It becomes `=E2=80=99` because an equal sign followed by two hex chars gets encoded as a byte, per [RFC 2045](http://www.faqs.org/rfcs/rfc2045.html). Check out [this stack overflow thread](https://stackoverflow.com/questions/15621510/how-to-understand-the-equal-sign-symbol-in-imap-email-text) for a better explanation than I can offer.
Have you considered asking them why instead of sitting around here raging? It could be that there's just a fault with the RFC as it is now. In any case, my hat is off to Andrea. Win or lose, she's really trying to make a difference. Here's a person who is not only writing the RFCs, she's putting her money where her mouth is by writing the patches necessary to make the dream a reality *before* the RFC is even passed. That means something to me, and it should mean something to all of you.
I strongly recommend not writing it in PHP, if its business critical then even more so. 
Could you set up a demo?
I am trying to get comfortable by compiling from source so I can alter the source code of PHP, adding features such as anonymous class, C# property accessors. Maybe it seems incomprehensible to you, but I do want to play with it and see if there's something useful I can come out with. On a side-note, compiling PHP on linux is very easy and straightforward, although since bison 3.0 releases it has been a bit tricky to get PHP 5.5 or below working. Compling PHP on windows though, its so difficult and it confuses me like no end... *sigh*
Why do you want to alter the source code? To improve php, or to create your own build with your own features?
Why is this important to you? I am not saying PHP is bad, otherwise I wouldnt have used it in the first place. 
They already do support Docker through Elastic Beanstalk. We've been going through that process ourselves.
Why? So you can have a vote based on a bunch of uninformed opinions? Most people here don't know enough about PHP internals to understand what any given change might entail.
This is a web application I wrote mostly for my own amusement, but since I though someone else might find it useful too, I decided to share it as well. Basically, it's a web app that generates RSS feeds from Packagist profile pages and tracks the number of downloads on each package. RSS feed entries are generated when the download counts change, which allow you to use a RSS reader to track these statistics. It's a simple application, but I wanted to create it, because I kept checking my own profile to see if people actually started using my libraries. As an example, here is the feed generated from my packagist profile, that I've been following: http://feed.riimu.net/packagist/feed/riimu/ The source for the web application is also available at [Github](https://github.com/Riimu/packagist-stats-feed), if you would prefer to run it on your own web server.
Getting a bunch of [this](http://feed.riimu.net/packagist/feed/mnapoli/): &lt;b&gt;Notice&lt;/b&gt;: Undefined offset: 1 in &lt;b&gt;/home/riimu/feed.riimu.net/packagist/app/Feed/PageParser.php&lt;/b&gt; on line &lt;b&gt;37&lt;/b&gt;&lt;br /&gt; Also the XML doesn't contain the download count as a number, it's only a string like this: &lt;description&gt; PHP-DI is a Container that makes Dependency Injection as practical as possible in PHP&amp;lt;br /&amp;gt;&amp;lt;br /&amp;gt; Downloads: 58,358&amp;lt;br /&amp;gt; Stars: 2 &lt;/description&gt; No easier to parse than the actual packagist HTML page, or am I missing something?
Packagist exposes the download counts via a JSON request anyway.
Wow. The branch/patch looks quite encompassing already. But I wonder if keeping two backends isn't a maintenance chore. The GMP mapper is quite slim of course, but like the RFC said won't be favoured anyway. Why not concentrate on libtommath, or rather build against tomsfastmath alternatively? Couldn't that simplify exposing a few of the more fancy algorithms as userland functions later.
Add Stas and Andi to that list and we have a group of people who were quite happy with PHP4 and just wish everyone stopped adding stuff to *their* language.
Exactly this. Btw, I'd also like to open a new informal vote thread for "RFC: Void Return Type" as it's very closely related to this one, but I don't want it to be considered spam. There have been 26 votes in less than 2 hours, and given that it's Sunday and midnight in the US I think it will increase considerably in the next few hours. Would you people oppose to that? What number should be used as a "green light"? 100 votes? 200? More?
[This seems to indicate that you can just use the RedHat docs for the most part.](http://unix.stackexchange.com/questions/101868/where-are-the-centos-6-4-documents)
&gt; Anything else is at best a setback, and at worst a complete failure. It isn't really like that; Every RFC that is refused becomes valuable research for how *not* to do things in the future. If this RFC fails, that's not the end of the subject at all, it never is. There is a lot about this RFC that is good, there seems to be very little resistance to the base idea of having a nearly full set of type hints, the first revision that only implemented dynamic hints was very well received. I think if it weren't for the strangeness brought about by declare, it's possible strict hints would pass. tl:dr This is fixable.
Why do you think it *needs* them? Seems to work great without them for me.
YES.
&gt; But isn't that a chicken/egg problem? If people were able to do bignum operations transparently, they would start using those features. I don't think so. You can already use bignum operations nearly transparently with GMP. I've used GMP numbers very extensively in the past and since PHP 5.6 consider them to be quite ergonomic. If I happened on any issues with GMP, it was because some library function was not exposed (e.g. gmp_root and gmp_random_bits, two more 5.6 additions), not because it was inconvenient to use. &gt; Also, this RFC fixes one of the biggest WTFs of PHP. Namely, auto (and silent) promotion of integers to floats. What's the big WTF with that? I'm not sure I would call this a WTF at all and it's certainly not very high up if you compare it with all the other PHP "goodies" :) From what I've seen, most of the issues PHP developers have with floats are not caused by overflow of very large numbers, but because many devs don't grasp the rounding behavior of small numbers that is caused by limited precision. &gt; It might add additional complexity for internals, but isn't that the whole point of a high level language? To abstract away complexities from userspace? Most certainly! As I've said, this is a tradeoff. How much complexity are we willing to introduce in the implementation to reduce how much complexity for our users? People have different views on how much "complexity" this would really save for the user and how much actual practical impact it would have. People also differently value the implementation complexity of this feature - It shouldn't be very surprising that engine developers might have a somewhat different view on this than people writing docs ;) Disclaimer: This is not necessarily my own opinion, I'm trying to provide some broader context here as to why some people may not like the proposal.
I was actually for this RFC until a few days ago. Read a comment here on how a keyword to classes/functions (strict) could be used over the define method. That is what I would rather see. For now, I'd rather it fail so we can explore more syntax choices. Define doesn't seem right anymore.
&gt; I've used GMP numbers very extensively in the past and since PHP 5.6 consider them to be quite ergonomic OK, realistically, how many people are on PHP 5.6? How many of those have GMP installed? How many of *those* have it enabled? I think the combined number of users in that group is so small it could as well be a rounding error. On the other hand, if arbitrary precision arithmetics were part of the standard library, that number would be 100%. &gt; I'm not sure I would call this a WTF at all Really? Doesn't the following look like a WTF to you? $a = PHP_INT_MAX + 5; $b = PHP_INT_MAX + 10; var_dump($a === $b); // returns bool(true) &gt; It shouldn't be very surprising that engine developers might have a somewhat different view on this than people writing docs ;) True, *certain* engine developers might have a different view here :)
I looked at TomsFastMath, but it's fixed-size. It doesn't let you dynamically grow an integer's size, so it's not workable for PHP's needs. Having two backends could be a maintenance pain, but PHP can always drop one if necessary. The main reason for not using GMP by default is that it has licensing issues, but I suspect distros and such would probably use it. EDIT: Also, so far it's been alright. It's all abstracted and you're unlikely to need to touch this code once written, except for performance optimisations.
I see what they mean by LibTomMath being very liberally licensed :D https://github.com/libtom/libtommath/blob/develop/LICENSE
&gt; line with the way PHP currently works When put that way, I apologise for any misunderstanding on my part.
There are quite a significant number of people here that understand these changes as well as anyone else. In fact, quite a large number (most?) of those who actually voted on this RFC aren't even internals folks. They're just people from the community (like everyone here) who earned voting karma one way or another.
Silly question, why not use a VM? &gt; On a side-note, compiling PHP on linux is very easy and straightforward, although since bison 3.0 releases it has been a bit tricky to get PHP 5.5 or below working. Set up a Debian/Ubuntu VM, share some folders that contain the php-src, and compile it inside the VM.
GMP isn't without use, but we shouldn't need it just for large numbers in the first place. My comment was more about how you're using GMP as an excuse to shoot down a proposal that eliminates the need for it in many cases. Replacing it with something that is more elegant improves the language. It'd be like saying we already have array(), so why bother with short array syntax?
I guess I just disagree with the premise here. I *do* think that the existence of a bignum implementation in PHP, which works fine without highly intrusive engine changes, is a good reason to decline a secondary implementation of the concept. The short array syntax imho is a very different case - it's literally a two line grammar patch.
The benefits are: 1) Static analysis tools can more easily detect errors before run-time. So you are sure as you write that things will work instead of it being mostly hoping until you run it. 2) You save a lot of boilerplate by simply catching the generic exception(s) generated by type hint errors instead of writing your own, using it, checking and then throwing the exception. It isn't like it saves developers 20 lines of code on a project (unless it is really small.) You can potentially save hundreds or thousands if the codebase is large enough.
If by "we" you mean, you're going to dedicate the time to doing that then do it! There is some serious bickering over null and void but they are a but different. If you're always getting a null then you might as well just call `$foo = null`. A null is a value, and a void is a lack of one. The lack of a value is a sign that the function is more about actions than results, but either way, either would do the trick. Erring on the attempt to store a void is whatever, who cares. Don't pile other comments in with your frustration of the RFCs existence in general. 
Actually the entire point of *all* of those features is to type *fewer* characters. - **Scalar Objects**: Let's me type `$items-&gt;map(...)` on a regular array, instead of having to define an entire class that wraps arrays so I can use a more object oriented syntax. Less code. - **Real Closures**: Now I don't have to type `use ($foo)` to import the surrounding scope. Less code. - **Property Get/Set**: `$foo-&gt;bar`with the ability to intercept it in the class instead of `$foo-&gt;getBar()`. Less code, *and* I get to follow the Uniform Access Principle as an added bonus. - **Constructor argument promotion**: This one is just straight up less code, no real explanation necessary. I'm all for things that add convenience! :)
Correction! He makes the comment about 10 seconds earlier. 31m31s
PHP worked before they added classes. Or interfaces. Or namespaces. Or callbacks. Or generators. 
There is https://github.com/brianhaveri/Underscore.php which looks to do essentially that.
Getting tired of seeing all the posts about the Scalar Type Hints RFC. There are a number of voters who want scalar type hints but are unhappy with the implementation in this RFC. I don't blame them. The RFC isn't just about Scalar Type Hints and the code for strict typing doesn't even work well. I look forward to an RFC that is actually just about scalar type hints. Then they can continue to work on strict typing and vote on that one separately when it's ready.
Actually, I was referring to the fact that none of them offered functionality that isn't already possible in the language. If your support for new PHP features boils down to what's convenient, then you should be supporting typehints wholesale. :)
Wild sweeping generalizations that reek of ignorance. This is the programmer equivalent of Fox News.
You're telling me I've wasted all my time on here for nothing? 
And you posted this tripe, why?
It's not required though. That is overly timid, defensive code that shouldn't be written. Do you write that code in Ruby?
Type hinting doesn't add convenience for me :) Anyways I can't win this argument. The community just looks at me as some amateur who has no idea what he's doing because he likes dynamic type systems. I'd like to help educate people on the strengths and weaknesses of both type systems, because I think a lot of people are discarding dynamic typing wholesale as if it's automatically worse. There are a lot of real benefits to a static type system, but also to a dynamic type system, and I think a lot of people are expecting certain benefits from type-hinting that just aren't terribly real, especially in a language like PHP that's *still* dynamically typed under the hood. I fit in much better in the Ruby community where an RFC to add type-hinting would get me laughed out of the room :)
In pure Ruby I often have to be very careful. We had a problem the other day when a piece of input from the API could have been an integer or a float, and as such diving by an integer was producing a 0 result instead of a float. Changing it to `/ 1000.0` fixed that issue. If it was a string the whole damn thing would have fallen over. Ruby sometimes gives a fuck, and sometimes troops on. PHP never gives a fuck, and always troops on. In both cases of trooping on, production bugs can sometimes be the concern. In both cases, being a little more strict would have been just lovely at catching the issues earlier on.
Lol because I'm learning, and I haven't gotten beyond connecting to the database yet, obviously... =+) I think that fixed it, thanks.
Only from the database, not to the database, right?
&gt; Type hinting doesn't add convenience for me I don't believe you. And if literally none of the code you've ever written checks for type sanity (e.g. making sure you weren't passed an array of booleans or a file stream resource, when you were expecting a number), then you've been doing yourself a huge disservice, by not taking a pragmatic approach to dynamism. The right amount is great. Too much is horrible.
arafferty was probably your local username.
Thank you.
PHP is the only dynamic language in existence with any concept of "type hinting". You can write great code without it. When a parameter comes in, I expect it to be a certain type and I act on it as if it's that type. The is designed to only work with that specific type. The tests ensure nothing else is passed in. I make sure not to write code that passes incorrect parameters. I don't believe it has to be encoded in every function signature. In my experience, it is not a legitimate fear, and you are not protecting yourself from any real issues. Most type errors are from complex bugs that would not be caught in static languages either; runtime type errors occur in Java and C# all the time. They have value as inline documentation, but I think the level of "protection" you get is extremely over-stated. I don't personally need to lean on type safety to write good, dependable, and correct code. 
I think this post is a great idea and the post for the Void Return Type would also be great. If anything it shows what some of the actual PHP community thinks, regardless of their reasoning. 
Most of Reddit is pointless then. This is a subreddit about PHP. Why not get some PHP developer opinions on upcoming possible changes to their language? So a discussion is fine, but a little survey with actual pie charts, AND a discussion in the comments, is "fluff"? 
Please don't be swayed against this due to negativity. It is useful for many reasons, and there is nothing wrong with a quick poll to see opinions on the matter! 
Thanks everyone for participating! After 10 hours, there have been 152 votes and the post is sitting at 15 points with 78% upvotes. While the post itself doesn't look as an "approval" (low points and some critical opinions in the comments), it seems that some people *do* want to give their opinion about this subject. I may create a similar thread on the next big RFC voting phase (or anyone can do it freely of course!) to see if the interest fades or increases. I personally think it's useful to see the views of the userland communities, as we'll be ultimately the users of said changes. But if the results don't add meaningful data, as /u/SkepticalMartian says, then it'll be a small failed experiment. As always, please feel free to add your points of view. Thanks again to everyone to has participated, either in a form of vote or voicing his/her opinion in the comments!
Plus this RFC does have a strongly supported fallback vote that will make implementing this feature in future RFCs easier, so at least we have that.
me too. this is starting to get stupid, the real issues in php keep being pushed out as 'not bugs' while he good improvements are pushed out because... there are not even reasons
well, there's phpQuery, which does exactly what you described .. - PRO: really similar jQuery API - CON: dead project, many forks https://packagist.org/search/?q=phpquery
Ah right! Forgot about those humans ;)
This is true, but in real life projects portability between database platforms mostly doesn't matter very much. But being able to get job done more efficiently using native SQL capabilities matters a lot. In short - portability is not the only advantage for using Doctrine... :)
Thanks, exactly what I was looking for.
Thanks, exactly what I was looking for.
Meanwhile the 3 big problems i got are the only one that I would have needed to stop.
I did not have hardware failure. I had different brands of system failure.
Again, Meijer mentioned hardware failure. Also, I said "things like". I don't think you're taking the appropriate time to read what I wrote.
Are you actually using prepared statements now or concatenating the variables?
[**@stevescommits**](https://twitter.com/stevescommits): &gt;[2015-02-15 21:29:42 UTC](https://twitter.com/stevescommits/status/567073291160928256) &gt;I could find one I liked. Redis Status page: [*blog.steverobbins.name*](http://blog.steverobbins.name/php/redis-status/) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2w0ar8%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
We were so close to having scalar type hints!
Honestly I dont quite understand this, the votes are 67:34 as it stands, just one more vote can easily shift it to favorite position, or the total opposite direction. Its hard to tell, Id keep it till Feb 19, the date when it will officially end until making any judgment, like I said before. Too bad, the poll already ends, and we can only speculate whats happening behind the scene among PHP internals. I have no idea what happens, so I wont make any assumptions now, we will see. 
He never really left, just stopped interacting on the mailing list and put his RFCs through other people. Doesn't look like this is the same case.
Blog from 2011 that recommends XAMPP and CodeIgniter? Please delete.
You don't have to speculate "what's happening behind the scenes" - the internals mailing list is publicly available for anyone to read. The Scalar Type Hints RFC is one of the most voted on RFCs ever. The voting has been on a knife edge pretty much since it opened. In some ways, with such contention around the issue it might be a good thing for the RFC to get tweaked to make more people happier (if that's possible)
There's clearly more to this. One does not put in this much effort and get it this close to success to simply shut up shop and walk away. Some of this work has been highly politicised. Certain "original core contributors" implying their opinion should count for more (it shouldn't), suggesting that even if successful that the entirely weak option should be put to a vote (because manipulating the process to get your own way seems reasonable...), and throwing around boring FUD suggesting it will change PHP (as if change or evolution is somehow a bad thing). Add to that the weight of expectation from the community around this and you've got a massive amount of pressure. When an entirely voluntary thing starts feeling like a job it's understandable that people reassess their involvement. This is a sad day for PHP, and one hopes that it leads to some soul searching by certain members of the internals list.
Yep, being a dick when you're trying to accomplish something with a group of people is generally frowned on. Note that her blog post [PHP predictions for 2015](http://blog.ajf.me/2015-02-06-php-predictions-for-2015) is a bit dickish.
I think it was meant for some kind of joke and humor, at least to me. Maybe the two of us share a totally different mindset, but I wont be offended by a blogpost like that. 
Yeah, it didn't seem humorous to me at all, just cynical. Seemed like she was already fed up.
&gt; because it does I don't think that is an argument.
:-( Huge thanks to Andrea for all the work done to make PHP better over the years. It won't be the same without her but let's try to continue making PHP better.
While I agree totally I'm not sure if you're referring to others on internals, or people here/on the intarnetz? 
A little from column A, a little from column B. Mostly internals though, I suspect.
&gt; I seriously hope you aren't arguing that writing tests doesn't catch software bugs, because it does. I am clearly not doing that. The kind of testing to find the serious problems I have had would be mainly budgetbreaking. Akin to searching for every serendipitous possibility on every major project, which would be indefensible.
/u/StiltonOnStilts
Thanks, fixed. \^_\^
And you don't see the irony in writing tests to verify that the correct types are passed into your functions and claiming that typehints "lean on type-safety"? ;) We all end up doing various things to ensure code contracts are satisfied. It might materialize as tests, explicit type checks, typehints, etc. Ultimately, it's all for the same reasons.
I don't think that has anything to do with TDD. 
While I don't want to put words in Andrea's mouth (and if I did it would be "Later nerds!") I can't help thinking that this is less about taking time and more about wasting time. Knowing you were putting in massive effort to improve something you care about and were valued for it is one thing. Knowing you're putting in massive effort to improve something you care about, and then getting shat on and white-anted for it is nowhere near as appealing. With Andrea's leaving, PHP loses one of its best advocates for change and progress. Not only did she advocate, but she did it the right way - with patches and research, knowledge and RFCs. Her leaving is a great loss. This happens too much, progressive and active people lose patience with the "toxic kindergarten", leaving behind a steady core who actively fight changes to *their PHP*. You will be missed /u/StiltonOnStilts
Theoretically PHP 7 goes into feature freeze just next month, fyi. Another proposal probably doesn't have time.
&gt;This is why being a dickhead about people who makes RFC's you don't like is a shit idea. Wait, what did I miss?
What bullshit. To quit is one thing, to quit in the middle of the voting phase for something that could have revolutionized php and retract it is another.
I blame the ignorant assholes, chief of who are Zeev and Andi who have trolled her from the beginning. Fuck them.
Thing is, it's not trolling. They honestly believe these things: 1) that they are special because they are the "original architects" (littered throughout their writing, their talks, their company advertising). 2) that any form of strict typing is "bad", even if it is entirely opt in and they never have to use or be exposed to it. 3) that people who disagree with them are against php's "philosophy" 4) that this "philosophy" is an entirely immovable object, except when it isn't (part of the philosophy is pragmatism.. but when a pragmatic solution to a complex problem is put forward it's contrary to the philosophy). 5) that people who want nice things should literally fuck off and use Java. All of these things in one way or another have been stated throughout "that thread". They are not trolling, they honestly believe these things. That they are better. I wouldn't be at all surprised that while most of us lament a great and sad loss to the internals team, those 2 are sitting in Zend HQ toasting their triumph over change...
Yes.
I think that's really the root of the disagreement. You don't want a "highly intrusive patch" for what I assume must be either "it'll break something" or "it'll make something more complicated". Are those real risks? Yeah. They are. I on the other hand think that if you're going to move in a better direction, you need to stop trying to walk on eggshells everywhere and take those risks. The short array syntax example was not meant as a comparison of code complexity, it was meant as a way to show you that small changes in syntax can have a large net positive effect on how people view the language, and their enjoyment of using it. So while it may have been a short patch, it was a very significant patch. I think we may need to agree to disagree here, which I'm OK with. I appreciate you taking the time to explain your point of view.
Here's a tip for free: Just because this is the way that Torvalds carries himself does not mean it's the only way to interact with other people. Or even the correct way. One can be critical of someones work without wearing them down with back handed abuse resulting in backing them into an "i quit" corner. And people can be incensed by such behaviour without being "social justice warriors" (which is such a bullshit loaded term that I wish I could down vote you twice, just for invoking it).
I'm with you here ... Also, when Zeev [says](https://twitter.com/zeevs/status/567088454669189122): &gt; I’m sure we’ll have scalar type hints in PHP 7. Either via the current RFC (improved for declare()) or another one he likely means the weak scalar hints that he favors. I'm not sure supporters of that idea are prepared for the torrent of NO votes from all the folks who believe *faux* hints are a *terrible* idea.
[**@zeevs**](https://twitter.com/zeevs/) &gt; [2015-02-15 22:29:58 UTC](https://twitter.com/zeevs/status/567088454669189122) &gt; .@grmpyprogrammer I’m sure we’ll have scalar type hints in PHP 7. Either via the current RFC (improved for declare()) or another one. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
The amount of time an RFC vote gets canceled before it gets finished is becoming a trend.
Oh I was completely unaware. That makes me mad. Especially since the whole point of voting rights based on contribution was to make sure people have "skin in the game" before allowing them to vote. The problem though isn't so much that he has a vote. He's one vote amongst ~a hundred. The problem is the politicking. He carries a lot of influence, and he plays a very good political game. He was highly successful in stirring up FUD over this (and other) RFCs, enough to convince others to vote it down. FUD about breaking PHP's philosophy. FUD about declare(). FUD about how unfair it was that the "weak only" RFC wasn't put to a vote. All of these things I am sure have had some influence on some decisions, even if only subtly.
As much as I may agree with your assessment, calling people *"ignorant assholes"* is exactly the type of behavior that drove Andrea away. It doesn't make it better just because you might be correct. I'm sure the folks who misused Andrea thought they were righteously justified as well. Try to keep that in mind ...
Seriously, this internals group needs a fucking attitude adjustment when it chases off someone like Andrea. Honestly the **complete bullshit** that goes on in internals is the reason I don't get involved myself. Too many relics who have outlived their usefulness in there but still have massive sway over everything. So while I'm actually saddened that a great programmer and advocate like Andrea is moving on, I hardly blame her. Given the mountain of stupidity you have to deal with when trying to operate in a "software by committee" environment that contains toxic elements (read: people), I'm (in retrospect) surprised she didn't move on sooner.
I agree. It's the attempt to cow others that bothers me the most. I've committed +6,000/-2,400 lines to the project over the last year and every time someone plays the *"longtime contributors"* card it makes me question whether I really deserve any say in issues on which I'm perfectly well qualified to vote. So ... just imagine the effect those FUD arguments have on a voter who isn't a C person and volunteers lots of free time contributing to the manual (for example).
There are a few people in internals that nearly all developers find idiotic, and Zeev is their emperor. I would be upset if we didn't have hacklang. Thank god for Facebook. I'm done with PHP too, it's beyond saving.
Correct. They are not assholes for disagreeing, having an opinion and being passionate about it. They are assholes because they acted like...well... assholes. 
What is the easiest way to familiarize myself, with how php works behind the scenes? I know, I should learn C, and I've been trying to grasp the basics for a while now, but it seems hard to understand the source with little knowledge. What I am looking for is not how to create *your-first-extentsion* or what *zval* is.. I've tried those, I like to know the blueprint or the main components, what/where is the zend engine.. what does it do.. I am looking for soft and basic definitions of the interpreter.
Can you blame her? Imagine having Zeev criticize all your code for two years. 
&gt; This is why being a dickhead about people who makes RFC's you don't like is a shit idea. Except she said that wasn't the reason. Edit: to be clear I'm referring to the fact that she's *adamant* it's not due to the community/internals. I prefer to take her at her word instead of assuming she's lying.
I'm actually somewhat surprised that PHP hasn't been forked yet. It's only a matter of time before the balance between the community, who seem to have fairly coherent desires for the language's future, and the members of the internals group suffer a large enough schism to drive someone crazy enough to just apply all of Andrea's patches, clean up what's left, and put the thing out there. Either that or the internals folks step down off of their high horses and accept that perfect is the enemy of the good and forward progress is preferable to continuous debate and do it themselves.
I disagree. This just shows me how dedicated and passionate she is about what she does, and I see it as being quite irresponsible. If you're going to take time out of your own life to contribute to an open source language then you need to know what you're getting into and see it though to the end. Not quit as soon as you're getting started. Since everything she's now done as a personal achievement is now completely pointless, I don't really see the point nor do I really care. I just wanted scalar type hints.
&gt; What do people have against declare that can be fixed (besides removing it I mean)? One idea tossed around was not allowing `declare()` blocks to turn on strict mode for parts of a file: either you have `declare()` at the top of the file and it affects the entire file, or you don't.
why did the php internals were such prude dicks about the scalar return types? thats a no brainer, php will get a lot of benefits from that, it looks like they are trying to kill php and send everyone to hack
Exactly, so we don't need a new thread on r/PHP every 5 minutes with an updated vote count. They always seem to have the exact same discussions over and over.
Yeah, so far. But how much of that is in part because of how she operated. Had her scalar type hints RFC been just about scalar type hints, it probably would have passed. Instead she chose to push ideas that she knew were contentious.
&gt; why did the php internals were such prude dicks about the scalar return types? ~~Scalar~~ return types [passed without too much incident](https://wiki.php.net/rfc/return_types) and will be in PHP 7. Are you talking about scalar type hints? If so, there aren't very many (if any) people on internals who are against it. The point of contention is in its implementation: - Some people refused to vote for it unless it's strict for the caller (i.e. no implicit type casting at all) - Some people refused to vote for it unless it's strict for the caller by default (i.e. it should be `declare(weak_types=1)` instead) - Some people refused to vote for it unless the strict/weak opt-in/out was done in the INI file (i.e. they didn't want to put `declare(...)` on every file) - Some people refused to vote for it unless it has a different opt-in syntax (e.g. `&lt;?php strict` instead of `declare(...)`) - Some people refused to vote for it unless the strict type hints opt-in/out was removed entirely (but they still wanted weak type hints) 
&gt; She's asking people to vote for a language change that they don't even plan on keeping. HUH? The part that *may* change in the future is the nature of the switch (from `declare()` to something else). Not the concept. Not the 2-stage type system. 
I think this would a far more viable option if there was a foundation around HHVM/Hack. It being backed (and controlled) by a corporation does raise some barriers here. And raise some concerns for potential contributors (such as myself).
Yeah... but with the Hack transpiler available, the two biggest things Hack needs can be addressed without much fear/commitment: - The lack of libraries that take advantage of Hacklang. - The lack of IDE support. For the second one, FB has offered a TON of help to anyone trying to get Hack support in IDEs. And honestly, the question I would ask is this: At this point, is the possibility of what FB might do behind the scenes any worse than the state of PHP internals?
I think alternative syntax has been thrown around (use strict, or similar).
people are against it for a variety of reasons. Aesthetically it's pretty gross... but that aside apparently declare does not honour function scope either. 
Well I dont like using SSH, I'd rather have desktop-like access. But thanks for the link though, I will see what I can do. 
While we may never understand why Andrea decided to leave, I can only say that I believe her RFCs were pushing PHP in a positive direction. I'm extremely sad to hear she is leaving, and goddammit, I wanted scalar type hints. Andrea, thanks for everything you've done. You'll be missed, and I look forward to reviewing your future contributions, wherever they are.
OK but this one is still on the front page and has a lot of comments.
within a file you can flick it on and off as many times as you want. And if you turn it on within a function it remains on after the function... http://marc.info/?l=php-internals&amp;m=142336319118979&amp;w=4 
Completely the opposite: she tried to find a compromise for all variants between week and strict types. But many could not accept a compromise that was not 100% their wish. If designing a language by compromise leads to a good and clean language is another question ...
Complete dick? That's a bit of a reach. I thought it was quite clearly a tongue-in-cheek response. You're telling me that this subreddit is a lovely harmonious place where people are never rude about RFCs they don't personally like? 
No you're thinking the Zend Framework which began with PHP5 (but is made in userland). What Rasmus made initially (pre 3.0 PHP also known as PHP/FI) is noble but has nothing to do with PHP as we know it. Zeev and Andi have been involved since PHP 3.0 and they basically made 4.0 (which is PHP as we know it) from scratch: http://php.net/manual/en/history.php.php
It isn't a fork.
Oh but the mailing list is only one of the channels internal developers use to discuss and they have all reasons to keep it civilized (mostly). They also chat, IM, personal email. Go figure.
&gt; Both of those calls fail No, they don't. Only the strict one fails. &gt; the type hint doesn't fix that. Yes, it does. It's the only one that produces an error. The non-hinted function carries on happily by erroneously returning `int(0)` to the calling code. Hopefully now you've demonstrated to yourself why too much dynamism is bad, and why even proponents of PHP's dynamic nature (myself included) can get behind typehints. *Edit: That being said, you're only covering strict typehints here, with no regard to weak typehints (which would still fall victim to the same problem as proposed in the current RFC). I'd much rather we fix the type juggling rules in PHP and implement weak typehints, personally, but others disagree.*
I really like hack and hhvm however I can't seem to find anyone producing quality code or passionate around hack development. I released a simple router a while ago to test the waters and found not only 0 interest but 0 people who i could even talk to in the community. I am sure facebook is doing some cool stuff with it but I have yet to see any of it.
It's a bit disingenuous to state that "Zeev and Andi are the original architects of PHP" when they aren't. The link you posted states as much. Rasmus was also a core contributor to PHP 3 (again, your link states this). PHP 4 had a complete rewrite of the engine, dubbed Zend Engine. The *language* was still PHP, however. Given that Rasmus is still an active contributor to the language, it's not inaccurate to state that he has contributed to PHP 4 and 5 as well.
And how is that much different than the way that PHP is controlled by Zend and some of the original contributors? 
Civilized "mostly" my ass. I've seen internals developers call contributors retarded.
&gt; the real evil here is PHP's silent casting weak typing crap *Some* of its casting rules are to blame. If we could fix the ones that don't make sense, then it would be a lot easier to rally people behind weak typing. That would *not* remove the need for typehints, though. You still don't want it to be possible to do things like pass an array of booleans or a file stream resource to a function expecting a number, for example. It just doesn't make sense. Yes, it would eventually end up producing an error *in most cases* either way, but *what* that error is and *where* it occurs can matter significantly for debugging purposes.
The event handling in particular is still limited/barely existent but the async is working: http://hhvm.com/blog/7091/async-cooperative-multitasking-for-hack http://docs.hhvm.com/manual/en/hack.async.php
I'm just saying what I'm sure many of us are already thinking at this point. Something needs to change. Look around. I'm hardly the only one with this sentiment.
I personally prefer http://simplehtmldom.sourceforge.net/ But I am not sure if this composure package is same as the above one: https://github.com/sunra/php-simple-html-dom-parser
Alas, we are but the unwashed masses.
Such as what? Becoming part of the circus that is internals only to get burnt out from beating your head against a wall erected by an elite few? I'm very curious about how openly discussing the problem is not constructive, or what you would have in its place that is more constructive.
Nice :) . Going through, I dislike the `user` folder name. It could have named `src` or something. The code over looks http://inkwell.dotink.org/docs/quick-start#DynamicURLs is bit disordered in style. A few questions that came to my mind are * Does the view variables are escaped by default? * Is there a way that people can create module and later reuse the same ? Thank you
A fork is not necessarily a fork of the source code, it can simply be a fork of the "language". And HHVM aims for 100% compatibility with Zend PHP.
&gt; nor do I really care. I just wanted scalar type hints. No offense, but that just sounds childish.
I genuinely think I will be doing so. Much as I dislike Facebook, at least it's run by grown-ups.
I agree totally here. Andrea's RFC was a model of middle ground. Everyone could have what they want. Everyone wins. And yet somehow...
I'm answering your above question here, as it's mostly relevant to the same topic: Firstly, the documentation is not 100% complete, but if you're particularly interested in creating custom components, opening an issue on https://github.com/dotink/inkwell-framework will get more attention paid to that particular doc over others. The general answer to your other question is. Yes, you can create modules and later reuse them the same way. Outside of the nano core, essentially all of the offical components are modules. For example, although this one is not included in the official components meta package yet, it will become the ORM component, but is basically just a wrapper / module for Propel 2 which provides a plugin configuration and action in order to bootstrap propel: https://github.com/dotink/inkwell-orm The only code that contains is wrappers to make the CLI commands not require propel's default configuration file (so the configuration gets integrated in the framework better).
I'm working on a fullstack framework. I'm always open to discuss Hack. https://github.com/titon/framework
I don't plan to have the component released until a final release. It was more just an example.
I should add that for JSON there's an outbound middleware of sorts at the moment that will run json_encode() automatically if the response content type is set to JSON, so for JSON objects, controllers and just return objects which implement JSONSerializable (http://php.net/manual/en/class.jsonserializable.php)
While everyone has answered this, and correctly, it should be pointed out that you're only receiving this error because mysql_real_escape_string() requires a MySQL connection, while mysql_escape_string() does not. Real escape leverages the MySQL connection in its escape functionality. But yes. Use PDO prepare to receive the PDO statement, then use PDO execute. It will escape your params for you, leveraging your connection. 
portability is not what you are looking for in real life projects. But the fact is that you have to activate dql one by one when using this project so it is not a big deal if some are noe available with your current platform
☐ Junior Developer ☑ Senior Developer
I cant say which PHP internals contribute more to the project, but I can tell that experience matters but is not everything. In fact, decades of experience can prove to be an obstacle rather than benefit at times. I know such a guy who has programmed 35 years since he was teenager. He started with COBOL, and eventually moved to PHP world when PHP 4 was released. His understanding of OOP is shallow and unconventional, and even now he is still unable to think abstraction. For him, years of old fashioned programming style, experience and mindset have made it impossible for him to adapt to the ever-changing computer industry. So all he can do is to maintain his legacy code and be happy with it, even now he still refuses to embrace Dependency Injection. So you see? People with decades of experience may not really be necessarily better than people with 3-5 years of experience. To me 5 years is long enough to make a solid contribution, if the experience is say 1-2 years its another story though. 
She has certainly contributed more to PHP than the original author of the engine, who [hasn't touched](https://github.com/php/php-src/commits?author=zsuraski) the source since the failed PHP6 days, *9 years ago*. Or the other original author, whose last relevant commit was [6 years ago](https://github.com/php/php-src/commits?author=andigutmans). Given that, if you think her contributions are not valuable, whose is?
PhpStorm will probably get Hack support in version 9, [early access coming in Q1 this year](https://youtrack.jetbrains.com/issue/WI-21737)
Didn't know she was a girl...
https://twitter.com/weaverryan/status/566990931413721088
http://lwn.net/Articles/633227/ Too much tension... 
Putting aside for a second that you seem to come to this subreddit nowdays to troll about how shit php is and collect down votes... I was pointing out what has been stated or implied (and then questioned and not subsequently refuted) on internals. I'm not, even once, suggesting I'm better. I haven't mentioned Gang of Four, or DI. 
I must say that this RFC was the reason that I followed the internal list a bit closer and I was really flabbergasted about how a Rasmus or Zeev handled the situation. Fear mongering, FUD and extremely arrogant and aggressive stance was a red thread in all those posts. It struck me a lot because I saw the talk of Sara Golemon at PHPBenelux where she painted a nice picture of Rasmus that he hates the BDFL title as he wants PHP to be more a community project. That is certainly not the feeling that I had after seeing those discussions and I don't think she will repeat that also after all that has happened. I personally don't mind that people have different opinions, but the way they handled it made my blood boil. In the end I was rooting for this RFC just to silence them. It doesn't surprise me one bit that talented people – which Andrea clearly is, from a programmer POV I have far more respect for her then those mentioned above - don't want to invest further in such a toxic environment. Granted it isn't the first time that this happened and unfortunately I don't think it will be the last. I also want to add that I really like PHP, but the fact that the language is riddled with design faults or inconsistencies makes that the “we are the original developers” argument is a bit moot. I certainly don't remember growing up as a developer with them as my big examples. I'm even beginning to hope that Hack gains more traction, something that was certainly not the case a year ago. 
Well, it seems it was OK for Google's SPDY → HTTP/2.
Aside from interfaces, those all actually add functionality. Type hints are documentation only, as are explicit interfaces. In Java or C#, interfaces add functionality by allowing polymorphism between two types that don't share ancestry. PHP already allowed that, so it adds nothing. It just lets you continue to do it should you choose to type hint. My main argument against type hints is that people think it actually has some affect on their code. If your code had a bug before you added the type hint, it still has the bug with the type hint. If it's a very specific class of bug (related to PHP's silent casting), you might get an error now where you weren't before. Otherwise it's the same. It doesn't enforce correctness. Type hints are inline documentation to make it a little easier to understand the code, but on their own they don't change what the code does. If I was passing the wrong thing before, I'm still passing the wrong thing after I add them. If you're system works, it should continue to work after you add them (as long as you aren't hinting concreteness where you don't want it, and adding interfaces for things you were previously duck typing). Code that is already well written and working gains no benefit other than documentation. Code that suffers from subtle bugs involving PHP's silent casting *may* reveal some of those bugs when you add type hints. If you value the documentation aspect a lot (I know you personally do Phil), then that's a fine reason for them. But to act like they somehow "improve the code" is unwarranted.
Well OK then. It's just she's very adamant in that post that internals are wonderful people.
Use the migration from Yii2 advanced template to create the user table: https://github.com/yiisoft/yii2/blob/master/apps/advanced/console/migrations/m130524_201442_init.php Create the User model which implements IdentityInterface. Look here for example: http://www.yiiframework.com/doc-2.0/yii-web-identityinterface.html That's all you need to get started. You can then create forms to register, login, etc.
&gt; but I would cut some slack to the guys who has to argue and reason with every wannabe contributor who want to get his patches approved. The particular "wannabe contributor" in question here was arguably the hardest working on the internals team. And she'd been committing changes and running RFCs for ~2 years.. hardly some "wannabe contributor". Also it's *not up to old guard* to chose what makes it or not. Theres a voting process. If it was run as a dictatorship (which one might argue may be a more successful model, but that's a discussion for another thread) you'd have a sliver of a point, but it's not. &gt; Source? Dig through the vote thread - Zeev points to the fact that the 3 "original" core developers are against it, and *strongly* implies that this should mean something in the face of what amounted to ~100 votes. Later, in the very same thread he laments the 2/3 voting rule, suggesting that it's intention was to prevent temporary majorities, not to be some absolute deciding factor. This intention is not expressed in any of the process documents, and was news to at least one person in the thread. He then states that the original weak-only RFC should subsequently go to a vote even if the 0.3 version was ultimately successful, which is rather disrespectful to the process.
&gt; She has certainly contributed more to PHP than the original author of the engine, who hasn't touched the source since the failed PHP6 days, 9 years ago. She has contributed more recently, but not overall.
This is indeed true, but it's still important to be careful - the GC is nowhere near as advanced as those found in Java or C# (not a slight - their design goals are different).
What's happened on internals? this seems like a very desperate outcry... I know they have a fetish for backwards compatibility, even when going to a major version bump (PHP7), but that can't be the reason for this, is it?
No way I'm ever going to use Eclipse again, I'd rather use gedit. If it works in PHPStorm though, that would be very nice.
I will, but not yet. &gt; HHVM on Windows is currently unsupported 
What makes you think Andrea is a drama queen? I've never got this impression from what I've seen of her (internals posts, Chat Overflow, various podcasts). What does Andrea's gender have to do with any of this? Andrea has been a massive asset to the PHP community, including the massive amount of work she's put into pushing the Scalar Type Hints RFC forward. Her leaving is a massive loss to PHP going forward.
I can recommend Vagrant for this (+maybe Laravel Homestead) or, as I currently handle it, use VMWare + Ubuntu + HHVM + nginx + Sublime3 (including the Hacklang Plugin) to develop.
Very different situation though. SPDY was an experiment to test the waters for a new revision to a web standard. PHP/HHVM are just languages/engines.
 echo strtotime("Beat") Why does the word "Beat" convert to a date, but other strings I've tried do not? What is the property of the word "Beat" (or "beat") that makes it a date? I am totally perplexed... 
I don't think Anthony wants to have his name on things anymore. 
&gt; If someone takes Andrea's patch and RFC and just turns off the strict things I wouldn't be so sure. I'm likely not the only person who thinks faux hints that don't actually do anything but cast (which you could easily do right now) are a terrible idea. They provide the illusion of safety without actually providing it. IMO this is the worst possible "solution" and I would vote "no" 100 times out of 100 unless cases like `(int) "apple"` were definitively addressed in a satisfactory way. Unfortunately, doing this would almost certainly prohibitively slow.
&gt; It would be nice if PHP had a "vision" or a direction of what the developers want it to be Zend PHP is about what the internals team can navel-gaze up without too much effort. HHVM seems much more about what programmers actually need from a language.
Zend has no authority over the project that the community does not give them. If the community decided that they collectively wanted Zend to have no influence, it would simply happen.
Having a vision only works if people are willing to accept that vision. Try this for a test, vision for PHP: no type-hinting. Your head exploding? It is a vision, it is a direction. Oh it is not the vision/direction you want? Gotcha. The thing to remember is that people are trying to pull PHP in different and conflicting directions and all got valid points. I feel that some who wish to pull it away from its template language origins are people who fail to acknowledge what made PHP the most popular language to begin with. I am sometimes reminded of the difference between Engrish (correct spelling, google what it means) and Esperanto. One is the global language with all its weirdness and the other has tried for decades to be and only a handful of people speak it. I wonder if Andrea had worked on the first PHP, whether it would A: ever been released or for ever been in development and B: whether it would have been as popular. Sometimes you need ugliness to get things done.
My floor is $40, and it works for me just fine. I agree that having to compete with the third world is godawful, though. I'd advise you to suggest to all your non-oDesk clients to hire you via oDesk instead (maybe just tell them to pay via oDesk as a one-time project) just to build a solid set of five star reviews. That should help in the long term, but yeah, it's a process, and a tedious one at that :( 
So what you're looking for is basically an overview of what the individual files in http://lxr.php.net/xref/PHP_TRUNK/Zend/ are for / which functionality they contain?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Swatch Internet Time**](https://en.wikipedia.org/wiki/Swatch%20Internet%20Time): [](#sfw) --- &gt; &gt;__Swatch Internet Time__ (or __beat time__) is a [decimal time](https://en.wikipedia.org/wiki/Decimal_time) concept introduced in 1998 by the [Swatch](https://en.wikipedia.org/wiki/Swatch) corporation as part of their marketing campaign for their line of "Beat" watches. &gt;Instead of hours and minutes, the mean solar day is divided up into 1000 parts called ".beats". Each .beat lasts 1 minute and 26.4 (86.4) seconds. Times are notated as a 3-digit number out of 1000 after midnight. So, @248 would indicate a time 248 .beats after midnight representing 248/1000 of a day, just over 5 hours and 57 minutes. &gt;There are no time zones in Swatch Internet Time; instead, the new time scale of Biel Meantime (BMT) is used, based on Swatch's headquarters in [Biel](https://en.wikipedia.org/wiki/Biel/Bienne), Switzerland and equivalent to Central European Time, West Africa Time, and UTC+1. Unlike civil time in Switzerland and many other countries, Swatch Internet Time does not observe [daylight saving time](https://en.wikipedia.org/wiki/Daylight_saving_time). &gt;==== &gt;[**Image**](https://i.imgur.com/ZMZPbDH.png) [^(i)](https://commons.wikimedia.org/wiki/File:Swatch_beat_Logo.svg) - *Logo of the Swatch Internet Time* --- ^Interesting: [^UTC+01:00](https://en.wikipedia.org/wiki/UTC%2B01:00) ^| [^New ^Earth ^Time](https://en.wikipedia.org/wiki/New_Earth_Time) ^| [^Internet ^time](https://en.wikipedia.org/wiki/Internet_time) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+con3am3) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+con3am3)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; If the community decided that they collectively wanted Zend to have no influence, it would simply happen. I'd like to test this theory ;)
I suppose you could use [checkdate](http://php.net/manual/en/function.checkdate.php) to validate it with some custom snippet, but beyond that I can't say. It would be interesting to findout though
I've been reading a few replies from Zeev today and without saying my opinion on the type hint rfc the only thing I want to say is that whoever is not evolving is doomed to die. I like PHP a lot and it's currently my main language but I don't like what I read today from the core devs. Too much arrogance, fixed views and unnecessary tension...if "community" is like this then, just let it go and move on to other languages
You deserve to be chased out of the community with an opinion like that. There is no place for people, who hold that opinion, in modern society. 
Please dont argue other peoples misunderstandings with me. :) http://blog.ircmaxell.com/2015/02/scalar-types-and-php.html Seen those examples? Those are the sorts of bugs that are absolutely avoided with type hints. If you pass in true or false and its expecting 1, 2, 3 but keeps on trucking then you've got some silently broken code. If that code instead says "Yo, we want an integer and you gave us a boolean" then you've got some fair warnings about having some broken code. That + our other conversation of if (! is_int($foo)) { throw something } being wildly inconsistent when implemented in userland instead of at a language level. Other people might misunderstand them or have shit uses cases, but that is not whats happening here. :)
Ah.. well, that's a shame, then. I think maybe you have a misconception about the purpose of typehints. They don't try to *prevent* developers from making mistakes. After all, you can still pass whatever you feel like into whatever function you want. Their real benefit is apparent during debugging when things go wrong (and they will *always* go wrong in an application of non-trivial size). With typehints, the error you get will be produced at the function call, and it will be blatantly obvious what went wrong: you passed in an argument of an unreasonable type. Without typehints, PHP will carry on into the function body, potentially doing all kinds of operations and adding frames to the callstack before finally breaking when (and *if*!) that unreasonable type presents an unrecoverable problem. How long it takes you to figure out that it was the original argument passed into the function that caused the problem depends on a lot of things, but my opinion is basically that "anything more than instantaneously is too long." It's not necessary for me to try and trace the problem back up through the callstack to the point of origin, or turn on remote debugging and step through the code and figure out what happened. If I typehint, PHP will tell me immediately what happened, with no debugging necessary. And all of this is assuming that PHP actually *does* break when I pass in something unreasonable. As is often the case, this may not even happen, and (due to some legacy/broken casting rules) PHP may *never* complain and carry on like nothing bad even happened (as you demonstrated before in your example). Now I have to expend a huge amount of time tracking down why my application is misbehaving, and I have nothing to go on other than "it doesn't work right." So, that's a very real benefit to me, and simply having `array` and class typehints available to me is already a big timesaver in my day-to-day. Having scalar typehints would be even more amazing, because these are the ones that end up producing the most difficult to track down bugs.
Go away.
&gt; An Active Record Post has no protected $comments = [] property. Adding a comment saves it to the database right away. This is fundamental to how Active Record works. Not so sure about this. At the very least, eloquent, and I'm sure others, use collections for relationships, allowing you to add(), as opposed to saving right away.
To be completely fair, using the proposed conversion rules for parameter types you get better behavior than doing `(int) $dunnoWhatThisIs`, since casting will always succeed even if it is nonsensical.
I should've been more clear: I did mean it would be difficult to make this happen in time for 7.0 ... though I'm starting to think I was wrong about this. You have to remember that 7.0 will not be out until mid 2015. So 7.1 wouldn't arrive until mid 2016. Now with the usual upgrade pace for hosting services you're talking about this functionality not really being widely available until 2017 or 2018. If we think the functionality is useful it would definitely behoove us to try to make it work in a satisfactory way in time for 7 ... However you bring up an interesting point. It's really more of a theoretical issue than one that really matters in practice, but the question isn't invalid: *"is it really sensible to check all the characters in a string until we arrive at something non-numeric when we could instead just check the zval type of the zval?"*
And what is calling somebody childish on the internet but childish? Especially without elaborating on how me wanting a proposed feature in the voting phase and getting upset because it was retracted a few days before it ended. That really doesn't make sense, and claims to a statement without any logical evidence is called an illogical argument, which has no grounds for a constructive discussion. So maybe if you want to start depicting how people are acting and telling them it's wrong you would like to explain why with a proper set of reasoning behind your claims. I'm love php, I'm upset about this, and it was irresponsible of the RFC creator to do what she did. I'm not wrong for having the feelings I do, and if I hurt anybody's feelings in the process then I apologize. My intentions should be clear, I'm upset about seeing a wonderful thing that could have made PHP a whole lot better and expressing why. If you have a problem with that or think I'm wrong, why don't you guys actually comment something along with your downvotes.
&gt; I'd like to test this theory ;) It's a matter of fact that Zend employees have 4 votes between them, the only thing they can do is try to influence the choice of others. It's interesting to note that Zend employees do not even act as one when it comes time to cast votes, they are not expected to act as one either, you quite often get dmitry voting yes for things the others don't like. If we ignore Zend, the sky doesn't fall in.
I have written some bash scripts that use ssh + rsync to do this. I would be happy to help with a script if you are working on one. That being said there are much better deployment tools. 
I don't want to take this off-topic, but there are also a lot of people (and this is true of any standardization effort) who aren't totally thrilled with everything about HTTP/2.0. There are some things there that feel like they really only help huge outfits like Google where the small performance margins matter. Those things push implementation complexity through the roof without providing much tangible benefit for the vast majority of applications. That said, it *is* a net positive. So take from that what you will.
That's because Zeev's vision of PHP is stupid. It wouldn't matter whose mouth it came from. 
Because HHVM exists now. This isn't some random speculation. I've seen it start happening at recruiters and companies I've worked with, and after this fiasco I'm moving my entire company's project to it as well. 
Ah, here's the sexist post I was expecting. 
If you are wanting to manage javascript/front end stuff you should use a package manager meant for that, not one that was rewritten in PHP for the sake of it. Bower or npm for JS packages/frameworks. Composer for PHP libraries/frameworks/goodies. 
It depends on 1. how much backward compatibility breaks PHP 7 ends up having, 2. whether there will be a substantial amount of confusion with the mass population of PHP users with "where is PHP 6?", 3. whether PHP 7 becomes some sort of bastard with tons of new syntactical cruft (&lt;=&gt; "spaceship operator", I'm looking at You!), 4. whether the current PHP type hinting debate resolves to something sane or devolves into the worst of both worlds no one is happy with, 5. whether there is a push by people fed up with either the Java-fication of the language *or*, on the other side, the adoption of insane RFCs (::cough:: &lt;=&gt;), *or* just general php-internals bickering, childish behaivors, etc. and from that come one or more forks of the language, 6. **WHETHER ZEND CORP. WILL GET OFF THEIR ASSES AND SERIOUSLY PROMOTE THE LANGUAGE TO ENTERPRISES, UNIVERSITIES, ETC.** But they haven't really ever done this so far. PHP is mostly word of mouth and entropy against change. 7. The state of Wordpress by 2020: It currently has 15 years of technical debt. It could be a SHIPWRECK of decay and rot by 2020, and could take down *over 50% of PHP installations* with it... 8. Whether the people who like "the Javafication of PHP" (::cough:: OOP) decide to ditch an as-yet ineffective Zend Corp., a rabble roaring php-internals, and a directionless PHP and embrace the existing alternative: HHVM and HackLang. Points 3, 6, and 7 are the most important, followed by 5 and 8. Really, your question and this comment are so important, they deserve their own /r/php post.
I haven't seen the repository pattern used in the way the author describes. In the case of Doctrine for example, the repository pattern is used to aggregate entities like a factory, not decorate active record calls. Is this a Laravel-derived concept?
I don't see strict mode being used, but at this point i will take any strict/weak combination as long as we get those fucking scalar typehints
&gt; Using bare class names as type hints is a potential issue too, as it makes reserved keywords and class names share the same naming space. I think we should deprecate the use of class names as type hints in favor of 'object(class-name)'. If we don't do that, every future addition of a type hint keyword will cause a BC break (and will be practically impossible). I understand where he's coming from, but that's going to break a *lot* of code and add to PHP's infamous ugliness and verbosity. Once you've picked the low-hanging fruit (int, bool, float, string, void, none, mixed) there aren't that many type keywords you'll need to reserve. There isn't much possibility of getting scalar type hints in 7 anyway, so we can probably mop them all up by 2020 or 2022 when PHP 8 comes out.
Good luck. While the move to HHVM is probably minor I wish you the best of luck. Then when you leave the company I wish the HR manager good luck too trying to come with a buzzword tech list to fill that no candidate can match. I seen it a lot of times before, I specialize in fixing damaged projects and the worst ones are were everyone is chasing the latest and greatest, half implements a solution they barely understand and then let it rot as they move on. Nothing better then when you see a simple project and it is chopped up in to 3-4 different languages, multiple frameworks and a host of storage solutions. Smart people in IT know to stay away from versions 1.0 or MS software until at least the first service pack. But hey, you go and chase the rainbow. Somebody has to be the trail blazer. If it is a success, be sure to write about it, so others can learn from it.
I think the more relevant question is "how should PHP behave in scenarios X, Y, and Z?" If we'd prefer PHP to retain some of its type-juggling behavior, then the question of whether it's sensible to check all the characters in a string becomes pretty moot, since it's *required* that we do so. The community seems fixated on the two extreme implementations, though. I don't think weak typehints are useful at all without fixing the current unsafe casting rules, and I also don't think strict typehints are right for PHP from a philosophical standpoint. It's a shame that more emphasis hasn't been placed on the 3rd option, which seems to be a much better compromise than implementing both extremes as a configuration option. We would get the right amount of type safety, and still not deviate too far from PHP's naturally convenient weak typing.
Changing class hints to 'object(class-name)' seems super bad proposal. Actually, I'm not sure how hard it is to implement operator overloading in PHP engine, but there is an option of adding built-in classes for int, string and float (\Integer, \String and \Float) and making them work with standard operations. It might be hard, but it will not introduce any breaking changes, plus it will give an option for everyone to choose: a) scalar types without type checks b) new classes with type checks Maybe not the best option but it seems like introducing pure strict scalar type hints brings a lot of complexities which no one really knows how to deal with.
Active record is a very specific thing, and Eloquent ORM isn't that thing. Still, I've used Eloquent-backed repositories with great success. It's ok if you don't expose the Eloquent objects, but instead use Value Objects or plain arrays to message the repositories. Should also return Value Objects or plain arrays. Then, Eloquent is just an implementation detail. I was [at a stage] running some Eloquent concretions and some DB concretions of the same interfaces and the application couldn't tell the difference...
Too cheap to spend $4?
agreed. I'd also recommend [Goutte](https://github.com/FriendsOfPHP/Goutte) if your `curl`ing begins to get more involved. It is backed by DOMCrawler.
wouldn't be surprised if we get the best of both worlds. int($var) that accepts "6 so stupid".
Are we reading the same post? The author doesn't mention Laravel or Eloquent anywhere. How have you established that this is something to do with Laravel specifically? The (new?) Laravel docs don't mention repositories either. Is it your experience that has led you to believe that this is something frequently done or encouraged by developers using Laravel? If that's the case it would be anecdotal at best and needlessly judgemental at worst. Please could you explain..?
The author does not, but the comment I replied to does. Perhaps I misinterpreted the comment, but it *seemed* like the comment author was attempting to prove the article wrong using Eloquent as an example. Though I'll admit, I may be biased as I'm not much of a fan of active record full stop.
Laravel does have a fair bit of magic in it already. It just wouldn't surprise me if this were a "Laravel-derived concept". Hence my saying "More than likely" and not "Definitely". 
the feature freeze will be in less than a month, meaning that they have to make a new rfc TODAY or we won't get scalar type hints at all.
You're kind of all over the map here, but this sounds more like an issue that **your** HR dept in **your** company is having. Also, whoever your project manager is (or whoever the tech lead is), doesn't seem to know too much about Java development.
Where is the RFC?
can they learn how to do word wrap in their official mailing list viewer? and may be threaded conversations? god, the incompetent fucks
What is stupid about it? Not trying to start any crap, I just don't even know what people think is stupid.
~~Eloquent is an ORM. Not an Active Record implementation. They are not the same thing. It's unlikely that the author is talking about Eloquent unless the author has also conflated the two.~~
except most languages are sane and have a core philosophy that everyone agrees to, and they don't have these wild 'no type hints' / 'strict type hints' type of opposing views
He goes on to make his own problematic assertion, using "alien" three times in reference to Andrea's idea. Technically, all new features are, by definition, alien to PHP. Thus we watch someone making a logical fallacy while correcting another for the same flaw. Spaceship operator? :P Definitely alien. Can't possible be added.
Please tone it down. This sort of personal attack is not permitted in /r/PHP.
I've heard hack can run symfony2, does this mean it is currently fully compatible with php 5.x? i.e.: you can mix &lt;?php and &lt;?hh files when running them in hhvm?
I made a CMS :)
&gt; goddammit, I wanted scalar type hints. Try moving to any sane language and you'll have full type safety.
Befunge 93 interpreter.
I love how every time I say something like this, people seem to assume I'm making spur-of-the-moment decisions and that I work as some kind of rank-and-file programmer. I too have had more consulting work on the types of work you described than anything else. It's definitely a concern I keep in mind, and I don't do something like this lightly. I will almost certainly be writing about what my team is doing, and giving presentations at conferences where I can, because AFAIK, no one has used ReactPHP to the extent that my company has, and no one has entertained Hacklang for as large of a project as I am. In that respect, there will be unforeseen challenges. That's part of the project plan, to account as much as possible for unknown-unknowns. If there is one thing I've learned from cleaning up the messes you're talking about in my career, it's that you're chasing rainbows when you don't *understand* the choices you're making. Which I think was your point and your warning: that I shouldn't make decisions like this if I don't understand the decisions that I'm making. I can assure you however that being a 'trail blazer' is actually part of my organization's plans. This is being done on purpose, and at the moment PHP appears to be holding us back in that respect. In fact, the application was specifically designed to mitigate any problems that might occur from this kind of experimental choice. EDIT: Also, thank you for the 'good luck'. :) Despite my confidence in the direction, we will of course need it.
Thanks for the informative response!
I like the concept, although by php 8 or php 9, I'd like to see scalar objects being implemented so you can just use object keyword as type hinting to accept any mixed type. Still, this RFC is very useful if you want multiple type hinting, but not to allow everything. I hope it will be implemented before PHP 8, otherwise it means that we have to wait like 5-7 years till the next major release is available. 
Frankly, I don't know if I like this. I can see things getting out of hand with the type ambiguity. You can have multiple types, each with its own separate interface. It would make it very easy to introduce bugs into the software while also having the quality of being hard to analyse. I think something like method overloading would be a better option to what this RFC is trying to solve. Or in the case of array|traversable and int|float, have them implement common supertypes/make one the supertype of the other. 
&gt; I see you're not a fan of the Javafication of PHP. Did we read the same post? They were clearly in favour of it (they call the other side "insane").
Excuse me, I must be having a slow day.
Yes and no. For most files in most programs this is true, however there are some notable things that do NOT work in Hack (by design/choice) that do work in PHP. For instance: - No passing by reference such as: function(&amp;$x) - No breaking block scope using: global $x - No variable variables: $$x - No string eval function names: $x = 'func'; $x($a); - No string eval: $x = 'echo "hello";'; eval($x); - And perhaps the biggest... no top-level execution. Everything in the top level must be a call into another scope (function or object) like in C++. These changes/sacrifices allowed them to do some very intense static analysis using the typing. As to your main question though, yes, your program can mix &lt;?php and &lt;?hh files. &lt;?php files will run like normal php, and &lt;?hh files will have the sort of limitations I listed (with all the additional benefits Hacklang provides).
What I am trying to explain in a nutshell. We had constraints that certain functions would "fail gracefully" during timeouts etc. This was part of the functions behavior. Function passed every test. However during runtime, serendipitous systemic consequences made the code misbehave anyway. The answer "write better tests". Yes Im saying to write these better exhaustive tests would be budgetbraking.
Are we looking at the same Laravel docs? The docs [explicitly](http://laravel.com/docs/5.0/eloquent) state that Eloquent is an ActiveRecord implementation. Moving on, there is [plenty of people](https://www.google.com/search?q=active+record+anti+pattern) who consider AR to be an anti-pattern. Database logic in entities, poor testability, static accessors, global state etc. are all known problems with AR. Compare Eloquent to Doctrine (which implements the [data mapper pattern](http://en.wikipedia.org/wiki/Data_mapper_pattern)) and suddenly, all those problems are solved. Entities are now POPOs, repositories are now proper implementations of the repository pattern, there are no static accessors (i.e `User::find`) and repositories can handle their own configuration. Of course, like everything else, there are trade-offs involved. The parent comment, although not constructive, is technically correct since, of the two big "modern" PHP frameworks, Laravel is the only one going with AR.
if they go scummy, we can always just fork it, no?
I will support HHVM and Facebook in any way I possibly can. I applaud all of the provided leadership already, as well as every contribution to language (Just-in-time VM, language spec, HackLang, static analysis, etc.). Where is Zend Corp. in all of this?? Are they **really** going to continue letting the inmates run the asylum? :o
[Here's the complete list of PHP features that are unsupported in Hacklang](http://docs.hhvm.com/manual/en/hack.unsupported.php) One you may HAVE used that I forgot to mention is: - break N - continue N You can still use break and continue, but you can't have them cascade upward N scopes.
&gt; My main concern, anyway, is with March 15 announced feature freeze. If we need a vote by this date, it's impossible. And planning such BC for 7.1 is probably unrealistic because of the huge syntax additions and BC breaks it brings. So it has revived as a zombie?
magento has a community edition: http://magento.com/products/overview#community
That's a separate RFC which was just mentioned in there.
&gt; fart noises sure buddy whatever you say. i prefer my languages to not be obstacle courses, but i guess that makes me an outlier in PHP bizarro land. have fun googling every time you need to use a function, loser. &gt; while i'm thworing excuses lolwhat i don't even
I think you're mixing up Active Record and Active Repository. The latter is what's discussed in the article, and is definitely an anti-pattern. And nothing to do with Laravel.
 // Nullable without new syntax function foo(int|null $bar) {} Yeah, no. Just no. Type hinting is for making sure you get passed the right type. This use case means type checking inside the function is still necessary, so it's ridiculous because your code hint ironically defeats the entire purpose of code hinting. If you think you need this, that means you don't know whether you're passing in a value or not, an if that's true then you need to think about what you're about to code before your fingers touch your keyboard. (edit: this was maybe a bit impolite, but I really do see it that way: not trying to imply that you don't actually think before touching a keyboard, but I don't like nullable types and I think better options must be sought if they are considered) // Falsifiable (a common PHP idiom) function foo() : int|false {} First of all, `false` is not a type. Second, if only there were a way to make an int falsy... But of course I see your point: you want to differentiate between "no value" and "zero". Fair enough, but perhaps throwing exceptions is a better option for most use cases. // Numeric without reserving a new keyword function foo(int|float|boolean $bar) {} Booleans are, by definition, not numeric. INB4: I know that they are often implemented numerically. But they are *not* "just 0 or 1". Also, the only way I see this making any difference is if you are passing in values and you don't know whether they are an int or a float. If that's the case, You Are Probably Doing Something Wrong. Otherwise, just make it accept a float and cast to an int if necessary afterwards.
when talking about the job adverts i was talking more about HackLang, I kind of got the 2 mixed up in the beginning... And I know the infrastructure of most of my clients, and often do the deploys myself, so I know nobody in my circle is using HHVM yet :) (ZF2 and symfony2 apps) I've never seen an advert here for wordpress or joomla here either btw, it's not that popular here i guess. most are drupal and full stack frameworks. Also nodejs and angular are everywhere these days.
&gt; I think something like method overloading would be a better option to what this RFC is trying to solve. People think of method overloading as an anti-pattern, I don't agree with them but that may be why they're choosing to do an RFC like this instead.
&gt;People think of method overloading as an anti-pattern, By people you mean people in PHP Internals? 
I didn't say it _wasn't_ respectful or to-the-point.
Well then, what's the problem? Not trying to pick a fight here, but you could need to clarify your opening remark. What do you find being akin to "WHAAAAAT IS THIS" among the responses made and why is it a bad thing? 
This could be good fun to work with, thanks for that
HA! I totally said more. I blame these pain killers. 
Do share.
May I ask why this feature is particularly important to you? I think graceful handling for fatal errors is primarily useful if you have long-running daemons, but probably not so important for the average website.
Wow, people really are writing code like this in Laravel? I just can't fathom how anyone would reach that point...
No need to shout, Phil. I didn't ignore that at all. In fact I said "just make it accept a float and cast to an int if necessary afterwards." It's certainly useful and I'm not denying that, but my original point was, and remains, that I am not convinced that cool handy syntactic stuff is worth having just because it's useful. It makes the language a little bit more complicated, a little bit less easy to read, a little bit harder to learn and to remember. That's okay for one change, but there seem to be so many now. Also, single types works for C, C# and Java? It's been a while since I used those, but I'd be surprised indeed to learn that developers in those languages spent all day enraged at their language being strongly typed. But then again, they have method overloading and we don't...
I've been involved with 5+ different Laravel 3/4 projects in the last 2 years, 4 of them employed this pattern. They were all done by different people, and it was something completely new to me and I've used other PHP frameworks and Rails extensively in the last 5 years. (So I'm familiar with both the Active Record and Data Mapper patterns) I've also seen it recommended often by people who advocate Laravel in blogs, on forums, here on /r/PHP , StackOverflow etc. I've seen multiple blog posts actually calling this *the* repository pattern etc. So no, the article didn't mention Laravel, but I'm fairly certain that the author encountered this anti-pattern in Laravel projects. ALSO: I'm not 100% sure, but I sorta remember the Laravel docs recommending this pattern in the v3 days. Around 2 years ago. EDIT: I'm half right, the docs were not recommending this exactly http://web.archive.org/web/20120427222355/http://laravel.com/docs/models#best-practices
Having had to deal with active record in Laravel specifically, I'd never go back. The classes you wrap your AR logic in could probably be called something other than repositories (but since they mimic "real" repositories' behaviour I still call them that), but not using them at all is a great way to end up with tons of code duplication or really fat models.
I like your point about undefined parameters. It's a very strong case for nullable types, consider me convinced on that front. &gt; Read the RFC: it's being proposed. Sorry! You're absolutely right. Should have read better before jumping down your throat like that. But yes, I guess I think booleans are a semantically very different animal from a number. &gt; If the callee method or function can handle ints and floats, it's much cleaner than polluting an API with garbage like: public function fooAcceptsInt(int $bar) { return fooReal($bar); } public function fooAcceptsFloat(float $bar) {return fooReal($bar); } public function fooAcceptsBool(boolean $bar) { return fooReal($bar); } private function fooReal($bar) {} Why would anyone want an API like that? If you need that, then why not just type check and use `mixed`: surely three different types warrant the use of `mixed` and there's always docblocks to explain what is actually expected. Having said that, I guess this makes for a good use case.
The ["official" Laravel book](https://leanpub.com/laravel) is the first place I remember seeing the concept of wrapping active record logic in a class and calling it a repository, I'm pretty sure it's safe to say the Laravel community is where this idea originated.
If this occurs in a development environment, why should XDebug not be able to show it? As far as I am aware it is perfectly fine with displaying fatal errors and will even show a stack trace (which PHP doesn't provide for fatals itself). This sounds like some kind of configuration issue to me.
Have you worked with active record in general? You need some sort of wrapper class to avoid code duplication or fat models, and it ends up having a very repository-like interface, so you may as well call it that.
A `mixed` type hint would allow anything: numeric, string, boolean, and non-scalars. If my function only handles numeric stuff, I don't want people passing strings, objects, and arrays.
A shitty, but kind of working, [similar image detection library](https://github.com/huanga/GaBan).
I'm still working on making a [minecraft server in PHP](https://github.com/andrewvy/HHVMCraft). :) *Much of the logic is built out (flatland generation! inventory management!), but not a lot of packet sending just yet!* EDIT: I think this is the first real server for original Minecraft, but someone has already created [a full-blown server with plugin system for the Minecraft Pocket Edition in PHP](https://github.com/PocketMine/PocketMine-MP) . Now that's crazy.
I rather suspected you didn't mean to shout, but it kind of came across that way. No hard feelings either way BTW. &gt; It's bitten me a few times and its taken me a while to get used to it coming from PHP especially, as we so often have multiple types being taken in and spat out. Interestingly, I've known a .NET developer who was used to C#: they put him on a PHP 4 project and he struggled, because he obviously had absolutely no strong typing, and since it was 4 not even hinting. What he did to try and grok PHP better was replicate certain parts of the .NET framework in PHP and litter his code with comments like this: /* public final */ function doStuffWithrecord(/* int */ $recordID) { ... } I guess I'm coming around on the one type to rule them all thing. There's something to be said for the `float|int` thing, to be sure. You and /u/htfo both make excellent points. Again, I'm not denying the usefulness, it's just that I don't know that it's enough usefulness to warrant a change to the PHP language...
&gt; The best advice on this subject I ever read was this: If you decide tomorrow to switch from MySQL to mongodb, you should be able to do it easily and fairly quickly. That means your application (outside of repositories) should never interact with objects specific to a single ORM or data store. If you ever need to do this overnight, you've done an awful job planning ahead. Repositories are a good place to put an interface in front of your persistance layer, but it is also a place where general ORM logic goes. If you drop the repository your ORM-specific logic bleeds out into the rest of your application unless you're dealing with extremely simple operations.
I wrote a port of the dataframe from python/pandas.
Understood. So, yourself being part of Internals, what's your take on all of this?
I second your concern wrt. ugliness/verbosity. IMO, classes should never begin with a lowercase character anyway, so what's the problem even if we do want more scalar types at some point?
Andrea was great but she was one dev. And her stated reasons for leaving had nothing to do with internals, but her own time management. If everyone wants to assign more meaning to her words and cry apocalypse about internals they're welcome to. Just not in this thread, this thread is for appreciating the software we've all built in the language we all love. We'll be fine. The world spins on.
Did someone disable the garbage collector again? :p
Nicely done Colin! Where did the boost come from?
Great work!
Hey Andreas thanks for your feedback! I don't like using repositories to directly manage relationships. Using Doctrine, I'd write code that looks like this, like I described in the article: $post-&gt;addComment($comment); $postRepository-&gt;save($post); With Eloquent, I prefer to just write this: $post-&gt;addComment($comment); I really don't like `$commentRepository-&gt;addCommentToPost($comment, $post)`. I don't find it as expressive, and it feels like I'm fighting the tool I've chosen. It's not how I would write the code if I was persisting plain PHP objects (like the Doctrine example), so it feels like a failed attempt at an abstraction. Both of the options above read much closer to what I'm modelling to me. I would never write `$commentRepository-&gt;getCommentsForPost($post)` for example either. My main point is just that I think if you really want to introduce separation between your domain models from your database access, it's a lot easier to just use a different ORM. For 99% of the things I've worked on, that separation just hasn't been as valuable as people make it out to be. Using Eloquent by the book has worked just great and I'm totally comfortable with the coupling it introduces. Of course, the article is just my opinion, and is only meant to be a discussion of some things I've been playing with lately :) The title is probably a little strong, but it leads to more interesting discussions that way ;) Thanks again for reading Andreas! EDIT: Always forget I can't use fenced code blocks.
it's 2015 already .. why can't we just say that `[1, 2, 3] instanceof Traversable` 
Why don't you *startup* with fixing the slug? &gt; mylanderpages.com/test_123/Test-Landing-Page Looks like someone uploaded the dev version