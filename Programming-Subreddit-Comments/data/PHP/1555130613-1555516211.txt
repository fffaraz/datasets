Wow this is false
people write everything from scratch, you are missing it
The way it handles interfaces and anonymous objects. The use of generics, json, the fact that vscode is perfect for ts development but 1/20 of the resource hog intellij is. The fact that the language is constantly being improved on, yet it's still backwards compatible (through babel and stuff). The import system. That's just off the top of my head.
Absolutely not and don't let anyone say otherwise. I use no frameworks. Code without frameworks is harder to write, but you always gain a significant overhead advantage and your code will be swift and speedy. Not just PHP either... I use no JavaScript libraries on the front end. Don't use MySQLi though. they're going to deep six all that shit eventually just like they did with all the other old mysql calls. Just accept the pain and use PDO. You'll be able to more quickly switch to Postgres when Oracle decides to fuck everybody one time too many.
I see a lot of people who are confusing mysqli with the old mysql_ functions which WERE deprecated. For practically everyone here, mysqli replaced the old mysql_ functions and includes prepared statements and the option of using as class or as standalone functions. PDO is still preferable because of its flexibility, but the only major advantage to PDO over mysqli is that PDO supports named placeholders in prepared statements while mysqli only supports the ‚Äú?‚Äù for placeholders. Stop spreading misinformation. mysql_ != mysqli_
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Nope, your tiny project doesn't need any caching. the only question have to be asked here, "is there any *existing*. Problem or the whole idea is pure imaginary. If the latter, then just ditch it and do something sensible instead
The level of sanity check in this sub is appalling. People would eagerly offer a solution for any problem, however imaginary or far-fetched it is
I would say GoLang and Node is state of the art now, but I love Php. :]
You are right in general, and for static arrays it's the best way to cache them However, the OP asked about an array they are taking from a database, and that's a different matter
Just for your information. Mysql ext is not "deprecated". It is completely removed from the language. And there is not "a lot" but just one poor bloke. While speaking of numbers, there is a real lot of people, for whom mysqli did nothing good, and who continue to write as though it's still PHP 3, despite adding "i" to function calls
Interestingly that nobody said the word "framework" here.
[Nobody](https://www.reddit.com/r/PHP/comments/bcmjx9/is_it_considered_old_fashioned_to_develop_my/ekrw9xj/)?
Depends on your project scope. Simple project require simple solutions
Or don't use the database in your unit tests. I can see needing it for the application when running integration tests like behat but don't use the database for unit tests.
Okay, "the OP" would be a more correct phrasing. And there is a shitload of options between "pure php and mysqli" and a framework.
MariaDB exists. No need to switch from MySQL to Postgres, just switch to MariaDB.
You _can_ dig a hole with a spoon.
Whatever. Do you want to fight about it? It seemed to me that the OP was asking about whether he should start with a framework. Fucking sue me.
I prefer to fight ignorance at whole, not a single representative. Have a nice day
Btw, there are only two hard things in computer science. Cache invalidation, naming things and off by one errors.
&gt; Code without frameworks is harder to write C'mon dude.
May I ask, what are those PDO*s* you are talking about?
https://stackoverflow.com/questions/6980792/what-is-pdo-why-should-i-use-it For extra credit, go right for an ORM; https://www.doctrine-project.org/
So you are one of the blokes who have no idea what mysqli is. But my question was different. Once more: what are PDOs, in plural form, this guy is talking about. Before patronizing me again, consider you are talking to the guy who knows a bit, what PDO (singular) is
Yes it's a little old fashioned. Use pdo instead of mysqli or an abstraction like eloquent
You will thank yourself later if you master pure PHP first. People think they can skip to frameworks, but that is a mistake. It‚Äôs like skipping school directly to college. You miss a lot of basics.
Sigh. Are you one of the blokes who when someone refers to an ATM machine or PIN number you feign ignorance as to what they mean, or mock them mercilessly for a technically inaccurate but commonly accepted use of language? Do you feel that makes you superior in some way? Do you truly not understand how petty and insecure it makes you sound?
So you are one of the blokes who likes to collect downvotes!
Haha, this sums it up nicely.
If there is money for fancy coffee, there is money for another server. Don‚Äôt tell your boss that though. He won‚Äôt like honest observation.
PDO connects with all types of databases not only MySQL.
Just for your information. ext/mysql was deprecated in PHP 5.5. It was later removed in PHP 7.0.
not old fashioned, more impractical and large waste of time. It is completely acceptable for something extremely simple, like showing a random quote from the database, but once you start adding request handler, active record, templating language, caching, well you end up with a framework anyway.
Sure thing. Given the averagee level of ignorance in this community I often get down voted for asking something contrary to a popular superstition :)
Sure thing. Given the averagee level of ignorance in this community I often get down voted for saying something contrary to a popular superstition :)
No. Even in 2004, we would have - at bare minimal - used MD5 to hash the password and then check it (and we may have had a salt); and [we would have been wrong](https://en.wikipedia.org/wiki/MD5#Security), but holy crap would it have been better than this. Side note: for anyone who reads this, _do not_ use MD5 to hash a password. The functions `password_hash` and `password_verify` exists. Use them instead.
PDOs is nowhere a "commonly accepted language", so your preaching is off the track :) Yet it's a sign. There are too much people around who have no idea what are they talking about.
Yes. And PHP 7 is no more itself. So, saying that this ext is just deprecated, someone clearly shows off as yet another person who have no idea on what they are trying to preach about :)
For datasets or tables that don‚Äòt change often but are queried a lot, it is possible to write those ‚Äûcache files‚Äú automatically. It offloads the database and can be much faster as long as the PHP hash for variable reference is fast enough.
Yes but that's not the point either.
Because the author isn't a native speaker
And for this purpose such home brewed caching would be silly. And what you all eager cache makers keep forgetting is mysql is excellent at caching itself. And for tabes that are queries a lot it will be already from cache
Yes but that's not the point either.
Did you notice the past tense in beef-ox's and messages?
 Ugh... from that one comment I can tell that everyone in my team would absolutely hate to have to work with you. We would be flooded with your comments that do absolutely nothing but just gas the atmosphere. You are either working alone or with people just like you or if you're currently in a larger team, people really don't like you, either openly or secretly.
Probably PHP Data Objects. See here if you never heard of them: https://www.php.net/manual/en/book.pdo.php . Stop being an ass if you did understand what he meant.
Oh I am a very nice guy generally :) You just have to realize the difference between a co-worker and an average redditor. None of my coworkers would ever say such ignorant rubbish like "PDO's security benefits are enormous compared to mysql". My coworkers would never venture their opinion in the matters they have no experience with. But thank you for providing a profound analysis on my personality. This is surely accepted in *your* team, I believe ;)
&gt; The difference between Laravel and for example Doctrine. Is that Doctrine actually warns people about this. Well now Laravel warns people as well.
Ah, that's the /u/colshrapnel I remember. I was wondering where you went. You were a nice person for quite a while, too.
I still am. This particular thread was been invaded by redditors who think they know PHP, and it made a hell of it. So I don't care, just entertaining myself here :)
Guy who you replied to didn't say PDOs in plural, someone else did. That's one thing, second thing - does that s at the end really twisted your panties so much that you felt compelled to shit on someone?
&gt; there is a real lot of people, for whom mysqli did nothing good, and who continue to write as though it's still PHP 3, despite adding "i" to function calls So what? It's not the fault of the folks who wrote mysqli that people do that. This sort of reasoning is exactly what I don't like about the anti-PHP mentality on the internet.
I wouldn't recommend it. Use a framework like Laravel or Symfony. They make stuff so much simpler
He's probably a dude who started coding few years ago and still hasn't gotten past the peak in the Dunning Kruger Effect graph.
Thank you very much. Incidentally, I am the author of the best PDO tutorial out there :) I am not stopping being an ass though. Not until you hardcore redditors, who just spotted in your memes feed two vaguely familiar words PHP and mysqli, would leave this sub. You are not welcome here. Go discuss your memes.
&gt; PDOs is nowhere a "commonly accepted language", so your preaching is off the track :) Wow, so you just doubled right down on being a douche, huh? You must be a very unhappy person. I hope your approach to life works out for you.
Just compare the doctrine docs including their remarks about security and their entire security topics in both the dbal and the orm project to how the laravel docs tried to warn people.
Yes. Which is what I said...
Surely you were able to read my comment you are talking about, weren't you? I didn't mention PDOs to *that* guy ;)
Where does he say he wants to dig a hole? Maybe he just wants to spoon a couple of sugars in to his coffee. Not everything needs a framework. üòÑ
Yes. But you completely lost the track of this discussion, however short it is. You just put your own meaning in my words and now reproaching me for it. I don't find it amusing.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm confused what this even means. How / why would PDO or an ORM by any more secure than using mysqli? This doesn't make any sense. &amp;#x200B; If anything this is a very dangerous statement for innocent people reading this and taking it at face value. I'm sorry, but this is just wrong. If anything ORM's can make things less secure because of assumptions people make about what is safe to do v what is not safe to do. Sure in most cases it's because of people not reading the documentation, but ORMs give you a lot more abstractions to shoot yourself in the feet with.
No, I'm not. You're saying that a bunch of people who don't know what they are doing have just tacked an "i" at the end of their function calls, and you are implying that they were enabled to be bad programmers because MySQLi exists. I used to work for people like that and trust me, they are every bit as capable of writing shit code with PDO as they are with MySQLi.
Please stop spamming.
No no. I was looking into software design and I was thinking about how I would design a cards game. Like how would interfaces look like for a software like this.
&gt; MySQLi.... just don‚Äôt. Use PDOs instead. Hey, what's the reason?
Surely your judgement is correct. And a I'm extremely concerned in a random bloke's opinion about my personality, emotional state and an approach to life. Now my self-esteem is ruined (:
It all depends on the use case, if it's a very simple website then it's quite alright to use pure PHP. However if it's a complicated site then it's fast to use a framework. A framework is basically a tool box with tools already crafted for you so you can build the finished product right away. If you want to build it with pure PHP then you have to build the tools first then build the product, and a lot of thought and consideration is required to build your tools to make sure they are secure and effective. Again there is nothing wrong with going pure PHP but it will be more time consuming and effort but on the plus side you will know the whole code base inside out. As for MySqli, I can't say, I've never used it. Im a Mariadb and postgres type of guy.
PHP data objects
I agree with the colonel
+1 on using PDO and an ORM (with nothing stopping you from using some occasional raw SQL when needed) I like this one https://redbeanphp.com
Where can I find it?
This question is double edged. Generally speaking, PDO is superior to mysqli from the *usability* standpoint. Mysqli is almost twice as verbose as PDO in performing even basic tasks, let alone some magnificent automation PDO offers for getting the query results. However, there is a possibility that the guy confused mysqli with the old mysql ext or simply don't realize mysqli offers prepared statement s as well. So in essence, PDO is much better, but not ln such imperative form.
&gt; and you are implying that Ah, that's simply marvelous! That's exactly what I said about putting your own meaning in my words :)
Asking for science? :)
PDO in its raw form doesn't have features like auto-reconnect or read/write splitting, load-balancing reads. Since I've used wrappers to do that around either PDO or MySQLi, the interface was pretty standarized or even sugarized, e.g. \`function query(string $sql, array $params)\` where you can query and bind params in one go. If you stay with MySQL only, the MySQLi might still be not the worst choice. In theory PDO offers you a flexibility, whilst truth is that regardless if you use MySQLi or PDO, if you migrate to PostgreSQL there is usually still work to do.
If it's that good I want to read it. Always trying to improve skills.
Oh, speaking of wrappers I completely agree with you. It takes hardly a hundred lines of code to replicate all PDO's functionality with mysqli, save, probably, named placeholders. But people here are talking here of using both in the raw form
As long as you use OOP and PDO, I see no problem with that. You‚Äôll just have to be well organized.
I knew it would be futile to write those comments, yet I'm still disappointed.
&gt; So you are one of the blokes who have no idea what mysqli is. &gt; &gt; But my question was different. Once more: what are PDOs, in plural form, this guy is talking about. Why don't you just answer: "You're confusing mysqli_ with mysql_. Mysqli_ also supports prepared statements which protect you from sql injections when used in the right way.". Less trolling, less biting, less polluting this subreddit. Everybody wins. PDO PDOs. Potato potatoes.
The word you‚Äôre looking for is *deprecated* but since MySQLi hasn‚Äôt been deprecated then your statement is baffling.
You are right, and in general I would agree with you. But this topic has been doomed from the beginning due to it's title that would attract every redditor and every redditor consider themselves an expert in php. So all you can do is relax and enjoy :)
Besides, potatoes are usually come in quantity, while PDO is only one around. In case you know what are you talking about, of course
Mysqli is to be found I basically any tutorial for php out there but imho that's misleading//outdated and ignoring the way more comfortable Syntax of pdo
Yes that's considered old school...try using those skills with WP and u are a clients dream because those skills are still super important!
What are these 'too much' people that you're talking about? Let me help you out with your grammar - it's 'too many' people, because 'people' is a count noun. If you're going to be a pedant, get it right.
Creating website(s) *is* digging a hole. Even the simplest non-framework page for a silly homepage could be like &lt;?PHP $title = "Site news"; $data = db::query("select * from news order by id desc limit 10"; require "news.tpl.php"; And it would be far superior to the usual pathetic loop with "pure mysqli and PHP", making a spaghetti of database calls and HTML.
Thank you, I stand corrected.
That's the voice of sanity but it will just drown in this ocean of ignorance and quick judgement.
It is never futile if you can read *and* know the topic you are talking about
Thank you for highlighting this. It is so irritating when people do this. I think the only real response to that in real life is "F*ck Off" when they say "what is an ATM Machine?". Idiots.
In most cases, when you want to post with a body, you want to post in /r/phphelp instead. If it's not the case, and the topic deserves some discussion, you can post on social media, such as medium.com and post a link here
I don't want to post it here but you can Google it easily. It's a very easy spot.
You're still a fucking moron.
 $pdo1 = new PDO('mysql:host=localhost;port=3306;dbname=db1', 'user', '1111'); $pdo2 = new PDO('mysql:host=localhost;port=3307;dbname=db2', 'user', '2222'); Voila, two PDOs.
GTFO, fucker!
&gt;Generally speaking, PDO is superior to mysqli from the *usability* standpoint. Higher Usability roughly equals **Higher Maintainability**. Is OP working on his websites alone? Then he probably feels it is pretty maintainable because he knows this stuff in and out and can write 5 lines of mysqli\_ what 3 lines of PDO would do. If you are collaborating with developers or if someone should take over the maintenance later he will have a better experience using higher level abstractions. For me coding everything in plain PHP would be an excercise of my skills. I don't get paid to excercise. I get best get paid when i'm productive. Higher level abstractions (PDO, ORM, Router, Middleware, Templates &amp; many more libs for things i don't want to reinvent the wheel for) make me productive and my code maintainable by people that even have just a little knowledge in the aformentioned abstractions. There is a possibility that you can go to high-level and worsen the usability for unexperienced users. That's why we **choose the right tools for the job**. One day me wight want to whip som crude API up with Slim3 framework and PDO - easy. The other day we want to build something big with automated migrations, generated docs, multiple message formats, so we choose API Platform on Symfony4 with Doctrine.
He's just blatantly lying. The mods need to ban his ass.
Use https://old.reddit.com/r/PHP/
The title is spot on. People who still use mysqli extension are almost universally noobs, as you yourself have demonstrated. People, in general, who still use MySQL database *BY CHOICE* are noobs, too. At a minimum, we've all shifted to MariaDB. At a max, true pros greatly prefer postgresql once they've used it for a few months.
I like PDO too, but there are definitely advantages to mysqli. The biggest one being that you can run your query async.
You have single-handedly fucked up this entire post, you asshole.
Anyone who writes `require` in 2019 is a loser, in my experience and opinion.
PDO is a class, remains one while $pdo1..n are objects. Different things That said, this wrapper is a blunder :)
Look, if I take a 12 year old who is motivated to code and I mentor them, then they can FUCKING DROP OUT OF HIGHSCHOOL by age 15 and start making $70,000-100,000 and if they just commit to learning the IMPORTANT stuff on their own (e.g., history, English grammar, a large vocabulary), they can SKIP all the useless shit. And university for programmers is an ABSOLUTE joke, with ONE huge exception: If you're a foreigner, get a goddamn degree so you can come to America on an H1b and get a shitton more money than you can, even in London. I'm making $150,000 in TEXAS and best I can find in London is closer to $80,000 for the same stuff...
People stopped using mysqli back in the mid-2000s for PDO. By now, it's just derelict and its parent, `mysql_` is already REMOVED from the language. It is ipso facto old fashioned.
This is really spot on, dude. What the fuck happened between 6 hours ago and 2 hours ago????
Everything in colshrapnel's comment seems spot on to me. What is false and why?
Woah i need to stop raging against all the seeming idiots who post in comments instead of a text post. I had no idea reddit's "new design" was that fucked? The day it is foisted upon me is the day I block reddit.com in all of my hosts files.
I would say the *most useful* one is the ability to get the number of found and updated rows separately. Anyway, the OP (if you still remember the guy who started the topic) didn't mean async queries :D
Yeah, hard to take someone seriously who calls that 'the best PDO wrapper'. :) He should take his head out of where it's stuck.
My coffee maker has two different drip settings
Yes I did. And did you notice that removed is much more important than deprecated and someone who knows what are they talking about should know it happened 3 years ago?
&gt;And university for programmers is an ABSOLUTE joke I worked in the industry for roughly 6/7 years without any kind of formal education in programming and I thought along the same lines, I don't need a degree. After a job change, I was offered the chance to gain a degree at their cost as they had a dedicated training budget. I can categorically say a degree in Computer Science completely changed the way I think about programming, it has made me a far better programmer. Sure if you're only ever working in web doing CRUD and some form input you can certainly do well without an education, I did for many years. Outside of web programming through an understanding of how the code is being executed at a machine level really helps you produce much more efficient and robust code. That's just my opinion after being on both sides of the fence. &gt;come to America on an H1b and get a shitton more money than you can, even in London. I'm making $140,000 in TEXAS and best I can find in London is closer to $80,000 for the same stuff... This is something that has been discussed at length on /r/programming numerous times. When you take into account the cost of living, insurances, medical etc the numbers aren't much different here in the UK compared to the US, obviously which region you are in the UK and US will have some variation but on a whole, all living costs considered there isn't much in it.
I simply adore this stream of consciousness. Did you try to publish your magnificent works on Amazon?
&gt;Rather than up-front optimization, you get to do it as it‚Äôs necessary. But that they‚Äôre coming to PHP 8 isn‚Äôt the only news. It‚Äôs awesome that PHP will get a JIT in PHP 8 means that we can expect that server-side language of WordPress Why do I get the feeling this article wasn't written by someone with the name "David Hayes".
No-one said ext/mysql is _just_ deprecated.
Thanks. Appreciate it.
You seems to be talking to someone else. Keep talking to them
If I Google for best pdo tutorial I'm supposing it will be hard to get there :)
Assumption: Your goal is to write the best code you can, as quickly as you can, so you can grow your skillset the fastest. If you go to a framework without understanding how it works you will hinder your long term progress. If you keep writing oure PHP once you've learned the basics of how it works you'll be maintaining a stagnant level of knowledge and itll take you longer to roll out new products by not using all the tools at your disposal. Very few developers churn out websites without using a framework or CMS of some sort. You want to write code? You'll probably spend the rest of your life learning new things. If you take a course of action that prohibits this growth you're hindering your long term potential. In the end though just do what you want. Anything that keeps you writing code is best.
@kettlesplash I hope you find a useful answer somewhere in this thread-turned-into-flame-war. Fact is, it really depends on the size and complexity of your project. Instead of using a full framework you can choose to use only the packages you need. mysqli is fine. Personally I prefer PDO, but when used in the right way (parameterized queries!!!!) both are fine. Using a templating engine like Twig can also help a lot. It protects you from XSS because you don't need to worry about escaping. It also forces you to seperate the logic from your output. Composer is very useful to manage packages. ( `composer require "twig/twig:^2.0"` and you're good to go )
Oh, so be it :)
You're definitely the type of person who is disliked by the rest of your dev team.
???
I would leave the display to javascript, probably Vue.js, and provide an API for the deck, keeping the scores, etc... So, client in javascript and server in PHP. I don't know your game so I can't be more specific.
Since doctrine saved my ass when I needed to migrate from mysql to Oracle in a 50% developed app and only needed to refactor like 10 lines of code, I never went back to raw DB management Long live query builder
Context. It changes in every single comment thread. One needs some certain attention and ability to remember the prior discussion to get each distinct comment right in it's own context. For example I would "defend" or "attack" mysqli depends on what certain superstition my interlocutor just expressed.
Me or col? I‚Äôve been programming since 2003. Started PHP in 2007. Maybe that‚Äôs not that long, but I am only 30. Writing in native PHP isn‚Äôt inherently insecure. Neither is using mysqli if you do it correctly. Yes, PDO is superior. It‚Äôs easier to use and more flexible. But the mysqli wrapper is only insecure for people who rely on buzzwords and falsified resumes to get jobs or don‚Äôt make use of prepared statements and properly treated user inputs. As far as Dunning Kruger is concerned, I deal with this on a regular basis when hiring programmers in my department. Anyone who knows how to use google and SO thinks they are experts. Then I give them a simple challenge for which there is no pre-existing method in their favorite framework and come back three hours later to nothing accomplished and send them home.
This comment is a pure gold. Yet in the world where most jobs *are* simple CRUDs and form inputs, it will be always underappreciated.
Mysqli is a database API one can use in php to connect to mariadb
&gt; Is it considered "old fashioned" to develop my website(s) in pure PHP and MySqli? Is this type of PHP programming still utilized? I've used a number of languages over the years, but for some reason only the PHP community seems to have this weird hangup about "pure PHP". No Python programmer wants to avoid using a library or framework if there's a solid option that will help them solve their problem. If you're doing something where Flask, or NumPy or Beautiful Soup or whatever will be useful, then you just use it. Anyhow, to answer your question, PHP without libraries is adequate for very simple websites. As you want more complicated features, or want to work with a larger team, you'll need to use libraries and frameworks or your productivity will drop. Adopting something like, eg, Doctrine has an overheard. If you're a single developer working on a small website that isn't heavily data driven, it's not worth it. But if you need the features Doctrine provides, it's prohibitively difficult to re-develop them yourself, and even if you did, it would be difficult to on-board new developers to use your custom library. So it's not "old fashioned", but it is a choice which makes sense for a relatively small number of developers doing relatively simple things. (MySqli is similar. It's *fine*, but PDO would be be a better choice, because it's a bit more "standard", and it's a bit nicer to use. Again, as a solo developer on a small project that already knows MySqli it's probably not worth switching. There are still better options, however.)
Most of the time people are actually using Maria when they say mysql.
Ok thanks for clarifying
For named parameters, you could potentially use mysql variables for this. Like, preg_replace('/:([^\b]+)/', '@$1', $query); and then build a query to set the variables based on the passed array in your execute method.
Lol, yikes
This three gave me cancer
With such wisdom I'm sure the noobs on your favorite Discord server really admire your perceived experience yet you didn't even mention the pros/cons of emulated prepared queries...weird.
This is true. And I personally favor PDO. But for a person using mysqli, I would not tell them they are doing it wrong
Clearly you've never had a code review. https://youtu.be/hib4n9RmFrQ
This is beyond the scope of the OP. This was simply to say that mysqli isn‚Äôt ‚Äúdoing it wrong‚Äù to the extent that the response conveyed. I am not on Discord.
&gt;I'm making $140,000 in TEXAS How much of that do you spend replacing your caps lock button?
Finally someone says it
I‚Äôve never done this myself. I was just thinking off the top of my head one way it might be possible to use named parameters without any forethought or research.
I‚Äôve had plenty. I‚Äôve also conducted plenty.
Depending on the use case though. If you're never going to move away from MySQL, the versatility of PDO isn't useful, and mysqli supports things specific to MySQL that PDO doesn't support. As in almost everything, your mileage may vary.
Anything inherently wrong with PHP? No. Anything inherently wrong with MySQLi? No. Anything against using PHP as a template engine? Unless you're doing PPR, no. Could you learn something else that would increase your career marketability by 5x? Absolutely 100% yes. Thought you might want an answer from someone who knows directly which roles show up 10x a day and commonly pay six figures versus which do not.
Yes and yes. It's still extremely valuable to learn PHP the "old fashioned way", as you'll understand how things work under the hood and pitfalls to avoid, but at some point you'll likely want to switch to packages and/or frameworks that make things super easy for you (and handle or avoid those pitfalls for you).
What do you mean by pure PHP? I'm guessing a website from scratch, it's not old fashion just takes more time. You shouldn't use mysqli though. PDO does the same but more secure.
It is far superior to use a framework. So much stuff is done for you already. It is more secure. Other devs can pick up you code much quicker. Everytime you start with plain PHP you sre in effect writing your own framework.
Just for your information, mysqli is as secure as PDO
Why are so many of you devs rude about so much?
It's considered old fashioned, but i think it's underappreciated to write in raw code.. I still write code that way for my own projects. Of course, if you present the source code for any of this in a job interview, you're not getting the job though.
Hi beef, I'm irony, nice to meet you.
Lol now it's officially getting funny.
It's not the new design fault. Moderators configured this subreddit that way. Not the best decision if you ask me.
This doesn't work if your app rollbacks transactions in some cases/does its own transaction management.
You're not escaping arguments when calling shell_exec, so if DB password or username will contain special shell characters, mysqldump won't work.
We did the same thing a few years ago and the speed up was quite significant. We are using Doctrine, and it's very slow at saving a lot of data, so switching to SQL saved something like 10 minutes out of 50 minute build.
That's the meanest insult I've ever seen on Reddit. Saving it for future use!
Support for different databases is not the only thing that makes PDO versatile. Rather it's least important feature, in my opinion. And what truly makes PDO versatile is its sleek syntax that let's you get the data right in the proper format without the need to post-process it
I made a post about this last week and people on this sub attacked me. I was like wtf
I think it limits what you can post based on sub-reddit karma/reputation. Many other subs do it but they make it very clear. This one doesn't seem to tell you anything. TBH some of the errors qualify for r/softwaregore ü§£
Decided to implement this to answer your question: &amp;#x200B; Feel free to play: [https://repl.it/@slifin/SwiftAjarCarrier](https://repl.it/@slifin/SwiftAjarCarrier)
This is not the best advice. Frameworks are a set of tools that work well for some purposes and not for others. It really depends on the application. Any developer that can‚Äôt write native PHP because they only know their framework of choice is no different than a person who only knows a little bit of jQuery saying that they know JavaScript. Or a person who knows how to use bootstrap saying that they know css.
This is true. The mysql_ functions were completely removed from 5.6 and 7.0 while attempting to use them in 5.4-5.5 emits a depreciation notice. And since it‚Äôs a really bad idea to suppress errors in the logs, you‚Äôre going to end up with a massive logging overhead. colshrapnel is right. It is important to know that they have been completely removed. And one should never use them on any project and migrate away from them on legacy code.
Mysqli isn‚Äôt inherently bad. A person who doesn‚Äôt write good code will write insecure code in PDO as well. `$pdo-&gt;query("SELECT * FROM users WHERE userid = {$_GET['userid']}");` Mysqli allows you to prepare statements. It also has functionality specific to mysql that PDO doesn‚Äôt. Though most use-cases will be better off using PDO for its flexibility and simpler usage, it‚Äôs just bad information to say that it‚Äôs inherently insecure in every way imaginable. Everything is insecure if it‚Äôs used poorly.
Here are some Symfony implementations: [https://codereview.stackexchange.com/questions/195462/simulations-of-the-card-game-crazy-eights](https://codereview.stackexchange.com/questions/195462/simulations-of-the-card-game-crazy-eights) [https://github.com/ApolloZhu/Think-Java-Exercises/tree/master/Chapter14](https://github.com/ApolloZhu/Think-Java-Exercises/tree/master/Chapter14) &amp;#x200B; UML diagram: [https://github.com/ApolloZhu/Think-Java-Exercises/blob/master/Chapter14/UML.svg](https://github.com/ApolloZhu/Think-Java-Exercises/blob/master/Chapter14/UML.svg)
I agree. I mentioned in a previous thread on this topic that I think it would make more sense to display a banner redirecting help posts to the other board, if that's possible with reddit.
Look man I dont come into your posts and tell you your unthought through concept is inherent code smell. If a person wants to write a wrapper that uses mysqli but works like PDO, it‚Äôs not inherently wrong to do so. If you want to use named parameters, you can certainly do that with mysql variables. Instead of bashing people, why dont you give details about what could work vs what doesn‚Äôt.
can you give one example where it helped your code just curious
This is accurate. This whole thread is full of misinformed comments from people I doubt could even write a secure application in native PHP thinking they‚Äôre goddam experts because they can drop in a massive framework to print hello world referring back to stack overflow for ever character
On that note, as a hiring manager, this whole field of expertise is the same crap. I have to toss 80% of the candidates the recruiter sends me for the same bs
He‚Äôs not a moron just because he is being pedantic. It‚Äôs called sarcasm.
I like turtles.
To even further improve the speed, you can only truncate the tables that are present in the fixtures of the current unit test on tearDown.
Too many*** Learn to speak and type English if your gonna insult some one.
Off topic side note: this post is full of idiots who have more downvotes then I know what to do with, they don‚Äôt stop either. Can a moderator step in? The answers here are either wrong, rude or very opinionated and don‚Äôt help the OP in the slightest. Correction, money answers here. You have to weave through a lot of bullshit.
/u/colshrapnel said: &gt; It is unprofessional, inefficient, and prone to every error and vulnerability you can think of. This is simply not true. Efficient, professional and error-free code can be written using mysqli. Conversely, inefficient and unprofessional code that is full of errors can be written using frameworks and PDO. It is *how* they are used that makes the difference. &gt; Any programmer, even being forced to work with "pure" mysqli, would invent a wrapper, to automate repetitive tasks. This is true, but not just for mysqli, although I agree that the usability difference between "pure" mysqli and wrapped mysqli is more significant that between "pure" PDO and wrapped PDO. When I used to work with mysqli, I wrote a wrapper. When I changed to use PDO, I re-wrote the wrapper. In the end, my code looks pretty much the same, and without looking at the wrapper, you wouldn't know whether I was using mysqli or PDO. &gt; If a site is developed in "pure php and mysqli" it means its author have no programming experience. To make this conclusion is just ridiculous. I actually think that the opposite is more of an issue. I am aware of people who really have no idea how to program, but think that they do because they can follow instructions on how to setup a framework and then plug in various components without really understanding how they work and what they do. As a result, they create systems that are full of bugs, usually edge cases that it doesn't occur to them to consider because they are used to the magic of the frameworks and just assume that it will be taken care of. At the end of the day, mysqli vs PDO is a personal preference, but most people prefer PDO (and with good reasons). That doesn't mean that mysqli is wrong or bad though.
You should always look to using a framework. The reasons for not using a framework are usually wrong. If you are going to do very basic scripting I would still use a framework. It encourages good practices rather than spaghetti code. I love how CrypticWriter and I are down voted, whereas "6 to one or half dozen to another", is upvoted. Choclove90 is advising going down the rabbit hole to spaghetti is a good thing and gets 26 upvotes!?! Convert TDD by Kent Beck to PHP if you want to do non-framework PHP, but that is just learning PHP and not something you should do in anything practical and the question is "to develop my website(s)" and the answer to that is no use a framework. It is the best advice. Beef-ox you are not answering the question at all and discussing something way off topic.
I'm one of those that still do pure PHP, but I did change to PDO when they removed the mysql functions. My reasoning was that eventually they will remove mysqli too and I don't want to have to change my code again..
Thanks for the suggestion
Just treat the top comment as the body unless they say they aren't the OP.
Frameworks aren‚Äôt the best in every case. I think we have become too accustomed to relying on everything being prebuilt. There are issues with this approach, as no framework will be perfect for every situation, and for people looking to have strong employment should be able to do everything correctly with native PHP and extensions. Learning one framework and not knowing how to write good, clean, native code will not make you hirable. Little to nothing complicated written in PHP is going to be faster and more efficient than binaries. When choosing a framework and choosing whether a framework is even necessary for a project, the initial decision should researched carefully based on needs‚Äînot based on popularity using a framework. Also, I don‚Äôt get why the community at large is so obsessed with frameworks to begin with. Any programmer worth half their weight in toenail clippings should be able to write purpose-built code from scratch better and just as quickly than shoe-stringing massive one-size-fits-all projects together to make something work. This is why I believe you, the developer, should make your own framework for your own project unless a particular pre-existing framework has more than 80% of things you need and less than 20% of things you don‚Äôt. We shouldn‚Äôt teach people to require other people‚Äôs work to get their job done effectively. It‚Äôs just plain bad advice.
To be fair, you could set up that very small website with, for example, laravel, a lot faster than with pure php.
Correct, me personally would not use pure php alone for 99.9% of my work. It would have to be something so specific and have a very extreme criteria for me to consider it. Also laravel for the win. I moved from Yii a few years ago, just after laravel 5 was release and i have never looked back for most of my projects.
It's been ages since I used something like pure PDO style last time (never used mysqli btw) I can't even remember how to do it. In real world projects you mostly deal with ORMS (Doctrine in my case).
The time to migrate was before, if the application had a life to continue.
You‚Äôd be surprised to find out that many business don‚Äôt just update all their programs every time there‚Äôs a new version. If I were to place a bet, I‚Äôd say at least 20% of running PHP code in the corporate world are on old versions for the pure and simple reason of time, available resources, and fear of breaking something that currently works.
And those applications likely stayed internal, which is their prerogative. Of course it is best practice to upgrade and update but it‚Äôs not always feasible and in some cases unwanted.
I wish we lived in a world where only internal, private installations were outdated. üòÇ It‚Äôs a shit show. They look like they have it together on the outside, but as soon as you step into the devops team, you‚Äôll wish you were at a startup that wasn‚Äôt dependent on decades old legacy code running on outdated platforms.
I mean if you're going to try and be a smug arsehole you can at least spell properly, otherwise you're just failing on two levels.
Wow that is wrong. Using a framework is bad advice!?! hir[e]able!?! All jobs are based on frameworks and skill sets. I can't believe your reply. Anyone that takes your "advice" is very gullible. 80% of thing you need to justify using a framework or you should program you own framework!?! I think it is implicit in your advice that you should use a framework, but you specific advice is terrible. What framework would not have 80% of what you need? That is the most breast fondling theory that I have heard in a quite while. Don't write code from scratch and don't write SQL queries is the best practice at the moment. I hope you are really old and giving old bad advice that will soon disappear. I think this whole thread is almost all terrible advice. "Write web sites from scratch" is terrible advice that is far away from modern best practices. The only reason to write "pure php" is for learning fundamentals and should only be done in courses and tutorials not in full web sites.
You think enterprise websites are using frameworks? Unless something has changed very recently, they don‚Äôt. This is bandwagoning at its best. Sure, learn a framework if you want to freelance mom and pop stores and startups and relatively small businesses for the rest of your career. Also, these frameworks come and go based on fads and trends. Don‚Äôt be trendy, major corporations do things in house.
Very old-fashioned. Only used by people that don't know what they are doing i.e. trying to learn php fundamentals or just incompetent.
I don't see how it could help being that a-hole :)
They do have their own frameworks, that doesnt mean they are not using frameworks. Enterprise frameworks are usually bad because they are based on old bad core code and so are too expensive to replace. Large companies having shorter and shorter lifespans as time goes by, mostly because their underlying techologies which they are created to exploit become out of date, e.g. Kodak. If you want to hack old and bad framework code all your life go for it those jobs are drying up as major corporation employ innovative technologies. It seems clear your advice is based on bad and ageing truths. They did do things "in house", but that is less and less true as time goes by.
Y‚Äôall need to learn to code. I can write any functionality a framework provides better for my applications needs in most cases better and faster than some generic piece of framework that was designed for to be for beginners. Don‚Äôt rely on a framework that does all the coding for you‚Äîyou WILL eventually find yourself hitting a wall inside the box you put yourself in. Period. It‚Äôs not hard to avoid spaghetti code without bloating your application full of prebuilt code that isn‚Äôt going to be used.
The question was from an obvious beginner you are sending him to the dark side, even though you can make it work from being evil for a long period of time it is not good advice for a beginner. Learning code should be done in class or tutorials not in the wild. It is hard to avoid spaghetti code unless you have a lot of experience. All your answers and advice have been terrible for a beginner.
Yeah, laravel is the best. Tried it 5 years ago and never looked back. Now i mostly take jobs only if i can make it on laravel.
Personally, I find frameworks exceptionally useful when building simple applications from scratch. Because mature frameworks like symphony or laravel have almost everything the client might need and I can focus on business logic. Sadly, most of my work consists of modifying existing solutions which use old/custom built cms so general php skills are way more useful than proficiency in any popular framework
A tutorial that doesn't teach or explain anything. Should just zip up the contents and make it downloadable.
I liked it
How does this compare to https://moneyphp.org? Are multiple currencies supported? Is the type immutable?
You may want to discourage passing around `float` values: give [https://github.com/Roave/no-floaters](https://github.com/Roave/no-floaters) a spin on your code ;-) &amp;#x200B; (yes, I saw that you use BCMath - still, input/output being `float` is a concern)
Not at all- just produce. Libraries and WordPress are great IF you need them. Map out your project before you start and limit complexity to your needs
That was a feature, not a bug.
[removed]
That website is 403ing... From the Github project: MoneyPHP vs. MoneyType (Quality Metrics) * Build passes: [**NO**](https://travis-ci.org/moneyphp/money) [**Yes**](https://travis-ci.org/phpexpertsinc/MoneyType) * Test Coverage: 89% vs [**100%**](https://codeclimate.com/github/phpexpertsinc/MoneyType) * Code Quality: 8.66 vs. [**10.00**](https://scrutinizer-ci.com/g/phpexpertsinc/MoneyType/inspections/54ffb01e-206d-4665-8b83-9d197d692775) * Unresolved issues: **53** vs. **ZERO** (Issues are promptly resolved within a 24 hour SLA or business contracts are violated). * Code Size (src): 4,180 lines vs. **439 (89.45% smaller)** MoneyPHP vs. MoneyType (Features) * JSON Serialization: Yes vs. Yes * Big Int Support: BCMath+GMP+Native vs. BCMath+Native * Money Formatting: Yes vs. No * Currency Symbols: Yes vs. No (purely about storing / handling money amounts).
Definitely looking into this. Thank you so much.
I think of a lot of the reluctance to who libraries is that most people who have been coding for 15+ years realizes that a lot of those libraries are going to stop working eventually or be incompatible with something going forward. Having experienced catastrophic failures multiple times due to libraries no long being maintained makes you hesitant about what you rely on in your code.
Pure PHP means you are gaining more performance.
&gt; most people who have been coding for 15+ years realizes that a lot of those libraries are going to stop working eventually or be incompatible with something going forward. I kinda have to call bullshit on this, sorry. Code doesn't just "stop working". Maybe it doesn't work with a new version of some *other* library, or a new version of the core language, but *the same thing is true of code you write*. Don't blindly update until you're sure all the moving parts are going to work after the update (you have tests, right?). &gt; Having experienced catastrophic failures multiple times due to libraries no long being maintained makes you hesitant about what you rely on in your code. Again, if you've experienced catastrophic failure you're doing something wrong. Worst case, you're facing a bit of extra work to fix a bug in an underlying library, or to switch away to a different solution. And again, someone has to maintain the code. If you're not using a library, then that person is *you*. If you're using an open source library and nobody else is maintaining it, then that person is *still* you. You're not actually worse off. By all means be careful about what dependencies you rely on. Review what they do, look at how active the projects are, and give a couple seconds thought to what the risks are, how much time you'll save from using it, etc. Only pick the ones that *are* likely to save you time on balance. But if you're going through life refusing to use Twig because who knows, maybe a 2am one morning the code will just totally stop working and *break your site*, you need to calm down. :)
And it is a bad practice anyways. for example, let's say : &gt; list.php?sort=IdName // select \* from table order by **idname** ASC Instead of the name of column, we could use a number for column, for example: &gt;list.php?sort=2 // select \* from table order by **table.idname ASC** where 2 (a number base 1) is the column table.idname. It is widely used because you could change the order by inverting the number. &gt;list.php?sort=-2 //select \* from table order by **table.idname DESC** And filtering is as simple as a single if($sort&gt;=1 &amp;&amp; $sort&lt;=5) Now, let's say if instead of the name of the column &gt; list.php?sort=IdName We use a column that it doesn't exist &gt; list.php?sort=ThisColumnDoesntExist **// it will raise an error.** Of if the are listing a big table and we are sorting by a column that it's not indexed. Now, what if we use the name of the column &gt; list.php?sort=IdName And the query uses a join where two tables uses the same name of column &gt;select \* from table1 &gt; &gt; inner join table2 on table1.idname=table2.idname &gt; &gt; order by idname **// this query will fail**.
What if the query uses two tables and in each one exist a column called first\_name?. This sort could work: &gt;select ..... order by country.first\_name while this sort will not work: &gt;select .... order by first\_name So we need to map it anyways. Also, if the column name is user input then how we audit (DBA audit) the query?. How we document the query plan?.
The industry has all but standardized 100% on PDO vs mysqli. Here's a case in point: How often do you ever see the [**`pg_query`**](https://www.php.net/pg_query) function in the last, oh, 6 years, much less today? GitHub reports [408,845 results](https://github.com/search?q=pg_query&amp;type=Code), many of which are false positives. The vast majority on the first 3 pages (everyone I saw) were for Data Access Layers, ORMs, etc. E.g., skilled professionals writing abstraction layers for, undoubtedly, MANY different scenarios (no PDO, etc.). But the 408k is proof that the pros are moving away from database-specific functions, for the last 14 years, since PDO came out. [**`mysqli_connect`**](https://github.com/search?q=mysqli_connect&amp;type=Code) has 979,491 results and I couldn't find a SINGLE ORM or DAL in the first 3 pages. They all look like individual projects. No unit tests, either. Due to the youngish nature of most PHP projects, the odds are good that a whole heck of a lot of these are done by not-so professionals who may not be up to the latest trends. A **huge** case in point is just how many ERROR reports are listed, which are also inappropriately stored in github. Have you, ever, stored an error log in git? I mean, I've never seen such a thing. SVN days, sure, but that was more than a decade ago. [**`new PDO()`**](https://github.com/search?q=%22new+pdo%22&amp;type=Code) has 1,384,051 results. The first three pages seem like a mix of about 33% DALs and ORMs and 66% code. No error logs. Two tutorials and 3 unit tests. When these contentious things come up, look at the numbers.
Well, then you need to take a vacation, Mr. Irony, lest we have a repeat of mistakes ala in The Adjustment Bureau! You were so ironic that you were *completely serious*!
/u/9dp7 wrote: &gt; PDO connects with all types of databases not only MySQL. /u/xRockTripodx wrote: &gt; Why are so many of you devs rude about so much? How the *heck* is what he said rude? He was stating a bona fide fact that is a HUGE reason to use PDO over mysqli or ANY db-specific extension in PHP.
It's turtles all the way down.
This thread just shows me that people (not you in this case, colshrapnel) in this sub cannot maintain coherent and logical thread even two levels deep. Deeply disturbing.
/u/joske79 wrote: &gt; No-one said ext/mysql is *just* deprecated. See??? This is yet Another example in this thread of people being unable to maintain logical consistency! In fact, /u/beef-ox wrote, first line of the top of this thread: &gt; I see a lot of people who are confusing mysqli with the old mysql_ functions which WERE deprecated. I'm recording this now before people start editing their comments and REALLY screw up the possibility of rational discourse/discovery!
Yes, I would have said ARE deprecated. Except that I know of many large companies which still use old AF versions of PHP and are just now beginning to migrate code to upgrade to 7 later this year. It‚Äôs absolutely ridiculous, but this is the reality we live in.
Me, too. Triply so. At my last job, full of people I truly respect, only one out out 9 Americans had a college degree, and it was in Physics. They were all great, awesome devs. At my current job, it is full of 11 people who claim to all have 10-15 years of coding experience AND 9 of them have CS degrees. They are several levels below what I'd consider an intermediate developer.
Well, it's easy to make $140,000 in Los Angeles or NYC. In Houston, the cap is around $85,000 to $100,000. It's super frickin hard to get paid that much.
I work with several people who all have 10-15 years experience, and they say the exact same thing to me. The problem is that in 2019 not a single one of them had ever *used composer* to download a package, didn't know what autoloading was, and had never even seen or heard of a unit test. You'll find that people that share the mindset you just mentioned fall into the same bucket. It's really fucking shocking to me.
He edited it. That is not what it said originally.
You're speaking to someone who has never witnessed the security of automated tests. He probably has never installed a package via composer and probably still does `require_once`. His team mates may have literally edited the package outright instead of, you know, extending it, etc. And upgrading by hand may have been an ordeal and blew up the site. People downvote me ALL THE TIME for calling out shit coders. It's part of this whole blameless culture bullshit. But seriously, I bet this is the exact scenario that scarred /u/hattmall.
You'll find that professionals defend DALs, which PDO inherently is, if thinly; while unprofessionals do not. That is what this entire post is about.
I saw someone attacking someone, someone else calling the attacker out on their own bugged code, and you insulting the person who came to the defense of the grandparent poster. That makes no sense to me.
THIS IS A PROFESSIONAL ARGUMENT vs the unprofessionals! /u/scootaloo711 is *obviously* a professional! We as a community need to STRIKE BACK against the legions of unprofessionals who *choose* not to self-educate, self-improve and choose to be LAZY by not learning and practice best practices! Even when it'd mean less work for them long-term! Quit downvoting me and start downvoting people who don't take responsibility for their own development. You can see this pretty easily: How many github repos have they published since 2014? Me? 49. Them? Usually zero.
Apparently, you've let yourself out as being pedantic by responding to me. Obviously I wasn't being LITERAL. I was being FIGURATIVE.
https://v.redd.it/8ueb28vwzlr21 Showed up on r/programming
Thank you
People stopped using mysqli back in the mid-2000s for PDO. By now, it's just derelict and its parent, `mysql_` is already REMOVED from the language. It is ipso facto old fashioned.
Can someone explain to me why /u/HAL_9/TRILLION has -10 downvotes? Literally everything he said is both professional sound and factual. Did the unprofessional mob get triggered? [If this comment gets downvoted past -5, then that counts as Yes].
/u/mrunkel wrote: &gt; MariaDB exists. No need to switch from MySQL to Postgres, just switch to MariaDB. No one mentioned MariaDB here at all??
Code without frameworks *is* harder to write!
Your statement is a true example of unprofessionalism fighting professionalism. /u/pikknz statement that it is far superior to always use a framework is spot on, and if you were at 10x coding level, you would totally realize this. So kindly refrain from preaching to a global audience, many being noobs trying to better themselves, and read several books.
[removed]
SOMETHING CHANGED OVER TEN YEARS GO! Every Fortune 500 company I've contracted to mandates frameworks. /u/beef-ox, you are really wrong in these statements. I wish you would request a formal live-stream debate on this matter with a seasoned PHP professional
But is it worth your time creating all the unit and integration tests, and is it worth your team's and company's time to actively maintain it, when there are already well-tested, well-maintaned functionality elsewhere? Unless it's a core business practice, or such well-maintained functionality does not exist, then the answer is no, and you are doing a disservice to first and foremost your future coworkers, second to yourself, then to the company and the world in general.
StackOverflow
&gt;The problem is that in 2019 not a single one of them had ever used composer to download a package, didn't know what autoloading was, and had never even seen or heard of a unit test. That's a little extreme, composer, package managers and the like are fine to use for prototyping. It's not really a sustainable way to code, but their's often times a disconnect between IT and the Business side of things. The most common scenario I run into is some SME has paid a company a few years back to develop custom software, an in house team has been maintaining it but it's gotten to the point where they are experiencing way to much down time and hire somebody to "fix" their software. Then when you look at it, it's 90% outside code, filled with dependencies that are no longer maintained. Then you have to tell the coders that made thee coders they contracted with didn't even really code much at all and their custom software is going to have be rewritten. Large companies are going to have to build their own. The only place where it's acceptable to have a lot of dependencies is smaller companies that don't know much and in startups that are just trying to get something out working on venture funding. That's definitely where they have their place though and they should absolutely exist to fill that role. If you're writing serious code though for a medium sized business that can't really afford a full team it's definitely seen as cheap to use a lot of outside code and if their in house IT knows enough to stop you they will. Large companies aren't going to let you unless they have a major role in the upkeep with that code.
&gt;Code doesn't just "stop working". Sure it does, when ever someone figures out an exploit or when outside system that you are interfacing with update. Code breaks all the time. If your dependencies aren't maintained you have a whole lot more hours and headaches than figuring out the issue with code that is written specifically for that task. Instead of having to backtrack through thousands of lines of code that do a million things unrelated to the project. It's not that they're inherently bad, it's that some people are way to over reliant on packages. Then when you come in and have to fix something instead of just looking at task specific written code your having to dig through lots of old outdated libraries and every fix breaks something else. If your doing it for your personal site or something where downtime isn't a huge issue it's fine, but if something where downtime is calculated by thousands of dollars per minute it's a different story. Of course there's a right way to do things, but I'm gonna say if it's important, based on my experience I would always err towards writing more code upfront vs including more dependencies.
Recently I have updated my PHP Arrays tutorial with more examples and explanations. What I learned by writing this is it's not easy to explain all the array functions for a beginner as there are tons of. So, I filtered the best (and most used) array functions and added them into this tutorial. If I have missed anything I would like to know. Your suggestions would be ideal to improve my Arrays tutorial. Thank you.
&gt; Sure it does, when ever someone figures out an exploit or when outside system that you are interfacing with update. If the code is exploitable it was always broken. And again, *someone* has to find the exploit and then fix it. If you're using Twig, that's a lot of eyeballs and a lot of people working to fix it. If you're using your own hand-rolled template library...not so much. There's no free lunch here. *Someone* has to maintain the code. &gt; your having to dig through lots of old outdated libraries and every fix breaks something else. [...] if something where downtime is calculated by thousands of dollars per minute it's a different story. Maybe if you're working on a system like that having a ton of old outdated libraries is a problem? And again, *your* code also counts. If you're too lazy (or overworked) to keep your third-party dependencies up to date, you're sure as hell not going to keep all your internal re-inventions of the wheel up to date. &gt; I would always err towards writing more code upfront vs including more dependencies. I hope that strategy works out for you.
Your reasoning should be to build a solid *abstraction* around low-level functions. This way you will have to only rewrite this wrapper's code, leaving the application code as is.
&gt; Tip: Indexes starts from 0, not 1. ... except for times they don't $x= [5=&gt;'asdf', 6=&gt;'qwerty'];
You screwed the pooch on this one https://developer.hyvor.com/tutorials/demo/php/arrays-map
wut. Troll gonna troll I guess
üòÇ ü§£
That‚Äôs my point. The post I replied to said that you‚Äôd be able to switch to Postgres if Oracle mucked with MySQL. You don‚Äôt have to switch to Postgres, switch to MariaDB instead. Sorry if I was unclear.
Your ideas are way too farfetched and overcomplicated. A lot of reluctance is caused by a mere fact that people just don't know anything else and scared to learn anything new.
I fixed this issue. Thanks.
So, $x is now an assoc array, right? "Tip: Indexes for indexed arrays starts from 0, not 1." would be perfect
I am a seasoned PHP professional, though... maybe I have just had weird luck in the jobs I have had? Strangely, everyone I interview who lists Laravel or Code Igniter on their resume can‚Äôt seem to program anything in an extended interview.
You sound like someone who would strictly adhere to the antipattern of every property having a getter and a setter.
Your example next to the tip was an 'indexed array', as you call it. It just started as 0 instead of 5. Either way I think the example you're tying to the tip shouldn't show one where the indexes are being manually assigned. I *think* you're trying to show what generated indexes would be for something like array('asdf','qwerty')
Yeah, what I mean is when we declare \` $fruits = \['Apple', 'Banana', 'Orange', 'Mango'\]; \`, the automatically assigned indexes start from 0.
The OP didn't say "learn"
Except for prepare-&gt;execute-&gt;fetch which doesn‚Äôt work unless you extend or abstract your own like colshrapnel did. The issue is that these methods don‚Äôt return $this, they return booleans. Although, if you‚Äôre going to go through the trouble of extending PDO, do yourself a giant favor and extend the query method to run prepare() + execute() is an array is passed as the second parameter.its just going to make life much easier.
Here is my very standardized caching framework that follows all PSRs until PSR 45: &lt;?php $GLOBALS['cache'] = @include('cache.php'); function saveCache() { $cache = "&lt;?php\nreturn unserialize('".serialize($GLOBALS['cache'])."');"; file_put_contents('cache.php',$cache); } register_shutdown_function('saveCache'); Just put everything you need in $GLOBALS\['cache'\]; Feel free to steal the code for your production.
Just include it in the first line of your application.
Yeah, and what I meant was to be more clear that's what you want to communicate :) The way it was drafted the code vs tip made it seem like you were suggesting to enumerate numerical ids, and the tip was by convention start it at 0.
Yeah, I also notice there's an error in the order and communication. I'll fix it asap
Much better than these "dont do that. Just install this composer package" "developer"
Read my lips: the OP doesn't need any solution, neither a home brewed crutch, neither a composer package. Their problem is imaginary, and imaginary problems don't need any solution.
You can have a list with manually assigned indices as well.
Just let them learn something. Probably he will see that he dont need this. But after that he has learned more than nothing. Its better to do things than said over and over "dont do it"
It is not don't do it. It's 'be sensible and don't fight windmills'. Php is already too loaded with superstitions, no need to spread another one. There are too much PHP users already who are producing the code mindlessly, no need to draft into this army anymore
The "PHP Expert" certificate expired a half year ago. Experts....
Because they only learned to use pre programmed frameworks and ideas. Failing is learning.
Nobody mentioned a framework here. You are either confusing threads or seems to have voices in your head.
... What it the the thing op ends up with if hes making the thing right? Its obviously no caching.
Its "his" desing indeed. But it works for him not very flexible but i see that this forces clean small classes. If your application works with that why not? Its only one way to do it.
I never saw a "normal" big controller and said "yes im gonna test that easily" :D
Why cant the single action classes use OO? They absolutely can
&gt; An array can be declared using the array() function. `array()` is not a function, but a language construct.
&gt;you can post on social media, such as medium.com and post a link here lol wtf, we just need to add a post body to our subreddit and that's it.
Well I would say coupled with the adequate moderation it would be the best solution. But given we have a herd of half-dead sloths for moderators, I can't say the current setup is in vain
That's Crossed-Fingers Driven Development.
MoneyPHP doesn't support fractional pennies which is a bit of a nightmare. If OP's does I'm going to look into it though since it apparently uses floats rather than strings it looks like it might have its own set of problems.
You can test your code with behat or something. Doesnt have to be unit tested to work.
You are absolutely correct. I'll change it soon. Thank you.
Im pretty sure that this 'native calc strategy' is dangerous in whatever way for monetary calculations or any other calculations that requires precision. Floats or no floats
Do you perhaps agree that there are multiple disciplines within software development, and that the type of background you have should match where your interests lie? E.g. if all I want to do is webdev, I don‚Äôt need a CS degree, but if my real passion is e.g. distributed systems design, a fundamental CS background will help?
Why put PHP in this stack at all? By simply installing a MySQL library for Node, you can remove a language, a webserver and network overhead for both the client and your hosting.
You can take a look at our Money library. We've been using it for four years already, transacting millions of euros per year and only one bug with negative numbers found. It only works with BCMath, but it has dynamic scale not to limit the number of decimals required, supports currency and it integrates with Doctrine embeddables. https://github.com/ulabox/money
Yes, PDO is more versatile, so that's why I prefer it. I should mention that your search queries are not representative/usable for statistics. Ofcourse 'new PDO' would not yield that many error logs, because 'new PDO' doesn't appear in the error message. Try these results for example: [Class 'PDO' not found](https://github.com/search?utf8=‚úì&amp;q="class+pdo+not+found"&amp;type=Code) 5M results [Uncaught exception 'PDOException' with message 'SQLSTATE HY000 1045 Access denied for user](https://github.com/search?utf8=‚úì&amp;q="Uncaught+exception+%27PDOException%27+with+message+%27SQLSTATE+HY000+1045+Access+denied+for+user"&amp;type=Code) 295k results Oh, and let's collect credentials.... [pg_connect](https://github.com/search?l=PHP&amp;q=pg_connect&amp;type=Code)
JWTs are most likely _not_ a good way to solve the problems that sessions solve - thought of course without more context we can't say for sure. I just wanted to emphasize that as far as I can tell, "traditional" sessions are _usually_ the right answer, and JWTs are _usually_ not. JWTs are a great answer to a _different problem_. [This article](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/) is a classic.
A section about sorting arrays would be nice. At SO there are daily related questions
Sindhara, Thank you very much. I'm working on it.
Removed in 7.0. and 7.0, let alone all prior versions, is not supported anymore. So in any sensible way mysql ext is not in the language at all. A function that doesn't exist cannot be "deprecated".
True, it *is* not deprecated, it *was* deprecated in 5.5, just like beef mentioned from the beginning.
I can explain it to you in a few words. This is internet. Worse yet, it's Reddit. So people here are to show off. Given any task could be solved different way, and given there could be a few exceptions where a framework wouldn't the best choice, some people would fiercely argue that framework is not 100% always the best choice. As though anyone claimed so. You can make any generalized statement like "one eats a soup with a spoon", and can be sure you'd be accused for lying on the grounds that Japanese would eat a soup with chopsticks. There is no winner in such a flame war. You can either enjoy it and attack your adversary the same way, or simply ignore them.
The comment I'm replying to, which has since been deleted, referred to someone else as a pedant. Most people are different types of shitty... and that's fine. I'm shitty, you're shitty, we're all shitty sometimes. But someone who throws the word 'pedant' around is definitely the type of person who annoys the rest of their dev team.
I honestly don't understand how you'd ever write a decent-sized application without using (quite a lot of) third-party code, unless you're ready to spend thousands of man-hours just getting basic stuff working. Do you just write your own... * HTTP (request/response) abstraction * Filesystem abstraction (including remote filesystems and whatnot) * router * DI container * Event system * Caching system * Queue system * View/templating system * Translation system * Logging system * ORM * Clients for all kinds of external systems: * HTTP client * Elasticsearch client * Redis client * AMQP client ? Would you really write all that yourself? And this isn't some made up list, that's just basic stuff I use every week at work. I can't even imagine having to write and maintain all of that!
Your code is vulnerable to XSS attacks...
&gt; What if the query uses two tables and in all of them exist a column called first_name? Don't really need mappings, just use the correct reference from the beginning (e.g: The UI, the API, etc). Aliases could be used to help with backward compatibility. &gt; Also, if the column name is user input then how we audit (DBA audit) the query?. How we document the query plan? The right answer varies: why are query plans are being documented?
I'd really recommend describing the difference between php arrays and c arrays, anyone who learns what an array is in computer science courses is going to be confused when they get to php arrays in my opinion. It confused me in my early days. Php arrays are really just hash tables.
I assume you‚Äôre trolling, colshrapnel. Deprecated still applies even after removal. Deprecated just means, ‚Äúunacceptable‚Äù or ‚Äúdisapproved of‚Äù in English and ‚Äúthe old way‚Äù or rather ‚Äúdo not use this‚Äù in software. Whether something has been removed or not is irrelevant to its deprecation. It‚Äôs still deprecated.
They are associative arrays or dictionaries. The ADT can be implemented many ways. CS data structures courses should make this concept evident.
We already know, for months because we read RFC and not third party blogs who are always late to the party.
Ikr, sounds more like a sadjeed muhamed
Well, in computer science and most other languages, arrays are a continuous block of memory. Dictionaries and associative arrays are usually hash tables, like I said in my comment.
Thanks for the explanation. I didn't know how the internet worked. Ca n you go and condescend to someone else please. No one said 100%. You obviously don't understand the question or how the internet works. I did win. I would never ignore you you will always be an adversary. Don't give people advice that they did not request. Your ad absurdum is argument is pathetic. Thanks for nothing.
I could not make change method functionality, like array_push() method are use to add element then i will write this will ads element not delete.
Disagree. A good implementation is PCI compliant, effortlessly scales with fewer resources-- which saves money, coupled with a good "object server" for cached results of queries with a ton of joins makes for a snappy system, I won't go back... You can deal with the problem twice... potentially. Or you can do it once. I know what I choose. And yes. You do need to be careful about not turning your custom claims into a kitchen junk drawer. Not local storage; secure, http only cookie... so be cognizant of your key name lengths &amp; the data you are storing. JWTs in addition to actual CSRF tokens... A lot of a good experience is created by having a solid JWT interface with methods that make it all easy to use.
I was in a similar boat -- working as a programmer after getting a bachelor's in general engineering, then went back after a few years to get my master's in software engineering (not CS but there's a lot of course overlap). The degree helps *all the time*. Just last Friday I was pair programming (lots of pairing at my company -- I thought I'd hate it but it's actually kind of growing on me) with another dev who had 15 years of experience and an undergrad degree in economics. We were working on creating a decision tree classifier trained on millions of data points to solve one of those big business problems my boss wanted us to take a stab at. We wanted to see at which depth the decision tree performed best and how that best depth varied with other factors. The "only way" to do this (based on lots of internet research) is just to train a bunch of trees at different depths, but each one took, like, 20 minutes to train and our "best depths" were ranging from 30-40. Also, we wanted to get depths way before and after that point because our plots would be prettier which would help show off the project to the higher ups in the company. So, run it overnight and/or put it in a cloud job or something, right? Well, we dug into the internals of the classifier and pursued a few potential solutions to the problem. I could show, based on the model settings we were using that adding a scoring rule like "stop at depth 20" for a tree that was actually depth 30 would produce the same results as a tree that was actually only depth 20. This isn't always the case, but I was able to explain to my colleague why it was true here. We wrote a function that would progressively "chop off" the last layer of our tree and re-score the decision tree model so we only needed to make a single very large tree but could get scores for all the depths under it. My colleague knew about tree structures in theory, but needed a little refreshing. The way they were being stored and represented in the model creation code was a little confusing as well. So we took a step back, wrote some fun tree code from scratch to get used to it, talked about memory management, how we would restore our classifier tree once we'd mutilated it, etc. After we put everything in place, it worked really well! The tree creation and scoring was wicked fast! Of course, it doesn't take years of formal education to be able to manipulate trees. Trees are easy. But what's tricky is recognizing the situation as one that can be improved, coming up with a solution, showing why your solution will work, reading and understanding highly optimized library code, tricking it into doing what you want (or writing a wrapper), and bundling it all up in some nice clean code. And doing it all quickly and efficiently while teaching others.
At my workplace we make "competency management software", and for this we have a role-tree where we have roles placed in a tree. People are then given some roles, and various requirements are placed on various nodes in the tree. Example: we might have a tree like this: ``` +-- Pilot of airplane type 1 | +--Pilot --+-- Pilot of airplane type 2 | | | +-- Pilot of airplane type 3 Crew --+ | +-- Chief Steward | | +--Steward --+-- Normal steward ``` Then we might require that all pilots have "basic flying course", and that the pilots of each type have something specific to the aircraft. Likewise the stewards might have some shared roles, while the chief has extra. Finally there may stuff like "basic life-saving" that everyone in Crew must have. So you just put stuff that all pilots must have on the pilot node, and then everyone with any pilot role with be given that requirement. There is a quite large number of tree algorithms involved in this software. One example is an algorithm for simplifying placement of requirements. For example if I put some requirement on "Pilot of airplane type 1", "type 2" and "type 3", you can simplify that to just putting it on Pilot. I wrote an algorithm for this, and figuring out how to write an algorithm that: 1. does this correctly 2. does it _fast_ is something you learn by studying computer science.
I think I should not add a comparison of PHP and c arrays because this tutorial is for beginners. They may get more confused when they see a comparison like that. TBH, I was confused seeing your comment until I searched what are hash tables.
There are two things I don‚Äôt understand here: The first is everything you just said. It is entirely incomprehensible. The second is why you would reply to something 50 days later
To use this concept, you will need a server running both PHP and Node.JS. I wrote about this concept on [Medium.com](https://medium.com/@supunkavinda1125/php-node-js-4811d5f8c10a) a few months back. All the source code of the chat app is available on [Github](https://github.com/SupunKavinda/Chat-App-With-PHP-and-Node.JS). Thank you.
Why is it that this example from the `no-floaters` readme evaluates to false? var_dump((0.7 + 0.1) === 0.8)
That's kind of my point though. I think too many PHP beginners lack an understanding of actual data types and structures which is what is taught as entry level in computer science programs. PHP is a C-based language, so I think having a basic understanding of C data types is important to properly understand PHP. Especially considering associative arrays is something that doesn't really exist in other languages.
No 15 year old will be mature enough to work in a professional software environment unless it's literally a dog shit company, and they won't be making anywhere near that, or be worth that.
how about array\_column? one of most handy "new" php functions!
I wouldn't say it's beginner's level though
Not really, associative arrays and dictionaries are a concept abstract from any language, as I said they are ADTs and could be built with anything from hash tables to sorted trees. PHP is using the right nomenclature. I never said arrays, I said associative arrays.
Meh, Node is a waste here. There are plenty of async websocket PHP frameworks today.
This is the best thing I have ever seen.
Django is older than php? Yea, didn‚Äôt think so
This is an engineering problem, and I really don‚Äôt see how you need CS to solve this. You basically described a problem and then at the very end ‚Äúsomething you learn in CS‚Äù. What, attributing shared skills to nodes and having nodes inherit from parent needs a 4 year applied math(CS) degree?
I love how the actual guys making those claims has no examples
I mean depreciated, the loss of value over time. What I deprecate is your comment.
I mean it's not like you can't solve algorithm problem without having a CS degree, but if you have one, you probably know some tools and theory to help you solve it.
data science and machine learning - Python websites - probably PHP ...but they are both languages capable of pretty much anything
That's just how floating point arithmetic works as per IEEE754: it will bite you. Comparing floats is also not really viable (in software in general).
Is it not taught in almost all introduction to computer science courses? What is the definition of a beginner?
i would use message queues to sync php &amp; node states
Well it would be welcome in the computer science tutorial then. See, one cannot embrace the unembraceable. You cannot squeeze into a beginner's tutorial every bit of computer science you know of. Simply because nobody will be able to finish it. So, although it is important piece of information, it shouldn't be in the introductory tutorial. It deserves a distinct article.
Go ahead and use mysqli, it will be fine. Hell, while your using old sql drivers go ahead and down grade php to like 3.2 or something and use the dandy mysql driver. I‚Äôm sure it will be just fine.
If you already use Node Js then why add PHP? And vice versa, if you are already using PHP why not simply add an async library instead of the entire Node Js codebase?
Coming from someone who makes negative comments on a basic programming subreddit, doesn‚Äôt mean much to me.
Wow. Your arrogance is only on par with your ignorance
Please specify my ignorance in my answer. We can discuss in a professional manner or we can banter like children.
You had plenty of time to verify that ignorant statement about mysqli you made yesterday. If you didn't that by now, it's only thanks to your arrogance. Either way, there is nothing to "discuss" about such a silly topic that you can simply pick up from PHP manual.
with php arrays there is a trap that even most experienced php developers will fall into $a = ['a' =&gt; 'foo']; $b = ['6342' =&gt; 'bar']; var_dump(array_merge($a, $b)); it's [a=&gt;foo, 6432=&gt;bar] right? nope.
That's weird. I feel like I'm missing something.
Enough of a topic to belittle someone though right? Tough guy.
Your JavaScript is causing the browser to crash, what do you do?
1. I personally don‚Äôt code JS beyond basic syntax nor web dev so beyond standard checking for infinite loops, commenting suspect parts out and shit like that idk 2. literally no CS program teaches you what to do, most actual programming you do is implementing algos in Java, C or python. Anyone who has a degree knows this is the kind of shit you learn in the job
Hi r/PHP OP here again &amp;#x200B; I've started experimenting with using Rubix ML for image recognition ... the tutorial is coming soon but for the time being you can check out the [CIFAR-10 example project](https://github.com/RubixML/CIFAR-10) on Github &amp;#x200B; Also, we released version 0.0.11-beta of Rubix ML which included many upgrades to unsupervised clusterers including 1. K Means now uses mini batch Gradient Descent under the hood and is capable of [Online learning](https://github.com/RubixML/RubixML#online) 2. New cluster Seeder interface and [Plus Plus](https://github.com/RubixML/RubixML#plus-plus), [K-MC2](https://github.com/RubixML/RubixML#k-mc2), and [Random](https://github.com/RubixML/RubixML#random) implementations 3. Optimizations to [Mean Shift](https://github.com/RubixML/RubixML#mean-shift), [Image Vectorizer](https://github.com/RubixML/RubixML#image-vectorizer), and more &amp;#x200B; View the full [changelog](https://github.com/RubixML/RubixML/blob/master/CHANGELOG.md) here &amp;#x200B; Feel free to ask questions and let me know how you're using the library &amp;#x200B; Thanks r/PHP
I just noticed that. Yeah, it's handy. I'll add that to my tutorial. Thanks.
What result would you expect?
The + operator on array is great, but beware won't replace existing keys: print\_r(\['a' =&gt; 'foo'\] + \['a' =&gt; 'bar'\]); // \['a' =&gt; 'foo'\]
&gt;1. I personally don‚Äôt code JS beyond basic syntax nor web dev so beyond standard checking for infinite loops, commenting suspect parts out and shit like that idk You need to know at least some degree of modern computer architecture and how systems programming works at a reasonable level to cover all possibilities. &gt;2. literally no CS program teaches you what to do, They teach you what you need to know in order to figure it out. And actually many programs today are designed to throw you into the deep end working on legitimate projects. &gt;most actual programming you do is implementing algos in Java, C or python. Oh, right. So a networks class which requires you to implement a chat program using sockets and C but doesn't actually focus on any common CS data structures (because it's assumed you learned those in your freshman and sophomore years) would fall into this category. &gt;Anyone who has a degree knows this is the kind of shit you learn in the job There's a certain threshold where the amount you learn "on the job" can only be practical if you have certain amount of fundamental knowledge as a prerequisite first. I'm not saying a C.S. degree is crucial, here, but I am saying that having a grounding in CS does make a difference - irrespective of how you obtain it. I can tell you that you won't learn it all on the job - trying to will get you fired. And the theory opens up mental facilities by introducing different ways of thinking which a) do make you better as a programmer and b) cannot be obtained through any other means. If you can't implement a hashmap on a white board, you shouldn't be working.
`Values in the input arrays with numeric keys will be renumbered with incrementing keys starting from zero in the result array. ` https://www.php.net/array_merge
I get it, I use php whole ife, but it's so counterintuitive, I'll forget about it in next few years, guaranteed.
What are these ‚Äúconcepts‚Äù that you need to know? Name them specifically. You make everything sound so complex and how level, for example your chat app, Fucking bootcamp grads make full blown chat apps with web sockets like after a month of class. You think people who learn by themselves are incapable of reading up on all these things that your o holy degree teaches you? Just for the record, I‚Äôm a CS grad, but I see through the bullshit professors peddle to their students making them think they‚Äôre learning special skills that other lowly self taught devs don‚Äôt have
that's why $b + $a is solution
Wouldn't change anything with your example since $a is associative and $b is indexed.
think again http://sandbox.onlinephpfunctions.com/code/95ce9e1463f7eda455ce5cee02e9a111e2782fcc
If you use node js then why add PHP? * No Reason. If you are already using PHP why not simply add an async library instead of the entire Node Js codebase? * You can use an async library, no problem.
&gt;What are these ‚Äúconcepts‚Äù that you need to know? Name them specifically. You make everything sound so complex and how level, for example your chat app, &gt; I edited my response. Please re read. &gt;Fucking bootcamp grads make full blown chat apps with web sockets like after a month of class. The web is a tiny bubble of the entire industry, and a poor example: the barrier to entry for that domain with respect to fundamentals is relatively low. The standards for the web are incredibly poor as well. &gt;You think people who learn by themselves are incapable of reading up on all these things that your o holy degree teaches you? Of course not. But very few are able to attain a *complete* picture that a degree provides. *very* few. The level of understanding also varies much more with those who are self taught. Don't get me wrong, I taught myself assembly language and used it professionally in some areas before attending uni. The same can be said about computer graphics and systems programming in general. But the knowledge I've accumulated through a formal education has been invaluable, and has covered so much more than I ever thought it would. &gt;Just for the record, I‚Äôm a CS grad, I've been working in C and C++ professionally for 4 years now, and I'm still an undergrad finishing school. I've worked in real time rendering, reverse engineering, cybersecurity, CAD software and GPGPU. And yet, if you are a grad but you couldn't answer the question I initially posed, I think you're not thinking hard enough. What was the hardest thing you did in school? &gt;but I see through the bullshit professors peddle to their students making them think they‚Äôre learning special skills that other lowly self taught devs don‚Äôt have Some of it *is* bullshit in the sense that the ideals which are taught are often impractical/impossible to fulfill or are coming from a lack of understanding about the industry itself. I won't deny that at all. But to think the kbowled
Read again, I said "with YOUR example" which is $a = \['a' =&gt; 'x'\] and $b = \['321' =&gt; 'b'\], but even that is different since the keys would be in a different order.
Thats why I like array_replace
My point is people in the professional world, whatever field they get into, they read up on this stuff and they learn in, much more in depth than the CS degree even touches on, and that‚Äôs the level you need to know professionally. Barely touching on random concepts isn‚Äôt gonna teach you shit, and that surface level knowledge, most self taught developers already know, because they can learn things too
I never use low level php functions without a big range of unit tests corresponding to my use case. All attempts to use these functions without tests have failed basic assumptions,
Well, basic assumptions are for BASIC, only.
&gt;My point is people in the professional world, whatever field they get into, they read up on this stuff and they learn in, much more in depth than the CS degree even touches on, and that‚Äôs the level you need to know professionally. No, they don't. If that were the case, DHH wouldn't be saying things like "I would fail to implement bubble sort on a white board" as a political statement. There also wouldn't be so many bad developers out there who don't even know trivial basics. It doesn't work that way at all, and if you claim otherwise you're naive or you're trolling. &gt;Barely touching on random concepts isn‚Äôt gonna teach you shit, and that surface level knowledge, most self taught developers already know, because they can learn things too &gt; Let me guess, you think a CS degree is essentially just learning how to write SQL queries, implement trivial data structures, and understanding basic algorithms in Java. At this point it's beginning to sound as if you didn't even study CS. &gt;Also why is it that all you insufferable elitist always C programmers? Oh, I see. You look at my profile history and use the word "insufferable" thinking that's going to make a dent. How clever. Why are you web shits always talking out of your asses and completely wrong when it comes to any technical discussion whatsoever? You know nothing. &gt;You ever wonder why you are always the least paid group? Probably because of all dogma LMAO. Our group isn't "least" paid. At this point you're just a troll who makes empty bullshit claims without substance.
sorry I really don't get what you are saying at all. &gt; a is associative and $b is indexed. both input arrays are associative
Not everybody here knows it. So i am just sharing a news to those who do not know it.
Christ your dense, why do you put words in my mouth? Who said they teach you sql and web dev in school...I‚Äôm saying when you enter the market and you get into something, you learn all that‚Äôs needed about it, we use Go. My coworker is self taught. Dude knows everything he needs to know about compilers. He picked up the same book your professor had to drill into your dumbass and learned. he doesn‚Äôt need to learn all the useless trash elsewhere outside of the scope of what he does. Keep sucking your professors dick, I‚Äôm sure they‚Äôll do a great job assuring you you couldn‚Äôt have learned all the important shit by yourself in 1/3 of the time
Good that the behavior is documented, but why is that the behavior?
&gt;why do you put words in my mouth? Where did I put words in your mouth? &gt;Who said they teach you sql and web dev in school... Where exactly did I say that? I said let me *guess*, you *think* that this is the case. And it's reasonable to assume that. You can't just learn how to program at a basic level and then learn information that takes years to study effectively and understand, unless you're exceptionally intelligent. Most aren't, though,and even then, you won't know *what you do not know*. That is the problem, because it produces arrogant little shits like yourself. &gt;I‚Äôm saying when you enter the market and you get into something, you learn all that‚Äôs needed about it, we use Go. Yes, you moron. I know that's what you're saying. You're confusing trivial bullshit with actual theory - of *course* learning a language is something you're going to do on the job. The whole point of CS isn't this kind of shit,it's about grounding root concepts from which everything is all derived. &gt;My coworker is self taught. Dude knows everything he needs to know about compilers. I don't see at all how this contradicts my point. &gt;He picked up the same book your professor had to drill into your dumbass and learned. And what book was that? &gt;he doesn‚Äôt need to learn all the useless trash elsewhere outside of the scope of what he does. lmao. And what specifically are you referring to that's "useless" trash? Can you give an example in the context you've just provided? &gt;Keep sucking your professors dick, I‚Äôm sure they‚Äôll do a great job assuring you you couldn‚Äôt have learned all the important shit by yourself in 1/3 of the time I never said you couldn't self teach yourself theory. People have taught themselves mathematics in the past, so for me to make that claim would be wrong. I am saying that there is universal theory that applies to *all* areas in software engineering, and very few self taught developers are aware of what that theory actually is. Even fewer actually learn it all on their own. Very few. It's those fundamentals that are important, irrespective of your method of learning them. You couldn't answer my initial question because you don't have an understanding on how any of this shit actually works, clearly, else you would have said something beyond "removing infinite loops". There's so much more to this than just banging out code and reading some domain-specific book. Without the fundamentals it's not going to carry anywhere near as much weight.
Not into the entire ML stuff but that code quality is what dreams are made of!
Because your question is specific and retarded, I‚Äôm not even sure what you mean by ‚Äúcrash‚Äù as there are levels to what chrome crashing is, and you probably looking for a specific answer among a see of correct answers. Your attempt at a shitty gotcha question is quite pathetic tbh. I have written like 300 lines of JS in my life probably. I have no idea how tf v8 works, nor have I ever looked. I didn‚Äôt even know chrome could crash from JS, I‚Äôve just seen and heard about webpages crashing. But not the entire thing. Regardless, I‚Äôd start by looking into crash logs if any to solve it. Im not a pretentious asshole like you who‚Äôs gonna act like he knows everything because I don‚Äôt. Now fuck off back to writing pure^tm C code no one cares about(on vim or emacs probably as is with all pretentious elitist assholes like you) and making a pathetic salary, keep propping your shitty career up by bringing down your fellow devs, because that‚Äôs all you‚Äôre gonna have in life. I‚Äôm done arguing with someone who‚Äôs so disingenuous.
A bit of clarification, in PHP, associative array are only those with string keys. ['312' =&gt; ends up [312=&gt; , as in not a string... These are some "weird" things that happen in a language that's not strictly typed... ( Also the things that make some development faster ...)
&gt;Because your question is specific and retarded, I‚Äôm not even sure what you mean by ‚Äúcrash‚Äù as there are levels to what chrome crashing is, and you probably looking for a specific answer among a see of correct answers. Your attempt at a shitty gotcha question is quite pathetic tbh. This is what you said: &gt;I love how the actual guy making those claims has no examples I came in and said &gt;Your JavaScript is causing the browser to crash, what do you do? You were looking for an example of how studying CS helps with making you a better programmer. Studying CS helps you understand how to deal with issues like the example I gave. You're just pissy because you're wrong. The funny thing about you is that all you've provided is just bullshit insults without substance - you can't even back up the things you're saying. Also, it's funny how you think I'm an elitist C asshole just because I told you I write in it. Look, the fact that most of my career has involved using it should at least provide some kind of evidence that I have some understanding here. I like working in areas where I have control and where incompetence is less likely to be found. In the areas I've focused on, I've found it to be a pretty great. It doesn't mean I think I'm _better_ than you just because that's the case. But of course you being your typical emotionally loaded and passionate self you're going to assume that I'm implying I'm better solely for that fact and you're going to try and use that as a means to "win" this discussion we've been having. I mean, hey, don't get me wrong: there was once upon a time where I was young and dumb and I thought knowing C somehow meant I was the shit. I'm thankful to have been able to grow beyond that. Also, this is the definition of elitist: &gt;relating to or supporting the view that a society or system should be led by an elite. Well, that's how the U.S. operates. It's led by an elite. I live in the US, so if I'm accepting of those views and that makes me an elitist, that's fine. It doesn't mean I think I'm better than everyone else. That said, I tend to be pretty good at being right, and in this case, I'm right. &gt;Im not a pretentious asshole like you who‚Äôs gonna act like he knows everything because I don‚Äôt. Ok, first off: where did I say that I knew everything? I already told you I'm still a student, if anything that should indicate that I still have much to learn. And even after I graduate I still don't expect to be even close to knowing it all. But, hey, I'll have the fundamentals. Those matter. &gt;Now fuck off back to writing puretm C code no one cares about(on vim or emacs probably as is with all pretentious elitist assholes like you) and making a pathetic salary, You sound so pissy. It's entertaining at this point. &gt;keep propping your shitty career up by bringing down your fellow devs, because that‚Äôs all you‚Äôre gonna have in life. Most of my "fellow" devs I'm actually quite respectful and nice to. I like them. They don't say stupid things and they're practical. They also admit when they're wrong, and I do the same. But of course we're all competing together, and you still haven't even remotely answered half the questions I've asked you, which I've asked solely to give you an opportunity to prove your points. You chose to enter this discussion, and you haven't been able back up anything. And I know, you think you understand me because you've looked through my profile history or whatever. You think you can exploit some kind of weakness and play on some adhominem attacks trying to hit a weak spot that you assume I'm too stupid to be aware of myself. There are two kinds of snakes. The ones who use deception intelligently and actually can debate, and then there's the idiots who think they have leg up on their opponent and attempt to twist the situation to their advantage. You're the latter. Enjoy sucking off Paul Graham, tool.
What part of my answer is wrong about chrome crashing? You keep saying I got the question wrong, without even saying why, and pile on 20 more questions and 6 paragraphs on top, and claim how right you are. You can‚Äôt even stay on point, without adding a dozen tangents to the conversation.
Please post this to /r/phphelp instead
Buh bye ‚úã. I've said all I needed to say.
Could you make it any more obvious that your shitty chrome question didn‚Äôt really have a right answer? Do you always ask gotcha questions with no right answer to prove a point? Christ you‚Äôre a sad individual
üëå
TDH I think it would be best to switch to PDO. I hear everyone loud and clear. I just stuck to MySQLi because it was easy to use and I could copy SQL statements directly into it. PDO eliminates the chance of sql injection which I like.
Thank you.
try this in CLI. var_dump((0.8 - (0.7 + 0.1))); You'll get something like this: 1.1102230246252E-16
I'm not saying not to use any 3rd party, but for the heavily used items the goal would be to reduce overhead and dependencies. So some of those things yes depending on the applications needs I would write code that's application specific. Some of those are fairly basic elements so I wouldn't see a reason to bring in anything. It's also a choice of where you want to spend your time, setting up a foundation, or troubleshooting. But again I'm not saying not ever, or not even often, I'm just getting at the fact that a lot of people's primary of programming isn't even writing code, it's just bringing in outside tools for every function. It's not as bad with PHP because you have many more seasoned developers, it's terrible with JavaScript though, which is why so much Javascript is poorly written code that hogs resources like no other.
I think you're right, but I don't think this is a beginner level topic. This is an intermediate level topic. Understanding the actual layout of data types and how they're implemented will not matter much to a new PHP developer until they get to the point they need to start worrying about time complexity in their implementation.
Because most arrays with numeric keys are going to be default keys that don't need to be statically referenced.
Well you either confused the wording or didn't get the idea correctly. In case of the latter, [PDO doesn't eliminate injections by itself, it's only **using placeholders does it**](https://phpdelusions.net/pdo/cargo_cult_prepared_statement). Again, it is not to condescend, but only to be sure, because many people take prepared statements wrong at first. So please follow the link above and make sure you are going to use PDO properly. Just for sake of truth, mysqli does have a support for prepared statements as well but nevertheless I would recommend to use PDO instead. It won't make your code less "old fashioned" but will make your life easier.
That makes sense but I look at this and think to myself that '321' is a string containing numeric characters.
My take on it is like this: deprecated is more advisory while removed is much more strict and final. We are talking of php, not English. And in php deprecated means a certain **status**, not just some vague "meaning". If you know that something has been **completely removed** (and will give you a fatal error instead of a warning that you can shrug off), as long ago as 3 years ago, you wouldn't bother to repeat the popular refrain "has been deprecated".
I worked in software (paid) during highschool and uni; when I finished my Master I had a company with employees and profit. One does not exclude the other and uni does help especially when you want to be a better programmer (robust theoretical underground), social skills and networking (at a good uni your classmates can help you later on it life) or when you want to move up the ladder into upper management where diplomas still are often demanded. Also, in some countries (in EU or Asia) diplomas are often a must as well to get into bigger companies.
What is more important, it will be not only faster, but the site will contain a lot of essential features, which beginners just never heard of, such as proper and helpful error reporting, proper http response codes, powerful debugging capabilities, emails that are not going to spam, and a lot more other things
What is more important, it will be not only faster, but the site will contain a lot of essential features, which beginners just never heard of, such as proper and helpful error reporting, proper http response codes, powerful debugging capabilities, emails that are not going to spam, and a lot more other things
IP, user agent and/or tracking cookies
Hey Reddit OP here with some more detail of my problem. I recently built a system for our company that allows our staff to work flexible working hours. The way it works is as follows: 1. We register a user's mobile device IP on the system. Our DHCP server is configured with static entries for each person's mobile device. 2. A user connects in the morning to the company WiFi and when they log into the system it will check to see if the device (by IP) is a registered device. If it is, the user is asked if they want to clock in for the day. We do this to enforce users not to clock in and out for each other, hence the mobile device. The problem: We have the opportunity to sell this solution (it isn't all the software does but for the sake of my question I don't want to give unnecessary info). We would love to be able to provide flexi time to our potential client while we host the application on an internet facing server. Obviously this solution won't allow our software to see the internal IP of the mobile device, but rather a public IP behind a NAT'd router for all connections. I have looked at implementing a cookie on each device with a device ID with a random value to identify the mobile device but my issue is anyone with a bit of technical skills can copy the cookies from their phone to their PC at home and be able to clock in and out on that PC without having to be in the office. Is there another way I can do this to ensure that it is secure and that we can host the application on a public facing server or is there a smarter way to implement the cookie method? Thanks for your input.
I posted a bit more info in a comment that might be able to provide a bit more insight into what I want to achieve. I have looked at cookies but given the issue it might not work unless I implement them in a smarter way.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Any time you rely on information you store on a remote device, even if it's information you put there, it's going to be manipulable in some way. In short, there is no way to make the system you want 100% secure unless you have administrative control over the end-user devices or provide a black box piece of hardware that goes in/on them. Now if making it difficult enough to dissuade others is a viable approach you can do things like make an initial fingerprint of the device with useragent data, screen size, etc and make sure the connecting device always reports this same information on every request, but still, a dedicated end user could spoof it. Even if you restricted the connections to IPs from mobile network providers only, a user could tether their home PC through a phone and that's that.
You cannot. Everything PHP knows about a client can be found in the $_SERVER array. Nothing much there and almost everything can be faked.
Security is also a big one. Csrf and stuff...
For your second case - barring any VPNs, wouldn't a combination of unique key + originating ip (from the client's network) be a possibility?
Yeah? I forget it every two hours.
We made something similar and authorize devices with a token in localStorage and record the user‚Äôs location on clock in and out. In addition, you could also snap a picture at clock in and out.
Yes, a very good point!
Start with browser fingerprinting: https://github.com/mattbrailsford/imprintjs https://github.com/Valve/fingerprintjs2
Unfortunately some business in South Africa still use ADSL (dynamic IPs) for their internet connections.
There's a provider that has this service that we used for our online casino. It was used to limit the user's number of game instances open. It combined a lot of information to create a "client profile" as discussed by others already; IP, browser used, cookies and many more I can't remember.
Just how to design a software like this. how the classes would look like. No interface, no multiplayer. no client side, just server side. No interaction.
Exactly!
localStorage is just as portable as cookies are though, it's not inherently more secure in any way. It's essentially just cookies that don't get sent back on requests. Location is also easily spoofable - even on phones, as is a camera provider.
Thank you, this is definitely something to consider.
I think it‚Äôs important to have a solid understanding of how vanilla php works but I‚Äôd stick to modern php frameworks for production that are battle tested. I do from time to time like to mess around with vanilla though just because it gives me a sense of building something from the ground up.
Sick of OOP? What sort of Discord is it ...
Says on the tin. Perhaps for oldschool 2000s php coders.
....Any help please
A discord for those who don't know how to utilize the tools given to them
Have you restarted/reloaded your web server software after changing the PHP.ini?
But why would you advocate for old code? Shouldn't you be advocating for modern techniques?
This subreddit isn't for support purposes. You should post your question on /r/phphelp instead.
I'm advocating for KISS, Procedural PHP seems KISS enough, so there you go.
OH come on really!!! What's it for then. Can it not just be for \*anything\* PHP???
Yes I did. Still gives me the same issue
It's in the rules in the sidebar. I quote: &gt; A good rule of thumb is that if you're asking how to do something, instead of why something's done, or how to better do what you're already doing, you're probably asking for support.
&gt;What's it for then It's for PHP related news and tutorials. /r/PHPhelp is for support you can type your question there with more details as the text option with body is enabled and not use the title input.
Not sure how Python fits in here. Procedural PHP is old. You shouldn't teach old things or advocate for them. Yes they have their place. But a dedicated place to circle jerk over how y'all hate OOP is just weird
Complexity (which is what KISS is about) has nothing to do with OOP or not OOP &amp;#x200B; Procedural code can be as (or arguably more) complex as OOP code, it's how you design your architecture and what paradigms you are using.
Well, anything goes these days, even when it comes to [inventing languages based on php](http://tht.help), no one really complains about that. How about supporting this unpopular opinion instead? Python fits here due to KISS principles, code readability and obviousness. Yes, true, Procedural PHP is quite old, yet i doubt that it can't be modernized a bit, i have a handy set of notes what it's about on the server, btw.
KISS is keep it super simple. Procedural is not KISS. Procedural is how you get spaghetti code and spend all day fixing 1 bug.
Just run php --ini and look for Loaded Configuration File in output for the location of php.ini used by your CLI, and on this file with this path add/uncomment extention and try
You could use the crypto api to create a public/private key pair on the device, these are harder to transfer between devices.
It's the .ini file in xampp. Thanks, I'll ask in the phphelp subreddit. I don't understand why have separate subreddits, one for questions and this one for whatever the f\*ck. I mean I'm pretty there are a lot of experts in here who are keen on answering beginner questions. I just find this really annoying like WHHHHHYYYYYYYYYY. Can this not just be for ANYTHING PHP. But anyway dont mind me. Thanks
This case can be solved by defining best practices (like separation of concerns (code-vews)) and being more [strict](https://i.imgur.com/cwSw4yW.png)
Cool thanks a lot. Can i just ask, Am I wrong for asking PHP questions in a PHP subreddit..
You mention xampp, if your running on windows check out [Laragon](https://laragon.org/). Its similar to xampp but comes setup ready to work with Laravel out of the box, plus has quite a few nice tools included too!
&gt;ou mention xampp, if your running on windows check out &gt; &gt;Larag Oh ok cool. Thanks a lot man. Will give it a try
True, and one such best practice can be OOP. &amp;#x200B; I'm not saying OOP is ALWAYS the correct tool for the job, but I would argue it is most of the time. Especially for separation of concerns ( [SOLID](https://en.wikipedia.org/wiki/SOLID) )
**SOLID** In object-oriented computer programming, SOLID is a mnemonic acronym for five design principles intended to make software designs more understandable, flexible and maintainable. It is not related to the GRASP software design principles. The principles are a subset of many principles promoted by American software engineer and instructor Robert C. Martin. Though they apply to any object-oriented design, the SOLID principles can also form a core philosophy for methodologies such as agile development or adaptive software development. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Perhaps that's just **your** experience, everyone has their own
I guess... but the term is ‚Äúmarked deprecated‚Äù to indicate that a piece of code has been slated for removal in a future version. Your arguing that a word should have different meaning in the context of PHP contrasting it‚Äôs usage elsewhere. At this point, it just feels like we‚Äôre splitting hairs.
native mobile app with a webview to your site, set device's IMEI number as header.
Apparently it is not for loud entitled children
Why is a key harder to copy?
I've never seen a project based on procedural PHP that wasn't a huge mess.
It isn't.
Give [this](https://floating-point-gui.de/) a read, it explains everithing.
Why can't this framework just die :'c ? ***sTaHP***
From this sub description: /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required).
Perhaps I wasn't clear. I didn't say that these classes cannot use OO, because if they are classes then clearly they are OO. What I was trying to convey is that this approach prevents us from applying the usual OO design principles, which I believe it absolutely does, because this approach comes with a hard rule of "you must create a new class for your new action method." This is at odds with "put the method in the most appropriate class," which is what common design principles like GRASP and High Cohesion encourage us to do when applied to OOP.
This framework enhanced my php knowledge and gave me a boost to Laravel and Symfony. It's low entry learning curve is ideal for starters and small projects.
But it teaches so many bad habits. The biggest offender is using `$this-&gt;load-&gt;` everywhere. As far as I can tell, there is no way to use dependency injection at all.
It uses the actual names of controllers/methods for request dispatching, it forces default constructibility for models, etc...
I know for a fact that some companies use his exact criteria (crazy eights, no interaction) as a technical assignment when hiring developers, so I have a feeling this might be "homework"..
But it doesn't make sense to renumber them. There are a non-trivial amount of use cases where you might pass around an associative array where specific numbers are the key
RemindMe! 3 days
You don't need Youtube to encode a video, use ffmpeg( [https://ffmpeg.org/](https://ffmpeg.org/) ) instead.
For easier reading : $teacherNames = array(); while (($row = mysqli_fetch_assoc ($result))){ $teacherNames[] = $row [ 'firstName']." ".$row['lastName']; }; $teacherNames = array_unique ($teacherNames);
I will be messaging you on [**2019-04-18 13:29:39 UTC**](http://www.wolframalpha.com/input/?i=2019-04-18 13:29:39 UTC To Local Time) to remind you of [**this link.**](https://www.reddit.com/r/PHP/comments/bdfxpb/can_i_use_youtube_to_encode_a_video_from_mov_to/ekxsu0h/) [**CLICK THIS LINK**](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/bdfxpb/can_i_use_youtube_to_encode_a_video_from_mov_to/ekxsu0h/]%0A%0ARemindMe! 3 days ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! ekxsx8h) _____ |[^(FAQs)](http://np.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^(Custom)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^(Your Reminders)](http://np.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^(Feedback)](http://np.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^(Code)](https://github.com/SIlver--/remindmebot-reddit)|[^(Browser Extensions)](https://np.reddit.com/r/RemindMeBot/comments/4kldad/remindmebot_extensions/) |-|-|-|-|-|-|
First line: We initialize an array called teacherNames Next we are looping through the rows returned from an unknown DB call and adding the values of first and last name separated by a space into the teacherNames array. After the loop we run the php function array\_unique() on the teacherNames array, this would presumably remove any duplicate instances of first space last name.
&gt;$teacherNames = array(); Initialize a variable named "$teacherNames" to an empty array &gt;while (($row = mysqli\_fetch\_assoc ($result))){ Loop through a mysqli result $result (assumed to be set earlier in the code). Each loop, set $row = to an associative array. &gt;$teacherNames\[\] = $row \[ 'firstName'\]." ".$row\['lastName'\]; &amp;#x200B; Concatenates 2 variables $row \[ 'firstName'\] and $row\['lastName'\], then adds it to the end of the $teacherNames array &gt;}; 13 $teacherNames = array\_unique ($teacherNames); After you are doing looping through the results array, call array\_unique which will remove duplicate items from the $teachNames array, then return the result - so now any exact duplicate names are removed.
9 create a new empty array 10 this loop will retrieve a new row until all rows from the table are processed. 11 1. create a full name using firstName and lastName. 2. add it to the array. 12 ends of the loop 13 remove all duplicates from the array and replace de original array with unique array This should make it clear for you. Also try to replace mysqli with pdo
It makes a Db connection and fetch unique teachers FIRSTNAME and last name from database,put the data in and array and it assigned to the teachersnames variable.
Liked. There is a good project for this task - [https://github.com/futurechimp/enigmamachine](https://github.com/futurechimp/enigmamachine)
Line one assigns a new variable called `$teacherNames` as an empty array. Basically you can think of an array (in PHP) as a bucket of values, either numerically ordered or with named keys. Line two starts a loop. This loop will run line three *while* the condition in line two evaluates to a "truthy" value. The condition assigns a variable `$row` to the result of `mysqli_fetch_assoc($result)`. I'm assuming `$result` is the result of a SQL query; `mysqli_fetch_assoc()` returns each row in the result set individually as an associative array. An associative array is the one with named keys, not numerically ordered. Line three pushes a new value onto `$teacherNames`. The value it pushes is a string containing the first and last name from `$row` which are columns in the database. The `. " " .` in the middle concatenates (or "joins") the first and last name with a space. That's what the period does when it sits between two strings. Line four calls `array_unique()` to return only unique names from `$teacherNames`. It will re-assign `$teacherNames` to a new array.
I am wondering if it's better to use `in_array()` inside the loop instead of the `array_unique()`. I would say it depends on the size of the array, but I just don't know.
Yes
The first line just creates a new array (just a list of teacher names in this case) in the variable $teacherName Next you start a while loop ( it loops the code inside while a condition in brackets is satisfied ) - in this case you have a mysql(i - for improved) query and it loops over all the rows `$row = mysqli_fetch_assoc($result)` `mysqli_fetch_assoc()` fetches all data from query row to associative array (dictionary) stored in variable `$row` for example you have table: Teachers | teacher_id | firstName | lastName | |-------------------------------------------| | 1 | John | Doe | | 2 | Martha | Smith | When you run a query using `mysqli_query("SELECT * FROM \`Teachers\`")` and store this query in variable `$result` the resulting associative array for the first row of this query will be `array( "teacher_id" =&gt; 1, "firstName" =&gt; "John", "lastName" =&gt; "Doe")` &amp;#x200B; This is what you get in the `while` loop stored in `$row` &amp;#x200B; Next you process it and store it in a new array &amp;#x200B; `$teacherNames\[\] = $row\['firstName'\]." ".$row\['lastName'\];` &amp;#x200B; This just takes a first and last name of the teacher and joins them with a space &amp;#x200B; `$teacherNames[]` is used in order to add a new value to `$teacherNames` array &amp;#x200B; `$row['firstName']` and `$row['lastName']` is used to access data from row by key (firstName =&gt; John, lastName =&gt; Doe) &amp;#x200B; The `." ".` notation is used to join these two values &amp;#x200B; `.` is basically used to concatenate two strings (texts) &amp;#x200B; The last line `$teacherNames = array_unique ($teacherNames);` is used to remove all duplicate values in array &amp;#x200B; `array_unique()` takes an array and returns another array with no duplicate values - this array is then assigned to `$teacherNames` variable again.
It would be much more effici√´nt, so yes.
it's not a separate language, it's a subset of php
/r/phphelp
Thanks. I went with this one in the end. Not exactly what I had in mind but it worked enough.
Did you turn off the server and turn it on again?
I had to do something similar with Vimeo (pro) a few months back.... and it worked pretty well (mostly short product marketing videos). Not sure if I understood what you really want (using youtube to offload transcoding or simply automate publishing to youtube). In my case it was more about offloading the conversion (it's quite heavy) and retrieve the transcoded mp4 "locally or s3..." (we had a requirement for chinese market where youtube/vimeo are not available. so we can stream from our servers or use the vimeo/akamai cdn depending on the origin). The idea, upload locally (that was a requirement for us, but you can imagine uploading directly to youtube) and save a record in db. Then upload to youtube/vimeo using their apis with a tag holding the primary key / unique identifier for future reference (use a queue or crontab for that). The last task was to retrieve the videos once they've been transcoded (thanks to the unique identifier)... (on vimeo it takes around 5 to 10 minutes for short clips, you'll get 3 resolutions: hd/normal?/sd). I would not do this if I didn't had the requirement for both local streaming and cdn... The easiest way: ask users to upload video to youtube and paste the link in your form ;) But if it helps you can have a look to: - [https://github.com/soluble-io/soluble-mediatools](https://github.com/soluble-io/soluble-mediatools) (a tool I did for a different project, local transcoding with ffmpeg, very useful for thumbnails too) - [https://github.com/nytimes/video-transcoding-api](https://github.com/nytimes/video-transcoding-api) (if you're looking for remote transcoding) - [https://github.com/ankitpokhrel/tus-php](https://github.com/ankitpokhrel/tus-php) (if you have to deal with big uploads) It might be possible to upload from the the client side (javascript) too but I haven't checked. This would avoid the bandwidth usage of your server. I you don't need to keep the original on your server, try a direct upload from the user browser.
Just to add... transcoding is very heavy. It's fine doing it on a laptop, but don't expect to do it on cheap servers. Better to offload (youtube/vimeo or amazon elactic transcoding, bitmovin, zencoder...) .
Yeah I‚Äôm using Laravel now but got my start with inline PHP with no framework, then CodeIgniter.
Yes, I'm aware of what procedural PHP is. I'm not claiming it's a separate language. What I'm saying is: Every single project I've ever seen using "procedural style" was a complete clusterfuck of terrible, unmaintainable code. Do you have an example of a medium-sized project/application, written using procedural PHP, that is **not** a huge mess?
Understandable, but what defines it as bad practices? PSR? In that case i can imagine it needs improvement, but in essence its a great low entry framework.
Now? No, but with community effort i bet we can achieve at least something.
&gt;It isn't. That \*depends\*. You can ask a phone's TPM/SE to store a private key, and then that key is irrecoverable. You can ask the HSM to use the key to sign things to prove that the TPM/SE has the right key, but actually getting that data out is not going to be possible. &amp;#x200B; The problem is that not every phone has a TPM, and SE's are unique to iPhones. &amp;#x200B; As to if you can do this from a server, possibly not, but with an app, pinned keys, and some hardware-security focused design, you might be able to create something that'll make it nearly impossible to get the key from the phone (certainly far more effort than someone would use to cheat a clock in/clock out system)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
it also needs to able to update it. so far i have. &lt;?php $firstname = $\_POST\["firstname"\]; $lastname = $\_POST\["lastname"\]; $person\_file = fopen("directory.txt", "r"); do { $person = fgets($person\_file); $person\_array = explode(",", $person); if ($firstname!=$person\_array\[0\]) { echo "First Name: &lt;input type='text' name='firstname' value=$person\_array\[0\];/&gt; "; echo "Last Name: &lt;input type='text' name='lastname' value=$person\_array\[1\]; /&gt;"; echo "Email Address: &lt;input type='text' name='email' value= $person\_array\[2\]; /&gt;"; echo "Phone Number: &lt;input type='text' name='phone' value=$person\_array\[3\]; /&gt;"; echo "address: &lt;input type='text' name='address' value= $person\_array\[4\]; /&gt;"; echo"city: &lt;input type='text' name='city' value=$person\_array\[5\]; /&gt;"; echo "state: name='state' value=$person\_array\[6\]; /&gt;"; } &amp;#x200B; else {echo "no contact";} } while (!feof($person\_file)); fclose($person\_file); &amp;#x200B; ?&gt; thank you in advance
This post will be deleted in 24 hours
This is pathetic
 it also needs to able to update it. so far i have. &lt;?php $firstname = $\\\_POST\\\["firstname"\\\]; $lastname = $\\\_POST\\\["lastname"\\\]; $person\\\_file = fopen("directory.txt", "r"); do { $person = fgets($person\\\_file); $person\\\_array = explode(",", $person); if ($firstname!=$person\\\_array\\\[0\\\]) { echo "First Name: &lt;input type='text' name='firstname' value=$person\\\_array\\\[0\\\];/&gt; "; echo "Last Name: &lt;input type='text' name='lastname' value=$person\\\_array\\\[1\\\]; /&gt;"; echo "Email Address: &lt;input type='text' name='email' value= $person\\\_array\\\[2\\\]; /&gt;"; echo "Phone Number: &lt;input type='text' name='phone' value=$person\\\_array\\\[3\\\]; /&gt;"; echo "address: &lt;input type='text' name='address' value= $person\\\_array\\\[4\\\]; /&gt;"; echo"city: &lt;input type='text' name='city' value=$person\\\_array\\\[5\\\]; /&gt;"; echo "state: name='state' value=$person\\\_array\\\[6\\\]; /&gt;"; } \&amp;#x200B; else {echo "no contact";} } while (!feof($person\\\_file)); fclose($person\\\_file); \&amp;#x200B; ?&gt; thank you in advance
Great! I have tons of CI sites that are still running beautifully, sites that I did years before Laravel was around, and while Symfony and RoR were around, they would have been drastic overkill for those types of low-traffic, shared hosting web applications. I would still use CI on a new site, if it was a simple application with no API endpoints. Who knows, maybe CI 4 will have features that will make it competitive.
Not if you know how to use its routing features.
Good point, I hadn't considered HSMs.
I started picking up MVC frameworks in PHP with CodeIgniter, with absolutely no idea of what I was doing. From there I moved on to Yii 1.1, which my job at the time used, and today I use Laravel - all day, every day. I've picked up a lot just through using it, but I'm still trying to grasp some of the finer points - especially the ones that Laravel doesn't implement out of the box. &amp;#x200B; Let's start with the obvious ones: &amp;#x200B; Controller: The traffic cop. Accepts incoming requests. Based on data present in the request, retrieves data from elsewhere in the application, then renders the view using that data. Doesn't execute any logic short of determining what view or redirect to send to the user. View: When you have your data, you render something with it. This is generally HTML or a template file like Blade or Twig. Could be XML or something else, so long as its shown to the user (is a JSON payload a view? I suppose not, if you don't have an actual view file being rendered). &amp;#x200B; Let's look at models. There are three distinct concepts here, that I feel most PHP MVC frameworks tend to combine into one: &amp;#x200B; Model: In most implementations of PHP MVC frameworks, this is obvious, but if we talk about broader MVC concepts, the PHP implementations seem to be more misleading. The way I understand it, a model is purely and simply, an abstraction or representation of a concept. Any concept. If the class represents something in the real world or in the domain, then it's a model. Entity: A model with an identity. A User can have a model, and the model for the User with an ID of 7 would be an entity. Repository: A layer of abstraction that sits on top of your data persistence and disguises the actual method of persistence. One shouldn't need to understand how data is persisted to use a repository. &amp;#x200B; To use Laravel as an example, all three of these concepts sort of seem to end up mashed together. What Laravel calls Models would actually be Entities, and rather than a repository sitting on top of model access, instead its 'baked in' to the base model implementation. The database abstraction is still there - I can change my database driver on the fly, so long as it can be accessed with the PDO implementation - but it's much less of a distinct layer. The concept of standalone models - models without identities or persistence - doesn't really exist in Laravel (I mean, you CAN make a model without persisting it, but the framework is clearly written with that as a secondary concern). Am I right on this one? &amp;#x200B; And finally, some of the vaguest terms: &amp;#x200B; Service: Any class that does anything that doesn't fall under any of the other definitions. To use Laravel as an example again, it does contain specific directories, base classes, etc. for Jobs, Events, Requests - are these services? Or something else? Library: Same thing as a Service? Maybe? Or every Library is a Service, but not vice versa? I would categorize a Library as a collection of related but individual methods (ie, a String Library containing multiple methods to manipulate strings), but at this point the definitions start to get so vague that it sort of seems to start being up to everyone's individual interpretation.
You could easily check if a class' member variable is set and conditionally assign the value of a $this-&gt;load class in any constructor. I've used this type of simple dependency injection in many frameworks that do not natively support it, it's easy and effective. Perhaps the bad habits come from frameworks that do too much for you, people get spoiled.
You mean, the naked array of arrays/functions/strings : no thanks.
Thats the point. You could do exactly what you're saying, but find me anything in the documentation that suggests it. The framework and documentation promote these bad habits as standard practice.
Is this for absolute not using OOP or for using is where it has it's benefits but prefering procedural style?
Hey, Sindhara, just a quick heads-up: **prefering** is actually spelled **preferring**. You can remember it by **two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
CI is probably my all time fav! Especially for all the prototyping I do. This framework made a huge impact on development when it came out and Im glad its still active.
delete
No, that's not what I mean. You've obviously never worked on an enterprise CI implementation. I have seen routes created programmatically in a number of flexible ways, including based on database records, others that simply process the route names based on a naming convention unique to the application. Remember, the routes file is a php file - you can write any code you like to create your routes, it's only limitation is the coder's skill, experience, and imagination.
Please format your code, it's really difficult to read when it's not formatted at all. Reddit offers a built in "pre-formatted" text block, just preface every line with 4 spaces. You could also paste the code into Pastebin: https://pastebin.com/ or create a GitHub Gist at https://gist.github.com/
routing from DB üëå sounds efficient and performant
26 &lt;option disabled selected value&gt; -- select a student name -- &lt;/option&gt; 27 &lt;?php (start parsing) 28 foreach ($studentNames as $value) { 29 echo "&lt;option value='$value'&gt;$value&lt;/option&gt;"; 30 }; 31 ?&gt; (stop parsing) 56 &lt;script&gt; 57 var x = document.getElementsByClassName("color"); 58 var i; 59 for (i = 0; i &lt; x.length; i++) { 60 var temp = parseInt(x[i].innerHTML); 61 if (temp &gt; 59){ 62 x[i].style.backgroundColor = "green"; 63 x[i].style.color = "white"; 64 } else { 65 x[i].style.backgroundColor = "red"; 66 x[i].style.color = "yellow"; 67 }; 68 } 69 &lt;/script&gt;
Burn
Sorry I don‚Äôt know how to do that and the Line by line I feel would give me a better understanding thanks
Which feature are you referring to? I can't seem to find anything of the sort in the docs
That's a very good question which I asked myself many times. In the end I made a single assertion that helped me to get everything in the perfect order. I always heard that Model should represent the whole business logic of the application. However, it makes little sense as long as there are multiple models. Yet it makes perfect sense if we assume that there is only one Model per application. From this point of view we can make everything else clear: entities, repositories and services or helpers) are all belong to a single Model. Whereas Controllers are just interfaces to let Model to interact with http client. I wrote a short article where I summed up my thoughts, hope it will make sense for you too: [MVC in simpler terms or the structure of a modern web-application](https://phpdelusions.net/articles/mvc)
The htaccess pull is garbage.
The burn is on the poster himself, not me. It just shows that he's never built a CMS that allows admins to enter the SEO-friendly URLs for page they create, as well as functionality that avoids duplicate names, illegal characters, etc. Downvote my responses all you like, but this matter of mistaking inexperience for being opinionated would disqualify any of you from a first-round interview with any company I've worked for. It happens when interviewees blame frameworks for simple things they do not know how to code.
Check out /r/PHPhelp
are you even trying to understand how proper routing works?
In Laravel, Controller: With the Kernel, handles ALL of the request lifecycle (request -&gt; kernel -&gt; routing -&gt; middleware -&gt; controller -&gt; response), not just the incoming request. It handles the response returned from the server as well. View: Can be anything really that ends up using data from the controller, so yes your assumption here is correct. In the case of Laravel, Blade is used for HTML templating. Model / Entity / Repository: I would agree that a model in Laravel is a conglomerate of all three of these, since Eloquent is an ORM that does data mapping, relationships, and querying out of the box. &amp;#x200B; &gt; The concept of standalone models - models without identities or persistence - doesn't really exist in Laravel (I mean, you CAN make a model without persisting it, but the framework is clearly written with that as a secondary concern). Am I right on this one? In Laravel, a standalone model wouldn't need to be part of the framework itself since it is doing just as you said -- modeling one thing, and that one thing would hopefully pertain to your project as business logic. Simple data objects don't need to be part of the framework. &amp;#x200B; &gt; **Service**: Any class that does anything that doesn't fall under any of the other definitions. To use Laravel as an example again, it does contain specific directories, base classes, etc. for Jobs, Events, Requests - are these services? Or something else? I would say this is correct. They add some kind of functionality to your application, and as such, provide a **service**. &amp;#x200B; &gt; **Library**: Same thing as a Service? Maybe? Or every Library is a Service, but not vice versa? I would categorize a Library as a collection of related but individual methods (ie, a String Library containing multiple methods to manipulate strings), but at this point the definitions start to get so vague that it sort of seems to start being up to everyone's individual interpretation. This is true yes. I would say that in Laravel, a library is a collection of many services &amp; other constructs. You can register routes, migrations / seeds / factories, providers, controllers, views, models, services, etc which adds additional functionality to your application, but is separate and modular from your application itself.
You tell me what is improper here: http://blog.newmythmedia.com/blog/show/2016-03-08_Routes_in_CodeIgniter_4
To me, the docs get you up and running in the simplest fashion. Most very simple websites will never benefit from it, but any experienced PHP programmer who wants dependency injection can code it very easily. Again, if I were to interview a coder who said they would not use CI because of lack of DI, they would fail the first interview. It's up the CI docs to show how the framework works, but anyone who knows PHP can make it do whatever they want.
you can post this link 100 more times we won't be on the same page I think. whatever floats your boat, mate..
Weird seeing people that will never use this framework come in this thread bitching about this framework. Obviously this news wasn't meant for you in the first place lol. Just don't use it and go on about your day lol, it's not a hard concept. I see the same shit for laravel, yii and any other framework that isn't symfony. I personally love Flex, but I'm not about to go shit on someone else for not using what I'm using. It's not that serious and if things like this anger you then maybe you should reevaluate the things you focus on in life.
Well there's no time like now to learn! Navigate to Pastebin and the first thing you see is a giant text box, just paste your code in there, make sure it's on newlines like you see in your text editor, and don't copy those line numbers either! As for an explanation, how about this, here's the PHP manual for getting started, they run through a couple "hello world" type scripts and explain the basics. https://www.php.net/manual/en/tutorial.firstpage.php Keep in mind too, I'm seeing a mix of HTML, PHP _and_ JavaScript in that little script, so you're jumping between 3 different things here, too.
The rules are laid down in the server
CI4 is a complete rewrite. You should take a look at the code before bitching about something you saw years ago.
Me too, but I feel I should have learned framework-less PHP first. It kind of bit me later on when I tried to learn Magento, and didn't know what the hell was going on. As for ci today, for small projects I would use Lumen. For large projects Laravel. It just keeps things simpler. I still need to learn proper OO-PHP though as I don't really have a good knowledge of it.
To understand Model in MVC requires you to know some history of MVC. MVC started out as a simply *pattern* for representing a reactive graphical user interface. The view was was what rendered the data, and the model stored the data and behavior for how that data should change or interact with other data, where the controller directed user input to the right model behavior. The pattern was very tight. MVC then got adapted for the server side, where it became a high level *architecture* upon which to organize your code. In this context, Model is not a single type of class. Model *is your entire domain*, and it is comprised of any number of classes necessary to make that domain function. This *includes* DTOs, value objects, entities, services, utilities, repositories, observers, mappers, transformers, validators, factories, foos, bars, etc etc (whatever makes sense to adequately model your domain). While views and controllers are fairly specific, concrete things, your Model (capital M) is not. It just means your domain. In the original pattern, a model was a very specific thing, but in server-side MVC, the "M" means "your whole business domain layer". Now, that said, part of your ***M***odel may also include data models (notice the lower case "m"). Data models may very well represent rows in a database table, or other specific bits of your domain, but they have a very specific purpose and should not be confused with the over-arching nebulous ***M***odel in MVC. Some MVC apps may not even have data models, but by definition will have a single ***M***odel made up of many different classes. So if you've ever heard the phrase "skinny controllers, fat models", this is wrong. It is "skinny controllers, fat Model" (upper case singular). Where the code that is part of your Model is split between whatever classes should have what responsibility. For this reason, I don't like the terminology of MCV. It's really View, Controller, and Everything Else. Sadly, because views are concrete things, and controllers are concrete things, people assume models should be concrete things too. So they hear "skinny controller, fat models", and wind up with 3,000 line god classes in their "models" (which end up being a random mess of service methods, state, and data). This is simply wrong. Nothing about MVC changes the notion that you want classes with focused responsibilities and limited scope, which means you're going to need LOTS of different classes that are responsible for specific things, and the sum total of all of that becomes your ***M***odel.
You're right. I wasn't trying to imply localstorage was any more secure than a cookie. I was just sharing what we did. Essentially, the combination of the 3 provided enough deterrent to try and fake the click ins. I suppose if your workers are engineers you might have to worry about it. If you're happy with you're current system, you could send the client a raspberry pi that could act as a proxy between their devices and your app, which could send you their ip addresses.
I did dabble with oop before laravel but learning laravel really opened my eyes to its potential and usefullness. It did so many things right and i wowed the whole time while learning it. I think its good to start learning pure php and then move on to things people actually use. Like you said, i had almost no idea about exceptions or logging or anything like that. I have to mention that i am self taught so experience for schooled developer could be different.
Ya know, I skipped CI and went with Kohana. They were extremely similar, but I still really like the way they handled frameworks. It's rather amusing to see people argue over how routing should be handled and how various other things need to be handled. Give it a few years and we will be on to some different approach. If it works and you are efficient with it, then I see it as a positive. I never really cared for Laravel or Symphony because they are just more complex than I feel useful (for myself). I see where their power is great for professional/enterprise developers, but for the average users, I feel like CI/Kohana and the "lighter" frameworks are far better suited. I really dislike how long it seems to take to learn a lot of the modern large frameworks, and a lot of the "newer" methods of handling things are fairly confusing at first (such as routing, the whole request/response crap) etc. &amp;#x200B; Take what I say with a grain of salt, because I'm only an intermediate type, still learning by making my own framework.
I looked at it today, please show me different so I can apologize for my "bitching"
This was released almost 2 weeks ago, it's been posted here before.
Do i need math for machine learning?
You looked at it and didn‚Äôt see there‚Äôs no more $this-&gt;load in CI4? There is a lot of new and improved things. Everything is namespaced, there‚Äôs autoloading, etc.
&gt; Again, if I were to interview a coder who said they would not use CI because of lack of DI, they would fail the first interview Lack of DI is the least of its problems. &gt;It's up the CI docs to show how the framework works, but anyone who knows PHP can make it do whatever they want. Sure, the docs and the framework promote poor design, but you can just rewrite those parts to do whatever you want! I'm done here, this is getting really stupid.
All the replies so far have been helpful - but this one is like a bolt of clarity from the sky. The understanding of 'Model' to mean 'your entire business domain layer' just clarified a thousand small questions and what-ifs and what-abouts I had about the entire MVC architecture. Your point about enormous god-classes is 100% on point and one of the things that I've run up against in countless projects (typically in a model). It also contextualizes the constant barrage of 'your model should contain all your business logic' - this never seemed correct to me. I understand now that this is because I was understanding 'model' to mean 'specifically data persistence models', so no wonder.
My apologies, i literally just realized I clicked back to the 3.x documentation. I'll have to look at it again.
Well, SoapClient will do the mapping between your input and the xml AND the mapping between the xml returned by the endpoint and your output. If you want to reimplement both you have two choices: \- Either knowing perfectly how a WSDL can be structured and reimplement every mapping strategy \- Or have a specific xml builder and xml parser for each endpoint you want to consume. &amp;#x200B; The first option seems a PITA to implement and the second mean more work for each new endpoint as you would have with SoapClient. &amp;#x200B; There is a third option you may want to consider: SoapClient has a \_\_doRequest method you can override and replace any http fetching you want while keeping the mapping and parsing intact. (I've done that with curl instead of the basic HTTP request for specific needs)
I think he‚Äôs simply giving an example of why some developers avoid third party dependencies. By definition you‚Äôre depending on a (potentially unreliable) third party. Of course, thats a strange line of thinking but I think it‚Äôs what he was trying to convey.
After this revelation, you may wish to look over the [Action Domain Responder](http://pmjones.io/adr) pattern. As it turns out, MVC is simply not for server-side implementation; ADR is.
&gt; still learning by making my own framework. But... what are you learning? I don't mean that to be snarky... just... do you have real goals? Or 'just learning'?
That depends on how deep you want to go with ML &amp;#x200B; You do not need to know math to use Rubix ML (I've abstracted the hard stuff away for you) - however, understanding the intuition behind concepts such as distance, dimentionality, basic statistics, and probability would be very helpful to know &amp;#x200B; If you want to understand machine learning from a deep/fundamental level then math is a requirement &amp;#x200B; The following maths show up fairly often in machine learning: * Linear Alegbra * Multivariate Calculus * Statistics * Probability
&gt; Last stable release: 3.3.6, **July 2016** for **PHP5** Rofl no thanks. Make it easy on yourself and look at [Slim](https://www.slimframework.com/docs/) if you insist on avoiding Symfony and Laravel.
Feel free to explain what you think "proper routing" involves instead of just being an absolute jebend to people trying to engage in conversation.
Mostly, I've never made anything out of years playing with php aside from fairly simple sites. I've made a basic forum, article comments and that basic kind of thing with existing frameworks, but I got the itch to make my own and see what problems I would run into and could solve. I've managed to keep it simple and effective. Really nothing depends on the other, it's just kind of tied together with a bootstrap (so framework is probably the wrong word here). The end goal is that if I ever needed something outside my skill set (let's say a super technical router), I can add the files and roll with it. I don't think any core files has been dependant on having anything else, which has led me to not needing DI at all. Just making something for the sake of understanding the processes better, trying to simplify what seems to always be more complex than it needs, and once I'm done, to get feedback (never worked with a group or shared code before). Also, I just like to code, and I had no idea what else to make lol.
I don‚Äôt know what you‚Äôre building but I can‚Äôt think of a single reason not to use the SOAP client to interact with a SOAP service. I can‚Äôt think of any benefit you‚Äôd gain from your reusable client object, given these APIs use different standards and presumably are on different domains and serve different functions.
I don‚Äôt know what you‚Äôre building but I can‚Äôt think of a single reason not to use the SOAP client to interact with a SOAP service. I can‚Äôt think of any benefit you‚Äôd gain from your reusable client object, given these APIs use different standards and presumably are on different domains and serve different functions.
I learned CI vack in the day, then went Kohana, but I think that Kohana shot themselves in the foot with verson 3. But that was almost 10 years ago and tue way "we' think about how things should be has changed a lot and our tooling.
"MOV" and "MP4" are container formats. And in fact "MOV" is the same as "MP4", so you just need to rename the file and be done with it. You don't even need to remux things. If you talk about changing the encoding of the included video or audio streams, then that's an entirely different story.
Ya, I didn't care for 3 at all. I really liked their orm and orm tree. I've managed to make a pretty clean qurry builder but so far still haven't quite been able to make anything like that, out of my league there lol.
let me answer the other way around instead: op talked about enterprise CI routing defined in DB (seo-friendly urls). this is what I call bullshit in the first place. enterprise. why? how? because it's seo-friendly? what does that mean? if op thought about urls (slugs) stored in the DB (of course they are), I'm pretty much sure these aren't mapped directly to the request URI. if so, that's highly inefficient way of doing routing. so I think op thought about different routes defined by regex rules which then mapped to different entities after all. let me ask again: how is this enterprise again? how is this more advanced (according to op's definition and CI's poor documentation) than anything else in the market? how is this more flexible than Symfony's or Laravel's routing?
`ext-soap` is quite the nightmare (because of its huge list of php-core weirdness), but building your own is worse. Give [https://github.com/goetas-webservices/soap-client](https://github.com/goetas-webservices/soap-client) a try instead.
Mind that the SOAP spec has some ambiguities and people implemented it with slight variations. The soap extension has handling for many common varieties of SOAP. Depending on your requirements (do you need arbitrary endpoints or are the endpoints your talking to known? Do you need a WSDL/SOAP feature `ext/soap` doesn't support?) and priorities (where do you want to spend your time?) you can decide to reimplement that or stand on proven shoulders.
Man this 100%. These are the same people who don‚Äôt do absolutely anything to help grow the PHP community. They simply bitch online constantly about anything that isn‚Äôt their own tech stack, so anything outside of it is ‚Äúcomplete shit‚Äù. This shit is rampant everywhere on the internet. These types of people are just miserable. They don‚Äôt seek any happiness, only to bring others down with them.
Then you need to handle key collisions anyways and array_merge isn't appropriate. There's a language level construct for that use case: the + operator.
It's also worth pointing out that what Laravel, CodeIgniter, and all the rest of the main PHP frameworks call MVC is not what the rest of the programming world calls MVC. Rather, what PHP devs implement is MVVM - Model, View, View-Model. (The "controller" (view-model) acts as a wrapper around the view and model, mediating all communication between them.) There's nothing wrong with MVVM/PHP-flavored MVC; it's just that C# devs like to laugh at us when we use a term in a different way than they use it, and use it as an example of how PHP devs are stupid. Older styles of PHP-ish MVC is more of a Database Abstraction Layer/Template/Super-Controller system, where the model does not have any business logic whatsoever (very bad idea), the view has no logic at all, and the controller freely mixes business logic, data access, etc., in route-specific calls. There *is* plenty wrong with that. In the *classic* MVC design pattern from the 1970's, each view gets the data that it needs directly from the Model, rather than having the controller pass data along. The view is responsible for *everything* that is necessary to render information for the user. The controller's job is to handle user input, such as mouse clicks, typing, etc. It would update the Model, then notify the view that it needed to be refreshed. And, of course, the Model is the state of the application, bound business logic that the Model itself implements, rather than having it dictated by any single view or controller. Now, web development is a bit different from desktop GUI app development... Classic MVC doesn't have the concept of request/response calls to a server... Either everything was local, or the Model handled retrieving data from the server without any prompting from either the views or controllers. Web development, on the other hand, is founded on the idea of request/response. If we wanted to use purely classic MVC for web apps, it would have to be a Javascript driven application, with the web server only delivering static files and JSON (or whatever appropriate format) data instead of building dynamic HTML documents. The way that PHP developers get around this, is to treat the user's request as user input, and fire up a controller to handle that input. Other languages have the paradigm that a user request is not input, but rather is just a request to use a specific view, so controllers only exist if the user is doing something more than just following a link. (I.e., they've submitted form data, or have gone to a link that should have special effects despite being a GET request, such as going to a /logout page.) And, of course, classic MVC has no concept of URLs or routing.
&gt;The last thing we need is more vulnerable code in the wild.The readers seeing this code and thinking it is useful for them. STOP. DO NOT USE. Its just an example!
OP is asking for a secure solution that can't be emulated on a home computer. A header on a REST request is probably the least secure thing anyone here has suggested.
There is no MVC in Laravel.
Just use pimple. Its not that hard if you think outside the box and read through how CI bootstraps itself. You can use get\_instance() in a service provider to pull out any of the CI stuff you want to use in your class. I maintain a ton of legacy CI 2.0 apps and its always a pleasure to pull features out into a namespace and have them be well tested.
I have three end points and am calling one method on each, really basic usage that I could very easily re-use the client I'm currently using. I'm not opposed to using the SOAP client by any means, was simply curious as to what others thought.
Nothing crazy, calling one method at three different end points. It would be very simple to extend the client I am currently using but I'm not opposed to using the SOAP client - just wanted to see what others thought.
Haters gonna hate on CI, but personally it has made me allot of money getting apps up and running faster and leaner than any other framework. Slim is close but CI for me is just more flexible. I like to think of it as a light framework that just has enough to make it worth learning. I am looking forward to CI4 and Trongate to be released.
I mean - I know you're specifically asking for how to use a text file as a database, but Jesus Christ, why? Why not use any of the dozens of viable database options currently available? Performance will be way better, and you won't accidentally corrupt your only source of data.
I'll wait for array_real_key_first()
I can't see them without joining. So you could share them here when you're searching for new members
Sounds like an interview question or homework to me ;)
How is CI more flexible than Slim? You can wire Slim literally however you want whereas CI is much more similar to Laravel and Symfony in scope.
Hopefully [there's](https://paste.ee/p/Tih4Q#k2NT3znwwIFHxbEe8ToDO8pC51NqwwKV) not a lot of contradictions
I really can't get my head around this [https://codeigniter4.github.io/userguide/incoming/filters.html](https://codeigniter4.github.io/userguide/incoming/filters.html) Does anyone know why they deiced to go against what everyone else in the PHP community has considered good/best practice in PSR-15 middleware? I can't begin to think why they thought doing their own half baked solution would be a good idea, it's just going to produce a lot of code that is a complete vendor lock-in to CI instead of it being transferable. Are there any CI devs here or any links to blog posts on why this decision was made?
If that‚Äôs all there is, you could implement your own client as a learning experience I guess. But I‚Äôd use the built-in client and get to shipping.
I guess I would have to ask how can you not wire CI any way you want? Every time I think I had hit a wall with needing CI to work a certain way (like pragmatic routing) I found it was easily implemented.
I don‚Äôt use any frameworks. Talk about light.
Some people enjoy writing their own code instead of relying on other people. Maybe this person wants to be the person who made the framework you rely on.
Nice! Do you have any libraries handy that you use often?
CI has many [conventions](https://www.codeigniter.com/user_guide/libraries/loader.html) and [opinions](https://www.codeigniter.com/user_guide/libraries/uri.html) about the way you write your code; it's more work to circumvent a feature than to adhere to it. Slim simply lets you wire your app up however you want. You said CI was more flexible than Slim, and I just don't see it.
Nothing really on the back end. I have many on the front end. I basically started using PHP back when it was the Wild West, and you had to write everything yourself.
This is a great summary. I've always had a hard time explaining why MVC isn't a good enough way to explain what's going on in an application other than "so where in your definition of MVC does business logic fit?"
"Everyone else", I hate to break it to you, but most of the community don't really give a flying toss about PSR outside of the early ones like PSR-4. Most of the projects that the majority of the community use were either never part of PSR/FIG or have left (often because they have issues with it), I.E - Symfony, Laravel, Wordpress, Doctrine, Guzzle, etc. As a standard PSR is a joke, the most used PHP projects don't use anything but the early PSR's and have expressed outright hostility to some of the later PSR's and way the PSR project has gone. Codeigniter is not a member project, there is no reason for Codeigniter to follow these failed "standards", that for the most part are just another framework in disguise.
I wasn't saying it's inherently bad or wrong. I've gone that route myself, but also know that had I had a plan, or something more than just "XYZ is too bloated!" I'd have gained more experience faster. I see it quite a lot with people who code their own stuff because in many cases they didn't understand the tools available in the first place. That *really* highlights the fact that many tools/projects/libraries are so poorly documented that many potential adopters simply don't understand them enough. I'm often really excited by finding a decent library that has decent docs, sample data and tests that are up to date and functioning. The absence of those alone often drives people to write their own stuff, even if the end result is demonstrably bad (or worse than the available tools). "instead of relying on other people" - everyone does - every bit of the internet and code the OP is using is the result of other people relying on other people, and so on. It's fine to say "I'm gonna try this myself". Often you simply learn that DIY is harder than it looks, and that you end up seeing the 50 other use cases that other tools support that you never even knew about (or said "I'll never need that" until you did). "Maybe this person wants to be the person who made the framework you rely on.". To get far more cynical about it, maybe this person will make their own "framework" that will cause their company a lot of pain because it's 100% NIH, has exploitable security holes, performance drags, is untestable and is causing their company a huge disservice because everything takes 4x as long to do as their competitors. OP - I don't know you, and that wasn't directed at you specifically, but it's been a repeating pattern I've seen at company after company I've had the mixed fortune of consulting with. Back in 2017, is it a good idea to use codeigniter, but also graft on your own DB layer because... you thought the CI ORM was "too heavy" and "slow", so you build your own to be "faster", but conveniently ignore things like escaping data? I've just spent 4 months dealing with that. Hey, that person before me certainly got to experiment and "learn", right? But really, what did they learn? That leaving a codebase with 1200 "mysql_query" calls is an acceptable tradeoff to save 4ms in query time? In 1997, this might have been acceptable, actually we had no community-driven db/orm tools at that time in the PHP world. It's 2019+ - we have composer, we have community, we have tools. Learn from them. To the OP - "...Symphony because they are just more complex than I feel useful....I'm only an intermediate type...". In 1997, we didn't have an abundance of battle-tested high quality community-driven codebases to study and learn from and build on. Today, we do. Don't sell yourself short by ignoring learning from other tools - see how they solve problems, seek to understand their decision process, etc. A lot of what we have in major projects is the result of years of experience, filling real world needs, and community consensus, not some guy saying "I like it this way". Best of luck you all of you - it really was not a condemnation, just encouraging someone to have goals in mind for their learning/work.
TLDR
Well, if you **really** need to save your data to a file you **could** work with json I'd say. &amp;#x200B; At start you would have a simple php array composed by your persons, convert it with **json\_encode()** and save it to your file with **file\_put\_contents()**, then you can retrieve back your data with **file\_get\_contents()** and **json\_decode()**. &amp;#x200B; It would be much easier for you to work with a real php array than exploding a string and looping over it like you did in your previous example. It would be also easier to update it as you asked previously. &amp;#x200B; But like others people said, using a real database should be the way to go.
&gt;I hate to break it to you, but most of the community don't really give a flying toss about PSR outside of the early ones like PSR-4. &gt; &gt;Most of the projects that the majority of the community use were either never part of PSR/FIG or have left (often because they have issues with it), I.E - Symfony, Laravel, Wordpress, Doctrine, Guzzle, etc. &gt; &gt;As a standard PSR is a joke, the most used PHP projects don't use much but the early PSR's and have expressed outright hostility to some of the later PSR's and the way the PSR project has gone. So using middleware isn't a generally expected best practice for modifying PSR-7 HTTP request interfaces in the PHP community? [https://laravel.com/docs/5.8/requests#psr7-requests](https://laravel.com/docs/5.8/requests#psr7-requests) [https://symfony.com/doc/current/components/psr7.html](https://symfony.com/doc/current/components/psr7.html) Well its certainly news to me. Do you have a technical insight or articles on to why this CI 'filter' homebrew stuff is better than a PSR-7 interface middleware implementation? What makes PSR-7 "a joke" in your opinion?
When it comes to libraries and services: **Service** is more detailed - functional separation within (MVC) layers - it may be part of domain, controller or view layer (last two fall into infrastructure/application services category). It might serve more layers by having **indirect** connection between them (mind ISP). Examples: (controller) authentication and user data cached in memory for expected domain/view usage, routing in controler to select endpoint (domain use-case) and generate links in view. **Library** covers some generic and reusable part of functionality, but usually not as broad as a service. Library and service might be related similarly to class and object where service is a concrete instance/configuration of a library - routing library will become a service when you configure its routes. Not every service is generic enough to be implemented entirely by a single library or wired set of libraries alone. For domain services simple CRUD may be the only exception (orm &amp; validation libs), but it tends to backfire (or become unpleasant surprise your boss or client) when some minor feature becomes relatively massive slowdown. Ps. Be careful with commonly used names in Laravel context - they tend to use them for specific or even unrelated stuff (like: their facades have nothing to do with Facade pattern).
I have to ask if OP just preferers to use procedural (and if so why?) or if OP is refusing to adapt to modern practices because they‚Äôre accustomed to old habits?
First option overweighs the second one, yet both are there. One of the reasons is php webapps are becoming very complex very quickly with modern OOP+patterns(+frameworks) approach and people without prior OOP+patterns(+frameworks) knowledge will get a hard time to get inside a php webapp, be it modifying or extending it (i may be wrong here)
I completely agree as I am still quite new to OOP myself but it‚Äôs just something you have to inbreed and tackle head on. üòÇ
Because both the convention and the opinion you linked to are optional. You can use the convention or opinion or roll your own. For me these are just convenience / helper's that happen to work alright with low overhead.
Have a look at the slim framework. Bare minimum, add what you need.
You realise that PSR-7 is an example of Symfony (and by extension Laravel) not meaningfully supporting it. Instead of actually supporting it by implementing with Symfony 4 they just kept with their own "half baked solution" from Symfony 3 and stuck with their tacked on bridge as a Band-Aid to pay lip service to it. And guess what, most people who use those frameworks don't use that PSR-7 Band-Aid, most of the "community" don't care about it nor most of the other PSRs. As for CI no idea, but why should they adopt "standards" that are a joke, for standards to function you need most users actually following them, that hasn't happened with PHP. The largest CMS by far ignores them, the two largest frameworks by far only pick and choose, and have both left because they have issues with the project. Here is what the Symfony guy wrote when he removed symfony from the project: &gt; PHP-FIG is **not** about interoperability anymore, it's about creating an opinionated framework, a framework by committee... PSR is a dead duck.
Even just using exportable = false when creating the key will mean most people will have a hard time
I'd rather not. I like pphp.
EasyPHP Webserver 19.0 is coming...
Huh? Both of those are dependents of CI core. Trying to build a full-featured app in CI while avoiding them is pointless impossible, which brings us full circle to the original question I asked that you still haven't addressed.
I'd love to have more of a discussion about your thoughts on this. I have the opposite mindset, that being: "procedural PHP is difficult to maintain, easy to mess up and leads to hard to understand code." That's just an opinion though and my experience isn't yours. It'd be great to talk more about what you've found makes procedural PHP easier to maintain and work with than OOP PHP. Is your discord open to this type of curiosity or is it very "you already accept procedural or you leave"?
Like most people I learned procedural PHP; I could never go back to that. I can't think of a single good reason to avoid modern PHP development tools.
None of these people can respond to your inquiries because they simply don't know what they don't know; they look at the terminology in a modern framework's documentation and rather than buckle down and try to work through it they throw their hands up in the air and carry on developing their piecemeal codebases.
After almost 20 years in the fiesld, I have to say... If a paradigm is your problem you should find a different field to work in. They're all staying. They're all useful. Ideology makes terrible, uninformed programmers.
Do you at least use a router? Or is your About page literally just about.php in your root directory...
This..
Isn't the idea of some of these higher numbered PSRs to make code more portable? I personally don't look at stuff beyond PSR-2. I'm just too busy getting out XYZ feature and living AFK but I like the idea that the authors behind my framework of choice are implementing PSRs.
In 2008, I added full Canadian sales tax support to www.blinds.ca. It was NOT pretty!! Have to analyze the billing address, shipping address and *factory* address, and if they are in three different provinces, watch out! In the end, we found it easier to ship the product from U.S. factories because the import tax was relatively straight forward. Talk about counterproductive!
Slim is an excellent recommendation, I've used it on several projects.
Wow, adding year-long cache expiration dates by default is ridiculous. That‚Äôs going to cause so many problems for newbie developers. Especially for images which you don‚Äôt want to constantly change URLs when the image changes.
It wasn't so on PostgreSQL. When I implemented the same solution, it actually slowed down the tests from 2 1/2 minutes to 4 minutes. 1,900 integration tests (phpunit) vs 3,400 in the other (behat) test.
Development in the 90s was wild. Kids out here trying to build stone tools in the middle of the bronze age because they don't know how bad the stone age sucked. This sort of learning really only comes with experience working in professional environments. To go a little further with the analogy and past TLDR: Imagine you are one of 10 blacksmiths contracted to provide weapons and armor for an upcoming battle. That's 10% of the army you're expected to outfit. The state offers bronze molds to each blacksmith to ensure consistency. The 9 other blacksmiths show up with bronze swords, shields, and armors, all consistently crafted. Here you come rolling up with a bunch of sharp rocks and grass tufts sewn tightly together drenched in a bronze coating. The portion of the army you're outfitting would be in deep shit because you just *had* to figure out those damned rocks when you knew damn well and good this was a bronze vs bronze fight coming up. In a team or production environment it can really bite you in the ass to be reverse engineering and building a ton of stuff we have collectively figured out and decided upon best practices for already. That doesn't mean it's wrong or bad to do it, especially in your free time. I am all for challenging the status quo. It's just less productive than the alternative which is picking an established framework and getting your idea up much faster. A lot of us here code all day for our jobs so the hobby/exploration/learning side has little weight in our decision making - we're usually thinking of things from a "get the job done" standpoint and rolling your own framework goes against that notion entirely.
STLDT
 &gt;I basically started using PHP back when it was the Wild West, and you had to write everything yourself. And doing this today is irresponsible
I disagree.
&gt;Development in the 90s was wild.
I just read that article you linked and it help me because it highlighted the concern of fat controllers. An idea i had been dancing around but never actually seen anyone talk about. For example this is the psudo code of one of my controllers for inserting / creating a model object. 1. Check session token for permission to this action 2. Create SchoolRepository 4. Create a new School 3. Instruct SchoolRepository to insert the new School (validation and business logic for that object is in the SchoolRepository) 5. Return the new School Is this fat? by your outline it is because my controller is doing all this work to spin things up. I just don't know where else this code would go. My generic model entities are glorified data objects.
Here a +1 In general, we shouldn't talk here about: * Wordpress (we shouldn't talk about it, for good or bad) * Laravel versus something * Node.js or JavaScript by other that jquery. Why?, Because Nodejs is the arch-nemesis of PHP. * Python. Why? Because Python is the arch-nemesis of PHP (yes, PHP has two arch-nemesis, it had a third one (Ruby) but it's dead) * About dead, we shouldn't say PHP is dead * PSR (it leads to polarities)
It's like an antivaxxer server but for programming
Most things in the 90s were pretty wild ;-) There are two kinds of developers. The developers who make the tools and the developers who use the tools. There is nothing wrong with wanting to make tools. There‚Äôs nothing irresponsible about making them, or no new tools would ever come out. It is perfectly fine to live a (PHP) life full of other people‚Äôs code. It‚Äôs perfectly fine to write your own.
&gt;There is nothing wrong with wanting to make tools. There‚Äôs nothing irresponsible about making them, or no new tools would ever come out. This is what I said - but it's counterproductive if your job is to build or work on an idea of someone's and you go down the path of building your own framework for it. In nearly all cases that's not what they are paying you for and it would be irresponsible and unethical to do so. Or if you work on a team that uses a framework as another example. It's fine to build tools and write whatever code you want but not on company/client time. There are a lot of different kinds of developers. Some write their own JavaScript but use other's PHP code. Some are hobbyists that like playing around with code just to learn, some do it for a living and don't have as much time or desire to build their own versions of everything or reinvent wheels - there are grey areas in between. The point remains - if you're tasked with doing a job in PHP today for a paying client or customer, and that task is not to build a framework, then building a framework for it is wasting someone else's resources - that's no good.
There is nothing either of us can do to make the other one agree completely. I respect your opinion, but I disagree. Clearly, we have very different clients.
I‚Äôve seen your previous work. Is this all you do is promote your own blog? This subreddit has a rule against that
This again begs the question of what problem is actually being solved. To me, talking about "sessions" implies "a persistent record that a user is authorized/signed in to a web application from a particular device". This implies a bunch more things (e.g. likely use of a web framework, likely security needs like being able to terminate sessions remotely). Now, the OP and anyone else who asks about sessions might not have that exact use-case in mind, and they might also not fit the assumed implications above, which is why I phrased my objection in terms of _usual_, not as an absolute.
Still maintaining several sites on CI 2 (and PHP 5) here. Yep.
&gt; Weird seeing people that will never use this framework come in this thread bitching about this framework In a nutshell, Codeigniter was cool, it worked fine and was fast; it was THE framework for PHP (over Zend). However. They changed the license, and it polarized the whole community. Then, the company behind CodeIgniter abandoned the project (it was 1 or 2 years), so a big part of the community migrated to greener pastures. Then, it was sold, it "revived." (more or less). Then, they promised CI4 (with a "comming soon"); it was three years ago that in technology-time, its a lot of time. So, most anti-ci are people that used it, developers that believed in this framework; you can't blame them because it wasn't funny.
Hey, magallanes2010, just a quick heads-up: **comming** is actually spelled **coming**. You can remember it by **one m**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Just wanted to let you know I ended up using the php-cache session handler. Seems to be working well. I'm still using stashphp for the actual caching, but its working like a champ. By default just using a filesystem driver, but it's pretty simple to change: File: `config/caches/session/file.jin` [cache] disabled = false class = Stash\Driver\FileSystem path = storage/sessions File: `config/packages/stash-session.jin` [caching] pools = { "session": "caches/session/file" }
&gt;delete
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
I have use this on probably 100 millions page and in my case uniqueness was around 75%. I added local ip (through webrtc for browser that support it) but you cant really identify a user with that method.
Do you also have some code to show? How would you wrap an external library like proposed in 0.5? Take PHPMailer as an example.
Not at the moment.
I can find error in your Magento project even without using PhpStan. You see, the error is you are using Magento. (/s)
üòÇ
your problem is Magento in the first place
Probably find an open source project that‚Äôs fairly active and build your CI/CD from whatever vendor. Tools change but fundamentals are fairly stable.
Having flashbacks to the mid-2000s.
jenkins is good, you decent with bash?
Consider adding TeamCity to your list, developed by jetbrains (the guys behind Phpstorm). Also, Travis and codeship as hosted Services.
who fuckin cares?
Circle is really easy to get going with. It‚Äôll set up itself by scanning your project. (Eg, if it sees a composer.json, it‚Äôll add running composer install to the build script, etc) IIRC it doesn‚Äôt work with any repo though. I used to use it with github, but when my team moved to gitlab, circle (at the time at least) couldn‚Äôt work with it, so we moved to gitlab‚Äôs CI. It‚Äôs also decent and free, but takes a little more setup, and isn‚Äôt quite as nice to use IMO. I‚Äôd start with circle if it works for you.
I can't fairly tell I'm decent with bash but if this is part of my learning I'll train on it as well. I read Jenkins is hard, that's why I was wondering if it would be a good choice to start.
Only tangentially related: the 12 yo soap api I have to interact with is incompatible with the front end cms upgrades the same vendor has added (yes, they return malformed xml with emojis in it) rendering ext-soap useless. Therefore, yes, it‚Äôs possible, and very unenjoyable, to hand roll your own almost-soap parser with guzzle and regex.
I enjoyed using PHPStorm, I'll check TeamCity for sure ! Didn't know Codeship, will check too. Travis was part of my list at the beginning but it looks like it is mandatory to have a GitHub repo. As I'd like to apply CI for private projects in the future with probably self hosted repos I preferred looking elsewhere. Was I wrong ?
Jenkins is very easy to setup, but probably hard to master. I implemented it at my work but it currently doesn't do much more than rebuilding the repos and deploying them via sftp.
Circle seems nice ! No stupid question: is it common to have a website repo hosted on GitHub/GitLab ? I thought that'd be a bad idea but it seems to be the correct way to use some CI tools. Maybe I'll try both if I can.
Start by making a Jenkins pipeline to run your Phunit tests/ phpcs and to pack the current build , you can hook this up to something like github before merge into master to enforce integrity
That'd be a good exercise. Could you explain what do you mean by "packing" the build ?
you can secure it all you want, the header is simply to identify the device... and even that you could obfuscate with ssl.
Mh I honestly didn't know, seems you are right about github. We migrated from codeship to tc as we wanted to reduce the number of companies having access to our sources. Anyhow, I got to know one of the founders, smart &amp; kind guy. Would have stayed with them if it wasn't cloud-only. Might want to decide if you run on docker containers, so switching between ci providers is easy. If I had to rebuild our ci process, I'd go with docker containers. Most ci tools have great support for docker, including TC and codeship. Don't know about jenkins :)
Oh great, confirms that Docker could be nice to learn too. Thanks for your answers :)
Take a look at Statamic - it's built on Laravel: [https://statamic.com](https://statamic.com) It's flexible and developer friendly - whilst still being easy enough for clients to use.
Ideal would be a headless CMS (like ProcessWire) because of it's speed. Wordpress is slow like hell and the environment to build in is rubbish, i.e. migration is crap, using ACF is "not ideal" and there are no core integrations on custom content types whatsoever. These are the things tho that I'm looking for. I'll summarize below. 1. Headless CMS (or semi, like ProcessWire) 2. Flexible content fields 3. Easy to add content types (like Wordpress "post types") 4. Easy and flexible API (like ProcessWire) 5. Adjustable and lightweight UI 6. CDN integrations (for images, javascript and css) 7. REST API / GraphQL (this is optional)
I‚Äôve recently checked out Craft (coming from WordPress), and it‚Äôs fantastic. Learning to write templates with twig takes a little bit getting used to, but all of the custom fields that come out of the box are incredibly flexible.
[Sanity should fit](https://www.sanity.io/) most of those needs.
It's far from a bad idea. It's really common. Almost every site I've worked on in the last few years has used either gitlab or github for the code repo.
Be honest about the position and salary. Also, read about what I know and don't contact me for something completely outside of my resume.
I don't answer my phone anymore at all to numbers I don't know. I got 10-20 calls a day, many for the same job, and 99% are ignoring what I've written in my CV. All just wanted a 5-10 minute talk to get my preferences (all in the CV already) and promising to call me if something comes up, because the job they actually had is something I don't want (again, stated clearly in the CV). Email me, and I'll get back to you when I have time to read it and am interested.
So you had no idea you were in r/php? Sounds like a load of crap and you‚Äôre just another boring old PHP naysayer trying to be edgy.
Yeah I agree! It's a shame that there a few recruiters out there who give a bad name on the industry
Yeah cold calling should be kept out of recruitment in my opinion
Yeah I use a link with all relevant IT / Programming subs in it. If you like I can share it. I'm someone who was a Wordpress dev, with PHP but I hate the shit out of it I hope it burns and dies in agony. I'm also not that old btw mid 20s :D
October CMS is also worth a look. Built on Laravel. https://octobercms.com
Source control of some sort is always good, which option you go for depends on the criticality assigned to the project, budget, and availability of ops knowledge /teams. Is entirely possible to run gitlab CE on a small or medium ec2 instance if you want / need to keep code on something you control, rather than using a shared /hosted service.
Yes, see [https://craftcms.com/](https://craftcms.com/) \- it can also be used as a headless cms via [CraftQL](https://github.com/markhuot/craftql) for GraphQL or the REST [Element API](https://github.com/craftcms/element-api)
Drupal. Bring on the hate folks. Seriously, it's a mess to learn but it fits your use case.
Holy crap that pink burns my eyes
I really like Grav. getgrav.com
What does headless mean in this case? I thought it would have been "no admin interface" but there are screenshots of one on the ProcessWire homepage.
I'd give Statmaic an upvote here too the CMS is slowly gaining popularity the developers seem committed so far. It also uses some great new technologies which I expect to see more of in the future.
I wonder if any of this has changed since going from 5.x to 7.x, given the nature of zvals and all the under the hood changes. I know this is algorithmic complexity, and that those may have remained the same between versions, but just a thought.
Don‚Äôt mention anything about ‚Äúwork hard, play hard‚Äù etc. Put the salary in the description and be honest about the expectations and requirements.
I'd say honesty and actually read the CV. I'm from France and the amount of recruiters using automated mail is just horrible, don't know if it's the same elsewhere tho. And look for those who are listening to the market. Cheers!
I agree with what you said, there's always a better job out there to hear about. ... However, I'm not interested in the better job. I'm quite content at my mediocre job, and switching jobs would require me to move environments, leave my colleagues, learn new technologies, new culture, it costs a lot of energy, etc... I don't want to hear about better jobs. I want to be contacted about jobs when I'm looking for one, or when I'm ready for a new one, and I would be fine with being contacted by recruiters then, but not when I'm not looking for one. At all.
I'll second October. if you're a developer it's simply a superb platform to deploy on. It's extremely flexible - I've moved several really old sites to it without a hitch, but at the same time very modern in it's approach. The plugin system is superb - no problems with conflicts as per WordPress, very straightforward to develop in - and there's even a Builder plugin which takes all the hard work out of creating plugin scaffolding - you can pretty much build a reasonably complex plugin and only touch code for specifics. And even better the plugin system is inheritable - if you find a plugin that almost does what you want but not quite you can extend it without touching original code (so forward compatible) Documentation is excellent too. Of course the ecosystem is nowhere near the size of WordPress, but if you need a CMS to develop an application on (as opposed to a cookie-cutter portfolio website) then OctoberCMS is simply the best thing out there. There's enough plugins that in most cases there's at least one that will cover what you need. If you're primarily a designer with limited code skills the WordPress is still hard to beat because of the plugin ecosystem. But if you coding skills are reasonable then OctoberCMS wins hands down. Every client I've deployed it for has loved it. And case in point - I recently had one client who needed a couple of similar websites created for her business - both in a training sphere with moderately complex booking and similar requirements. Before she came to me she'd commissioned one with a guy who was primarily a designer. He delivered a site using purchased templates and plugins to which a little custom code was attached to make it do 90% of what she wanted - but not all because of limitations of plugins. I delivered a site in OctoberCMS which delivered \*exactly\* what she wanted. Took a little longer and was a tad more expensive, but I now have the repeat business.
&gt; 2. Procedural PHP forbids any usage of Objects. How do you work with dates? https://www.php.net/manual/en/function.date-create.php `date_create()` is literally just an alias to `DateTime::__construct()` and returns an object. &gt; 3. Procedural PHP allow the usage of Modules. PHP modules like gdlib and php-xml or what is meant by Modules? &gt; 4. Procedural PHP allows the usage of Namespaces and (Static) Classes strictly as modules/ function containers. Why? There is no difference between `MyDateFunctions::create()` and `my_date_functions_create()` except that one tries to be something it's not (the former). Sure, you can use static variables in static methods of a class, but that kind of defeats your "no-OOP" paradigm. &gt; 5. Procedural PHP allows the usage of external packages, but they have to be used procedurally or wrapped in a procedural way. Wrapped? So it's okay to use objects if they are wrapped in procedural code? How is that even possible?
I get a lot of emails from recruiters, maybe 5x per day. The ones I respond to are the ones that actually seem personalised. The thing is I get so many emails that are obviously just templates that my name has been dropped into that they don't even get read for a job. The most frustrating thing is when I either get positions way below my experience (I've been working for over a decade and have been firmly senior for a good portion of that, why are you sending me listings for junior positions?!) or for a country I left 4 years ago (Which I responded to any recruiters from that country letting them know I had moved for 2 years, after that anyone who still emailed me was just being lazy). The best contact I've had was this top notch recruiter called Manraj. I call him top notch because he was pretty good at making me feel like our communication was personalised. In the call we had he asked me what my favourite movie was, we chatted for a few minutes, and he said he'd put the movie in the title of the email so it didn't get lost. Maybe other people wouldn't like that, I don't know, but at least I knew the email coming from him was for **me**, and not for a list of people. Turns out everyone else at my company who had dealt with him loved him too. So yeah, after my long rambling response, my advice just comes down to making sure your emails have a personal touch. I'm much more likely to respond to a recruiter who looks like they put a bit of effort in than someone who put me on a list.
Couldn't agree more with this. I get fairly regular LinkedIn approaches about positions. But if I was interested, I'd have put something on there saying I was interested.
French here so maybe my opinion will be different. \- Don't call me as first contact, prefer email or direct message on "professional" social platform like LinkedIn or equivalent where you found me \- Read my CV and experiences before asking me things I've already wrote \- Give details about the new job : company's size, position, salary (according to my own experience, I don't care what is junior salary when I have several years of experience), where the job is, etc. \- Give details about techno involved (I receive way too many proposition that don't mention it)
Checkout SilverStripe as well. It‚Äôs not as well known but has a lot of nice features for when you want to build something more complex.
Personally, I ignore every single recruiting message that does not include the company, job role and salary range. I've stated so in my online profile where applicable. Recruiters who ignore this are simply wasting their time (and there's lots of recruiters wasting time). Even though I'm not actively looking a couple of recruiters do get it right and at least I'll give them an answer to their inquiry... the others can go to hell.
Well if you deploy it somewhere you need to pack it somehow. If not then forget what I said.
"Better" is a tricky word. You never know what is better for me personally. Either way, it should be a personalized offer.
do you already have automation set up for your project? if not, set up test suites, code styling, static analysis, locally. look at something like grumphp.
&gt; I see you have experience with javascript, I have this great Java position for you!
Very relatable to me.
Same here. If I'm looking for a job I'll look for one. If I'm not then I don't want to know.
Useful for large scale projects, thanks. I've had problems with Big-O in the past, but with our own code instead of built-in functions. We had three nested loops for no apparent reason...
I'd rather be contacted by a few recruiters once in a while than not being contacted by any. I never dismiss any opportunity right ahead unless the company's reviews are too bad. If all the employees rate the company 1 star only then it just can't be a good place to work.
array_key_exists() has been optimized in 7.4 ([PR here](https://github.com/php/php-src/pull/3360)).
I have a script to deploy which installs vendors, execute DB migrations etc. But I'll search about static analysis &amp; grumphp, thanks !
&gt; How do you work with dates? By wrapping in a function or module &amp;#x200B; &gt;PHP modules like gdlib and php-xml or what is meant by Modules? Modules, you know, like [normal languages](https://paste.ee/p/5cMDt#7FvWTGrpDhHzXOWMyypC4P7BtRLnnOCQ) have. Not apache/nginx/pear extensions. &amp;#x200B; I'd prefer if you'd ask questions on the server, i won't monitor comments forever, you know.
So it's okay to use objects as long as the functionality is contained in a function that can be used procedurally? Like, it'd be okay to do: function get_days_between(string $from, string $to): int { $f = new DateTime($from); $t = new DateTime($to); return (int)$t-&gt;diff($r)-&gt;format("%a"); } And it'd be okay to make this a static method of a class: class DateFunctions { public static function daysBetween(string $from, string $to): int { $f = new DateTime($from); $t = new DateTime($to); return (int)$t-&gt;diff($r)-&gt;format("%a"); } } And then I fail to see the advantage to using `DateFunctions::daysBetween()` and `$date-&gt;daysBetween()`, assuming `$date` is an instance of `DateFunctions`. No thanks, I don't subscribe to your way of doing PHP - I've been doing it long enough to know that OOP is the way to go and that trying to circumvent that doesn't lead to anything good. I'm just legitimately curious about what is allowed and what isn't and why that is.
I would, as I'm looking for work.
Webflow. They've been around for some time now and keep improving their product. I like you can build nice animations with it which others don't provide.
Please forgive the dumb question. What's the Big-O for direct key references? $value = $array["key"]; One mob of people have told me its O(n) and one group have told me it's O(1).
It's O(1) since it has direct memory access to the value.
&gt;Bring on the hate folks. :'D
don't call me, I'll call you
I'm having a weird date display issue. The raw data in MySQL shows that the 2 date fields are exactly the same value. They are in different tables. But when I display them in PHP they're offset by 10 hours. I have no idea why because the same code is applied to the recordset. I have my timezone set in php and mysql correctly, but I don't see why that would matter anyway. &amp;#x200B; The relevant code is so simple: $date = date("Y-m-d @ H:i",strtotime($row\['Date'\])); &amp;#x200B; It's always adding 10 hours to the 2nd tables dates...like that table is somehow set at a fundamental level to be offset by 10 hours. &amp;#x200B; What could be causing that?
It's an unpopular framework because it's maddening to learn, but it's quite powerful and built on top of symfony. If you don't treat it like a hammer it's a much easier solution to maintain rather than hacking up your wordpress site. It's probably not the tool of choice for truly mission critical services that are going to be complex. Hiring a team of *good* drupal developers is very very challenging.
Drupal definitely has use cases. Big enterprise editorial sites can really benefit from Drupal. With D8 it's a more modern code base as well, utilizing many Symfony concepts.
Basically means it should have a REST API so that frontend (for visitors, not admins) is decoupled.
Only if they change the approach itself
It has to be O(1) : You don't scan the whole array, you use the index for a direct access to the value
I moved from France years ago, changed techonologies, moved up to management positions and still get recruiters sending me emails about php dev jobs in Paris... I sometimes reply with my new CV attached, but I don't think they bother reading it, because a few weeks later, same emails come back again
Hmmm ... does this optimization still work even if devs don't namespace it properly? https://github.com/php/php-src/commit/f1c0e671e988b9bf679bd21dbf6dab9adc1e1b4e &gt; A specialized VM opcode for the array_key_exists() function has been added, which improves performance of this function if it can be statically resolved. In namespaced code, this may require writing \array_key_exists() or explicitly importing the function.
I've spent a couple of years doing Drupalese. :)
Yes if the asker knows his data structures he would have realized one is similar to a list the other is a set. This is precisely the reason why knowing your data structures is so important in software engineering.
It's O(1). The data structure is a hash table. The way that works is that the key is hashed, and the hash is used essentially as a memory address. It is possible that two keys can cause a hash collision in which case we get something just a little bit worse than O(1), but it is definitely O(1)
Rejoice for the bot mail time!
Suppose I do. What's next?
Useless blogspam. Voted to remove.
O ===
Everyone who says O(1) is kind of wrong. You can't directly access a string key. It's hashed (hence the name "hashtable") and the hash determines a bucket that the key goes into. This bucket is accessed directly, more or less, but then if you have multiple items in a bucket, it's a linear list and it works O(N) like you would look for a value in an array via in_array(). So the overall solution is more accurately ranked as O(log N), where for small number of items you can assume it's O(1) but for larger number of items, not quite. Also typically the more items you have, the more buckets you have to avoid long lists (called "conflict resolution chains") in each bucket.
hostnoc.com quite often features interviews with people no one has ever heard of. Another example: https://www.reddit.com/r/PHP/comments/9tiuqn/founder_of_7php_wasseem_khayratte_reveals_his/
For non numerical indices, the worst time complexity is O(n), average case is O(1). PHP uses associative arrays so the keys are bucketized.
So I can choose to have a byline or to receive payment, but not both? Why? What currency are those payments in? I just see a weird symbol. Is it Rupees?
If you switched out some words, this post - and all the others here - sound very much like the advice for successful online dating.
Doesn't really help unless you have a subscription to php[architect].
Again, disagree. The majority of the use cases are in reality the exceptions you are alluding to. A JWT can act as an indicator of authorization as a result of authentication-- and do a superior job if I may add. Hey, I am detecting a pattern that we are not going to agree. I am glad you are super secure with your choices where you have to do significantly different things given the circumstances you find yourself in. And if it works for you, great. I found a solution I only need to tweak for a lot of use cases and put it forward.
Do I have to learn C in order to learn PHP? What is a hash table and how is it used in PHP?
thats a bit odd, wonder why they did that. noones gonna do that
No mention of [bolt](https://bolt.cm/)?
&gt;Procedural PHP forbids any usage of Objects. this is a very 'newbie' opinion on what procedural is. Sometimes when a person don't really understands OOP, he just starts using objects and thinks he has started 'writing OOP code'. &amp;#x200B; You may, and there are lots of examples, use objects and still be writing procedural code.
requires a fair amount of shell script knowledge, i was using it for over 10 years til about a month ago at my new job where we use envoyer. Install it and give it a shot. It takes a lot of getting used to, but you can do almost anything with it.
1st: It had better be at least the state I'm living in (especially as a Texan). And I title my resume/profile "NOT LOOKING TO RELOCATE", don't offer me full blown job description that would require a cross country move. 2nd: Don't call me 10 secs after emailing me. If you're going to cold call &amp; I don't answer, then email. Don't do both. If we speak &amp; I want details, I'll ask you to email me. And I know from a recruiter perspective, it's maybe 20% that respond, so you have to put everyone on a blast, but cold calling AND emailing is annoying. Why not use some of those marketing tricks in emails? Short descriptions with key points that link to job descriptions so you can track engagement?
The other thing is contacting me about Java jobs because I have Javascript and/or JSP.
How would we know if you become active. If a desirable company come knocking on your door but you wasn't open would you not want to hear about it
You don't need to know C well, but if you're planning to program professional, you should have some understanding of how data structures and data types work, which is what a basic understanding of C will show you. It's also why C is taught in almost all introductory level computer science courses. A hash table is a data structure optimized for lookups. It is the most useful data structure when you need to store items with association. This structure is implemented for you with PHP arrays. Arrays in C and most other languages are a contiguous block of memory that only holds one data type. For example, a C array of 4 integers would be a 16 byte chunk of memory, an integer stored in each of the 4 bytes.
Among other reasons because this speeds up WordPress and similar code bases which don't make heavy use of namespaces. Such changes are done by looking at real life benchmarks and seeing where work can be done.
 The issue here with Big-O is that it doesn't give worse case or something, but only an average. Yes collision might happen, but if they happen often the hashing algorithm is bad. Also when discussing algorithms mind that constant time sounds nice, but sometimes (for a small number of elements etc.) a linear search might still be faster than a complex hashing. Big-O in itself only tells a little. For chosing an algorithm know the data and algorithms ... (PHP of course gives you little choice)
Lmao, at least with Symfony and partly in WordPress you can version control the application logic. Most Drupal coders are just Drupal back-end clickers which makes migrating between different environments and updating modules night impossible since EVERYTHING is stored in the database.
Previously posted at https://www.reddit.com/r/PHP/comments/bbzs0b/10_bad_things_about_consulting_and_why_it_might/ I agree with the previous poster's sentiment: _20 minute video for what could be a 3 minute read on a blog post?_
Would the Senior PHP Team Lead Laravel job in Fairfield, NJ, **please** stop calling me?!?! I live in *Texas*. I have received over 30+ calls and over 50+ emails regarding this position since December 2018. I get it. You can't fill it in podunk NJ and I meet every requirement with flying colors. But no, I'm not willing to relocate to NJ and, yes, I would work for them in a heartbeat if they offered me a remote position. But none of the recruiters I've talked to (half a dozen) about this very position will even let me talk to the client about that possibility. Still, I keep getting the emails and the phone calls. Same for the team lead job in Phoenix, AZ, and a half-dozen others.
Except we're the hot blondes with big boobs, and we, too, have to suffer prying Indians w/ a lack of Western social graces.
Eh, I contributed to an eMule fork back in the day and now I get what must be 100% of the offers for something called "Mulesoft" ;-)
&gt; [Drupal is] built on top of symfony Isn't it more accurate to say *Drupal uses some Symfony modules*? (honest question - I haven't played with D8 yet) &gt; Hiring a team of good drupal developers is very very challenging. Can you give more detail?
I'd second learning on Jenkins. I think OP meant "packaging" by "packing" - creating a distributable archive file for your project (.zip, .tar, etc.)
And LinkedIn is our Instagram where we duckface and post our butts in yoga pants.
I wouldn't. If I'm interested in finding something new I'll amend my LinkedIn account to show I'm actively looking. Normally I won't be, so my LinkedIn profile will reflect that, and any approach will receive the generic "not interested" response they provide.
&gt;A hash table is a data structure optimized for lookups. What is a "data structure"? Is that a database thing? ... and what is a lookup? A database query? I'm just a beginner at all of this. PHP is my first language. That's why I am here at this article about PHP Arrays for Beginners.
Big O represents the upper bound. Big Omega represents the lower bound of an algorithms complexity. It is true that they do not give a worst- or best case scenario but they are informative enough to reason about an algorithms.
why not just replace the function completely instead of having 2 version?
Just give me any indication that you have even looked at my resume. Any at all. Thats all I want. Like "I'm reaching out to you because you did X at company X." That's enough for me to keep from junking the email.
Because the parser and compiler won't know if there might be a local function with the same name. fake_ake.php: namespace myapp; if (DEBUG) { function array_key_exists($a, $k) { echo "Searching $k\n"; } } myapp.php: namespace myapp; define(DEBUG, $_GET['debug']); include('fake_ake.php'); array_key_exists([], 'k'); Is valid. And stupid. There only at runtime the function is called and the olcode to call the fast version can't be changed accordingly. Unlikely anybody does this, but I can imagine somebody mocking some functions in tests for some (bad) reason. Also having the function available is needed for indirection. $callback = 'array_key_exists'; $callback($a, $k); Here again the call has to go through the function call path.
I've been getting deep into Bolt. I've already built multiple systems for clients. I love it, they love it, and it saves us both time.
is the new version not part of the core?
All of the existing exceptions from PHP5 extended `Exception` and it implements `Throwable`.
Is that still active? Surprised.
I think you're missing the point of phpspec, especially if you're trying to use it the same way as PHPUnit. The main point of phpspec (and by extension other BDD frameworks) is to drive the design of your code. Verifying the end result is just a logical outcome of it. If you're having difficulties testing the code, it might mean that the code in question isn't particularly well designed.
If I remember correctly, while parse error do implement Throwable, it will be weird to catch. &amp;#x200B; For example file\_required.php: &lt;?php try{ //parse error occuring here } catch(Throwable $t){ //This catch won't be able to catch the parse error } &amp;#x200B; file\_requiring.php: &lt;?php try{ require 'file\_requiring.php' } catch(Throwable $t){ //it will be catched here } &amp;#x200B; I don't know if this was that sort of case you wanted
Hey, orklah, just a quick heads-up: **occuring** is actually spelled **occurring**. You can remember it by **two cs, two rs**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Hey /u/CommonMisspellingBot, just a quick heads up: Your spelling hints are really shitty because they're all essentially "remember the fucking spelling of the fucking word". And your fucking delete function doesn't work. You're useless. Have a nice day! [^Save ^your ^breath, ^I'm ^a ^bot.](https://www.reddit.com/user/BooCMB/comments/9vnzpd/faq/)
Hey BooCMB, just a quick heads up: I learnt quite a lot from the bot. Though it's mnemonics are useless, and 'one lot' is it's most useful one, it's just here to help. This is like screaming at someone for trying to rescue kittens, because they annoyed you while doing that. (But really CMB get some quiality mnemonics) I do agree with your idea of holding reddit for hostage by spambots though, while it might be a bit ineffective. Have a nice day!
A programming language is just a tool. You should learn about programming concepts, basic algorithms, and data structures before learning intricate details of a specific language. That's why no CS programs start with Python or PHP, they start with an introduction to computer science, then go into higher level languages.
&gt;I just see a weird symbol It's the standard Indian rupee symbol there's nothing weird about it. Anyway....... they want to pay you less than $10usd ¬£7gbp per article
Definitely agree. I have something similar to a spam filter on my LinkedIn profile - if the message to me doesn't reference it, I simply don't bother responding. For the record, this filters out around 95 percent of the messages (not an exaggeration). There may be a few exceptions but the message should definitely feel personalized.
Singapore citizen here, had 4 years of working experience in Kuala Lumpur as a web developer/technical consultant, trying to get into a job back in the island republic. Been out of job since January. The job hunting experience here is terrible: tried lowering my salaries, explained to interviewers about my range of expertise in my field of work (from server provisioning to developing internal portals from scratch), but for four months I have tried looking for work, and only one company had came back to me. It's not a web developer-related job. My experience with job agents &amp; recruiters are not helpful in landing a job: most called on my roaming (because I'm not based in the island) with only a promise and an offer for an opportunity, and never come back. Very few are professional enough to come back to me on email. Only a few are good enough for me to come down to the island for interviews. So far, only the company that I applied directly had given me the job. I can only wish good luck for tomorrow's signing. I've read reviews on Glassdoor against this company, and I think they are willing to take me in despite my web developer experience ‚Äî I could script in Linux as part of my previous job requirement to spurn new servers/harden existing ones for my websites ‚Äî because their attrition rate is high and its people have scathing opinion against their CEO. (Heck, during my interview, the man that interviewed me, whom I later found out to be their CEO, criticized my range of skill sets in my resume as "being too lacking in depth to be useful".) I have no other options: future potential employers are going to question my period of inactivity and will put that negatively against me in their assessments, I need to finance my escitalopram as I was diagnosed last year. &amp;#x200B; tl;dr: had to take a lousy job offer for a job that's not what I wanted but had the skills to, because antidepressants are not insurable nor subsidized here, and job agents are not helping me land a job.
delete
&gt; That's why no CS programs start with Python or PHP, they start with an introduction to computer science, then go into higher level languages. This seems a bit like asking someone to take a course on linguistics before teaching them how to say "How much is the hotel room?" in French.
That's why I was confused. Surely they're not offering around $11 per thousand words? If they want to attract good writers they need to be paying at least 20 times that. Especially as you don't even get an author credit.
https://www.php.net/manual/en/class.throwable.php &gt; Throwable is the base interface for any object that can be thrown via a throw statement in PHP 7, including Error and Exception. So no - if you use `catch (\Throwable $e)`, you'll be fine.
[Directus](https://directus.io/) fits that list.
This here is good advice. To add my own experience, almost every time I respond to a recruiter initial message the first thing they want to do is call me right away or schedule something immediately. Aside from putting pressure on me to respond right away it also doesn't give me much chance to learn about the offer and see if it's really a good fit before taking to the recruiter. Plus developers are normally very busy and overworked, I don't have time to be on the phone with people any time during normal people hours.
The point is that the "new" one is not a function but part of the language. What does that mean? - When a PHP script is executed the script is compiled into "opcodes" a low -level representation, conceptually similar to assembler or Java byte code (while opcode is only in memory etc.) These opcodes are then sendlt to the executor, which you can, conceptually, see as loop over the array of low-level commands with a big `switch` for each command. Where a command might be "do a function call", "create an object with new", "do the add operation for the + operator", "do a write to a variable", ... (https://www.php.net/manual/en/internals2.opcodes.list.php has a list of these commands) Now on that level, among other things, there is a difference where data for arguments are coming from (temporary data which is returned from a function is slightly differently handled from a local variable, which is different from array index access etc.) Also the set of those opcodes is limited. When calling regular functions this is compiled into a set of opcodes, which first initialize a function call, then put each argument in a list and then do the actual function call. For doing the actual function call there is a big function table, which tells what kind of function it is (user defined or internal) and where in memory it can be found (and information onparameters expecting references etc.) Then the engine prepares an environment (a stack frame) for the call and calls the function. This while process takes, from CPU perspective, quite some time. Now with the new version already when parsing the PHP script the compiler notices "oh, this is array_key_exists" (assuming it can figure out without a doubt that this is really, really that function) and can create some shortcuts, where at runtime no lookup has to be made and where arguments are passed slightly more efficient etc. But all of that should happen behind the scenes and the developer should not see that there is anything special about it and that's why the fallback regular function is needed. Hope that helps a bit, on 3v4l.org/ you can use vld to dump opcodes and play a bit to see the difference and googling should give more info on Zend opcodes.
&gt; people without prior OOP+patterns(+frameworks) knowledge will get a hard time to get inside a php webapp, be it modifying or extending it (i may be wrong here) Good. If a developer can't be bothered to learn OOP (especially the version that we have in PHP, which is watered down version), he shouldn't be touching any codebase outside of his / her personal projects. Might sound harsh, but that's the truth.
I like [MODX](https://modx.com/).
I don't know that I necessarily agree with the approach. It feels to me that having to always define expectations on how methods will be called _internally_ is somewhat wrong. You're right in saying that this way drives the design, but I feel like that shouldn't the the goal of a test. I test something to verify that it works, not that it's designed in a certain way. I feel like this approach kind of mixes two purposes, testing design and testing behavior. Also, it's just way too much magic, which makes debugging a pain üòî
In case you'd like to try it: [https://www.tomasvotruba.cz/blog/2019/03/21/how-to-instantly-migrate-phpspec-to-phpunit/](https://www.tomasvotruba.cz/blog/2019/03/21/how-to-instantly-migrate-phpspec-to-phpunit/)
Same sentiment as others, I will typically ignore phone calls from numbers I don't know, but I do read emails coming through.
If you contact me about a new job role, you better: &amp;#x200B; 1. Understand my skill level based on my public profile -- if you fail to do this and I have to jump through hoops to get your job, please don't contact me. 2. Understand what I do based on my public profile -- if you fail to do this and I have to explain to you where my strengths are, please don't contact me. 3. In short, if you're a recruiter actually do your job and learn about the people. If all you're doing is passing me off to some other company or grabbing me to go into the same process as every other Tom, Dick, and Hariette that applies for the job, then leave me alone.
makes sense a bit. so i could previously override array_key_exists, new version is essentially a construct, kept both for backwards compatabilty. that right? (btw thanks for the replies, very informative)
You are a fucking hypocrite
That is not a strict procedural then, please refer to a comparison image
I'd typically mark myself as active on the job boards and post my CV. One thing worth mentioning is that "desirable companies" is a very small list when you do software development. Google, Facebook.
I'd go so far as to say never call until after interest has been established. Send all the details via email for the initial contact and offer contact details in case they want to discuss it further. I for one keep my phone off at work and check my voicemail on a near annual basis, and never accept calls from unfamiliar numbers, so calling me is a waste of time.
[Neos](neos.io) for every one that loves clean code and no Wordpress like code...
Definitely wouldn't want to know. If my LinkedIn says, "looking for a job", feel free to contact me, if it doesn't, please leave me alone.
Thats a great idea actually, having a filter with a minimum of 1 of a set of keywords referenced. Ill have to set that up for myself.
Backwards compatibility plays a role, bit also for telling in future "it is a function" and then just have an asterisk to details, which can mostly be ignored. There are things in PHP which are no functions, which could be seen as limitation. For isntance $cb = "echo"; $cb("Hello world"); Won't work, as echo is no function. Which means that a user has to learn the special rules. For array_key_exists there are no special rules you have to learn (but you can follow the asterisk to see a performance hint and learn)
Not really. It'd be like learning words in French without how to properly organize a sentence.
Debugging a pain? You can trigger xdebug: `php -dxdebug.remote_enable=1 -dxdebug.remote_mode=req -dxdebug.remote_port=9000 -dxdebug.remote_host=127.0.0.1 -dxdebug.remote_connect_back=0 vendor/bin/phpspec run sometestdir` Or you can run phpspec with -vvv &amp;#x200B; It's important to test behaviour as you want to interface/lock that behaviour. Asserting whilst making sure the design is better = winwin? You also want to avoid mocks as much as possible [https://hernantz.github.io/mock-yourself-not-your-tests.html](https://hernantz.github.io/mock-yourself-not-your-tests.html)
That's a negative 1.5
Exactly my thought. If there‚Äôs one single thing that technical recruiters ought to learn, it‚Äôs the names of the various programming languages.
This is also something I would consider, thanks.
Any errors that don't present themselves as exceptions. There's still some stuff that returns null/false/-1 and requires you to call a separate function to get error info. For example curl_errno and preg_last_error...
The router is ``` switch ($route) { case "about": require "about.php"; break; case "contact": require "contact.php"; break; default: require "home.php"; } ``` ü§£
You do what makes the best sense for the item at hand. Some examples: `$userBeingCreated = new User();` `$someService = app(SomeServiceInterface::class);` `$heap = new Heap();` The idea of the IoC/DI container (or Service Locator as it is sometimes called) is to DRY up repetitive instantiations. This is especially an issue for objects that represent some service or have a complicated configuration. If you find yourself copy/pasting the setup of an object, it should be in the DI container. If it's more generic and local, it should feel awkward to have to pull it from the container but perfectly natural to call `new` on.
I'm assuming you mean a dependency injection container, because there's a difference between the two concepts: Dependency injection refers simply to the act of injecting dependencies into an object, while a dependency injection container achieves what's known as inversion of control (IoC). Since the purpose of the DI container is decoupling your class's dependencies, I think it could make sense to directly instantiate objects in places where you either won't or can't get much benefit from the container. It's a judgment call. Also, I want to note that I'm not an expert, so don't take my word over someone whose more qualified. I haven't had a lot of experience with DI containers personally.
Rule of the thumb: &amp;#x200B; \- use \`new\` only on objects that you can create multiple times (\`Product\`, \`User\`) \- DI and constructor injection on service (\`ProductRepository\`)
The point is security preventing the end-user from spoofing, not a MITM...
If were using new on objects you create over and over, then - for testing purposes - lets say you have: // This is pseudo code. foreach(products as product) { (new Product)-&gt;create(product); } How would you mock the product in that for loop? Or would you care?
The container is not magic. If you create an object in the container that's basically the same as putting a \`new\` right there. &amp;#x200B; It's just that if you create a specific new object INSIDE of another object the newly created object is now tightly coupled to the object because there is no way to swap it out from the outside. So lets say if you were to write a unit test and you needed to mock this object, you cannot because there is a literal reference to that specific object. &amp;#x200B; If a factory is a place that creates objects for you (i.e calls \`new\`) then your DI container is a factory for services and you can use services as a factory for your aggregates (i.e User or whatever else). So instead of worrying about calling new or not, ask yourself, do I want this to be tightly coupled to this other object I'm about to call new on? If the answer is no, then don't :) If you are unsure why you would care about this in the first place I would suggest this talk. This is not the only architectural design you can do with DI but it illustrates a lot of the concepts and properties that might seem very abstract and pointless at first: [https://www.youtube.com/watch?v=K1EJBmwg9EQ](https://www.youtube.com/watch?v=K1EJBmwg9EQ)
They're not looking for good authors, though... They're looking for people who can churn out new text for SEO purposes, and really don't care if you tell all of your users to use: $result = mysql_query("SELECT * FROM users WHERE userid = '" . $_REQUEST["userid"] . "' AND password = '" . $_REQUEST["password"] . "'"); (How many things can you find wrong with this statement? ;-) )
I'd add that IoC is used to loosen coupling between objects, not to turn a codebase into a scattering of ideally isolated objects that you then assemble in thousands of lines of services.yml. Dependency injection comes with both a mental and code overhead, and it's important to know when using DI brings no immediate or short-term value. If you foresee using multiple different classes with the same interface then DI is the way to go. On the other hand, I have often run into cases (and caused them myself) where a simple "new" would have sufficed. Implementing an interface at that point led to a bad abstraction at best, and a "good code theater" at worst where people thought they were writing good code because they were using DI and interfaces, yet the classes they wrote were still tightly coupled together and knew about each other's internals. When it was time to refactor we had to battle both the assumption that was wrong from the start (existing code compels you to write more code like it) and the actual code that was perhaps pretty to look at but flawed inside out. tl;dr everything in moderation including moderation
Usually the use of `new` is relegated to the dependency injection wiring code. Depending on the framework, where exactly this code is is not always clear. Some micro-frameworks, for example just have you throwing DI resolver functions as closures into some big PHP collection of "application services." For me, personally, I abstract all dependency resolution code into "Delegates" which is the only place I use `new` -- or at least the only place I try to with the exception of simple data objects. For data objects, even if you were to pass around a factory or something to create them, inevitably that factory is still going to be calling `new`. You could, in theory have it inject a new instance on construction and then clone it... but why?
I thought that service locators and dependency injection containers were separate ideas. The way I've heard it explained before was that with a service locator one manually requests objects from the container, whereas with a dependency injection container, objects are instantiated with their dependencies injected automatically by the container.
Yes. But it does use it's own instantiation of the symfony kernel. A symfony laravel dev would be very confused by a project structure or tooling. Drupal isn't really MVC. Beyond the symfony http kernel everything is fairly unique to drupal. Drupal also being so powerful up front cause junior folks to rely on a gui, and sometimes are missing skill. Thinks like auth are basically handled out of the box so you miss underlying concepts. So finding someone who really understands code, knows enough about php and the environment, and has solid knowledge of drupalisms is tough. They are out there but in extremely high demand. ESPECIALLY in the DC area where the federal government is full sail ahead on the drupal train.
If you had to mock the product in the for loop for some reason I think you would have to inject a factory into your code, and then mock the factory. ``` foreach(products as product) { ProductFactory-&gt;createProduct(product_name, product_price, ...) } ``` You could then change what the `createProduct` function is producing.
Like php and low barriers, you get the shit with the good stuff. We have a team of folks who write well written low maintenance modules all the time. Definitely harder to find and build a team around but lots of up front gains for simple projects. Not sure what you mean about version control logic. 100% best practice in the community. That plus database migrations and other areas. Not sure what part you take issue with, what you said isn't really at all accurate.
In both cases, it's a container that holds object instances or factories. The difference between the two ideas you have is actually pretty trivial.
&gt; tl;dr everything in moderation including moderation Love it.
the most common scenario I run into, where you simply can't inject, is when you need runtime data to instantiate a class (e.g. a user model). Factory type classes are fine; you still have a given class being instantiated in a single place, and you can mock the factory.
If my linkedin is set to "actively seeking" linkedin messaging would be my preference. Here are my expectations of a recruiter: 1 - Read my resume or linkedin profile! You are not bothering me if you are reaching out about a technology I am fluent with but if you are contacting me about some tech that I have never touched you are just another spammer who is wasting my time! 2 - Know my location. Unless it is doubling my salary or something I don't give a shit about employment opportunities with a 200 mile commute. 3 - Know the market. Know how much the skills and experience you are recruiting are worth in the area your clients are in. Combining 2 and 3, I once had a recruiter pleading with me not to pass up some $65/hr job 200 miles away, when I turned him down he was like but it's $65 an hour! I realize that is insane if you are sitting in a call center in India but it is just the going rate where I am.
200 miles is 321.87 km
I agree that mocks are to be avoided as much as possible, but isn't mocking everything inherently how PHPSpec works?
At least every Drupal project I've worked with was a house of cards, there was a minimal amount of code and the whole thing was dependent that the right check boxes were clicked in the Drupal admin. There was no way of knowing how things were supposed to work because there was no PHP code detailing the logic. &amp;#x200B; Moving a site from local to staging or staging to production was a nightmare because you either had to click the right things in the Drupal admin or use the "features" module which was garbage and full of bugs to save the clicked configurations to serialized code. You had to use another module called "strongarm" because "features" didn't actually save half of the data. &amp;#x200B; I don't know if all Drupal shops are like that but all the developers there were amandant that this was "the Drupal way". Thank god I work with WordPress nowadays. It's not perfect but at least you can code the post queries and custom post types in PHP instead of clicking things in the backend 100 times.
Procedural Programming is for amateurs, OOP is the professional standard. In a perfect script/program, everything is an object. You cant be perfect, but you can approach as close as you can. Procedural code is a code smell, something that professional programmers will need to identify and get rid of.
Thank you /u/mjcov, this is what I was looking for. I have an uneasy feeling that the work to move everything over to `\Throwable` isn't finished yet, and there are still errors that will crash my code and miss my exception handling, or avoid my error handling altogether. Know if there's any other built-in functions using C-style error handling like `curl_errno` and `preg_last_error`?
Good question. @BnMcGi provided a great answer!
Hey, maybe take a look at this library: [https://github.com/thecodingmachine/safe](https://github.com/thecodingmachine/safe) &amp;#x200B; it rewrote native function to fully use exceptions instead of null/false returns
&gt;How would you mock the product in that for loop? Or would you care? You really shouldn't need to mock entities. Mock service, not data, classes.
For testing purposes, I would create a `CanMockProduct` trait in my `tests/` directory, then import in into the test case. foreach ($products as $values) { $product = $this-&gt;mockProduct($values); }
Not in american dollars it isnt
start bracket inline, always end bracket in new line
I like to newline my curly bois. public function thisMethod() { $a = ['first', 'second']; return $a; } But that's just like, my opinion, man.
Not ridiculous.. religious :) Those two styles are functionally identical, but the open-curly-on-the-same-line-as-the-statement is easier to read (imo). Some languages, Python for example, blend style and syntax.. leading spaces define the block. But for most, readability should win the day.
Trying to get that ad money on YouTube.
Ha, industry standard. Look into https://en.wikipedia.org/wiki/PHP_Standard_Recommendation.
Thanks! Fortunately I'm not too deep into a project. I'll go back over my code and amend the mess.
Ideally? I'd love to be able to look at what jobs need developers. When I'm interested in a new position, I'd love to know what's available. I think that was the original concept of job sites, until the spammy, sleazy recruiters convinced them to allow fake postings. I can see several problems with this from a recruiter's perspective, of course. Giving away a list of positions to your developers is also giving away your customer list to your competition... Just curating a list of jobs isn't going to create relationships with clients, whether those clients are hiring managers or potential employees... If you become a job listing curator rather than a recruiter, then what's to keep you from selling ads for sleazy recruiters in a few years after your site takes off, like current job listing curation sites? There's only one recruiter that I trust, and I was lucky to find him. I honestly don't know how I'd find another good recruiter if he won a lottery jackpot and retired. He knows the businesses in the area. He knows several developers. He takes the time to get to know us -- I've talked to him over the phone only (never in person) for the last decade, for short periods of time while I was actively looking for a new job, but the last time I talked to him, he remembered how many children I have. He even knows the difference between Java and Javascript -- and knows that I haven't touched C# professionally for 14 years, so though it's mentioned in one of my earlier jobs, he doesn't bother to even look at those positions for me. &amp;#x200B; ... As far as there being a better job for me right now? Sure, there probably is. But it's a huge risk, and there isn't any way to know if the job is actually better without taking up considerable amounts of time, both on my part and on the hiring company's part. If a recruiter can convince me that they understand my needs, abilities, and the type of company that I would enjoy working for, then I'd be happy with them sending me a note about a position that they know I'd prefer... but that's a level of detail that I wouldn't expect from any recruiter -- even the one I've been working with for over a decade.
For PHP I've always done it like the first.
Have a look at https://github.com/FriendsOfPHP/PHP-CS-Fixer This can fix a lot of style issues for you. I prefer writing the variant with the bracket in the same line. When I'm done, I'm running the fixer and my code passes the company's ci
I've learned a lot reading your posts here the past few years, thanks! The distinction between "big-M" and "small-m" models is new to me, and very useful in organizing my thinking (I'm planning to write a framework as an extension API for a project sometime in the near future, probably in Node). One pattern I don't like and that I've seen in (active record) Model implementations is this (w/o mentioning any specific framework): The base Model class is god-like, with a huge number of concerns. It is either instantiated directly (for create/read/add views), or has a class property for a "Collection" of model instances (browse views). The empty Model has to hold a reference to a Collection of Model instances, because it has many methods that *work on a collection*, and other methods that work on a single instance, and other concerns unrelated to either. This Model is managing lots of other, unrelated stuff - stuffing request vars into session storage (as well as the instance data), authentication in its internal "onBefore" / "onAfter" eventing system, etc. I need to read Eric Evans book *Domain Driven Design*. I have it and understand some of the ideas, but I don't think I've completely grasped the Repository pattern. I've understand that in terms of data-mapper ORMS like Hibernate, where the repository is a class of (mostly) getters/setters annotated with mappings to database fields. I don't think that's the correct meaning though; it didn't match up to what I read on Laravel's site (a guest post) about applying the repository pattern in Laravel.
Thanks for this. Why do you prefer coding in line first then changing it with a tool afterwards? Is it easier to read whilst coding as appose to just reading for someone else?
Thank you, maybe you could give your perspective to the question I asked in the other post as well :)
I think what I have in my head is auto-wiring vs. service location, but the way I phrased my comment didn't communicate that very well.
&gt;try { &gt; &gt;trigger\_error("hi"); &gt; &gt;} catch(Exception $ex) { &gt; &gt;echo "catch"; // it's not called. &gt; &gt;} &amp;#x200B; Result: &gt;&lt;br /&gt; &gt; &gt;&lt;b&gt;Notice&lt;/b&gt;: hi in &lt;b&gt;\[...\]\[...\]&lt;/b&gt; on line &lt;b&gt;3&lt;/b&gt;&lt;br /&gt;
When I'd push it with in line bracket, it won't pass the ci pipeline. So I have to push it with the bracket on a new line. But I like it more to write the bracket before pressing enter. It feels better imo. But the tool can do a lot more. It rearranges my use statements, adds the strict declaration to new files, adds a new line before loops, ... Okay. It supports my lazyness
That's interesting. CI pipeline being Jenkins, teamcity etc?
Yes, but much simpler. Just gitlab ci with calls to phpmd and phpunit.
&gt; existing code compels you to write more code like it Oh, how I "loooove" pull request's discussions when I try to fit into a already established huge project and keep up with existing codebase and receive comments about how bad this is done. FFS, this is what you guys did 3 methods above and now it's wrong?
Sure is. Still going strong.
Everything in drupal is available in code. You can extend Entity Bases and write whatever logic you'd like config is stored in yaml. That part isn't ideal but it's a trade off. I've seen just as many hacked up wp sites with custom code accepting direct params. It's a mess. I've also never had to search through a un-normalized DB which stored media as serialized json strings so, to each frameworks issues.
So if using "new" makes it hard to unit test, I try and make it injectable. If it's injectable it's easier to mock. Injecting lets us use a mock in place of the real object. If I am using the factory pattern of course new is expected.
Sounds like you had some shit developers or simply misunderstood what was going on. For example most of projects I work on are eventually deployed by the client without receiving a DB, and later on content team gets in without introduction. I'm the other side of the coin where I point how terrible WordPress is, but usually is human factor at fault and not the platform.
This is the answer I was thinking of. Inject dependencies into your factory and inject your factory into the classes that depend on it. All object creation should be handled by the factory from that point on.
People should really use pastebin for questions like this so entire questions aren't being stuffed into the sibject, or just switch back to the old reddit design. Or the mods could actually do something in here.
If your errors aren't handled as exceptions then any parse error will halt your code because no exception will be thrown. If your errors are being handled as exceptions then `\Throwable` will provide you the Error Exception being thrown by the error exception handler.
In fairness, PSR-7 being immutable means you'll need to clone the request over and over. A mutable PSR-7ish object is better.
Or just use the text box? I don't understand why people should need old reddit or pastebin to have a post text.
I wrote up a long document on this topic a while back: [http://joebubna.github.io/Cora/documentation/v2/dependency-injection/overview/](http://joebubna.github.io/Cora/documentation/v2/dependency-injection/overview/)
and in fact, this sort of thinking is why DHH came out with his blog post about "Test Induced Design Damage". What the above poster was doing is asking why you're not mangling your code to be able to mock everything, and the answer is that it isn't worth it.
Last time I checked the new reddit design doesn't have a textbox on this sub. The new reddit design is terrible.
&gt;One thing worth mentioning is that "desirable companies" is a very small list when you do software development. Google, Facebook. What's desirable about Facebook or Google?
For a very long time, the one in the middle was the correct structure. You will find it all over 1990's C/C++ programming books, maybe even some early php ones. But someone decided part of the bracket belonged somewhere else later on, and the current standard is your top example, from what i can tell. The old way makes a lot more sense to me visually, so i keep doing it that way, and will until they pull it out my cold dead hands. I also do an abbreviated version when the code fits into one line easily: if( whatever == whatever ) { doAThing(); }
As title, quite junior so documentation goes a long way:) Searched high and low and can't find it anywhere. Appreciate it if someone can link me
Your first example is K&amp;R, second one is Allman style. Neither is wrong. Not really sure what the benefits are for the third one.
memory allocation error. check error\_get\_last on shutdown (register\_shutdown\_function)
That's a good one I hadn't thought about, thanks!
Thank you. This scenario is covered for me - parse errors throw a [`ParseError`](https://www.php.net/manual/en/class.parseerror.php) `\Throwable`, which I can handle in my uncaught exception handler (`set_exception_handler`).
Scotch?
PSR-2, fig. I've written inline for years, but I've adopted PSR-2 standard on next line. Check these: phpcbf - phpcs
Share the expected level of the role. Level of remote work tolerance. Tell us more about the product. Some details on the team size, culture. The salary... {range}. We have filters too. :)
Loads of modules that still return false/null errors. We are still not at a place where everything is represented as an exception... but we're getting closer! I'm sure you can wrap things, call secondary functions, etc... but to your point, we're not there yet.
Good recommendation.
Like, from ThoughtBot? https://www.bourbon.io
It's tough. Let me try to paint a picture... you might be able to identify a pair of shoes based on it's imprint, but to figure out the weight and height of the person in those shoes is more difficult... if reliably possible at all.
It's a bit mixed according to the standard. class CurlyBrackets { public function index() { if (true) { } } }
Boy do I not miss SOAP!
With Rubix is it possible to train a language processing model to recognise a question and extract key data from that question to answer the question? AKA the whole backbone of Diaglogflow &amp;#x200B; If someone says `What is the weather in london?` Can rubix be trained to recognise the question and tokenize the location to perform a basic query to answer the question &amp;#x200B; What is the weather in london |intent | | &gt; search weather | |location | &gt; london &gt; common seperator I use diaglogflow, and it is a nice service for free, but I am a person who A) doesnt want to put full trust in the avaliblity of a 3rd party service B) Always looking for a way to acheive a simular result inhouse
I completely agree. I know how to switch back to old php reddit. But I didn't think this question was "long enough" for a body. On a side note, I get why they removed the body, but that prohibits conversation.
Jesus christ thats in depth! - why thank you good .... person.
Seems like somebody doesn't fully understand their toolkit here.
Hmm, trying to start a hosting company or something?
GST? Simple math.
Just in time!
Check this out: https://zephir-lang.com/en
Cool - I've definitely heard of phalcon, but I'm wondering if anyone found the need to roll their own C modules in recent times... via a generator or not. With recent major performance overhauls to the language, is this event relevant anymore?
I don‚Äôt know for sure but they gained performance in php7 by using less memory. In php 5 they were making a bunch of copies of data and by making use of data once without any copies that sped up performance significantly. So my guess would be making a C extension would perform better than php7
Cool man, thanks for the input! I'm going to have to benchmark that legacy C module with PHP 7.* and see if there is even a point anymore.
Let me know how it goes. I‚Äôd be interested in learning about your findings.
I'll keep you posted @doodooz7
Call me a terrible Laravel Dev if you wish, but personally I don't like DI. To me it makes the code less obvious and less readable. Sure it makes the code cleaner, but try coming back to that function 6 months later, and then figure out exactly what's going on and where all this data is coming from.
It is possible but not as sophisticated as Dialogflow &amp;#x200B; The best we can do in Rubix's present form (0.0.11-beta) is a feed-forward neural network (MLP) with term frequency inverse document frequency (TF-IDF) input vectors (still better than anything else I've seen in PHP) &amp;#x200B; One problem with word count vectors is that we have no sparse array solution in PHP yet so we still have to do the full matrix multiplication even though most values are 0 (most words never appear in a sentence) &amp;#x200B; To get to the level of Dialogflow, we'd need something like a Long-term Short-term memory (LTSM) or Recurrent Neural Network, or even a Convolutional Neural Network (CNN) which I'll implement once we solve the multithreading problem &amp;#x200B; I also plan to implement Word2Vec and/or Doc2Vec word embedders and I believe those can be done efficiently even without multi threading &amp;#x200B; Having that said, this library by my friend in Brazil could use some love
Let‚Äôs assume your Product is more than a dumb value object and it contains some important business logic calculations that could affect your current test. While in general you want to mock the moving parts of your unit of work, you need to be careful not to blur the line between which unit of work you‚Äôre testing. In other words, it‚Äôs okay not to mock everything, so long as those real pieces are covered by their own tests. Keep your tests small and very concise in what they are testing. It‚Äôs better to have 10 small tests that are accurate than it is to have one or two larger tests that you aren‚Äôt as confident in.
It‚Äôs really not very difficult. How does using dependency injection make your code less readable? Instead of calling new className all the time you just pass className by reference into the constructor of the class. If you find this confusing then you are probably have too many dependencies in any given class which is a symptom of poorly architectured classes. In addition to all of this, if you aren‚Äôt using DI you cannot unit test your code. So yes, it does make you a bad developer.
Can bolt be used headless?
This interests me, can someone provide some cool examples of why youd do this? Interested to see when its needed.
Do you have an example of DI making code less obvious?
I have PhpStorm configured to run CS Fixer automatically after saving a file, and asked my colleagues to do the same (CS Fixer config file is included in version control as part of the project). This makes all code consistent and cuts down on pull request noise/merge conflicts. I could apply a lot of formatting myself when I write code, but I have more important things to keep in my head, and formatting on save is quick enough. It should be noted that this is not "my code style is better than yours", but about having a consistent code style across the entire project. I have worked in a number of languages and used their styles without problems, and arguments like "I will keep formatting code exactly this way until I die" are absolutely laughable.
Fair play on the downvotes, I expected them to be honest. Take the example below: https://pastebin.com/WdxDAWTQ Now, yes, it's obvious that the goal here is to export some messages to an excel file, and download this file, however, none of the params are passed to this method, Laravel is magically resolving them. This method is called directly from a route in the routes file with no params. I had to try and explain to a new member of the team yesterday how this works, where the actual data comes from for the download, and none of it was easy to explain.
Does not writing unit tests make you a bad developer? 1. There are many other kinds of tests that can be automated, to verify the system's functional status 2. "unit" is subjective
You should be unit testing your code so you know exactly what is broken. Feature and integration tests are useful and should be written as well. But if I‚Äôm a developer working on your codebase and a feature test fails I don‚Äôt want to have to be digging around to find exactly what method is causing the failure. With unit tests I would know immediately.
It‚Äôs not magic though. It‚Äôs dependency injection. A pattern that should be recognised and implemented. It will only take one explanation for the other developer to understand it. The second piece of code is no more readable but a lot less testable. Also almost everything in this controller should be abstracted to service classes. From looking at your code examples and your reasoning I think you need to revisit and truly understand DI and IOC. Once you do you will see the benefits.
yes a proper C program will outperform php all day long.
can we got a mod to clean up marketing bs here ..just gonzo this
You are probably right about seeing the benefits in the future, but for now this just feels like extra cognitive load. Ultimately I am a (relatively new) self-taught dev (who's been mostly working solo since day 0), and its definitely possible that I've picked up some terrible habits along the way. With the above statement in mind, can you give a more firm example of how you would abstract "almost everything" from the controller method above? I am always keen to improve my skills and my code, especially now that my company is taking on some new devs.
yes we do. read RFC or go home.
Try some courses on domain driven design it can help you with both abstraction to services and give you an idea on IOC. There is a very good course on plurasight (free trial) Essentially your controller should only be responsible for handling the request and returning the result. In the example you posted you would have a service like ‚ÄúExcelGenerator‚Äù that would be responsible for generating the file/storing it. The service would be called from the controller (you can use DI) and the controller then returns the stored file. The idea is to have skinny controller and abstract the business logic away.
nope. not everybody here knows it.
Thanks for this. I think it's time for me to really dig in to learning IOC in depth.
like others here i write code like a barbarian then auto-format to whatever my current job requires or desires...phpstorm : shift+ctl+alt+L
I am having trouble with this and could use some help. I used the below guide to get up and running with PHP but getting MySQL support (e.g. mysqli) within PHP has proven harder : [https://aws.amazon.com/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/](https://aws.amazon.com/blogs/apn/aws-lambda-custom-runtime-for-php-a-practical-example/) Would love any help you could give.
This one is a really good interview question!
You know, I hadn't thought about that. From the point of view of hiring, there are three things that I'd use as learning opportunities for juniors, would treat mid-levels as juniors if they can't identify, and would be instant deal-breakers for seniors... The rest are up to interpretation and, for seniors, I'd expect them to either have very good justifications for their decisions, or for them to identify it as something that, if given context, they may or may not choose to do things differently... such as using $\_REQUEST instead of explicitly using $\_GET or $\_POST.
I totally agree with you. I will try this question while interviewing candidates.
You probably should check out bref: https://github.com/mnapoli/bref
Link to other post please
Stateful mutable objects do not belong in your IOC container. These are your entities and other service classes that may mutate state during a request lifetime. You can delegate instantiation to a factory, where it is fine to use new. However, most of the time I will just instantiate in place, because I don‚Äôt believe in mocking classes that don‚Äôt cross system boundaries. Sometimes a factory makes the most sense, though, so use your best judgement. tl;dr it‚Äôs fine to use new for non-mutable/non-stateful classes.
If only add that it also turns out incredibly useful to make all date-related operations testable. For that I usually use DateTimeFactory of sorts. It doesn‚Äôt even have to be injected via DI, a static factory of factories approach would work here too (just like with loggers): `static $dateFactory = DateTimeFactory::forClass(self::class);`, this should make it easier to mock date time factory calls from different services as now you can easily tell service of which class calls the factory. I should add about loggers as I often see that in PHP people still often use DI to inject them, I think here Java‚Äôs approach works the best - it‚Äôs much easier, you only have one global logger for the whole app anyway, though you can still tweak a lot of things in that logger as its configurable, just globally (per each class that is using this logger). The reason I like it more is that injecting loggers everywhere via constructor only adds more boilerplate with no useful gains at all. (you also wouldn‚Äôt ever want to mock a logger)
code style, type hints, obvious descriptions, too many 'else', use sprintf instead of concatenation (.)
mobile unfriendly site (
1. If I already politely declined, please do not send me the 1:1 exact message 2 days again without changing even 1 word. 2. Don't make it obvious that you copy pasta the message to another 100 developers. At least change the name at the beginning lol &amp;#x200B; At that stage there is not much to do.. the only reason I want to change my job is either REALLY bad current conditions, then this post would make no sense, and $$$ CashMoney ‚Ç¨‚Ç¨‚Ç¨. &amp;#x200B; So. Let's say someone is earning 10k a year (just to make an example). Why would someone risk his safe job to get 15k/20k a year? Okey, in this example this is actually 100% more money. Let's increase this to like 80k$ a year. Why would I even try to risk my safe job to get 85k or even less? For a few days more holidays? For free fitness and food? Because a company is "open minded", "flexbile", "startup-ish"? &amp;#x200B; Yes, this all summed up are important in the beginning of your carreer. You probally have to start with less benefits and if a company has better benefits than another, then you even can say "damn okey I take 5k$ less for more comfort". But if you could get like 30k-50k$ more salary.. this would change a lot. This would make you think at least trice before even considering to decline. &amp;#x200B; I for my self can't think about changing. Maybe it's me, but I somehow feel like this is part of my family now. We gone trought so many things together, had so many nice times and now saying good bye to "give another company a try for money"? Mhmm I don't know.. it must be really a high amount of money that would be really stupid to decline. &amp;#x200B; Another reason would be the distance. If I could get a job way closer to the place where I live with a similiar (obviously preferring an higher) salary, bonuses and having some sort of security.. like employees that made a very good impression, or knowing their current state so your imposter syndrom can't win, because your confidence can shine trought.. that would be fantastic. At this point I don't care how a recruiter messages me. He literally could have ghetto slang, no grammar at all, but if he can make my life better.. why not?
A service container is a way of handling dependency injection. A service locator is a way of using a service container. The difference is not trivial and should not be trivialized. Service locators are bad and should be avoided, as they make you couple your code to the service container. With true inversion of control, you couple your code only to its true dependencies, and the container should *not* be one of them.
Yes, and it is a bit easier thanks to the memory management compared to PHP5. I also liked PHP-CPP allowing you to write plugins in C++ (http://www.php-cpp.com/).
if an object is not a service (DTO, Entity, any custom object which hold some data, a typed array for instance), you will always create it with `new`
Can you think of no other tools or types of tests that could tell you exactly what is wrong with your code, apart from unit tests?
It's a good start, and congratulations on publishing your package. I like to point out that the library attempts to one thing and it appears to be doing it well. Good job. &amp;#x200B; \- Try to add some tests. Even if you are confident about what you just wrong, these tests help in the long run and it takes a couple seconds to find out when you have broke something. PHPUnit is a good, easy to use, and a mature framework. Travis CI can be used to automate this, and is free for open source projects. &amp;#x200B; \- Your project requires PHP 7.0+, but the code does not appear to go with it. For example, PHP 5.3+ supports \`\_\_DIR\_\_\` constant, so you don't have to use the \`dirname(\_\_FILE\_\_)\` workaround anymore. &amp;#x200B; \- Implementing PSR-16 ([https://www.php-fig.org/psr/psr-16/](https://www.php-fig.org/psr/psr-16/)) can help increase the friction in adopting libraries like this. \- Try to use parameter and return types. This will help in many ways from help conveying the expected parameter type to actually enforcing. \- All the exceptions thrown are \`\\Exception\` ones. It helps if you shrink the scope to \`\\RuntimeException\` for example when the directory could not be created.
Don't call me, I'll call you, if I'm really frank and honest. By now my network of recruiters is almost as big as actual peers and I would just choose those most reputable to me. This even covers international job opportunities. I'm not that much of a job hopper, though. I've had to learn to put recruiters under a lot of scrutiny and found that interviewing them is way more important than the interview with the new job opportunity, because most I've got experience with have a real knack of wasting oodles of my time on opportunities that explicitly fall out of my criteria and they're not honest about up front. As some have also mentioned, please read my actual resume and please pay special attention to my current role. That I've used to accept a role as junior front-end developer at the start of my career and have spent two weeks on getting a Magento certificate, which I don't use in any capacity, does not mean I'm looking for either or the combination of the two. I will respond best to an honest and complete job opportunity by mail or LinkedIn, which is actually tailored to my interests. Please also don't assume that my interest is any different if I would get to earn triple my current salary, if I'm willing to up and move across the globe. My private life is the most important part of my life and uprooting is not something to be assumed as an easy thing for all of us.
Looks good in general, but some obligatory cargo cult code is present. For example, did you try the following throw? Did it work as expected? if (!file_exists($this-&gt;dir) &amp;&amp; !mkdir($this-&gt;dir, $this-&gt;mode, true)){ throw new \Exception("Can't create cache director: {$this-&gt;dir}"); } Here you are doing the double job and doing it bad. First, PHP already will tell you if it will be unable to create a directory. And second, it will tell you the **reason** which is most important for you, letting to fix the error. So your throw just duplicates the PHP functionality adding rather useless error message. Manually thrown exceptions are needed much more seldom than they are generally used. Most of time you just let PHP to report the error.
Bref is good, the problem is going to be the MySQL connection. You‚Äôre going to need to be very strict with how you clean up and timeout your connections. Node sub-processes are not forgiving and if you mess something up it could cost you dearly.
I just named some above for you. That doesn‚Äôt change the fact code should be unit tested.
This might be reasonable for application code but does never apply to library code. Imagine a library, where some classes retrieve their logger via lets say Monolog Factory. You would never be able to use it with another (perhaps more leightweight) Logger, which is also Psr\Logger compatible, even though it would be possible from an API perspective. This is tight coupling and that's the reason why it should be avoided. The boilerplate only hurts the lazy ones and if you tend to have too much dependencies for your class, you're likely violating the SRP anyways and should refactor it.
https://speakerdeck.com/nealio82/running-your-symfony-project-on-aws-lambda. Have a look at this. He‚Äôs explaining how to add a database connection as well.
Nicely written!
One thing I found very useful i understanding DI was building my own DI container. It's not something I'd want to use in production, but I found it helped to understand the concept and make it feel less like magic.
TL;DR: A very long read that tells you every single commonplace fact about PHP but doesn't answer the question stated in the title
Was hoping for something 'new' (coming) in 2019 to read.
**Race conditions** are not handled in your library. If you're in a high-concurrency environment you should avoid using a filesystem cache. Multiple operations on the file system are very hard to make atomic in PHP. I have written a similar library that implements the PSR-16 (Simple Cache) interface. I've had to acquire an exclusive lock witch `flock` on the file while proceeding to the writing. A more atomic option when creating directories would be to use `@mkdir`. I know that using the `@` is not very good, but it's more atomic then using `if (!file_exists($this-&gt;dir) mkdir(...)` and so on.
DI container and Service Locater are **TWO COMPLETELY DIFFERENT PATTERNS**.
[This is planned for PHP 7.4...](https://wiki.php.net/rfc/ffi)
Saw the title, clicked the link, went back, saw your comment. You are the real MVP &lt;3
From the sidebar: &gt; /r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required).
With PSR-2, many frameworks have now adopted the Almann style way. Preference wise I wouldn't care, but in my opinion, since the new return type hints in PHP, the Almann style is now more practical to use than same line brackets.
Both code blocks are fully correct. See [here](https://github.com/kalessil/phpinspectionsea/blob/master/docs/probable-bugs.md#mkdir-race-condition). The correct one would be: if (!is_dir($this-&gt;dir) &amp;&amp; !mkdir($this-&gt;dir, $this-&gt;mode, true) &amp;&amp; !is_dir($this-&gt;dir)) { throw new \Exception("Can't create cache director: {$this-&gt;dir}"); } Looks strange but it works.
I've gone ahead and made a pull request for the repo to set up [travis-ci](https://travis-ci.com/) with [phpstan](https://github.com/phpstan/phpstan). Static Analysis with [phpstan](https://github.com/phpstan/phpstan) reports the following issues: ------ ----------------------------------------------------------------------------------------------------------------------- Line FileCacher.php ------ ----------------------------------------------------------------------------------------------------------------------- 18 PHPDoc tag @param has invalid value ($path): Unexpected token "$path", expected TOKEN_IDENTIFIER at offset 56 34 PHPDoc tag @param has invalid value ($key): Unexpected token "$key", expected TOKEN_IDENTIFIER at offset 57 49 PHPDoc tag @param has invalid value ($key): Unexpected token "$key", expected TOKEN_IDENTIFIER at offset 42 79 Call to function is_callable() with null will always evaluate to false. 92 PHPDoc tag @param has invalid value ($key): Unexpected token "$key", expected TOKEN_IDENTIFIER at offset 42 92 PHPDoc tag @param has invalid value ($value): Unexpected token "$value", expected TOKEN_IDENTIFIER at offset 61 110 Parameter #1 $fp of function fwrite expects resource, resource|false given. 111 Parameter #1 $fp of function fclose expects resource, resource|false given. 124 PHPDoc tag @param has invalid value ($key): Unexpected token "$key", expected TOKEN_IDENTIFIER at offset 18 124 PHPDoc tag @param has invalid value ($lifetime): Unexpected token "$lifetime", expected TOKEN_IDENTIFIER at offset 37 128 Call to function is_callable() with null will always evaluate to false. 148 PHPDoc tag @param has invalid value ($key): Unexpected token "$key", expected TOKEN_IDENTIFIER at offset 54 162 PHPDoc tag @param has invalid value ($key): Unexpected token "$key", expected TOKEN_IDENTIFIER at offset 52 174 PHPDoc tag @param has invalid value ($filename): Unexpected token "$filename", expected TOKEN_IDENTIFIER at offset 51 185 Parameter #1 $json of function json_decode expects string, string|false given. 206 Parameter #1 $var of function count expects array|Countable, array&lt;int, string&gt;|false given. 207 Argument of an invalid type array&lt;int, string&gt;|false supplied for foreach, only iterables are supported. ------ -----------------------------------------------------------------------------------------------------------------------
It's not just about the language (quirks), it's about the price, the ecosystem and the big community. And that's exactly where PHP wins again and again.
Come on, Chris, you've been here long enough to know that just as "only the Sith deal in absolutes", this sub goes one further: "/r/php ONLY deals in absolutes". This sub has solved programming in its entirety - there is no need for further thought. As your punishment, write out _"You should use prepared statements with PDO"_ 100 times.
‚ÄúLike a barbarian‚Äù I love it!
Sorry, neither them, literally called whisky frameworks or whsky
Disgusting. Stop showing newcomers these bad practices. You should be advocating for clean, well separated OOP code and using PDO.
Looks indeed strange. There is still a superfluous *and* useless error message. And the only problem with the race condition here is an extra error message (when a directory created between is dir and mkdir calls) and your code doesn't deal with it
Thanks for all the suggestions, I will try these out.
what the hell! I don't like it!
@mkdir is shooting yourself in the foot from a feckin' cannon. Using @ is not just "not very good". It's an epic fail. **To get rid of just ones single particular error you are ditching all possible error messages** that otherwise would help a programmer to find and fix the problem
We don‚Äôt need more shit tech articles from incompetent ‚Äúdevelopers‚Äù, thanks though.
I think you should add a disclaimer to these kind of posts stating that ADR is your own concept. &gt; As it turns out, MVC is simply not for server-side implementation; ADR is. Many very smart people have come to a different conclusion.
Alright let me have a crack... 1. You‚Äôre using mysql which is depreciated. 2. You‚Äôre not using prepared statements. 3. You‚Äôre passing the god damn request super global into a sql query without any sort of security check (empty, special characters) 4. The credentials are not hashed which would assume you‚Äôre database credentials are stored in plain text 5. You‚Äôre selecting all columns when you really should just be selecting the ones you need. Did I miss anything? ü§î
Isn't the difference that throwing an exception will stop the control flow and non-fatal errors will continue?
General reaction: nobody cares.
It depends on your configuration. It can be easily configured to stop on non fatal errors as well. Either way, throwing an exception with useless error message is not the way to go
Currently, you can choose only be a guest blogger or paid blogger. Yes it's INR sign.
This would be a blog revolving around PHP, Laravel and Angular.
I always just offer up my brief analogy in place of waffle like this. PHP is like the English language. It‚Äôs inconsistent, weird and confusing. But you can do a hell of a lot with it.
IIRC, recursive `mkdir` checks if directory exists before create one, so: ``` mkdir($this-&gt;dir, $this-&gt;mode, true); if (!is\_dir($this-&gt;dir)) { throw new \\Exception("Can't create cache director: {$this-&gt;dir}"); } ```
They're not for everyone, that's for sure.
&gt; use sprintf instead of concatenation Please explain why
I‚Äôve only ever maintained a horribly built, makes you want to scream type of CakePHP 2.x application but in saying that the latest version of Cake isn‚Äôt bad. I‚Äôm mostly a Laravel dev but I like the more hands on and closer to vanilla php feeling Cake gives you. Laravel can feel very ‚Äúmagicy‚Äù sometimes.
eMule, that takes me back.
I would normally bypass the recruiter on everything but my daily rate, as that's between them and me. Including conditions like remote working, I'll discuss directly with the client.
Shameless repost: https://www.reddit.com/r/recruitinghell/comments/ay9ocz/notes_to_recruiters/
You could use aurora data api instead (SQL over http)
good analogy I've not read before! :)
Can't believe this is still going...
in all this the OP didn't say they were doing this for a client or being paid as such for this learning - it was a (logical?) jump I made. to the extent it's a factor, I think our points are valid. my entire original question was "what are you learning?" as in "what are your goals?". having a plan to learn xyz vs just randomly poking around gives pretty different results (in quality if not just in time spent). We probably both agree that the OP will likely end up rebuilding much of the stuff that's already out there - and likely generally poorly - without a deeper understanding of what problems exist and the approaches existing tools take. AND THAT'S FINE, to the extent that it's just code running on their own projects. It's even better if OP builds something, then understands *why* it's bad - in what areas it's deficient (security, error handling, perf, docs, testing, whatever) - and then practices making improvements. That's how we learn. It's much harder to do that sort of process by just dismissing existing tools by saying "they're too big/bloated/etc".
Features like short closures would have an immense impact on my day-to-day programmer life. I makes me wonder whether some influential userland developers should be allowed a vote on these kinds of life-changing features. I realize that this probably won't happen, but I see potential for the FIG here. Although not in its current form: some current FIG members shouldn't be considered as representatives of the larger community, and many who could be have distanced themselves from the FIG. Still I believe that the FIG could become a group of developers that accurately represent the current world of PHP, and they could actually have a big impact on how the language evolves. This is already possible btw, according to the RFC rules: https://wiki.php.net/rfc/voting#who-can-vote
They all are "magicy". And filled with global state, and using active record, and really hart to actually write tests for :(
Hello r/PHP \- I Create this small library to generate/validate CSRF tokens without storing them anywhere. This doesn't provide replay-attack protection, but should work well for forms. &amp;#x200B; I appreciate any feedback I can get. Thank you in advance for your time.
Much easier to read/maintain. Use numbered tokens for the cherry on top.
So you propose instead of ``` fwrite($h, $meta . PHP_EOL . $value); ``` use ``` fwrite($h, sprintf('%s%s%s', $meta, PHP_EOL, $value); ``` I mean, yes in many cases sprintf is better solution, but in OP`s code IMO sprintf will make code less readable.
please let this happen
Php, as other langyages as go, are based on community feedback. However, once a draft and proposal is made, is up to the language internals to decide what to do. The article explains the need for the fn prefix, the first proposal failed and its normal, only the language internald know if it's possible to parse and implement the features without adding much complexity. That said, jit + arrow functions comming to php 8 is a great step forward... Can't wait!
it doesn't work that way for a reason. The PHP group comprised of all the contributors have to develop and maintain the features that exist and that is a lot of work. Since almost all of them do it in their free time, imagine being "forced" to work on certain things by outside control, the contributors will run away very fast. &amp;#x200B; The PHP RFC process is done to allow community feedback on the internals list and especially with the short closures RFC Niki has gone above and beyond imho in explaining different syntax proposals, their advantages and disadvantages and listening to feedback on the internals discussion thread.
Except mkdir emits a warning, not an error, when it fails to create the directory so an exception or user error is warranted if they desire to stop execution. This is a package, it shouldn't dictate you configuring warnings to stop execution.
My argument of more towards the use of concat vs sprontf, but you are right in the particular use, interpolation looks much better.
&gt; The container is not magic. If you create an object in the container that's basically the same as putting a `new` right there. This is also why it‚Äôs good practice not do anything more than variable initialization in the constructor. If something breaks in the constructor in DI, it can be a bitch to debug.
&gt; I think you should add a disclaimer Here you go: - http://paul-m-jones.com/code - http://paul-m-jones.com/community - http://paul-m-jones.com/talks - http://paul-m-jones.com/writing
I completely understand. And I was in no way criticising Nikita's amazing work. Looking at the people who voted on [typed properties](https://wiki.php.net/rfc/typed_properties_v2), I see quiet a lot a names popping up of people who don't maintain any PHP code, I'd even say there's only a minority of people who are actively contributing to php-src on that list. I'm not talking about allowing 50 user lands developers, though I'd love to see more people like /u/ocramius having voting rights. I'm sure you can also think about just a few developers who have a big impact on the day-to-day programmers community. Of course, please correct me if my assumption about people not actively maintaining PHP is wrong, I wasn't able to find a list with all people who are eligible to vote, and I don't know in detail about what those 71 people do in regards to PHP; so I'm all ears if my assumptions are incorrect!
As you were asking below about how you might refactor this controller. My first, naive, refactoring would be to extract the dependencies out to the constructor, rather than the method signature and extract the filename logic to it's own method. [Like this.](https://pastebin.com/ZMzSBdz8) In my opinion, your example of something that's easier to follow is actually slightly more confusing, at least without context. $data = $this-&gt;getMessageData($company); $export = new Export($data); Where is `getMessageData` coming from? Why does the data from `$company` need to be provided to `Export` here, but not `MessageExport` when it is instantiated by the container and if it is, where is it obtained from? My guess would be that when `MessageExport` is instantiated by the container, you are pulling the current user out, getting it's company and providing it with the data. But this is a pretty odd thing to do when creating an object in the container. If you need to be able to mock `Export`/`MessageExport`, I would inject a [factory](https://phptherightway.com/pages/Design-Patterns.html#factory) object that can create it when passed the data. If, however, `Export` is just a dumb object the transforms some data it may make sense to simply `new` it up in the service that is using it, but you'd still want to be injecting the service that is using it into the controller. Also, why the global `company()` helper? Is that just returning something like `$user-&gt;company`? If I'm understanding this right, I would create a `CompanyMessageExporter` service with a `download()` method that is passed a company object and a type to return. The controller's constructor would require this dependency to be injected. That way, the controller is only aware of the existence of this service and only passes massages on to it, without any concern for how the request is fulfilled. The `CompanyMessageExporter` would in turn have the `Excel` dependency injected into it and could either use an injected `MessageExportFactory`, to create the `MessageExport` object with the appropriate data pulled from the company, or it could simple `new` up the `MessageExport` directly with that data, if there's unlikely to ever be a need to mock `MessageExport`.
This vote is targetting 7.4 ;)
I personally find it unreadable and don't use it in javascript. I don't know why they are trying to add every js feature to php but the ones they have added so far are working well.
Arrow functions is proposed for PHP 7.4, so we might have arrow functions in as little as 8 months üéâ
Oh that's great!
Maybe one more thought about the internals list: from a userland perspective it's a mess. Before you know it, people are shouting and discussing irrelevant stuff. I don't feel the need to represent myself in any way on the internals list, imagine what would happen if everyone pitched in‚Ä¶ But it does seem nice if more developers with lots of userland experience were actively present in the discussion and voting process.
One example agains the by-value binding that has occured to me, and is not mentioned: While it is true that by-reference binding of variables is of little use with single-expression functions, this single expression might still call to some other function with wants to modify the variable. Kinda forced example: function printItem($a, $b, &amp;$counter){ $counter += 1; return $counter . ". item: " . $a . " " . $b . "\n"; } $c = 0; // lets try print some items print(printItem(2, "ducks", $c)); print(printItem(5, "ducks", $c)); print(printItem(3, "ducks", $c)); // output: // 1. item: 2 ducks // 2. item: 5 ducks // 3. item: 3 ducks // repeating the "duck" and the $c is dumb though; // let's create a partially applied function $duckPrinter = \($n) =&gt; printItem($n, "ducks", $c); print($duckPrinter(9)); print($duckPrinter(5)); // output: // 4. item: 9 ducks // 4. item: 5 ducks I mean this is not a good way to code, but still my intuition would not warn me about the usage of $c here in the lambda function.
I will not review the code itself, I'm not a security expert and that would be the job of a security reviewer. Nevertheless, I can still make some comments on the form: * you don't seem to respect your own coding standards, spacing is inconsistent along the file, * it's lacking a few empty lines here and there, code needs to breath to be readable (I give the point that that's very subjective, everyone has its own opinion about this), * may be you should comment more (actually you didn't comment anything, that's sad). That was my two cents, happy coding :)
The PSR-2 is not consistent about the placements of curly brackets. For function and classes, the brackets are placed in the next line. For ‚Äûif‚Äú-conditions, the brackets are placed on the same line followed by a new line. As mentioned below, there is no right or wrong according code style. Mostly it still get very emotionally, when argue about spaces or tabs. To keep it simple: * stick to an existing code style (like PSR-2) * let your IDE format your code automatically (e.g. [PHPStorm](https://www.jetbrains.com/phpstorm/)) * code can be also formatted using tools like [PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) or [PHP Code Sniffer](https://github.com/squizlabs/PHP_CodeSniffer) * use a test in your build pipeline, to ensure that the code follows the code style (e.g. [Style CI](https://styleci.io/) or [PrettyCI](https://prettyci.com/))
This is a package, it shouldn't stop the execution. I would prefer a package which doesn't make me wrap every call in a try catch so it won't crash my entire app.
Well, it depends on what the package is designed to do. If it expects a directory to be available later, it may be worse for it to keep running versuses just throwing an exception. I'd much rather a package throwing an exception when it should throw an exception versus forcing me into a paradigm that stops execution on all warnings...
Have you checked in the header?
I did, I assuming it would be obvious?
Most factories I've seen are static classes that rarely need any specific initialization, thus, they can be used without dependency injection. Just instantiate the factory few rows above and have it create objects in the loop as much as your heart desires.
Thank you! I have made several code style changes. I will also add comments where they deem helpful. Thanks a lot for your helpful feedback.
Definitely a good point. What makes this worse is that it's not even obvious that this code is broken when you look at it, because PHP has no way to mark by-reference passing. I should pick up https://wiki.php.net/rfc/explicit_send_by_ref again...
Repositories I think are often described more complexly than they really are. At the end of the day, you should just think of a repository as an in-code database. You can put stuff in it, pull stuff out of it, modify it, and put it back in the repository. Behind the scenes the repository might actually persist those changes or new bits of data to an actual database, but as far as your code is concerned, it doesn't know or care about what's on the other side of that repository abstraction. But because a repository is intended to be part of your domain, it's important for it to facilitate concepts in your domain. Suppose you have a frequent need to identify customers who have purchased more than $100. Maybe there's some important rule in the actual physical business that customers who have purchased more than $100 are sent special thank you emails with coupons in them. Well, if you have a `Customers` repository, then you probably want to make that an explicit method. `$customerRepository-&gt;findCustomersWithAtLeastOneHundredDollarsInPurchases()`. But clearly that's a clunky name. So part of domain driven design is to come up with terminology that fits both the business, and the code. Maybe the business decides to call those customers "Big Spenders". Well, that's now a term in the domain's ubiquitous language. So you might capture that in your repository. `$customerRepository-&gt;findBigSpenders()`. That method then has that rule of $100 in total purchases baked into the underlying query. And maybe that query uses a slightly more abstract repository method: `$this-&gt;findCustomersByPurchaseAmount(PURCHASE_AMOUNT::GREATER_THAN_OR_EQUAL, $100);`. But taking this further, constantly polluting the repository with these methods will become a bit unmaintainable, and force the repository to carry a bit too much responsibility. So instead of methods, you could create domain queries instead: `$repository-&gt;find(new DomainQueries\BigSpenders())`. Then each of your domain's explicit business rules and concepts can be encapsulated by single classes to represent them. Each class has then one responsibility, and the repository doesn't have to change each time you want to add a new domain concept to it. Why not just do this in plain SQL? You can, of course. But the repository is just there to facilitate those domain queries in a way that cannot easily be expressed in SQL (short of a stored procedure or user defined function). If you aren't doing this kind of domain modeling for your queries, then I would argue there's little point to having a repository abstraction. In the context of Laravel, just using Eloquent and the Query Builder *itself* is enough of an abstraction.
How do you honestly understand this ```($a = ($a = ($a = ($a = ($a = 42) ==&gt; $a))))```
I'd say then: download every file in the theme and then search in those files. I don't know where he put it.
Maybe you shouldn't use the new syntax in this case.
I'm so fucking stoked for this one. This really opens the door for a lot of cool design patterns for end developers, and for frameworks. The particular thing I'm excited about is higher-order functions, and continuation-passing as a mechanism for dependency injection. ``` $add = fn($x) =&gt; fn($y) =&gt; x + 1; array_map([1, 2, 3, 4], $add(5)); // [6, 7, 8, 9] ``` Easier-to-write Higher-order functions really open the door to cool design patterns. For common predicates / simple functions, a higher-order function can generate them all. Like that `$add` example. Or, for filtering database results based on some column name. The possibilities are endless. And then the continuation passing... That's probably the biggest deal. Instead of injecting a service class and using the dispatch rules to customize action, we can all of a sudden do something as simple as: ``` function returnAsElement($continuation = fn($a) =&gt; $a) { $innerHTML = something(); return $continuation($innerHTML); } ``` So all of a sudden the caller 100% decides what's getting returned! It's not like we can't do this stuff with the current syntax, but it will completely blow a chunk of code up. `function () { return _; }` is supposed to be over at least 3 lines, and it's already a lot of charaters. This feature could really change everything and catapult PHP further into the world of modern languages. But as with anything, there will always be people that take this way too far and chuck around arrow functions for the sake of it...
A simpler way of writing closures doesn't mean you disregard all other clean code techniques... &amp;#x200B; array_filter($arr, function($item) { return item &lt; 10; } &amp;#x200B; array_filter($arr, fn($item) =&gt; $item &lt; 10); &amp;#x200B; &amp;#x200B; To me, the bottom example is easier to read and write. It removes a lot of the unnecessary boilerplate, but perhaps I'm just used to this syntax being in other languages. If you're brand new to this syntax, it may take a little bit more time to get adjusted to it.
any one that used JS arrow functions sees the value when combined with methods like filter() and map(), replace the short closure in your snippet for any other operation and it will still look ugly, so the problem is your snippet. Also the syntax will be fn($x) =&gt; $x + $y
Unlikely, when the brunt of developers will use it in libraries.
the creator actually just reached out - I thought we were gonna get into an argument but he admitted he DID hard code that into the theme - why????????? Anyway, he showed me where it was and I removed the line and removed the errors. PHP is proper confusing!!
Their example is concatenation, not interprolation, as interpolation won't work with constants. Interpolation would look like: `fwrite($h, "{$meta}\n{$value}");` Note that PHP will automatically convert `\n` to `PHP_EOL` as long as you're not using `fopen` in binary mode.
One-offs are fine. People do abuse features that they do not fully understand though. It's actually the reason why PHP has a bad name albeit it being a very clean language nowadays IMO.
I stick to the first example. I can't stand seeing the bracket on a new line after a function only to have everything else on the same line, looks inconsistent. If I have an old project where I used the second example then I do everything with a new line bracket.
Looks like it's not even on Github anymore. I was able to poke around in the cache here: &amp;#x200B; [https://webcache.googleusercontent.com/search?q=cache:WRaekRSOp7AJ:https://github.com/D-L-M/whsky+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us](https://webcache.googleusercontent.com/search?q=cache:WRaekRSOp7AJ:https://github.com/D-L-M/whsky+&amp;cd=1&amp;hl=en&amp;ct=clnk&amp;gl=us) &amp;#x200B; Doesn't look like any docs are present tho.
&gt;I would think it obvious that the site "pmjones.io" and the user "pmjones" are related Fair enough. &gt;I prefer to say, not that I ‚Äúcreated‚Äù the pattern, but that I ‚Äúrecognized and named‚Äù it in 2014. Slim, for example, already had single-action controllers at that time, and the various Domain Logic patterns previously existed as well. If I ‚Äúcreated‚Äù anything, it was the idea of the Responder; that is, of treating the Response-building work as a completely separate concern. But even that is just an application of Separated Presentation. Interesting stuff. Still, in the absence of something identical, ADR as a pattern seems to be your own concept. The fact that it is similar to other existing patterns doesn't change that imo.
You should be aware though that you cannot have multiple expressions: https://wiki.php.net/rfc/arrow_functions_v2#multi-statement_bodies
No
Not really, I wanted some feedback from my own perspective, I come on Reddit and thought I'd ask to improve how I can provide my service to developers. Your post is a rant, mine is a question. Very different.
Too many syntax shortcuts and your language turns into Perl.
That's not a router, that's a mapper.
&gt; every js feature Shorthand variants of closures or their equivalent exist in the majority of widely used programming languages, many predating JavaScript's adoption of it. Like many programming concepts or syntaxes, if you don't see it regularly it can look weird, but if you're using them with any kind of regularity they can make certain kinds of code _much_ more readable and strip out visual clutter that forces you to spend longer scanning code to understand it.
&gt; C# that do it right &gt;turn PHP into Javascript with extra steps You realise that C# already has the equivalent of short closures in it's lambda syntax, right? Short closures were available in JavaScript long after many other languages had adopted similar functionality, because they're extremely useful and can make certain kinds of code far more readable. Particularly in PHP, being able to obviate the need for `use ($lots, $of, $params)` is a big gain.
Sorry, I meant the same comment you originally mentioned.
1, 3, and 4 are the ones I put in to be the big red flags. 2 and 5 are definite code smells, and if I were doing a code review, I would expect solid justifications... With 2 specifically, I'd expect *parameterized* prepared statements (though for consistency, I'd want every SQL statement [that can be prepared](https://mariadb.com/kb/en/library/prepare-statement/#permitted-statements) to be prepared, whether it takes parameters or not).
Definitely a rant, but notice how people have made here many of the same points I ranted about on that post.
What do you think about combining the two? What I mean is to have the arrow function bind variables by reference which are explicitly marked 'by-reference' on site, i.e. fn($n) =&gt; printItem($n, "ducks", &amp;$c) as a shorthand for function($n) use (&amp;$c) { return printItem($n, "ducks", &amp;$c) }; As far as I can tell the `fn(...) use (...) =&gt; ...` didn't make it in the proposal, and this would still make it possible to do bind by reference in arrow functions. I see no point in intentionally passing a captured-by-value variable as a reference to a function, so this would not be a problem. However it clashes with the reference assignment syntax (i.e. `fn($x) =&gt; 2 + ($x = &amp;$c) + ($x++) + $c`), right? Unfortunately though, unless explicit call-site pass-by-reference is mandatory, it still wouldn't really help with catching the error in the duckPinter code.
Protip: Have a look at something like PHP Codesniffer and configure it to use PSR2. Don't know if you've used it before, but not only will it find the errors in code style, but can also fix many of them automatically.
&gt; ADR is your own concept In fairness to /u/pmjones, the fact that ADR is a pattern he's worked on developing is irrelevant to discussing it. Although GoF patterns occupy much of the thought-space around the topic, there are numerous patterns in software engineering, and a well-developed discipline that is concerned with [establishing patterns](https://hillside.net/patterns/) and verifying them.
The comment on exactly what an ubiquitous language is with an example and refactoring domain queries out is helpful. I don't feel like I'm completely getting it though: Repository looks like a typical MVC framework model implementation, just by a different name. Are the model entity properties set as class properties on the repository? What other objects are involved, besides a DBAL layer / query builder / ORM layer? Are there POJO entity objects being generated by the repository? Thanks for taking the time to write that up.
Makes sense to make an open source version (see laravel and how this business model works in general) Is Zend still relevant? I haven't heard someone making something using Zend in a while for sure.
Seems like it's going to!!
Yes, the framework and other libraries have experienced amazing growth the past 2 years going from 100 million downloads to 400 million downloads.