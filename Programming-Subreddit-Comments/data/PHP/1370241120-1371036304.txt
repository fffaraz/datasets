This already exists on imgur, sad to say. Hit the ['random' button](http://i.imgur.com/tMjqp0G.png). You also need more looping - there is a lot of repeated code. What about images with 7 character hashes? Imgur recently moved to 7 character hashes from 5. Why is there a landing page whose only point is to get to the next page? Say you own imgur-roulette.com. If people go to imgur-roulette.com do they want to have to click a button to get random images? The whole *point* of going to imgur-roulette.com is to get random images, so just do that instead of making them press a button. Penultimately, this code has the possibility of generating random non-gallery images. Only about 2% of images on average are submitted to the gallery so if you are purely generating random image hashes, you are going to get a whole lot more non-gallery images than gallery images, which has implications for the kind of content you will be showing (adult, gore, cp, ...). This isn't bad in and of itself (you are immune with DMCA safe harbor) but it's something to keep in mind for various reasons, the most obvious of which is if you ever put advertising on the page, advertisers usually don't like their product being associated with pornography or anything. This is the reason that Imgur only shows advertisements on SFW reddits, and on most gallery images. One possible solution is to use the Imgur API to verify the hashes you generate are gallery images. Lastly you'll notice that most of the images you generate through the random process are non-existent. On the actual Imgur site, random mode looks at the set of already existing images and randomizes them in various ways to get really random gallery images. You'd need to send a HEAD request to Imgur to determine whether an image exists if you wanted to fix this, or you could just [use this convenient endpoint of the Imgur API](http://api.imgur.com/endpoints/gallery#gallery-random)
so many dick pics, crazy. comments: - detect if the image does not exist. - keep aspect ratio on the front end 
Captain Obvious on duty.
Doesn't every programmer already believe that their own code explains itself, and that it's always clean by their own standards? And isn't this the problem in a nutshell? 
Thank you the constructive comments! &gt; Lastly you'll notice that most of the images you generate through the random process are non-existent. On the actual Imgur site, random mode looks at the set of already existing images and randomizes them in various ways to get really random gallery images. You'd need to send a HEAD request to Imgur to determine whether an image exists if you wanted to fix this, or you could just use this convenient endpoint of the Imgur API My solution below, but it results in very slow generation of results. I was thinking to write a script that collects the images that actually exist and then store them in a database so I can quickly retrieve them randomly. $url = 'http://i.imgur.com/'.$randomized.'.jpg'; while (testurl($url) == FALSE) { $randomized = ""; for($i=0; $i &lt; $numchars; $i++) { $randomized .= $str{rand() % strlen($str)}; } $url = 'http://i.imgur.com/'.$randomized.'.jpg'; } return $randomized; } function testurl($tsturl) { $test = get_headers($tsturl); if ($test[11] == "Content-Length: 503") { return FALSE; } else { return TRUE; } } 
I think there's a subtle but important difference between function/variable names that are considered 'self-explanatory' and those considered 'self-commenting'. The former implies that the code contains all the information needed to understand their purpose and use, or at least the programer's intent; the latter only that an effort is made to communicate their purpose and use and so will typically be more verbose ($formattedResult vs $res or $r), which is more realistic, in my opinion. The problem still remains of whether the intent is communicated unambiguously or not (do we understand what $formattedResult actually means in this context? why is not just a raw $result? are there other kinds of results that aren't formatted?), whether in comments or in code. No language is completely transparent, after all. All we can really do is aim for the lowest noise to signal ratio.
In this particular case, the second one. His code shows a stronger understanding of the language
Funny it mentions Symfony2 but not [Silex](http://silex.sensiolabs.org). I've been working with it recently to make a RESTful API server; I've made [a skeleton project available](https://github.com/inanimatt/silex-oauth2-api).
Being anal retentive here but there's no need for the pass by reference in your format_item function (the &amp; symbol). Namely, all objects are passed by reference so the indicator is superfluous. As well usage of the &amp; symbol in a function's arguments is generally frowned upon these days. Again since objects are always passed by reference and PHP uses copy-on-write (meaning if I pass an array to a function it will be a reference every time you read from it until you attempt your first write, then PHP duplicates var) there are no real benefits to using it (short of making php throw a strict notice). 
The nitwits I have encountered that write the asinine comments like "initialize variables" and the like for some reason believe their code does not speak for itself. Most of the time when I see this I think the programmer is writing a note to herself to help them think through the problem. THat's fine just delete that crap after.
I'll pick clean code any day of the week, because clean code documents itself. Clean code makes it easier to detect bugs whereas messy, commented code might actualy hide it (the comment is right, but the code is wrong, which isn't getting noticed because it's messy)
I choose the second, not just because the first method makes my eye twitch but if you didn't know that a foreach iterates through something then you shouldn't be programming ;) I am one to write a big docblock above a function which dictates what output it provides for a given input, how it should do it, what it replies upon and the correct code execution order. 
I've also seen it used as headers, like: // Initializing variables $foo = 'foo'; $bar = 'bar'; $baz = 'baz'; // Start main app $app = new App($foo, $bar); $app-&gt;start($baz); // do other stuff $other = $app-&gt;getOther(); $stuff = $other-&gt;getStuff(); $done = $app-&gt;do($stuff); Here the comments aren't really needed but it breaks the code into segments, which makes it easier to read. Though, if the code is clean; it could be replaced by // ===== // lines aswell, since it's just deviding code-segments
Second, of course. Kill the first guy. Readable code is self-explaining and much easier to maintain. Putting spaces "only where needed" and not using empty lines is great way to make the code less readable.
Very true.
 //-- iterates through items seriously?!
"... the code already tells us how it works; we need the comments to tell us why it works." http://www.codinghorror.com/blog/2008/07/coding-without-comments.html
Anytime ;)
Both of those are messy. If you want to use a lot of comments, you need more blank space between the lines to separate things and make it easier to read. That second example doesn't need so much blank space if there are no comments and everything is so self explanatory. Bottom line, PHP is retarded easy to learn, and is very forgiving, so anyone can develop their own ugly coding style. You should look at the code for the project they are working on, and see who adapts to the native code better.
New lines divide code segments perfectly fine, no need for pointless 'spam' comments. Having said that I do like 'header' comments (like 'start the main app') because it makes it much easier to scan a bunch of code looking for the section you want. Even with the 2 lines you have there it's always easier to read the comment than the code. But they should be descriptive; 'do other stuff' is stupid.
Personally, I'd like to be able to toggle it on and off like some kind of script... but I'm not well-versed enough in NetBeans to accomplish this, or know if it's even possible to make it something that could be toggled.
It also depends on how familiar you are with certain things, when I'm working on something I haven't seen before yet, I have a habbit of over-commenting things. When I look back at it later, I usualy start removing comments that don't make sense because, at that point, it's obvious what's going on. The advantage of using headers like in the post above is that you can easy put those code-segments in methods (where they probably belong) And yes, I might have exagerated with the 'do other stuff' in the example, :P
It annoys me to see someone thoroughly comment the function: string GetUserNameFromUserID(int user_id) Unless you are programming an API then any docs generated from this are never ever going to be read. 
Not sure if anyone noticed, but if the code was from a real programming project then the first guy could miss an item when the database only returns 1 or 2 results. //does nothing when count == 1 or count == 2 if( count($items)&gt;2 ){ foreach ($items as $k=&gt;$item) { //-- add hello $items[$k]-&gt;item="hello ".$item-&gt;item; } } //no else for count == 1 or 2, 1 or 2 items are never prepended.
So... array_diff*.
I was expecting that. This library (obviously) does more than just array_diff. You are welcome to actually read the link.
Here's the thing: Your docblock should say what your method is doing. If you need more than 1 more line inside the method, your method is too large, too complex and should be broken down into smaller methods.
I did check the link. What I can see, it does nothing which you cannot already accomplish with the built-in array functions. 
And also, there is no PHP framework or library that cannot be replaced by using native PHP functions, that's still not a reason not to use them.
That's a really poor argument. Your library replicates already existing functionality in the language. PHP frameworks extends the functionality present in the language. You're comparing apples and oranges here.
*sigh..* this is about the way of writing code/comments between 2 interns that I'm currently evaluating. As you see, I didn't declare any function or method name, this is simply an example to showcase as of how they mostly write code. My partner prefers the first one, I prefer the second one, and since we're only 2 seniors, I turned to reddit for help. But I mostly agree with you, though I'd say max ~5 lines instead of 1. 
Not if you crop the image so it fits! There's also CSS ways of doing this. img { width: 75px; height: auto; } put that in a div where div { width: 75px; height: 75px; overflow:hidden; } the image will never go above 75px, keeping the height. Problem is it won't be square, so the div makes sure it's a square. I'm sure there's a more elegant solution but this should work. 
I'll simplify the debate then: Yes, PHP built in functions are good for unidimensional arrays of primitive types. But to compares multidimensional arrays, or object arrays, this becomes quickly complex. array_diff has one status by array item: different, or not. ArrayComparator has the following concepts: - added items - removed items - modified items (i.e., 2 objects represent the same "identity" but have different values) You cannot have an equivalent only by calling array_diff (or associated) once or twice. edit: and added/removed items are not only resolved by array keys! Not the same as array_diff_key
I like the idea of what you're doing with this class. Nicoon is right that you can get this functionality with php functions, but why rewrite the plumbing every time when you can have it in a composer repo. 
first thing that came to my mind too :)
[learn how to keep your code dry](http://en.wikipedia.org/wiki/Don%27t_Repeat_Yourself). Of course, the code is still amazingly useless even after you begin to learn basic core concepts. I don't understand why you think we should rain praise down on you for code like this: echo '&lt;br /&gt;&lt;br /&gt;'; echo '&lt;table&gt;'; echo '&lt;tr&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;/tr&gt;'; echo '&lt;tr&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;/tr&gt;'; echo '&lt;tr&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;td&gt;'; $code = imgurCode(); echo '&lt;a href="http://i.imgur.com/'.$code.'.jpg" rel="lightbox" title="'.$code.'"&gt;&lt;img src="http://i.imgur.com/'.$code.'.jpg" width="150" height="150"&gt;&lt;/a&gt;'; echo '&lt;/td&gt;'; echo '&lt;/tr&gt;'; echo '&lt;/table&gt;'; It's terrible on so many levels. It uses echo all over instead of a simple php template. It uses tables as a layout tool. It uses line breaks instead of margins. You don't even try to maintain image aspect ratios so they distort and look awful. What should be a simple pair of loops that output some divs with anchors spanning 1/3 of the actual code size turns in to an ungodly mess. Not to mention the methodology you use to select images is bad in the first place, and may produce images that simply don't exist. It's even a bigger pile of crap once you realise that imageur [exposes an entire API](http://api.imgur.com/) that [can already give you random images](http://api.imgur.com/endpoints/gallery#gallery-random) which you either didn't bother to look for, or was too complicated for you to understand.
Site is down
I've been messing around with Blade in Laravel 4 and I like it, kind of unnecessary to the whole process but {{ }} is faster than &lt;?php ?&gt; in terms of coding obviously a templating engine will inevitably cause some slight overhead whether it will actually impact anything noticeably is another story..
my vote is for Pagodabox.com if scalability is a concern. There is a bit of a learning curve getting up and running, but I love it.
Must double-space like a high-school essay men, we can't be authors like the rest of the world!
I love how composer has enabled the community to create and share small, useful packages like this. I don't think a package like this would have ever made its way into PEAR. So Thanks, PHP community!
Go with the guy who promises (and signs a paper supporting that promise) to write clean code and to comment it as you expect him to. And remind him about that promise on a weekly basis. My colleague did that with an intern we had a couple years ago. He was really smart, really gifted for thinking through some annoyingly hard problems, but had never learnt to write clean and commented code. We explained him it was a flaw, and he agreed to try his best to improve. And he really did...
I'll take json_encode/decode over that any day of the week.
I can't stand phpDocumentor. Total garbage.
It's more like the name of it rather than its functionality.
Dude, you need to make this a lot shorter and clean it up. Trying to help, but it's just too much and too difficult to follow without it being formatted correctly at the least. EDIT: Been a while since I've used Php... it looks like you have application, business, and presentation logic all on the same page... Please tell me your Dbconnect class isn't using mysql_ functions... EDIT2: Okay, not mysql_ functions, but you aren't using prepared statement correctly. I believe you're still at risk for sql injection with how you're using them. Hopefully someone else chimes in with this, like I said, been a while since I've used Php... especially without a framework.
pdo. i not really sure how to clean it up. i'm a total noob when it comes to php. front end guy by trade - just learning/self taught with php
2nd guy by far. If you need to comment a ton, you're doing something wrong. 
Horrible. * use mt_rand instead of rand * in order to use response headers properly you have to scan each one since they're not obligated to be returned in any particular order * what the hell are you doing using content-length for that in the first place? * code is utter garbage simply due to the fact that you're guessing if an image will exist or not. You can't know if it will stay in the loop for 1 second or a full minute. * how you format code is up to you, but ffs pick a style and **stick with it**. I really hope nobody takes what you've done as an example of how to write software.
Totally different use case, but okay...
That is the point in the project where you feel like Samuel Jackson. You'll come back to see it full of bugs and feel like Mr Bean. Then you'll fix them all, and be back to kicking some motherfucking ass. And continue.
You may want to look into using a framework. There shouldn't be this much php and html together. You want your application/business logic separate from the markup. Like I said as well, your pdo statement still looks vulnerable to sql injection. You don't put user input in the middle of the statement, you bind it to the key.
Even before i ducked out of the office, I had closed five minor bugs. Kickin' some motherfuckin' ass.
I think this submission would be better off at /r/phphelp
thanks for the advice. i'll post it over there
do you have any good rec's for a php framework?
Matt's site: http://www.mwop.net/ is pretty helpful and has lots of insight and tutorials. Diving into source with a debugger is helpful as well.
how easy is it to grow with those guys, and if i went with something like Yii would i be able to grow with it or would i have to switch to something better?
Just FYI, quickly looking some info up, you are DEFINITELY vulnerable to sql injection. You need to bind the parameters to a key in the sql statement. Concatenating like you did is definitely wrong.
I spent years developing ZF1 apps and struggled with the documentation. Tried ZF2 and didn't see any real improvements in the approach nor the documentation. Plus Zend Studio is a slow, ugly, bloated piece of shit. Went with Symfony2 and haven't looked back. Love it. 
If there is one specific piece of advice I would give to someone starting to learn ZF2, it would be this: learn everything you can about the service locator pattern, dependency injection and inversion of control. And then apply what you learned to writing your ZF2 apps, using ZF2's particular implementations of those principles.
That's great and all, but 24 hours really isn't enough time for proper testing and quality control. Don't be shocked if this app is full of glaring security issues. Hopefully people respect the fact that the app is for humanitarian purposes and don't attempt to assault it.
Also this.
 $outputter = new Zend\ZF2\IO\Output\Echoer($reply); echo $outputter-&gt;output();
Pretty pointless to use if you ask me. 
You're very right. I had "array" stuck in my head because of $items[$key] I forgot to remember that it resolved to an object rather than being a mysql array result. 
You should attempt to create a filter for dick pictures. I had 2 pop up. [My reaction](http://i.imgur.com/tTc9cKQ.gif)
Sounds tricky. Could you install an instance of symfony within Zend and then use htaccess to route newly rewritten code to symfony. Use custom php.ini to set different php version for sy font directory. Related: http://vimeo.com/47849625
Actually, the first example is wrong. it's only iterating if there's more than 2 items. Most people didn't even catch it, it's probably because of the messy style. I didn't do it on purpose but I didn't catch it when I read it again before submitting. 
Well, $items is a collection of items. It just happened that in the DB guy named the column "item" instead of "name", which would be more logic. The fact that you thought I had control over the DB makes me think that you're actually the Asperger-nazi whatever you said. Still, it wasn't even the original question. I didn't ask "Hey, how would you write this". Dunno why you're so on guard, no internet points to win here. Thanks for your input anyways, I guess. 
My current project is actually to rewrite an app in production. It's hard man. It's going to take us at least 2 years. We chose to do the separate server with newer PHP version - since the base of the app has been hacked on from the beginning. For examples - no routes management at all.. It's still all .php files. Eye-gouging stuff. no MVC at all. PHP 5.1 shit. Why we decided to do it: At some point, we had to cut. The fact that the first programmer didn't choose to go with a Framework meant that, we had a lot of missing stuff. Not only that, but no vision of how the project would grow. The JS itself is almost 10mb compressed and minified and it's always loading for every page - even if you don't need it.. but hey, that's the front-end part. The backend is similar, every library is loaded with a bunch of require_once and.. wow it's a mess. Just talking about it makes my head hurt. Oh, and, the programmer was French so every method, functions, vars, column name is in ... yes, French! Fuck me right? Here's what I do step by step (We use Laravel4) - v2: Rewrite the module's model - v2: Create import scripts. - v2: Rewrite the controller + unit testing - v1: Rewrite the ajax calls to point to v2. - v1: when no one is using the system, commit the changes &lt;-- hardest part, the workshop is working 24/7 - v2: do the import - v2: run one last PHPunit test to make sure shit is working - v1: manual test of the rewritten ajax, just to make sure it works (no unit testing possible here) - Rinse and repeat Of course, everything is tested locally first. When every module's API will be rewritten, we then go to the next step, which is recode everything front-end related. Hopefully my suggestion of using bootstrap+angular will pass, but I still have to make a case for it. Anyways, good luck man. 
"App" is the wrong word. It's a Drupal site. Any security issues that are there would be the ones available in the current Drupal 7 release. The functionality of the site is off-the-shelf. Minimal custom work. It's all nodes and [Views](https://drupal.org/project/views).
Don't like either of them but if I had to pick, the second one. What's the random double/quadruple hyphens all over the place?
There is no such thing as good code with shitty comments either. I have never seen an excellent programmer write shitty comments like many of the people here seem to think are OK. I delete that shit when I'm fixing things in those methods. GRRR.
Clean code requires almost no inline comments. I probably write an inline comment 1 out of 1000 lines of code myself. My code tells a story, inline comments are lame except in very few cases. Well placed white space and sensible names say it all.
Yes, I wrote whatever came to me using an existing DB schema that I had open. 
How soon are you looking to get started on something? Starting a new job next week so all my projects are on hold.
You might get a better response if you show off some of your previous designs. Design is sort of like programming in that a lot of people claim they're good programmers, but few actually live up to the claim.
Cool site but way slow loading times on images... maybe its just me but just a heads up! :)
Good deal - you'd be amazed how many people I run in to who claim to be designers that haven't even mastered basic color theory. This stuff shows decent color usage, typeface choices, and overall good design sense. Not a lot of UX-in-action stuff to look at, but free is free. I'd be surprised if someone doesn't take you up on your offer.
Hi, we're always looking for new contributors for our project called [Bolt](http://bolt.cm). While I think the current state of our UI isn't too shabby, we're constantly looking to gradually improve it. Also, we could use some more themes. Feel free to get in touch, if you have questions!
Sending you a PM about my projects. :)
Tip #1 for using ZendFramework2- use Symfony2 instead.
Thank you, good idea that would allow to reuse the comparator. I'll implement that. My use case was: I had 2 arrays of Doctrine entities: the first one was a list of persisted entities, the second a in-memory list result of a form submit. I needed to compare them to update the first array and persist the modifications. The comparison was complex since objects are considered having the same identity if a specific attribute was the same (association to another object). So if 2 objects have the same identity, I need to compare all their properties to check for modifications, including checking recursively through associations to other objects (that's a tree structure). That allowed me to write cleaner code: the controller parses the form submit, but doesn't update the persisted entities (that's logic code that belongs to a service). Instead it creates a new list of transient (in-memory) entities. Then, the controller calls a service that will compare the 2 lists and update the persisted entities. This way, the controller does controller stuff (parse form submit into a object structure that the model layer understand), and the service does business stuff (update persisted entities).
I'm building a website designed from scratch for collaborative storywriting (roleplaying). I've found I really need to figure out how to organize the pages and the layout for the user interface, but my design skills suck. Right now, I mostly just have a database, and a rough PHP backend that really needs to be written (and is only 5-10% done anyway). [Here's](https://github.com/Tynach/Unite/tree/dimentions) the source code, released under the EPL. [Here's](https://github.com/Tynach/Unite/blob/dimentions/database/rpsite.md) what I've implemented so far in the database. If you're interested, that is. I just figured I'd chime in, since you offered. I really know nothing about GUI design.
ha, egg on my face then :)
10...10mb download on every page on the front end??? I mean... that makes the site unusable, surely?
Only for the first page load which probably takes a minute, then it's in cache.
Thanks for mentioning [API UX](http://apiux.com)! Let me know if there's any specific topic you'd like us to cover.
Here's Drupal's introduction to working on the project: https://drupal.org/getting-involved-guide Here's the issue queue for mentions of design: https://drupal.org/project/issues?text=design&amp;projects=&amp;status=Open&amp;priorities=All&amp;categories=All Being a designer in the Drupal world can be rewarding; there are few relative to the number of developers, so your work has the potential to be very influential. But it's an opinionated, smart community, and you have to participate and argue for your ideas to get them accepted. 
Because its not? Just calling something a strawman doe not make it so. You are clearly not following the context of the discussion. Indeed, your attempt is an adhominem, attacking me, and by posing the question the way you did, an attempt to insult me. There are are a few other fallacies I could toss your way, but its pointless. My discussion was centered on the assumption of the original question. Without that assumption, the question changes dramatically. While you might think its strawman, it's actually critical. It's the difference between "did you stop hitting your wife?" And "have you been hitting your wife?" But it really doesn't matter, because you haven't said anything. 
And they could use some help :/
Hey OP! I could use your help with something I am working on. It is called chaicode and is a quick prototyping tool among other things. It lets you see your code changes "live" across devices and platforms. I use chaicode to build chaicode as well as use it a lot to test code changes across all devices at once. Collaborative coding is coming up next. You can check it out here: [chaicode](https://github.com/zeusdeux/chaicode)
I had to read that three times to understand it. Please, for the love of muffins, use words and maybe even sentences.
Bitch please. I'll share mine. * Legacy code (dating back to early 2000) * As with your French loving friends; I'm in the same boat but with German usage * Everything uses the prefix str/int/obj, even when lying. A variable may say int, but actually it is a string with a numeric value. Oh, and somehow for floats they didn't use it, but every array starts with arr. * Not only it was a typical PHP only at first, but they also slapped 3 different frameworks on top of it; each with a partial implementation of something. * They have a sort of price calculator for items they store, which has upwards to 100 classes of dependency; debug that my friend. * No code documentation; but I'm 100% sure your not surprised on that. * "We don't need no ORM", instead there is an abomination of a system that composes queries in a implicit way (events get passed around, strings are concatenated, dynamic and all that) and you have to find where that particular piece of the query is added. With German methods, it won't be an easy task. * The site is so slow, every goddamn page is fully cached; remember each time to add a new parameter to the url, because they didn't heard of development flags. We should have been in for the development of a new version, but surprise surprise; nobody knows the entire functionality of the platform; so we are in for development until they figure out the spec.
i have those moments whenever Unit-Testing gives me some sweet green.
/r/php could use some polish.
Don't try and rewrite it function for function, class for class. 1. If it's working, leave it alone 2. If you're wanting to add a feature, then add a feature. If there are features that you cannot do with ZF, then start a new project with Symfony2 that has all the features of the old app with the new features you want.
You don't need to use Zend Studio to use ZF. I used to use it at work and I agree its extremely slow. I bought my own copy of PHPStorm and have the added bonus of being able to use it at work because of their awesome licensing terms.
Hahaha damn. I feel your pain! Lets drink to that ;)
What a coincidence this has just been posted... "[PHP Version Adoption | LornaJane](http://www.lornajane.net/posts/2013/php-version-adoption)"
You yourself established that there were two uses of the phrase w/i the current context, you chose the specific use that's easiest to attack. It's pretty clear which usage he was using, hence my original point. That doesn't change because you want to be right on the internet.
We're always looking for new people, especially designers, over at the [Elefant CMS](http://www.elefantcms.com/) project. We're currently working on a redesign of our website for our 2.0 launch. We're also looking for UI improvements, new themes, just about everything could use a designer's eye! Our community is small but fairly active and very friendly too :)
My team is about to start a re-write on code from the late 1990s. The project started in ASP using VBScript, then somewhere down the road they decided to start IFraming in PHP pages and passing "session" data back and forth using cURL requests. No frameworks, no comments/documentation, no coding standards, 5 different database libraries all in use, PHP 4, includes on top of includes on top of includes...... The database is worse. good times.
+1 ownCloud needs some serious UX love.
Hahahaha! Wow. I won't complain anymore! 
What?! That looks decent compared to other projects &gt;_&gt;!
I loved Zend Studio up to 5.5. Since Eclipse it has been a hot mess. I have been trying to move from NetBeans to PHPStorm (I used NetBeans to build those ZF1 apps). It seems from the discussion here that I should have a second look at ZF2. After I finish a couple of Symfony projects that is. You have nudged me in the PHPStorm direction.
Which framework you use shouldn't really matter. ZF2 is nice. I still use ZF1 for applications here at work though. PHPStorm tends to not get in my way when coding. It doesn't have awesome support for views, but neither does Zend Studio or any other editor that I know of. Notepad++ and other lightweight editors are great for doing quick edits on files. That aside when I need an IDE (most days for me) PHPStorm wins the battle without even trying. But it's always a case of what you prefer and what helps you work.
You can get the array index in the following way: foreach ($dogs as $index =&gt; $dog) {
Thanks so much for the ideas guys, I will be checking out each one and ill message you if the project sounds like a good fit!
How does getting the array index help me print the # of each item (I would like them to start with 1) next to each item? Trying to understand...
I had the foreach in there and I can make it print each item but not with the numbers next to them...Ugh. I know I must be missing something very straightforward. :-)
If I've understood your question correct, this is what you're looking for: &lt;?php session_start(); ?&gt; &lt;html&gt;&lt;body&gt; &lt;?php if (isset($_REQUEST['dogs']) &amp;&amp; is_array($_REQUEST['dogs'])) { $questions = $_REQUEST['dogs']; foreach ($dogs as $index =&gt; $dog) { echo '&lt;br&gt;Dog ' . ($index+1) . ' ' . $dog; } } ?&gt;
Not exactly sure if I understand, what you're trying to do, but why not: foreach ($dogs as $index =&gt; $dog) print '&lt;br/&gt;DOG ' . ($index + 1) . ' ' . $dog; The array starts at zero, incrementing by one, so if you add 1 to the array index, you get the number of your item.
**THAT'S IT!**
Thank you! 
You're right, I just adjusted the relevant code. The code in the submission could use several more changes, like escaping output from the _POST variable (read: [XSS](https://en.wikipedia.org/wiki/Cross-site_scripting)) and outputing error messages like a previous poster mentioned.
A lot of really OLD sources, and many mentions of PHP4 make me question the relevance of this article.
register globals
[PyroCMS](http://pyrocms.com) always welcomes help with UI/UX work, or contributions of any kind. Starting in the Widgets and Navigation areas especially would be interesting.
Thanks for this comment, I am mostly a hobby php'er and have always used CI.. I have no idea what or why I would use IoC or Facades.. at first I thought if I couldn't learn them there's no use to trying to use a new framework but now I feel a little more confident that if I do try using laravel that I won't have a initial fatal flaw of not knowing IoC Facades etc..
If you're just looking to tinker, I've got a project you can play with. 
I didn't say it has a bad UI.
Thanks for the feedback. We've done some more work on the website and hopefully it is a bit easier to understand now. :)
My favorite video related to legacy application modernization: http://vimeo.com/47849625
Been playing around with [Laravel 4](http://laravel.com/) lately, and to me it really feels like a nice intuitive and non-bloated framework. It's also pretty loosely coupled, so you can replace certain components if necessary.
I'd ask my supervisor if I could go if it wasn't less than a month away. 
Laravel 4, Symfony, CodeIgniter, lithium (for mongodb) err.. CakePHP (not recommended)
Nitpicking ... you might want to make the if statement: if (!empty($_REQUEST['dogs']) &amp;&amp; is_array($_REQUEST['dogs'])) { The !empty checks to see if it isset AND to make sure that there is something in it. Slightly more correct. No point in assigning an empty array into a variable and then trying to loop through it if it doesn't need to.
Also just picked up Laravel. I'm in love :) Beside that, I've used some Yii, which is also great, but feels more bloated.
I don't only want to make blogs, I also need just websites without blog content, backend interfaces, portfolios, etc. I don't want to be dependant on patches all the time to prevent vulnerabilities and I don't need the whole blog-thing when I'm not doing blogs.
Pick laravel.
The "best tool for the job" philosophy? You and your logic - it's not welcome here. (kidding) Exactly why I often find myself using vi.
There is often more than one bundle to accomplish something. Oftentimes it's hard to tell right away which one should be used or which is still under active development or completely unstable. Additionally, many bundle devs haven't gotten around to tagging a stable version, so you're stuck pointing at a specific commit or the dreaded `dev-master` in your composer.json file. These are small issues to me, but they are drawbacks nonetheless.
This looks good, I'll have to keep it in mind for my next project.
Comments should explain what the author was thinking. Here's a sample of code from a previous developer. I want to stab people every time that I have to read or debug his code. Every line is commented, but the comments add no value. The variable names are overly generic, there are way too many blank lines, and the real WTF-ery is always uncommented. These comments miss the forest for the trees. // return trackers $return = $trackers; } } else { // return false $return = false; } } else { // return already assigned trackers $return = $this-&gt;trackers; } // return our value return $return; }
CakePHP is good for CMS development, if you set your database with the correct key between tables you can create CRUD that has all the connections already in a single command, so all is left for you is to develop what's really needed.
 function max_value_in_array($array) { return max(array_values($array)); } Something like this *should* work if it's not a multidimensional array.
Will there be video recordings? Have fun!
Is it a graphical version of vi? I keep hearing people like it but the only time I really use linux is via ssh and I use nano because it works so much easier for what I have to do with it
nginx + PHP-FPM is a more modern and speedy combination.
Nope, plain old text. I also use nano but it isn't installed on all of the servers I use. But you can always count on vi being there.
Yea this has never really been a concern for me. Though looking back there has been at least one time where this has bit me - I spent several hours working on integrating a certain module that ended up being broken in the end and couldn't work, had to find a different one in the end.
if you pick a framework you're still dependant on patches to prevent vulnerabilities and frankly: wordpress is usualyl really fast in patching, the recent patches where also all very special vulnurabilities it has been some time since there was a major issue, wordpress has a great Timetomarket for all smaller projects even if they dont seem blog related at first.
this was never for dogs i just neglected to clean that bit up in my attempt to generic-ize it. It was questions and answers
my personal advice: use something you know also if you are going to create your OWN framework ... then do that, but dont look at the other frameworks than, either use them or make your own. if you are not building high volume sites with more than 500k daily visits then theres no reason vs zend, even if it is a bit bloated and slower than for instance Laravel, still usually your stronges enemy in the beginning is time to market and not code performance. i use my own frame work for all small projects (and by small i mean team size of 1 or 2 people) for all bigger projects i chose the framework for which the team has the most shared experience, in the end it doesnt really matter which frame work you use as long as you know how to work with CDNs and caching in general + writing good queries, those are usually the biggest bottlenecks that could get bad. working around bad code performance is usually cheaper than one might expect, working around database bottlenecks or bandwith bottlenecks is more complicated.
so ive started with setting up a $tries and $n variable followed by a while loop. im just not sure how to check for like heads in a row etc.
Thanks. : ) I'm pushing for Laravel 4 or CI for the rewrite. Another dev is pushing for Drupal. Thankfully we'll be in much better shape regardless of what we end up choosing.
sorry 1 last question, I have: function coinFlip(){ $coin = rand(1,2); return $coin; } function flipSession($numHeads){ if(coinFlip()) } in the if statement, can I call the coinFlip() function as a parameter? I actually have this now: function flipSession($numHeads){ $heads = 0; $tries = 0; while($heads &lt; $numHeads){ $tries++; coinFlip(); if($coin == 1){ $heads++; } } echo "1 Head: " . $tries . "tries."; } flipSession(1); 
You aren't passing $coin as a ref val or setting it equal to the return of coinFlip(); just change out your if statement to be if(coinFlip()){$heads++;}
okay cool thanks
Protip: WordPress is only a blog if you want it to be a blog. Pages and Posts are essentially the same thing except one is hierarchical and the other is based on time. In the database they are both in the same table. Any code you roll on your own is going to be much more vulnerable than a properly maintained WordPress site.
Protip: WordPress is terrible. It's slow, bloated and your level of security is no greater than if you made something yourself correctly (as OP would most likely do). Edit: and just FYI, I have been doing WordPress development professionally for the past few years but am moving away because of the sheer number of great (and far superior) alternatives which exist now. It really isn't worth the effort anymore.
Works okay on desktop. Initial loading is a bitch, good thing it's in a local environment. Every changes to the javascripts takes a full minute to compress and minify. On an ipad, it's simply unusable. The javascripts is just too heavy for the device. 
Why not CakePHP?
It's slow, bloated and there are numerous better frameworks you can use. Laravel4 and Symfony2 in particular.
Which alternatives are you thinking of moving to? Can you name any major security issues that have popped up related to the WordPress core over the last two years? Are there any specific aspects of WordPress that you think are responsible for it being bloated?
Just finished a Laravel project and back to a WordPress project this week. Oh, God, I so miss the simplicity of Laravel. What you can do in that framework in a few lines, takes pages of code in WordPress - much of it copy/paste from other files. Routeing and MVC in Laravel just involves half a dozen lines of code to do what 200 lines of WP can do. Oh, I've gone off WP :-(
WordPress is great if you want a WordPress site. If you want to mould it to the shape of anything else, then you are in a for some long nights.
Directus is fantastic in its organisation and structure. It's probably the CMS/F that I am most excited about. I have also turned to building my own platform(s) using the Laravel4 framework. http://www.cvedetails.com/vulnerability-list/vendor_id-2337/product_id-4096/ WordPress is no longer a blogging platform. It is trying to be everything for everyone, built off a system originally coded for PHP4 (and later upgraded). Because of its legacy, none of its code structure really lends itself to being clean and maintainable.
*Nights* is an understatement.
"One bite at a time". I've been revising and modernizing a web based game for over a *decade*. Code that began in PHP3 days. We've maintained a working, running version the entire time, and (for the most part) stayed in a single branch of version control too. Start with things that are broken. When a fix is required, commit to making sure that the new code that replaces the old/broken code is written to modern standards. Functions get replaced with static methods at first if needed. Then you can recode your app to create a reasonable object. Now you migrate from a static method to a collection of correct interfaces to that object. In your "spare time" convert the code base to a coding standard. Its great to do when you can't think much and just wanna kill some time. Then you can start looking at things like migrating bits to use a different framework as well. That is a little harder, but if you aren't changing which database you are using, as long as each can connect correctly, you "can" mix the two. Its going to be bumpy in the transition. Eventually, you'll get a collection of objects, classes, a clean coding standard, a defined interface to a framework, and then you can get *really* nice and start adding tests and refactoring down fat classes. (It is important to note that if you follow test-driven-design, tests would have been much sooner than the order I have given here.) And poof! You keep a functional app throughout, you improve the code over iterations, and you get to a good ending position. Don't be afraid to re-evaluate your solutions as you go based on the real-world impact you discover. You can call that "Agile" if you want, but I'd call it being realistic in this situation. ;)
ZF2 typically requires that you have a background in MVC application development. Not saying you don't, but if you have significant experience doing so, you should just *sort* of get it. The biggest thing that throws people off is the wide use of the service manager. The configuration handles the factories of the various objects. I'd recommend maybe taking a look at this [example application](https://github.com/EvanDotPro/EdpCardsClient) that EvanDotPro (one of the primary ZF2 developers) and I have put together. It actually occurs to me that he refactored it into a module itself, so looking at [mine](https://github.com/TheFrozenFire/CardsAgainstHumanity) directly will probably help more. It doesn't cover all of the best practises, but it is a good example of a working application.
On my github I have put up my ZF2 blog. I set up a few modules to demo module management, routing and stuff like that. Went to a workshop with Evan a few months back and he (+ a british guy) showed me how the framework was structured. https://github.com/svenanders/zf2blog
Your code shows problem solving skills, but it doesn't display decent architecture. I don't agree with every way you chose to solve a given problem, but you did solve the problems which speaks favorably of your ability to cross the finish line. The good news is problem solving skills are important, the bad news is that if you write a whole application like that you'll be in trouble. You need to start focusing on proper architecture if you want to move forward. While you can write large applications as collections of loose functions it's generally accepted that it's not the best way to go about things. I'm going to go out on a limb and say that Wordpress is probably partially to blame for this since it's one of the worst examples of application architecture available despite its popularity.
1) STOP USING WINDOWS 2) STOP USING WINDOWS 3) lrn2unix The combination of programming ability and knowing how to admin and use linux(unix) for business purposes will make you employable faster than you can say 'Holy recruiters, batman!' Aside from that basic concern, I would suggest avoiding abbreviation in your code like the plague. $k =&gt; $v should never happen, it should be $key =&gt; $value ($thing_key =&gt; $thing_value is even better), you can spend the extra key strokes, and if follows the principle of explicit code. I'd also suggest moving away from WordPress as soon as you can and learning how to homebrew an MVC, then find one that you like and learn to use a proper framework.
Hey! Awesome reply, thank you. I guess I should make a better example. I just sorta threw the first program together specifically for dailyprogrammer. I usually don't have functions free-floating like that, I guess I just wanted to keep as much of the daily-challenge-specific code in each challenge file as I could. In hindsight, it was delivered as a display of problem-solving skills as opposed to an example of proper program architecture. I will have to make note of that for when the time comes to share some of this stuff with potential employers. I didn't get into WordPress or any other CMS until after I barfed out 12k+ lines of code through Notepad++ to learn PHP/MVC &amp; MySQL by making a dispatch system. So I'm hoping I can redeem myself with some examples of what I believe is expected in terms of proper program structure. I've read the stories about the WP architecture so I didn't go to it to learn. I am a big fan of MVC'ish approaches however I don't have any good examples of me implimenting it :( Once I learn to post code on reddit correctly I'll try to show how I implemented MVC in the above mentioned dispatch system. Thanks again! +1
also a few resources on [Bootsnip](http://bootsnipp.com/) , kickstrap and http://foundation.zurb.com would be great .. 
1) :O 2) :O :O 3) :) I do have Ubuntu dual boot! However I haven't set up LAMP or PHPStorm yet, you are sooo right I shouldn't be in windows. I'm a baddy and I should be ashamed :( btw what gave away my windows? Thanks for the notes about $k =&gt; $v, I will be making those more descriptive going forward. I should have known better, I was actually looking at them earlier today wondering how/if I should change em up. re: Wordpress/MVC Oh yes, totally, I want to learn how to use the real tools of PHP, I've learned how to make rookie tools, but I know there are a lot more mature tools out there built by people with more experience than me! I just need to learn how/which/when. As mentioned in my other reply I did make an MVC from scratch, with just notepad++ and google, I specifically avoided asking for help almost entirely. (stackoverflow ftw) Built my own database and table model classes w/ PDO wrapper &amp; user system and changed it up as I saw inefficiencies. ( example: user access was originally a 10 bit string where each bit granted different access, I changed the whole thing to an array when I figured out it was a lot easier to follow o.O ) So yeah, swap to Ubuntu, set up my new home... set up a Composer project and start building that dispatch system again from scratch using 3rd party open source tools? Thanks for your time! and for yelling at me :P +1 tyty
Notepad++ gave away windows!! 
I went ahead and gist'd it. https://gist.github.com/Ron916/a21f08b89fbb131eed41 This is a basic example of how my first MVC attempt came out, I'm sure it's not the best way, but it's how it ended up and it did still have a separation between controllers, business logic and view logic? I'd appreciate a comment on how I used the $tablearray, I imagine all that could be kept inside the DBUsers class and manipulated without dragging it into the controller. :)
Because it performs terribly and personally I don't like the design of it.
Blast! I would have gotten away with it if it weren't for those kids and their dog!!
If you don't like it, use the downvote button. Never fails to amaze me when people think they have the right to tell other people how to use Reddit. The downvote button is there for a reason. 
Did Junkie get downvoted? Was it for post content or his views on Windows or Wordpress :P Don't leave us in the dark! And on another note, I've done IT for years so I can admin, I just need to learn to do it from the command line. Thanks again.
Yes, especially since 99% it ends with Laravel circlejerk. 1) Either Laravel is really really good, and people posting these questions don't bother taking a quick look around before posting same thing over and over again. 2) Or this is great conspiracy for promoting laravel (just kidding)
So... what framework should I use? EDIT: Lesson learned. Don't makes jokes in /r/PHP.
Hm, servicefactory seems to be a registry pattern. I tend to stay away from these as much as possible since they generally wind up globalizing things too much. Instead, consider building your relationships through composition rather than a class which is inherited by a bunch of stuff that pulls things out of the global scope. Good OO tends to rely on how you build your object hierarchies and set up your dependencies. This is known as [object composition](http://en.wikipedia.org/wiki/Object_composition). For example, instead of DBUsers extending something which grants it access to a bunch of global dependencies, pass constructed dependencies to DBUsers as attributes. The reason we do this is for [inversion of control](http://en.wikipedia.org/wiki/Inversion_of_control), also known as [decoupling](http://en.wikipedia.org/wiki/Coupling_\(computer_programming\)). DBUsers looks like it's trying to be a model and if this is the case it's the wrong way to go about it. The reason it's the wrong way to go about it is that you'll wind up continually doing all the boilerplate code over and over since you're not designing anything reusable. Why hardcode methods such as getTablesArray (which I think may also be inappropriately named) when other models will likely wind up doing similar things? If you do want to do your own models, it's a good idea to begin learning how to [design by contract](https://en.wikipedia.org/wiki/Design_by_contract), since you will have many models which will expect similar functionality. A good model layer can be a bit complicated, which is why many MVC frameworks tend to opt for a mature [ORM](http://en.wikipedia.org/wiki/Object-relational_mapping) which is generally worked in to the framework via a replaceable [adapter](http://en.wikipedia.org/wiki/Adapter_pattern). The adapter is usually used as an intermediary level of abstraction so that the framework is not necessarily tied to one ORM. Not that there's anything wrong with you wanting to try to provide the model layer yourself, but it tends to wind up as a massive job all on its own if you want models which are capable of common object associations (has one, has many, has many through, etc) typically provided by ORMs. I know I've given you a lot to chew on, but this is the sort of stuff I'm talking about when I say "proper architecture". All of the stuff you're trying to do here has been done before. It might pay for you to study frameworks like Zend Framework or Symphony to see how they solved certain problems to gain more insight.
Maybe a request for creating a Wiki page in the sub-reddit?
If you don't want to read questions regarding the choice of framework, stop clicking those links. Really, it is as simple as that. 
Yes, because what it says about the community is that we have nothing better to do than continually talk about our tools rather than use them to do something interesting. I'm all for talking about new framework features when they're new, but rehashing the same discussions 50 times a week seems pointless.
That's certainly one way to look at it. Another way would be for those questions to go to an environment which is geared towards helping the new guy make these sorts of decisions, such as /r/phphelp.
Subreddits aren't democracies, I don't know where you get that illusion from. They often have rules for posting, and over time those rules may be amended.
Wasn't looking for praises for my code... Anyway, thanks for your comments.
i don't see a problem here, if we had more interesting topics, they would get up voted and therefore push the framework questions down. that's how the site works. it's not like those questions are hurting anybody. just ignore them
[Clearly, Laravel](https://www.google.co.nz/search?q=laravel+site%3Areddit.com%2Fr%2FPHP%2F&amp;ie=utf-8&amp;oe=utf-8&amp;aq=t&amp;rls=org.mozilla:en-US:official&amp;client=firefox-a).
I think all the framework questions are drowning out any interesting content and people keep upvoting them all the time. Let's be honest, if I visit my customised front page of reddit most of the time I won't see any 'interesting' links from r/PHP because they simply won't reach more than 10+ upvotes. These r/PHP links have to compete with links from my other favourite subreddits. The framework ones get bumped up to 20+ so I sometimes see those amongst all the other stuff. No-one else will see any interesting links from r/PHP either because the framework questions are drowning everything else out so they never reach anyone else's front page either.
&gt; Is there nothing else interesting to talk about with PHP? Obviously not. &gt; I say you make a one time poll. Because people always want to hear weeks, months or years old advice, not current, obviously...
The problem with that is actually leading them to r/phphelp. Reddit isn't exactly well-designed for that purpose. You have information in the sidebar, but people rarely see it. 
Because every piece of his advice is nitpicking or bullshit.
Best bet with php is using Curl. Have a look into something like [phantmos js](http://phantomjs.org/) or other headless browser implementations 
I just saw two interesting ones on my front page today. One on SQL injection, one on Symfony2 performance. Both quite good quality links. In fact, I can honestly say I have only ever seen two posts asking for such advice on the front page I visit daily. And one of those wasn't even directly asking about frameworks. People just answered as such. And hey, &gt; is there nothing interesting to talk about in PHP? Is this interesting? You could always post something is if you feel the rest of the sub is lacking. The two people I mentioned above certainly did. 
I dunno if any of those can talk over the tor network...
I didn't actually try, but my guess is you can do so. Curl is very configurable, and allows you to set proxies. All you have to do is go through the tor SOCKS socket. Some quick googling gave me this: http://stackoverflow.com/questions/13444738/how-to-use-a-socks-5-proxy-with-curl
You just need to create a connection through the proxy. From there on is just regular scraping. CURL is your friend: http://www.php.net/manual/en/book.curl.php (Didn't actually try, but I'm pretty confident it's doable. If not in pure PHP, through some OS trick.)
brainfuck_main method in the plugin is a bit of hell. 250+ lines in one method is just a no no. and it's imperitive ugliness. I'd learn to abstract bits and pieces to other methods of that out to shrink down that method. * Will make the method easier to read * Will give you smaller methods, which will be easier to unit test. * Will make parts of your code more reusable. Also, add phpdoc comments and unit tests. Adding these is kind of pedantic for such small projects, but when showing off code to prospective employers it leaves quite an impression.
 curl_setopt($ch, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5); curl_setopt($ch, CURLOPT_PROXY, 'TOR_IP:TOR_PORT'); Then scrape it exactly like you would any other site.
Mine is smaller: $g=$_GET;$c=@$g['c']?:'Home'; if(!@include"c/$c.php")die('fail'); $m=method_exists($c,$m=@$g['m'])?$m:'index'; $o=new$c;$o-&gt;$m($g);
Youporn.com is in symfony2. If it can handle that I think it can handle most projects your boss can throw at it
Sarcastic...jokes.....Can't..hold.back....much.longer.....
I've used this one already. Youporn.com, while much bigger and with much higher visitation rates, kinda only has its limited functions (provide porn, collect ads revenue). I need stuff that can cover accountability, human resources, projects, purchases... lots of stuff with lots of business rules. My boss seems to think ZF2 is more suitable for stuff like that.
"Hey boss, not that I would know or anything, but apparently there's this big porn site that runs on Symfony2. I think we should use it."
http://www.php.net/manual/en/userlandnaming.rules.php
Neither framework comes with anything out of the box that does any of that stuff, you're going to have to program it regardless. You might as well pick the framework that is going to allow you to do this in the best timeframe while providing you maximum flexibility. Sounds like your boss saw the words enterprise on the zend site and figured it was better.
Might be worth noting that Symfony just released their first LTS, 2.3.0, see [this blog post](http://symfony.com/blog/symfony-2-3-0-the-first-lts-is-now-available) for details. Also: I prefer ZF2, but to each his own. I'd recommend getting familiar with it just to stretch yourself as a developer, it incorporates some really cool implementations of some great programming patterns.
Use what? The pornsite?
You don't see major differences because there aren't any, they're both well suited for same niche - enterprise level projects. There are obviously many smaller differences (configuration, form component architecture, DIC implementation, Request/Response stack, view handling), but at the end of the day there's nothing that you can do with one and can't with another, so if you want to make the best choice possible you just have to try both and see which idioms seem more relatable. As for examples - we develop big projects for a living: from learning platform startups to bank CRMs, Symfony2 handles them all :)
I've have something similar, except I use Composer to pull in any dependencies I need for that particular project. Then, I have a simple bootstrap that links everything together. That bootstrap more or less is "my framework". I've found myself focusing less on the perfection of the framework (which is normally just routing and linking things together), and more focused on writing good, decoupled, tested apps.
I don't believe so. You'll probably have to call [ffmpeg](http://www.ffmpeg.org/), or something like that.
If you're serious about testing for injection, then you really should familiarize yourself with SQLMap: * http://sqlmap.org/ * https://github.com/sqlmapproject/sqlmap * https://www.owasp.org/index.php/Automated_Audit_using_SQLMap
I've been using PHP since about the time of 5.1, but I've never known that "sizeof" existed. 
...you get overtime? you lucky fuck.
_See also: why do we have both `implode()` and `join()`_ (I've been using since 4.3 and just learned of `join()` this year)
Well, SensioLabs (the creators of Symfomy) also have a [support offer](http://sensiolabs.com/en/support/sensiolabs_support.html) of their own.
Why not take this as an opportunity to learn ZF2? I don't understand what's the big deal is, take the positive out of this instead of fighting a useless fight. I would question the field you are in because to me this is the same as 'I drove Audi R8 for last 5 years but now they want to to drive Porche 911 Turbo WAH WAH'. Learn for free, expand your skill set and have fun. One tricky pony != good developer.
Tell him you're convinced your pay grade isn't suitable for ZF2-sized projects.
Sensio (the company behind Symfony, much like Zend behind ZF) [also offers supports](http://sensiolabs.com/en/support/sensiolabs_support.html)  just FYI :)
welcome to php
the ride never ends
Yes, but it would require that you understand the MP3 format and the process behind remixing the files. I'd start with learning [how to decode the data](http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html) first before diving in to encoding. Don't worry, mp3 has been around a long time and there's no shortage of information. All these people who are telling you it's not possible are only doing so because they don't understand how MP3s work, and there's no easy predefined way that does it for them. However, php could be made to perform this function and to say otherwise is bullshit. I hate this community attitude that if something is not easy, it must be impossible. Other language communities aren't like this, why does PHP have to be?
6 figure base salary for 40 hours a week, overtime for any work I do past 40 hours that's billable to a client. Percentage commission on any new projects that bring in, refer, or help land (writing the RFP, etc). Percentage commission on any project over $5K from an existing client that I'm a Project Manager for. Bonuses for completing projects under estimates... And seeing how much my company charges for my time vs how much I get paid, I still sometimes feel like I'm getting screwed.
Does anyone have any advice on dumping a huge set of routes in apache? Is there some limit to where the advantage falls off?
&gt;And seeing how much my company charges for my time vs how much I get paid, I still sometimes feel like I'm getting screwed. I get paid the same $50k no matter how much I work. I put in 350+ hours last month, 40 hours a week for a normal person in May 2013 is something like 140 hours. You aren't getting screwed.
Because of PHP's low barrier to entry. Many PHP devs are not all that experienced, especially compared with devs of other languages, and with little experience comes lots of ignorance. I don't think people are maliciously saying things are impossible-- they just don't realize or know any differently.
I'm not resistant to learning a new technology. I'm resisting switching to a new technology without knowing the impact it'll have on the team's productivity. Any time spent adapting to a different technology that will aggregate little or no value to the project is not a well spent time. Hence the discussion: will switching technologies at this point aggregate any value? Is ZF2 indeed better for larger projects? If so, how? What can I accomplish easier with ZF2 than I would with Symfony2? If I conclude that ZF2 and Symfony2 are both equal means to the same end, why on earth should I add an additional risk factor which is the team's lack of experience with the tool? It's not about learning or becoming a better programmer, I'm thinking about the best for the projects at hand.
Some time ago, the lead programmer in the company did a study for a big project and decided ZF1 was the best suited framework for the needs. ZF2 hadn't been released yet, Symfony2 had. We thought about using ZF1 for the new projects, but we figured that using a discontinued technology for new projects didn't make any sense. So he asked us to give him a written analisys, comparing both frameworks (ZF2 and Symfony2).
I completely understand that some people may not have the technical expertise to perform these sorts of things and there's absolutely nothing wrong with that. I just wish they'd realise when they're out of their depth instead of chiming in with misinformation.
Sorry but that's a cop out. You are switching from one widely supported framework to another. From technical perspective that's child play. And once again you fail to see my point. If you are saying 'best for the project at hand', spending few weeks learning about new framework will actually make your engineering team better and smarter. 
Ah, good to know!
I realize that I have it way better than most.. but just because you're getting screwed worse doesn't mean that I'm not. I'm a consultant. Just about every hour that I work, someone else (ie: not my company) is paying for it. So if I put in 350 hours in a month, I would have made roughly $17K in that month. And my boss would have made $26K just from my work by doing nothing but sending an invoice to the client, cutting a check to me, and MAYBE making a few phone calls to make sure the client was happy with the job I was doing. 
I hate to agree with you, because you're being slightly harsh about it ;) but its true. Learning all things is easier than learning one thing (when it comes to programming). It seems counter intuitive, but once you realize the truth in that statement you will become a better programmer. 
So, whenever new projects pop, should I just randomly switch to other widely supported frameworks without knowing what of value (if any) they'll add? Maybe this one with ZF, then Laravel, the other one with Drupal, the next with Ruby on Rails and the one after that with Django? Because, you know, it'll make my engineering team better and smarter. Sorry, but that made no sense to me. Yes, learning new stuff makes people better and smarter. No, adding risk factors just because it's supposed to be easy is not wise. Or are you telling me that previous knowledge of a tool is not an advantage (and that lack thereof is not a risk factor)?
This would convince my boss. But they also use Redis, IIRC.
maybe its a matter of experience, we base a lot of sites on wordpress as content management, and never had long nights at all. it really works nice for us. and we use the "post types" heavily i.e. we have a normal blog on the site and for all other content items we create a post type, and its usually displayed in completely different contest, for instance as help items / help area, or as magazine like content ordered in categories with related posts etc.
I know. I'm a terrible programmer and this was just a quick and dirty solution for something that I believe PHP should have built in. 
It's still going to add development time, which he'd probably avoid if he has the choice.
I'm curious as to why your boss thinks Symfony is not suitable for big projects-both frameworks are perfectly suitable for something like that. Disclaimer: I'm a seasoned ZF developer and I've only dabbled in Symfony.
1. He's not wrong. There are better solutions out there. 2. ZF2 is not one of them. 3. The better solutions are in other languages. If he wants to stick with PHP, Symfony2 most likely is the best solution.
"Let's not try anything new, it adds development time" - Says no good engineer ever. 
Seeing as I set you up, can I have half the points?
Thanks, I was not trying to be harsh I'm just speaking from personal experience and it's frustrating when people in this field don't see the doors infront of them (or refuse to).
That statement: "Learning all things is easier than learning one thing" really is probably the deepest, most profound, and meaningful piece of computer programming advice I have ever received. So many more concepts become clear, when you see how they're implemented in different scenarios, different languages, different frameworks, etc. It all overlaps in a really meaningful way that is worth exploring. And it all becomes easier, with every laugnauge you learn, every framework you familiarize yourself with. Its **not** like starting from scratch everytime, once you get the ball rolling. Everyone always wants to become "really good at X" when they really should be more open to learning a more broad range of computer programming concepts. It gets you to where you want to be faster. It can seem very daunting at first, and I suppose it is, but its worth it. 
You summed up my point really well, that exactly what separates men from the boys in technology field.
It's never really about the framework, it's what you need to do with it. Both frameworks are going to be fine for what you're trying to do, but if you're more comfortable with one, you should use that one because it will make your development go smoother. 
I would recommend to just confrontate your boss and ask for a specific example where ZF2 would be a better choice. If he can't give one, or even think of one then tell him he should not make such a decision if he do not have enough knowledge about it. If you can't talk to him like that, he probably aren't going to be a good boss.
Well played, Mauer.
If they're both roughly equivalent, then go with the one you know. That's not a copout, that's business sense, and I'm miffed by any developer who thinks it's worth their time to invest in a new framework when the general feeling is that they're both equally capable. 
Thank you sir, I was about to run out of the gold. I've been making this point around various programming subreddits for a while, so its nice to see someone appreciate it. It really is true. 
While the frameworks are equally capable the architecture and implementation varies. That's the WHOLE point of trying different things. If client is paying for it business sense does not matter. Also it's not up to developer to worry about the business. You get to learn new stuff while getting paid. Some people would kill for that. There also business sense in getting the most out of your developers, if you want to end up with one trick pony in 5 years and play catch up there will be no 'business' to sense. This is how you evolve as a developer, if you are coming in for a paycheck then do whatever you want.
Yes, a lot of cool things can be done in PHP and people should play with them - a nice example is to make your own ZIP archive function based on the RFC. Sure, there are lots of ways to do it, much faster and maybe even more memory efficient, but the exercise will show you just how much you can really do with some simple functions. However,all this "it's better to do it in a different way" attitude is not necessarily bad. A lot of extensions appeared for this reason - compiled C code will always be much faster than PHP. In 90% of the case the speed is not crucial (think about a web page - 10 ms or 50 ms .. who notices the difference?), but when it comes to heavy processing (audio, images, video) - the difference is usually huge. This is why, although it is possible to do it in PHP, you will realize that in the end it is much more efficient to use an external tool like ffmpeg or sox.
There's a big difference between saying "it may be more efficient to do it this way" and "it's not possible". I don't have a problem with the former, it's the latter that I take issue with.
Zend is the official PHP company. I'd use their framework over anyone else's without even comparing the pros and cons, simply because you know it has the backing of the guys who wrote the PHP core.
I consider that attitude to be unethical. You can grow as a developer without putting your clients at unnecessary risk. 
&gt; sorry, but that's a copout No it's not. It's a valid consideration for an environment you haven't been given enough information to disregard. 
obviously you've never been time boxed where the project has a completion date before you even have the specs.
Of course we are all terrible programmers. No need to feel bad. Technical debt may not be important when a project is shortlived. Hope that is the case here...
If Symfony2 isn't, what makes ZF2 suitable? That's like saying "I'm pretty sure a Ford Escape can't fit my whole family, we'd better buy the Mazda Tribute."
Oh, I completely agree with you, but that's not reality.
not sure why this got down voted, but it's pretty much the best answer if you want to get something done. If you want to do it in php just for the fun of it .. go for it
Probably PHP is not the best for this project. I'd say take a good eye at https://beautiful-soup-4.readthedocs.org/en/latest/ It can parse anything quite easily.
We don't live in a perfect world for that. Unfortunately, sometimes, time and cost constraints dictates what you do. Only a Sith deals in absolutes.
It's too bad ZF2 isn't here yet: http://www.techempower.com/benchmarks/#section=data-r5&amp;l=sg&amp;a=1
I'm still chewing. I've read this like 10 times already, and checked out the wikipedia links you so kindly took the time to add, and have done more than a handful of related google searches so far :O It looks like you're saying that most of what is done in those methods kinda lock it to this specific project so that when I attempt to use them in another project, or attempt to do something similar in the same project, that I have to go through a lot of extra hassle or code copying to make it work. I think I'm understanding that point. Also, re: Code Contracts; Are these a definition of method parameters whereas an interface is a definition of object methods themselves? Actually, don't worry about replying or spending much time in replying, it's getting more and more obvious to me that I need to grind into some frameworks with an emphasis on studying the design patterns of their objects. "The best way to learn is face first" -unknown Also I see another downvote which confuses the hell out of me. I've noticed that programming in general can have 5 points of views on a 1000 different subjects ( I see this within the FIG discussions, among other places ), and I know there's a lot of really smart folk who've been doing it "their way" forever without any problem; I guess I kinda have to accept that there will be dissenters, who may just want to avoid arguing over it for the Nth time. All in good fun I guess :P Thanks again
You boss's opinion has no basis in fact, only in supposition. You will not be able to find the facts you want to find. 
&gt;It looks like you're saying that most of what is done in those methods kinda lock it to this specific project so that when I attempt to use them in another project, or attempt to do something similar in the same project, that I have to go through a lot of extra hassle or code copying to make it work. I think I'm understanding that point. Sort of, I mean this is a concern as you put it, but it's also to do with the project you're using it in. One of the tenets of programming is to work smarter, not harder. This means when you have many things which act very similar it makes more sense to generalize and abstract functionality rather than making it absolute and specific to a circumstance. A contract in code is much like a contract in real life. It is an agreement between two parties to achieve a desired effect. Contractual programming means you code to an interface which is enforced. This means that you're only worried about the messages you're sending an object, and the responses you're receiving. You're not worrying about how the operation is achieved. Another fundamental principle that ties directly to this is the [Open/Closed principle](http://en.wikipedia.org/wiki/Open_Closed_Principle) which states that a given obejct is open to extension (you can change how it achieves a result) but closed to modification (you're not allowed to modify what it expects as inputs or the kind of result it returns, the interface must remain consistent). In real life, if I take my car in to a mechanic, there's a pretty standard process I go through to get it inspected, and to have any broken things fixed. The person taking my order is the interface. I give them my car, and tell them what I want done, and later on they return a fixed car and a bill which I pay. I don't actually have to have any real knowledge of how the car was fixed, because that part is abstracted away by the person who took my order and relays the appropriate commands to the people who need to know them. Objects can operate in a similar fashion. &gt;Also I see another downvote which confuses the hell out of me. A lot of people in this reddit often don't like my rather blunt way of telling them their code is bad. Some of them just arbitrarily downvote me now any time they see a response by me, instead of trying to argue any of the points I make. I'm pretty used to it by now. Most people aren't ruled by their logic, but rather by their emotion.
http://twitto.org/
Bare hyggelig! For the heck of it I reworked the code to how I would have done it: https://gist.github.com/voldern/5717948
This looks just up your alley: http://fixitts.com/2012/06/21/data-scraping-series-2-anonymous-data-scraping-using-curl-and-tor-php-or-linux/
&gt;If your BOSS tells you he wants to try other frameworks or other languages then embrace it instead of being negative about it Yes, because if the project is delayed, I wouldn't be questioned at all. It's not like it's my job to evaluate risks or to help my company grow. I could just point to my boss and say "hey, it's on you, you're the one who told us to switch". I can see that working out well. I don't have any responsabilities. &gt;If his manager is pushing for it time should be obviously adjusted for learning curve. Also yes, because clients love paying for an extra month so the other company's developers can, you know, learn and grow. "I know we said it would take 6 months, but it'll take one extra month. You see, we chose to learn a new technology and figured you'd gladly pay for it. We'll become smarter." Training will be done in training time. Development time should be used to, you know, develop. &gt;How will you know what value frameworks add without trying them? Reading about them and asking people familiar with them what are the selling points and disadvantages. You can even ask people on reddit about it :)
Symfony2 is fine for big projects, but you should be warned that both ZF2 and Symfony2 + Doctrine use A LOT of memory. We use it for parsing a lot of XML requests (40-100 a second) and it really eats up a lot of RAM (512mb+) and we had to start manually flushing doctrine to keep it below 512 too. 
One specific aspect: no MVC. The separation of concerns between views and controllers is unfortunately not there. If you want to change the login screen, for example, you need to override the hard-coded echo statements in wp-login.php that is the entry point for most of the user authentication and registration stuff. You can't just, I dunno, update a template in the theme, or anything simple like that.
Damnit. I just wrote an entire bloody article in reply, and then fricken' Fiewfox crashed. It was half-way uploading 155 photos to Flickr too, which I had spent an hour choosing from 400-odd photos. Sod this, I'm going to bed! But in summary, the reply was yes, and no, and here are two detailed examples of how a project can work as you describe, and how it can turn into a total nightmare. Will have to wait for another day.
You can modify it in the theme all you want. You just need to use the filters and hooks.
ZF2 and SF2 are the same thing by different people. They are for the same level of developer, who are interested in building things in the same sort of way. We've been having some discussions on the PHP-FIG about the possibility of ZF2 and SF2 deprecating the use of certain components in the favor of supporting the other, for example both using the same YAML component, etc. Your boss is just picking random projects and deciding they are "webscale".
Stuck on windows but want a linux server environment? No problem. Install [vagrant](http://www.vagrantup.com/) and [use a predefined box](http://www.vagrantbox.es/) of your choosing. Then it doesn't matter if you're running windows or not. You can even use your own favorite windows editors since it will synchronize folders for you. Easy, free, and no hassle.
You'll enjoy this: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
i agree, there isnt really a framework out there which is really bad base for a project, they are different in time to market, and have slight performance differences, but what can break a project is the coders and their approach, rarely the used framework. as for ZF2 vs Symfony, both are fine, i'd prefer ZF2 out of those 2, just because i am more used to it, but its harder to get into as the documentation of ZF2 is still not as good as it should be.
And thats why your new boss wants to go for ZF2? Just lay out the facts, if he doesn't care either go with it or complain. There are plenty with jobs for developers :)
Youporn
Nah that only supports functions, not classes with methods.
http://www.openwall.com/phpass/ You can bring phpass in via composer as well. https://packagist.org/packages/rych/phpass You can use that with any db backend.
Newbie here... I literally just learned this the other day, so feel free to correct me, but pretty much every reference I looked at told me to just use [PHPass](http://sunnyis.me/blog/secure-passwords/).
Well ... the ride ends when you discover other languages. Hi, I'm Gnascher and I'm a PHP-holic. I was on PHP for about 9 years until I hit rock-bottom. I haven't looked up argument order for needle, haystack in over 3-years. I've been back to PHP a few times since I decided to go DRY, but each time the experience left a bitter taste in my mouth.
perfect, thanks.
Notable projects built with symfony: - Dailymotion - Youporn - TED - phpBB - Drupal Check out [this post](http://fabien.potencier.org/article/65/why-symfony) ... it's somewhat old but has some decent info, also read the comments, on most sites comments aren't worth a shit, but on that post the comments help to argue both sides and give you a good view of what works better for what. The general feeling I got after reading is that both frameworks will generally handle large projects but each has better things on certain aspects (symfony with CLI stuff for example). Best of luck.
...and a hell of a lot more repulsive
[Handling file uploads](http://php.net/manual/en/features.file-upload.php) section of the PHP manual is quite well done.
why not use the PHP 5.5 password compatibility library https://github.com/ircmaxell/password_compat 
Why do people constantly talk about ruby on rails like *it is* the language? 50% of this article is him describing his love for PHP, and the other 50% of it is him describing how he couldn't wrap his head around rails because he's expecting to be as proficient with ruby in one month as he has been with PHP which he has been doing for years. The whole article felt like one giant /facepalm
Just to let you know - your SQL code is extremely insecure. If this is just for you to use, and a trusted handful of individuals, you'll survive. But if this is production code for a public-facing product, stop right now and research MYSQL security. You're basically super vulnerable right now to SQL-injection attacks. FYI.
I completely agree. You can't compare a framework to a language. A framework is an aid to a language like a jig/fixture is to a machinist. It lines things up and allows you to take some calculated shortcuts, but you still have to know the materials you're working with, what drill bits to use, and what speeds to use. &gt;"How could this be? I've given this all my time and effort and I've barely progressed! It's been a month, and I don't feel any closer!". How on Earth could anyone expect to not only understand a framework, but an entire programming language after a month? I had been programming with PHP for 3-4 years before I gave CakePHP a shot, and that took about 3-4 months until I felt confident in my abilities. If he loved PHP why not just use CakePHP? It's extremely similar to ROR, but while not identical it has tons of the same features and speed once you know what you're doing. 
Definitely an old dog/new tricks kind of vibe. My mind imagines the author to be in his 40s
I think this was posted here a few weeks ago: http://phpsadness.com
I agree, although I do concur with others when they advise you not to click. I think the sidebar - by now - is a little outdated and does not reflect the modern /r/php. Improvements could be links to top posts, an FAQ, framework discussions, security best practices, moving to OOP programming etc.
And (hopefully) in a few weeks you can do these things out of the box natively with 5.5!
I've used ZF1 and Symfony 2. Haven't got onto ZF2 yet. What I liked about ZF1 and which will likely translate to ZF2 is it was really easy to learn and it is really modular. You can literally pick and choose what you want. Ie I built my own MVC framework then pulled in components from ZF1 that I needed like the Mail and Date/Timezone libraries and whatever else I needed to get the job done. ZF2 will be even easier in regards to that. Compared to Symfony 2 in a job I worked in for 5+ months. Really difficult to learn. You're forced to do everything the Symfony way which is pretty much a try hard copy of "enterprise" Java. You do everything with their controllers and models and awful forms framework. Really convoluted way of doing everything. Everything is really difficult to customise. Also the framework is slow and chews up a lot of memory. In development it was running like an old grandma on a quad core with 8GB RAM. Seriously if it takes over one second to bootstrap the app and display a 'helloworld' something is wrong. I left that job as I hated fighting with the framework every day. Personally micro frameworks are my style. They just give you the bare bones and you customise it to what you want. Then you're free to pull in other libraries to do the complex stuff if you really need to. That's how life in PHP world should be. None of this enterprise crap bogging everything down with multiple layers and layers of OO patterns like Symfony. No thank you.
When learning, every moment is an "aha" moment. This question is not clear in any way since it all depends on your background. If PHP where your first language you'd be constantly surprised. It it where your first dynamic language there would be other things that would surprise you. If it where your first language used in web development there would be other. e.t.c.
You are better off using the password_compat library. It is built to be compatible with PHP 5.5's password function, so in case of a recode down the road you don't need to go using anything put pure PHP if you are on 5.5.
I only had "Aaarrrgh" moments, as I'd come from a background of languages which have reasonably consistent naming conventions.
I can see this might be useful, but personally I always want my production site to be unambiguously separate from dev. It's so easy to be testing the wrong site otherwise!
I don't understand why people harp on this. Yeah it kind of sucks but does it get in my way for more than 30 seconds a day? No not really.
There is alot of things to get. To me the best moments are the little "I know how to do this" moments when I can do things off of memory instead of looking them up. The most important thing to me is to have a project and refuse to cut corners but try to do things "the right way," the more you learn the better the right way becomes. 1 year in and I still have 'aha' moments every day.
It absolutely does. When you have to rely on the manual to remember things like needle, haystack order and whether there is an underscore and you write lots of code every day, it can actually take up a lot of time. I've been writing PHP for 9 years professionally, and I STILL have to consult the manual for these types of things. That kind of problem needs to be harped on in any language, if you ask me.
&gt;ZF2 is much more modular and flexible than Symfony2 I never said otherwise. I just said I thought Symfony2 was more flexible (as in has more features/resources) and modular than ZF1. 
The author seems to consider that the time investment required to learn a new language is "tools getting in the way"?
I remember the difficulties I had trying to wrap my head around complex HTML tables, then when I moved on to PHP I had similar trouble grasping functions and arrays. The lack of real world examples made me think "that's neat, but what's the point?" Once I was able to *visualize* it, in that writing code was like drawing a picture in my head, and each part of the picture could be pulled out and played with separately, it was like a tidal wave of knowledge hitting me all at once. I learned categorically, procedural code (very useful), object oriented code (sounds neat but I probably don't need it yet), strings (everything is a string), arrays (sort of an internal database that has its memory wiped with each request), databases (a permanent way to remember arrays), sessions, etc... Once you understand the basic purposes of each and how they all sort of loosely fit together, you realize that the manual is your gateway to coding anything your mind can dream up.
Mine was finally grasping that PHP != JavaScript. The realization that PHP "disappeared" in the context of a web page except for what you echoed back was huge for me. Looking back...I was a confused young man. The next one that helped me understand MVC was that your pages shouldn't be represented by actual PHP files. By leveraging requests that route to actions that output views rather than having people go to "thing.php", I finally understood why architecture is important.
Yeah, I consult the PHP Manual consistently. Some of the times, I don't even remember function names and IDE intellisense isn't much of a help because most functions are global and not part of a class.
https://github.com/ircmaxell/password_compat is honestly a better choice at this point.
No need to spread all that PHP butthurt all over the place though. Just discover and stick to them.
I use PhpStorm which has fantastic intellisense functionality, including all those global functions and their parameters.
I think it only confuses new people. Anyone who programmed in a wide variety of languages before picking up PHP is fine. You can actually see that certain functions come from certain libraries, and their parameter order is exactly like they were from the other language.
Experience? I'm an experienced PHP developer and I understand design patterns, best practices in OOP etc... But I wouldn't hire myself for a RoR project because I wouldn't be efficient and fluent enough to complete the project in a normal amount of time for commercial projects.
2 "ah haaaa" moments for me : 1. references. I come from a "you manage the memory and compile your code" background, and I was pleasantly surprised the day they added references to PHP. 2. streams. They are not well known and not well documented, but they rock. Especially in the context of writing PHP extensions.
Understanding http requests.
I'm not an author, so verbalizing a lot of this was hard. You quite eloquently put what I was unable to. This post is not about Ruby vs PHP, and Ruby may well be the perfect language, but that's irrelevant. I was learning the language not for personal growth but in some vain trek to find the "tools don't matter" utopia, and in the process I was forcing the tool to matter much more than it should. I was forcing myself to be unhappy using a language I did not enjoy because it was the tool that wouldn't matter. I was dumb, and hoped to share that.
Not butthurt at all. I'm a complete PHP power-user ... I was writing OO PHP code back before they even had a decent object model (since about PHP 4.1). I've written massive projects in it, worked on projects with multi-million dollar budgets ... and still go back and maintain them from time-to-time. For a long time, it really was the best thing going ... but honestly, I wouldn't want to start a new project of any significance in PHP anymore. I'm not going to espouse the alternatives here, not trying to start a religious war, but there are languages that really do help you develop more quickly and more easily write more maintainable code while you're at it. The fact is, the alternatives have finally matured into better options, and I would no longer recommend PHP as the language of choice for a significant project. I still think PHP is fine for small projects, especially since it's so easy to deploy in the shared hosting environments that are common to these types of projects, but as soon as you start needing more than just a basic config., things start getting a little hairy (Want some PEAR and PECL stuff from most hosts? Prepare for a battle). As soon as you start approaching the size of a "medium-to-large" project however, PHP's warts really begin to show, and you'd do better to consider another language. EDIT: I should also add, that anyone who considers themselves a "web developer" had better have PHP in their quiver ... especially if you're a freelancer. The prevalence of WordPress, Drupal, OSCommerce, etc... sites out there mean you'll be turning away a lot of work if you don't know how to play in this space. Just make sure it isn't the ONLY language in your quiver! 
Author of [rych/phpass](https://github.com/rchouinard/phpass) here. That's actually not the same thing as the Openwall library. It's an unfortunate naming conflict. I chose the repo name before I realized that although Openwall's class is called PasswordHash, it's known as phpass. Oops. I'm working on cleaning it up and changing the namespace from Phpass to PHPassLib (currently in [develop branch](https://github.com/rchouinard/phpass/tree/develop)), and I'll rename the repo and Composer library accordingly when I'm done. Anyway, my library supports several hash types including bcrypt and pbkdf2. Even so, it tends to get downvoted on reddit although it's very popular in other places. Oh well. 
Yeah, I use PHPStorm as well. I haven't been to PHP.net in weeks.
I keep forgetting to check whether I'm in r/webdev or r/php. In r/php this is circle-jerking. In r/webdev this would be starting a fight.
Relax, it's meant to be a joke but everyone on this thread is getting all butt-hurt over it. http://philsturgeon.co.uk/blog/2009/12/Twiny-Framework-the-framework-small-enough-to-tweet
I updated [the blog](http://philsturgeon.co.uk/blog/2009/12/Twiny-Framework-the-framework-small-enough-to-tweet), just for you. :p
print_r($_SERVER); 
Stop using a text editor and use a proper IDE. Programming isn't about memorizing the order of parameters in special_snowflake_method(), it's about putting it all together.
Making a file that would use ?page=foo to show different content between the same header / footer HTML. Before that I was smashing out sites with 200 HTML files using copy and paste...
The /facepalm was because his expectations were largely unrealistic. Ruby is *very different* from PHP, and it requires you to think differently. It's like thinking "well, I know English really well so Mandarin should be easy!". Essentially, he fails to get anything useful done and then he attempts to blame the language for his failure. Except there are tens of thousands of people who are successful in using ruby, and by extension rails. So you have to ask yourself, what's at fault here? Now, I'm not saying you have to love ruby, or rails. I'm saying if you failed where thousands of others have succeeded, you should probably shoulder that blame instead of attempting to project it.
Luckily, this isn't about programming, it's about a programming language. And yes, it absolutely is the business of a programming language to be consistent and at least locally intuitive. Now, that said, I've programmed Java, Ruby, PHP, C++, Python, Basic, ASP, blah blah blah professionally for the last 28 years. I like PHP the best for getting shit done, but it annoys the hell out of me sometimes.
For me, it was discovering how powerful arrays are in PHP, in 2000. I came from C++, and discovered that arrays were so flexible you could build a whole structures using them. The second was when I realized how easy it was to call a function using it's name, such as $functionname(); Putting one with the other, you could use arrays to build advanced finite state machines with arrays and function names... Back then, I was building almost only FSM using C++. 
What are magic methods? I remember seeing a page about it on php.net a long time ago and thought they were joking about methods being "magic."
phpinfo();
Thanks, that makes sense. There is no management associated with the position, so it is right in between mid and senior level. Thanks for the (now obvious) point about being driven by competitive bids rather than rent. That being said, I really don't see much on Craigslist for anything this level in my area. Do you mind if I asked where you would look for job postings? We may be looking in the wrong spot. Thanks again.
Your IDE should be able to tell you the needle haystack order. I have alias's setup in phpstorm to convert things like strreplace with str_replace. It's really no big deal
Oh, agreed. And for people who like to use an IDE, I say more power to you, they are excellent these days, with integrated debugging, syntax check, and all kinds of great tools. For me, all I have ever needed is syntax highlighting. I get a lot more done a lot faster without the IDE in the way. It's a personal style thing, really. We all love doing what we do, we just all do it a little differently. [Edit] grammar
The auto_prepend_file directive and magic methods in PHP 5. The combination made PHP my go-to language for getting work done. Once I grasped how truly dynamic the language was, it was a lot of fun to play with.
Thanks for this, I completely forgot to escape my form input while coding my new login system.
Completely understand :)
Possible duplicate of: [Parsing and processing HTML/XML?](http://stackoverflow.com/questions/3577641/parsing-and-processing-html-xml) 
Not really sure, since CL covers pretty much everywhere. If there's nothing on CL, then you must be somewhat remote? If that's the case, then you'll probably want to look at the closest metro area. Some may say, _'But those are big-city salaries! It's a lot cheaper to live here!'_, but I think the counter-arguments are: * It's a hassle living outside of a city (catching flights, shopping, entertainment, etc.), and so why would I give that up? You'll likely need to pay a premium (compared to the relative standard of living) to make that up. * Pretty much any recruit you reach is likely also looking in the city, and given the choice of 2 jobs of equal pay, I think most would choose the one in the city (on account of the hassles above). I could be completely wrong (I know I'd probably prefer the more rural gig), but cities are a draw for a reason, and even though the take-home may be lower in the city, it's sort of a subsidized living situation where you give that salary up to have access to everything a city has to offer. Also, I'd guess the average age of your candidates is going to be in the 25-35 range, an age range that typically would prefer city life in my experience.
This is much cleaner! wonderful!!!
I just feel that if you're a developer you would be short changing yourself by branding yourself as a &lt;insert language here&gt; Dev... Unless you are an expert on the said language I don't feel like its worth mentioning unless you really want to be tied to that language.
Thanks! I'll look into that. Would you mind explaining your reasoning?
Mine was finding out how dynamic pages work. I thought if there were a million users in a site than there would be a million pages for it :p
&gt;comparing PHP to Rails is that much of a stretch Rails, CakePHP, Django, ASP.NET, etc... are not languages, they're frameworks. They exist as is and you don't really program as a language. You use a language in tandem with them to make apps, but by themselves they're nothing more than guidelines and structures, if you will. If you made a PHP file called test.php and included another file, say awesome.php, you can call classes/functions/objects from test.php. Everything in awesome.php is already in existence and you're not changing any code. This is what a framework is all about. You're not "programming in awesome.php language", you're using what's already defined to benefit your test.php file. You're writing PHP code with the awesome.php file. Similarly, when you use CakePHP, you're programming in PHP with the CakePHP "file," if that makes sense. 
The problem is that HR people usually can't handle non-specifics, so we've gotten into this habit of referring to ourselves by specific languages or frameworks. I've run into this problem lately where most of the jobs I apply for reject me because I don't have experience in their specific PHP framework. I've got ten years in PHP, I can work in just about any framework with a little learn time, but because of shoehorning nobody wants me.
Variables must be stated before you try to use them, not after.
Oh my, 2003 and the discovery of include / require. Good times were had.
The differences between the languages are only apparent after study so it is not unreasonable to dive in thinking it will be one way and find that it is not later on. More to the point, why do you see a need here to find fault? Why do you perceive this blog as a criticism of Ruby (because i am 100 confident it was not intended that way). What is it about developer culture that so easily seeks to shame other's different choices? Whats so funny bout peace love and understanding if i may borrow a lyric to make the point. 
Because he's claiming that a language/framework shouldn't get in the way. However it's not the language or framework getting in the way, it's his expectations. If you were just to say "I've tried both, and I prefer PHP" that's fine. However if you move forward and try to say something like "I prefer PHP because Ruby gets in my way" after you were unable to to anything useful in Ruby that speaks more about your failings as a programmer than it does about any failings Ruby may have as a language.
Say the symlink has the user permissions and the file I want to read has root permissions. If I create a symlink with the user won't it still not be able to read the file due to it having root permissions?
Er, Drupal was NOT built with Symfony - Drupal 8 will have a few core Symfony components in the bowels, that much is true, but there are those of us who see that as primarily a marketing ploy to make it seem more "modern", when in actuality this won't affect Drupal developers 95% of the time...
That with every request, all the PHP scripts start all over again. Every time it's the first time.
If you're using a framework, just edit the index.php file. For example, https://github.com/puphpet/puphpet/blob/master/web/index.php Instead of doing `require_once __DIR__ . '/../vendor/autoload.php';` I would do something like `require_once __DIR__ . '/../../base/vendor/autoload.php';` Or even better, use a constant to define. It should be fairly simple, though.
Someone must always be to blame, right? ... and now it's my turn to /facepalm. 
It being a joke doesn't make it less repulsive.
I'll make sure v2.0 is fully PSR-2.
The easiest way would just be to create a file your webserver can read, but is outside the web directory, and contains your mysql password. But to explain what is happening you should check the permissions of that file, which you can do with "ls -l" # ls -l somefile -rw-r--r-- 1 root root 0 Jun 6 13:53 somefile So, for some file, the USER root can read,write, but not execute somefile the GROUP root can read, but not write or execute and EVERYONE can read, but not write or execute. joining apache to the group psaadm is a bad idea because it might allow apache to read other files that might compromise the security of your system. I'd ALSO recommend creating your own user/db for your website, unless your site is specifically messing with the plesk db. Last time I checked, /etc/psa/.psa.shadow was just a hidden file, and had the mysql password in plain text, so you should also be aware of that. Hope that helps. 
foreach($array as *&amp;*$ref){ ... } 
I appreciate your comments, and there's a tang of truth to them for sure: I definitely consider myself in this last month to be a failure as a developer, and am honestly a bit of shamed of how truly little progress I made despite the many hours. I just want to clarify a couple things: Of course I wasn't aiming for mastery. I'm a subscriber to the "Learn programming in ten years" methodology. To truly master something you just need to put in the hours, and then put in more hours. However, I was not progressing *at all* with my rails work, because I think fundamentally I don't understand the way ruby wants me to think. Ruby is OOP, but it's got a lot of functional principles buried within, which often left me confused and disoriented. This is not a jab at ruby, this is simply stating a hurdle that I had issues crossing. The point of this article was not saying that ruby is hard so everyone should just use PHP. Quite the opposite: the point of this article was outlining my experience of chasing after the programming language of the week and blindly trying to do something because it worked out well for someone else, while ignoring the fact that it simply was not working for me. I think the end point I was trying to get across is that in the programming community there's a lot of mixed messages and people telling others that one way is better than another, and I just don't think that's true. Instead of blindly following what others were doing I should have looked at what I'm good at, what makes me happy, and how I can combine those two and enhance them for more personal growth. I was so caught up on learning this thing that everyone else said was cool that I made the tool the problem, instead of the code I was working on, and that focus on the tool rather than the problems and algorithms is the issue I wanted this article to focus on, not infighting between languages. **EDIT**: To address the comment of blame below. I think the title was regrettable, but I also don't think it necessarily has to be about blame. This is the story of how a tool got in the way, and it is the story of why I'm not doing rails and sticking with PHP. I think you're instinctively assigning blame because of the habit in the programming community to rabidly attack languages, but that's not what I'm trying to do. The tool got in the way because *I put it in the way*. It was my short-sightedness and my incredible enthusiasm that caused this problem, coupled with the differences in how I think and how ruby works. It's not the tool's fault, it's mine. But I think there's merit in trying to help people not make the same mistakes I did.
I have no problems with the fact that you may have failed. Failure is an integral part of learning, and it's not like any of us is immune to it. Don't be ashamed of that, especially given how little time you allowed yourself to learn it. I think the core part of the problem is you spend way to much time focusing on how much you love PHP, so much so that it makes the entire thing seem like an "us vs them" debate instead of focusing on the bits that really gave you problems. Now, nobody is saying that you're wrong to work in PHP. If it does the job, and you can produce a good product with it you absolutely should use it. The thing that the article projects, even if you didn't intend for it, is an idea of monotheism amongst languages. The PHP community suffers a lot from this because PHP is seen by many as the only tool you'll ever need which is an attitude we need to combat. Learning new langauges, even languages you may never be good at, is IMHO absolutely essential to growing as a programmer. We should encourage exploration as much as possible. New ideas are learned from this exploration, and people bring them back to PHP strengthening the whole. Anyone who has used a modern MVC framework in PHP has already had a taste of what this can mean for everyone.
Find something you'd like to make and make it! Simple blog, basic CMS, authentication system (the process and practice is what's important, maybe don't roll your own for a major site), calculators...
So many ways. Fork each repo off a main repo, and just pull updates to each of them. The main one is called "codebase" or "shared" or "unicorns" and "sitea" is a fork of that. git pull shared master Done. Then you can commit your own stuff into sitea and push it, then deploy from there. That's the low-tech approach, without getting caught up on specific frameworks or shit like that.
if they are all on the same server just use different templates and styles in different directories and point apache to those different directories, its not really a problem at all.
That did not do it for me... Just displayed 0.
What about engineers? If you're a mechanical engineer chances are you know a bit of civil engineering (I do at least, my background is ME). I label myself as a mechanical engineer because that's what I studied and where most of my experience lies. Sure, I could work for a civil engineering firm but I'd have to take an entry level position.
And then you learned about std::map and functors and went back to C++?
https://github.com/symfony/DomCrawler
For me this is the [script's output](https://dl.dropboxusercontent.com/u/1689691/output.txt). I'm worried about creating invalid utf-8 characters.
You should give Sinatra a try. It will probably be a lot easier to pick up than Rails. The PHP frameworks Silex and Slim are based on its design.
It works, I just find the pack function a bit fascinating vs a utf8_encode(chr($i));
Coming from a Java background I had never used a dynamically typed language before. When I released I could assign and reassign multiple values/objects to a variable and then test it's value and type using ===.
I probably ran it wrong just put a &lt;?php on the front and a ?&gt; on the back and let er rip. FAIL.
Wow, this is so unrelevant but so true. Gj op
Aaah, functors. I remember a class I made that accepted chained parameters, lots of them, and executed itself on its destruction.
just chmod 777 the file. lol. I am out of here.....
&gt; Instead of imagining things to implement, I just took my site already built in PHP, and started porting it, page-by-page, feature-by-feature to rails. Well, there's your problem. Your headspace was too close to the php code (which was probably procedural or idiomatic php). You were trying to write idiomatic php in ruby, when the goal is to learn idiomatic ruby on rails. (If you looked at the php source code while doing this, that would doom you.) For a php developer, the first value of learning Ruby on Rails would be to learn the RoR idioms, which you could then import into your php code.
Recent versions of /etc/psa/.psa.shadow are encrypted and no longer plaintext. You can run a command to change it back though.
Just curious, where are you located? When I hire people, I ask them their github, stack overflow handles and ask a couple of questions. I honestly hire personality more than skills. I'd prefer someone that's eager to learn and a good team player than an asshole elitist. 
Interesting analogy and I think it has some value, however, I would have to disagree with your final conclusion. PHP may not have the elegance of other languages but as you said PHP was born out of purpose. It is the long standing design debate of form versus function. I feel the PHP thrives because it is incredibly functional and flexible, even if the code looks sloppy. It gives those who aren't well versed in coding to cobble together their own half assed code yet still have it work. 
Whaaaaaaaaaaaaaat? How!?
Does your company currently use any php frameworks like Symfony or Zend? 
Symfony2, yes.
Check out [Fowler's paper on DI](http://www.martinfowler.com/articles/injection.html) Basically, instead of hard coding dependencies such as this (using C# cause that's what I've been programming in lately): public class Test { private MyObject obj; public Test() { obj = new MyObject(); } } You pass it in as an injected dependency: public class Test { private MyObject obj; public Test(MyObject object) { obj = object; } } This allows you to configure what's passed in at runtime. If you combine this with interfaces, it makes it even more powerful: public class Test { private IObject obj; public Test(IObject object) { obj = object; } } Then when calling: IObject object = new MyObject(); IObject object2 = new AnotherObject(); Test test1 = new Test(object); Test test2 = new Test(object2); This allows you to configure what is passed in without having to modify the core behavior of Test because MyObject and AnotherObject implement the same interface that Test expects. It merely operates on the interface contract rather than the concrete implementation. I hope that makes some sense....
Actually, my boss made us switch to C# and soon after, I started my own company doing PHP.
Pushing onto an array using $array[] = $thing. Possibly not the greatest syntax for it but doing this without a function call is sort of nice. I also like how ob_start() works and is very easy to do some caching with.
Louisiana. We have nothing on Craigslist compared to other places, now that I've checked it out. I like the github suggestion as well. Thanks so much!
Being that it's an interpreted language, I don't have to compile my code every time I make a change.
The main reason is that it's 3 function api is an exact drop in replacement for the native password hashing api that's coming in php 5.5
why not learn about unit testing? (https://jtreminio.com/2013/03/unit-testing-tutorial-introduction-to-phpunit/)
Just to add, my getters and setters are manipulating the array directly. public function setUniqueID($uniqueID) { $this-&gt;arrBaseProps["uniqueID"] = $uniqueID; }
Then that seems odd he'd want to switch frameworks like that unless there were major, unnoticeable problems with Symfony, especially since the team is already familiar with it. I've worked with both and while Zend is very customizable, it also has a steep learning curve. Do you know of any particular incident that might have led him to want to switch away from Symfony?
I'd consider doing the merge in the constructor and storing that within the child class. This would only be adventurous if you had functions that manipulate the data. That way you could avoid writing logic within the function to decide whether the base array or the child array is getting manipulated. Ultimately if you're just using the classes to store data and that's it I think it's overkill to even use classes, an array would be fine. 
I can't say what you're doing is wrong, depends on exactly what you're doing. But typically the way people handle this is the properties aren't a member of an array. They're just direct members of the class. Then in the constructor you assign defaults to the properties so you know they're already set. Then in the setter function you validate what they're set to to make sure it's a valid value before you actually set it. That way you can avoid the whole looping through the array to make sure they're set. You know they're set from the get go. But it just depends on your specific situation. 
The properties contained in the arrChildProps array is prone to be often changed during the lifetime of the instantiated object. I believe making the array_merge in the construct would mean that I'd be "stuck" with the default value, unless I re-merge the arrays after changing a properties. Unless I misunderstood the way array_merge work ? Are the merged arrays still 'dynamics' after the merge ? Value from the resulting array will update when updating one the merged array ? 
 iconv('iso8859-1', 'utf8', call_user_func_array('pack', array_merge(array('C*'), range(0x7F, 0xFF))));
You can still change them. You just merge them so you're working with one array not two within the class. Because it happens when you instantiate the class you can safely rely on them being there. I might have the merge back to front in my head but you want to merge the base array into the child array. 
I see sf2 is better because it come with a practise bundled: composer, schema management, cli framework, bundle structure, debugging toolbar, etc. While ZF2 still more or less a library, it means when you get a zf2 project, you don't have any idea how it is organized Also SF2 is more friendly and open to the community, play along with many great librarys from the beginning, it end the era of writing framework == writing library.
Don't really have anything to test yet. I'm not really sure what kind of project I should start CMS, blog, etc that will require me to use new kinds of coding or extensions other than just basic OOP.
Define "wrong". I think you're answering yourself: **I came up with a solution that works exactly as I want**.
Well then I wouldn't say you're doing it wrong, you're just doing what you have to do in your specific situation.
Out of curiosity, are you planning on writing methods within the class that do stuff with the data?
What I thought was wrong : Using an array instead of "classical" class properties. That seemed unorthodox.... But you're right. It works as I want it to. Thanks for the feedback.
Yep, that's the plan. Any concerns ? 
I'd say everything you code could be tested. At the least, any new features you implement should be tested at the feature level, at least. As far as learning new paradigms, implement a CMS using an MVC framework like CodeIgniter or Laravel.
Your first statement is actually quite interesting. You don't need to have anything to test. One development method is that your write your tests first, which obviously fail, and afterwards write your code to make the tests pass. This is called test driven development if your interested.
If it runs, be joyful. I assume you're trying to ascertain if your code contains any ill-practices or algorithms. I suggest you review: [PHP The Right Way](http://www.phptherightway.com/ ). This will help you see what others agree are the best 'ways' to go about completing something. Keep in mind not all solutions will be pretty or *ideal*; you need to make whatever solves the problem. By this I don't mean make sloppy code. Write unorthodox solutions and try out alternate solutions on your own to see what solves your issue better. At the end of the day if your code solves your requirement, you've done it the *right* way.
Try to learn atleast one framework and one cms if you wanted to go freelance. 
Why aren't you using a framework?
A lot of frameworks use that feature and therefore I use it almost everyday :D
You're not doing it wrong if it works, but there are a few things I would do differently. Instead of setting the value for $missingProp, you could just do `return false;`. Would stop unneeded executions of the loop. The last line could be `return true` because if it made it that far, everything is valid. Speaking of the loop, I don't think it is really needed at all. [array_search](http://www.php.net/manual/en/function.array-search.php) would probably work for this. function validateAllPropertiesAreSet() { $isValid = array_search(null, $this-&gt;arrChildProps); return $isValid === false ?: true; // ? false : true if &lt; 5.3 } EDIT: Thanks /u/shawncplus for pointing out my error.
You don't want to do `return isValid ? isValid : true`, array_search returns boolean false OR 0, both falsy values. return $isValid === false ?: true; // ? false : true if &lt; 5.3
Someone might correct me on this, but aren't ASCII and ISO-8859-1 encodings both the first bit of UTF-8? I know ASCII is and [the wiki](http://en.wikipedia.org/wiki/ISO/IEC_8859-1) page for 8859-1 seems to imply its the same. Since UTF-8 encodes unicode code points (eg `U+0000`) from 0 to [whatever number they're at now], it would seem really hard to generate invalid UTF-8 from the range 0 to 255. You should [give this talk a watch](http://www.youtube.com/watch?v=sgHbC6udIqc). It's specifically about Python, but it has some good information on encodings and character sets and the like.
What is your take on remote employees? 
and with php 5.4 they get pretty
If you're in NOLA, [Worknola](http://worknola.com) is the place I'd check out to get a handle on the hiring competition. Even if not, Louisianians concerned with salary will tend to base their numbers off the New Orleans rate. FYI, as a Senior Dev/Systems Architect, I've been offered similar numbers before for positions that required high-level decisions and autonomy, so I think you're offering well above market rate and will probably get a few very qualified applicants.
Start writing plugins for Joomla or Wordpress. Both great tools. Why write a framework when there are decent ones out there already?
echo 'test';
MVC programming (code igniter, zend, symfony, etc.) is more rewarding in my opinion, you're more likely to feel good about your work in an mvc framework because you have the freedom to write clean, maintainable code. If you're looking for employment, Wordpress and Magento customization is in high demand. 
Have the same codebase per vhost, managed via svn or git, with a 'SetEnv' Apache directive within each to designate the particular site. Have your code look at this to determine which stylesheets etc to load.
But not functions! Because they are picked up in the first pass of parsing you can define them at the bottom of the page and call them at the top.
Thanks for the input. I will check this place out!
You should use prepared statements. Basically, if someone submits a string like '; DROP TABLE users;' the first semi colon will end his statement, and then add a second statement to it. This allows for SQL to be injected, because the PHP string will appear to have two separate mysql statements in it.
That's what I've used before, with no major issues. Also used it as a part of https://github.com/fabpot/goutte for web-scraping.
In my framework I'm doing something like that. Here's my solution: abstract class DbRecord { protected $requiredFields = array(); ... public function __construct($params = array()) { $this-&gt;properties = (object)$params; // you can merge it with your default values here } public function save() { $missingFields = array(); foreach($this-&gt;requiredFields as $field) { if (empty($this-&gt;properties-&gt;$field)) $missingFields[] = $field; } if (count($missingFields) &gt; 0) throw new Exception('Required field(s) missing: ' . implode(', ', $missingFields)); // save to db } } 
Bit of a boon and a curse but there's a built-in function for pretty much everything. I can't think of any other feature of PHP that I'm not used to from other languages. Maybe autoloading.
Yeah, I love me some ob_ functions. You can do your normal methods for output to build your cache. Hassle free.
I actually used a variable name in a situation like: $blah = 'something'; echo $obj-&gt;$blah; It felt dirty but it was a lot easier than the alternative at the time. 
I just looked that up, looks awesome! now if only they could get rid of the awkward =&gt;.. Right now I have to use key expansion from colon.
the job market, you will not remain without a job for long if you know php :)
Zend_Reflection makes reflection even better, too. No having to parse out the /* * * */ stuff yourself. 
Want a well organized, unit tested, OOP framework with 90% of the boiler plate stuff you'll need out the door? Here, have a boat load. (ZF2, SF2, Laraval, Cake, CodeIgniter, Yii, etc, etc, forever, etc). Want to bang something together in 10 minutes? You may hate yourself in a year for this, but I'll do that too. Want either of those things to run on pretty much any hosting system anywhere or install to any server in existence? Totally covered that too.
Arg. I'd be mighty pissed as both a developer, but way more so as whoever runs the "Operations" or sysadmining. 5.2 has been patchless since Jan 2011 -- 2.5 years is a long, long time to find any lingering exploitable issues. It's like hiring an architect, builder, and manager to construct and maintain a apartment complex -- and then they're all given sticks and mud as the owners say, "That'll be enough to keep our most precious things safe and secure, right? I mean, those are still good for this, and nothing really needs changing." 
Most of what is suggested here is all well and good, but keep a very, very close watch for functional divergence. If you look up once day and can't figure out which if(site=1){} statement you're inside anymore, you've gone too far. If it does start working out like that, try to veer more towards chunks of functionality that can be toggled on off, with each "site" represented as a configuration file which turns on/off functions (and even then, it will get muddled if you diverge too far.)
Yeah.. I was thinking along the lines of when I learned another programming language and learned what OOP can really be.
I knew this was possible, but I'm yet to ever have a use for it.
If you liked this, this will blow your mind in PHP 5.4... &lt;?php class foo { public static function bar() { echo "Hello World from bar"; } public function bat() { echo "Hello World from bat"; } } $func = ['foo', 'bar']; $func(); $func = [new foo, 'bat']; $func(); Essentially, any valid callback, whether it's a function name (string), class name/static method array, object/method array, or a closure now works.
This is completely different. He's calling an already defined function dynamically. You're creating a new closure. What if the function was say... `substr`? or see my example [here](http://www.reddit.com/r/PHP/comments/1ftupb/your_favorite_php_feature/cadx974) of non-global-function calls They might seem to be practically the same thing in this scenario (but not really, yours has quite a bit more overhead); but they're not really.
Have you seen the `DateTime` class? The constructor acts like `strtotime()`, so `$yesterday = new DateTime('yeterday');` works (under the hood, it's the same implementation), but additionally you can also do: `DateTime::createFromFormat(...)` which is essentially a reverse `date()` function. `DateTime` has fantastic support for doing date math, supports timezones and all sorts of goodies. And acts smartly when you compare two DateTime objects :) $a = new DateTime('5pm GMT'); $b = new DateTime('noon EST'); var_dump($a == $b); // true
tl;dr - Use http_build_query and htmlspecialchars to escape your output.
I *adore* the streams layer. It's such a great solution for I/O. If you haven't used the streams layer... you're a liar. It's used in all I/O including `require/include(_once)()`, `file_get_contents()`, `fopen()` etc. It's what allows you to do: `file_get_contents('/local/file.txt');` and `file_get_contents('http://example.org/remote/file.txt')` transparently. The closest thing I've seen to it outside of PHP is KIO in KDE, and FUSE.
I just upgraded all of our servers to 5.4 after seeing this. I think I might've just started liking PHP a lot more.
Just curious, what would you use instead of =&gt;? The normal assignment operator = would be pretty confusing in this context. Think about something like this: $array = $anotherarray = ['x' = ['y' = 1, 'z' = 2], 'y' = 'z', 'something' = 'somethingelse'];
Probably `:`, making them very like JSON syntax, and some even tried to add `{ }` object literals to PHP to complete the set when the short array notation got in.
My favorite feature is [SimpleXML](http://php.net/manual/en/book.simplexml.php) off the top of my head. My favorite story to tell when someone says, "Pssh, enterprise PHP?" is the Facebook story. The fact that a programmer was writing a PHP to C++ converter because he hated PHP SOO MUCH but instead birthed [HipHop/HPHP](https://github.com/facebook/hiphop-php/wiki) is incredible.
I would definitely recommend that you get some working experience with known frameworks before you start building your own. Building your own framework is a really good idea that I think most people would benefit from, but if you've never used a framework you won't know about all the details that the framework actually handles for you.
That actually makes a lot of sense, I'm not sure why I didn't think of it earlier. : would definitely make me think I'm dealing with an object rather than an array at first, but I guess I'd get used to it pretty quickly.
JavaScript uses `foo: bar` for assignment. I really don't mind `=&gt;` though. Ruby uses it, too.
Javascript uses the colon for assignment on objects, not on actual arrays.
Shouldn't you know the answers to these questions if you've developed PHP applications for a large corporation? Just seems odd... &gt; Support. This is a question for yourself if you wanted to write the app. Other companies can still support someone else's code. Happens all the time. &gt; Data migration. What type of database is it? Is it a database? Can you autokey data into a spreadsheet during migration? &gt; Equipment Any 486 would run this application but again it is dependant on size. How many users, how many records, etc... &gt; Dev. Environment Just setup a virtual machine or a subdomain that connects to a second datastore??? **You need to write down a list of business needs** ^Still ^hard ^for ^me ^to ^believe ^you ^developed ^for ^a ^large ^corporation.
Ah. So they're using __callStatic($name, $arguments)? Cool.
The proper thing to do would be to bring on a consultant regarding the regulations. Imagine the liability with a breach? 
You might like Twig templating
Not really sure I would actually. I get that templating systems add some nice shortcuts, but I already *know* PHP. Why would I want to learn yet another syntax for loops and if/then statements? (Not trying to be rude, but I really don't understand...)
You might be able to use get_class_vars or get_object_vars to obtain all properties of your class instead of storing them in an array. Then you could store them as regular class properties. This only makes sense if you want ALL properties to be validated. 
I am a bit old-school. Started with PHP3, back in the day, so I haven't gotten used to the newer library functions yet. Thanks for bringing this to me.
(student) web devs work from home, whenever they want ;)
What is the best way to get jobs to work from home? Starting your own small business?
No only the first 128 ASCII characters are the same. Everything else is used for multibyte code points. They start with a leading byte followed by up to three continuation bytes. You can't have a single 0xFF byte for example. 0xFF can only be used as a continutation byte and yada yada. UTF-8 gets complicated after byte 0x7F. You have to pay attention to what OP is doing. He's not checking if bytes 0 through 255 are valid because half of them wouldn't be. He's converting the bytes to UTF-8 first and checking that. For the first 128 bytes they'll be exactly the same as the ASCII. After that though each character will get converted to some multibyte character.
I don't know it was my first ah-ha moment, but it was an ah-ha moment of some sort, because I'm so used to the iteration being a copy rather than a reference. It's usefulness is marginal. Maybe about as useful as array_map() except more dangerous. The need for references has all but gone since PHP4 and I shy away from them these days.
I love the vast amount of useful functions, take the copy() function for example: // BOOM! Copies a file from one directory to another. copy("/dirA/file.txt", "/dirB/file.txt"); but wait, there's more... // BOOM! Copies a file from another server to this machine. copy("http://someserver.com/file.txt", "/dir/file.txt"); 
I believe in ruby (1.9 I think) you can use the `=&gt;` and `:` interchangeably.
Nope Software is viable because you can sell to many customers. You'll have just one. It will not be worth the massive amount of time and ongoing responsibility you'll have
It's the streaming layer that handles all this behind the scenes, as another thread here points out. If you can point to a resource that will stream out bytes, then you can copy from it.
I've found with most modern frameworks, you don't need to touch output buffers at all. Having to work with those buffers, for the odd occasion, feels like stepping back in time. But really, check out the likes of Laravel and other MVC frameworks. I have a feeling you may be missing out ;-)
I'm a fan of the idea, but you have no idea how persistent Not Invented Here Syndrome can be. Well, maybe you do :P. Latest example was a suggestion to rewrite Zend\Mail. I'd vote for just nabbing Swiftmailer and being done with it. If it needs rewriting for ZF3, it needs to suck resources out of the project better spent on core elements.
Nice, I had never came across that site yet. Looks useful. Thanks !
Eventually, I'll expend the function to also return which properties are missing to inform the user, and also do some data validation. The function right now is more of a placeholder, hence the loop through all properties. Nice tip however. I have something else in my code that could benefit from that optimization. Thanks !
I actually got a couple of casual jobs here through Reddit. (Disclaimer: I'm a professional)
I ask only because I know a couple of developers here in NY that would jump at the offer, but would rather not relocate.
I guess that will be one upside of the marketplace fairness act - since it will already submit me to the jurisdiction of states where I have no vote, there will be no downside to remote hiring. It is good to know that the offer makes sense, though. I really appreciate it.
Confronting people needs a bit of care. If you don't understand his reasons, you should find out what they are before anything else. For example, my company adopted ZF2 quite late simply because the cost of training, switching and dealing with 2-3 frameworks on existing work would be a PITA. Switching is a lot easier on clean slates - once you get the damn slate finally clean :P.
I really appreciate how well documented PHP is. php.net is a great resource! Love all the user comments. Variable variables ($$foo) is a nifty feature. compact() and extract() are cool too. Always using serialize().
I've found references really useful when working on ORM classes. Other than that I rarely use them.
I dont remeber what this is called, but damn is it useful. for($i = 0; $i &lt; 10; $i++) $$var = $i; EDIT: Missing $$$$$$$$$$$$$$ EDIT 2: Missing ;;;;;;;;;;;;;;;;;;;
IT'S FREE TO LEARN AND USE!
&gt; You can't have a single 0xFF byte for example. 0xFF can only be used as a continutation byte and yada yada. UTF-8 gets complicated after byte 0x7F. Gotcha. Thanks! I didn't know the specifics of the implementation well enough.
any practical example to share?
Also https://github.com/domnikl/DesignPatternsPHP/
which is highly discouraged because short syntax is disabled on most hosts
variable variable
the only error log entry that matters is the most recent one. When I have a hard time, I delete (clear) the error log so I see only *this* error.
One reason is that if your code above was given to designers then they have all the power of php within the theme layer. I've seen some horrific misuses in Drupal themes, with twig you can limit the theme layer to just theming. Go have a proper look at twig and make your own mind up :)
If you mean the people that have written the code in the past, that we now have to work around, then yes ;-)
I've always thought this would be amazing. I'd just be afraid of how some of the code would turn out if people tried to define objects anonymously. I know it's common for on-the-fly data, but I haven't seen much functional php programming that really utilizes anonymous functions. That being said, PHP is a cluster fuck of features that could be cool if used right, but seems to always be abused when I find them in any project I inherit. It would be par for the course.
But then you can't do this: http://xkcd.com/303/
It does. I live in Rural NY and work for a company in DC. I get a low end salary for DC but because of the cost of living difference, I'm quite comfortable. Added bonuses, I live near my family and a rough morning commute involves tripping over the cat. The company gets the skillet they want at a price they like, and I've been more than willing to help them adjust to accommodating remote employees into how we do business. I'm now one of three. All of us in rural areas. 
Enh, it works. It's a bit "meta". An alternative could be to use a validation component like Symfony Validator (or maybe Aura Filter) then extend the validation to cover your extra properties. The advantage is that it moves responsibility for validation out of your base class, so you're more "proper" with respect to the Single Responsibility Principle of OO design. It's a lot more code though. This is probably fine enough until you want to do more validation than just "is set".
I find it fairly common to have properties be held in a protected array and use magic getters and setters to interact with this array. That being said, I think magic is best left in Vegas.
Well I don't know OP's exact situation, but I probably wouldn't write it this way. Even if the class doesn't know the default values at the time, you almost always know them when it comes time to create an instance. In that case you can just take them as arguments to the constructor. But assuming it's a situation where even that won't work and for whatever you just have to create an instance before you have a clue what data to stick in it, I personally would probably have some sort of commit method that validated/threw an exception on the properties before you did whatever you were going to do, like stick it in a DB. And skip the whole array. But after talking to OP I feel they may have something weird going on and already tried a few things and this is what works for them so it just is what it is.
Yeah I've seen it before. It's not really that odd.
That's okay, I don't either, I just have a general idea how it works. Like I don't which bytes are used for start bytes or continuation bytes and stuff. It's one of those things I always forget immediatly after looking it up.
The two examples you gave could also be done in PHP4. The 'streams' rewrite in PHP5 made it a lot more powerful (though complex), but also something which doesn't get used very often, from what I see. Theoretically, writing your own stream handler is neat, but not something many people need to do. BUT... I was just reading about Google's App Engine support for PHP. Normally in a cloud environment you can't count on filesystem access. But they're defined their own stream handler for file access - gs. You can do something like $data = file_get_contents("gs://path/to/file.txt"); which is a pretty cool use of custom stream handling, imo.
Sticks and mud, not so much. Perhaps closer to building code and material changes. Forcing people to build according to building codes from 1900, give them asbestos to use in the walls, and leaded paint would be closer to the mark. Oh, and then complain when people get sick or walls collapse because of a minor earthquake. We know there are better ways to build buildings, and we don't (generally) require people to use outdated tools and processes to build new buildings. You likely wouldn't start a new building project with tools that were out of warranty, and have had manufacturer security recalls for known defects. But when building new software projects, we somehow seem to be OK with telling people to use tools from 5 years ago that have known problems.
Here's something I use at work to pull out the value of a class property's @var declaration. As chuyskywalker mentioned Zend_Reflection may do this for me. I should check that out. :) /** * Retrieve a model's property type * * @param \ReflectionProperty $property * @return string */ private static function getPropertyType(\ReflectionProperty $property) { preg_match_all("/@var [A-Za-z0-9\\\\]+(\[\])?/", $property-&gt;getDocComment(), $matches); if (count($matches[0]) &gt; 1) { throw new DomainException( "{$property-&gt;getDeclaringClass()-&gt;getName()}::{$property-&gt;getName()} has more than one @var declaration." ); } elseif (count($matches[0]) == 0) { throw new DomainException( "{$property-&gt;getDeclaringClass()-&gt;getName()}::{$property-&gt;getName()} has no @var declaration." ); } else { $parts = explode(' ', $matches[0][0]); return $parts[1]; } } Elsewhere: $reflectionClass = new \ReflectionClass(get_called_class()); foreach ($reflectionClass-&gt;getProperties as $reflectionProperty) { echo $reflectionClass-&gt;getName() . '::' . $reflectionProperty-&gt;getName() . ' is a ' . self::getPropertyType($reflectionProperty) . '!'; }
- nearly all files in /etc are _readable_ by everybody - symlinking the file will not change the permissions
Thanks! chr makes the code much more easier to read.
That is a very impressive one-liner! Are you a perl programmer?
This seems like a good use of "Not Invented Here." Just go buy something, save yourself the headache.
I think we're missing some information. Are these on different servers? If these are on different servers and you have ssh access, sse version control like git or subversion. You have to "roll out changes," but it's a simple one line command (usually) as long as you have terminal access. If they are on the same server, you should really leverage a framework that does a lot of this for you.
I've done this with several projects that support hundreds of customer websites. This is pretty common with multi-site frameworks I assume.
well, i only worked with companies having own webfarms, thus it never was a problem, and at least on all debian installations its default behaviour, - so far i havent come across on a hosting company in germany that had it disabled.
Load testing
also in php 5.4 you get &lt;?= ?&gt; tags by default, which let you do an echo statement with less code instead of &lt;?php echo $variable; ?&gt; you do &lt;?=$variable?&gt;
All on the same server. I really don't have any experience using frameworks so I doubt I'll use it for this project. Probably worth looking into for the future though. any recommendations? I've heard codeigniter is probably the one to go with.
I really don't have any experience using frameworks so I doubt I'll use it for this project. Probably worth looking into for the future though. any recommendations? I've heard codeigniter is probably the one to go with.
Now pretend you know absolutely nothing and re-do it all securely.
Do you know your way around regular expressions? I'm guessing not, so here you have some links to get you started: http://en.wikipedia.org/wiki/Regular_expression http://www.regular-expressions.info/quickstart.html http://www.php.net/manual/en/function.preg-match.php Good luck!
The reason is (I think) two-fold: 1. Because PHP arrays support string keys, you can never be strict JSON. You're mixing the two (object and array literals) together. You can limit arrays to just be int keys, but that's retarded 2. It's complex to add to the parser The latter is a complete guess, but `:` is part of the ternary operator which already has two states (`condition ? true : false` and `condition ?: false`).
Nobody said this thread was PHP 5+ ;) Streams allow for things like PHAR (PHP Archives) which I hold near and dear to my heart. As well as the filtering options (encrypt and compress on the fly? yes please!).
It's a sorry state of affairs for a lot of folks. I know of two shared hosting providers that are still on PHP 5.2 (HostGator &amp; ModWest), and according to [w3techs](http://w3techs.com/technologies/details/pl-php/5/all), PHP 5.2 is still in use on 44% of PHP 5.x websites.
 $func = ['foo', 'bar']; Can also be written as: $func = 'foo::bar'; And namespaces are also supported: namespace a { function b {} } namespace { $func = '\a\b'; }
Errors usually go to /var/logs/apache2/error.log, although the location can be changed. For example on a shared host there will be a single log per domain, something like /home/youruser/logs/error.log. You can do this: tail -f /var/logs/apache2/error.log | grep -i error tail reads the last lines of the file and -f forces to print live changes. So you can go to your browser and do the action that creates the error while watching the terminal window where you executed the command. -i on grep forces to ignore case, so Error, error or ERROR would match. Regular expressions can be simple strings, like "error", "mysql", etc. They don't have to be complex to be useful.
I totally recommend Python over PHP as well. In addition to BeautifulSoup, you'll want to take a look at [Scrapy](http://scrapy.org/).
That is the PHP 4.x way of doing things (aka. the Wordpress way), and it's madness. Most everyone now days is using an autoloader, and mostly autoloaders that are [PSR-0](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md#splclassloader-implementation) compliant (I think [this](https://gist.github.com/jwage/221634) is the most popular). This means that you can use someone else's code within your app, and not once have to worry about manually setting any constants to try and keep with and juggle paths and URL's.
FYI, /r/php is not really a good place to ask for help, since most of us have been writing PHP for quite a while and mostly come here for news and updates. /r/phphelp is a much better place for that. However, here's a snippet to help you get the job done: http://pastebin.com/YRs7kicQ Now, I'll be honest, I don't have time to compile that script to see if it works, but I'm 99% sure it'll do what you need.
Ding ding ding! I am indeed using an autoloader. The constants aren't for classes so much as they are for linking to files or stylesheets, etc. In several different places in my code base, I call Config::read() or whatever without having to require() it first. It's beautiful :')
Couple of things: * DEFINE() doesn't need to be capitalized. Minor thing, but still. * You might want to try escaping your backslashes, e.g. C:\\\Windows\\\System32 That should fix it.
Yes, but it looks different in Perl: Buf.new(0x7F..0xFF).decode('iso-8859-1')
Two = many? Never mind, that's semantics. Let me provide a specific example: class Logger { public static function log($message) { fopen(BASE_DIR . '/logs/' . date('Y-m-d') . '.txt'); ... } } THAT'S where I'm using the constants.
Should be decoupled. The path to your logs directory should be property of your Logger class (either static or instance, depending on your needs), that gets set when a logger instance is created. If static, you can set it once as part of your bootstrap. $logger = new Logger(); $logger-&gt;setPath('/my/path/for/logs'); OR in bootstrap Logger::setPath('/my/path/for/logs'); 
conversely, your Logger class needs a getPath method that you use to build the actual path for fopen
Data migration can be difficult and would be the first thing that I would look into. Depending on the source application/database setup it can be a nightmare. I did a lot of contracting work for a company that migrates data from Veterinary software into their webapp and it was (and still is) a complete hassle because the host application's db was designed by a toddler that had no understanding of how relational databases work. Equipment and resources should be the least of your concerns because you have one potential client right now. Fire up an AWS EC2 instance or Google Compute Engine instance and you're off and running for a relatively low amount and you have the ability to scale easily. For the DB you can host yourself on an instance or use something like RDS for a hosted solution. Both Amazon and Google (and I imagine many other providers) offer special instances for Gov't and other special needs clients. For you, I don't think you'll need to worry about much, just adhere to HIPAA guidelines. Dev environments. I'm assuming you mean dev/test/prod? This is easily done with multiple instances and you can use some deployment software to handle rolling out to prod. 
Compression I've done - what are you using for encryption? Something custom, or is there something inbuilt I'm missing?
Yup, 2 too many. // bootstrap.php, located in your project root $app = new App(__DIR__); // app.php public function __construct($path) { $this-&gt;logger = new Logger($path); } Or... // bootstrap.php, located in your project root $app = new App(__DIR__); $app-&gt;setLogger(new Logger(__DIR__)); Before the introduction of `__DIR__`, I found myself basically setting a constant that performed the same function, but with `__DIR__` I don't think I've ever needed to hard-code a path as a constant.
Awesome! Glad I could help.
I suppose making it a property isn't a bad idea...I'll think about that, thanks!
**index.php** http://pastebin.com/ErB0cRwQ **script.js** http://pastebin.com/QWVzw9Aw **style.css** http://pastebin.com/n3fT80YQ The magic happens in the first block of PHP in index.php :)
I really appreciate the compliment! I've never used Yii before, but I've been writing PHP for 6-7 years now and I'm pretty damn good at it if I say so myself :)
Agile, but loosely so. 
That's awesome. Even if you built something nontrivial with an MVC framework of any sort, and were disciplined enough to build automated tests, I would say that is extremely impressive right out of high school. Very inspiring!
That's not really the same thing. The example I gave is more about calling functions/methods dynamically. For instance if you have controller classes with method names formatted as &lt;name&gt;Action, ex indexAction(), accountAction(), etc. PHP makes it easy to call the correct method for the client request without dealing with configuration files, look-up tables, or complicated reflection. &lt;?php $controller = new Controller(); $name = $http_request-&gt;action_name; $method = "{$name}Action"; $controller-&gt;$method(); 
That's pretty slick. Feels cleaner than using call_user_func(array(new Foo(), "bat"));
Add new encryption algorithms, allow to loop through one or more encrypt ions multiple times,....
Not any different than doing: $key = 'test'; echo $array[$key]; That's very common.
Sounds like you aren't very good at WP.
One thing to be aware of regarding HIPAA compliancy and AWS is that AWS will not sign a BAA, and generally HIPAA compliancy means having a BAA in place with your hosting provider (or providers of other services). Amazon has announced they will make a decision at some point in the future regarding whether they will sign a BAA (Business Associate Agreement), but no word when/if this will actually take place. In the meantime, this means that technically any sites hosted on AWS are not HIPAA compliant. More on BAA here: http://www.hhs.gov/ocr/privacy/hipaa/understanding/coveredentities/businessassociates.html
**PHP's documentation.** Seriously, I don't know any other language with better documentation than PHP.
Can you objectify better?
Nope. It works just fine with 5.3 except the short array syntax.
PHP 5.3.15: php &gt; class foo { public static function bar() { echo "hello world"; } } php &gt; $foo = array('foo', 'bar'); php &gt; $foo(); Fatal error: Function name must be a string
Am I missing something here? [1] boris&gt; class foo { public static function bar() { echo "hello world"; } } [2] boris&gt; $foo = "foo::bar";  string(8) "foo::bar" [3] boris&gt; $foo(); PHP Fatal error: Call to undefined function foo::bar() Also while the namespaced function example you put works, static methods inside namespaced classes do not: [1] boris&gt; namespace a { [1] *&gt; class foo { public static function bar() { echo "hello world"; } } [1] *&gt; } [2] boris&gt; namespace b { [2] *&gt; $func = "\a\\foo\bar"; [2] *&gt; $func(); [2] *&gt; } PHP Fatal error: Call to undefined function \a\foo\bar() but: [3] boris&gt; namespace c { [3] *&gt; $func = ['\a\\foo', 'bar']; [3] *&gt; $func(); [3] *&gt; } hello world 
comprehensive, with version data, up-to-date, with curated comments.
Nice...might want to take what you commonly put in _meta and have it optionally be response headers. I'm personally not a fan of arbitrary envelopes, but then again I understand this is specific to y'all's API.
Oh, the comments are indeed one thing missing from the offline documentation in every other language. I wouldn't call them "curated" though, they're reactively moderated.
That's a pretty good idea. I struggle with where to draw the line on pragmatism vs. strict REST. Including an envelope makes the API more discoverable at the cost of it being arbitrary and less REST compliant. In cases like that, I think your suggestion of making it optional (a la suppress_response_codes) is a nice way of handling it. 
Although closures are pretty awesome too!
First, the obligatory comment: **Never, ever write your own encryption code.** You are guaranteed to get one, or two, or seven things wrong. (Exception: If this is just for learning and you don't plan to actually use it.) From a cursory glance at the encryption class, some observations: * Drop all those odd base64 size calculations. In `encrypt` first concat all in binary, then `base64_encode` *once*. In `splitEncrypted` first `base64_decode` *once*, then split with binary lengths. Rule: Always work on binary data, base64 is only for transmission and presentation. * You need to pad the message on encryption, using PKCS#7 for example. * I guess this checksum thing in your code was an attempt at authenticated encryption, but it is flawed in several respects: a) You are using a simple hash, but you must use a MAC, e.g. an HMAC (which is basically two hash functions). The key for the HMAC should be different from the encryption key. b) You must take the HMAC of the *ciphertext*, not of the plaintext. c) When comparing hashes, you must use a fixed-time comparison. * What's this thing you are doing there with the hash(key . salt)? If this is for password-based encryption and you want to derive a key from the password, then you must use a key derivation function and not a simple hash (e.g. pbkdf2). If it's not for password based encryption, then please explain what it's supposed to do. * You are taking substrings in a lot of places without checking that such a substring actually exists. This will throw ugly warnings and may compromise security (by returning false and coercing in comparisons).
Personally, I love that I can just type php.net/anyfuckingfunctionality and I will most likely get the documentation with only one click. No other language documentation I've seen has been better on that part.
Eh not really. You're just setting dynamic properties of an object. An object doesn't need a static number of properties.
Nice. Should probably automatically load the next Snoo. Or at least change the language of "New Game" to something like "On to the next Snoo!" as a single question doesn't usually fit the concept of a whole game itself. Also, a score tracker. edit - some snoos are normal snoos but make use of background images that don't get carried through by the game
Don't think anything has been explained so well in as so few lines of code. Nice to not have to wade through a 5000 word SEO optimized (i.e. obtuse, verbose, bloated) blog post to actually learn something.
As a user of Google image search, this is the worst thing ever.
To be fair to Wordpress, their roadmap is to support PHP 5.2 until at least next spring, and there's a fair amount of major shared hosts still not offering PHP 5.3.
**Well formatted:** * First their are a short **description** so I fast can see in which order the parameters should be. * Then we have the **parameters** section there I can read more about each param. * The next useful section is **return values**. * Then for newbies we have the **example** section that helped me a lot when I learned PHP. This is the absolutely best part with PHP's documenation * Finally we have the **see also** section that helps me to discover new functions that may solve my problem much better. * Oh and I forgot the **comments** part, the comments also helped me a lot when I stared learning PHP. 
These classes are mainly for learning/feeling out how everything works. This will never be used in a production setting. That being said i do love working on stuff like this, even if it's all for nothing. First, i like the idea about getting the base64 down to once, i'll refactor to work in all binary data till the end, that would also fix the annoying "i need to know it's length in base64" problem. (i'm not sure why i didn't do this in the first place) Second, Mcrypt automatically pads the data with null bytes "/0", should i be padding it with something else? Third, the MD5 checksum was more for data integrity than anything. the "prompt" for this was to encrypt data for storage, and i wanted something to throw an exception if the data was verifiably corrupt. I had heard of the MAC but i could not seem to find any straightforward guides on how/what it entails. Fourth, pertaining to the hash(key . salt) thing. I had partially pulled this bit from a few other examples on the net. The main idea was that the same key was not used for each "thing" i encrypt with this. Honestly i don't understand the 'why' here. Finally, i'll have to go back and make sure i add checks to those substring places. Thanks! Semi-unrelated, what do you think of my use of exceptions vs pushing errors or returning things like "false" or error codes? My idea was to use exceptions for everything and in the implementation of the class, catch them and return a generic "Error" in 'live' code to avoid giving any 'error hints'. Some of my colleagues seem to think that exceptions should only be used in extremely 'exceptional' cases where i like to use them for just about all error handling. Have any thoughts on the matter? I really appreciate all the feedback!
Web files should be accessed by url, just use the relative urls /css etc. For other files you could use \_\_DIR\_\_ if the file is relative to the currently executing file, or if you use a front controller (hopefully you do :) ) then getcwd() will always return that dir as a starting point. &gt;In several different places in my code base, I call Config::read() or whatever without having to require() it first. You should only have to require the autoloader once when your script boots. The several places then all just know how to load classes.
php 5.5 is almost out, if your host doesn't support php 5.3/4 you should really consider changing, theres plenty of options out there that offer multiple php versions with apache handlers at affordable prices
Context here... New project, just starting, no legacy... password_compat is the best choice I'd say.
Yeah same here, love the short tags. I don't really understand why they're so discouraged.
The fucks a snoo?
http://puu.sh/3aFWs.png
Granted, I knew it was from /r/fifthworldproblems, but that's not the point here.
Drupal is nice, but weird. Drupal 8 will be less weird. Make sure you look at community size and momentum for each project. Last I looked at Typo3 I thought it could become defunct. (I don't remember the specifics, but haven't looked at it since). I'm keeping an eye on Symfony2 CMF (content managment framework). I think that project has some killer ideas and since it's symfony2, you can build whatever you want (not that you couldn't with Drupal, or any other, but symfony2 makes much more sense to me, and is quite well documented). http://cmf.symfony.com/ It depends how much you want to roll your own. The only real way to know if it is a good fit is to use them. I would try a rapid prototype in Drupal (depending how far out your projects are and how high your pucker aversion is, try D8), and a few others that you want. Things that look good on paper can be quite different when you start to use them. http://cmf.symfony.com/ if you're interested in trying that.
Autoloader and use __DIR__ - and a little dirname() to move around the file system. Also nicer for opcode caches like APC which have to work a little harder if include/require paths are done relative. 
Good modern applications will bootstrap and load environment-specific configurations at startup and pass a configuration object. You should not be defining your configuration elements as constants.
I would prefer if this wasn't on github but was in a simple PDF or text file or even a minimal HTML page.
The game was inspired by this blog post.
It's also worth noting that DateTime::__construct can parse dates earlier than 1970 (birth dates for example). Strtotime cannot since it returns a Unix timestamp.
What's the difference between var_export, dump_var and print_r?
I never even thought of that; good catch!
This is actually the default in every version of PHP, it's just that some people turn it off. The only difference now is you won't be able to turn &lt;?= off (this won't be covered by short_open_tags), but you'll still be able to turn &lt;? off. The largely irrational thinking behind turning short_open_tags off is that it will save you some hassle when dealing with content that uses &lt;? such as the XML declaration tag even though there are already fairly easy ways to deal with that. Since no declaration starts with &lt;?= it's not deemed necessary to ever shut it off.
The default value of short_open_tags is on, I don't know where you get this misguided idea that it's off on most hosts. The reason it was discouraged was for maximum portability, but that's been a non-issue since PHP4, as it can be turned on and off via htaccess.
There is no point to it in most cases. Some supporters like to think it makes it easier for designers, but if your designer can't learn basic PHP, they'll have a hell of a time with twig anyway. The only time you might consider twig is if you were designing a CMS where an untrusted 3rd party might be sending you code and you want to severely limit what they can execute, but other than that it's a useless waste of processing power.
Just to be clear, templating engines are good. However, twig isn't just a templating engine, it's a *domain specific langauge*. You can have a template engine, and [still use PHP to write the templates](http://codeangel.org/articles/simple-php-template-engine.html).
Not really, he just uses the capabilities of phps array functions ;)
Zero padding is fine, but only if you never encrypt data that ends with zero (null). In addition to nikic's comments, about the MAC composition (encrypt-then-MAC), you must make sure you include all the relevant pieces under the MAC (ie. IV etc). About the MAC compare, I'd recommend that instead of constant-time string comparison, you apply HMAC again to the strings prior the comparison. It does not eliminate the information leakage, but it makes it useless for an adversary. This way you don't have to worry if, for some reason, ever, your constant-time comparison breaks because of some low-level optimization. Last autumn I wrote a small post about [cryptography in web applications](http://timoh6.github.io/2012/08/21/Cryptography-in-web-applications-a-false-sense-of-security.html), covering common mistakes and implementation issues and fundamental problems related to data encryption. You might find some useful information from that blog post. Also, try to reduce the amount of "options" in your system. For example, you are allowing users to choose weak password hashing algorithms etc. This only builds up your code base size, for no good reason. That being said, remember that every line of code is a potential security vulnerability.
String variables and closures - yes, arrays - no. 5.4 (in addition to `$arr();`) also added some new types of string-like callables, e.g. `SomeClass::{"someMethod"}();` or smth similar
Right. If your boss wants you to successfully finish a project he should probably not make you rewrite things that are already tried, and tested, and unit-tested, and established, and documented. Using standalone components is nice too, because they work regardless of the framework, or version of the framework, so they'll stand the test of time much better.
Still don't have slice notation... But bashing PHP in favour of Python here is like banging your head against a brick wall, or trying to argue the existence of God with a devout christian.
Awesome! I read up on MAC implementation, Key-stretching, PKCS#7 padding (pretty simple), and others, and i am going to go redo things (or most of the class). I appreciate the feedback!
Is he using an ellipsis as function name?
Yep! It's the  character. It's not totally portable though so you could easily replace it with: function ___() {return new PartialArg();}  definitely looks better though.
before php 5.4 they were disabled by default, you had to enable them in the ini to work
Now I am hungry
I will confirm that ExpressionEngine can do all the above. Dev time is worth way more than licensing costs. I would also consider PyroCMS though, especially once they move to Laravel.
What you're describing is a multi tenant web app. Single shared codebase with tenant specific configuration to specify look, feel, content etc. We have 110 customers using a single shared codebase where I work - makes rolling out weekly updates very seamless.
how is this different from wrapping it in another function?
That &lt;?php echo $whatever ?&gt; didn't just send something to the console, rather it printed it right into the HTML
Nice article, I didn't know about the differences of those two functions.
What does this have anything to do with PRISM?
Some people mistake their tools for what they can do with their tools. They think that the tool must be perfect. And in it's perfection they too will be perfect. It's the poor craftsman who blames their tools when something goes wrong. And some people just have to have something to hate.
1 - PHP has several problems with language design, core implementations, etc (many of these are legacy-related). It's also easy to get started with, which leads to a community with a large percentage of newbies making silly mistakes. 2 - (a lot of) programmers are elitists, bandwagon-lovers, or just trying to fit in; PHP is an easy target for the things I mentioned in the first point.
PHP gets a lot of flak in general for several reasons. One of the most common is that it has a LOT of functions, some of which are simply convenience functions for something you could do yourself in a few lines of code. Also there are occasionally contradictions between things like order of arguments ( haystack, needle vs needle, haystack ). Up until recently it didn't have a lot of common object oriented support, and the OO it did have did things a little differently and things such as anonymous functions are very recent additions. Also, PHP is very accessible and used by a LOT of people, so it's super easy to find examples of poorly written code and chalk it up as the language as a whole being bad. Finally, it's not a "hot" language by any means, and so there are certain kinds of developers who won't touch it with a 10 foot pole. 
People hate PHP, because they see a language that is arguably worse designed than their language of choice, but is still orders of magnitude more popular.
personallyILove_it();
Thank you so much for reading. And yeah you should always do validation when excepting data from users and filter_var() is very handy.
I hate PHP for not throwing exceptions from it's own functions. This makes error-handling and layering an application more difficult than it should.
Ahead: I'll be saying unpopular things here. Please consider the actual points before downvoting and if you disagree, please do so with a post or upvote a reply that you think explains a disagreement with what i say best. Also please keep in mind that this is my perspective and opinion, i do not claim anything as fact. *** I think the main problem with PHP is that, ultimately, it seems to be a language by [lazy people](http://en.wikiquote.org/wiki/Rasmus_Lerdorf), for lazy people. Now, this in itself is not the problem. [Laziness is a virtue](http://threevirtues.com/). However it seems to encourage a certain type of mindset that results in developers caring less about good design, stability and security^1 than other developers would wish them to. It also seems to lead to a certain kind of complacency. Since quite a few PHP developers will be of a certain lazy kind of sort, they won't seek out other languages to learn. I have known quite a few people who do PHP as their day job. I can group them into two kinds: * ones that dislike PHP, and actually do know other languages with high familiarity * ones that like PHP, but knew no or few other languages with high familiarity The result from that in my experience is that with PHP programmers in the second group i can have less meaningful conversations about generic programming topics because they've simply never worked with concepts that are not present in PHP itself, and on the other hand cannot meaningfully convey them new ideas, like the benefits of functional programming. Also, something people seem to like to ignore is that, while ultimately it is up to the developer whether they write bad code or not, the combination of target demographics in PHP and the lack of guidance towards good code by the core language do have an effect on how the average produced code turns out. (I hope i won't need to explain this, but can provide a more detailed example on request.) *** Personally I learned PHP as my 3rd programming language and used it successfully for 3 years. Then i switched to Perl and have been using it for 8 years with great success and pleasure. Looking back there are a few things that stand out the most to me in what Perl gave me over PHP: * testing and [quality compaigns](http://cpants.cpanauthors.org/author/BARBIE). when i write a web app in Perl all the components run extensive test suites at installation and similarly all my code runs through integration test suite to make sure it all plays well together. this gives me a degree of confidence that PHP simply has not matched yet. similarly there is also nothing like [Perl Best Practices](http://www.amazon.com/Perl-Best-Practices-Damian-Conway/dp/0596001738) for PHP * scoping. with strict enabled Perl has very tight and clear-cut scoping, which means i need to [remember less things](http://www.dailygalaxy.com/my_weblog/2008/04/the-limits-of-m.html) at any given time. in PHP i need to wonder at all times if a variable came from before my current scope with a value already set. * DRY culture. PHP has some sharing of pre-written components, and there is PEAR. however the amount and breadth of choice that CPAN offers isn't there, since PHP as a culture does not have this ingrained urge to identify and release components that can be generalized for reuse in other applications. These are the three main reasons why i personally prefer not to work with PHP. *** ^1 Compare: [PHP](http://www.cvedetails.com/product/128/PHP-PHP.html?vendor_id=74) - [Perl](http://www.cvedetails.com/product/13879/Perl-Perl.html?vendor_id=1885)
Sorry to be picky, but I noticed the same typo in the article - should be **accepting** data from users. Still a nice clear article, though.
&gt; One of the most common is that it has a LOT of functions Not quite. The complaint is that the developer does not get a choice over whether these functions are available in the current scope or not.
Thanks, just fixed it.
&gt; One of the reason why people say Php is bad is because it is a loosely typed language Not at all. Perl, Ruby, Python are well-respected languages with loose typing.
Are you sure Python is loosely typed as well?
To be exact, it has a special case called duck-typing. It is however not strongly typed in the manner that C is.
It's not. It's a strongly, dynamically typed language.
Well, what are you disagreeing with? How PHP enables weaker coders to put together functional web-sites is sort of Zerg-like. Individually, zerglings and hydralisks are weak. They are just mindless creatures. When you have a large number of them though, you are unstoppable.
&gt;Up until recently it didn't have a lot of common object oriented support OO has been supported since php4, though it could be argued that certain features haven't existed for very long. &gt;things such as anonymous functions are very recent addition. No they are not. Anonymous functions have existed in php for a very long time. The newer syntax for anonymous function hasn't existed for very long. Prior to that you had to use create_function and put your code in a string in order to have one. PHP gets shit on because php is largely inelegant, and is designed in a manner that encourages bad programming practices. The pitfall here is that a lot of people write really bad code that works, and then consider themselves awesome programmers even though they really aren't. Other experienced programmers see this and are disgusted by it, and don't want to interact with the community. PHP is hated more because it's a breeding ground for mediocre programmers than anything else. To be clear, you can write really good code in PHP. However examples of really good code in PHP are few and far between.
Emergence is built for this: http://emr.ge
Let's say I want to take an array, map on its contents to get some property, sort them by some function, and reduce them to a value. I have an example in production code of doing this and it's a fairly common pattern, though sometimes done in iterative form instead for various reasons. PHP: $unsorted = array_map(function($x) { return $x['property']; }, $array); uasort($unsorted, function($a, $b) { if($a == $b) { return 0; } return pow($a, 2) &gt; pow($b, 2) ? -1 : 1; }); // now sorted $result = array_reduce($unsorted, function($a, $b) { return $a * $b; }); * Inconsistency in function parameters. `array_reduce` takes the callback second and the array first. `array_map` takes the callback first and the array(s) after to support some strange use-case where you are mapping on multiple arrays at the same time. * `uasort` takes a reference, so you can't be passing its value around. * Since arrays are basic types rather than classes, even if uasort didn't take a reference you would still have code that looked like `reduce(sort(map(...)))` which is hard to read. JavaScript: result = myarray.map(function(x) { return x.property; }) .sort(function(a, b) { return (((a == b) ? 0) : (Math.pow(a, 2) &gt; Math.pow(b, 2)) ? -1 : 1); }) .reduce(function(a, b) { return a * b; }); * Consistent parameter order because arrays are first class objects. * Infinitely more readable * etc
Just to expand on this, PHP started off as a templating language for html, grew into a functional language and then introduced OO. Compared to Ruby or Python; both have been around for at least twice as long as full blown languages, they come from the opposite direction where web based libraries were introduced to them (rails, django etc). Further adding to PHP's misery was the development of WordPress, drupal, joomla, silver stripe etc when it was just learning about objects - and around this it was the easiest free / open language to use. What this meant was PHP gave the world some of the easiest free web apps to deploy and manage, working on coding principles that were incredibly archaic, during a time of the dot com boom and bust where demand for easy, free software was high. This also meant your average Joe with a bit of reading and tinkering could put up a site with minimal fuss. So now a huge chunk of our web is running some really old PHP code, which is difficult to deal with; more in the sense it doesn't follow established patterns laid by more complete languages which many don't want to sort through vs any technical difficulties. Web 2.0 movement really took off roughly 5 years ago, CS graduates found web apps could work with languages and principles they know and now we're in a place where smart educated people can use familiar, tried and tested methods to build applications on the web, after having to deal with legacy PHP for the ten years before that. So yes, there's a bit of a reputation with php that it's slowly shaking off. It's still incredibly popular, making huge strides (laravel, symfony) and hell, Facebook used it for its first couple of years (and still do, kind of). What it needs is people to use it like the OO language is aiming to become, not WordPress or some other legacy code based framework / cms. P.s. I haven't double checked any of my statements regarding timelines etc, someone with a better understanding of the history can probably correct me, but the above is a general gist as I understand and remember it, and why PHP is where it is.
Just use a wrapper that converts errors to exceptions. You can easily find this in the docs for set_error_handler and most modern PHP frameworks do it by default 
Yeah, most of the banner ones say what they are, like Scarlett Johansson was one of them, for reference.
Things like this look beautiful with C# and LINQ since it has nice syntax for lambda expressions. I'd post a full example but I'm posting this from my phone. But for example you'd do something like myarray.Select(item =&gt; item.Property).OrderBy(item =&gt; whatever) 
&gt; a functional language Imperative. Functional is something different.
Hating on PHP is **not** the same as blaming the tool for something going wrong. PHP is an objectively bad language. The fact that you can or cannot do things with said language is ancillary.
When in doubt, cast.
I always thought it was akin to people hating Nickelback - you hear the whiners that just have to put their opinion out there, but the truth is that there are Millions and millions of people who think it is awesome. Do what works for you. 
I work at a company that's a MS House. My last developers meeting was nothing but badmouthing PHP and I felt cornered. I code in C#.NET/VB.NET, but have always found PHP as my fallback when something is either too costly (licensing) or overly complicated (I started webdev with PHP). PHP gets the job done, but as I've said, given I work with other .NET programmers, keeping us all on the same language/framework becomes a necessity. I feel that if I worked in a purely PHP environment, the badmouthing would be very much the same for .NET/Ruby/Python or other popular languages. Another reason I see very little support for the language, in my environment, is the fear of supporting code no one has any knowledge of. Of course, I do, though you won't see me speaking up when a large PHP project loses its key developers. I've got enough on my plate as it is. :S
PHP makes it very easy to do things that work, but are *wrong*. One of the tenets of good language design is that it should be easy to do things the right way and difficult or impossible to do them the wrong way. 
Exceptions should not be used for program flow. They are a lot more expensive than just saying if (x === false).... or if (x == -1) (assuming returning some value).... I think arguably this is one of the areas where Python takes performance hits because a lot of libraries (including their own) throw exceptions for valid things like when a DNS name does not exist. https://gist.github.com/nadams810/5737304 Runs in ~0.12 seconds with throwing exceptions Runs in ~0.05 seconds with returning 0 https://gist.github.com/nadams810/5737324 Runs in ~0.30 seconds with throwing exceptions Runs in ~0.03 seconds with returning 0 Specs: * VM - Ubuntu 12.10 * Python 2.7.3 * PHP 5.4.6-1ubuntu1.2
I thought the function name was i_personally_love_it(). Same function, but the parameters are a completely different order.
Hi, Company I work for also supports big websites in adult industry, such as sexsearch.com (~100 milion users) that also uses Symfony2. We also use Riak as cache storage instead of Redis, because it probe itself to be more reliable for large volumes than the later. Also, Varnish is a very good inclusion in your technology stack to be considered. Cheers,
Your code looks awful in both examples because of the lack of proper line breaks after braces and trying to do everything on one line.
Sometimes, though, [tools can be crap](http://nigelholmes.com/images/useless/hammer1.jpg).
&gt; PHP is an objectively bad language. This "objectively" bad language is making me hundreds of thousands of dollars. Fuck me right?
Which has absolutely no relevance to the discussion-at-hand.
&gt; Also, what the hell is up with all these alias functions? Can we just stick to the one name?! Why the need for obfuscation? Because they are hell-bent on never breaking backwards compatibility for existing code. 
PHP is the C of web scripting languages, including many of the quirks regarding function names and parameter orders people bitch about. Much like C, it is widely available and easily ported, somewhat oblivious to objected oriented programming (at first) and intimately tied to system so that it is both very powerful and very dangerous. Newer developers treat PHP like the C++/C#/Java denizens that came after C, as if it was an inferior and clunky language that would soon be replaced by their favored platform. Except it wasn't; if anything, it's solidified its status as a language of choice for many integral projects, such as the Linux kernel. And the advantage PHP has had over the years is that, unlike C, it has evolved and grown to include features that is previously lacked (like objects and closures) and yet still retains its accessibility and widespread usage. That's why developers giving PHP the stinkeye might as well get used to the fact that its not going anywhere, the language does its job spectacularly well in the right hands.
People will always hate what they dont understand.
It has all the relevance in the world. An objectively "bad" language would not allow someone to earn a respectable living, as it would not perform to the expectations of the clients paying for the services created in that language, because the language wouldn't fucking work. Any other definition of "bad" is purely subjective. Does the language perform as expected and designed? Then it's not "objectively" bad.
I don't think you understand what "objectively" means. For a language to be objectively bad, it must be indisputably deficient, according to a universally agreed upon standard, sort of *a priori* -- which is extremely difficult to do, hence the word "bad" almost always being subjective. We could probably say that any compiled language that cannot be compiled is objectively bad, because it fails to perform the primary function of any language: allowing developers to write programs that run. Short of that, I'm not sure where it'd apply. PHP is idiosyncratic, but then again, so is English -- and it'd be a stretch to say English is an objectively bad language, because there's no universal standard that a language should not be idiosyncratic, and anyway, in both cases, what they lose in consistency, they make up for in flexibility. **tl;dr:** "Objectively bad" is not the same thing as "a lot of people don't like it." You meant to say that it's "subjectively bad", or in other words, you dislike it, as a matter of personal preference.
He means that PHP is going out of its way to do some things a certain way even though it's commonly accepted that it's not a good way to do it.
I make money as a PHP dev as well. In fact I've been using it for 9 years and have a ton of fun doing so. But still: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
I work in a large development group that's about 70% Java developers, 20% Scala and 10% PHP, never hear any badmouthing from anyone. We each respect our disciplines
they dont hate php, they hate the newbs who create monsters using php
Is the `throw`ing part expensive? Of is it the `catch` on the other end that's expensive? I would think doing type comparisons for a specific exception against a thrown object would be slow.
I was waiting for that fractal link to show up. 1.) A lot of his complaints are addressed in later versions of PHP 2.) Several complaints are his own preferences being passed off as standards 3.) He blames PHP for problems it doesn't have for its intended purpose. Threading? It's a web scripting language! It's designed to receive input and return a response! He is also factually wrong in quite a few areas (PHP acceleration is integrated in the 5.5 core and was free before then, his complaints about routing shows a laughable ignorance in how to properly handle them) A common thread with developers from other languages is that they're used to having their hands held throughout by their frameworks which they confusingly believe is their language (Rails is not Ruby!) and don't know how to handle PHP's inherent freedom to both fuck up and create programs that hew to your vision.
TCL isn't popular and I still hate it, because I'm personally forced by circumstance to use it. Nobody hates that which they're not forced to endure.
It's probably been posted many times, but this is still a good read regarding this topic: http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
[strtotime shrine](http://www.strtotime.net/)
Assuming your question is "how do I set up my own website with this source?", you need to set up a web stack locally, or get hosting. If you're on Windows and want it locally, use WAMP. If you're on Linux and want it locally, use LAMP. If you want it online, find a free host such as 000webhost.
2 is the more relevant point imo. Never underestimate the amount of ego any 1 software developer has invested in their way of doing things. Also keep in mind that PHP 'just fucking works', and that shit aint cool. 
What a bunch of bullshit. I'd refute specific points, but really, it's all trash.
This reminds me of a talk I saw in which someone in the audience asked the speaker if they thought CS was an actual science. His response was: You tell me how you define science, and I'll tell you whether or not CS happens to fit within your definition. In this case, it seems you've defined 'good language design' to be that thing PHP is not (in your mind). And that speaks of a bias.
There are many detailed reasons listed at www.phpsadness.com
presumably the reason he provided links was so that you could read over them instead of simply asking him to regurgitate what is already in the links. presumably.
That's because C# developers are like the security guards of programming. They make fun of others to make themselves feel better.
Oh please. The reason I asked is because I read it. In other words, I did not see how he is clueless or barely grasp the basic of OOP.
Agreed. It also sometimes comes from one coder having a fanboy ego and the other programmers around them simply agreeing and going with the flow (that happened at a prior firm I was at a few years ago - one Rails brogrammer was always mouthing off about how Ruby was superior to PHP, but once he was gone, that whole charade stopped). Yes, each language has its pitfalls, but they I am sure are progressing towards fixing them. 
multithreading support.
You wouldn't compare against a thrown object you would catch it. Comparing against returned values is less expensive than throwing an exception and catching it. To answer your first question the one triggers the other - catching construct itself has no effect on code execution (besides maybe adding extra instructions) if an exception is never thrown.
Sounds nice. Your environment is definitely more diverse. While I respect other programmers for their choice of language, I can understand why a team might wish to eliminate the lowest supported language in a group. We have 2 PHP programmers known at the company, or at least that I am aware of, but they're part of a subsidiary that loves to function standalone. Corporate is trying to change all this. Our manager does not want to support their code. It'll get real nasty before things get sorted out. In all of this, I've always been on my own little island of a subsidiary, a one man department, so I've been able to use different languages/frameworks for my code on projects local to my subsidiary. I'm sure it'll all eventually change.
&gt; I agree with your point but is that really a valid argument though? realistically you're never gonna throw 99,999 exceptions. even with a 100 exceptions you're costing yourself a mere 0.3 ms. My example was a simple one yes - however - for a more concrete example in the Django framework [get](https://docs.djangoproject.com/en/dev/ref/models/querysets/#get) query (which is retriving a single row from the database) will throw an exception if the database returns an empty set. Arguably this function should return "None" instead of throwing an exception - an exception should only be thrown if there was a database connectivity issue while it was making the query or some other issue that is non-recoverable (I would suggest this to the Django group - but I've seen their IRC logs and they are not nice people). The problem with this is that, at least in my projects, it is riddled throughout the code and we use for it execution flow - and Django/Python projects for me are already slow. I know there is .filter - which we do use but sometimes I do just want a single row. My example was a fairly useless micro-benchmark (just demonstrating that throwing exceptions does have a cost - even only slightly) but imagining mixing in other code such as database queries that already add latency. In my example Python/PHP may optimize the exception handling (as it's just in a loop), but in a big Django application I believe it may add unnecessary overhead. 
Returning `false` is fine, I think BreiteSeite was talking about PHP functions that throw errors rather than exceptions. These can't really be caught easily.
Yep, where I am now is definitely a good, balanced place that welcomes people who want to learn. Each team has their purpose - the Java devs handle a lot of the more sensitive back end data juggling, the Scala guys have their duties and us PHP devs are the forward facing team. Its good as a PHP dev to be able to hang at the water cooler with guys who cut their teeth when I was in elementary school and learn from them. 
I have the same opinion and if you take a look at the Python [db API](http://www.python.org/dev/peps/pep-0249/#fetchone) they actually say to throw exceptions instead of just returning None (or in PHP - null).
Your Rails guy reminded me a Drupal developer in a team that I integrated once as director to help finishing some pending projects. The guy was all the time mouthing how bad other CMSs are and how good is Drupal. When I started tightening on some specific details to finish a Drupal project where he was the single developer, he simply disapeared leaving the project unfinished. I found that he only knew very basic php, but was very good with Drupal and he was convinced that he could do anything with it without having to code, until he was slaped with specific requirements that he couldnt solve with Drupal features and couldnt find a plugin... so, he jumped the ship. Its a different story, but he was the only bad mouth I had to work with. Fortunately I can pick who I'm gonna have in my team, and I always drop their chances of getting hired on job interviews.
Arguable, but all truth. So widely used, so many people can't be wrong. - this says it all and cuts the chance for arguments.
You're close just grab any td below the tbody //tbody//td[@class="field_domain"]/a/@title Or you can get path the tr as well //tbody/tr/td[@class="field_domain"]/a/@title 
I know the exact type - who become dependent on frameworks and CMSs and don't bother learning the core languages. I don't want to sound unfair, but I blame the "brogrammers" 
You're being downvoted for stating the joke, not because you speak truth.
I'm not going to go on a rampage and list point by point all his errors (which he might've edited out anyway at some point), but when this article came out, **literally** 70% of his points were: "I used PHP pre-5.3 - it was shit then, so probably is now". Oh and for somebody that smart he seems to have an awful hard time at grasping how loose typing works, pointing out "inconsitencies", which in reality were working as intented (and would work the same in other languages like Javascript). And finally, he lost any credibility when he started throwing out generalizations like "all PHP devs are amateurs". Sure, it hurts me a little, but deep down I could agree I still have a long way to go as a developer (and he doesn't? yeah, right). But calling creators of things like Symfony2 and ZF2 amateurs? Please.
This article wasn't bad. A little off topic, but your [sql injection article](http://www.sunnytuts.com/article/php-security-sql-injection) contains an error. Queries like "SELECT * FROM articles WHERE id = 1; DROP TABLE `articles`;" can't ever work in mysql_query() like you use in one of your examples. Ironically, nearly every tutorial on the subject targeted at PHP makes exactly the same mistake.
I think the intended meaning was that Python and Ruby were designed, top down, as fully qualified programming languages with full OOP support. PHP, on the other hand, started out as a templating language and morphed over the years.
Please, go on a rampage. This guy listed point by point of what he believes are flaws on the language. And I think his points are valid. If you disagree, research and criticize. He gave his opinion about the PHP community. He even joined the discussions to defend his position. If you think otherwise, why should it hurt you or even anyone? PHP is the most used language in web development. And as a developer, I should be aware of its flaws that must be address. This post should be exposed and discussed, not burried by thumbsdown.
I definitely subscribe to not reinventing the wheel. I find there is enough invention and innovation in the "glue" just to join all the bits together. 
Plugins can be used such a doctrine which provide great functionality like lambda expressions in c# etc. Frameworks and plugins are at the heart of PHP, that's why there are things like composer
By the way, if you want to improve your knowledge of applied cryptography, I'd recommend solving the Matasano Crypto Challenges: http://www.matasano.com/articles/crypto-challenges/ They'll make you implement about 40 attacks on various cryptosystems, including symmetrical AES encryption, asymmetrical RSA encryption, key exchange protocols, random number generation, message authentication etc. That should give you a good idea of what you have to look out for when writing cryptographic code. Does take some time though to go through all of them ;)
If the two links above didn't change your opinion on the topic, then I doubt anything I say will. As much as I'd like to spend my Sunday persuading a random guy on the internet that another random guy on the internet is wrong, I have more productive things to do, sorry. But I will talk a bit about the flaws. Don't get me or any other PHP dev wrong, we **know** the flaws. We know the API is inconsistent and OOP implementation is relatively shitty. There's not need to point it out for the 100-th time, thanks. Fixing it is not a matter of flipping a switch. it's a slow process that is being done. If you'd spend a little time investigating changes throughout PHP 5.3 to 5.5 you'd know that. And It's not like other languages/platforms don't have their flaws. Java is still missing traits/mixins and RoR is being bombarded with 0-day security issues every month or so, but PHP is the bad guy. Go figure.
More ironically - and sad - is that the articles authors often just rewrite someone else article. They *read* about SQLi and then post a summary. But they never *practise* SQLi. If they actually set up a test site with a SQL flaw, and read a little more about it, they would realize two things: * Stacked quires doesn't work in mysql(i)_ and PDO. (; DROP TABLE `...`) * Worse things then `DROP TABLE `...`` can happen. Hackers can upload shells + download all the source code. (`load_file()` and `INTO OUTFILE()`) 
Good clean explanation, certainly a good deal more understandable than my attempts at explanation :p Forwarded to the PHP developers at my company, always good to know the reasoning behind the answer.
Sure. Fair enough. But out of all criticism I've seen so far about PHP, I think that one is the most detailed. And a lot of them are flaws that I never knew - perhaps for many others too. I don't think many knows them, and just take it for granted. tl;dr after all. I think it's worth pointing it out even the 1000-th times if that's what it takes to get people involve.
I guess so. The inconsistency is definitely a joke. Ha ha.
I really like that idea, thank you!
Thank God for IDEs!
I think the poster just meant functional in the literal sense, not the paradigm
&gt; I think the poster just meant functional in the literal sense, not the paradigm Nice. I never thought of it like that before. Thank you for sharing your comment.
I don't know if I should be offended or pleased, WeAppreciateYou.
Really? I actually got that example from a recent book. I'll have a look at it and do some testing. Will update with a different example. Thanks a lot for reading and for pointing that out.
It's *absolutely* a viable choice for web development, and it's entirely possible to code consistent, well-tested &amp; documented projects using modern programming concepts and methodologies in PHP. As well as one bad reason that it's derided by many (bandwagon hatred), here are four good reasons why it's derided by many: 1. It's a goddamn mess, and refuses to break compatibility in order to reform. The global namespace is a rat's nest, unicode support is strange and inconsistent, function names and arguments aren't consistent, sometimes you get errors and other times you get exceptions in many places it's just plain ugly. 2. Most people who hate PHP formed that opinion years ago when it was much worse than it is now (which isn't to say it's any less of a goddamn mess, but now there are namespaces, lambdas, stronger OO, reflection, good testing/documentation/development frameworks, two large libraries of good code, etc etc). 3. Many (most?) popular open source PHP projects are coded spectacularly, unrelentingly badly; either poorly written or poorly designed. It's hard to defend PHP when there's stuff like Wordpress out there. Supporting or dealing with these projects forms the bulk of most non-PHP coders' experience of PHP, so no wonder they hate it. 4. Unlike some newer, more fashionable languages, or languages that are led by a strong authority, there's little cohesiveness among PHP coders; instead, there are hundreds of minor communities usually organised around specific projects. They're largely siloed and don't present a strong voice, share code, or even think similarly. There's no "Zen of PHP". It seems to me that this is less true that it has been in the past; there's more sharing of ideas and code, and more interoperability between projects and libraries. But we've got a long way to go before we can present a united front. 
'Procedural' was probably the word he was looking for.
I do believe that PHP now supports functional programming though.
Are you saying that PHP has to be wildly over processed and marketed as a sex symbol just to work? Spears may not have been a good singer, but no one bought her CDs based on her voice.
I use php and like it but there are some weird naming conventions where two similar things are named in a similar way.
They still often love to shit on whatever they can possibly find that isn't what they're using.
COBOL and VB6 also make people hundreds of thousands of dollars. The quality of a language is completely unrelated to pay.
I think PHP is as good as the person writing it. I laugh when I hear people say that PHP is "dead". Elitists drive me insane. Since everyone jumped on the Ruby and Python bandwagons, PHP is seen as the bastard language. It's interesting to see those people quickly forget that a lot of their favorite websites are most likely written entirely in PHP. 
I doubt he means that. PHP obviously isn't going out of its way to confuse people; it just wasn't designed in the first place to be as flexible as it is today, so there's not as much order as if it had been.
There is an excellent framework called [Laravel](http://laravel.com)
It is the height of ignorance to accuse a language of inferior quality because it was designed in a different era, for different needs, and by different standards.
Some time ago there was actually a discussion in the PHP community about [frameworks vs. microframeworks](http://www.mwop.net/blog/2012-08-17-on-microframeworks.html) I believe that's worth looking into when trying to decide which way to go, instead of just going with that one framework everybody is talking about (whichever that is, this week).
That was her biggest selling point.
PHP4 release (introduction of classes) 22.05.2000 PHP5 release (rewritten support to better fit in OOP) 13.07.2004
no it doesn't. It supports a few minor handfuls of functional programming features, but it has a long way to go before it can say it supports functional.
I was making this decision almost identically a few weeks ago. Out of the frameworks, and I looked pretty closely for "ease of learning" and "ease of long term use" - mostly. I quickly found that Laravel was great, really great (my favorite of all the PHP frameworks out there, actually). However, a lot of the composer-stuff, command-line-stuff, and generally "getting started" stuff - combined with the fact that L3 is now the "old" version and L4 was JUST released... made me decide to hold off on Laravel, and instead find a few different classes to accomplish what I needed separately. I went with: * [ToroPHP](https://github.com/anandkunal/ToroPHP) for really simple routing. With [Smarty](http://www.smarty.net/) for the templating, this way my business partner can mess with the HTML and not destroy the rest of my PHP =). * [PHPMailer](https://github.com/PHPMailer/PHPMailer) for easy SMTP emailing (with [MailJet](http://www.mailjet.com) handling the hard stuff, of course). * [Valitron](https://github.com/vlucas/valitron) for simple form validation. * [password_compat](https://github.com/ircmaxell/password_compat) for Hashing passwords the right way. * [Former](http://anahkiasen.github.io/former/) for making my forms in nice Bootstrap form markup the easy way (this is used in Laravel, FYI...). Now, this one has some Validation built into it, but I haven't gotten there yet, and I'm fairly certain I need Laravel to really use it anyway... so for now I'm sticking with Valitron above until I do some more investigating... And then I decided to handle the DB stuff myself, since it's a simple build. My next step is to find a beautiful DB class to help me. Although, I'll probably just switch to Laravel by then =). FWIW, here's my simple functions I'm considering for easy DB calls... function fetchRows(){ global $pdo; $params = func_get_args(); $query = array_shift($params); $stmt = $pdo-&gt;prepare($query); $stmt-&gt;execute($params); return $stmt-&gt;fetchAll(); } Called like this: $userID = fetchRows('SELECT id FROM users WHERE email = ?','blah@blah.com'); Anyway, just food for thought. I might wrap that in a class, we'll see.
&gt;silver stripe You just brought back some terrible memories, friend.
you are treating the td as an attribute should be //tbody//td/a/@title
&gt; and still they have a smaller percentage of bad programmers. I'm not going to refer to C++ here, but I will speak about Java. This is simply not the case. And, more importantly, while Java and C++ might be more popular in the case of certain polls, I'll be quick to point out that it doesn't mean there are more Java or C++ programmers than PHP. On top of that, being a Java developer and writing Java code does not in anyway way make for a better programmer. I've seen enterprise level code that is far, far worse than some bad code I've seen in PHP. The difference is the scope. For those enterprise Java developers, they can hide in the enterprise world, shielded by the perception that Java is enterprise ready. And because of that, deficiencies are not the fault of developers. On that note: &gt; In PHP you'll create a security leak when you forget to sanitize your output, something even the most experience developer will do once in a while, let alone the large percentage of bad PHP programmers out there. This assumes you use PHP as a templating language, which is not recommended. This is the same for all languages, where you do not need to use any element of templating. Java, Python, C++: none provide templates. Indeed: In any language you'll create a security leak when you forget to sanitize your output. &gt; However, it is simply far too easy to create bad programs in PHP, and therefore this happens a lot. This is the crux of the problem. You can't have the ease of PHP without the ease of creating bad programs. If it was possible, you'd see contenders for this space. Unfortunately, what we get is Ruby and Python, neither of which have proven they can fill that specific pain point.
There are pros and cons, like with anything. With a framework you're somewhat restricted to doing things the way the framework wants you to do it. For example you might be required to have a particular directory structure. Or you might have to derive all objects from a base object or something. Modules might have to be written a certain way. Then of course the framework itself becomes a major dependency. If you ever need to tweak the core you can, but unless you get those tweaks put into the next official build, any updates are going to overwrite your changes. But there's a nice tradeoff. You have more consistency, maintainability, and less code to write. Many frameworks have active communities of people offering support and plugins and whatever else. Ultimately it's up to you and what you need. But hopefully this reply and the other replies here will help set you in the right direction.
I guess that's why C/C++ don't have any exploits inherit to the way the language operates, especially not caused by [mishandling input](https://developer.apple.com/library/mac/#documentation/security/conceptual/SecureCodingGuide/Articles/BufferOverflows.html). It's easy to be a bad programmer in any language. That's his point, and it's extremely relevant. PHP gets picked on because the number of beginner programmers far exceeds those of other languages. Partly due to the reason you mentioned (it is very easy to create a "working" program in PHP).
You know how I know you're on a "hate PHP bandwagon"? Because you used that page as an arguing point. It has some points, but it is also full of nonsense. There are verifiable falsehoods in his rant.
Exactly. Also, as your second bullet indirectly points out, the articles rarely ever discuss actual server security (permissions, configurations, etc) either.
Take a look at [Voodoo](https://github.com/mardix/Voodoo). It's a new PHP 5.4 framework. Designed to be simple and intuitive. Can be an alternative for those who want a simple MVC framework
I would like to suggest [Voodoo](https://github.com/mardix/Voodoo). It's a modular framework. It also allow the creation of multiple sites (known as application) to share the same codebase. All the sites can share code with themselves, ie: js, css, images etc. So Voodoo may be the right fit for what you want to do. 
5\. PHP tends to be a web developer's first programming language. This teaches them many bad habits that they will almost never correct unless they start developing in other languages and in other ecosystems. 
This thread is an example of the issues I have with most PHP developers. Everything here is factually correct and provable but downvoted because?
No, it's strongly typed. You're thinking of static typing.
PHP closures aren't closures at all. functions aren't first class, partial application and currying is so hacked in, it can hardly be called that at all. Side effects are EVERYWHERE, even in the most mundane operations. PHP was sort of designed with the opposite goals in mind that functional programming tries to avoid. There's nothing wrong with that... just functional is something PHP isn't.
I went to look things up, and it seems that both of us are half-right. :) http://en.wikipedia.org/wiki/Type_system#.22Strong.22_and_.22weak.22_type_systems
I saved the source code here: http://d.pr/f/fD2F
Thanks, I've just signed up for 000webhost. I'm overwhelmed, what do I need to do next? 
http://thenewboston.org/tutorials.php This guy has hundreds of free tutorial videos. You can watch in order or skip around to the topic at hand. He's not the only one. Google PHP Tutorial.
&gt; What this meant was PHP gave the world some of the easiest free web apps to deploy and manage, working on coding principles that were incredibly archaic, during a time of the dot com boom and bust where demand for easy, free software was high. This also meant your average Joe with a bit of reading and tinkering could put up a site with minimal fuss. *So many* many servers are now essentially botnets because of the websites/code people set up after some quick web searching. These folks have no idea how serious this problem is :(
Get your FTP details and download a client such as FileZilla. Put in the details, connect, and drag &amp; drop the files you want into public_html.
This has been asked and answered over and over again on Quora, they ask it pretty much every week. http://www.quora.com/Do-a-large-majority-of-people-hate-PHP-solely-because-other-people-do-so http://www.quora.com/PHP/Why-is-PHP-hated-by-so-many-developers
How skilled in programming are you? If it's a medical system, please do not write it yourself unless you have the skills required to write a secure application. Of course, you can learn by doing. But you'd probably need someone else to at least point out eventual mistakes regarding the security. As a customer, I would not want my medical data hijacked.
I would organize the font like you're doing initially, to put them in a database. That way your uncle can also add comments and other infos. Probaby table like this |id|name|description|type|weight|category|license|filename| |:-|------|------------|-----|--------|---------|--------|----------| |1|Font|Test font|Normal|400|Serif|GNU|fonttest_Rg.ttf| |2|Font|Test font|Bold|600|Serif|GNU|fonttest_Bold| 
I did as you said, but I can't access the website. Firefox displays: The server at awkwords.freeiz.com is taking too long to respond.
learn as many languages as you can. Java, C#, perl, etc... they all let you understand PHP better.
I started off by taking something I wanted to do (simple upload form, web based "notepad", user authentication... etc) and downloading the most basic, stripped down script I could find with that functionality. Then I broke the script down and basically re-wrote it in a way that I could understand. This of course involved numerous trips to the [**manual**](http://www.php.net/manual/en/getting-started.php), Google, StackOverflow, and in the process I learned dozens of functions, better ways to do things, examples of good and bad code, and so on. Eventually when I started a new project I found that I could write the whole thing from scratch without needing a 'starter script'. I'm not a professional developer but I do like writing for fun, so this method worked well for me. Along the way I also made sure to learn about important concepts when developing web applications, things like XSS (cross site scripting), CSRF (cross site request forgery), OOP (object orientated programming), how to use a database (e.g. MySQL) and their pros and cons, PDO (PHP data objects), and a lot more.
Looking at different frameworks and watching them grow over time. I started with CodeIgniter and moved to Kohana, then Symfony2.
I hear this over and over and have never understood what people mean by an IDE "getting in the way". Can you give me some examples of what you mean?
 personallyLove_it($me, $_LANGS['php']);
Except that, depending on the situation, mt_rand() might not have nearly sufficient entropy either. 
Thread from when this was first posted 5 years ago: http://www.reddit.com/r/programming/comments/6k4gz/php_rand_on_windows_vs_true_random_seeing_is/
I'd start with simple programming tasks such as printing numbers in a loop, which have no real purpose. This helps you to learn your basic tools - loops, conditional execution (ifs), functions, arrays etc. After this, try building something (DVD collection management, for example). Everytime you learn something new, rework your code. 
Find an open source project that you like, take it apart, and make it into something new. Futzing with [Mantis](http://www.mantisbt.org/) about 13 years ago got the ball rolling for me. 
Sounds like an error on their end, not much I can do there, sorry.
If you have time, will you please set it up for me? I'll PM you the login information.
I use Zend often, but there are still times when I am building a single script for a simple job, and I use output buffers. 
Generally it's best practice to remove your functions into a different file then include it at the top of the page. In the top of the page I'd put all the dependent logic and then only the templating after that. Dereference your $_GET[] array usage: $Value = $_GET["value"]; this gives you less chances of misspelling it and having to figure out what's going on. Once you get more comfortable with that stuff, then look into "proper" separation of logic and templates. Once you get that, look into frameworks that simplify all of that.
Drupal 8 is based on Symfony2. Rather, it is built upon Symfony2 components. D8 will take several months to stabilize, if you use in production (not recommended) be prepared to stay on top of it, have a good and tested backup solution, etc. My experience with Drupal over the years has been that it gets me close to where I want to go pretty quickly, and then run into something that requires significant work to overhaul, lots of custom module development, etc. It's a trade off - if the out of the box solution and modules solve your problems it's a very quick win. If they don't AND you are not familiar with Drupal development, be prepared for lots of work. For what it is worth, our team recently switched to Symfony2, and it has been fantastic, though we were familiar with MVC, Kohana, CI, Drupal, etc so the transition was not so difficult to grasp. The best thing your team could do would be to contract someone to come in and set up a project with you, and have someone who is detail oriented pair program with them. Or hire someone familiar with whatever framework you choose if you have budget.
I wonder if this isn't due to *nix environments having dedicated devices for this, e.g. /dev/random and /dev/urandom.
TL;DR: Languages like Python or Ruby were designed, PHP just happened. (This is not meant as an insult to PHP, btw)
i'm not sure there is any difference between php and core php. never heard of "core" php. PHP is PHP, PHP has extensions, some bundled with php distribution , some that need to be installed separately. 
I knew you were going to reach for hip hop. They didn't write hip hop because it was too slow, they were scaling PHP just fine. They wrote hip hop because at the size they were scaling, going native represented a real tangible money savings in terms of energy usage. There isn't a scripting language out there that can out perform C++, their reasons for moving would have been just as valid had they chosen perl, python, ruby, et al. But what I do know is that they scaled pretty damned large before they got to that point. PHP: The language that will get you there.
Core generally refers to any functionality that ships with PHP which is not provided by an extension. Any time you use PHP you're using core.
He isn't comparing pseudo-random with true random at all. Software is incapable of making truly random numbers on its own. You need special hardware for that and no consumer grade computer has it. This article is actually comparing different algorithms for pseudo-random number generation, some algorithms do a better job than others. All software oriented random number generators base their value on a seed, and all you can really do is make that seed hard to guess.
I cringe every time someone says "separation of logic and templates" without a clear description of what that means. Most novices take this to mean that their templates should not contain logic at all, which isn't true. Instead, it's a good idea to explain the difference between business and presentation logic. "Dereferencing your array" doesn't give you any value other than typing less. It certainly doesn't defend against typos.
No software based random number generators are "strong". They all rely on generating a "seed" value which is then thrown at an algorithm to generate a series of numbers that appear random. This is pseudo-random which effectively means "not random" for simple functions like mt_rand(), lcg_value() and rand() whose seeds are predictable or leakable. Appearances are deceiving. I can replicate your bitmap for mt_rand() if I guess the correct seed value (the MT algorithm is fixed across most recent PHP versions). The seed value is determined primarily using the current time (seconds and microseconds) and process PID. You can brute force from 1 output value back to the seed value in mere minutes. Here's the longer detailed version: http://phpsecurity.readthedocs.org/en/latest/Insufficient-Entropy-For-Random-Values.html If you use random numbers for non-trivial tasks (e.g. tokens, passwords, salting) then you should use openssl_pseudo_random_bytes() or using a library such as RandomLib which can assess your good options (accounting for OS and PHP version) and then create an entropy pool to significantly increase the cost of even pseudo-random value cracking.
your code on my Linux web-server (debina/amd64/php-fpm) makes beautifully random noise like seen in the random.org-image. did you run your code on windows?
There are some good ones though, such as [Fortuna](http://en.wikipedia.org/wiki/Fortuna_%28PRNG%29).
Even then the movements will not be as random as you think they are. Truly random values are derived from things which have no discernible patterns, such as [radioactive decay](http://www.fourmilab.ch/hotbits/).
I tried setting $value = $_GET[$inputvalue]; and replaced the other occurrences with this as well but it gave a blank output. Which just means I did something wrong and wasn't able figure out what it was. I was able to get it working the lazy way by putting this code in a separate php file, removing all html code that is echo'd in the functions so that when I type url?s="the long string variable", only the variable I needed was printed to a blank page. I was then able to just do: $result=file_get_contents($url); to get my string converted and set into a variable. I know there are ways to getting this simpler, I'm only converting this data one-way so I could remove all the logic to determine the type of input, just use the math formula, and remove error notices on incorrrect input since the original data will always be correct since it's being pulled from openid. One day I aspire to become an "okay" programmer.
Just a few points: - Try and make your variables more descriptive. If I did not look at the actual HTML for the form I'd have no idea what data is being stored/fetched here as neither "ret" or "s" are descriptive: $ret=get_input_type($_GET['s']); Likewise, no idea what $p is storing: $p=strrpos($data,'/') or $a=$item; - Similarly try and make your function names descriptive. If I want to know what the "convert" functions does I have to go through and read all the source code as the name is not precise (convert what to what?). - You make use of two magic numbers: 76561197960265728 and 7656119. If you have to use magic numbers then I'd recommend you store them as a constant with a descriptive name so people know why you are using that specific number. - Don't be afraid to add some white space to your code. You don't need to avoid adding blank lines. If uses appropriately blank lines help separate your code and make it more readable. Just don't over use it and add blank lines every other line. The same goes for spaces. For example: define("MY_MAGIC_NUMBER", 76561197960265728); $profile_number = bcadd( (($data['auth'] * 2) + $data['server']), MY_MAGIC_NUMBER ); $profile_url = "http://steamcommunity.com/profiles/" . $profile_number; Is much easier to read and understand than: $main='http://steamcommunity.com/profiles/'.bcadd((($data['auth']*2)+$data['server']),'76561197960265728'); - You'll most likely be better off pulling all the logic out into a separate file with functions or create a class that handles it. The output from this being just the id, not the HTML so that you can use the id for whatever you want.
I tried to screw around with this a bit, but I really have no idea what to do. How I'm supposed to input it, if I'm supposed to use a string or variable, etc. I'm a complete newbie to coding.
some points: * ereg is deprecated use preg_* functions instead. * SimpleXML isn't simple. I'd recommend learning DOMDocument instead * Don't use @. Instead use libxml_use_internal_errors for XML apis. * You need to reduce the cyclic complexity of the get_input_type functoin... try breaking out parts of that function into other smaller functions. Also you needlessly nest if logic since you return from most of them.
What you want to do it, take what exampled, you will have the function. which will take 2 arugments, a name and a age. use If else such as function checkRights($Name,$age) $rights = "$Name as the following rights:&lt;br&gt;"; if ($age &gt;= 16) $rights .= "Right to Bike Licence&lt;br&gt; "; if ($age &gt;= 18) $rights .= "Right to car License&lt;br&gt;"; if ($age &gt;= 21) $rights .= "All rights for an adult&lt;br&gt;"; return $rights."&lt;p&gt;"; } That would be your PHP function, so to use that you can add th following code before or after checkRights("Bob",12); checkRights(Anita,17); checkRights(Ruben,32); The use of the &lt;br&gt; and &lt;p&gt; tags are yo make you output look nice. I hope this helps.
For small sites, you should go with Slim or Silex. For medium sites go with Laravel. For large sites (and I mean large corporate sites) go with Symphony. Unfortunately, Codeigniter is old and for whatever reason it is barely getting updated, so if you want to dive into frameworks, I would not even bother with CodeIgniter.
This code is from someone else. I was merely repurposing it for steam id conversion rather than a lookup utility. Thanks for the info though, I usually do use descriptive variable names as good practice. 
I use Symfony 2.2. I try to stay as recent as possible. The upgrade from 2.0 to 2.1 is the most difficult in the Symfony2 Versions. I would suggest using the newest since it has the most features and it will be maintained the longest. The 2.3 version is a long term release.
Oh... I stand corrected. I was so used to my own wrapper functions that I had forgotten this. Yes, you still need call_user_func_array with PHP 5.3.x.
Great. Thank you. 
Try /r/phphelp (see sidebar).
First you set the conditions: function whichRights($name, $age) { if($age &gt;= 21){ return $name." is independent."; }elseif($age &gt;= 18){ return $name." can drive a car."; }elseif($age &gt;= 16){ return $name." can ride a bike."; } else{ return $name." is just a kid."; } } then you call each function with the persons name and age: echo whichRights('Anita',17);
It's quite an old article but a most of it is still true. Especially using require() instead of require_once. Another one that a lot of programmers misuse is using a function like count() inside a for loop. You should store the value of count($array) in a variable and use that in the for loop. 
A lot of these have been debunked as false, misleading, or downright harmful, and pretty much all of them are micro-optimizations. You should never trust any performance optimization suggestions that aren't accompanied with profiling results, along with the profiling code and the specs for the test environment.
Obligatory /r/php monthly micro-optimization post. The main reason that I don't like the article is that it is just bullet points but no real in depth explanation of what/why/how.
You can't get wrong with v1.0.
Thanks for the help everybody, it all worked out. Results: http://puu.sh/3cAFW http://puu.sh/3cABK.jpg
It's not just that these post happen all the time, it's that posts like these aren't informative at all. They're claims with no explanations as to why the performance characteristics are as mentioned. If you're an advanced PHP developer, a few of the tips mentioned are fun little reminders, but you learn very little. For people new to PHP, these things are blatantly misleading. To call these things optimization is a stretch. They're micro optimizations and are, more often than not, a waste of time. &gt; $row['id'] is 7 times faster than $row[id] Great. Why? Well, because a string without quotes will be treated as a constant, which requires some sort of symbol table lookup, throws up a strict compliance warning if it's not found, along with a re-interpretation as string literal for backwards compatibility. Or something along those lines. What you should get out of that is that strings should always be in quotes, and that's it. So should you go through an existing code base and "optimize" by replacing all your double quotes with single quotes? Probably not. Shaving off half a milliseconds due to str_replace vs preg_replace is unlikely to add up to any measurable savings. Now, if you're writing new code, it makes sense to adhere to _some_ of the things mentioned as part of keeping up with best practices / a sensible coding standard, but don't get caught up in just following these 'rules' to the letter, and certainly not in the name of optimizing. Code should be clean and easy to read. Developer time is more expensive than run time. Generally, optimizations are needed in database queries, iterating over an object graph or large data structure, assembling output in the view layer, or other larger operations of any complexity. Optimize logic components, not single statements. And above all, if you're not measuring it, you're really just guessing. So use [a profiler](http://xdebug.org/docs/profiler).
Or openssl_pseudo_randon_bytes() to leverage a proper CSPRNG.
Thank you for the detailed explanation. You explained it well.
&gt; &gt; `$row['id']` is 7 times faster than `$row[id]` &gt; Great. Why? Well, because a string without quotes will be treated as a constant [...] To tack onto the problematic nature of the advice: there could be situations where using a constant is what you actually wanted to do, and this in itself would not be a performance hit -- rather, it'd probably be faster (especially if inside a loop), since a constant is as you say a table lookup, as opposed to doing string interpretation on each iteration. But the advice doesn't discriminate, and just plainly says that it's bad. Yes, it's bad if you actually wanted to use `$row['id']` and instead used `$row[id]`, but if you have `const id = 'id'`, then that's a whole different story.
$value = $_GET[$inputvalue] wouldn't result in anything but errors. You would do something like $_GET['value_from_url']
Good to hear. My largest project is still on 2.1 because of the still lingering fear of how upgrading to 2.1 was. Not major problems, but when something goes wrong my phone and email get really busy.
I essentially did that. Is there a technical difference between $_GET['url']; and file_get_contents('url');? Any method more preferable? I've seen some people pushing cURL for doing this kind of work but I don't believe the web host I'm testing this on has cURL enabled.
how come he recommends 2.3 since it's a beta right now?
&gt;PHP: The language that will get you there. Again, I don't think anybody has disputed this. But there exists a point of scale for every PHP app where porting it to another language will give you a clear savings in energy, RAM, CPU cycles, maintenance, or whatever. Hell, porting our relatively simple app from PHP+memcache to Java+Tomcat+Ehcache resulted in needing only 1/12th as many servers for the same scale. Porting to C# gives even *better* returns, if you don't mind paying for Windows hosting (Mono is incompatible with every useful C# library). I don't find Java or C# any slower or more difficult to write than PHP, personally, but then PHP isn't really made *for* me.
[PHP](http://php.net/) is a programming language, used to power about 80% of the internet. [corePHP](http://www.corephp.com/) is a company run by a very nice group of people, who in the past have made some fucking crazy integrations between WordPress and Joomla. You are using PHP.
Please note that the only chapter currently available (on object orientation) is from the middle of the book and as such assumes that you already know about basic extension development, zvals and hashtables. So, if you're new to PHP internals this won't help you much yet. You can find some more "introductory" resources in here: https://wiki.php.net/internals/references
I had some small issues but they happened because I hadn't read the [upgrade guide](http://symfony.com/blog/symfony-2-3-0-the-first-lts-is-now-available). Read that and it worked like a charm afterwards.
http://symfony.com/blog/symfony-2-3-0-the-first-lts-is-now-available
You originally specified a variable inside the get parameter, that won't work. $value = $_GET[$inputvalue]; &lt;- not correct $value = $_GET['inputvalue']; &lt;- correct As for the difference between $_GET() and file_get_contents()...$_GET is used to retrieve values from the URL, file_get_contents reads the file as a string. Basically if you want to get variables from the URL use $_GET, if you want file contents, use file_get_contents()
okay, well the input value isn't static, it's unique to each user. I'll stick with the file_get_contents since I just need to pull data from the body of the page. That is unless I'm not completely comprehending what you are saying.
If you have a url www.example.com?variable=123. If you wanted to pull the value of 123 from that URL you would use $variable = $_GET['variable']; //$variable is now equal to 123 At first you mentioned $_GET and I assumed you wanted to pull data from a URL. However, now that you mention pulling from the body of the page, yes, file_get_contents is what you want.
_Again, I don't think anybody has disputed this. But there exists a point of scale for every [INSERT EVERY LANGUAGE THAT IS NOT C OR C++] app where porting it to another language will give you a clear savings in energy, RAM, CPU cycles, maintenance, or whatever._ 
Maintenance is one of the biggest problems when scaling (size of engineering effort), and neither C nor C++ are maintainable at massive scale. It's all about trade-offs, PHP just doesn't give you anything better than any other language for what you trade away.
Right, like starting databases with MySQL used to make you a shitty DB programmer. 
Okay I gotcha. I still need data from the body of the page, here is an example - http://chainsawhailstorm.com/steamid.php?s=http://steamcommunity.com/id/76561197993371428 there is a s=http://steamcommunity.com/id/76561197993371428 attached to the URL, when entering that in. It will take the data from the URL itself and then convert the 76561197993371428 number from a 64bit id to a 32bit id which gets printed into the body of the page as STEAM_0:0:16552850. I just needed to use the file_get_contents('url'); to pull that "STEAM_0:0:16552850" value from the page after conversion, not from the URL.
&gt; Maintenance is one of the biggest problems when scaling (size of engineering effort), and neither C nor C++ are maintainable at massive scale. sure, because the company that scales larger than any entity on the planet doesn't use C or C++. Making shit up doesn't make you right. and with that, we're done.
[Sara's book](http://www.amazon.com/Extending-Embedding-PHP-Sara-Golemon/dp/067232704X) is also an excellent one on that topic.
Cheers to that.
Ugh. Have you tried working on a C or C++ project with a few dozen engineers under you? The overhead required to get anything safe built is [insane](http://www.stroustrup.com/JSF-AV-rules.pdf). It's every bit as bad as managing a large PHP project, but for reasons on the opposite side of the spectrum. I've gone too far off topic. Sure, you can build things in PHP. But Turing completeness is an awfully low hurdle that says nothing about the actual utility of a language. PHP is a bad language that holds thousands of people back from becoming good at programming. [Here](https://github.com/search?p=3&amp;q=extension%3Aphp+mysql_query+%24_GET&amp;ref=searchresults&amp;type=Code) is a GitHub search that returns tens of thousands of results for hilariously insecure PHP (the "access/delete your entire database" kind of insecure). PHP is a bad language that makes it easy for programmers to do things the wrong way. If you can find a turnkey search string that provides even a single similar result for C# or Java, I'll concede the *entire* argument to you.
When I found out you can extra arrays into vars. So you'd do: $array = array("Waffles","Cats"); extract($array); echo $Waffles; and it would print out Cats. An example use of this is you're writing a function that gets file contents (Adjusted to any php that might run) and you can effect the php. Example Use: function GetFileContent($Path,$Vars) { extract($Vars); ob_start(); require($Path); $Content = ob_get_contents(); ob_end_clean(); return $Content; } and a page you would download example: &lt;?php echo $TheString; then you would do: GetContent("/GetString.php",array("TheString"=&gt;"Cats"); and the GetString.php file would echo "Cats" because that is the value of $TheString that you extracted. Pretty useful if you want to make dynamically adjusting pages.
Said company that scales way larger than anyone else on the planet is still doing it with C and C++. No matter what you say, or what you argue, I'll just keep bringing that fact up as a counter example. It's one of those niggling details we call reality.
Does OOP count? I love OOP in PHP, it's so easy and saves so much time. Although it is like that in most languages. Other than that arrays are pretty awesome as other people have said and there are little things that are nice like the ability to do &lt;?= "Something" ?&gt; instead of &lt;? echo "Something" ?&gt;
Nice resource, thanks!
If you open up the AuthenicatinoProviderManager.php file, you'll see how event dispatch is used. I've included the authenicate function from Authenication\AuthenicationProviderManager object public function authenticate(TokenInterface $token) { $lastException = null; $result = null; foreach ($this-&gt;providers as $provider) { if (!$provider-&gt;supports($token)) { continue; } try { $result = $provider-&gt;authenticate($token); if (null !== $result) { break; } } catch (AccountStatusException $e) { $e-&gt;setToken($token); throw $e; } catch (AuthenticationException $e) { $lastException = $e; } } if (null !== $result) { if (true === $this-&gt;eraseCredentials) { $result-&gt;eraseCredentials(); } if (null !== $this-&gt;eventDispatcher) { $this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_SUCCESS, new AuthenticationEvent($result)); } return $result; } if (null === $lastException) { $lastException = new ProviderNotFoundException(sprintf('No Authentication Provider found for token of class "%s".', get_class($token))); } if (null !== $this-&gt;eventDispatcher) { $this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_FAILURE, new AuthenticationFailureEvent($token, $lastException)); } $lastException-&gt;setToken($token); throw $lastException; }
&gt;Said company that scales way larger than anyone else on the planet is still doing it with C and C++. And they pay the costs associated with that trade off.
As other people have said, please do not write your own code for encryption. There are many instances in programming or coding where I would say, you should write your own code. But this is not one of them, encryption is an incredibly specialized field of work and you should always use whatever is strongest. Not just for your sake but for the sake of the person who's data you're encrypting. PHPPass is a great class for it. Other than that I cannot comment since I don't know much about encryption.
What a great resource. I only looked at 3 pages and I already know its going to be one of the best reference materials an extension developer will have. 
I'm sorry, but... *really*?
http://symfony.com/download i'm the only one who see BETA beside 2.3 version?
Hence the "proper" moniker. Typing less is a good thing, and I said "less chances of misspelling", not "zero".
ya i dunno. PHP as a language is imho fairly useless. I've had a hosting provider for instance have 0 support (until asked) for php xml: http://www.php.net/manual/en/xml.requirements.php its not installed by default when you install PHP. Here is usually a handful of extension _everyone_ needs to get work done. I consider anything for instance Drupal needs for Drupal7 to be core php -- the drupal developers assume a "complete" php install to get most work done.
Drupal. Core modules: Field, Images, probably views. Contrib Modules: Arrange Fields, Display Suite or Fences supports everything else you've asked about. Themes / Sub-themes; admin-only theme, front end theme. custom fields and validation is all in core. Conditional_Fields if you want to show/hide fields for something on condition. Subsites using a kind of OSX installer locations. you can have subsites in a directory; dependancies can be per: installer, all sites, per site.
I don't see a problem with needing to look up the manual constantly. At least you learn how the function works and the exactly how to use it each time. Probably takes half a minute to google it. Not a huge time waster.
... yes. Cache problem ?
seems it's gone? Beta removed? maybe my comment on fabien blog regarding this made sense :) Or the cache issue was only on my side?
Well maybe you were right 6 hours ago :)
yes! i constantly checked it since fabpot announced symfony2.3. saw it's beta and i was wondering how the heck he announced a beta... weird... Thanks!
Have you heard of Laravel? It's pretty good in laravel cases where you need to laravel the la ra your vel to optimise la ra vellllllllllllllllllllllll la la la l alallalalglalalllaravellaravellaravellaravellaravellaravellaravellaravellaravellaravel
constant table lookup is really slow in php, absolutely slower than string constant
Mine was a random &lt;topic&gt; changer, it picked from a list.txt that the owner of the website would maintain manually. I got paid $80 for writing it..
i get random noise just fine, so i assume its really windows specific, anybody using IIS for php production sites? i hope not
My first was a tipping website. I still use it to this day! It's really horrible procedural/inbred html type site but has barely shown a bug in 10 years. Have been trying and trying to rewrite it for years but haven't had the time (or incentive when it works well).
My first project was for a college where I had my internship. The college had various web applications with Oracle user credentials, but used LDAP for network authentication. I created some technology to pair the two for application security access without duplication of data.
Mine was a portfolio I did for myself. I'm currently studying web development so I had to a PHP project during my PHP module. It just allowed me to upload any other projects I had completed, you could search for projects by the coding used within it or you could search a date. Also linked my twitter account to it so you could see top 3 twitter posts I had tweeted. Was ok. 
It was an XML parser which would read in the contents of Sophos Virus Threat alerts XML document.
My first PHP project is the one I'm currently working on, it has been quite an uphill climb. It's a web application that allows users to interact with high voltage transients on power grids. It's highly proprietary, involving bushing couplers and high level calculus. Going pretty well, learning a lot about security and such from this experience. I'm doing the PHP, an electrical engineer is doing the calculus and other power related stuff (I don't want to get on top of a transformer). 
I made a website for my Quake clan, back in 1999 with a news system, guest book and integrated qstat so that we could see who of us were playing. I had previously used server-side HTML - so PHP was very dreamy at the time.
I had this wooden roulette game where you spin a top and these little wooden balls go into different holes. Each hole had a number on it and you got points for getting balls in these holes. You would take turns spinning until a player reached a certain score and won. I had no one to play with so I had the idea that I could build an app where two people could start a game together online (assuming they each had one of these game boards) and input their scores when it was their turn. I failed miserably and it barely worked but it was an educational experience. *thumbs up!* 
a CMS without a backend, super simple to use, I should update it.
A much easier and entertaining way of breaking down what he's talking about, watch this video. All western music follows a similar sort of pattern. Ever listen to a song and say, "hey, that sounds like X"? That's because chordal structures in pop music are quite similar. I V I vi V I. https://www.youtube.com/watch?v=ne6tB2KiZuk&amp;feature=youtube_gdata_player
I ran a torrent website which was based of the torrentbits source code. Started when I was 13 and just learnt through modifying bits of the code (if you want to give yourself a headache, take a look at the source).
My first PHP project was the college project, we had to learn the basics of PHP. File editing, multi user dynamic login system, basic login system, file reading, etc. I ended up making it into a full blown website with password reset and stuff. When I look back on it now the code disgusts me but I guess so is the way of coding.
You know what, it was split() that was deprecated. As you were.
You should be able to do a find and replace fairly easily. Take a look here: http://blogs.msdn.com/b/ssma/archive/2011/06/01/migrating-a-php-application-using-mysql-to-sql-server-running-php-on-iis.aspx
OSCommerce modifications. Made a shipping plugin edit that allowed 0 or negative weight items to be considered non-shipped items that didn't impact the total weight of the order. This led to purchasing training seminars and candles all at the same time without having to ship a training seminar in a box.
Jason?
In 1999, I was working as a web developer doing some HTML and graphics work. My boss said we needed a company intranet site, and he gave me that project. There were options to buy at the time, but building it was good experience to get me into PHP. I spent about 4 months on the initial revision and it actually came out quite nice for a first project. It was a lot of fun because I was learning new things, and being that this was a small company and it wasn't customer-facing, I could really play around and have fun with it. I'm pretty sure I'll never have another opportunity like that again.
Modifications to the core of phpBB 1.x for a client so that posts in their classifieds forum would have a strictly defined layout. Those were the days...
I did some tutorial to get the basics, after that my first small learning project outside of the tutorials was a blog script that retrieved and stored data in a mysql database. This was back in 2002. I expanded on that project by adding authentication to the post page, then sessions, then a comment script, then user accounts. I still have the code, and it's horrible. mysql_result for ever single field, I had no idea about variable scope and wrote a ton of functions with huge lists of global at the top etc. It is what got me into programming though, so I'm still very glad I wrote it.
I built a site called mediasnitch(.com doesn't exit anymore). It scraped album release dates and alerted you when an artist had a new album coming out. It was pretty cool but the scripts for scraping the data were a nightmare to stay on top of so I let it die. That was 2001 
My first site was for a local electronic band, that had a guestbook (remember those?) and would send out emails when a new entry was made. And forget about a database, it used files for storing those entries.
Robert?
6 months ago a customer told my company to "look at this website. i want this website" The website was yelp.com I was tasked with basically making yelp.com out of php
Building a Black Friday app in 3 weeks for my company. Hah. 3 weeks of studying PHP and web developing, and failing miserably at building an MVC. Luckily, I got it to function and didn't lose my job!
my first real php project (aside from a guest book or contact form) was a collective buying site. (teambuy.ca) learned a lot since then...
Back when webcam images didn't stream but updated every 15 seconds or so, I built a script that would watch the webcam/s of my choice and automatically archive the pictures so I could see a full history of images I would have otherwise missed due to sleep or work.
Collaborate. Work on open source projects. Read other people's code. Have people read yours. Be open to criticism.
LOL. A bug tracker. From scratch. For Atari. 
A script that translated a string to Pig Latin.
You should put up a donation link, or at least try to get it crowd funded, I'd pay. This is very much a needed book, and it would be great to finally have up to date internals documentation. A book that takes a developer with an intermediate knowledge of C obtained from the numerous existing good C resources to making their own PHP extension would be amazing.
A custom shopping cart done in php 3.0.4 in 1998. I don't remember the exact site/product line, though...
A shoutbox! 
That actually sounds like a reasonable way to learn about string parsing and manipulation.
Do you have any sort of coding background? I came from C and VB so it made for a smooth transition.
None. PHP is my first run-in. I learned html and css first, but as far as programming, this is it. 
There's no shame in slowly making progress! It all depends on your experience with coding in general. Don't feel out of place because you're not learning it as fast as you want to. It takes years to get to a level where coding concepts are fully natural to you. Read books! I feel like books are a great way to learn instead of the quick and small tutorials spread around the web. Books give you a structural way on learning your language as well as explaining concepts and keywords. As long as you're eager to learn there's no stopping yourself from doing what you want to do. And yes, eventually everything will fall in place and make sense eventually.
Thanks for the encouragement. Yeah, I am reading books, taking it very slowly, and working through the small projects. The thing that scares me is sometimes I will debug something that will take me 20 minutes, and then the next week I will have the same problem and forget what I did to resolve it! I'm thinking, "man, since I can't remember that, maybe I'm not cut out for this." But I guess it's just takes a ton of time to internalize these things? 
Well you know what they say, if at first you don't succeed, just give up and watch tv! Seriously though, here is how learning programming in general, and php specifically works. You start of with you hello world. Then keep adding feature until you get pissed off at how poorly you designed the whole thing. Then you burn it down, and start over. This time incorporating all the new stuff you learned along with way with the new stuff you want to learn. Then you keep adding features until you get pissed off at how poorly you designed the whole thing, burn it down, and start over. Repeat until you never program ever again. I've been programming for years, and I still have to reference the manual every day, and that is ok. It's what the manual is there for.
In 2001 I made a social network so that my friends and I could keep in touch when we went off to college. Never considered the rest of the world might be interested in such a thing. Two years later... MySpace [appears and everyone has to have an account]. Second project was the backend for a ATM card kind of like the Rush card. 
I came from C# and a few others to PHP, took me about one weekend to fully understand the syntax of PHP and how it works. I can't help that much since It was so long ago that I was new to code its self. But I remember just scrapping together what I could from different tutorials, in order to make what I wanted. Then over a period of time I slowly started to understand it (This was learning C#). Just stick with it, don't quit early on you will make it. You shouldn't be comparing yourself to anyone at the moment, let alone experienced programmers. Keep making stuff you WANT to make and you will eventually get the hang of it.
You're doing fine.
&gt;I could really play around and have fun with it i keep a side project for this purpose. sometimes it feels good to try new things and have the freedom to do what you want. it keeps me fresh and excited about programming.
Laravel laravel laravel laravel laravel. Laravel laravel laravel, [DAE Laravel?](http://www.reddit.com/r/phpcirclejerk)
I thought he was comparing against random.org which uses natural input (atmospheric noise) to generate random number generation. What is psuedo about using a natural source or randomness?
If you don't stop learning at any point, that is what you will feel for the rest of your life as a developer. Things I do today are no way near what I've done 4 years ago, not to even mention 7 years ago. And in that only a small fraction is about the language, but most is about the web stack, from html/javascript, libraries, frameworks, daemons; etc. We are in a time when technologies advance so rapidly that you can't even take a breath to catalog their evolution. As seeing another comment of yours, not remembering how you solved something a while ago is no big deal. Shit, I can't remember what I've worked on last week, not to mention how many times "cryptic" errors have troubled me, until I can with 90% accuracy predict the bug that causes the error. Good luck!
Ok. I'm wrong... that's fine. I find interesting when people post their opinions and back them up with their "Resume" as pure reality and point other's opinions as simply wrong... and more interesting is the way they totally discard the possibility that such opinions may come from somebody with bigger Resumes... Using just one article to back up an opinion is definitely for sheep minded people, since there can be also an infinite number of other articles that can say totally the reverse. In the end it's all opinion, as anybody else can have their own, the author of "your" article in my opinion doesn't have an open mind towards PHP as it may seems, and his criticism doesn't come from a neutral point of view but rather from a biased one, that takes him to look at the things that he sees as bad, skipping many good ones. I could write here other points that would make you question what you just said, and maybe open your mind to look at different perspectives and see that actually you are not so right or I'm not so wrong as you may think. However, a person that jumps pointing others wrong like you just did, without even trying to understand what they mean and without looking better into their statement that actually if he did maybe even finish agreeing with it, such person is definitely not open to conversation, but rather just here for ego boosting or self affirmation. So, sir, I know it is not possible, but it would be great if I knew who you are to avoid crossing professional paths, as my experience through years lead me to avoid to work with such people as I find them "closed mind and unproductive". And I stand for my previous comment... as I'm not the type of sheep minded person that changes his opinion based on somebody else's opinion backed up by small amounts of biased information just because they have big resume. My opinion is changed through time as reality takes me through its path! 
PHP is simple - it's the application of PHP that gets complicated. The important part is to understand things on an atomic level. Once you know that, you can start looking at how the parts come together. It can be extremely overwhelming at first - just remember: It all makes sense if you break it down far enough. Being a competent PHP programmer is mostly just being a competent programmer in general - you need to learn a solid repertoire of techniques and know how to work in various environments. Understanding OOP and MVC and knowing how to work with frameworks are just as, if not more important, than remembering $needle/$haystack orders.
What year?
Which is perfectly doable, feasible, and quite reasonable.
Yes, this is normal. I started learning PHP almost 10 years ago and every time I write any code in it I still have to keep the PHP function reference constantly open for what should be basic things, like arrays.
I agree with the "atomic" level. To me, it just seems like a bunch of small pieces/skillsets/techniques merging together, and if you can learn those well and keep things organized, it will be okay. And commenting a ton. I am learning basic php/mysql right now, and am then planning on Codeigniter to learn MVC ( i understand the reasoning behind it). No idea what $needle/$haystack orders are lol
Thanks so much, I've been feeling a bit like an imposter when I program. The more I do it though, the more I think it is just important to have a vague idea of "how" to do something, and then look it up, rather than just be able to memorize everything perfectly and drill it out real quick. 
Thinking in code took me years. You sort of just do it, go through the routines and just "look the part". Then once in there long enough, you start getting the feel, getting familiar. Its like going to a new city. Once you start connecting roads together, finding your way around, it starts making sense.
2001 I think? Right around there... It started when the company was still calling itself Infogrames.
My apologies, I stupidly assumed you meant for the Atari console, during the 70's (pre-php). Accept some of my cake as an apology :)
No problem. I stake my claim to have worked at Atari as a matter of honor - I did work for a long time in the game industry - but my web development experience does not go back *quite* that far. :)
My first project (circa ~1998) was an online application that polled Counter-Strike (beta at the time) servers to show current player stats, player names, kills, deaths, and various ratios based on that data. I used PHP 3.0.9, I think, which didn't actually have support for UDP sockets, only TCP based sockets. So I wrote a C application to handle the actual polling of the server (at the time I didn't know how to write a PHP extension) and then used system calls to the application to pass the data into the PHP script itself. It ran real time so it was very slow. I also made some additional changes to the code to cache and save the player names in a database, and store total number of kills and deaths and displayed them on a site. Like an early gametracker. I sort of wish I would have stuck with it, but I lost interest and it was eventually replaced by some server admin modules that made some of the reporting much easier. My first paying gig was modifying the FishCart ecommerce application. The site owner approached the guy who wrote FishCart and had asked him originally to do the work but he declined due to moral reasons (the site was porn). I wrote their entire back end order processing application that created PDFs for their fulfillment center to print off orders, package them using a packing list, and put the label them for shipment. It also marked the orders as completed and notified the customer of their order status. This was back in the libpdf days, when creating a PDF wasn't terribly easy. I got paid REALLY well for that. tl;dr; games... and porn.
It's a learning process! Take your time. Try to do very small projects. Find a good book to get you started. Generally, as far as I know, PHP isn't taught as a first programming language. Java and C++ are pretty typical to learn in school as a first language, so there might not be as many resources to get started.
Thanks for the link, i didn't realize that was a "thing" in web dev. Good to know I'm not alone. 
My first real project was an internal web application for the company I just had joined, back in early 2001. The main part of the app was the employees management, plugged to our LDAP server. It handled contact and pay data. It also stored data about every projects and customers. People were able to log the time they worked on each project, and we could generate and send bills to our customers in a single clic. In time we added various crap such as an interface to our NNTP server, an internal chat/IM thing, an RSS reader that kicked ass for years before I find anything better. I stopped working on this application around 10 years ago, but the whole thing is still running, and the pay and charging-per-project parts are still heavily used. We greatly upgraded the DB server and plugged a reporting tool, for better project management KPIs. Looking at the changelog right now, I'm shocked to realize it went through many big PHP upgrades (almost every minor from 3.x to 5.4) without much changes to the code : * 9 lines changed when automatic GET and POST variables extract()-ing was disabled * 37 lines changed to our DB abstraction class to switch from mysql_* to mysqli_* * 69 lines changed to our DB abstraction class to switch from mysqli_* to PDO This is just the bug-fixing. There has of course been many other changes in the code, but mostly based on a clever DB-abstraction/ORM-like thing I made and used to build everything upon. I would never have thought this app would still be online (and myself still in the same company) 12 years later.
It was something about statistics from user-{username}.txt file. These user files was generated by my IRC game on same pc. Nothing fancy but it was visited by 10-30 users. 
it's a thing in life, actually, not just web programming :-) .
You assume much about me! Just because somebody says something is bad doesn't mean they are biased against it. What if I told you I arrived at my conclusion after much objective and unbiased experience (hence the "resume" inclusion)? My opinion of PHP is formed entirely from years of PHP enterprise development reality taking me "through its path". In my experience (with PHP and many other languages -there's that resume again!) PHP doesn't offer any feature that's better than every other language. Everything PHP is good at, I can point to another language that does it better. Your mileage may vary. &gt;So, sir, I know it is not possible, but it would be great if I knew who you are to avoid crossing professional paths, as my experience through years lead me to avoid to work with such people as I find them "closed mind and unproductive". I've interviewed hundreds of software engineers and only one PHP zealot has ever made it through the process. I think we're safe from each other.
Go to Project in the menu and uncheck Build Automatically. ...And yes Aptana/Eclipse will leech all of your physical memory for its search indexing at some point, some time. ...If your project has a lot of files.
I don't know where did you get the opinion that I'm defending PHP, or that I'm a zealot... You are the one assuming to much. I'm only basing my self in everything that you said. Now point me where did I say that PHP is better or worst? Over all I was just saying that I find you a person with strong opinion, and opinions are just opinions. In my opinion, PHP is just another languages, has its ways, and it is just different. If it's better or worst, that is relative to each person that uses it, from a coder level. Now what I find is that many people want to turn it into Java, or Python, just because they find it better, but why?? don't we have those already for coders that like and are comfortable with them? I'm not here to boost my ego with my resume, but I have made dozens of Enterprise Level Web applications with PHP for more that 15 years... as I have also made with Java, Python, Perl, and even C++... I chose the language according to a set of conditions and requirements, and never worked on a project that I regretted my choices, either it was with PHP or any other language. If it was the tools that defined the success of a project, we wouldn't have today buildings that were built thousand of years ago. And try to understand one thing: I was not saying that you are wrong, I was just sharing my opinion, and I understand yours because I can also look from the same perspective as you. But maybe if you look at things from other perspective too, you'll know that many times people are not wrong as you may think. Opinions are just opinions, always relative to each one's experience. I'm not saying you are wrong because according to your experience you are right, as according to my experience I'm right to... so before jumping into pointing somebody as wrong, get on their shoes first!
My first 'real' project was the final project for my PHP class. It was a simple blog system with a user permissions system. My first REAL project, which is ongoing, is a designed-from-scratch Roleplaying website.
Same here. And our entire dev department.
That is already unchecked... It keeps "refreshing workspace" and make it hang... the project is not extremely large, but there are a ton of images inside the project folder.
1) Yes, there are colors, this is how it appears on the new "Darcula" theme: [Screenie](http://puu.sh/3dxoW/008eb6d001.png) 2) Yes, it supports passive FTP, SFTP, SCP, and FTPS. 3) Yes, The project I screenshotted has about 700+ files and it indexes in under a minute on a network share (obviously this matters by the connection type, it's your typical internal connection (100mb/s)). 4) Yes, native jQuery, JSON, JS, HTML, CSS formatting and color support. I would absolutely recommend PhpStorm. Edit: details
1) PhpStorm allows you to customize every single aspect of code highlighting in the editor. I've finagled mine to look similar to my old Atari's BASIC :D They have a bunch of pre-defined themes, and you can download more from the user community too. 2) Yes, it supports PASV FTP. 3) I'm currently working on a Moodle project that includes 34, 426 files. It runs smooth as silk. 4) It does a great job on JS and HTML5. It also has a bunch of code libraries built in that you can choose to include in a project's codebase &amp; libraries including JQuery, and it not only handles JSON just fine but they've just addded [a pretty spiffy little REST client](blog.jetbrains.com/webide/2013/02/using-the-rest-client-within-phpstorm/) to boot. The developer and user communities are both hugely active, and very responsive. Developers communicate with bug report filers regularly (two of my reported bugs have been fixed!), tech support is fast and helpful, and the user forums are great too. The documentation is *superb* - it is easy to search and super well written. One of my favourite features is the fact that the menus, commands and configuration options are searchable from within PhpStorm! Saves me so much time when trying to track down a setting I changed and need to change again a few weeks later on!
Hm you could also try doing a Project -&gt; Clean operation. I used to be a PhpEd user but because I needed a portable IDE switched to Aptana. I also tried PhpStorm in the past but could never get used to the UI.
Mine was a simple webapp that allowed you to run SQL commands on a google spreadsheet
Have you tried Craigslist? I see PHP jobs here in Seattle on Craigslist.
I used aptana for 3 months, it was the required IDE at the company I was working for breifly. Aptana is bloated as fuck, and you can feel it in everything you do. When I do my morning pull from the master branch, aptana provided me with a nice 30 minute coffee break. Scrolling through a 1,000 line file was like pulling teeth. Where SVN Commit takes seconds to run, committing in aptana takes 5 minutes. It's not like my computer was slow or anything, I had a top of the line Optiplex. 12GB of ram. Nothing should be that slow on that computer, especially not some glorified text editor. Now I use Kate, and it's great. It's "just a text editor", but there's tons of actually useful features, no bullshit. Sure, I need to use the command line for SVN/GIT/HG. Also there's no error checking, tab autocomplete, inline PHP docs, or integrated interpreters. But that's why you have a web browser, and a development environment. 
Sounds like you have a lot of projects in your Explorer. Close the ones you don't need by right clicking and selecting Close Project.
PHP was my first language, and I had no education on coding at all when I picked it up, I still have no idea how I landed the job(and I was honest in the interview). So I can say I know how you feel. My first few months were terrible, concepts came slow and were quickly forgotten, its like being dragged through the ringer, but I'm sure this is everybody's first coding experience without formal education. Here's the good news, it will get better, just keep at it and you'll find that things that were taking days to debug or get right a month ago come easy and can be accomplished in minutes. Its been a year since I first wrote "Hello World" on php and there are still challenges, but I've discovered that is just programming, you are a problem solver and if you dont like that aspect then programming really isnt for you. What I found helpful was the college level java classes I've been taking. The concepts are what make you a strong programmer and a formal eduaction in OOP has gone a long way in helping me write PHP. Stick in there, you wont regret it!
Craigslist or any kind of local listing is going to give you the best bang for your buck. It's easier to prove your skills in a face-to-face context (IMO), and you aren't competing with people from Bangladesh asking for 5.25/hr If you still want to look online, remember, "English fluency" as an account detail is a red flag. Again, the more localized, the better. You can't compete with people who's cost of living is 1/50 of yours.
[It sure does!](http://phpstorm-themes.com/theme/dreamweaver/)
Are you looking for a remote or local position? I'm a PHP dev and I use LinkedIn to post my skills and let recruiters come to me with their open positions... Granted not likely to find a start up this way... There are small "indie" agencies that I get contracts for on occasion... But note, I live in a major metro... Farmtown USA might not offer much... If you happen to be in the Minneapolis / St Paul area, I could get you bombed with contacts / perm roles from recruiters.
I'm not in a tech hotspot so unfortunately I'm somewhere on your Bangladesh spectrum. If you are in The Bay Area saying "I have 10+ years experience pay me $250K", I'm elsewhere saying "I won't move to The Bay Area but only want $150K"
I'm closer to Farmtown. LinkedIn mostly gets me recruiters who want to relocate me to SF, but it is a good one I forgot to list. There is some stuff a long commute from me, but I mostly look to remote for really interesting roles.
This may not apply to the US - but if anyone's wondering this from the UK, get your CV onto as many websites as possible. I left University because two companies setup interviews with me, and I got a job on the first interview. Honestly, no word of a lie - I have had phone calls every single day since then (6 weeks ago) or emails, asking if I'm available for an interview or talking about an available position. I'm sorry if this doesn't apply to the US. (These are entry level positions, 18-22k GBP UK)
URL shortener! Turned out pretty well.
You might just need to relocate because maybe there aren't many PHP jobs in your area. Or, you might need to pick up other web programming languages and branch out. It's just the way it works out there in the web dev landscape.
Well if you find a good company offering multiple remote roles then let me know, I can never find remote stuff... Which doesnt make sense... Seems to be more cost effective having your devs work at home where they pay for their costs and dont force you to have a big office space and you just mail them a check... I personally get more stuff done at home locked in my office then sitting at work next to the sales guys... You can try setting your title on LinkedIn to "PHP Dev | Looking for remote work only, No relocating" and see what happens... I usually have to set a custom title when Im in a contract just so recruiters leave me alone til Im ready to get the next one...
A shitty portfolio using includes. I'm a little better now
None of the below ;) (RE @Vangar, @ratpoisOn, @iliketurlesyay)
Finding a job with just PHP today is a hard sell. Do you have other skills to supplement? I started out as a PHP developer, but my employer was willing to pay while I tackled the javascript to node curve (previously only having the standard jquery background). Now I do both equally, and have a contract gig maintaining a PHP legacy system.
* Do blocking work in the background This is huge. Too often I see people doing really stupid things that cause the active connection to hang and remain open while the server grinds away on some task. This is a pretty good article, and if you're looking for ways to speed up your application the advice here is sound (even if some of it is a bit obvious).
Unless you just posted your first form to an email the day before, as I had done.
I also forgot to mention the customer only paid for 4 hours of work to build this. The reason this happened was a gross misunderstanding of what he wanted and a gross miscalculation of the time it would take to do that. Not to mention he kept adding things he found from other websites he wanted to add in. In fact, the entire project started off by him saying, "I want a store locator for my website".
Will you move at all?
As a partner in a reasonably new company trying to recruit a decent developer I am feeling your pain from the other side of the fence. I don't know where to advertise to attract the right person. Gumtree (we are uk based) seems to only attract foreigners and while I don't mind that I just don't know where all the British people are hiding! Sorry not trying to hijack your thread but if anyone is local to Edinburgh, wants to work on a brand new project with symfony2, twitter bootstrap, jquery etc and get paid 20-25k per year let me know :)
At my last company we attempted to hire off Craigslist. It's not something I'd ever try again. The applicants seemed sub par and limited English. Also a lot of them needed Visas.
Any criticism that isn't accompanied by helpful tips for improvement raises a red flag for me. A flaming red flag with a troll logo on it. OP: (I assume you're the author) your project is a great idea. There's actually some momentum gathering behind a community-driven caching interface standard over at the [PHP-FIG mailing list](https://groups.google.com/forum/?fromgroups#!forum/php-fig). I think a project like yours would benefit greatly from the ideas being tossed around there.
Haha, no no I know it can. It was just very poorly thought out. The directory works now, although there's tons of redundant coding and poor methods being used around every turn. But what can I say? It was my first project. Since then, I've moved onto using CI for a large internal system for my company. I like mvc better. 
What's wrong with PHP includes?
You're right, [igorw](https://igor.io/) is a [troll](http://yolophp.com/) who has [contributed](http://silex.sensiolabs.org/) [nothing](http://stackphp.com/) to this [community](http://reactphp.org/).
Nothing at all, it's just the only bit of php I used.
Oh, tips? OK: [In this particular case the code base consists of ~~a single class of 1800+ lines with only static methods~~.](http://www.phptherightway.com/) How's that?
mktime() is surprisingly useful and clever. This example assumes $hour, $minute, etc, have been set previously, or are (most commonly) something like date('j'), date('n'). mktime($hour, $minute, $second, $month, $day, $year) is the usage, and all of the values are integers. Note: the order is stupid. But being integers, mktime is oddly un-fussy about how it takes them, and will work out what the result is no matter how stupid your numbers are. mktime($hour+100, $minute-14, $second+90000, $month, $day+365, 1847) The above is entirely valid and will give... I don't know. Some time in 1849? mktime(0, 0, 1, date('n')+6, date('j'), date('Y')) That will give you a time exactly 6 months from the start of today. It will figure out correct month and year, etc.
Oh, you said "using includes", I though you implied includes were bad :P But yeah, I've been there, includes were do-all-be-all back when I learned of them.
Ah, okay! But what if each font is in its own folder? For example fonttest/fonttest_Rg.ttf
I've actually got a system exactly like this I'm working on for PHP API docs (using ApiGen currently, but any docs processor can be dropped-in). If you'd like to collaborate, that would be cool. For end-user docs though, [rtfd.org](https://readthedocs.org/) is a very good solution. ReST docs are a bit more flexible than Markdown and are still human-readable without being processed. The Zend docs use it, and I've used it in a couple projects with great success. I think the first step in the PHP world is easy and automatic API docs. Developers need to start there before they move on to comprehensive end-user docs.
Shameless plug right here: http://www.shutterstock.com/jobs.mhtml?jvi=oKexXfwc,Job We are remote dev friendly. It's largely becoming a recruiters market, even if it is internal recruiters. The good ones don't bother with Dice or Monster or the big sites. They look for the language specific sites and actually do research. For example, look at who is talking or attending trade shows.
I didn't say he was a troll, and I know exactly who he is. I implied that his comment was trollish, because it was. Might be news to you, but no one is infallible, and just because he's active in the community doesn't make his comments immune to scrutiny. In fact, he's usually very helpful in his comments, but this is not one of those times. Sorry if that observation offended you.
Great resource; horrible presentation. How's that?
Dude, if someone was paying me 150k a year I would live out of a fucking shoe box AND move there. 
In the process of learning PHP, I wrote plenty of HTML pages with variables for the date, or includes, etc. My first actual project however, after I messed around to get a feel for the language, was a message forum. It was a major project, and it took long enough that once I had a half-finished model of it, all of the original code was garbage, so I went back and started from scratch. I'm on iteration 7 as of when I last touched the project. Iteration 5 or so was 90 something percent finished when I scraped it. Still have a working copy on a test machine (but the DB is probably gone). The project wasn't beyond my scope, but the fact that I kept scrapping bad code slowed me way down. While I've gotten better about it, I still have to watch out for this on projects, where I will get part way through but want to restart because I don't like how I designed the groundwork. EDIT: I should note that I started iteration one back when I was in 7th grade. When I say I worked on the project for years, I continued working on it through high school.
A lot of good info. Two things I wanted to add: * Make sure that your server is sending cache control headers for every single thing that doesn't need to be refreshed with every page load (this isn't entirely specific to PHP, but it *so crucial* for making a website experience faster. [Here's](http://www.webscalingblog.com/performance/caching-http-headers-cache-control-max-age.html) one article about it. * Use a good template system (Twig, Smarty, etc.) and use their cache feature (HTTP caching mentioned in the article is great, but limited to static content). On my websites, I try to make every page possible cache their output and use the cache whenever possible instead of generating the page again (you can intelligently cache based on cookie values, etc., and also you can have your database write operations clear related cached pages). This is the #1 key that I use to make my websites super fast and able to handle massive traffic.
I'd have to disagree with you. It all depends on what the company you work for thinks about working with the language and how modern of a code-base they have. If they are starting from scratch and want to jump on the trendy bandwagon, then you're right. I think that having the smarts to work on complex php projects, even monumentally large code-bases puts you in a good position to move up the ladder. The key is keeping good contacts, keep your linkedin profile uptodate, add relavent recruiters to your contact list, and all shall be fine.
Anyone else is using [Resque for PHP](https://github.com/chrisboulton/php-resque) mentioned in this blog post? It seems very straightforward and easier to use than *MQ solutions.
&gt; I implied that his comment was trollish, because it was. Fail. His comment is nothing but serious.
What a waste of money for buying a domain.
Replace filename column with path. Put all the fonts in public_html/fonts And fill each column with Fonttest/fonttest_reg.ttf
I'm sorry, as much as all the info is very good, I can't get over this part: &gt; When Mozilla shaved 2.2 seconds off their landing page, Firefox downloads increased 15.4%. &gt; Shopzilla saw conversion rates increase by 7-12% as a result of their web performance optimization efforts. &gt; Making Barack Obamas website 60% faster increased donation conversions by 14%. Really? All those places did nothing else other than changing their response time? I'm sure Obama didn't run a campaign, shopzilla did no adverts and surly did the shaved time have an impact on people looking for a faster browser ...
Not in the bay area it isn't.
Recommending autoload AND opcache? Ehe. Calling for a disaster. 
I love ReadTheDocs. Our PHP project, Novius Os, uses it for all its documentations. The principal issue with RTD is its poor documentation (like we say in french "cobblers are the worst shod"). But when you got it, it's a very good service ! Readthedoc is not made for self-extracting documentations like PHPDoc/Doxygen. An RTD's equivalent for self-extracting documentation of PHP projects would be an excellent idea.
Either you're on the wrong side of the world or you are not good enough yet. Source: http://mjs.me/gX 
Database import. Running unit tests. There's no lack of excuses on that front :P
There's nothing wrong with this imo. It's used a lot for OOP.
Here's a similar thing in PHP, which has worked well for me: http://simplehtmldom.sourceforge.net
[Glob.](http://php.net/manual/en/function.glob.php) *Find pathnames matching a pattern.* I fucking love this function. 
We've released Bolt 1.1, as the first major update for Bolt, since our initial release in February. This recommended update contains a whole lot of new functionality, together with iterative improvements for the current functionality, as well as slight changes to the look and feel of the backend. The complete list of changes and improvements can be found on our website. If you're just curious about how it looks: We've updated the screenshots on both [the frontpage](http://bolt.cm), and [the screenshots page](http://docs.bolt.cm/screenshots). 
I don't know a lot of CRM tools but as I work at a French Web and Open source agency (TALCOD), I do know well CiviCRM. Customers are quite satisfied with the management tools we build and base on it, so it could be a great tool to suggest.
For stats keeping, user management, etc, PHP is more than enough. If you're looking for realtime number-crunching or game-world management, something like Python, Node (Javascript) or Scala may be a better fit.
The effect of loading time on sales and conversions is actually well documented by both Google and Amazon. Google found increased search volume and Amazon found increased conversion rate from even 100ms decrease in load time.
It doesn't help that the linked page throws an error.
Sorry about that, I was tweaking the posting, and I missed an escape in a Twig tag. It's working now. 
We are in the same boat except we're in Yorkshire - we use a variety of agencies, and almost every candidate they send us is awful. We've now started sending candidates a short aptitude test to complete before it even gets to the interview stage, just a very simple task to demonstrate that they can code in an OOP style, and half of the scripts we get back don't even run. The latest submission contained no classes, or even any user-defined functions! So yeah, not trying to hijack your post either, but we are also offering full-time positions working on a fairly large Symfony2 project, though you must have good experience with PHP5 and OOP.
Yes, I can see Google doing A/B testing (as they've done it in the past) but Mozilla / Obama? Not so much.