Are you hosting the videos yourself or just linking to, say, YouTube?
Because hosting video is a pretty big undertaking. Embedding is definitely the way to go up front. But just in terms of class structure for a video, it might be easier to just go with an off-the-shelf ORM solution that will reflect database tables into models you can then interact with directly. For example, [Propel](http://propelorm.org/documentation/03-basic-crud.html) is a great library to get started with. I recommend a well-tested library because when you're dealing with a database, there's more than data upserting and retrieval to consider. There's also security, and something like Propel will that have kind of thing built in.
Long run you'll probably be happier with objects - at least I was. Here's a contrived short example that will hopefully illustrate the point. Lets assume that you have the ability to mark videos as deleted. Deleted videos can be identified in the database using `select * from videos where is_deleted = 1`. Now, lets assume that there's an admin page that shows all of the videos for a user and denotes deleted images by adding a `deleted` class to the div. &lt;?php foreach ($videos as $video): ?&gt; &lt;div class="&lt;?= $video['is_deleted'] ? 'deleted' : '' ?&gt;"&gt;&lt;?= $video['title'] ?&gt; &lt;/div&gt; &lt;?php endforeach; ?&gt; Later, you decide that simply tracking `is_deleted` isn't enough, you want to add other statuses like draft, published, deleted, in_review. You drop the `is_deleted` column and add a status column. You'll have to change everywhere that you've used the `is_deleted` offset in your code to look like this: &lt;?php foreach ($videos as $video): ?&gt; &lt;div class="&lt;?= $video['status'] === 'deleted' ? 'deleted' : '' ?&gt;"&gt;&lt;?= $video['title'] ?&gt; &lt;/div&gt; &lt;?php endforeach; ?&gt; If you had been using oop, you'd have done something closer to &lt;div class="&lt;?= $video-&gt;isDeleted() ? 'deleted' : '' ?&gt;"&gt;&lt;?= $video-&gt;getTitle() ?&gt; &lt;/div&gt; Your method on your video object would originally have looked like: function isDeleted(): boolean { return $this-&gt;is_deleted == 1; } With your change, you'd update it to look like this: function isDeleted(): boolean { return $this-&gt;status == 'deleted'; } You won't have to change anywhere that relied on the `isDeleted` function. This is called encapsulation and is one of the main principals of oop.
Not sure if you're the author but "Eich Brendan" should be "Brendan Eich" ;)
There's more to OOP then grouping all your functions under a class. It is really hard to understand until you see it in action. Do some research on design patterns, and the SOLID pricipal. I think those may help it click for you. I know you probably don't use Laravel but laracast.com has some great videos on OOP SOLID Design patterns etc. It's only o bucks a month and we'll worth it. Here's a link to the OOP series https://laracasts.com/series/object-oriented-bootcamp-in-php
Little bit confusing. The article states that php is a frameworks then goes on to say don't use frameworks. So the takeaway is to not use php? You should also consider linking to some full blown production ready php application repositories that were created using the principles stated in the article. Always good to show some code.
I've finally have had some time to flesh out more of this library and brought it to a point release. I'm guessing you're part of Sabre based on your name, and I do like the library -- nice and fast and makes XML an afterthought. I am still using the Xml\Service functionality, but still only for deserialization. I've abstracted out a few methods that may of be use to more than just me into a common abstraction... https://github.com/SellerWorks/amazon-mws/blob/master/src/Common/Serializer/XmlDeserializer.php Which lets me simplify the concrete interfaces to a simple map of objects to closure generators... https://github.com/SellerWorks/amazon-mws/blob/master/src/FulfillmentInbound/Serializer/XmlDeserializer.php The library is very fast, although I haven't done any real benchmarking. I have a feeling it would be my previous implementation using simplexml and mapping everything within the serialize() method. I'm a fan of using an external serializer/deserializer/iterator/etc. Again, assuming you're **the** Evert Pot, thanks for the work on your end!
It's possible i haven't worked with docker enough to see the value. But we had a guy here at our office write us a basic anisble server deploy. From there we've added 5.6, 5.7, and 7.0 as other options. We modified the exisiting setups to support them. I'd say we haven't stress tested them as much as he did initially with the 5.6 deployment but over all it's been a good set up to manage multiple servers with different configuration files. As long as the anisble scripts understand the new configurations it's all good. I've heard good things about docker and server set ups.
Pretty straight forward: Don't use a framework on top of another framework. I happen to agree. Not many industries go posting their full blown applications on public repositories, this is hardcore experience!
You're going to love what I'm working on.
I'm betting hardcore oop folks might just vote this site down out of insecurity.
My development system still uses a Ubuntu 14.04 LTS version (support until 2019-04) with PHP 5.5. A 16.04 reinstall is on the to-do list, but I didn’t find the time yet. There is no more official support from PHP core for this version, but there is ongoing support from the Ubuntu package maintainers. The release/EOL schedules between packages (PHP) and distributions are not in sync anyway. Just because of this, there’s always naturally an adaption period of one or two years after EOL until old PHP versions truly disappear. That’s just how it works. Old versions are always still around, and there’s always a new version on the horizon. Where you make the cut depends on the context you’re working in. It’s fine to use PHP 7 features if you can afford it. It’s also fine to use only 5.4 features if it makes sense for you.
I don't think it's easy to understand OOP (or any programming concept really) until you've struggled with the problem it solves. You don't need to use OOP (or anything really) to achieve a technical goal, but rather you can use it to better organize your code. So it's not like "Oh I need to interact with a database so I better use OOP here", but rather "Oh, I have all this code all over the place and now there's a new business rule I need to implement and I'm not sure if I found all the right places to change". Here's an example where I think using OOP would solve a problem you might run into. You say that you have video info stored in the database, for example: id, src, title, desc, and category. Maybe there's a form where users can add new videos. For example: save_video_to_db($_POST['title'], $_POST['src'], $_POST['desc'], $_POST['category']); echo 'New video saved!'; Simple enough. Now let's make sure the user entered the required information: $errors = array(); if (empty($_POST['title'])) { $errors[] = 'Title is required'; } if (empty($_POST['src'])) { $errors[] = 'Video Src is required'; } if ($errors) { echo 'Please correct the following errors:'; foreach ($errors as $error) { echo $error; } } else { save_video_to_db($_POST['title'], $_POST['src'], $_POST['desc'], $_POST['category']); echo 'New video saved!'; } Nothing too crazy, but what if you want to do more things? Like make sure the category is one of your pre-approved categories from a master list? Or that the src doesn't already exist in the database? You can keep adding functions there, but over time it will get real messy. Also if you have some other place in your site that saves videos (maybe an administrative dashboard for bulk uploads by you, which is different from your end-user form where customers only upload one at a time?)... now you have to copy/paste that code a bunch, or have a bunch of functions scattered about. Here's where OOP can come in. If you group all the data and functions having to do with videos together, it helps keep your code cleaner. For example: $video = new Video($_POST); if ($video-&gt;isValid()) { $video-&gt;save(); } else { echo 'Please correct the following errors:'; foreach ($video-&gt;checkForErrors() as $error) { echo $error; } } //Here is the class (probably keep in another file to get out of your way).... class Video { public $title; public $src; public $desc; public $category; public function __construct($post) { $this-&gt;title = $post['title']; $this-&gt;src = $post['src']; $this-&gt;desc = $post['desc']; $this-&gt;category = $post['category']; } public function checkForErrors() { $errors = array(); if (empty($_POST['title'])) { $errors[] = 'Title is required'; } if (empty($_POST['src'])) { $errors[] = 'Video Src is required'; } return $errors; } public function isValid() { $errors = $this-&gt;checkForErrors(); return empty($errors); } public function save() { save_video_to_db($this-&gt;title, $this-&gt;src, $this-&gt;desc, $this-&gt;category); } } It's a very simplistic example, but hopefully you can see that things are better organized with the class. It makes it much easier to maintain in the future because you can just update things in the class and then wherever else in code you're using that functionality, it will be able to utilize it through the class. It also lets you separate concerns better... like, the portion of the code that retrieves the user's input and decides what to display to the browser doesn't really care about *how* exactly the data is saved or *how* the errors might occur, rather it only cares if there are errors or not. Whereas the code that deals with the video data does in fact want to know all about how it saves to the database and how errors might come about, but it should not care at all about how those things are communicated to the user / web browser. So really, this "separation of concerns" is the most important reason to use OOP. It's not a functionality thing -- anything you do with OOP can be done without it -- but rather it's about organizing your code better to keep it more maintainable in the long run. Hope that helps!
Honestly, I was expecting the domain to just redirect to https://github.com/WordPress/WordPress
My fault? Cause I wrote that code 4 years before I was hired? Also well known by who? It's not mentioned anywhere in the documentation for that function...
Well said!
Yes I'm sure the most successful php script of all time is "the wrong way" because you personally don't like procedural code.
This article calls out laravel as well as every other general purpose framework. Maybe read more than the domain name next time?
&gt;PHP on the other hand was created from the beginning by Rasmus Lerdorf as a set of tools written in C that would enable you to easily and quickly develop dynamic HTML. As such PHP was, and still is, a framework in and of itself. While PHP is a framework in and on itself, as *such* framework it doesn't even come close to Ruby on Rails or Django when comes to building a website with set of tools, as author indicated beforehand. &gt;In the world of Python and Ruby building websites from the ground up is tiresome because neither Python nor Ruby was originally created to build websites. As a result general purpose frameworks such as Django and Ruby on Rails quickly became popular for building websites in these languages. &gt;PHP on the other hand was created from the beginning by Rasmus Lerdorf as a set of tools written in C that would enable you to easily and quickly develop dynamic HTML. As such PHP was, and still is, a framework in and of itself. Sure PHP on itself offers more than Python and Ruby for a quick "hello world" page. In fact I have done a few. But, if you want maintainable, reusable and sensible structured code for slightly advanced website...you are bound to end up with something that is similar to framework. Either developed by yourself or by using the set of libraries. PHP frameworks started as a response to Rails, or rather inspired by rails. &gt;Some companies began listening to the hype about PHP frameworks and they started their next projects using one of these popular general purpose frameworks only to end up in a disaster. They not only discovered that the general purpose framework was really bad at solving their very specific need, but it was also extremely slow in doing so. It was impossible to scale and as a result they started ripping the framework apart in a desperate attempt to pull out all those things they really didn’t need. This I agree with. But what author is really saying is that instead of using **general purpose framework** you should build your own tailored to your own business needs. Which is true but also very different from the initial sentiment "Don't use framework". In addition: not every business can afford an application from a ground up, especially in PHP. You would need good set of very skilled developers and then think of future and maintainability. &gt;Some companies began listening to the hype about PHP frameworks and they started their next projects using one of these popular general purpose frameworks only to end up in a disaster. I've seen both cases. Where company starts to develop their own solution then they end up with legacy code developed by 10 developers with 10 set of different approaches with end result looking something that sort of looks like a framework that is hard to maintain or upgrade ...and it is just a Jeb... a mess I mean .
Shit, I hate the factory pattern so much. I want to shit in the mouth of whomever even conceived of it 
I hate when people encapsulate what is clearly a structure. They will religiously put a getter and setter for every variable with exactly zero code in any of the getters/setters that does anything but set the named variable and never ever will do anything else, ever. 
This has made my day! Love this comment! 
Works great. We PR into master, `docker-compose up` runs which uses the project's root Dockerfile to build an image and related services (mongo, redis, what have you), tests get ran, if pass build docker image (sans dev deps), tag with short commit hash, upload to registry. Our production environment is a Deis cluster (some deployment management and routing goodness ontop of CoreOS, essentially ECS before AWS offered it), so we just in ops just run `deis pull registry/image:stable` and X amount of instances spin up, requests bleed off the already running instances, and requests start routing to the new instances. Development environment? `docker-compose up`
I love how the few crybabies who have shown up are trying to select the edge cases that support their framework as opposed to this guy's point which is that most of reality doesn't fit the framework's talking point view of the world. 
ExtJS is a giant bloated pile of shit. I don't know how many classes it has but holy shit they are intertwined and there are certainly hundreds. Worse than that, if you follow their guidelines, you will certainly generate hundreds of your own classes that inherit from their shit classes. I know that this whole thing is about PHP but the reality is that most frameworks blend both the back and front ends. ExtJS is a very expensive example of a silver bullet. It will get you a prototype in a shockingly short time, but you will never finish the product you intended, you might finish but it will either be a buggy mess or it will have given in and be something that ExtJS wanted, not what you or your customers wanted. 
Other than the permalink system and the generally poor quality you see in 3rd party plugins and themes, Wordpress isn't too bad at all these days. Sure it's not the prettiest or fastest but it gets the job *done* 
Ahh, yes.. Libraries. I do use plenty of libraries. For tasks like generating a PDF, I would never want to start from scratch. A library to connect to my database though? No thanks, I'll work my PDO magic myself. 
[Please create responsible tutorials](http://i.imgur.com/86lonXv.png).
I think a lot of people is sadly going to completely miss the point of the author. A lot of this stuff doesn't matter for small sized websites (except for security, that always matters of course), framework, no framwork, OOP no OOP, etc., which properly constitutes about 60-70% of all PHP websites in the world. If all you have ever build are small to even average sized websites, you're most likely not going to understand this and you're most likely going to respond with objection. And maybe you don't need any of it. But this site is about hardcore experience and I believe it's trying to get a point through for the inexperienced before it's too late. Maybe you'll learn these things the hard way, as most of us do, but if you can save yourself some real pain understanding these points before you get yourself into trouble, then it's worth its weight in gold. 
I want my DB library to send my SQL out, and have table-ish stuff come back. 
There's nothing intrinsically wrong with procedural code, but that's not what WordPress is. WordPress is a staggering monolith of global state, which is unequivocally bad. 
I think you're misunderstanding the author a little bit, he's not criticizing OOP or frameworks per say at all, he's criticizing when these gets promoted in an extreme way as the only way to do things. That's why the titles says "Always use OOP" or "Always use a framework" as being wrong, not simply using these things generally. The site is against the extremism we so often witness especially in the PHP community about these things. And about producing packages etc., that's exactly what the author is promoting in what he calls libraries. This is not bad. I love it too! I hope I have the time to contribute, this is a great service to the PHP community.
The truth is that most PHP developers are pitiful hacks and since they are scared to death someone will find out how little they actually know they hide behind overly complex frameworks.
We use Docker for just about everything. Can't speak highly enough about how its allowed us to improve our workflow and ability to get things done and onboard new people. I have an internal scaffold for new projects that sets up the base project along with sensible defaults for Docker and Docker Compose (along side our extension for Docker Compose for our Kubernetes stuff) It's just ludicrously easy to get into production these days. 
Having a setter means that you can add validation. 
You're right, those absolute statements are extreme! But who says that? I never see people who say that so it seems like a strawman argument. I wonder if I've simply grown blind to that kind of thing precisely because those statements are bullshit! I wish the site linked to articles that say that stuff.
&gt; A library to connect to my database though? No thanks, I'll work my PDO magic myself. You realize PDO is a library to connect to your database, right? 
Good article. I liked the section on programming history. How programming languages evolved from unstructured -&gt; structured with control flow constructs -&gt; procedural -&gt; OO
Ok, couple follow ups. 1) WP to me seems to be more functional programming with some special WP objects. So, in a pure functional environment, are all functions at the global state? If so, does that make functional programming bad? 2) I understand that having less in the global state is a good thing, (well, I don't 100% get it, but I'll take the word of smarter and older programmers than I), but, if a frame like WP isn't stepping on itself, or isn't polluting and confusing globals in the global state, is it still bad? To me, it seems like if you want to work with WP, you just have to do it the WP way, and that is just how it is. Just like any other framework, if you want to use it, you have to use it the way it is supposed to be used. Right? 
Disagreed with the author that PHP supports functional programming. It does not. Functions are not first class citizens, and the syntax needed to bring externally scoped variables into lambas is downright clunky. Also, that gorilla banana jungle quote is getting obnoxious. Been writing OO code for a long time now and I don't understand the problem that analogy is referencing.
And a getter means you can apply some formatting in a single place instead of the 300 different places the property is accessed from.
&gt; WP to me seems to be more functional programming with some special WP objects. So, in a pure functional environment, are all functions at the global state? If so, does that make functional programming bad? I'm not sure what you're talking about/saying here. My issue is **not** that WordPress functions aren't in a namespace or a class (well I dislike that also but I could tolerate it). The issue is that WordPress functions access implicit global state. This actually violates one of the sacred rules of pure functional programming languages: I.e. that functions are a "*function*" of their inputs. What this means (a so-called "*pure*" function) is that a function provided with the same arguments **must** return the same value. For example, here's a pure function in PHP: function add ($x, $y) { return $x + $y; } I can pass it 5 and 3 this second, the next second, and twelve years from now, on my computer or my friend's computer, and it will **always** return 8. Why? Because the return value depends only on the arguments to the function: You give it the same arguments it returns the same thing. Here's a non-pure function: $global_state = 0; function add ($x, $y) { global $global_state; $global_state += $x + $y; return $global_state; } If you invoke it with 5 and 3 it returns 8, just like before. But what happens if you call it **again** with 5 and 3: You get 16. Same inputs, different output. This is the problem with WordPress. A great many WordPress functions go out to implicit, mutable global state and the result of calling that function depends on not just the inputs, but also that implicit, mutable global state. This makes it very hard to reason about what functions do. If you call a certain function, what does it change? Does it save something to the database? Does it change the "current" post? You have no idea because it can just opaquely go off and grab those things and mutate them. Under a more functional (or more OOP) scheme you'd be able to better reason about the code because you'd have to provide all the things the function depended on. You'd know (for example) that a certain function doesn't save something to the database because you never provided it an object or argument through which it could access the database. You no longer have to be concerned that it sneakily goes off and accesses the database even though you never gave it a mechanism to do that. &gt;if a frame like WP isn't stepping on itself, or isn't polluting and confusing globals in the global state, is it still bad? Of course it is. When everything implicitly depends on everything else, how do you isolate something to test it? If I write a WordPress plugin that uses the functionality that WordPress provides (which is cobbled together on top of a mess of global state) how can I isolate my plugin and test it to make sure it's doing what I want? I can't. I have to spin up an entire WordPress instance, make sure the database, configurations, et cetera are just right, run my one test, and then repeat the process (because the test may have gone off and mutated any arbitrary piece of that mass of global state).
They just don't think about it. Or, rather, they think in patterns. There is a pattern: use prepared statements to prevent an injection. So they do!
Exactly. Not to mention that there are extremely lightweight frameworks (Slim and Lumen), that puts all argument of framework being restrictive and bloated (framework on top of framework) as bogus. As someone who worked on the the in house solutions and as mentioned...you will eventually end up with something that looks like framework, but 10 x worse with 10x more time invested and 10 x harder to maintain. Put that in front as a case of any bushiness and they will tell you to go with framework. Unless you can really justify the cost and time benefits long term that they are ready to pay. Almost every work that I was hired to worked on their in-house solution I heard this "In retrospect we should have gone with [framework] but we are stick with this, so now we have to live with it". On a second read, I missed this part too. &gt;It was impossible to scale and as a result they started ripping the framework apart in a desperate attempt to pull out all those things they really didn’t need. This sounds more of a wordpress than any modern framework out there. I don't known what is there to be rip apart in Lumen or Slim for example that hinder your project so much and that you will not build yourself anyway if you are building some mid to big, scalable and maintainable solution. ..and if they did [hinder your project] then your requirements from the start were wrong. 
 $testStr = '&lt;p&gt;This book is blablabla &lt;/p&gt; or even &lt;div&gt;&lt;b&gt; This description is&lt;/b&gt; blablaba &lt;/div&gt;'; $libxmlOldErrorValue = libxml_use_internal_errors(true); $doc = new DOMDocument('1.0', 'utf-8'); $doc-&gt;loadHTML($testStr); libxml_use_internal_errors($libxmlOldErrorValue); var_dump($doc-&gt;textContent);
I work a lot with WordPress and I really don't mind other programmers calling the WP core shit because it is shit. It's slowly getting better though.
Since it seems that you are unaware of paragraphs, I'm scared of the possibility of having to read your code.
those quotes by rasmus are bothering me for a long while, but im going to spare the trouble expressing myself and move on.
Well Tom I was on mobile at the time but I must have struck a nerve. 
I'm not sure where they encountered the extremism either but I'm sure it's out there if you are involved in online discussions. [this is the guy who made php](https://www.youtube.com/watch?v=DuB6UjEsY_Y) talking about frameworks. This was before laravel so I'd like to think that it has dealt with some of what he doesn't like. I know Jeffery Way has mentioned on Laracasts how things that he teaches goes against best practices etc. [here](https://laracasts.com/series/learning-vue-step-by-step/episodes/3) at 3:40 I've also seen a lot of railing against the fig on here when people were leaving them. I honestly don't care about any of it. I have to balance things between being able to understand them and see the usefullness of doing it a certain way and just focus on getting stuff done. I work on older code a lot too and I'd love to see more OOP and namespaces but i'm not re-writing it. I just plug my nose and dive in. 
Thanks for great article, for most of the things i can say the same. 
I'd drop the "Essential PHP security" link from the reading section. While this book offers some good basic information, it leaves way too much unsaid (which is in part understandable as the book is 10+ years old) and in addition, it also gives some bad advice. For example, see the crypto section or password handling or randomness generation. That's something we must know better today. (I didn't review the book, just a quick look)
If you think the only problem with wordpress is procedural code you're a pretty naive programmer or know nothing about wordpress. There's nothing wrong with procedural code when it's maintained and written by competent people. Wordpress has neither of those strengths.
Your examples prove my point - programming is subjective. You might think the star wars prequels sucked but I loved them. As long as something works, everything else boils down to semantics and a dick waving contest.
A general purpose framework needs a lot more "seams" than an app connected from already individual components. This is because popular frameworks are an explosion of contradictions. A general purpose framework wants to be rigid and "enforce" its architecture upon you. Yet it also wants to be as configurable as possible, *while still enforcing its architecture upon you*. Frameworks do this with a mountain of configuration files, conventions and hooks, that are layered on top of a rigid architecture. The end result is *complexity*. *"For every 25% increase in problem complexity, there is a 100% increase in solution complexity." (Woodfield 1979)* A general purpose framework is purporting to solve *everyone's problem*. It can't be simple by definition.
If you have the answer, you could also provide one and state why the others are unsafe. That way if anyone else falls onto that question they have a valid, secure answer. One less place for people to fall into the trap of a bad resource online.
If you think ad hominem attacks with no actual substance to back up your claims proves any kind of point, I'm afraid you're the naive one.
I think you missed the entire point of encapsulation. Maybe read up a bit on it? What you're talking about is an anemic (domain) model. This is not what encapsulation is about. Encapsulation is more about hiding the implementation and data that resides within the object. So if you have `getName()` you can change the way it formats the name without any of your code having to change. In fact most of your code shouldn't care how it is formatted as long as it abides by it return signature.
I've seen people using it for such things and like I said its basically a wrapper around LXC which is a wrapper around cGroups which is a stable technology which has been around for well over a decade so yes I would say its 'stable' because of its underlying technology. I haven't seen anyone do a large scale deployment of it in my area, I've freelanced for many dev teams who have used it alongside Vagrant for local dev environments but in production it still seems that the VM is king. Docker uses less resources but you loose the flexibility of OS changes which most large scale deployments do need that low level flexibility so its all about trade offs. LXC is a great technology so in time I think dokcer will surface as the dominate force but like cGroups, Jails, Zones, OpenVZ, LXC and many others in between they explode on to the market and then when something else comes along with a cooler name everyone jumps ship
Why are there so many people whining about what other people are doing on this sub?
thank you for the suggestion, I am working on the answer right now. Going to post it soon.
And the irony is that it's probably one of the most used software applications of all time. Perhaps we're all doing it wrong...
the prequels are better than the original, except episode 3 which is awful because of the way anakin becomes a bad guy out of nowhere. The original trilogy was good when it came out but it's just ordinary now, looks more like a episode of a bad TV series (of course it's so because the series had something to copy in the first place), if you remove all the nostalgia. Episode 6 sucks big time (ewoks...)
Value over code quality is what we're seeing. 
I agree with most of the points there are times and places to use frameworks and there are times and places to use OO, they are not 'I must do it this way because everyone else does'. The only thing I do disagree with is the PSR spec, this has done wonders for the PHP community, even the standard styling guide is a huge plus for me. I cringe when I open a PHP file and see functions all over the place, brackets thrown in random places and inconsistent indents. It makes the code much easier to follow. Autoloading is obviously a god send
I view Lerdorf's opinions on frameworks same as Thorvald's on desktop environments. Sure, he's a star of a related field, but not THIS field he's currently talking about. Lerdorf (AFAIK) is not building and maintaining huge complex web apps for years on end, having to on-board new recruits as people shuffle in and out of the team, adding new features not even heard of when the app was initially designed. I really don't care what he thinks about frameworks which solve such problems.
&gt; Citation please. I would really, legitimately, like to know which framework is made of thousands of classes Symfony2 - Classes 2950 - according to phploc on a phploc vendor/symfony on new project creation. That's not including all the other projects they include. Symfony2 is soo large filesystem wise you get really bad performance on virtualbox. 
There is absolute nothing in this post about the PHP Core
It seems that PHP 7.1 is ever closer to stable release now, nice job and thanks PHP internals. 
[removed]
Routing in wordpress is done by a single function with many branches. It's about 400-500 lines long, and it's recursive.
What is with these empty content posts and tutorials originating from India? Do you guys get by blowing smoke around over there?
2,950 classes, including test ones that aren't autoloaded with your application. Also I'd argue since Symfony is a set of decoupled components, it's your responsibility to pick only the ones useful for your application, rather than building your project on top of the demo one they provide. Regarding the bad performance on virtualbox, isn't rather caused by Symfony caching stuff on the filesystem? Can you prove your point using some profiling?
A soft deprecation before a straight removal, where the removal is in a minor version? That's a double no-go. If anything, the functions should be deprecated (not softly) in a minor version (such as PHP 7.2) before being removed in a subsequent major version (such PHP 8)... So definitely -1 on the current proposal.
&gt; 2,950 classes, including test ones that aren't autoloaded with your application. Also I'd argue since Symfony is a set of decoupled components, it's your responsibility to pick only the ones useful for your application, rather than building your project on top of the demo one they provide. The symfony framework is made of components but it comes packaged with all components. If you want to use some components then you're using the components and not the framework. Also phploc doesn't count phpunit test files by default you have to use the --count-test flag to include them. &gt; Regarding the bad performance on virtualbox, isn't rather caused by Symfony caching stuff on the filesystem? That's one of the ways of increasing performance but it stands none the less that performance is way slower than a real metal box. &gt; Can you prove your point using some profiling? I probably could but considering the time effort, I would rather people thought I was wrong.
what was the saying? either you are using a framework or you are writing one.
&gt; WordPress has a fantastic UI for managing the content This one gets repeated over and over again, though I really beg to differ about that. WordPress is really easy to install, has a good way to manage extensions (and has lots of them) and it's pretty easy for non-developers to do that as well. It also has a huge community, so you usually find help pretty quickly. But the content editing part is not great IMHO, most blog platforms and some CMS I've seen so far are just as easy or easier to use for editors, WordPress doesn't shine in this department at all (I never tried the new frontend, so it might have changed now). The main reason WordPress is so successful IMHO is that it doesn't need very deep technical skills to build and maintain, so it's a lot more accessible for agencies for example. 
Ah, I missed the "once the password is expired" part....I assumed that email was user-initiated via "reset" handling. Yeah, at that point he's trading one factor for another, not supplementing.
functional programming typically has some guarantee of idempotency - using global state inside a function tends to break that guarantee.
I'm a little late to the post, but i dont understand this solution can you explain me a bit more?
you're calling the query twice, you're running it and checking it in your if statement and then if it passes you're running it again. Also a word of advice as a new comer, use PDO instead of mysqli
The hard task here is finding the right middle number of "seams". Do not exaggerate, but do not throw _all_ your abstractions away either. Too many "seams" makes code complex and hard to follow. Not enough makes it unmaintainable/patchwork.
Yes, this question is repeated, but that's not the point. This is a vivid example of Stack Overflow's efficiency. It's no problem with bad answers or rep-whores, if there is a good quality control mechanism. But there is none. Besides, this question is not a 20th iteration of same "how to update in mysqli" question Want another example? The most upvoted answer in the most upvoted question [has been vandalised](http://stackoverflow.com/posts/60496/revisions) by /u/sarciszewski and remained so for half a year, until my ban was expired and I was able to fix it. The motto of Stack Overflow is "Nobody cares". Nobody cares whatever shit is written in the answer.
That's what happens when a technical advice becomes a brainless meme void of its original meaning. Pepper with prepared statements, and your soup will taste better.
Ok, I see what you mean, and I can totally understand and agree with that. Thank you for the education.
thanks!
What you offer is not enough
I think this is more of a result of SO's management being more focused on "getting more users", what they then can show to the investors. Which is why 10k-users have been loosing effective admin-tools. As for quality control - there is no way to control any of this. Every hour there are 100+ new questions in **[php]**. And the simpler the question seems, the more answers it will get. And many of those answers will be bad. But there is no way to control it. Even relaying on reputation amount is pointless because, when you see someone with 100k points answering "how to hide 'header already sent' warning", it's likely someone who has earned those point by answering only question like that. Unfortunately there is no viable alternative ATM. 
ok, 1 final question - and thanks for explaining so much. if a function in php, and in JS as well, (and I can't remember if you can do this in Java/C/C++) but if you can reference a global variable in a function, and to do so in bad because it can change the result of your function without know your knowledge, isn't this really just a flaw with the language? Why can't PHP/JS/etc just enforce a rule, if you want to use this value in the function, you have to pass it. And if you don't want to make a copy of the var in the new function, you have to pass by reference. 
May be Documentation can be the answer though. I browsed there today for the first time. It looks promising to me. Sort of tag wiki incarnation in the form of canonical answers collection. At least there should be no duplication.
That's what I meant with "untrusted" - you should whitelist them. Just, in case you don't (which is a bad idea anyways…)... Also what are you talking about backslashes? Just talking about keys which are surrounded by backticks and backticks there are escaped by doubling them.
Whoops, for some reason it was shown to me as sort a backslash replacement, but now it's clear. Nevermind my recent comments. 
Or.... if (mysqli_query($con, $query)) { echo "Request sent successfully"; } else { echo "Failed to send a friend request."; } ... if you don't need to use the $result
Again, what you think is good is an opinion and is entirely subjective. Get over yourself.
&gt; wouldn't it be easy to have a global connection for the page and then close it at the end of the file? Pretty much that, save for closing a connection, which you don't need at the end of the file
Yeah, that helped a lot. I wasn't really understanding the concept of why use OOP. It's mainly for keeping things organized and for scalability / maintenance, which makes a lot of sense. Thanks!
&gt; I've noticed in many of my files that the connection opens and closes in included php files, wouldn't it be easy to have a global connection for the page and then close it at the end of the file? I don't know what your files do, in my case a connection opens on first use (aka "lazy connection"). I have a system where different modules will open different connections, if used concurrently, this prevents them stepping on each other when they open transactions concurrently. In general opening and closing a connection is an expensive operation and it should be avoided when possible.
What your files do is not for security, and it's not a best practice. The only reason they do it is likely because they *have no other place* to get a connection from. "Include files" in general are a poor practice for a long time. A "file" is not a good unit for a piece of code. Instead we have functions, closures, classes, traits, interfaces. The fact they're hosted in files becomes just a detail. Your includes can be refactored to have access to a connection by making those include files be functions/classes where the connection is injected when you run said function or when you instantiate said class. Before: $conn = new PDO(...); $conn-&gt;doStuff(); ... unset($conn); After: return function (PDO $conn) { $conn-&gt;doStuff(); ... }; You can also make it a class in which case the connection goes as an argument for your constructor.
&gt; And whats the purpose of closing a connection at each included file? Is it for security? I'm not 100% sure on this so take this with a grain of salt - I'm not really an "infrastructure" guy. Depending on your PHP and Database Server settings, an opened database connection has a certain lifespan or waiting period before it expires, so explicitly closing it avoids the database pointlessly keeping that connection open. &gt; My strategy would be just to include a connection on my index.php (ie. the top level code) then use the global variable for the rest of the file. Generally, it's better to have a setup or bootstrap file that lives *outside* of your web server's document root. If your index.php file has the database credentials in it and your web server encounters some kind of error and loses the ability to parse PHP, that file will be displayed as plain text, which would expose said credentials. For one of my small projects, I have an `index.php` file that calls a `boostrap.php`, which lives in a non-public directory. The bootstrap file loads the configuration and builds the application, then returns an `$app` instance. The index file just requires it and goes from there.
&gt; Also a word of advice as a new comer, use PDO instead of mysqli Yes, this newcomer is not sufficiently indoctrinated in our arbitrary preference of one good MySQL extension over another good MySQL extension. Good job, /u/twiggy99999.
Thank you! That looks like a pretty good way to clean this code up a bit. This was a good explanation (and i'm assuming you mean to write (PDO $conn) )
Here you go. I had this article in mind for a long time already, and today's events encouraged me to finish it sooner. Here is a link: https://phpdelusions.net/pdo/sql_injection_example
I know I am bad with title-making but I'd at least expect you to read the article before voting. I posted it due to demand for a working example for the SQL injection that gets through seemingly solid protection utilizing PDO prepared statements. I were conceiving this article for a long time already, but today I finished it rather hastily - so there could be some mistakes or things that require more through explanation. I'll be mighty grateful for all the pointers and explanation requests. Thank you in advance. **Update.** Thanks to a well known local security expert for [reminding me about another false measure that is often used](http://stackoverflow.com/revisions/39045482/1). Another section is added to the article. 
Sure, that helps a lot!
Wordpress is the most famous culprit, but perfect examples of this are all over the place (like this piece of shit ACM I've been spending 6 months trying to migrate from). As soon as there is a medium-large userbase, no matter how terrible it is it will (likely) be around for a very long time.
&gt; (and i'm assuming you mean to write (PDO $conn) ) Yup, fixed. 
Does the $request object automatically sanitize data? If not, the following line looks pretty scary... $query = "DELETE from library WHERE book_id = $get_id"; 
And fragile as fuck, and horribly inflexible. Defining a custom URI schema in a proper framework, easy. WP requires plugins, and still isnt as reliable or flexible. God forbid you take on a client with hundreds of different legacy URIs that WP can't support. You'll be writing 301s into Nginx for days.
&gt;As long as something works This is the fundamental flaw in your argument. "Works" doesn't mean one narrow little thing. It means lots more than "does what I need it to do". Security, testability, maintainability, understandability, flexibility, and performance are all key factors.
&gt; professional as ever I don't think you're in a position to judge
So because their legal council said no you think they're unprofessional? Seems like the update at the bottom of [this page](http://www.export.pitt.edu/embargoed-and-sanctioned-countries) states that it's not just Crimea they've changed the rulings on.
The design pattern section reminded me of this bit I read recently: &gt; I never fail to be struck by the irony that despite the supposed power of inheritance, interfaces, polymorphism, and such, you still need a book of ~~spells~~ design patterns to “code proper”. - From [this article](http://www.richardrodger.com/seneca-microservices-nodejs#.V7cyiNz57-c) about seneca.js
It says everywhere "Crimea - Region of Ukraine". Nowhere does it say "Ukraine" as a whole. Crimea is the annexed region, that had to be embargoed, because otherwise Russia would just proxy stuff through it. US never embargoed Ukraine
This quote has nothing to do with design patterns. It's about repetitive patterns in the code, occurring accidentally (that can most likely be refactored). &gt; When I see patterns in my programs, I consider it a sign of trouble. The shape of a program should reflect only the problem it needs to solve. Any other regularity in the code is a sign, to me at least, that I’m using abstractions that aren’t powerful enough - often that I’m generating by hand the expansions of some macro that I need to write. &gt; – Paul Graham 
They removed Ukraine entirely from the list of countries you can choose. I'm now in Germany so I could access the shop without issue, but Ukraine is not in the country dropdown on checkout. The explicit ban is also confirmed by the above reply from customer support.
I'm utterly and completely bias, but if you learn via tutorials, use http://knpuniversity.com/tracks/symfony The entire first tutorial is free, and the script/code is below even the paid videos. And, welcome to Symfony :)
"“As part of a series of sanctions announced by the United States, the U.S. Department of Commerce’s Bureau of Industry and Security (BIS) announced that it is expanding its export restrictions on items subject to the Export Administration Regulations (EAR) in response to Russia’s continued actions in southern and eastern Ukraine. [...] The United States will continue to adjust its export licensing policies toward Russia as warranted by Russia’s actions in Ukraine. " Sounds like more than just Crimea to me...
What could possibly go wrong? *eyeroll*
Protected does allow for inheritance to a subclass, as seen on [PHP.net]:http://php.net/manual/en/language.oop5.visibility.php) &gt;Members declared protected can be accessed only within the class itself and by inherited classes. I can't remember all of PHP's quirks with regard to objects, but given the following basic code example: $video = new video($id); //More stuff with the $video object $myStorageObject = new storageObject(); $myStorageObject-&gt;save($video); In this example you are passing in the object you created, $video, into the storageObject's save method (function). In certain programming languages, such as Java, you can force the save method to only accept input of type video, but I don't know if this is possible now with PHP 7 or not. 
It's almost as if the customer doesn't care how shitty your code as long as they are given the freedom to use the software the way they want it. They don't care how OO it is, as long as the buttons are in the place they want them to be and they can make the text "pop". Any idiot can install a plugin, and most do. The fact that anyone could easily create a crappy plugin for WordPress, and anyone could install that crappy plugin on their website, and publish a poorly written post about it, means that users are not being held for ransom by developers or anyone. They are free to play around, make better, make worse, break and fix their website. They can learn how to write crappy plugins themselves, and over time, learn to write great Craft modules. They still happily pay for developers good money to do it well when they can't, judging by the hundreds of thousands of dollars we've been paid to create and host WordPress sites in the past few months. WordPress is all about the lowest barrier to entry for the end user. That's all they care about: Creating a great experience for the user. They don't care about developers more than making sure they provide enough APIs to access things users want to do.
I don't understand why they are downvoting you. Fuck Zend and don't buy their products. They deserve to be neglected. Code an example project, put it online, use Bitbucket and show it in your CV. Fuck Zend again. Probably Zend has some Russia fanatics, thats probaby why they are doing it intentionally.
Right, but private doesn't allow for inheritance to a subclass, right? That's the whole difference between protected and private, private can only be accessed by the class itself, protected can only be accessed by the class and subclasses of the class. Right? So it passes the whole object through, so within the save function of myStorageObject I'd be using $video-&gt;src, $video-&gt;title, etc Like this if using PDO? $conn-&gt;exec("INSERT INTO $tablename (src, title, desc, cat) VALUES ($video-&gt;src, $video-&gt;title, $video-&gt;desc, $video-&gt;cat)";
Actually this should be a lesson to us all: when those who know don't create tutorials, those who don't know will. In a way, I admire anyone who does things, no matter if they're completely incompetent at it. They did it somehow.
Thanks. Always informative to try and think like a hacker.
In your last example, since you have enumerated the possible keys and excluded everything else, do you really need the backtick escaping part? That is, none of `name`, `surname`, or `email` have a backtick in them, so str_replace("`", "``", $key) will always just return `$key`, right?
There are two issues, although quite odd but still existing: 1. There are people, mostly from financial background, who tend to use a wider set of characters for their table and field names - namely spaces, quotes and such. Mind you all those are legitimate characters for the identifier. 2. The case explained in the last part of the article, where, although not through conventional injection, but still the information can be altered undesirably despite such a regex, when just a valid field name but one a user shouldn't be allowed to can be used.
I agree with your premises and wording. Even more than that, whole SQL injection problem could be called as just a side effect of improper query formatting.
I might have a [better comic](http://cube-drone.com/comics/c/ingeniuty-of-sorts) for the interlude ;)
However, I now understand what he meant by this. You get the same result either way.
I feel like this is a problem with the writing style of the site's author than the underlying point, because the entire concept of the website is based on negated ideas (the wrong way). The point of that section is that you should consider whether you need a framework before using one, not that you should never use one. `!(always) use a framework` is not the same as `!(always use a framework)`, and the opposite of "always" isn't "never" (probably something closer to "maybe") Hell, PHP The Right way even [says the same thing](http://www.phptherightway.com/#frameworks): &gt; You do not need to use a framework for every project. Sometimes plain PHP is the right way to go, but if you do need a framework then there are three main types available:
You are hot
Or even more accurately, fulfills the requirements. IKEA furniture, to pick one example from above, is neither globally good or bad (though it is indeed popular). Much of it excels at being low-cost, functional, and utilitarian, frequently at the expense of long-term durability and "interesting" design. There's no one trait that makes it magically good or bad; it's a multi-dimensional spectrum. Hell, the back end of a screwdriver is the best tool for hammering a nail when the goals are "get this done as quickly as possible" and you have a screwdriver but not a hammer sitting next to you.
Too helpful! Where do you get this info from (aside from experience)?
&gt; judging by the hundreds of thousands of dollars we've been paid to create and host WordPress sites in the past few months. hundreds of thousands of dollars for WordPress... Nice catch! Large company with reputation, or awesome at marketing?
But That would negate the exercise :-/ 
Would I be able to just typecast the object that's passed through as an array within the save function or would that be an awful idea? function save($object) { $object = (array) $object; $conn-&gt;exec("INSERT INTO $tablename (src, title, desc, cat) VALUES ($object['src'], $object['title'], $object['desc'], $object['cat'])"; } Something like that, or is there no point? What would be the best way to convert an object to an array, like within the getDataAsArray function? function getDataAsArray { return var_dump(get_object_vars($this)); } ? 
400-500 line long function... http://giphy.com/gifs/ebKdLJ2ODGLqo
Half the variables names would be made up words
How is context irrelevant? I'm not sniping at your success, I'm happy for you; I'm content with customers wanting WP, I wanted to understand the business situation that gives rise to a 100k WordPress development was all. 
Hopefully he would chase me enough to give me a good scare, but not actually gore me to death before I find my way out of the labyrinth
I didn't say I like how WP's extension structure (or anything else in WP's code, for that matter) is done. From a developer's point of view, it's a mess. It's just very easy for non-developers to use. I was just arguing that content editing, contrary to popular belief, is not WP's forte. 
This code and procedure existed prior to my employment. This post was an effort to figure out a better approach to a rather flawed policy. And the link expires immediately after its clicked...
 /** * What's in a name? That which we call a rose * By any other name would smell as sweet. * * @param $name string Name of the thing you would like to smell * @return string */ function whatsInAName($name) { if(strtolower($name) === 'rose') return 'sweet'; return 'sweet'; } todo: function should be renamed to "howSweetDoesItSmell($name)"
Build something. Look around at how other people solved the problems you encounter along the way. Look at third-party bundles and projects to see how they handle stuff.
I'm currently learning through KnpUniversity. It's like Laracasts for Symfony. I'm going to * Work my way through the Symfony3 track on KnpUniversity. * Install the [Symfony 3 demo project](https://github.com/symfony/symfony-demo) and have a look around. * Scan through the documentation on the site. Read the important parts carefully, and then jump in.
Reminds me of this: http://stackoverflow.com/questions/5925356/reasons-to-not-use-a-php-framework
Keep in mind the $this-&gt; part of your is only available inside a class referring a property or method within that instance of the class, the object that function save() is a part of. The only reason I bring this is up is that typically you don't echo out of a method when using OOP (I am sure there exceptions that I'm not aware of), but rather return either a string or a Boolean value so that you can then later use that value in your script.* For instance in no particular coding language: Create needed objects for video, connection, storageObject, etc. Process all the video elements to make sure they are valid and contain no errors Save that video's information to the database Page Output &gt; "Save Successful" or "Error" By processing in this order, you can check to verify if there are errors at each step and if there are you can skip to the output. Take a look at [Exception generation](http://php.net/manual/en/language.exceptions.php) and the try/catch block in PHP. --- \* One exception that I use is during debugging to print the value or contents of a given variable on the page before I do any template-related output.
Um, cron? Any sort of scheduler either is built off it it, or becomes complex enough to reinvent it as some sort of daemonized master process. Until you need all sorts of complex state tracking, the latter is usually not worth the pain. And even if you need that, don't write your own. Someone else has already done it, and handled the edge cases you don't yet know about. For data loading, ETL work, etc I use Apache Airflow (which is good enough to mention, but not enthusiastically suggest) - however its main benefit is in multi-stage operations with upstream/downstream dependencies. It's not 100% clear if that's what you need or not, but maybe directionally correct? Keep in mind it's written in Python and the scripts that it runs are also Python objects, but you can just use the `bash_operator` to run `php your_existing_script.php` and not worry about that.
I actually don't entirely disagree with you on the content editing argument. TinyMCE leaves a lot to be desired, but I meant that as a CMS, WordPress is one of the best that I've seen in regards to managing content at a higher level. Everything is right where it needs to be (and where it makes sense to be to the user- even when they aren't super tech savvy), and I honestly think the admin interface is designed very well. I don't mean to put you on the spot, but I'm curious if you could give one or two examples of an other CMS that handles content organization better that WordPress in both structural and visually appealing (even if it isn't PHP). I always like to get a feel for what other programmers are into.
This is probably the wrong way, but it's what I've built for our internal application that is also the same - no frameworks and was originally a legacy mess, which is slowly being modernized piece by piece. First, our application is running on Windows, that means task scheduler. For Unix, I'd have just used cron. We use CURL that points at different URLs (all internal, https, using authentication) that run at different times. Each job is a PHP file that contains job entries, each job is a class implementing a common interface for scheduled tasks. Task scheduler runs CURL each night for example, and calls the taskNightly.php file. There are other scheduled tasks that run each hour, each week, month and a special job that runs once a minute to pick up emails and send them from a central queue. taskNightly.php itself runs the jobs sequentially, logging any status messages to a log file. There is a separate job that scans the log file for error and exception, or incomplete jobs and generates email reports to my team with details. Again, probably not "the right way", but it's worked great for a couple years now. New jobs have been added without issue. 
Here's why I wasn't sure: it could have considered the else to be for the 2nd if; that's not a fair assumption? I've seen PHP and other coding languages make worse assumptions. Plus I've never seen an else foreach; not everything that looks like it will work works... fact of life.
Terribly written? Negativity seems to rule comment boards just for the sake of self-amusement, so explain your assertion or have it forever be considered trolling. Looks more efficiently-written than this bloated crap (you prefer a ton of unnecessary spaces and lines and brackets everywhere on a small bit of code?): if(empty($question['sub_questions'])) { if(!empty($question['optional'])) { $nbrOptional++; } } else { foreach($question['sub_questions'] as $subquestion) { if(!empty($subquestion['optional'])) { $nbrOptional++; } } } 
I must say I don't know what type of answer you expect... At best none, at worse lot of `uninteresting` and `crappy code`. PS: I have too much time.
Another variation: function theQuestion() { return 'to be, or not to be'; } function theAnswer() { return 42; } However stupid code, whatsInAName( theQuestion() ); still would return "sweet" ;)
I beg to differ, the way you organise your files and whether or not you want to have a file structure matching your application layers or something else is completely up to you and unrelated to the autowiring.
Ok, I see what you mean and I agree with you about the higher level content administration and the design - that's true, users get along pretty quickly. My gripe with WP's content editing is that it tends to get messy, not only because of TinyMCE, but also the simple taxonomy or other ways to organize the content. I'm currently evaluating bolt.cm, which seems pretty promising so far and IMHO it looks cleaner both for an editor and especially for a developer. 
Your videos taught me so much about Symfony. The guard tutorial is great too. Can't wait to see it completed.
I don't know why are you talking about file structure. It's not what I'm talking about and not what that tool is about. We're talking about dependencies. 
What about making these tasks some micro-service? Then you could utilize something like Lumen and get all the benefits that go along with it.
The key word being "can" I usually see people with the pair that only set and return the internal variable. This will go on for class after class after class. Once I had a Setter where something was changing from setting the colour of something and the new core functionality also called for the opacity to fall as the colours got darker. So my colour setter also called for the opacity to change based on the colour coming in. There was no opacity setter. So I combined the colour setter and the opacity change in the color setter. The people who did code reviews just about shit themselves blah blahing about encapsulation and abstraction and how a setter should not do more than one thing. I said that it wouldn't be very abstract if it weren't to be say abstract. They said that if I left it in they would file a but. Then I ripped through their code and filed about 300 bugs where they solidly broke what was clearly abstraction. I pointed out that I was about 1/50th through their code. They stopped reviewing my code, and just about everyone else's. Better code reviewers stepped in. 
keep it simple; multiple single purpose cron scripts in PHP. Possibly with a job queue like beanstalk or gearman if it makes sense. Make sure you have locking (flock/lockfile-progs etc). Log everything. Setup something like Nsgios to alert you if a job hasn't run in the last X hours. 
Ok, makes sense. Either lick every ignorant ass or get no stupid votes. 
Not really much specific to PHP. It was pretty much just "Yeah, Google Cloud does PHP as well. Check out this, that, and the other Google product". Host was being a bit of a douche too ("lol PHP, lol LAMP").
I don't know if you're for or against this quote, but good lord, this quote is dumb. Having a book that demonstrates the power of inheritance, interfaces and polymorphism is literally the most powerful tool you have as an OOP programmer, unless you are so incredibly gifted that you automatically know how to solve design patterns as and when they emerge. I mean, come on.
Drupal 8 is making long strides to reap the benefit of the OOP paradigm; it's had a major rewrite from the ground up to do so. But you're not a PHP programmer so I don't really see how you can make a worthwhile assessment of these things.
&gt; Since this is not possible in PHP we need tools like deptrac to enforce certain architecture decisions. I've never understood this. Why do you _need_ to make it impossible to make a class private to a namespace? 
Are you really going to read a "Response to" article without reading the original article?
We call this "expert code." Not to say that the programmer who wrote this is or isn't an expert, but that it requires an expert to understand what's going on. One could argue about that on several levels. First, you need to know how PHP parses the if-if-else-foreach combination. That's not too difficult but it may take a non-expert PHP programmer a few moments. Secondly, you need experience with the data structure that the application is assuming, because apparently 'questions' is a tree in which each node can contain other questions, and each node can be 'optional'. It's unclear whether sub questions may contain sub questions, they could or could not. Defining data types would make the concept easier to grok. Lastly, you need to be a domain expert to validate that the requirements are implemented correctly. For example, is it clear from reading the code that once a parent question is optional, its optional subquestions are not counted? Or should the optional subquestions actually be counted instead? Good code expresses its full intention. Slightly better naming and structuring can make a big difference. Otherwise just replace the comment with `// Ask Alice about this, she's our questions expert`
&gt; The problem deptrac wants to solve has nothing to do with DI but more with the lack of access modifiers for classes and such. DI can actually do a whole lot to enforce certain architectural decisions (especially about... *dependencies*), and while I agree class visibility would help, this isn't in PHP, yet, so let's focus on DI, using the example given in the deptrac docs. First of all, a well factored application would split *domain logic* from *clients of the domain* into separate modules. That's common sense, because you would typically have at least two distinct clients for the same domain for a given web project (the public site, and the admin site). Each of those modules has its separate dependencies. The domain logic module would use repositories, which in turn would typically need an SQL connection (or other storage mechanism). The clients won't ever be given an SQL connection, they'll instead be given models/endpoints from the domain to interact with, via DI. The deptrac docs show an example where we want a controller (client module) to use a model (domain logic module), but we don't want the controller (client module) to use a repository (domain logic module *dependency*). In a well factored application, you have two ways to grab that repository from the controller (i.e. the client): 1. Declare it in the client module dependencies. The composition root, as I said, won't satisfy such an obviously wrong interface. 2. Instantiate it yourself. To instantiate a repository you need to satisfy *its* dependencies, which in this example includes an SQL connection. You have two choices again: 1. Declare it in the client module dependencies. I won't repeat myself - that won't go far. 2. Instantiate it yourself. Now the *client module* needs some place to get *connection host and login* for an SQL connection. Where would it exactly get those? Login details are almost always machine-specific. They're not checked into version control, and every developer configures their own copy in their local composition root, for work. This means you have to slap some machine-specific manual connection settings in your controller. Host, user, password and everything. That'd be quite obvious and alarming during code review. But let's say *we don't have code review*. The next stage it'll fail at is any sort of testing (automated, or QA), because no other machine will have the exact login that the developer hardcoded so they can spawn a repo on their local machine. So... good architecture enforces itself, at least to a good degree. Writing soup and then using **regex matches** on class names through something like deptrac to me is nothing but a sign of resignation in the face of chaos.
What are you using to deliver a CMS?
I /don't/. Too many sites out there uses software too bloated for their needs. Using a CMS is way at the bottom of my list and it's fine there.
Great, just wanted to make double sure you don't know what you're talking about.
I know precisely what I am talking about. Go waste your time with your CMS and come back to me in 10 years when you finally learned something.
You don't. By your own admission you don't work with CMSes, so your opinion of Drupal is from a position of ignorance. Drupal fulfils the major use cases for clients in my industry very well.
We follow the PSR guidelines strictly at work, but use ternary operators instead of single if statements (hence me mentioning bad practice before that line): return ($id ? User::find($id) : null); And I guess they changed that scope block then, it used to be like that before. It actually works like that in C, so I don't know exactly why it has changed or when.
A wild Hashicorp eulogy appeared...
I like the great attention to detail, here. Even the title is wrong.
&gt; Trust me, you really do NOT want to re-invent the wheel At least don't use the very same tired non-argument the author warned about. Heck, even with *actual wheels*, there isn't a single type of wheel for everything. &gt; You're living in goddamn magical fantasy land if you think you can write a competent PHP application using just the language and SPL in anything less than years. That's a strawman... The choice was between *libraries* and frameworks. Not between *nothing* and frameworks.
I know it depends on your toolset of course, but for something simple, if it's a Symfony app for exemple, I'd use their console component to create commands I can manually run easily (most frameworks have such components), this way you don't need to reinvent the wheel for all tooling such as database handling, maybe you may use an ORM, you can use all you libraries and applicative components easily this way. Once I got my commands I'd just use a cron to run them, but if you need something more sophisticated, meaning you have lots of them, and need to schedule them in a complex fashion (we do have scripts that run every minute, others every 10 minutes, others once a week, some at 3h in the morning etc etc etc) then use an external scheduler. Some framework also have modules/bundles to do this for you using the framework itself and providing monitoring, scheduling, etc... via a single front controller (a command) you may just run every 30 seconds or every minute. There's a lot of ways to do this, but if you use a mature or complete (or both) framework I'd use it this way.
One can argue that Symfony isn't actually a framework but just a collection of the most helpful and independent libraries for web development. Config management, routing, http request/response abstractions, dependency injection, just to name a few of the best in class components. 
1. Choose a simpe use case, photo gallery, simple blog, simple survey tool, a nice personal custom dashboard, your personal groceries list, anything that would be fun, nice, and useful. 2. Choose a good IDE that will highlight pretty much everything, easy navigation, good debugger support. 3. Install XDebug 4. Then get started with http://symfony.com, install it and go develop your über nice useful custom piece of software :)
Haters gonna hate, please don't yell VIM! EMACS! or PHPStorm! it does not make sense, in order to learn you need something to guide you, and even if you don't need or like any IDE, making the exception for learning purpose good actually be a good thing for you (for anyone even those who don't need to learn the framework itself).
Well, right now I am fixing some stupid mistakes there. But I think in time it can mature and become a solid thing. Don't you think so? Mind you, it just started.
Be aware that by widening the list of allowed characters you may expose the query to injection. So, if using regex approach, it's better to be safe than sorry and keep with stricter set
I wonder if the author realizes that he's completely confirming the accusations of elitism made by "PHP The Wrong Way" in his strawman rebuttal of it. Regardless of how you think people should write PHP the irony is real.
The PHP object model is influenced by Java, but Java is a very different language. It has no free-form pass-by-value (copy-on-write) hashmaps like PHP does, Java apps are long-running processes, not fire-and-die request-response cycles like in PHP. The practices Java uses are modeled to take advantage of Java's strengths and compensate for its weaknesses. While the PHP version of this is to copy the Java model, *without* taking advantage of PHP's strengths and compensating for its weaknesses. Look no further than what projects like Symfony and Doctrine are doing. Doctrine folks are directly saying they copy Hibernate, because "they know better than us". Well, Hibernate knows what's good for Java, not for PHP, so copying Java is not a shortcut to PHP brilliance. In particular, objects make really poor DTOs in Java, this is why the language will be adding value types (think structs) on top of objects in the near future. PHP has "structs" - arrays, but instead look at any "model library" or ORM, they're quick to wrap DTOs in objects, even often mutable objects, thus incurring all the cost of creating an object that'll cease to exist milliseconds later, incurring all the cost of bugs introduced by mutability of passing around data objects, and zero of the flexibility of using value types for this. The PHP community needs to see Java do it first, because "they know better", so hopefully when in 2020 or so Java 10 comes out, in 2025 we'll finally have typed array structures in PHP and use them for DTO... the way we did with arrays in PHP 3 and 4.
I'm aware, don't worry. I've decided to rewrite it to use a whitelist instead. there really isn't any other substitute that doesn't raise the possibility of users accessing data they're not supposed to see.
He says we have no class visibility in PHP, so this is an alternative. 
&gt; overburdening them with every minute detail is not the way to be helpful I beg to differ. When you teach someone to play chess, you don't start with checkers to explain the concept of black and white. Why not show him how to do it correctly _from the start_ ? If there are concepts the OP does not understand, he can investigate or ask right here. That's what this medium is for. &gt; Nobody learns everything at once, you need to grasp just the simple basics first Sure, but giving _incorrect_ examples, will only confuse beginners. Do it right from the start and they will learn it The Right Way (TM) &gt; The one thing I will disagree with, though, is your comment about an object being in an "invalid state" This is the root of your distrust of your own objects :) Maybe this video can convince you otherwise better than I can: https://youtu.be/ZJ63ltuwMaE
if i ever wondered when an article is too long so that people dont really read it ... that article was too long for me to really read it.
Oh, yeah, they're totally forgot about "PHP – The Spaghetti Way" and "PHP – The Lasagna Way." Anyway, all those "PHP – The * Ways" are partially subjective pretty much. All what related to design of the application is subjective (c'mon, people used to write programs in procedural style, look at git and older id software games). Paradigms, design patterns, all those B.I.G. L.E.T.T.E.R.S (SOLID, [STUPID](http://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/)) acronyms are partially subjective. While stuff like security and which database adapater to use is more or less objective. It's my opinion, anyway. P.S.: There's also supposed to be "PHP – The Pizza Way," (everybody likes pizza *amiright*?) and "PHP – The Schnitzel Way"
And what about PHP, awimba way awimba way awimba way... 
This is a pretty narrow-minded way to look at things. As if good practices for writing software were somehow confined to the boundaries of a given language. Java itself owes much of its identity to its predecessors, so you might as well use those, instead, right?
&gt; DI can actually do a whole lot to enforce certain architectural decisions (especially about... dependencies), and while I agree class visibility would help, this isn't in PHP, yet, so let's focus on DI, using the example given in the deptrac docs. DI is about managing dependencies not about enforcing architectural decisions at all. And since not all "dependencies" are managed via a DI (e.g. domain objects), DI is definitely the wrong place to "fix" this particular language problem. &gt; Writing soup and then using regex matches on class names through something like deptrac to me is nothing but a sign of resignation in the face of chaos. True but we currently have no other means to do so. deptrac is flexible enough to allow you to write your own collector classes. Not happy with the regex one? Build one that matches your needs.
Really high standards and great clients. We're a full-service marketing agency, and websites are just one part of the offer. We work for clients who are used to at least spending $10-15m a year on marketing. So $150k on websites for one client in a year isn't exorbitant: ~$14k a month, they have a website with reliable uptime and a development team ready to work for them. It's about what they would spend to have two crappy developers working within their company, but then they have to manage them, and hire them, etc. 
I've never used Propel so I'd like to know your opinion having experienced working with it. Would you choose Propel over another ORM like Doctrine ORM, and why?
Fair enough, my wording was too strong, there are cases for rolling your own. I do discuss where I think re-inventing the wheel shouldn't happen in my post. I also would argue that if you're building something that fulfils a use that didn't exist before, you're not re-inventing the wheel so there's no problem; but at without knowing the level of granularity I guess it makes it a bit of a nebulous concept.
&gt; I do not waste time with routing (about the lowest value activity I can think of these days) Seriously dude!? You don't use the front controller pattern? You have a bunch of separate end points like user.php, and login.php etc? Do you not realizing you're repeating all of your common file includes and logic across all of these end points? The whole purpose of a router is to make all requests go through a single entry point where all bootstrapping and common includes need to be defined ***once***. If there's anything that provides the ***most*** value that everyone should absolutely always use, it's the front controller pattern with a router.
You make one common include file. You include it in each endpoint file. Y is that hard 4 U? Some endpoints require special libraries. I only include these extra files in endpoints that need them. Writing route files is a waste of time.
&gt; This is a pretty narrow-minded way to look at things. As if good practices for writing software were somehow confined to the boundaries of a given language. It's not a "narrow minded way", it's a "critical way". I dare to think *why* I do something before I do it. When the only *why* that comes to your mind is "well, because Java does it" then this is defined as a cargo cult - the imitation of superficial attributes of the successful, in the hope it brings you their success. Java is not PHP, so some things *do* translate, and some things *don't* translate. I mentioned a couple in previous comments which *don't* translate, but are pervasive throughout the PHP community.
At the level of building the query I have another approach. The whitelisting has likely happened at an earlier point while I was still validating my form input (unknown field names wouldn't be allowed further into the app). But my DB layer has two functions: encodeValue() and encodeName(). The first one is basically what quote() does in PDO, for ex. The second one wraps delimiters around the name, and validates its charset to: /^[a-z][a-z0-9_]{0,63}$/Di Which is safe for all databases, and covers all plausible names one'd use for a table/column (length varies per db).
&gt; They're good practices in PHP, Java, C#, and many other languages purely because they're good practices. They stand on their own merits. Yes, what did I say: &gt; Java is not PHP, so some things do translate, and some things don't translate. But there's a difference between "some" and "all". Take the YAML/XML/annotation storm from Symfony and co. - definitely came from Java, and it's such a heavy-handed approach in PHP, it's insane to call it a "good practice". Likewise, the only reason Java wraps everything in objects is that it *has* to. But PHP frameworks today wrap everything in thick object graphs, whether it's necessary or not. Despite all data in PHP comes and leaves as arrays anyway.
There's also PHP - The Jeffery Way, which involves deriving your knowledge from Laracasts
While all the data may come and go as arrays anyway, arrays are a bitch to handle in complex business cases. It's very obvious why one would want to transform about array into something that gives you autocompletion, security checks, validation etc. etc. Maybe if you work alone on a project you might be able to sling arrays raw, which I actually doubt, but when multiple people work on something it is a good idea to have well defined objects with well defined apis. 
I forgot it's impossible to validate an array and use it in APIs. /s
It's too bad PHP doesn't have a Taint mechanism...
The reason this style looks "bad" is because it's exposing code complexity the single line method hides. Using arrays as complex data structures creates a great deal of debt for developers and the "bloated" method is showing that. With a data object the code could be as simple as $nbrOptional = count($question-&gt;getOptional());
Overall I'm pro-docker, but it's certainly not for everyone. It's really nice, but you should know that it will NOT necessarily simplify your infrastructure - it's yet another layer on top of your servers. Using it builds on top of regular server concepts, so you should have a working knowledge of running apps on a server already before jumping in. It's super nice in development as @mrferos points out. Using it in production is another matter, although it's getting less complex (esp with the latest version of Docker Swarm). Docker development (as in, the people coding Docker and related tools) moves pretty quickly, so docs can get a bit outdated and tools can lag behind current versions fairly easilyish (not too bad, but it def. happens). There's also a lot of competition in the field for tooling still, with no clear winners, so expects lots of options for a few years before some defacto (and hopefully easy) tools emerge. Related: I'm currently making http://shippingdocker.com/ (expect it out this fall) to help make it easy/clear how &amp; why you might use Docker!
The biggest disappointment I've had with the docs (and almost every tutorial out there) is how heavily favored toward annotations and service location they are. You don't have to use either with Symfony but you won't find as many resources if you opt for configuration and dependency injection.
Going to conferences, reading a few books, reading some blogs, following some people on Twitter. Basically always keep learning.
I think that he had to do browser development and he found a happy home in ExtJS. 
In most slow bloated languages primitives are actually objects. Good luck ever finishing a project the way that it was intended to be finished. At least you will make some adademic happy with your attempt. 
Redunant brackets.
Routing is automatic if you set up your file system hierarchy correctly. Why mess with that?
If this is just a script to run, it's all redundant.
Um, no. If you tried to program an OS in PHP then, yes. If you are making a website that needs to run at rocket speed, then PHP is about as good a choice as can be made when it comes to simplicity, speed, deployment, etc. For most corporate websites my standard is 100ms is the slowest a page can take to respond. 10ms with PHP is not uncommon. The key is that with PHP your default page does not have layer upon layer upon layer of abstraction to produce something that is straighforward. But if you do use one of the bloated PHP frameworks (the gist of the article) then the site will be shit slow. 
But...then...all the coffee would fall to the floor! 
Thank you!
If you are doing that and you want search engine friendly urls then you're doing rewrites in a web server config. I'm weird... I tend to like keeping all application settings easily editable in the application repo. I don't like having to setup funny release logic to check for rewrite changes and restarting the web server but to each their own.
Nice to see all your tests are passing green in the background there!
I thought that about Python until I needed to do saml token stuff. Now I'm dealing with `onelogin.saml2.auth.OneLogin_Saml2_Auth` - that's the actual class path. And there's a utility class that's all static methods called `onelogin.saml2.utils.OneLogin_Saml2_Utils` I'm only 99% convinced they transpiled Java to Python because *why would you do that?* And, yes, there's other libraries that handle saml stuff in Python but they come packaged with either Paste and WebOb (lowish level server libraries) or also OpenId and OAuth libs (which I don't need). 
Yeah seriously, and after a couple of years of NIH a company is incredibly dependent on specific developers and it's a total catastrophe if/when they leave the company.
Doesn't matter. Might as well put something like: &lt;?php &lt;script type="text-javascript"&gt; echo 'stupid code.'; var something_dumb = $this; &lt;/script&gt; ?&gt; I mean, why not, it's just a mug.
lol! hey now.. code I write more than 6 months ago is someone else's code. No way would I write anything that dumb!
Pick one component at a time, and see how successful projects use Symfony. I built a flippin sweet console app for my main project at work by studying how composer uses Symfony/Console
Chris's serversforhackers.com site is legit, I've sent a few people there to help learn about firewalls and permissions. Good stuff 👍. I saw your other question on running a DB with docker. I actually run MySQL on the host and then add a firewall rule allowing traffic on 3306 from the docker0 interface. Works like a charm.
I'd hire that person.
While that's true, the author's depiction of frameworks was way off base. It honestly seemed like they never properly used one, or tried to side-load one next to an existing project and couldn't get anywhere because they *also* have an aversion to autoloading and PSR-4. Given they did not provide any specific examples of which frameworks were problematic for them, and why, we can only speculate, but the impression that article gives regarding frameworks does not line up with reality, so something is amiss with the author's complaints. So if we're going to talk about strawmen, the choice presented in that article wasn't between libraries and frameworks, it was between libraries and frameworks-are-terrible.
It's one way of doings things. It's not a wrong way. Depends on the circumstances and requirements for a task. 
🙄🙄🙄🙄🙄🙄🙄🙄🙄
Found the senior.
Thanks.
Laravel is only good if you're a web **artisan**. For regular web developers it's pretty crap.
phpthebestway.com redirects to Laravel...
Pretty much. I've done a few mobile social networking apps. They all use the same server actually. /signin/index.php /post/index.php /comment/index.php /like/index.php etc.... 
Nice font, round parenthesis make me happy.
I always go with the parens.
I guess. I don't really do page by page apps. I do "one page" html/js apps or mobile apps that use web services. I don't know why more PHP development isn't geared towards that.
Our biggest battle at the office is the if statement bracket argument. That on a mug would be hilarious, thanks for the idea!
I mean, in fairness, for regular web developers PHP is pretty crap.
I'll answer that question with a tautology: laravel is the best way to do the things that laravel is the best at doing. As far as SOLID, request heavy web apps go, it's pretty great. I wouldn't look to any framework for your question. Only strong fundamentals could be considered a "best" practice, e.g. Phptherightway. You could criticize Laravel's router or approach to OOP, but I can't really make a case against good fundamentals: clean code is better than messy, prepared statements are better than unsanitized db queries, etc,.
Too much facade!
Of course. But for arguments sake, try `whois symfony.com` for example. Then try `whois laravel.com` (which is nearly the same as phpthebestway.com.) In my view, there is a reason why professionals and products (which Laravel has become) do not hide their contact information. 
Dude...
Hey don't be too hard on yourself man
Yes, it's the cost of doing business with products. Symfony seems to understand that. As do thousands of other businesses. Just making a point.
Hi @colshrapnel, can you please provide your website URL ? (http://copyscape.com/?q=http%3A%2F%2Fpdo.w3clan.com%2F) I will report to author for infringing or not providing source url in tutorial. Speaking frankly, platform is only allowing users to create tutorial , we only work, if some one reports the tutorial to us. Thanks
I prefer whatever my IDE autocompletes to.
The URL is https://phpdelusions.net/pdo Parts 1, 7, 8 and 10 on your site are stolen from my tutorial linked above. 
Can you explain when it's a good idea to use this library? My first thought was that this was a library about regression testing - and only after reading the examples I found out it's about regression in statistics. 
Yes, we can clearly see some part of the text in (1). http://pdo.w3clan.com/tutorial/167/why-pdo (7). http://pdo.w3clan.com/tutorial/173/getting-row-count (8). http://pdo.w3clan.com/tutorial/174/fetch-data-out-of-statement (10). http://pdo.w3clan.com/tutorial/176/like-clause-in-clause-and-limit being strictly copied from your website https://phpdelusions.net/pdo . We have sent the message to author http://rajrastogi.w3clan.com/ [ You can know about Author via Author tab in tutorial page (http://pdo.w3clan.com/?tab=author) ] to either "remove it" or "provide source url" immediately. We are awaiting for his response. Thanks @colshrapnel for reporting us. We will love to have you on our portal with your any tutorials you make, we provide user domain option in all course or profile for free. If you ever want to try us, you are heatly welcome.
Whatever the coding standard says to use, otherwise always with parenthesis.
Yeah obviously you should know HTML and CSS for webdesign. If you don't want to design buttons, forms etc. from scratch, you may wanna look into something like [Bootstrap](http://getbootstrap.com/).
Awesome advice. I think I'll play around for a few days then use that. btw- how likely is it that I have to use javascript? Netbeans is borderline forcing it on me. 
Great. Thank you
We like to ruin things. Just kidding, we LOVE to ruin things!
Judging someone based on a novelty mug makes you look like a crazy person. Sorry.
&gt; Exactly, private can be accessed within the class itself, or practically within a single instance of an object of that class. So if class youTubeVideo extends video, then protected methods or properties of video can still used in objects of class youTubeVideo. This is actually a common misconception. `private`doesn't restrict access to the specific object, but rather to all objects of the same class. class A { private $property; public function __construct($property) { $this-&gt;property = $property; } public function test (A $a) { echo $a-&gt;property; } } $a = new A("test"); $b = new A("asdf"); $a-&gt;test($b); This will output "asdf".
Just reading the other comments, here is a quick overview. HTML+CSS are the pretty things you see when you go to a website. Say Amazon. Where the pictures go, where the text goes, etc. Javascript (not Java), is the programming language that makes the pretty things move. A drop down here, in browser dialog asking you to subscribe to their mailing list. That's javascript. HTML+CSS+JS are considered "front end", things the visitor sees and plays with but doesn't explicitly request information from the server (AJAX notwithstanding). PHP is the server language: it works when you do things, like logging into your account, add things to your cart, when you search for a waffle maker, when you add things to your wish list. You interact with the database, you work the cookies and the session variables. That's what this subreddit is about. Having said that, [Pinegrow](http://pinegrow.com) will let you open Bootstrap and Foundation based files, also builds WordPress themes. Bootstrap and Foundation are HTML+CSS based packages that have a permissive license for you to work with. They have tables, forms and buttons nicely skinned and worked out so you don't have to. That's still only the front end of your web application. PHP deals with the back end. Edit: words
&gt; Looks more efficiently-written than this bloated crap (you prefer a ton of unnecessary spaces and lines and brackets everywhere on a small bit of code? Yes I do. It makes it more clear what is going on and a lot easier to debug should there be an issue with that piece of code. I can only imagine if you write all of your code in this way that it would be a maintainability nightmare not just for yourself but for others to work with. You're trying to do something smart but you won't get any brownie points for writing code in this way. Keep it simple. I suggest reading [Clean Code](https://books.google.co.uk/books/about/Clean_Code.html?id=hjEFCAAAQBAJ&amp;redir_esc=y&amp;hl=en). The examples are in Java but the principles can be applied in PHP or any other programming language.
Trying to use a regex to handle what is a non-regular language should make people pretty... uncomfortable. A much more robust and easier-to-verify solution would involve an actual parser that can verify its sanitation attempts have caused the expected grammatical structure to result.
I made this project for myself a while ago. The idea was to be able to create a project structure using a Yaml file so I didn't have to create all the folders by myself. I thought it would be a good idea to release this to the public too, so here it is. https://github.com/glowdemon1/ysgen (ps: only tested on Windows, not sure if this works on unix)
I prefer the former, empty parenthesis combined with "new" just looks ugly to me. If you want to get specific, you could use parenthesis to send in a parameter like "red" or "22oz" etc. But if you have nothing specific to add, it's just a waste of indicating you want to get specific. "I'd like to order a new mug." "Anything specific?" "Yes." "Like what?" "Nothing comes to mind." C++ seems to agree with me: http://stackoverflow.com/questions/180172/default-constructor-with-empty-brackets 
My advice would be to learn the basics of HTML, CSS, and JavaScript when starting out. Forget about tools, frameworks, and libraries for now, that'll come later. You don't need something as heavy as NetBeans for front end development, Sublime Text is a nice and lightweight editor for that along with a plugin called Emmet that will speed up the writing of HTML and CSS. Some people would recommend Atom editor but it's slow as hell. As for JavaScript, you should checkout JSFiddle if you want to quickly test how JS works, find some tutorials online and follow along, make sure you replicate the code you see in videos and test with different inputs. Learn about variable scope, objects, prototype, functions, and when you're comfortable enough learn about closures. Here are some goals you should aim for when learning front end dev: * HTML5: learn about the most used tags, when to use them, and how to use them correctly. * CSS: Selectors and specificity, media queries, animations &amp; transitions. * JavaScript: Closures &amp; callbacks, promises, code modularity. * JavaScript frameworks, only when you know enough JavaScript: VueJs (or React) * JavaScript Tools: Npm &amp; Webpack (really advanced stuff, but it's a must-know tool). 
I'm pretty sure I know who you work for, although I've seen various bits of work like this. Whilst it's okay to have multiple files rather than follow-front-controller for some huge projects, it shouldn't be kicked to the FS in every case, certainly not your case. Why not use the web-server if you don't want to use PHP for routing? It has a lot of benefits (long-running process so init times are slashed), but also fine-grain control that you seem to be missing. You can even use interpolation at the web-server if you really need the free-form to use flat-file routes, or simplify your routing conventions. Not everything has to use fastroute for sure, but it looks pretty awesome and reads very well. Also worth remembering is that social networks that I've seen all succeed by being simple. Facebook has &lt; 10 base objects, Twitter has Three objects, Tumblr, Instagram, none of them need hundreds of routes, so none would suffer from using a central router.
Seen a lot of answers mentioning 'bootstrap' in the first sentence which Is worrying to me, so ima write a little post on where I think you should start! So web pages are requested from a server and HTML is returned as the response. These webpages are built on top of something called a DOM (Document object model) which I suggest is a good place to start! The DOM primarily makes up the structure of the web page. So this is where HTML comes in. HTML elements help structure your content which is the basis of all pages, whether this is a section, article, a button, a form for data, imagery, paragraphs, headings etc. I should at this point say, before going any further, that content is KEY. Before playing around with the styling of HTML or its interactivity you should read up on how to effectively structure your content and indeed devise GOOD content. Moving on - We have our content structured on our page, which right now from a user experience perspective is a blank canvas. From this point we can help 'enhance' this user experience by styling our HTML using a web language called CSS (cascading style sheets). What this allows us to do is affect existing properties of HTML elements. This could be anything from change a paragraph's colour, to the width and height of an image. These are incredibly basic examples so as before, go read about the fundamentals of element properties and how CSS can change these. A side note. People say CSS adds 'style properties' to your HTML elements but it actually doesn't, these properties already exist when a HTML element is rendered, all CSS is doing is altering these pre existing properties and attributes. So now we have a well structured page that's visually pleasing with perhaps minor interactivity. Now we want to enhance our User's experience further by adding another layer on top. JavaScript. JavaScript is a scripting language built (originally anyway) for the web. Using JavaScript we can achieve things like adding transitions and simple animations to our HTML. We can also use it in more complex situations to request data from our server asynchronously to inject into our HTML. We can even use it more programmatically to build games on our browsers rendering engine using Canvas. Ok so this post went a bit crazy! But I genuinely believe these fundamentals should be learnt before any kind of framework or library is mentioned! TLDR; learn web fundamentals and their languages before jumping into libraries and frameworks!
Clearly, (new \DrinkContainers\Hot\Mug()) -&gt;loadBeverage() -&gt;consume();
WYSIWYG is terrible for web-based design work. It leads to code you can only easily comprehend through your chosen tool-set at this time, which is what framework and front-end coding aims to help protect you from. You need people in-between the WYSIWYG (in a graphic-design app if needed) and the coding, to ensure you don't waste effort and time re-developing new shiny spokes. It's easier to start with foundation or bootstrap (probably more so now with pre-processors in stylesheets), than by hand. Let the cascade handle differences than to craft a new GUI from scratch implementing a design palette, elements, etc, and reduce from there. What you might be encountering is someone that is front-end or full-stack, interacting with you as a back-end developer, or composition-based designer / author (using existing design work). There is no foot up, or better or worse, just crap work, good work and amazing work. How you get there is less important, but the amount of people required to be involved increases with WYSIWYG.
I am not sure if you understood what I said. The benefits of framework or library routers are * easily read rules with powerful descriptive capability * central rules, so we don't need to map a potentially dense file-system to scry from the void developer mindset * The ability to respond with more than simple HTTP codes, so we know if it's a 400, 401, 403 or 404 (this is also amazing for logging) Routers are a basic part of a system, and as I've said they are not always necessary, but you are advocating /signin/index.php /post/index.php /comment/index.php /like/index.php as an alternative. Which is like advocating reducing limbs and appendages for reduced body complexity. You are introducing more complexity in what seems like a really basic application. If you'd like to tell me I'm wrong, I'd love to know why you feel that is true so you can both demonstrate this superior knowledge and help me and others learn what you know that we do not.
Everyone just tries to force their opinions down our throats. There are too many competing topics under discussion and none of them can claim a legitimate winner on any side of the spectrum. It is all just opinions and emotions. What the programming community lacks is continuous assessment of applied concepts to verify that they result in an advantage. It is hard for humans to sort out things that they invested a lot into. If MVC is wrong let it die, if microservices are wrong don't let them thrive. 
Just look at any thread on /r/PHP you will see plenty of "don't reinvent the wheel", "use Laravel" and "use this horrible Dependency injector". The whole /r/PHP community could be renamed to /r/LaravelFans. I wouldn't mind too much if Laravel wasn't this POS software with this horrible documentation and patterns and I wasn't forced to use it. But I am, not because it is supposedly the best solution (it's not), but because it is trendy.
[removed]
Do you happen to be looking for this? https://github.com/glowdemon1/ysgen#initializing-files-with-content https://github.com/glowdemon1/ysgen#saving-and-re-using-templates You can write your own templates with this, save and re-use them. If you're looking for pre-made templates like these, then I'll have to disappoint you for now :( - I may look into it in the near future.
First off; Impostor Syndrome. Secondly; don't worry about it, people who write about what they're doing online don't represent the normal coder, and may well be exaggerating.
Remember when reading articles on the web you are comparing the author's highlight reel with your day to day - they are naturally going to be better at their area of expertise. It sounds like you may find this an interesting read: https://en.wikipedia.org/wiki/Impostor_syndrome - I have suffered from it myself but have got over it (mostly) by using the above advice. What struck me from your OP is that you have the passion for coding. Few programmers have this. I've been a round a while, and most coders I've met code 9-5 which is fine. But the real skillful ones, the ones who will last in the industry are the ones with passion - who do what you do - read about programming, try to understand other concepts etc. You will never know it all, particularly nowadays. There is so much breath, so many new things - stick with what works and go from there. Also at 2 yrs you are just coming out of 'junior' status. From your post you have exactly the right attitude in that you seek a deeper understanding. This is a character I look for in new hires. My suggestion is to fire up your php framework of choice and start reading the framework code. Learn how folks better than you do it, and you will then be able to stand on their shoulders. My second suggestion is to continue reading - blogs, reddit. Another good tip - see if you can find a Greybeard to help guide and mentor you. Sit at their feet, soak up their knowledge and try to be as good as them. Greybeards get a lot out of mentoring too. The small amount of mentorship I've done (my beard is roan rather than grey), it has been quite rewarding to be forced to articulate concepts in a concise way. In short, as far as I can see, you are on the right path and the insecurities you are feeling are normal and part of the Journey. Even Bruce Lee got butterflies in his stomach before a fight. 
I'm looking for some API which allows me to write "blueprints" for some code. As an example. I have an API documentation written in RAML 1.0 with annotations, which provides me additional information. I could generate from it: - Routing and controllers - Request objects with validation rules - Tests! (at least some boilerplate for it) - For very simple project I can generate whole API. But this is totally not the case since it will be easier to just use firebase instead. The problem is that... I couldn't find anything "better" than just writting some twig templates and wrap it with nick/php-parser.
First of all, thanks for the long answer. I've read about impostor syndrome in the past, and watched a talk about it, but it's pretty hard to get past it (especially since I started a new job). I do have a passion for coding, but I honestly feed overwhelmed with all these technologies. I love Laravel, but in France everyone uses Symfony, and I have a really hard time using it. It's the same for JS frameworks, I can't start learning one since I want to use VueJS since it goes well with Laravel, but everyone tells me to use Angular. The main problem I have with jumping in the framework code is that there's so much different files, I don't really know where to start to see how it articulates altogether. I'll try to follow your advice and keep doing what I'm doing, and try to stop thinking about my skills, but focus on what I have to learn. 
Why are they not the "normal coder" ?
What do you suggest? I've got [this book](https://www.amazon.fr/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612), do you think it's a good start?
Processing Image... Reflection detected... Extracting reflection... Post-processing... Female detected...
A few observations: First: Two years is not a long time; I'd expect someone with that much experience to be familiar with their tools, but not necessarily the big, complicated things you've listed. Second: There's nothing wrong with using a framework like Laravel, nor is "lazyness" a bad thing. Your employer/clients want you to ship working solutions that don't lose data, not to handcraft artisanal, locally sourced, solutions that explore artistic ways to persist data using non-standard storage mediums. :) What you *should* be on the lookout for is places where the frameworks you're using fall down or aren't perfect, especially where they fall short in ways your client/employer cares about (eg, cost, speed, security, etc.). A bank might not care if your proposed solution requires 50% more server hardware if they can be sure it's not going to expose customer details; your local SPCA branch that needs a CMS customized so they can list kittens for adoption might have the reverse priorities. Don't blindly trust Laravel, but don't blindly abandon either. Rather, maybe spend some time thinking: What are five things it's bad at? What, hypothetically, is a project that would be so ill-suited for Laravel you'd be better off not using it at all? On a similar note, don't worry so much about *using* design patterns, worry about *recognizing* them. You're certainly using them all the time without noticing it. When you say you "develop a bunch of features together", the way they fit together is going to be a design pattern, and there's a limited number of ways they *can* fit together. With time and experience you'll start to find that when you "develop a bunch of features" some bits keep popping up again and again. Eventually you'll find yourself saying "man, this is just like the Foo project, and I already found a good way to validate all these forms...I'll just do that again". That's a design pattern. :) Speaking of which, design patterns exist to solve problems (specifically, difficult problems that need to be solved in code). If you don't have a problem (because some aspect of your language or tooling solves it for you, or because you're working in a different problem space) you'll have zero use for the design patterns that have evolved to solve that problem. Don't worry about it, and don't try and cram it in anyhow. And in terms of DI in particular, DI solves the issue of having a complicated dependency graph, and needing to substitute in different dependencies at runtime. Example: You might run into this if, say, you want to send all emails via a third-party service like Sendgrid or Mailgun, so you may a little Email object that different classes can import and call a send method on. But then you realise that actually, your test scripts don't want to send emails, so you add some if/then logic to the send method to check what environment you're running in. But then you realise that sometimes you need to test that the email class is running, so you add some overrides so tests can pass an extra flag if they actually need to send an email. But then you realise that for some of your clients you need to use a different email provider, so now you've got another flag being passed in, and your send method is turning into a pyramid of boolean logic, environment variable checks, override flags, and if/else conditions. This is not great; your Email class is starting to get really complicated and fragile, plus it needs to "know" about a ton of business logic, which isn't great. All of this can be solved in a few ways, but ONE of those ways is DI: If you create a preconfigured Email object at the start of of the request that does, and pass it down to where it's needed, then the actual object can be really simple. Which is cool! ...but if you're reading that and shaking your head and saying "I dunno, I've never had an issue like that" then that doesn't mean you need to find a way to use DI anyhow, it means you don't have the problem that DI is used to solve, and that's good! Fewer problems is better than more problems. :)
Can't take this seriously. Your docs have invalid syntax &gt;.&gt;
Thanks for the answer. :) The problem with Laravel is that I couldn't find any case in which it wouldn't be good in my old job: I could use the technology I wanted, without having to care about anything but getting the job done, and fast. It was mainly small applications which served a single purpose (like extracting data, or sending alerts). I have not encountered a case where I'd need to use DI yet. For your mail example, I often see it when I try to understand it, but for instance, with Laravel, it already comes out of the box with a Facade, so if I want to swap the implementation I just have to change a string in the config file. I am currently trying to develop a few applications: a budget app, an app to visualize phone data, and a crm app, but I find the way I code very "rigid": there's no abstraction, I just develop the features as they go. I've been trying to use TDD to make it better, but I find myelf making more integration tests than unit tests. Thanks again for the answer.
She said she doesn't know because you don't get invited :(
&gt; The main problem I have with jumping in the framework code is that there's so much different files, I don't really know where to start to see how it articulates altogether. A neat tool, which can help in these situations, is and IDE with symbol links. Something like PHPStorm, which allows you to ⌘ + click a class/function name, and go to the definition. With a tool like this, you can track the flow of logic from one class to the next. You can figure out inherited logic. On the other side of this are debugging tools. Learning step-debugging is pretty useful, when you're trying to figure out how your application is in a certain state (or even what that state is). Far more useful than `var_dump` debugging... [Edits for spelling and grammar]
&gt; people who write about what they're doing online don't represent the normal coder I'd say that depends greatly on who is doing the writing/coding. I only write about things I've learned, most often just after I've learned them. Sometimes I volunteer to write about something before I've learned it, and the process of writing gives me the experience to write about. I think the key is how writers portray themselves. Do they call themselves thought leaders or subject matter experts? Then they better have vast experience in the topic. Have they spoken at user groups or conferences about the topic? Do they have a business or product built on the experience? I'll give an example: Jeffery Way writes/records/speaks loads about building applications with Laravel. Many would call him a subject matter expert and an excellent teacher (myself included). Does he appear to have vast experience on the subject? He has built and maintains laracasts.com, and many of the things he teaches are taken straight out of the codebase. I would hazard that this writing is not exaggerated. Granted, good teachers are not normal in the sense that they are willing (and often able) to teach. But their ability to share does not mean they're abnormally able to program or in any way disconnected from the realities of everyday programming. 
If you've been in the field for two years, don't worry about it. Even if you've been in the field for 10 years, don't worry about it. Some people have a passion and a knack for building tools, some don't. No big deal.
If all classes were in the same namespace, then every single extension/library/etc would have to make sure they never have the same class name as another library/extension. That's obviously a very hard thing to do, to have every developer of the tools you plan on using to make sure they never conflict with eachother. To solve this, namespaces provide a way to put all the classes in a "folder" of sorts that makes it easier to keep all your code organized in a "space" denoted by a "name", (hence namespaces). Does that explain it?
Not the OP but articles you find online are either from A) Someone who _really_ knows what they are talking about or B) _really don't_ know what they're talking about and their article gains attraction because people want to discuss how wrong they are In general, average developers (or average anything, really) don't get attention. So what you read doesn't represent you, it represents either the really good or the really bad, in general at least 
The ELI5 version: I tell you that I live in the town of Springfield. So you put Springfield into your GPS and realize that there a couple dozen different Springfields in the US. It's a very common place name. Which one was I referring to? Without giving more specific context, there is a naming collision - the name is ambiguous as it refers to more than one place. By telling you more information, the issue can be resolved. So I tell you "Springfield, Wisconsin". You type that in, and then once again, you find that there are 5 places in Wisconsin named Springfield ([not making this up, btw](https://en.wikipedia.org/wiki/Springfield,_Wisconsin)). You still need more information to resolve the naming ambiguity. This time I tell you what county - Jackson county. Now the ambiguity is resolved, and you know exactly which Springfield to navigate to. In English, we might say "Go to Springfield in Jackson County, Wisconsin.". It goes from most specific, to least specific. In PHP we do the opposite for namespaces: `use Wisconsin\Jackson\Springfield` - more general to more specific. A more extreme example: `use Milkyway\OrionSpur\Sol\Earth\USA\Wisconsin\Jackson\Springfield` (aka writing Java -_-) That's the entire purpose of namespaces - to resolve ambiguities when two different classes end up having the same name (which is a very common problem when you start using different libraries).
1) How would you then reference that class? 2) What is the "namespace" keyword used for? 
The `namespace` keyword is used to declare the namespace the class is part of. In the above example, the `Springfield` class would look like this: &lt;?php namespace Wisconsin\Jackson; class Springfield { ... } Then when you want to make use of this class, you'd do this: &lt;?php use Wisconsin\Jackson\Springfield; $springField = new Springfield; Meanwhile there might also be this Springfield: &lt;?php namespace Massachusetts; class Springfield { ... } And you would use it like this in another part of your application: &lt;?php use Massachusetts\Springfield; $springField = new Springfield; But what if you wanted to use both together? &lt;?php use Massachusetts\Springfield; use Wisconsin\Jackson\Springfield; $springField = new Springfield; // Fatal error, which Springfield are you referring to? $springField1 = new Springfield; // Fatal error, which Springfield are you referring to? To resolve that, you can either alias one of them: &lt;?php use Massachusetts\Springfield as FooBarSpringfield; use Wisconsin\Jackson\Springfield; $springField1 = new FooBarSpringfield; $springField2 = new Springfield; Or you can just inline them directly rather than using the `use` keyword. &lt;?php $springField1 = new Massachusetts\Springfield; $springField2 = new Wisconsin\Jackson\Springfield;
I've been a developer for almost 20 years, and I've spent the day today working on a task I've never done before. So I'm learning as I go along. I don't use Laravel, but I feel like if I need to I can learn it quickly. Some years ago I needed to write a reasonably complicated site in Cold Fusion, which I thought was a stupid idea, but I learned Cold Fusion quickly and delivered the site on time and it worked flawlessly. The key thing here is that if you want to be a competent dev you need to know how to learn things quickly, and learn on the fly. If you feel you are good at learning things, you will be fine. Laravel is not a dirt simple thing to me. I've looked into it some, but it is far removed from the way things were done in 2002 when I first starting learning PHP. For that matter, I myself am far removed from what I was doing then. So, it's a never ending learning process. 
`use` is a way to define a shortcut once at the top of the file, so you can just do: use Wisconsin\Jackson\Springfield; $obj = new Springfield(); $obj1 = new Springfield(); $obj2 = new Springfield(); Rather than $obj = new Wisconsin\Jackson\Springfield(); $obj1 = new Wisconsin\Jackson\Springfield(); $obj2 = new Wisconsin\Jackson\Springfield();
I have run an industry standard site for almost two decades, Loads of data, hundreds of thousands of indexed pages, etc. I originally built it like Johnny Cash's Cadillac, one piece at a time. When something got too time consuming to maintain, I would find a way to upgrade that piece. I started in PHP3, so you can imagine how different it was from today's best practices. However, it has done its job for many years, with very few hiccups. It is far easier to maintain now than it was in the beginning, but it still needs upgrades here and there. It's a never ending process. In my opinion, if you use a lot of includes as you say, someday you will need to change the path of every include on every page, which is a bitch, but not impossible. I've done it several times. THIS is where using classes and Composer's autoloader is a huge benefit. I don't think it necessary to rewrite the whole thing from scratch when it works.
I read this book just a few days ago (although I did not have a project to modernize). T is extremely detailed, and well reasoned on why a particular way is bad, and what you can do to prevent it, etc. I also liked the flow as it takes you from the legacy code base in its worse condition, and making changes step by step. Larry Garfield did a great presentation about the development of Drupal 8 from 7. Drupal 7 was a PHP 5.2 CMS, with tightly coupled code, an in-house routing, template, and rendering system mostly built on functions, includes, difficult to test code, etc. D8 is quite modern code base built upon Symfony routing, Twig, etc. It doesn't go details, but how we all managed to improve it step by step. 
&gt; OP is not doing object-oriented programming, despite whatever loose similarity you might see between their "1 script per part of the website" and concepts in OOP. Sorry, your point is unclear. Are you arguing that if he's not using the OOP features of PHP, it's not OOP? What about all the folks doing OOP in assembly and C?
Not stupid at all. Do what works and what is appropriate to the project. There are much more important things to worry about than your programming paradigm- one being security/validation. OO doesn't even begin to become efficient until you start doing very large projects and/or more than one programmer on the job. Even then, the benefits are debatable. 
This is how Laravel handles polymorphic relationships out of the box, but it is a bit inefficient for a SQL database. I'd recommend creating a table with a primary key and the class name, and a foreign key in the table that points to the class it relates to. For instance you have an addresses table. Your users, orders, and retailers all have addresses. The way you're suggesting would be to have Addresses - 1 - &lt;data&gt; - user/order/retailer - 2 - &lt;data&gt; - user/... - ... Instead of 'user/order/retailer' use a 'type_id' that points to a 'types' table of sorts. It also makes it significantly easier to change the name of the type for a large number of records.
You are really naive if you think that we can all choose a good company, most of us just take the first one that accept us, after a good number of recruiters not even picking up your name because your name sounds foreign or you are too old, or whatever they don't like in you. But yeah, in theory I agree with you 100%, but the reality is far from being as ideal. And yeah I have to work with code from people who don't know anything in PHP but actually do code with Laravel. It's sometimes funny, but most often… not so much.
&gt;Impostor Syndrome. You keep using that word...
Just asking this question indicates that you're not stupid. At the end of the day, if you're the only person that is ever going to look at this code and it makes sense to you and it's secure and it works, just leave it. If you ever will need others to work on the codebase, then standardizing and modernizing it is a must. 
\&gt;ActiveRecord implementation \&gt;SOLID 
Watch this talk :-) https://vimeo.com/album/4045988/video/173322918
Watch https://www.youtube.com/watch?v=taklO4YIMow as well 
PHP dev for over 15 years piping up, of which about 5 have been in the field. First of all, there is a lot to learn here. Being a good developer is hard and it's a real trade. Just take in what you can, do it in chunks. Nobody can do it all at once. In another two years, you'll look back and go, oh man I can't believe I learned so much in such a short time. And it's all because you're trying and putting in the time. You're doing well. I'd say you are a *good* developer. You're curious and you want to develop well. Please hold on to this. Try to learn and try to be a good developer. This already sets you apart from the shitty developers that PHP is unfortunately known for. I know professionals of over a decade that are a lot worse than you will be in just a few years, if not already. Feeling that you need to grow is a good thing but also a dangerous thing. Keep feeling this way, but don't let it get you down. It's a fine line to tread and the curse of people in our profession: there's so much to learn so even if you're good, you still feel like you are an amateur among the wise and learnéd, which is why they call it [impostor syndrome](https://en.wikipedia.org/wiki/Impostor_syndrome). Keep at it. Work, learn. You'll grow and you won't even know it. Just use version control, preferably Git. You're a crap dev if you don't. :)
The concept looks very interesting, but the statistics details fly over my head, so forgive me if my question seems a little stupid! In your example, you state that you can use it to model potential prices of properties coming onto the market etc. This is an interesting idea, but how do you account for external influences and market sentiment (i.e. things which are not so easily quantifiable)? E.g. if you were to use statistics of properties sold over the last 5 years where I live; they have close to doubled. The price per square foot of a property sold 5 years ago is therefore quite different to what it is today. Are you able to plug such external influences that affected this rise in price into the data you are analysing, or if they can be quantified are they just added to the data set and thus considered part of the data under analysis? Thanks!
Two years is not enough time to worry about how good you are.
Thanks for good example
You know you're lacking on that regard. That's a good sign. Go ahead and learn some design patterns, write a small mvc framework as a learning exercise, learn how to test code. Get yourself out of your comfort zone.
There are! For example Memio is a PHP code generator that relies on templates: http://memio.github.io/memio/
Facadavel?
Without the ending ?&gt; the coffee might fall out of the bottom of the mug.
Yep. And using a form component (like Symfony's) would do this automatically.
As most comments already suggested. 2 years in the field is a pretty short time to know all the stuff you have listed. Most of it comes from experience, which is exactly what you are building up by working,reading and hobby projects. Apart from the suggestions you already got, one thing I didn't see from scanning through the comments was get help from more senior developers at your workplace or at open source projects you like to get involved in. Most of them have a chat on freenode, a mailinglist or some other way to get in contact with them. Just ask them for a beginner friendly task or how you can help out in other ways, e.g. documentation, if you don't feel comfortable diving right into code. For me a big boost was having people around me in my day to day work who I could bother any time with a question or discuss designs with, not just in an abstract form but right on the project we were working on. Why did our leads decide to do something the way they did? Why choose this over that? If you have helpful colleagues who do good code review, you will learn a lot and you will learn fast. Maybe your employer even offers to subsidise conference visits where you can meet other devs and discuss and learn or maybe they will pay for books/e-books if you ask them. Honestly pretty much every place I worked at was eager to help me learn and develop (new) skills and if your company is any good/values their developers they should too in some way or another. If you have the feeling your company doesn't support your development enough maybe consider going somewhere else.
Here is an explanation why this function is inapplicable: https://phpdelusions.net/pdo/sql_injection_example#quote Let me know if you need any more explanations.
When using PDO it doesn't really matter which DB you will be using. Ever heard of Wikipedia? Yeah, they are using MySQL, so no worries.
One thing important to understand is that there are three principles you should be trying to improve on: 1. Don't write the same code twice Basic levels of this I'm sure you know, such putting code into loops or functions and re-using those. But you should always be on the lookout for more opportunities to do this. Not just functions, but class inheritance or dependency injection to prevent having to write the same code inside two different classes. Modularizing your code makes it way easier to maintain and easier for someone else to understand when each function is broken into understandable chunks. 2. Abstract your code While doing #1 and writing your code in many different parts, don't make any of those parts depend too specifically on another part working in a certain way. In a general sense, each part of your code should not know how the other parts work, and should not make any assumptions about that. A basic example would be for instance, database queries -- Rather than running an SQL database query directly from your PHP script, use a dedicated class to fetch the data, and have your script interact only with that class, calling methods such as $user-&gt;load() or $user-&gt;save(), etc. This way if you need to change your database structure or even entirely change what database you're using, or anything else relating to database-specific logic, it has no effect on your PHP code, because your PHP code does not rely on knowing what database you're using. Another term for this is making your code "loosely coupled", great Stack Exchange answer here: http://programmers.stackexchange.com/a/244478 3. Document your code and make it self-documenting There's 1000 articles on this and you probably already know, just including it on the list. As you work on your code, keep those 3 things in mind. If you get a nagging feeling when working on a piece of code that it's violating one of those 3 things or you feel like there should be a better way to do it, then do some research into how other people have done that particular task you're trying to do. Most of the design patterns, concepts, techniques, etc all come down to accomplishing one of the above 3 goals. 
It's not a realistic example when you click an anchor rendered for humans, and get back a raw API response, is it... Truth is doing TDD for the "frontend" part of a typical public site is a waste of time, unless the site is giant and changes *very very slowly*. And this is because on a typical frontend, the *way* content is rendered changes *constantly* to reflect changing needs of the stakeholders. There's A/B testing going on, new campaigns pop-up, re-organization and so on. TDD makes more sense in testing pure APIs, but then, if factored correctly, you don't need to go through the HTTP dance to do that, but you can use the native API interface for your domain you have right in PHP. So you'd rather have something like: $result = $domain-&gt;shapes-&gt;getArea(['width' =&gt; 10, 'height' =&gt; 2]); assert(20 == $result); Or similar.
Dunno if you don't know the difference or it's just phrasing, but the way you put it is confusing. When using PDO it DOES matter which DB you will be using. PDO won't rewrite your SQL for you to conform the SQL flavor. So, to use two different databases you will have to write two different sets of SQL queries.
One must appreciate the original author's cognitive dissonance: A: using a framework makes you less of a programmer B: PHP is a framework C: use PHP You'd think someone who believes that "Building software using general purpose frameworks **doesn’t make you a coder or a programmer** any more than putting together a pre-built house makes you a carpenter." would conclude that he should use a low-level programming language like C, but it all becomes clear when you factor in the following psychological projection: &gt; Many of today’s programmers [...] **in order to appear more clever, more cool, and more acceptable** [more of a programmer, anyone?] by whomever they regard as their peers There we go. The author is trying to tell us, in a Freudian way, that he prefers to reinvent the wheel because it makes his perceived peers consider him more of a programmer. Followed by rationalization and appeals to authority. Addressing each point is overkill, but I must mock this one: &gt; These people seem to work tirelessly at getting other people to follow their way of doing things. *"Therefore you should follow my way of doing things."* Like one projection wasn't enough...
I'm learning Python in my free time , but I feel that I need to get really good at PHP before trying to learn another language. What do you think?
Will watch tonight, thanks a lot!
Hi Airhead2016. Thanks for your feedback. I agree. - It may not be the most realistic form of testing. - Frontend does change more frequently on certain pages. I feel you can use TDD to develop themes. When I worked as a theme developer, I wish I knew about TDD and testing. Even on small projects it would have proved to be useful. Not essential, but useful. As I mentioned in my other reply: "This video is part of a course I am doing called "A journey to TDD". If you watch all the videos in order this video makes sense. This is the part of the series where we start to write our first tests after learning theory. The full series can be found here: Testing - A Journey To TDD: https://www.youtube.com/playlist?list=PLrIm-p2rpV0EWSkkE6Llxaw7sxnsxdVWB I can understand why the title, out of context, may make you feel this way." Maybe next time I should be more clear about that. 
No, s/he was pointing out that OPs mention of 1 view, 1 code does not represent the use of OOP. Just because it could align to the VC part of MVC does not mean anything even close to OOP has been used.
"More complete" is highly subjective here. Despite conventional wisdom, some companies are finding that MySQL provides better performance, stability and a more mature support for critical features like replication than PostgreSQL: https://eng.uber.com/mysql-migration/
The fact that you feel the need to learn more makes you a good dev. Comparing yourself to others with greater experience than you can be, both motivating and disheartening. The trick is to focus on improving yourself and not thinking too much on what others can do that you can't... right now. Working as dev is like climbing the infinite staircase in Super Mario 64, there will be always something new to learn and achieve. So, keep on climbing.
i think the simples explanation for the 'namespaces' you can get is from php.net manual : &gt;For example, in any operating system directories serve to group related files, and act as a namespace for the files within them. As a concrete example, the file foo.txt can exist in both directory /home/greg and in /home/other, but two copies of foo.txt cannot co-exist in the same directory. In addition, to access the foo.txt file outside of the /home/greg directory, we must prepend the directory name to the file name using the directory separator to get /home/greg/foo.txt. This same principle extends to namespaces in the programming world. source : [php.net/namespaces](http://php.net/namespaces)
I for one like the "outside in" acceptance testing methodology. Test to make sure things appear on the page, then if you need to write tests for just a single unit you do that when you get to it. Adam Wathan is starting a screencast series where he explains this. Adamwathan.me
[removed]
I taught myself PHP for 6 years now, starting with HTML, CSS and Javascript 15 years ago. It's not my fulltime job, but at every job I use these skills. On the side I make web applications for random clients. I'm completely the opposite; I'm constantly making frameworks from scratch and improving design patterns for particulair applications. But I have no notable experience with any existing framework. While making my own PHP frameworks I looked alot at the internals of Laravel and CodeIgniter. However, I do feel exactly the same. For example; every job application I look at, requests experience with framework this and technique that. However I think I could get the job done, but I feel like I'm missing something compared to other developers.
This seems like a job for the business logic layer (the one issuing a command), not the storage logic layer (the one converting a command to SQL queries etc.). I see no good reason to mix these.
As a developer, you're always a bad developer. It's one of those jobs where you never stop learning. But if you are mastering frameworks after 2 years, you're on a good track imho. Many people out there with decades of experience who still code like it's 1980. You cannot expect to be equally experienced as a 10-20 year dev, when only having experience for 2 years. Don't waste time on trying to put a value on where you stand, just take every opportunity to learn new things and different concepts, without ever getting afraid to learn new stuff. Never believe that you know everything already and keep learning, that's what makes you a good dev. 
I'll take it as a feedback. I'll try to add audio in my upcoming updates. In further updates, it wont seem to you like an amateur video for sure. I've been seeking for a better screen video capture software.
I'll reading all the thread before evantually write something other, but there is one thing i can tell you just now: "I code during the day, and I try to learn new things at night." This could be really wrong. Spent too much time coding and studying could reduce your performance when you work and your learning ability when you study. It's not only about to be tired after a long day, it can have long term consequences if you are too stressed out. I know the exciting for doing more, but don't overdoo it.
You're using dependency injection by using the services. Symfony favors it because it offers a whole lot of power, and it's very easy to work with. Also I typically don't use annotations, and I find most docs have annotation/yaml/php config sections.
At first I thought it was because I still had error reporting on in the quest script because I added that very recently but after checking I see I have it all commented out. Then I realized that I'd been getting a lot of error reports from players recently, after moving servers. Going to take a look at my php.ini, thanks.
Don't do Oracle. The setup and maintenance is dramatically harder than MySQL. It is solving a problem you do not yet have. MySQL DOES support crazy amounts of data, provided you have all your indexes set up correctly, set up read replicas, partitioning etc... Although I have no experience with it [Amazon Aura](https://aws.amazon.com/rds/aurora/) is said to be fully MySql compatable with the same level of performance as Oracle.
Many thanks for the clarification. Makes good sense. I'll bear your library in mind when I get round to doing stats work in the future. Thanks!
No, that's not how plagiarised article works. The author could have intention of quoting or have taken reference from different sites while writing article, and in those cases, he must provide the source of the content, else we remove his stolen content from the article and send him warning before banning him. Take down of article only happens if the whole content is just the mirror OR Whole article text is exactly same but with different color design or layout etc., This scenario, we consider it in immediate take down. Some of the similar scenario's where copyright violations doesn't happen are like :- 1. Posting "Reaction to Movie trailer along with `whole movie trailer` embedded in corner of video" in youtube doesn't violate copyright. 2. Quoting or Referencing any part of text from any site and providing exact source URL from where the content is copied, so that readers interested more to read from reference URL can visit and read about it. Let me know, if there is any misconception or question about copyright violation in w3clan. Thanks
I agree that you should learn other languages for 2 reasons: 1. you will become a better programmer 2. you will become more marketable I write PHP for my job and I do Android programming in my spare time. It allows me to learn new things and keeps me motivated.
Research polyglot persistence. You could provide a standard MySQL setup for free customers and something hybrid with added systems (Mongo, Cassandra, Redshift, etc ) where additional searching or analytics are needed. 
&gt; Edit: stupid link won't allow parens at end? [Cassandra Comlex](https://en.wikipedia.org/wiki/Cassandra_(metaphor\)) ```[Cassandra Comlex](https://en.wikipedia.org/wiki/Cassandra_(metaphor\))``` Gotta escape it
You aren't stupid, you're just learning. If you can find the time, I suggest you rewrite the code using OOP a bit at a time because it will be easier to maintain in the future. Good luck!
3 years is an awfully long time to forget syntax. If it is parameter orders, that par the course with PHP, since parts of it are inconsistent, however if its the syntax of how to structure a class, or a loop etc, i'd say that is normal only for the first few months to a year perhaps.
Thanks for the feedback, I actually have a limit of 15 characters on the username (right now I'm thinking I could have made it 20) and only now noticed that I did not put a "maxlength" on username input on the login screen. Changed the max length of a username to 20 everywhere and added a max length to the login username input :) If you want I can add that last L to your name, not that I expect you to log in after this but hey.
Been working with PHP for nearly 13 years now. I can't do half the shit I read about. I use SlimPHP for pretty much everything, can build a semi-decent REST API, and know how hard something will be to develop. Otherwise, I feel I should be a mega-wizard at this point, but I'm only grunt.
&gt; The problem with Laravel is that I couldn't find any case in which it wouldn't be good in my old job I'm 15h late to the party but I wanted to chime in. What others say here is good advice but it's very general advice. People around here are very well meaning but tend to think in ideals. It's also a big field so you and somebody else might have the same job title but very different things. If it helps, I'm a senior software engineer (official title) and I haven't written one line of PHP in four years that wasn't in some type of framework or CMS. If you're doing web-based development then almost everything is probably better off in one. People will always say "use the best tool for the job" or something along those lines. What they don't mention is there isn't a 100% right answer for that. That's when people become human and their bias begins to shine. Go ask /r/programming and they will tell you PHP is **objectively** a bad language. Go ask /r/drupal and they will tell you WordPress is a garbage fire. Some devs will say Symfony is too big and complicated while Laravel is not robust enough. And all of those will be **stated as objectively true facts**. When one of those people decide on "the right tool for the job" it will be different from the next. As many have stated - programming is about problem solving and critical thinking. That applies to everything. So, take what you read online with a grain of salt. Especially since you're just starting out in your career. Don't be closed minded. Ask questions. Learn who to ask for different questions. Learn to recognize theory vs reality. My last six months have been spent doing primarily WordPress work. A very vocal part of Reddit would consider me to be a shit-tier developer. Some would argue I should only be called a 'coder' because I'm not a real developer. I essentially know PHP. Sure, I can read anything and I could probably make just about anything work but I wouldn't want it to go to production. Yes, here I am, a senior developer at a company the specializes in development and brings in around 85M a years. You do what makes you happy. Be okay with failure. There is always somebody smarter. Learn from them. Help the people that are less skilled than you.
Thanks, will do. I did find a stackoverflow question ages ago where someone had the exact same problem as me but I can't really find it anymore. 
It was more like, we played a game where we got one item each 2-3 days and they had to be distributed over a group of 6 friends. I just made an array of my friends, did a rand(1,6) and then took the friend that won out of the array, next time I'd run it again as rand(1,5) etc. It worked fine, and we used it a while, but then people started to complain that I was messing with the results because some people got last place 2-3 times in a row, but well, that's how randomness works. But the thing about making a sort of lottery was just to illustrate what my knowledge of PHP was before starting work on the game. I began with looking up how to make a registration and login system with properly hashed and salted passwords, making sure I was protected against SQL injection, the base stuff.
Just to be nitpicky, the form component doesn't persist the entity, the ORM component does. You could use an ad-hoc object with a form/component form whose attributes are set via $_POST and then run your own query to persist the data. Not that most people would, but frameworks are flexible! There's always tons of room to make bad programming decisions.
&gt; Fewer problems is better than more problems. :) I need this on a poster.
Who's awesome? You's awesome.
Ah, I didn't see it on yours. I had just made an almost identical comment on another users post is all.
And then there are things like this now 11-year old bug: https://bugs.mysql.com/bug.php?id=11472 We got in trouble because of it in like 2010. These days we're on PostgreSQL and we're more than a little bit happy about having made the move. When Oracle bought MySQL, we figured it was also likely to slowly but surely crumble to pieces - so far it hasn't really happened, but...
Mysql performance degrades after a few gig?? Slightest bit if tweaking and ur talking hundreds if gigs. Been there and done it. It's free so why not test it and find out? :) I'd go for Mariadb over vanilla mysql btw - they've added some magic sauce
DrWhatNoName has sharp eyes. I had a missing closing parenthesis on two lines.
Does this have a GitHub or other means of perusing the code? Or is it closed-source? Just curious. Also liking the game so far, haven't made it to the battle system yet, but the daily bonus and general UI looks nice. Got to also spin the wheel too. :)
[removed]
Bugs aside, this is really neat! Game development was my second choice after web dev, and I didn't go into it because it's such a total shit show for work-life balance. Well done :)
Cleaning up my company images to share is gonna take a while, but here is the basic setup I would use in my docker-compose file for a project that I need to run with NGINX and PHP-FPM: version: '2' services: fpm: image: server-image-phpfpm70 restart: 'always' volumes: - ./webroot:/var/www/html web: image: server-image-nginx ports: - '30001:80' - '31001:443' volumes: - ./launch/sites-available:/etc/nginx/sites-available volumes_from: - fpm links: - fpm:fpmhost restart: 'always' depends_on: - fpm I usually have a project folder for each site on my dev server that contains a 'webroot' folder and 'launch' folder. Website files all go into webroot and anything like system config files such as the NGINX default go into launch. I spin up the PHP-FPM container first and load the webroot volume. Then the NGINX container gets launched with the correct ports, the NGINX sites config, I load the webroot volume using 'volumes_from', and then let NGINX know what host to connect to for PHP-FPM using an alias under links. So instead of using the UNIX socket file, your config will say: fastcgi_pass fpmhost:9000; Assuming everything in your images is correct, 'fpmhost' will be added to the hosts file of the NGINX container with the IP address of the FPM container and both containers will have access to your webroot. If something is wrong with your PHP-FPM setup, you'll get a Bad Gateway message. If something is wrong with your shared webroot you'll more than likely get a 404 message. But with any luck you'll get your site to load up. If you need to change from PHP 7 to 5.6 or earlier, you just change the image reference in docker-compose and restart.
Just FYI: Use a \\ to escape the markdown reddit formatting, so 'user\\\_email' becomes 'user\_email' Also you can get do `user_email` by writing out \`user\_email\` (Those are backticks)
I always feel like I am a horrible developer. Reading so many blogs and I know I am not even close to as smart as these developers, but somehow I have stayed employeed the last 10 years as a developer. Sometimes I feel like my employeers are being suckered. Recently my employeer bought a software pacakge from a company for 200K (for the source code). The language was c#. Last time I used c# was about 12 years ago or so (in college). I took one look at the source code and it blew my mind on how terrible it was. I dont know the .net framework anymore but it was the design of it. This was a project that screamed for OOP yet was 90% procedural code. I spent a week or so reading up on the .net framework and dove in and got my hands dirty. Within 2 weeks I refactored the majority of the software. Multiple places they had functions that were 100 lines long that I could rewrite with 5 lines of code. While I still think I am a bad developer, this opened my eyes to that there are also a bunch of other bad developers out there. I just need to be less bad than they are.
It's closed source yeah, sorry :) It's something that I once thought of maybe actually turning a profit on with some ingame micro transactions, but purely optional. There's no "premium currency", everything is just bought with gold. I eventually wanted to charge a few bucks for a name change or something and packs of gold. But thanks a ton! That really means a lot to me. It's something I'm proud of because I made it all myself (well, aside of the sprites, those came from a free pack and some artists I hired) and even though it's simple and doesn't really have nice animations and full character models, a niche crowd really likes it.
This is probably a book you are looking for: [Head First Design Patterns](https://www.amazon.co.uk/Head-First-Design-Patterns-Freeman/dp/0596007124) Instead of showing you the encyclopedic description of specific pattern, it presents a problem and a way to solve it. In a way you learn patterns organically. Examples are in Java, but easy to understand. 
I find time to balance between working and resting, and sometimes spend a few days without coding when I need to get out of it for a bit.
Thanks, this list looks very interesting, will do asap. :)
You should have errors logged to a file and you should review them daily.
 $theQuestion = function() use($2b) { return ($2b || !#2b); };
I know how the paths works-- but sharing from a singular Amazon non-block virtual device via standard official Docker hub images has been... fun to say the least. Edit: --from someone else smarter than me... https://github.com/micahhausler/container-transform
Cool cool, no problem. I was curious just to see how you did it! Everything custom, or did you use any popular packages/frameworks? If that's not prying too much. (I know you said you made it all yourself, but I guess clarifying what "all" means is my question :P) Also, good luck with future installments of this game! Question about the battle system. I just hit "Attack" and it goes through the motions for me in the arena and in the quests (both of which I lost so far :[ ). Is that just how it is? Just curious because I was expecting more turn-based-ness coming in.
That's a very good article. Thanks for sharing.
http://www.fluffycat.com/PHP-Design-Patterns/ Learn design patterns! 15 years here
&gt; Object-orientated programming is literally defined as "using objects". So I think you're arguing that object-oriented programming isn't possible unless a language supports OOP abstractions. But it is. http://x86asm.net/articles/oop-from-low-level-perspective/ From a computer-science-y point of view OOP abstractions built into a language are just a "nice to have" — you can do OOP in almost any language. More important is OOP thinking.
While everyone seems to be arguing over naming conventions, I prefer to sidestep the whole problem. A table name, as afforded by the database will never be expressive as to describe correctly the namespace of the code that uses it, the entities it describes, relationships it covers and so on. This is why I've started treating the actual table names as opaque identifiers that are injected into my repositories, and mapped to more descriptive names I use internally. This means *if* I wanted to have a join table named after two tables I could literally have it named "User\*Email" and have it map to anything I get given from outside. Within my code I could just refer to it as "User\*Email" and use a map to convert to the externally specified name. Another thing one can do is have "hierarchical" table identifiers for ex. "Node" and "Node.Person" etc. I'm basically trying to say, be as expressive as you want and map. Because you'd want to not have hardcoded table names in your code anyway. No matter how many prefixes you stuff on your table name, it may collide with something else in the same project, so it's best the names are "inverted" to the control of the caller.
99.9% of SQL statements are for fetching and updating data. It doesn't matter if one uses MySQL or Oracle or Postgres or whatever. 
Sure, but as others have also side - after similar spans of time, they feel they're not on the same level as some of the more famous 'PHP'ers. I don't think I'd want to invest the amount of time it takes to become wizard-like in PHP. To be fair, PHP development isn't my only realm, I'm pretty diverse in my benefits to a team: backend, frontend, business management, planning, discovery of implementation, communication, and helping setup standards. Had I spent my entire 13 years strictly focusing on PHP, I'd surely be among the ranks of those that we all read about :D
&gt; I could write a book about the workings and my motivations behind them hahaha. Perhaps a blog post of some sort would be better :P Though neat with the calculated battles and such. Side note, you should probably look into refactoring pieces now that you have a workable product to work with. Just maybe encapsulate bits at a time, especially globals if you take advantage of those too heavily. That's just my preference is all, this certainly doesn't diminish the quality from the user's side of the experience so far though! 
I've worked with many frameworks. Some suck and some don't. With the ones that don't, I've never felt like it hindered me in any way. Quite the contrary. I felt like it helped me wrote code faster and more robustly and very testable.
I have a friend who is it the same. Niche website built from scratch been in existence since early 2000s (if not late 90s) and when I presented some of my code to him he told me that he'd never done anything in OOP. I was floored, but the website still works just fine and that's what counts.
What year is this? Are we in 2007 again?
Do you have example of projects, or ideas I could develop which would force me to use external resources?
I knew which bug you linked before I even clicked the link. It's the MySQL world rickroll, we should all recognize the ID in the URL by now. :(
This is the kind of thing someone would do if they worked in a silo and had a lot of free time on their hands. I mean, until you've throw a graph database on top of your RDBMS to manage your map-to-uuid tablename metaschemata you've really only been scratching the surface of finding ways to fill your lonely weekends.
We just call them crosswalks because that's what the BAs, directors, and executives in our industry refer to them as. In flat organizations everyone tries to speak the same language.
Hey, thanks for the detailed answer. I'm pretty familiar with Linux alreaday, I have Arch installed at home, and I've been using it for 2 years at my old work. I installed and configured Jenkins, Elastic Search+Logstash+Kibana, I've maintained a Java app (made by externals) doing maintenance + upgrades + minor code updates, played around with Business Object, used Jasper Reports and interfaced it with PHP to generate mass reports, used Talend for various tasks. I've also deployed my applications on Linux servers, installed and configured them to get my apps running, and before leaving my old work, I've done project analysis and wrote specs. I try to use Sensiolabs Insight and Travis CI to have a good workflow. Sorry if this sounds like I'm "showing off", it's not. I just resumed my CV here so you can see I'm kind of a "jack of all trades". You're right for Symfony, I think I'll try to do a few projects on it, and since it's pretty used in France, it might get me some business opportunities, even though I'm not actively looking for work. I'll also try to interface Angular with it, but I'll take baby steps since I know neither Symfony nor Angular. You're also right, there are millions of things to make, I just need to focus instead of going for anything and achieving nothing. Also, thanks for both links, I've bookmarked them and will try to develop something using one of these APIs. 
&gt;and how is it that I still have a job? Because as long as it works, no one (minus you and people who work with your code) cares how the sausage is made. I'm proud of the things I've developed for my employer, but good god does my code make me want to slap myself sometimes.
If I had to guess, out of the blue, phpMyAdmin does that to help organize tables from different systems in the same database, as in `blog__tag`, `blog__post_tag`, `blog__comment`, `ecommerce__product`, `ecommerce__tag`, and so on. These double underscores are not related to relationships between tables. But then again that's just a guess. And of course this scenario would be better organized using different databases, but God knows what phpMyAdmin users had to deal with on shared hosts a decade ago.
&gt; A table name, as afforded by the database will never be expressive as to describe correctly the namespace of the code that uses it Not sure about all RDBMS's but MySQL lets you enter table comments if you want to provide additional context...
Why would anyone ever do this
The controller is pretty much the only place where you should have that problem. In PHPStorm, you can use inline docblocks to type hint that stuff. So you can do like /** @var FormFactoryInterface $formFactory $formFactory = $this-&gt;get('form.factory'); And then you'll have the full power of your IDE that you speak of.
&gt; whereas MySQL performance sharply degrades after few GBs. Only if you do really dumb things with your data - in which case, you'd likely make the same mistakes in Oracle. Even if you do, they're generally fixable (and often relatively easily) Source: 5+TB of data in MySQL (yes, terabytes)
And for those interested, I know in America, this game is called Sequence. Or a very close resemblance of it.
Pretty fun. This is the exact kind of card game that benefits from being digitized: shuffling is a pain, dealing out an entire field of cards is a pain. Computer takes care of the pain points and you can just focus on the game. Which I enjoyed. Good job!
Don't waste your time rewriting an MVC framework unless you actually want to use that pattern. Also, MVC for PHP sucks anyways. It is not true MVC. It's basically just a hack that tries to delegate the responsibilities of a web server.
I'm running a mysql database that's approaching 1TB and it's faster today than when it started. Mainly because today it's php code PDO based and when I started it PHP was using mysql_xxxx calls.
If I had to guess, it would be because non-semantic names are always a bad idea when it comes to software. Even if it makes sense to you now, it may be utter gibberish to someone else later. That said, I can't really see this particular naming practice confusing anyone familiar with SQL, as it's virtually ubiquitous.
This game is fun!
You don't have to build a blockchain. Just use an existing one.
It's not really a question of how to cheat around the problem. It's that the Symfony community is pushing a well known antipattern through its tutorials and best practices. I would venture to guess the vast majority of projects use service location instead of dependency injection and it makes life difficult for anyone else browsing a repo, inheriting code, or just trying to learn good programming.
There's nothing wrong with using the service container in Symfony. Yes, it does add a little to the learning curve, but it's not that big of a deal. I can look at most code in Symfony and get a pretty good idea of what's going on even if they're using the services. A lot of the time it's the same basic services being used... form stuff, validation stuff, ORM stuff, etc. It doesn't take long to become familiar with them. Every framework is going to have some inevitable baggage. All things considered, this one is pretty minor. Symfony has guidelines on services which makes them fairly consistent. You should know where to look to figure them out. Also, a proper IDE makes it super easy to use.
If I have a user table, and need to store email address (1-1), I'd simply add the column to the user table where it semantically belongs. For additional data, use a field name that makes sense. For multiple email address relationships, user\_email sounds good to me. 
I do use OOP now, but I'm not religious about it. Classes are a big help. I don't often use packages (other people's code), so when I need a shopping cart for example I just write a class for it or mod one I've written before. My reason for that is that I seldom need every single feature you could pack into a shopping cart system - I just need a few basics. I'd rather write a simple and solid version myself. Most premade packages are designed to cover every conceivable contingency, and most of it usually doesn't apply to whatever situation I'm dealing with. By the time people started saying only a crazy person would try to write their own authentication system I had already written 20 that worked pretty well, so... It's actually quicker for me if I don't have to wrap my head around someone else's code.
Include tasks a path relative to the current file. It has nothing to do with the URL or web path. You can put your config file outside or your web root and include it there. You could also use htaccess / nginx rules to hide the file. 
Agree 100% with this. This is a nice game. Even if I did lose.
Nice, I've been always wondering how best to do this to deploy on new machines. I might rewrite this as a yii2 command later for one of my projects. Thanks!
Ideally all your code sits outside public_html, and you have a single PHP file there, index.php, that starts your app by looking outside public_html (through relative or absolute path). Otherwise as others said... use htaccess (or respective server config).
Comments are useful sometimes, but not for what I'm talking about.
Please enlighten us with your never ending wisdom. And chill. 
[Can someone pls provide some context here?](http://imgur.com/cMWalaa)...
Solid advice. I'd like to expand a little on that. When coming up with a solution to do a complex task, while breaking it down into smaller pieces, write down in comments what those little pieces are, what you're trying to achieve with them. I often do this before I write any code for the function, though it will admittedly often require some tweaking as I go. Another important thing I often read about but haven't seen in this thread yet: as a rule of thumb, don't make your functions longer than what fits on your screen. Break them down into multiple functions if needs be. This again helps reduce mental load when either you or a colleague revisit the code later.
I assume this tutorial was written in 2007-2008
Can you elaborate on how you made your games AI? You said you evolved it... Is that like you programmed the first version and then made it progressively smarter, or did you actually make a neural network or something?
There's always room for bad decisions :P Anyway, to do that with SF's forms, you would have to define the form on-the-fly, inside the controller, inspecting the request for POST parameters and using them to add fields to it, to match the request... It's totally backwards!! With the "normal" way, the form is defined once and for all in its class, and the request POST field MUST match that for the form to be considered valid.
Good lord. RPMs vs Docker Containers? Docker wins every time. :) But then the challenge might be getting your customers to adopt docker. :\
Yeah. We didn't do it right the first time. I really wanted to get docker figured out but the big issue is we mostly all use Windows machines. Docker for Windows didn't exist yet and boot2docker wasn't very good. Now there's docker for Windows but we still need virtualbox to run some test machines. Hyper-v and virtualbox can't run at the same time. I decided to just switch to Linux to develop a new project with docker from scratch and that worked well but now we need to migrate our other project to docker and get the other devs accustomed to Linux. My boss is worried about migrating our customers to docker - I'll have to script the entire migration so it goes smoothly. Deployments are hard. :(
1) What encryption type is still safe for passwords (php)? 2) Is it worth putting the code to a website on GitHub? Bcrypt -&gt; http://php.net/manual/en/function.password-hash.php 2a (yes) 3 Yes what if you fuck up halfway through. You better have that backup regardless IF you fuck up. 4 Yes, if the device has a interface you can probaly interract with it 5. If you feel more comfortable creating it in VB go for it. Though i recommend to keep the same language troughout your project as you are not that experienced. EDIT: a word 
Doesn't this defeat the purpose of said container? Imho best practice is making a container for diffrent setups. That is what docker is for right ? 
it's worth putting anything you like on github, assuming you don't mind it being publicly visible. (I assume you're not talking about private repos). You've got a back-up. Versioning websites? You mean writing "version 1.5" on the bottom? And I assume you're saying you want to write some software that will integrate with external hardware? Yeah, maybe PHP's not the best for that. 
1. Use `password_hash()` to hash passwords and `password_verify()` to verify if a password matches a hash. You will need PHP 5.5 or higher in order to use those. Yes, they are slightly more complicated than `md5()` and `sha1()` but not by much. 2. I don't understand this question. Put what code on GitHub? 2. I also don't understand this question. 3. You should use version control, such as Git, but you don't need to put a version number in the footer of your website. You could, if you really needed to, put the commit hash somewhere to display what version is currently deployed. 4. Don't use PHP for a cash register. PHP is a great language but it's not perfect for everything. I would recommend C# (if the cash register is going to be running Windows) or possibly Java. I can't even begin to fathom the pain of interfacing with USB via PHP. I'm 99% sure I've seen a library somewhere for it, but don't go down that route. Here's a quote which sums up my point perfectly. "I suppose it is tempting, if the only tool you have is a hammer, to treat everything as if it were a nail." - Abraham Maslow 
&gt; 1) What encryption type is still safe for passwords (php)? I can't believe you cannot google it. Try again. &gt; 2) Is it worth putting the code to a website on GitHub? It's always worth, at least for yourself. You'll be able to use Git version control for your project. &gt; 2a) Like a self made forum? But not a website? Same as above. &gt; 3) Is it worth "versioning" websites (Like software)? Dunno what you mean. &gt; 4) My brick wall would be if I would be able to open a cash register drawer? Could php interact with an USB hardware like that? Once I were writing a driver for a mobile POS terminal that has been connected to a PC through USB. I just installed some driver that made USB port to look like a COM port, and PHP can easily read and write a COM port. So it's possible.
All the context is in the post and the links. If you can read the PHP code, you can get the context. If you came here for entertainment, then better look for another sub.
Just use '_to_' to split them. Most of the comments in this thread are from ORM jockeys (and I mean that as nicely as possible) but eventually apps get complex enough that you need to interact with the DB in other ways. A clear, simple and 30 year standard naming scheme in the DB never hurt anyone.
You don't need any special library for that - look up the format CSV. It's really, really easy - you just output your columns, seperated by commas. That's really all you have to do to export simple data.
Yeah, that's why I meant. CSV is a very basic format, literally every table calculation software supports it.
I am using PHPExcel extensively for both simple sheets and extremely rich and bushy reports and never had a single problem with it. Go on waste your time upon your "maintainability" fantasies.
yeah I"ll try it out. I'm kind of done with this. I don't know why I agree to do these jobs that take weeks/months for $20.00 or $10.00 more, etc... not part of the question sorry.
What is pure Excel? I'm just trying to make this "Dumb proof" no "This is the wrong format, change?" kind of deal when the file is opened up. .xlsx I think is the format I'm looking for. if it's really easy to install php-excel I'll do it. I mean, this is my initial obstinate mindset to new things, like Flexbox where I was like **hurrr rrrr rrr** I don't need that... then Wow I use it every time now. Anyway, well shit, let me try it, so I don't regret going to work feeling like I didn't do anything today.
Honest question - are you on drugs right now?
Nah. I'm tired though. I'm easily butthurt, insecure, impulsive, ask dumb questions like this one at the expense of my internet shame.
Although wouldn't be hard to dox. No worries, I am a nobody. Also I'm straight edge, stuff's not for me, and job requirements. Overall I think it's a waste of money/time(drugs) I wanted to trip but I'm scared I'd be trapped in my own nightmare for the next 8-12 hours. Edit: I did want to add that doing drugs is a matter of self-control. People can be successful and also do drugs. I don't have self-control however therefore I don't mix with drugs.
Create composer packages for your modules.
Well I give up, sorry. I thought I explained it well but it seems you can't get it.
1. /r/phphelp 2. `current($result-&gt;fetch_fields())-&gt;table` 3. there is no point for that as you already know the table name - it's "messages"
to avoid arguments, try sorting the names of all the tables joined function join_table_names(array $tables, string $join="_") { return implode($join, sort($tables)) } **UPDATE** to incorporate `__xref__` or other delimiter 
What about CSV is dirty? I'd argue that supporting an overcomplicated, proprietary format which might exclude other people from using the reports is a lot more dirty.
This. I don't exactly get why I'd prefer `services` over `car_mechanics`. `car_mechanics` directly tell me the kind of relation that table might have to other tables. Can anyone explain why he suggests `services` and why he advises against `car_mechanics`? I've read his article, but all he's explaining is "Don't to it".
It's something really hard to deal with, I struggled with it myself. What helped me was to two things: 1) What could I use the time for? There's a lot of things once you think about it - no matter wether it's working on personal projects, playing video games or meeting with friends, all are things you'd most likely rather do. 2) Why undersell yourself? You are obviously competent enough to do what they want since they ask you. They are not going to invest this much time for free for you, why should you? Especially since you can always use the money.
You don't need a symfony plugin, you just need a simple @var annotation.
&gt; You cannot set the cell type, leaving Excel to guess, which ends up with things like Jun.14 for a decimal value 14.7 I'm guessing "=14,7" should work fine. &gt; Excel for Windows does not recognize utf-8, demanding proprietary windows encoding instead A small google search revealed that you can simply set that upon importing the data. &gt; Excel do not understand a literally comma-separated values, asking for a semicolon instead. Unless you specify the delimiter beforehands... http://superuser.com/a/730509 &gt; To create a properly formatted CSV is not that easy task as one thinks. Can you tell off your head how to escape a quote in a text field? I'd guess that it's double-quoting based on my earlier experiences. But do you know that OP needs that? And if he does, that he can't simply look it up?
Nice guys don't win haha. I have a factory job as my full time job. I'm not saying I'd prefer factory work over web dev. Yeah I don't know. If I'm not going to man up and change then don't complain about it right? Also I'm not a full time free lancer. I work when I can. Which happens to be almost every free moment. Unless I am binge watching garbage. Anyway, also I think the clients don't understand the value of what they're buying. It's like "oh just make it. It's not hard." Of course they'd understand if I said no, but I'm an enabler man. I feed the fiends.
You are correct. CSV is not .xslx. If you really need .xslx then php-excel what you need.
Hey, nice guys do win if they know how to sell themselves ;) The secret is not to just say no. The secret is to say "yes, but with this price". You have probably written the main codebase, right? That means you are the person most familiar with it, and they are going to prefer you to other people. If they ask you next time, think about how much time you'll have to spend - ESPECIALLY if it's your free time. Think hard about that and then think, with a realistic rate, how much you should get for that. For example a client recently asked me to implement a new feature in a piece of software I've been developing on and off for them for over a year. I sat down and thought of possible pitfalls, came up with the hours (I think it was 15 hours, which was with a little buffer - which I actually did need since I found an unexpected problem). The I sent them how much it would cost them based on the time, and they agreed. Think about it this way - if you are already working for free, you have nothing to lose. The worst case is that they say no, it's not like you lose out on anything, right? And the potential of earning money, maybe even a good amount, is better. If you'd hire a web developer. Who do you think does better work, solely based on his offer - someone that does a lot for free, or someone that knows what he's worth?
Two things really fast. 1. I've been using PHPExcel (https://phpexcel.codeplex.com) forever now it seems. The only reason you would want to use this is if you have to do some special formatting or calculations otherwise once you get a large enough dataset you are going to run into memory issues that you will eventually have to manage. 2. Most people will tell you to export as CSV but in my experience exporting as CSV is a horrible idea. There are two reasons that it is a horrible idea (a and b). a. It is a horrible idea because when your client goes to save the file they are going to have to do a save as if they want to keep formatting. b. A client will be running a system that doesn't have .csv associated with excel for some reason and they will have to do open with and it will just be annoying. Therefore the best solution is to do tab delimited instead of comma delimited when you create the file and save it as .xls. This will allow them to open the file in excel directly and save formatting etc without using save as because it is already an excel file format.
That's manual resolution and a pretty strong code smell.
Meh. I've been using Symfony for several years now and I don't see it as a big deal. If you absolutely hate it, you can just register your controllers as services and have "real" DI. In some cases I use methods to return a service from the container - this makes it a little easier to test if I need to, and also gives type hinting with an @return annotation. Symfony's service container is immensely powerful. It can do things that would be impossible or extremely difficult with just DI alone.
Sounds like you need to get outside and go for a walk, to clear your head.
More specifically, do this: https://getcomposer.org/doc/05-repositories.md#vcs
Great I will have to figure out what tab delimited is vs. comma. Thanks a lot for this. Yeah I'm looking for a fire n' forget kind of solution. My code is kind of cluster F'd. So many functions. Hey this would be a great time for OOP!
I can say it's OK (talking mainly about active community than being trendy): - https://github.com/cakephp/cakephp/pulse - https://github.com/yiisoft/yii2/pulse - https://github.com/laravel/framework/pulse
The AI is an extension of the point detection system. The first real programming challenge was being able to detect when 5 chips had been placed in a row. Think of the board as a 100 cell grid, and whenever a chip is placed you need an algorithm to check the cells around the placed chip to determine if the move resulted in a new point. For the AI, it's just a matter of looping through the cards in the CPU's hand, simulating its possible moves, and determining which move would be the "best" move. In the context of this game, the "best" move is determined by how many chips surround its possible moves. So of the 6 possible moves (since each player has 6 cards), the move that would result in the greatest number of chips in a row is considered the best move. There's also a weight system which determines if the AI should be aggressive or defensive. The game defaults to aggressive unless it is losing (down 1 point to 0), at which point it switches to defensive. Aggressive play just means it favors moves that result in placing more of its own chips in a row, while defensive means it favors blocking th human opponent. The last bit of logic deals with wild cards (since 2's are wild, and there are no 2 cells on the board). The AI will only use a 2 if it either a) results in a point, or b) blocks the human opponent from scroing a point. So if you're playing and have 4 chips in a row and the AI blocks you, it usually means it had a 2 in its hand.
That was actually a fight and a remarkable fight. Unlike current ZF and Symfony.
It's funny because I'm actually happy when I lose. In some strange way it's like I'm proud of the AI, almost like a proud parent :P
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Core development wise, it's doing fine - no problems there :) Actual usage in opensource projects however has all but vanished. A prime example. Look at how many CMS systems use Cake3. Then look at how many use Laravel 5 or Symfony.
It seems like we set an arbitrary hourly rate. I happened to pick $45.00/hr better than 30 and less than 70. This job. Of fixing a boot strap web page (which was so bad I just built it from scratch) and then made it responsive. Implemented two recaptchas. Email. Admin panel. And now a CMS. All of this for $20.00 I've since gotten a "raise" for $30.00 so I was just paid $50.00 haha for 2 months of work on and off... I think I have another $50.00 anyway. At least I get to implement my own style. I designed the UI. That was kind of neat. Thanks for your time man. The other thing is I don't feel qualified to ask for that much. I make like $12.00/hr if I'm lucky standing up and doing the same task over and over. I find it hard for everyday people to afford a $45/hr granted what I'm building is supposed to handle traffic in excess of thousands of dollars. So...
Yeah I've been hearing this for a wile. The only issue I've ever had with memcache is its 1MB value limit (per key). Since the game's state object is only a few KB I figured memcache would still be fine for this project. I'll give Redis a try someday though, memcache has just been so good to me over the years it's really hard to make the switch.
I did see that (have the tab open) Thanks this sounds like it will be easy. Take the selected string of rows. Feed it through a loop. I just gotta deal with making on of those windows pop up asking the person if they'd like to save the file. That was one of the things I saw I think, the file has to exist.
Oh no. I thought somebody just said I don't need php-excel to get .xlsx I could use fputcsv just use tab delimiter. I will have to check this out with a fresh mind. Thanks to everyone's help.
I guess my work must be afraid of me losing too much time to the game. It's blocked! I wanted to see how it looked in IE, but alas, I'll have to look at home.
Take a look at http://www.the-art-of-web.com/php/dataexport/ It will show you how to add the header as well from the key names. They use implode instead of the function I suggested as well. Either will work.
congrats! Cant wait to give it a try.
Please don't laugh, but the tech stack consists of CI, Memcached, and MySQL on the backend, and jQuery and Bootstrap on the frontend. I know CI, Memcached, and jQuery aren't the cool kids in school anymore, but really all I needed was a fast and efficient way to send AJAX requests and JSON responses. It probably could have just as easily been done in another framework or some hacked together PHP, but my team at work uses CI so it meant I didn't have to do too much mental context switching between my day job and hobby project.
Dude that's awesome. If I ever make another game maybe I'll give the API calls formal business sounding names. "placeChip" and "playGameKey" are probably a bit too obvious :P Set expectations extremely low for the IE compatibility. The only MS testing I've done was on a windows phone, and even that had issues.
This was in the business logic layer. The storage logic layer is within the $table object.
Or may be you cannot read. This is not my post.
&gt; No I'm talking about large modular systems, so you are arguing a false premise. There is nothing modular about slapping everything onto a single DB server, single controller, single route. The whole shared-everything vs shared nothing is only a competition between groups of incompetents and their over-simplistic pedantry. &gt; Each module is a bounded context (as in DDD terms) and the team assigned to working on each module don't coordinate each others implementations, only their public interface. I Don't know who convinced you an abstract domain had anything to do with implemented modules, or that two implementations should share a data source. I'd suggest what or whoever suggested you force implementations to conform to application diagrams using the same table on the same schema should be removed from your library, contact list and burned. They will only cause you and all those surrounding you a lot of headache. Can I have two tables named person with different implementations? Maybe, but not on the same schema. I'd call it out immediately and be a bit wound up that there were two implementations sharing a storage location in an RDBMS. It's lazy, it's hard to maintain and it will lead to terrible code!
don't use "id" for your table's id col. use tableName_id leaves no abiguity (to the reader or to SQL what ID you're referencing) Allows you to do LEFT JOIN Groups USING(`Groups_id`) instead of LEFT Join Groups ON `Groups`.`id` = `table_a`.`id`
Haven't heard of that. Will have to check it out.
Either way the first comment become irrelevant as the score gets positive now. Deleting.
I suspect the score went positive because of your comment :)
Oh alright I saw questions posted here that's why I posted here. I was looking for something like learnjavascript or ask programming but for php. Anyway I'll keep that in mind.
If you're loading your controller as a service then you're still using the service container, so you'll have the same power there. 
You should probably take quality into account. For example, there are many Yii-based CMSes and many are production-ready but, as for quality, https://craftcms.com/ stands out. For Laravel it's October CMS, for Symfony it's Pagekit. Usually only a single CMS stands out for a particular framework.
For which? * excel compatible * csv? * ods? * excel specific * xls? * xlsx? ODS and XLSX are zip files with some weird custom xml schema... http://faisalman.github.com/simple-excel-php is an old example, but it's not massively hard to write, just nobody cares about XLSX. 
Well, you're able to instantiate classes without making them services.
&gt; Read: https://en.wikipedia.org/wiki/Modular_programming ## Key aspects[edit] With modular programming, concerns are separated such that modules perform logically discrete functions, interacting through well-defined interfaces. So not by modifying the state of a single table... cockwomble
&gt; So not by modifying the state of a single table... cockwomble Sigh. We don't share *tables* between modules (or any state for that matter). We share database connection between modules (when multiple modules run in the same PHP response). You... you really need to learn to read.
Well ok this is really bizarre. I didn't even see the cards at the top and just randomly clicked a card and got my dot. The CPU put a dot down. Then I clicked the one next to mine and it worked. Then after that it stopped working, but the CPU could still puts dots in a single line across... unless there is some bug in the game, the chances of that happening must be infinitesimally small.
Or you could consider Sheets's built in importdata / importxml functions to pull real time data from your php backend. So instead of regenerating excel every day you'd just have a constantly updated Google sheet. 
Oops, my bad. In this case it was just graph paper and time. You can checkout my response to /u/Glutnix to get an idea of the thought process, but basically the AI is just an extension of the point detection system. Graph paper was used to workout the point detection because it provided an easy way to visualize a 100-cell grid. Once the point detection was working the AI was just a matter of choosing the best move available based on the 6 cards in the CPU's hand, and the scores returned by the point detection algorithm.
That is awesome to know a tab delimited file is a valid .xls file! Once they open it in excel and make changes, could the format change to something more complicated than a tab delimited file? I'm guessing the answer is yes, which I would think means that you can't just process all .xls files as if they are just tab delimited data...
u/utotwel you rock. Laravel is a joy to use. The Docs are fantastic and I'm learning so much good practice from using Laravel.
&gt; PHP can easily read and write a COM port. So it's possible. Can you please elaborate? I'm pretty sure I haven't seen such functionality in the core... Were you using an extension?
the only one that i don't see useful is WebSockets because of the PHP runtime.
Chrome on Mac OSX. But it's probably the 2's like you said.
Ok maybe I don't "get it", no problem for me :P Could you please take a look at this functions (from propel, phalcon and doctrine) and tell me which implementation is secure and not vulnerable for sql injections? Function: quoteIdentifier https://github.com/propelorm/Propel/blob/master/generator/lib/platform/MysqlPlatform.php Function: escapeIdentifier https://github.com/phalcon/cphalcon/blob/master/phalcon/db/adapter/pdo/mysql.zep Function: quoteSingleIdentifier https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Platforms/AbstractPlatform.php 
Well, basically com ports are *files*, so you can open it using `fopen()` like this $fp = fopen ("COM3", "r+"); and then use regular functions to read and write 
I actually had some fun playing this game. My only gripe is the lag for the computer player ;)
Duly noted :) I'll work on making it feel more responsive.
WOW this is genius. Honestly never thought about this :D
note that you can link to a particular line in the Github source, simply by clicking on a line number. - [quoteIdentifier](https://github.com/propelorm/Propel/blob/master/generator/lib/platform/MysqlPlatform.php#L752) - is not safe. - [escapeIdentifier](https://github.com/phalcon/cphalcon/blob/master/phalcon/db/adapter/pdo/mysql.zep#L66) - is not safe - [quoteSingleIdentifier](https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Platforms/AbstractPlatform.php) should be safe. Note that Phalcon and Propel may have other means of protection, like white listing implemented somewhere else. But it will be interesting to look deeper, I'll investigate these two functions a bit. 
Unfortunately I don't have my sources from the period when I worked with USB, but it seems there are PHP libraries for COM port interaction, like https://github.com/Xowap/PHP-Serial
I do agree that these are frequently found in projects but in my opinion they should be tackled as external libraries and not part of the framework itself. 
&gt; Laravel 5.3 requires PHP 5.6.4 or higher. ~~We’re running 5.6.24 on our production server (cPanel) and Puphpet's current 5.6 branch uses the same. Dang so close.~~ Turns out semantic versioning (math/numbers?) is hard for me before coffee in the morning. Carry on.
Regarding your previous suggestion. You see, it's just a mixture that consists of the approach I offered in my article (which is safe): $setStr .= "`".str_replace("`", "``", $key)."` = :".$key.","; with `PDO::quote()` result stripped of surrounding quotes, which is essentially useless. Therefore although technically your code is safe, the substr/$pdo-&gt;quote part is superfluous and you can safely take it out. In its current form it will effectively escape the quotes, but as it is shown in my article, there are injections that do not use quotes, which renders this function useless. 
24 &gt; 4, you're fine :)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
In most (all?) versioning, 5.6.4 is the fourth patch release, while 5.6.24 is the twenty-fourth (24 &gt; 4), so no problems there.
Wow... just wow. I'm pretty sure I would laugh at someone if they asked me to do that. I've interviewed over 100 developers in my years and I never asked for anything that time consuming. The things I tended to ask were related to figuring out how they think. Then in person we would solve a problem together... I don't see what this gets them. I guess maybe it determines if you can put a product together with no input from them? Just kind of odd.
Is there a date set for the Lumen 5.3 release?
&gt;It's absolutely weird that they suggested sqlite(as far as I know it is limited to one user at a time, I could be wrong tho) SQLite doesn't really have users, or perhaps more accurately it relies on the OS to provide the user system; if a process is granted permission by the OS to read the SQLite file, it can read the database. If the OS grants write privileges to the process it can write to it. SQLite itself supports multiple processes holding the database open and performing read operations, and uses locks to allow a single write at a time. Write locks lock the whole database, so it's not great if you want to support multiple processes inserting data regularly, but a lot of use-cases aren't that. For read-heavy work it may well be faster than RDBMSs because reading a file - especially one cached by the OS in RAM - is likely to be a lot faster than the network calls to a remote database or perhaps even a locally-hosted database. The reason it's not really something you want to try and share over multiple machines, and it doesn't support a whole lot of types/constraints. (Though a lot of people barely use those features in bigger RDBMSs anyway.)
oh eff....thanks, it's still early
If you picked $45/hr, how can you only have been paid $20? And why do you keep working if there's a lot of hours unpaid? You gotta stand your ground, man! Obviously you are capable since you continue to work for them and do UI as well as logic. Don't throw away the money you can and should be earning! I'm not saying that you should take $100/hr or something ridiculous like that. State a price you are comfortable with, of which you think that you are worth that much. But don't accept being paid too little, they wouldn't either!
Just keep using 5.2. There's no fault in that.
Not sure but here's my guess. The ability to: - translate high-level business requirements into working technical solutions. - clearly document/communicate your proposed solutions to non-technical audiences. - formulate/document plans for delivery. - manage the execution of your proposed solutions. - clearly communicate requirements to the dev team. - provide reasonable budgets and timeframes to project stakeholders. If it's a hands-on architect role, then obviously the ability to actually code/implement the proposed solutions ;)
Oauth2 and scout *are* external packages.
Oh, I see. Drama queen.
In all seriousness, I can't imagine using either framework. They are both outdated and ill-equipped compared to the alternatives.
It was mentioned at Laracon it will come a few weeks after Laravel. 
That's fine. Everyone has a difference in humor, but to feel the need to downvote is a bit strange. Like, "This is so terrible, I must downvote it!" Just odd to me as all. 
I use almost all of them. Scout for sure, because I just converted a site from WordPress. Passport so clients can easily login to take pills or anything else we require a login for. The notifications for our office team to look out for successful Envoyer builds to the staging site. And I'm really interested in building a Slack not to handle commands pushed from Slack as well for possibly Asana tasks, bug reporting, etc.
So what's your opinion on the fact that it also needs MySQL or Postgres? Does that make Laravel not a PHP framework too? Also, Laravel is written in PHP, so that's kind of why it's advertised as a PHP framework. Agreed about the shims thing. If it can't do these things "natively" and would ultimately require the end user to pay for a service once they reach a certain volume, it's hard to claim it ships with those features out of the box.
What an eloquently put comment ozmeister 
&gt; So what's your opinion on the fact that it also needs MySQL or Postgres? Does that make Laravel not a PHP framework too? There's the understanding that a PHP framework with features X, Y, Z would have X, Y, Z at least *functional* on the most popular and typical PHP server set up on the planet: the "LAMP stack". It's so popular, that it has a name. When Zend Framework added text-search to their framework, they would connect to Lucene when available (if I remember right), but **they also provided a PHP-only fallback**, for their LAMP users. That's what I'd expect from a PHP framework. I'd like to hear which typical hosting providers out there provide the "LLAAMPPRN stack" that Laravel requires for its features to work. It's a matter of false advertising. Most other "PHP frameworks" try to implement features "honestly" in a way that's compatible with typical PHP servers, and Laravel advertises itself as a PHP framework, but most of its new features don't work on typical PHP servers, or require third party service subscriptions. It's also a matter of scope. If Laravel wants to be a generic "kit" for making web apps, fine. But what scope does it have at all? What goals does it have? What requirements? What dependencies? Is that locked down and defined somewhere, or is Laravel just a random assortment of things Tylor thought he'd throw in, because he needed them for one of his personal projects.
&gt; I'm learning so much good practice from using Laravel This is what laravellers actually believe. 
Use swagger ;)
If you're new to programming you need to realise the sort of people you're going to be working with. It's hard at first working with socially...different people, but you get used to their nuances. 
Passport is not simply a shim for League OAuth2. If you believe this to be the case start with a blank Laravel project and integrate with League OAuth2 and support all Passport features and see what it takes. I had to write 40 classes on top of League OAuth2 to bring the package to acceptable level of ease of use that I was comfortable with actually releasing to the masses. Echo doesn't require NodeJS. The backend is driver based - I just think doing WebSockets with PHP is really stupid so I don't ship a driver that does that. If you want to write a driver that is PHP based that is fine and can be done. Events and Scout are relatively lighter on code but I still wouldn't call it a simple shim.
? I'm not seeing this in the release notes...
What bad practices does it encourage?
&gt; The ability to write a theoretical driver for a suitable service LAMP doesn't have is not helping either [This is a PHP-based web socket library, requiring nothing more than PHP 7.0](https://github.com/amphp/aerys/blob/2e0a7596dad0d0122f52cbc0a056787d6c94b778/composer.json#L34).
Please read the end of the paragraph you chopped in your quote. Is it too much to ask...
FFS, man. We're not attached to pure LAMP. We're just dealing with the market, and it's a huge one, of businesses who keep their sites on shared hosting for any number of reasons that have nothing to do with our preferences. Maybe they've been with a shared host for years and don't want to change. Maybe they don't have a server admin. Maybe they're just stubborn, who knows? The point is that if they don't want to move, and if they've got money, then that money is going into MY pocket, not that of some other dev who decided to turn their nose up at building sites for shared hosting. The elitism in this sub around shared hosting is mind-boggling. We need frameworks - good, secure full-stack frameworks that use well-tested packages - to be quickly and easily installable on shared hosting and multiple versions of PHP, and what do we have? Fucking Codeigniter, which is showing its age like whoah, but you can toss a site together with it and shove it up on FTP without even needing your own dev environment. It's easy and stupid and requires no command line bullshit to make it go, and it's still popular because everyone's getting up their own arse about doing it the One True Way(tm) instead of just getting it done with whatever tools you've been given. I swear, there are a lot of people here who seem to think we can always follow best practices and we are failing as devs if we have to make compromises with people who don't know or care about how websites work. As if we can just refuse to work if we're not given a VPS. If there is one place where this community is falling right the fuck down, it's this constant lack of support for devs who have to work in sub-optimal conditions. /rant over, go ahead and downvote me, IDGAF.
I'm super happy about the OAuth component. It's going to save me weeks of work.
[Beware of backwards compatibility](https://laravel.com/docs/5.3/upgrade#upgrade-5.3.0). e.g. argument order of `Arr::first` has been changed which will probably cause subtle bugs. `make:console` will stop working. Logging out is now a POST request instead of a GET -- your logout link will stop working. Possibly more.
Right, but if their email has been compromised, the hacker can click it first. He can set up notifications for when the email comes in, and even programatically click the link if he really wanted to. If you have the opportunity to fix this flaw, you probably should.
Never mind the nit pickers, your jape was amusing. 
Sorry, I thought this took. RealPage in North Dallas is has 10 PHP Developer openings. All Direct Hire, No Remote. We are innovating from within and building our new generation of products, such as Rentjoy (http://www.realpage.com/realworld/ -watch Rentjoy Keynote – Dustin Gellman, our SVP Innovation Lab), ALL PHP. Ideally they would have Laravel experience but not required. RealPage is a growing SaaS and Cloud provider for the multifamily and rental industry with over 65 products. Job Desc: PHP Web Developer Job at RealPage, Inc. in Dallas/Fort Worth Area | https://www.linkedin.com/jobs/view/185472378 You can message me or you can apply online. Open to helping with relocation. 
Great! Going to start a new project with it tomorrow right away :)
Huh? That rules out every web socket server, you realize? Is the argument against a php framework not offering a php-only solution, or against a long running process to serve web socket requests? 
&gt; Tied to MySQL. Sadly so, but that's not a problem for us right now - and maybe not others hopefully. We use Kubernetes to deploy our platform, and as we provision an RDS instance per deployment we'd much prefer this to be automated alongside the initial seeding and migration. 
We use Kubernetes to deploy our platform, and as we provision an RDS instance per deployment we'd much prefer this to be automated alongside the initial seeding and migration.
It's still lacking. We do quite some weird stuff with Eloquent models, and you discover there is a looooot that's not discussed in the official docs. Then you head over to the api docs, and it's garbage. Another example, when having your own service provider, you can register other providers and stuff to the IoC container, but it differs from how you normally do this, and it's not documented at all. (There's a very old cheatsheet [here](http://alexrussell.me.uk/laravel-cheat-sheet/#ioc)
There is your answer. With the latter suggestion can use your local bash command history. In addition you don't limit yourself to a mediocre REPL, aside from poisoning your container with it.
Looks good! Amazing work, keep it up guys. Can't wait to start using the notifications and the searchable trait.
"We've gathered today to talk about com-pee-eitsch-pee-artment, I'll call it com-fart-ment for short from now on..."
What's the logic behind posting php work offers on tweeter instead of reddit? Seems dead on twitter..
You may want to look into enforcing some stronger passwords. Was able to input a 5 letter password without any other characters/casing. [https://www.owasp.org/index.php/Authentication_Cheat_Sheet#Implement_Proper_Password_Strength_Controls](https://www.owasp.org/index.php/Authentication_Cheat_Sheet#Implement_Proper_Password_Strength_Controls)
That's a shame...
Quite likely this isn't the community for you then. Your market seems to be the whatever-gets-the-job-done market, which is fine, but that's not the market the majority of /r/php users deal with.
You can get a non-shitty VPS for $5/mo. What other reason besides cost could possibly keep someone on a shared host?
Are they offering visa sponsorship? I think it's a good idea to mention this if you're posting job openings on an international community website.
Isn't that a framework though? I want to understand the concepts behind MVC without the use of a framework. I do want to learn Laravel eventually and would learn it now but I would have to know if it will teach me the concepts of MVC. 
That's fine too. 
When will companies get with the now and stop denying remote workers?
Laracasts covers the basics of MVC by using examples with Laravel. It's a good starting point, and covers some other basic concepts as well.
I have cloned and am using the L51ESK project from github. I am relatively new to laravel. Could anyone give an educated guess on whether I could upgrade to this version and how difficult it is to upgrade laravel in general? I really like some of the new features like the notifications feature. I wonder if it can integrate with hipchat.. it did say slack.
What do you do after you get the VPS? If you don't want it to explode at the first minir problem you need a whole other set of skills (system admin). 
Wow, what amazing hyperbole. Anyway, good providers have practically idiot-proof setup documentation and FAQs. And great tech support to help you fix any missteps you can't correct yourself. If you can't be bothered to learn, don't be mad that the world passes you by.
I think it's too bad they don't because it's a familiar standard. But from what I understand, the reason has to do with Taylor and the other developers preferring to fix any annoyances and imperfections with every release rather than letting them remain until the next major update for the sake of compatibility. That means every major release tends to require a few minor changes to code that uses the framework, usually just some quick fixes that you have to grep your code for and rename a method or that kind of thing. Since it annoys people that it's not strictly semver, maybe they should just make each minor release be a new major version number. If so they'd be up to something like version 14. 
of course there are reasons. SINGLE RESPONSIBILITY!!!!!!!!!!!!!1111111111111111 to the most granular level is what drives most of the laravel haters. reasons are mostly opinions, too. srsly, give me reasons and i'll show you my reasons.
Look, this is less about Laravel and more about people shitting all over shared hosting and stuff like WordPress and the devs who have to deal with them. Your comment was one in a long line of comments I've read here along the same vein. You ask, why weigh yourself down with legacy support baggage if you don't have to? Well, what if I have to in order to do my job? And sure, shared hosts SHOULD get their act together. They should do a lot of things. We should all be able to develop on good servers using up-to-date technology with accommodating hosting providers. But the world isn't perfect, and we're left developing apps in less than ideal conditions, and we have to roll with it with sub-standard tools because fuck us, right? And that's why this makes me mad. I'm not asking to nerf framework features but it'd be nice if the modern frameworks gave half a thought about supporting devs on shared hosting, maybe get them on the road to arguing for a decent VPS. And maybe this place might be less assholish about it.
I don't use Laravel.
I. Don't. Use. Laravel.
Thank you for your clarification. Since I'm newbie to PHP , which I think I should have stated at first, I mistook your code for PDO. I didn't have much time to review your first comment but I tried the last one and here's what I came up with. $query = "SELECT FROM 'friends' as table, UNION SELECT FROM 'messages' as table, WHERE user2 = 'User1'"; $result = mysqli_query($con, $query); $row = mysqli_fetch_array($result); Unfortunately, I don't think this is working but will keep plugging away. Thanks again.
&gt; No I don't know how long a project will take, seems unfair to charge for me going through a bunch of stack overflow posts. Hey, it's your free time. They could be doing the same, but they choose not to. It's absolutely fair to charge people for that, it's no different from any other work. &gt; Also I don't have windows computer for them to track hours through up work (excuses) That doesn't matter :P you set a price for how many hours you think the project is going to take. If you need less, nice, if you need more, then you'll have to give a better estimate next time, but the client will have agreed to those hours, so he's fine with it. &gt; I'll figure it out eventually. My balls will drop out of my body someday. Just don't spend too much time working for what seems like absolutely nothing :P
You're a developer, of course these sound like total nonsense to you. These are the reasons of business people who control the money and who neither know or care about how websites go. You can talk tech at them until you're blue in the face, and they'll still sometimes tell you to get working on it and just make it happen, and at that point you either ride off into the sunset on your high horse, or you make it happen. Guess which one results in you still having a job.
Try to roll your own tiny mvc framework to understand how it works. Never actually use it tho. There are resoucprces online that guide you in the creation. Look at [this](https://github.com/Mikushi/Tachyon) micro framework and try to understand how it works. Once you got that you can look at the source of [opulence](https://github.com/opulencephp/Opulence) which is a little more complex but not like laravel or symfony. You will understand in no time.
Those are some great features, this looks awesome! Thanks for your great work. I never gave Laravel a shot until you came out with Spark. It's a real pleasure to work with! Are there plans to update Spark to Laravel 5.3?
The notifications feature is driver based and the community has already put together a multitude of new channels including hipchat. You can check it out here http://laravel-notification-channels.com/
Acriverecord for one
Learn good OO principles like SOLID and forget about MVC
The notifications feature makes it really easy to integrate with your own channels. The community has already created a bunch of custom drivers here: http://laravel-notification-channels.com/. You'll find that most major push/chat/sms services have already been covered.
Could you elaborate? 
&gt; Laravel is great, and there's plenty of free resources to learn Not that I do not like Laravel (it is a good framewok with a good documentation) but I'm tired of seeing this exact sentence as an answer of 2/3rd of questions asked in here. It's spam.
No problem, you just have to upgrade to PHP 5.5.3.
I'm sorry to say but is this some advertisement for codequs? All links point to the same site. All posts of OP (3 total) are the same imgur-picture-with-codequs-link-list posts.. :( Could be great content there but these posts make me a bit wary! In my opinion it would have been better to just link to a specific tutorial (with some explanation why it's great).
MVC is not an architectural pattern, but it is used as one in PHP, because 99% people don't understand why it was created for. You'll be much better off learning good OO principles like SOLID which can be used to design your programs architecture.
I started learning laravel 1 week ago.. yesterday I created new projects and wondered where the routes.php was?? they moved the routes to routes/web.php -.- 
MVC is just a single architectural pattern and is one of many options of how to structure your application. While very popular, it's not always the best choice and is often overused. &gt; I really like how it separates your back-end from your front-end That's not because of the pattern itself, but proper SoC (Separation of Concerns) instead. Learning SOLID and other principles may be more beneficial in the long run. However, I don't agree with /u/feketegy about not learning MVC at all. You should absolutely learn it since it would definitely open more job opportunities. Just keep in mind that's not the only solution of the problem it's trying to solve. Alternative approaches such as ADR exist as well. P.S. If possible, try to read a bit about the _actual_ MVC as well. The version we're using in most frameworks is what's most commonly known as Model2 and significantly differs from the original.
Except that MVC is not an architectural pattern, it's not really good for structuring applications.
Facades are probably the main issue. Active Record ORM _may be_ another one, however it heavily depends on the project complexity - for small to medium projects with simple domain model it's absolutely fine. There's also a service injection into views (which is absolutely horrible IMO and you should never, ever use it), but I've never seen it actually used in production. Some people (I'm not one of them) consider it's lack of configuration as another problem, however I'd argue that they made a mistake by choosing the wrong tool for the job and are blaming the tool instead of themselves. Otherwise Laravel is mostly fine. There are some issues but all frameworks have them and it's nothing that can't be easily avoided.
I'm going to get hell for this, but I like how easy it was to learn MVC while trying to learn CodeIgniter. You should absolutely learn better frameworks like Symfony (specifically the second link posted by @ahundiak), but I'm just stating where I learnt it from.
&gt; The reason this is a security boon over escape-then-concatenate is that the query string is never tainted by the parameters. They're sent in separate packets. This is an important distinction; Unicode-based hacks to bypass mysql_real_escape_string() are dead on arrival when prepared statements are used. In the very article *you link to* it says clearly that the de-facto Unicode charsets in use in RDBMS (utf8, utf8mb4) are *not vulnerable*. So saying the attacks are "Unicode-based" is exactly the opposite of what's happening here. Additionally, to exploit this, even with the so-called "vulnerable" charsets, you need to open a connection with a single-byte (or UTF8) charset, then invoke "SET NAMES" on that connection to a vulnerable charset, which I bet no WordPress installation or plugin does, because it makes no sense as a use case. I'm getting tired of the misinformation about interpolating values in queries and prepared statements. A lot of your points are good, but let's not take liberties with facts. 
No problem :)
You want to know something weird, my first name and I'd say my best friend's name makes your username. Sign from God? I don't know.
As your application gets more complex, you'll find that MVC does more damage than good.
&gt; If you think utf8 is safe from all charset bugs that have security consequences, I have bad news: Not in MySQL, it isn't. Your example is completely unrelated to the subject of avoiding SQL injections, and it's *not corrected by the use of prepared statements*. So it's unclear what's the point you were trying to make. For readers who are unaware: in MySQL UTF8 isn't really UTF8, it's just a giant mistake, being rectified with UTF8mb4 (which is actually UTF8). So if you use MySQL 5.5.3 or later, always choose UTF8mb4 for your connection, tables and columns. If you don't, then it's up to you to encode out-of-range characters properly. Also, thanks, this video gave me a headache, especially the part explaining double serialization and "is_serialized()". It's been a long time I've seen this level of incompetence, somehow cobbled together to appear as a working system. The problem was caused by the WP developers trying to wrap up a flawed approach of their own making with infinite layers of duct-tape rather than fix the obvious category errors in their thinking, and resulting design.
Hi. I created a small library which converts integer numbers to strings using base 52 (or any other base, just provide an array of characters to the constructor), for the purpose of making said numbers easier to remember and prettier to see, for example a link for an image link site.com/i/2334334 while with the conversion it would be site.com/i/qFpc With just 4 digits it is possible to cover numbers as high as 7.3M Anyway, the library is called [fzaffa/baseconverter](https://github.com/fzaffa/baseconverter). Hope you find it kinda useful.
Possibly? Seems like you really should take my advice :P
Right, avoiding to store the whole data and only instead the currently needed state is much more efficient. I really can recommend using Generators for any incremental parsers. Need more data? just yield and wait for the caller to pass more data. And inversely for the lexer. Caller wants more data? Just call me, I'll yield you the next token! [As opposed to _everything_.] No need to backup state or store it in tons of properties or having large stacks (especially when you need to call generators recursively (`yield from` ftw!)). Apart from that: Interesting project … I wonder though, any reason why this project is featuring a LL parser instead of a more powerful LR (or LALR) parser? At least some things like programming languages are hard to parse with LL.
Haha Well, when my balls arrive, I'll let you know, I'll send them in the mail. Sorry hahaha took a weird turn.
I haven't had this problem with very large applications (over 200K LOC and rich domain model), although I'm certain there are situations when that happens. However, in this case I'd argue that it's not the problem of MVC itself but that it was chosen despite not being the best design choice. Just to be clear, are you talking about proper MVC definition where model is treated as a layer?
I'm kinda afraid now to open my mail. :D
That's true, you'd need a GLR parser to parse LL parseable grammars, my bad for messing that up. [which have also different worst case runtimes…]. Additionally, lexers (thinking of e.g. re2c) typically allow manipulation of tokens before being fed into the parser; would it also be possible here to add that?
you can though audit serialized data and see whether any shady unrelated classes are invoked with weird properties [for doing an actual exploit …]... I would not describe it as a _security_ issue thus. PHP code is a friendlier and more compatible format, but serialized data is just about as dangerous as PHP code.
If you see blood, don't worry, taste it, who knows, it could be strawberry jam, same goes for the chunks.
(ಠ ͟ʖಠ)
Haha take care fellow human
Random question. So I meet this dude at work seems cool, talks about tech. Then he brings up HHO and he believes it. I right away am skeptical. Even say out loud "this sounds like that perpetual energy bullsgir on youtube" as he sources a YouTube video for proof haha Anyway. Should I be an asshole? Avoid? I am being an asshole now by what I'm doing. This happened to me before. Guy's like "I sae these blueprints man... Magnets... Seemed legit." Hahaha Thank goodness for the internet.
Yeah right who am I to judge? Often I find myself wrong about things anyway. Hypocrite! Alright thanks for you insight. I still have to implement this excel thing. Works been sucking lately. Just come home beat af.
I do half SA. It's nothing to with PHP but an overarching abstract view of technology stack, choices that best fit the company, domain knowledge etc.
I've been working on a refreshing new Data Mapping concept - powerful enough to give Doctrine some competition yet simple for a new users and familiar to ORM users. I am going to do a tech talk on it and in preparation I have recorded some videos with a demo. Please give me your feedback on the talk. Does it convey the uniqueness and benefits of Agile Data? Have I missed any important bits? Also what kind of impression about Agile Data you have after watching all the 4 videos? Appreciate your time!
Sure. The API will not allow it because the lexer cannot be injected but this is 2 methods to add and we are good. If you are able to wrap the lexer inside another iterator, it will work like a charm.
&gt; Yeah right who am I to judge? Often I find myself wrong about things anyway. Hypocrite! You don't have to always be right to be able to judge, everybody does so. But sometimes it's just better to keep your opinion for yourself, no use in confronting others if there's no real reason to do so :) &gt; I still have to implement this excel thing. Works been sucking lately. Just come home beat af. Don't overwork yourself. You are doing this for free, don't lose sleep over this.
If you do in up in hell then at least you will good in company. When mentioning CodeIgniter you should also mention that you are using version 3 or later. That gets you away from the "ancient and obsolete" comments. And once 4.0 is released, CodeIgniter's can return to the latest and greatest community. By the way, the links I posted are Symfony articles but not Symfony framework articles. Yes they do encourage you to use Symfony components but they are pretty much framework agnostic.
Or just `FROM nginx:stable`...
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
http://convertphptags.online Not a library and a bit old fashioned but I recently needed this for a wordpress plugin I released, so I thought to put it online so anyone can use it. What it does? You can use it to convert PHP short open tags to long in existing code so it works on installations without short_open_tag enabled. Really useful if you are not using a template engine so you have html mixed with PHP output tags. 
Haha, no problem :P
In the first video, I don't think you're doing a good job enumerating the weaknesses and strengths of each approach. Having "love and hate" is fine in the title, but talking about emotions and ideals in the presentation is too abstract - we need to hear a set of objective engineering technical arguments. Regarding your approach. Using collection semantics is an improvement, but you're not going far enough to obscure the difference between "fields" and "references". I use a similar system in-house, and my records don't have references, joins, and so on *when looked from outside*. A record is defined as a set of fields, and as you select more fields, the query is modified accordingly. Some may be built upon expressions, some may be a subquery, some may trigger a join. This should be transparent IMHO. This allows users of the system not to have to care why and how the values for the fields are populated, and I'm free to refactor this in the schema, without breaking users. Something to consider.
&gt; Yes, I am removing the content that Author has copied from your site So you were lying. Nothing was removed but just changed a bit. You are trying to create your site robbing others of their work. Your site will be associated with plagiarism and shame forever.
What you describe as your in-house tool is also how Agile Data operate. I am trying to find a good ways to demonstrate the benefits of this approach. Model and all of it's logic lives inside "Domain Model" and none of the business code have to care about persistence layers (which can be SQL or NoSQL). Significantly, my approach allows to do so without loosing any SQL features: joins, Sub-queries and Conditions are all supported without any scalability issues. I'm curious - if you look at the documentation of Agile Data and this sample project here: https://github.com/atk4/data-primer/tree/master/src, I wonder how does it compare to your in-house solution.
Noice.
Hi, Contact authors on site. When they say, they are going to rephrase and make it unique, I can't help much. About plagiarism and shame. Good luck. That i believe will have to live with it being a network site, where users are adding the content. All i can do is create better reporting option to get rid of plagiarsim as much as possible. But, when it's author, i can't rule them with just 1 button. I can warn , warn and ban until author doesn't improve. Also, I think, content rephrasing or rewriting , there is nothing bad in it. Every one learns from some where.
My time was limited with the example. - $m-&gt;onlyFields(['name','surname']); Here is link to the doc: http://agile-data.readthedocs.io/en/develop/model.html?highlight=only%20fields#Model::onlyFields I think I actually did mention in in 4th video briefly when I talked about optimizing. - Joins When using joins they are transparent inside a model. For instance you can define a single entity to be stored in 5 different tables that link to each-other, then extend this model to add 2 more joins (including recursive joins if you need). When adding a field, you can associate it with "Join". Syntax is pretty simple: http://agile-data.readthedocs.io/en/develop/joins.html?highlight=join Agile Data automatically resolves any conflicts. Join can also be defined as a property of a model so than you can add more joins into it when extending. - Transactions They are handled by a DSQL, because they are SQL-specific, however I'll introduce atomic operations for basic CRUD in 1.1, which means if your `afterSave` hook fails, the save operation is also rolled back. - Type casting Joins or not, type-casting is sitting in PR right now for the 1.1.0 branch: https://github.com/atk4/data/pull/109. The reviewer has asked for better documentation. The draft for this feature is here: https://github.com/atk4/data/wiki/Type-Normalization and also here https://github.com/atk4/data/issues/90. (This is good examples on how new features are planned and implemented in Agile Data) - same column under 2 names In the stable version you can define Expression (http://agile-data.readthedocs.io/en/develop/expressions.html#no-table-model-expression) than can be any SQL, but it is read-only. There is also support for 'actual' property but it's not fully working in 1.0 and is not documented. It will be ready in 1.1 version. You can also use beforeSave and afterLoad hook to manipulate some values. You can rely on support for "Dirty" fields and create more complex logic, e.g. if you split "datetime" field into "date" and "time". http://agile-data.readthedocs.io/en/develop/model.html?highlight=dirty#Model::$dirty At some point there will be a better support for in-php calculated fields, it is on a roadmap and is pretty trivial to add.
How do I choose whether a join is included in the results or not, though, that bit wasn't clear to me? If it's truly transparent to users, it should be via onlyFields(), but then this implies that by default *you include all possible joins defined for a model* in the results. Which sounds like you wouldn't do that. BTW: Curious, what exactly is your business model with Agile Toolkit? I see the licensing, but I wonder how you attract / plan to attract devs. P.S.: One more difference. In my mapper, I don't need a separate model class for every table, instead it looks like this: $mapper-&gt;from('ModelName')-&gt;select(...)-&gt;where(...)-&gt;getAll(); I have typically 5-6 tables in a single mapper, which might interact somehow (shared expressions, joins etc.).
&gt; The solution is 10 lines of code, completely transparent to the connection users (the trick is to encode 4-byte chars in input through an escape sequence, then decode it in result-sets) Could you expand on this? 
&gt; I guess it's 6 of one... Nope, PHP skipped 6. *rimshot* Thank You, I'll show myself out.
http://phpdeveloper.org is a good aggregator
I had a game, it was fun! good work :-)
Good to hear :) Thanks!
It's better than "putting everything in the index.php" pattern. 
Will do! Appreciate your suggestions.
I really like [http://csv.thephpleague.com/](http://csv.thephpleague.com/), I've never had a problem with clients opening CSV files in excel. PHP-excel is usually overkill for the exports I need.
It's also better than the "litter your public folder with dozens of insecure PHP scripts" pattern.
I wanted to say this is kind of ridiculous, but then again Symfony already has one. But honestly, if this is going to be an API quiz, just don't bother really. I am yet to see a single company that gave the slightest fuck about any certification (apart from the Oracle ones). But I guess the money has to roll in from somewhere, but if you really want to support a developer just send the donation directly.
Stared and Watched. Going to give this a try in my next project, Jade is one of my favorite template engines. If I can tie it into my framework of choice and use it in php thats going to be awesome. Thanks for the hard work!
Money making scheme from the guys that run laracon EU
From a game design perspective, I think the most glaring issue is that your combat system very heavily incentivizes a certain stat combo (even spread of points), which led to homogenization of most of your top players. Secondarily, it appears that the whole "drop your weapon" thing is far too common (anecdotal). It happened to me on just about every single battle. Typically, random negative events like this are kept to a bare minimum in games, because they're out of the player's control and that's frustrating for the them. Other suggestions: * Allow equipment upgrading while equipped (unequip, upgrade, equip is tedious) * Remove all player identification from the arena list (this makes it far too easy to grief specific players), and put it instead at the battle ending screen * Tighten up respect gain/loss for level differences. Each level gives insane benefits relative to respect gain/loss, and this heavily incentivizes sandbagging. Do some data analysis to find out aggregate win/loss percentages for level differences and use that to adjust the respect gain/loss scale * Give more details about what each stat does on the level up/stat allocation screen * Attacking and losing only nets you half the respect loss that being attacked and losing does. This seems odd. Cool project. Good luck to you.
`s/seperate/separate/`
All codecanyon links...don't really see the content quality here... On the other hand, what confused me or made me rage the most was the "Perfex - Powerful Open Source CRM" ... which is not open source and costs USD 54 .... what.
This is a noise reducer. People who claim "Laravel expert" on their resumes now have a way to prove it on paper, which will give them an advantage in a competitive applicant pool. One just has to hope that companies don't over-depend on this, and skip over candidates who are actually outstanding developers and problem solvers. Being certified at Laravel doesn't mean you're a good problem solver or programmer.
As already said, **MVC** is more for the presentation layer, because it allows connection between the View and the Model, in my opinion this can lead to unnecessary communication in backend services. For example: Controller -&gt; Model -&gt; calls X service over HTTP to modify something View -&gt; Model -&gt; calls X service over HTTP to retrieve something In **ADR** you have both responsibility in the action, it allows you to do only a single call that will do both jobs, or call the X service in a parallel manner (with multi curl for example), therefore you gain speed. Of course when you have a single application with direct database access, it doesn't matter much which one you choose. :)
I never said it should be the sole reason to hire someone, just that it could be another tool to weed out people faking their experience.
OP linked to the ADR article, that's pretty good on that.
&gt; MVC isnt a full fledged architectural pattern, but a pattern specifically designed for UI/presentation layer. Hear, hear. More specifically, MVC is *one part of* an application architecture, the UI/presentation portion. Further, in HTTP, the presentation is not the HTML/CSS/JS. That is, [the template is not the View](http://paul-m-jones.com/archives/5993); the View is the entire HTTP response. This is the core revelation that led me to [Action-Domain-Responder](http://pmjones.io/adr).
I agree seems like Shawn and his EU organization team could use this as a money grab. It is not listed as a Laravel product on the website and instead listed as a "WebEngineers" product. It does not seem to be something managed by Taylor. He is just listed as an "advisor".
I tried to speak to Taylor about it today at Laracon, he made it pretty clear it was Shawn's project and he was just going to be checking the material to make sure it was all correct. Then I quite tactlessly (but not meaning to sound like a dick) told him a friend of mine thought it was just a cash grab and he seemed to lose interest in talking to me... oops.
feels a little sploggy
&gt; This is a noise reducer. People who claim "Laravel expert" on their resumes now have a way to prove it on paper, which will give them an advantage in a competitive applicant pool. As an employer, the first impression of seeing something like this on a resume makes me think that the candidate is a gullible bozo. But... I try not to judge people based on my first impression. &gt; Being certified at Laravel doesn't mean you're a good problem solver or programmer. Precisely. No certificate can demonstrate what a 10 minute conversation and a sample project can demonstrate.
Don't sweat it. At least you're using Laravel and not some WordPress or Drupal CMS, where you even look at the internals (btw Drupal is Symfony now, so not that basic). Just take one thing at a time. Go to Laracasts, YouTube tutorials - about DI, HTTP Kernel, SOLID, testing, PHP the Right Way etc. I'd say learning one thing per month is a good speed. You don't have to dive into everything at once. Try to download some tiny framework like Silex and developer something like an API - try to write decoupled componenents. That's what it's all about - fiddling with things, concepts, packages. Also, subscribing to latest PHP news on reddit, youtube, twitter, etc. You don't even have to be learning PHP - if you're interested in something like React, go for it! It'll make you a better developer.
what is the deal with this version numbering?
The auto-setting of headers isn't the problem. The problem is... whose responsibility is it to build the response. If it's the Responder's responsibility, as stated, then there shouldn't be some random middleware that injects cookies into a response object. And if the responder's responsibility is not to *build* the response, but to *be* the response... then it's just "the response", not "a responder". To quote you: &gt; The Responder is entirely in charge of setting headers
So basically the domain is a description of how stuff works, the infrastructure the "adapter" that makes it actually work?
Woha, that's the biggest steaming pile of horse manure i've ever seen! I thought buzzfeed listicles were only used on Facebook posts.
I'm pretty sure I can do that MVC style, as well.
&lt;Year&gt;.&lt;Quarter&gt;.&lt;SubVerison&gt; is my understanding, or the middle number could be the major version released in that year and last number is minor version number. Edit: Also Adobe CC apps are versioned in a similar way now.
Not necessarily, but it is telling that he sanctions it.
Ha! I wish someone could tell me where I am at in my career with some certainty. The market changes so fast in tech. I went from IT to back-end dev to front-end to full stack in the matter of 5 years. I am also crap at certain languages I want to learn more about (Elixir/Lisp), Good at languages I don't want to be good at (COBOL), OK/Professional in some others (Ruby/Python/PHP/.js) ack! Github is also not a good indicator as our company switched to GitLab and other companies use BitBucket (although I guess if the candidate included the code-portfolio link, it would not matter). GL /u/trs21219 you have you work cut out for you. I would hate to be hiring in this field!
&gt; there shouldn't be some random middleware that injects cookies into a response object Oh, I completely agree. In my own ADR work, middleware does very little, especially not response manipulation. That particular middleware piece is for those who are not doing ADR.
I never really did any PHP with NetBeans, but for the price I paid for a personal license was well worth it for me -- and that is a something I say as only a casual PHP and web coder. The nice thing about both environments is that they have tons of plugins to do lot's of things but I'd say that many of the core features are there in both systems. There is a 30-day trial for all of JetBrains' applications, so checking out PHPStorm could be a could move to see if it fits your needs.
So then how do sessions work in ADR? You'll need to repeat a *whole* lot of boilerplate all the time in order to support things like sessions... I think the problem with your ADR is that you separate HTTP request reading from HTTP response building, and in 80% of the cases, that separation is counter-productive. The controller is there to do the dirty job: extract usable data from a request, turn it into useful domain changes via the model, and then use its accumulated state to build a response through views. In most cases we're talking about 10 lines of code, if that. There's no good reason that I see to have yet another intermediate model between Action and Responder, which is what you encourage.
&gt; Unless I'm misunderstanding, the heart of this discussion is whether a certification program (like this one) has any value in assessing whether someone is any good (in the context of a job application). The heart is whether or not the certification itself has any value in such an assessment. The question is whether or not someone saying, "I'm certified" says anything about their capacity to solve problems you're likely to face. &gt; As I understand the comment (and please do correct any faulty assumptions I'm making here), you're saying what you learned didn't translate into practical problems. That's part of it. Yes. The other part of it is whether or not one can study/learn in order to pass a certification without needing to actually have the capacity to solve such problems. &gt; I'd assert that what you were studying either wasn't relevant... Relevant to what? It was relevant to passing the certification. The question is whether or not the certification was relevant to me doing my job. The answer in all cases is no. &gt; ...or you weren't learning well under the conditions you found yourself in. I'm not sure I was learning at all given that I'd already learned most of what was covered. &gt; You literally (and literarily!) were speaking about learning. I'm speaking about the relevance of certifications with respect to job function. &gt; What I'm saying is that, while you might not feel that your studies (in certification programs like this one) were ineffectual to your practical development efforts, others may (and often do) have different experiences than yours. While I do feel that my studies were ineffectual to my practical development efforts, that's not what I'm saying. What I'm saying is that my ability to pass a program or certification is irrelevant to my capacity to do the job, and that while it might be relevant for some people, there is absolutely no way for an employer to determine that. If person X feels that they wouldn't be able to do occupation Y unless they'd taken gone through certification Z, you are correct that this has to do with the learning styles of particular individuals. The question I'm addressing is whether or not person X can actually do occupation Y based on the fact that they've gone through certification Z. &gt; You don't seem convinced that certification programs (like this one) are valuable in all cases. Valuable to whom? Whether or not a certification is valuable to a student is wholly independent from whether or not it's valuable to an employer. &gt; I agree with you that they aren't always useful. "Usefulness" is a separate question entirely. The reason I have certifications is because they are useful (for getting some jobs). But I'm an employee, not an employer. &gt; But I'd never assert that they are never useful (which seems to be a line you're more comfortable to straddle). Whenever you talk about or hear the word "value" (or any related word) you should always ask "for whom?" Whenever you talk about or hear the word "use" (or any related word) you should always ask "for what?" The use/value which I have implied was not some vague notion of use/value that could apply to anyone. My first comment was an (obviously) sarcastic remark about the value for an employer and the usefulness for certifications being able to determine an employee's capacity to do the work. The fact that all (or in this case just "many") smart dogs wear handkerchiefs around their neck does not necessitate that all dogs which wear handkerchiefs around their neck be smart.
The domain is your business logic. The infrastructure as I understand it (I call it persistence) persists the changes. Look up onion/n-tier architecture. Microsoft has a great architecture guide: https://msdn.microsoft.com/en-us/library/ff650706.aspx
For me it's less about the knowledge of one specific thing and more about their maturity as a dev. Do they code themselves into a mess? Do they over abstract to the point of madness for things that will most likely never change? Do they use non production proven server tech for *real* projects? Etc... GitHub or any other code sharing tool just helps demonstrate those things. Same with open source contributions because you can see how they interact and if they are receptive to feedback. Thankfully hiring isn't my actual job, I just ran the interviews for that one because I was going to be working directly with the person day to day and didn't want to be fucked over haha. 
How are we not in the third quarter yet? It's August.
&gt; The first part is clearly input work (Action) and output work (Responder). Basically you're saying you can't encapsulate the session mechanism in ADR, because it's always explicitly split between two independent components. I think that's a bit damning, don't you think? With a normal controller, I'd just have something like this in a container: $sess = new HttpSession($request, $response, $storage); ...and now I can inject it to whoever needs it. &gt; The second part, then, has to be Domain (and/or infrastructure) work: it's dealing with storage and persistence. That's why making sure that session_*() functions don't manipulate headers is so important in this case; you want to make sure the Domain is not sending output. I understand, but that's trivial. Heck we don't even need to directly call session_*() at all. The mechanism is trivial to reimplement. But I think the inability to *encapsulate* the session shows a flaw of ADR.
PHP certification from Zend is not easy to pass. Without actual experience - no chance in hell. It's too broad for someone to prepare for it witout having at least a few years of actual good work under the belt.
If you have a very large code base then the indexing superiority in PhpStorm vs Netbeans is a huge feature. Phpstorm can nearly instantly search my codebase for words rather than the minutes Netbeans took.
Related question: what would be the advantage of using netbeans/phpstorm over a text editor such as Atom? Better typehints? I'm not sure an IDE is for me as I write Dockerized applications. 
It's not as ridiculous as that one guy who inflated download stats just so he could join the big boys and feel important.
Not really. I passed the Zend certification after a few months of programming in PHP.
&gt; You keep avoiding the point I'm trying to make (/me grins) Quite the opposite, you seem to be avoiding mine; or, perhaps, I am merely not being clear enough. Either way, I'm happy to let you have the last word here.
The overriding principle should be "separation of concerns". Depending on the type of app you're writing, and how you're approaching it, and what libraries or frameworks you're using, it's possible that all (or most) of your problem could be separated out into "data", "presentation", and "business logic", and you could call the code dealing with those parts "models", "views", and "controllers", and then you kinda have MVC. Of course MVC is actually a concrete pattern which was developed to refer to desktop apps. Your "MVCish" webapp may look superficially similar on some ways, but given the enormous technical differences between a PHP app and, eg, a classical C++ GUI-based app...the resemblance is going to be quite superficial. Plus, if you look at a lot of MVCish webapps, you'll find there's a lot if *mixing* of concerns. And if you collect 10 different MVCish webapps, you'll probably find they break things down in 10 different ways, both of which are signs that MVC is probably not the right abstraction. &gt; Are there other "well tested" patterns that I should learn about? I would say: 1. MVC, as applied to PHP webapps, is not really a "pattern" so much as it is a fond dream. And as such it's not tested at all. 2. On the other hand, there aren't any other patterns which *are* tested either. MVC, MVVM, ADR, MVP, MV* are all terms used to describe "let's break this down in ways which kinda seem logical", and depending on you, your problem, your team, and your tools, some of them may be more or less appropriate, but none rise to the level of "well tested pattern" in the way a desktop app programmers mean when they talk about MVC. TL;DR: Learn principles, not patterns. Separation of concerns is awesome; MVC is more of an interesting idea. :)
:( So basically I'm asking you a question and your response is "I'll let you have the last word here." That's not a particularly nice way of saying "I don't have an answer." 
i have fast computer and speed was never an issue edit: downvotes wow guys :D i asked "i use netbeans for long time. is phpstorm really that much better?" and /u/Lefaucheux answered performance might be issue but i cleared that up that it was never issue for me i don't discuss what is better netbeans vs phpstorm for general public, but why should I switch for phpstorm, i am just curious
That's good to hear. I just want to dumb proof it. Thanks for the link.
Yeah it depends how you use it if you are doing remote sync it's definitely internet-connection-bound
I do too, but also have 1.5 million lines of code. 
What a load of crap. This isn't for web developers this is for people who don't know fuck all.
Update, just read some of this guys posts its clearly a spam bot. posting blog articles about anything and everything.
i have big projects too, no issue at all. netbeans has cached/indexed everything too
Yeah I tried it off and on for a long time and it wasn't until I forced myself to use it for a month and hated my life for a lot of it. I had to learn the various helper functions before I started to like it. 
I found my job on my uni's job offering forum.
Maybe I will have to do the same. I only tried it for a few days.
Yes I am not trying to make discussion netbeans vs phpstorm as phpstorm is probably better. I wonder would phpstorm give &gt;&gt;&gt;ME&lt;&lt;&lt; any benefit and if switch is worth it. Thanks.
Financial quarter?
FYI, I might interchange intelliJ with phpstorm, as phpstorm is a subset (plugin) of intelliJ. There's a lot of advantages, actually... As you mention, better typehints are obvious, however the idea of debugger integration, git/local versioning (and the UI behind it is nice), great diff tool, pretty much every language and derivative supported, integrated data store explorer, console, you name it. Support for all build system types, or you can even just have intelliJ pre-compile all your assets, and avoid a build completely (although I don't suggest this). Most of it is supported right out of the box. What isn't default, can be detected and presented to have plugins that support a found file-type. The stuff in the plugin repos is pretty badass as well, not much varying from some necessities from Atom/Sublime (i.e., String Manipulation [sequencing, case-change, etc], code/file templates, extra support (docker integration, markdown previewer, etc). If you ever used Eclipse, or Visual Studio, it's like a modern eclipse or a really modular Visual Studio. Either way, I highly recommend utilizing the trial period and don't give up for a solid week/40 hours. You'll find Atom just feels like a basic disposable PEMDAS calculator and intelliJ products like the TI-92 Plus. ----- EDIT: I forgot to mention one of my recent favorites, which is Scopes. With these, you can configure file-action contexts, such as Search. You can limit things like npm/bower modules, libraries, etc when searching for text, and you can include external folders as well (i.e., if you explicitly want a library searched). What I also really like is just overall features that are geared towards devs. If you place TODO/FIXMEs all over, it will aggregate them into a panel for easy finding. I mean, i could go on for days about this IDE - nothing compares.
The main problem with MVC is that it's not a complete picture of the request/response cycle, nor does it use sufficiently concrete terms. If you were to build an application using ONLY three types of files: * controller classes or functions * view files (basically just HTML) * model classes You would find yourself with massively bloated model classes that do far too much work and have far too much responsibility. So the "Model" isn't really just one class, it's any number of different classes needed to process business logic. Also, if you were to follow plain MVC, you would wind up with controllers that are represented as separate endpoint files (users.php, login.php, register.php). This has some pretty serious disadvantages. To fix these disadvantages, the modern way of handling requests is through the front controller pattern, whereby all requests point at `index.php`, and then virtual routing maps incoming URIs (e.g. `/user/3` or `/post/3/edit`) to dedicated controller classes. In other words, the controllers are no longer directly publicly accessible, and are called internally. However, this introduces a new element: the router and/or route (and technically a dispatcher). So really, now it's MVCRD. But it turns out there's certain responsibilities that don't really fit well in a controller, nor the business logic the controller invokes. One such example might be initializing a session, or piping all POST requests through a CSRF validator. Those things happen on the "outside" of the controller, and we call those "middleware". So now it's no longer MVCRD. It's MVCRDM. It also turns out you need to wrap the notions of request and response in an abstraction - literally `Request` and `Response` objects for middleware to be implemented in a truly clean, maintainable way. So now it's MVCRDMRR. Etc.... Basically pure MVC doesn't really account for all of the nuance of the architecture and structure needed to build more complex sites using modern conventions for doing so. You need more than models, views, and controllers.
Thanks for the info. I write Docker apps. I don't need alot of the integrations. Like you said, Atom has great plugins, too. I've actually used IntelliJ for some Restacular API's, but I didn't like it at all. The typehints used with Restangular did help some. 
I get that recruiters get a bad wrap because there are some really bad ones out there. The truth is if you have a good relationship with a really good recruiter they aren't going to bug you for no reason. The really good ones are busy and they don't want to waste their time or your time. I would suggest going to PHP meet ups in your area if you have any. If not find other developer meet ups. In our area they are sponsored by recruiters and they are top recruiters so you might luck out and that might be the case in your area.
The only good recruiters are internal recruiters. (who are easy to find by the fact they are employed by a specific company, like say, Home Depot) There are **no** good external recruiters and they should be avoided like the plague. They rely entirely on their ability to interject themselves into the hiring process. **Every single recruiting agency I know of (~30) in the Metro area I am in has:** 1) Cold called us every time we created a job ad to "help us". 2) Taken our job ads, created copies, and circulated their copies which reduced visibility of our ad. 3) Attempted to convince potential candidates that they were responsible for our job ad and not to contact us directly. ( Literally, we have had people forward us emails with questions about this. ) 4) Attempted to create the illusion of them being retained by us to recruit people in a variety of ways.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
As do Interfaces and Exceptions.
I've been having issues recently with not being able to type. Seems to happen when doing such things as adding a new file or opening an existing. It just won't let me edit thereafter. I end up having to restart PhpStorm.
I wouldn't recommend recruiters. Instead, I recommend finding a local PHP user group on meetup.com and attending their meetups. They are often sponsored by companies looking for developers. In my experience these are often companies with more interesting jobs than those you will find through a recruiter. And at the same time you will meet new people (expand your network) and learn new things about PHP and development in general.
In my implementation, the session is an argument (as in PSR-7 argument) of the request, constructed by a middleware. The same middleware, after getting the response from `next`, is in charge of setting the cookie headers. What is wrong with this approach?
To be fair, I don't think anyone truly considers MVC as a complete solution to the application architecture. It's just another tool that must be used properly to be actually useful.
Ubuntu here. I've tried that but it doesn't work. I am almost convinced that happens when I do anything related to SVN such as adding a file or doing a commit.
If you're asking yourself that question then I would highly suggest you download it and try the 30 day trial. If you don't like it, simply uninstall. :)
Is that Fabian's very first framework? If so, he's come a long way. :)
I dunno; as a consumer it just makes sense to update the last number every time there's a release that's not bug fixes. If the upgrade's seamless[1] I don't care that it's major or minor. Semantic versioning is irrelevant, really, and since it's reset every year it's meaningless. going 2016.3 makes sense - "Ah, it's the 3rd release from 2016!". do this. Next year's first release is going to be called 2017 whether it's a total rewrite or just features new fonts [1] this is probably the sticking point.
I freelance full time (and then some) and Upwork has been a huge help. In the beginning, I lowered my price to something barely acceptable to me, I think it was $15 per hour (still enough to set me apart from the hordes of Indian "devs") and made sure I got a 5.0 rating on every gig. This helped put me in the "top freelancers" section, and then the jobs just kept coming. All that matters is keeping your rating - too many clients filter by rating alone, and when you take into account how many 5.0 guys there are out there, even something as high as 4.99 puts you at the bottom of the pile. These days I focus on long-term contracts exclusively - months, if not years in duration. The Upwork fee is much lower for long term contracts, you get to know your client and a good rapport evolves so you understand what they need, and you look extremely reliable to anyone inspecting your profile. After you've held on to the 5.0 rating for a while and have had 20ish or so gigs, you should be invited into the "long term contracts" group on Upwork - an official group the sole purpose of which is posting only long term contracts. That's where the "dream gigs" usually are. Also, pro-tip for freelancers: there's significantly more "fuck off" room when you're freelancing on 3 long term jobs part-time, than one job full-time. Three 15 hour per week jobs will set you up much better than one 40 hour job. Not just financially, but also in terms of not wanting to do something any more and being able to just walk away (provided you did a good job and can get a 5 star rating for it).
Yes! It's amazing 
&gt; As your application gets more complex, you'll find that MVC does more damage than good. MVC is neither good nor bad. It's a pattern. How you implement it, and what responsibilities you burden it with determines whether it's good for you or not. Think of a pattern as a knife. You can make it instrumental to a great restaurant's kitchen, or you can cut your hand off. The knife is just there, it has a handle and a sharp end. That's all.
Keep in mind that most popular frameworks make the same mistake implementing MVC: they turn each of M, V, C into monolithic *layers*, that grow indefinitely, each in its own folder, until you have a spaghetti of models, views and controllers talking to each other. MVC is referred to as the "MVC triad" because you're meant to look at each triad individually, building isolated MVC components out of such triads.
I stumbled on the same ones... Really, skip the dumb ass questions, give someone a small (practical) programming task that takes a few hours and ask them questions about why they did what in there. 
&gt; And once 4.0 is released, CodeIgniter's can return to the latest and greatest community. I don't think targeting PHP7 is enough for something to be "modern". I checked the roadmap, and save for a few modernizations, CodeIgniter's architecture remains quite dated. It's hard enough for a framework to keep up, but even keeping up is not enough to make it anymore.
How do you tackle a difficult situation? Google. In the end, every developer will tell you they will google solutions to difficult. Heck, even simple ones.
LinkedIn and meetups
I have had that also on OS X, although touch wood it hasn't happened since 2016.2
I was secretly hoping this is a tutorial about how to write a new database server from scratch. But, nope. It's about how you can click "Create" in phpMyAdmin.
I wouldn't say "major" open source contributors, they gave me a free license and I wouldn't say my open source project is very big :)
&gt; So as procedural code... there are pros and cons to every pattern. Technically OOP is an extension of "procedural" code, to break a big procedural problem into smaller procedural problems through encapsulation. So yeah. &gt; MVC in the context of how most PHP devs and frameworks implement it has more cons than pros. Well, it just still seems unfair to blame the concept of MVC for this, never mind what frameworks call MVC. MVC is so simple and beautiful... and works great when applied with intelligence. In a way it's even inevitable. Those who don't implement it right are doomed to re-discover it (Facebook's Flow for ex.).
I pull them from the queue. Badum.tsh
Learn the basics firsts. It is incredibly important in the long run to learn the basics. You should know &amp; understand how to use the common functions (e.g. arrays, string manipulation), PDO etc. Jumping straight to a framework can leave you hanging as you will start to learn and depend on the framework's built-in functionality/shortcuts which will likely be different framework to framework. Having a core understanding of things will help you adapt faster. You'll also run into projects where a framework might not even be needed and you should know how to write &amp; structure something properly without one.
Definitely learn the basics first. You likely won't write code that lasts forever or that you're still satisfied with in a couple of years, but it's important to fully understand a language before getting into frameworks that make use of a lot of the language's constructs and design patterns. I can recommend [The PHP Practitioner](https://laracasts.com/series/php-for-beginners), which is a free tutorial series on Laracasts that goes from the PHP language basics to the fundamental concepts and components of most frameworks. I developed PHP for about 6 years before even looking at a framework. When I did (I started with Symfony and moved to Laravel shortly before 5.0 released) it was definitely overwhelming at first, because there were a lot of concepts that I haven't even considered before. It wasn't before I started looking into how the framework is built and how a usual request-response-lifecycle usually works that I actually understood what it does and became more proficient in using it. So using simple versions of some of the components outlined in _The PHP Practitioner_ (or somewhere else) is definitely a good way to go before switching to a framework.
OOP doesn't involve solving a problem by assembling encapsulated objects? [My whole life has been a lie...](https://www.youtube.com/watch?v=8oi12dCzHG4) :(
&gt; Try to roll your own tiny mvc framework Question. Can't we just "write" a framework, why does everyone say we have to "roll" it? My editor doesn't support this.
Your comment can be read in two completely opposing ways: &gt; Learn the basics (get familiar with plain PHP) before start learning advanced stuff (utilizing big PHP frameworks). And: &gt; Learn the basics (guided by a beginner-friendly framework) before start learning advanced stuff (designing the architecture of an app on your own). Many frameworks openly target beginners, like Laravel. In many cases people can do a basic app in a framework but are completely lost how it works under the hood and why the framework was built the way it was (that'd be "advanced" to them). And because frameworks target beginners, they often make architectural concessions (either intentionally or not) in order to appear simple. So are frameworks "advanced stuff" or "basic stuff"... depends on PoV.
I think you mean people who DO know fuck all. ("Fuck all" = nothing)
If you think of an object as procedural code in a class then you're doing OOP wrong
&gt; "What is your favorite computer language to solve a complex algorithm?" This can be an interesting question. After attempting Google Code Jam this year, I found out the best language for me to use was, in fact, PHP. Sure, I tried to swap to C at one point for performance increases, and performance did jump! Immensely! I think it was roughly 24x faster at the things I was throwing at it. That being said, C still couldn't handle my algorithm for large data sets. Then I found out how to optomize the solution to make it run in a reasonable time frame for the large data set. And that same optomization meant PHP was fast enough too. Certain problems are betters solved in certain languages (I'm not going to try neural networking in PHP any time soon), but when it came down to it, it wasn't the language that was the problem. It was that my algorithm was too naive, and I was blaming the language as an easy out. Being comfortable with my language was more important than how fast it was. Being comfortable meant it was easier to spot and avoid bugs, to debug easier and to iterate through better algorithm designs quicker. So the answer, imo, is whatever language you feel most at home with
Yeah they are quite relaxed on that front. I once met a (quite lovely) girl representing phpstorm at DrupalCon, and she was very eager to encourage others to get that free license. 
Do a handful of really small play scripts, perhaps for a personal site, before jumping into a framework. It is useful to know what is "the framework" and what is native PHP. The jQuery community ended up with this issue. Lots of developers only know how to use jQuery, when some native JS would do the trick much of the time. So you get really trivial things becoming framework dependent.
But... you didn't say what it means :P Also, I'm trying to drive a point home. To me a framework is not "advanced programming". It's "programming with training wheels". It has its place in RAD scenarios, but the drawback is bloat, loss of control over the app architecture, and often leads to monolithic apps that die with the framework that's hosting them (and frameworks tend to die a lot in the PHP ecosystem).
When teaching beginners, I prefer to recommend against a framework, so the "how things work" is done explicitly to start off with. When you realise you're writing the same code again and again, a framework can be helpful, but I don't think it is good for the learning process when you get free functionality by "magic". It was this philosophy that guided the writing of [my beginners' tutorial here](http://ilovephp.jondh.me.uk/). I deliberately didn't use a library, except in the area of security, where it is good to teach readers not to roll their own. 
If you cant find things in Google then you classify it as difficult situation :P and i suggest debugging and reading source code at that point.
I like HTML. I can write it anywhere and refresh and, boom, there she goes.
This right here. Same problem plagues WP-only devs.
Yes it is worth learning barebnones php first. Example: If you try to learn some framework which support dependency injection autowiring and you don't know wll enough how does interfaces, abstract classes, inheritance etc. works, than you will have a lot harder time using this feature of your framework.
Plain PHP for sure. Frameworks that do things like automatic dependency injection, utilize magic that will significantly confuse a new developer when they *dont* have access to such magic. Frameworks are productivity tools best used when you know precisely why you are using a framework and what problems the framework is solving for you (and not solving for you). A framework is NOT a crutch or a set of training wheels.
&gt; In PHP what is the difference between a Class and an Interface? "**In PHP**"? But to be honest, I wouldn't be surprised if PHP actually did something special and unexpected here compared to all other OO languages.
&gt; If you cant find things in Google then you classify it as difficult situation :P and i suggest debugging and reading source code at that point. To be fair, I'd turn to Stack Overflow first. And if Stack Overflow doesn't know, post a bounty on your question and they'll know. I usually have other things on my side plate that if it takes more than 2 hours of debugging and reading through source code, it might be more time efficient to swap tasks and see if SO can scour the source code for me. And they have, too. Saved me days that I probably would have spent doing it myself. It's for that reason that every so often when I'm low on work I go through SO myself and stack up on points, for the few times when I do need to post a bounty.
Yeah, you never made your point clear. Also, your feedback isn't helpful since you don't elaborate why you would pick one over the other. 
The problem with the "learn the basics first" approach is trying to figure out which basics to learn and which examples to follow. So okay you probably know you need a database. Great. Search for php database tutorial and you get back umpteen thousands of links most of which are outdated or just flat out wrong. How does a beginner choose? By starting with a framework you end up with a very constrained learning path. This is how you access the database. This is how you define a route. This is how you generate html. etc. A framework can save you from going off in all directions while actually teaching at least some of the basics. Ideally, at some point you would start to wonder why you access the database in a particular fashion. Perhaps you hit a limit and using the default approach becomes messy. At that point you could start learning alternatives and perhaps understanding the bigger picture. In other words, starting with a framework does indeed give you training wheels. The trick is to know that eventually you need to take the wheels off. 
It does. You can reach past the interface to access public methods on the class that aren't exposed by the interface. Other languages treat the interface more strictly.
They do have a build number. It's like 169.18xx or something.
CTRL+SHIFT+N is ONLY filename lookup, which should be less resource intensive than Search Anywhere.
If you are an experienced programmer in another C-based language already, I think you probably could jump into a framework much quicker than if you are not. In both cases, though, learn the basics before jumping into something.
I know it is off topic but could you clarify this? Every oop oriented language I have used (c++,java,c# etc) allow you to add whatever methods you feel like on classes that implement interfaces. I know php implements interfaces a bit differently but never noticed anything unusual while using them.
&gt; Yes I am not trying to make discussion netbeans vs phpstorm as phpstorm is probably better. I wonder would phpstorm give &gt;&gt;&gt;ME&lt;&lt;&lt; any benefit and if switch is worth it. Thanks. The problem is that phpStorm has so many amazing features tucked away that everyone's favourite feature is different. No one can tell you exactly what will be the killer feature for *you* specifically. There is one, and it is in there, but we can't tell you what it is. For me? It was how well phpStorm integrates with xDebug, Vagrant and PhpUnit. Find a bug? Get the workflow of how to reproduce and chuck some debug points in. Go line by line to hit the bug. Found the spot? Okay, chuck a debug point in the line above then write a quick Unit Test to hit that spot. Right click the test function and debug it. Keep going line by line till we hit that. Is it for a certain environment? Just set PhpStorm to execute the unit tests and php binary inside the vagrant and debug as normal. Done? Bug fixed? Run your unit test in coverage mode, go to the place where the bug was and look for the green and red lines along the editor to make sure that you test covers the branches of the code that you need. That's my killer feature. Maybe for you it's phpStorms' amazing refactoring tools? A friend of mine liked the Symfony2 plugin. Another just liked it's good JS support as well as PHP support. It's different for different people
You can add them yes, but you can't access them. Java (PHP's closest cousin): https://repl.it/Crk0 Since `foo` is type hinted to be `Foo` the interface, it won't let you access `baz()` even though the implementing class contains it, since as far as its concerned, it doesn't exist. PHP, however, would let you access `baz()` even though it's not present on the interface. https://3v4l.org/EGK7D
I mapped similar functions in Phptorm to the same keyboard shortcuts that I use in Sublime Text so it makes going back and forth between the two much easier. I use both just about equally.
well, cross browser support has coma a long way... that usually helps
I see. Never noticed that before. Never occurred to me to even try to use a method not in the interface after type hinting against the interface. My ide will complain. Thanks.
&gt; What is wrong with this approach? I hesitate to call things "wrong" per se. I would say instead that under ADR, the Responder (i.e., the layer that builds the response) should be in charge of setting cookies, not a middleware piece. (Unless the middleware piece is named something like "ResponderMiddleware" and is the only thing in charge of building the response. ;-) Further, I opine that dealing with session storage should be Domain work, not Action (collecting user input) or Responder (building user output) work. The Action can read the session ID cookie from the request and pass it to the Domain, and the Responder can write that ID (or a regenerated one, as reported by the Domain) to the response, but the Domain (probably via infrastructure) should be the thing reading from session storage and writing back to it. Yes, more work. But it cleanly separates the input and output management from the actual Domain logic.
&gt; The problem with the "learn the basics first" approach is trying to figure out which basics to learn and which examples to follow. So okay you probably know you need a database. Great. Search for php database tutorial and you get back umpteen thousands of links most of which are outdated or just flat out wrong. How does a beginner choose? I don't think it matters, because they're going to use the framework to deal with the database in real life. The point is to learn how things function underneath, so they can understand what the framework is doing for them. There's not enough difference between, e.g., mysql_ functions and PDO to create any major conceptual disconnect.
That's not related to the implementation of interfaces in PHP, it's just dynamic typing. In fact you can access those methods in Java, too. But it has static typing, so you need to cast: `((FooImpl)foo).baz()`. Since PHP got dynamic typing you don't need to cast, the set of available methods is determined at runtime automatically. Type hints don't change this behavior. You don't even need interfaces for your example: class A { public function bar() {} } class B extends A { public function baz() {} } function func(A $a) { $a-&gt;baz(); //works as usual } //If you remove the type hint in order to pass any object, you will //have access to "every" method and it would work as long as the //object does have the required methods (inheritance not even required). //Welcome to the world of duck typing. function func2($a) { $a-&gt;baz(); $a-&gt;newMethod(); }
&gt; If you haven't actively looked for the good ones that you would, by definition, never find them. How do you define a good middleman tho? A couple of those 30 were suggested to us by other people who argued they were "good". 20-30 years ago, that served a function because of limited circulation of job ads. Now, almost every single job opening for a professional ends up circulated on 2-5 search engines for jobs.
When a theme or plugin brings in another copy of jQuery...
You should not learn a framework at first, because then you can't really appreciate what exactly a framework is doing for you. You won't know why you should even be using a framework, or what problems a framework actually solves.
This seems to go against most of the advice I hear, but I prefer starting beginners with a framework. The framework adds a nice facade on top of what can rapidly devolve into pretty ugly code. Of course, it's important to learn the more intricate details *eventually*, but in web development (and really any other kind of development for that matter), there are already enough things to learn. Starting with a framework allows you to focus on the higher level concepts first, and then when you have the time or inclination, you can dive deeper into the things you care about.
I get you now. I thought you were the hiring manager. Its hard enough developing, hiring sounds like a whole new hassle. You sound like you have a good YAGNI and DRY look to software :) Just a side question, you mentioned LaraJobs. What has been your experience with the service? In my area, we have a very small amount of positions (and no LaraJobs within a 100 mile radius). 
It's strange nobody mentioned this yet. https://github.com/PatrickLouys/no-framework-tutorial 
I won't focus on the actual content, but more on the presentation style and some generic advice. 1. Never turn your back to your audience. It will seems like you are disengaged with your audience 2. Never look at the big screen / point at it. If you need to point at something, make it a specific slide or highlight it in the current slide. 3. There are a lot of 'euhms' in there. Try (I know this is hard) to practice your talk more, so you don't have to 'think' what you're going to say. As with anything (like a kata) the more you do it, the more natural it becomes. 4. People usually find it easier if you pack your message in a story. So think about maybe having an user doing different things through the API and how that would look. It saves you from coming up with examples on the fly. Hopefully this helps a bit. Good luck on your journey into becoming a speaker! 
It helps to know what you're "really" doing if you have a grasp on the simple syntax stuff.
I imagine you don't actually know what fortrabbit is then?
Learn basics. Understand how to do basic DB calls. Build some classes. Learn OOP. Then learn a framework and appreciate the simplicity.
Yes I miss read the title and twitched , fuck Drupal tho.
Well that sucks that that's been your experience.
Life. Maybe I'm just really unlucky but the people I deal with all shall my bias. It could just be a location thing.
I think this is generally excellent, I've seen it before - but IMO it is entirely unsuited to beginners. There are too many advanced patterns for the new programmer to deal with (SOLID, DI, etc). There are also some areas that are glossed over that will lose readers early (e.g. _This is not a Git tutorial so I won't go over the details_).
&gt; but I don't have a knowledge to replace JQuery And you shouldn't. jQuery is amazing at abstracting away (most) of the browser-dependent aspects of javascript, of which there are plenty. It does lead to questions like "how do I redirect to a URL with jQuery?", which make it clear that the dev asking the question doesn't have a handle on native JS and understand *why* he/she should be using jQuery.
I've read through most of the framework code over the past couple of years. Taylor seems to maintain a comment structure of 3 lines, each line with 3 fewer characters than the previous line. An interesting if unnecessary detail. (Sometimes the comments are a bit contrived to fit this pattern but not so much as to be generally noticeable.) Not particularly relevant but interesting.
Point me towards tech support that will tell me what I've broken in Apache config, for $5/mo. If I spin up the cheapest droplet on Digital Ocean, they're going to palm me off with a LMGTFY answer to any configuration question I have. 
Have you ever used Weather Whiskers?
LaraJobs was great. We got like 100 responses in the first 24 hours, and then they kept coming in for a few weeks after. You obviously have to weed out the bad apples but overall we were really happy with the results.
Nope, but I just checked it out. Thanks for mentioning it, I'll give it a try!
&gt; I imagine you don't actually know what fortrabbit is then? It's a service for people who don't like to install things. Which... makes the subject of their post quite ironic... 
That...is the whole point of the framework, to abstract away the details so you can focus on writing maintainable, readable code instead of worrying about the inner efficiencies of this vs that function. Clear code written for a specific framework &gt; pure JavaScript that's ten times harder to use and unreadable by most collaborators. Pure JavaScript is a waste of time unless you're trying to optimize performance, and in that case you might as well write your own framework... 
You're using windows xp to tell people how to install wordpress 3? Please don't....
You can also try to break down a framework by going through it to understand what it does and "why it does like that". That helped me a lot.
&gt; The jQuery community ended up with this issue. Lots of developers only know how to use jQuery, when some native JS would do the trick much of the time. So you get really trivial things becoming framework dependent. jQuery is a small library. You can use jQuery and no one from "outside" your component would know. While a framework swallows all your code and "contains" it. It has full control of what you can and can't do, and how you organize your project. As such I'd say jQuery may not be needed in some cases, but at least it's harmless. It's easy to take a project that uses jQuery and refactor it to not use jQuery. The same thing cannot be said for most PHP frameworks. You'll be basically rewriting all the code.
&gt; Laravel violates both of them As a trade-off for what? :)
The reason: many, many people - who have used NB and have now switched to Phpstorm - are saying it's better and you should try it out for yourself. What more could you ask for?
Depends on what you want to do. If you want to be a PHP programmer, it's best to learn PHP first. The better you know it, the more powerful you'll be with the framework. If you're just trying to get something simple up quickly, you could probably get by without a ton of PHP experience. 
You could "write" a CMS, but would that be the "right" thing to do?
Seems like a good idea, thanks. I looked it up and there are a few related groups around here, not huge but it looks like some people go to them. 
Boo, you're an enemy of fun!
Frameworks take a lot of the edges off of PHP, however they leave you without the capability to recreate their features on your own which can be important for applications which need those edges or need more customization.
Just use libsodium.
As a frontend dev, I've always liked PHP, so I've dabbled in it a little bit, writing my own code here and there. Unfortunately, I didn't necessarily write good code (as is the way for all new devs), so I decided that I didn't know enough to do things right. Just a couple days ago, I installed Laravel for a personal project, and it is SO MUCH EASIER. But more importantly, I feel like it's *right*. That being said, when I get an error (which happens a lot), I know how to troubleshoot it, because I've learned enough PHP to know what part isn't working right. I can tell you now that learning Laravel is much different than learning PHP, but I'd be moving 100% slower, if I didn't know actual PHP to begin with. I HIGHLY recommend learning and writing your own PHP with database queries especially. Grab one of those free hosting sites that gives you MySQL database and just plug away on it for a bit. That's what I did!
me too. but I don't have a problem with this. I actually got grandfathered into a lower rate because I already had a license. They reward loyalty. So if you like it and stick with them the annual rate decreases. 
You're approaching this incorrectly. Don't worry, there are lots of good tools available, but you're not going to find them as long as you assume that they need to be PHP. But before you can look for a tool, there's a number things you need to understand. Most encryption is defeated because it wasn't installed properly. Sure, they unzipped it, and ran install.php just like the manual said, but then they did something careless like running a chat server on the site that can read data from RAM... and the entire use of encryption is for nothing. Sure, Libsodium might be the strongest encryption in the whole world, but if you run it on a web site that has a security hole in the Email.cgi script or something, and it lets people read all your encryption keys, then you might as well not be using encryption at all. So don't ask about Libsodium. Learn to build a secure web site first, then do the encryption. If you do don't have time to learn to build the site securely and you hope that the encryption will make up for it, do your client a favor and tell them that you don't know what you're doing. Once you've got a secure site and you're ready for encryption, you need to identify why you need encryption. Where is the data coming from? Who is it going to? Do I need to decrypt it? Or do I just need a hash to prove I had the data once? (Don't assume you need to decrypt it.) Are we talking about SSL so we can take credit cards? If so, what are we doing with the credit cards after they arrive encrypted? Are we sending them out in a plaintext email? If so, why bother with the SSL on the site? Or are we talking about storing it in the database? Or sending it along to a bank? Or sending it to the web site's owner? Or sending it from one user to another? So encryption isn't just a "thing" that you glue onto a site and it magically fixes your life and your problems. It's a tool that needs to be used carefully... because it's REALLY easy to do it wrong. SHA, GPG, SSL are staples of the encryption world. And they don't have to actually BE written in PHP for you to use them. You can call them from PHP. You can make services that handle the encryption. You can have the data bypass PHP and go directly to the point where the encryption happens. There are so many solutions... and you design one that works for your project... you don't buy it and install it and feel happy that you didn't have to think about it. The reason I'm sounding like an overbearing asshole right now is that after doing this for 30 years, I've seen too many people say, "I just got a project and, umm... I don't know how to build things securely." And they cut corners and do it wrong because they're too lazy to learn how to do it right - and the client pays the price for the mistakes.
The question is a bit ridiculous to be honest. Solve a *complex* algorithm? In what way is it complex, and what are the parameters? Different languages are better suited for different tasks, so it'd be extremely shortsighted to use one language to solve every problem. As an aside, unless you can leverage built in libraries for the challenges in these sort of programming competitions (Java has some great ones for dealing with large strings, numbers, etc.) I generally opt for c for performance reasons. Most of these competitions don't give allowances for slower, interpreted languages, so you're often shooting yourself in the foot by trying to get through using Python/PHP etc.
Feeling inspired by sitepoint were we? I genuinely thought it was a sitepoint article on sitepoint looking at the styling and lazy writing. * Making forms submit without buttons is a JS or platform / browser specific question... * Indexes were a database question * For some bizarre reason you asked someone to use a data-structure that is not in SPL and only proposed in ds namespace but not in any current release http://php.net/manual/en/class.ds-vector.php * You missed some of the nuance of HLL's including PHP (pass an object to a function, modify object, look at original object, cry at mutability and non pass by value or copy-on-write) **Trivial example problem code** &lt;?php class something { public $name; } function changeName(something $s, string $name) { $s-&gt;name = $name; } $someone = new something(); $someone-&gt;name = "bob"; $guitar = new something(); $guitar-&gt;name = "fender"; echo $someone-&gt;name.PHP_EOL; echo $guitar-&gt;name.PHP_EOL; changeName($someone, "Jerome"); echo $someone-&gt;name.PHP_EOL; Now of course you have asked about interfaces so this triviality should not exist due to a well defined public interface for something, but that example although admittedly trivial is something I've seen many people not realize why an instance is changed for years. * PHP Interface access of non-interface methods (/u/phpdevster pointed out) * Giving a practical test might be more of an eye opener (/u/Kratzyyy pointed out, not sure about take-home, I like timed, in-interview because I'm terrible at them) * Get someone to show you how to debug a problem using a debugger
I'm aware of when and when I should not use hashing and I definitely require encryption/decryption. This is not a decision that I blindly made. I'm not new to the industry (PHP since 3.x, and even longer with C) so I've got a good background when it comes to program and server security. That said, while I'm well read on encryption, ciphers and whatnot, I wouldn't consider myself an expert which is why I'm asking for help from experts in the field. I appreciate the response and while it doesn't apply to me, it may assist others.
&gt; (seemingly) relative ignorance on the topic I'm not sure how you got that impression but I'm definitely not ignorant when it comes to encryption.
Agreed, but for compliance in certain cases it may be a requisite.
This is one of main the reasons I created [Laravel Shift](https://laravelshift.com). At the time, I was managing several Laravel projects. The newer ones on L5, the rest on 4.2. Now I just *shift* anything that's behind.
True. Though in some cases higher-ups might be dead-set on AES even without FIPS/industry regulation.
Yeah, seeing jobs mostly from recruiters was another problem I had, especially the ones where the listing didn't even tell you what company it was hiring for. But it does look like recruiters might be the only way.
I don't think there is a particular reason for it. I also don't think it really matters. If it were to be changed, why not just omit it altogether. 
Knowing the function name you want is the first step. Once you know that, IDE's can autocomplete. 
Right, but how will you know the difference if you don't know where the boundries of the framework are? Don't get me wrong, I'm not suggesting never use a framework I am just suggesting that knowing the language you are writing in is invaluable. Frameworks are fantastic and I have used many, but if you don't know the basics of your language then you might end up pulling in a module or framework in order to handle something quite easy. Then you have a dependency you don't need. For example someone including jQuery to handle a single button toggle, because they don't know addEventListener exists. Also worth noting that jQuery and something like Laravel are very different tools for very different jobs. Perhaps jQuery wasn't the best example to use, as it is more of a library. But it did get the idea across.
If you already know basic programming, OO, web programming, and are familiar with another loosish, scripting like language, I would just start with a framework. Otherwise learning barebones PHP and a framework at the same time will likely feel like overload as there are so many things interacting with each other. It will be hard to narrow down what is doing what. Alternatively you could do both at the same time and see which works better for you. Create two versions of your project. In one of them, use a framework. In the other one, don't. Then spend a couple hours on one, switch to other one and spend a couple hours working on that. Keep doing this until you know which way is working better for you for now.
It is kind of a chicken and egg thing. I would learn the basics while learning a framework. Pick a framework, read the documentation, implement something simple. After implementing simple, read the framework code and spend time inderstanding what is going on behind the magic curtain. If you see an interface and you are unfamiliar with interfaces, read about what interfaces are and why they are used. Do not be afraid of the vendor directory. I have noticed that a lot of devs like to think that the vendor directory is some kind of "thou shalt not pass, experts only" border and that is a limiting viewpoint to embrace. Remember, everything you create can be improved and nothing is perfect. This is true for the work of all developers. Do not be afraid and understand that frustration comes before a breakthrough.
Well, it wouldn't be very helpful for me to say much, but if you can't get a solid answer here please do feel free to x/post into /r/phpsec where most of the readers are deeply interested in security.
Posting the result as an image is a horrible idea. There is no way for anyone to tell how it is actually formatted. With that said I suspect it is a `name: value\n` Pretty easy to split that up.
*triggered* I'm remembering the early 2000's. Shudder. 
Reddit in the office does not work well for me I guess :D You're right.
I'd also label myself as "above-average but decidedly non-expert". Thanks for your thoughts, /u/Firehed.
That output is missing line breaks. Use nl2br() or stick the output inside a &lt;pre&gt; block to get them back Formatting / parsing whois output otherwise is hard because different whois servers produce different output. There are some libraries that do attempt it - I think phpwhois has a god, but for a project I was working on I forked novutec/whoisparser and made some fairly major changes. You can find my fork at https://github.com/AllenJB/WhoisParser . Unfortunately I haven't found much time to work on it recently.
Where most subscribers are just clones of /u/sarciszewski you mean? ;)
I'm aware of the tongue-in-cheek intent there, but in the interest of full disclosure... I have 2 accounts (the second was created in an attempt to evade a bot that was spamming the mods with reports for literally everything I submitted) and one dedicated to a hobby I'm not *particularly* public about. I also still have an access to one registered for my employer, but I do not use it anymore (handed it off to someone who incidentally doesn't post much on social media).
OctoberCMS is written in php..? I guess we shouldn't talk about stuff built with PHP on /r/php then.
The default plugin is not a WYSIWYG editor. It's markdown, which has a live preview. But there is a ~~paid~~ plugin that offers a WYSIWYG editor. Edit: Nvm, it's a free plugin.
A plugin is a plugin... not OctoberCMS, so I'm not sure how it makes what I said inaccurate. Adding a TinyMCE (or similar) on top of the code editor doesn't turn this product into a "content management system". It turns it into a WYSIWYG HTML page editor. A good CMS models *content*, using constraints specified by the administrator, so users can then interpret and publish this content as HTML, or a PDF, or print it, or show it in a mobile app via native Cocoa or Android widgets, or provide it to third parties via an API and so on. Content is neutral of technology and device-specific presentation markup. And again, no version control, no auth and content workflow system... it's just a code editor. Dreamweaver circa late 90s also had a WYSIWYG, but it didn't call itself a "CMS".
They are functions, method is just a name given to a function within a class (afaik). Believe it was primarily adopted from the Java community as a nice way to differentiate. Don't really think there would be enough of a use case to change it personally, can't think of any other language that does it either of the top of my head.
Just wait some weeks, in PHP 7.1 you may use nullable types: https://wiki.php.net/rfc/nullable_types public function getFoo(): ?string {}
I believe this is in 7.1 https://wiki.php.net/rfc/nullable_types which is currently in beta.
In my experience, you need barebones php, so start with that. But I wish someone told me at the very beginning to start right away with OOP PHP.. apart from very trivial scripts, that's the way to go. (But I come from the C++ background, so I don't say this is an universal advice).
&gt; How do you deal with null return values in PHP 7? Don't typehint such methods, wait for 7.1.
I guess I should have included this in my original Post: I am aware of nullable types in 7.1, but I don't think I like them very much. It's one of thise things I hate about Java - the null pointer exceptions. But I guess nullables are cool if the IDE could warn you about them. Like "Hey, you're trying to call a method on a variable that you haven't checked isn't null yet." PhpStorm? Gary? :)
&gt;has an official, native PHP extension With PHP7 support.
If you do `$entity = $repo-&gt;find($id);`, you expect to find an entity for the given ID, so having nothing there is a failure. It's not a fatal failure which should stop the whole system, but a failure nonetheless : I couldn't find this entity. As such an exception is appropriate here. Fetch a non existent entity? Failure. Read a non existent entity? Failure. Exceptions are as appropriate in a query as in a command. "can you maybe do this if possible" rather translates to "try to do this, if you can't (depending of the why you can't) then do that". You can do that with `null`, but you loose the information of `why`. However, I agree that in some cases there is only one possible reason so in practice it may not be that big of a difference (unless you care of the single return type like here).
Just throw a `NoDefaultOptionException` already
If method is supposed to return a string and an empty string is valid from business point of view, then you should just return an empty string. If empty value should not occur, because business rules makes it invalid, then you should throw exception. (BTW - It applies to all types, not only strings - numbers, arrays, even objects.) If you need to make spacial action when the value is empty, then you should use has method. Has method is way much better than comparing to null or even empty string outside of class, because you don't leak representation of empty value from your class. In class empty value may be null, it may be lack of value, it may be false etc. - other collaborators should not know that, they should know what is important from business perspective that they model. This enables you to refactor the class at any time and change the representation as you wish, without touching an outside code. Also one more note about throwing exceptions - the best practice is to make sure that an object can not enter invalid state. You should be sure when constructing object that is has all required data and that the data comply with business rules, otherwise you should not allow invalid object to be constructed by throwing exception. Validation is not always trivial though. I would recommend to read https://thephp.cc/news/2015/11/how-to-validate-data And for Symfony folks who will be probably struggling with forms and doctrine when trying to apply this ideas: http://verraes.net/2013/04/decoupling-symfony2-forms-from-entities/ https://webmozart.io/blog/2015/09/09/value-objects-in-symfony-forms/ http://allwrightythen.com/ddd-with-symfony-forms/ http://rosstuck.com/persisting-value-objects-in-doctrine/
Duplicate: https://www.reddit.com/r/PHP/comments/4zlvci/how_to_format_the_result_returned_from_using_net/
Friendly reminder that PHP got type-hints right on this. `null` doesn't pass a non-nullable type-hint, luckily :-) `null` is still not ideal, but it's a good-enough solution for most problems. If you need to be more purist about it, then you would probably benefit from stronger typed languages (haskell, idris) instead of wasting time with PHP, which is more of a "get it done, and if it crashes we fix it up later" language.
I'm talking about overlooking that something is nullable. Yes, I want to code defensively, but I want my tools (PHPMD, PhpStorm, Scrutinizer, etc.) to help me with that and tell me if I'm not considering some case.
&gt; Like "Hey, you're trying to call a method on a variable that you haven't checked isn't null yet." It sounds like you want [Hack](http://hacklang.org/).
This is what I do. I just catch an exception if I'm supposed to get something back and it could possibly be null. 
Why wouldn't you want the language to disallow it explicitly? Why defer to a third-party tool if you can guarantee at the language level that your value cannot be null? 
WordPress should be your first and only consideration
I'm sorry, I don't understand what you're getting at. The language *does* disallow returning `null`. That's what this thread is all about. Can you clarify please?
on top of what youve already mentioned yourself, master block ciphers and their modes of operation. no need to get complicated with numbers to do so, its fairly easy to understand and will help out alot of making good decisions.. ECB vs CBC, etc not aware of any white papers as its usually over complicated text on black and white made to impress
I use phpstorm, I set the *.htm type as a php format in editor filetypes, got back my syntax highlighting for the php, but not the twig. You could go the other way, and set *.htm as a twig format if you prefer. Can't do both it seems
Alcohol and antidepressants.
Generally, I don't think you should rely upon error handling as a control flow mechanism. An exception shouldn't be a normal and expected part of your program. edit: here's a good write up of why, http://programmers.stackexchange.com/a/189225
The first one obviously. : ) But it would be nice if my tools helped me find the cases where I didn't handle the null case.
1. Add this line to config.php and see errors you get. 2. The units choice is not remembered, which is slightly irritating.
Yeah. Exceptions are for uncontrollable dependencies, like http requests.
You should consider the possibility that your reasoning is wrong if you create a method which is supposed to return strings, but doesn't always return strings. Would you for instance say that not returning a string is _an exception_? In that case - throw one.
For example, I've got an `Event` class that may or may not have a description. I would rather have the description set to `null` to indicate that it hasn't been set. But I get what you mean: an empty string means "the description is empty". I just think the `null` option is more explicit. To me, an empty string would look like something went wrong on input filtering/validation. But I guess that's just two different schools of thought. : )
&gt;The article discusses about some of the technical interview questions, which are usually asked if you are appearing for the PHP jobs. Read on to explore! If you couldn't tell immediately, just from this opening paragraph, that the article is shit then you should probably give up reading altogether.
And still, there are cases when you want exactly this behavior. That's why in C# Linq both .Single() and .SingleOrDefault() exist. Let the user decide which behavior he wants.
Empty string is a perfectly valid way of expressing that the variable is empty and it keeps your typing consistent. I wouldn't sweat too much about it.
Bigger question is, how to stop shitposting.
1) I seriously doubt your repo is that big, and your description sounds like you don't understand Git very well yet. Practice more. But as for splitting, you can split components to their individual repos and use Composer to bring them in to your application as dependencies (including from private Git repos). 2) Subdomains don't cost anything, maybe that developer means "domains". Either way, none of this is related to where the files go, so the domains thing is a red herring. It's not worth the battle, though, just put a .htaccess in the source folder, forbidding access (and make sure it works). 3) Write a simple facade around a third party component, which exposes exactly what you need from a package and nothing else. Then use the facade throughout your project. Look up the "facade pattern". This way you don't have to create existing functionality from scratch, but also you don't have to become bound to the specifics of a third party package. 4) Not enough specifics to say anything here. Except maybe I should say, [get your shit together](https://www.youtube.com/watch?v=-tGL-buZ94Y).
Wait so here's no aurguemebt as to how it's cancer or why you think it's cancer? Are you a troll????? 
Pretty simple actually. Start here: https://help.github.com/articles/creating-a-new-repository/ Then, build something that people find to be a much better alternative.
&gt; If method is supposed to return a string and an empty string is valid from business point of view, then you should just return an empty string. If empty value should not occur, because business rules makes it invalid, then you should throw exception. (BTW - It applies to all types, not only strings - numbers, arrays, even objects.) This part bears emphasis. Either: * Return '' * Throw a custom exception (and catch it)
That is exactly what I'm doing right now. But if there's a class with many optional fields (like an entity), I end up with a ton of `get*()` and `has*()` methods. Well, I guess there is no perfect solution for this. Thanks for your input!
&gt; As an employer, the first impression of seeing something like this on a resume makes me think that the candidate is a gullible bozo. But... I try not to judge people based on my first impression. I have the same exact issue. I wanna see them play ball on the field first, not reading about how great their statistics are.
Yeah, sorry about that front. :-/ A small consolation is that the `has` methods should all be a single line and the `get` methods should be just a couple of lines, since you could probably extract the exception throwing into a helper method. Here's just a little bit more input: I often just let `null` get returned from my accessors for scalar values, since it's semantically-correct for the lack of a value but PHP does the right thing when you try to add, concatenate, or multiply the value. That is, you can treat the value as if it got returned per normal in your calculations or display, but you can also still distinguish between a falsy value (`''` or `0`) and a true lack of value (`null`). For arrays, I simply return an empty array. Again, it's semantically correct. I can usually also treat it the same way whether a value has come back or not. Objects are where this gets sticky. I'd do this the way that we just described. It usually isn't an issue for bloat. If you have a ton of optional fields that are object-valued, you may have a situation where you need to refactor things so that you don't. Without seeing the concrete situation, I really cannot say.
Well, yes and no. For strings in particular, the empty string is more of a legacy holdover from PHP's C roots. No other scalar type has an "empty value" that satisfies its type check like an empty string does, so this solution is not very generally applicable to the broader problem. And treating strings differently than other types in this respect is probably a code smell.
I found some of the concepts interesting, but overall it felt pretty lacking. I tried out a number of WYSIWYG plugins which all failed at some things pretty miserably. I do like the idea of being able to modify the various code pieces within the context of the framework and I like the idea of how you can add components to particular pages. That said, it doesn't feel constrained enough in some ways, and some component usage was just confusing. In the end I decided to take some of the best ideas and develop my own.
I agree that would be a bad pattern for normal use.
I haven't tried this, but isn't that (or at least partly) what curl --spider was made for? From what I hear, you don't do anything with the crawled pages. Aside from the ponit that you do nothing after the pages have been visited, you could turn towards seo services (onpage.org for example) who already crawl the pages for you.
I understand your reasoning. Just advising to avoid horrible solutions like the ones in the standard lib: http://se2.php.net/manual/en/function.strpos.php One reason PHP is ridiculed is because of stuff like that, and with good reason. 
I've developed a theme and a custom plugin for OctoberCMS. My thoughts on it so far: **Content Creation Standpoint** The WYSIWYG editor is set to use Markdown by default. I'm a developer myself so I have no problem using it. However, if you have a separate Content Creator that will be creating content on the site - you may want to brush them up on Markdown. There also might be a WYSIWYG plugin alternative out there for OctoberCMS to make it more Word-like, but don't take my word for it. With the very popular Blog component, you'll be able to create a separate Blog section in your OctoberCMS backend - which is great. My rating - it's not super non-developer friendly but damn is it pretty. ***Developer Standpoint*** *View Layer* If you've learned templates from Blade or Twig, you'll be right at home. The view layer uses Twig but it's very simple to create layouts and sections (Twig calls them blocks) just like you would a Laravel application. *Plugin Development* Developing a plugin is also (mostly) simple. There are some opinions they have out of the box to help ensure everyone's Plugin backends are pretty similar. You can create your own "form-widgets" for these backend views with an artisan command. But it creates a whole directory of stuff and you have to wade through it to realize how to create a simple button. It's built so you can scaffold up Models with fields based on a YAML configuration - which makes a lot of decisions for you. On the good side you can quickly scaffold up your basic views in a sintch. On the positive side, there are controllers and models for plugins - and even a Settings type model you can utilize which is pretty nice. You can also use composer in your plugins without any problem. There's also ways to use the Plugin as a Service Provider or register additional Service Providers. Sweet. The bad side: I have yet to find a way to autoload any custom classes directly in the Plugin's directory. To workaround I've had to create *another* git repo and integrate it into the plugin with composer require'ing. OctoberCMS dev's - if you're out there please please show us how we can psr-x autoload in our Plugin directories. Registering your Plugin and hosting it on the store is pretty straightforward though. *How Laravel-ish is it?* You might be asking, is this basically a Laravel app with a blog component? Answer: umm no not really but kind of. The views especially are very "modern" php like thanks to Twig. But there are some weird things like the functions in the views I mentioned earlier. But if you don't like them don't use them. There's documentation you can read up, but there's a section of the view that's hidden from the content creators where you can register simple handlers. It's not MVC but it lets you do some simple actions. But you can also generate and use controllers, even expose an API with ease. They also threw this AJAX framework in there, but it's super confusing - you're better off just using a little bit of vanilla, jQuery or Vue to communicate with your API can handle the response as necessary. *CLI* There are a handful of generators and utilities out of the box with OctoberCMS. They are pretty helpful - but a couple are missing that seem like common sense, like resetting the Admin's password. *Documentation* The documentation is - alright. It's nothing like the Laravel documentation and is downright confusing at parts. It's not super well organized, but I could be spoiled after using Laravel's documentation for so long. **DevOps Perspective** NO MORE FRIGGIN CONTENT IN THE DATABASE. What a beautiful thing. You can easily version control everything because all content is file based. No stupid node exporting or bullcrap database driven CMS's force you to work with. Deploying your OctoberCMS is stupid easy and just works. You can even register Database Seeders to prepopulate your app for your non-content data dependencies. **Shut up already and tell me the conclusion!** Sorry about the rant. But I was super excited to see a CMS that was being built with Laravel philosophies. I would say it's the closest thing out there to what I feel is RAD for CMS's. But it's got it's own twist to a lot of things and doesn't quite fit to the "Back to Basics" motto it claims. I give it a solid 7/10 and I am confident that it will improve, hence why I'm bothering developing plugins and themes.
I think you're looking for value objects to solve your problem. Value objects have many great uses including the scenario of providing strict types and supporting null values. Given your stated example, your event definition might look something like this w/ a value object refactor: class Event { /** string $name */ private $name; /** EventDescription $description **/ private $description; public function __construct(string $name, EventDescription $description) { $this-&gt;name = $name; $this-&gt;description = $description; } public function getName() : string { return $this-&gt;name; } public function getDescription() : EventDescription { return $this-&gt;description; } } We'll define our value objects like so: class EventDescription { private $string; public function __construct(string $description) { $this-&gt;string = $description; } public function __toString() { return $this-&gt;string; } } class EmptyDescription extends EventDescription { public function __construct() { parent::__construct(''); // or maybe 'no description provided'; } } And we can use our new refactored code like so: $events = [ new Event('needs-a-description', new EventDescription('This is an event description')), new Event('needs-no-description-event', new EmptyDescription) ]; foreach($events as $event) { echo sprintf("Event: %s\n", $event-&gt;getName()); $description = $event-&gt;getDescription() if (! $description instanceof EmptyDescription) { echo sprintf("Description: %s\n", $description); } } 
[There's an API for that](https://www.whoisxmlapi.com/)
This is the correct answer.
I don't think this is something solved completely by the type system. Depending on needs, there are two types of getters: optional (returns value or null), and strict (returns value or throws exception). I just pick the one that makes sense for whatever Foo represents inside the application. Assume we have an optional/unsafe getter: class FooGetterLibrary { function getFoo() { // return value or null } } But then we have a SomeSpecificClass where Foo is always supposed to exist, so a strict/safe getter makes more sense. In this case just write a wrapper method in SomeSpecificClass that converts Foo from unsafe to safe. Something like: class SomeSpecificClass { public/private function getFoo() { $foo = $this-&gt;lib-&gt;getFoo(); if ($foo === null) { throw new FooException(); } return $foo; } // ... } Then replace in SomeSpecificClass occurrences of $this-&gt;lib-&gt;getFoo() with $this-&gt;getFoo() If I don't use the getFoo() wrapper, then I should always check for ($foo === null), not nice. If FooGetterLibrary already implements getFoo() in a safe way, but Foo makes sense to be null inside SomeSpecificClass, then just write the opposite wrapper (safe-&gt;unsafe): public function getFoo() { try { $foo = $this-&gt;lib-&gt;getFoo(); } catch (FooException $e) { $foo = null; } return $foo; } If I don't use this getFoo() wrapper, then I should wrap all calls to $this-&gt;lib-&gt;getFoo() with a try/catch just to assign a null value, again not nice. I usually don't use the hasFoo() approach, because if getFoo() is expensive, then most likely hasFoo() is also expensive.
I just might
What benefits do you think that a framework would give you when creating a crawler? I can understand a framework if you are going to have an admin interface for it but other than that I don't see a benefit in using a framework for a crawler. You just need PDO to store data in your database and then you're done.
Not really, as things tend to vary from project to project. But this is what you can typically see in a modern PHP framework: . ├── /app (Contains all application business logic) ├── /config (Contains all configuration files) ├── /public (Also called "/web". Contains all frontend web assets. Domain webroots are mapped here) │ ├── /css │ ├── /img │ ├── /js │ └── index.php ├── /tests (Contains all Unit Tests) ├── /vendor (Contains all package dependencies) │ ├── /dependency1 │ ├── /dependency2 │ ├── ... │ └── autoload.php ├── .gitignore ├── Vagrantfile ├── composer.json └── composer.lock Projects that are built as Composer packages usually look a little different: . ├── /src (Also called "/inc". Contains all project business logic) ├── /build (Also called "/assets". Projects with compiled frontend assets will typically contain this) ├── /dist (Compiled assets are sent here after running Gulp or Grunt taskrunners) ├── /tests (Contains all Unit Tests) ├── /vendor (Contains all package dependencies) │ ├── /dependency1 │ ├── /dependency2 │ ├── ... │ └── autoload.php ├── .gitignore ├── gulpfile.js (If using Gulp) ├── Gruntfile.js (If using Grunt) ├── composer.json └── composer.lock
&gt; take a look at a framework (say Laravel or CI) Make a blank install, take a look, and see if you can make sense of things without reading the instructions!
The other reason is that for best performance you'd always want to batch a fetch operation. Either select multiple entities by some filter, or specify multiple ids in an array, etc. So it's guaranteed that a mature API will have a method for fetching many entities at once. And then having *another* method dedicated to the cases where you always get up to one entity, just becomes noise in the API: twice the methods, twice the documentation... It's better to just start with collection semantics and stick to it at the top service API level.
Technically we have three primitives, that in a conversation we call by different names, but are all named "function" in code: 1. Global functions 2. Object methods 3. Closures Bottom-line... it helps get the point across in a conversation, but they're all functions, and in the syntax it's clear which kind it is.
[removed]
I think not finding an entity is a fairly normal. You even named it find, which indicates you are searching for it.
It's asking about you as a developer of a package.
I found this code on one of our webservers. This code is definitely malicious but I'm not versed enough in PHP to determine its actual function.
Best way to determine what it does it running it in CLI using XDebug and proceed with step-debugging. It ofently uses quite odd PHP behaviors where some variables names are not fully interpreted thanks to special characters in names, or stuff like that. With a good debugger you will see what contains the variables and be able to follow the flow, best way ever. And it's not that unsafe, since you are running it a degraded environment, and step by step.
You don't need to inspect the code to figure out what it does. What it does... is accept code from the internet and run it. So it may literally do anything at all that the attacker likes to do.
Most likely it's meant to facilitate code execution; basically let someone use it like a shell to run whatever they want. Certainly it looks like that to me, but it's intentionally obfuscated and obtuse to read. Just shoving a backdoor onto a system and controlling a whole bunch of infected machines remotely is pretty normal. (Unless you're so high-profile as to be worth targeting personally odds are this hack was pulled off by a web crawler that saw a likely vuln and just tried to exploit it blindly. ) The fact it exists on your system probably means you have something with a known (at the very least known to the hackers) file upload exploit. If you're using WP you should check all plugins you use now. If you don't, well look for known exploits for anything you are using. If it's all only your own stuff and you're not sure how to find the issue that let this occur you probably want to have a consultation with a security auditor. In the meantime: consider taking the site down for maintenance until it's fixed up. 
Well CMS has always been a pretty crap term to describe what something like WordPress or others are: a system to manage mostly article-based websites. To quote Richard Stallman: &gt; “Content” means “some sort of information,” and “management” in this context means “doing something with it.” So a “content management system” is a system for doing something to some sort of information. Nearly all programs fit that description.
&gt; Sure. Can you point me to the page where it is used? I couldn't find it. Sorry its been a while, http://php.net/manual/en/internals2.ze1.zendapi.php It is in this section: http://php.net/manual/en/internals2.ze1.zendapi.php#internals2.ze1.zendapi.creating
This. I met the JetBrains/PHPStorm team at DrupalCon in 2013. I was an EclipsePDT user at the time. They offered a discount on the license for people who signed up for their mailing list, so I figured I'd at least give it a try. I downloaded PHPStorm demo and imported the big project I was working on at the time, and forced myself to learn some of the keyboard shortcuts. This was on day one of the conference, and by the time I flew home at the end of the week, I'd deleted eclipse from my laptop. 
It is subscription, but honestly, if you buy it for yourself (Individual Developer) and pay the monthly rate, it's $9 a month. I spend 10x that on coffee each month. And they do reward loyalty, your second year subscription is discounted some, and your third and beyond years are discounted a lot. Stay with them for over 12 months and you get a perpetual fallback license to a version you can use forever, even if you have to cancel the subscription. It won't be the most recent version, and you lose the ability to update, but if money gets tight, you still have a good tool to work with until you can get back up.
I don't mind money, it's cheap. But if I'll pay for it I'll promote such licensing which is very very bad, all of us vote with wallets. It looks like right now top most popular IDE + Graphic editor is PhpStorm + PS is subscription based. What will be next? I really really don't like programs provided as service. Imagine yourself paying subscription for using PHP. And Apache. And MySQL. And Linux or even Windows. Or many other stuff. This is very dangerous. You guys gave my nice reasons to use PhpStorm and I am grateful but I am so off because of licensing and I realized about it just after I installed trial version and checked prices. I always thought it's just one purchase price. Also it's just ridiculous when if let say I used program for 10 years so I spend hundreds of dollars/pounds on it but I can't afford it anymore so I need to stop using it. It's way beyond my imagination and it's very aggresive license. Program should be licensed like program not like service. I should feel like I am buying an application not like I am renting it.
Bower? Switch to npm already. https://github.com/bower/bower/pull/1748 https://github.com/reactjs/redux/issues/944#issuecomment-154858804 https://gofore.com/stop-using-bower/ https://blog.liip.ch/archive/2015/10/16/bower-kthxbye.html
It's not that hard to figure out. The only thing that might throw someone is "resources". I would probably just call it "assets".
Great answer by /u/maiorano84 If you're looking for a little more detail about what's actually in `/app`, I usually tend to follow [Bob Martins' advice](https://youtu.be/WpkDN78P884?t=7m45s) a bit: I make sure that what's inside of /app is the high level architecture and structure of my project. If I have a `/profile` component, then I have a `/profile` folder (which contains all of the views, controllers, and validators and so on and so forth). I don't go quite to the extreme that Bob Recommends, but I do apply that principle to `/app`, while leaving all of the other infrastructure folders as they are. I've found this helps me reason about the project much more easily, and makes the overall breadth and nature of the app more transparent. I also apply that principle recursively. Say `/forum` is a main component of the app. A forum is a non-trivial piece of software. It has a board index view, a forum view, a topic view, lots of moderation and admin views etc. Those too are exposed at the top level of `/forum` so that they're more transparent. And so on and so forth. However, that works best for larger projects. For smaller projects, you get less mileage out of it. 
Don't be shitty. Both have their place. In my workflow, I typically use Bower for front-end package management and NPM for backend and Dev dependencies. So things like Bootstrap, jQuery, fonts, etc. can be managed by Bower, while things like socket.io, Gulp, and Browsersync can be managed by NPM. They're not mutually exclusive.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; Why have two package managers? I just told you: One is to manage the front-end, the other for back-end and dev concerns. [This is a rather common practice](http://stackoverflow.com/questions/18641899/what-is-the-difference-between-bower-and-npm), as Bower was originally built and optimized with front-end dependency management in mind. [It even says so in its description](https://www.npmjs.com/package/bower) &gt; Bower is dead Says who? Do you have anything to support that claim? Because both are running very strong with continued support and maintenance. Just because you have a hammer doesn't mean every problem is a nail. Bower was created for a reason. There's nothing wrong with using it for that specific reason.
I use Laravel in my day job but before that I did several smaller projects in Yii2 and before that I was working on a large, mainly monolothic project on the old Yii. Yii is a very good "get stuff done" framework, and especially if you are making a more "traditional" web application, i.e. not a SPA you can get a fully functional product off the ground in no time at all. I really found the old Yii a very handy platform to build on with a fairly linear learning curve and good code generation tools, but it was definitely starting to feel its age. I haven't done much in Yii2 recently but when I was using it about a year ago it seemed like a very handy, intuitive modernisation of the old Yii, with little learning curve if you already knew the old Yii and have worked with more-modern PHP, plus half of the things I developed on the old Yii are now included in the new one out of the box.
Where do you find your clients? Every client I've ever worked with has wanted pages with such complex layouts (especially so when you factor in mobile/responsive) that you have to use a grid layout theme framework, which has means one of two things: 1. A super complicated, not-at-all-user-friendly GUI 2. Or complicated shortcode wrappers for Bootstrap-like grids and floats. Either way, you're average Excel jockey isn't going to be any more effective at building their own custom marketing pages with those two options than they would with any other CMS. The end result is that despite the fact that WP is supposed to be for DIYers or client handoff, it's always us, the developers who have to do the content entry for the client *anyway*. At least, that's been my experience. The only CMS that looks remotely client friendly is Wagtail for Django. I've yet to see anything in WP that as simple and streamlined as Streamfield. 
&gt;The fact it exists on your system probably means you have something with a known (at the very least known to the hackers) file upload exploit. If you're using WP you should check all plugins you use now. If you don't, well look for known exploits for anything you are using. I'm suddenly reminded of when people used php include a lot for their sites (back when people were switching over from SSI to using PHP to include content across multiple pages), and making themselves open to remote code execution by not checking the input.
Looks at the date...2013. Ok, I would have agreed with you even a year ago, but everything is also available in npmjs.com now. So it's like using Composer and PEAR. Sure, they both manage packages, but what's the point of using two? Bower doesn't specifically handle frontend packages better, so that's a moot point. https://www.quora.com/Is-Bower-dying 
&gt; Why would jQuery be loaded twice? How the hell do you compile your assets? It's an example. Breathe, it'll be ok. I'm sure you'll figure it out at some point. &gt; Just use Gulp to build your bundles (you'll probably tell me you use Grunt next) Again, you draw up opinions on things you either: a) know nothing about b) haven't used I use Gulp myself, but there's nothing wrong with Grunt either. [Here's some light reading](https://medium.com/@preslavrachev/gulp-vs-grunt-why-one-why-the-other-f5d3b398edc4#.jh8otwe6m) so you can learn where and when one might be appropriate. &gt; WebPack and a manifest file. Problem solved. No argument there.
Not a serious developer, but I've used Yii 1.1 and 2.0 for a couple of projects. Yii is the only framework who's design clicked for me. 
Nonsense. I've been consulting using SublimeText and Atom for years on "whole projects". I only use IntelliJ for Java projects.
Well, it's up to the use case. I gave examples. Someone was checking for username existence during registration - the positive outcome is the username is free, i.e. no results. But during login, username existence is the positive outcome. While listing users in an admin interface, existence or no existence is neutral - I can filter users from the UI, having no results is not error condition. So, it depends. The use cases are defined somewhere between the hard disk and the application. The mapper is precisely as qualified as the DB. The domain is more qualified, but it's often arrogant and shortsighted to assume what the exact use cases for your API will be. The domain is *less* qualified than the application, about the application's use cases for its API. The focus of a domain API should be on providing broader, flexible support for what people might want, and maintain its business logic invariants. Its opinion should stop there. The more opinionated it is, such as what query result is an "error" and which isn't, the less adequate that API seems in real world usage. Even the domain doesn't know how its APIs are used exactly. That is what releasing an API in the wild teaches you. 
I watched these series as an introduction: https://www.youtube.com/playlist?list=PLUBR53Dw-Ef-X-_A1KLy41r2QArCBy4rM Still haven't built something but I got a lot more understanding.
Are there actually people here, who would unironically place a redundant comma at that position in a sentence?
You think that's a really clever reply because it implies your framework is popular because it is good, or at least, a better alternative that its competition. It is not. It is popular because of the mass amounts of forced social media marketing. A good indicator of this is the fact that, even today, you are still trawling Reddit hard enough to find and respond to a post with zero upvotes and few replies.
Drupal has largely always relied on modules to provide a "complete" experience. 
But if you don't use this, that and that, what's the point then of using a framework at all? It's not like these days development speed and maintainability don't matter a lot. If a lot of your time needs to be coupling things together, keeping it all updated with changes in the framework (we all know the release cycle in Laravel is quite fast) - this slows you down and makes development a boring tedious task. It's much better to contribute to a well supported package and not some obscure stuff.
I've used Yii 1 a lot, it really clicked for me. I loved the CRUD and model generation. The PHP 5.2 compatibility was annoying though (`Model::model()-&gt;findAll()`). 
Your npm knowledge is out of date, it doesn't do nested dependencies any more (unless there are conflicts). You whole jQuery example is bogus as you don't used sub-sub-modules in your front end. If you need jQuery you'd include that as a "root" module and use gulp to move the compiled version to your web root. 
&gt; I know of 2 instances where client and the dev team decided to put 1.5 and ~2 years worth of work on Laravel down the drain and move to Symfony 2 because they got fed up with issues they where encountering supporting the project. And those where quite professional people that didn't make light decisions. So why did they use Laravel in the first place then? It usually takes less than 1.5 - 2 years to figure out a framework has issues.
Yii 1.0 was a mess, but Yii 1.1 was overall a very good framework. We're still working in it right now, but newer features get written as loose components, so we can easily move, migrate and scale. Yii's documentation is a hell, and there's lots and lots of know-hows that you don't get to learn unless you've experienced them firsthand. 
Would WhatsApp notice that a message is sent by a non-person?
As long term DB oriented coder I hate migrations. Why write DDL in code? It's error prone, an abstraction, and incomplete in its available options. I also don't like the static generators beyond very simple ones. I love Laravel though and I just don't use them. Laravel's other Artisan options like listing routes are very handy as things get more complex and it has a lot of flexibility if you know where to look, which can be hard to nail down at times, but the touchpints exist. 
That's like saying... to learn how a gun operates, pull the trigger while looking at it. 
I like it. Good job :)
Yes, there are. For example, non-native English speakers might have problems with punctuation rules that differ from their native language.
I don't know about what's app, but in general you set up a web server running the lamp stack (Linux apache mysql php). For local testing xampp is great for this. Once you're ready to deploy, try nearlyfreespeech.net of dreamhost. Google might also offer hosting but it's more convoluted. You don't compile a php page the way you'd compile a program in VS. Instead, your web server analyzes the web page requested to see if it has php code, and if so, calls the php interpreter in real time to deal with it. Ultimately you request and receive html and the php happens behind the scenes. You can also run php strictly from the command line using the php command, but most apis aren't meant to be used like that. 
I've been working with Yii on a professional level for 6 years. Some projects had up to 4 devs working on the same app simultaneously. It's been a blast. The hype surrounding Laravel made me cautious, but I wanted to see it for myself. When I saw the "helpers"-file, I stopped immediately. Someone mentioned ITT to just don't use these helper functions .... yea.... if you're the only one working on a code base, then that'll work. For me this was a flashback to php spaghetti times. No way, José. The only other framework I'd recommend whenever I'm asked is symfony for obvious reasons.
But what were the issues? Spending so long to tackle anything at all suggest to me these people were not that professional. What I find quite a lot is that people who want a framework that acts more like a loose set of libraries are the same people who spend ages trying to re-invent the wheel by making it square, then blame their libraries for their failure to bodge in their own code. Wasting such a long time is for me typical for developers who just aren't that good. So what makes you claim they are quite professional and yet took so long to figure out that there were wasting their time?
This tutorial is shit, don't bother with it
So why not just use Symfony?
Hi. PHP is interpreted, not compiled. So, if you want to use these files all you need to do is put them in a location on disk that can be served by a webserver. Typically, you'll have an html form to display in a browser to collect input and post to the PHP script for processing. Feel free to PM me if you'd like some help.
You probably want r/learnphp instead.
We have done about 90 projects in Yii (v1 &amp; v2) ... A long time ago we started making reusable 'admin' modules based on the Gii/crud generators that we just drop into new projects. We have our own modules for managing page content, file uploads, apis, user management, shopping carts, payments, search, etc. Yii (v1) community also bought a license for redactor which made things easier/nicer. Maintaining old projects (5+ years) is always a pain in my opinion. But usually the pain points are with front-end items ... Old JavaScript libraries or CSS frameworks. ... Anyway, I could go on and on about all of the great stuff Yii does. 
You're preparing the statements to insert and update, but not the ones to select or delete. SQL injection ahoy.
The things I listed can't be provided through plugins. At least not in a usable and comprehensive way. 
Gotcha. We definitely have our own gii extensions to build models and cruds. It was easy to extend the functionality we need as well. I misunderstood when I heard admin panel - I thought of a magic extension that required no coding, and I've never seen that. Gii tools are super easy and a great starting point to roll your own tools for sure!
I imagine that if you're careful you'll be ok. I don't know what Whatsapp uses to weed out spam and bots, I just know they do. Don't make it act like a bot and I *think* you should be ok.
So neither the name nor the messages should indicate it? It's nice that they do it, though. 
Thank you so much. After reading your comment, I came up with the following code and its been working like a charm. I think I had lost the concept of Javascript from writing PHP all the time, and it seems it was only a matter of using arguments. &lt;!-- friend requests handling --&gt; &lt;?php while ($extract = mysqli_fetch_array($f_result)) : ?&gt; &lt;?php //fetching variables $sender = ucfirst($extract['user1']); $query = "SELECT * FROM users WHERE username = '$sender' "; $result = mysqli_query($con, $query); $user_info = mysqli_fetch_array($result); $status = $extract['id']; ?&gt; &lt;!-- show f requests if there is one --&gt; &lt;li&gt;You have a friend request from &lt;a href='user_profile.php?id="&lt;?php echo $user_info['id']; ?&gt;"'&gt;&lt;?php echo $sender; ?&gt;&lt;/a&gt; &lt;!-- accept button --&gt; &lt;div style = 'display:inline;' id = '&lt;?php echo $status; ?&gt;'&gt;&lt;button onclick='addFriend("&lt;?php echo $sender?&gt;", "&lt;?php echo $status; ?&gt;")'&gt;Accept this request&lt;/button&gt; &lt;/div&gt;&lt;/li&gt;&lt;br&gt; &lt;? endwhile; ?&gt; &lt;!-- ajax code --&gt; &lt;script type='text/javascript'&gt; function addFriend(sender,status){ var xmlhttp = new XMLHttpRequest(); xmlhttp.open("GET","../php_include/accept.php?sender="+sender, true); xmlhttp.onreadystatechange = function(){ if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200) { document.getElementById(status).innerHTML=xmlhttp.responseText;} } xmlhttp.send(); document.getElementById(status).innerHTML='&lt;span style="margin-left:5px;"&gt;Connecting...&lt;/span&gt;'; } &lt;/script&gt; 
I'll try writing under r/learnphp next time. Thank you for your suggestion.
Dude your code is a hot mess. Please follow coding standards.
/r/PHP is not a support subreddit. Please visit /r/phphelp for help, or connect to ##php on Freenode IRC (nickserv registration required). You may also join us on at #phpmentoring on Freenode IRC for community and mentoring discussions.
Oh no, no risks, I did it a lot of timesn believe or not but that's the kind of things I'm used to deal with. Just run this into a VM, you don't risk anything except that the script might (and I say might) attempt to reach some SMTP server to send mail or attempt to do some kind of HTTP request somewhere to ping a server it's online. Nothing to be afraid of with such small code. Most bots like this will attempt to decrypt incoming parameters using keys and eval() it to respond to master order, they will never do that by themselves until you gave them the right order/crypted code to run. Plus, this script is really really small, I don't see it embedding anything. Ugly variables and intentionnal typos to trick the PHP VM will be automatically readable into your debuggers variables view so you can easily avoid to run them if anything seems wrong.
And after I said this I read the unoffuscated code, and it mostly does exactly that.
What? The whole point of Laravel over a framework like Zend or Symfony is to be very opinionated speeding up the development assuming you are following the "Laravel philosophy". Going against it (which can happen a lot on long-term development projects), and you'll find yourself fighting the framework more than anything else. Because in this situation you don't want an opinionated framework, you want a configurable one. Of course if you're extremely confortable in Laravel, then you may have easier time to fight a bit the framework from time to time rather than learning a new framework, but that really depends on how far you'll have to go.
I think I can do code on here. Here's a crawler script which uses pcntl forking to fork off children. I wrote this for a search engine. Keep in mind that when you're doing something like this, it's up to you to lock resources and make sure they're all properly checking. /** * The Crawler Service * * This service is responsible for */ use iMarc\Rummage\Models; call_user_func(function($handlers = array()) use ($argv) { declare(ticks = 1); // // Set up an empty children array and define our max workers // $parent = posix_getpid(); $children = array(); $uuid = uniqid($parent, TRUE); $max_workers = 1; $max_runs = 500; $loop_delay = 10; $shutdown = FALSE; /** * Handler for SIGTERM * * This does nothing other than set the shutdown value for the process to FALSE * * @use boolean $shutdown The shutdown flag pulled in by reference */ pcntl_signal(SIGTERM, function() use (&amp;$shutdown) { $shutdown = TRUE; }); /** * Handler for SIGHUP * * Parent process id is handled by restarting all children. Child signals are ignored. * * @use integer $parent The parent process ID * @use array $handlers An array of handlers for various operations * @use resource $stderr The standard error file pointer * @use array $children Children pulled in by reference */ pcntl_signal(SIGHUP, function() use ($parent, $handlers, &amp;$children) { $pid = posix_getpid(); if ($pid == $parent) { $handlers['print_err']('restarting all children'); $handlers['terminate_children']($children); } else { // // Ignore child SIGHUP requests // } }); /** * Handler for SIGCHLD. * * This handled multiple signals from children including children dying naturally * but also those that receive signals from the system. * * @use array $handlers An array of handlers for various operations * @use resource $stderr The standard error file pointer * @use array $children Children pulled in by reference */ pcntl_signal(SIGCHLD, function() use ($parent, $handlers, &amp;$children) { // // If we're not the original parent we should not be handling children. // if (posix_getpid() != $parent) { return; } // // If we get a PID, let's check on it // if (($pid = pcntl_waitpid(-1, $status, WNOHANG)) &gt; 0) { if (pcntl_wifexited($status)) { if(($code = pcntl_wexitstatus($status)) == 0) { if (isset($children[$pid])) { $handlers['print_err']('child %d exited', $pid); unset($children[$pid]); } else { $handlers['print_err']('janitor %d exited', $pid); } return; } } else { switch (pcntl_wtermsig($status)) { case SIGKILL: $code = 0; } } $handlers['print_err']('child %d died unexpectedly, cleaning up', $pid); if (($janitor = pcntl_fork()) &lt; 0) { $handlers['print_err']('failed to spawn cleanup process'); break; } switch ($janitor) { case '0': $handlers['init'](); exit($handlers['janitor']($children[$pid], $code)); default: unset($children[$pid]); return; } } }); /** * Main Logic, init + loop * * The parent process will loop, forking up to max_workers children. Each child in turn * will loop performing the 'main' handler. Each child is given a unique id which in the * parent scope is referenced by it's process id in the $children array. This unique ID * can be used to coordinate various data access in a database or similar. */ while (!$shutdown) { if (count($children) &lt; $max_workers) { if (($pid = pcntl_fork()) &lt; 0) { $handlers['print_err']('failed to spawn child process'); break; } $child_id = sha1($uuid . '::' . ($pid ? $pid : posix_getpid())); switch($pid) { // // We are the child, hurray! // case '0': unset($children); unset($max_workers); $handlers['init'](); for ($x = 0; !$shutdown &amp;&amp; $x &lt; $max_runs; $x++) { $handlers['main']($child_id); usleep(100); } exit($handlers['terminate_child']($child_id)); // // We are the parent, watch closely // default: $children[$pid] = $child_id; break; } } sleep($loop_delay); } $handlers['terminate_children']($children, $max_workers); $handlers['print_err']('shutting down'); exit($handlers['terminate']()); }, array( /** * Initialization * * @return void */ 'init' =&gt; function() use ($argv) { if (isset($argv[1])) { $_SERVER['SERVER_NAME'] = $_SERVER['HTTP_HOST'] = $argv[1]; } include dirname(__FILE__) . '/../init.php'; }, /** * Performs necessary cleanup if a child was killed or exited in error. * * @param string $child_id The unique child ID * @param integer $status The status upon exit, 0 if the process was killed. * @return void */ 'janitor' =&gt; function($child_id, $status) { Models\Resource::declaim($child_id); return 0; }, /** * The main functionality * * @param string $child_id The unique child ID * @return void */ 'main' =&gt; function($child_id) { $spider = new Spider($child_id); $resource = Models\Resource::claim($child_id); if ($resource !== NULL) { $collection = $resource-&gt;createCollection(); printf( '%s: Claimed resource %s on collection %d' . PHP_EOL, $child_id, $resource-&gt;getUri(), $collection-&gt;getId() ); try { $spider-&gt;crawl($resource, $collection-&gt;fetchOptions()); } catch (\Exception $e) { var_dump($e); } Models\Resource::declaim($child_id); printf( '%s: Freed resource %s on collection %d' . PHP_EOL, $child_id, $resource-&gt;getUri(), $collection-&gt;getId() ); } else { if ($spider-&gt;sync() === TRUE) { // // Boolean TRUE indicates that no collections were synced, but we did not // error. This usually occurs when everything was synced previously. We'll // stall for a full minute before rechecking. This means that if each child // does 1000 iterations it'll take about 17 hours for the child to exit if // all collections are synced. // sleep(60); } } return; }, /** * Prints to stderr * * @param string $message The sprintf() formatted message to print * @param mixed $component The component for the message * @param ... * @return void */ 'print_err' =&gt; function($message) { $stderr = fopen('php://stderr', 'a'); $service = pathinfo(__FILE__, PATHINFO_FILENAME); fputs($stderr, vsprintf( $service . '[' . posix_getpid() . ']: ' . $message . PHP_EOL, array_slice(func_get_args(), 1) )); }, /** * Performs routine termination tasks if a parent is terminated gracefully * * @param integer $pid The process ID of the parent * @return void */ 'terminate' =&gt; function() { return 0; }, /** * Performs routine termination tasks if a child is terminated gracefully * * @param string $child_id The unique child ID * @return integer The status of termination (0 is success) */ 'terminate_child' =&gt; function($child_id) { return 0; }, /** * Terminates all children by sending them SIGTERM * * @param array $children The children taken as a reference * @return void */ 'terminate_children' =&gt; function(&amp;$children, $wait_time) { foreach (array_keys($children) as $child) { posix_kill($child, SIGTERM); } for ($x = 0; count($children) &amp;&amp; $x &lt; $wait_time; $x++) { sleep(1); } foreach (array_keys($children) as $child) { posix_kill($child, SIGKILL); } for ($x = 0; count($children) &amp;&amp; $x &lt; $wait_time; $x++) { sleep(1); } } )); Also, a framework for this sort of thing is not the way to go. Perhaps you can use a framework to build a front end to control it later, but right now just the crawler should be a package you can pull into other/any frameworks/projects.
Thank you for your heads-up . I might as well go over the rules again as I probably have been flying in the face of convention. Thank you.
I don't understand the downvotes. https://github.com/PatrickLouys/no-framework-tutorial
/r/forhire
The prefab framework mentality is pretty deeply entrenched in the PHP community, so it doesn't really surprise me. That looks like a really well put together tutorial.
I'm actually the exact opposite. The start-up I used to work at used Yii as the framework for our website and I did not like it very much. I pushed for a move to Laravel, but nothing ended up happening towards that. Yii's workflow is just something that does not really work with my mindset. Laravel does, but that is probably because of its similarities to Ruby on Rails.
Migrations are very useful for applications with simple data schemas. They allow easy set up of environments for new devs and allow schema to be adequately source controlled. Plus, they simplify automated unit testing with easy DB recreation and seeding. And of course, they make it really easy to automate deployments. I find it interesting you complain that they are an abstraction when that's all a framework does anyway is abstract certain points of the code away. Also, not every web developer is a SQL master (I certainly am not, and the abstraction away from SQL makes my life much easier with the applications I maintain.)
This is such a weird post. The title asks if people seriously use Yii and then the post body is nothing but trashing Laravel. In addition, your biggest gripe seems to be that it doesn't have easy admin setup for you, so it's looking like your main complaint is that it doesn't do everything for you out of the box. Okay... [How](https://laracogs.com/), [hard](https://github.com/rappasoft/laravel-5-boilerplate) did you [look](http://labs.infyom.com/laravelgenerator/)? 
Good. I'm glad they work for you and your use case. There are types of applications, team sizes, team skillet makeups where the skillset, data size and app particulars make them difficult or make other options better IMO. In my case I have 21+ years of DB experience and 21+ years of Web dev experience. MySQL and PHP literally back to their creation and using other tech before they mainstreamed and am using new stuff like Mongo now where they fit. As a CTO of a funded small team startup I've scaled multiple apps to multiple millions of users. The first relationship that changes in a scaling app is its relationship with data. Given that, I expect to have a process in place compatible with 100s of gigs of data, multiple devs and a release process involved in change management a bit deeper typically than github code, possibly involving replica sets, master slave, preproduction and more. Given that, we expect devs to write and understand DDL and basic DB optimization. We version DDL right along with code and can easily see changes just as easily as you would in a migration. TLDR; This isn't for everyone and every team, and I'm not trying to blow smoke up your ass about being some hotshot. I'm just trying to relay that in my experience, and our expectation for product growth we really steer clear of migrations, but love laravel. Laravel is a great RAD (rapid app development) framework, but I've found it easiest to write straight DDL as that's the first place Laravel breaks down when scaling and DBs are one of the places my team and leadership are strongest. I will say it behooves any dev to learn some straight SQL and DB optimization concepts. Relational DBs are not going anywhere for a while. They map too well to world.
Just as I finished figuring this out myself... 
I'm just gonna leave this here: https://github.com/FriendsOfPHP/Goutte This is a website crawler library built on top of Guzzle and Symphony 2's Crawler component.
I love Yii. It really agrees with me. I have our company's proprietary centralized platform running on it, and amongst other things, is hosting over 300 client websites. I did look at Laravel to see what all the fuss was about, but didn't like it either.
Every project you do, no matter how easy or how dumb it might be, it's worth to put on your portfolio. In two years you will be surprised to see how my good projects you will have in your portfolio. 
Literally the second paragraph of your link says what I just explained.
So If I do the "naive" version and then commit I can persist the changes?
That's not "what you explained". You asserted very clearly that "NPM doesn't do nested dependencies anymore". That statement is flat-out wrong, regardless if you throw in the exception to the rule, in this case when there are version conflicts. It's an important distinction to make, and NPM's use of nested dependencies is a very powerful and important feature, but one that shouldn't be overlooked or mistaken for something else.
Laravel is a PSR-4 autoloaded framework. Therefore, the only opinions it *actually* has is that it's a PSR-4 autoloaded framework. There's no "fighting" anything like there would be in the old Cake 2 or CI 2 days before PSR-4 autoloading was a standard thing, and you were forced to structure your code in certain ways. I work on a very, very large project that has extremely specific needs for authorization. I tried to see if Laravel's built in policies would work, but they wouldn't - not quite sophisticated enough. No big deal, I just wrote my own policy library for my needs, and because Laravel is PSR-4 autoloaded, I just use like literally anything else in modern PHP. Laravel doesn't get in the way in the slightest. No fighting involved, I simply didn't use one of its features. Also, I have unique requirements that 99% of Laravel projects don't have: I have to sideload Laravel to run in parallel to a large existing PHP 4 legacy app, with its own auth/registration/sessions and things. One would think that a highly opinionated framework would make that challenging, but Laravel actually made it stupidly easy. Just wrote my own custom auth driver, which Laravel makes easy. Just need to implement an interface and off you go. So now authenticating through Laravel also authenticates in the legacy app, and vice-verse. Also, speaking of "Laravel philosphy", Laravel's default folder structure is insufficient for the scope and complexity of my app. Having controllers in `Http/Controllers` and routes in `Http/routes` wasn't cutting it for me. But because Laravel is super flexible, I just defined my own project structure to keep things organized and modular. The new folder structure is actually very similar to the notion of bundles in Symfony. Who would have thought that a "highly opinionated" framework like Laravel would make it so easy to structure your project like Symfony? Crazy, I know. Really, people who feel constrained by Laravel or feel like they're fighting Laravel are simply not using it correctly. I've never seen so much FUD surround a framework before.
I have yet to use Statmic - my main business is custom software not CMS's specifically. I'm just playing with a CMS to market my own things. I can't really justify paying for a CMS to support a few personal sites.
My clients range from fortune to mid enterprise and small business... https://codecanyon.net/item/visual-composer-page-builder-for-wordpress/242431 has worked great for the majority of use cases. If you develop components seperately and have the design of it down, it's not very difficult, just time consuming... and the crazier the design, the more money :D
I've renamed files to be unique inside a year month day folder scheme and reference the original name in a DB. The other way I've done it is using YYYY/MM/DD/XXXXX/filename Or you can remove the date in the folder scheme. 
Thank you for the specification. I think now I know what I'm faced with. Your comment actually makes sense since I learnt most of what in there from Youtube tutorials which are not consistent at all. I spent too much time watching basic tutorial videos available on some major websites without much results and Youtube tutorials helped me create actual programs. But it appears that I should keep in mind that they are often lead to a chaotic code. Also, I'm not sure why I used ucfirst there, but it was probably because I had copied and pasted the line from another file. SQL Injection has been my concern and I've been doing a bit of research. I haven't applied anything to prevent those attacks but will definitely work on that later on. Thank you so much for your help.
OP... you really are an idiot. You think any of these other frameworks will be less opinionated? Or they will include everything you want? Jesus christ, just write your own.
Thank you so much for the kind explanation. I'll try the suggested tutorial videos later. They don't appear lengthy so I could probably get a quick overview of what people are trying to tell me. I'm interested in learning about framework in the future too, so that doesn't concern me. I've been writing PHP my own way. Maybe I can step back and review the basics every now and then. Thank you!
I'm going through this page now, this is great. I don't know I'm having problems with the client's server provider (excuses) For one I can't seem to SSH... I tried to check the phpinfo page to see if I had the required PHP components for php-excel but that results in a blank page. I don't have command line access to the server. Going through the site above though, the basic sample which outputs a .xls file with a pop-up for download seems like the approach I will take. I checked out the resulting data in Libre Office Calc, I'm asked to format the text initially then I see the data. I asked the client to try it on his computer as I don't have a windows computer. Anyway thanks for linking that. I'm not exactly getting paid for this so I'm feeling lazy hahaha
&gt;Laravel is a PSR-4 autoloaded framework. Is there any recent framework working with Composer that is not a PSR0/4 autoloaded framework? &gt;There's no "fighting" anything like there would be in the old Cake 2 or CI 2 days before PSR-4 autoloading was a standard thing, and you were forced to structure your code in certain ways. My apologize, I have less years of PHP experience as you, enough to not have know much of the pre-Composer era. So my sense of "fighting" may clearing differ to what the one you are referring to. &gt;speaking of "Laravel philosphy" I wasn't limiting this "philosophy" to the folder structure, but what Laravel kind of push you to do: - customization is always done by inheriting framework classes to override hardcoded values - kind of hints you to use auto-wiring, active record and "facades" Sorry if that offended you, but for having to go really deep in Laravel as well (although not on the legacy side with very old PHP versions like you seem to do), you have to "fight" the framework. For example, let's say instead of having 1 front controller, you want to have 2: one for a production mode and 1 for a dev mode (i.e. dev environment, debug enabled and no cache at all). Symfony? Out of the box (except metadata sometimes like for doctrine if you are using it for example, because it would be a nightmare performance wise even for dev). Laravel? A nightmare, you have to checkout the whole bootstrapping process, the debug mode is absolutely not linked to the prod mode and is a config variable. You want to change the default file structure? Sure it's doable, you have to extend the Application and register your own path... Make sure you didn't miss any hardcoded path left and right. You have a library and you want to expose a config? You can't. As simple as that you have absolutely no equivalent to the bundle extension system in Symfony. Either your config is simple enough to fit in a few env variables or you copy/paste a nice config template with no validation whatsoever. Not found of auto-wiring because you have so many services autowiring becomes more dangerous than anything else and you want to explicitly configure your dependencies? A pain, PHP does a very poor job at that, this is why you have XML or YAML, which provides live static checking or auto-completion as well, but nothing of that in Laravel. Need to decouple your app? Laravel won't make it easy for you, if you are using Eloquent, you easily couple your Domain to it. Want to customize something? Inherit, look for hardcoded values, make sure you the right classes are used. Inheritance all the way down. Another big problem is the lack of high quality packages: there is little well written and well tested, maintained, Laravel libraries. I can't remember the number of times I had to ditch a Laravel package and use a component itself even if it meant to redo some extra work on the provider and config side. And the number of untested packages... Makes me shiver. Laravel is very much like Rails: an opinionated framework. I'm not saying it's bad! It's its strongest point: easy to get started and if you are following the framework it also goes very easily. Of course you can have a large scale project. If that's what your team is confortable with it's better to go for it that going for another framework nobody is familiar with. But it remains an opinionated framework nonetheless, and as such it will be harder to customize it than a configurable framework. That is by *nature*, and again, I'm not saying one is better than another, take for example the learning curve in Symfony: it's incomparable with Laravel's one. Please also note that I took Symfony as an example because it's the framework I'm the most familiar with (I also worked a fairly long time with Laravel), but any decent configurable framework would do. &gt;I've never seen so much FUD surround a framework before. There is a lot of wrong complains made to Laravel or Laravel folks, I completely agree with that. And I feel for Taylor who must see so many shit coming at his face although his has his share of worshippers. Most complains I see are due to inexperience or plain stupidity, both for which the framework matters little. However I must say I've never seen so much blind worship toward a framework as well, and I must say, it does scare me although not nearly as much as this JavaScript/nodejs hype.
https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller "Model–view–controller (MVC) is a software architectural pattern for implementing user interfaces on computers."
don't forget that you should always setup docker containers in a way that rebuilding one is always possible, and should be. which shouldnt be a problem at all if you use data containers. this spares you all the hassle of doing this, and your dockerfiles need to be up to date at all times anyway, because deployment and colleagues. so dont make this a common practise
It will be like Google alerts kinda. Users will be notified if their subscribed keywords are found in specific websites. 
It will be like Google alerts. Users will be notified for certain keywords that are found in some websites.. 
I'm sure I'll believe Wikipedia over senior software developers on this one
I wonder how does a typical PHP developer use containers. What's the difference to them between this and applications simply co-existing on the machine without hard isolation.
The Best Way you mean.
Reproducibility
Docker is a thin virtualization of some system APIs, like the file system. What's more "reproducible" about it? If I wanted perfect reproducibility, I'd rather use a full virtual machine.
it doesnt offer anything extra, it simplifies. envs between projects differ, with docker you dont need to build an entire virtual machine for every project, instead you have containers for every 'service'. so nginx with php7 might be a service. an older project might depend on apache and php5.6, another service. projects usually have a fig or docker-compose file which sets everything up just like a vagrantfile for example. on top of that, you obviously dont need an entire guest OS, everything runs on the linux kernel(unless youre running mac or win).
You might want to use these components: Symfony console, Symfony cssselector, Symfony domcrawler, Guzzle
&gt; anything remotely aproarching a quality admin panel is either very basic I use angular to build admin cp (there is a lot of ready to use components to build simple CRUD apps) and then I just can use any CRUD API generator for symfony for example. I think that this approach will dominate since it gives you far more abilities to reuse code.
Symfony does essentially the same thing with its Bundles. See section "Configuration" here: http://symfony.com/doc/current/bundles/best_practices.html It says basically that we should have "*the* bundle configuration" (implying there's one of it) under a key that's the alias for the bundle. That automatically precludes multiple differently configured instances of whatever that bundle provides. Symfony appears more professional on the surface, but it makes some of the same architectural mistakes.
My point was more around your choice of phrasing ("singleton configuration"). Laravel's managed to convince most of the user base that the singleton pattern is [totally](https://laravel.com/docs/5.3/facades) [ok](https://www.laravel.com/docs/5.3/helpers), as long as it makes your code look pretty. Since that's so baked into the documentation, it's not surprising that packages start to appear with the same "single instance" mindset.
I was wondering why would PHP developers typically need Docker. The answer was that PHP developers would need nginx, Apache, PHP 5.6 and PHP 7 on the same production server. Thanks for the answer, I just find it hard to identify with such needs, so I wanted to learn more. With the given scenario, now you have twice the technologies to maintain and update when security vulnerabilities show up, and you have a fragmented codebase that can't be as easily reused across projects. It's probably useful for development, but Vagrant already fills that niche (and I'd say naked Virtual Box does it by itself, even).
lol https://github.com/jordanbardsley7/laravel-admin where is the video
This is kinda useless marketing bullshit. If they use any other framework probably results would be the same. Frameworks just reduces costs on development (because of code and infrastructure reuse).
When you have the manpower behind Uber you can dish out a new framework every month if you like
It's a matter of taste. Everyone should try a couple of frameworks and choose the one that works best.
Does this support relationships? How is this different from https://github.com/FrozenNode/Laravel-Administrator
My hammer is not what built my house. I built my house using my hammer. I like working with good tools, and I like to research which ones I choose, but ultimately, it's not the tools that accomplish the task. Codeigniter did not make $25million for Uber. Uber used Codeigniter in the process of making $25million. They could have used any other framework.
&gt; He is a developer who is not afraid to say on stage, in front of hundreds of people, that a previous idea or piece of code of his was stupid. Too bad he doesn't say that about his current ideas or code.
There are not special rules for non-native speakers.
Take a chill pill dude. To reiterate my comment, I was referring to the fact that Laravel heavily promotes global state (singletons), and how by doing so I believe people using the framework don't learn why that is a bad thing, and they end up building components in the same way. As a concrete example, the main reason why the package in this thread cannot easily have multiple instances with different configurations is mostly due to it using `config()` calls throughout. The alternative would have been to inject some `Config` object where needed, which could have solved the problem (or at least made it possible to approach) without requiring the package author to explicitly write the multi-instance code.
That's not why it can't have multiple instances. Laravel's authentication system uses configuration files and you can have N number of authentication guards. Same with database. Same with cache, etc.
&lt;pedantry&gt; It was definitely a pointless and trite criticism (which also incorrectly used both "ironically" and "redundant"), but you're wrong about the OP's comma being acceptable from a grammatical correctness point of view. There is no break in that question, nor are there independent clauses. The clause "who have seriously tried or used Yii Framework" is called a [restrictive clause](http://www.kentlaw.edu/academics/lrw/grinker/LwtaClauses__Restrictive_and_Nonrest.htm), and it serves to identify the "people" in that question. Commas are *never* used to separate restrictive clauses from the things they describe. &lt;/pedantry&gt;
Theprintful.com uses Yii2 from alpha version and we are aiming for 20mil. revenue this year. So yeah. I personally enjoy Laravel 10x more. Anyway, Framework is only like 1% of thw whole business logic, so it doesn't really matter what you use.
That would play you a nasty surprise if you connect to different databases from the same migration tool for whatever reason, and the file for one is taken for the state for the other. I'm curious why you don't want meta information in the database. Are you afraid you might run out of tables?
No I was just curious if somebody has ever taken a different approach, and if they did, which.
Simple, PHP7 support...
Technically, all you need to do is store one value somewhere (current DB version, or last migration that was run). So it seems perfectly feasible to me to have a single file with that value. But it does seem more logical to keep that in the DB. 
Some databases have limitations around migrations (especially if you're dealing with a something sharded/clustered) so migrations might not be controlled by the application.
&gt;&gt;Is there any recent framework working with Composer that is not a PSR0/4 autoloaded framework? &gt;Nope, which is the point. You should see no inherent limitations in any modern framework. Not even micro frameworks like Slim or Silex. I do, and this is about the design choices of the framework, its flexibility and it's ecosystem. &gt;Beyond that, customization through extension / inheritance is a normal part of programming, so doesn't have anything to do with Laravel specifically. I beg to differ, making things configurable with inheritance is an horrible design and experience. It is done this way in Laravel simply because it's simpler and requires less work. But forcing inheritance is not nice. &gt;There's nothing special about Laravel's auto-wiring. It just follows type hints. Many other frameworks use auto-wiring, not just Laravel. I did not imply there was anything special with Laravel auto-wiring, simply that it hints you to make use of it, which is a very questionable choice. Of course you can choose not to use it, but it's a pain in Laravel because your only alternative is plain PHP for which you have no auto-completion and no validation. This is a choice made in Laravel, again, I'm not saying it's wrong, but when you don't want to go that way, it doesn't make it easy for you unlike for example Symfony for which you have the choice between PHP, XML and YAML. &gt;Nothing is stopping you from pulling in Doctrine or even writing raw SQL behind an application-facing abstraction like a repository if you really hate Active Record that much. I don't remember saying I hated Active Record, I said this was what Laravel hints you to use. &gt;Earlier you had mentioned that Laravel hints you to use auto-wiring [...] Laravel gives some examples in its documentation as facades for brevity, but in no way shape or form encourages or forces you to use them. If you don't read the documentation throughly enough to know that, how is that Laravel's fault or problem? Laravel is the first main framework pushing this kind of "Facade" pattern, for the best or the worst. The sheer number of examples given using this pattern and how widespread its usage has been made within the Laravel community is what can push one to use it. Sure at the end of the day it's the developer responsibility to choose to use it or not, but you can't say Laravel didn't encourage it in any way (I'm using the past tense because I got the impression that lately they encouraged it much less than when I started in Laravel 4). &gt;You'd have to explain in greater detail how that could ever be beneficial. That sounds like a pretty serious code smell to me if you have architected your application such that it's dependent on two front controllers, and all of the inherent duplication that will come with it. Either way, that's a massive edge case. It's no code smell, just a convenience for development. If you check Symfony standard edition you have an [app.php](https://github.com/symfony/symfony-standard/blob/master/web/app.php) (the main front-controller) and [app_dev.php](https://github.com/symfony/symfony-standard/blob/master/web/app_dev.php) (for dev purpose only, to be removed in a production app) which basically starts the application in dev mode with debug enabled regardless of what environment or debug mode you configured you application. It's something I've been missing a lot when using Laravel, and honestly is a real pain to introduce in Laravel. And worry not, there is almost no duplication (very little, and it's a case where it's more dangerous and has no value to try to remove it). &gt;I drastically changed my folder structure in Laravel. Didn't have to extend Application at all. Not sure exactly what you're trying to customize, but you shouldn't need to extend Application to do it. How did you do for [those hardcoded values](https://github.com/laravel/framework/blob/5.3/src/Illuminate/Foundation/Application.php#L315) then? &gt;&gt;You have a library and you want to expose a config? You can't. As simple as that you have absolutely no equivalent to the bundle extension system in Symfony. Either your config is simple enough to fit in a few env variables or you copy/paste a nice config template with no validation whatsoever. &gt;Huh? How is this any different from literally any other aspect of PHP programming? Config validation is 100% the responsibility of your library, not the framework. And since we're talking about modern PHP and PSR-4 autoloading here, your library should have absolutely ZERO dependency on a framework. If you're relying on Symfony to validate your config so that your library doesn't blow up if the config is invalid, you're doing it wrong. Ask yourself how you would expect your library to work outside of Symfony. There's your answer. You may have misunderstand what I meant, and in all fairness I didn't really bother explaining either so I apologize for that. When you have a core library, you may then want to have bridges for framework integrations. For example, have a Laravel provider for a Larave integration or have a Bundle for Symfony. In this framework integration, you may register services to the DIC or expose a configuration. [Here's an example of configuration in a Symfony bundle](https://github.com/api-platform/docs/blob/master/core/configuration.md#configuration). Symfony as a framework, makes it easy for your bundles to expose this kind of configuration and say what are the config parameters and what values are allowed, see [here](https://github.com/api-platform/core/blob/master/src/Bridge/Symfony/Bundle/DependencyInjection/Configuration.php) for an example (it corresponds to the config example I gave previously). In Laravel you have absolutely no equivalent so ever, it's #yolo mode. If you want to expose a config, it's a documentation thing (so entirely up to the user) or manual work in your Laravel bridge. If you have 2 or 3 possible optional parameters it's alright, more than that and you cry. &gt;Absolute nonsense. You're blaming Laravel for lazy programming. You can just as easily couple Doctrine to your domain... At least with Doctrine you are using POPO out of the box and the mapping is just a configuration thing. Sure you can decouple, but it's extra work and you have to do configuration in a PHP model class still. But completely agree that it is as easy to couple your domain models to Doctrine if you are lazy and are using `ArrayCollection` or something. I just find it better that it pushes you to use POPO right away. &gt;What is actually the issue here? PHP does a poor job of allowing you to explicitly configure your dependencies? It's called a factory class if you're that worried about it. Again programming 101. The idea that you need some nutter YAML or XML file, or even more nutter things like this, is literally just a more complicated way of doing the simple thing: writing a factory. It also likely means your classes are VERY poorly designed, if you need branching validation of what configuration values are and aren't allowed. Sorry, but I have to say the need for Symfony's dependency tree definitions and configuration validations is a self-made problem. The link you gave is wrong, it's related to parameters configuration when you want to expose a configuration in the library, like I talked above. &gt;It also likely means your classes are VERY poorly designed You either have a very different view or completely misunderstood what I said. If you don't want to rely on auto-wiring and declare your dependencies manually, one thing you can do in Symfony (and you have the choice between YAML, PHP or XML): ```yaml services: dummy_service: class: App\Services\DummyService alias: dummy arguments: - '%app.url%' - '%app.env%' ``` The exact equivalent in Laravel: ```php $this-&gt;app-&gt;singleton( 'dummy_service', function ($app) { $url = config('app.url'); $env = config('app.env'); return new \App\Services\DummyService($url, $env); } ); ``` It has nothing to do with the design of the class, it's just that in the case of PHP, when you'll try to inject `dummy_service`, you won't benefit from the auto-completion, neither from the type checking (i.e. if you are referencing `dummy_service` for something typehinted as `\DatetimeInterface`, you won't have any warning whatsoever. Sure you can find you quite easily, but it's more convenient and has a nicer DX. [1/2]
[2/2] (sorry, Reddit text size limit) &gt;Sorry, but I have to say the need for Symfony's dependency tree definitions and configuration validations is a self-made problem. I don't really get what is the problem you are referring to. &gt;&gt;Another big problem is the lack of high quality packages: there is little well written and well tested, maintained, Laravel libraries &gt;Once again, Laravel is PSR-4 autoloaded. This is your playground. There's really no such thing as (or need for), a Laravel-specific package. MAYBE a thin adapter that gives you a service provider or something out of the box, but that's 5 minutes of work for you if you find you need one. Let me rephrase it: there is too many people pushing for Laravel packages as if Laravel was the center of PHP, whereas you should have (unless it's really a framework specific thing) a PHP library and eventually bridges for frameworks. Too many packages re-inventing the wheel for components. But granted I digress I shouldn't have mentioned that. Any framework community had this problem at some point, and in the end I ditch the shitty Laravel integration to write my own one for the library itself. I'm just always a bit saddened to always have to do it myself, hopefully It's never a big work as, as you said, it's a thin layer. &gt;It's far less opinionated then you think. Or more accurately, it starts you off with some opinions, which you are free to change later on to your liking. I just don't see the point of using Laravel if you are not following those opinions. Laravel for the most part (except some works like done for Eloquent or Blade which are reusable components) is an opinionated version of Symfony components. At its essence, Symfony is just two things: reusable standalone components and FrameworkBundle. The later is what the real Symfony framework is: access to a DIC with different ways of configuring your application and exposing your configuration (which is why I'm always a bit amused at when people give you a weird look when you say that Symfony *is* a micro-framework, if you want to it can get reduced to the size of a single file, people just misunderstand that the Standard Edition is just a full bloated version made to fit most common use case). That's it. Laravel came in, picked some components, added some of its components (like Eloquent), and added an opinion on everything to simplify the file structure, make it more accessible, make more choices for you. I'm not downgrading the work done in Laravel: it brought a lot of things such as making PHP much more popular by having a lower entrance barrier and have an outstanding marketing. It brought auto-wiring to PHP (for the best or the worst, it's a hot topic and I'm not fond of it personally but I find nice to have an alternative), re-introduce a proper Active Record ORM (Propel? Who's using it? Doctrine 1? Not maintained anymore. Again, I'm not super fond of it either, but it a nice alternative to Doctrine and I always find better to give the choice for this kind of thing). Also one focus made in Laravel was to have a very low learning curve and a nice DX. We may disagree on a lot of choices made in Laravel, but it's one major framework that gave a bit of energy to DX focus in other frameworks. Also I must say I appreciate that you take time to give sensible arguments and have a constructed discussion. Most Laravel people I get the chance to talk to are more like completely worshipping Laravel and Taylor and blindly following whatever looks cool in Laravel rather than try to be more open minded and critic. And reddit is not always the best place to have a sensible discussion either.
You can take a look at this: https://github.com/appdeck/rapport - it's very rubbish and I haven't worked on it in ages (it's functional though), but it does what you described.
Irony *(noun)*: The expression of one's meaning by using language that normally signifies the opposite, typically for humorous or emphatic effect. Also, I never said it was grammatically acceptable, nor grammatically correct. I simply said that it is acceptable, and not redundant. Redundancy infers superfluity, which infers a need, of which there is none in the title of this thread. But good job for pointing out things I didn't contest.
It's not in PHP but depending on the amount of text this could be interesting for you: https://github.com/facebookresearch/fastText