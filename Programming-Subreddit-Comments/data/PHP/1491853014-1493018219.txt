Clearly.
Why doesn't he compare it to Ruby? I've always thought of Ruby programmers as having a false sense of superiority because they use the first MVC framework on the market (as if they created it or helped create it themselves). In fact Ruby developers seem like the /r/iamverysmart group for programming.
 $transaction = new Transaction(); $transaction-&gt;store($post); $transaction-&gt;run(); I highly recommend buying a copy of "Clean Code" and learning a little bit more about OOP, separation of concerns etc. You mention IoC, but there are singletons everywhere? 
&gt; Things you can't do as a PHP developer: Build your own React TODO MVC app boilerplate This one killed me 
me too, til i realized it's not true, because your back-end language has nothing to do with React @_@
Can you recommend any resources for reading more on fine grained authorization like that (per object instead of just a generic permission)? So far I've seen most people implement it in the DB query and not in the domain itself. But I'm sure there is a best practice/better way somewhere out there.
Darn ok next favorite is "creating your own memory leaks" then ;)
I can't stop laughing at: $caption = ‚ÄòNode is a remarkably efficient tool of evil‚Äô;
&gt; Things You Can‚Äôt do as a PHP Developer &gt; &gt; Program in JavaScript This is just plain wrong... http://php.net/manual/en/book.v8js.php
The cool factor was not high enough to really count.
Heh, that was pretty good. Plus lots of logos to show _how_ evil it is! 
&gt; Can you recommend any resources for reading more on fine grained authorization like that (per object instead of just a generic permission)? Wish I could. Fine-grained authorization seems to be domain-specific. In something like a CMS, though, it can be pretty straightforward: "does the author_id match the currently-signed-in user id?" and/or "does the current user have a role that allows this specific functionality?" From what I've seen, it's often a method on the service, or on the domain object by itself, something along the lines of `isOwnedBy(User $user)` or `isReadableBy(int $user_id)`. &gt; So far I've seen most people implement it in the DB query and not in the domain itself. Implementing it in the DB query is perfectly reasonable, and is probably going to be the result of having set up some domain criteria before getting DB results. It can be pretty efficient to just not-return records that don't match a JOIN somehow. However, some more complex stuff like hierarchical RBACs might need you to loop over the results and check each record, or each entity if they've been mapped over the to the domain already (or only map allowed records to domain entities). It really does depend on the specifics of the domain. I know that's not a lot of help. :-(
No one can program in javascript..you can just try :)
That is possible too actually. Not in the sense of dangling pointers, but collecting too much stuff into an array and not clearing it, for example. You also have to be careful of what you maintain references to.
&gt; Lynda.com eh? 
I may have just started a war but I couldn't resist ;) https://www.reddit.com/r/node/comments/64m5ce/why_node_is_better_than_php/
I would say the same in the opposite direction. I use ES6 and full stack JS because it's not PHP. Moral: Different strokes for different folks. 
Hell yes! and blame the server version just in case.
&gt; Things You Can‚Äôt do as a PHP Developer &gt; &gt; - Get consistent, easy to use function parameter ordering for standard lib functions :(
 3. Write code that your IDE will understand This would prevent a lot of PHP devs from using Dependency Injection, which is much harder for IDEs/static analysis tools to reason about. Languages with generic type parameters can overcome that deficit, but PHP ain't one of them...
You should reread them. There should be no singleton at all. Your are abusing extension. Everything seems to extend component. FooController extends Controller extends Component ... Composition over inheritance... please
I think it's great that people continue to contribute to the community. But what advantages does your framework hold over others?
Thanks for the post, and thanks for your work on the library. Whilst I did try your library first and I was able to get it up and running. You haven't directly answered the two issues I brought up. Here they are, incase you missed them: https://github.com/arnaud-lb/php-rdkafka/issues/101 https://github.com/arnaud-lb/php-rdkafka/issues/42 For your information. I have better performance and persistent connections with https://github.com/weiboad/kafka-php. Which I can connect either to zookeeper or broker.
lol, the last graphic is brutal. monsanto, blackwater, enron and timewarnercable... totally the corporations you want to associate yourself with, lol. 
[We're gonna build a framework...'](https://www.youtube.com/watch?v=Wm2h0cbvsw8)
Markdown is weird sometimes. You need to escape the 3. `\3`
Does Slack RTM needs a public URL or something? I tried this with my local PHP 7.1 (from homebrew) and it didn't do anything for me :( &lt;?php require 'vendor/autoload.php'; use Mpociot\BotMan\BotManFactory; use React\EventLoop\Factory; $loop = Factory::create(); $botman = BotManFactory::createForRTM([ 'slack_token' =&gt; 'YOUR-SLACK-BOT-TOKEN' ], $loop); $botman-&gt;hears('keyword', function($bot) { $bot-&gt;reply('I heard you! :)'); }); $botman-&gt;hears('convo', function($bot) { $bot-&gt;startConversation(new ExampleConversation()); }); $loop-&gt;run();
If he was defending himself (which, by the way, he doesn't need to do), then the choice to make a single post/tweet without any context of defending Laravel is a poor one. I feel the argument of trying to defend one's self doesn't help when the optics of just the lone tweet make it look like Taylor is "firing shots" against other frameworks. The snarky comment he made would also turn me off from using Laravel in any of my projects, but that is just my opinion.
I think you're mixing DI with some harebrained approaches to writing DI "containers" that breaks IDEs. Dependency injection itself, as in the act of passing objects as constructor/method parameters, has no issue being understood by IDEs.
Yes, but pretty much every DI container implementation does this. Obviously if you write your own from scratch with your IDE in mind, it's going to be fine.
&gt; Yes, but pretty much every DI container implementation does this. That's how things roll. Someone has a bad idea and then everyone copies it. DI containers are basically this: $container-&gt;call('methodName'); When you actually need this: $container-&gt;methodName();
Thanks for that, didn't knew it existed
While it does require the extra step of installing the ide-helper package (one composer command and an Artisan command to generate mappings), I've always found Laravel to be just as explorable by IDE as Symfony. In PHPStorm I've not found anything that's easier to navigate in Symfony projects than it is in Laravel.
What do you mean by "it's usually custom code being added"? This just seems like a really weird problem. I've worked with very large teams, including ones split across different organisations, on large Laravel projects where facades are specifically ruled out for use in the coding guidelines. Just like all the contributing developers are expected to conform to all of the other guidelines, they're expected to follow that one too and I have never encountered a problem that persisted beyond a single code review with a comment asking them to refactor to injection and a link to the pertinent section of the guide. On some of those projects the facades configuration was simply commented out so they couldn't be used in the first place. They're just a tiny bit of syntactic sugar that is entirely optional. In my experience it has never presented any more of a problem than doing the exact same thing with Symfony projects where new developers need to be pointed to the guidelines for that project because they're not familiar with the project's expectations or style.
I'm not being an asshole your statement is pointless if TypeScript isn't the default "language" used. You can literally say anything above and then say but change the default and use something else.
Why wouldn't you be able to do this with Laravel? There's nothing that inherently makes application code more tightly coupled to Laravel than application code written for Symfony. I've certainly seen Laravel code that would need to be heavily refactored to use it elsewhere, but I've seen the same thing in many Symfony projects. All of the projects I've worked on from scratch in both frameworks have kept a core of plain-PHP application logic, because that's just good practice, whether you use Laravel or Symfony makes no difference. If you're not designing your application logic to be portable that's not the fault of the framework. 
I'm excited too, especially since a lot of the PHP stuff we have been doing are just combining together some simple components. Excited how this will all be tied together and the potential libraries people will write that will easily integrate (similar to providers in Silex, but hopefully less work to configure).
Apparently, yes (Drupal): https://builtwith.com/tesla.com
I was specifically addressing your statement that it was "just" some custom packages on top of those components, when it provides far more than that. Your second paragraph is exactly what I'm getting at, the original poster was equating a bunch of packages quickly bound together to the likes of Laravel or Symfony, when there is significantly more to them than that, as you rightly point out. You were replying to someone who was pointing out that if you just pull in a load of packages and put them together your glue code isn't going to provide anywhere near what a full framework provides. 
Lots of valid points here, notably that php is dead (gauging by available jobs, not coolness)
Rewriting your projects in another language is a pretty great way to learn another language. 
The safest method is to rewrite everything as a Rust app that outputs Javascript.
I'm a freshman who recently got an internship, and I'll be working with Symfony. I've been watching tutorials and building some small projects to get used to everything (I haven't used php before, although it doesn't seem too different to what I've done in the past). Does anyone have any tips on how to prepare for working on a more enterprise-scale project?
I'm surprised by how much people go on about this. It's never bothered me in the slightest.
thanks! 
It always bothers me for a good 1/5 of a second as my ide tells me the order. However it's one of the last valid criticisms of the language so obviously it gets a lot of attention. 
this is a well written misleading article. i congratulate you in your up votes in your social media platform. 
this is that guy who gets off talking shit about php, don't give him any attention. (check comment history)
Probably he was looking to post this very true technical article in that full of technical discussions /r/lolphp
Testing eloquent just isn't actually hard... you've probably heard it's hard, but the same person that told you likely never tested it either. Whether it's fine for small/big projects is a conversation you have within your company about whether it satisfies your expected metrics. In my experience the database layer is ALWAYS the slowest point of any sufficiently complex application. So when you introduce caching, framework use is almost completely negated.
Jeeze... All those flavors and you chose salty.
you don't need to learn a new language. If you are contributing to the base code, then yes. Not everyone who uses Symfony or Laravel rewrite their base code either. Usually you choose not to use that component until the main devs fix it anyway. 
It's funny cuz it's so true. I've mastered this under appreciated art. 
We all have our crosses to bear :'(
Life is just so much easier when you let go of the idea that there is any "one true way" or perfect-for-everything stack. I've dabbled with node on some pet projects. Love Python/Flask for building APIs. WordPress when it fits the client's needs and budget. Just use the thing that makes the most sense for the job and delivers the most value to your client. It's why our clients keep coming back and/or sending referral biz.
It's not possible to have a constructive conversation with you on this topic. My point to the original commenter was to demonstrate that yes, you can get type hints, interfaces, and clean code in a Node.js app using TypeScript, and it takes little effort to set up. Your tone is quite brash, which is distracting and hurts the credibility of anything that you say. Your counter-point about default languages invalidating my stated fact is subjective and contains some pretty impressive mental gymnastics. Any further discussion with you would be a wasted effort.
Ha ha, nice pic `:==D` 
I immediately thought of [`in_array`](https://secure.php.net/manual/en/function.in-array.php) but instead saw the code on that post and saw it's a little bit different. Any love for [`array_walk()`](https://secure.php.net/manual/en/function.array-walk.php) or [`array_map`](https://secure.php.net/manual/en/function.array-map.php)?
and then, php process will just be killed if memory usage exceed the limit (assuming it is not a daemon or long running process)
I do use both of them but for this kind of work stripos() is best. 
Yah especially when it needs only 4gb of ram to treeshake angular2
thanks zorndyke I'll try as you said.
Stripos is not utf8 safe so this would fail if the name had multibyte characters in it. Also.. array_search is worth looking at. 
I never know there is array_search function available for this type of work. Thanks for this function I'll take a look at it and will use this function for next time.
As you are consuming their API, one would think you'd read the documentation or terms for usage? According to their [Developer Documentation](https://www.instagram.com/developer/limits/) the limit is 5,000 calls per hour (specific endpoints have other rates as stated by the documentation). Additionally, the [Platform Policy](https://www.instagram.com/about/legal/terms/api/) also states the following (in C.2): &gt; Instagram may rate limit or block apps that make a large number of calls to the API that are not primarily in response to direct user actions.
That was cute, but there were quite some things that I hardly would call a "framework". Lot's of libraries, though. I mean lodash? Undescore? Carbon? Those are not frameworks...
Could very well be, but how is anyone supposed to keep track of that? Edit: Why the downvotes? It's an honest question. Not everyone who reads the tweet is even on Reddit, so how would you expect everyone to know the context of the tweet if the Reddit thread is not even mentioned anywhere?
Tidy üëçüèª
Yup. And well, for frameworks that have the resources to reinvent a flexible enough configuration language, with expressions and everything, and the entire ecosystem of popular IDE plugins required for it all to work, it's fair game, I guess. Not sure Symfony is quite there yet, or will ever be, but in theory, if you have sufficient resources you can do it. But for everyone else, I feel the best container configuration language remains the language you're writing the rest of the application in (hence why I use plain PHP factories, with type hints).
You can login to demo team using following credentials: Team Name: Opus Email: admin@admin.com Password: admin 
I'm seeing a considerable difference between local and remote mysql connection. If I run a script local to the mysql server it can process 10k records in seconds. If I use a remote web server to connect to the mysql server to allow for load balancing, even with name resolution disabled, it takes multiple minutes. Is there something I'm missing or some other optimization that is suggested?
I was thinking exactly same thing. `etc/` should become `config/`, it's more semantic (for human not computers). `web/` might become `public/` but never `www/`.
&gt; As you are consuming their API, one would think you'd read the documentation or terms for usage? It's a REST API, it should't need documentation. ^^/s
Your comment inspired me to look at his post history... oh man, it gets worse. His posts are spread all over the place like this.
You can use session for this. Check out this example http://php.net/manual/en/reserved.variables.session.php#116843 Post on /r/PHPhelp next time.
You should read up on [session handling](http://php.net/manual/en/book.session.php) in the PHP docs, starting with [the basics](http://php.net/manual/en/session.examples.basic.php). Rather than passing around the username via request parameters, you would instead store it as a session variable after successfully authenticating the user against the username &amp; password they provided. That way, in other scripts you can check for the existence of this session variable and treat the user as logged in if it's set, e.g. session_start(); if (isset($_SESSION['username'])) { echo sprintf('Welcome back %s!', $_SESSION['username']); }
Anyone has idea why PHP local server (with xdebug) opens a shittone of ports? pics: http://i.imgur.com/zlQXzYC.png
[removed]
Great job, guys. I wish you all success.
Oddly enough, Mr Jones has actually designed such a structure: https://github.com/php-pds/skeleton
Anyone can recommand a good single-file router class ?
no doubt. anyone upvoting me all over reddit would become my Friend as well, with capital F. 
yes with capital F
&gt; the concept of storing configuration files in /etc is as old as unix/linux itself, Sure, no argument there. But we're not talking about an operating system, we're talking about a PHP package -- and among all PHP packages represented on Packagist, `config/` is used *much* more frequently than `etc/`.
I don‚Äôt think you need to write your container configuration in PHP, you just need to provide a public facade for it with type information, for example: https://github.com/mlebkowski/Bakery/blob/master/src/Nassau/Silex/Application.php So you can still define your services in BazingaCode‚Ñ¢, but get them using `getFoo` helper methods instead of a generic `get('foo')`.
&gt; they use the first MVC framework on the market (as if they created it or helped create it themselves) Lol I'm not sure if its a bad troll effort or the OP is actually an idiot? * MVC is not (and can not be) a framework, its a architectural pattern (also referred to as a design pattern) * It was first conceived back in the 70s, Ruby wasn't even invented until 25 years after this fact
local server
some people treat version numbers arbitrarily... I'd hope this isn't the case, but we'll have to await response. For reference: (major: new release) . (minor: feature addition) . (hotfix) This is a pretty common method for version numbering. I'd recommend adopting a similar method and keep a change log denoting the differences (haven't made the effort to see if this has been done or not, though).
&gt; Ruby programmers as having a false sense of superiority [RoR smugness? Never!](https://www.youtube.com/user/GreggPollack/search?query=ruby) 
I use Wordpress as a framework. Sue me.
Also the text within the main body of the article
I does not matter, config of a single package is very different from config of a custom app, the config folder itself does not even exists in Symfony, it's just generated at install time and fully configurable, it's not harcoded either, and never wrote into any composer package nor github repositories (except maybe potentially in some rare applications delivered as a complete distribution, and again it's not hardcoded and can be changed locally).
Indeed.
Are you seriously quoting yourself from https://www.reddit.com/r/PHP/comments/64ksoy/symfony_4_directory_structure_incremental_changes/dg2zcsw/ ? It really does not matter what is the name of the config folder, it's an app config folder you can change in the end. And I don't think that a common pattern for very different frameworks is a good idea, at all. It's not a bad one either, it's just useless. Most people will use a single framework, maybe two at most for a few month or years, and absolutely don't care about a global application-level config folder name that their sysadmin could even force them to change for something that is really different in the end.
I don't think it's useless, because "config" makes a lot more semantic sense than "etc". Sure, "etc" is consistent with Linux, but that's less important compared to better semantic meaning in my opinion.
well I'll be damned
The sad part is, lots of Node devs will take it seriously.
Yeah, me either. The people complaining are clearly not using an IDE, or even any type of intelligent editor. The only time I run into trouble is if I'm in discussion or trying to help someone. I'll have to grab the manual page to double check.
Update everything to use prepared statements. Filtering user input is messy and error prone. 
Not sure about other things but this is true at least for me &gt;PHP devs can‚Äôt find jobs to support their families I have been hunting for a job for last 4 months, almost all of the calls I have received wanted to know if I have worked on node.js or Angular or React. No one was interested in knowing if I can code. 
Wow, i have not. This is amazing. Thank you! 
Most likely you should have an access log, which will allow you to look through all server requests. It won't show data being sent via POST, so that won't help, but any GET requests with the query parameters you would be able to see. Run "grep" on that for "SELECT", "INSERT", "UPDATE", "DELETE", or any other characters and you would see attempts. 
Nice, but I have the filters as JSON already, so I'll need something to convert it to GraphQL, to use this library. ^^/s I wonder if people notice how similar to JSON is GraphQL already. Conceptually, GraphQL is a nice idea, but it doesn't need its own parser - we have JSON.
You are not correct. I created a higher order function. The `studentData` one is executed once, the data is parsed once, and the resulting function is same as the method body in the ‚ÄûOO‚Äù example. Given a HoF: `f: array ‚Ü£ (g: needle ‚Ü£ boolean)`, `f` is doing the work of the constructor, the closure mechanism encapsulates the state, and `g` function is the public method.
For sure. I would be much worse at my job without PHPStorm.
Not quite what you were asking for .... but there was a proxy like tool called GreenSQL - but it seems to have renamed and not really available now. It was apparently capable of detecting suspicious queries (either through heuristics or whitelisting) to protect the database. You probably want something like mod_security. ( https://modsecurity.org/ )
Follow my train of thought for a second. One of the largest critiques of Phalcon is that it ties you in to a C extension. You can't deploy to shared hosts, you have a dependency on an extension that's often not available for the latest PHP release, let alone betas, and you can't seamlessly debug your code with the code of the framework. Yet Phalcon is written in a C dialect called Zephir, which looks similar to PHP. And they can apparently compile IDE stubs in PHP out of Zephir code. Why not go the extra step and generate a PHP version of the framework and make the extension an optional feature for extra performance? This will make many more users relax and test the waters, knowing that if they really need the extra performance, they can get it, but also if the extension is unavailable, abandoned or lagging behind the binaries, there's always the PHP version to rely on.
Why not just use one of the fully-fledged PHP-GraphQL parsers [already](https://github.com/webonyx/graphql-php) [built](https://github.com/Youshido/GraphQL)?
Drupal 8 can serve as a headless CMS. Combine that with CDN &amp; static caching either via varnish / ngnix microcache and elastic servers it maybe the fast migration path. Especially with the limited feature set and Drupal migration modules.
&gt; Creating a PHP version of Phalcon sounds interesting, it will pretty much defeats the main objective of the framework which is performance. It doesn't defeat it, you can still use the extension. It's about reaching a wider audience. If I want my app to run on a stock PHP install, which is basically half the Internet of mom-and-pop business sites on shared servers, I can't write applications in Phalcon. This means I might not use Phalcon at all, and seek other way to get faster, in the situations I need to be faster. But if I have access to a PHP version and a binary extension version, I can write everything in Phalcon and deploy accordingly. &gt; There have been numerous projects over the years that have tried to create this PHP version of Phalcon but they all fell behind. Hence why my point wasn't to port manually, but convert Zephir to PHP. Then it can't fall behind. In fact, it'll possibly be the *first working version of Phalcon* for every new PHP alpha/beta release (because for PHP, extension API breaks are worse than userland breaks). &gt; Doing so will require quite a lot of work and resources and frankly the project can benefit from not going down the PHP/file route but fix existing issues and offer more functionality with Zephir. That's OK, I mean maybe Phalcon doesn't want to foster a rich ecosystem for itself, maybe it's content with over-specializing for the tight niche it's targeting. As long as Phalcon's authors **realize that's their goal, and not popularity**, that's OK. &gt; Let's face it. The shared host argument is a valid one but in reality although one can purchase a $5 shared hosting they can also purchase a $5 VM from Google Cloud, Amazon, DigitalOcean, Rackspace etc. where one has full root access and can install anything they want. My company works on projects ranging from small to large. Let me tell you, this "we can move you to a virtual private server and have root" pitch, to a non-technical user, you might as well speak Greek to them. They won't move. They also don't care that Phalcon is a bit faster if you "have root", because PHP is fast enough to those people. So the result is that most PHP hosts are lost to Phalcon, no matter how trivial the solution may seem to you and me as developers. Once again, Phalcon may care about this, or they may not care about this, but at least they should be aware. Say when I develop a long-term asset for my business, say a Content Management System, or an E-Commerce Shop or whatever reusable module you can think of, I can't afford to make a Phalcon version *and a non-Phalcon* version, so I can cover all my customers. So I'll just make the non-Phalcon version out of necessity. And the "Phalcon crashes on the latest PHP" problem is very real. How long did it take for Phalcon to be stable on PHP 7.0? Almost a full year after the first stable beta of PHP 7.0 by my recollection. That's not acceptable. If I had a working PHP version I could've started working on PHP 7 enhancements of my codebase, using the PHP Phalcon version for development, and deploy to production when the binary extension is stable. In fact, what happened is our company dropped our last Phalcon projects while migrating to PHP 7.0 for that reason: we can't wait forever, and we can't risk being left behind. Phalcon is a **big risk** as it is right now. Should Phalcon be abandoned one day, we can't afford to maintain the Phalcon code in Zephir, and to maintain the Zephir language itself. But we can maintain a PHP version if the shit hits the fan. This would give us security.
&gt; than look it up This is exactly my point, languages with consistent APIs you can pretty much guess without ever looking on how it expects params and how the functions are named. If you think this..... http://php.net/manual/en/ref.strings.php is a sane and sustainable way to name functions and pass params then you really are missing out when it comes to a well designed language 
Functional style is fine, but you dropped strong typing for no reason and have to do manual type checks and throw unwarranted exceptions. The use of Yoda condition is also questionable and does not contribute to readability here.
&gt; That really doesn't sound like the kind of project where many benefits from Phalcon are going to be seen. If the client is in charge of the infrastructure for a project you surely have bigger issues than trying to squeeze out performance by using a C extension for the framework. I'm trying to convey to you that we're not talking about a single client here. Let's say my company is offering a Content Management System - that's our business. We license it to users, and we develop plugins for it according to customer needs, implement themes, install and configure and train users to use it. I have different types of customers. - Type A: Some need scale, performance, they can pay us, or someone else, to maintain a dedicated server for them, and they would benefit from us using Phalcon. *We offer our Content Management System to these people.* - Type B: Some are small businesses or private citizens with existing sites that need an overhaul, an existing hosting, they have their domain wired there, credit card configured on the account, all their email accounts are there, their email clients are configured for their email, they like the automatic hosting management and software updates, and they *won't move*, and frankly we would be doing very bad favor to these customers if we'd force them to move to a VPS or a dedicated server. *But we do also offer our Content Management System to these people.* Now. Here's the thing. We have one Content Management System. We can't afford to develop it *twice*, but we need to target *both type A and type B* users. Type A users would benefit from Phalcon's performance, we would use the extension there and be fast. But can we make our Content Management System depend on Phalcon? **No.** Because then we can't sell to customers *type B*, as there's no *PHP version of the framework*. So in the end we don't use Phalcon at all. I'm not contributing to the Phalcon ecosystem. Not filing bugs, not learning Zephir, not sending patches, nor popularizing Phalcon, not writing and open-sourcing Phalcon components. I can't. Because I have two types of customers, and I can't give up a good chunk of my revenue For The Cause. Am I managing to describe the issue more clearly now? &gt; Phalcon certainly has its place, but spending considerable development resources on trying to appeal to a larger market that is already catered for, rather than focusing on what it does best would just be a waste. I'll tell you something, which I feel even Phalcon's authors don't realize I think. Phalcon isn't that important as Zephir. Zephir can be a "killer app" that can get wildly more popular than Phalcon itself. There can be an entire ecosystem around applications directly written in Zephir. Simple pitch: *Write your app once in Zephir! Target any PHP host, but also compile your entire app to a C extension for containers, VPS and dedicated servers!* Obviously for this to work, Zephir should be able to export to PHP, and the marketing should focus on Zephir, not Phalcon as much. Alas. I don't feel the Phalcon authors see Zephir's potential. Handled properly Zephir might even overtake PHP entirely one day and become a standalone product. But that's not Phalcon's vision I guess. 
If that's the case, why don't you build the transformer in PHP and boycott the GraphQL syntax? For the rest of us, it gives us a convenient syntax for tools like GraphiQL. I've also taken a liking to the schema syntax. I originally wrote my server in pure JS, but having a schema gives me a quick reference point to know what the data structures look like at a glance. I can also hand that schema off to someone else to implement. None of this is a problem because the GraphQL and GraphQL Schemas can be precompiled, so there's no performance cost, just a nice succinct syntax. Which, by the way, has excellent support in PhpStorm.
Wordpress ;-) Just put a regexp on the title that matches `pwned by`. ... If you're on Apache have a look into `mod_security`.
Like others have said, use PDO, however, also check out this description of caveats surrounding PDO: http://stackoverflow.com/questions/134099/are-pdo-prepared-statements-sufficient-to-prevent-sql-injection/12202218#12202218 
More context? When we say remote mysql, we actually mean a mysql instance available within the local network. A good example would be a dedicated mysql instance, connected from one or more application servers via a private IP address. Passing over the Internet can add massive network latency. Also, a connection taking some time to build sometimes mean the mysql cache (innodb) was not ready. See if the settings are correct. Persona DB site has a nice tool for that.
I doubt it's xdebug. There's often one port and that's it for xdebug. Probably a running `composer update` or any such update checking?
I think https://github.com/dannyvankooten/AltoRouter suits (haven't used it myself). Not PSR-7. May I ask why, though? fast-route, Aura, league are pretty good routers with really nice set of features. They aren't single-file routers, but not all files are loaded for every requests (exceptions for example). fast-route is really fast, and the router is almost never a bottleneck. I would stick with a modern PSR-7 compatible router. 
This is just circle jerking that avoids mentioning the very real problems with PHP.
Yep, was supposed to be addressed to /u/emsai 
One thing is you change some API and end up needing to go back and change rules again. Given not so many are using Apache now anyway, probably better ways to do it.
You are correct, it's a dedicated mysql instance on the local network. If I take a CLI script and run it on the mysql instance with a local connection it is crazy-crazy fast. Exact same script on a separate machine connecting over the local network to the mysql instance is magnitudes slower. I get there would be a little latency just from the connection, but a 10s task on one machine shouldn't translate to a 20 minute task on another. Long term I want to tunnel these machines together for security purposes but that is going to just add even more latency, which at this point is not even remotely feasible. There has to be something I'm missing.
I realize that. After working with Drupal 7 for the last year, I'm definitely not a fan, but realize 8 is a fairly significant rewrite. Aside from migration efficiency, why would you recommend Drupal 8 over another CMS?
You're splitting hairs here. A framework that uses the MVC pattern CAN and IS called an MVC framework. To suggest that it cannot is just silly.
https://github.com/PHPIDS/PHPIDS
you're right.. i read the code wrong and missed that you were returning a function. have an upvote for my stupidity.
You could add methods for adding/removing student names from the stored array, which wouldn't violate SRP imo since the class is called studentData, and appears to be acting like some kind of container/collection, which the presence of the contains() method also supports. That would however be deviating a lot from the intent of this post's title.
1) Needless hate on OP 2) Needless hate on /r/php 3) Pointing out something stupid, OP already said they needed prepared statements Good luck with that holier than thou attitude in the workplace.
I'm developing my own micro-framework for learning purpose and I wanted to implement a simple routing system that doesn't need +5 classes files to work. But thanks, I will look further into the others one you mentioned (:
Little late to the discussion, but you could use something like mod_security to scan requests, if your server supports it. Also, you can use filter_var() to quickly sanitize input data.
second order sqli?
Laravel
What point are you trying to make? Every comment here talked about using PDO with prepared statements, which your example does not. What was the point of your example?
On [Smoothcomp](https://smoothcomp.com) we save the team/fighter on either the left or right seat of a match. Two different properties. Then we report the winner as "left" or "right". I don't really recommend having two properties like that. It has forced us to duplicate a lot of code (write code for left seat, duplicate for right seat). Your suggestion seems smarter, to have a sort order within the match. But I do recommend you to have matches as their own object. Something like these tables perhaps: teams, brackets, matches, match_team (match_id, team_id, sort_order). Another suggestion is to make seats their own object: matches have seats, each seat have at most one team (maybe less if it's a [BYE](https://en.wikipedia.org/wiki/Bye_\(sports\)) or not seeded yet).
[Here's the schema I use](https://github.com/dxprog/anime-bracket/blob/master/database.sql#L220). Short breakdown: You have brackets, entrants, and rounds. Bracket is information about the bracket as a whole (name, date, whatever). Entrants are info about the individual entrants (name, city, seed in bracket, whatever). Rounds is each individual match up, and where everything comes together. Each round has the following properties: entrant1 ID, entrant2 ID, the tier/round, and the winner entrant ID. "Tier/round" is how deep into the bracket you are (ex. semi-finals, finals, etc). This is the basic info you need to display back your bracket results. For example, [I display mine as a seeded bracket with multiple groups](https://animebracket.com/results/-r-leagueoflegends-s-best-champion-contest-1/?group=full) (group, of course, being an extra field I added). That's a whole bunch of stuff, but hopefully something in there is useful. Good luck :)
Thanks for the comments. I does look like I have missed out the limit part of the docs. After reading the links you guys have shared, I have found out what I need. Thanks for you help.
This isn't a PHP question, or I would tell you to ask in /r/PHPhelp. Maybe try /r/gamedev, but this definitely is not the right sub.
Well, for one you might be dealing with a legacy system as I am (PHP 5.3). While I would love to upgrade it, the only option I have is to develop new microservices, while unfortunately keeping the old monolith (and hopefully deprecate it fully at some point). Also, regardless of PHP version, all of the implementations I evaluated are using strongly-typed GraphQL entities (objects for Fields, etc.), including the one you linked. This is highly unpractical if you're dealing with JSON exclusively as is the case with several interconnected microservices. As a final-destination, GraphQL is not something I'm looking at to support it fully. Endpoints should be built with GraphQL in mind from the ground up, which is just not the case with almost any API I'm dealing with. We're consuming a lot of third party APIs, and generally just need to augment this data (add fields, filter fields by use). I could have used CSV to set which keys to keep, but that would require me implement some notation to support filtering nested objects in JSON, or I could use JSON directly instead of GraphQL, but GraphQL fields were closer to what I needed in terms of syntax/notation. JSON is redundantly verbose for this, that's why it's possible to convert a limited subset of GraphQL to JSON. To be honest, what I'd like to see down the line is something interoperable with what was already done, while GraphQL aims to replace it. As an idea, I am interested in using a reverse-proxy for JSON apis, where I can add [jq](https://stedolan.github.io/jq/) filtering on top of them. There are many services that we run in the back-end that are completely external and will never implement GraphQL in any form, ie.: [shields](https://shields.io/), [imaginary](https://github.com/h2non/imaginary), [errbit](https://github.com/errbit/errbit), docker registry, docker engine, elasticsearch, and probablly many others which I realized I don't need to link at some point ;) Thanks for the question!
It's only because I really do not understand your own agitation, I try to understand very hard why it does matter to you. I don't see any point in reuniting the whole PHP community, PHP is a language, not a philosophy, and it contains a seriously huge lot of very different things that don't all share a common view or purpose.
As a point of curiosity, how much verbose is your filter in JSON? The underlying JSON that's being created is: { "name": true, "id": true, "value": { "name": true, "id": true } } In terms of GraphQL this is a bit verbose. Restructuring can bring this down a bit: [ "name", "id", {"value": ["name", "id"]} ] But it feels hacky with the `[]`/`{}`. GraphQL is better, but writing (or using) a complete AST parser for it is just bonkers, where you can literally do a conversion to JSON with some glue. I realize it's not elegant, and by all means you should use JSON directly if you want. We're in agreement, GraphQL is a nice idea - and it's not the parser I'm really bothered about, it's the structures it needs to operate. JSON is the rule of the jungle and whatever query language needs to work with it. I don't have some strongly typed source without doing pointless conversions just to spit out a reduced JSON with a GraphQL library. Sounds like a hell of a thing to support once you write it.
Oh well, I thought it would slow down a little bit the load time. Thanks, I learned something today :)
Laravel is very much a mix front controller and ADR
You're missing the point of GraphQL a bit there. As ideally a GraphQL API would be built from the ground up to support GraphQL syntax, it can progressively build this data out based on what you request. For example, you might want just an `{ id name }` which may be a simple lookup in the back, or you might want `{ id name friends }`, which might combine data from two sources (a SQL database for id/name, and neo4j to retrieve a friend list). Basically, GraphQL should be implemented as a query language, not as a transformation/filtering one, because that's where it shines. That being said, I agree with you, if you're dealing with native data structures, GraphQL is useless because you'd have to convert them to GraphQL-typed ones first, before you can do any processing. That doesn't mean that the syntax is useless however, and if you want to do filtering on native data structures, you can still implement a subset or a larger portion of the GraphQL spec, as I did here.
The only valuable quote from this thread for me: &gt; PHP may not be saner than Python by default, but a good developer knows how to stay within boundaries. 
Nice! :) But for me run all the tests is overkill when doing TTD. For that I'm using PHPStorm FileWatcher which basically does the same and more :)
&gt; It confuses people, as they tend to misunderstand whether they should typehint for Translator or TranslatorInterface It confuses newbies, once. Then they are slapped during a code review and they are enlightened. &gt; public function __construct(TranslatorInterface $translator) &gt; This constructor definition is saying: ‚ÄúI need a translator interface to operate‚Äù This constructor says ‚ÄûI need an object instance implementing the `TranslatorInterface` contract‚Äù. No more, no less. The rest is how a misguided developer may understand this differently. &gt; Default implementations The special thing about the `Translator` implementation is that it comes with the vendor, so it‚Äôs‚Ä¶ you know‚Ä¶ The default. If it‚Äôs the only implementation provided, there isn‚Äôt always an incentive to give it a descriptive name. Am I understanding correctly, that if the default translator (i.e. *the* `Translator`) just provides translations from a static catalogue it should be named `ArrayTranslator`? Can‚Äôt we make the same argument then? What makes it so special that it grabs the generic `Array` prefix? Aren‚Äôt all implementations allowed to use an array? &gt; Don‚Äôt be lazy, think really hard about what it does It translates. And there are no other implementations in it‚Äôs namespace / vendor / lib, hence no need to distinguish it from others. If I would make a class that translates, I‚Äôd name it `Translator`. I‚Äôm on the edge with this topic. I tried the no suffix approach but it didn‚Äôt stick. I think this will always be a matter of preference and code style, since the arguments are mostly subjective. For example, the author claims that class header should resemble a sentence (`Class Product implements CanCastToJson‚Ä¶`). An english one for that. Switch to AppleScript then, or cucumber. There are too many cases where your code doesn‚Äôt remotely reminds a sentence, I don‚Äôt see why anyone should treat this any different. I partially agree with the renaming argument though‚Ä¶ You make a `Translator` and expect that, without caring if it‚Äôs an interface or an implementation. Converting a class to an interface would be a breaking change anyway, so I don‚Äôt see much gain from this. &gt; If your business has only One True Way to calculate prices This would not matter much, since your code probably has multiple implementation either ways ‚Äî in tests.
Because his only goal on /r/php is get people to go to his blog and sell his book. He has no interest in anything else.
No, I didn't delete any reply dear
Because he has a point. Semantics matter. `/etc` is a relict of past days where this directory would literally contain everything that did not fit in the other root directories. "Et cetera" has very poor semantics on what the directory should contain. It might be obvious to some that this directory contains the config, but I know for a fact that `config` is even clearer in a Symfony app context. Also if I read the original post and @pmjones reactions, I cannot find anything remotely suggesting agitation. Your comments on the other hand...
&gt; your own agitation That's a nice attempt at projection; what part of "might be nice" sounded like agitation to you? ;-) &gt; it contains a seriously huge lot of very different things that don't all share a common view or purpose. Of course. But on *this* topic, there seems to be pretty wide agreement: `config/` for example is 10x more common than `etc/`. If someone wants to be different merely for the sake of being different, cool; but if you are interested in common standards, as Symfony appears to be by its adoption of various PSRs (some of which I was the lead on) then perhaps adopting this common standard would also make sense. I'll let you have the last word on this, if you want it.
&gt; second order sqli? Not exactly sure what is being asked here but PDO allows you to create and execute raw sql strings directly which is where injection can be a problem. PDO does not force you to use prepared statements. Second order injection is an interesting topic. But I don't think it is relevant here.
With challonge.com you can embed the bracket into your website. Challonge has an API, but also comes with a ton of quirks you need to work around, e.g. no team signups. They only operate in "participants".
&gt;If an interface only starts to describe behaviour, then we get dangerously close to ducktyping in my opinion. Not necessarily. We get close to functional programming by taking the interface segregation principle seriously. Though one should always think about how much segregation is really necessary, because PHP has no way of combining typehints (i.e. saying that a parameter needs to implement multiple interfaces), so if you create an interface for each and every method you either have to create dozens of additional interfaces that again inherit from those single method interfaces to combine them or your code will indeed be cluttered with `instanceof` usages, i.e. ducktyping. Though ducktyping isn't inherently bad either, that's definitely not the point of interfaces. Btw. I do agree that naming interfaces is really a matter of preference. I like my interfaces with an I prefix (I really like the C# style conventions in general) and I don't consider it harmful, even if it might work without them. I just like how it's immediately clear whether the class at hand inherits from another class or just implements an interface (granted, in PHP that's distinguished by the `implements`/`extends` keyword anyway). And while I don't use that style myself, I can see the value in naming interfaces to form sentences, especially with the I prefix (e.g. `ICanDoXY`).
How about this: 1. Both classes of ExampleA and ExampleB can implement the same Interface(maybe GameMiningTargetInterface?) 2. This interface may declare one method ::parpareForMining() (or more of other actions depend on your real use case) 3. Both ExampleA and ExampleB implement this method differently. For example, A will do the CSV parsing, and B will do both CSV parsing and image processing. 4. The actual implementation of the CSV parsing and Image Processing(and other actions) should not be placed within ExampeA nor ExampleB. Instead each of these actions should be a standalone classes(CsvParser, ImageConvert?) And they should be injected into the class ExampleA and ExampleB(by dependency injection maybe) 5. So in ExampleA::prepareForMining: { $this-&gt;csvParser-&gt;parse(...) } And in ExampleB::prepareForMining: { $this-&gt;csvParser-&gt;parse(...) $this-&gt;imgConverter-&gt;convert(...) } 6. A more advance version is to abstract those existence of CsvParser and imgConverter away from Example A and ExampleB by using some provider pattern. But this maybe out of the current topic. 7. Anyway, by doing so, you can say good bye to your checking method exist logic, which is a little bit harder to be understood and make the output of the code quite unexpected(thus harder for debug and maintenance)
I wonder if you are comparing old version symfony and new version Laravel because I believe you wouldn't use singleton in either of them
This seems to be one of the few articles about programming advocating not naming things what they are. Let's see... an interface for classes that provide translation: Let's call it anything but a **translator interface** because that would be silly and confusing /s 
I have thought about the problem with having too much interface segregation too a while ago. But if we strictly follow "tell, don't ask", then we should rarely have to call more than one method of a dependency. But I can see how that doesn't always work out nicely like that in real life. I mostly use interfaces to communicate across boundaries, I have an interface `UserRepository` for example and and implementation `DbalUserRepository`. In that case I think naming it with anything else than a noun would only create confusion. In C# it makes sense to use a prefix like you mentioned. In PHP we have the keyword to distinguish and on the calling side I really don't care if it's an interface or implementation. And that's where I spend up most my time reading the code. So I think it's sensible to optimize for that, having `Interface` plastered everywhere just adds noise in my opinion and makes the code harder to read. 
&gt; We don't use hungarian notation anywhere else Yes, we do. FooController, FooRepository, FooFactory, FooBuilder.
I should have been more specific. What I mean by hungarian notation is specifying the data type, like `$integerFoo`. Your examples describe what the object/abstraction itself represents.
&gt; I don't think the structure one might use for a package is always suitable for an application. /me nods In this particular case, what do you think the difference might be for "package" `config/` and "application" `config/` ? (I'll grant that the *contents* of a config directory might be different in libs vs apps -- I'm talking about the name of the top-level directory.)
I'm not gonna argue if it's the correct way or not since it's very subjective. But I thing the Interface suffix has already became a standard by now. Well at least it's the "standard" used by most of the frameworks and libraries.
&gt; get people to go to his blog and sell his book s/get people to go to his blog and sell his book/help people who need it/g FTFY
Using dependency injection, the two instances injected into Example A and ExampleB can have totally different configuration... Or, you can invoke them in totally different way within Example A and ExampleB ::prepareForMining 
But a while ago the standard was to use service locators instead of dependency (like in the codeigniter days). But we (mostly) moved on from that to greener pastures as a community. The goal should be to write clean code, not to blindly follow standards. There are many experts arguing against the pre/suffix. See the clean code book for example. 
&gt; I'm wondering if there's an easy first line of defense There's a hole market for that: https://en.wikipedia.org/wiki/Web_application_firewall
I do agree the impact of the suffix is much smaller, but it does have some ramifications that goes beyond preference. Extracting an interface from a class results in a BC break if you use the suffix.
&gt; Extracting an interface from a class results in a BC break if you use the suffix. Hmm.. I didn't think of this, it's actually a good point. Could you give a specific example? My brain processes don't work that good after 8 hours of coding :D
Here is a real life example from [Doctrine](https://github.com/doctrine/doctrine2/issues/5051)
Well, the last thing the author of the article writes before changing subject and dissing programmers naming their default class implementations **Default**Something is: &gt; our former Translator class needs a new name. He then bails on telling his readers about which amazing interface-name-which-does-not-include-the-interface-word he was actually thinking of. Maybe he has concocted some amazing naming scheme and will be hailed by the masses as the next Uncle Bob but I fail to see where, following the path of least surprise/astonishment/WTFs, he provides any solutions in the article. Any programmer worth his salt is always looking for better and more descriptive ways to name symbols, objects, tables, etc. in his code, but after reading the article I see no point in naming a translator interface anything but TranslatorInterface. Sorry...
I might have to write an article of my own, since my viewpoints and arguments are not quite the same as the authors. If you don't mind, could you give me the pros and cons from your point of view? I don't want to be that guy who ends up arguing against strawmen in the end :)
You didn't understand what I said. I didn't say GraphQL is implemented by transforming/filtering a resultset. I'm saying that things like functions, variables in a GraphQL, can be statelessly reduced into a simple function-free and variable-free GraphQL before the result set is even fetched. Which means you don't need functions and variables if you can flexibly build the final query you're going for in your application language, which already has functions and variables. For example, you may say "but I need variables so I can supply parameters alongside the query, like this": $query = QUERY&gt;&gt;&gt; query something($size: Int) { user(id: 4) { profilePic(size: $size) } } QUERY; Then you send the query with the variables like `['size' =&gt; $size]'. But what if the entire query was an array, would you still need indirection? Let's see: $query = [ 'user' =&gt; [ 'id' =&gt; 4, 'fields' =&gt; [ 'profilePic' =&gt; ['size' =&gt; $size], ], ], ]; The same goes for functions. You can use PHP variables and PHP functions to build the query as long as it's just JSON serializable data itself. No special query features required. BTW I'm not saying you have to specify queries as *manually written array literals*, the very power of this approach comes from the fact you can easily read/write/update this information from your own code. So you can easily procedurally generate parts of queries, or even write yourself a tiny helper to reduce verbosity: $query = $ql('user', ['id' =&gt; 4], [ 'profilePic' =&gt; ['size' =&gt; $size], ]); 
check their github i guess
This one is premium. But you have free project also. Depends of your interest.
&gt; the number of contributors looks alarmingly low My anecdata is that contributing code is stymied because maintainers are too busy. I've got open PRs (with unit tests too) that have outlived the work-projects that discovered the bugs.
What's the point you're making here? You want us to donate money? Who pays for the hibernate project to maintain itself?
I mean if Symfony considers doctrine a critical piece of their framework ecosystem (and they should) maybe doctrine should be brought under the Symfony umbrella? Fabien has created a paying business around that framework, why not support doctrine as well? I'm sure some of those contributors would be open to accepting full time jobs working on that library. It would be well invested money for Fabien I imagine, win-win imho.
This is not the hungarian notation. `ProductController` makes sense because `Product` is, well, a product. A product controller is just that. `OrderObject` instead of `Order` would be the hungarian version (or `OrderClass`).
Why not make the interface the default then :)
&gt; As a point of curiosity, how much verbose is your filter in JSON? Good question, I've kind of wrestled with myself how to provide both terseness for manual entry and a consistent format for machine generation and processing. My internal format for filters is the same as GraphQL. But to avoid typing "true" all the time during manual entry, I supported this more concise format as an alternative: [ "name", "id", "value", [ "name", "value ] ] It's similar to what you suggest, but slightly more terse and clear. Internally, it's of course converted to this (through a simple for loop), for easier handling by further API logic: { "name": true, "id": true, "value": { "name": true, "value": true } } But in time I eventually moved the "terseness" entirely to the client, because when you're building a query programmatically from easy to manipulate structures, it's so easy to write query builder helpers with terse interface, that then generate the more verbose JSON structure to send to the server. &gt; it's not the parser I'm really bothered about, it's the structures it needs to operate. JSON is the rule of the jungle and whatever query language needs to work with it. I don't have some strongly typed source without doing pointless conversions just to spit out a reduced JSON with a GraphQL library. Sounds like a hell of a thing to support once you write it. Not quite sure what you mean here (can you rephrase). Do you mean it's hard to return properly typed JSON data from PHP maybe? 
I'm also interested in your opinion on them, I've used both fairly extensively, although I've used Eloquent to a greater extent. Is the Eloquent code you're working with well designed, or is it a case of the way it's being used that's the problem? I love Eloquent as a thin persistence layer, but I've seen some horrendous abuses of it to manage all of the domain logic.
Is the library discovery thread coming back?
To recycle from a [past thread](https://www.reddit.com/r/PHP/comments/30e05b/using_interfaces_effectively_in_php/cprxn9r) &gt; Personally I believe you should always program against the interface when possible, and that means the interface "deserves" the nicest name, because it's the one you *want* everyone to be typing and reading. &gt; In other words, better to have `interface Foo` / `class FooImpl` instead of `interface FooInterface` / `class Foo`. [...] &gt; &gt; `FooImpl` is not good enough &gt; I agree when it comes to most use-cases, where you expect/allow many equally-valid implementations. In that scenario, the developer should be able to think of a more-specific name for the default implementation(s) you ship, because it can be compared or contrasted to the other potential ones. &gt; However I think there is also a different case: When you will only ever have one production implementation, but you're working around a deficiency in your testing tools regarding proxies/mocks. (This applies more to some other languages.) 
I don't know why it's so complicated to understand what I'm saying. I'll go with an analogy. Let's say we have two cars: - Car "Laravel" is street legal, but very average in speed. In a sports car competition on the racing track it would lose to any sports car. - Car "Phalcon" is a sports car, it's extremely competitive on the race track, but it's not street legal. Now our premise is that the cost of owning and maintaining two cars would be extremely cost prohibitive. But there's a perfect technical solution that makes it possible to make "Phalcon" street legal, as long as we follow the speed limits as necessary, when we're not on a sports track. If we implement this solution, I can drive "Phalcon" everywhere, so then I'll buy and drive "Phalcon" and drive fast when racing, and drive slow when in the city. If we don't implement this solution, I have to buy and drive "Laravel", because I'd rather lose during racing, rather than walk by foot in the city every day. Any of this light any lightbulbs, ring any bells? Or is it still unclear.
I thought I understood you, but after reading the analogy, I don't... You're pretty much saying "having zephir and compiling is taking away your user base. Why should I compile something when I write PHP"?
That actually sounds like a great idea. I'm guessing Fabien has had that thought already though.
I guess I really suck at explaining. Compiling is not the problem. The problem is that when compiling Zephir to C, you can't target stock PHP installs, where you can't install binary extensions (which is most shared hosts). The solution proposed is to have two output modes for Zephir: **1)** compile to a C extension for PHP, **2)** compile to PHP userland code. Thus we can write-once-run-everywhere. More applications will be written on Phalcon, or even directly in Zephir, and then you can compile and export two versions that you can deploy on the entire range of servers: from crappy shared hosting (you will deploy as PHP), to top-speed dedicated servers (you will deploy as a C extension).
I'm the only one who is a little bit concerned about the fact that just one person is doing this big code refactoring and this fact goes even unquestioned? It looks quite bad to me.
&gt; Fabien could name the folder /bananas Yup; like I said, "Fabien obviously has final say over his own projects." Hell, maybe he can call it `facades/` -- that wouldn't matter either, right? ;-) 
&gt; This constructor says ‚ÄûI need an object instance implementing the TranslatorInterface contract‚Äù. No more, no less. The rest is how a misguided developer may understand this differently. I like how you strategically switch to a synonym of "interface" (i.e. "contract") to avoid the problem the author is trying to express: it's redundant to say ‚ÄûI need an object instance implementing the TranslatorInterface interface‚Äù. Whenever you typehint something "Translator", there are two things you instantly know, regardless of the name: - I'll be provided an implementation instance (an object). - That object will match the public interface of "Translator". That's all you need to know. You don't in particular need to know which one of those "Translator" is: - It may be a class (interface + 100% implementation). - It may be an abstract class (interface + from 0% to 100% implementation). - It may be an interface (interface + 0% implementation). The % of "implementation" in the interface type is absolutely irrelevant. **A typehint always references the type's interface, not its implementation.** No matter which kind of type provides the interface, you will always be provided with 100% complete implementation when given an object, and you will always use this implementation the same way, no matter how it was produced. Implementations **are disposable** and replaceable, and their names **don't matter**. Call it DefaultTranslator, call it ArrayTranslator, call it TranslatorImpl, call it PoopTranslator: *almost nobody will see the name of the implementation. In most cases it'll be produced in a factory or a container somewhere and injected.* **The only thing that matters is the interface name.** *Everyone will see that everywhere.* Java got it right. PHP, ever since version 5.0 copies Java in everything when it comes to OOP design, but this one we didn't copy. Worse, we didn't even understand how to think about interfaces.
You like `interface TranslatorInterface`? Then you would **love** `class TranslatorClass` and `function translatorFunction`! Go try it today in a codebase near you. Call now and get a free `$translatorVariable`.
&gt; Because in this context, interfaces are purely abstract concepts that we programmers use as a mechanism for defining a contractual relationship in our code. They have no direct value for the end users of a system. Are you kidding. *Code* as a whole has no direct value for the end users of a system either. They see no code. So what does that mean for naming anyway? Let's make all names in code pointlessly verbose or something? This doesn't compute. And if by "end users" you mean, say, you write a library, and the end users are PHP developers using it... then you're absolutely wrong. In a well-designed library, the most visible types are typically the interfaces, not the implementations.
&gt; I still prefer to be able read from the function signature the types it will accept as parameters when relevant, without looking for color-clues or having to hover the mouse over symbol names. And how is it exactly helping you to call a method based on the distinction of "Foo" vs. "FooInterface" parameters?
I'm not sure using "Interface" suffix helps with anything when calling a method. Even if the parameter is a class name, it doesn't means you'd just instantly make a default instance of that class and pass it. If the class is abstract you can't do that. Even if it's not abstract it may have subclasses extending it. By that logic, it makes most sense to explicitly name final classes FinalTranslator, so you can look at parameters and say "yup, I'll be instantiating FinalTranslator, apparently, as that's not an interface, abstract or non-final class." But even then you know very little about the purpose of the class or its arguments. So the whole argument kind of falls apart - you have to at least hover, more realistically go to the declaration, read comments and open the documentation, so you know what you should pass in. 
After thinking about it for a bit, I completely agree with you. We should optimize code for reading, not writing. And for reading code this argument doesn't matter.
[removed]
&gt; As I commented elsewhere: I don't suffix all my objects as MyObject and tables with MyTable either. It's the default datatype in that context. Among class/abstract class/interface, none is the "default", really. In fact, if you think about it, the only common thing among all those three, a default baseline property of all, if you will, is that they expose some kind of public interface.
As I said, I've used both quite extensively and know how they work, but even with very complex domains with a considerable amount of logic (hundreds of tables with in depth reporting requirements), I've rarely found a considerable advantage to using Doctrine over a properly designed domain that uses Eloquent as a thin persistence layer that is, well, eloquent.
&gt;So I think it's sensible to optimize for that, having Interface plastered everywhere just adds noise in my opinion and makes the code harder to read. Indeed, I wouldn't like that either. A little I prefix doesn't hurt though, imo. But as I said, that's a matter of preference.
[removed]
active record just means that your models are just data models and you should build your domain models on top of it. Something like row data gateway for example. data mapper allows you to build only domain models and use it's state as data model. But since it should be mapped to database it brings some limitations in what you could do. By introducing JSONB support some of this limitations are gone, but not all. This differences are causes some pros/cons and I think that people want to know what this pros/cons are for both approaches. p.s. I don't see any reason why you should chose one vs another. I think that on some projects different contexts could use both this approaches. But anyway you should know pros/cons of every solution to wisely chose right tool for the task.
You don't have to agree that the effort to get Zephir to export PHP code is worth it, that's entirely up to you. But your inability to understand what I'm saying, or pretending that you don't, is quite preposterous at this point. Other people in the thread are getting it, and you're the only one who can't see the point. Not my problem at this stage.
I would say this is a myth that open source = huge community of active contributors. Most of the time, even for monster projects, you have a couple of people working on it. Doctrine had most of the time been the work of 3 very active people, and this is a good score. I am maintaining several important open source projects, and I see this situation every time.
ahgreed
Phalcon is an open source project. I don't necessarily want "the developers" to spend "their time" doing this. Heck, if there was a recognition of the problem, I could contribute myself. It would be literally less effort for me to write a Zephir PHP emitter, than to maintain two distinct application codebases for products written on top of Phalcon. And that's just the math done if Phalcon has one user like me, who targets "vanilla PHP" installations. But there are far more than 1 potential users of this solution. Let's say 10 thousand PHP users are itching to use Phalcon if they can also compile their application for "vanilla PHP" servers. You're saying it's "preposterous" to ask that Zephir maintainers consider a PHP emitter, but instead 10 thousand PHP users should implement their apps twice: with Phalcon, and without Phalcon, so they can reach widest audience. I mean, at this point we're talking basic math. But I get your point, Phalcon doesn't care about those potential users. They just don't want users in general, is what you're saying. They're just going for the hardcore enthusiasts who picked a framework solely based on the fastest "hello world" benchmark, and zero other real-world considerations.
&gt; Not sure why you think people would waste their time doing everything twice. Are you serious? I explained that to you in five different ways already. This feels as if I'm talking to Derek Zoolander here.
&gt; This constructor says ‚ÄûI need an object instance implementing the TranslatorInterface contract‚Äù. No more, no less. The rest is how a misguided developer may understand this differently. I think I can explain the problem without code here. Just compare these two versions of the same conversational statement: 1. Tomorrow I need to catch a `bus` so that I can go to `work` and earn some `money`. To be specific, I'll catch the `CityMetro #23`, work at `Acme Widget Inc.`, and earn `US Dollars`. 1. Tomorrow I need to catch a `ThingWhichActsLikeABus` so that I can go to a `InstitutionWhereWorkCanBePerformed` and earn `SomethingThatCanBeExchanged`. To be specific, I'll catch `Bus‚Ñ¢`, work at `Company‚Ñ¢`, and earn `Money‚Ñ¢`. You're basically promoting situation #2. It makes 99% of language a pain in the ass, *except* for a rare special cases that have been allowed to **steal** the best words. In those cases they've removed useful *concepts* from the shared vocabulary in order to personally profit from prestigious *concrete* labels.
Wait, let me paint a more complete picture, before I tell you what you're telling me: - Which DI does a "Framework Agnostic" web app use for its services and dependencies. - Which router does a "Framework Agnostic" web app use for its routes? - Which ORM does a "Framework Agnostic" web app use for its models and persistence. - Which validation &amp; form component does a "Framework Agnostic" web app use for its input and web forms. - Which ACL does a "Framework Agnostic" web app use for its authorization system. I can keep going, but let's stop at those above and see what happens.
Yet so many manage to do it with hatred of AR
btw, all those items are available separately, and when you get done putting them all together you will have your own "framework" of sorts. It would be pretty cool if you pick the pieces that give you exactly what YOU need. Another thing that programmers tend to do
So basically your answer is "well a Framework Agnostic app would use an independent component, as can be found on Packagist etc." You said "you can use Twig with Phalcon". Now tell me.... if I'm using a non-Phalcon router with Phalcon, a non-Phalcon DI with Phalcon, a non-Phalcon ORM with Phalcon, a non-Phalcon validation &amp; forms with Phalcon, a non-Phalcon ACL with Phalcon, a non-Phalcon template engine with Phalcon etc., where does Phalcon come into the picture, here? Does it ever? No. You're basically telling me to replace Phalcon with non-Phalcon components. That wouldn't be a "Framework Agnostic" app, it would simply be a "No Framework" app. So you won't get anybody on the Phalcon train with that talk. 
I mean, this is why shitty Wordpress is literally **one third of the web** nowadays. While the snobs talk about how easy it is to get a droplet on Digital Ocean, Wordpress runs on everything, and a child can install it. That's truly "new and improved" winning the war here, huh. /s
Cross-posted to eight subs is way too much, and qualifies this as spam. 
Mostly just rejecting features :P
We actually built out a Domain layer and Repository layer to abstract away, as much as possible, the places we need to use the persistence functions of Eloquent. We can't get away from the model objects being permanently tied to the database but with discipline we manipulate the objects as necessary and then pass them back into the Domain/Repository layers where they can be persisted. On larger teams this really helps get everyone coding consistently.
If you look again, you will find several that are simply stating "switch/use PDO and you're golden". While one might argue that the use of prepared statements was implied, it also speak to a fundamental misunderstanding of what PDO is.
I was not taking specifically about them. In other OS projects there are PRs I submitted that have never been considered and issues I opened that have never been answered. Some project I tried to contribute had a too little documentation or hostility towards contributors. I don't want to name any project, but that's a reality.
Need more context. - What types of sites are you creating with Wordpress? You mentioned WooCommerce which leads me to believe you are doing some ecommerce sites?? - What types of challenges are you currently facing with Wordpress? - Why are the customization taking too long? - Why hasn't the owner and team wanted to switch? - What is the lead designer currently feeling frustrated about?
PDO better feature options, specifically named parameters, and a simpler interface. If you don't have either, why not choose PDO over mysqli? But we don't know what OP has, so I guess it doesn't really matter.
This is one of the dumbest reasons to build your own framework. Instead of closing your self off, why not contribute to OSS?
Just because one person is doing the leg-work doesn't mean they aren't collaborating. Guillerme (probably slaughtered spelling) has talked to me in the past about selecting data structures, for example.
nice website www.imgcluster.com
Heh. :-)
Thanks for sharing. Once suggestion: put the code up in GitHub and let people pick it apart, if your intention is to learn and be guided. 
You gotta be a bit more specific pal. If you want someone to invest their time to help you with something, then you should at least invest some time into asking a more specific question to your problem that makes it easy for someone to help you.. Show us your code.. what you have tried already and what you are struggling with etc.. Also, for help you should check out r/PHPhelp/ 
If you are currently enrolled as a student some where make sure you grab the student developer pack. It has a few little perks that are nice. You might want to share some GitHub code with someone for example but keep it private and the pack gives you that for free. https://education.github.com/pack 
&gt; But programmers do care about those little details. Seeing TranslatorInterface tells you things about the code Translator doesn't. It doesn't tell you anything useful. C# uses `I` because they don't have a distinction between implements and extends. Java doesn't use anything. And by using a suffix you can't extract interfaces without breaking BC (see the Doctrine link that I posted in another comment). For me the pros\cons stack up heavily against using a suffix. What are those little details that are important enough to sacrifice readability and the ability to extract an interface from a class?
Holy shit, I can't believe I haven't seen this one yet, thanks!
You sound like the author of an O'Reilly Head-First book on naming conventions. 
Hey that's actually sick, I setup my GitHub and the student developer pack. Thanks for the suggestion man! I will make a GitHub doc and post code when I get home tomorrow.
That's really good. Well done üëç
Because Symfony (even Phalcon) DI would not solve this issue, I can inject CSV parser into example A or B using DI but the class is the same, it contains the same logic for both which isn't what is needed, I would need to make multiple csv parser classes all with different logic
You can also sign up on the jetbrains website and get most of their products for free!
I was not claiming they need to spend more time on the project, I was discussing how that time is spent. Anybody can spend his free time as he wish and if their choice is to work on os software they should be always thanked and praised. Said that I think it's fair for the users of every OS project to express their ideas about how the projects are managed.
The impression I got by reading the OP was that at the moment the bus factor of doctrine 3 is a dangerous 1. Again this is not meant to be a criticism for anyone. Just an assessment of the state of the project.
&gt; And what has the lead designer have to do with the code? It's an agency, and WordPress. Our designers aren't doing plugins, but HTML and the loop are well within a web designer's capability. At the same time, I have suggested we bring on a front-end person, but something something deaf ears...
Considering that you even don't know what is Decorator pattern, let's end this discussion as soon as possible. To write better code or not, it is your own choice. And I don't want to argue with you any more :-&gt; 
I use Laravel daily, so anything closer to that I'll take a look at. I've heard good things about Craft, and the only things we really need are custom fields and easier AJAX, most everything could be custom, honestly.
This is interesting. So you use WordPress only for the dashboard? How do you get data to it, the API or manually inserting data into the database?
Sure. I mean it's hard to convert native structures (array, object, string, int) to the typed structures which GraphQL libraries need to perform execution, ie `Schema`, `Field`, etc. GraphQL would be more immediately useful if it was working on language primitives, ie, what is directly produced with `json_decode`.
Do you have any thoughts on alternatives for non-ecommerce websites? I get that we may be stuck with WooCommerce for the long haul.
Hum, I didn't know GraphQL requires this, because I used this home-grown GraphQL-like layer (which actually precedes GraphQL in time). With me the validation/formatting routines are separated from the actual data, so I can run a validator on a tree of data, and I either get it normalized/formatted on the other side (and mostly untyped again, unless I choose otherwise, but guaranteed to have the right structure/fields/data), or I get validation errors.
Sure - Bolt, October, Pyro are pretty good. Craft has already been mentioned. Even a quick custom solution is feasible if you want to deal with forms, simple event registration/attendance through Laravel and other features that agency clients might sometimes require. 
Thanks. Bolt is the only one I've spent real time with, so it is good to see someone suggest October and Pyro.
Yes PDO and parameters binding. Well i mean not detecting, just safest way and only you should use.
Take a look at Pyrocms. Their e-commerce platform is almost ready and it's all Laravel based with an active community. Personally I cant stand wordpress. We took over another web dev company recently who had used it almost exclusively and the key problems we've found are: - Despite everyone repeating over and over that Wordpress is easy for clients to use, we've found it to be the opposite - it's way too easy for a client to screw up the entire site - People abuse plugin use massively. If you've got any more than 5 plugins, you're probably doing somethig really wrong. Wordpress should not be used as a one size fits all solution - 1 bad plugin can take down an entire server, and I'd say wih 99% certainty that at least one of your plugins has a massive security hole. - For developers, wordpress is a nightmare. The code structure is just awful. The practices are things you'd expect a junior level developer to be producing, yet devs that are actively working on wordpress dont see this as a problem.
Sadly, the slider doesn't work on mobile
This one is no joke. Php storm, their ide, is fancy and great. 
["It looks quite bad to me"](http://imgur.com/a/HJxuz) comes off a bit like an unfair criticism.
this is superseded by expose/expose
A criticism (maybe unfair, maybe not) about this specific situation. Do you think it's good?
You need to do this from a script that is external to the one you want to modify. For local files it might also be better to use output buffering and include the file you want. //login.old.php echo "Cloud" //login.php echo get_rendered_php('./login.old.php'); function get_rendered_php($php_file) { $html = ''; if (file_exists($php_file)) { ob_start(); include $php_file; $html = ob_get_clean(); $html = str_ireplace('Cloud', 'Ass', $html); } return $html; } 
I think you are better of editing the .phar file itself. https://github.com/jgmdev/phar-gui http://cweiske.de/tagebuch/php-phar-files.htm#tools and so on
I did it using a dictionary, but I'll study the phar file structure and how to use it.
Maybe I don't want other people to touch my code because my coworkers write shitty code?
What would you say are the top 2 or 3 features of the Spiral framework, wolfy-j? 
The bus factor of this is not 1. Guilherme extensively discusses all his changes with the core team. We are reviewing his changes and discussing different approaches. And this is for a develop branch that isn't even ready to be merged to master. The current stable master has half a dozen maintainers in the core team that are at different levels of "active", but all are available in the core contributor chat where we discuss broader issues together. I think the main objection is that people tend to think with the amount of issues and PRs that we are not actively maintaining. Our main problem is that most of the Pull Requests have absolutely no chance of ever getting merged or require massive rework. Cleaning this up regularly is dreadful and painful work for all sides, core and non-core contributors alike. We tend to error on the side of caution with changes, because the core of Doctrine requires a deep understanding of the side effects that many first time contributors don't have. It is unfortunate, but as for the ORM, I don't see a way where we can improve this experience for contributors except through lots of rejection. Decoupling the code base to avoid the side effects is not possible without introducing many abstraction layers that will have an effect on performance. Personally I don't like it myself that Doctrine is so hard to contribute too. In addition, Doctrine is not an "open" project with regard to development as other projects, as much planning and work is going on on a private chat + core contributor list. This is the way Doctrine has always functioned, and for an outsider this may look like nothing is happening.
Under Win 7, I used Vagrant all the time, I use Homestead when I'm on OSX or Linux these days. If you can get Vagrant working, I'd go for Homestead first. Really easy once it is working. Deployments. At work I've set up CodeShip which is cheap(ish) and hosted. They are rolling out a new interface which is really nice. What will determine what you use is price, not features. 
It would be cool if you could "share" the content generated. For example, if I enter in `https://www.google.com`, it would be nice if your site's URL changed so that I could copy that and send it to someone. Even if it's just a simple GET param, just something that let's me share it :)
Phalcon proving once again that a compiled C extension will always out-perform a PHP framework :P I mean, I think Phalcon is awesome and deserves more attention, but this is like comparing pistols and rifles to a ship's cannon.
Curious, thanks for that link. What makes it better?
The Techempower is a more complete because uses the ORM and stuff. About the "this framework could be optimized etc", every framework listed could be optimized, even Phalcon. I don't think the final result would be different.
Great list. Aside from feeds, there are also some related weekly newsletters like [PHP Weekly](http://phpweekly.com) [(latest issue)](http://phpweekly.com/archive/latest.html), [FrontEnd Focus](http://frontendfocus.co) [(latest issue)](http://frontendfocus.co/latest), and [Web Operations Weekly](http://webopsweekly.com) [(latest issue)](http://webopsweekly.com/latest). [Cooperpress](https://cooperpress.com/publications/) has additional languages and topics that I didn't list here.
What really triggers me is that the colors in the graphs are not consistent to each product, but just to order from left to right.
Having a team/organisation/business to put your vulnerability disclaimers behind probably helps a lot, if you do it as a single person that's a lot of feedback/responses you have to filter out yourself. Also, without knowing the specific case(s) you're thinking about where you've dealt with outrage, having seen your name on reddit the past 2-3 years, my impression is that you often come off as condescending and snarky. There is a possibility that changing the tone of your writing would reduce the outrage you feel like you have to deal with.
[This post](https://www.sitepoint.com/re-introducing-vagrant-right-way-start-php/) might be useful. As someone who spins up a variety of projects every day and needs to make sure they behave exactly the same for several thousand other devs, I recommend Vagrant. I'd probably invest some time in learning Docker properly if I was solo or in a small team. For production, some Forge, some raw DigitalOcean droplets provisioned by custom Ansible playbooks.
&gt; How is GitLab CI/CD. I like GitLab in general. Doesn't it need a server backing it, like a droplet or something? That was the impression I got when they announced it. It's good, i'm quite happy with it, even on free tier. They provides free shared runners, but sometime it would take a long time to wait the queue. But you could also use your own server, even your pc/laptop, to create private runners.
It helps you when doing Continuous Integration (build and testing your code whenever you push it) and/or Continuous Deployment (deploying your code whenever you push it). It helps the "deploy" parts of your questions.
I am blindcolor. Didn't notice the difference.
&gt; Eager to try out Symfony Flex? Well, I will push everything to Github just in time for the next blog post. _Next time on DBZ_ &amp;nbsp; Jokes aside, very interested to see everything come together. Admittedly I don't know shit about makefiles though, guess I'll get to continue learning new things this year :)
So based on this logic musicians shouldn't feel bad if we say their songs are bad?
So, first, major kudos for working on this and putting it out publicly for criticism... This function in *MyCMSSecurity.php* worries me: function s_crypt($str) { $code1 = base64_encode(base64_encode($str)); $code2 = base64_encode(base64_encode(CRYPT_KEY)); $crypt = "my#cms" . $code1 . "my-cms" . $code2; return base64_encode(base64_encode($crypt)); } I cannot quite tell how you are using it in the project, but **base64 encoding != encryption**. Next, by convention, your class files should not also be executing code -- you really don't need to have the following in every class file: if (!defined("MY_CMS_PATH")) { die("NO SCRIPT"); } 
&gt; Also, without knowing the specific case(s) you're thinking about... **[unsolicited advice]** This is an anti-pattern. If you don't know the specific cases, you really aren't in a position to comment on them.
Been working with Expressive 2.0 for about a week now and I'm starting to like it I believe. At first I didn't know how I'd felt about *Action*Factory classes because it seems like my actions folder fills up extremely quickly. Eg.: - User/Action/RegisterAction - User/Action/RegisterFactory - User/Action/LoginAction - User/Action/LoginFactory - etc.. etc... I feel like this folder hierarchy could be done better, maybe a factories folder, idk. Although I think it was weird at first, I think I like it because in my factory invoked classes when I'm grabbing the dependencies from the service locator container (using pimple) and passing them to my *X*Action class, I could either throw an exception if one of the dependencies are missing or I could say return a `InternalServerAction` action which handles those errors (logs them), but gives a nice little twig render and it's very reusable. It's a very neat setup to think about. I haven't really written code like this before personally. Thinking about writing a few how-to blogs on setting up different things and explaining how a few things work that aren't clear on the zend documentation site. My biggest issue w/ the zend doc's is they go in depth on how something works, but don't always tell you how to use it in your own project. Or if they do it's not that clear.
http://i.imgur.com/tyTc1Nl.jpg
Cute, but you'll have to explain yourself, unless you want it to look like you accidentally posted in the wrong thread.
Updated, the s_crypt is an old, wrong and unused function. Now I've removed it, thanks for the second hint!
**Work Environment:** I made the switch from Windows to Linux a few years ago and it has made workflow much easier in my opinion. **For Projects:** I use Vagrant and have a couple of Ansible Playbooks to handle provisioning. What is nice is that for production deployment I can still use the same Ansible playbooks to configure (usually Digital Ocean server) the server. In the passed I did run into issues where if I had to many virtual machines runnings it would crash my PC but it hasnt been an issue since I upgrade laptop with more RAM. I think using Docker may have reduced that problem. **Deployment:** Lately I have been using Bitbucket the GUI is nice/easy to understand but honestly I would rather just do most of it manually using GIT. **Other:** I messed around with Docker and didn't really like it. I tried Laravel Homestead and found it sort of annoying to work with. I used Scotchbox for a while and its pretty simple to get started with and easy to customize. 
It's a real thing, @taviso gets heat too, and he has Google behind him.
Sorry, I was refering to the "Popular Symfony bundles" section at the bottom of the page here: http://symfony.com/doc/bundles/#bundles-popular
I am not very good in critic but here are two: First-level intent is unnecessary; $this-&gt;init_security(); $this-&gt;initPlugins(); $this-&gt;init_functions(); You should standardize naming.
Why use such a verbose implementation? Edit: https://gist.github.com/anonymous/38bbcd148fceb678b91fd00d2c8e93aa
&gt; 5 months You must be new to the Magento world... Every now and again I'll get an update from a support ticket I filed a year ago that they're "still looking into" a fairly major data corruption issue (that I worked with one of the Magento platform architects directly to identify and patch in custom code in about 2 hours).
You have a good, very even perspective. It also reflects why I don't push harder than I do. I'm the house developer, with a fair amount years at this point, but I do try to avoid setting up a system that can't be maintained if I leave for that sweet Golang job in the sky. I'll have to keep our limitations in mind. Thanks for the input.
As developers, we're always going to be concerned about implementation details. Particularly if we're the only developer on a project. The argument being made here is that this should not be the _only_ mindset, and how you design and architect your contracts (interfaces or otherwise - the public API) should take this into consideration. Change one word in your response, and it might help clear that up: &gt; Why should a **consumer** care how a system is designed?
You're not the code you write, except if you wrote CodeIgniter
"I do try to avoid setting up a system that can't be maintained if I leave" That is very thoughtful of you. Sounds like you may be happier working in a company that develops products (SaaS products, mobile apps, etc.) rather than an Agency that does client work.
"programming is 95% business concerns and 5% coding." Very, very true. "I probably need to be one of the success stories of a developer, going out on their own and never looking back." I did that 12 years ago and still at it. Whole other set of challenges but I can't imagine any other way. I develop SaaS products. I ran an advertising agency at one point too. Not a Wordpress shop though. We developed our own landing page and ad creation/management software that we used for our clients. I do understand the challenges of running an Agency though. I personally hated it and closed it down after 3 years to go back to SaaS. Hopefully you can make a little headway where you are currently at. Hope your boss knows how lucky he is to have a developer who is thinking about this stuff rather than just punching the clock.
Thank you. I appreciate the kind words.
It came with Laravel 4 so I always thought it was a 4. Since it's stayed for 5 I've always wandered what it actually was 
It's like reverse Wine.
Hey, I work for Bugcrowd and I can help you out. I'm going to ping our folks with that ref ID, but also please feel free to email support@bugcrowd.com if you ever need anything..like have us follow up with the customer/vendor on the bug.
&gt; The internet seems to be severely lacking in Opencart resources Trust me, this is a good thing
Cool, thanks.
Sucky, but thats what my company runs, and I dont get much say in the matter :/
Yep. I've never used OpenCart, but I have worked on legacy codebases. My best advise is to go code spelunking and learn what you can from the source if you can't find good documentation. 
Letter "L" ?
1500 lines _removed_ since last commit, no comments. [Still working exactly the same, but don't brag about it] &gt; Feels good :D Yup, refactoring is fun! 
This is my guess, with the addition that its separate blocks put together to make a whole L
If it has tests and is properly decouple through a Domain-Driven-Design manner, then [no comments is probably fine](https://medium.com/@fagnerbrack/code-comment-is-a-smell-4e8d78b0415b). Now if the code has low quality, then yeah comment out. But focus onfixing the code quality problem.
My perspective here is a little skewed as the vast majority of my work is currently maintaining legacy code written by someone who wrote it as he learned it. Otherwise I agree with you lol. Edit: one instance I can think of is a whole slew of sections that started with *extract($var);* and proceeded to declare a dozen different variables like *$var1, $var2, etc* which are then passed to various preg_replace_callback calls whose callbacks are equally poorly written and so on. 
That's totally understandable then.
[That's what it says on GitHub](https://github.com/laravel/art)
One thing I don't like (as for now) is console output and makefile defined in composer.json. Lines of file written as elements of array. It just doesn't seem right in this place. Maybe, in bigger picture (after Symfony Flex release) it would make sense.
Oh thanks for pointing that out. I guess that file_get_contents() doesn't support urls that don't have http or https, I will try to fix it when I get home. Possibly by just searching if there is an "http" in the url string through strpos and then appending "http" at the beginning of the string. That's a pretty substantial error so thank you for pointing it out
So, if you are asking for PHP projects which help to implement a REST API with authentication: * Frameworks * [Symfony](https://symfony.com/) / [FOSRestBundle](https://github.com/FriendsOfSymfony/FOSRestBundle) * [Laravel](https://laravel.com/) / [Dingo](https://github.com/dingo/api) * [API-Platform](https://api-platform.com/) * Micro-Frameworks * [Slim](https://www.slimframework.com/) * [Silex](https://silex.sensiolabs.org/) * [Lumen](https://lumen.laravel.com/) * API-Management * [Apigility](https://apigility.org/) * [Fusio](http://www.fusio-project.org/) 
Some people will always be angry at you, sure. But I specifically said "reduce", not "eliminate".
You really think that first request only will change results so much? I highly doubt it. The c extension will be still faster. You can even compile php 8 jit already, on some php only code benchmarks it's faster, in real world applications for now(at least lastly i checked) it's actual similar or even slower.
You really think that first request only will change results so much? I highly doubt it.
You can use PHP for the backend, it is possible. But other technology stacks have more mature support for realtime communications and WebSocket specifically. That being said, you should be fine. Regarding the database, Postgres has better spatial types, which might be useful when making such a game.
Good Job !
Meanwhile I've added the missing outline tag, sorry for the hassle
It actually has a home on reddit: /r/bashonubuntuonwindows
ALWAYS.
They are different roles, but more importantly, the AdminUser is not stored locally in my database. AdminUsers authenticate via AD/LDAP using the same login page as the CustomerUsers. I use the Guard authentication component to handle that.
&gt; When developing an e-commerce application, unless you work at United Airlines, you generally want to avoid overselling. I know that's not the point, but UA doesn't oversell because their team is not aware of locks. All airlines oversell, because some people don't show up when the airplane is about to take off. I wouldn't have to make this remark, if you wouldn't make a reference to UA, which wasn't necessary for your article.
Oh yeah, you don't need to have one class user, but I was simply saying you don't need to differentiate classes only to express different roles. Otherwise have as many as necessary. BTW the pattern you implemented, intentionally or by accident, is the Visitor pattern, sort of. Or "double dispatch". It has its uses, it means you don't need the branch, but it's not suitable here IMHO.
You are right about the long term, to a good degree. That's why it's a great framework to start with. Keep in mind a business needs to minimize costs and risks until it gets traction. Once the app is proven and has paid for itself, it's easy to change. For the initial number of users, you will have more than enough to satisfy their needs. Other frameworks might be better when it comes to long-term maintainability, etc. Though it's harder to afford developers ( or learn on your own ). This can slow down a project so it never gets off the ground.
The definition of "high quality developers" varies a lot I have to say. For a web shop it's one thing - and here you are right. For a product company, where your plans stretch into next 5-10 years the requirements for a "high-quality" are much different, and having been on the hiring end, finding those Laravel gurus is harder than for Symfony. The Laravel ecosystem is not ready for serious business - fractured, low quality, tons of unfinished/abandoned packages, half of it lags behind for 2-3 versions and a lots of "pay us a yearly cost for our package". Laravel is overly hyped by marketing, the reality sets in quite fast when you stop doing short 1-2 month projects and your requirements range into "100 pages of specification" of business rules, integrations with a few dozen of partners and all that stuff.
Yeah I guess that applies as well, depends how you look at it :-) Many patterns have similar (or even the same) code, but different intent.
Really depends on what your SaaS does.
Looks good! Nice to see that you've done all the annoying parts of launching an open source project, like the changelog, contributing, etc. I didn't do any of that stuff when I first started my project and it was rather annoying to do it all from scratch later on, lol.
In my limited testing I've found that PHP (using http://reactphp.org/ or http://amphp.org/) and coupled with an event library (libev or libevent), the performance is quite significant. I guess time will tell whether or not that holds true at scale.
&gt; This will be plenty of time for malicious parties to track down the issue in the source code. I guess the sec team needs to do these disclosures differently and tell a bit more about the problem and exemptions and mitigations that apply. Furthermore, the *critical* level of the announcement is standard for unsupported projects. It does not reflect the criticality of the original vulnerability.
I'll write up a blog post detailing how it all works when we're at an early alpha stage but it's actually quite performant and lightweight: * for standard https requests, nginx sits on the front-end sending requests to php-fpm, which actually solved the "spin up a process for each request" problem a long time ago. php-fpm maintains a pool of N workers (configurable) that are ready to handle requests without needing to spin up a brand new process * for web sockets, it's fundamentally a similar approach except there's no php-fpm -- Instead there's regular PHP long-running processes (daemonized) that handle websocket connections (react-php or amphp provide this). WS connections are long-running processes that provide a bi-directional stream between the client's browser and your PHP process(es) (with nginx in the middle as a reverse-proxy). These libraries follow an event-based model very similar to nodejs, so for any file or network I/O, the processes are non-blocking. This allows a single process to handle thousands to tens-of-thousands of clients simultaneously. By using nginx as a reverse-proxy, we can easily have multiple of these PHP-based WS servers operating transparently to the clients. I'm leaving out a lot of the nginx details but the relevant portion for websockets it's simply: upstream websocket { server 127.0.0.1:8080; server 127.0.0.1:8081; } server { location /chat/ { proxy_pass http://websocket; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_set_header X-Real-Ip $remote_addr; } } The above would support two backend daemon processes (running on :8080 and :8081) but to a front-end client, they'd just simply establish a websocket connection: var conn = new WebSocket("wss://arynda.com/chat/"); WebSocket is a standard object in all modern browsers at this point, so it makes the bi-directional real-time communication an absolute breeze. In terms of file descriptors, the default event mechanism (select()) is indeed rather limited but that's where advanced polling libraries such as libevent/libev come into play, and can easily handle tens of thousands of active sockets. This is precisely the same strategy employed by nodejs and libuv (which is just a wrapper for various event systems across linux/osx/windows)
Look we'll just build in extensibility, we'll have a plugin layer, and have some open repository to put them on, we don't have to even to code review them, this way we won't have to do most of the work to... OH MY GOD EVERYONE IS WRITING THOUSANDS OF SHITTY INSECURE MODULES AND ABANDONING THEM AND MILLIONS OF PEOPLE KEEP INSTALLING THEM.
This is spot on
Laravel, and I think I remember symfony too, need to be configured a bit more to fire up cache everywhere needed to be relevant. If they are all well configured, it should be detailled in the article, and still, feature list out of the box are different enough this achieve not that much. Still, phalcon will stay in first, no doubt. Proportions might change though.
Yea sure, i agree, but in mind that sometimes there are apps which are updating pretty often, nearly all the time and with like those you can't really use varnish or some other cache and here come the point when you need well performing framework/technologies.
So you mean like GitHub and packagist?
Pretty much. I consider everything on GitHub and Packagist unsafe, until I verify the authors, and the package's track record myself. Don't you? But end-users don't do this. Drupal, Wordpress are end-user apps. *Those users* don't use any discrimination in choosing what to install on their sites. The plugin ecosystem of Drupal, WordPress is closer to the iOS App Store. If it goes unchecked, it'll get filled with insecure data stealing malware in negative time, and people will keep clicking and installing. It's hard to get an ecosystem going. But it's easy compared to keeping it healthy once it does get going. Keeping it healthy is expensive and tedious, and requires skills that many open-source project maintainers don't have.
You need a different structure. But that's a larger question. For example - if a transaction is ultimately denied by the PSP or abandoned, the `inventory` must ultimately not be affected. When doing an update with :quantity = 1 you can check affected rows to determine if the transaction should be accepted. http://php.net/manual/en/pdostatement.rowcount.php
Thank you!
More like Wordpress
Literally has 1000s of contributors (several other people besides me even have write access to all of Laravel) and release roadmap defined on documentation.
Why not just use the same API for your backend and Frrontend? Saves you having to maintain two different projects and saves you from duplicating logic
And here's the place to throw in [`TransactionalMutex`](https://github.com/malkusch/lock#transactionalmutex).
I don't think having them separated is a good idea. If you have any changes to business logic, you'll have to update two projects. This will inevitably lead to consistency errors, because we're all humans and we may forget stuff. Your web interface and (presumably) JSON returned in your API endpoints are two ways of *presenting* the same data. They're different views in terms of MVC. Therefore try to abstract your presentation (views) from logic and you'll live happily ever after. A good example would be this very page: remove trailing slash and add `.json` to the url now - and you'll get JSON. This is API-style way of presenting the same data - your post.
You could have an object (QueryBuilderModifier ? I'm bad at naming on the fly) with a static constructor `forUser($user)`, and a `newQuery()` method. In the `forUser` static method, extract what you need out of the user, and pass it to the private constructor to store it as private property on the returned new instance. class QueryBuilderModifier { private $type; public static function forUser(UserInterface $user) { return new self($user-&gt;whatTheHellIsMyType()) } private function __construct($type) { $this-&gt;type = $type; } public function newQuery(QueryBuilder $builder) { if($type === 'whatever') { return $this-&gt;addWhereClause($builder); } return $builder; } } That object would get passed to the repository, either via constructor or setter, and hide whatever complexity needed.
Shouldn't the business logic only be in one place in the first place though? I thought that would all go into the API side of things, and then the web interface code would just make requests to the API. Is is not standard for a site to use its own API? I don't know, I'm new to this whole API thing.
I would add to the Laravel this: * Documentation is targeted only at inexperienced. If you need details - forced to read the code. API docs are very lackluster. * Laracasts are a bane for experienced developers. A lot of answers on stackoverflow or otherwise just point you to a video. That is an unacceptable form of knowledge delivery when you need a single sentence answer. Not to mention it's a paywall.
Checked with [my first open-source project](https://github.com/vimeo/psalm) :)
Except the Drupal release process for a module does include a code and security review. It's a different approach than WordPress and other OS projects. It doesn't avoid these problems, because open source often means volunteers who can walk away, or in the case of the media module, die of ALS. Then of course how many people were running insecure versions of QuickTime when Apple said they wouldn't patch, and how many people were running insecure versions of windows after ms skipped a patch Tuesday a few months ago when there were published zeros day exploits in circulation. I know my shit doesn't stink. How does yours smell?
Added some more details about what the application will be
Fun fact: the guy working on the current state of the art for Go dependency management started working on the Drupal module and packaging system. He recently mentioned that on Go Time. https://changelog.com/gotime/36 Take that for what it's worth, I know this will bring an interesting crowd.
That process was abandoned and it's now pretty much a free for all, anyone can post full projects they just don't get Security Team coverage. Also I should point out, while many people do just install modules without any kind of vetting process, established agencies (like where I work) put an emphasis on reviewing the code of any new contrib module we use for the first time. 
It's probably not a good idea. You'll end up with a lot of duplication and things to keep in sync in two code bases. Obvious example : Eloquent Models. If you ever wanted to add a field in your database, you have either 1 model + migration + related codes to edit in both projects, or you end up creating a package used in both apps which is a pain to test (I'm not talking about automated tests here. Even manual checks would become painful).
Why would the web interface need to know or care about models at all though? The way I'm imagining things, all it needs to is either fetch data from the API (for GET requests) and use this JSON/XML data to render a view, or pass along data to the API (for POST requests). It doesn't interact with the database directly or anything like that.
Did you see the first link I posted? :P
I'm one of those project review administrators. The process was good and had a tough choice scrutiny, mostly thanks to Klausi (regardless of the Drupal drama recently). However, the projects kept coming and got out of hand quickly. Some projects were in the queue for several months, but responsive developers got through the queue Inna couple weeks or so. The vetting process is still there if you want to opt-in to security coverage. Pretty much similar to Mozilla add-ons now. 
So PHP is code that is interpreted by a server. It displays an HTML page according to the code on the server level. So you unless you have access to the original code, you are really only get access to the results. Not the original code. Even if you did get access it would be trimmed down to such an extent that you would not be able to use it, which can be done. All of the spaces would be pulled out and such. And it would be rewritten into something as close as gibberish as possible.
https://github.com/pizdata/oauth2-shopify-php/blob/master/src/Provider/Shopify.php#L52 Passing an array that you don't use, kind of strange.
Well that drastically changes my opinion about them. 
How about instead publishing a dumbed down way to attack via exposed vectors and force them to change the implementations before there are more users on the site and the threat becomes exponentially greater?
[@bugcrowd's latest tweet](http://i.imgur.com/fAWwPom.jpg) [@bugcrowd on Twitter](https://twitter.com/bugcrowd) - ^i ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
Laravel is a clear front runner in my view. It's easily robust enough and has a community which dwarfs Symfony's in size and speed of growth. For $99 you can start with Spark which will cover all of your subscription and billing boilerplate which save you thousands in development time. Laravel is much more pleasurable to work with than Symfony which means you'll never struggle finding good devs. Be wary of people who write off Laravel as good for "toy" applications but not good for "real" applications without offering any concrete reasons why. Comments like this are usually rooted in either parroting what other redditors have said or long term Symfomy developers who write off Laravel as the latest shiny toy because they are happy with their more familiar toolset. Symfony is not bad, that's not what I'm saying, many solid apps have been built on it, Laravel uses some Symfony components. But I think you'll be more delighted with Laravel in the long term.
Why not just use one Laravel project which is able to serve json and views at the same time? The only thing you'd duplicate would be the routes, but that's not a big deal. You could use an extended controller or trait or a dedicated class to handle responses. That way you could even use the same controllers for both aspects when needed. I'm using this approach in a project of myself, because there's an existing and running codebase which needs a few new features, while at the same time there's already a plan to rewrite the project with laravel (current codebase is awefull). Surely your approach could work too, but imagine you'd add things like authentication and some sort of ACL, then you would've to double check everything in both applications.
I understand your question. It's not so much about a Laravel frontend, it's about separating the data from the presentation. This has nothing to do with MVC, etc. That's a straw man if I can put it that way. I see the biggest benefit being a clean mental model. Build a backend that delivers data and call on it however you like. You can also do the same with your admin, which is just another frontend to authorised users. We already have many solutions that do that, or are devolving to do that, like Wordpress. Everything is just an interface to a data store after all. It doesn't have to be monolithic.
&gt; can you explain what the added value is of all this extra work and complexity of getting nginx/php to run under supervisor? The article is about a bash script that runs nginx and php-fpm. There is no need for supervisord. The point is there is no need to use supervisord. It solves some real problem like: 1. Logs have to routed to output. 2. If one of those process fails the docker container has to stop another process and exit. 3. Signals have to be properly handled. 4. some routine basic configuration at runtime. &gt; but basically any app requires some modules to be installed &gt; nginx modifications, &gt; in the end you probably need to alter the dockerfile, why not have everything in there? Let's say I have ten services working together. Services are run by docker. Every application has its own path and config options. Imagine how many files (dockerfile, nginx conf, php-fpm config) I should have to run them by building a unique image for all of them. What my infrastructure should look like? My approach speeds up a development process. I reuse same basic image for all of those service. Set some env vars and that's it. They up and running in a second. That's exactly a single concern as I see it. One docker container one web app. I run a container and I have an app on a port ready to work. Easy to distribute by the way. Take the https://hub.docker.com/r/payum/server/ as an example. It is a single container that contains a payum server application, php-fpm and nginx. You need only ONE container to run it as a web application. It perfectly extends a basic image with additional stuff: https://github.com/Payum/PayumServer/blob/master/Dockerfile
It depends on the size of your project. I would recommended different endpoints, share same code as business services and implement that via composer. As recommended above you have reusable business logic and could use it in web frontend, Rest api, commands. If you have a huge project I would recommend a microservice architecture. I prefer asynchronous microservices.
**How is the demand for procedural PHP developers vs OOP?** I am not sure what you mean by procedural. But i will assume you mean programming without classes?(Correct me if i'm wrong) - But PHP developers should know how to program OOP(Thats expected for every place that i've ever worked at) **Is a well-rounded front and back end knowledge base expected?** Depends on the job. If you're applying as a backend developer you should know a lot about backend, but it's not expected that you're some kind of a frontend master **What are the typical roles of standard developer? ** This is some of the tasks i have as a inhouse developer for a ecommerce site. - Maintain servers - Develop new features for the backend - Bugfixing - Develop integrations with a lot of different API's. - Drink coffe - Help internal staff with their IT problems We're 3 developers at my place. **What frameworks and/or resources should I familiarize myself with?** Well, depends on what you want to do. But i would definently recommend learning frameworks like Laravel/Symfony and learn how to make a good solid REST API. (And be a ninja at SQL) 
I had seen similar results and was disappointed because I really like the array map and filter functions. The good news is that without XDebug, the speed difference is a lot closer although for each is still a little faster 
One of the bigger contributors was probably stuff like this: $foo = array_map($arrayOfThingsHere, [$this, 'bar']); vs $foo = []; foreach ($arrayOfThingsHere as $v) { $foo[] = $this-&gt;bar($v); }
My first idea is pagekit üòâ
I would try increasing the timeout (https://getcomposer.org/doc/06-config.md#process-timeout). Looks like the trouble is at downloading the package and info json files. F the packages are slow t install, try downloading the `dist` version f the package (smaller size, one zip file). 
In my view, you gained both performance and readability! Nicely done
Not only that, but it's much more readable to folks who are coming into PHP from another language. I tend to avoid PHP specific looping for this reason... There is actually very little reason to use array map at all.
it's not more readable if you are familiar with more "functional" styles of programming.
 &gt; That said, how is the demand for procedural PHP developers vs OOP? Learn OOP. You might get unlucky and work for a place that does thing procedural, hates frameworks/makes their own. &gt; Is a well-rounded front and back end knowledge base expected? Be comfortable with front end, but since 5 years ago, front end isn't just html/css/javascript. There are tons of front end frameworks, ways to build and addons. &gt; What frameworks and/or resources should I familiarize myself with? Symfony since a lot of frameworks are built with their components. Laravel maybe if you want to work in an agency pumping out sites.
I see no reason to avoid features of the language just so that unfamiliar people can read it. That would be incredibly limiting. Also, it's not like this sort of function is unique to PHP.
 array_filter(array_map(function ($s) { return is_string($s) ? trim($s) : null; })); The first example has a lot of iterating compared to the second (one time through the array vs 3). That doesn't matter on a small dataset, but it will make a difference on a larger one and it will make more of a difference depending on how may times the routine is called -- even small differences add up if they are a hotspot in the code.
OK got it now. What you want to do is feasible and has been done in the past. Close to microservice architectures. The theoric advantages are that you can scale both project independently, and as long as you don't modify existant api comportment, you'll be able to work on one project at a time. The disadvantage is web front end app now has to make requests to the api, even for validating a web form for an api ressource, and you work on either arrays only, or some kind of model adapter. Lot of time, web will need aggregate data from several of your api endpoints. With a bit of caching it can be mitigated, but it's not as simple as theory makes it seem. &gt; Why would the web interface need to know or care about models at all though? Like I said, it's easier to reason on objects than array, at least to me. But it's not my main point. 2 things : * Do you really care if it knows or not ? Dogmatic academic purity is the bane of simple and easy to work with systems. * Microservices always (ok not always) goes with huge companies or multiple companies with dev teams working on 1 app. See google/IBM, this kind of things. I don't think you are that big, or have 2 teams. Unless what one might think, [monolitic apps](https://m.signalvnoise.com/the-majestic-monolith-29166d022228) aren't that bad, especially if you have only one team or few devs. In the end do what you want. But the whole distributed system era began not when we wanted to, but when projects woulnd't work in traditionnal monolith. If you know a bit of Ruby on rails, DHH (it's creator) is quite vocal on this subjects. And always remember, there is a bias in tech. The new shiny thing is shiny because you don't know it's flaws, unlike what you used before.
This. Edit: Dat hate yo ;(
array_map has the overhead of a function call for each element in the array, so yes it will be slower. In my personal benchmarks in a more production-like environment, it was never that big of a difference.
Those BC breaks are only relevant for library code and that should be designed well from the beginning anyway (in terms of: could this implementation ever change drastically? Then have an interface for it from the beginning). I couldn't care less if my IDE has to replace a few more occurences of a renamed type in my code base.
When does it differ?
 * Xdebug is a bitch to functionnal programming. Without it it might be a lot closer. * Cache it or queue it ? 20 array_map &amp; array_filter loops seems a lot in one request. * Offload work to the db if it comes from there ? It's better than PHP ever will be to work on data
Unless if it's something terribly complex that array map can simplify, I always use the language's for loop by default. Sure there are absolutely scenarios where these functions actually becomes a feature, but most of the time it's just for the sake of converting a very simple loop into complex looking one liners. Python developed are notorious for this and it's incredibly annoying.
You could try a [repo proxy](https://moquet.net/blog/proxify-composer-php/) - just found that with a search. 
All of these are excellent points. It really comes down to using the right tool for the job. Use a hammer on nails and a screwdriver on screws.
I'm not sure which way you are saying is "more readable", the foreach or array_* functions?
This is absurd. You shouldn't be limiting your code's readability so that the absolute least knowledgeable developer can understand what's going on. If we were to do that, we'd need to remove any PHP specific syntax and "wishful thinking" to actual code interpreters.
Note that there will be a patched version of the module available soon, as per the update on the SA: &gt; 2017-04-14 - A potential new maintainer is working through the process of fixing the References module. When this is complete a new release will be published and this SA will be updated. 
the foreach
If it's your goal to speed this page up more, drop the he foreach use and go with for. Significantly faster. Only get the count() of your array once and put it in a variable. If your arrays aren't standard 0..n indexes, use array_keys() and iterate that. 
Offloading to db is a terrible plan if scale is a concern. Adding more php servers is easy. Adding more db servers is not. (depending on your db and if you need consistent reads or not, of course) 
Yeah, I'm going to disagree with that. Readability is mostly subjective, anyway, but what we can all agree on is that the more you nest loops and conditionals, the bigger the cognitive load. I really hope we can agree that the smaller the cognitive load the easier it is to understand. 
we've got symfony/http-kernel sitting in front of things, so the every-request performance wasn't a concern here, more the unprimed-request performance.
This particular chunk of code was from a project that previously used it's own collections library, with this version being specifically written to avoid (amongst other things) using collections libraries. Or rather, it was specifically written to avoid using the collections library in question as a default return type for the large number of cases where it wasn't being used appropriately to begin with.
Well, I never said you should do it all on one line. In fact you definitely shouldn't. I usually do something like: $foo = array_map(function($b){ return $b-&gt;something; }, $bar); Not sure what is so crazy complicated about that, where only the most elite PHP hackers can read it.
This ignores the abstraction gain you get from map. For loops cause you think about each iteration (what the data is doing), whereas map causes you to think about what function you want to apply. I think that different way of thinking is useful. 
As someone who is in love with functional programming and uses it in its daily life, when it comes to PHP I usually prefer to just use a foreach. foreach is more idiomatic and always works, while array_map has issues with Traversable and other cases and the performances are often noticeably worse. I really hope that some decent functional module will be accepted into the php core. Until the day it happens, arra_map looks just like the wrong choice. 
&gt; "one man army", I don't see how it's different for Symfony ? Symfony is backed by SensioLabs which has many developers working on Symfony and there is clear flow on how everything is decided (including people not being an employee at SensioLabs): http://symfony.com/doc/current/contributing/code/core_team.html vs mainly 1 guy at Laravel making all decisions. &gt; My main problem with Symfony is Doctrine Doctrine ORM (which is different from Doctrine DBAL) isn't mandatory for Symfony to function (in fact it's not even made by the Symfony team). Using one to many relations is very easy with ORM so I'm not sure who you spoke on using 10 queries for that. &gt; "Staying up to date was not fun too" The BC promise of Symfony is awesome, yeah :) &gt; if you choose to split your code correctly and work with well tested library (like you would do with Symfony) I don't see any problem with using Laravel. Totally agree but I haven't seen any Laravel app created like this so far. 
I'm curious, did you try mapping something like this instead? function($e) { return $this-&gt;bar($e); } As compared to the array-as-callable syntax? I'm wondering if the checks PHP needs to do for that aren't optimized in some way. In either case, I would recommend what's semantically correct unless the performance change is huge since you'll get future optimizations, and map operations should be (on paper) one of the easiest things to optimize. 
I've not tested the impact of an additional 2 explicit function calls vs. an implicit callable, but if any of you who are fluent in opcodes could give some explanation? * https://3v4l.org/oqsTm/vld implicit array-style callable * https://3v4l.org/GD8H4/vld closure with explicit method call p.s. the reddit formatter is a pita.
It's a question of proportion. I'm not saying it's OP's case, but I've seen guys not even using SQL for basic ORDER and WHERE clauses... The only real answer is benchmark. If there is a shitload of ram available on the db server, why not. If it's already limited don't.
This time we had a release on the Ubuntu/debian repository of Ondej Sury before the announcement on php.net and I thought they just didn't get to it yet. Retagging a release is a big no-go... :/
Well that is more on a developer discipline i think. Explaining to everyone that you should always either convert the collection to array and return that or typehint a traversable of specific type when returning the collection directly. But i don't know your use case or the library so maybe this wasn't an option.
What's the benefit of using this instead of Twig or another template engine? Programmatically generating DOM makes sense in the front end where nodes are objects, but it seems unnecessary in the backend where you can simply use HTML. Your library simulates DOM, then renders it to HTML, which then has to be parserd into actual DOM in the browser. Looks like it adds an unnecessary step.
If you have to explain to everyone to always convert the value to an array, it would seem to be more effective to return an array and not gunk up the composer dependency graph with a package that isn't getting used most of the time :P
There is no firm date for a Laravel 6 because there is no need at this point for such a paradigm shifting change to the framework that would require such a version number change. If we get to 5.9 instead of going to 5.10 I will probably switch to 6.0 then. Core developers who do significant work: Mohamed Said, Jeffrey Way, Adam Wathan.
Ok, i'll try to explain. Collection libraries exist to make your life easier by creating code that is more readable. You need to do a complex operation on a set of data? You'll convert it to a collection and do it. Nice and easy. But passing a collection object around your application makes everything depend on the library that introduced it. So what you do is either convert to array before returning (which is really bad for large sets) or you typehint return value as traversable and then return the collection directly. This hides the collection object from the next layer of your application. When you need the collection operations again you'll wrap that resulting Traversable into collection. That is superfluous since technically the Traversable is a collection already but you've lost that information when you set Traversable as return type. So the library is being used, you just don't propagate that you are using it between layers of your application.
I'm not likely to use collections myself, but I'll keep in mind using Traversable as a return type instead of array for when it's necessary, thanks!
Thanks for the detailed feedback :) Yeah, I totally see your point. Another problem is that Soundless is probably be hard to use for web designers who have only basic knowlege of PHP. Funny thing is that at work we're going for the same approach you described: Tradtitional templating, but script/stylesheet tags are generated.
Thanks for your reply but this is simply not as clear as Symfony has it on their website. For a big(ger) company this can make a big difference, not future proof enough.
Best practices are to expose a single service out of a given container. It is more scalable however to separate php from the webserver, and less wasteful of resources since you can run a large amount of php fpm services out of less webserver processes. Ymmv. Kubernetes solves this dilemma wonderfully via adding an extra level on top, the pod. 
You wouldn't. Trust me. Don't touch ci with a barge pole. 
It doesn't tho on apps where you're trying to keep response times below 25ms. 
This is incorrect.
More people need to use phalcon, v3 is really neat and easy to get into. I looked at v2 awhile ago and it was lacking in what I needed.
learn OOP. just do it. I recommend Symfony if you're looking for a framework. It's well designed and maintained by some very good developers. 
&gt; It basically comes down to the fact that you have all the power of PHP available in your templates. That's exactly what PHP was originally created for... 
&gt;Retagging a release is a big no-go... :/ I'm not here to judge the development practices of The PHP Group. I'm just explaining the situation.
&gt; Therefore try to abstract your presentation (views) from logic and you'll live happily ever after. Where you put your logic? In controllers? Controllers should be just like adapters between HTTP and your application. So basicly there should be two sets of controllers which generates different responses. And probably there will be just different set of routes. &gt; remove trailing slash and add .json to the url now - and you'll get JSON. This is bad idea from consumers point of view (i.e. you have to write more code on client side just because someone was to lazy to make things right way).
Latency... If API is deployed near web frontend app then it will be much faster to get data on server side. That's why in javascript world there is so much noise around server-side prerendering. 
Fair point, it's more of a review than is present in many similar ecosystems, especially in combination with the fact that the security team, does respond and flag know vulnerable modules. 
&gt; I honestly think that they just don't know how to do this securely and need help with it. You don't get to make press releases repeatedly claiming to be "privacy focused", using the word encryption over and over, and generally claiming to be more secure than Facebook, if you "need help" with the basics like this. 
Did 7.0 change things? Because I know in 5 it was quite a bit faster to use for. And before anyone jumps on me, yes, I know who this is. 
 $_SESSION['__elgg_session'] = md5(microtime() . rand()); ... really? return 'https://chart.googleapis.com/chart?chs=200x200&amp;chld=M|0&amp;cht=qr&amp;chl='.$urlencoded.''; Good job. Make claim after claim about being privacy focussed, then report to Google. // Use last nipple of result I have to chuckle.
Thanks for the agreement, despite the hate :D
I should clarify. I didn't mean to suggest MVC doesn't separate data (models) from presentation (views). I meant that in the discussed context comparisons to MVC were not helpful in answering the question.
Would love a screenshot or three
Had used altorouter, and I can safely say it's very extendible. I had personally created a micro framework with it. Good Luck If you have any queries, create an issue in the github project of altorouter. I check there regularly
Nice! Documentation with photos, and even videos. But c'mon... No tests?
Well yeah but using PHP as a template engine echoing all the stuff is annoying. You always have to remember to escape your values manually or you got XSS vulns, all templates are mololithic, no possibilities for abstraction... I really tried to convey the idea of Soundless in the previous comment, and that is probably not what the creators of PHP had in mind.
Not entirely sure about the inner workings, but passing the reference to a collection object sounds way more efficient than passing an array, which is copied for each function call
On PHP 7 I have foreach being about 2x faster. I don't have PHP 5 builds around, but 3v4l confirms that it's faster there as well: https://3v4l.org/UYaFY What you *might* have in mind is that on PHP 5 foreach may trigger a copy of the array in some cases. In this case the simple for loop can indeed be faster: https://3v4l.org/UAn6M (Of course, any advantage it has in this specific case goes away if you have to call array_keys().)
How does overwriting the `$response` as the routes are being registered work? As far as I can tell from that example only the `/greet/Leo?salute=Hello` route will work, anything else will yield a 404 response which is the only `$response` assignment there that respects the previous value of it.
Didn't think I'd ever see this here.
Using mysql_connect is completely deprecated these days. This is not stated by me, but by the official PHP manual: http://php.net/manual/en/function.mysql-connect.php Switching to PDO have many benefits, including prepared statements.
Yeah, that's the better way. Or if you are on 7.1 or higher just typehinting iterable which is an abstraction above Traversable and array.
Common interface for [wifi positioning services](https://github.com/tuupola/whereami). Includes network scanners for macOS and *NIX based systems. Uses [HTTPlug](http://httplug.io/) internally so you are free to choose the HTTP client implementation such as curl or guzzle.
&gt; Controllers should be just like adapters between HTTP and your application You're right, no one is questioning that. &gt; This is bad idea from consumers point of view (i.e. you have to write more code on client side just because someone was to lazy to make things right way). Could you elaborate please?
Yeah you got me... Put them off for so long that now it's just overwhelming. But I'm hoping to have them soon, just need to sit down one day and knock a few out and then work from there.
Always nice to be reminded that my entire PHP career is built on the shoulders of C coding giants. Kudos.
Found the UA shill... Funny thing is you don't get a refund if you don't fly unless you buy a refundable ticket; you might get lucky enough to get a credit. So they profit twice. Its the equivalent of you buying something for in store pickup and someone else buying the same item. First person to the store gets it and the person who you beat doesn't get a refund. Or they only get offered store credit. Its pretty hard to defend as a business practice when you apply it to other industries. Unless you're a shill for those as well.
Hi ! I know about the HTML5 autofocus but my page is a single page landing page with a bit of text, a image and the form. So on mobile using the HTML5 autofocus results in the page being focused on the form once loaded every time. On a large screen this is no problem but on mobile, despite being a responsive page, its not what i want. I would like to focus the php form only when there is a error with the input. It would be great if this could be done with php code.
I mean that when you have some kind of services which communicated using http, this doesn't mean you have microservices or any kind of distributed system.
Many client implementations already supports basic structure of URI for manipulating resources. This simplifies process of integration with API. Also it much easier for clients to specify consumable format via `Accept` header instead of file extension. And again, authentication may be very different for web and for http api. Also URI for web and json api version could be very different. There is no any point to force API to have the same routes as web version. Basicly API is very different from simple WEB pages (even if it very similar in some aspects) just because API rarely would have benefits of HATEOAS which WEB relies on.
&gt;So on mobile using the HTML5 autofocus results in the page being focused on the form once loaded every time. Sorry we might have misunderstood each other here. What I suggested was to conditionally render the property, only if the error was present for the user. So in your template, a simple `if` statement on your input field, which checks for the presence of your error, and if it's there writes the autofocus property. &lt;input type="text" &lt;?= $error ? "autofocus" : "" ?&gt; /&gt;
Will it be possible in future to see opcode dump (or heap dump) on already running process? Without need to start new process.
 - [Michael Feathers - Working Effectively with Legacy Code](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052) - this book contains some helpful thoughts on how to write tests. This is important to know what you need to test rather than just stupidly cover lines of code without any profit. - [Kent Beck - Test Driven Development by example](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530) - to learn how to do this red-green-refactoring cycle. - [Robert Martin - Clean Code: A Handbook of Agile Software Craftsmanship](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882/ref=pd_bxgy_14_img_2?_encoding=UTF8&amp;pd_rd_i=0132350882&amp;pd_rd_r=EZAM54QVEMXYT8335QCE&amp;pd_rd_w=JR51o&amp;pd_rd_wg=qorr6&amp;psc=1&amp;refRID=EZAM54QVEMXYT8335QCE) - this book is more like "how to build your objects". Basicly TDD won't help if you don't think enough about how objects are interacting. Your tests are like client code for objects you are designing. They forces you to make more easy-to-use interfaces and think more about decomposition.
Had to look that up. Good call 
&gt; Found the UA shill... Oh yes, they pay us to go on /r/programming/ and weigh in in favor of the airline industry when someone talks about MySQL. &gt; Funny thing is you don't get a refund if you don't fly unless you buy a refundable ticket; you might get lucky enough to get a credit. A refundable ticket means that the *passenger* can decide to return their ticket for a refund, even though the seat is waiting for him in the airplane. But if the *airline* decides not to honor your ticket, you're always owed a compensation, no matter what kind of ticket you bought. But if you've flown less than one times in your life, I can imagine those complex terms can be confusing. Glad to help. &gt; Its pretty hard to defend as a business practice when you apply it to other industries. I mean yeah, especially when you make things up, and then you have to be outraged about it. &gt; Unless you're a shill for those as well. Oh yeah, come have a coffee with me sometime. I'll show you my entire portfolio of customers. It must really suck to post comments like free, like you are doing.
Well I am sure we all agree on that.. but making unrealistic claims and having shitty marketing is not a reason for the users that use the product to suffer...
tl;dr Nothing that even remotely comes close to convincing me that WordPress should ever be considered, or called, a "Development Platform". It's okay though, I often get paid very well to rebuild projects started by agencies that convinced their clients it could be used as such.
The PHP source code comes with a very useful .gdbinit file that contains a few macros you can use to inspect the interpreter state of a process you've attached gdb to. This has helped me a few times to track down infinite recursions on a production system
Thanks for the extended validation of my comment!
I think it looks fine. Some might say "it's best to prefix getter methods by `get`" i.e. "getTotal()" not "total()" etc. but this isn't that important. The classes do what they're supposed to do. Frankly, the procedural/functional version is ok, too. The only thing that stands out oddly, I feel is this function `get()` which seems like a way, way too generic of a name for any library to use. If it was `get_system_info()` or something similar, it'd be much better IMHO.
NPE is acronym for Null Pointer Exception, aka "call to a member function on null"
Thanks for the feedback, in your opinion is having the Statsy.php file in the OOP version a good idea. It makes it so you only have to include 1 file then you can use any function from that one class instead of having to set name paces for all the classes and then calling each object before you can use it?
I was planning on making a composer package when it was done, but the OOP will be replacing the normal version it doesn't have any dependencies so im a bit confused what you mean by this part? 
I thought you might want to keep both. Keeping just the OOP version is nice, as well.
Ill probably just make it into a separate branch for people who dont wanna bother with the OOP version tbh 
I did relise this problem sort of as in i realised you would be calling an entire object but i dint know how to improve it but im a bit confused about what that construct function does and how it fits in and how it would be used sort of thing.
Facades are just service locators for classes which are bound to the service container. Want to use a different implementation? Just bind it to the service container in a service provider (1 line of code). Still not convinced about facades? Don't use them! There's nothing that facades can do that can't be done with regular dependency injection or resolution out of the container. Eloquent source code is actually quite straightforward to read. Yes there are big classes but these are framework classes. They are well tested and well documented and I don't think it's necessary to apply the same standards of smelliness to non-userland code. You aren't personally maintaining Eloquent, so it's not really something you have to concern yourself with. If you really don't like eloquent, you can use any alternative you like for database access. Laravel doesn't lock you in to anything. 'eww' is not really a reason why Laravel's global helper functions are bad, but if you really find them so offensive then don't use them! Once again, they are just service location over the IoC container so actually they don't lock you in to anything, just provide some very handy syntactic sugar to keep things neat and readable. But there's nothing you can do with a global function that you can't do in several other ways so that's just a personal choice in the end. As for breaking Laravel up into several services, I'm not really sure what about Laravel would make that more difficult than Symfony. Yes it's possible to code your app in such a way as to make that more difficult, but that speaks to the quality of the developer rather than that of the framework. There are good an bad Laravel developers just as there are good and bad Symfony developers. At the end of the day, it's really personal choice. I don't think Laravel or Symfony is the "right" choice. Each are strong options with strong communities and by all indications will be around a long time. Each are composer based, fully modular, use modern OO PHP and are fully testable. Each are performant, and highly customisable. Use the one you're going to be more excited about seeing in your IDE every day, and for me, having used both, that one is Laravel. For you, it might be something different.
This is exactly what i was looking for! i knew it was bad practice to build a object everytime i call it but i had no idea how to fix it thanks very much!
This sounds like a very good idea! Im just a bit confused how the interfaces would fit into the current implementation or if i need to rewrite it which im completely fine with as i want to make it the best it can be do you have an example of how this would work? 
This is certainly true. Bigger does beg the question though, what is it about Laravel which has caused such growth above and beyond Symfony. To some degree it might be because Laravel came later and so was the newer shinier thing for a time, thereby taking advantage of a certain level of bandwagonism. It might also be true that Laravel has just been lucky to stand on the shoulders of Symfony, taking the best components from Symfony but then being free to build from a green field on those areas where Symfony lacked. I think a healthy level of credit has to be given to it's developer friendliness, both for rapid prototyping but also long term maintenance. I can't offer any empirical data to support my claim though, so in the end I'm just speculating.
Thanks very much for you help i really appreciate it i definitely have alot of work todo!
that would still require the debug symbols being available which isn't/shouldn't really be common on a production machine.
WP is trash.
But the problem is all the listings on Indeed want PHP developers who have knowledge WordPress.
Yes you can run it locally. Search *local WordPress installation* As others have said, better frameworks exist, but there's still a lot of demand in WordPress given that its the biggest CMS and growing, so its not the worst thing to get into. If you have the time and the energy, dip your toes in a few other frameworks to compare.
That's because no one wants to work on WordPress projects. If hordes of eager, smart developers were filling those positions, there wouldn't be positions to fill. I won't tell you what to do, I'll just tell you how to make the correct choice. If you're in this for the money, you're not looking to learn modern PHP practices, you are fine with going through bad code on a daily basis, and you are fine with the product of your work being relatively fragile sites produced by combining poorly written off-the-shelf WordPress plugins, mostly by amateurs, then WordPress can be a nice career for you. If not, well, certainly download it and check it out, but keep in mind it's absolutely nothing like what PHP applications tend to be nowadays. It's a real living fossil, WordPress. 
Hmm, you won't convince anyone. You might as well try selling Windows at a Mac conference, or teach hackers how to bathe. Losing battle, but I applaud the effort.
I don't know if your area, but if you are looking for a stable job, I traditionally see more jobs for zend, symphony, cake, and lately I'm starting to see Laravel as well Listen just my opinion but don't just go for the listings, WP has a lot of demand but also a shitty pay, having to work in old School PHP knewl... Cliche as it sounds, focus in something you actually enjoy, the right job will come for it 
&gt; That was kind of rambling. Agreed :) Anyway I agree on your concerns. As usual, it's a bit of a case by case decision. 
I'm surprised you didn't get shit yet for putting Laravel and OOP best practice in the same sentence on this sub... Not that I complain, I'm a Laravel guy myself.
This is definitely one of my favourite PhpStorm plugins... please keep up the good work! :)
I'm looking into it as well, now that Docker makes it much easier to distribute and test on specifically configured PHP environments.
https://laracasts.com/series/php-for-beginners
Just a healthy warning: sometimes you'll read about some brutally simple Technique, that feels intuitive, and promises great returns of investment (for your time and effort) for every type of project you'll ever manage. Then as you try to implement it, the promised land always remains in the distance, and suddenly find yourself neck-deep into Methodology presentations, blog posts and guides, and you still have no idea how to do the Technique "correctly". This is just what bait-and-switch feels like. Read books, learn techniques, but always be skeptical, especially if it starts simple and then you're repeatedly told that if you don't like the exploding complexity "you're doing it wrong, but learn how to do it right by buying our book". TDD is useful *sometimes* and it's as simple as "write tests, then write code to pass them". If it takes a giant book to figure it out, maybe you've figured it out and it simply doesn't work for your type of projects. **TDD is not suitable for every project, and it's not suitable for all components of a project.** Ideal components that can be TDD driven are those who have clear, simple, small inputs and outputs and are **pure**, as in they have no observable effects (like editing files, running SQL queries etc.) other than their output. Examples include: - Data transformation (from one structure to another), validation, filtering. - Parsers, compilers. - Encoders (video, audio, other data). - Calculators (say tax return software, mortgage payment calculators, loan interest calculators etc.). There are plenty more, but those are the kind of components I do TDD with. For many I don't do TDD. And don't forget: *you can test everything MANUALLY, but you can't test everything AUTOMATICALLY*. Any real project would have a mix of both. Say most techniques for unit testing GUI are mostly limited to detecting basic regressions, and will break on innocent changes, while missing whole classes of issues that would render you GUI unusable. If you can't automate testing effectively for a component, you can't do TDD, obviously. Consultants and fanatics will tell you can unit test everything - it's a lie.
&gt; WordPress‚Äô big development platform secret is that when you use WordPress you don‚Äôt ever touch WordPress. Instead you write a Plugin. That's a pretty big secret. I feel like I've just discovered an entire new world of possibilities. ^^/s BTW, the entire article is like that. It just uses marketing phrases to tell you stuff you already know just by being a PHP developer and occasionally hearing about WordPress.
This is more like ATDD. Useful but not as useful as TDD. But yes, if your application doesn't contain any logic (i.e. a lot of infrastructure problems rather than domain) then maybe you don't need TDD.
&gt; are pure Mocks are something that verifies side effects. I highly recommend this video: [J B Rainsberger - Integrated Tests Are A Scam](https://www.youtube.com/watch?v=VDfX44fZoMc) &gt; Parsers, compilers. It's very hard to make compilers using TDD. So again, TDD is not best way to develop parsers/compilers. You could use ATDD instead. &gt; Any real project would have a mix of both Agree. &gt; Consultants and fanatics will tell you can unit test everything - it's a lie. There is such problem: testing for the sake of testing. 
Wordpress is just a CMS. and it does "ok" in that field. 
&gt; Mocks are something that verifies side effects. I didn't say mocks can't verify (some) effects, but that's not "ideal" right. I listed ideal cases for TDD and unit testing in general. The less pure something is, the more hairy it becomes to test. And then there are some things which are nearly impossible to mock effectively. For example SQL code generators. You can run it against the real DB, but this means you didn't mock the DB. You can check for specific strings of SQL, but this means trivial changes will break your tests, despite your code would run correctly against a DB. You can use something to normalize or parse SQL and check an AST, but that only slightly alleviates the problem, it doesn't solve it. &gt; I highly recommend this video: J B Rainsberger - Integrated Tests Are A Scam I might check it out, but just the title turns me off and tells me I'll be sold silver-bullet B.S. I'm a pragmatist. I hate consulting-speak. I like pragmatic solutions. I certainly have mocks to eliminate effects of otherwise effectul component, but I also have integration tests. &gt; It's very hard to make compilers using TDD. So again, TDD is not best way to develop parsers/compilers. You could use ATDD instead. The boundary between TDD and ATDD is quite fuzzy here. The "unit" here is the compiler, or depending on how complex it is, and how fleshed out its architecture, the unit may be particular stages of the compiler (lexer/tokenizer, AST parser, optimizers, emitters). Putting definitions into too narrow categories can sometimes be counter-productive. It leads to an explosion of overlapping and inconsistent terminology, where most discussions end up into arguments about words and definitions, rather than about substance. TDD to me simply means you write tests, then write code to pass them, then you can optimize and refactor. From that point on, the details entirely depend on which flavor book and presentation you watched.
There's a crowd funding campaign that ends in a couple weeks. Let's try to raise as much as possible. 
This could be a radical change, but I think there's an opportunity to make the Statsy class return instances of Memory, CPU, etc in a way that caller can chain to get the desired value. For example, the Statsy class should return nothing but objects of each component. `$statsy-&gt;memory()-&gt;getAvailable()` and `$statsy-&gt;cpu()-&gt;getCores()` looks way nicer IMO. Also consider requiring PHP 7 at least (may be not possible for a library like this), and the library can use scalar type hints. The cpu getModel will return a string, and getCores will return an int. It's nice to make PHP assert that. You can use phpdoc declarations for PHP 5. 
[Growing Object Oriented Software, Guided by Tests](https://www.amazon.co.uk/Growing-Object-Oriented-Software-Guided-Signature/dp/0321503627) is hands down the best TDD book out there in my opinion.
&gt; Another problem is that Soundless is probably be hard to use for web designers who have only basic knowledge of PHP. And then it becomes pointless. Why else make it harder for yourself and the program itself?
What I do is I write my endpoints as objects that take in arrays/DTOs and return arrays/DTOs. Those arrays/DTOs are JsonSerializable, nothing complex about them. Then I have a reusable ApiController where I just pass the endpoints in, and boom, it exposes the API over HTTP. No routes, no nothing. Zero effort. Now I can write my web site as a separate **module** which is a part of the same project, but it doesn't access the back-end internal details, it goes through the endpoint objects (still native PHP calls). This means my PHP controllers use the *exact same API as my client-side JavaScript does*, but without going through HTTP. It makes for very decoupled, very light, very uniform architecture, but without the overhead of maintaining multiple projects, or pointless overhead like, say, having my web site having to call my API through HTTP. So **tl;dr** I'd say isolate the web site from the back-end details, but you *don't* have to make it a separate project, and you *don't* have to go through HTTP or even internal emulated HTTP requests. Make the API universal, and use a controller which can expose it over HTTP as-is. It only makes sense to isolate the back-end APIs in a separate repository once you start having multiple clients, each on a separate team, and so you want the web-site team to have their own repository, and evolve relatively independently.
The "view" isn't request/response, it's just the response. And the request is actually the "application events" which controllers process. Patterns sometimes are about a PoV, although I don't quite feel there's a PoV where saying the view is a "request" makes sense IMHO.
This is great. Seriously this is one of the last errors that commonly happen at my company that should‚Äòve beed detected during the static analysis. This is enough to want me to use this plugin
Yep, this type of issues happens all the time and we finally got to the point when we can start reporting it. There is space for improvement and some limitations (https://github.com/kalessil/phpinspectionsea/blob/master/docs/probable-bugs.md#null-pointer-exceptions-prevention), but I hope we'll find a company who will sponsor further work here.
Well, if you have DOM at the backend it means you can do things like: - Pass generated HTML through filters, decorators with little effort. - Produce code non-linearly, for ex. have a widget in the middle of your `&lt;body/&gt;` insert a new script in `&lt;head/&gt;`. - Validate the structure strictly even if a good chunk of it is produced dynamically (and hence static validation wouldn't be enough). In theory it's nice. It allows you to do more. In practice, I've done this and the benefits aren't worth it, or there are alternative solutions to the features it allows.
&gt; The "view" isn't request/response View is representation of model. And by model i mean application state. Http response is just representation of application state and it should be considered as view in terms of API. As for web pages - http request also should be considered as view since html stuff is just part of the resource and whole resource includes it's metadata (headers). Also there is redirects which also represents state transition. &gt; the request is actually the "application events" Not application but view event. It's like event from clicking on button. Controller/adapter then converts it to application event (i.e. pass message to application). &gt; saying the view is a "request" In [original MVC paper](https://heim.ifi.uio.no/~trygver/1979/mvc-2/1979-12-MVC.pdf) there was separate "editor" entity. It's like UI controls in the view layer and it generates events which was handled by controllers. But because 3 letter abbreviations [are cool](https://en.wikipedia.org/wiki/Three-letter_acronym) editors was skipped and thous events are part of view layer. So if we think that request is just event which describes some kind of action, then it belongs to view.
[Very, very often](https://beberlei.de/2013/04/12/traits_are_static_access.html) :-P
A poor craftsman blames his tools. My traits are very benevolent and virtuous. They're great for, among other uses: - Default interface methods. - Reusing one-liner delegate methods, for ex. `public function doFoo() { return $this-&gt;delegate-&gt;doFoo(); }` Excellent for decorators. - Reusable magic methods (getter/setter helpers, mapping closure properties to methods, and methods to closure properties, etc.). - Private/protected methods that use reflection to work on the current class. - As a temporary measure for sharing implementation in private parts of a library/app (i.e. traits as an internal detail not visible to library users), where single inheritance is not sufficient, or too restrictive due to LSP.
Would you be so kind as to elaborate a bit on your points? Perhaps a li'l bit of example code? :)
Well, I'm happy to elaborate, but regarding which points, and what questions do you have about them?
&gt; As in "the response is the view, but the request is not the view". It also contains client specific representation of data. It's definitely doesn't belongs to application. &gt; Now I see you're saying "the view listens for applications events" I didnt say that. I sad that some adapter/controller listens for view events and then ask application to do the job. &gt; Point is HTTP maps to MVC well: No it's not. If you don't have active view (and you don't with http execution model) you don't have MVC. &gt; In a hierarchical view of MVC, three types of components is enough. My point was that components not important, important is how they interact with each other.
&gt; It also contains client specific representation of data. It's definitely doesn't belongs to application. When we're talking about a web site... the client is part of the web site application. In some cases it's even most of it (like JavaScript single-page-applications). Architectures can cross the boundary of a machine, and sometimes a language. Especially for HTTP and browsers where we pretty much have no choice about it. &gt; No it's not. If you don't have active view (and you don't with http execution model) you don't have MVC. We have a view that sends back events to the server in the form of HTTP requests, be it from HTTP forms, or JavaScript AJAX requests. What are we missing to call it an "Active View"? &gt; &gt; In a hierarchical view of MVC, three types of components is enough. &gt; My point was that components not important, important is how they interact with each other. Sure.
It's like a bastardized form of composition.
Third point, reusable magic methods. Those are magic methods: http://php.net/manual/en/language.oop5.magic.php The way most of those are defined, you require cumbersome boilerplate to do basics, like dynamically defined properties. But you can implement a reusable implementation in a trait, which provides you with a more convenient interface: class Something { // Defines methods __get(), __set(), __isset(), __unset() and protected method defineProperty(). use Properties; function __construct() { $this-&gt;defineProperty( 'height', function () { // Getter logic. return 123; }, function ($value) { // Setter logic. throw new \Exception('This value is readonly.'); } ); } } $x = new Something(); echo $x-&gt;height; // 123 Fifth point, sometimes you want to share methods between several classes, but you don't want to make them part of the same inheritance tree. Typically a more robust approach is to use object composition or export the repeated logic to static methods in another class. But as long as the trait is not a part of the public API (i.e. users don't see or use the trait), and you don't need the flexibility of object composition, you can share similar code through traits for a little extra simplicity and performance boost (small one, nothing big). Consider point five a "micro-optimization". It's not as essential as the other uses, but it's fine when used smartly. The key to using traits well, especially as described in point five, is to not couple yourself to them too tightly. Make it so it's easy and quick to refactor and replace a trait with something else without breaking a lot of code. This is one reason why I rarely use traits across libraries (i.e. I avoid having a library expose a trait to users and say "use this trait to access some feature"; I keep trait usage "local", so I can refactor both the trait, and the classes using it in one go). I only use traits across libraries when the functionality is very fundamental and handy, like the properties example above. Such traits are rare.
Thank you all for the advice and resources! I greatly appreciate it.
That's a different tool, not really comparable. Php Inspections (EA Extended) is a plugin for PhpStorm/Idea Ultimate with on the fly analysis and quick-fixes functionality - at the current state, the plugin is kind of intelligent development assistant. It covers: - architecture related issues (e.g. design pattern violations) - weak types control and possible code construct simplifications - performance issues - non-optimal, duplicate and suspicious "if" conditions - validation of magic methods usage - regular expressions - validation of exception handling workflow - compatibility issues - variety of time-consuming bugs - PhpUnit API usage - security issues - and much more
A few things: ClassName.class.php is a bit outdated. Read php-figs psrs, even if you find a few minor points you disagree with, things like PSR-4, which talks about auto loading is pretty much standard at this point. 
As hard as the JS community is about composition over inheritance, you think they'd adopt traits instead of their bastardized cumbersome boilerplate to avoid doing `class A extends B`.
&gt; TDD is not suitable for every project, and it's not suitable for all components of a project This is the main reason why I am looking for a good resource on TDD. Like you said, if it takes a giant book to figure out how to write tests and write code to pass them, then something is wrong. I'm more than capable of writing unit tests, but there are certainly some components where I know I could be doing it better. Just like any topic in software, it doesn't hurt to set aside your ego and have resources you turn to for advice. I'm not looking for some Bible of TDD but I am looking for a good read written by someone who really knows what they're talking about. From there I can hopefully learn a thing or two and be critical of the parts I may not agree with or seem too good to be true.
I'll take a look, thanks!
Thank you for the replies. I took PHP and I enjoyed it along with C#. My strongest language is Java learning Java Enterprise Edition and connecting to Oracle 11g. I've been looking on Indeed in the Atlanta Georgia area. What about LAMP? Is that the Linux answer to XAMPP? What other skills compliment PHP? 
I don't have a specific opinion about traits, but: &gt; A poor craftsman blames his tools. My traits are very benevolent and virtuous. &gt; They're great for, among other uses: You could say this about pretty much every "bad" language feature. There's always going to be good uses for a feature and there will be people who use it the right way, but part of good language/API/framework design is that you don't want to create something that makes it easy for its users to abuse or write poor code.
EDIT: Since I'm being downvoted, I'll add that several months ago, [I mailed the PHP maintainers](https://pastebin.com/MmG9FQEK), and they confirmed "traits are a limited form of multiple inheritance." ---- [Traits don't do composition, they do inheritance.](https://www.reddit.com/r/PHP/comments/65uyv3/are_traits_evil/dgdqlae/) But if you want to same effect as traits in JavaScript, then we can do class factories. class Hello { sayHello() { console.log('Hello '); } } const WorldTrait = (Base = Object) =&gt; class World extends Base { sayWorld() { console.log('World'); } } class MyHelloWorld extends WorldTrait(Hello) { } o = new MyHelloWorld(); o.sayHello(); o.sayWorld();
Yes, I know that, but the convoluted shit the JavaScript community comes up with to avoid typing `extends` is astounding.
I use traits/mixins(JS and python) often and the biggest hurdle that I've run into is method naming collisions. I found it useful for giving common functionality to various objects (surprise), but I've sice refactored my code because I felt like things were a bit easier in the long run Went from (python): class TagMixin(object): def add_tag(self, tag): ... def get_tags(self): ... class Person(BaseObj, TagMixin, MediaMixin): ... person.add_tag() # .get_tag To: class TagManager(object): def add(self, tag): ... def get(self): ... class Person(BaseObj): Tags = TagManager() Media = MediaManager() person.Tags.get() #.add etc I know PHP doesn't quite support class assignments as members like this, just illustrating a point
Still no. Implementing wrapper calls to access shared methods is still boilerplate (i.e. unnecessary code). Aspects and Traits (and other language equivalents) have a lot in common, addressing this situation. I don't understand the past and present attempts to paint it as something odd or bad.
&gt; Traits aren't composition, they're multiple inheritance. No, they are not. Classes that use a trait are not subtypes of said trait. It's not inheritance by any definition, it's just a form of code reusage. 
I don't believe the language should be in the hand-holding business. It should assume general competency, otherwise things get dumbed down. You can see this in Git, Linux, etc. Those things have no problem with you deleting your entire hard drive or destroying a 10 million line code base. It's not their responsibility.
It's fairly impressive that the php7 core team was able to release something that competes well with HHVM from a performance perspective. I assume they are working with significantly fewer advantages and resources than Facebook, so that's a pretty nice result.
i.dont.know.what.your.are.talking.about();
Eventually NikiC stands somewhere on top of the human pyramid with at the lowest levels Newton &amp; the giants on whose shoulders he stood, but I guess skillsofanartist's point is that many people need telescopes to see the top from where they're standing.
One thing I didn't see here yet, an annoying thing is support in IDE's. You just can't do things like following function calls,because the trait can be used by different classes. Also, this : http://hhvm.com/blog/9581/trait-and-interface-requirements-in-hack
I don't know what kind of traits other people are writing but I haven't yet written one for summoning otherworldly, extra-dimensional, or supernatural forces or beings. ... should I?
That's one person, not "the PHP maintainers". (Good luck getting everyone with php-src karma to agree on anything.) For what it's worth, I would personally describe traits as composition only ‚Äî sure, some of the problems they solve are problems that other languages _do_ solve with multiple inheritance, but traits are (intentionally) invisible from an object hierarchy perspective.
Any tests?
&gt; the client is part of the web site application This is quite complicated. Basicly what we see on web pages is just how browser interprets resources. We also have code-on-demand for interactivity. But the most important in web is resources. Just hypertext + unified interface. Browser just knows how to interpret this resources. So from client-side perspective "representation" of state machine which drives web app is http requests/responses. &gt; (like JavaScript single-page-applications) SPA are different from simple web applications since it doesn't necessarily relies on hypermedia controls. &gt; What are we missing to call it an "Active View"? "Active view" doesn't require any controllers to work. It listens for changes of model (via events for example) and update itself by taking data directly from model (application state basicly) without any mediators. HTML forms are just hypermedia controls and ajax requests are more like part of code-on-depend.
I found it pretty much helpful as temporary solution during refactoring of legacy code.
&gt; never from the outside-in? Search for "integrated tests are a scam" &gt; Not sure what you mean here. Value of TDD is that it help you to design your objects and how they support they contract. &gt; I think the distinction between ATDD and TDD is really so blurred Acceptance tests are pretty much different from unit tests and they have different goals. &gt; I don't do any front-end testing, as this is too painful and low value You could perform acceptance testing on application level (using services directly) without any UI. 
&gt; I'm a pragmatist. I hate consulting-speak. Then you'll probably will like it. &gt; TDD to me simply means you write tests, then write code to pass them To me TDD is not about tests. It's about design your objects using tests as client-side code (i.e. consumer of object). Tests are just side effect. 
Yes, in case of Debian 8 when you need it to work with PHP 5, and I aggregated latest content for PHP 7 and latest versions of Nginx, MySQL, etc. Much changed since Debian 8 initial release, and mostly in a better way.
TCP connection.
I personally like the approach Martin Fowler suggests in his article "[OverloadedGetterSetter](https://martinfowler.com/bliki/OverloadedGetterSetter.html)": &gt; I'm not proposing that Java's ugly getHeight() / setHeight(100) convention is better. I think using a bare value for the getter is usually the best way. My preference is to make any setter clearly stand out. In other words, a getter for the `foo` property would just be `foo()`, but the setter would be `setFoo(value)`. Of course, we also want to limit getters and setters in our objects when we can.
Shouldn't these slugable, sortable, etc interfaces? You can have multiple implementations, just not inheritance. 
But if an attacker somehow gets your refresh token -- can't they use it to refresh which gives them a new refresh + access token and then just continue doing the refresh with the new refresh token?
Some more images fresh out of the new v.0.6.0 beta: http://imgur.com/a/HoxHJ
That argument would seem to strongly support the case for traits being a form of inheritance. If I have a class `Dog` and a trait `BarkAbility` that defines a `bark()` method, and then I do `use BarkAbility`, my `Dog` object literally **is** an object that has the ability to bark; that ability has literally been copy and pasted into my code at compile time, so it's as if I had written a bark ability directly into the class. Which is (I think obviously) an "is a" situation. Composition would be something like where my `Dog` object has a reference to another `Barker` object that can actually bark, but when I use traits there is only a single object. That's much closer to inheritance than composition in my eyes (and suffers from the same strengths, the same drawbacks, etc).
They did: `--no-preserve-root`.
Legacy project? Project aimed for shared hosting?
I think you're too hung up on nouns. It's true that, grammatically speaking, nothing can have an "is a" relationship with a verb, but the lesson here isn't that things with verb names can never participate in inheritance. We're talking about programming, not grammar. &gt; doesn't make that Dog "is a" BarkAbility Grammatically, no. Programmatically, yes. It is innately an object which has a `bark` method, and it can bark because of what it *is*. It *is* a barker, if you want. If you want an example with a noun name, one project I work on has an Entity trait, which is applied to domain objects that can be persisted to a database. If a domain object uses the Entity trait, then it *is* an Entity. (It's not a great design, but that's a seperate issue...) &gt; You can't use a trait as a type. Of course you can. :) Not in PHP, but that's a limitation of the implementation, not something fundamental to the concept of a trait. And we usually work around it by pairing traits with interfaces, and you *can* use interfaces as types. &gt; But inside "foo" I can only refer to methods defined in the Barkability interface. Noting else is visible. That's totally, totally false. Not sure where you went wrong, but you might want to recheck that. :) Your IDE won't type hint the other methods, but you they're still there, because what you have there still IS A dog. And also a Barker, or whatever noun-form you prefer. And if you have two "is a" relationships, then you've got something which looks a lot *like* multiple inheritance. &gt; This is because there isn't "a thing" such as a BarkAbility, i.e. BarkAbility is not a type. Which is another reason why we're dealing with something which is much closer to inheritance than object composition; a BarkAbility is not an object, cannot be instantiated, and cannot be referenced. There is literally no way for an object to "have" a BarkAbility, I cannot have a subtype of the `Dog` class with multiple BarkAbilities, I cannot replace the BarkAbility in one `Dog` with the BarkAbility of another, etc. All of which I would be able to do with composition. ...that being said, I think this conversation has got far off track. Traits are not identical to multiple inheritance, and if you think the differences are more important than the similarities, then sure, okay. :) Edit: Also see /u/FruitdealerF excellent comment [here](https://www.reddit.com/r/PHP/comments/65uyv3/are_traits_evil/dgeyndv/). Traits fundamentally *act* more like inheritance than composition, and have the strengths and weaknesses of the former, not the latter. The argument about "is a"/"has a" misses the point; those are just heuristics to help you figure out which you're dealing with *in general*, not actual definitions.
kill me
&gt; Ah i see you're a man of culture as well I loved to give following url as reference: http://www.christianheilmann.com/2010/08/13/can-we-stop-with-the-ninja-and-rockstar-hype-already/ In short: Ninjas don't want to be known, they want to live in darkness and kill people. Rockstars usually are assholes that want to be the ONLY famous one and bad working with others. (Ignoring bands that actually can work very well as team)
To me it cheapens my career, and makes it sound like some sort of position at a reverse funnel company
If this is your first project: congratulations. Personally I wouldnt use library and here is why: * It lacks documentation * Code needs improvement * Require? Please make it compatible with an autoloader (see PSR) * Why use html in Exceptions? * Document methods and properties Probably some more things, didn't so a proper review. Please have a read about PSR as well.
&gt;Sharp Like Blade. LMAO aaand tab closed.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; there's still a lot of demand in WordPress ...because no sane developer wants to touch the shite wordpress codebase
- "Please make it compatible with an autoloader (see PSR)", - "Please have a read about PSR as well" https://github.com/anovsiradj/php-cutter/blob/master/composer.json - "Document methods and properties", - "It lacks documentation" todo (basic usage added instead) thanks.
&gt; Don't use Internet slang like "LMAO" ... deleted &gt; Show me some examples in the Readme ... added &gt; Tell me why I should use this .... thanks
Sure they can. But there is some security to be gained by not transmitting the refresh token on every request. But the main idea is that you don't need to go to the shared session store on your backend for each request, but issue short lived access tokens that can be validated without reading from a shared store which enables you to scale out (horizontally) more effectively because you don't have to hit a single point of failure on every request. Having a single resource like a session store being hit on every request requires that service to be scaled up instead of out, which is of course much more expensive/complicated.
They're as evil as [any other](https://www.sitepoint.com/the-delicious-evils-of-php) feature that people warn against. There's some pretty cool potential uses out there for everything. The hype train is on a fast rail to nowhere, fearing features and then trying to make things with a reduced toolset leads to frustrations and burnout. Enjoy the language, use it in a way that feels good, and stop worrying about the bomb.
- "Document methods and properties", - "It lacks documentation" added: https://github.com/anovsiradj/php-cutter#documentation
EDIT: I meant `__get` and `__set` not `__construct`, whoops! &gt; Third point, reusable magic methods Wouldn't you just use basic inheritance for that? e.g. abstract class Something { __get(...$values) { //.... } __set(..$values) { //.... } } class DoSomething extends Something { } I suspect I'm missing something obvious here 
&gt; MVC is not an architecture. It just a way to separate concerns. I never said "MVC is architecture", you posted diagrams and said "here's how web apps work". **One pattern isn't how an entire app works.** Which is in fact what I said up there, so that one's on you. &gt; Have you noticed that most of JS frameworks uses MVP/MVVM but not MVC? I could comment on this, but I'll try to keep things on point: none of this has absolutely anything to do with the use of routers in JS frameworks. &gt; Anyway this is different kind of router. This router is simple state machine which responsible to update view or view partials depending on some internal state. It routes state transitions, http requests. And it may not rely on URI at all. What's the difference again? &gt; Also "router" is not part of UI/Data Processing separation concepts, it's separate infrastructure to orchestrate parts of UI. It isn't part of any MV* stuff. Your statements are so inconsistent. You're saying: - On the server we have routers, therefore it's not an MV\* app. - On the client side we have routers, the app can be MV\*, but the router isn't part of it. So which is it? &gt; &gt; That's your mistake in the diagram. Both diagrams should have one direction for data flow. &gt; function (Request $req, Response $res) { &gt; // two direction... &gt; } That's not two directions. Without more details, this looks like a closure that can read a request and write a response. I'll assume you mean middleware... I explained this in detail in my previous comment. In short: - Server apps don't have to use middleware. And most don't. Don't confuse a fad for essence. - What middleware does is more accurately implemented as a pipeline, as most components **do not operate bi-directionally**, they just pass-through in one direction. - A controller can be implemented as a pipeline/middleware, this doesn't contradict MV\*. You can't have just one pattern in the entire app (as already stated). &gt; And that makes no any segregation at all. What if part of your app uses websockets and part is rely on zeromq/amqp? That questions reads as if you were in a hurry. State it more clearly, please.
&gt; Wouldn't you just use basic inheritance for that? Let's say you have existing `class Foo` and you want to create `class FooWithProperties extends Foo {}`. Unless you use traits, you hit a dead-end in code reuse here. Now let's try something else. We move from traits to classes and inheritance, so we'll have `class Properties {}` for `__get` and `__set`, but also others, like `class Uncloneable {}` which defines `__clone()` to throw an exception and forbid cloning the object, which is useful, when cloning can't be done safely or properly. Now let's say I have an object where it has properties, like `class Properties` and can't be cloned, like `class Uncloneable`. Can I extend both? Nope. I hit a dead-end in code reuse again. ----------------------- With traits, you'll never hit a dead-end like that, you can freely combine traits and still extend some other class, which is nice, when a framework requires you to extend their class, for ex. in order to do something. Single-inheritance is a big commitment, because a class can extend only one other class, so you must choose carefully. It's like getting married. In fact it's even worse, because there's no divorce here.
Seems that your package requires PHP7.1+ yet I fail to see any use of PHP return type while looking quickly in the source code. So its PHP7 without any PHP7 feature ?
Yes but I would argue that return type is way more important that iterable or nullable type hints. Adding the return type better enforces your package usage while for instance iterable is just syntactic sugar which can be easily implemented on userland code.
[removed]
The package uses return typehints, just not everywhere. That said, a PHP 7+ return typehint is only useful for methods in interfaces and super-classes, otherwise there's no pragmatic difference between it and a PHPDoc return type.
We didn't submit a PR to the laravel collective package because our changes are not a simple added feature but a whole new api. The goal of the laravel collective package is to provide the old api to current Laravel apps. 
&gt; Seems like something the Javascript community would do, then before you know it we have 10 different packages writting HTML tags Shit, that's pretty intense. Are you going to be OK if this happens? ^/s
PHPDoc won't enforce your return type. Meaning if you return an incorrect type, you may not notice it until way later. At this point it may be hard to trace the error back to its origin. Return type + `declare(strict_types = 1);` makes your function/method fail immediately and makes it clear that you messed up your types. No ?
I disagree, PHPDoc return type is primarily for documentation while PHP7+ return typehint is used at the engine level you can't compare both. One will be ignore by the engine the other will greatly ease package development and maintenance. for instance the [HTML class](https://github.com/spatie/laravel-html/blob/ee9e1844877b821fe7bc8f3f399d1ea18ddd9e0c/src/Html.php) which seems to be the primary entry point to the package would be improved with return type.
Okay, thanks for the reply. I knew it would be something I missed :)
I can compare both and I just did. Both are good for documentation, and the PHP 7+ return type also helps constrain the return type of interfaces, abstract methods, and overriden superclass methods. We don't disagree about this. &gt; For instance the HTML class which seems to be the primary entry point to the package would be improved with return type. I'll bite. Tell me in what way it'd be improved. Do you expect users would extend this class or modify its source in some way? If not, then they only need their IDEs to know the return type of `Html`'s methods. And they do, because PHPDoc. I'm not saying "don't use PHP 7+ return types". I love 'em, I use 'em. But I'm just saying that sometimes it actually *really* doesn't matter which kind of return typehint you use. Actually, using a PHP 7+ return typehint introduces a slight performance overhead, because it's like an `assert()` check you can't turn off: if your code is already correct, there's zero reason to incur runtime penalty for having that type check there. 
It's not an interview he's talking to himself 
So many times I've hit a wall, gone to a coworker and started explaining my problem, only to realize the answer half way through my explanation 
Hi, I'm that coworker :D
&gt; Do you expect users would extend this class or modify its source in some way? Well I don't know what users will do so I prefer defensive coding. &gt; If not, then they only need their IDEs to know the return type of Html's methods. IDE features come and go and what if I don't use an IDE ? PHP 7+ return typehint will yell at me in any circumstances, PHPDoc won't &gt; Actually, using a PHP 7+ return typehint introduces a slight performance overhead I would call this micro-optimisation. I'd rather have a slow but coherent code than a fast one which will break without my knowledge because shit happens.
&gt; Well I don't know what users will do so I prefer defensive coding. The best way to be defensive against unintended inheritance is to make a class `final`, not adding return types. :-) &gt; IDE features come and go and what if I don't use an IDE ? PHP 7+ return typehint will yell at me in any circumstances, PHPDoc won't The idea was, once again, that the circumstance in which you get "yelled at" almost never occurs when the return typehint (whether PHP 7+ or PHPDoc one) and the implementation are in the same place. &gt; I would call this micro-optimisation. I'd rather have a slow but coherent code than a fast one which will break without my knowledge because shit happens. Just saying. BTW, you have a very strong opinion about types. I **bet** you have detailed assertions for validating the content of arrays and so on, right? Especially when returning arrays? Just kidding, I know you don't.
Your blog config example really isn't very convincing. Neither is your demeaning tone and intentional misrepresentation on my point about magic methods. In your example you're basically using traits as config files for you classes. In a real world example BlogConfig would be some sort of value object loaded from a database or config file. No need for traits here. Your blog class appears to be some sort of controller but it doesn't really resemble any real world usage of a class. Should I interpret it as a BlogController? **Decorators** I know what composition is. I guess people who love talking about design pattern like calling every instance of composition a decorator. In that case decorators are amazing. I still fail to see how traits are actually useful. Why are you reusing the same compositions all over your application? **Magic** My point about not using magic methods was aimed at __get, __set and __call. **Reflections** Give me 1 good example of using reflections to achieve proper abstractions. &gt; As for how often you need them: I never said you should need them often. Maybe 5% of my codebase is traits, typically. But if I didn't have those 5% traits, I'd probably have around 10-20% more code and classes. Using traits intelligently can reduce complexity and allow efficient code reuse. Give me one good real world example where traits help you implement a problem that I couldn't implement better without traits. An example using traits doesn't lead to the same static/tight coupling described in [this post](https://beberlei.de/2013/04/12/traits_are_static_access.html) 
[Are traits the new eval?](http://blog.ircmaxell.com/2011/07/are-traits-new-eval.html)
 &gt; Actually, using a PHP 7+ return typehint introduces a slight performance overhead My thinking is that being *more strict* always wins at the end. - Compensate the overhead of return type hints by using strict comparison (if not already) - Future optimizations possible when the return type is known on beforehand 
I know it works. But I'm mentally not prepared to talk to an inanimate object.
&gt; Your blog config example really isn't very convincing. So be it. I guess me, the PHP &amp; Java teams will go cry in a corner or something. &gt; Neither is your demeaning tone and intentional misrepresentation on my point about magic methods. "Magic methods" are just a convention for interface methods, from a time before PHP had proper interfaces. I.e. if `interface JsonSerializable {}` was introduced in PHP 4, it would be `function __toJson()`, like `function __toString()`. Magic methods control not only dynamic properties and methods, but also serialization, deserialization, cloning, code generation, string representation, debug information and others. And yes the constructor and deconstructor are also magic methods. So when you say "you shouldn't use magic methods" and that turns out stupid, don't blame me, I wasn't there guiding your fingers to type it out and submit it. &gt; Your blog class appears to be some sort of controller but it doesn't really resemble any real world usage of a class. It's not a controller, the example was that this was the entire blog. Sure, it's just an example, but it's simple enough for any developer to understand. Except negative Nancy. She just rejects everything. &gt; In a real world example BlogConfig would be some sort of value object loaded from a database or config file. This is just you attempting to reconcile unfamiliar pattern with something you've done before. Truth is that a configuration object is far more flexible than what you can stuff in a database. Take a closer look at the methods. Can you stuff a PDO instance in a database? That kind of makes no sense. What about this method: function authorizeAdmin($user, $pass): UserInfo; This allows the Blog module to "outsource" authorization to the creator of the Blog instance. The creator can write and provide this simple method above, that connects the blog "Sign In" dialog to any existing set of users you may have from another module. Any storage, any mechanism at all, no limits. You can't do this if your configuration is just serializable content, because you can't effectively serialize methods and closures (you can sort of through third party code, but it's... terribad). Anyway, this was an example of the "Encapsulated Context" pattern. If you're curious, Google it up. In a real world, I'd have an encapsulated context on a naked module, and if someone wants to make it user-friendly with "config files" and "database storage" they would *implement* this interface, and have the implementation read *some* of the values from a config file or a database. &gt; I know what composition is. I guess people who love talking about design pattern like calling every instance of composition a decorator. Haha, I love your misguided arrogance. No, I meant specifically a Decorator, not just "composition". Also, I said *functional composition*, which is decidedly not the same as *object composition*. &gt; Give me 1 good example of using reflections to achieve proper abstractions. The way 90% of routers work, when invoking a controller method matching the extracted route action. &gt; Give me one good real world example where traits help you implement a problem that I couldn't implement better without traits. I already did, but it was lost on you. I'll give you another example. I like encapsulation, so I want to make sure people can't mess with my objects in ways I don't intend. Say things like: - Cloning an object, which can't be, or shouldn't be cloned. - Serializing an object, which can't be, or shouldn't be serialized. - Adding randomly named dynamic properties on an object from outside. PHP allows a lot of silly things on objects by default: class Whatever {} $w = new Whatever(); $w-&gt;blahblah = 123; echo $w-&gt;blahblah; // 123 So I might declare a class like this: class Whatever { use NoClone; use NoSerialize; use NoDynamicProperties; } Now my object is better encapsulated: $w = new Whatever(); $w-&gt;blahblah = 123; // Exception: Attempting to set non-existing property "blahblah". **Now do this better without traits**. I'll be right here, waiting. 
It does tend to win, when you have a language built for it from the ground up (i.e. statically typed, compiled language). PHP is inherently dynamic, so I don't think we'll be "winning" any time through strict types. So my only consideration is detecting bugs (which is still not too shabby).
That's actually a great example. Using traits in this way to disable PHP's shitty default behavior is a great example. I wouldn't say this example is really in the spirit of this discussion. I don't think disabling default PHP behavior is a good case for traits. Also my better solution without traits would look like this class Whatever{} You don't actually need to disable clone, serialize and dynamic properties. But I can see why you'd want to. --- &gt; This is just you attempting to reconcile unfamiliar pattern with something you've done before I'm trying to reconcile your example with my experience in real world programming. I don't want to outright dismiss your usage of the pattern but if I can't apply to my actual experience I can't learn how to use it. 
&gt; The best way to be defensive against unintended inheritance is to make a class final, not adding return types. :-) agreed but return type can help too :) https://3v4l.org/RMfRU . 
&gt; Are you suppose to literally talk to the rubber duck? If it helps you, sure. If you can have that conversation silently in your head, great. Hell, you don't even need the duck.
&gt; That's actually a great example. [...] I wouldn't say this example is really in the spirit of this discussion. So it's a great example or it isn't? **:-)** All examples I've given of traits, including the last example: all of those are real things I use traits for. Any many other things, but I wrote a small book here already. I like traits. Here's another very common example, which is often cited for JavaScript mixins: class CoffeeMachine implements EventBroadcaster extends KitchenAppliance { use EventBroadcasterImpl; function brew() { $this-&gt;setHeater(true); while ($this-&gt;getTemperature() &lt; 90) sleep(1); $this-&gt;setHeater(false); $this-&gt;broadcastEvent('coffeeReady'); } } $cm = new CoffeeMachine(); $cm-&gt;addEventListener('coffeeReady', function () { echo 'Coffee is ready!'; }); $cm-&gt;brew(); This is emulating multiple inheritance through a trait, and an interface. We can't have "EventBroadcaster" as a base class, because then every time you want an event broadcaster *somewhere in a type tree*, the base class should extend "EventBroadcaster", although most objects in the tree don't broadcast events. That would be a recipe for turning every object into a junkyard of rarely used functionality. But, anyway. Have fun *not* using traits, I'll have fun using them :-D
Yeah, for real, no need to interrupt a rubber ducky's busy schedule.
If you are doing anything non-trivial inside that config you‚Äôd like to have services or values injected into it anyway. Config errors are non-issue when used with a simple `array_replace`, and even better when used with [OptionsResolver](http://symfony.com/doc/current/components/options_resolver.html). The plus side is that you can actually build those configs in runtime if you need to, using data from a database for example (the builder would convert non-serializable closures into service names for example, etc). YMMV.
I'm sorry this is absurd. Who ever heard of not using a rubber duck for rubber duck debugging... sheeshhhh..
Well i have this old class, that just do that, maybe it can inspire you to write your own wrapper. Basically, it use regex and reflection. https://github.com/peakphp/framework/blob/edb8b7c8edb63385bfed0537bdb1914e462a3d59/src/Common/Annotations.php. IMO, it's not an hard task, but caching should be considered. 
PHPDocumentor has a "reflection docblock" package: https://packagist.org/packages/phpdocumentor/reflection-docblock (I have not used it directly so I cannot vouch for it per se, but it is a core part of PHPDoc, which is a good indicator.)
Instead of a rubber ducky, I got a chocolate labrador retriever... He gives me this weird look every time I poke him and wake him up and start talking to him. 
Wow, thanks a lot!
Thank you!
cPanel does have a decent file manager for worst case scenarios like this. You can upload a zip file and extract it or purge entire directories fairly easily.
I meant creating different ‚Äûimplementations‚Äù of BlogConfig in runtime. The things you propose doing by mixing various traits, could be easily done by injecting an array with values. Again ‚Äî not saying one is better than the other, just different use cases.
Rubber ducking isn't for everyone. A little pseudocode and comprehensive commenting gets the job done just as well. With the added benefit the next programmer can see wtf you were doing.
Ahaha, what a nice joke! :D Big truth is that not all Windows-users are script-kiddies. I use Windows as workstation because my hardware works better there than in Linux, Windows has better GUI tooling for MySQL and MongoDB, and I work in Photoshop sometimes. For my web projects I often use Docker, Vagrant or Ansible with Linux image, because server-related stuff is ways easier in Linux. Blaming others for tooling that suits them best is at least dumb. What company do you work in? Fair point about MySQL port 3306, but it is not a problem if you use MySQL with SSL support, since it provides same level of protection as SSH. Yes, MySQL 5.7 in Debian 8 from official channel comes with SSL built-in! I haven't measured performance slowdown in comparison to SSH or OpenVPN (didn't need it), but zero problems so far. More over, real server is hidden behind CDN, so you won't reach its port 3306 if you don't know real server IP, but if you are paranoid, then just bind mysqld to different port in configuration. That is not a big deal. Still, thanks for input! I will update instruction to explain that reader should use SSH tunnel for MySQL remote connection and not to expose 3306 without knowing how to protect it.
"Hey, Siri!"
I like to think of it as roping in other kinds of brain-circuitry to help attack a stalled problem. By expressing/codifying the situation to another person (or consciously working out what you *would* say) one part of your brain is forcing another part to clear cache and re-check assumptions, and automatically re-interpreting the planned output to check for whether what you-think-they'd-think actually matches what you're-thinking-right-now.
&gt; I just call it tracing the logic through the application I don't think that's the same thing: Rubber-duck debugging is not about poking at the source-material, it's about clarifying what you already "know" in your own mind. The point is to force yourself to take your own internal thoughts and generate a more-formal description (e.g. English) of those ideas. As social creatures, we have a bunch of brain-circuitry dedicated to checking our own communication and trying to predict what another person is going to think when they hear it, which means we monitor and reinterpreting our own words back to ideas. In the process, forgotten details or inconsistencies can be discovered.
Just curious, is there anything like cpanel or laravel forge that targets AWS autoscale EC2 groups (or similar autoscale for other hosts)?
Here's mine: http://i.imgur.com/j9KjHCR.jpg
You could try this package too https://github.com/marcioAlmada/annotations
Stack Overflow is even better. You know you are expected to word your question really well, so you really end up breaking down and explaining the problem in detail. I often find myself figuring out the answer before I finish posting the question.
Where's the fun in that?
The whole point is that you *could* have done this at a trivial cost. It's a contract that your library isn't going to promise an int and return a null. You're way too defensive and come across very arrogant when facing criticism. 
I went from the Traits-Are-Evil camp to the Traits-Using camp and back again. Traits, though not evil, allow one to specify a poor layout of responsibilities. If you are thinking about using a Trait, consider using a common parent class instead. I liked Traits because they let me add methods to _some_ extended classes but not all extended classes that extended a particular class. But what I really should have done was to have a deeper class hierarchy. I've found after refactoring the Traits out of a few places that being generous with class hierarchy was _always_ the better solution, at least for me. I wish that I'd never used Traits and instead was forced to properly design my class hierarchy properly from the beginning. That said, I'm still open to seeing Traits used 'properly', so long as someone can show me a real-world use case where a deeper class hierarchy is not the better solution.
This! I want to know what kind of hosting charge extras for ftp and ssh so I never do business with them. It's 2017 goddamit.
Corsair K70?
Sorry but Ting is better :-)
Have a RGB Strafe at home that I love.
Agreed! With those prices, I'm amazed this provider is still in business...
Dilbert replied, "In my day these used to be called FAQs, not articles"
Don't worry. I started a WP development without knowing nothing about WP. 2 months so far and I am making the bosses happy. Though mine is internship so they don't pay me, but it is to say that you can get started without anything pretty quickly specially considering you have 2 weeks of head start. take a pen a paper and draw/write what the framework does generally. Or get a copy of the framework or tool you are about use and just delete something and see what changed, where, why ... this is good for your confidence since you will think you are learning something ... i can't phrase it exactly but i can tell you don't worry, just start playing with it
Or html meta redirect. No php or javascript needed!
[removed]
You should look at how much time it will take you to handle file transfers/changes/uploads. Assuming you charge by the hour, if the time spent on that exceeds $20 then it's obvious that paying the $20 is actually saving money in the long run. Moving forward your contracts should clearly state the minimum requirements of a hosting provider and for the sake of your projects moving forward always have one or two that you recommend. 
&gt; The webhosting also had the FTP disabled, but I send a message asking the price of FTP and they enabled after some discussions. What in the wide world of fuck?
I'm looking for a migration library that I can pass a PDO object instead of having it connect on its own like Phinx. Anything out there that fits the bill? 
[removed]
[removed]
A lot of people are unhappy with Magento 2. I'm really hoping Sylius starts getting more attention.
For Best Framework, I will prefer Laravel which is top ranking PHP framework now a days. It already includes different powerful features which make it a perfect framework for web development. Some powerful Laravel features : **Markdown Mailing System :** * Markdown enabled mailing system has been added as a new feature in Laravel. It provides pre-built templates and components for mail notification. You can also send message through emails, SMS and different channels. Responsive or plain text templates can be generated by this markdown system. Please have a look Markdown email template. **Collection Higher Order Messages :** * There are different collections methods to perform higher order messages. These methods are contains, each, every, filter, first, map, partition, reject, sortBy, sortByDesc, and sum. **Automatic Facades :** * Now Laravel provides real-time facades. Through this feature, you can use any class of your application as facade. You can create any class in your application and use that as facade. 
"Ok. Here's what I found for 'So on the first call of the function, the value of $foo is null, but on the second call, it's bar'". \**Wolfram Alpha result showing the weight of heroin in degrees kelvin*\*
From a year ago? 
It's a way to make something. So I think recipe is a pretty good name. If you know a better one, I'm sure you're welcome to contribute.
I've been in a similar scenario and used [banago/phploy](https://packagist.org/packages/banago/phploy) with great success. It takes file changes from git, uploads the added and changed files via FTP, and removes files, too. You may also tell phploy to clear folders, e.g. those containing caching content.
"Everything on the Internet is dangerous!" - Proceeds to add a malicious Javascript snippet because it appeared in the top 10 search results on Google.
* Your Flask.class.php has a dependency on functions in the utils.php file, but this dependency is not explicit in the file itself. You could fix this easily by adding an include_once line at the top of the file. * The run() method in your Flask class has way too much responsibility. You should consider breaking up that responsibility into other methods, or even other classes. For example, your blueprint, which has its own method (register_blueprint) as well as some logic in run(), should probably be its own class (perhaps a BlueprintCollection or something similar). * Similar to blueprints, you should probably create an object for the routes. In HTTPHandler.class.php, you're using an associative array to hold the route information. I think you would find that your ability to control the data and set good methods would be better with a class. * In Blueprint.class.php, you have the method init() which has no code in it. If this is a method that any child class should define, you should make it an abstract method instead, or in the alternative, just make Blueprint an interface. In general, you should also look into more modern practices, like using namespaces and autoloaders to cut down on all the "include/require".
Very nice! Curious what's the reasoning behind ${DS} (seen [here](https://camo.githubusercontent.com/6444646e4dc7650c3373c35bd71fb0d800329a2c/687474703a2f2f692e696d6775722e636f6d2f69614f49394a372e706e67)) over just plopping in the dollar sign? 
That's a PHPStorm recommended way of escaping dollar sign. https://www.jetbrains.com/help/phpstorm/2017.1/creating-and-editing-file-templates.html
/u/fuckswithducks relevance
I got the k90 purely for the macro keys because I'm full on starcraft nerd but I also have code blocks (skeletons) programmed to the macro keys as well. So I can hit the macro keys to construct me a function or class, sure my IDE can do that as well but if I need to make quick changes over SSH using vim or switch to my laptop as long as I have my keyboard I will always have my shortcuts. Works nicely.
Just said in another post: I have the k90 purely for the macro keys because I'm full on starcraft nerd but I also have code blocks (skeletons) programmed to the macro keys as well. So I can hit the macro keys to construct me a function or class, sure my IDE can do that as well but if I need to make quick changes over SSH using vim or switch to my laptop as long as I have my keyboard I will always have my shortcuts. Works nicely. Macro keys are the future if you jump around and don't always have access to your IDE
I've built a basic ORM which has CRUD functionality and can handle one-to-many relationships so far. I can't wait to tackle the where in relationship functionality so your implementation looks helpful. Thank you for sharing 
I've constructed a full interface from a subset of methods in a class of mine, I rely on docBlock instructions to generate a form with accurate types and default values, so I can confirm this works great.
Dude, your Framework is called PHPixie and you wanted to call your ORM Unicorn. Recipe at least makes sense, but even if it didn't I wouldn't say you were in a place to judge. And even if you were, this isn't constructive
Maybe something like http://web-console.org/ could help. But a new hosting would be preferable.
I use it in [PHP-DI](http://php-di.org/) to read annotation on classes, properties and methods. Based on that there is logic happening. I don't know if that answers your question.
&gt; I suggested the client to hire cloud vps servers, but he didn't wanted neither pay the extra 20$ to webhosting. Add a couple of billable hours to each deployment estimate to accomodate having to manually perform the operation until the client pays the $20 to enable the SSH. 
Nice! I use Phalcon a lot and we've just ditched swagger in favour of postman docs. Hopefully this will help revive it especially for external facing APIs we have. Thanks! I'll test it out later
Yeah, we need one too, for posts like this &lt;?php header("Location: https://www.reddit.com/r/PHPhelp"); 
Hello. Please have my downvote. I‚Äôm /r/OutOfTheLoop but it seems like a right thing to do.
Please do not get me wrong, you asked for feedback, so here it is. This feedback comes from genuine interest; I am just trying to understand the premises. Could you mention some of the profitable niches that you have successfully discovered and is currently running? It feels like the only advice you gave was to look at the Envato marketplace for existing ideas and go to a meet-up and listen to the ideas of others. Or find an existing niche product and outperform them. You say "*When you market yourself, focus on promoting your solution*" As opposed to what? When would I market by not promoting my solution? It might be super obvious to you, but I read it a bit like: "When you talk with someone, use words." Your insight and tips don't stand out when someone like me, with no experience, can't tell it's not just a basic knowledge. Additionally, you write "*So then, that becomes your niche: helping bakers in your town [...] You can now approach bakers confidently. [...] If one says "No!", you know there is another one, just around the corner.*" But my town only has one baker? It doesn't seem very nich√© when the entire premise stands on having unlimited buyers for your nich√© product. In fact, I'd argue that example is the exact opposite of a nich√© product.
Whatever you're doing right now, just stop.
I feel like you have replied to the wrong comment....
[removed]
Make sure you use canonical links when linking to a file/directory on GitHub. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/ahmedkhan847/mysqlwithelasticsearch/blob/master/src/SearchElastic/SyncMySql.php#L79 | https://github.com/ahmedkhan847/mysqlwithelasticsearch/blob/20989b16a272861f70e10f9bf28686ed17a6528a/src/SearchElastic/SyncMySql.php#L79 Shoot me a PM if you think I'm doing something wrong.
that what I have said. I am learning them.
Thank you, that's a very good question. I need more of those so please feel free to ask and suggest all you have on your mind! **Your first question** &gt;Could you mention some of the profitable niches that you have successfully discovered and is currently running? Yes, first let's be clear - it's really not in your best interest to go after a niche someone else has discovered. You have to do your own research based on your character, personality, experience, and overall goals. Having said that, I've made money in the following niches: * rapid marketing for restaurants and bars - SMS marketing apps * marketing automation for info-marketers - Facebook apps and various custom solutions * first time SaaS founders with limited budgets to get going - rapid MVP creation ( with my proprietary formula that helps the platform sell itself. ) There are others but I want to keep it simple. At the same time, these are niches that work for me - it doesn't mean they'll work for you. I'm trying to show how you can find *your own* niche. **Your second question** &gt;You say "When you market yourself, focus on promoting your solution" As opposed to what? When would I market by not promoting my solution? Great question. A lot of PHP developers market themselves like this: *"I have 7 years experience as a PHP developer, I'm an expert in Laravel, ZF2, I also know Angular, etc. I've worked at X and Y, created this and that. Here is my portfolio/github, ..." ( I'm paraphrasing ) That's like a plumber saying *"I know how to fix every pipe under the sun and I have the latest spanner"*. Your skills are your **tools**. Your experience helps but that's not what the client is looking for. When your toilet is blocked what you want to hear is "I'll be there to fix it in 30 minutes or less"* ( ideally ) So instead, you want to say to a local business owner "You can handle your orders 30 minutes faster with my automated order manager." That's your solution. **Your third question** &gt;But my town only has one baker? It doesn't seem very nich√© when the entire premise stands on having unlimited buyers for your nich√© product. In fact, I'd argue that example is the exact opposite of a nich√© product. If your town has only one baker, that could still be good news. In our * **example** *, the baker is slowed down by how long it takes to take an order. Let's assume, with your system, he could sell more cakes per hour. Depending on how big your town is, let's say you've added $500 per day to his bottom line. ( 500 people x $1 profit per cake ). $500 x 30 days = $15,000 every month. I think it's fair if you charge him between $1000 - $3000 a month to use your platform. Then, promote your solution online! Of course, most of us have more than one baker in town. So that's not really an issue. ( and we're not all going after bakers ) **The point:** if there are not many businesses in your local area, you have to rely on the internet. It's a bit harder, but you can do it, once you understand the steps. Please let me know if that clarifies it for you ( and any other questions ). 
&gt; Your next step is to write down a list of possible markets you want to work with. Then, start with your top pick ( you can always change it later! ) I'd say, go the other direction. Find niches that are not covered well and when you got a bunch, pick one you like. If you focus on things you know you like, you leave out the ones you might like, but just haven't thought about it yet. It also helps you avoid the most obvious choices, that others very likely already had, saving you some time in avoiding over-crowded places. Edit: I'd also add: Look for synergies. If you can find 2 or more niches, where the same solution can solve an existing problem, don't be stupid and invest the work into one of them, without getting the benefits of the others. Try to get the most out of your working-hours in terms of reusable code. 
What is your opinion on Backpack for Laravel ? Or alternatives ? I want to start a new project and start using Laravel for the first time ? Can I start both using Laravel and backpack simulatuously or should I start with plain Laravel first ? So far, I only used CI3.
Estimate the amount of time it would take you, send an invoice for the work and wait for payment. If you're paid then do it, if the client queries the cost then show the difference when using a VPS. If the client still isn't on the same level as you at this point - walk.
That's how the program works
TLDR: That person is using the EAP to get around having to pay for a license, and they are mad because it is longer available. Serves them right!
It'll open in a couple of months when they have a new EAP ready
Yeah, it is "bugs" from PHP-FPM on docker, it has been discussed [here](https://github.com/docker-library/php/issues/207).
_Just one more feature_, the programming equivalent to _just one more game_ :P.
I've got a K95 for work and home(They quit making the k70 I like and the k95 rgb was cheap refurbished), for the love of god I cannot keep my macros straight so I end up avoiding them. CUE is an evolving turd since 2.0. I know that G1 and G2 are bound to open Visual Studio Code and ConEmu... I just don't know which one is which so I end up just hitting the shortcut in the task bar tool bar(That's confusing, [this is what I mean](http://i.imgur.com/mc3KE4x.png)) I'd love a way to label the G keys. 
I see where you're going with it. Let me explain my approach a bit further. Imagine a situation where you need to create a product or attract a client. At the same time, you're trying to provide for those you care about. Would you care more about what you like or... ...would you prefer to focus on something you can actually do ( and bring some money home )?
Good points, I'd recommend writing a book about this type of thing. I'm sure people would appreciate your insight. 
Very nice would be nice if there was an alpine php version btw to make things a bit smaller :)
https://gist.github.com/codenamegary/bf0fd370d61480c57744416448aa4a58 Was hard to even look at so I threw it in a gist, then threw up a little bit in my mouth.
``` function isNotEmpty($value) { return !empty($value); } ``` Someone create an RFC!
If you just want to learn something your choices are many. WP, Dupal 8 (closer to symfony that 7), Craft, SymfonyCMS, Joomla, October, etc. If you want something that might make you more employable then it's a different story. Then you're left with WP, Drupal 8, and maybe Craft. Unless your locality has an odd preference.
An interesting function (that could be replaced with just `!$value`). Though it's somewhat logical, as PHP users en masse do not understand `empty()`.
Roger that, thank you üëç
üí™
Kudos to both of you for keeping the conversation healthy, readable and to the point. Sincerely, a reader who enjoyed reading
Thank you too, this means a lot.
https://media.tenor.co/images/c37f2d7725644cf1daf3bcfc59aa8ef3/tenor.gif
I like this pattern for complex conditions to help explain themselves: $invalid = array(); if (! validateA()) { $invalid[] = 'A'; } //.. repeat thru all if (! empty($invalid)) { alert("Wrong data: " . implode(',', $invalid); } 
Thanks. The main reason I am interested is because I don't like building admin panels etc. for my backend I am less concerned about performance although it is important that I can understand what is going on. This is for a hobby project / maybe proof of concept and I am mainly interested in building business logic. That's what I find most interesting anyway. 
It's basically in the style of "Uncle" Bob Martin http://blog.cleancoder.com/uncle-bob/2016/11/10/TDD-Doesnt-work.html 
Gosh darn front end ;)
Thanks. Anyone struggling with impostor syndrome should take a gander here and feel marginally better about themselves.
I have built two now with Bolt.cm and I really like the flexibility it gives the developer. The users one of my pages say that the editor part is so much easier than other systems as you can define different content types. So I can really recommend Bolt.cm as a base for a new project.
Why aren't you using the [official PHP Docker images](https://hub.docker.com/_/php/) as a base image instead of ubuntu and apt-get'ng everything?
Nine years since first Yii version was released 1.x reached EOL.
Yeah, we could use Monolog's StreamHandler and write it to `php://stdout` or `php://stderr`, but it doesn't solve OP's problem. His logs got prefixed by php-fpm's.
&gt; LoD, SOLID, and GRASP are not design patterns. They are coding principles to follow in order for you to be a better developer. The "P" in GRASP literally means "Patterns". Come here so I don't have to get up from my chair to neck-slap you.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Agreed. Never going to build something in Wordpress again. Bolt CMS is a pleasure to work with.
So many nested ifs. Do they even need the the, "=== true"? Or is that there to make it look not *as* ridiculous? I just noticed validateP() is in there twice. I can't get past it. Why?
One interface for the, a class for each specific business case using that interface, and then you can have a generic implementation and easily add futures cases. $cases = [ new UsernameValidator(), new EmailValidator(), new CityValidator(), new ComplexBusinessRuleValidator(), ]; $invalidStack = []; foreach ($cases as $case) { /** @var ValidatorInterface $case **/ if ($case-&gt;isValid() === false) { $invalidStack[] = $case-&gt;getErrorMessage(); } } 
I wouldn't be surprised if one of the other validateX() functions changes state...and the duplicate validateP() is actually necessary....
http://i.imgur.com/m5l0ots.gifv
you can choose destination file using [error_log](http://php.net/manual/en/function.error-log.php#refsect1-function.error-log-description). It says by default it will always log to your server error log. better than that, try to use PSR or monolog like others suggested
I can't say anything one way or another about Bolt. However, I will say that I really like the work the folks have done who have developed the [Pagekit](https://pagekit.com/) CMS. Also, if one of the reasons you want to work with something else besides the obvious options is to expand your PHP skills, why not try building on the tools that come with an async framework such as [AMP](http://amphp.org/)? 
&gt; why not try building on the tools that come with an async framework such as AMP? I had never heard of AMP before, thanks. Although I think it would be an overkill to create a blog using nonblocking io. Pagekit looks interesting as well.
Tried it on a recent small project. Definitely a huge improvement when compared to out-of-the-box Wordpress. It was buggier than I'd like; I remember trying to use their equivalent of repeater fields and I ran into 2-3 fairly nontrivial issues. The docs were *okay*.
Actually, yes! Learn another language! :) Advanced patterns emerge when you learn another paradigm and framework. It pushes you to understand edge cases and both the 'why' and the 'how' of the way things work. I would recommend from personal experience these two: http://learnyouahaskell.com/ https://www.railstutorial.org/ If you want to strictly stay with PHP, look up: http://www.phptherightway.com/ https://laracasts.com/ PS: I think you meant 'imperative' coding which means 'Lots of functions all over the general namespace' which is how most people start writing php. *Functional Programming* is an actual thing (Haskell and others) and can help improve your PHP a lot :)
&gt; If you are writing your own logger at least follow the standard Not to pile on the standard, but it has 8 more methods than it needs: interface LoggerInterface { public function log($level, $message, array $context = array()); } To put all those helper methods on an interoperability standard was very shortsighted (hi, Jordi). An interop interface should be short and sweet, so implementations can be focused on the meat of the job to be done and not dancing around fulfilling bureaucratic interfaces. My logger library is full of decorator implementations which do things like filtering, transforming, formatting, etc. events, adding log channels, adding fallback channels and more. Now all of those have to implement one method instead of nine. And when you need a log with helpers for human use, it's as easy as decorating the final chain in your DI container: $log = new LogWithHelpers($logChain); Now everyone can have their own helpers, while having light and *still fully interoperable* log implementations up the chain. Separation of concerns, y'know. - One concern: light, easy &amp; quick to implement interoperable interface. - Another concern: helper methods for humans calling into the log from their application code. BTW, syslog's 8 log event prioritites... just bad.
Even more, it's an interop standard, not a standard that everyone should use for their native library interface. Interop standards are typically intended when writing bridges and adapters, not the core implementation.
Some like to read the "P" as Principles. But Craig Larman, who defined GRASP, defined them as "Patterns". He also first described GRASP in a book called "Applying UML and Patterns". Anyway my larger point was, let's not nitpick each other's terminology, or might come back to bite us. OP meant he's trying to learn about them fancy acronyms that we keep talking about, and "patterns" or "principles" wasn't that important.
I dealt with this a lot as a new PHP developer back in the days of old, when I was a wee young thing. I pitty the fool who wrote this.
I have issue with the conversation aspect, specifically this one. It makes it seem like were all trolls who harp on other peoples projects and ideas and solutions and the whole concept of "hate the guy who re-invents the wheel" but then "check out his cool stuff after I get my head out of my ass" Other then that, the project is really cool Good job :)
&gt;I am still alive. If you can call this personal hell "living", sure.
https://youtu.be/poz6W0znOfk
The part of vanilla PHP doesn't bother me much because I have some experience with both Silex and Symfony. The menu thing might be an issue. I'll give it a try anyway, since it's not a project for a client or anything, I don't have much to lose.
Terrible comparison. Wordpress is the worst. I think anything is better than that bloated junk.
ha. Nice one.
You could‚Äòve used traits for default implementation of the remaining 8 methods :&gt;
We do our best to have quality stuff at [SitePoint](https://www.sitepoint.com/php). We both pay for posts and have a peer review system in place to make sure the material is good and double checked before publication, which leads to generally high quality content. Of course, mistakes still happen so if you notice any please tell us. We've got stuff ranging from the usual stuff to downright [oddball](https://www.sitepoint.com/tag/oddball+php/) things done with PHP (beer pouring with PHP? Sure..), so I think there's something for everyone. --- Also, if you're in the "I hate SP" camp I'd appreciate feedback on *why* rather than just being downvoted. I do actually care and want to make the site better (don't say "because ads" - it's something we're fighting against internally as well, and they were recently completely removed for premium members, so progress).
&gt; I hate PHP because it has terrible typeconvertion and it's not typesafe.. . &gt; $balance = intval((string)($price * 100)); Also lol on that "isNotEmpty". What about the "isNotNotEmpty" case? &gt; ^ This variable name is safeVal so no need to worry God thanks!
Thank you! :-)
Q: Why did you go for the interview style? A: After written 50+ introductory blog posts in the same style , I wanted to try a fresh approach. Q: Did you intend to paint everyone as trolls? A: No certainly not. My apologies if it came across that way. Q: Why are you responding on reddit in this conversation style? A: Boring, next question :-) 
I'd encourage you to load up another project and have a play. But if all you want is user management then it's a waste of time. If you have any admin requirements that go beyond the typical CRUD flow the it's also probably a waste of time. IF you have a whole bunch of models you want a whole bunch of simple forms for then yes it will do well.
To be quite honest, this isn't even that bad. Reason being that this is _easily_ refactored. No hidden dependancies nor any form of tight coupling. Yes the code is not pretty, but that doesn't mean it's unsalvageable. You could actually get a lot of readability improvements simply by moving parts of the code to their own function/method, and then extracting them to their proper encapsulated objects. I've seen way worse than this tbh ¬Ø\_(„ÉÑ)_/¬Ø
¬Ø\\\_(„ÉÑ)\_/¬Ø
What's advanced for you? Things like SOLID? Or more advanced stuff like DDD and CQRS? Maybe consider my [tutorial](https://github.com/PatrickLouys/no-framework-tutorial). If it's more the latter, check these [resources](http://patricklouys.com/resources/)
If you are only used to CodeIgniter, you probably lack a lot of OOP knowledge. Grab a copy of [clean code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship-ebook/dp/B001GSTOAM) and go through the [clean code talks](https://www.youtube.com/watch?v=4F72VULWFvc&amp;list=PL693EFD059797C21E&amp;index=1)
I like your sarcasm
Silver Lining: There's some low hanging fruits that wouldn't take long to take care of in there :)
&gt; Yeah, it is "bugs" from PHP-FPM on docker, it has been discussed here. Finally someone who mentions the issue, and not my implementation. Thank you!
Make sure you use canonical links when linking to a file/directory. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/phpdocker-io/base-images/blob/master/php/7.1/fpm/Dockerfile#L25 | https://github.com/phpdocker-io/base-images/blob/b9cc877e36ced2a9c5277b24bcb61680cbf9fa6f/php/7.1/fpm/Dockerfile#L25 Shoot me a PM if you think I'm doing something wrong. To delete this, click [here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgibea7.)
In phpstorm why do escape characters get flagged as "Bad character" in `preg_match` when using `"` instead of `'`? http://imgur.com/a/oSTqo I know it wants me to use single quotes, but I'd like to know what pitfall it is attempting to avoid as both work &lt;?php $input_line = 'test-foo bar'; preg_match("/([\w_-]+)/", $input_line, $output_array); echo $output_array[1] . "\n"; preg_match('/([\w_-]+)/', $input_line, $output_array); echo $output_array[1] . "\n"; 
Thanks, your feedback is very useful. That's what I'm trying to share here - a strategy that gives traction. Later, you can have time ( and money! ) for personal passions. Have you got suggestions on how to make it easier to apply and understand?
The extension system is complete bullshit, but the CMS itself works fine. 
do the descriptions follow a PSR? they are completely interchangeable! lazy article. 
maybe http://www.phptherightway.com/ ?
I usually direct people to this list: http://stackoverflow.com/a/16356866/727208 (don't be scared by the question's title - it's misleading).
\#Casper
Written by smashing the temporal bone on the keyboard.
It depends. There are projects I worked on with Yii 1 around 4-5 years ago. I don't want to rewrite them because they are still functional and serve their purpose. For example a simple logistics system to requisition materials used between construction sites and ware house. It's been operational for a long time and they're used to it. I save time by updating the Yii core and get all the security / stability benefits quickly. Clients understand the need for security and willingly pay for it for the time it takes to update the Yii core and a few small changes if needed.
Click.Bait.
&gt;Mindfire Solutions is amongst the leading providers of Software &amp; IT services... Somehow I doubt that 
I think a good approach is to find something that is useful to a group. Find an existing problem and solve it. It's easier to provide a solution to an existing problem, than to convince customers that they need to solve a problem they don't even know they have. For example, there are tons of "wysiwyg-online-webpage-editors", bascially implementing a simple CMS for small businesses to have their own website, without having to pay a web-designer to do it for them. Most of them suck, but since small businesses don't have the budget to hire a professional and big businesses are looking to get the best people for their money, it used to be a niche that was interesting for beginner to intermediate developers to gain traction. I think it's a perfect example of using a niche to your advantage. I was working for a company once that specialised on linking android/iphone apps with an backend API, creating services for museums, galleries and events. Since they used their main app they continuously kept developing, their costs were a lot lower than any developer that would have had to start from scratch could have offered. They were also able to show a working system and quick mockups of their work, at barely any cost to new customers. This job basically taught me, that I don't have to be interested in museums and art galleries, to enjoy solving problems and creating tools for them. In my experience, discovering a whole new world you weren't aware of before is a lot more satisfying than finally getting what you wanted from start... the hype usually ruins it. Never turns out as good as you thought. 
**Laravel is a great PHP framework which includes important features like:** * Controllers and RESTful Resource Controller * Implementing authentication is very simple * Easy-to-use Routing Approach 
I've taking a closer look and the improvements especially in 5.4 regarding PHP 7.1 and async signals are really great. I only have on show-stopper issue which I'm not sure how to solve it, with supervisor. The docs recommend to use it, but when supervisor gets instructed to stop a worker (say, you want to change `numprocs`), then it sends a SIGTERM. Now in 5.4 SIGTERM is handled but it doesn't really change a thing with supervisor =&gt; it will wait a bit (or: `stopwaitsecs`) and send SIGKILL anyway. I.e. it's not possible to say: do not forcefully kill a worker, always let it finish. This is something I'm used to work as expected with the "resque" approach: it uses the concept of two processes where the parent gets the SIGTERM signal; once the child (the actual worker) finishes, the parent exits too (but not before; and the whole time the child process is left alone). But of course *I want* the `queue:work` daemon concept, who doesn't? :-) Is there a solution to this, is supervisor the wrong tool or am I just looking into the wrong direction? thanks
&gt; Same reason I'm not using alpine, half the extensions aren't available I'd like to know which extensions you're talking about? If something is missing why not just build from source?
Thanks, I'll check those out!
It says it's still pending review. Looking forward to try it out when available. I was surprised to see the composer.json support plugin does not offer this feature out of the box. 
I am aware of such criticisms, but I have not yet found anything that in my view is more suitable for beginners. Of course, one could use an existing framework, or write one's own, but that adds too much complexity and/or magic already. I have deliberately and consciously avoided that, as well as Composer and Git. I have mostly avoided objects, though they were necessary for PDO. The question title asked for advanced PHP, but in fact I think the OP was looking for something simpler - in the body of their question, they admitted to copy-and-paste programming. Sadly either the OP or a mod now deleted it anyway... 
Achievement Unlocked: Indentation Face Molesting Level 9000 That `$safeVal`, though... Some damn fine idiocy going on right there.
First of all this: &gt; Example -- our REST API, main website, and admin interface all might add/remove inventory items, ... But each has their own unique inventory item model at present and this is terrible (I don't mean they have copies of the same model, I mean they have their own super unique models .. each may have specific use cases added or removed, but they could easily be shared). You need to fix this. Because if you rely on an API, that should be center of your architecture model. The clients should be only digesting the API provided information with no processing logic in them except for the actual displaying of the information. Second, if you are going to rely on the API, the architecture of the API should be planned as well. Microservices should help with that, and with them you can do a CQRS approach, scaling where you need it. The code for the microservices should be shared, and with that you should look into the middleware approach. Create one module per scope and just reuse those. I think you can have good code reusability if you follow this approach and if needed, you can use the decorator approach. All in all i think you have to figure out the architecture of the entire system before doing anything. You need to see if you are going to be API centric and if so, what is the outer layer of architecture, where do the clients fit in, what are your needs for them, and then the API architecture, single API, microservices, etc.
Codebase of main application (without vendors and separate integrations) is ~500k lines. Tech debt ~400days. Duplications ~15%. Project is getting better and error rate is decreasing, but by looking into those numbers you should get an idea what monster it is. There is some refactoring going on but there are also "business needs". Sorry currently I have no time to explain in more details of a process, but maybe I will update later.
&gt; Example -- our REST API, main website, and admin interface all might add/remove inventory items, ... But each has their own unique inventory item model at present and this is terrible (I don't mean they have copies of the same model, I mean they have their own super unique models .. each may have specific use cases added or removed, but they could easily be shared). Why is this terrible? If they are unique, with their own (business) rules, they should exist as separate modelled entities within your application. I would advice you to watch this video about layered architecture. This might help better understand how Hexagonal Architecture fits within your application. https://www.youtube.com/watch?v=ajhqScWECMo 
IMO this just comes off as unprofessional.
You could also use [this "hacks"](https://github.com/docker-library/php/issues/207#issuecomment-276296087) # Workaround https://bugs.php.net/bug.php?id=71880 ENV LOG_STREAM="/tmp/stdout" RUN mkfifo $LOG_STREAM &amp;&amp; chmod 777 $LOG_STREAM CMD ["/bin/sh", "-c", "php-fpm -D | tail -f $LOG_STREAM"]
Middleware based API with clients cannot be considered hexagonal architecture?
Well, because basically those who use the dockerized php-fpm + logging would has that issue :D
I think having the same entity everywhere where it is used should be the preferred approach. If you have one inventory item, shouldn't that inventory item be the same in all instances? I think it is clear that it needs different rules in the admin vs client but the operations performed should be determined by the scope and should be performed on the same model.
There's something that puzzles me about this - why must recipes be kept in a centralised repo? Surely it makes more sense for recipes to be maintained in the bundle's own repo where their maintainers can manage their release cycles properly, instead of having to cooperate with a third party on such matters. More importantly, it would significantly lower the barrier to entry and all but negate the concerns that some have had about this becoming a walled garden for Symfony/SensioLabs. The only benefit I can see to having a centralised repo like this is to enable "aliases", essentially short names for packages. However, this feature could easily be retained - have Flex grab a list of official aliases-&gt;package names and install based on that.
No because its _context_ defines what the entity represents. In this case you're thinking about a _record_ in a database. Using the same representation for different use cases, will only confuse any consumers and make it more complex than it need be.
I am sorry, you are right. It does not. Please disregard my comment.
If you are using shared hosting (if that's what you mean by resellers) in 2017 for a webapp, you have much bigger problems than CodeIgniter...
&gt; 5 years old code base, very little planning, and proper design and architectural patterns essentially nonexistent If your goal is hexagonal, it *might* be that you are getting ahead of yourself, architecturally speaking. If you don't already have good layers of separation in the codebase, moving directly to something like hexagonal (and splitting up into multiple repos!) is likely to be pretty difficult. This is the point where I mention my book, [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). It details a step-by-step process to getting that messy codebase under control. Once you have good separations in place, *then* you'll see more clearly where boundaries really lie. (cue the n0xie freakout in 3, 2, 1, ... ;-) 
&gt; Microservices should help with that, and with them you can do a CQRS approach, scaling where you need it. This was precisely my plan. I really don't like our actual REST API -- it's a mess. But I was going for a CQRS approach, backed with something like AMQP, Gearman, or Beanstalk (wanted to even take it a step further and make the actual protocol itself agnostic)... Particularly for scalability and that if done right I could actually execute a lot of the commands async. (And, yes, it would honestly speed up and simplify parts of our code significantly). Basically, I _think_ the right way is for my application to call my domain model, my domain model to call the CQRS, CQRS to call a worker via a real queue. And this is where I get really confused. Because it stands to reason that validation should occur within the AMQP worker. But the AMQP worker isn't a part of the domain model. This seems like it would be just as bad as validating at the persistence layer.
&gt; What do you mean by domain model? An active record entity or the domain layer? The actual business domain layer. Using my inventory items as an example again, let's consider a database that looks like: Inventory: id | name | price InventoryImage: id | inventory_id | path OK, .. So the way I _think_ it's supposed to work, and certainly what makes sense to me, is that we have a `\My\Model\Inventory` which is the business logic. It is not an active record nor entity. We might have `setName()`, `getName()`, `setPrice()`, `getPrice()`, `addImage(id)`, `removeImage(id)`, `getImages()`, etc... This is also where, if I didn't want negative prices, I would implement the rule for that. Within that domain model, it would use `\My\Entity\Inventory` and `\My\Entity\InventoryImage`, each representing one unique row, to actually complete the work. Is that generally correct? Because, if it is, ... by throwing ~~CQRS into the mix, which I believe does make a deep amount of sense for parts of our application, I even get more confused, because then if I have a domain model calling a command, -- well it's not really a domain model anymore is it? Since we've removed the logic from it.~~ edit: see reply 
I'll second this question. I've never had an issue finding 95% of the packages I need in [Alpine's Package list](https://pkgs.alpinelinux.org/packages). If that fails then `docker-php-ext-configure`, `docker-php-ext-install`, and `docker-php-ext-enable` has met my needs.
I use them on getters/setters, not so much on magic \_\_get/\_\_set. Which, I guess may not be what he was talking about. However, magic methods have their place, as as you're careful. 
Their documentation is good. Check it out: https://www.gitbook.com/book/delc82/yii2-guide/details
impostor syndrome... it's a thing! I am not alone!
&gt; let's just say it's pretty much worst case - already 5 years old code base, very little planning, and proper design and architectural patterns essentially nonexistent Hah. Try a 13 year old code base. I've been here over 6 years now and still haven't gotten it under control.
To be clear... this is a GraphQL server implementation written in PHP, to be used with an Apollo JavaScript client? I'm looking for the opposite -- a GraphQL client written in PHP to be used with apollo-express-server.
It's not a bad idea, it's perfectly valid syntax, and you seem to already understand it. It's like `new self` but with late-static binding. Use it, if it's useful :)
Great. It's weird that PhpStorm doesn't do this out of the box with frameworks like Laravel being all the rage. You have to go and configure namespace prefixes manually every time you start a project.
The documentation on how you can use self/static is on the [late static binding](http://php.net/manual/en/language.oop5.late-static-bindings.php) page. You're right, they don't *explicitly* say you can do `new self` or `new static` - but I think the idea is that it's implicit. There's a whole host of things you can new up, including strings - anything that resolves to a class, really. Which `self` and `static` do.
No the domain logic is not calling a command. Commands would be the application layer, but that's just one way of implementing it. Think of it just as separate entities for the read and write side. CQRS allows you to use a simple table gateway or query for reading while you use a entity with business logic for writing. There are many different ways of implementing CQRS, but the basic principle is quite simple. You can think of your business logic method as the commands if that helps, commands are what changes state (I know there are more complicated patterns with command objects and eventual consistency, but that's overengineering for most webapps imo). An entity is a class with an identity. In case of your inventory, that would be one. If they don't have an identity, they are value objects (price would be one). Your rows and business objects don't have to match one to one. Start with the domain first and worry about the persistence after. But I think generally you are on the right path.
Imagine working on modular framework there is over 50 components and .idea folder is not present in repository...
I couldn't find a documentation on php.net either, but I have used the `new static()` pattern myself too. Not only this, but `new parent()` and `new self()`are valid syntax too. 
Nearly spat out my drink reading this. Okay yes Node is cool and the "Future" but to me the future means that you don't have a requirement list as long as your arm and a flaky system that combines it all together (npm). When node sorts out npm things will be a lot better than it is right now. But that is my humble opinion. 
It's a GraphQL server implementation for any client. Just the resolver resolution part is based on how Apollo servers does. But building your own client to query GraphQL servers isn't that hard. It basically sends a query, operation and variables data through a HTTP POST request. You can use Postman, for example, to test out GraphQL endpoints.
Pretty hard to buy a community project, no?
&gt; it (PHP) will get purchased and ruined by Microsoft "as it has happened with a number of technologies". Did he pulled this out of his ass ? Or is there anything to back it up ? Because I can't see Microsoft buying PHP in the future. I don't even think the way PHP internals works would allow it.
That's the thing, none of his statements had any evidence backing them up, that's why I'm trying to find out if there's anything that I've missed.
There's the door. Don't let it hit you on the way out.
Thank you for the condescending tone? Actually, I'm working in a Fortune 500 as a senior back end eng. If you think every web app in 2017 needs a CDN load balancer... perhaps you are the one who doesn't know what he is talking about. 
Eh, we decided to use it a couple years ago. We're too far in to back out now and port our stuff to a new framework. Too bad. ¬Ø\\\_(„ÉÑ)\_/¬Ø
Actually, I was even more confused than I thought. I got CQRS confused with another wildly different design pattern, of using service layers over a network queue. 
&gt; even though it seems like a lot in overhead There's actually almost no overhead at all. It's all about structuring your code in such a way that it doesn't mix concerns. To show a co-worker what DDD looked like, I wrote a very simple [example TODO app](https://github.com/Garethp/hexagonal-ddd), that probably doesn't run but shows the point. It may be a couple of files here or there, but it took 10 mintues to write. Maybe 15. &gt; each has their own unique inventory item model at present and this is terrible (I don't mean they have copies of the same model, I mean they have their own super unique models .. each may have specific use cases added or removed, but they could easily be shared). Maybe this is bad, but maybe they're not. If they're truly unique, with their own use cases, then it's likely that they are their own individual concepts. Just because they look similar, and share some of the same functionality, doesn't mean they have to go together. DDD is, at it's core, about the Business. If there are different use cases on the Business level, then they should be different in the code level as well. You don't try to merge the concepts because it makes for less code. Remember: It's called **Domain** Driven Design, and the Domain means your business. Your code is meant to match the business cases. &gt; To combat this, I am trying to introduce a 'common' repository with basically any code that can be shared across more than 1 application I would do this for infrastructure only. Nothing is "shared" across the whole application, not really. You break your application down in to different contexts, and then you realize that what *looks* like it's being shared really means that other contexts are depending on a centralized context or two. Once you draw out your context map, and find out what contexts keep getting used everywhere, you can draw lines to say "Hey, this context is depending on that". And rather than trying to merge contexts together in to a "Common" one, to make it easier, write those dependencies in to your code. Create an Anti-Corruption Layer, make composer dependencies, whatever. I'd say *Maybe* an Anti-Corruption Layer could be in a Common Repository, but if you drill down well enough, you should find that even if a Domain Model is used everywhere, *how and why it's used* should be different for each Context. Remember, DRY isn't about not repeating code. Don't see code that looks the same and think you need to abstract that away. DRY is about intention. It's about not having the same code **for the same intention** in multiple places. 
I would reach out to the old organizers and see what insight they can give you. See if there was a reason the previous one died. Was it lack of talks, lack of users, lack of sponsorship? Other than that, register the group with meetup and start marketing it online. If there's any kind of community events about development in general, go there and gauge interest. Try and lock down some sort of sponsorship with someone to get a space, and some other niceties for the rest of the meetup participants. Just my two cents.
Your two cents is worth quite a bit. Thank you!
No problem
https://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612
Interesting. Took a quick glance through the code and it looks really clean nice job. Will have to play around with this over the weekend.
&gt; I wrote a very simple example TODO app Well, this is actually one of the points I am attempting to get at here. With a very small group of models/entities, and ridiculously simple business logic, DDD/hexagonal/etc all makes perfect sense to me for the most part. It's when I am trying to scale up to an application that has over 150 tables, in use by approx. 300 customers and runs over 600 unique websites that things are falling apart for me. Not that I couldn't "hack it" -- but I _really_ want to do this right. I've had to live with the consequences of previous developer's actions for nearly 3 years now -- I may have to live with my own for many more years to come. &gt; Maybe this is bad, but maybe they're not. If they're truly unique, with their own use cases, then it's likely that they are their own individual concepts No, we're talking -- 90-95% of the models have at least 1, if not 2-3 duplicates that cover the exact same crud-like use cases. &gt; I would do this for infrastructure only. Nothing is "shared" across the whole application, not really. No, I believe you are correct when you're saying nothing is shared across the application. But refer to my previous statement -- our infrastructure layer is pretty big because it's just a pretty big and diverse application. We have 150 relational tables, some of those are very wide, we have very large EAV tables.. We cache a lot of data in redis. We have a lot of (non-critical but) authoritative data in redis. We recently began moving a lot of our data to ElasticSearch, -- which the data is being copied there via a timer at present -- since it would be impossible to do something as _crazy_ as say "write inventory to the relational database and elastic search at the same time" because since data access is so disparate, it would take a day and a half's work just to find all the different places it's being written to. We have several million S3 objects as well that would definitely fall under persistence. &gt; you should find that even if a Domain Model is used everywhere, how and why it's used should be different for each Context. I just don't understand how this could be true. What about the simplest of all examples -- performing some function over both the "regular" user interface, and also duplicating that functionality into a REST API? Don't get me wrong, I am not in love with the idea of shoving a ton of fairly disparate business logic into the same repository that'll have to be pulled down as a composer dependency in every one of our projects. But I do believe I have an appropriate use case for at least some of it
Yii2 is an absolutely awesome framework, I reckon you'll do pretty well. I taught myself Yii2 with some help from the usual documentation, SO, and asking the occasional question in the IRC chat (note, don't expect a quick response, but patience definitely pays off). I usually leave IRC as a last resort personally, because I don't want to bother people if I can find the answer somewhere else. One of the core maintainers, /u/sam_dark has a book you can find online here: https://github.com/samdark/yii2-cookbook If I can make a humble recommendation, it would be to switch from vim into something with good autocomplete and source navigation (or maybe there's a vim plugin out there that can do the trick). Even a trial version of PHPStorm would work well. It really helps with navigating through classes and understanding how the feature you are using has been designed. Yii2 is very low on 'magic', so you will learn quite a bit by inspecting classes. This is how I best learnt the framework. Lastly, if you have any questions at all, feel free to PM me. If you haven't already guessed, I'm a big fan of Yii2 and would love to spread the word and give a leg-up if I can. 
For migrations, check out phinx.
I'd still go for 3v4l.org or create a local script to invoke from my IDE. Funny little project, but I don't think it really adds much.
This is a question for a YouTube support channel or maybe a subreddit specifically for YouTube. Your using PHP variables doesn't really make this a PHP issue and if it were, there is a PHP help subreddit.
https://medium.com/fuzz/php-a0d0b1d365d8 "everyone knows that single-threaded, asynchronous, programs are better by default. Faster. Stronger, even."
Do adblock type extensions affect that? And yeah, this is a question better suited for YouTube support to answer.
Currently I am following this book https://drive.google.com/file/d/0B3tK-UlwC-LeMzRyWWo0VnQwd1E/view
Is it just me or does it seem really silly to use PHP like this? I really don't think PHP has any business being used as a command line language...
So, are you under the impression those things will not be achievable when running scripts from your IDE? Is there a feature set in here I'm not going to be able to use from a temporary script or scratch file? I'm looking for any benefit to running this. Is it maybe intelligent enough to find the autoloader in the local vendor directory? 
Really? I use php on the command line all the time. What do you use to create your command line tools?
Python
Upon further inspection, I see two reasons not to use this. The first being I cannot install it as a dev requirement in my projects, so it needs additional installation steps that haven't been documented. Further, your runtime is opinionated by applying a custom ini.
* 1) Forget most of what you just learned * 2) Goto [Laracasts](https://laracasts.com/) and learn how to do things proper * 3) ???? * 4) Profit!
I don't see any real advantages to using python since php has a very robust command line interface but if you want to port this to python or any other language I would be interested in your take on it :)
I fail to see how cloning a repository and configuring a separate dev environment next to the one you're working on is taking less time than creating a new file and requiring your autoloader. It all seems like you're trying to solve a problem that doesn't exist. And it's solved in an opinionated fashion, not compliant with modern development, so it's harder to use than readily available conventional solutions. I still applaud the effort, but fail to see the added value to the overall community.
Why does everyone think that doctrine is an overkill? I'm not pretending that it is lightweight, but which step of the setup is making it hard to use? A minimalist setup includes: * an entity class * an XML mapping file * `bootstrap.php` (~10 LOC) * `cli-config.php` (~3 LOC) If there is anything making this feel "complicated" or "overkill", I'd like to know how to improve the manual
This site tells you exactly how to move on from w3schools. I'm not even joking. http://www.w3fools.com
It's under example #5 here http://php.net/manual/ro/language.oop5.basic.php#example-175 
First thing I thought of. Php5 is so nearly end of life now
It's allow you to use raw SQL
At the risk of being accused of self-promotion (ha! :-) you might want to take a look at [Atlas](https://github.com/atlasphp/Atlas.Orm).
Maybe, because on simpler ORM, you would only needs 2 step: * an entity class, extending ORM's class * `bootstrap.php` But yeah, no migrations or cli tools.
http://www.phptherightway.com now that you've learnt how to use the language basics it's time to learn how to use them properly.
Here's the ultimate guide: https://github.com/ziadoz/awesome-php
Thanks!
Really clean code and actually useful! Nice one
Oh yeah, your right! Going to a YouTube channel now... Sorry and thanks anyway. 
I want to be a Back-end Developer. Thank you for your advice
than you very much. i really appreciate your advice
To comfort OP a bit: what you've learned about SQL queries itself is probably right, the abstraction thaught by w3schools is terribly outdated, though. Outdated, wrong and insecure
I really need to give this to some of my co-workers. Thanks!
It looks really nice! Maybe it's my inexperience talking here, but what's the use-case for it? The README states the following; &gt; a great way to automate initial build tasks. So would this go to multiple virtualboxes at the same time?
I would also try to look at restful api development. If you can master when to PATCH POST and PUT, it will serve you well as a back end dev
Why are people downvoting this? Canvas is a great blog based on Laravel. And even if it's not amazing, it's still a nice PHP resource.
Thank you everyone :)
Then you could not generate the schema through doctrine ORM but migrations and just validate it. I also often get the impression of not mastering Doctrine, but honestly it would be the same for any ORM and anytime Doctrine gets in the way, you actually should use SQL instead.
You can buy a VPS for 5$/mo. I don't care where you work or what title you put in your CV. If your employer can't afford that, you probably should refresh that aforementioned CV and start looking for a new job.
Laracasts has a good PHP fundamentals course that will help OP learn industry best practises for PHP development. I admit this is way to early for OP to jump into a framework, but Laracasts has loads of useful videos on plain PHP and programming in general.
You can't write `class extends static`, or for that matter `class extends self`. For normal classes that's pretty obvious, but for anonymous classes at least the latter form makes some sense. The reason it's not supported is that due to closure rebinding `self` is not actually a fixed class.
PHP7, oh ho! just kidding ;)
Thanks that makes sense! As far as disabling, I'm just using `'` to make it go away. 
Agreed with this one. Please do learn the crucial parts of the language first before trying to learn how to use other technologies or frameworks involved with it. Most learners tend to jump off to these frameworks because they find it really popular or "currently in-trend", without even knowing the crucial parts of the main language itself. Yeah sure, you get to have an easier way of doing stuffs with frameworks, but it's like giving a child a condom without giving him proper orientation about bananas and peanuts. 
https://imgur.com/gallery/Y2PEu Street Fighter PHP
Might have something https://github.com/docker-library/php/issues/207
&gt; Before i came here to ask, what i planned to do was to learn Laravel, and then learn bootstrap and afterwards learn node.js. what do you think? Don't try to learn everything at the same time. Being beginner in 10 technologies is far less useful than being reasonably good in 1.
Thanks man, really appreciate the kind words! 
Make sure you use canonical links when linking to a file/directory. On GitHub, you can press the "y" key to update the URL to a permalink to the exact version of the file/directory you see -- [source](https://help.github.com/articles/getting-permanent-links-to-files/). I've tried to fix your links: Relative | Canonical -|- https://github.com/api-platform/core/blob/master/.travis.yml | https://github.com/api-platform/core/blob/141530cbbe82e5291a34b92172938dc8c02e9d3a/.travis.yml Shoot me a PM if you think I'm doing something wrong. To delete this, click [here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgk2j9n.)
 &gt; We are using doctrine at work for a long time but nobody with a confidence can say it has mastered it. Please just use: * `EntityManager#find()` * `EntityManager#remove()` * `EntityManager#persist()` * `EntityManager#flush()` * `EntityManager#createQuery()` ([ebnf](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/dql-doctrine-query-language.html#ebnf)) There is absolutely no need to master the ORM, unless you are doing some crazy trickery (that you probably shouldn't in first place). &gt; One big complaint are doctrine generated foreign keys which can not be renamed to human readable format without messing up migrations. Those are excellent suggestions, but the schema tool can only help you that far - the rest is migrations regardless of the tool. We'll try adding FK names to V3, but that won't save you from migrations regardless, since the assumptions of an ORM and a DBA will always differ in multiple locations. 
Checkout www.laracasts.com.
&gt;$array-&gt;intval === self::NO_INTVAL huh? why not just use `is_*()` functions instead of this weird construct? it seems very error prone
Doctrine appears to be heavily influenced by hibernate. Would you say this is true? Unrelated to the current topic but I've been wondering for a while.
Very interested about performance gains on v3 ORM, do you have any rough indication whenabouts will it be released?
or you know you could use an ArrayObject :P
&gt; Laravel is a minefield you can't really navigate through without **blowing yourself** at least a few times Now I get why Laravel is so popular ( Õ°¬∞ Õú ñ Õ°¬∞)
PDO, phptherightway, OOP, write some simple websites/webapps: - todo app - some simple blog - some simple shop And other things you will have idea. Best in plain php in OOP matter, then switch to some framework and do it again IMHO
We're using it in production ourselves, as are a small number of other adopters.
Im learning html/css right now on codeacademy. Is it also a good website to learn php?
&gt;afford that wow.... Mr Assumption, I have 21 freelance projects in a shared hosting, they actually sum for a very nice extra each year. Haven't move them to digital ocean or AWS, because I don't want to invest the time, and really they just do fine there. 
u/ocramius &gt; If there is anything making this feel "complicated" or "overkill" That part was ok, in fact, it was the most easy part. &gt; I'd like to know how to improve the manual I've been playing with Doctrine for the last 8 hours and so far here's what i found: - Online documentation is ok. However, the search bar return a 404 page. - "Getting Started with Doctrine" and "Installation &amp; Configuration" are very similar. - GetEntityManager() function does'nt exists and don't know why, but it was easy to get around. Also, i'm not sure how to handle properly multiple databases with dynamic names and cross database relations. I really want to use Doctrine 2 but i'm short in times and have complex structure (multiples db). I'm afraid that i will make architectural errors in the beggining only to find after a while that i'm screwed mainly due to my inexperience with Doctrine. I'll continue my exploration with doctrine take my final decision afterward. Thanks for taking to respond to my initial post. 
You have typo, in one there is soboury and in second soubory. 
Don't discount php 5 so quick it may no longer be supported but there are still tons off companies that use/have to support apps in php 5.
Thanks for the thoughts. The main loop has several hooks where other developers are able to add callback functions. Unfortunately in some cases their code has had infinite loops or processing a chunk of data takes a really long time. In other cases we don't know if it's just taking a long time or if it exited abnormally. With ticks, we can be guaranteed a periodic update, even if the other dev's hooks take a long time. I agree that it's not ideal, but until everyone else writes perfect code I don't think I can count on logging in the loop to provide the frequency of updates I need.
&gt; I don't believe ticks will interrupt a blocking call That's my understanding too. 
Node is nice and everything, however it's still quite early to say that it will kill php, I've heared there're people like these around and the only thing I can say is they really don't know much what they are talking about themselves. Yes Node is new and yes php is old, yes many people use node instead of php but here's the thing, and I hope I'll convince many people: php is a mjltipurlose language at its core philosphy and it has been like that since the beginning, it's also true that php used to be a procedural only language (php 2), and here we are today (php7) with a language which provides classes,interfaces, anonymus classes and functions. And all of this happened because the comunity requested it to a certain extent. What I'm trying to say is that saying it will die is not only nonesense, but it's also foolish, by nature it's a language that has been experiencing changes, just like other languages such as java. Php is a very stable language as it is right now, it's not perfect for multipurpose programming but it is very good at doing what it was meant to do: web development. HOWEVER, imo it has yet to evolve, it won't die in 7 years, infact I think (and I really hope!) that php as a whole language will be starting to branch to a more multipurpose oriented development, and we see that with different extensions and libraries such as pthreads and ratchet project. Php can do the exact same things Node can do with Ratchet and pthreads extension, I'm working on a university project using those two combined with sockets, and it works just perfectly. Don't drift away, learn more about the language before dropping it, you might find out there's actually more to it than these kind of people belive there is! 
Bedrock/Roots
Here, take my up vote.
Just show him `npm install`. Then, after the 30 minutes that takes to run, calmly explain to him that within 7 days (give or take), one of those 1000's of packages will either disappear or break some kind of compatibility within a mini point release. Developers will be forced sink hours trying to track it down to find the exact version they were using before so that they can pin to that version, and start using `npm-shrinkwrap`, which for some reason is not a default npm behavior.
Off topic but I don't know why but I can never really get on with Google Groups. But then I have the same problem with classic forums and email chains where it's hard to follow the thread of the conversation and it's all separated by a load of whitespace
Respect for trying to bring namespaces, contemporary PHP, and (piggybacking) Twig into theme code. One github star. 
Ran this on our legacy API and am in a state of mild shock. There's a few features I'd love: - A counter! Give us a tally of how many it found and we can work at decreasing it over time - the ability to exclude specific files. I know there's excluded folders but there's one or two files that just have to suck
You make a very good point. I disagree with the part of deeply nested arrays though. Usually the presence of a multi-dimensional array is a sign of poor application design. In my application arrays are almost all one-dimensional, with rare occasions of two-dimensional, they never go three or above. Consider refactoring your code if you end up with too many multi-dimensional arrays. 
Microsoft cannot buy a community and Node.js won't be the successor of PHP. BUT, keep an eye on ASP.NET Core!
PHP-FIG needs to throw in the towel to be honest.
This is Symfony's HttpKernelInterface and Stack‚Ä¶ Nothing new here since it's how middlewares started in PHP \^\^
"It started as an exercise to play with some of PHP7s new features" Edit: I misquoted op slightly, I can't reference it while posting on mobile.
Sure is. Check it out here: https://cnvs.readme.io/docs/changelog
You got it :)
It was a completely arbitrary decision. I just wanted to use some PHP7 features. In the end I only wound up making use of return type declarations and scalar type hints so it would be fairly trivial to drop down to 5.6+. Oh - maybe some grouped use statements in the tests... As for PHPUnit - version 6 hadn't been released when I wrote the bulk of this. I considered updating but had some issues with Mockery. However my use of Mockery is very minimal so it should also be fairly trivial to drop it completely and update PHPUnit.
I assume you are talking about a single template file doing all those things? If so, thats kinda why I started using this MVC structure in my own sites. Instead of having, say, a custom subscription page template named page-subscribe.php that has all the html with the form, the php to process the subscription on submit, blah, blah blah... With this, the template file is a controller class. For custom page templates, say a subscribe template like above, instead of including the page-subscribe.php file, it calls the showPage() method on the Controllers\PageSubscribe class and from there, you can break up the chunks of code into separate methods in that class, and call $this-&gt;render() to call to render the twig template. And since Subscribe pages don't necessarily need a lot of copy editing done to them and can stay relatively static, the other option would be to just make the page a custom route so you can use: Use this to display the subscribe page using the Controllers\Subscribe classes showPage method (new Spinion\Route)-&gt;url('subscribe')-&gt;methods(array('GET'))-&gt;controller('Controllers\Subscribe@showPage')-&gt;call(); And this to process the subscription (new Spinion\Route)-&gt;url('subscribe')-&gt;methods(array('POST'))-&gt;controller('Controllers\Subscribe@subscribe')-&gt;call(); I basically wanted to mimic what most frameworks out there do with the request coming in through the route (or in this case, the non-custom routes go through some internal wordpress routing which Spinion then translates to a class/method call for you), pass to the controller that then renders the view. edit: tried to fix formatting. Those chained method calls are ugly but im tired of fighting the formatting
Doesn't Wordpress provide some sort of method to register routes? Does it always have to be regular PHP files without a framework like yours? Not a rhetorical question but I always thought Wordpress provided some sort me route management system at least.
Not disagreeing with your general sentiment, but there's no way a PR for this would be accepted.
&gt; So, when it comes to becoming a professional developer, all you should care about is how much you can make doing it. That's where you earn the money and save the time, to do the things you are passionate about in your own time. I don't know about this. I work for a company now that makes health care software, but I have the chance to work for another company that makes MLM software (pyramid schemes), that pays ~50% more. I'm not sure I'd be too happy with myself if I made a handful of people rich while sucking the souls of hundreds more. Also.. the technology *does* matter. Do you want to tinker with the latest tech and work at a leisurely pace, or do you want to 'get er done using crappy tools from the 90s because that's what the current codebase uses and there's no time to refactor because there's money to be had?
Glad to hear it and I hope it works out for you!
Missing interfaces, classes from ecma6(when php had them from php5, it's 13 years ago! pretty much oop with classes and interfaces). No real namespaces. Just compare when js got some new features, most of them is from 2015-2016, when php had them like many years ago, when nodejs will be usable anyhow php will have already jit, async, await, defining variables using let or type and performance something like 5 times faster than it is right now making it as fast as nodejs. Also npm is just huge problem of nodejs, it's slow and time wasting.
On mobile, so won't be able to answer your question directly ATM, but you should post this to /r/phphelp (linked in the sidebar)
Thanks everyone for your replies.
Looks like good old OOP. I call these *actions* or *commands* though - middleware (type) seems a bit leaky to me. Implementation might reveal its middleware nature, but all I expect from injected dependency is that it returns response.
Thanks! For what it's worth, I think that the best way to do this would actually be to use a real daemon which forks off child processes. The child PID could then be returned and signals could be used to ask for a status update only when needed. However, this will be executing with the FPM SAPI, so pcntl_fork and friends won't work, but *declare(ticks=n)* does. I do have the ticks number set high (to 100 ATM for testing) so that the interruption is less frequent. 
&gt; `apt-get install php-cli` Why not ruby too? Or NodeJS? Sure, root *can* do it, but there's something to be said for building tools that are less-likely to require your target user-base to install dependencies they wouldn't otherwise need. &gt; The GIL prevents good threading. That's not a fair comparison, since regular PHP doesn't have *any* threading at all. You'll need to install a third-party extension that **only** works in the CLI mode. Plus, a lot of the threading-benefit for these kinds of tools we're talking (e.g. something sending keyboard scan-codes) is not raw number crunching or executing huge blocks of code, but the ability to gracefully handle waiting and background tasks. The GIL impacts that much less. &gt; PHP and Python are pretty much equivalent in terms of async support - both languages lack async primitives but have nice libraries that fill that gap. Untrue: Python has had `async` and `await` keywords since 3.5, released back in 2015. In addition, many of its relevant libraries are *standard* rather than something third-party you need to download or repackage. &gt; This is absolute nonsense - please provide me an example of something you can do with Python in regards to processes, streams or signals that you can't do with PHP. Depends, are you talking about standard libraries and core functionality, or the hard-to-survey field of "anything an administrator could ever find online and recompile/install"? &gt; Python is much more academic based, meaning it's provisioning and deployment stuff tends to be less polished. Sure, there's an academic aspect, but it's also much closer to being the "sysadmin swiss-army-knife" as it takes over jobs from Perl, which influences where people invest effort into the language and standard libraries. That's why I generally prefer Python for CLI tasks.
We use DI on our middleware constructors and this solution would cause php to throw a warning that the constructor is not compatible with its parent.
IMO it's a bad idea to make any objects that can be "confused" for a native array. It's not safe to mix them since they don't behave the same when it comes to mutability.
n0xie, Things are making a lot more sense. I was way off base. One thing I am still slightly confused on which I cannot find an answer on, however: Are doctrine models/entities containing very little logic in themselves but assuming doctrine will persist them -- are these anemic models? Just data objects? What are they considered? 
r/phphelp next time. Try bind_param instead of bind_result. And... would you not bind before executing? 
Hi, I appreciate very much your post and the whole discussion. I will try to follow your advices.
This is a valid approach, but personally, I wouldn't go for object classes that are named after an action. Object classes should be named after an object (value-object). The opposite is true: service classes should NOT be named to look like value objects. I don't know the specifics of your problem, but my preferred API client classes usually look like this: class IssueApiClient { public function submitIssue(Issue $issue); } I append `Client` to the API class name when it's a remote API, and use `IssueApi` when it's within the same application (for smaller apps this may not be so useful). You can create a separate ApiClient class for related API method groups (e.g. methods for issues, methods for users, etc.). Then I create a corresponding method in the class for each API method. Next step is to explicitly define the parameters for the method call, so the user doesn't have to build the call himself (e.g. `submitIssue(Issue $issue)` instead of `request(array $options)`). This is the main point. 
Thanks for your response. How do you separate these clients from the lower level things such as handling the instantiation of HTTP client and building the JSON request and parsing the JSON response? Where would you put these things in your solution and how would you inject/instantiate the HTTP client?
Yep if you're using the Symfony2Extension you can run your Behat+Mink tests through the Browserkit stuff (https://github.com/Behat/Symfony2Extension) A better strategy is to validate most things not through the UI
Have you checked out Expressive 2.0? It's basically just a router/template engine and a container which takes from: &amp;nbsp; Routing. Choose your own router; we support: - Aura.Router - FastRoute - zend-router &amp;nbsp; DI Containers, via PSR-11 Container. All middleware composed in Expressive may be retrieved from the composed container. Which is used in an [interesting way](https://github.com/zendframework/zend-expressive-skeleton/blob/master/src/App/src/Action/HomePageFactory.php) &amp;nbsp; Optionally, templating. We support: - Plates - Twig - ZF2's PhpRenderer &amp;nbsp; Error handling. Create templated error pages, or use tools like whoops for debugging purposes. &amp;nbsp; The rest is up to you mostly. More info [here](https://zend-expressive.readthedocs.io/en/latest/) - [skeleton app](https://github.com/zendframework/zend-expressive-skeleton) if you want to see if it works for you.
Well I have been reading it for a while, and y'all are definitely winning on SEO, because most of the time I read your articles from a Google search. I like how the articles have substance, I dislike when I start reading a series and they don't link to each other. 
I just disabled my adblocker to see what kind of advertisement it is (Edit: Well, no need to disable it actually). Where is the problem? It's not a big animated skyscraper or anything related. On top of that, the ad is tech-related. You can use the framework without paying a single penny and the ad doesn't disturb taking a look into the docs at all, I'm fine with that.
Preach.
Nah it's fine as long as it's not video ads, or resource hogging ads, of 1 page full of ads
This. Me too passing PDO instance on my `phinx.php`.
PHP for beginner. It will much helpful for the beginner to start 
Offsetting the cost of some additional hiring I'm doing around UI / frontend design for various things I'm working on related to the Laravel ecosystem. I am still undecided if I will keep it. It generates about $5,000 / month which is nice but not sure I like it on the sidebar like that. After this first full month I will decide if it's worth it to me or not. I am a fan of the Carbon Ads overall because they tend to be pretty relevant to developer interests.
Basically you prefer to carry your keyboard around rather than keeping config files in some sort of cloud storage.
Carbon ad on the top of sidebar.
Ahhh I see that now on my laptop. Thanks.
Thanks. I'm personally really getting annoyed by the request super global. This really helps :)
This article is not written by me. You are just misunderstanding and getting misdirected
Maturity of a language can be a huge benefit from what I have seen. Being able to search the most specific and strange things will still yeild helpful results. I started in PHP because that is the language my brother works in. I am grateful he pointed me in this direction!
Please stop this low quality spam, what's the point of this? 
1) Install VirtualBox 2) Install Linux 3) Install PHP 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [jmauerhan/phantomjs-behat-selenium-example/.../**.travis.yml**](https://github.com/jmauerhan/phantomjs-behat-selenium-example/blob/ff4c81626467eeaed96d2027d42b9ae59d852c15/.travis.yml) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dglz7qe.).
My favorite components (packages) for a full stack framework are: * Router: symfony/routing * HTTP: symfony/http-foundation * Text translations (i18n): symfony/translation + Poedit * Caching: symfony/cache * Logging (PSR-3): monolog/monolog * Console: symfony/console * Templates: league/plates * SQL Query Builder: cakephp/database * Database migrations: robmorgan/phinx + odan/phinx-migrations-generator * Unit tests: phpunit/phpunit * Directory structure: php-pds/skeleton If I would build a PSR-7 framework (with middleware etc...) I would recommend zendframework/zend-diactoros, relay/relay and nikic/fast-route for the HTTP layer.
&gt; Basically you prefer to carry your keyboard around At no point did I say that. ever. I said if I switch from my desktop to my laptop (which I often do when switching between work and personal projects) which are both sat on the same desk and go through a monitor switch. Anyway the key benefit to this set-up is no matter what I'm developing in, even the command line using Vim or Nano, my macros work just the same regardless which is a huge time saver.
TBH this is a case where I prefer using Vagrant over just VBox
&gt;Best Outsourcing Sowtware Farm Get outta here!
hope you will like it https://sabuj.me/it_0_54-career-in-cyber-security
I'm sorry, what are you trying to achieve? Create backlinks? Anyway, this blogspam is helping no one.
Are you crazy, forms in html are giant wads of html spaghetti. Look at how easy it is to read, update and modify as small methods...
If you enjoy that workflow suits you then more power to you, but your use-case for why context-less macros "are the future" is absurd. If you're that gung-ho about efficiency why are you using a monitor switch in the first place? A simple Samba/Network share would be more efficient, and you wouldn't have to (a) physically move your keyboard to your laptop or (b) set up synergy to work on a host/client config between the machines.
It is all about reusability. You might want to add the same form in different places, so it will be the same. At the first look it seems like a lot of extra work, but later it will help you out. It is comparable to unit tests. At first it looks like extra work, but later on it will help.
This looks very interesting.
&gt; Then you're already smarter than most beginners. Right, don't try to understand why thousands of top level developers are all doing something the same way, just throw it away and write everything from scratch.
Recently started an api-based backend with - Zend expressive 2.0 - Twig - Nikic Fastroute - DoctrineORM (for schema generation, migrations...) - Zend-db to actually access the data (I like it a lot, this is probably the most hidden gem) - DI with zend-servicemanager (very nice one too) - Symfony console - Chronos for date manipulations - Monolog Till now I really like it... 
The developers of Symfony, Laravell, Apple, and more. I lived in SF too. Now I work from home 5 days a week, so it doens't matter where I live. You sound like a pompous ass.
It's still going strong. I'm actively working on v1.1.0.
So the reason you use a monitor switch is because your government's contracts require you to multiple systems? That doesn't make any sense. My primary workstation is a windows machine, my NAS runs centOS. It seems like you're arguing that I'm proposing you should only use a single OS? Also, my condolences on having to take government contracts (I remember those days). Keep working hard and you'll be able to take on better clientele one day.
It shouldn't even be applicable. The moment you start trying to integrate deployment with specific frameworks it the moment you make assumptions about how that framework is being used.
Agree 100% on your last point. public static function unserialize(array $data) : static; This is clearly the right signature for an `unserialize` method. Edit: I've done some work in one of my own projects with serializing and unserializing data, and in practice it became rapidly clear that the ideal unserialize mechanism is a function which accepts the serialized data and returns an instance of the object. This is what is actually needed in practice and works well, while the alternative (where unserialize merely modifies an existing instance based on the data it receives) does not work well, is difficult to implement in many cases, and makes no sense when you think about it. And in an OOP context, that means that a static method is obviously the right way to go.
I suppose you think you're funny but I'm here to inform you that's certainly not the case. Further consultancy is available on request.
I think you're overlooking a major benefit of the form builder. It's not the templating, it's the data handling, transformations, validation, security, etc. where you see the benefits. If it's custom html (or even no html) that you need, symfony allows that.
Criticism != hate. Can you put the bulk of your framework into a plugin? Themes are meant for decoration, not logic. 
I can't tell if this is sarcasm
I guess I'm still struggling to see the real world issue here. Maybe there's some situation I'm missing where this helps a lot.
Never used Symfony, but I extend the Form class in Phalcon. I actually have my own abstract class in between my actual form classes and the abstract Phalcon one for lots of handy shortcuts for things you need to do regularly, like validation on character length and stuff. I don't even need to write the validation message that the user sees for each field in most cases, because generic things like "Please enter at least x characters in this field" are good enough most of the time. In terms of just rendering some HTML tags, that's only a small part of the function. Most of the usefulness comes from all the repetitive stuff related to validation, populating the &lt;input&gt; fields with default values, and populating the model. And like others say, you're less likely to miss things when you have single class handling all four of: validation, &lt;input&gt; population, model population and rendering. One of the things I hated the most about webdev was all the repetitiveness of form code. No longer an issue, and I get that shit done 4x faster now. When you're starting out and having to learning something new, I can understand the frustration of something you're used to seemingly being made more complex. But you could make the same argument for using frameworks in general. Once you get over the learning hurdle, you won't want to go back. Remember copy and pasting heaps of code before you learnt to write your own functions and classes? Doing forms manually is the same thing. Also as a bonus, because all my forms use a standard "known" structure, it's made it really easy to have all my forms work with AJAX POSTing by default, and regular old style "reload the page" POSTing as a fallback if the user doesn't have JavaScript enabled. Big fan of having all forms submitted using AJAX now.
I don't see why anything needs to be done with it, I've never had issues. Adding an intermediate state feels strange though. But i accept that i may not be using the features where the issues present themselves.
When "potentially long" hits the radar, I typically consider using Gearmand. A bit of setup, but great to have once it is set. Usually combine with supervisor. 
Not really true..the forms are a separate library and you can map or not map it to your entity..it is completely optional. At some point you will have to select dependencies and tools for your project and forms are one such dependancy. It is crazy to work without any 3rd party library and doing things by hand. Now with forms, everything is separated so you either use a mapper or not, it is completely up to you. I include the form library even in my api's just as a validation layer. It is just a class which defines fields and validations. So having in your controller something like if($loginData-&gt;isValid()){...do processing} is pretty amazing. The form is just a wrapper you can just call $form-&gt;getData() and have an array, do your validation, save into db whatever. At the end you will end up with something similar to the form component. You need to have a place where you define your fields, you need to have a place where you define your validations, you need to have a place where you process your request and you need to have a place where you will save the processed data. SRP is one thing but DRY is another. The form component provides you the tools, they are not bound together so there is no SRP issue here. Of course Symfony's Form component is pretty heavy and there is little benefit of using it on a 2 field form without validations but since websites are made out of forms you can get into a form management hell very fast without using it.
Yeah, they do a lot of traffic.
But you can still use a framework and have the application logic and business logic completely decoupled. But if you use the form component, you can't do that.
Take a look at the CakePHP ORM. It is a very good alternative between doctrine and propel. It is actively maintained and gets a larger user base every day - propel seems rather to decline.
&gt; You think Apple use form builders? Considering I helped develop the site, yeah.
[removed]
Post it on twitter and take the feedback. 
Isn't it already part of SonarQube? If not, will it be integrated in Sonar's PHP rules?
Don't tell people to reinvent the wheel to drive well. Either take a look at how CMS/blogs/forums and their plugins (usually lighter) are made, or do a simple project you want. Not just one all already did, because you will only learn to redo everything yourself, which is a very poor coding habit.
‚Üí Project must match a need. If it doesn't, it's almost a lost cause (because you don't have marketing budget/reputation to do so). Find in your friends &amp; contact people who may want to use your project, and share it. That's how I do, even if they're not open-source projects. Lambda users won't give a lot of feedback, they'll just leave if something get wrong (no matter whether they are usual users, or coders using a new library). So turn to people who know you first: they're much more willing to feedback. Last, find communities around your topic (ie: I'm doing web games, so I'm in its French community).
This is a great idea, I'm definitely going to be playing around with this. This kind of tool would be great for static analysis builds, having something like phpmnd.xml alongside phpunit.xml, phpcs.xml, phpmd.xml, etc. could be really handy. Any chance you've got plans to expand it to detect magic strings too? Even if it's just from a list, that would definitely be handy for me to check that things aren't being reintroduced.
Any platforms besides Reddit? I definitely don't want to spam, that just has the opposite effect!
Yeah when/if I launch it I plan to make it a composer package (and possibly a project to make the basic Skelton easier) but I guess it could be adjusted and put it in the WordPress plugin library. I feel composer is really the better method though since almost everything is object oriented in this and autoloading not only my frameworks classes (which I could do in the plugin of course) but the classes the theme developer writes is the best approach - and composer makes that much easier. I also feel like this is something that would be a theme dependency more than a site dependency. 
Yeah I hate building all my forms by hand since Formbuilders are unscalable. ^^^\s
&gt; btw by selecting a framework you are binding your project to it. Sort of. I don't recall if I've blogged this as a subject of its own, but I find it easy to imagine a "user-interface framework" for handling the HTTP request and response, that is completely separate from an "infrastructure" or "application" framework that is fully HTTP-independent. So you may end up binding to *some* framework, but you also need not bind yourself to a *user-interface* framework. (C.f. [Radar](https://github.com/radarphp/Radar.Project) as an example of a UI framework that is completely separate from any domain-building framework.)
Im not telling reinvent a wheel, im just telling to make those applications in corrent OOP matter with some simple and basic MVC, writing it with basic knowledge is really easy and not so hard, and you will know how it works at least before getting know to framework.
&gt; You can bypass rendering a form and render it yourself and have "complete control". You're not "bypassing rendering", you're making use of the tools that Symfony gives you. Like, extending the Twig blocks, using Twig form themes, using the formbuilder options, etc. If you're writing a big block of pure HTML, you're holding it wrong. &gt; You can't attribute to Symfony Forms. Well you can, because Symfony provides this functionality to you.
&gt; If you validate with the form component, then you will have to duplicate the validation for every endpoint. By keeping it separate in the application layer, you can reuse it. If you validate in the form component you do *not* have to duplicate the validation for every endpoint. That's the point of putting the validation into the form component.
There is no form in an API request or file import, but you still need to validate the input. The application layer is not supposed to know about the concept of a form (that's part of the presentation layer) and that's where the validation rules of your application belong. The controllers should just be glue code, not contain any non-presentation logic.
&gt; You're not "bypassing rendering", you're making use of the tools that Symfony gives you. Like, extending the Twig blocks, using Twig form themes, using the formbuilder options, etc. If you're writing a big block of pure HTML, you're holding it wrong. I'm doing neither. I render components through React (and others). They aren't submitted, they produce FormData objects, which are set up as view events, and submitted from an application controller on the client, which is tasked with talking to the back-end APIs responsible for taking that form data in. That's the kind of workflows that are typical in 2017. It may look complicated if you haven't done it, but I've done it both ways (programming for 15+ years), and I can't even tell you how much less code it is, how much more flexible it is, how much better architecturally it is, and how much more interactive and intuitive UI to the user it results in. Especially when you start factoring in support for desktop and mobile applications, which in my case can now use the same server APIs that my React forms use, because they're independent of client platform technology. Symfony's forms exist to support an approach that was relevant 15 years ago, back when I started programming, and hasn't been for many years.
&gt; I render components through React. Okay, fair enough. &gt; Symfony's forms exist to support an approach that was relevant 15 years ago. Uh, not at all. You can still use all of the same form classes. You realize that rendering the form in a template is a separate process, right? You can definitely still take advantage of the form component benefits while using an API, or whatever you're doing with React.
&gt; Uh, not at all. You can still use all of the same form classes. You realize that rendering the form in a template is a separate process, right? You can definitely still take advantage of the form component benefits while using an API, or whatever you're doing with React. Symfony takes on some back-end responsibilities like data validation, serialization etc. but is intended for use with simple HTML forms. Let's say your API takes in a boolean. With Forms you have to specify what type of widget it is: a "CheckboxType", a "RadioType", a "HiddenType" or whatever... if you don't plan to use this information, as you don't render via it, can you tell me what's the purpose of specifying it? None. Without making use of the widget meta-data Forms provides, it's just a basic serialization/deserialization library for validating and producing "form objects". Thing is, a form object can't handle the real-world complex structures that modern APIs take and return these days. Here, I'll take a structure from another recent post I made. This is the kind of "form data" that's coming from the browser while I'm doing data-grid editing of multiple clients's profile information in an admin panel: [ [ 'id' =&gt; ..., 'firstName' =&gt; '...', 'lastName' =&gt; '...', 'phone' =&gt; '...', 'billingAddress' =&gt; [ 'line1' =&gt; '...', 'line2' =&gt; '...', 'city' =&gt; '...', 'state' =&gt; '...', 'zip' =&gt; '...', 'country' =&gt; '...', ], 'shippingAddress' =&gt; [ 'line1' =&gt; '...', 'line2' =&gt; '...', 'city' =&gt; '...', 'state' =&gt; '...', 'zip' =&gt; '...', 'country' =&gt; '...', ], ], ..., ... ] This is actually simplified, in the original example, this was merely one data item, in one command, in a list of commands sent in a PATCH request. But let's keep it simple. What do we have in Forms for building something like this? A list of clients, where in each client, some of the fields in a client are groups of fields themselves (the address fields). We have "CollectionType" type and "RepeatedType" which are again, very, very specific to the kind of widgets they result in, and neither is even close to what we want here. I haven't event mentioned anything yet about how inefficient and error-prone the process of entering form configuration in annotations/strings/YAML is. But it is. Why use this, when I can easily use type-safe OOP validators, with full autocompletion support in my IDE? I think the people who praise Symfony Forms have simply not had the luck of stumbling onto a better approach. Once you do...
Check out the live demo on the first page. Where vardumper outputs a string, Kint recognizes it as base64 and automatically decodes it for you. Then it recognizes it's json and automatically decodes it for you. Then it automatically recognizes a color in the json and it shows you the color and all the different ways to represent it. Along with exactly what line of code you need to get the color out of the json out of the base64. That said, I'd personally use both - vardumper is better for heavy objects since it's fast without configuration. In kint if you don't blacklist your IoC container and dump it by accident it'll take a while. tl;dr: Kint focuses on squeezing out all the information it can get
It's devel that uses it isn't it? Last I checked the devel version was from 4 years ago or something like that. I rewrote it from scratch over the last 18 months: It now has options that will vastly speed it up. For example you can tell it to ignore your IoC container and other heavy objects - that will (drastically) speed things up if you accidentally dump it.
That this isn't built-in had me hammering my desk with my forehead just yesterday. Thanks for writing/sharing. I'll give it a spin in a couple of hours.
In devel? :O
Coolio. Also, make sure you make use of the tools available to you. People are more likely to use something with unit and functional tests, and if you can run that in a CI system, so much the better. Most of the CI tools (e.g. Travis) are free for F/OSS. 
Yes
Then you would have a quicker and better result by not coding it, and just think of how you would do before digging a bit into an existing code.
&gt; Then you use CheckboxType, because that would be a boolean value. Pretty straightforward. How is it straighforward? Why would you type "CheckboxType" for something that you have no idea how it'll be represented on the client-side? A boolean value may be represented via: - a hidden field, - a radio group, - a select box, - a flag that's turned on when you, say, type "I have read terms of service" in a text box, or whatever, - a custom control not part of the standard HTML controls... You don't have to play dumb here, something called "CheckboxType" obviously intends to couple data to a specific type of presentation. &gt; &gt; a form object can't handle the real-world complex structures that modern APIs take and return these days. &gt; They absolutely can, you're just not using them properly. You can easily produce that form structure for an API, and I do it all the time. For your example you could simply have a ShippingAddressType, or some such, and use it as a collection on shippingAddress. Not much to it. To do so you have to implement this interface: https://github.com/symfony/form/blob/master/FormTypeInterface.php Notice how 99% of it is view/template rendering concerns. None of which you need purely to validate data. I can't tell if you're horrible at picking the right library or just stuck arguing the bad side of an argument here. You can always be smarter and say "ok, I guess Symfony Forms aren't for this, my bad". Would you like to put your mouth where your money is? Write `ShippingAddressType` and anything else you need to parse this list of users I pasted, and I'll write a validation routine using my validation library and let's compare. Hint: I don't even have to create a single new class, let alone register them as "a service", and all the other bullshit Symfony makes you do. I can write a parser for this in something like 20 lines of code, zero new classes. By rough estimate my code will be around 1/10 yours and have far more clear expression of intent (which here is just: validate and parse incoming data). &gt; &gt; I haven't event mentioned anything yet about how inefficient and error-prone the process of entering form configuration in annotations/strings/YAML is. But it is. &gt; It is not, but sounds like another "you're holding it wrong" problem. "It is not" is not a proper retort to what I said, unless you're one of those "fuck IDEs, I can write code faster in Notepad" types. In which case, I'd just slowly step backwards and leave the room, I think. You think IDE autocompletion, refactoring and static analysis error detection are irrelevant? You'd rather type half your business logic in PHP comments? You'll have to say something very amazing to make this plausible. &gt; I've definitely had the "luck" of previous shitty solutions that resulted in a whole lot of repetition and crappy code. You're full of it. If you're so open to learning, let's write and compare code. Implement parsing that list of users with Symfony Forms, and I'll implement it using my library. I'll link you to the library source, as well. For simplicity, let's make it so all scalar fields are text fields between 1 and 100 characters. If you want it 100% accurate, we can do that too. I'm pretty sure if we benchmark the resulting code I'll leave you in the dust as well.
Nice, but devel for D8 uses a 'old' way of including it. it's hard linked in the repository instead of being loaded with composer? http://cgit.drupalcode.org/devel/tree/kint
Looks nice, I might try it out. I'm particularly impressed with the "modifier" hack, had to check your code how you did it. That's some serious black magic. But is there a reason beyond "because I can"? Multiple functions or a parameter would do the same, simple and understandable, and also slightly more performant.
Because Kint 1 had it, and I'm not going to throw away good features :) Besides, since I have to check the source code to get the parameters for the access paths anyway, supporting the modifiers is the easy part (30 out of the 450 lines) Note that Kint *also* has parameters for most (All?) of the modifiers so making a function to do it is easy. Example, the `!` modifier: &lt;?php function dx(){ $stash = Kint::settings(); Kint::$expanded = true; $out = call_user_func_array('Kint::dump', func_get_args()); Kint::settings($stash); return $out; } Kint::$aliases[] = 'dx';
The Symfony component also gives you error handling, CSRF protection, event handling, a much more sophisticated validation constraint system, and more. I'm on mobile right now. I'll post how I would handle your example with the formbuilder in a bit.
Kint 1 was very rigid. To change just about anything you needed to at least drop a file inside the Kint folder, probably change the files themselves. It probably wasn't feasible to include it normally. Kint 2 fixes this. You can change almost the entire system without touching the Kint source code. That was a big goal for the rewrite. That said I'm not sure how D8 plugins work (Haven't worked in Drupal for a while) and they might not get composer dependencies installed automatically
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [kint-php/kint/.../**SourceParser.php#L193** (master ‚Üí d6b2540)](https://github.com/kint-php/kint/blob/d6b2540da2477ec8f4c5d6d30807208e5f814d75/src/SourceParser.php#L193) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dgnoce3.)^.
Best practice? I'd pretty strongly recommend using something like ReactJS and a backend PHP API to build forms, rather than trying to do it all through PHP. Although PHP is my favourite language, HTML forms are so much easier to implement in a UX friendly way using a Javascript library that is good at forms, rather than doing it in solely in PHP. 
I think PHP installations fit into one of three categories: * It's a Dev/QA site where you can install a debugger and use a side-channel (like an IDE) rather than throwing extra stuff into the normal output, possibly breaking it. * It's a serious production site where the risk of exposing that kind of information to actual customers -- or accidentally corrupting non-HTML output -- is unacceptable. * A non-critical site under shared hosting where you have no real control over the PHP installation. So for debugging, I'd only use "fancy HTML dumping" for the last situation. That said, there's another niche for this kind of code: Custom logging/console pages that might be part of a web-framework. 
Not sure what you mean by 'install' a debugger. Even if XDebug is enabled on a production server via an extension (or wherever), you need the source to do anything with it. I just don't see how people actually can *efficiently* debug complex application without a debugger. A console dump here and there, sure. But if you are going to be 'working' on the site, I find it is best to get it running locally through a VM and use a debugger. If this is somehow not doable, and var dumps are the only way, then I just hit the highway because that is no way to work. 
&gt; Just going off your example, it appears that your constraints have to be methods of the StringType. That is going to make your StringType way more responsible than it should be. The actual name of those "Type" classes in my library is "Format" so StringFormat, I didn't want to introduce terms that I have to explain. Formats in a library are typically combined in a static factory for ease of use. Say instead of writing: new StringFormat(); You can do: use Blah\Formats as f; f::string(); A "format" can transform and validate an input value, but StringFormat doesn't have to exhaust everything ever that you may want in a string. For example I have: - f::email() - f::creditCard() - f::arbitraryPrecisionNumberFormat() (actually called f::bigNumber()) ... And so on, all of which technically produce strings. So each of those may have its own constraint methods. They can also be combined in a bunch of interesting ways. Do you know about algebraic types? Unions (sum types), intersections (product types)? Here's a field that's a union, it has to match one **or** the other format, the first format to match emits the final value. &gt; f::or($formatA, $formatB, ...); For ex. $formatA may be a number, and $formatB may be an enum of fixed string values. This means that given field should be either a number or a string with a valid enum value. And intersections: &gt; f::and($user, $address, ...); Now I *merged* the fields of the dictionaries in $user and $address into a single flat dictionary (unlike the original sample, where one contained the other). The input should contain all fields from both dictionaries. And there are others like pipeline: &gt; f::pipe($formatA, $formatB, ...); This means the field input value should pass through $formatA, and the **output** of the first format is fed into the second format, and so on until the pipeline is exhausted. &gt; How do you add custom constraints? If the built-in formats, their constraints and combinations (through And, Or, Pipeline etc.) are not enough, you can define a new format through a simple closure, or a class implementing an interface with a single method: `apply()`. Then you can insert it at any point at all through the combining formats that I mentioned. &gt; Symfony has a very powerful validator/constraint system, that lets you use services and such. I've made it so I **never** take static class names anywhere. I also don't have a list of predefined options in an array like Symfony forms does. Everything is closures and objects implementing a simple one-line interface. Which means you extend everything, and you can inject everything with any services you wish at your own leisure. If it's not static, you can inject it and configure it. &gt; Anyway, here's how I'd do it with the form component. Well, thanks for writing the sample. Here's a list of remarks: - **You don't accept a list of users, but one user.** - You forgot to add the agreed upon constraint "between 1 and 100 chars", but I assume accidental. - More verbose than mine, with "stringly typed" configuration options ("constraints"). And it'll be way more verbose with more constraints. But it's not 10x, so I concede that point. - "TextType::class" is static. I know it doesn't have to be, but it's unclear why Symfony encourages poor architecture. - "TextType::class" is kind of pointless as we don't care what the form field widget is in the use case we're discussing. - Has to run from a controller, which is a bad deal considering controllers aren't where you should be validating input data, that's a business logic model/service concern, i.e. where the rest of your API would be. My code sample would run as-is, no implied "wrapping classes" and big frameworks. - Related to the previous, a Form directly parses from a `$request` instance, which means all validators you create are specific to HTTP requests now. My validators work on any input (typically array tree, but honestly... anything). - Related to the previous, it means you can't easily "split" multiple forms from one request and validate/parse them independently. Very monolithic and clumsy. - List of constraints passed in an untyped array. You won't see a type error until you run the code. - Low discoverability of constraints (in my case typing "::" after the factory reveals formats, and "-&gt;" after a format reveals relevant constraints; very intuitive for learning on the go). - The array works as `f::pipe()`, which with me is just one option for combining formats. I don't think Symfony supports algebraic types. Those are really handy in modeling input... - Call it as you wish, but one object instance per constraint is just verbose and wasteful. There's a reason I group them the way I did. - Highly overloaded input parameters. Both first and second. You can pass string, or object of one type, or of another type... what a mess. In my case everything is strictly typed, and it's clear what goes where. Field name first (= string), field format second (= Format). No messing around. - You messed up a few little things like not calling `-&gt;getForm()` at the end of your named builder, but that's what happens with libraries with messy interfaces. ^/s - I can't even comment if the way you reuse $addressForm will work, because the documentation is unclear. But I'll take your word for it. Some of those are nitpicks, some are serious concerns. The tight coupling to HTTP request and controllers is just as bad as the embedded rendering/template state/logic. It's maybe even worse, because it messes up your architecture. It **forces you to do the wrong thing**. Also considering how much logic Symfony Forms dedicates to the view/template logic in these classes, I expect serious overhead compared to my solution that's basically a tight tree of data validators and filters and nothing more. One more thing. The constraints in my case can also normalize and transform data. Symfony Forms can't do that. The only processing option is "trim" and that's in the "stringly typed" options. Where's the extensibility here? Say for me it's trivial to have comma separated values (CSV) in a &lt;textarea/&gt; and have this converted to a list of strings, and every list of string validated independently: $item = f::string()-&gt;oneOf(['red', 'green', 'blue']); $format = f::pipe( f::csvToList(), // Convert "foo, bar, baz" to ["foo", "bar", "baz"] f::list($item) // Validate as list&lt;item&gt; ); Now that's true power, because I didn't have to reinvent list validation, I composed CSV conversion with existing list utils. I didn't have to write a custom format, just combine existing ones.
&gt;Not sure what you mean by 'install' a debugger. Compile or copy over third-party shared library file, edit PHP configuration, add any necessary firewall exceptions, etc. &gt; Even if XDebug is enabled on a production server via an extension (or wherever), you need the source to do anything with it. Oh, no, it's a big security risk and lacking source-code is no barrier at all: A stranger with a debugging channel can still set breakpoints and execute arbitrary PHP code. Indirectly, a that means they can run whatever SQL/shell commands they want with the stored/system credentials your web-code has access to. A crude attacker would wipe your database and delete all the files your web-user can touch but a sneaky attacker could do worse, like zipping up your code, downloading it, and then inserting in their own sneaky changes... perhaps secretly copying everybody's unencrypted passwords as they get entered. If you *must* put a debugger in prod, make sure you go over all the relevant settings to lock it down so that a dev must SSH in and establish a particular SSH tunnel. &gt;I just don't see how people actually can *efficiently* debug complex application without a debugger. Agreed, print-statement-debugging is like using lots of dated zip files instead of a real source-control system. 
&gt; More verbose than mine, with "stringly typed" configuration options ("constraints"). And it'll be way more verbose with more constraints. But it's not 10x, so I concede that point. It can be reduced a bit. For example I could have done: $options = [ 'constraints' =&gt; [new NotBlank()], ]; ... -&gt;add('line1', TextType::class, $options) -&gt;add('line2', TextType::class, $options) -&gt;add('city', TextType::class, $options) Or, the constraints could have been specified in the entity configuration (which is more common). &gt; "TextType::class" is static. I know it doesn't have to be, but it's unclear why Symfony encourages poor architecture. It's not static, you're just passing in the name of the class. I could have put "Symfony\Component\Form\Extension\Core\Type\TextType" instead, but that's silly. &gt; "TextType::class" is kind of pointless as we don't care what the form field widget is in the use case we're discussing. We do, because there is inherit validation rules and expectations on the types. A TextType expects a string value, and would throw an error if you entered something like an array instead. &gt; Has to run from a controller, which is a bad deal considering controllers aren't where you should be validating input data, that's a business logic model/service concern, i.e. where the rest of your API would be. My code sample would run as-is, no implied "wrapping classes" and big frameworks. This code is also portable and can run anywhere you want. It's defined in the same way as yours. A more common approach is to create a separate Type class that holds the form definition, but I didn't do that here. &gt; You forgot to add the agreed upon constraint "between 1 and 100 chars", but I assume accidental. Accidental indeed, but you can just pop it into the `constraints` array. &gt; List of constraints passed in an untyped array. You won't see a type error until you run the code. Meh... &gt; Low discoverability of constraints (in my case typing "-&gt;" after a format reveals constraints). If anything I would say it is easier in the case of Symfony constraints because I can easily look them up... they're all listed under one namespace. In your case, I'd have to search through a bunch of different classes to see if the constraint I wanted is available. Also, the Symfony PHPStorm plugin may be helpful here. &gt; The array works as PipelineFormat, which with me is just one option for combining formats. I don't think Symfony supports algebraic types. I'm not sure what you mean. Are you talking about combining or embedding multiple types? Because that's definitely a thing. &gt; Call it as you wish, but one object instance per constraint is just verbose and wasteful. There's a reason I group them the way I did. Perhaps, but I haven't run into any performance issues or otherwise so far. There's no point fixing problems that don't yet exist. &gt; Highly overloaded input parameters. Both first and second. You can pass string, or object of one type, or of another type... what a mess. In my case everything is strictly typed, and it's clear what goes where. Field name first (= string), field format second (= FormatInterface). No messing around. Eh...nitpicky. The first parameter is the field name, the second is the type, and the third is options. Pretty straightforward. &gt; You messed up a few little things like calling -&gt;getForm() at the end of your named builder, but that's what happens with libraries with messy interfaces. /s Huh? What I did is correct. &gt; I can't even comment if the way you reuse $addressForm will work, because the documentation is unclear. But I'll take your word for it. It should work, perhaps with minor adjustment. Though normally I would probably make an AddressType class, for reusability. &gt; One more thing. The constraints in my case can also normalize and transform data. Symfony Forms can't do that. Yes they can, with [Data Transformers](http://symfony.com/doc/current/form/data_transformers.html) or [form events](http://symfony.com/doc/current/form/events.html).
[No.](https://www.youtube.com/watch?v=vbmNquz89U4)
&gt; It can be reduced a bit. For example I could have done: Still longer! :D I guess you could also... `$t = TextType::class` :P &gt; It's not static, you're just passing in the name of the class. I could have put "Symfony\Component\Form\Extension\Core\Type\TextType" instead, but that's silly. Yeah, I mean passing a class name is static, never mind if you use "::class" or not. By "static" I mean you're passing a static reference (a class name) and not an object instance. The problem is that when you pass a static reference, you obviously can't specify your constructor arguments. Which means either is the component passing "default" arguments, or delegating this to the DI container deep in the bowels of Symfony, and the resulting autowiring creates its own set of architectural mishaps. I have a simple rule: never pass ~~static references~~ function/class/interface/trait names around, and in config. It's always a bad idea regarding extensibility, flexibility, configurability and testability. Here it's optional. But it's still stupid. &gt; This code is also portable and can run anywhere you want. It's defined in the same way as yours. Come on now, did my code call into a phantom `$this-&gt;something` methods? No. My code **literally** runs as is. Yours uses Symfony Controller methods. &gt; If anything I would say it is easier in the case of Symfony constraints because I can easily look them up... they're all listed under one namespace. I actually made an edit to use the static factory I have. It's entirely optional, but truth is I don't spell out "new ClassName()" every time. So this means it is still easier in my case because you can type `f::` and you see all formats. Then you type `-&gt;` and you see all constraints and filters on that format. Also how exactly would you "look up" constraints that are relevant to a specific type? Do you **really** want to be looking through a list of constraints for an **array** while typing constraints for a **string**? What's the constraint for array size? `Count`. What's the constraint for string size? `Length`. And they're in the same namespace. Because of course you want completely incompatible sets of constraints in the same place. Hurrah. How is that "intuitive" in any world? Here's mine: f::string()-&gt;hasLengthRange(1, 10); f::list()-&gt;hasLengthRange(1, 10); When you want a string, you see string constraints. When you want a list, you see list constraints. &gt; I'm not sure what you mean. Are you talking about combining or embedding multiple types? I'm talking about algebraic types. I described those at the beginning of my comment. &gt; Eh...nitpicky. The first parameter is the field name, the second is the type, and the third is options. Pretty straightforward. No the first parameter is called `$child` and sometimes it *is* a form type instance and contains an embedded field name, and then you don't have to supply the second and third parameter. And this is what makes me doubt if that code you posted even works, because looking at the parameter parsing code of the `add()` function alone gave me a headache. This is some seriously over-engineered P.o.S. interface. &gt; Huh? What I did is correct. I fixed this in an edit. What you did was forgot to call "getForm()" in the $address form. You call it the second time. Minor thing. What's a bigger issue, which I noted in my last edit though: **you don't read a list of users, as was the problem definition, you read one user**. That's a big omission in your code. &gt; Yes they can, with Data Transformers or form events. Events are out, because that's not even part of the validation chain. You can't compose and reuse that transform as part of a field type. Also I'm not sure if a validation error occurs during the transform, how will your handler report it so it's part of the form with the other validation events. And "data transformers"... tell me that it isn't sad they added a completely separate pathway, API and interface just for this. It's completely unclear if the model is transformed **before or after** constraints are checked. What if I want to have constraints checked **both before and after** the transform? Do you not see the hilarious amount of incidental complexity going on with Symfony Forms here? Let me show you the power of simple, composable design: $item = f::string()-&gt;hasLengthRange(1, 10); // Each item is between 1...10 chars. $csvField = f::pipe( f::string()-&gt;hasLengthRange(1, 255), // Check the text is 1...255 chars. f::csvToList(), // Convert to list f::list($item)-&gt;hasLengthRange(1, 10), // Check the list has between 1...10 items of type $item ); It's intuitive what happens first, what happens second, what happens last. And how the hell do I do this in Symfony forms? First I have to dig into the documentation for half an hour. Then into the source. And maybe I'll find a way. Maybe. Or maybe in this case I won't. My entire library relies on a **single composable interface with one damn method** in it. And it outdoes all this hard word Sensio Labs put into this unfortunate forms component. Isn't this sad? It's sad.
&gt; You passed it as the second parameter, not first parameter. You're right, my bad! &gt; I mean the fact we can't even get this straight kind of proves my point that the add() interface is a mess. No, it just means I don't really care that much and wasn't paying attention. I'm just bumblefucking around in a text editor. &gt; how do you add constraints before and after the CSV-to-list transform in Symfony? You can't. Form events is one way. I've never encountered that, so I can't say for sure the best approach.
&gt; No, it just means I don't really care that much and wasn't paying attention. I'm just bumblefucking around in a text editor. So was I, but simple well-designed interfaces are hard to get wrong, even when bumblefucking around in a text editor. &gt; Form events is one way. I've never encountered that, so I can't say for sure the best approach. So you'll write a custom event handler where you manually run a list of constraint classes on fields, and manually add errors to the validation error list in the form. No, that's definitely not the best approach. Also it's completely non-composable for reuse, as in, you can't create a FooType class from it to use for multiple fields and forms.
&gt; Also it's completely non-composable for reuse, as in, you can't create a FooType class from it to use for multiple fields and forms. Yes you can, because that's where the form event is created.
You know what's interesting. You can either do what you say from an event in a Type class, **or** you can reuse the `$address` definition in your code sample the way you did, but it can't be both, logically, because reusing it implies it doesn't know which fields it's used on. And making it named, like you started anyway, implies you can't reuse it. This kind of uncertainty what goes where and how to do basics is perfectly in line with typical Symfony Forms experiences I and others have had. But it's kind of amusing to watch you defend them so hard and then get confused what goes where and how to do basics as well.
"Both places"? Both which places?
2002 called the want the code back.
So how does this compare to ref. What are the advantages and differences?
maybe nothing.
Jeffrey Way of laracasts takes over. Source: https://www.reddit.com/r/laravel/comments/3bewjn/what_happens_to_laravel_if_taylor_otwell_is/csljobh/
Not to mention that there is almost no responsiveness.
It would get 1 version per month instead of 2 /s