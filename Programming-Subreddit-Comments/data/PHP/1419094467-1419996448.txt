I'm a software developer for hire as well, can you pm me some details (scope of work and budget)? I will say that *my* hourly rate is most likely not cheaper than what you're going to find on Guru, so depending on your budget somewhere like Elance, oDesk, Freelancer, etc, may be the way to go. But I can probably get you pointed in the right direction and let you know what I think the job is worth. That said, don't forget that you get what you pay for. If it's a business critical piece of software you might want to think about spending a little more.
All words are made up
This seems a little bit of a hack, and blurs the distinction b/n constants and variables, as constants' only use case was for storing scalar values. Now, I am assuming the array can not changed once assigned to the constant, so we have a non scalar but immutable value ... a bit confusing, although I understand it case be used to use arrays from a global scope.
 I'm pretty experienced with PHP as far as CRUD operations and interfacing with APIs using cURL and file_get_contents. I've built a few cool tools at my job but when it comes to drawing with programming, it seems a little foreign. I can work with strings and databases and use frameworks but coding something that draws squares with other squares inside it seems to trip me up. Does that help?
Overworked is not the same thing as reputable. 
I agree with /u/boolDozer that you should plan on spending a little more money for quality work (you can get a cheap shitty programmers anywhere). I've taken over a lot of projects that were done by people who weren't trained programmers and their work is buggy and hard to maintain. 90% of the time it's so bad we recommend a full rewrite. It's better to pay more money now and have a working product than spend much more money later and have mad customers. :-) I would suggest you shop around a bit to see what people have done and contact their clients to make sure they're happy with the work. All that being said, I *also* work for a company that does work for companies trying to get their company of the ground. Feel free to PM or email me your scope of work and I'll be happy to give you some help and (if you would like) a proposal.
&gt; If they acknowledge it's horrible, then why are they pushing it from the browser to the back end as well? People like Douglas Crockford who wrote "Javascript: The Good Parts" have the done the work to find the best ways to program in javascript. That couldn't be done without first acknowledging that "Most programming languages contain good and bad components, but Javascript has more than its share of the latter" â€“ to quote Crockford. Acknowledging javascript's shortcomings and embracing its strengths actually leads to a language that is pretty fun to program in. This serves in stark contrast to the PHP community who is unwilling to admit the shortcomings of PHP. For example... &gt;Also, what exactly is horrible about PHP? There are long lists of problems with PHP that you find on the internet, but the two big things that get to me are 1.) The community behind PHP and 2.) The outdated model of embedding dynamic scripting into HTML documents. &gt;The reason it's a dirty word is that there are so many amateurs writing code that the odds of any given project being an unmaintainable pile of spaghetti are pretty good. I've heard this before as an excuse for PHP's shortcomings: "bad code can be written in good languages." But good code can be written in bad languages too, and I think that is a better description of the state of both PHP and Javascript at this point. The difference, of course, being that the javascript community won't shame you for being upfront about javascripts issues.
Truly good developers are probably not going to be cheap. Honest advice: change your budget or your expectation.
In one older application I work on we try and limit the use of other platforms (db, other languages) to keep the footprint as small as possible. Loading a constant array would be an alternative option for storing static data that rarely, if ever, changes. It's certainly not the best way to go about it in any other application, but it's a native way that only requires PHP code (no file reads).
Two drawing extensions that I know of are: [GD](http://php.net/manual/en/book.image.php) and [ImageMagick](http://php.net/manual/en/book.imagick.php). On a past project, I've used ImageMagick to generate images that were based on user input, not too different from this dungeon concept. We had all assets as separate transparent png layers, so the php script was able to assemble a custom image according to the algorithm. We were also able to place user supplied text with a fancy font in the image. You could also explore the client side route - you could draw on an html5 canvas with javascript.
You could do this completely client side with JavaScript and canvas.
Googling "wikitext php" brought up a load of options. Have you tried any of those?
Nope. Have you? If Google were a recommendation engine and not a search engine then I would ask it everything. When I need an opinion *and* info I go to communities like Reddit. I know "did you Google" is the go to response for tech questions, but I would hope smart people in this community are able to go one step further than that and maybe share an experience which is why I said "know of a good" and not "does this exist?".
It's usually good etiquette to do some research before asking a tech question. Otherwise it just looks like you're asking to be spoonfed.
That's an excellent answer! Thank you! This is exactly what I was looking for.
True, but a reputable developer can probably rely enough on word of mouth that he doesn't need to advertise on Reddit. 
I will try this route as well-- thank you so much for the idea!
Question: does PHP's handling of session data make this a serious issue? My understanding is that session data is serialized, and would assume unserialize() is called at some point upon retrieval.
I would strongly recommend doing the drawing in Canvas. Using the GD libraries to make anything actually pretty is the very definition of a headache.
+1 for ffmpeg and gearman, great tools and if you need visuals check out spek.
The code is just in the index.php file before it does anything else, so it's before Laravel gets booted. The only catch is you can't use Laravel, so I had to do things like connect to my Redis database directly rather than using the Laravel interface. 
Many thanks!
This may come in handy some day, but the class could use some oop best practices atleast [here](https://github.com/commando/dogpatch/blob/master/src/Dogpatch.php#L1-L31) for a start.
But wouldn't his customers just switch to another hoster? I don't think he "really" has a choice.
Oh come off it. I didn't ask for the answer to a simple question. I am specifically looking for opinions.
If you have no experience with these then just say so or don't answer. I was looking for an opinion, there are quite a few libraries. People either have an opinion or not. I don't need a lecture.
TinyMCE is a rich text editor (WYSIWYG), I don't see how that is going to work with a plain text format like wiki text? If you want something that's friendly for users then I'd recommend using either a rich text editor, or for a plaintext format use Markdown since that's pretty standard these days.
Lots of great advice here, all solid suggestions. I'll throw in my 3 suggestions. 1: Know your environment. Familiarize yourself with how PHP utilizes system resources. You'll eventually run into scenarios where you need to know where temporary files are stored, which db driver you're utilizing, memory ceilings, session storage, image manipulation, etc. I know some houses separate dev and admin but it helps the dev to know what they need and what the code they write is doing. 2: Realize PHP's limits. Don't try to get PHP to do everything, pick the right tool for the job. Two examples of this would be using the Java version of Apache's Lucene as apposed to Zend's PHP implementation for large search pools, and using My/SQL to handle certain types of transformations, filtering and calculations. 3) Have fun. It won't always be fun, but you should enjoy what you do and be proud of your work. This applies to any profession I suppose.
Yeah, a bit of a stretch. I'm hoping someone has some direct experience so I can avoid kissing 100 frogs.
Your approach makes sense, but here's my input: Don't try to reinvent language. You shouldn't feel compelled to develop a new syntax or query format and your users shouldn't need to learn one. Typically in well formed language, precision is achieved through verbosity. The specificity of the search should be defined by the available criteria, fewer constraints result in a broader result set. Google really has this one down, in addition to using operands and search switches.
This makes the most sense. Create a unique index (assuming no duplicates) on the email column in both tables, and let the DB do what it does best. Simple, clean.
To add to all the other advice you've got, I'm a freelancer with 10+ yrs experience programming professionally. happy for you to send details of project and I can give you an idea of how much I would charge if you were interested.
This is an interesting and atypical result. Something is wrong with your query, or your tables. I'm glad it worked for you, but a JOIN of this nature and scale should take less than a second - very important on scaled applications and frequent operations.
Agreed.
&gt; They pay you because you claim to be the expert. No, they don't. They pay me because I have one of those magical Internet things. If a site gets defaced with a goatse image, and a customer's actual response is "it's pretty funny. If this is the worst a hacker can go, you can f^%&amp; off with the idea that I'm going to spend money to prevent it " - that's an actual scenario and conversation there - it's just not realistic to expect I can do a lot with that. I can absolutely tell you any sort of "force" will not force customers to upgrade. 100% of them will just take their business to GoDaddy and scream and shout about my incompetence. 
I feel/u/dead-fish was playfully jabbing you. However this is a very "homework" style question and in graduate level curriculum you bring your own solution. If this is a query that must be run frequently against a dynamic data set, I'd lean towards a hashed table of computed values or results. An index with a value column based on a stored procedure, and a glass of whiskey.
&gt; but the two big things that get to me are 1.) The community behind PHP and 2.) The outdated model of embedding dynamic scripting into HTML documents. Neither of these are issues with PHP. They're also both extremely dated arguments. There's nothing of substance to debate in what you've written. You're simply claiming the entire PHP community is unwilling to admit PHP has short commings, thereby making it a bad language, whilst simultaneously claiming the entire JS community is open and accepting of it's shortcommings, making it a good language despite actually being a bad one. 
Asynchronous PHP. Just think about it. And, I personally dislike FB, but damn they are doing a pretty good job with this. Definitely disagreeing with your comment.
So, I have a theory here. I just googled for "php hosting" and looked at the results on the first page. All of them support PHP 5.4 or higher. Some of them *additionally* support lower versions as well, like PHP 5.3, PHP 5.2 or even PHP 4. Here comes the theory: The people who are using WordPress on PHP 5.2 do so simply because it's their currently selected PHP version and they have no reason to change it. If a newer version of WordPress required a newer version of PHP, they could simply enable a newer version in their control panel. So basically: There's a difference between "running on 5.2" (which is what the stats tell you) and "being able to run only 5.2" (which is the limiting factor for choosing a minimum PHP version).
&gt; The defense of older versions seems arbitrary. Why not 5.1? Surely requiring 5.2 is going to leave some users out in the cold, right? Did you read the article? It's anything but arbitrary - it's based on market share of PHP versions. 33% of WP installs are on 5.2, it's 20% globally according to [w3techs](http://w3techs.com/technologies/details/pl-php/5/all).
I like this solution. It works and it's simple. But there is nothing wrong with Bruteforce solutions with 1-off problems. Sometimes we just have to get sh!t done.
Session data isn't a concern, because it's written by the application. It can contain user-provided information, but the serialized string itself is generated by the programmer, not the user. The main problem is people who store serialized data in cookies and then just blindly unserialize them. As cookies are fully under the control of the user, they can wreak all kinds of havoc using that (e.g. using this vulnerability they can execute arbitrary code). If you want to store serialized data in a cookie, you must complement this with a MAC verification. But better not do it at all...
If you're bored, pick up a project and contribute. Like music? Try picking up a trouble ticket at https://github.com/ampache/ampache Great for practice and always looks good to prospective employers.
 class PartyTime{ __constructor(){ $this-&gt;allTheTime(datetime()); } protected function allTheTime($now){ echo 'This is why we can't have nice things. &amp;nbsp;' . $now; unset($this); } }
Yes, great point. Though I'd go about this differently: For web dev, learn XML first. This will help HTML make sense and enable you to navigate the DOM, for web dev you are producing documents - validate. Like an onion. PHP is your logic layer. Use it to produce your valid documents. Again, validate! JS: View manipulation, let the visual magic happen here. Light sorting? Input behavior? AJAX? JS has come a long way, it's the icing on your UI. Edit: words
&gt;You're simply claiming the entire PHP community is unwilling to admit PHP has short commings, thereby making it a bad language I can see that PHP's community is a giant reason PHP is so bad. The best example I can give is you: yet another example of a member of the PHP community unwilling to acknowledge the points I'm making. In my opinion, more than anything else PHP's community affects PHP's quality in a negative way. Also, I'm not sure I've ever claimed PHP is a good language.
On second thought, JS gets a lot of bad press. It can be an eloquent language when deployed properly. Chrome's V8, Firefox's imp. etc., and NodeJS make it a highly intriguing language. JS is PHPs next best friend after *SQL.
This looks cool, but why the curl requirement? It doesn't seem to do anything you can't do with built-in PHP streams.
You're right, I'm sorry. I was being an asshole.
WP have a reason for that version support, therefore it's not arbitrary. Yes, they could probably change that (I already said so elsewhere) but that's up to them. Seems like WP is happy to be "reactionary" rather than progressive.
well I havent even taken my undergrad yet :P in fact, I am a college drop-out XD Mye, gotta try that. I have managed to solve it but the solution is rly slow! 
You aren't making any points. You are making the baseless assertion that the PHP community is rubbish, and the only evidence you have to support this is your incorrect assumption that the PHP community is still considers mixing logic and presentation as a good practice.
cool blanket statement. any suggestions? 
ty for your reply. That is what I did. I managed to write a brute-force somehow that ended up being pretty shitty in execution time. however, it worked. Now I tried to run over the same problem recursively but hit a wall programming-wise. should get it done by tomorrow. Regardless, I didnt know that this was such a huge thing but the more I read about it the more I like it :D ty for the link!
I've spent 20 years in web development and I've asked questions online maybe 6 times because I find the answers on my own usually. I wasn't being lazy, I was being hopeful if anything. Hopeful this community had something to contribute on this front. Apparently people would rather call people lazy because an open ended, friendly question might have info tangentially related on Google. I can find Google info all day. I want more than that. Yet all I get is flack.
No problem. I've got a lot of experience in web dev. I know to search Google. I really do want then"hey, I used x and it sucked or was awesome" sort of stuff. I can find Google info all day. I would only post here to get real personal info. It may not be here, but would be silly not to ask.
Interesting but lacks the other way: turning PHP objects into JSON documents. That makes it not so useful to writing an HTTP API. Also it doesn't look really configurable. How can I do if a JSON field doesn't match the name of one of my object's property? How are handled collections/arrays of objects? What about 1-N associations? (e.g. `Category::$articles`) It doesn't say if setters are called or if values are set directly in properties, maybe the documentation should be explicit on this. Have a look at those similar libraries: - [JMS Serializer](http://jmsyst.com/libs/serializer) (used by Symfony &amp; co) - [Fractal](http://fractal.thephpleague.com/)
Hello, I read through most of this and I am feeling like the sole advice you got is read the book and do it gradually with xdebug and a proper IDE. While all these are good advice, having the fact that you are a junior php developer, they might not apply to you directly. Here are some thoughts: 1. The code base, messy as it is, works (to some degrees at least) and generates revenue. 2. The spaghetti code you have there covers real life problems, bugs, weird browser behavior, edge cases, special business requirements for that one special customer etc. A full rewrite will have you lose most of that, especially if you do not have any prior experience in dealing with this issue(s). 3. A book on refactoring is a good start, Paul's book is a great start but first you need to understand the language and it's quirks to be able to have at least a decent architecture. Here are my 2 cents: 0. Start by going through the backlog, fix bugs and add trivial features. This will give you a good understanding of the application flow and of the logic behind the existing architecture. This also exposes you to enough code to figure out where to start your refactoring. 1. Write tests, any tests at least for the critical parts of the application. And don't aim for all green and shiny, aim for less is more in this case. This will allow you to have your refactoring as safe as you can. 2. Isolate parts that can be replaced by proven open source solutions. e.g Sending emails? Centralise everything and use Swiftmail. 3. When you want to refactor bigger chunks, create yourself tickets / tasks / what ever you have (trello.com is ridiculously good at that for me at least). Do not start refactoring until you have the bigger picture planned in tickets and sleep over it (really). 4. You are alone in the company, with no "senior" supervision. You will fail. Not because you are bad or dumb or anything alike, but because you do not have anyone to review your code or bounce ideas of. Go to http://phpmentoring.org/ and get a mentor. 5. When using version control, use it as a tool not as a "cool". Take the 2-3-5 minutes to write proper commit messages that can help you in 3 months time. Write down exactly why you removed the x file / function / call and you will thank yourself later on. Using git? Use git notes (http://git-scm.com/docs/git-notes) 6. You are a professional. If you consider the application being in a technical debt you should communicate it to your boss. Not like "this is shit, let's redo it" but like "we could start refactoring these parts, thus eliminating risks in the future and making the development process safer and more streamlined". If you are afraid of hurting your boss's feeling, you should probably think of his feeling when the application crashes entirely for 1-2 days and you have no idea why. It's like you are an assisting surgeon and your boss is about to commit a deadly mistake for the patient and you sit quiet because he has feelings. Hope it helps in any way.
The new version uses mysqli_* functions now, and has no error suppression anymore. https://github.com/sciactive/nymph
They pay you for one of three reasons. They lack: * The skills * The resources * The time They hire you because you have the know-how, the resources and the time. &gt; If a site gets defaced with a goatse image, and a customer's actual response is "it's pretty funny. If this is the worst a hacker can go, you can f%&amp; off with the idea that I'm going to spend money to prevent it " - that's an actual scenario and conversation there - it's just not realistic to expect I can do a lot with that. Then you're not doing your job. There's two ways you can run your business: 1. Take peoples money 2. Do the job they pay you for, which means making the decisions that they are neither capable of making, informed enough to make nor understand enough to make. If you choose to do it the first way, that's on you. But don't pretend that it's the only way for you to run your business. There are **plenty** of hosts out there that do the right thing. And if you do it right, you won't piss off your users. If you do it right, you can help people and keep them happy at the same time. &gt; 100% of them will just take their business to GoDaddy and scream and shout about my incompetence. Better to be called bad names than to be deserving of them...
The new version uses MySQLi now. I don't use Doctrine or Propel, so I wrote the JS frontend for what I use. ;D Also, I added Travis CI icon to the readme. Thanks for the tips. https://github.com/sciactive/nymph
Unless you've read my contract, you're doing a lot of guesswork around what exactly my job is. Mechanics don't break into people's houses and change their oil because they are too incompetent to take a car in for a service themselves. I've never had a dentist come into my bedroom while I was asleep and remove a tooth. There's nothing special about IT that gives a person power of their customer.
The use-case for this feature is definitely obscure, but you could use it for a lookup table if your application depended on a constant table.
Agreed.
I'm a full stack PHP developer. I have an impressive portfolio, but no paid work yet. Would be willing to work at a steep discount in exchange for work experience. I have solid design and development work. I have an online resume and portfolio [here!](http://gooseweb.io/).
No, but no dentist will do something that they know will risk your life just because you ask. No mechanic would drain your brake lines because you asked them to. They are the mediator of what they do and what they don't do based on your safety and the safety of the public. By not upgrading PHP versions, you are explicitly putting them, and the rest of the internet at risk. It's not going into their bedroom to force them to do something they don't want. They are paying you for the service. It's up to you to choose to provide it properly or not. 
Does it play nice w/ RethinkDB?
not natively, but that's the wonder of composer. you can pull in whatever implementation you want. here's one: http://danielmewes.github.io/php-rql/
ummm .. what are POPOs? propably not [this](http://www.urbandictionary.com/define.php?term=POPO) ?
Plain Old PHP Object I guess. The PHP equivalent of [POJO](http://en.wikipedia.org/wiki/Plain_Old_Java_Object) or [POCO](http://en.wikipedia.org/wiki/Plain_Old_CLR_Object).
The new version improves on a lot of the points you made, but not all of them. I'll continue to improve the code for the next version too. :) Let me know what you think. https://github.com/sciactive/nymph
Of course, the good ol' classic, I want quality work but I don't want to pay for it. 
Neat, I was looking at JsonMapper today. Can you explain the difference between them? A brief look says this library always requires a setter method, even if the property is public. How does Reflection perform in production these days? In most cases I see it used there's also a caching adapter to skip the Reflection lookup. 
At no point did I state that I was not willing to pay for high quality work. Nor did I state the budget that I had in mind. Furthermore, your statement itself is ridiculous.
It looks like Scrutinizer gets a lot of things wrong with its assessment of the code. :(
yup (wikipedia,baidu,box moved to hhvm)
First learn how to use composer. Should be easy to grok in under 10 minutes. Then do the composer create-project installation for Laravel. Once you've done that, maybe play with this https://github.com/duxet/laravel-rethinkdb (I haven't tried it yet). 
Laravel isn't the only option. Symfony works well with literally anything.
I never understand what people mean when they say that Symfony is too big. You're not forced to use any features you don't want to. Why isn't Symfony suited to building a small, simple website? 
I'll quote myself &gt; Also, what exactly is horrible about PHP? The reason it's a dirty word is that there are so many amateurs writing code that the odds of any given project being an unmaintainable pile of spaghetti are pretty good. Perhaps you could highlight your points about what is so bad about PHP? All I can see is your opinion that the entire community is rubbish. A perception I explained half a dozen posts ago. The fact there are large numbers of poor coders out there does not mean the active community is poor, nor that PHP itself is a poor platform. And let's not forget that this started from the assertion that JS is so bad there are two different languages that compile to it so you don't have to write any JS code. An assertion you cleverly brushed aside by completely ignoring it and asserting that: &gt;Acknowledging javascript's shortcomings and embracing its strengths actually leads to a language that is pretty fun to program in. Weird. Edit, not so weird, I just had a quick look at your history, you're struggling to understand Wordpress and HTTP status codes ...
Everyone has ideas - while most don't have the skills to realize their ideas, those who do have the skills will necessarily have their own ideas. If you want a 50/50 split to realize your ideas, you're going to need to (a) find someone that you can mentor who's willing to put in the hours, (b) settle for a less-than-exceptional partner (see (a)), or (c) write-off the time it takes you to develop the skills necessary to realize your ideas (probably more of an 80/20 split if you go that route, before factoring in opportunity cost).
C9 is on Github, so guessing you can host it yourself. Actually this is just version 2 instead of 3 supposedly: https://github.com/ajaxorg/cloud9/
You are approaching this from the wrong angle. [Your application should be completely independent from your framework](https://www.youtube.com/watch?v=WpkDN78P884). That means that past your controllers you don't have any dependencies on the framework and instead you are just using plain old PHP classes. If you want to use 3rd party code, just use a composer package for what you need. The framework is a small implementation detail, it is just the glue between the web and your application. So make sure you treat it as such and don't make your architectural decisions based on it.
Can you paste a link? What does it get wrong specifically? Have you reported it to the team? 
As others said, it's possible with most frameworks. My question is why not use sqlite? It's easy to use and migrate to a "big" sql server once needed.
If you take an approach like this, the seeming complexity shrinks even more. http://www.whitewashing.de/2014/10/26/symfony_all_the_things_web.html
Also, take a look at Gearman and rabbitmq. They have RPC like functionality built in, which you might find useful. If you check out Gearman, also checkout Gearman Manager
Just shove the job into a queue, and then pick up that job and run it with another process. There's two sides to a queue system a producer (the thing that create the job and puts it in the queue) and a consumer (the thing that picks up the job and does it). Here's the fun part: the producer and consumer need not be in the same code base or even in the same language. It just depends on your application needs. As long as each can talk to the queue and speak the same job data format you're good. This is a great [set of slides](https://speakerdeck.com/justincarmony/managing-and-scaling-asynchronous-workers-and-staying-sane) on managing ansyc workers.
Thanks for the feedback! Your note about going the other way is true; I only created this library as the other solutions for deserializing I could find for PHP weren't close enough to the almost no-configuration-required jackson-databind in Java - JMS Serializer requires the use of it's custom annotations (or XML/YAML) and JsonMapper got closer, but it only seemed to support a camelCase/snake_case hybrid for setters (e.g. setDistribution_version) and it wasn't namespaced, so just aesthetic gripes really. Arrays of objects in the JSON are now supported - I added the code last night and updated the documentation (which I also made a bit clearer, I hope). I'm also going to look into being able to add custom property mapping - good shout!
Try producer consumer. I used beanstalkd and wrote the producer consumer part in python. The Python part would spin up multiple thread at a time that would call php scripts at the same time. The php scripts would then handle the data in batches. If you want to stick with strictly php, then you might want to consider spinning up multiple processes. 
I've found [GraphicsMagick](http://www.graphicsmagick.org/) to be significantly faster and less resource intensive than ImageMagick.
do the front-end/website with PHP. for the number crunching/report generation, do it in the background using a queue/scheduler. to maximize gain, you might want to look into using a different, preferably one of the fast compiled languages that your team can use, for the crunching/report generation. you don't have to do everything in PHP.
I'm doing a lot of stuff from a queue/list/text file triggered by a script run in cron. PHP times out, felt janky processing files line by line, and there are ways to mitigate these problems (beanstalkd, rabbitmq, Gearman, Laravel, as described below). But, I've been using bash, tcl, &amp; node.js (which is simply command line server side JavaScript execution-- not as complicated on the whole as people running node web servers with it make it out to be.) Node may be new. But limited processor and RAM is an old problem with really great old tools to deal with them. I use a script to get my new data (wget or curl), command line SQL to work with the things I have (data infile &amp; the MySQL CLI client), bash to process most things-- much of it line by line to conserve resources, and node.js digs me out of jams when bash or tcl or other tools at my disposal don't seem to be working. Once I use command line SQL to put it back in the database, then all PHP has to do is trivial transformation and display...
RethinkDB isn't any bigger than SQLite in the way I use it. So its like asking why not use a flat file instead of SQLite.
Following on with what /u/datphp and others indicated, processes taking 10-15 minutes might be indicative of suboptimal processing. It might be worth revisiting the assumptions involved and how you're doing it. Moving some of this to another language might be useful, shoving more processing back at the database might be useful, rethinking the problem might help as well. I took an import/processing problem that was taking &gt; 20 hours and, over a few days, got it down to &lt; 30 minutes, and this was on 2005 hardware - would probably be &lt; 5 today on faster CPUs and SSD. The assumptions about how to import and process were naive - they worked at low volume, but at high volume it all fell apart because the entire set of indexes couldn't fit in to RAM. Quick solution was to chunk the import and processing in to multiple steps, and do that with tmp tables (mysql) to avoid writing to disk before absolutely necessary. The thing flew. Point is not that it's necessarily 100% possible to speed your processing up a lot, but it very well might be. 
Who says they aren't? Maybe the problem is in badly written SQL queries or missing indexes. Finally, SQL is not a magical wand that can crunch any data any way you like.
[Symfony DomCrawler](http://symfony.com/doc/current/components/dom_crawler.html) + [Symfony CssSelector](http://symfony.com/doc/current/components/css_selector.html)
I usually use PHP's [DOMDocument](http://php.net/manual/en/class.domdocument.php) along with [symfony/CssSelector](https://github.com/symfony/CssSelector) to convert CSS selectors to an XPath query. It's usually as easy as $doc = new \DOMDocument(); $xpath = new \DOMXPath($doc); $xpathQuery = CssSelector::toXPath('#some-element &gt; div'); $xpath-&gt;query($xpathQuery); Though I'm not 100% sure on the CSS3 support in symfony/CssSelector. I know some selectors are supported, but not all. Edit: using symfony/dom-crawler actually looks to be a better solution.
I've had this problem in the past, to fix it I wrote stored procedures in my db to handle some of the calculations... That sped thing up a lot. If you need more speed use something like reactphp to preform multiple parts of the processing in an asynchronous fashion. Also try to think about parts of the reports, or the data that is used to create the reports, that can be cached. Also, can some of the calculations be performed when data is written, instead of when the report is run?
Do you currently have any developers? If so, you may want to consider investing in them instead of hiring some unknown person. If you don't have any developers... good luck knowing which ones are good and which ones aren't. That's rough, mate.
Wow that was verbose. And at the end of it all :"but I haven't used it in a production system". :/
This was a problem at our workplace as well. Turned out a lot of the problems stemmed from the SQL queries themselves taking a long time to run, so they were optimized which cut down on a lot of the time. We also changed a lot of the Postgres cache settings which helped. For the stuff that still look a long time, we threw it on a beanstalk queue. Then, you have a pretty nice way of scaling the process depending on demand. So for example, at the start of the month every department would request a monthly report which took a long time to generate, so we used to throw more servers at the queue system for that time. You're also not limited to using PHP in a queue system, so if the synchronous nature of PHP is what is slowing you down, you can pop the job off the queue and process it in whatever language you want.
Well, you havent given any real clues about what your data looks like (or where it comes from) except for "financial data involving thousands of records" -- which doesnt mean much -- and really, thousands of records isnt that much data. I think the suggestion for doing the processing in a job/queue style configuration is solid, but that also doesnt really help you as far as setup and programming go. What you really need to tell us is how are you getting this data? how is it stored? is it a constant stream? what does it look like? These kind of questions will determine how you process the data. If its just log or csv files, you can iterate the files with a bash script and pound through them. If its a db, maybe you can just set a cron job that polls occasionally. My real question would be, do you really need to use php to process this data? Lately, I pass off all the actual heavy lifting to another language (in my case, Go) that can better deal with it -- that has better concurrency, faster and more efficient. Other languages will give you the same results.
I'm not criticizing you OP, but I think people forget that you can connect to any db you want, no matter the framework... This is php and it works without frameworks. You can use any framework you want and just use the mongodb extension. 
And that's probably a good thing. The PHP engine is not at all optimized for functional programming, so all these calls and closures would take a heavy toll on performance.
This looks like it was written by a copywriter. My favorite part was this graph: http://www.enukesoftware.com/blog/wp-content/uploads/2014/12/total-market-share.png
This question is begging for real analysis, starting with a profiler run. The issue isn't going to be solved by paging out the processing to an async process. I mean, you could work around it that way, but every time I've run into big data-related performance issues, I've been able to solve it by adding an index or two to my database. For instance.
best advice in this thread by far
I don't know about closures, but I don't think call_user_func has any kind of performance impact at all.
great advice, indexing and refining legacy queries has increased performance on my servers 10 fold. ive found redundant loops of code that do the same stuff over and over and it was bigging stuff down, store it in a variable or an index, boom. i try and let all the calculation be done on the server before serving up the data~
I don't know if this applies to your situation, but have you considered processing parts of the data as they come in rather than all at once when the report is generated? A basic example: if the report is displaying the number of products for each type, A/B/C, you might be querying all the products and then grouping them by type during report generation. Instead of doing that store the counts somewhere and increment the count when someone adds a product and vice-versa when someone removes a product. Now when someone loads the report all you have to do is pull the counts, which should take almost no time. If you're worried about performance during the write process, put the reporte updater function into a queue so the user doesn't have to wait for that part to process.
Function calls are typically (very) slow on dynamic, imperative language platforms. You don't want to make more calls than you need. Compare with compilers for FP languages, who knows how to optimize many of these calls and who can handle larger stacks appropriately.
This right here is the basis for every question like OPs, benchmark and profile code. If you don't know why something is slow you can't optimize it.
Checkout using a reporting solution like Jasper Reports. A *much* better solution than doing it with PHP.
I usually call exec out to php-cli which is not beholden to the same timeout limits that cgi is. I also use some kind of messaging service, typically backed by redis to communicate status to a polling Ajax call. The only caveat is to monitor your memory usage, if it gets to high your data processor script well crash. My async job manager automatically forks a fresh process when memory usage hits a certain threshold.
Well, surprisingly, I found no PHP library to validate types and values from associative arrays. To validate forms, an option map or an arguments list, people still use isset, is_string, is_numeric, is_bool, etc. Which often leads to bug-prone, verbose and hard-to-read code.
Try to make your queries more efficient. Give to the database more job to do.
Looking into this now, thanks!!
I think this poster can be forgiven slightly - I've seen quite a few requests for cheap (and even free) developers here on Reddit. Maybe edit your post with a precis of your project and your rough budget? If you can demonstrate you are willing to pay market rates for good work, these sorts of responses are less likely to come up. 
If you're expecting to have more than one site, it's often easier to set up virtual hosts inside of different users' home dirs than to carve out individual directories and set up permissions in /var/www If you're just deploying a single site, I can't come up with a convincing reason not to deploy out of /var/www
I chose the */home/username/* option for our servers as we host multiple sites on the same server. This allows us to keep a simple directory structure for each site, and more importantly, it helps make permissions easier. If I create a new user *adduser xx*, then this automatically creates the home directory. Now, when using a FTP service such as *vsftpd*, it will allow you to login into FTP accounts using that newly created users credentials, and that FTP user can be restricted to their own home directory only. So you're limiting FTP/SSH etc access to one user, per site (or directory). If you we're to stick everything in /var/www, and still host multiple sites, you might be tempted to have a shared login to manage these, which wouldn't be advisable. So you'd have to create individual users or permissions anyway.
couldn't put my finger on it, but yeah... spot on. Good to know laravel is beating lasso - it must be the modularity.
I've been profiling Drupal sites for years and never noticed any performance problems around call_user_func. I understand the logic in what you're saying, but I'm fairly sure the way PHP implements it's list of functions internally is known to be extremely efficient and the reason Drupal and other frameworks that rely on call_user_func extensively perform so well.
[phpQuery](https://github.com/electrolinux/phpquery) is a decent library for this. The particular version linked is the packagist-friendly fork.
90% does sound high, but depending on where the referrals are coming from, it's not out of the ballpark. 90% of the time, when I don't rebuild from scratch, I wish I had. Took on a small project this summer, and I 'won' the project partially because I was the only person who didn't look at it and say "rebuild from scratch". I ended up refunding the guy his deposit back after several hours of hitting every road block imaginable; just trying to get the stuff installed and running locally took WAY too long - multiple areas had things hardcoded to specific IP addresses and were dependent on particular hardcoded paths and module dependencies (that ultimately were not *used*, but had been used at one time, so things failed when an object was created, even though the object was not actually used). And yes, it was built on a framework - slim, in this case - which simply reinforced to me that frameworks generally provide almost nothing of value if someone is determined to write crappy code. 'micro' frameworks are actually worse in this case because there's little guidance as to how anything should actually be done, other than inlining loads of closures by copying hello-world examples and extrapolating that out to full-scale projects. If I'm being asked to provide 100% of the support and actually guarantee that the code will be stable in production (to generate those revenues), I need an astonishingly high comfort level with the quality of the code. If I can't get that from a code review, I will recommend a rebuild. Usually people are coming to me because they had problems with the previous person/firm anyway, and "really bad code" is just one of the problems. I dealt with a project generating $x million per year, and felt when I stepped in it should be rebuilt. I mentioned it once, to one owner, and it was dismissed. 5 months in, it was apparent the problems were much much bigger, and I brought it up again, and was told "you should have said this before!" Reasons to keep code in place - there's one or more people who already actively know the codebase, are fluent in it, know where the bodies lie, etc. In this case, 5 of the 6 devs all left at the same time, and the 6th didn't want to be there. 2 new folks were brought on who didn't know the language, didn't know the industry or the business, and were handed this pile of code written by people who'd developed their own JS framework to talk to Java, but they hated Java, so 90% of the Java was written in Ruby-esque idioms wherever possible. It was all done with no written docs, and without anyone from the team actually talking to end-users for... 18 months. There was a strong 'sunk cost fallacy' going on there - "we've paid for this, we need to launch it and use it".... but no one really knew how. Eventually it worked out, but that 'eventually' took more than a year to sort through, and they ended up with software that no one was happy with. Same time could have been spent rebuilding from the ground up, had a working product in &lt; 1 year with a much high confidence level between the dev and business teams. Hindsight and all that, but ... it was obvious to me on day 1, but not to anyone else. And even if you're *right* by some measure, it's not a message people want to hear. :( 
Source: http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/srv.html Web applications are an http service and should be placed in the service directory: /srv/http/ So usage would be as follows: /srv/http/example.com/ /srv/http/api.example.com/ For other network services such as ftp, rsync, cvs, git would be structured as follows: /srv/ftp/ /srv/rsync/ /srv/cvs/ /srv/git/ More information on FHS compliant directory structures: http://en.wikipedia.org/wiki/Filesystem_Hierarchy_Standard
You can also deploy to `~/` with a symlink from `/var/www/`. This allows you to quickly see all the sites that the server is hosting without having to spend tons of time configuring permissions and, if/when you get to a point where application versions matter, you can easily switch the active application version by changing the `/var/www/` symlink.
Nice project. Does it integrates with PHPUnit? Btw, REST module of Codeception can handle this job as well http://codeception.com/docs/modules/REST Also it allows to validate the strcuture of JSON with JSONPath expressions
The only reason I can think of is that you should probably be deploying to `/srv/http` instead.
Ah, fair enough.
Never heard of this approach, thanks for the info!
That's a pretty naive view of it, and indicates mainly that you've experienced exactly what OP mentioned - job title inflation. Here's the thing about an actual senior dev, particularly one in a leadership role: they know they can't be an expert on everything all at once and that seniority isn't someone being bestowed with the power to be unquestioned, but rather the recognition that they have accumulated enough wisdom and skill to be relied upon to make better decisions.
Not 100% sure but probably 40-50 tables with similar records. The database is about 1.8GB when backed up via mysqldump. Maybe my math is way off. I don't know exactly how many records we have.
This is certainly one way you can do this, but is a bit decieving because it is not defined as explicitly as you do. A `/srv/[protocol]` model is proposed, but not actually suggested or defined as a any recommendation. The entire issue is a bit distribution-specific issue. In some Debian/Ubuntu, some packages are compiled to only-allow paths under /var/www. Some other packages will automatically try to configure themselves to use /var/www. So you may want to be careful with /var/www if you install these packages. As for what to use: Its probably best to prevent the application from reading web-server things that it doesn't need (like SSL keys and passphrases). Depending requirements, you may organize this under one user. Access to add/update/remove the application may influence the decision. I tend to use different users to restrict what applications can do-- so using /home (or a subdirectoy like `/home/http` or `/home/www`) makes sense for the way I set it up. tl;dr Its not just a clear-cut "It goes in /srv" and is not defined in the FHS as that way.
This seems purely a mnemonic approach, if you replace /srv with /var/www there is no difference there. However /u/adrianc333's approach seems to lay ground for separation and responsibility features based on how many users there are on a single machine. Unless, I am missing something.
 # in sshd_config AllowGroups ssh sftp Match Group sftp ChrootDirectory %h ForceCommand internal-sftp PasswordAuthentication yes That's my usual scheme. Gives the SFTP groups some access, only to their own directory (chrooted, so they can't get out of it) and allows SFTP folks to use passwords. Password use is not ideal, but asking non tech savvy people to generate ssh keys often doesn't go well. I'll also set those user's shells to `/usr/sbin/nologin` (or `/sbin/nologin`). *edit:* chroot is a bit weird, so read up on it. `root` has to own the `ChrootDirectory`. I usually have `root` own the users home directory and a subdirectory named `writeable` for the user to actually put things in.
Assuming these multiple sites need to run PHP scripts, how would you organize the ownership of files? For example the files need to be accessed by apache (www-data) but also edit and deleted by the user (user1).
I normally set the ownership &amp; groups as, chown username file.txt chgrp apache file.txt Then the CHMOD permissions would depend on the type of file it is.
Files in /home are meant to be owned by the users that access them, and most UNIX utilities and such assume this. There could be data user's don't want exposed (like .ssh) in various dot files and directories in a user's home directory. Unless you never allow them login via SSH or have things locked down really tight with what users can run, or have 100% confidence your web server will never show what you don't want it to show. /usr/local/share, /srv/ or /var/www is meant for files not belonging to a human user on the system, or meant to be served externally. Since logs write to /var and bad things happen if the partition they are on fills up, I prefer not to put web files on /var. I like /srv or /usr/local/share much better.
What type of bad things do happen if /var fills up, that won't be the same /srv or /usr/local 
Understand everything to do with OOP because most people today, surprisingly, have no idea when it comes to OOP in PHP. Some will understand the basics; but not everything. :)
I use [`mod_ruid2`](http://sourceforge.net/projects/mod-ruid/) so that PHP scripts are run as the user in whose home directory the site is stored. (Or, technically, the whole Apache process runs as the appropriate user for the virtual host for which it's responding, which causes PHP scripts, CGIs, etc. to be run as that user.) In each of my `VirtualHost` definitions, I set RMode config RUidGid $username $usergroup ...replacing `$username` and `$usergroup` with the username and group, respectively. If you want to use PHP via FCGI instead of `mod_php`, there's another solution but I can't remember what it is. Either way, this is preferable to running as `www-data` as self-updating scripts like WordPress can manage their own guts.
Badly written sql or missing indixes? Better fix the problem somewhere else then. A magical wand that can crunch data anyway you want? Yes, thats half the point of SQL Thanks for the dissertation
It's an alternative that is more semantically correct. http://www.pathname.com/fhs/pub/fhs-2.3.html#PURPOSE16A &gt;/srv contains site-specific data which is served by this system. &gt;This main purpose of specifying this is so that users may find the location of the data files for particular service, and so that **services which require a single tree for readonly data, writable data and scripts (such as cgi scripts)** can be reasonably placed. Data that is only of interest to a specific user should go in that users' home directory. &gt;The methodology used to name subdirectories of /srv is unspecified as there is currently no consensus on how this should be done. One method for structuring data under /srv is by protocol, eg. ftp, rsync, www, and cvs. On large systems it can be useful to structure /srv by administrative context, such as /srv/physics/www, /srv/compsci/cvs, etc. This setup will differ from host to host. Therefore, no program should rely on a specific subdirectory structure of /srv existing or data necessarily being stored in /srv. **However /srv should always exist on FHS compliant systems and should be used as the default location for such data.** and &gt;/var contains variable data files. This includes spool directories and files, administrative and logging data, and transient and temporary files. Does that sound like it describes a web application? It doesn't to me.
Then after you've done all that, still use a queue.
Sorry, I think I'm having trouble deciphering your argument...? I don't understand why it's moot, or what the way the hierarchy has evolved has to do with it.
generic memoize function: function memoize($function) { return function() use ($function) { static $cache = []; $args = func_get_args(); $key = serialize($args); if (empty($cache[$key])) { $cache[$key] = call_user_func_array($function, $args); } return $cache[$key]; }; } $memoized_sqrt = memoize(function($n) return $n**0.5; }); $memoized_sqrt(64); $memoized_sqrt(64); $memoized_sqrt(64); Only computes it once.
This is a huge discussion topic which it totally dependent on your application and also includes a bunch of best practices. Raw mysql queries, avoiding quering for thing within a loop, shutting down any type of "framework query caching" and debugging info that could cause high memory consumption. We have php scripts that place semi-formatted data from the database in elasticsearch and we do all of our analytics there ... 
Sticking with what has become the norm is easier than retrospectively applying logic. I agree with you in principle, but not in practice. 
&gt; or what the way the hierarchy has evolved has to do with it. Well, personal opinion, and you are right to have yours, but much of the Linux file system hierarchy is outdated and irrelevant for modern servers/systems. So to say /srv/ is the *more semantically correct* choice vs. */var/www* I don't personally think holds much weight, nor does it really matter.
Thanks for rewording, now I understand. Fair enough.
&gt; Badly written sql or missing indixes? Better fix the problem somewhere else then. Why should OP do that if that's the problem? I'm not saying that. What I'm saying is that maybe they tried to have the DBMS do the heavy lifting but failed. &gt; A magical wand that can crunch data anyway you want? Yes, thats half the point of SQL The point of SQL is to have a somewhat easily readable language that allows you to talk to a relational database. Nothing more. The data crunching belongs inside the DBMS and by definition has absolutely nothing to do with SQL. The point of a DBMS can be to crunch numbers, but mostly its purpose is to be an abstraction layer that allows you to think of your data as a set of tables without having to worry about how that set of tables is actually implemented. Which is where SQL comes in, because that's how you manipulate this abstract table set. So you might say that the point of SQL is actually to expressly *not* do any data crunching. &gt; Thanks for the dissertation Two lines is hardly a dissertation. The word you're looking for is *sermon* and it isn't that either. My advice to you, or any other developer who ever works with relational databases, is to read a book on relational databases, database schema design, and SQL. Preferably one that doesn't mention programming or programming languages in any way, and is not tailored to fit any specific DBMS. I did it, I learned a lot and so far it's proven to be very healthy for my career as a PHP developer.
No problem - not saying you are *wrong* (in-fact I think your argument does hold some weight based on the sources you have quoted above), just in as much that I think `/var/www` is a poor choice anyway :) The "www" or "world wide web" is a bit of an outdated term in 2014. Web severs talk "http", not "www". Maybe a `/http/APPLICATION_NAME` directory, straight off the root file system is a smarter choice for the future? Certainly if I was running Nginx/PHP-FPM from inside Docker containers, this is where I would probably home all "http" things for the container(s).
If you are interested, I made this some time ago: https://github.com/camspiers/php-fp
I go with `/srv/appname`. It's exactly like `/home` except in the correct location for files that are owned by an application. This is mostly semantics, but it also makes it significantly more practical to share a `/home` tree across servers, while also making it easier to share specific applications without sharing everything (if desired). I don't consider `/var/www` or `/srv/http/appname` a good idea because more often than not, modern web applications are far more than just web applications. You have things like queues to process jobs in the background, a variety of crons and other things that stretch the definition of "web application" out quite a bit.
If `/http/APP_NAME` then why not `/srv/http/APP_NAME`? My current convention is `/srv/http/FQDN`. I personally like the idea of consolidating externally available resources under a common root like '/srv' instead of cluttering up the filesystem root with a bunch of directories that have a related purpose. `/srv` is still succinct, but describes and compartmentalizes its contents quite well.
I always deploy websites as a vhost and put all vhost files in /srv e.g. if I have ponies.amazing-url.com the directory structure looks like this: /srv /srv/ponies.amazing-url.com/ /srv/ponies.amazing-url.com/htdocs /srv/ponies.amazing-url.com/htdocs-ssl /srv/ponies.amazing-url.com/log /srv/ponies.amazing-url.com/ssl /srv/ponies.amazing-url.com/lib /srv/ponies.amazing-url.com/cgi-bin &lt;-- legacy and not typically needed anymore The ssl directory is for certificate files (e.g. server.key server.crt server.ca-bundle) The lib directory is for PHP includes that I don't want in the web root (referenced from the web root as "../lib/x.php"). Typically this also has a config directory. I'm a strong believer in keeping as much PHP out of the web root as possible so a broken server configuration doesn't expose source code and possibly sensitive information like database passwords.
Thanks a lot. Even though right now I'm trying to write FP-ish code for PHP 5.1 (Santa Claus is real right?).
Indeed. It's definitely worth going through and improving the things it gets right. A lot of the duplication stuff is just very similar code between the MySQL and Postgres driver, so I'm not sure how I would get rid of that without making it more difficult to follow. :/
A parent class would do it. 
This sounds like a good idea, but it's not. The web server should NOT have any write access to the files it serves. This cuts down a huge attack surface for hacking as it doesn't matter if you can control the webserver - without write access you might not be able to do anything. Now wordpress does want to be able to write files, so you should have a split installation - have one user for most of the files, with read-only access, and just the files that need it have write access.
Okay 90% might be an exaggeration but it's more than 50%. :-) This comment from /u/mgkimsal is why we usually recommend a rewrite: &gt; If I'm being asked to provide 100% of the support and actually guarantee that the code will be stable in production (to generate those revenues), I need an astonishingly high comfort level with the quality of the code. If I can't get that from a code review, I will recommend a rebuild. Usually people are coming to me because they had problems with the previous person/firm anyway, and "really bad code" is just one of the problems. 
5.1?? You're crazy :) Dying to be insecure? 
Ok r/php you asked for it :) The moron here asks: 'Why do we have to use a model in mvc frameworks? If have have a PDO wrapper or database mapper, what is wrong with calling the wrapper or mapper to handle data i/o in my controller as simple as &lt;?php namespace xyz; use vendor/database/wrapper as db; class MembershipController { public function addMember() { if( ... ){ $db = db::table('foo'); $db-&gt;name = ...; $db-&gt;age = ...; $addMember = db::save(...); if($addMember){ // success. } } } } 
This is for a personal pet project hosted on a very old free account I got in the 56k RTC days. Mind you I had to activate php 5 otherwise they're still serving 4.4.3 :D
Here I go, What are some good VIM plugins one can use for PHP development? 
Thanks, I agree with you to some extent, even though this is the defacto monolog for the use case these days. Basically the whole premise is based on the slippery slope fallacy, that if I don't spend an `$x` amount of time/effort to add a level of abstraction that I won't use now, in the future I will waste `$xx` amount of time for a feature I might use. Not taking into consideration if I will even be using PHP in year, or if my application will ever have the need to grow. 
That dude is a complete ass.
/srv/http/apps/{app1,app2,app3} But rarely do I have more than one app per server.
Omnipay is a great library that might fit your needs: https://github.com/thephpleague/omnipay
How do you prevent stale data then?
then you'll love: chown username:apache file.txt
In your example, you do have model but it's just a really simple dumb model. Your model is in that `$db` variable (terrible naming btw, it should be `$foo`). This model is so dumb that it's auto-populated by your database mapper. It doesn't contain any logic, it's just a bag of key-&gt;values. There's nothing really wrong with that, it is just very simple. But I'd say it's really too simple for any sort of real application. At minimum, you want to some kind of input validation: The `name` field might be required and limited to 255 characters. The `age` field should probably be a number and not allow the string "none of your business". Furthermore, maybe age should be a calculated value rather than just a field as it changes every year. All of that code goes in the model. You could put that code in a controller but as soon as you access the same model in more than one controller you're duplicating effort. If `name` is required that should be enforced everywhere but that code only written once. I would argue there's a pretty clean separation of concerns -- if it's model related it's as easy to put with the model rather than in an arbitrary controller. 
How can I output text instantaneously. Text input box on 1.php. Output text to 2.php. Each letter typed on 1.php is submitted instantaneously to 2.php. Text appears on 2.php as I type on 1.php, in other words. Maybe "real time" is a good way to describe what I mean. How do I do this?
We have all domains as /var/www/domain.com and they are symlinked to /home/user/sites/domain.com. Home and web directories tend to have very different behaviours: NFS, sharing, permissions, concurrent access, caching, etc.
I found ACLs to be a pain. * Poorly supported by libraries and applications * NFS will wreck you * Sometimes the permissions get weird for dubious reasons * Files created elsewhere (think /tmp and tar) and then moved will not inherit permissions. I found myself always fixing permissions, I eventually put a cronjob to reset all ACLs.
Database + Ajax. 
If you want realtime communication between two pages, the only sane way to do it with PHP is to use Ratchet. Checkout its tutorial: http://socketo.me/docs/hello-world
Sorry I should be more clear. The real time output is whatever new, creative, unknown to me, text that the user writes. It can not be selected from an array of words because the input is new and more or less random. So not Ajax.
Yeah, you are right. It does look more like a model. I have such script now, and I should implement a validation for it, but then again I have a validator class, so it won't be needed. Do you have any more suggestions? 
You can always use Firebase.io. It has a Javascript library. Allows you to send data to Firebase, and Firebase will push the notifications to everyone connected. You just have to write the listeners and senders. Long story short, you need to use Javascript to handle the AJAX or sockets. There needs to be a socket server or database application to receive the data. And then it needs to be returned/pushed/retrieved by the user on the other page, either via polling or sockets.
For the same reason we code SOLID: To create software which is easy to maintain and extend over time. The point is to separate what you are doing from how you are doing it by externalising it as a dependency because how you are doing it has the potential to change. This also has the added benefit of making your controllers easier to test, if you're into that thing. 
One thing that could help on top of everything else is to use HHVM. It runs things like reports which generally consist of tight, long running loops much, much faster than normal php.
Sorry, but I think you're fundamentally wrong in both your response here and your initial question, and I'll explain why. &gt; Why do we have to use a model in mvc frameworks? Because otherwise it's called VC, and people try and give us money. Seriously, though, we don't have to use a "model file". That's a common misconception. What matters is that we keep our code split into three layers - one contains business logic, one contains presentation code, and the other handles request and response. MVC frameworks routinely call a specific file the "model". Laravel, for example, refers to its ORM classes as models. But these shouldn't be assumed to be "the model". They're merely an important part of a layer. And, tbh, in a lot of sites can make up the **entire** of a layer. But that's not the point. Can you ignore a model and just put your shit in the controller directly? Absolutely! It's not MVC anymore, though. There are plenty of interpretations of similar patterns that have slight variants of MVC, but they're just... you know... different. There's nothing wrong with that, they're attempts to solve similar but different problems, etc. There is a deeper point though. There's a **reason** people are using the MVC pattern (or whatever approximates it, for the purists) for frameworks. It's a good architecture pattern for systems that have to be maintained and extended. That's what it, and actually really all OOP, is for. &gt; Basically the whole premise is based on the slippery slope fallacy, that if I don't spend an $x amount of time/effort to add a level of abstraction that I won't use now, in the future I will waste $xx amount of time for a feature I might use. Your counter that it's a "slippery slope" is completely wrong. For a start, there's just no slope here. People are advocating choices that make things more maintainable and extensible. If you're not going to be extending and maintaining the system, why bother using MVC at all? Just make a big ball of procedural code, smile upon your creation, and walk away. Using an architecture that's designed around improving and optimising maintainability and criticising it for prioritising maintainibility and extensibility, or saying that those things are a "fallacy" is woefully missing the point. More to the point, your argument ignores huge amounts of fairly obvious counters. You have an `addMember` method and you're contradicting /u/refuse_human for the suggestion that there could be an `addMemberFromApi`. Fair enough you might not need that. But is it not reasonable to think you might at some point very soon have an editMember? It's almost unthinkable that you *wouldn't*. And it's similarly unthinkable that it wouldn't be almost identical to `addMember`. Congratulations. You now have two blocks of duplicate code, with all the setting, updating, and validation rules, responses, etc. This is **exactly** the sort of thing having a model file would allow you to avoid. To make the argument even more clear, why not extend your question from the M to the V? I mean, why not just put the model layer in the controller, right? So... by that same standard, why not put the view in there as well? class MembershipController { public function addMember() { if( ... ){ $db = db::table('foo'); $db-&gt;name = ...; $db-&gt;age = ...; $addMember = db::save(...); if($addMember){ // success. } } } public function getMember() { if( ... ){ $db = db::table('foo'); $member = db::get(...); ?&gt; &lt;div class="member"&gt; &lt;div class="member_name"&gt;&lt;?php echo $member['name']?&gt;&lt;/div&gt; &lt;div class="member_email"&gt;&lt;?php echo $member['email']?&gt;&lt;/div&gt; &lt;/div&gt; &lt;?php } } } Look at that. Nice and simple! Why take into account changes in the future that might or might not happen, right? Your application might never grow. Why use anything more than a controller? &gt; Not taking into consideration if I will even be using PHP in year, or if my application will ever have the need to grow. Seriously, how much do you want an design pattern to do? You can't even commit to a **language** then what's the point? What pattern could **possibly** accommodate that? Some sort of "build from a spec document" system? It's a silly statement to make. 
Also: "...Although, it is difficult to delve into the coding intricacies but Google trend and analytics is something which can help us easily to make the best choice." Yes, always make a choice based on what the masses are searching for. We can't tell by the music, but google trends tells us Justin Bieber is the right choice.
Not a plugin, but I use this enough to alias it: `grep -rsl "pattern" ./` `vim -p $(!!)` -&gt; evaluates to -&gt; `vim -p $(grep -rsl "pattern" ./)` That returns a listing of matches in the first line so you can grep away, and then easily open each file in the previous search in its own tab with the second if you're satisfied. When I need to step through debugging, I use some variant of [debugger plugin](http://www.vim.org/scripts/script.php?script_id=1929) to interface with xdebug.
Nothing wrong with questioning why we (or everybody else) does things the way they do. Let's assume there's indeed some controller that is the only spot where a certain DB table is hit. It might indeed be tempting (sane even?) to just directly code in the controller without having to come up with entities, services, repositories or whatever you're using. Less is more. But even then there are stil pro's of keeping business logic out of the controller: * Inconsistency with other parts of the codebase, which makes the project harder to grasp. * The flow of what happens in that controller becomes harder to read as it is interspersed with database code. * You might know at what point refactoring to separate classes is needed, does everyone in your team?
I guess it depends what the specific mission is. If you're going to have users logging in and want to jail them to a home for permission reasons (including FTP), id do /home/username . if its going to be edited only by root users id use the /var/www/ . 
Is this comparable to apigility or what? &gt; It extends the Proton Micro StackPhp compatible Framework. Describing it in terms of other frameworks I haven't heard of isn't helpful.
Get a cheap VPS. They are CHEAP :)
Ignore MVC for a second... software developers have for quite a long time recognised that an object which has more than one responsibility is difficult to maintain, extend, test and reuse. Whether you actually do end up extending (experience should tell you that you probably will), you are likely going to be maintaining, and you should be testing. Simple objects with discrete responsibilities are far easier to comprehend. 
You can do this with Pure Ajax. Attach an onchange event to the text input on 1.php and put a small interval loop on 2.php that checks for updates. It has nothing to do with predefined arrays. That being said, Ajax is not the best answer (sockets are) because polling is slow and inefficient. 
Let amazon/paypal handle it lol
Am I the only one who thinks this is a bad idea? Multiple sites on one box... yeesh
Multiple sites on one box is good. Putting everything off the home directory probably not. But that's how I've been doing it for 6 years. Granted this is because I started with shared hosting and that's how they did it.
yes 
It was clearly a joke (as indicated by the tone with the "lol").
&gt; I use mod_ruid2 Be aware that *mod_ruid2* is not really maintained anymore and the author itself warns about security issues in the README - I wouldn't recommend using it.
I've been using PHP for Wordpress mainly. I'm starting to look into PHP frameworks like Laravel and came across Composer. Okay so I understand that Composer will pull in all the required libraries, dependencies and manage them all in one place and makes starting a project easy. Question is: 1. What packages are these? 2. Why do I need them? 3. How do I know I need them? 4. Where do I find them?
There are pros and cons. My experience was yes, using a framework can slow down your understanding of the underlying language. When I first started working with Python, we ended up using the Django framework. Django's great, but I ended up learning so much Django specific stuff that I learned less Python. In order to learn more Python I had to pull away from looking at it through the lens of a framework. But that's just my experience. On the other hand, working with a framework may expose you to some best coding practices. Especially if you look under the covers and see why certain functions work the way they do. Also, many jobs will expect familiarity with their framework of choice, and if not, at least A framework.
If you don't go the extra step to learn how the framework works, then yes it certainly does hinder you. But it can also be a great way to actually learn how things work, if you take the time to look at the source and even better if you then compare how another framework approaches the same problem. Sadly frameworks can be a double edge sword, allowing people to build things without truly understanding what their doing. The tipping point is usually performance or when attempting to go beyond the basic expected implementation of a framework. We've seen it happen for years with things like WordPress or jQuery where you get lots of people who know "It's" way of doing things. Nothing wrong with this, allows more people to build things but with the knock on of not actually mastering it. 
No, refusing to learn more is the only thing that hinders new devs from learning more. Imagine having to learn circuitry gates before being allowed to use a computer, that would basically ensure that almost no one would use a computer. Some of the best computer users out there don't know how logical gates in circuitry work.
Get your data, *then* do the computations. At least in this case, remember we're talking about at most 10^4 rows.
For WordPress there's [WordPress Packagist](http://wpackagist.org/) which is a Composer Repository for WordPress plugins and themes. So to answer question 1 in a WordPress context, packages are plugins and themes. &gt; What packages are these? Outside the WordPress world some of the most popular packages are: * [psr/log](https://packagist.org/packages/psr/log) Common interface for logging libraries. * [monolog/monolog](https://packagist.org/packages/monolog/monolog) Sends your logs to files, sockets, inboxes, databases and various web services. * [symfony/event-dispatcher](https://packagist.org/packages/symfony/event-dispatcher) Symfony EventDispatcher Component. * [swiftmailer/swiftmailer](https://packagist.org/packages/swiftmailer/swiftmailer) Swiftmailer, free feature-rich PHP mailer. * [symfony/console](https://packagist.org/packages/symfony/console) Symfony Console Component. &gt; Why do I need them? In case of the five packages above: psr/log if you want implement your own log library. This makes it possible for devs to just swap the log library and have keep their application running without any code changes. monolog/monolog is a widely used log library. symfony/event-dispatcher enables you to dispatch events inside your application, listen and react to them. And so on. You don't *need* these libraries, but without them you'd have to write all this stuff yourself. &gt; How do I know I need them? That's not an easy one. Probably if you have to write something that's not really "business relevant" or domain logic but a generic component? In that case it probably already exists. &gt; Where do I find them? I already posted the links, but [WordPress Packagist](http://wpackagist.org/) for WordPress stuff and [Packagist](https://packagist.org/) for general PHP stuff.
Straight to the point. Thank you!
Awesome. Thanks! I will look into it further.
The Wordpress example just made everything clearer. So with Composer I do not have to manually add plugins and themes into the folders. Once I run "composer.phar update" the plugins and themes will be installed into their respective folders. Am I right? Where should I install Composer? Root or theme? I suppose this will also be where composer.json would go.
I keep user sites in /home/someuser/htdocs/ and my sites in /home/myusername/sites/sitename/htdocs/, then symlink both into /var/www.
&gt; much of the Linux file system hierarchy is outdated and irrelevant for modern servers/systems Can you cite some examples of what you're referring to here?
Using php frameworks definitely hinders the advancement of skill. Especially when it comes to beginners. I would go as far as to state that frameworks prevents one from stopping being a beginner. It's because of two main factors: - php frameworks perpetuate bad practices (global state, tight coupling, multiple responsibilities, leaky abstractions) - communities for the said frameworks feel personally invested in their framework of choice and will oppose any criticism What we end up with "developers" who have worked for 5 years, but who haven't learned a single new thing in all that time.
That is a false analogy. 
jQuery is a good analogy. A lot of jQuery users couldn't use the DOM directly if they had to, which is rather scary.
Yes, absolutely they do. Frameworks are there to provide solutions to problems, if your problem happens to be "I need a site fast and don't know exactly how" they solve that problem well. However, if you have no problem other than "I don't know php very well" that is absolutely not a good enough reason to use a framework, in my opinion. Frameworks are always open to change, and often arbitrarily so. The best developers are always the ones that seem to make informed decisions about frameworks rather than the old "look a shiny framework that makes my site more glittery - MUST USE" 
Exactly. Personally I've installed composer globally (see [here](https://getcomposer.org/doc/00-intro.md#globally )), so I only have to run `composer update`. I've done that because I use it quite a lot. Also have you looked into autoloading? Composer helps you with that, too.
I've been learning Symfony2 for the last 3 months or so. It's great as are many of the components used in it. The problem I'm having is that learning 95% of everything is super easy and fast and has all sorts of documentation. It's that remaining 5% that takes days to learn how to do some very simple things or to learn basic fundamentals. So in the long run they can be great if you can somehow figure out that 5% of really important stuff that is next to impossible to figure out or find details on.
Errr... you realise we are in 2014 (pretty much 2015 actually). This sounds like the PHP community from 10 years ago.
No, it's hyperbole.
&gt; I did mean dissertation. I was mocking the use of 'Finally' as a lead in to your second discussion point. Ah ok, I missed that. &gt; it is not the data storage half of SQL to do the heavy lifting, but it IS the job of the interfacing language SQL *is* the interfacing language. It's right there in its name. It has nothing to do with data storage except to describe it. I don't know what else to tell you.
No, it is not. You are comparing apples to oranges. People who use computers do not need to know how a logic gate works. But people who design CPUs must know how a logic gate works.
Can you name me one framework that doesn't fit in these points?
Sadly it takes time and experience to look past "Shiny, shiny" and be able to actually see if X will help build Y without limiting for future use of Z ;)
I was trying to illustrate for you, that you "logic gate" analogy **is not comparable** with language-to-framework relationship. 
**User** * id * username **User Address** * id * address_type (shipping or billing) * address_id **Address** * id * address_line1 * address_line2 * city * state * zip --- Perhaps something like that?
Totally agree. I think the onus should be on the developer to say "Why *should* I use this framework" rather than what seems to happen now which is just "well why not?".
One point would be that the DiC is actually used as a service locator, which means your code is tightly coupled to Symfony's container. I'll let @teresko answer if there are other points :)
I've never heard that the PHP community would speak with one voice, so I highly doubt that. And are you sure about the number? For me that sounds more like you wanted to pick a high one (at least two digits) so your argument sounds better, so if you could back this up with some sources, I would really like to know more about that.
Just a copy and paste pointer but a good quick answer. If you're still stuck I'd be happy to go into more detail but there's fine examples from much better than me out there http://stackoverflow.com/questions/490969/stack-overflow-reddit-voting-system-in-php
You mean *"side from being really terrible choice for a beginner because of the steep difficulty curve"*, right? The issues with symfony2 are: - DI container is used (and recommended to be used) as service locator - there are extreme [LoD](http://c2.com/cgi/wiki?LawOfDemeter) violations (note: minor LoD violations in code are often beneficial) - tight coupling to the names of bundles and/or classes That said, Sf2 is IMHO the best php framework that we currently have. Than again,getting "best php framework" title is like being smartest on in the remedial class.
Cool thanks, I think that's how cPanel does it right? Or something similar? I use nGinx and found a way to start a new php process as each user, but then it starts eating up memory pretty fast. Does ruid2 keep php as one process and magically assign privileges as need be? 
That works pretty well, folders would be 775 and files would be 664 right? Just as a general rule, instead of the old 755 and 644. Do you know if this is a good practice?
&gt; Wrong. For example: &gt; "myapp.com" can exec. PHP at /var/www/myapp.com/ as it's doc root. &gt; "uploads.myapp.com" is at /var/www/uploads.myapp.com as it's doc root. &gt; Permissions allow the running PHP (PHP-FPM/mod_php/otherwise) to write files into /var/www/uploads.myapp.com. Actually not wrong, because in a previous comment you said that the vhost serves only static files and no PHP execution is allowed. That means that your files from "upload.myapp.com" will be written across document roots by "myapp.com" and/or any other local application which has upload capability. &gt; files saved outside your document root are then only accessed via a second virtual host (e.g. upload.myapp.com) with it's document root set to the uploads path and no PHP execution allowed - static file serving only.
Here it goes: How do I run a php script which is located on the server? The script should import a file (which is on the server) into a database.
There's nothing unreasonable about knowing how to use shell tools and using them as part of dev. ack/ag are going to be a bit faster than phpstorm's search, though lacking in UI integration.
You can use mt_srand to seed the RNG with the entitity id. Then use mt_rand to select one of the variations.
Historically (and I'd be surprised if much has changed) browsers haven't supported the DOM reliably, which is why there's jQuery - if one isn't actively developing a compatibility library, one might take more pride in delivering working widgets versus knowing the ins-and-outs of the ever-growing number of browser [quirks](http://quirksmode.org/) in the wild, no?
&gt; Beginners might learn the theory behind current best-practices, but do they really understand the benefits they bring in a real-world application, without undergoing the transition from bad &gt; good? Whatever day you start, one day that'll be the "bad old days" - the fact that people take up *any* programming pursuit is a good thing IMHO, whether they start with [training wheels](http://tnx.nl/php.html) or not. Sure, many will get comfortable with a framework and stop learning there ... but the fact that a framework was there for those who would've otherwise given up before a "hello world" doesn't mean that it can't be a springboard for those who get interested. Everyone learns at different rates and peaks at a different level of understanding - worrying about others' lack of knowledge isn't nearly as enriching as building one's own (there'll never be any *real* competition between those who can't write an SQL query to save their life and those who bother to RTFM and scour the sourcecode).
The short answer is: "how do you think?" The longer answer is: I'm not really going to answer the question that you think you're asking, and instead I'm going to answer what your question should be: "How do I figure out how to do achieve this?" And my answer (again) is: think about it. Seriously. Think about it. What are the steps that you think happen during the process? 1. You click the button. 2. What do you think happens when you click the button? 3. What do you think happens after that? 4. etc. The solution to *any* problem is to really break it up into smaller and smaller and smaller problems until you reach problems you know how to solve. Do you know how to handle a click event in Javascript? [If not, you should figure that out first.](http://api.jquery.com/on/) Do you know how to increment counters? [If not, you should figure that out second.](http://www.codecademy.com/courses/a-simple-counter/0/1) Do you know how to save that new number into a database? [If not, you should figure that out next.](http://code.tutsplus.com/tutorials/everything-you-need-to-get-started-with-mysql--net-3076) Generally speaking, asking a question like yours isn't particularly helpful -- that is, it's unlikely anyone else will take the time to fully answer your question. That's because the scope of what you're asking is much larger than what a typical "answer" would be to a question. You're really asking a dozen questions in one: "How does this work? How do I do a click event? How do I change the color of the button? How do I count how many times people have voted? How do I save that so that it lasts forever? How do I show that to other users?" So my advice is this: when you're tackling a new problem, break it up into smaller problems, until you start to find problems for which you know the solution **or for which the solution is easily found**. All code is just a series of small statements... big, complex tasks are generally just a ton of simple things put together in a specific order. Figure out what those simple things are, figure out how to put them in the right order, and voila, you're done. It's easier said than done. Hope I'm not too condescending here... I'd just rather teach a man to fish than give him a fish, you know what i mean? :) Best of luck.
And so we circle back to my original comment which someone said was overcomplicated
Do you need help finding a project, do you need help with how git works, or both?
I disagree. I build great code but I think of this as a business, which means that I need to devote a certain amount of time to working the pipeline. I've met plenty of talented developers who went freelance who think the world will magically know that they are open for business or that they can focus just on being good at programming. On that note, I have 15+ years experience in web app development in many subject domains. I've built great stuff and I've screwed up royally too, but I'm at a point where I can see the difference between the two paths. PM me if you want to talk about projects.
My path to open source contributions began with using a lot of open source software. I found myself saying, "this doesn't work the way I expect it to," or "it would be really cool if I could do this thing." Then, you just fork the repo and code away. Make the library do you what you want. Create a pull request to the original repo, and if the owner likes it, they'll merge it. Some tips would be to just follow their coding style/guidelines, test everything, and maintain backwards compatibility. 
&gt; Historically (and I'd be surprised if much has changed) browsers haven't supported the DOM reliably This has absolutely changed. The modern browsers are a bajillion times better. 
i'm going to replace evernote with this =)) 
memoization is for pure functions. 
I need help finding projects. I want to focus on back-end development, mainly PHP and SQL to start, but when I search PHP on GitHub, the only thing I find is "The PHP Interpreter" repository. Where do I find other projects? It doesn't seem like it should be that challenging to do, I must be overlooking something fairly easy??
Well-&gt;to-&gt;be-&gt;honest() I must say that putting '-&gt;' every 2 letters is really cumbersome. I would much prefer toBeEqual to -&gt;to-&gt;be-&gt;equal. Also the colors you used for code highlighting burn my eyes =) This function kinda sucks: https://github.com/peridot-php/leo/blob/master/src/Core/Definitions.php It's definitely doing a huge amount to stuff. Try turning it into a class that utilizes __invoke instead 
I believe this syntax works, too (at least on debian based OS): chown user.group file.txt
&gt; Historically (and I'd be surprised if much has changed) browsers haven't supported the DOM reliably, which is why there's jQuery Eh, not really. Even IE 6 supported the DOM pretty well.
Nobody here has heard of suexec it seems http://httpd.apache.org/docs/2.2/suexec.html
Not a fan of Monokai eh? Thanks for the feedback! This might be a good reason to use the [Assert](http://peridot-php.github.io/leo/assert.html) interface instead of the expect interface. I think I do like the invokable object pattern, and I used it it in the [LeoHttpFoundation](https://github.com/peridot-php/leo-http-foundation) plugin. Definitely makes mixed-in behavior more portable. A goal for Leo was to be flexible in [how you mix in behavior](http://peridot-php.github.io/leo/plugins.html#plugin_extend). I can definitely see definitions outside of the core definitions leveraging more invokable objects.
Should I keep use PHP?
TLDR: I believe you should learn the raw PHP first and then venture into frameworks. Personally I think the way that I learned is a way that could be helpful to some others. Basically, I got a job in college at a startup, originally programming a c# app. But then our company wanted to move to web and we already had a website on GoDaddy. I had the most minimal amount of PHP, server, HTTP experience, because most college curriculums don't go in depth with such topics, but I knew about FTP and PHP. So I started there. I accessed the files using winscp and edited them in sublime. I learned how to use &lt;?php ... ?&gt;, javascript, and even styling inline. (EEK! ikr). So here I was, starting at the bottom, like a noob. No one was holding my hand and telling me what to code. I was the only programmer at this startup and no one else had any web experience. BUT that is what made my learning experience so perfect I believe. (enter the interwebs, /r/php, codeschool, google, stackoverflow, code academy, and treehouse...) If I wanted to do anything, I needed to learn it, I always had a set goal in my head of what needed to be done, and I always ended up going down multiple paths. Not until about a year and a half into my development life, did I start hearing about frameworks. By this time our site had 3000 users, some intricate logic. I thought to myself, why the hell do I need a framework when I can just do it all myself. And then I remembered what one of my best professors told me programming was... 'Appropriate Laziness'. Then I thought why write something myself when someone else has already written it. I believe going through the trials and tribulations of building a decently sized web app has tempered me into a better developer and gives me a deeper understanding of what is really going on under the hood of such frameworks.
I love it. Teaching people to think critically, rather than spoon feeding answers. Personally, I don't think you're being condescending. It looks to me like you made a thoughtful post and genuinely want people around you to do better. :-)
For plugin manager: https://github.com/junegunn/vim-plug Here's my plugins: * vim-sensible - good defaults - https://github.com/tpope/vim-sensible * FuzzyFinder - https://github.com/vim-scripts/FuzzyFinder * L9 - https://github.com/vim-scripts/L9 * vim-json - better json formatting &amp; added functionality - https://github.com/elzr/vim-json * nerdtree - https://github.com/scrooloose/nerdtree * vim-colorschemes - https://github.com/flazz/vim-colorschemes * vim-phpcolors - https://github.com/modess/vim-phpcolors
I'm sure this will get buried with close to 50 comments already, but here's my approach. This is for VPS or development systems since the whole question is out of your hands if you're using shared hosting. * The root of the website/app is: `/var/www/&lt;domain&gt;/`. If there are multiple subdomains then I use `/var/www/&lt;domain&gt;/&lt;subdomain&gt;/` * Names like `htdocs` and `public_html` are a stupid tradition because they contain more than just HTML files. I configure the server to use `/var/www/&lt;domain&gt;/public` as the publicly accessible directory. Then I organize files/directories that should not be publically accessible at the `&lt;domain&gt;/` level. * Creating a symlink from `/home/&lt;username&gt;/public_html` to `/var/www` is stupid. Anything under `/home` should be personal (or how the FHS phrases it "data that is only of interest to a specific user"). If you're the only user then work in `/var/www`. If there's a team then you're going to be working on the same files anyway so work in `var/www`. `/home/&lt;username&gt;/public_html` is only good for `example.com/~user` type sites. * Add your user account to the `www-data` group (or whatever the group your server runs under) and re-assign permissions on the `/var/www` directory: * `sudo adduser &lt;username&gt; www-data` * `sudo chgrp -R www-data /var/www` * `sudo chmod -R g+rw /var/www` * `sudo chmod g+s /var/www` (You'll need to log out and back in for the shell to pick up the changes to your account's permissions afterwards.) * You can configure your system to use `/srv` instead of `/var` if you'd like. See the [FHS's description for the `/srv` directory](http://www.tldp.org/LDP/Linux-Filesystem-Hierarchy/html/srv.html). In the end my typical skeleton web app directory structure looks like this: * `/var/www` * `example.com` * `bin` * `conf` * `include` * `public` * `css` * `img` * `js` * `tests` * `vendors` 
Looks really, really good. Needs some [packaging work](http://phppackagechecklist.com/#1,2,4,5,9,10) though.
Somehow I missed the LICENSE, not sure how that happened. I'll fix that.
:)
Wow, I guess adding 'language:' before php helps a lot... I have already found a few that seem interesting and that I can learn a lot from. 
It's like asking if driving a car hinders you from learning how to get around town. I mean that's not really *you* going. The car is what's going, and you're just sort of directing it. There are still plenty of people who can't learn directions, and who drive. But the two things aren't related. And those same people would be just as lost on foot or on a bike.
&gt; if the owner likes it That's really sort of the bone of contention with contributing to someone else open source project.
Do you want to run it on the server via command line or do you want to run it in a web browser? If browser, just type the address into the address bar and it will run. If command line, go to the directory and then type "php myscript.php" where myscript.php is the name of your script. If you have php installed properly, it will run the script. If the server replies that php is not an executable or binary file or something like that, you don't have php in your path. Any other errors you get would be in the script and would need to be debugged.
Thanks! Leo is just a small piece of a testing environment. It's pretty un-opinionated on what test framework you use. Instead of `$this-&gt;assertEquals(1,1)` you can use Leo's `expect(1)-&gt;to-&gt;equal(1)`. It really comes down to a preference on how you want to describe your expectations. Another benefit might be how extensible it is. I think its pretty useful to write something like this in an api test: `expect($response)-&gt;json-&gt;to-&gt;have-&gt;property('name');` Which is part of the functionality added by the LeoHttpFoundation plugin mentioned above. We do a lot of BDD style testing in the vein of Mocha for JS using [Peridot](http://peridot-php.github.io/), and the expect interface compliments it nicely.
I actually just tried it on a whim but most of the time things like that work. Embrace the open source world, but don't forget there's other sites too like BitBucket. You may not get as much exposure on there but there's some projects that are on one and not the other.
Thank you! I'll install them asap. By the way, I use Vundle. Is there any advantage from using Vim-plug?
Right, but I feel that if you get a project with an active community, chances are someone else would find your solution useful. I haven't had any times where pull requests were outright kicked out without some good feedback.
Honest question. Can this work on any php server without the installation of PHP extensions?
I don't want to shoot it down with a quick one-liner on the internet but personally I prefer the PHPSpec style. $mock-&gt;getTitle()-&gt;willReturn('result')-&gt;shouldBeCalled(); It's still English sentences, but each token has a meaning, unlike -&gt;to-&gt;be-&gt;... I would reconsider using expect([1,2,3])-&gt;toHaveLength(3);
Peridot itself actually looks cool, too. Its syntax is very similar to Jasmine for JS, and I like that. It would make testing syntax look more consistent between javascript and php. I will probably give it a try on my next personal project.
&gt; Symfony has done a Laravel-style 180Â° and dove right into making its components more end-user friendly, its docs more complete, and its AppBundles unbundled, simplifying entry and further development almost exponentially Awwww yeah. That was my only complaint with Symfony. Laravel does ~85% of what Symfony does painlessly, but Symfony does *NOT* do 85% of what Laravel does, painlessly (it does it of course, but painfully in comparison to Laravel). So the choice for me has always been 85% painful development (Symfony), or 15% painful development (Laravel). Kind of a no-brainer.
It depends. Do you want the thing's score to decay over time (like a post)? Or do you want the thing's score to be purely based off of its estimated quality (like a comment)? These are two very different algorithms. Here's a good post about this stuff: http://amix.dk/blog/post/19588 These algorithms are core statistics concepts - if you want to learn more about this, consider taking a statistics class :P
Leo - Next level actor (sorry had to do this)
Had some pretty good work in progress on this already https://github.com/peridot-php/leo/pull/1
I like it - I really like how it's right there on the toolbar as well, if you use it as part of the framework. What's missing from the cookbook article is that if you're migrating to 2.6 from a previous version, you need to ensure you have enabled the DebugBundle in your AppKernel. http://symfony.com/blog/new-in-symfony-2-6-vardumper-component
&gt; test everything Emphasis on this one. Lots of projects have automatic testing set up, and if your changes break existing tests, they will most likely reject your contribution. Just be sure to update any affected tests.
Ouch. In my country (I live in Venezuela) it's kinda difficult to have access to foreign currency. Thanks for the information though :)
There's no one answer. Some people are helped more than others using particular tools and learning approaches.
I think you missed something in all these comments http://imgur.com/SKdk4X7
Pretty cool, but I still like the UI to dBug more. http://dbug.ospinto.com/
I don't think there's a big difference between plug and vundle, honestly I don't remember what made me go for plug initially. I think it was just the new hotness at the time. Good luck!
While that is true for WordPress or jQuery, some frameworks are a shining example of how to be a good programmer. For example, I've seen people learn to use Symfony and become far better developers because of it.
Have an upvote for the proper use of `/srv` dir
This is essentially a subset of [Java's annotations](https://docs.oracle.com/javase/tutorial/java/annotations/) hacked into PHP through the [reflection API](http://php.net/manual/en/reflectionclass.getdoccomment.php). It's relatively common. What you get out of it in this case is locality of definition. The `href` argument to that `@Hateoas\Relation` annotation in particular allows you to add routes to your app without actually modifying your router; you just need to drop in the class and the framework automagically starts dispatching those requests. (Whether this is worth it to you is another discussion altogether.) Is this confusing? Hell yes! In a perfect world, it should be possible to delete comments (and docstrings, etc) without changing the behavior of your program. That's what comments are for, right? Unfortunately, this is the *only way* to get annotation semantics in PHP. So until we get a real annotation system in the core and pre-annotation PHP versions drop off of LTS, we have to settle for the hack version if we want annotations.
Thank you :)
I've noticed that when I use Symfony's CRUD generator, the delete action is called using the DELETE http method and the delete link is actually a form. Is there a problem with adjusting the route to delete the record using /{id}/delete instead? Is either way incorrect?
I really like this feature. If, like me, you are still using Symfony 2.3-2.5, you can get this exact functionality from [this bundle](https://github.com/tchwork/debug-bundle).
xdebug doesn't have nearly as much functionality. Did you seen him expand a section of code and show a closure in the class's property with the line number the closure was defined? Do that with xdebug.
Symfony is an exception to my initial comment, to me it doesn't fit the typical framework mould as right from the start you using much smaller, well thought out components and not just following the cow path of a single developer or team. Aura also seem to be doing this very well, although i've not personally had a chance to do anything with their stuff yet but they certainly send out the right messages. 
I believe this is mostly for CSRF protection, both ways are correct one is just more secure. 
And he, patiently, explained why you are wrong.
Nice summary of the different micro frameworks that are available including some that many people haven't heard of. People are pretty opinionated when it comes to their frameworks, so you might have better reception not to include adjectives that denote quality, like "best", in the title. Also, the API people will not like you using RESTful out of context. I shared it so might help you out. 
Yeah, I didn't really go into detail on the other lookup tables. That being said, you could have a lookup table for the address types and states
Will it truncate strings that are too long too?
I store addresses in the payment tables, and orders table (service in your case). I also maintain an address book table that can auto fill the forms using a drop down. I have decided to keep the addresses in those separate tables because an address isn't always required... And I want to be able to make changes to specific order addresses if required.
Wow.. that brings back some Cold Fusion memories. edit: now that I read the text they clearly state its from CF, oh well, still love/hate memories :)
I actually prefer ladybug....
You just have to remember that the DOM is that handy global, mutable variable that's too big for its own good, and that it just has a bunch of triggers firing when its state changes. Oh and you can change its state from anywhere, no biggie. Oh and the triggers can be changed from anywhere too. Gee, I wonder why people would use Javascript libs! 
This might be a subjective question but... From a beginner standpoint, as someone who understands procedural PHP but hasn't written projects with it, is it better to get familiar with writing procedural PHP first or jump straight to trying to learn an object oriented form? And is it easier to jump into an MVC style framework than getting the hang of DIY object oriented stuff?
thanks you were the most helpfull
Thanks for the info, that's useful. I'm familiar with type annotations use by code analysers and IDEs, but of course they are optional. Not so here, it seems. In this case, I would assume these annotations are cached somewhere (since we cannot be calling Reflection for every call). In that case, the thing that is scanning for annotations could instead scan for classes extending a particular base class, and auto-execute a magic method, which in turn would do all the necessary routing initialisation. That could be cached in a similar way. With that simple alternative, the only thing I see as an advantage is keeping routing definitions with the methods that should be called. For me I see this as the wrong place anyway - I would rather have my routing in a centralised file (plugins excepted perhaps) so it is easier to work out where a routing problem is being introduced. Does annotations in the way they are implemented here offer more than my simple code-based alternative? I wonder if I am missing something here. 
I've always used [Kint](http://raveren.github.io/kint/). Any opinions or facts on why this is better or worse?
Yeah this is nasty bullshit and you should never use it or do it. I want this php "fad" to die out until PHP comes in with proper language-level syntax for this. Annotations are bolted on pseudo-language with their own arbitrary syntax, and arbitrary support/stability cycles. Code should not be executed this way. Either provide a native PHP syntax to accomplish what you want in a normal PHP execution cycle, or don't bother building the library in the first place... Sorry if that sounds harsh, but annotations piss me off - clear and utter abuse of reflection and a requirement that users of your library learn a completely arbitrary 3rd party syntax instead of building your library in the language they already know: PHP. I mean, why not just do shit like this? &lt;?php /** * @Execute("python") * @Code: * * def hello() * print "World!" * * def lolPHP() * print "Why even bother writing php when you can just have one giant-ass doc block full of python?" */ class Derp { } \&gt;:(
To be honest unless you actually use the software it's pretty hard to determine what changes are worthwhile. Whenever I've made significant contributions to projects it's because I needed a feature that didn't already exist. The slightly exception to this is that lots of big projects need unit tests written but that's not a very exciting thing to work on really.
Does it safely handle dumping Doctrine objects? 
If you are using it standalone, `Symfony\Component\VarDumper\Cloner\VarCloner` has a method called `setMaxString()` which allows use to set the truncate length. As far as where the config tree is parsed in the full-stack framework, it is part of the `DebugBundle`: https://github.com/symfony/symfony/blob/2.7/src/Symfony/Bundle/DebugBundle/DependencyInjection/DebugExtension.php#L37-L39
I haven't take a look at Aura yet. Thanks for the heads up.
I don't know PHP very well so I would be very interested in how to solve this problem. I guess one tactic is always to limit server processing time per request.
I asked this last week and didn't get the answer I was hoping for. If I want to cache database stuff in Redis (or whatever) how would I go about implementing that if I was using PDO? I think making a decoratoring PDO class that wraps the real PDO class but I don't know how I'd go about intercepting the queries. class PdoCachingDecorator extends PDO { public function __construct(PDO $actual_db_connection) { } }
&gt; You just have to remember that the DOM is that handy global, mutable variable that's too big for its own good, and that it just has a bunch of triggers firing when its state changes. All of this applies to jQuery. &gt; Oh and you can change its state from anywhere, no biggie. Oh and the triggers can be changed from anywhere too. All of this applies to jQuery, &gt; Gee, I wonder why people would use Javascript libs! Well you haven't answered that.
Ah, right. Thanks! 
This article has been heavily redacted now since its original form yesterday. It was full of personal attacks again a "junior developer" (me apparently) in which he explains how he was trying hard to help but got bullied, or something. Let's have a little story, because there are lots of good lessons to be learned. He was working on a few small and kinda handy features, which he then put into [one massive bulk PR](https://github.com/thephpleague/oauth2-client/pull/88). This bulk PR had some things we agreed with, and some things we didn't agree with. _**Lesson 1:** That is the downside to multiple changes in a single PR and can lead to bottlenecks. Keep PRs specific to just one change, and try to avoid PRs that depend on other PRs._ We spent 3 or 4 days discussing these changes in only a few emails. During this time some other merges happened, leading to conflicts with his branch. _**Lesson 2:** Massive PRs gather conflicts quickly, which is another reason to avoid them. If you must do them, merge upstream changes quickly or you will be stale again._ After being requested on May 5th (day 4 of this PR) to pull changes (pretty damn reasonable) he waited until May 19th [to complain](https://github.com/thephpleague/oauth2-client/pull/88#issuecomment-43530544), at which point there were even more conflicts. I gave [some general advice](https://github.com/thephpleague/oauth2-client/pull/88#issuecomment-43570971) on how to make PRs and avoid these problems, but he flipped out and took his toys with him to [make a new fork](https://github.com/thephpleague/oauth2-client/pull/88#issuecomment-43588528). _**Lesson 3:** Don't flip out when just because somebody gave you feedback to avoid a crap situation that you accidentally created._ He then asked us to [remove all of his code](https://github.com/thephpleague/oauth2-client/pull/97), which is something I've never seen happen in open-source. There is no legal requirement for us to do this. He [renamed the project](https://github.com/StukiOrg/oauth2-simple-client/commit/cce69346275719be2d14c1f8a12c56b4881f233b). He removed Alex Bilbie from the LICENSE (illegal) and that's when I lost my cool. I tried to [put the Acknowledgements section back](https://s3.amazonaws.com/philsturgeon-blog/Added+missing+credits+by+philsturgeon+%C2%B7+Pull+Request+%232+%C2%B7+StukiOrg_oauth2-simple-client.pdf) and asked him to fix the license. He tried to argue that purely the number of line changes involved in the code meant it was fine for him to just pretend it was his. Sure, if there is substantial change then he can release under a new license, but this chap just added about 40% coverage to our unit tests and kicked the codebase through CS-Fixer. Not substantial. Since then he's done nothing with his codebase in 7 months, other than add a Meetup provider shortly after we did. (More copying.) Last week I asked him one more time to merge the PR adding acknowledgements back into the README. His response was to ask me to make a new PR because this was already closed. [So I did](https://s3.amazonaws.com/philsturgeon-blog/Added+missing+credits+by+philsturgeon+%C2%B7+Pull+Request+%234+%C2%B7+StukiOrg_oauth2-simple-client.pdf). He then wrote a whole diatribe about how I'm a junior who does't understand how open-source works. I'll try not to overuse this one, but the American government gave me the hardest visa you can get (twice) for contributions to open-source. It's pretty fucking difficult to say I don't know how OS works after that. All I was looking for was a bit of respect, for myself and the other named contributors who put in some serious time and effort on this code. Instead I've been insulted, threatened with legal action from his lawyer who specializes in military law (what?) and had shitty blog posts written about me, all of which have since been redacted. He's deleted comments from me where I was being perfectly reasonable, said a bunch of stupid crap to work me up, then left only the messages where I'm angry. Whole pull requests are gone. It's a level of addiction to asshattery I've never once seen before. His fork seems to be going again, with loads of really weirdly worded [messages like this](https://github.com/StukiOrg/oauth2-simple-client/commit/94fc2c770013ac2865c4ac75d42c139cccabdcf4). &gt; This is a break-away fork and this is the offical repository for oauth2-simple-client. &gt; &gt; This simple client implements a well architected solution for OAuth2 authentication. Contributions are accepted for new OAuth2 adapters if you choose to share. It's all been so very strange. Steer clear of this guy, and lets not post his junk up here. It'll probably say something totally different tomorrow.
&gt; More seriously, beginners are much better off using libs. &gt; &gt; When they don't use libs, they end up tinkering (by pretty much throwing bad code at the browser) until something works. &gt; And then their code breaks when someone accesses the script using a browser they didn't plan for. I've seen plenty of awful jQuery code written by beginners that is equally dependant on browser behaviour. And if beginners rely on jQuery, then they don't understand how things actually work underneath (dealing with the actual DOM) and can't fix problems they encounter in their code.
Again - you have lost me. It's quite simply two vhosts, only one of which can exec requested PHP scripts and has file system permissions to write files into the other. Can't really make it any simpler for you. Maybe let's just leave it at that and move along. :)
Ahh I see! Well that makes things easier then. I have never used autoloading. Just had a brief look into it and I can tell that it will be useful for project startup. Thanks for your help. This will give me a good start to using Composer.
Yes
I personally like to just ln -s within the webroot to a /home/$USER/web/$SITENAME/ and use virthosts of some sort (i use lighty/apache in a mix) 
&gt; Why isn't Symfony suited to building a small, simple website? Because our minds are wired to build something from the ground up, not stripping components that you will not use and because of the scary thought that you will *radically* change a full stack framework, which I agree could be challenging if you don't fully understand the framework. Leaving that aside, maybe in 2015 I will close a task which is in my todo list for a long time: *Build something small with SF2*.
The best way to solve this problem once and for all would be to create a randomized hash function like Ruby and Perl did. Python also solved it this way: http://bugs.python.org/issue13703 But perhaps this has already been discussed 
[Original write-up on the official Symfony blog](http://symfony.com/blog/new-in-symfony-2-6-vardumper-component)
Well, looking at the PDO documentation, there are two methods responsible for actually executing queries: `query` and `exec`. So your cache decorator would implement those two methods, check to see if the results of those queries are already in the cache, and return them if so. It'd look something like this: ``` class PdoRedisCacheDecorator extends PDO { public function __construct(PDO $next, RedisCache $cache) { $this-&gt;next = $next; $this-&gt;cache = $cache; } public function exec($statement) { $useCachedResult = false; $key = false; if( !$this-&gt;isReadStatement($statement) ) { return parent::exec($statement); } $key = $this-&gt;generateCacheKeyFromSql($sql); $useCachedResult = $this-&gt;cache-&gt;has($key); if($useCachedResult) { $result = $this-&gt;cache-&gt;get($key); } else { $result = parent::exec($statement); $this-&gt;cache-&gt;put($key, $resultSet); } return $result; } } ``` You'd have similar code for the `query` method as well.
&gt; And sure, if youâ€™re an Xdebug user, youâ€™re probably used to a slightly better looking output than the raw PHP prints. If you are already using xdebug, why not just setup the step debugger? I can not stress this enough, if you have never tried out stepping do so on your very next project. You will save so much time over var_dump it is ridiculous, and this is one of the biggest favors you will ever do for yourself. If you are actually going through all the trouble to setup a dev dependancy like this just to make var_dump marginally better, setup xdebug instead and tryout a proper debugging tool. You can set breakpoints instead of typing our new lines of code. You can adjust breakpoints on the fly. View not only the one variable your are interested in, but also all other in scope variables like $_POST, $_GET. See the current call stack. And you can do all of this with the press of a button in your IDE, instead of writing dump code, page refreshes, etc. It does take a bit to get setup and learn, but that time is easily earned back in how much faster you will get at debugging.
*cough* voices *cough*
I hacked together this, a while ago: http://phpnews.io/ It aggregates the RSS-feeds of a bunch of people in the PHP scene, that find interesting to follow. Click the links in the sidebar to go to their own websites. 
[Krumo](http://krumo.sourceforge.net/) for me; same question
You may think to order by upvote/downvote difference, but you will get a "static" list where the most voted posts will stay forever on top, and new posts will be read only by the people reading /r/new. AFAIK reddit orders every list of posts by a sort of "reddit time" . The "time" of a post is its "time of publish" plus or minus a value based on up/down votes. Each upvote to a post "adds" time, pushing its time a little into the future; every downvote pushes its time into the past. So, for example, if we count each vote as ten seconds, a post published at 09:00:00 with 20 upvotes and 2 downvotes will have a "reddit time" of 09:03:00 (as it will have 18 votes, so 180 seconds=3 minutes) , and it will be listed before a post published at 09:02:00 with no votes, but after a newer post published at 09:10:00 with no votes. It is an elegant way to show the most voted content and also to give an opportunity to new content. Of course, it is not so simple to choose the right amount of seconds to add for each vote...
Agreed. On any server the only files/apps I'm adding to the file system touch /var/www/* and /var/server/ (for any server utility scripts/files/etc.). Thinking about this more - maybe a change to /srv/http/* and /usr/server/* could be a nice change up. 
Because people are too uneducated in most cases, and the software doesn't hold their hand the entire way. In almost every case I've helped people with regarding xdebug and remote debugging, they set everything up and then can't figure out how to make it work because they can't figure out firewalls. Especially on the Linux side. In their defense, IPTables isn't exactly the most user friendly or intuative software in existence. I can't stress enough how much xdebug remote debugging is superior to things like VarDumper in every way.
Really I'd have to override every method in the decorator but that's easy enough. Thanks.
cool site, bookmarked.
I found this library was better for poorly written html DOMDocument choked on. http://simplehtmldom.sourceforge.net/
&gt; What packages are these? Everything. Well... anything. You might decide you need nice date formatting. So instead of writing a big class that formats dates in various ways, or calculates out the time remaining, you instead grab Carbon, add it to your composer, install and you're done. Using a package like that instead of making your own means you have a tested, well used system that's pretty much free of bugs. You can get straight to using it, instead of implementing it. You could do the same thing with encryption, or string formatting, or logging or templating or testing. In fact, these last three are among the most popular items on Packagist. &gt; Why do I need them? Because it's that or you write your own encryption library. Please don't write your own encryption library. &gt; How do I know I need them? Because you know. You have a requirement. "I should totally support markdown in this application, so people can write more interesting stuff." Now you have the choice of writing a markdown parser, which is surprisingly difficult, or just searching for "markdown" on packagist and finding the one that looks best. Use CommonMark, by the way, or /u/philsturgeon will come for you in the night. True story. I've lost friends that way. &gt; Where do I find them? If my understanding is correct, [Packagist](https://packagist.org/) is basically a search frontend to keep them together, and they're actually on github. This is a very good thing.
It's worth pointing out that /{id}/delete can cause problems of its own. Because it's just a url anyone who navigates there will trigger the delete action. There are famous stories of people who wrote admin interfaces that got visited by search engines and the spiders went through obediently following all the delete links.... Using the DELETE verb is RESTful, which is a good thing. 
Sure. It's better now than it's ever been, and has a very bright future.
As one of the Krumo developers... thank you.
Obligatory post for [Krumo](https://github.com/oodle/krumo) which does something very similar.
Xdebug is a huge performance drain. Some of the less optimized parts of our code base take a 5-10 seconds longer to rub when debugging with a large data set. Not a huge issue, but annoying none the less. 
Is the 5-10 seconds significant compared to your standard rub?
I religiously read this sub once a day to get my fix.
Yeah. Goes for ~5 Seconds to 10-15. 
i think they opensourced it (sometime?) ago, about when they started using magnet links and the entire collection of torrents they had could be squeezed into a few megs. Edit: found when they first starting doing this http://torrentfreak.com/download-a-copy-of-the-pirate-bay-its-only-90-mb-120209/
Try double-bagging it. 
What about it is that much of an eyesore? I'm actually surprised with how well it's done - I was expecting wordpress 2.0.
Written in Yii, that's a surprise.
As the author noted in the article, the issue exists for any parsing function in PHP that uses the PHP array hashtable implementation. Json_decode isn't the only vector for the attack. I suppose you could introduce a time limit for parse operations that are vulnerable, but that would be kind of crap.
It looks a bit painful to install. Where's the composer?
im curious of this persons answer...been 2 hours no response
Oh you poor soul. You should warn them that 5.2 leaves them open to being hacked. Maybe they'll listen. Use buzzwords like "cybercriminals".
Great post. Look forward to more articles like this as PHP 7 development moves along. 
"Hopefully I was able to provide you some insight into the internals of PHP 7 hashtables. Maybe Iâ€™ll write a followup article focusing on zvals. Iâ€™ve already touched on some of the difference in this post, but thereâ€™s a lot more to be said on the topic." Yes please :)
Also countries for international growth :) 
This makes me smile :)
Someone that can't read it :-/
The NVD description says this only affects PHP 5.2.X? How was this fixed in 5.3?
shell_exec('ffmpeg');
Too bad I can only give you one upvote. :-P
I want to run it on the server. (not in browser) Is there a way to execute a program as in windows (double-clicking it), or via command line is the only way? Also, connecting through putty doesn't seem to work.
Yeah, I'd agree with that, although I'd say it went hand-in-hand with DOM manipulation (Sizzle is all about selection) Sizzle wasn't part of jQuery until around 1.3 and was a kinda good-will gesture to other JS libs.
It's common for some monolithic applications (like Drupal) to do what you're suggesting, but it's rare for libraries to do this. The main reason is that while applications are generally expected to be turn-key, libraries are usually incorporated into a larger whole that has its own dependency chain. Consider this scenario: I like your library and want to include it in my project. Your library has a dependency on FooLib 1.0. My project also depends on FooLib 1.0 for other things in addition to your library. You package FooLib 1.0.3 in your library, but I want to use FooLib 1.0.5. I can't do that unless I modify your package, which makes using your library a pain in ass to maintain as a dependency. If you want to offer a complete package, consider having a separate build stage that compiles all of your dependencies together just before release. This has two benefits: - You're not committing a bunch of code you don't personally maintain to your repo which makes it much easier to update dependencies during the development of your library. - You can offer a "minimal" package that does not pre-package all the dependencies and allows others to handle the dependency management however they need to. Beyond all that, you need to make sure your library's license is compatible with the licenses of the dependencies you are prepackaging. Because it's not your code, the rights of the dependency authors kick in as soon as you attempt to distribute their code, even as part of your larger package.
I looked closer at the NVD, I'm not sure wether this is the correct NVD because they are talking about a segfault error not a complexity attack. Also when I tested the scripts it worked for 5.3.
May i ask what your list of RSS feeds is?
Thank you very much. I'll start following them right away.
No RSS to aggregate the aggregator? 
Thank you for your work. I'll keep an eye out on it.
Thanks, didn't know that! That should make it!
Hence my point, if a $5 a month Digital Ocean instance is too much for a client to spend on hosting then they're not worth my time.
Please go read about single point of failure.
I still don't understand why hashtables get any attention. Why would you want an indexing alias?
IIRC Popcorn Time was forced to move off github due to multiple takedown notices.
Look mom! 14 people [agree with me](https://www.reddit.com/r/PHP/comments/2q2t1q/no_more_var_dump_introducing_symfony_vardumper/cn2csg0) and prefer a real debugger. 
Uhh... you're hiring... Lol, I feel totally dumb right now. Sorry for wasting your time. Next time I'll think twice before making any "valuable-contribution" to the discussion ;).
Firstly, I couldn't run your example as is because I don't have the BC extension installed, so I switched bcmod() with % and bcdiv() with / and used that as my base benchmark. I realise that might already be a huge improvement because I believe functions have a considerable overhead in PHP. Anyway, I came up with this: function regFactor($n) { $array = [1, $n]; $max = sqrt($n) - 1; $x = 1; while ($x &lt;= $max) { $n % ++$x || ($array[] = $x) &amp;&amp; $array[] = $n / $x; } return $array; } My benchmarking shows it's 4 times faster than my modified version of your base. I'd be keen to see how it compares to the real base. Some things to note: * I'm initialising $array with 1 and $n so that I can start the loop from 2. * I'm storing the result of sqrt() rather than calculating it each time. * I combined the $x incrementing, if() check and appending to the array all into one statement. * ++$x is faster than $x++, but ++$x will return the value after incrementing. Because I want my loop to start processing with 2, I initialise $x to 1 and subtract 1 from $max. I also experimented with the following ideas but abandoned them: * Building a comma separated string and exploding at the end. * Using array_push($array, $x, $n / $x). * Using pow($n, 0.5) instead of sqrt($n).
I guess it's just not worth mentioning in this context. If you use suexec to run PHP on a server you are in control you did something wrong. 
What's currently preventing PHP from using different internal implementations for contiguous integer-keyed arrays, and string-keyed (or mixed-keyed) arrays?
I like to think of it as the Laravel of its day. Had some good times coding with Yii and I'd probably give Yii 2.0 a lookin based on the quality of the project.
Agreed. I still use it in my day job, it's a bit dated but still solid.
&gt; pretty standard way to get all prime factors of a number, although your program doesn't work correctly just from glancing at the code. Well it does run and produce the correct result. So you must be mistaken!
sexy php scripts in ur area, click here now!
Uh, I never got to understand this and I'm the author of Kint :D Verbal Kint is a chartacter in The Usual Suspects, correct? Time to watch it I guess :) In actuality "kint" is the first part of the word for "variable" in my native language and I wanted a non-existing short word :)
Not for this subreddit/spam. 
What about using security to restrict delete to authenticated users?
PHP 7 is already using a (slightly) different implementation for reasonably dense integer-indexed arrays with increasing key order. Those do not use collision lists, so they are exempt from this issue. However not all integer-indexed arrays fall under that category. I don't worry much about slowing down the "not reasonably dense" category, but the "with increasing key order" requirement could be a problem. It can easily happen if your arrays aren't just a result of append operations. But that issue can maybe also be solved with some effort...
That thread really rustled my jimmies. CI3 (which is not even released yet) will support 5.2! 
Awesome, thank you. I will definitely use Canvas-- the last thing I need is another headache! = )
It's such a turd I'm not sure why anyone would want it. If a torrent site is what you want, you could almost certainly do better building your own.
Thanks for letting me know! The last thing I want to do is get going with a new tool and think it's ME messing up! = )
What if you are one company hosting four of your own sites? Then you'd spend $20 a month vs $5 a month for hosting. The decision seems clear: Do proper system administration and put multiple sites on one box until you need to split them up for some reason. Nothing is wrong with multiple sites to a box, it simply requires someone who actually cares to know their system to put things in place. If you don't care, it won't end well.
There are numerous SPOFs within an application architecture. This one is hardly worth worrying about. You can solve this case by having multiple boxes that sync files across and then load balance requests. This would still allow multiple home directories, users, and sites to be served from the same set of systems. Still cheaper and more efficient then buying one box per site and still having them all as a SPOF for each given site.
Well, "using security" is pretty vague. The example in question actually DID "use security". They had an auth check on there, checking for a valid login/session, etc. If it wasn't found they did a header redirect to a login page. Fun thing? **Nothing is actually required to obey a header redirect.** The spiders didn't. They just ignored it. Had a `die()` command followed the header function, there would be no problem. But instead the application just spat out its list of resources, safe in the knowledge that anyone who got this far would be authenticated. The spiders then followed the links, as they do. It's easy to say you wouldn't make the same mistake, but... 
Also, the information is wrong and dumb
Because PHP arrays are hashtables.
This question should be posted in /r/phphelp Anyway, you made a typo, it should be finfo() NOT Finfo() e.g $fileInfo = new finfo(FILEINFO_MIME_TYPE); [finfo_open](http://php.net/manual/en/function.finfo-open.php)
&gt; It's quite simply two vhosts, only one of which can exec requested PHP scripts and has file system permissions to write files into the other. And exactly that is the problem. Why is that exactly a problem I will leave you to figure out, as an exercise, because I don't want to lose you again. :)
I'd also humbly submit PHPDeveloper.org as another source of (curated) news happening in the community. Each post is written, not automatically aggregated: [http://phpdeveloper.org](http://phpdeveloper.org), [@phpdeveloper](http://twitter.com/phpdeveloper)
That's a copy of thepiratebay's data, not its source code.
The future... Today! dev@aerilon ~/dev $ php --version PHP 5.5.20-pl0-gentoo (cli) (built: Dec 22 2014 13:44:21) dev@aerilon ~/dev $ hhvm --version HipHop VM 3.5.0-dev (rel) dev@aerilon ~/dev $ php memusage.php 13.97 MBs [14649088 bytes] dev@aerilon ~/dev $ hhvm memusage.php 2 MBs [2097152 bytes] DEMO: http://www.hhvm.rocks/memory_usage.php
Unfortunately that means lots of other people write otherwise good libraries but with API and documentation dependent on or heavil favoring those silly annotations :/
The example about the product repository was good, but calling the cache storage a "repository" I think is a bit odd and out of place here. Really, all you've done is define a generic interface for accessing a cache layer.
Hey, unfair, you should compare with 5.6. 5.5 is old.
To get proper user separation, it's necessary. If only one site, sure, at this point permissions are controlled. I've seen many times people installing things like WordPress alongside their one site because now they want a blog too. A few months later they are serving up malware across all sites because WordPress wasn't maintained and lack of user separation. The more sites served from a single user, the worse it gets. Not everyone has the luxury of a server per site. In the context of the misguided configurations throughout the thread, suexec should be mentioned. 
If you want to run it on the server, it's pretty much command line only. The graphical way would be via the browser, as PHP is a web language. There are ways to make actual executables from PHP, but that is a very large scope and it's not overly-well defined. 
It depends what you are currently using it for. If it's shampoo, then yes. Keep going!
Same script, PHP 5.6.4 on Windows: C:\Users\theodorejb\Documents\Code\test&gt;php --version PHP 5.6.4 (cli) (built: Dec 17 2014 13:20:35) C:\Users\theodorejb\Documents\Code\test&gt;php memusage.php 8.13 MBs [8524560 bytes]
Yay, it's not quite as bad.
I think what phpdevster is saying is you should just have a CacheInterface and depend on that. It doesn't need to be a repository to have an interface. A CacheRepository would be a repository for all of your caches, not a key value store for your cached items.
To be fair, that data is more important than its source code. Anyone can slap together a pretty basic torrent browser with *FAR* better UX than the Pirate Bay (seriously, I never know whether I'm going to click on an add, or an actual download link) using just about any tool.
reminds me a lot of my little project https://github.com/bkdotcom/PHPDebugConsole http://www.bradkent.com/?page=php/debug which is basically a port of the [javascript/web console api](https://developer.mozilla.org/en-US/docs/Web/API/Console) can currently output as html or via firephp Cool new feature coming for v1.3
Out of curiosity, why aren't you a fan of composer?
Really enjoyed your thoughts. I don't believe create, get, save, destroy and make are required to be in a Repo though. That would just add unnecessary methods in many cases. I think this is just one of the flavors of how to apply the Repository pattern. One that I haven't seen, but I do like. It would be especially effective for larger applications. In small modules I think it would be overkill to create a repository in this way. Thanks for sharing though it was really neat, and like I said I can definitely see this kind of application coming in handy.
Yes please. I'm very interested in learning about the implementation of PHP. Does anybody have some more good resources?
Lots of people actually provide the use of both annotations, and an alternative. Not really as big of a deal as you are making it out to be. Nor is the problem really.
Don't over think it. Start simple. Most frameworks can appear complex because they (deliberately) introduce a set structure. Consider the following simple example then work out how the framework you are looking at implements it. 1) The controller "manages" your code. 2) The models "map" to your data sources. 3) The view displays the result. So an example: The controller receives an input from a user, a request via a form for a record for example. The controller loads a model that goes and fetches the record and passes it back to the controller. The controller then passes it to the view that then echoes it to the screen (or produces whatever output is required). Essentially (in a very simple nutshell) that is all that is happening.
My short answer is Models - Interact with, access, and process your data in discreet chunks. The idea being that you can build functions into your models that can be used over and over again throughout your application. Say you have a website that let's you create a sales quote. You can have a quotes model with methods to do the heavy lifting related to the quotes. Models basically take requests, process them, and spit back responses in predictable ways. For instance, you could have a method in a model that only does sales tax calculation. Controllers - These are classes that take requests from the user send it to the appropriate models. They then take the information returned from the models and pass a view (or views). The result is sent to the user. Views - These take the information (like an array or object) passed from a controller and dump it into it's final presentation (like an html layout). Requests go: User &gt; (makes request of controller) Controller &gt; (takes the request, and sends it to model(s) ) Models &gt; (do stuff, pull from a database, process things, and return response) Controller &gt; (takes model's response, sends it to view for a layout ) Views &gt; (lays out the data send from the controller, and sends the layout back) Controller &gt; (sends the layout back to the user) Frameworks make all of this way, way easier than doing it yourself by starting you off with a model/view/controller architecture that is ready to go. Plus, they have a lot of functionality already built in that you would otherwise have to build and maintain yourself. Plus, they give everyone a common understanding of how things work in your project -- which you might not care about now, but if someone else ever has to work on it they'll be much better off. And the MVC architecture forced you to break your application into little logical bits so that when you later have to update things you can just update the way a particular function in a model works, rather than have to dig through everything to find what needs to change. Others, feel free to correct me. 
There's a ninja first-level domain?
https://www.godaddy.com/tlds/ninja
I would say MVC is about breaking your code out into logical groups. Those three groups, are Model, View, and Controller. Often times people explain each of these, words but I assume you've seen those explanations before, so lets jump into the code. Here's a classic 90's php blog homepage. &lt;?php require __DIR__ . '/../bootstrap.php'; ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to my blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php $articles = DB::getInstance()-&gt;query('SELECT * FROM posts where published=1 ORDER BY publish_date desc LIMIT 20'); ?&gt; &lt;?php foreach($articles as $article) ?&gt; &lt;?php $author = DB::getInstance()-&gt;queryOne('SELECT * FROM users WHERE id = ' . $article['author_id']); ?&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;&lt;?= $article['title'] ?&gt;&lt;/h1&gt; &lt;h3&gt;Posted by &lt;a href="/profile.php?id=&lt;?= $author['id'] ?&gt;"&gt;&lt;?= $author['name'] ?&gt;&lt;/a&gt;&lt;/h3&gt; &lt;/header&gt; &lt;p&gt;&lt;?= $article['body'] ?&gt;&lt;/p&gt; &lt;/article&gt; &lt;?php endforeach; ?&gt; &lt;/body&gt; &lt;/html&gt; There's some bootstrapping happening with require bootstrap.php, this is setting up your application to handle the request. Then immediately we start displaying some the HTML. Then we do some database lookups interspersed with more HTML. If we break this out into 3 different parts, we have bootstrapping, database look ups, and html. We'll ignore bootstrapping since that's more of a FrontController concern. That means the page is doing 2 things, generating HTML and issuing some database queries. From an Web MVC perspective the HTML is the "view", so lets create some kind of separation here between our Database Queries and our View. &lt;?php require __DIR__ . '/../bootstrap.php'; $articles = DB::getInstance()-&gt;query('SELECT * FROM posts where published=1 ORDER BY publish_date desc LIMIT 20'); foreach($articles as $index =&gt; $article) { $author = DB::getInstance()-&gt;queryOne('SELECT * FROM users WHERE id = ' . $article['author_id']); $articles[$index]['author'] = $author; } ?&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to my blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php foreach($articles as $article) ?&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;&lt;?= $article['title'] ?&gt;&lt;/h1&gt; &lt;h3&gt;Posted by &lt;a href="/profile.php?id=&lt;?= $article['author']['id'] ?&gt;"&gt;&lt;?= $article['author']['name'] ?&gt;&lt;/a&gt;&lt;/h3&gt; &lt;/header&gt; &lt;p&gt;&lt;?= $article['body'] ?&gt;&lt;/p&gt; &lt;/article&gt; &lt;?php endforeach; ?&gt; &lt;/body&gt; &lt;/html&gt; This should show the logical divide between View and other portions of your code base. From here, we'd break the &lt;?php block at the top of the file into it's own class called a controller, maybe `HomepageController.php`, which could look something like this. &lt;?php class HomeController { public function get() { $articles = DB::getInstance()-&gt;query('SELECT * FROM posts where published=1 ORDER BY publish_date desc LIMIT 20'); foreach($articles as $index =&gt; $article) { $author = DB::getInstance()-&gt;queryOne('SELECT * FROM users WHERE id = ' . $article['author_id']); $articles[$index]['author'] = $author; } return ['homepage.tpl', ['articles' =&gt; $articles]]; } } In the controller, we're returning a template name, 'homepage.tpl', as well as data to assign into the template. The important part here is that we've separated the view layer(HTML) away from the rest of our code. Now you're probably wondering what about Models. I'd say models are a bit more tricky to define, so we'll just go extremely basic and let purists argue about it. The Model portion will be broken out of our controller code. So if you look at what our controller does, it's two things. It retrieves data from the database(SQL Queries) and then prepares it for the view(Matching authors with their blog post). Again you'll see two distinct portions of code, that we can rewrite to look something like this, though maybe not the most sane. public function get() { $articles = DB::getInstance()-&gt;query('SELECT * FROM posts where published=1 ORDER BY publish_date desc LIMIT 20'); $author_ids = array_column($articles, 'author_id'); // Assume this returns a map where the array offset is the primary key of the value. $authors = DB::getInstance()-&gt;queryMap('SELECT * FROM users WHERE in (' . implode(',', $author_ids) . ')'); foreach($articles as $index =&gt; $article) { $articles[$index]['author'] = $authors[$article_id]; } return ['homepage.tpl', ['articles' =&gt; $articles]]; } Once again, we've created some division between our two portions code, which we could break out even further into 2 model classes. class User { public function getByIds(array $ids) { return DB::getInstance()-&gt;queryMap('SELECT * FROM users WHERE in (' . implode(',', $ids) . ')'); } } class Post { public function getRecentPublishedPosts($limit) { return DB::getInstance()-&gt;query('SELECT * FROM posts where published=1 ORDER BY publish_date desc LIMIT ' . $limit); } } With those two classes comprising our model layer, we can update our Controller to be this public function get() { $articles = Post::getRecentPublishedPosts(20); $authors = User::getByIds(array_column($articles, 'author_id')) foreach($articles as $index =&gt; $article) { $articles[$index]['author'] = $authors[$article_id]; } return ['homepage.tpl', ['articles' =&gt; $articles]]; } And if we look at all four of our files, they'll look something like this: &lt;?php // file: controller/HomeController.php class HomeController { public function get() { $articles = Post::getRecentPublishedPosts(20); $authors = User::getByIds(array_column($articles, 'author_id')) foreach($articles as $index =&gt; $article) { $articles[$index]['author'] = $authors[$article_id]; } return ['homepage.tpl', ['articles' =&gt; $articles]]; } } // file: model/User.php class User { public function getByIds(array $ids) { return DB::getInstance()-&gt;queryMap('SELECT * FROM users WHERE in (' . implode(',', $ids) . ')'); } } // file: model/Post.php class Post { public function getRecentPublishedPosts($limit) { return DB::getInstance()-&gt;query('SELECT * FROM posts where published=1 ORDER BY publish_date desc LIMIT ' . $limit); } } // views/homepage.tpl &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to my blog&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;?php foreach($articles as $article) ?&gt; &lt;article&gt; &lt;header&gt; &lt;h1&gt;&lt;?= $article['title'] ?&gt;&lt;/h1&gt; &lt;h3&gt;Posted by &lt;a href="/profile.php?id=&lt;?= $article['author']['id'] ?&gt;"&gt;&lt;?= $article['author']['name'] ?&gt;&lt;/a&gt;&lt;/h3&gt; &lt;/header&gt; &lt;p&gt;&lt;?= $article['body'] ?&gt;&lt;/p&gt; &lt;/article&gt; &lt;?php endforeach; ?&gt; &lt;/body&gt; &lt;/html&gt; This is obviously missing glue that ties the incoming request to the controller execution and controller result to the view rendering, but I believe those are left up to implementation and aren't specific to the understanding of this extremely basic MVC. The code and comments above are not meant to be a strict definition or realistic implementation of the MVC pattern. Their designed to show the transition a developer could make from an old fashion php page to a mvc application. Separation of concerns ends up being an extremely important part of programming. Keeping your code small and modular helps other developers or even you 6 months later understand what is going on. This separation also becomes important when you want to make modifications to your database. Lets assume that you've decided blog posts have more than 2 states, published and unpublished. It can have pending review, published, deleted, unpublished. You've decided to drop the `published` column from your posts table and use a `status` column. With our separation of concerns it should be easier to find all the times you had queried the posts table, rather than having to search through piles and piles of HTML and php and sql jumbled together. 
Alright, so for a very basic real world model. User is attempting to login. He posts the form which sends the data to the controller. The controller know what model to call on, so it sends the model the users login details to confirm they're correct. The model will then call the database to confirm the details are correct, then send the answer back to the controller. The controller then gives the okay to the view which uses the users data returned by the model to say "Thanks for logging in, {user}! You will be redirected in 5 minutes." or something like that. To confirm, the view would call the corresponding template file correct? It would call the template, then the view would inject the message into the template, and spit out the resulting page with the message. Is this correct, or am I missing something? I have Laravel on my computer just sitting around, I might check it out and see what I can gleam from it as well. I'm a more hands on person anyway.
Holy shit, I want to give you a hug. You cleared everything up. I thought the view file was just another class that called a 4th file to output content. I didn't know the controller called the view which had the content. You cleared everything up completely. This actually makes a lot of sense, and it looks SO much better and easier to work with than any of the shit system I have now. For the models, will they ever be doing anything else other than grabbing data from a database? Would this be a good correlation for MVC? Controller &gt; Logic Model &gt; Data View &gt; Presentation
I see what you're saying, and that makes sense. I think my best option is to refactor away my dependency (it's only Carbon) and keep my package slim so I don't worry about these issues. 
So I think the idea is there is now an added layer of abstraction using read() and write() so the database could be swapped out for something else, right? But what about search queries? Aren't searches still done in a way that's dependent on the database anyway?
You have the basic idea yes. However, the database is abstracted away to a Repository that tells us about the data we can access through it. Such as interface ProductRepo { public function getProductName($sku); } The benefit of this is we know nothing about the database, but we still have access to what we need.
as someone else said, just because they want it doesn't mean you should give it to them. What if they asked for plaintext passwords?
I'm sorry, i meant utilizing symfony's security configuration to deny access to the method unless the user is authenticated with the correct role. Interesting to know about the headers though.
It was done before. The explanation is included for the benefit of readers who do not who what a hashtable mask is.
Doesn't even have to be that. That's more appropriate if you are abstracting something behind another actual object. In this case, your `Memcache` class can just implement the `Cache` interface, then you can depend on that interface in the consumers and you can be done with it. Not every object in your system has to be classified as some sort of pattern :) Just rename `CacheRepoInterface` to `CacheInterface` and everything else stays the same. Most of the advantages you talk about are the advantages of programming to an interface, and not really specific to the repository pattern :)
That's not an accident. 
I'm not the author of the parent comment, but perhaps I can answer your questions. The Model "layer" in your MVC application is for modeling data and the business logic around that data. It does not need to be directly coupled to database access, though in many implementations of MVC the most common models you'll encounter are those that are trying to model rows and relationships in a database. A few other common things that you can model are forms, http requests, http responses, and sessions. If you can think of a discrete piece of data, especially if there are discrete actions you can perform on that data, then you can almost certainly model it. If your reaction to that paragraph was "but 'data' and 'actions on that data' seems to describe most of my application", then you are probably understanding MVC more than most people did when they started using it. Your model layer is the core of your entire application. It's where the vast majority of business logic should be. The Controller "layer" in your MVC should be as light as possible, and it is essentially just the glue between your Model layer and your View layer. It "controls" the flow of data between your models and your views. In the example MVC setup from the original comment, the controller knows about the view that needs to be rendered and is responsible for making the relevant models of data accessible to that view.
I didn't meant it was wrong to do user separation. The problem with suexec is performance, bcz it's CGI only and I avoid running PHP like this at all costs. You can do user separation with the builtin FCGI process manager (FPM) for example, where you can have multiple pools with different users.
Yup
I'm pretty sure calling it by the class name and calling self are equivalent within the class. Basically, any protected static call within the class is going to bypass the __callStatic if the function exists. You could try using an anonymous function to get out of the scope of the class.
&gt; But using the class name should treat the calls as an attempt to call a method publicly This isn't true. Privacy is at the class level, not the object level. Eg: http://3v4l.org/JGa8L
You've pretty much described the options already. It doesn't make sense to directly seed a number generator using a string, but you can come up with your own systems of converting something to an integer. If you want something that does go all the way across the integer spectrum: * Get the SHA256 of the string in hex * Trim to only the first eight characters * Convert that to a 32-bit hex integer You are aware mt_rand is not a strong source of randomness regardless of how it's seeded?
There ARE situations where you might want to seed based on a string. Such as creating a random set of events for a given username. Or postal code. Etc. But as you mentioned, converting the string to an integer is the solution. Another idea... for short strings, convert each letter to a 2 digit integer then concat them together. So "cat" becomes 030120. But your solution would depend on the length of the strings and if you want to avoid collisions at all costs.
MVC when done RIGHT, also maximizes the ability to reuse chunks of code by splitting code in spots that isolate what is being done. If many of your projects are MVC you'll find yourself thinking hmm... I've done something like this before .... ah ha and view which creates the exact style of screen I want. Make some tweaks and done. MVC in my opinion becomes more and more useful the more your library of complete projects grows.
This is correct behavior - if you were to call a non-existent method, or say a private method defined in a parent class from the child then it should call the magic methods - but they are only called when the method doesn't exist or is not accessible *from the current scope*
I agree conceptually, but not pragmatically. Requiring `n` roundtrips to your database to construct an object graph with `n` different entity types is a pretty unacceptable performance hit, IMHO.
Read this earlier today; implemented it in Python to search multiple services at once tonight. Thanks for posting
What do you mean? Honest question by the way, how do you do it? Also I suspect I'm calling things repositories when they are really just table gateways or some other label. What I call "Managers" (which is not great either) is probably closer to the traditional definition of a repository, I generally inject managers into my controllers and things as needed, not repositories.
Thanks for your inputs, I just sat down and tried to make changed to my framework, but couldn't really grasp the idea behind the fact, why my config or view files should not a directory that is autolodable, as in where my controllers and models are found
Right, the repo pattern is just one way to achieve LSP. I am actually abstracting behind another object though so I believe the gateway pattern would be the correct way. You can't apply the interface Cache to the proprietary Memcache object. So you need another layer between the two. If I'm understanding you correctly that is.
The ELI5 Version I have actually used in a job interview and got an offer from: You ever see the movie Office Space? Think of the Controller as the "I'VE GOT PEOPLE SKILLS DAMMIT" guy. He said that his entire job was to bring the requirements from the customers to the engineers. In our case, not only does he bring requirements from the customers (The View) to the Engineers (The Model), he actually brings feedback from the model to the view, and the view reflects the new information.
json_decode is a very prominent vector though, and almost certainly the most common. It is very common to accept json as input and parse it using json_decode
Look up Domain Driven Design. Value Objects are a big part of DDD and are almost exactly what you're describing :)
This is pretty accurate, yes. I would honestly recommend just writing your own simple MVC if that's the concept you really want to learn. If you dive into Laravel you will spend most of your time learning Laravel rather than the MVC pattern. Here's a PHPAcademy video tutorial for making one: https://www.youtube.com/playlist?list=PLfdtiltiRHWGXVHXX09fxXDi-DqInchFD
I am neither stressed, nor dealing with it. I am making sure everyone knows what a joker this guy is, just in case somebody almost accidentally takes him seriously. :)
Suexec with fast CGI is nothing new. Yes, the classic method is CGI but most people use suexec+fcgi these days. See http://httpd.apache.org/mod_fcgid/mod/mod_fcgid.html#fcgidwrapper (a good place to start is with the fcgi wrapper if you're not familiar). The pools you describe is an alternative method but can be more complex in certain scenarios where the suexec method simplifies and contains with the same benefits.
I think that "no silver bullet" applies here. In some cases, repositories make sense, in others they don't. Obviously both can coexist just fine. I do agree with what you propose and I have had cases where I needed to join a bunch of tables with complex conditions and your solution was similar to mine. However, majority of my use cases would work just fine with simple crud interfaces. 
Yes.
=== true
i REALLY like the websiteâ€¦ its pretty.
This is a fantastic answer. Kudos to you for taking the time.
Creating objects in PHP is cheap. Do it! Not all objects need to have logic, they can be used for simple transport, or when it makes more sense than using a simple primitive because they're a core concept of your domain. I recommend looking at the Command Bus Architecture. It seems to me you'd benefit from using simple data transfer objects that you'd pass from one handler to another. * https://laracasts.com/series/commands-and-domain-events/episodes/1
You just discovered OOP, the point of classes/objects is tying data and behavior together.
I didn't know you can pair these two up - thanks, my bad!
r/PHPhelp
Doesn't feel right but it's interesting. Never knew that.
There is also http://24pullrequests.com which is a good source.
I highly recommend taking a look at https://laracasts.com/ It will make you a better developer even if you aren't into using laravel. Lots of general php lessons on there.
go back to nerd land u weirdo!!
I realized, I developed something similar like this, even though it was no where near as good. I had a folder with 1 file that controlled what was displayed. Then 1 file that grabbed stuff from the database, another that handled most of the logic and processing, then 1 that displayed the HTML. So I was pretty close to it without even meaning to be, haha. 
This is why MVC is called a user interface "pattern." You end up doing very similar things over and over. The term "MVC" formalizes a description of those things, and gives us a common vocabulary word to use when talking with each other. As a side note, you mentioned ADR earlier. There's a point at which you will realize that your vVew is not merely your templated HTML code, but the entirety of the HTTP response. This realization will occur at about the same time you start wondering where to set HTTP headers. That's the point at which you will begin to see the use of [Action-Domain-Responder](http://pmjones.github.io/adr) as a refinement of "MVC". 
Good to know you aren't stressed. Having people throw lawyers at you tends to do that (whether they have any kind of a case foundation or not.) Keep up the awesome work dude and Merry Christmas.
Your Domain/Business don't necessarily need to know how those things are stored in the database. Say you start with two classes `User` and `Address`, like so: class User { protected $name; protected $billingAddress; // instance of Address protected $shippingAddress; // instance of Address } class Address { protected $street, $city, $country, etc; } As you can guess by now, you can re-use the "same" address for both billing and shipping . When comes to persistence, then you can choose wether to normalize. Using a good ORM makes it easier, eg: http://doctrine-orm.readthedocs.org/en/latest/tutorials/embeddables.html
Awesome, glad it helped!
Merry Christmas!
I recently started using a lot of value objects in a domain-driven application, and I'm loving it. I'd absolutely recommend it! Also note, while DDD and value objects are good friends, your app doesn't have to be domain-driven to benefit from VOs.
As a hint, there's equations for both parts of this Euler problem. Though, just about everybody who doesn't know about them does the loop method you have. Inefficient, yeah. Stupidly, nah. Unless you were gonna find the difference for a really big number. Edit: As an aside, does anyone know if PHP has list comprehensions? I know list/array literals finally got added but did they get any of the bells and whistles that languages like Python or Haskell provide? 
&gt;Technical debt is going to be there and grow at any company you work for. It doesn't have to grow though. If the culture of the place appreciates the value of paying off tech debt early, it can be dealt with. If you use TDD and understand it properly then you can actually improve the code base over time instead of watching things rot. And I disagree that it's a bad thing to complain about bad code - in the right culture, that can be a good thing. If **all** you do is complain, then yeah, that's gonna get annoying fast, but if you mention your gripes and raise them as a concern, then go about fixing the problem then I'm all for it. I moan about bad code all the time, but I usually end up improving it as I go along. It's a kind of productive annoyance, and it works.
Just a thought: Can't the Bittorrent protocol be updated so that all the magnets are stored as a single blockchain (as the BTC crypto-currency does), so that every Bittorrent client is a bay in itself and there will no longer be a need for pirate bay anymore!
not any native types. There's stuff that's closer to what you probably want in the spl like SplDoublyLinkedList
Just wanted to emphasize, +1-ing this because there is way too much emphasis in the community these days on patterns and classifying things. Sure this is a value object if you want to classify it, but like WishCow said this is just OOP. edit: But yeah, do this! Discovering these sorts of ideas on your own is great, your examples are really great opportunities to do what you're talking about. Don't need DDD to give an object some properties and methods.
I'll definitely read more about them. Couldn't find any quality content for PHP so far, so I guess I'll try to get Eric Evans' book. 
Sony does not run 5.2
Without knowing the equations I ended up with this: &lt;?php function square($value) { return pow($value, 2); } /** * Use array_fill to provide a array with the length we desire. * * Grab the keys of returned array for our number set. */ $numbers = array_keys(array_fill(1, 100, NULL)); $sum_of_squares = array_sum(array_map('square', $numbers)); $square_of_sums = square(array_sum($numbers)); echo $sum_of_squares . "\n\n"; echo $square_of_sums . "\n\n"; echo ($square_of_sums - $sum_of_squares) . "\n\n"; While it technically removes the loop, it's actually probably less efficient. It's also a little more PHP specific as I'm not sure all the various array functions have translations to other language.
Sometimes step debugging is what you need to do, but sometimes a quick vardump is faster and easier, and serves a different purpose.
A RSS reader.
Yeah, HHVM has multiple internal array types which correspond to the new PHP array types Niki mentioned, including a "pure packed array" like he referenced as a possible future optimization for PHP. Great to see PHP getting these as well, and an awesome writeup on the structures involved and why they're better. :)
Hi! I wanna say thank you to all of you! I want to imeplement this and make it fit into my current code base quickly, so here's my final solution! implement the verification method in domain model // Article.php public function verifyOwnership(User $user) { if ($this-&gt;user_id != $user-&gt;id){ throw new Exception('Not article owener. Do not hack.'); } return true; } And call this method every time you want to make sure in the controller public function postUpdateArticle() { try { $article = Article::find(Input::get('id')); $article-&gt;verifyOwnership(Auth::user()); $article-&gt;updateContent(Input::get('content')); return Redirect::to('/article/' . $article-&gt;id); } catch (Exception $e) { throw $e; } } In this solution, the domain model totally trust the controller which call for the action would take care things related to ownership issues. I think this may not be a mature and perferct solution, since if you forget to call the verifyOwnership in some place, then there's a securify defect. But it work great for now in my project. :-)
I wouldn't venture a quality rank, but I've watched a few of IPC talks here https://www.youtube.com/user/PHPcon/videos 
If you go looking specifically for PHP talks they tend to focus on more entry-level stuff or introductions to new tools. While they can be great, my favourite talks tend to be more conceptual or language agnostic I'd recommend watching any video you can find from [Robert C Martin](https://www.google.co.uk/webhp?sourceid=chrome-instant&amp;ion=1&amp;espv=2&amp;ie=UTF-8#q=robert+c+martin&amp;tbm=vid) and all the Google Talks by [Misko Hevery](https://www.youtube.com/watch?v=4F72VULWFvc)
&gt; PayumBundle, which integrates Payum into Symfony I want to clarify here a bit more. It is an integration for Payum Library which supports many payments http://payum.org/doc/0.12/Core/supported-payments. It also provide bridges for jms payments and omnipay gateways. &gt;Edit - To make things even more confusing, it appears there is a bridge that lets you use Payum behind JMS's bundle. I did that to allow people reuse jms payment which Payum does not support natively, same goes for Omnipay Gateways too.
For debugging, step debugging is better than dumping contents of variables that, as you suspect, have wrong values. You are saying this most probably because you just can't use it properly. Step debugging not only can reveal context on each step but you can also change this context, it makes it much easier to debug something when you found one bug and you know that there can be others - so you fix this bug in your code without even stopping the process, you fix the wrong data in the debugger and step forward to see what goes next... It's much better for no cost.
It's got a new documentation site too: http://commonmark.thephpleague.com
Look into OOP and MVC or use a framework like Laravel which uses both, if you need a tutorial i can link you to some. 
That's overkill for a beginner.
Should stay out of frameworks until he doesn't have good php basics. Diving into frameworks very early can cause problems in the long run IMO.
If you want to start real simply, you can use GET variables. This is NOT something you should carry into quality code in the future, but it works when you're learning. http://example.com/index.php?action=value "action" is what is called a GET variable. It can be named anything really, but "action" is a pretty common convention. What comes after the equal sign after it is the value given to it. $action = $_GET['action']; -- would yield "value" in this example How do you use this for what you want? if($action == "home") { /* display home page*/ } which would be http://example.com/index.php?action=home if($action == "about") { /* display about page*/ } which would be http://example.com/index.php?action=about if($action == "contact") { /* display contact page*/ } and http://example.com/index.php?action=contact Include the header at the top of the script, then do your if statements to determine what page contents to output, then stick the footer at the bottom.
Thank you! I have been looking at this before but didn't know if it could do the task. Because I'm new to PHP I will try to use this approach rather than start learning a framework. I have a follow up question. Would it be preferable to store the content information in an array or is there another way?
What you're looking for is an URL parser and/or router. It parses the URL and uses it to dynamically generate a page. This approach requires your webhost program (Apache/nginx) to be configured correctly (i.e. tell the webhost to sent all requests to index.php but hide index.php in the URL itself), but is more common and user friendly than using GET parameters when dealing with mere pages. 
I suppose if you don't normally use an IDE that might be the case. But, in PHP Storm for instance firing up a debugger is literally two clicks. One for the break point, one on the debug button which launches your browser. It is bother faster and less complicated than typing a new line of code and then clicking to the browser. It is especially faster when that var you just dumped wasn't the problem after all.
Depends on how you're looking to output it. If you have a sort of common layout of things with just slightly different elements, then yeah an array can work. You could then construct a function that (after your if is run) outputs the $array["whateverkey"] with content.
Don't forget Dart. 
I am guessing you need an absolute beginners' starting point to web development. PHP may not be the thing you are looking for. I would suggest you get familiar with some HTML and then come back to PHP.
I'm wondering what might have changed since then (outdated advice?) 
Agree with deadman87 unless you can provide some context. If brand new I would suggest html &gt; css &gt; Java script 
Escaping is the good ways to go if you're not displaying HTML. The hard parts comes when you have to display html (for example, after converting user-submitted content with markdown) In that case, use a whitelist with HTMLPurifier. 
I'm tired. I've been getting downvotes before for stating that filtering is nonsense. Use stored procedures, use prepared statements, use escaping on output. Don't allow html output. That's it
Nothing. You still have to escape the data in accordance to the context it is used in. 
&gt;I've been getting downvotes before for stating that filtering is nonsense. Depends entirely on what definition you ascribe to 'filtering'. Filtering certainly isn't nonsense if it used to normalise data, for instance: 120,000 -&gt; 120000 
It's outdated, the `mysql_` functions are deprecated, PDO offers prepared statements which offer a higher level of security than what was available in the MySQL extension, `mysql_real_escape_string` and `mysql_escape_string`, for example.
Good stuff. Anything similar for organizing starred repos ?
On a lower Level. I wasn't talking about this kind of validation 
I know some data structure. I am just very bad with starting, and getting ready.
The top answer actually refers to `mysqli_real_escape_string` which isn't outdated/deprecated, and even though I prefer PDO myself, MySQLi does provide prepared statements as well.
Love the show, but a small suggestion: you should put descriptions on the episodes.
You should wipe the notion that just because it's your site, security isn't important off your mind. If you are handling users and their credentials, it's absolutely essential that you provide proper security. If your site gets hacked, it's not just your site that will be compromised, you'll be handing over the keys to your users' entire digital identity. So don't give me some bull about it not being important.
http://blog.ircmaxell.com/2013/05/development-by-numbers-slides.html Athony's Development By The Number. Saw it when he was speaking at Sunshine PHP. It was very insightful and mentioned a lot of great techniques to help point out possible maintainability issues, code quality issues, etc.
Your first option is pretty common now a days (think mobile apps). Probably the safest and cleanest way at this point of your code.
I have a security guy who manages my security, but we have a notice explaining to use diffrent usernames then normal because of insecure site.
We normally do. This was another weak episode because I was lost and homeless and distracted. Now that im not living out of a backpack we're gonna get this shit back on track. Hit that URL for a link to the EP on the 28th. It should be awesome.
19 files, 3 folders to add colours to your cli. At some point (and this is not a direct criticism of this project) I think 'we' need to stop the bloat.
weh
Neat, league packages are nice to work with
Cheers buddy!
Stumbled upon this the other day and thought it was great and super simple to use
10 of those files are licensing, readme, changelog or testing info. 2 are examples, 1 is actual unit tests.
Well tested code is 'bloated' now?
19 files and 3 folders *would* be bloat if the source wasn't actually 4 files and if composer didn't handle the file-pushing for you :)
there's already a good PHP CLI library out there: https://github.com/thephpleague/climate
I can not agree with this: it depends on the circumstances. In the backoffice of a website I allow it, because our users do want to add some kind of formatting to their texts. And in some cases even some javascript. In this case I do need HTML output. On the other hand, it's terrible to allow a front user to enter some code which reproduces HTML-output. Input used for queries must always be escaped.
This isn't a PHP specific talk but it was given at laracon and could be one of the most important talks you ever watch: [Devs and Depression](https://www.youtube.com/watch?v=Z6x9wmlFz_c) 
What the f*ck. This is the worst way to approach stuff like this. Also - and this might just be me - I think it sounds like you're just making up stuff, just so we're going to help you.
You cannot have someone else manage your security. It's a part of the development process. Now start taking proper responsibility. 
I've only ever used pcntl_* functions (not pthreads) for asynchronous, long-running stuff (albeit 10 years ago). I think pthreads scratches a similar itch to pcntl, although I'd be interested to hear how pthreads can improve over traditional forking of processes - I assume it just makes parallelism easier to manage rather than cumbersome pcntl_waitpid stuff. As a simple example, imagine you have a reporting function in your system. Users can request a report, your system generates it, writes it to disk and then emails it to them. Do you: 1. Simple generate the report during page load, running the risk of 100s of users requesting a report simultaneously and then having them all hit refresh a few times because it's not responding... 2. Batch up the requests into a queue and have cron pick up the jobs in a single process (so if there's a long queue, or a big report in front of yours, you just have to wait). 3. Have multiple cron processes run, lock items on a queue, and work in parallel 4. Have a daemon, constantly running, polling the queue every few seconds, and when a report comes in, fork a new process, up to a maxmum, pre-determined number of child processes. The advantage of approach 4 is that all users get a decent user experience, (quick reports are emailed almost immediately, unlike 2 and 3). We can gracefully deal with a spike in requests (unlike 1). In this example, long-running processes work best when you want a balance between immediacy and managed scalability. 
Nice. Good work :)
I agree, the first option is a lot simpler. I'm a fan of creating and consuming APIs. It's just so simple.
@terrorgoat, If you are still doing your stuff w/ crons &amp; semaphores, your process is very antiquated. These days I use rabbitmq w/ php waiting on queues to run &amp; acknowledge processed. These can be fanned out to multiple processes in parallel. I guess my main question is when do you use pthreads verse using some other technology like queue services for workers. 
The first use I gave it was for reading the console on Windows asynchronously (that for some reason doesn't work on Windows). Then... a full Minecraft: PE server software. I might post it here after new year.
Why would I make shit up. I have a team to help with my game server and I need to manage database and development of a layout with tables and I don't know how to do that, but if you cocky ass bitch programers don't wabt to help then fuck you.
What are you talking about. Why wouldn't I. It's a close friend whi manages it bettee than I would.
Jokes on climate. colors.php is 2 years older, looking at git history.
Like I said - this was ten years ago. At that time, we were excitedly delving into PHP 4's OO model and toying with the idea of MySQL 4 (which wasn't stable yet). I interpreted your question as "what use cases are there for parallelism, rather than simply long running processes?" If I were to tackle a similar problem to the one I described, then I'd certainly consider a proper job broker system. I'd never consider using cron as a job processor for that example, it was just an example of what not to do :)
&gt; From what I've experiences, pthreads doesn't actually do anything. Do you even know what pthreads is ??
Of course hurr derr php is teh lightweight superprogramming language for just using "exec" for, right? 
Well that sounds like a lot of extra work to this old school dev. 
More specifically it's [String conversion to numbers](http://php.net/manual/en/language.types.string.php#language.types.string.conversion) A single '+' is not evaluating to '+0'. It's a failing to convert entirely, which yields 0. It's the same reason intval('a') also yields int(0).
I would think the following: '+' is actually a string. When type casting a string (without numbers in it) to an int, it gets the int value of 0. And 0 equals 0, so you'll get a true result. The conclusion, however, stays the same: use === when comparing these things
Lots of the Euler exercises aren't good Code Katas because, like many pointed out here, they expect you to have the mathematical solution to have an efficient answer. It's fun, but not very practical in helping you become a better algorithm writer.
Eh, if you're not familiar with composer you are doing yourself a huge disservice. There's being old school, and there's being old dog. One can keep a career, the other will lose it.
There is no reason for it to bug you.... I believe is /u/richjenks's point.
How does one get involved with organizations like this? Is there a list somewhere? I'm not wealthy, but I can donate time and skills. I would guess there's a lot of really great non profits stretching a shoestring budget and they just can't afford quality technical resources. If anyone knows, I'd love to hear how I can use my powers for good.
I used to think like you. Then my productivity increased.
== shouldn't be used for comparing a string and a non-string, no matter how logical it can seem. implicit casting in PHP doesn't care about validation, it will always be converted to *something*. Be extra careful when dealing with password hashes! 20 == '20hku2hkj34gg53jj43k' is true. SQL is worse in that regard. $value = '0'; var_dump($value == '+'); Would fix your issue completely. I have to agree with you: as much as implicit casting is nice for beginners, it's a nightmare when you start to find hard to debug issues raising from bad comparison in your code base, until you understand its limitations anyway ;).
It doesnt matter if "the cool kids do it" so the other stuff is old, they are both the correct answer to the problem. With different pros and cons. 
Many businesses have dependencies that are not managed via composer. I think your statement is exaggerating quite a bit.
So clearly no one should ever learn anything new in their profession because many businesses have products built using old methods and ideologies. I don't think pointing out that apprehension to new (and better) methods is a definite sign of someone becoming an "old dog" is exaggerating in the slightest. It's the mindset that is the problem here, not the specific technology being discussed. Also, what those businesses are doing and what those businesses should be doing (using a dependency/package manager) are two different things. Many businesses don't use source control, so we shouldn't learn/use that. Many businesses don't grasp DRY, so we shouldn't bother. Many business don't do &lt;best practice&gt;, so why learn how. Am I right boys? This attitude is why people think PHP is a joke language. Just because you can fart a php script together that will run doesn't mean you're a programmer. I mean, we're talking about apprehension against learning to do this: composer require symfony/console Instead of manually downloading components, dealing with autoloaders, dealing with updating, dealing with XYZ. Why would you defend this? Because some shitty product you work on/created makes me maintain that themselves? Many businesses don't use abstractions, traits, closures, etc. Does that mean they aren't worth learning? ffs!
holy crap this I shall use :D thanks!
I think in the context of PHP, the really common use-case for "pthreads" is not to use them. But I'm saving this thread, hoping someone actually has a use case for it and will share.
Pro tip, if its a symbol or non alpha numeric type out what it actual is, in this case "php operator greater than greater than" worked. http://stackoverflow.com/questions/5508349/in-php-what-does-the-double-greater-than-symbol-mean
it's a bit-shifting operator. quite interesting. quite opaque/uncommon in everyday usage. a good start can be found here: [bitwise operators](http://php.net/manual/en/language.operators.bitwise.php)
Good advice but my ocd requires me to point out it's less than less than. Sorry.
If pointing out your laziness constitutes me being an asshole, then I'm cool with that.
No. You're just lazy. If after ten supposed years of coding experience you don't have the ability to run a simple Google search, but instead rely on other actual developers hand you the answer you're looking for, that says a LOT about you as a developer. So either you're lazy, or you're a shitty programmer. Or both.
You misspelled "asshole".
Ross' talk was so great. Definitely a must watch.
i mean slowly get into them because you cant be a php developer without knowing them
`$user-&gt;getIsGuest()` made me cringe...
??
why not just use ctypealnum and remove the spaces using str_replace when checking? I guess that's more of data validation than filtering. On the other hand, how would a function like this be beaten?: public function sanatize($string) { return $this-&gt;_db-&gt;real_escape_string(htmlspecialchars($string, ENT_QUOTES)); }
I'm sorry anyone has to work with you.
An algorithm is just a set of steps used to get a result from some data. What exactly are you having problems with?
Just looking for something that can guide me through the theroy of how to approch a programming problem and not get stuck. add more tools to the tool box 
I fix `$user-&gt;getBooleanIsCurrentUserAGuestQuestionMark()`
What problem are you trying to solve
A good place to start might be learning some of the common design patterns, these are common solutions that have been found to work over and over. The standard book for learning them is this one: http://www.amazon.com/Design-patterns-elements-reusable-object-oriented/dp/0201633612 It's not a PHP book but the patterns it covers can be used in any language, there's also loads of stuff on Wikipedia around them: http://en.wikipedia.org/wiki/Category:Software_design_patterns Learning how to approach a programming problem is at the heart of being a good programmer and it's something you'll always be able to improve on (I'm still learning after 15 years of programming) so I would recommend a combination of trying to read as many programming books as you can, asking for help on StackOverflow when you need it, looking through well written open source code to see how those guys approach problems and above all else, practice, practice, practice. 
I think this is a poor example unless each rule required some slow external process to complete e.g. an API call. Even then it might not be worth it. For example if the purpose of trying to speed it up is because the user's browser is hanging for the duration then it should probably done differently anyway. Threading adds a lot of moving parts and can be quite hard to get right so it's worth avoiding until you have no other choice. If you start to parallelize things just for the sake of it it's just premature optimisation and will probably hurt you in the long run.
Funnily enough, I've always remembered it by `&lt;3` being "less than 3" and being unable to make a heart-symbol with a greater than symbol.
&gt; filtering is nonsense I agree. Let's have a look at some production code I recently found on a server: $username = $_POST['username']; $username = preg_replace('/\'/', "EXPLAINATION", $username); This is insanity. This is a developer believing he should sanitize "explaination marks" with this horrendous garbage because he's read in every PHP security article that sanitising is important. I've got users that are greeted with "Hello Bob OEXPLAINATIONMalley". I showed him PDO and all he knew "if you don't sanitise you can get hacked". It's a view supported by far too many blogs and articles out there. Rails users don't even have conversations about sanitising SQL. 
you gotta be kidding man! 10 years and you can't search a simple php syntax?? programming is not your only problem, it's your research skills. jeeeebuuuss.
This is a perfect example of why I get things shipped with "B &amp;amp; C" on the address tag. Edit: apparently reddit changes &amp; amp ; (remove spaces) to an ampersand
It doesn't make more sense to just dump the values. My experience tells me that after you fix the bug found after looking at the dumped variables you will stumble upon another bug in a large percentage of cases. And so you'll need to dump variables again. Anyway, modifying code to see what it does is not easier than just watching what it does as you step from line to line.
Tip for the lazy pro: there is also symbolhound, where you can actually search for [php &lt;&lt;](http://symbolhound.com/?q=php+%3C%3C) 
Something that supposedly allows multithreading, but neither have I been able to get it to do multiple threads, nor have I found any examples ever of working code that gets multiple threads working with it. I would appreciate some resources to good examples if you know any.
I'm going to give you advice, but before you tell me to fuck off with it, here is my value statement. I'm a self-taught programmer and I've been doing web application development professionally for about 15 years (PHP for more than half of that). I currently work at Wayfair.com where our PHP website handles millions of dollars of purchases each day (many hundreds of thousands of page views), and I am leading the team responsible for the search/discovery aspect of the website. Here is my advice to you: * Read [PHP the Right Way](http://www.phptherightway.com). Not everyone follows all of these patterns and guidelines, and there is never one truly "right" way to do anything, but this is a very good template and one you should at least know about and try to follow. * This is not the easiest read, and it's long, but you should try to get through [The Structure and Interpretation of Computer Programs](http://mitpress.mit.edu/sicp/full-text/book/book.html). Examples are in LISP, which is worth learning about, but the concepts apply to any and all programming and too few people have a working knowledge of this. I interview for PHP programming positions very often. I have probably conducted around 50 interviews and many phone screens. While I am absolutely looking for raw programming talent and the ability to reason about a problem and implement a solution, hardcore algorithms is pretty low on my list of things that I care about and hire for. If you have the ability to think through a problem and understand the programming tools that you need to solve it, you can get everything else from Google. If you want to build a Bloom filter, you can find code for that, but you have to understand how code works. I care much more about: 1. Essential programming concepts (basic design patterns, how and when to use loops vs. recursion, etc.) 2. Understanding of how the Internet itself functions (DNS, HTTP headers, cookies, session management, security). 3. Ability to adapt to changing requirements or to pivot solutions to react to new problems. This one is hard to judge in an interview, but some of the earmarks of success here are people who can move quickly through a rough implementation and use observations and my advice to hone it, or at least realize shortcomings in it and describe a preferred solution. 
Main issue with the PHP League is the fact that it diminishes the original author's unique identity and instead all gets lumped under "that thing Phil Sturgeon does".It would better serve the original author's if the League was simply a directory to really good packages, while still letting the author keep the work under their own Github username. I'm surprised so many open source library authors have sacrificed their hard work to the identity and ego of almighty Phil and lost a lot of recognition in the PHP community in the process.
what about the autoloading?
You're irresponsible.
This. Hardcore algorithms, as you call them, actually don't factor at all in my daily work. It's the reality of being a software developer by trade. 99.9% is about storing data, retrieving it, or making it look good. Most of us don't get to do stuff with fancy algorithms...
I, for one, welcome our new British overload.
Thank you for the advice. Im not one to tell people to fuck so fast. I will read your suggested post and strive to be able to sovle programming problems from multiple directions instead of just looking at it one way.
This is a fair point being well made, so thanks for being reasonable here. I'll ignore the ego comments because thats a bit cocky of you, and we can just get to it. &gt; Main issue with the PHP League is the fact that it diminishes the original author's unique identity We list their names on the [homepage](http://thephpleague.com/) right next to the project. The subsites [like this one](http://commonmark.thephpleague.com/) list the author on the main page. They're on the README and in the credits. Not entire sure what more you'd like. The namespace is fairly unimportant. &gt; and instead all gets lumped under "that thing Phil Sturgeon does" This is a weird one. People keep on calling me a BDFL of the League but as I've [explained multiple times](https://philsturgeon.uk/php/2014/10/16/what-is-the-league-of-extraordinary-packages/) I'm just the chap that bought the domain name. And I do a bit of tweeting, along with Frank, Alex and one of the Bens. &gt; I'm surprised so many open source library authors have sacrificed their hard work I think you're a bit confused about where these packages come from. Most of us were friends already, and WE decided to come together. Again, assertions of me being a leader are weird and false. I also spend a lot of time reviewing new submissions to Packagist, and keep an eye out for stuff with great potential. When I saw something that could be awesome but needed a bit of help, I got in touch. Out of 10 packages approached, only one turned us down. Everybody else applies on the [mailing list](https://groups.google.com/forum/#!forum/thephpleague). I am actually in the process of coming up with package suggestion guidelines, to make it easier for us to keep people out. What I do like about the League a lot is that its a meltin pot of interested people. There are about 20 names - big names - who all keep an eye on each others work, who contribute, who help each other with ideas, who provide moderation of PRs while the others are on holiday or away, and most of all - aren't a bunch of dicks to each other. If the Leagues packages were spread out over various peoples projects then they'd be harder to find, harder to swap maintainers without breakage, harder to work together on and we wouldn't have that central point for discussion other than... twitter? I see a lot of hate towards the League because people just don't get it. It's not PEAR. It's not PHP Classes. It's not a framework and we're not stealing all the code to inflate my ego. That, really, is a pointlessly shitty and wildly inaccurate thing to say. :)
There is no directory like that which I know of. Jordi a while ago (very early in the Leagues beginnings) suggested we just became a directory instead, but im not wanting to walk around smashing my rubber seal of approval on people. I think that would be drastically more arrogant than trying to bring together smart interesting developers to work on things together. I don't want another PEAR. 
Maybe not coerced, but I would contend there is some fairly strong pressure on Phil Sturgeon's part for any high-quality PHP project to join up, thus adding more "notches" to his belt of things he is seen as "representing". And, as Phil can fly off the handle at any hint of opposition (as you have witnessed in this thread), some lesser known developers may feel pressured to bow to his wishes or risk being accused of not being a "team player", "being a cunt", etc. To give an example, I **know** the author of Carbon is Brian Nesbitt. How? Because the project is hosted on his Github account. Because Carbon attests to his work, I also know Brian is a good developer who writes high quality PHP code. If he would have been pressured by Phil to add Carbon to "The League" while Carbon was still lesser known, I would have no idea who Brian is, I would just know Carbon as "another one of Phil's League projects". Just thinking developers do a disservice to themselves to sell out the respect and reputation that comes with maintaining a high quality PHP project. Their project just becomes another Phil thing.
It doesn't have to work like that. Something on GitHub where people can submit high quality libraries under different categories (Money manipulation, Date, Database, etc.). Get feedback from community via GitHub on what deserves to be added and what is a pleasure to work with. Anyways, point being, it doesn't have be Phil's "rubber seal of approval".
Thanks :)
No exactly it doesn't need to be and shouldn't be. We're agreeing there. I have been talking to somebody who is working on a package rating system, which identifies various metrics (based mostly off the Leagues rules, which then inspired this http://phppackagechecklist.com/). That system will check which PSRs are in use, if the composer.json is nicely searchable, all sorts of things. That will hopefully become the system you'd hope for, and it really won't be anything like PEAR. :)
[Awesome PHP](https://github.com/ziadoz/awesome-php) is almost exactly what you're describing - check it out sometime!
And you can easily learn who any maintainer or contributor to the League packages are. It isn't hidden in any way. There isn't any "selling out" it is just allowing the package to be more resilient to future issues by not having it under your own github account and php namespace.
In interviews, I do ask candidates to implement algorithms, but it is generally straightforward stuff like "given a list, return the unique elements from the list" or "determine if a given string is a palindrome." These are exercises to gauge basic programming ability and are never taken as 100% of the picture of someone's capabilities as a software engineer. I've never asked someone to do something like write code to do a depth-first traversal of a binary tree; it's not stuff that we would ever do in our jobs, so why test them on it?
I just wanted you to take my advice as that of someone with experience in this field and not immediately think "ew LISP that's 1970s technology," which is something I hear from a lot of young PHP developers without formal training. There is a lot of value to formal training, I simply believe that a lot of that can be acquired through self-discovery, if you know where to look and can be persistent in it.
Lookup "algorithms part1" and part 2 on coursera. They have a great Princeton University course on the subject complete with video lectures, exercises and programming assignments
Have a good one Chris, and the rest of you lot.
I didnt even realize phil sturgeon was part of it until a few days ago... I don't really think thats a fair point for the general populous. I would sacrifice my libraries identities so they could get more use...
It's a bit more complicated. What you call "[Repository](http://martinfowler.com/eaaCatalog/repository.html)" is actually the [Data Mapper pattern](http://martinfowler.com/eaaCatalog/dataMapper.html) (a converter between the storage and the object data). See http://www.contentedcoder.com/2013/08/repository-vs-domain-model-vs-data.html and https://stackoverflow.com/questions/13550690/how-is-the-data-mapper-pattern-different-from-the-repository-pattern The first pattern you show as a bad example is called [Active Record](http://www.martinfowler.com/eaaCatalog/activeRecord.html) but you didn't improve it much with the final example. The object still has multiple responsibilities - its business responsibility as well as its own persistence (and caching!).
or if your program is still working... $message = var_export($variable, TRUE); // more code. print($message); For example, with Drupal, that would be: drupal_set_message(var_export($variable, TRUE));
PHP and Java have changed a lot in these 11 years...
TIL This has been a problem I've experience in the past and been annoyed with. Guess I should be digging into the documentation more often. Thanks
I'll say it again, there's no cost in using step debugging over dumping variables. On the other hand it even has some advantages. Plus at some point you will start writing code without checking it until you get to the point when you think the feature is done and can be checked, it's also much faster than checking each small step.
Spending my christmas break writing 3 more FOSS PHP packages... I think I have a problem.
I'm just heading to do some chores, so I can't help too much; but a tip, stop sending email for the moment and just output your code to html in the browser - see if it still happens (also, you don't have to flick windows to see the errors and junk). Also, along the way, output what you think variables should be: $FirstName = ....; echo "Found Firstname: " . $FirstName; That way you can see WHERE in your code something is going wrong, instead of just doing your entire script then outputting it as false data. Another quick thing, while you're testing - don't use @ (eg @trim), as this will suppress any errors that come out of the function so you don't even realise something is going wrong.
Example: http://ryantbrown.io/laravel-contracts-cheat-sheet/
Thanks man, you too!
 $subject = @trim(stripslashes($_POST['subject'])); Your form is not posting any field named subject. My guess is you're getting an error from this.
How do you post the subject ? Sorry I am still kind new to php. By the way thank for helping me.
At the top of your PHP code do a print_r($_POST); and comment out the rest of the PHP to see if and what data is making it from the HTML form to your PHP.
**Option A:** Add a field to your form. If you want the user to be able to enter the subject themselves, add this: &lt;input type="text" name="subject" value="" /&gt; If you want it to be hidden to the user, add this: &lt;input type="hidden" name="subject" value="This is the subject" /&gt; **Option B:** Set the subject in the PHP variable instead of looking for a posted subject. Change the subject line to this: $subject = 'This is the subject';
I have change it , now i can see the subject but the rest is still blank :( from gmail: Name: Email: Subject: This is the subject Message: this is the php : &lt;?php header('Content-type: application/json'); $status = array( 'type'=&gt;'success', 'message'=&gt;'Email sent!' ); $FirstName = trim(stripslashes($_POST['FirstName'])); echo "Found Firstname: " . $FirstName; $LastName = trim(stripslashes($_POST['LastName'])); echo "Found LastName: " . $LastName; $Emailaddress = trim(stripslashes($_POST['Emailaddress'])); echo "Found Emailaddress: " . $Emailaddress; $subject = 'This is the subject'; echo "Found subject: " . $subject; $Message = trim(stripslashes($_POST['Message'])); echo "Message: " . $Message; $email_from = $Emailaddress; $email_to = 'karolburatynski@gmail.com'; $body = 'Name: ' . $FirstName . "\n\n" . 'Email: ' . $Emailaddress . "\n\n" . 'Subject: ' . $subject . "\n\n" . 'Message: ' . $Message; $success = @mail($email_to, $subject, $body, 'From: &lt;'.$email_from.'&gt;'); echo json_encode($status); die;
At the very top of your PHP script, put this then post the output here: &lt;?php print_r($_POST);exit; ?&gt;
This thread, so far, includes only non-sequitur, off-topic, borderline defensive responses. Not that it's all *bad* advice; it's just mostly unrelated to your question. There *is* value in learning how to analyze algorithms at a level beyond google-driven paging-in of topics when you need them. I'd propose that anybody telling you otherwise has never taken a proper algorithms course (or undertaken the self-study equivalent). That said, I don't know what kind of shortcut you're looking for. You should probably try to work through a respected algorithms text, like this one: * http://www.amazon.com/Introduction-Algorithms-3rd-Thomas-Cormen/dp/0262033844/ref=sr_1_1?ie=UTF8&amp;qid=1419737752&amp;sr=8-1&amp;keywords=introduction+to+algorithms
&gt; &lt;?php &gt; print_r($_POST);exit; &gt; ?&gt; I put that at the top of the php but it doesn t show anything 
or is it my whole sendemail.php that is wrong. 
â€¦easy there, buddy. I was simply pointing out that I think it's quite the exaggeration to say you will lose your career by not knowing composer. 
You're submitting the form and not loading the php script directly right? You should see something if the form was submitted.
Your use of stripslashes is making it sound like your server has [magic quotes](http://php.net/magicquotes) on which also indicates your version of PHP may be pretty old, or else your code sample is from some bad internet post. You're saying you got the emails with everything blank which and your print_r($_POST) outputted nothing which most likely means the form isn't actually being submitted through post. There isn't enough information here to figure out what's going on. For instance, you may have a javascript library on the page sending it over get. What version of PHP are you using? Your version of PHP might be so old you need to use $HTTP_POST_VARS. How is your PHP configured to run? mod_php, cgi, apache+fcgi, nginx+php-fpm, other? If there's a misconfiguration, the server might not even be receiving the data. One thing you could try is seeing all defined variables: &lt;?php var_dump(get_defined_vars()); exit;
Getting my forward-slash and shift keys working together.
Think that you can use [Repository pattern](http://ryantablada.com/post/the-repository-pattern-in-action) just for that.
It looks like your Document model is also part of your persistence configuration and a query builder. Laravel's Eloquent ORM uses the ActiveRecord pattern, which leads to designs like this. The DataMapper pattern splits out the entities and their persistence. Here's a brief comparison of [ActiveRecord vs DataMapper](http://culttt.com/2014/06/18/whats-difference-active-record-data-mapper/). I'd read up on the DataMapper pattern, then gradually migrate models over. You can either do this with Doctrine (which may be best long term but harder to do) or just use Laravel's ORM as a repository and use POPOs as your entities.
There is a large collection of examples in the github repository and in every pecl release. pthreads has very close to 100k downloads from pecl alone, not counting installations from source via github; you are obviously doing something wrong.
never trust non responsive web sites
This didn't really say anything. 
Is there any way in which React is deficient in comparison to Node.js?
I don't know enough about it to give a technical answer to that question. From an outside perspective; the community of developers using it is relatively tiny when compared to Node. cc /u/igorw
PHP doesn't have to be the best tool for every job. And it might not ever be the best tool for this job. I do think it's worth exploring the boundaries of async PHP before we make that call though. So for real world business apps [that need async]; let's use Node (because it's the best, current tool for the job). But let's not end every conversation about async PHP with "you should be using Node for that". That's all I'm saying... :)
By saying "filtering is nonsense" you're automatically assuming that they're putting all of that information into a database. Filtering is a much wider subject than that. For example, would you not filter/validate an email address or the contents of an email if the script didn't store the message in a database? Would you not filter a variable that's only used during processing and not actually stored? Don't assume that filtering data is always connected with the storage of data. That's a dangerous assumption to make.
I managed an asynchronous project with a multiprocess feature : PHP create a process, ZeroMQ handles the process routing and ReactPHP handles the messaging queue. I tried some other ways, like PHP extensions (pthreads) or socket technologies, but there are some limitations with PHP streams (resources). Without process or an extension, I don't think PHP can handle a truly asynchronous job. If interested by the project : here, the [process factory](https://github.com/EloGank/lol-php-api/blob/master/src/EloGank/Api/Client/LOLClientAsync.php), the [process worker](https://github.com/EloGank/lol-php-api/blob/master/src/EloGank/Api/Client/Worker/ClientWorker.php) and the [ReactPHP server](https://github.com/EloGank/lol-php-api/blob/master/src/EloGank/Api/Server/Server.php). 
How do you compare with [`Hoa\Console`](https://github.com/hoaproject/Console) which supports tput to get good controls and appropriate number of colors?
[**@atoum_org**](https://twitter.com/atoum_org): &gt;[2014-12-28 14:26:50 UTC](https://twitter.com/atoum_org/status/549209867706441728) &gt;atoum 1.2.0 is released \([*github.com*](https://github.com/atoum/atoum/releases/tag/1.2.0)\); mainly: &gt;\* fix a bug in the mock generator, &gt;\* santa reportðŸŽ…, &gt;\* variadic arguments support. ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/2qm9v2%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
I sort of agree. The interpreter goes a long way to making this possible (as in the example of Hack/HHVM). Currently React uses libev/libevent/`stream_select` to emulate the event loop. In the case of Node, V8 + C bindings provide this functionality. It's not just the language, but if the language fights it then game over.
Why are there still 32 bit web servers? They must be like 15 years old by now. 
A sysadmin will tell you, "because you don't touch something that runs perfectly for 15 years unless you absolutely have to."
&gt; I have no idea how to go with this, is there any way to get my Silex app running in there? Or should I go with a plain PHP website? It sucks, but just FTP the whole thing there from your dev environment. It takes a while because `vendor/` will have a lot of small files, but it should just work.
If it's working properly and doing what you need, DO NOT TOUCH IT! ;)
/u/bopp is correct. Uploading all of the files from your local environment to your school's server via FTP should work just fine. It seems as though you have a good bit of experience with servers and have an understanding of how they work, so I think what I would stress more than anything here is the process in which you go about forklifting your school's site. Most web developers in this case would probably develop the new site locally first before making any changes on the school's server. As shitty as your school's website looks, and as insecure as it might be, people there are under the impression that it works and it does the job. Unfortunately, you have to take this into consideration before bringing the whole thing down. So unless you can go to http://yourschoolsdomain.com/phpmyadmin and then login as root with no password, you should be safe in holding off a production push until you're finished with your development. Additionally, some hosting providers are still running outdated versions of PHP. Check with their provider to determine whether or not Silex can even run on their host. I do believe cPanel comes with a phpinfo module somewhere. So if their host meets the Silex criteria, you should actually be just fine in continuing to use Silex. If you already know the kind of server setup your school uses, you can probably get a local environment up and running quickly with [Vagrant](https://www.vagrantup.com/) to minimize any environmental differences between your local environment and production. If you don't, you can at least get a quick local server up and running using WAMP, MAMP, XAMPP, or some variation depending on your OS (if you haven't already). After that, I would just edit your local Hosts file and map your school's URL to your localhost. This will give you an accurate representation of how your website will look in production, while still working locally and without touching any remote files. This is probably a different answer than you were looking for, but hopefully it helps.
Do you really need to generate an array? What is it you're planning to do?
I'm not sure if this is relevant to OPs needs but worth noting just taking a range with out knowledge of the netmask includes broadcast/network addresses of the network in question.
I'm willing to bet that a computer system that has been running "perfectly" for 15 years untouched is just an illusion.
Similar to what /u/bopp said, take a copy of the production site and set up a mirror with [Vagrant](//vagrantup.com). Do the development locally and when you're finished, FTP the new files up to the server. This opens the door for version control you can do locally and instant environment testing, and you won't have to keep pushing up every single change to the server every time you want to check it's working.
This solution is very elegant code-wise, but unfortunately it uses linear space complexity (roughly O(2n)), so it's suboptimal for the task of just looping a range of addresses, as it will "waste" relatively large amounts of memory (eventually causing process failure when the memory limit is hit - at something like ~16 million addresses for the default 128M `memory_limit` setting). It may be arguably less elegant to look at, but /u/shindaseishin's similar answer uses constant space complexity, so it should be used instead.
Unless you're being a pedant over the loose use of "perfectly" in that context, you'd lose that bet pretty easily.
&gt; Is it possible for PhoneGap to accept PHP? No, PHP is not a client-side scripting language. You *might* have some luck with PHP-to-JavaScript compilation tools, but that's a long shot.
I don't believe the arguments shut down the attempt to evolve the core of PHP. They are arguments saying it hasn't evolved *yet*. React PHP is a really good move forward, but there still has to be some work done on the SAPI level. As most SAPIs people will want to us for async programming (mod_php or php-fpm) are inappropriate for async setups.
Really? You think a web server can go on without any maintenance for 15 years and work without any issues? 
You could run a PHP REST API on a server and interact with it using Javascript &amp; Ajax in your Phonegap app. Just make sure to enable CORS on the server for cross-site Ajax to work.
Dump that data into a database. As sickening as it is, each has to be it's own row in the table.
This is the route you'll likely want to go. (And the one I had in mind when I clicked on this post) Makes it easy as pie.
Yes. It happens. Old stuff used to work for much longer than the new stuff. 
I still lease 2 ~15 year old web servers that I don't want to move or even touch too much because they run my DNS. They can probably be replaced by a $5 instance somewhere but until now, the work and possible downtime involved hasn't been worth the savings.
I don't think Chris is suggesting that PHP needs to be the best tool for the job. I know him well enough to know he's not that dumb. PHP is a good simple tool for a lot of things, and there is very little reason to exclude async logic from the core. If I wanted to build something to leverage a lot of async functionality now I'd use Go, which has routines and channels that make tough loops go so much quicker. One (but not the only) benefit of adding functionality like this to PHP is the amount of simplification it could bring to existing projects. Right now PHP developers are forced to implement rabbit/gearman/beanstalk message queues to handle even the most basic "do multiple things at once or later but not all right now" functionality. If PHP 7 slapped in some async as a first-class feature of the language then that could be cut right out in an upgrade, which is certainly better than trying to rewrite everything into another language or force SoA onto people who don't know what it is. Having it in there does not distract from the fact that PHP is a language built for the web. Go is too, and it fits right in there. Python makes great use of async too, with frameworks like Tornado going as far as to make all incoming requests and responses async, making for one hell of a fast turnaround on responses until your CPU explodes. [PHP is a pillagin pirate](http://blog.astrumfutura.com/2012/04/php-innocent-villagefolk-or-a-pillagin-pirate/) and as always taken shiny bits from other languages. Letting other more experimental small languages do the hard work then implementing proven approaches should be seen as a highly positive and mature approach to improving what still is the most popular language on the web.
Ugh, apparently it's running PHP 5.2, that's too old right?
Unfortunately, yes. Silex - or really any kind of Symfony-based platform - requires at least PHP version 5.3.3. Additionally, PHP version 5.2 is no longer actively maintained. Whoever this hosting provider is (Hostgator?), you may want to check and see if your school's account with them allows you to upgrade/modify PHP versions through cPanel or customer service.
It's even more dangerous to mix filtering with validation, like you just did. You don't want to filter emails, even though php offers functions named "filter_*" used also for validation. Our maybe I'm picky on the word. I imply that filtering means to pick something out of a haystack and therefore ignoring other data. That's how a filter works in my mind. And that would basically imply changed data. I don't try to filter some input, removing chars or alike to get an expected input. I urge the user to put the email (or whatever) correctly and validate that. Then it remains untouched. The goal is to take data as is and not opening oneself to attack vectors like xss, db injections, xsrf, header injections or whatever else. Trim() is ok, though. ;) But you have a point in that it is hard or impossible to make a short statement which is always true and superior in all situations. 
I don't have access to the server right now, but under the "features" page they list PHP 5.2 I will try to convince whoever is in charge of the web to switch hosting, the current provider (HostRentable, a local Argentinian one) is really cheap (about $2/mo) and I'm not sure if the school would want to spend anything more.
Still nothing . I really appreciate all the help . Maybe i need to redo it and put a simpler contact form.
should i post my post over their ?
Which can be accounted for (start and end are already considered sane and sorted initially): if ($start &lt; $end) { // integer overflow error on 32 bit system detected, adjusting. for ($i = $start ; $i &lt;= PHP_INT_MAX ; $i++) { // go up to PHP_INT_MAX echo long2ip($i) . "\n"; } for ($i = ~PHP_INT_MAX; $i &lt;= $end; $i++) { // and continue from PHP_INT_MIN (which is PHP_INT_MAX with all bits inverted.) echo long2ip($i) . "\n"; } } else { for ($i=$start;$i&lt;=$end;$i++) { echo long2ip($i) . "\n"; } }
Yep, but hopefully one is never deploying anything but maintenance patches to those machines at this point.
What he is saying is that you're storing all the adresses in a big array, if you're just gonna loop on them it's way smarter to use /u/shindaseishin's solution.
Not necessarily "lose your career" in the sense of being fired, but most definitely stagnate. Ours is not an industry where you're done learning once you get out of college / enter the job market. If you (or whoever) refuses to learn about new, useful tools I can assure you that there are other folk out there learning about them and willing to take yer jerb.
I don't think you can quantify it like that. 
phonegap is nothing more than a web browser that has the address bar hidden. phonegap injects a few javascript hooks so you can interact with the hardware. Back to my first sentence, its just a web browser. When you build phonegap you can specify which URL you want the app to point to. You do not have to embed the HTML,CSS, JS in the app when you ship it. It can load content from the internet.
You can write reusable code in various programming styles. Not just OOP. I've seen lots of bad OOP code that I'm reluctant to agree with your instructor pinning something like this on OOP. Even though I've started to program in 2006, I've seen enough people telling (in conferences, books, articles out there, etc) that there was a big OOP hype in the 80's and 90's that led to a bunch of people shooting themselves in the foot. That's not to say that OOP is bad, of course. I've also seen good OOP code, and I hope can I write good OOP code if needed. Well structured code tends to pay out on larger projects, but that isn't inherently about OOP. And line count is highly meaningless unless under a really tight context. Consider how many hundreds of lines of C can be replaced by a single line of Python. Even within the context of a single language, a good library or framework can help you develop the same program with you having to write a lot less lines of code. Tools can also influence (IDEs, code generation tools, ...).
Another way to tell the story is it's best to use an iterator instead of assigning the whole array. It becomes especially if you start having a big range between the first and last IP address.
So not web servers then, since they are not hosting any websites. Or you're telling me you have 15 year old, unpatched Apache/httpd running... 
Yeah! Security vulnerabilities aren't a thing! Software doesn't behave unexpectedly!
This is exactly right. Many many phone gap applications use PHP services so there's plenty of help available with that technology stack.
We use laravel as a server app, and then just run Ajax from Cordova to it 
I use PHPStorm for larger projects, and it's great. But unless I'm using it wrong you only get code completion when you start to type something, or search. This is an overall glance at what's available via the contracts. For example a friend at work used it to create a single page print out with all the interfaces/methods that he keeps on his desk for quick reference. I thought it might be useful for anyone who likes Laravel.
I'm still not 100% familiar in the more formal notations and stuff, but isn't /u/shindaseishin's answer linear as well? O(n) as opposed to O(2n) but it's still not constant. it would take longer to do 10.0.1.1 to 10.0.2.1 than 10.0.1.1 to 10.0.1.6
Out of curiosity, does it need to stay in Argentina? It sounds as though you're not expecting *too* much load... Red Hat's OpenShift has a free tier that would probably work out well for you?
Yea, Laravel is a great solution for this.
Not at all. I just posted an example of 15 year old "untouched" (besides security updates of course) servers that are 32-bit.
This all started from a comment about 32 vs 64 bit operating systems. The 32 bit versions are still kept up to date, so I'm not sure what security vulnerabilities you're talking about. Are you implying that 32 bit processors are somehow insecure? 
I don't think it **has** to stay in Argentina, most "local" servers are in the US anyways. The problem with foreign services is that we have to pay in Dollars, which makes it super expensive for us. I know OpenShift, I might give it ago. But I have to see what they think about using it, since they barely know what 'git' is.
I have no idea but Amazon will happily let you install 32 bit Ubuntu 14.04 LTS if you want. Rackspace won't.
If the site is just a simple site why don't you just use Joomla or Wordpress?
Using the term "scripts" is a bit misleading if what you're talking about is an application. I think a better way of judging is not the number of files or the lines of code, but more the number of "entities". If your system is dealing with... just *orders*, you'll probably get little benefit from a complex order object. Some, sure, but little. If your system is dealing with *orders*, *products*, *users*, *coupons*, *categories*, *shipping details*, *dispatch* and *inventory*... then you'll certainly get a lot more benefit from OOP. It's not just a matter of reducing lines of code. It's a matter of simplifying the way things connect (or don't). Lines of code is also a poor metric for anything. 2000 lines of clear and concise code in a series of well-named and namespaced classes properly used by a rational system is far easier to follow than 500 lines of "clever" procedural code with no conventions or discipline in a giant blob. 
The direct comment is in response to a web server going without maintenance for 15 years. It has nothing to do with 32 vs 64 bit. Unless you're saying that "old stuff used to work for much longer than the new stuff" is saying that somehow 64bit is inherently less stable than 32bit.
Irony: Explaination mark isn't a word. I'm assuming he meant "exclamation marks", being a !, which is not filtered. He did the same thing for spaces on other fields where they became XXSPACEXX, but decided it was an acceptable risk for a "full name".
so if I use the "usernames[]" name, and then use Input::get('usernames'), and submit that to a database - will the usernames be placed on separate rows of the database?
Fair enough, thank you.
CIDR encodes blocks of IPs of length 2^n . The posters example has however 6. To understand the systematics of CIDR play for instance a bit around with http://myipdoc.com/CIDR-to-range.php
So I tried it and when i submitted the form and checked the database the data was "Array". how do I get the data that was in the form field? Thanks
&gt; whether Zend 2 is actually caching data If it doesn't expressly say it does, and expressly have you provide a cache backend, then no, it doesn't cache a thing. &gt; I was hoping to prevent the models from becoming bloated by defining my own "fetchAll", "find" methods, etc. Those methods don't belong there. Those would belong at the data access layer. Consider using a Data Mapper like Doctrine or even Spot instead of the included Table Row Gateway stuff. They make it easier to build smarter data layers without cross conatminating your model.
I think a better measure would be a certain cut off of database tables you update in any given action. I only have six tables in one of my recent projects-- but OOP made the most sense since there were several refactors after the minimally viable product delivery. Refactoring was easier in OOP since I could update classes 'cafeteria' style. One of the classes I did not have to refactor in the first round was the database access layer (generated by Propel)-- it remained the same before and after. A similar refactor in procedural would have required more work. The second major refactor did require a database table change, which required a new data access layer representing the database structure changes (that just means it is an autogenerated code library based on the database structure to interact with the database), and the classes for objects that interacted with those tables were rejiggered. Procedural code would have made me cry.
I picked them because he said the host had cpanel which could install Joomla and Wordpress. 
How would one utilize a db tree structure in multiple sessions. I've been building applications using sql queries on every page load. I would like to use a graph structure but do not know how to use it without loading it and unloading it on every page load. My guess would be to load it into session global but is this safe and appropriate?
&gt; Those methods don't belong there. Those would belong at the data access layer. Doesn't the ORM, in this case my implementation of the AbstractTableGateway represent the data access layer? 
What exactly do you want in your database field? If you want a string representation of the array, something like `implode(',', $usernames)` may do the trick (depending on how long it can get). But surely you want to insert a row for each name submitted?
For HHVM's part, allow me to nudge everyone towards: http://www.reddit.com/r/PHP/comments/2oduau/async_cooperative_multitasking_for_hack_and_async/ I'd also offer an impromptu IAmA as the author of the blog entry it links to ( http://hhvm.com/blog/7091 ) if anyone wants more context on HHVM's take on an asynchronous PHP.
I don't think this is quite what you want. I think `usernames[]` will give you a slightly confusing format for the data. I think what you would actually want is something more like `data[]username`. This would mean that you could just loop over Input::get('data'). foreach(Input::get('data') as $user) { echo $user['username'] // username echo $user['description'] // the description. } Not sure why you're doing with that, of course, echoing isn't exactly useful. I should also point out that the above might not work. Saying `data[]username` is pretty weird, and you might have to make jquery create something like `data[1]username` to keep things valid/together. On another more judgemental note... This looks like Laravel code. I'm a big supporter of Laravel and frameworks in general, but this is basic array access. If you can't do this I suspect something like Laravel is concerningly premature.
When the form is submitted I want each "username" and "description" to be placed on separate rows in the database. However I just tried using the 'name="usernames[]"' and 'Input::get('usernames')', but only one row was populated in the database, and every field said "Array".
Should I use mysqli or PDO ?
Yeah, it has a lot to do with maintainability. I also feel OOP helped a lot with speed of development.
PDO gives you some flexibility over your actual DB, but you then have to research for the few options required for whatever db you're actually using (when establishing the initial connection). They both support prepared statements so if you're not planning to switch database any time soon, you could go with either. Personally, I use PDO unless my framework has an ORM.
I think it should be `data[1][username]` or perhaps `data[username][]`
I'm not specifically trying to use laravel. I am starting to learn my way around PHP and for most of my project I have been fine, however I am having trouble submitting a from with multiple fields that have the same name. I trued the example above and unfortunately couldn't get that to work either.
Dumping your $_POST array is just a step in debugging your script. It will let you know if anything is even being posted to your PHP page.
for all of these solutions I am clearly doing something wrong.. damn 500 errors :p. If anyone has a solution for a PHP novice it would be greatly appreciated!
for all of these solutions I am clearly doing something wrong.. damn 500 errors :p. If anyone has a solution for a PHP novice it would be greatly appreciated!
On top of what others said, I would use PDO because it is more wildly used. You will often find the same look n' feel with other libraries and most libraries (like Doctrine DBAL) are wrappers on top of PDO.
I am not sure what your question is. Could you provide an example? It seems to be a general programming/algorithm question, perhaps it would be useful as its own thread. Are you asking about how to store a tree in a database? If so, what are your use cases? Do you have partial queries (subtrees)? Do you have frequent updates or mostly reads? I would suggest having a look at how Doctrine Extensions does it first. https://github.com/Atlantic18/DoctrineExtensions/blob/master/doc/tree.md
Have you looked into using a graph database like Neo4j? Would something like that fit your needs?
 &lt;div class="x"&gt; &lt;input type="text" name="usernames[]"&gt; &lt;textarea name="descriptions[]"&gt; &lt;/textarea&gt; &lt;/div&gt; &lt;div class="x"&gt; &lt;input type="text" name="usernames[]"&gt; &lt;textarea name="descriptions[]"&gt; &lt;/textarea&gt; &lt;/div&gt; Then in your PHP: $usernames = Input::get('usernames'); $descriptions = Input::get('descriptions'); foreach ($usernames as $index =&gt; $username) { // Insert using $username and $descriptions[$index] }
It seems to just post 'Array' to the database again.
If that shows nothing at all, you most likely have a syntax error in your file. Check the error log to see where the issue is.
Please put your code on pastebin or similar.
I would wager a high percent of us.. a lot of us work in PHP frameworks. 
I want to use Hack for its static typing but I want to know if that will make me unable to use PHP7 when it comes out. I also want to know if anyone uses Hack with phpStorm and how well it does catching type errors.
I prefer mysqli because 1) it's unbelievably rare that you'll switch database products without other very significant changes and 2) [this](http://php.net/manual/en/pdo.prepare.php): &gt; PDO will emulate prepared statements/bound parameters for drivers that do not natively support them, and can also rewrite named or question mark style parameter markers to something more appropriate, if the driver supports one style but not the other. bothers me, personally. I want guarantees that my parameters are being properly bound and not `mysql_string_escape`'d in some kind of fashion.
&gt; only FTP 
The company I work for uses their own custom framework, but I don't touch the PHP bits much, I mostly do C++.
Your problem might be related to [session locking](http://php.net/session-write-close).
Facebook?
I have not I will though thank you
so youre not a php developer?
As much as PHP is hated on routinely, I **could not** be more grateful that this happened.
Could you not simply serialize it and store it in a cache such as Redis or Memcache?
&gt; I think joining the League Did Phil just turn up one day, eye patch over the left eye, and say: "I'd like to talk to you about an initiative called 'The PHP League'" ? 
I think you accidentally an important.
If it is you running the report and then you again trying to load another page, it likely is session blocking. Just close the session before generating the report, and then open it again if you need to before delivering the data. If you are running the report and someone else is having issues loading the page, then you would be running into issues with database and server connections and limits.
It depends on the goal. Is the data tied to a specific person? Then session may be the way to go. Is it an object? Maybe consider APC. Is it just one set of data that expires infrequently? Consider storing as a serialized file. If it's going to churn a lot, memcache or redis may be the way to go. 
As a self-though programmer this is indeed very valuable advice. Especially reading the books. The understanding and knowledge of patterns are necessary, especially when to not use them. :))
If it's viable for you, you may benefit from setting up a read slave. Basically an extra copy of MySQL that is read-only, good especially for large queries and reporting. 
As for generating a large report, you could do that on a backup of the database. Of course, this may or may not be feasible, depending on various circumstances. But if you're the one doing the report, and you do the report not very often, then this might be a good way for you to do it. If you are searching for a product out of 3,000, then this should not normally be taking any noticeable amount of time. The fact that requests are piling up suggests that it's a single query that's the culprit. See if you can add indexes to table columns to speed things up, running [EXPLAIN](http://dev.mysql.com/doc/refman/5.0/en/using-explain.html) on whichever query you're using can illuminate the bottleneck. In MySQL, an index is a sorted list of all the values that exist in a given column, with pointers to the rows that contain this value. It's like an index in a book, if you want to know where traits are mentioned in a PHP book, you can check the index and quickly go to the mentions. If you didn't have the index you'd basically need to flip through the entire book. A primary key or a UNIQUE column automatically gets an index in MySQL. Any other columns don't, so you'll need to index those yourself. EXPLAIN will tell you if a given query could and would use any indexes if you were to run it. Indexes take up disk space and make INSERT queries slower, especially if you have a lot of rows in the table. Rest assured though, 3,000 is *not* a lot. Adding a single index can speed up queries by multiple orders of magnitude.
It sounds like your script is locking up one or more tables. Make sure that these tables are using storage engines which offer transaction support. You may want to run the following command via mysql-client while the script is running just to be sure: "show full processlist" 
I'll be using this one at work. I wish I'd seen this three weeks ago.
Definitely. People can rag on it all they want - if I'm being paid to know how to write it, I'm happy.
you like static typing?
If you gonna have end users entering this I recommend having some kind of sanity check. I built a form for this years ago and a user filled it out wrong which resulted in him allocating thousands of IP addresses. 
How well does CQRS work in real world applications, where you make a request and want to see a result synchronously?
That's not why most people hate php. That's only the reason people state when they are jumping on the hate bandwagon and don't actually know why. Personally I prefer use the '.' Instead of a '+' so math and concatenation stick out. As far as variable prefixing goes, it adds another feature called "variable variables" (look it up). As far as the '-&gt;' goes, I'm guessing we ran out of operators. As for why people actually hate php, I think the main reason is that anyone can write php. It's easy to pick up the extreme basics of php, and writing out some terribly ugly code that works, but is super inefficient. I'm sure there are other reasons but I've never really looked into it as many search results will just give you the typical "LOL variable prefixing? Wtf php is garbage" with little explanation.
Lines of code != cost.
I've finally had the chance to meet Rasmus â‰ƒ3 weeks ago. What a great guy and what a fantastic thing he has begun. I've been working with PHP for the past 15 years and there's still a lot to learn, whch is a sign of a great language, IMHO.
It's not worth going into detail, but dislike for PHP is often not based on the things you mentioned. Some of my biggest gripes: * PHP is cluttered, the standard library is huge, and the entire thing is in global scope. * Inconsistancy in naming and function return values. * The PHP developers are overly afraid of fixing the language, if a bugfix causes even the slightest of backwards incompatibility. They mark obvious bugs as nofix, because the insane behavior already has been warned against in the docs, so now it's a feature. * The old versions (and to some degree all versions) allow the developer to shoot himself in the foot. The mysql_ functions have caused more damage than any other software bug or feature in history. And yes, you can say that it is the fault of the developer, but I believe that PHP made/makes it too easy to make these mistakes. * Other than stackoverflow, 90% of guides/answers you find on google teach bad code. This has something to do with the past of the language and the above reasons, and I don't know how it would be fixed. I realize this is not the fault of the language itself, but it is a deterrent for beginners. Also, I find the official documentation lacking in places. The comments are often full of "clarifications" and code examples, some fine, some very poor code. * I have always found error handeling in PHP to be kinda insane. It's so inconsistant. Do I use exceptions? Oh, this function return NULL .. or 0 .. or just false. * The == operator should be removed. The type coercion in PHP is the most confusing and inconsistant thing in the world, and I have no idea how anyone could defend it as a good idea. I could go on. I don't think PHP is unusable or shit or hate it, but I don't think it is a great language in it's current state.
Thanks for the response. These are the details that I was looking for.
I'm one of the people who hate PHP with a passion. I have several decades of experience from other languages, and also some theoretical knowledge about programming languages, but I often wonder why other languages (I can only think of some earlier Basics and Perl) didn't choose to separate variables from keywords with a sigil like $ -- it seems like a fine choice to me. Why the hatred then? Mostly it's because PHP has grown without any real design, which makes it an appallingly bad tool. That wouldn't be enough to hate it of course, since I could just ignore it. What creates the hate is that it's used everywhere, so I am also forced to use it sometimes. Perhaps it's cognitive dissonance? The pressure between seeing that something is total crap, but then seeing that it's hugely successful and popular.
Then where on earth are you getting `Input::get('field')` from? This is in no way standard PHP. If you're not using Laravel you'll be getting errors all over the place.
Then build it and stop moaning about stuff other people have built. This "you did not do this the way i think it should be done" attitude is useless. If you think there is a better way of doing this that is not a wiki (cause that is useless), then go for it.
So, taking only built in functionality in PHP, what is the breakaway line count that object oriented programming becomes more cost effective than other ways of structuring a program. While the answer is very difficult to quantify so much more so is the question in the first place. It would be highly enjoyable to simply get a comparison of say around line 438 it starts to become more efficient and or cost effective. I know that I am highly oversimplifying things but curiosity won't let go. 
Yep. Full time employed as senior dev and team lead, and freelancing on smaller projects on the side.
Wow. I've had that problem before, and never been able to put my finger on why a session gets locked (when doing long csv imports), and my browser won't open another page, *but* another browser has no problem. Thanks for that pointer :-) 
How does one test header output with PHPUnit, without using Xdebug? I don't see a way, without abstracting the response into an object, such as HttpFoundation/Response. However, this isn't always possible...sometimes you need to actually output headers in a library. Anyone have any experience here?
You can see the error messages adding these lines at the beginning of the script: error_reporting(E_ALL); ini_set('display_errors', TRUE); After you are done, you can comment (hide) them.
I don't know. Besides... If you had started out structuring your code well in some other way, it may be that it'll never pay off to do a transition into OOP. And it seems like a silly thing to find out, honestly. If you want to get a better idea of when you should use OOP and when not, you should program more. Not ask for a line number. Program in different languages, with different styles, with different techniques, and so forth. Implement things just for the hang of it. Look for good programming books. The "real deal" requires more than just knowing a line number threshold. If you __really__ want my advice, stop pursuing this curiosity. There were and still are attempts to analyze software in various ways through LOC counting. They're generally frowned upon by every good (as far as I can tell) developer I've heard of (seriously, I've never seen an exception to this - LOC counting is generally perceived as meaningless, evil, and all sorts of bad stuff).
Abstract it. [Aura.Web](https://github.com/auraphp/Aura.Web) is a lightweight solution here. Alternatively, override the header(), cookie(), and setrawcookie() functions in the liibrary namespace to make a static call to a test-specific class that retains the headers in a static property. Then your test can inspect that property.
I've been trying to find something similar to this for quite a while. I'll definitely take a good look ASAP, but rest assure that this is very interesting.
I did something similar with lftp: http://oscarm.org/2012/07/automating-ftp-uploads/
So, what do you think about Symfony 2?
Thanks, I appreciate it! I couldn't find a suitable solution when I first needed something like this so hopefully it might help you and others too. Hopefully feedback and contributions can help to improve the package and extend its functionality further :)
Informally. My title is "Analyst," but I'm coding 24/7.
I don't see anything useful in this article. The author appears to be just complaining about other peoples problems with their pet framework. Frankly, while I haven't used ZF2, and I have no real idea what problems the author is complaining about (since they don't provide any examples), I'm with the other people. Good programmers *are* lazy. They use and write libraries and APIs and use appropriate patterns so they don't have to do the same annoying things over and over again. I don't want to spend hours configuring the framework and bending to its will. The framework should get the hell out of my way and let me get on with creating my masterpiece. An artist doesn't want an easel that takes hours to set up, even if it does set their canvas at the perfect angle with the perfect lighting for almost any situation the artist may encounter. They want to plop their easel down and start scribbling outlines and laying down paint.
The main problem with the article, is that it's not really related to ZF2. I won't explain what I mean. Give Laravel 5 a try if you are interested. 
Cool, thanks Paul.
My career has been PHP for 10 years, professionally for ~6. My primary job involves Laravel and Wordpress. Can't really discuss much of the Laravel stuff, but the WP stuff is themes/plugins. My secondary job ("hobby") is a custom framework, transitioning to Laravel with some custom components. It's a multi-tenancy social site. To answer your question though, I do "make stuff," I'm happy doing what I do and I make decent money doing it!
There's still a lot of misunderstanding ... if I said the following: &gt; C was not built to be asynchronous. Any attempts to do these things are by definition going against what C was built to do. Yet many people think C can change to accommodate these tasks. You would say I was barking mad, you would be right to do so. Asynchronous concurrency is not necessarily something that requires support from the environment executing code. It so happens that some environments do provide help, but it's certainly not necessary. Asynchronous concurrency means interleaving instructions for individual tasks so that the tasks run concurrently *with respect to each other*. It's usually the case that the programmer needs to take some special action in order to achieve this, which is part of the reason why we don't need to change PHP. I think maybe some example code that we can all understand might help, so I'll have a go at that. The following code creates 10 tasks, the tasks are stupid; count from `$this-&gt;start` to `$this-&gt;end`, this' is unimportant for the explanation: &lt;?php class Task { function Task($id, $start, $end) { $this-&gt;id = $id; $this-&gt;start = $start; $this-&gt;end = $end; $this-&gt;pos = $this-&gt;start; } function execute() { if ($this-&gt;pos &lt; $this-&gt;end) { return $this-&gt;pos++; } else return false; } } $range = range(1, 100); $ranges = array_chunk($range, 10); $tasks = array(); while (count($ranges)) { $range = array_shift($ranges); $tasks[] = new Task( count($tasks) + 1, array_shift($range), array_pop($range)); } while (count($tasks)) { foreach ($tasks as $id =&gt; $task) { if ($task-&gt;execute() === false) { printf("task %d complete\n", $task-&gt;id); unset($tasks[$id]); } else printf("task %d position %d\n", $task-&gt;id, $task-&gt;pos); } } ?&gt; *This is horrible code, but should work on every implementation of PHP that we care about, or did care about ...* http://3v4l.org/Xq6m2#v430 The *way the tasks are executed* is asynchronous without requiring anything from PHP. It so happens that this particular pattern lends itself to implementation of non-blocking I/O; it allows you to eliminate the need for waiting by returning immediately when a stream would block, so that another read/write may occur. That's all you need to achieve asynchronous concurrency, interleaved instructions, so we don't necessarily need to talk about changing PHP to accommodate this new thing, because it's not a new thing and not something that necessarily requires accommodation.
&gt; That's all you need to achieve asynchronous concurrency, interleaved instructions, so we don't necessarily need to talk about changing PHP to accommodate this new thing, because it's not a new thing and not something that necessarily requires accommodation. This is true, but language features can make this much easier. PHP 5.5 added generators, for instance, which allow you to use `yield` and write normal imperative code instead of creating complex state machines: &lt;?php function counter($from, $to, $step = 1) { for ($i = $from; $i &lt;= $to; $i += $step) { yield $i; } } $counters = [counter(1, 10), counter(2, 22, 2), counter(3, 33, 3)]; while ($counters) { foreach ($counters as $i =&gt; $counter) { echo $counter-&gt;current(), PHP_EOL; $counter-&gt;next(); if (!$counter-&gt;valid()) { unset($counters[$i]); } } } With generators you can do asynchronous I/O with good libraries, so there's no real need for Hack-style `async` to be added.
afraid not affraid
I agree generators are nice, but it's undeniable that they weren't strictly necessary. The example code was the way it was to demonstrate that since PHP4 you could achieve asynchronous concurrency. The only take away is that we don't really need to do anything, and we never really did.
I do custom application development, usually with Symfony, as my day job. 
For anyone else confused as shit initially.. this was posted 6/8/95 and despite being paid a bunch of money to code in PHP, I never knew what it actually stood for and thought this was some _new_ project playing on the PHP name and couldnt figure out why he was "re-inventing the wheel" /derp
what are you coding for (what are you making)?
Im a junior web dev who focuses on PHP. I used to work at a company where I was the sole developer and purely used raw PHP, no frameworks, mainly because I had never been introduced to frameworks. Now I use frameworks laravel, slim, yii, zend. But my job has never been to just tend to a CMS
Ugh I already tried. Bad idea. I'll leave it at L4 for now, and just use the migration tools once L5 is ready.
And I don't think he's fully fleshed out **why** people complain. Or maybe it's because I just felt this over the weekend. It's a big Symfony2 project and there is this one feature that was marked as "phase 2" that I was going to take a stab at (on my own time) because I've done it before (geolocation/geocoding). When it came time to start coding I realized just how much work it was going to do just to do some proof of concept stuff. Change an entity, run some migrations, clear the cache (which takes forever), and then if it didn't work I would have to roll everything back so I could do work on Monday. It was just a little disappointing. The framework took the wind out of my sails. Maybe it's just me though.
I ended up adding a quick fix limiting a range of max 50 IP addresses at a time which was fine for my purpose. 
Thanks for clarifying but I stand by my statement that; "PHP was not built to use an event loop. PHP was not built to be asynchronous." You've demonstrated how it can, as a language, simulate the event loop. So it's possible to do, and is in essence how ReactPHP (using `stream_select`) implements the event loop. But PHP was never created with this use-case in mind. As Rasmus will be the first to tell you; PHP was just created to help him make dynamic forms quicker to write. Functions like `curl_multi_exec()` and `reap_async_query()` are comparatively recent additions to a procedural, blocking tool-set. Projects like ReactPHP are also comparatively recent additions to the ecosystem. Event-based/reactive architectures are virtually unheard of in production PHP applications. It's mostly just MVC or "legacy". Thats the point of the post. So, as you've eloquently illustrated, PHP already has the tools to do asynchronous concurrency. Yet the demonstrable majority of PHP applications/websites sit behind Nginx and Apache. Compared to daemonized [and evented] Ruby, Python, and Node application architectures; we're still very far behind. I am trying to encourage discussion and exploration into all manner of applications that use the event-loop. I'm trying to nudge a generation of MVC-minded PHP developers in the direction of a new [to them, at least] paradigm. 
A+
&gt; With generators you can do asynchronous I/O with good libraries, &gt; so there's no real need for Hack-style async to be added. You could take that same argument to mean that since you can do asynchronous I/O without generators, there's no real need for generators to be added. You're making the argument that enhancements to the language make async cleaner and easier to do right, then saying that enhancements to the language are unnecessary. It's a weird middle-ground to fall on...
&gt; You could take that same argument to mean that since you can do asynchronous I/O without generators, there's no real need for generators to be added. You could, but I don't really agree. Generators avoid the need for callbacks and state machines, greatly simplifying the creation of iterators and coroutines. `async` doesn't do anything that can't be easily done with a plain PHP library for handling generators.
Prepared statements are not a security measure as much as they are a performance measure. What exactly is wrong with just escaping the string?
So lame, link to demo is dead!
Well, that's what it *originally* stood for, but with PHP/FI 2, PHP was officially changed to stand for "**P**HP: **H**ypertext **P**reprocessor" (a recursive acronym, just like GNU is an acronym for "**G**NU is **N**ot **U**nix").
Do you need the whole tree on each page load? Could you just do queries to get the nodes or subtrees you need each time?
A "Database as a Service" self-provisioning platform. Developers at my company can log in (via ldap authentication) and request a database (oracle, sql server, mongo, to name a few), and get a connection string via email. We're expanding from provisioning into operations too, so for example, a regular user can perform some "DBA" level tasks such as bouncing the database via an API call. It's a neat project, kind of like Amazon's AWS for the private cloud.
&gt;a recursive acronym A recursive *backcronym*. 
Random off topic question for you, how is SC2Armory doing this days? Are you still maintaining it or planning on porting it to Laravel?
I'm fairly passionate about this. I'm going to answer your question and then give you a whole bunch of information you didn't ask for, just because. At my company, historically yes - my job was (and still kind of is) just to be a CMS jockey - install some plugins or themes, do some configuration, initial content entry etc. This is because both management - and clients - operate under the myth that custom code is expensive and that "all you need to do is install some plugins and you're done". Both of these are false statements, and are precisely why almost every CMS project my company has gone over budget. I've slowly started convincing them that custom code in a proper framework is cheaper, faster, and better in almost *all* situations. The reason for this is because we are a client services company: we don't tell the client what is and isn't possible, they tell us what they want and we build it. The problem is, canned solutions like CMSs and plugins don't adequately fit the individual business rules of most of our clients, and as such we break our backs attempting to make that canned software work in a way it was never designed or intended to work. If you're asking this question because you want to know what life as a PHP developer is like, you are likely to find an agency that does just have you doing CMS jockey stuff. I recommend avoiding this entirely. The work is painful, it's not fulfilling, it doesn't pay well, and the company's clients are likely only companies who haven't heard of Squarespace. Find an agency that understands custom business rules and specifications requires custom code, not canned code. And that if you're going to write custom code, do it in a proper framework instead of Wordpress, Drupal, or Joomla. 
*shakes fist* BUSSSSEEEEYYYYY!!
Wouldn't that defeat the purpose of have the trie? I wouldnt get the sane efficiency right?
We currently handle translations by keeping them all in a file (currently an giant xml file... feel free to suggest better ways of doing that as well), and have a script that goes through that file and builds an array of key=&gt;translation for each language and serializes those to a file. On each page load the proper file is selected based on the user's profile settings and is unserialized into a global variable. Strings are printed out with a set of functions that access that array and return or print the translated string. This has served us well. Despite the serialized files being around 200K each, loading them takes an pretty insignificant amount of time... but I was just wondering if there's a better way to do that? Should I put them in a local redis/memcached instance or just in APC? If so, should I load the whole language array on each page load, or request individual keys when they are needed?
*Offtopic:* I am sorry to inform you, that the generation of igniter-tards and lara-tards know nothing about MVC. You really should avoid making claims about subjects on which you are quite ignorant. Oh .. and regarding this, one of them is not like the others: &gt; Compared to daemonized [and evented] Ruby, Python, and Node (..) 
Ah. Probably. I missed the part where it was a trie. We have a few simple structures using something like [this](https://en.wikipedia.org/wiki/Nested_set_model) that we do queries for parent/children/anscestors/descendants when needed.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Nested set model**](https://en.wikipedia.org/wiki/Nested%20set%20model): [](#sfw) --- &gt; &gt;The __nested set model__ is a particular technique for representing [nested sets](https://en.wikipedia.org/wiki/Nested_set) (also known as [trees](https://en.wikipedia.org/wiki/Tree_(data_structure\)) or [hierarchies](https://en.wikipedia.org/wiki/Hierarchy)) in [relational databases](https://en.wikipedia.org/wiki/Relational_database). &gt;The term was apparently introduced by [Joe Celko](https://en.wikipedia.org/wiki/Joe_Celko); others describe the same technique without naming it or using different terms. &gt;==== &gt;[**Image**](https://i.imgur.com/KEFChJA.png) [^(i)](https://commons.wikimedia.org/wiki/File:NestedSetModel.svg) --- ^Interesting: [^Hereditarily ^finite ^set](https://en.wikipedia.org/wiki/Hereditarily_finite_set) ^| [^Subgenomic ^mRNA](https://en.wikipedia.org/wiki/Subgenomic_mRNA) ^| [^Joe ^Celko](https://en.wikipedia.org/wiki/Joe_Celko) ^| [^Hierarchical ^database ^model](https://en.wikipedia.org/wiki/Hierarchical_database_model) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn8ik3y) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn8ik3y)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
&gt; You really should avoid making claims about subjects on which you are quite ignorant. I welcome correction, especially when it is well-reasoned (as Joe tends to do). - Ruby -&gt; [Event Machine Apps](http://rubyeventmachine.com/) - Python -&gt; [Twisted Apps](https://twistedmatrix.com/trac/) - Node -&gt; [Apps that use the HTTP Module](http://nodejs.org/api/http.html) Which one are you referring to?
I didn't say Node was a programming language, either here or in the post. I distinctly used the word architectures, and then provided you with examples of apps that use event-based architectures, relating to distinct environments (associated with some languages and frameworks). Bit nit-picky, don't you think?
I actually took SC2A down around May and have no plans to bring it back. I originally wanted to shift it over to a Heroes of the Storm portal, but simply have no time to run a website. It had a good run.
*cough* She works on HHVM.
I write Hack in PHPStorm and it's "ok". It marks all the generics, types, etc features as invalid in the editor, but it doesn't completely break everything. All the PHP related code, like namespaces, and class resolution still work. The PHPStorm guys are currently working on Hack support, so I suspect we will see it sometime soon. As for PHP7 compared to Hack, what do you mean exactly? Hack/HHVM is usually ahead of the curve and integrates new PHP features before PHP actually does, so by the time PHP7 rolls around, it will most likely be interoperable. I was able to write a complete Hack framework in PHPStorm. https://github.com/titon/framework
Wouldn't you load the entire tree and then cache it? Via memcache or something similar? No need to query the database each time.
&gt; "simulate"? That's an event loop. then &gt; The only thing special about node.js So is having a default event-loop special or does making an event-loop (which is not provided by default) equal having a default event loop? I'm not sure I understand your frustration here. I don't think my use of the word _simulate_ is worth getting upset about, especially when your wording indicates a subtle difference. Let's move on... &gt; ...and? I'm not saying it's a bad thing. Take a look at that part of the post again - I don't use that as a reason against introducing async language features/functions. The post is in strong agreement with evolving the language. &gt; What's wrong with using a traditional shared-nothing architecture? The "behind" I'm talking about here is our ability to use shared-nothing **as well as** event-based. One aspect (shared-nothing) is time-tested and obviously works well. The other (event-based/reactive) is never used for anything big, and there are only a handful of extensions and libraries aimed support of these kinds of architectures. Forgive the ambiguity of "behind" but I really don't mean that the language is inferior. I love PHP very much, and that does not stop me from wanting it to be better. :)
What are your current thoughts on PHPs current implementation? Namespaces, generators, traits, all the stuff.
&gt; So is having a default event-loop special or does making an event-loop (which is not provided by default) equal having a default event loop? I'm not sure I understand your frustration here. I don't think my use of the word simulate is worth getting upset about, especially when your wording indicates a subtle difference. Well, you're using the word "simulate" as if what those languages do isn't "real", as if it's some inferior imitation. It's not. JavaScript is usually hosted within an event loop (node.js, browser), other languages usually aren't, but there's not really a difference between running one yourself and being run in one. Well, the former gives you choice, I suppose. &gt; The "behind" I'm talking about here is our ability to use shared-nothing as well as event-based. Alright, yeah, the libraries for that aren't terribly mature yet.
&gt; using the word "simulate" as if what those languages do isn't "real" I see where you're coming from - I'll stop using it in that context. If it helps, think of the definition of simulate which means "to create a computer model of something". Or just ignore the word. Joe illustrated how to make an event loop.
Actually it's a recursive initialism. Acronyms need to be pronounceable as a word, like LASER or SCUBA.
I'm by no means an expert on CQRS, but my understanding is that it's entirely about reducing complexity in your application development workflow. What it comes down to is that "Asking a question should not change the answer". You don't have to necessarily represent the CQRS pattern in the front-end of your application. You can simply implement it as the method your application uses for querying and updating information in your model. In a recent project, I implemented a sort of CQRS pattern where I had command objects representing either read or write operations, and then had "aggregate" command objects which executed a series of these read or write commands and chained their results together. Each aggregate could draw on the individual operations, re-using their behaviours without worrying about reads causing side-effect writes, or writes being pigeonholed into being based on a particular read query.
Then what are ones like "MS-DOS" or "JPEG" that are partly pronounced as a word and partly as letters? ;)
you gave not 1 reason, just saying "its used everywhere" so its a bad language is contrary.
I'll definitely be looking at this. We have a calendar system that has a way old version of phpcalendar (to handle recurrences) hacked in that has given me more headaches than I care to think about. This looks extremely promising!
I am a PHP developer. I'm in a small team developing a customer CRM system, building MI reports, refactoring functionality and implementing custom systems to suit my employer's business needs. We do have some CMS operations, but it's quite remote and isn't used much. 
If you try really hard, PHP could be pronounceable.
Some good points but as someone who's had to develop extensively with moodle, I got PTSD just reading the name.
It's not a hypothetical scenario; there have already been and still are such servers.
Is this bad practice or easily exploitable to load pages? if(isset($_GET['page']) AND file_exists("pages/$_GET[page].php")) { $page = $_GET['page']; } else { $page = "home"; } include("pages/$page.php"); There is nothing in the Pages-folder the user should not be accessing
I actually just started testing Ratchet with our API last night ([unfortunately not laravel](http://www.reddit.com/r/PHP/comments/25mdqi/10_things_i_learned_from_rphp/))... what a coincimadence. Nice read... I also like how it was written/structured. 
Does anyone has a code example how a model should look lie in MVC framework? Something easier to understand? 
Thanks buddy! Are you behind [this](http://mygaming.co.za/news)?
Nope, that's a different guy. My gaming era was 99-2005 lol.
But what if I specified the page as "../sensitive_info" I could theoretically load random files from your file system. You should never trust user input on a filename that you are loading. 
That's an outgoing port, not an incoming port! :(
This is only tangentially related to your question, but if you're using an FTP-only server but you still want to use Git, you can use git-ftp: https://github.com/git-ftp/git-ftp I used it for a project a couple weeks ago and it worked flawlessly.
Gonna have to disagree on that. String escaping is tricky and prone to exploits wherein a malicious users can break out of the string escape and then manipulate the SQL directly. The escaping routine must prevent against every escape workaround ever, because it only takes one to break through. Prepared statements, on the other hand, will never suffer from this kind of exploit -- the data has no relationship to the sql and can not modify what the SQL is designed to do. This is a _major_ security boon. As for performance -- yes, prepared statement can help increase looped queries, but the vast majority of php project aren't going to be doing loops like that. If you are, you're probably using SQL wrong. For example: if you are loading a page of comments, you could get a speed boost by preparing the "fetch a comment" sql but in reality you should be executing a "fetch all applicable comments" sql a single time.
&gt;Mostly it's because PHP has grown without any real design, which makes it an appallingly bad tool. and &gt; so I am also forced to use it sometimes. and &gt; Perhaps it's cognitive dissonance? Indeed, I did not give 1 reason, I gave 3. 
It's my opinion that the PHP core developers are not afraid of backwards compatibility, but they are cautious about breaking backwards compatibility only when absolutely necessary outside of major versions, and not making too many breaks in major versions. There are plenty of examples of major language changes causing major, long-term adoption issues in across many languages (Perl 6, Python 3) and PHP already has enough issues with hosts not keeping up even with the lowest supported major version. PHP 7, the next generation of PHP, as well as containing excellent performance improvements, contains a large number of backwards compatibility breaks - primarily (so far, altho I expect this trend to continue) mainly in the name of making the language more consistent from the point of view of those writing PHP code. Yes, there are discussions on the mailing lists where backwards compatibility is raised as a reason not to implement things, even in PHP 7. But in my opinion this is a good thing. The developers should be aware of how many backwards incompatible changes they're making, and why those changes are made. Some notable things which are gone, but not forgotten by those of us who have been around long enough: * [register_globals](http://php.net/register_globals) * [Magic Quotes](http://php.net/magic_quotes) Things which are being fixed in PHP7, with backwards compatibility breaks: * [Integer semantics](https://wiki.php.net/rfc/integer_semantics) * [Uniform variable syntax](https://wiki.php.net/rfc/uniform_variable_syntax) * [list() behaviour consistency](https://wiki.php.net/rfc/fix_list_behavior_inconsistency) * [Remove alternative PHP tags](https://wiki.php.net/rfc/remove_alternative_php_tags) For other changes which have been made in the 5.x series see: * [PHP Dev Wiki: Implemented RFCs](https://wiki.php.net/rfc#implemented) * [PHP Manual: Migrating Appendices](http://php.net/manual/en/appendices.php)
&gt; You can simply take your static HTML website, add a simple &lt;?php include 'counter.php'; ?&gt; in there, and â€¦ be done! congrats. your first spaghetti code.
Yum!
&gt; Is this bad practice Yes, horrendous. Some problems in your code you may not have noticed. $_GET[page] Is missing single quotes around "page". include("pages/$page.php"); Is a textbook example of a [Directory traversal attack](http://en.wikipedia.org/wiki/Directory_traversal_attack). tl:dr, you're allowing the user to load any file from the file system. Solutions? [Edit] I lied, not quite as bad as I thought since you're specifying the ".php" extension, so only PHP files would be loaded, but I still recommend you work off a white list approach. 1. Load the filename from a predefined list of valid files. 2. Set open_basedir restrictions ([See](http://php.net/manual/en/ini.core.php#ini.open-basedir)) Popular frameworks solve this by allowing you to define routes, ie, you'll register a controller to handle "/contact. When the request comes in, it'll check what's registered and only process valid URLs. 
Yeah, I always upgrade to the latest PHPStorm version.
I have this class - public static function get($item){ if(isset($_POST[$item])){ return $_POST[$item]; } else if(isset($_GET[$item])){ return $_GET[$item]; } return ''; } - in a file called Input.php
/u/AllenJB83 gave a much better answer than I will, I just wanted to respond to this: &gt;I have been thinking about PHP for a while in order to match my resume to local demand. Im my years as a developer I have heard a lot of shit about PHP. So I am what you might call a skeptic. Don't be skeptical -- just try it out. PHP as a language is just fine. It's installed on almost every server worldwide, it has a huge standard library, it has great OO support, and it's super easy to get started with. What gives PHP a bad name is the number of people who write shitty PHP (because it is very easy to get started in PHP). Every language has its prickly bits and stupid parts, you will learn them in time. 
&gt; currently an giant xml file... feel free to suggest better ways of doing that as well I understand storing translations in a .po file is the best option. With specialized tools like [Poedit](http://poedit.net/) you give the ability for people not familiar with XML to edit translations; Also means you can outsource your translation work. I assume you're doing a simple string replacement. Make sure you take into account pluralization to not dig yourself into a hole. I'd personally use the [Symfony Translation Component](http://symfony.com/doc/current/components/translation/index.html).
In a Symfony application the model is typically a Doctrine Entity. So a plain class with defined properties. &lt;?php // src/Entity/Product.php class Product { /** * @var int */ protected $id; /** * @var string */ protected $name; public function getId() { return $this-&gt;id; } public function getName() { return $this-&gt;name; } public function setName($name) { $this-&gt;name = $name; } } It has no idea where it's persisted or how it's loaded. That's the job of an entityManager. Can't get any easier than that.
Yes, because because every single hit counter needs to have at least CounterModel, CounterController, CounterServiceProvider and CounterView.
Moodle is what made me decide I don't want kids. I'm not bringing children into this world where software like that exists.
But, there's only 18 different versions of the YUI library being used at once! It's okay, you can add a tooltip to let them know there's issues... in the giant localization array.
Because it's free. You have to pay out the ass to license blackboard or canvas.
I work exclusively in the edu sector and they pay a LOT to get their websites running properly. Since moodle is web I don't know why they don't just roll in a paid solution. It's the students that end up suffering! 
Has anyone used this? How does it stack up against Sculpin or any of the others?
Just put HTML aside from logic and you will be good.
&gt; I have been thinking about PHP for a while in order to match my resume to local demand. Im my years as a developer I have heard a lot of shit about PHP. So I am what you might call a skeptic. You're reasonable to be skeptical. And somewhere like here, where there are mostly evangelists and expert users, you'll struggle a little bit to get an objective response, but I'll do my best. A lot of the "shit" you've heard about PHP is out of date. PHP has improved substantially in recent years. There has been a rise in standards bodies, an appreciation of testing and code quality that hasn't been present much in my roughly 14 years of professional development. There are a lot of things that PHP developers consider "new" or cutting edge. MVC Frameworks, Unit Testing, Dependency management. These are "givens" in professional development in most languages, but PHP... not so much. Unfortunately, though, PHP has a huge legacy of... legacy. Some of the most popular PHP projects, and I'm speaking specifically of Wordpress, are horrifically regressive and nasty pieces of cludge. Unfortunately there is a lot of work in that end of town, from massive agencies to one man bands. &gt; The thing that holds me from investing in PHP is a fear that backwards compatibility is central enough that old mistakes are never repaired. That's a well founded fear. IMO backward compatibility is held in too high a regard, with even the future version (inexplicably named PHP7) on the way there is some resistance to "breaking changes" that fix what is unarguably incorrect behaviour. But that being said, many things **are** fixed. When I first started doing PHP, a setting called `register_globals` was the standard. This was a very *convenient* way of working with data, because it would take data from the POST input or GET input stream and convert them into symbols in the global namespace. So if you went to a page with ?name=Steve, you'd have a `$name` variable all ready to go. "Convenient" though this was, it was also a huge security issue, as just adding something like '&amp;logged_in=true' or '&amp;admin=1' could potentially bypass security checks. Initially this was on by default. In PHP 4.2 it was turned off by default. In 5.3 it was deprecated, meaning attempting to set it raised an error, and in 5.4 it was removed entirely. For some time the standard way to start a session variable was `session_register("name");`. This was also deprecated in 5.3 and removed in 5.4. There are plenty of other examples that are going the same way. The routine documentation for how to database in PHP is to use `mysql_connect`. This extension is now deprecated (since 5.5) and is likely to be removed in the next PHP. There was a recently noted... feature... where people could put multiple default cases on a switch statement, the compiler then ignoring the first one. That was unanimously voted to be fixed in the next version. You're not wrong in your concern that BC is PHP's sacred cow. Many of us using the language feel the same. It's up to you whether that's an issue or not. If you **do** find you can't get over it, you may find some love in Hack. This is a Facebook initiative which adds a lot of modern features missing in PHP that you might be used to (nullables, generics, static type hinting) and is far more aggressive and progressive than PHP itself. If you do end up going with PHP, you'll also find that modern frameworks make a lot of PHP's stupid go away. 
&gt; So, this is basically a class that maps a table? Not always, could be persisted in memory where there's no such thing as a table. &gt; class name being a table name? No, Doctrine tends to do this with PHP annotations, but you can define this class -&gt; table mapping elsewhere. the class itself shouldn't have knowledge of how / where it's stored. &gt; what else is in play to send data from model to the controller? Here's a quick example taken from the Doctrine documentation. $article = $entityManager-&gt;find('Product', 1); The entity manager here is something which loads the data, could be from MongoDB, MySQL, Postgres, etc ... You then give it a class name "Product" for it to populate. The "1" is the ID of the data stored in the backend.
The header image ... oh god.
Thanks, let me know how you get on with it :) I had a look to see if there was a solution out there so that I didn't reinvent the wheel. I've tried to build the package in such a way that it can be customised to the users needs if the default implementations do not fulfil their requirements. Hopefully it proves to be useful! :) 
Ok, I get it now. So, I guess it makes sense to say that in pretty basic MVC framework, the "Model" can be made of two *things*: An entity and Entity Manager. If I have an ORM or a query builder class like a PDO wrapper plus the entity class in your example, would that somehow describe an example to what a Model is or looks like? 
&gt; register_globals Fun fact: The management interface to current model, high end SANs from a major vendor is reliant on register_globals. 
Now try to understand my "joke"
What everyone talking about space complexity seems to be missing here is that the dude said he wanted to build an array, not merely output the values. Furthermore, and what's actually a better point, is that your assertion that the more machine-optimal approach should *clearly* be used over what you called a "very elegant" approach, is questionable. What are we even doing mussing about with PHP, then? It's so inefficient!
tl;dr: HHVM
Reading this makes me very happy that I'm now coding in Java.
AKA - Real World benchmarks. None of that contrived fibonacci stuff.
Eh, never trust a benchmark you didn't fake yourself.
I see no reason a library can't do that.
What says you have to spend time in a busy loop? If you're waiting on I/O, well, just block using `select`. If you're waiting on a thread, join it.
And if you're waiting on multiple types of events? Say a socket and a thread?
if php is so good, why do php programmers constantly reassure themselves that it is?
PHP 5.3 has reached End of Life and is no longer receiving security updates. Seems to me that this tool is coming a bit late to the party.
It's cool that it exists. It's horrifying if anyone uses it.
You're probably not the only person who works more *on* PHP than *in* it. I'm the same.
Because it's usually in rebuttal to "PHP sucks because of...." insert non relevant reason here.
how about magento?
&gt; But publicly shaming fellow developers isn't constructive or avuncular. I just got out of bed at 4am having read this response on my phone in bed. I didn't do that did I ? I didn't intend to, apologies if that's how it seemed. When you opened by iterating again how you opened in your blog post (more or less, that php wasn't built to be asynchronous), it really felt like you missed the point. The point was that innovation in this area, for *PHP*, is not held back by language support.
...you can't break out of string escaping. And you're not doing it yourself, the PDO library is, so you are not doing it on your own every time. On the other side, prepared statements are not perfect, and it only takes one exploit in the mysql driver to get through.
This comment caused me to spat my drink
I think there's a real difference in how we are thinking about this and I think I know why. Wasted CPU cycles in HHVM are a disaster, since those cycles are likely to otherwise be executing users code directly, but in Zend this would never be the case; those CPU cycles would just be used entering or exiting another opcode handler, parsing some parameters, or any of the other (inefficient) things we do for every call and every opcode. Having language support is neat, having generators is neat, but if the community wants to innovate in this area then they need not wait for some higher level of support from the language, they can just take the pattern and implement it, or even use Hack.
Never touched it.
If PHP is so bad, why do people that've never touched it need to constantly reassure themselves that they were right in not touching it?
&gt; After we had already been working on the conversion for several months, Facebook approached us offering to donate some developer time to help with this task. Facebook developer Brett Simmers spent one month full-time with our team providing very valuable assistance, and Facebook also offered to make themselves available for other issues we might encounter.
Kill it with fire
Oh my. This is the wrong solution to the problem. 
Please click on the link wrapping the very first words of the post. It explains my motivations. :)
Making reactive/event-based apps is [understandably] very different from traditional apps. Memory management is a [relatively] big concern because every request shares the same context. That's not to say it causes excessive memory use (no memory leaks or anything) but that every request is on the same, persistent script execution. We've got to make it work by reducing memory use, queueing/sending-to-workers intense processing and handling IO efficiently in the main thread.
Could easily make that same argument for ROR devs. 
The Helper component looks quite interesting and seems to me like the strongest part of this static page generator.
Thank you, fixed.
&gt; It's horrifying if anyone uses it. Not really. This is how you prove that your conversion to 5.4+ was successful. You upgrade, then run this tool. If the code it outputs is identical to the code you started with before your upgrade then you know your code is 5.4+ compliant.
php is successful because of [this](http://en.wikipedia.org/wiki/Principle_of_good_enough)
The point is that I am no beginner, I know how to wtite web apps and I do it well. I want to gauge (by some type of retrospective approach) if the language is headed in what I believe is the right way. There about a hundred other things I would like to check out so if PHP turns out not to be worth it I have other things to do.
This is three years old. 
Is the best way of ensuring the same CLI script doesn't get executed twice simultaneously really just to test and acquire a file lock on an arbitrary file? That seems clumsy. (I'm on Windows)
Also, if you want to add a log statement for every method in a class as it starts and ends, is there any way to do this without either just pasting the log statements into every method, or using a string to store the name of the method to be executed? It seems like you should be able to pass a function pointer as an argument to a log method cleanly, but all the ways I've seen it done rely on simply passing the function name as a string - which could lead to execution-time errors that should be picked up at syntax-checking time.
I've been doing PHP since version 4, in 2004. AMA I guess. I have a CompSci Masters and so the work I've done has skewed towards complex bespoke development from paypal card processing integration taking about $1m/day to juggling big-ish data for home automation services.
One of the good things about PHP is that it's fairly well documented: http://php.net/ChangeLog-5.php
The problem here is when you use some vendor package which requires PHP 5.4+. The only sane way to use it under PHP 5.3 in this case is to use some conversion tool like this, and run the testsuite of the package to ensure everything is fine.
That's what you do when you want more people to adopt and spread your technology, I guess.
Adding "sockets in an API" isn't hard,however making it scale definitely is. I hate to say,but for me it was just easier to front whatever PHP code I had with nodejs while using a queue for inter-process communication. Because clearly PHP isn't built for that kind of stunt. I'm checking Hack though,it's async feature look interesting BUT as long as libraries arent designed from the ground for async I/O it will hardly make a difference. In nodejs,you're forced to write Async code,and all libs and native extensions are built around async I/O. It makes things definitely faster but also makes error management a nightmare.
Modern IDEs and editors have autocomplete options and plugins (For example, type "in_array", and the editor will add the parameters in their respective order). And the PHP manual is very complete :)
That's the standard way of doing it. [Wikipedia Lock](http://en.wikipedia.org/wiki/Lock_%28computer_science%29#Types) You'll find a lot of Unix services use lock files to ensure there's 1 instance running. It's also how it's done with the [Symfony Process Component](http://symfony.com/doc/current/components/filesystem/lock_handler.html). You running into issues using a lock file?
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 1. [**Types**](https://en.wikipedia.org/wiki/Lock_%28computer_science%29#Types) of article [**Lock %28computer science%29**](https://en.wikipedia.org/wiki/Lock%20%28computer%20science%29): [](#sfw) --- &gt; &gt;Generally, locks are __advisory locks__, where each thread cooperates by acquiring the lock before accessing the corresponding data. Some systems also implement __mandatory locks__, where attempting unauthorized access to a locked resource will force an [exception](https://en.wikipedia.org/wiki/Exception_handling) in the entity attempting to make the access. &gt;The simplest type of lock is a binary [semaphore](https://en.wikipedia.org/wiki/Semaphore_(programming\)). It provides exclusive access to the locked data. Other schemes also provide shared access for reading data. Other widely implemented access modes are exclusive, intend-to-exclude and intend-to-upgrade. &gt;Another way to classify locks is by what happens when the lock strategy prevents progress of a thread. Most locking designs [block](https://en.wikipedia.org/wiki/Blocking_(computing\)) the [execution](https://en.wikipedia.org/wiki/Execution_(computers\)) of the [thread](https://en.wikipedia.org/wiki/Thread_(computer_science\)) requesting the lock until it is allowed to access the locked resource. With a [spinlock](https://en.wikipedia.org/wiki/Spinlock), the thread simply waits ("spins") until the lock becomes available. This is efficient if threads are blocked for a short time, because it avoids the overhead of operating system process re-scheduling. It is inefficient if the lock is held for a long time, or if the progress of the thread that is holding the lock depends on preemption of the locked thread. &gt; --- ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cn99dkv) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cn99dkv)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
"Are PHP quirks phased out eventually?" &lt;-- Hmmm, Cleaning mostly happens in major versions and it takes 10 years for a major version release. and even if some one *in the internals says lets remove a quirk* other idiots in the internals say, *lets keep that because of bc thingy* .. and to the question.. yes .. after 15* years. PS: see the discussions here (http://www.serverphorums.com/read.php?7,1044048) 
&gt; I know how to wtite web apps and I do it well. Friendly advice.. Ignore *php*. Concentrate on a PHP Framework (Zend,Symfony,Laravel, Typo3 Flow). If you have a choice use a utility function package (better abstractions around core functions, so that edge cases are covered and you dont have to worry about them anymore.) .
&gt; I would like to check out so if PHP turns out not to be worth it I have other things to do. (y) PS: am not *saying* anything!!!
Don't use them. This easy.
Say that I focus on Laravel (I've had some limited exposure to it). What type of abstractions are you suggesting I might find? Could I expect Laravel to provide me with array manipulation APIs or maybe regex APIs?
Undeservedly , the post is downvoted... I am tasked to convert a premium wordpress theme that supports 5.4+, to a 5.3 version and been putting off this for weeks. I was preparing for a whole day of boring semi-manual work of replacing array notations and you saved the day ;) 
&gt; Where would you say is the best place to look at PHP bugs ? http://bugs.php.net A detailed overview is at: http://bugs.php.net/stats.php
Tldr: dvorak keyboard :D
Constantly three years ago.
Thank you.
You're not going to find clean APIs and canonical ways to do things (*edit: in the language itself). You will find fairly comprehensive up to date documentation, a very active community with as many opinions as developers, and your choice of libraries for almost anything you need.
Plover, surely.
That, by it self is not an issue. What I am interested in is official patches and the like. But as far as I can tell a lot of obvious bugs are actually fixed even if backwards compatability is broken, which is nice.
It is very interesting that you can set such a specific time frame. It puts things in perspective.
The fact that tooling can help doesn't mean that all problems disappear, if naming is inconsistent I still have to know roughly what the methods are called in order to find them. If the naming does not follow the same pattern this can be needlessly hard. This problem is not unique to PHP mind you. As shitty APIs exist for all development stacks.
The issue is that I think it's ugly and I'd rather have a proper mutex!
Broadway is composed of multiple components, usable for Event Sourcing as well as CQRS. We just released a demo to show how you can use it within a Symfony application: http://labs.qandidate.com/blog/2014/12/30/a-broadway-demo-application/
Self proclaimed best practices for people who would prefer to defer to the self proclaimed standards body
Yessir! Makes me happy that I've been using %Y all this time
Sweet list!
Yup, use pastebin for that.
I love PHP, I really do but PHP is the last language I would pick for a socket server. I can't think of any good reason why I would not use node, C++ or Java for this application instead.
Please click on the link wrapping the very first words of the post. It explains my motivations. :)
&gt; This is absolutely and unequivocally pathetic. This means that over 78% of all PHP installs have at least one known security vulnerability. Pathetic. Exactly. Anyone who wants to bring a counter argument starting with "but [insert tradeoff here]" needs to read this post and the previous one linked at the top.
I couldn't agree more. The previous poster was spot-on that a competent IDE makes the problem more of an... idiosyncrasy. But the fact is that PHP's API has grown organically, according to perceived need and without formal guidance. (Or insufficient guidance.)l If that's a show stopper you should let it stop the show. There are options. Doing something you hate "because the industry" shouldn't be one of them. 
Laravel (nor any of the other frameworks to my knowledge) provide either of those. Though there may be libraries you can include with your project (very very very simply) to add that stuff.
this isnt neccessary
I think that this is spot on the reasson that PHP might not be for me yet. Maybe in ten years.
Another nightmare I had to deal with for a while.
You have no idea what kind of bullet you just dodged. You may think you do but it's much worse than you imagine.
Self-proclaimed? PSR-0 and PSR-4 have proven their worth a thousand times, they easily stand on their own merit.
This is absolutely a problem. We need a resource that lists what versions hosts support, and what the default is. Then we can shame them into upgrading. 
hey man, thanks. happy holidays!
I won't argue against the concept, as most PHP developers are amateurs that need direction lest we repeat the late 90s code quality
Happy holidays! :)
Quick, let's install 5.1 as it's the most secure!
I think this problem is magnified by a few things. 1. I don't know the exact figures, but I'm willing to wager that a large percentage of web accessible PHP apps are on shared hosting servers. Servers where users don't have root access to update PHP (nor would they necessarily know what to do if they had access). 2. A large percentage of projects are probably built more procedurally and lack unit tests. When you have a legacy application without testing and you are looking at what could possibly break from 5.5 -&gt; 5.6 it becomes a leap of faith unless you have a battery of tests that can ease your mind. Unless you are itching for more performance or some new capability most people just don't bother and keep kicking the can down the road. We've probably all dealt with legacy codebases that don't have tests and are built 99% procedurally and don't feel like biting the bullet of re-arching mountains of code you didn't write just to make it work on a new version of PHP. I'm not saying it's a good excuse, but I think we have all felt that pain before.
Let's do this. https://github.com/philsturgeon/php-host-versions/blob/master/README.md
Yes I am aware, but the entire post is about inconsistencies in PHP and how they evolve. I was enquiring to whether or not laravel in this case had any alternatives.
I somehow missed this comment, really helpful!
NameCheap supports 5.2 &amp; 5.3 on Shared and 5.4 &amp; 5.5 on Business Shared SSD. ~~Not sure if 5.4 works on Business Shared.~~ [Source](https://www.namecheap.com/support/knowledgebase/article.aspx/9312/2194/how-to-switch-php-version-on-shared-servers) Edit: 5.2-5.5 on Business Shared. [Source](https://www.namecheap.com/support/knowledgebase/article.aspx/9311/2194/how-to-switch-php-version-for-business-servers)
This puzzle and the discussion just remind me how *much* I hate formatting time() to human-readable.
Submit a pull request! It's one button away (the wee edit pencil).
&gt; I don't know the exact figures, but I'm willing to wager that a large percentage of web accessible PHP apps are on shared hosting servers. Servers where users don't have root access to update PHP (nor would they necessarily know what to do if they had access). Some shared hosts let you choose your PHP version, though.
Doesn't look more clean at all. Just some wrapper which probably makes the catching of errors more complicate 
Vulnerabilities are detected when you run `composer update`. As for the DB, we currently compile conflicts from https://github.com/FriendsOfPHP/security-advisories: report issues there. More security advisories feeds will be factored inlater on. I will also send it to the OWASP org: thanks for the hint!
I'm not sure I agree with this assessment for two reasons: 1. The examples provided illustrate where and how this can reduce typing the same code over and over again. If you need to use PDO features, just use them. No methods were overwritten. 2. How will this make "the catching of errors more [complicated]"? There are no try-catch blocks anywhere in the DB class description. A PDO exception will still be raised. Am I missing something?
Did you end up switching to the Packers?
From my point of view these examples lack error handling. Because they are just examples. I don't see where I can add error handling, because the whole processing is encapsulated in some alias. I could catch several different exceptions by putting the foreach loop in a try block, but I don't like that. It all comes down to preference. Maybe this is good for a small site like a blog, but for me it doesn't bring benefit. If I have to type code over and over again, then I made a design flaw. 
Install php5-fpm instead of whatever you're installing (also, 5.6 isn't on any official ubuntu repo that I can find).
I'll give that a shot right now, Thanks For your answer!
No need to be sorry 
This could be really useful if they expanded support for more complex nginx configurations! Still really cool, though.
&gt; Accounting for a whopping 45.9% of all PHP installs, 5.3 hits big. That's so irresponsible that I can't help but want to slap each and every single host and system admin that pushes for this. 
Playing Devils advocate here: backwards incompatibility is a bitch and she has most companies by the balls. 
I knew this was going to be running on ubuntu. heh.
Have a look at this: https://github.com/magnetikonline/dockerbuilddeb Will produce PHP-FPM and CLI for 5.6 as a deb package easily installable on Ubuntu 14.04. You can then back this onto Nginx (either from repo/source build). Getting PHP 5.6 from official repos for 14.04 I don't think exists. 
Why is anyone using them compared to DigitalOcean. A 5 USD/month VPS provides a stack that can be "Almost" fully controlled. 
&gt; A PDO exception will still be raised. Actually, no it won't, since PDO doesn't raise exceptions by default. Since your class doesn't pass through the error values PDO produces, well...
Your repository has inconsistent tabs and spaces.