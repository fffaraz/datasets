Ocramius does it himself [here](https://ocramius.github.io/blog/when-to-declare-classes-final/)
&gt; No. No. No. No. OMFG NO. this
Drupal, Craft, Expression Engine are all better and more popular (a lot more resources). Hell I'd rather do wordpress over Joomla!
&gt; it won't even show as a "change" Unless you use Chef, Puppet, etc. to configure your environment.
 Monolog ( https://github.com/Seldaek/monolog ) which can be configured to output to STDOUT and STDERR. Most of the time the application should be configured to write logs to the file system in a specific folder or remotely. If you go with a 12-factor app ( http://12factor.net/ ) then writing to STDOUT/STDERR of the server is somewhat expected. This allows the server monitor (ex: supervisord) to write logs elsewhere.
urgh
Finally, I can hear how to pronounce `T_PAAMAYIM_NEKUDOTAYIM`
It's the slides for a talk, not really a web page.
Not necessarily. In his first example he extends the base controller, whereas in his rewrite the base controller is injected. This way both classes can be sure that the "fragile base class" scenario cannot happen.
That's why you provide interfaces which act as contracts and basic implementation classes for general cases. You're not meant to extend the classes, but make your own implementation of the interfaces if your case is not the usual one.
&gt; ...})(...$wagons); could anyone explain what far are those last brackets? how to read this, i am totally lost. anonymous function is an object and brackets are to push argument to its construct?
Of all the filler and pop culture references in there, one was missed in the beginning. https://youtu.be/l1YmS_VDvMY
The "rule" says to "favor", not rule inheritance out. The talk says to rule it out because this is "extreme" on purpose. Just like "never use goto/service locator/global variables/…", these are extreme rules so that people remember them. It doesn't prevent to do some critical thinking.
No. Just no...
The proper way to do it: $handler = ExceptionHandler::register(); $handler-&gt;setHandler(callable); Where `callable` is a callable (dûh!): http://php.net/manual/pt_BR/language.types.callable.php An example: $handler-&gt;setHandler(function ($e) use ($logger) { $logger-&gt;log('An exception has occurred: ' . $e-&gt;getMessage()); });
Last time that i tried Joomla i was not impressed. If you want to just slap a nice design on your site with a pre-made theme i would recommend either Drupal or Wordpress. Heck, there are even pre-made designs/templates that are not made for a specific CMS, you could just yourself in Laravel if you want and slap a theme on it.
I am a laravel developer. I ve just taken on a large joomla site a freelance. I hate life.
Typehinting removed, even though it's kind of a moot point, since the ExceptionHandler component typehints on the `handle(\Exception $e)` function..
In essence: $this-&gt;wagons = array_map(function(Wagon $wagon) { return $wagon; }), $wagons); I think the example given is more complicated and clever than it needs to be, reducing readability. But it's just forcing the typehint on each element of the array. Lacking native syntax for this, I prefer something like [`assert_instances_of`](https://github.com/phacility/libphutil/blob/master/src/utils/utils.php#L524) since it maximizes readability.
If you're not seeing a doctor for regular checkups, you should start.
And yet haven't been promoted to management. Go figure.
We have a Herlock Shomes here, huh. :) Can you guess what I had for lunch.
Something within your budget.
That's correct. It *was* within my budget!
Hah, at first I thought the title was "Extremely Defensive about PHP". I'm so sorry, everyone.
thank you, now all is clear :)
That page is really out of date. Here, read this: https://docs.joomla.org/Inserting,_Updating_and_Removing_data_using_JDatabase
Press the right keys, and you get the page index. It uses reveal.js so check out the cheat sheet for that. Also in chrome you can add a parameter to get a pdf version that can be easier to flick through. On my phone, so can't remember exactly what it is. Edit: [this link in Chrome](https://ocramius.github.io/extremely-defensive-php/?print-pdf) then "print" to save as a PDF. A 107 page PDF. A 10Mbyte PDF.
I love immutable objects, but unfortunately they're kinda clunky to design right now in PHP. Either you initialize from the constructor and it's frozen (optionally using a Builder object), or you go wild with the withFoo() pattern that clones on every call (see PSR-7 for an example). A more natural way of working with value objects is objects with copy semantics, like arrays work right now. Java will be getting native value types that'll be mutable, but have copy semantics, so all the benefits of immutable without the associated manipulation issues: http://openjdk.java.net/jeps/169 Swift already has value types (and they even use copy-on-write for collections, *exactly like PHP's arrays!*). Maybe PHP also can have value types... one day. I mean, that's how objects worked in PHP4 already, so why not.
Though I have not even tested PHP7 yet, but how exactly is this supposed to break on it? Exceptions replacing all kinds of errors in PHP 7 will implement Throwable interface and not extend \Exception class (https://wiki.php.net/rfc/throwable-interface). Or maybe I understood the whole issue wrong; I have just got up, I admit.
Drupal is trying to become the most sane of these CMS systems by moving to using Symfony components. From what I've seen, the Wordpress core is coded much better than Joomla, but that's not saying much. Having said that, I do not like working on Drupal, Wordpress or Joomla sites at all.
Yeah, I spent a lot of time on this recently. I second using unoconv (or headless Libreoffice on its own if you want a pure repo installed solution on something like CentOS). Every PHP based PDF generator I have ever used has been one big compromise - poor output, bad performances, usually both. 
Agreed. People introduce bugs to code... code doesn't introduce bugs to code. The harder code is to understand and use, the more people are going to use it improperly and introduce bugs.
I write to php_value error_log in webserver config.
&gt; It's the C++ of CMS's No that would be Kentico. &gt; What makes wordpress better than Joomla It's not as customizable out of the box, but the plugin ecosystem is several dozen orders of magnitude better, and despite still being a terrible codebase to work with, it's simpler and better documented than Joomla's. The interface is simpler to use as well, plus there are a bazillion themes you can just slap in there and have a reasonably decent responsive site up and running in no time (provided you're happy with what you get - if you're not, customization is going to be a we bit painful, but not as painful as Joomla).
As much as I enjoy working with immutability in Erlang, PHP just doesn't seem to fit it. If you're going to write: A = A.changestate(whatever); How is there a practical difference between having the changestate function actually change the state, and return a new object? You could of course ban yourself from using the above construct, but you're then forever just reliant on promising no developer in future will make a commit that violates your code style. The interpreter can't take advantage of this. Rails gained a lot of micro-optimisations through use of .freeze, which makes a variable immutable. The interpreter knows it won't change and thus doesn't mess with copying data when passed into a new scope. The proposed solution here doesn't offer that. 
If that's true, kinda makes for a really bad talk. 
There were some pretty interesting dockers interviews on YouTube that triggered my curiosity. How did you started up with dockers? Do you used a certain guide?
you make a class `final` when you don't want people to extend it, it's simple really
Restart the machine or the process that is running php ( apache, fpm, etc ). A lot of time with Linux a program will still hold that space until it's killed off. I forget all the technical crap lol 
&gt; The PHP community has its fair-share of devs struggling with alcohol ... wat? 
I agree, Drupal 7 isn't the most modern CMS in the world but if you know how to work with it then it's not that bad actually. But Drupal 8 is to release soon and it's a big improvement, you still need to know quite a lot tough to use it the right way. I would say Wordpress is better because there are great plug-ins and themes available, and IMO it's got a much better administrative interface than Joomla.
It's a neat idea, but I've had cases in the past where Immutable objects simply were not going to work. So what if you have setters? So what if you have multiple ways to change or grow the class? Standardized testing can handle complex situations.
One could probably have "setters" but not setters, make several methods that returns a new object with another state. That method is setter-ish since it kinda works as a setter except it doesn't set anything and returns a new instance instead. I'm more worried about dependencies, I'm deep down into dependency injections at the moment.
That's completely right, and one of the most sensible answers I've had in this thread :)
The goal: to enforce the `$wagons` array only has instances of Wagon (typehint "Wagon[]" in many other languages). The way this works is [common in JavaScript](http://markdalgleish.com/2011/03/self-executing-anonymous-functions/) and it's just an anonymous function that is immediately executed.
I've been out of the WordPress loop for a bit more than a year, but have you looked at things like [Themosis](http://framework.themosis.com/)? How is Freya different to that? I fully understand why you want to abstract WordPress, honestly, I did the same when I worked with WordPress. While I feel WordPress is a good solution to certain problems I'm glad I don't have to work daily on those projects anymore.
&gt; Share situations where you find extending a class indispensable, and I'll share what I'd do instead. I'll take you up on this, even though the original person you posted to didn't. I'm interested in seeing other ways. * I'm making a library for EWS with SOAP, and I've auto generated objects for every type of item/message/request that can be passed to and from the server. That way when you ask for a CalendarItem, you get an object with methods pertaining to that. I've not made them final so that when someone is consuming my library they can extend my objects and override the classMap, so that their extensions are returned. This allows consuming applications to add specific methods for their use cases (Such as "fetchAllAttendeeEmailAddress"). How would you approach that? * Likewise, for the object generation, I've had to find a library that would read the xsd files well, get all the types and generate objects. Because the output was different to what I wanted, I needed to override a couple of methods that I knew what they did and how to modify them. So I extended the classes I needed. Sadly, all the internal methods i needed to change oh so slightly were private, not protected, so I ended up having to copy and paste even the methods I didn't need to change just to access them. How would you have approached this? I did consider forking it, but I wasn't really keen on maintaining the library I'm interested in your thoughts on this
Can someone enlighten me on how to properly unit test code containing final classes? You cannot create a mock object of final class, thus disabling the whole "test single unit in isolation" point of unit tests. Is there a workaround I do not know about?
If you control the server then I would suggest you are using the wrong tool for the job, nagios or similar would be better to give you an overview of your hosts and services. However if you still require it to be PHP and you want to find if a server on a particular IP is up, ping is the best way. There's a complete example [here](http://php.net/manual/en/function.socket-create.php#101012).
Nice explanation, cheers
Huh, does that work without root?
I've found it already and it looks like it was designed to be used along with it's front-end part. I won't use it but thanks anyway.
The logging strategy depends of the environment. For development, most will prefer to to store logs in local .log files (something like Papertrail is still good though!), while for staging and production, it's recommended to store them in a dedicated logging service such as ELK, Loggly. Monolog (already mentioned) is a MUST have.
&gt; What happens of the host is also dropping all ICMP packets? Then this host is considered as not alive. Simple as that. It's up to the host to play by the rules otherwise it will be excluded.
Just because something is newer doesn't automatically make it better. If you think javascript slideshows are better at conveying technical information then good old text, then argue and articulate *that*.
You redirect any non-existing file/directory to your front controller in your web server config. You match a route in your front controller, throw a 404 if you get no match. I fail to see what you're asking?
Yes, you failed to see it, that's the easy part. There's a router client and server side and if no route matches, the default `index.html` (the app) is delivered and does the routing on the client side: https://en.wikipedia.org/wiki/Single-page_application
Every "API" route has to be declared beforehand $app-&gt;route('POST','/user', 'UserController::create'); $app-&gt;route('POST','/login', 'SessionController::login'); $app-&gt;route('GET','/comments/:id', 'CommentController::get'); and so on. All of them perform some validation if needed, do their thing and output status 200 + json response. Of course if validation fails you may return 401, 403, 404 and 500. For example getting a non existent entity might be treated as a 404 (since the entity was not found) or 500, since the ORM might treat the its non existance as an exception. Then the last route is a catchAll for every GET request to an undeclared route pattern: $app-&gt;route('GET','(/:whatever)','FrontController::get'); Request of type POST, PUT, DELETE to undeclared route should just return 404. In FrontController::get you render a basic html structure including CSS and JS. Now, **this JS should be in charge of your front routing**. You see, both GET '/home' and GET '/about_us' will render the same basic html. Your **JS router** will then take control and decide that 'home' fills the main div with certain content whereas 'about_us' fills it with another content. There are a lot of routers for JS. You can roll your own using location.href, but I normally use Backbone's router: var WebRouter = Backbone.Router.extend({ routes: { "about_us":"aboutusRoute", "home":"homeRoute", "post/:id":"postRoute" } homeRoute:function() { ... } aboutusRoute:function() { ... } postRoute:function(id) { ... } }); var webRouter = new WebRouter(options); Backbone.history.start({ pushState: true, root: '/' }); You see, certain routes will eventually lead to a request to your backend, but only your front logic with deal with any backend logic that isn't the front crontroller. **Edit** you need to return 200 when retrieving a json response from the backend. You may use robots.txt to disallow search engines from indexing non-front urls, or you can include a header in your ajax requests so the backend can validate that it is the front who is asking. This header can have the form of an Authorization token generated when you log in. To fill the content of every front route there are several tools. You can use jQuery to append plain html, you can use underscore templates (since it will be already loaded because of Backbone). I personally use Handlebars for this task. I hope it helps. 
If no ports are open you'll have to ping it (assuming it responds). There are libraries to do this, such as https://github.com/geerlingguy/Ping
I think running experiments is awesome and commend the effort. I think he will learn a lot from this. He will learn about PHP, frameworks, the right tool for the right job, retrofitting and any more things. Whether it will be of utility in the wild is a different story, but these adventures can help shape one's career. I would advise against squelching them. 
yes I totally agree with what you said but he's actually doing it to "ease his pain" working with wordpress everyday, at least that's what I get from reading his posts here and in /r/wordpress, hence my suggestion but sure go wild do what you want it's all good
The only thing that turns me away from reading a blog post is a bunch of memes. Memes should be treated like sugar and used sparingly. 
1. datomic is no SQL database. You has a "fat" client that performs a lot of logic and can thus synchronize each change to an object to the database. (in fact, the key-value-store) 2. The identifier seems now to be the id+timestamp. So whenever you change a property, a new entity is created and returned. But this requires tight coupling of the entities to the database storage (active record-like). Data mappers try to avoid this. 3. I haven't even found a single hint datomic is available for anything that does not run on a JVM. So I don't see why this very special niche Java case is relevant here.
I believe most of the CMS out here will store some information in database. Is there any CMS you know which don't save configurations in database?
Note that for PHP the "RC" suffix means pretty much nothing. It isn't actually a candidate for release, just another preview release with a different name. There are six RC releases planned.
Note that Ocramius is quite clear about when you should make a class final: If it implements an interface and provides no methods beyond that interface. As such, if you make a class final, there must be an interface you can mock instead. If this condition is not met, you should not make the class final (as a rule of thumb).
I'm very curious about this as well because that behaviour does not seem correct at all. I've noticed related weirdness when using &amp; to reference the value in the past and as a result I just don't use that feature anymore.
This is some weirdness with using the same reference names in multiple foreach loops. The correct thing to do in this case would be to unset the referenced variable after the loop terminates. Adding a unset shows the expected output: https://3v4l.org/uYaNp Check out the foreach manual page at http://php.net/manual/en/control-structures.foreach.php (see the warning box). Hope that helps. 
There are a bunch of attempts to explain this phenomenon here: http://stackoverflow.com/questions/3307409/php-pass-by-reference-in-foreach I just don't use that pattern, because its implementation is so unintuitive.
Does anyone actually write loops that way with a reference?
Yes, just take a look at the code from the company I used to work for. Then again, they're also the people who store all passwords in plain text and display them for every person in the admin area (on their own employee site and on at least one of their client sites). I still have nightmares.
You said you control the IPs in response to a question about ICMP packets being dropped. This implies you have root access to manage the firewall settings on the server. As you are now suggesting you don't have root I'm curious how you are managing which packets are dropped and which are allowed through? The simple answer to your initial query is to follow the consensus of the thread and use ping.
Do you have a valid reason for this? It seems very opinionated. The "WordPress" way is a mess. Its unsustainable and unscalable.
why even use vagrant ? just use docker.
Experiments like this are pretty important though. At some point Wordpress is going to have to migrate away from the "Wordpress way" because of code quality reasons, and at that point they aren't going to want to have a BC break with tons of plugins and themes. If they can wrap up two ways of doing things, best practice versus legacy, then they'll have a good business case to proceed.
Yep — that's really been the case since beta 1 anyway, but the rule gets applied extra hard from here on out.
It may seem wrong, but it's actually correct. You just have to understand what is going on! [Read this](http://stackoverflow.com/questions/3307409/php-pass-by-reference-in-foreach)
I'd need more detail to give a competent comment on your use cases. But we need to differentiate two distinct type of objects, which in modern OOP languages, are unfortunately both "objects": 1. Actors (i.e. "real" objects): true "entities", but not just value objects that have a primary key, but objects that encapsulate their own lifetime, persistence, and have a well defined public API (example: local &amp; remote services). A good indicator of an object in that category is that it wouldn't make sense to "serialize" it. It exists at a specific location, has a specific purpose, and you communicate with it through local or remote messages (be it method calls, command objects, Unix pipes, sockets, etc.). 2. Messages (transient data structures for communication): light, serializable, value objects, command objects, DTOs. These are used as a means of communication between actors, they don't represent any canonical truth about the state of a system, as they're just "snapshots" (for ex. having a user entity object that came from an API response doesn't mean the actual user still exists; you're looking at a message containing a snapshot, a representation of a user only). Alan Kay strictly differentiated objects from messages in his definition of OOP, but over time we've lost that distinction, which I feel is a major source of confusion when people discuss best practices in OOP. In OOP we talk about combining state and behavior, to create a well encapsulated, consistent object with hidden state expressed only through behavior. This works great for actors, but is, in my opinion, a really bad idea for messages (DTOs). Due to their nature, messages of the same kind are produced, seen and passed through many layers of your application, and many applications. Behavior can't be sent over the wire, only data can. And if we start adding complex behavior on a DTO ad-hoc everywhere, we get conflicts, where different layers of an app want to see and operate with them slightly differently, or even worse, we duplicate behavior from app to app, because every time we serialize a DTO to send it to a remote location, we strip all behavior and pass only data, so the other side has to replicate the behaviors locally, and we risk losing our "single source of truth" regarding how a piece of domain data should be operated upon. I try to treat message objects as "dumb data", I don't extend them, I don't add behavior to them, anything beyond the imperative minimum for defining their data structure, to generate them, read them and transmit them through various media. I concentrate almost all behavior and logic at the canonical repository for a given type (a remote service that holds the entities). As messages pass from application layer to application layer, they'll also often need to be transformed into a locally consumable format, so I use extensively the Data Mapper pattern (it's not just for SQL and ORMs, hehe). If I detect I have a local concern, a local behavior I want to add onto a DTO, I don't extend or replace its class at the point of deserialization, I instead leave it be (this means no need to touch your XSD code generation library) and when it crosses into my layer, I read the original object and map it to another object has this local format and behavior (and, of course, on the way out, I map it back to something the XSD library can use as-is; the remote service that receives and validates those DTOs will have the final say if I botched something in this process). I'm sorry if this is too generic, I don't know enough specifics to be more clear about my PoV.
* [TDD: Where did it all go wrong? by Ian Cooper](https://vimeo.com/68375232) * [Making Badass Developers - AKA how to make documentation not terrible by Kathy Sierra](https://www.youtube.com/watch?t=27&amp;v=FKTxC9pl-WM) EDIT: Ben Orenstein is explaining refactoring like a god. So clear. This talk is amazing. "Im vimming too hard".
Nope, ``$this-&gt;wagons`` will be an array of ``Wagon`` objects. The brackets are to invoke the closure.
seems like the &amp;$value variable jumps out of the scope of the loop, if you do the second loop with $valueAlt insead of $value it seems okay, also here's the output of print_r on the array in every iteration of the second loop: Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; a ) Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; b ) Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; c ) Array ( [0] =&gt; a [1] =&gt; b [2] =&gt; c [3] =&gt; c ) 
Silex might be an okay option but I would generally just prefer to use something like Klein PHP (which handles routing) for Restful API'S and just add components as I need them via composer . Symfony (the framework) has a lot of things you won't use or need. 
Probably shouldn't be encouraging users to run PHP7 just yet. PHP advises not to use the RC's in production.
True but I was thinking I could basically gut the templating and doctrine and use it like Silex, but I guess at that point I may as well use Silex right?
Please have a look at Restler PHP. It has some build in components such as versioning, xml and json support, 201 Created response etc, oh and REST Explorer.
https://github.com/phptodayorg/php-must-watch And also: - [Gojko Adzic - Specification By Example](https://vimeo.com/109079233)
How is that the desired behaviour? I understand what's going on, but it seems like a straight up bug. The $value in the second for each declaration should create a new variable scope. Variable scoping is something I feel PHP gets horribly wrong.
As much as I'm all for getting around the hodgepodge of bullshit that is Wordpress' codebase, I think /u/teuna is correct. **Edit**: But his comment should probably read: &gt; I honestly think you should stick to the "Wordpress way" or if you hate it that much look for another ~~job~~ framework First and foremost: Wordpress is not an MVC framework. In fact, there really is no rhyme or reason to Wordpress' internals, apart from tacking on pieces of functionality and committing to retaining backwards compatibility as much as possible - often to the detriment of speed and security. Even the database schema doesn't follow the kind of practices every modern database should. What you get out of Wordpress is a low barrier to entry for clients. Clients are the ones who are often driving the content of their site, and having a UI that feels familiar, makes sense, and has a strong community driving its extensibility through the use of plugins is what appeals to clients the most and contributes to why Wordpress is still the buzzword of the year. To the client, they don't care about the codebase. They just care that it works, and that it's *easy*. That's really what Wordpress is good for. When picking two out of "Fast, cheap, and great" - "Fast" referring to the length of time it takes to bring a project to production - Wordpress has "Fast and Cheap" covered in spades. Bear in mind that this is at the cost of speed, security, and modern coding practices. But if the client doesn't want to spend the money on "Good", then it's likely that a project manager won't care about writing a "good" application. Trying to write a maintainable codebase on top of something that itself is unmaintainable is an exercise in futility, so more often than not developers will work within Wordpress' own confines to meet tighter deadlines. It's unfortunate, but if it *works*, then that's all the client and the project manager cares about in the end. Shoehorning an entire framework into something as ungainly as Wordpress only adds more overhead, and benefits the wrong party. **tl;dr;** Any application of sufficient complexity that necessitates the use of an MVC pattern is best *not* written in Wordpress. It's the developer's job to know which tools are best to meet the needs of the client, and if the developer is using the wrong tool, then the *developer* has become the point of failure. Not the framework.
PHP 7 RC is only made available there so you can candidate-run it, not run it. :P
You would think, but no, its not the user. Lots of other people I know have had problems. I have run into issues on several different computers/versions of windows. 
The only thing I could see Symfony being useful for vs Silex would be including the serializer component. You could pull that into Silex easily enough, however. Or use another [normalization layer](http://fractal.thephpleague.com/).
Yeah I've actually heard of people using the serializer before but I still don't exactly grasp what it does above simply sort of json_encode((array)$object); into an object, and even that I've head [serialization in general] is a bad practice because it make your objects resistant to change (especially if you're doing things like storing serialized items) 
The serializer in symfony normalizes and encodes objects to different formats (JSON, XML). Normalization is the more interesting of the two. Fractal's docs (linked above) has a good explaination of why in its *Goals* section. You create a barried between stored data vs what's output to the API -- makes your API more resistent to change in your entities. If it's a tiny API this stuff probably doesn't matter.
The joomla code has improved slightly but it is still shit. The DBAL is the worst I've ever seen in any framework. The joomla devs are garbage. Most of the extensions are coded horribly. The documentation is non-existent or terrible. I hate to admit it, but WordPress is much nicer to work with. The crap in WordPress has a much less cognitive overload where Joomla is in an order of magnitude greater in crap. Btw, even if you wanted to improve Joomla you couldn't because of the snooty devs. They would not make core changes to the DBAL even though it was pointed out it was crap years ago. You'd wake up to seeing your SVN account banned and your changes revoked.
my production setup is always Linux. I can build a docker container that includes all of the software I could have in the vagrant box - makes no difference.
Does anyone else here use PHP on SLE / openSUSE? I believe no official packages for it exist yet. Does anyone have enough experience to build it?
 &gt; First and foremost: Wordpress is not an MVC framework. Freya is not an MVC framework either, it is a layer of abstraction to help bring more common php practices to developing themes and what not. It is a thin wrapper among common functions you use or encounter when developing themes and plugins. This allows for a more modular, component based theme with parts that can be reused in other themes. &gt;To the client, they don't care about the codebase. They just care that it works, and that it's easy. You are right they don't, good thing Freya isn't for them ;P. Its for developers who treat PHP as a "Scripting language" when its more then that today. Its also capable of creating some very clean architecture. Have you ever tried to modify a theme in a child theme? Have you looked at some popular themes code bases? They are disgusting and a nightmare when you try an debug them. Freya helps you weed out the logic from the view, create appropriate classes and use factories to create those classes on the fly. It creates routes, views, partials and a more "modern" way of writing code with out having to learn a whole framework. The client might not care but the client is also the one who sais "add me this feature and that feature and that other feature and this stupid thing that no one cares about but me, oh and add me ecomerce." Now while there are plugins and other technologies for this, should you choose to code these your selves, having a framework that helps you with the fundamentals is a lot better then the creating more of the "mess" thats out there in relation to plugins and themes, which there are some severe security vulnerabilities out there. Have you ever tried to write unit tests for your theme? Again Freya allows that because of some of the assumptions it makes when you are developing. &gt; Trying to write a maintainable codebase on top of something that itself is unmaintainable is an exercise in futility, so more often than not developers will work within Wordpress' own confines to meet tighter deadlines. Not if the framework is with in the barriers of WordPress. Everything you said i that last sentence is a complete lie and Freya proves it to be a lie. Freya is not a Web Framework, it is a component based framework that has components that are thin wrappers around custom used aspects of WordPress. The non WordPress related components help to create a sense of common practice. They also help to bring some additional features you may or may not find useful. Because of its component based nature, you can use one or all components. Composer is also a heavy thing here. &gt; It's unfortunate, but if it works, then that's all the client and the project manager cares about in the end. Until those people go on to a "real job" where there programming skills are put to the test and they create classes that echo out HTML. ya i would fire those people in a heart beat. PHP is so badly abused by theme developers because of this excuse that a client wants x for y in z time. Building anything should be about using the tools properly, taking the time to make sure the site works and taking into account that the client may want to add ore features down the road. It should also be about building components of the theme or plugin such that you can use those components in other themes or plugins. &gt; Shoehorning an entire framework into something as ungainly as Wordpress only adds more overhead, and benefits the wrong party. I disagree, considering that Freya is a series of components where you can easily drop them into any theme you are currently developing or starting to develop is not "shoehorning". &gt; Any application of sufficient complexity that necessitates the use of an MVC pattern is best not written in Wordpress. Freya, again, is not an MVC framework. It is a component based framework that is a thin wrapper and set of abstractions around common used WordPress functions to bring OO based concepts to theme development. At the end of the day both of you are wrong. Anything that helps make a WordPress theme developers life better and allows them to create themes faster, cleaner and more modularized is good for the community. If we can foster better practices in the community it will then leak out to other corners, like WordPress where you have these "hackers" and "script kiddies" who (again not all people fall into this) have no idea how to program and just throw mud at the wall until something sticks. 
Excuse you, but I was detailing out a school of thought that focuses on business practice and not coding practice. Now I apologize, for whatever reason I had read "MVC" somewhere in your post, but apparently I had misread that. I wasn't attacking your hobby framework, so there's no reason for you to get salty over it. If you don't want feedback, don't ask for it. Or would you rather I pat you on the head and tell you your framework is special and unique over all the million other ones people are peddling these days?
Maybe the Wordpress code is a mess (I haven't looked at it since way back) but the "Wordpress way" is actually pretty damn well documented and have been used by thousands successfully worldwide for many years again I'm not saying to stop doing what you're doing and /u/no_not_me make a valid argument below the point is I'm guessing you *have* to work with Wordpress because it wasn't your decision right? The people who asked you to build them a wordpress site/app did so because Wordpress is popular, easy to use on the backend for content writers, it has tons of documentation available, tons of plugins/modules, tons of themes. but most of all, It is very easy for a company to look for a "Wordpress developer", there's so many of them... What you are shipping them is not really Wordpress, sorry. Maybe it's *better* but still not Wordpress, if for whatever reason your client decide to let you go the next "Wordpress expert" they hire will probably have a lot of bad things to say about you, maybe he'll be wrong and you'll be right, it just wouldn't matter at this point then again maybe I'm wrong and your client decided to go with Wordpress because of the hype around it among executives / managers or because company's boss son told dad that Wordpress is the "best CMS/Framework ever" but good luck to you and building a community around your project
&gt; I wasn't attacking your hobby framework, so there's no reason for you to get salty over it. Apologies if you took my post that way I wasn't getting salty or trying to come off that way. I was mearly explaining that Freya does not attempt to be MVC in any way. It tries to be a series of components where some do and some don't depend on WordPress. it is a thin layer of abstractions that keep with the concept of what WordPress does, but also allows you to build better solutions that can be maintained. &gt; If you don't want feedback, don't ask for it. Or would you rather I pat you on the head and tell you your framework is special and unique over all the million other ones people are peddling these days? I appreciate all feedback and criticisms. As or what makes it special is that fact that it doesn't try and be anything its not. if you use the whole framework it imposes some concepts and best practices, how ever if you use components of it in your theme or even out side of WordPress it helps you to abstract the mess of some code systems and some themes and plugins into something more manageable and clean as well as modular and testable.
If you want a CMS try [Bolt](http://bolt.cm). It pretty much eliminates the need for plugins.
No.
I'm not surprised. 
Slim was originally for python right? How is the PHP version?
Drupal is a complete pile of dog shit. It requires you to un-learn every good practise you have ever learnt as a programmer.
That sounds interesting. If random people run into problems with various challenges, feel free to PM me. I like helping fellow programmers out. I'd say I'm intermediate to advanced, I'd join your quest for knowledge once the challenges become less of 'oh yeah, I did ______ to do that' - for me.
[Ross Tuck's *Models &amp; Service Layers; Hemoglobin &amp; Hobgoblins*](https://www.youtube.com/watch?v=ajhqScWECMo)
This is more of a javascript question, but you should end up with something that looks like this: &lt;script type="text/javascript"&gt; var lng = &lt;?php echo $lng; ?&gt;; var lat = &lt;?php echo $lat; ?&gt;; // initialize gmap with js variables &lt;/script&gt; 
Writing JavaScript with PHP? Ew. This should be done with AJAX
Hey Jesse thanks for the help. What I'm more stuck with though is how to display the specific members details once they're logged in. So far I just have a "welcome (username).." and a log out button and a generic map. I just need to be able to post the member that's logged in's other details in the nextrow of their mqltable if you get me.
I don't think an AJAX request, which will introduce an unnecessary extra request to the server, has to be used. And I don't find anything particulary ugly with writing JS variables directly from PHP into scripts to some template, as long as they are properly escaped before doing so. 
Hey it's ok I have the map set-up where I just need to get the address (stored in the next row besides the users username and password in the database table) and $_Post it into a div in the map. I'm trying to figure out how to post the stored address of the specific member that's logged at the time. Sorry for the confusion.
Hmm - I am actually more confused now. It sounds like you are unable to query your database for the correct information... Select GOOGLE_MAP_URL from YOUR_TABLE where user_id = "CURRENT_USER_ID". Hmm after typing that Im curious if you are putting your user_id variable in quotes. Can you put the sql that you are attempting to put in an echo statement, copying it into your database's sql area and actually see if the results is populating instead of getting errors? Do not put your sql query here. Database stuff I don't trust with anyone.
This. I would always stick to something youbare comfortable with. What's the point in using some fancy framework that everyone has to get in to first. This part should always be part of RnD. If you go for yourself and have nothing to lose, test out other stuff. Do a hands-on. You might get the feeling you desire
I think openSUSE uses epel and yum?? like CentOS, if so then you can use [webtatic](https://webtatic.com/news/2015/08/latest-updates-in-testing-38/) to get php7, or build it like you would any other php version. I have used both ways, it's dead simple
&gt; Maybe first step should be just PHP in CLI and writing FizzBuzz etc.? Yeah, if you want to be boring :P Just kidding. But the value of PHP is making web pages, so there's no harm in playing with that. It'll keep their motivation strong and they'll learn a lot more, than pretending PHP is the Pascal of 2015 with exercise command line apps. It really isn't. It's far more interesting, I think, to code a simple contact form, and stuff like that. It's actually useful! :)
That's great to hear – make sure to subscribe to the subreddit so you don't miss that point! Also, if you want to help us create more engaging and diverse challenges that are interesting to both beginners and intermediate coders, we would greatly appreciate your input! You can join the conversation here: https://gitter.im/Gin-Chan/phptogether
I think what you're doing is interesting, and you probably should mesh more with WordPress core developers because I can bet you they're thinking about the day when they'll have to move from their current mess to a more organized and modern API. The only thing that make me frown is the extensive use of static classes. I can spot a Laravel user from a mile away with those. I realize in this case the statics may be necessary because you have no context passed to you with the necessary dependencies, and fetching them statically is convenient. But this will limit severely the expressiveness of your API going forward. Read about how frameworks use Inversion of Control (IoC) to provide encapsulated environments for plugins and extensions (a great fit for WordPress).
A better practice is: &lt;script type="text/javascript"&gt; var coords = &lt;?= json_encode(['lng' =&gt; $lng, 'lat' =&gt; $lat) ?&gt;; // initialize gmap with js variables &lt;/script&gt; Less context switching (one echo, cleaner) and proper data encoding for the context.
inb4 ninja syntax : I kept it obvious and simple for the noob
&gt; I think what you're doing is interesting, and you probably should mesh more with WordPress core developers because I can bet you they're thinking about the day when they'll have to move from their current mess to a more organized and modern API. So I posted this here to get ideas on the framework as opposed to the concept of WordPress. &gt; The only thing that make me frown is the extensive use of static classes. There's only one ... Routes. Which is being converted in 0.10.0 &gt; I can spot a Laravel user from a mile away with those I have never used Laravel. &gt; But this will limit severely the expressiveness of your API going forward. There, again, is only one - Routes. &gt; Read about how frameworks use Inversion of Control (IoC) to provide encapsulated environments for plugins and extensions (a great fit for WordPress). I am interested in IoC and in the sense of Freya there is no room for it. That would take away from the concept of the thin layer of abstraction that Freya Presents. It would add uneeded complexity. So instead I wrote [Freya Container](https://github.com/AdamKyle/Freya-Routes) which is essentially a factory. It does not try to be DI or IOC but instead is a factory pattern based concept. The goal with Freya was to create a thin layer of abstraction over WordPress such that you still understood what was going on under the hood. Freya is a component based framework and a modular based framework. This means you can use Composer to get what you need and only what you need. Freya is opinionated when you use the whole framework, but not so much when you use the individual components. I think IOC as a whole would be over complex for WordPress, hence Freya Container. Thanks for your input - I look forward to more in the future :D 
openSUSE uses zypper, although I'm not sure that's a frontend for something else. I don't think yum commands work.
[Your Password Complexity Requirements are Worthless](https://www.youtube.com/watch?v=zUM7i8fsf0g)
&gt; I have never used Laravel. - In your own thread post up here you say you use Laravel. You also compare Freya to Laravel in your linked description. - Someone else spoke about MVC in this thread, and you said Freya is not a MVC framework, and then in your description you say it's a "MVC-like framework". - You also say there's only one static class: Routes. Then your own tutorials in the Freya wiki it's littered with static calls to \Freya\Factory\Pattern, \FreyaTheme\AssetManagement\AssetHandler and others. The jig is up. Now the only question is... why did you murder /u/SavishSalacious and where did you hide the body?
Status codes don't have semantics? 200 is for those requests that are okay and 404 for those that cannot be found, you shouldn't change that. Instead simply do a redirect for the pages that aren't part of the SPA and treat them as external?
I've had a similar idea, never implemented it. HTML5 includes client-side form validation rules, you could parse and enforce those on the server-side for simple validation: https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Forms_in_HTML Interested to hear if it's been done or if there's a reason it won't work very well.
This wouldn't work as the client could simply remove the validation (via inspect element), and bypass any server side validation. Never trust the client with anything, especially with what kind of validation rules you want enforced server side.
What the fuck?
Jesus
If you want a good inspiration how to reduce the form boilerplate code, look at [Nette Forms](https://doc.nette.org/en/2.3/forms) - you can either inspire by it, or just use it as a standalone package (last section of the page covers that), should you like the approach it offers :)
I see that makes sense. But in my case I am caching results from say a database. There would be no need for me to check if there it is stored first I should just try and retrieve them from cache and if nothing is returned then proceed to pull it from the database. Or would you still recommend I check if it exists first. Just for reference I am using Zend_Core_Cache in one application and Laravel's Cache in another.
All of the caching systems I have used (APC, Memcached, Redis) automatically clear out older entries when the cache is full, so I suppose I haven't had to worry about managing that myself. I guess with database or disk caching, this would be more of an issue?
I wasn't permitted to use any third party code as part of the test.
That's a great point, I don't normally store null values but i can see this being an example of why I would want to have a check in place if I was dealing with them. 
Memcache API returns a false since the cache can only store strings.
https://github.com/mikehaertl/phpwkhtmltopdf This is hands down the best one I could find when I looked for PDF solution. The only issue is it won't work on most shared hostings.
It's not a good idea almost universally. It's just a logical crutch people fall into. There may be a cache that has trouble identifying blank from non existent, if that's the case then adjust but memcache and the most common PHP caches don't have this issue. I would avoid it. I've profiled this pretty heavily with memcache and the check calls add up to meaningful time in a sizable app.
I don't care. I can run my app on my own server ;) Thanks!
http://www.fpdf.org/ was ok when I needed it
Ah, just to be clear. I'm referring to RCs for major or minor versions. For patch releases RCs are really release candidates and will usually be released as-is.
Usually RC also mean there are no unresolved issues/changes to be expected. For php7 we still have to sort out the exception related proposals though.
&gt; What I would rather do is resign APC(u) to the history books and provide a good cache ... but I'm scared that people will shout at me for dropping APCu, so as yet I haven't done anything ... I think you should drop the current API and create a new sane API. To avoid screaming people call that APCu version 5 (or APCuNG version 1 to avoid name clashes). But keep the current APCu version somewhat maintained so legacy code can still use APCu version 4 but new projects can use the new API.
I have one big project that is based upon FuelPHP framework. I would not recommend it, version 1 is terribly outdated (not even namespace support yet). Version 2 has been in development forever, and it seems to lack a community to bring it to a succesfull end. Another question, why would you write a cms on your own? There are a lot of existing solutions out there which most likely are enough for you
I think you haven't used a good validator library and you're trying to attack the problem in your own way, that's ok. But let's see what I was talking about: Form fields: &lt;input type="email" name="email" value=" foo@bar.com "&gt; &lt;input type="text" name="arrival" value="July 5"&gt; &lt;input type="text" name="money" value="$123.50"&gt; &lt;input type="text" name="something" value="001.00"&gt; Reading at the server: $input = (new DictFilter()) -&gt;add('email', new EmailFilter()) -&gt;add('arrival', new DateFilter()) -&gt;add('money', new MoneyFilter('USD')) -&gt;add('something', (new IntegerFilter())-&gt;setRange(1, 10)) -&gt;apply($_POST); What I get in $input: [ 'email' =&gt; (string) 'foo@bar.com', 'arrival' =&gt; (DateTime) 2015-07-05 12:00:00, 'money' =&gt; (Money) {amount: "123.50", currency: "USD"} 'something' =&gt; (int) 1 ] So, we can define the format at the server and get the same benefit. What's the benefit of defining them in HTML? What if the user modifies the HTML?
True, I was assuming a cache that can take more complex values
This one saved me a lot of times
I enjoyed this talk immensely
The most flexible solution I've ever found is to use html and then pass it to something like wkhtmltopdf. If you want an html to pdf utility with more bells and whistles (and it can handle tables something sweet) check out prince 
you can try Lumen
Thanks guys. I hadn't realized it was behind on its release cycle. With the plethora of cms' out there what is the most stable in your opinion? I've worked extensively with Drupal and Wordpress but Drupal seems to be dated and Wordpress has security issues.
What if they change the type. Eg changing Email to Integer and sending the value 1 so they skip any email address requirements?
Could you elaborate on the differences between this and something like rabbitMQ? 
Don't have enough experience with the *mq systems to do so. They've always looked a tad more complicated to integrate and work with and the simpler tier (gearman/beanstalk) has done pretty much everything I need in this category.
Drupal and WordPress are both fine. WordPress has a large attack surface - it does a lot of things - but if you stick with the core, keep it updated, and only add plugins cautiously you'll be fine. There are a lot of people looking at security issues for WP, which may not be the case for smaller projects. 
Do you use a specific protocol/standardization when sending jobs/payloads via Gearman to other systems? What's your preferred back-end runtime/lang?
It's also worth pointing out, that this really only applies when you're in a single server situation. When you start scaling out to multiple php front ends, having all of them need to recache data can, again, lead to cache stampedes (granted at a smaller scale, but still there none-the-less)
If you are writing html output using modern methods wkhtmltopdf is a godsend. 
Ya I've worked with laravel on a couple projects but it reminds me of ember for the js world for the fact that it's highly opinionated on setup and configuration. On that note is there a backbone(js) for the php world? 😁
This may be the route I end up going which allows for more freedom in constructing.
This is my experience. The other problem I had with html -&gt; pdf tools was that sometimes I would want to do something that was not supported well and would have to switch libs.
I recommend you add support for [Disque](https://github.com/antirez/disque/blob/master/README.md) as a backend. While it's still under development it's already much better than most solutions out there. I've used Gearman a lot (processing tens of millions of jobs monthly) but I'm moving everything to Disque now. You could use [disque-php](https://github.com/mariano/disque-php/blob/master/README.md) to interact with it. Disclaimer: I've built it
Klein is a router but Slim is a micro framework, which should explain the difference in speed.
Another cms could be the solution as well. Depends on its flexibility to scale.
Always, friend. Size of app is never a deterrent to veer away from best practice code development principles and techniques 
&gt; An Event Listener is an event listener. Listens one event, and that should be all its work. So, we should never inject any event listener, anywhere. This can become the lyrics to a very catchy song. I think the whole event listener concept in Symfony is quite overdesigned, and the "middlewares", bless their crappy name, are showing people an alternative and simpler way to do composition in a server app. My apps have no "events" at all (save for domain state events, as in event sourcing, but that's a whole 'nother kind of events).
rabbitmq only passes messages between systems. but it is fast as fuck. I just implemented a few microservices using rabbitmq and nodejs. it isnt a job scheduler and I wonder if one is needed. Based on rabbitmq performance alone I would be hard pressed to even consider an alternative.
I use pdflib if it needs to be pixel perfect or if it's for printing (cmyk). In all other cases I use wkhtmltopdf mostly. 
Any insight on what would be an ORM suited for tiny projects ? I've been looking up various ORMs for quite some time but never felt I could use any of them considering how little data most of my projects use, and always end up tinkering something of my own on the top of some barebones DBAL (or straight PDO). I'm pretty sure i'm "doing it wrong", but never found something DB-related that really "clicked" with me.
Just out of curiosity, why not go direct to nodejs via HTTP in this case?
Are you doing commercial work at a company? If so, you really should get princexml. It's pretty expensive but it's so worth it. For years I've fiddled about with various free tools, but none of them simply work. Princexml does. Don't let the price scare you; the cost of all the hours wasted on mediocre tools adds up quickly (especially for your employer).
&gt; I think the whole event listener concept in Symfony is quite overdesigned Hey Tanks -- even so, I think this is an improvement over what is normally done.
Personal stuff :-)
I was confused for a while as to why we would want functions to randomly throw exceptions.
I'm currently using Laravel's library but it's not that good, correct. Actually, upon thinking further about this, I'll go with your solution and combine it with Laravel's FormRequest objects.
I started out redoing some stuff thinking it would be a 2 pages and a few Ajax calls. After hitting 5 pages, I did not like my index.php looking the way it did. I use Silex often so I installed that and went to town. The little thing I did has around 8 routes total and utilizes Silex, twig, sessions, and a few other things that made the decision a good one.
From your github README: &gt; WARNING: This is alpha code NOT suitable for production. The implementation and API will likely change in significant ways during the next months. The code and algorithms are not tested enough. A lot more work is needed. So why should the OP support it if it isn't suitable for production?
An improvement over what's "normally done"? And what is that?
I still don't trust nodejs as a public facing option. I prefer nodejs only within a trusted environment.. for the moment at least. So that means using nodejs for micro services consuming messages off rabbitmq and doing something specialised. Which also means in general those services don't have a ton of code behind them and are very easy to manage. On the public facing side it depends on what exactly you're building that will dictate what route you go but in general I am a big fan of symfony2 and trust it as a dependable public facing product. With symfony2 already saying they have achieved full php7 compatibility.. just gives me even more reason to use it for that purpose. 
Fuelphp is not a cutting edge framework, but i like it , i like fuelphp and codeigniter, because they do my job, they have all i need to use, yes they does not have new features but both are so cute, i think bigest cons. of fuelphp is its small community , but its develop team always helped my in any aspect in IRC or forum, if you like to challenge yourself and play with code and wish to join a real framework development cycle, i suggest try fuelphp, fuelphp is created on codeigniter with many goodies in mint, 
One route or a thousand. One service or 800. Never an excuse not to write modular apps. I'm with you. 
if you want to help to release a great release of a cool php framework, i give you fuelphp, a framework with many good points in mind based of other best php framework, it release 1.7.3 version but ver. 2 is stil in alpha state, please read the roadmap for version 2 and if you any question join its IRC channel, i hope see you in contributes list for version 2 :) fuelphp.com
If you are not feeling for using a full-blown ORM, try using just a simple database layer that gives you benefits over PDO/mysqli() functions. I could recommend [Nette\Database](https://github.com/nette/database) (approach is based on [NotORM](https://github.com/vrana/notorm) - but it seems it's no longer in active development) or [dibi](https://github.com/dg/dibi). I've tried both on smaller projects and they are OK. Doctrine FTW though, IMHO.
Well, I personally use [Kdyby\Events](https://github.com/Kdyby/Events/blob/master/docs/en/index.md) for event listeners in my application - they really come in handy sometimes*. :) *) like a while ago, i had to extend order process to also send SMS notification in addition to sending emails; i didn't need to touch the order process at all, just created a listener that sends SMS, registered it in config and all was working instantly. :)
Because RabbitMQ doesn't just except connections and pass on stuff. RabbitMQ allows you to cluster, route, and federate your message passing. Something a web server will never be able to do. Also, web servers are for web tier tasks they serve out web content, for which they are designed, not message queuing. https://www.rabbitmq.com/features.html 
It is an extreme edge case that almost never should happen. On misconfigured servers it may happen. But in general you should never see an exception. It can happen if your server runs out of file descriptors, or other far more rare events. I wouldn't try to "handle" it, but instead simply fail gracefully.
I'm using RES with Night Mode. So 90% of all custom CSS looks so bad I never have it enabled ...
You are looking for [trigger_error()](http://php.net/trigger_error), but you can generally not generate the errors you mentioned. You can only generate errors for types starting with ``E_USER_`` like ``E_USER_NOTICE``, ``E_USER_ERROR``. If you want to go the very dirty route, you can use ``eval()`` to execute code that will raise the error code you want. But you can not set the error message freely as you are limited to the errors generated by the eval'd code. This is not recommended and a very dirty hack.
Thanks for the links. Nette's db looks fine. I'll also dig into doctrine cause last time I did I prolly dismissed it too fast for complexity
Prince is the best tool for pdf generation http://www.princexml.com. Waezyprint is a good second (and free) http://weasyprint.org
I personally prefer DomPDF, I find it to be stable and it has the most support for modern CSS compared to the other PHP -&gt; PDF libraries I've tried.
Back in the day, young man (j/k) when I looked in the past, when they were on google code, worst site ever, it was very difficult to make this product work because of all the dependencies it required. Hopefully that has changed, I can see that their site has increased in quality for sure.
Sure, but you can't know if the page exists or not when sending the response if all routing is done on client side. So without duplicating all routing logic, you can either send a 200 or 404 always.
A little late to the game, but figured I'd throw in my $0.02. I chose FuelPHP for a pretty large project about 2 years ago. The codebase is mostly backend, ie. not a website. Therefore I really wanted a framework that was more extensible and less opinionated. Fuel does a good job of letting you pick and choose which components you want to use and is also flexible about how you organize your app. Their concept of Packages is a nice way to organize your backend libraries. For me, a framework provides a lot of value getting started, but over time your codebase will grow and mature to where the framework shows through less and less. Would I choose Fuel again today? I'd probably take a closer look at Symfony2 first. It's definitely more opinionated than Fuel, but is high quality and has an active community behind it. As someone mentioned here, Fuel's development has been stagnant over the past year and I question if version 2 will ever see the light of day. Lastly I wouldn't call Fuel _terribly_ outdated. It may not make heavy use of things like closures in Laravel or popular patterns like dependency injection but it definitely does make use of namespaces and PHP 5.3 OOP.
Have you looked into wkhtmltopdf? 
I fixed mine using [Stylish](https://addons.mozilla.org/en-Us/firefox/addon/stylish/) and the following CSS: pre { background: transparent !important; border: 0 !important; }
I have it disabled constantly. Most of them look horrible while using night mode, which I prefer to having my eyes scream at me for the stark white of most subs.
Hey everyone - I just finished refactoring v2 of Pop PDF if you all want to check it out (working on the documentation, so that should be coming soon, but there's the README to get started.) It handles the basics of PDF generation (text, pages, etc) plus embedding fonts, images, graphics/drawing, linking and importing other PDFs or pages from other PDFs as well: https://github.com/popphp/pop-pdf 
It's important to clearly enumerate the functionality you want in order to choose the right package. It's not 100% clear from your post what you need, but here's my attempt at codifying it: 1. You need authentication - a way for users to log in with a username/email and password 2. You need registration (presumably?) 3. You need roles (user, manager) ... 4. ...which you can assign to users 5. ...with definable permissions (remove fake scores, edit games, edit profile, etc) Given that, and also to answer your question about Sentry, I would recommend [Sentinel](https://cartalyst.com/manual/sentinel/2.0) - the successor to Sentry. This is a well-documented stand-alone library with a straight-forward API, and you can use it any framework you choose. This means you can use it in place of Laravel's auth, since Laravel does authentication *only*, not roles and permissions. If you do want to use it with Laravel to build out the rest of the application, there is a convenient guide on how to [integrate it with Laravel 5](https://cartalyst.com/manual/sentinel/2.0#laravel-5)
Nah. I hate tinting. I can't stand when a color isn't exactly how I want it to look, and I feel like f.lux would make that part of me go absolutely insane. I just have everything in night mode. I can adjust screen brightness accordingly without any third-party things. c:
&gt;on Linux and Windows. It's based on QtWebkit. Also please note that current stable branch (0.12.x) is based on Qt4, which has pretty old built in webkit engine. 0.13.x branch based on Qt5 and pretty current version of webkit, but it not so stable right now.
A good place to start would be open source projects that you currently use.
A search reveals it's been a recent glut for this week. But you probably didn't know that, being an ignorant troll and all.
I recently started using a package called Searchable for something similar: https://github.com/nicolaslopezj/searchable I think that might get you started on how you could create your own traits for searches like you're talking about too.
Thank you for the response. What I need is a flexible user framework so I can layout a foundation for a leaderboard system, (something that has been needed in the community for awhile). It mostly just needs to allow for the higher ups to be able to do their job while not interrupting users from adding their scores. I have a MySQL database with over 2000+ games that is constantly growing day after day. As response to your post, why integrate it with Laravel 5? Is there some revolutionary features that I wouldn't be able to do without as apposed to Sentinel vanilla?
I wasn't sure how much of the leaderboard application was already complete, thus the suggesting to integrate with Laravel 5. If you already have the leaderboard or surrounding application built and just need to add in some basic management of that leaderboard, then using just Sentinel should be fine.
The Leaderboard is just MySQL database like I said. Though, I was given the SQL dump by a friend, it leaves a lot of columns empty such as XP, suggested difficulty, etc. If Laravel 5 does something as automating the process of processing XP and global leaderboard ranking calculations then I guess it would be helpful since I wouldn't have to write the script myself. Otherwise, thanks for the info on Sentinel, didn't know such a successor existed. 
You don't realise it changing but it makes a huge difference, I have it installed on my phone while downstairs, as soon as I looked at the TV I saw the blue light and it made my eyes hurt. Basically, just give it a go, it's not like you can't remove it.
This is true. However, I've been fine just sticking everything in night mode. I'll probably give f.lux a try on my phone, since there's less customization options available there. (I can't style webpages, for example.)
Seconded, highly recommended.
That's what all of my searches look like on every subreddit, using RES with night mode. I even disable all of the custom CSS because it's usually annoying. So, this isn't an /r/PHP problem.
When I tried this, it basically did page breaks right in the middle of lines of text and I didn't like it.
There are four possible cases as far as I can tell: * All file descriptors are exhausted, meaning the OS can't open any new files. This is a major problem and requires solving at the server level. * Fresh boot of a fresh install. For the first few seconds of a new install (typically while the installer is running) the OS won't have enough entropy to actually generate random bytes. This is practically a non concern to PHP as it isn't installed until later in the process anyway. * OS level bug. Both Linux and BSD make some pretty strong guarantees around urandom/arandom. However, I wouldn't rule out a kernel level bug as possibly causing issues. Though this will likely never happen in practice. * Server admin setups chroot jail for PHP with nodev flag set. This may happen, but is dangerous since without access to /dev/urandom, the application can never generate good random numbers. So the chroot jail will be severely reducing the security of the application and its data. Hence this should be considered an error on the admin side. There may be others, but those are the only I can come up with while looking at the source code of both PHP and Linux...
You may wish to consider [Aura.Auth](https://github.com/auraphp/Aura.Auth) as a starting point. (I am the Aura project lead.)
Ah I slightly misunderstood. I still think if it's "not suitable for production" by the author then doing something like this is probably unwise unless you are dedicated to maintain it.
Is there a style guide for embedded php in html? I've been taught to put the "&lt;?php" tags at the very beginning of the line and make the actual code align along with the indentation level of the html, like so: &lt;div class="container"&gt; &lt;div class="madeUpClass1"&gt; &lt;div class="madeUpClass2"&gt; &lt;ul&gt; &lt;?php if($test) { ?&gt; &lt;li&gt;Blah&lt;/li&gt; &lt;?php } ?&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Is this typical? I haven't seen any style guides for this sort of thing.
I am trying really hard to keep my code following the single responsibility principle. I find it means my classes are growing in number but slowly shrinking to one (public) method classes. Is this normal?
~~I think that is a little overkill if you're sprinkling classes all over the place with only one method. I'd need to probably read up on your use case - but it sounds like you're making it a class for the sake of following the rule and not because it makes sense. That is just my intuition, though.~~ ~~Can you give us more info?~~ edit: just re-read that you mention only one **public** method. That's fine. I misread thinking it was your only method. Sometimes you wont need more than one method. I have a class dealing with some business logic that uses a lot of behind the scenes details to calculate some stuff. For this, it's the same situation. 
Has anyone tried controlling InDesign Server from PHP?
You can use [DateTime](http://php.net/DateTime) and [DateInterval](http://php.net/DateInterval) Start by creating the initial date and final date you want: $initialDate = DateTime::createFromFormat('Y-m-d', '2015-01-25'); $finalDate = DateTime::createFromFormat('Y-m-d', '2015-12-25'); Then define the interval you desire, one month in this case: $interval = new DateInterval('P1M'); Now you can just create a loop and increment the date using the interval for each iteration: $date = clone $initialDate; for (; $date &lt;= $finalDate; $date = $date-&gt;add($interval)) { echo $date-&gt;format('Y-m-d') . PHP_EOL; } The output should be: 2015-01-25 2015-02-25 2015-03-25 2015-04-25 2015-05-25 2015-06-25 2015-07-25 2015-08-25 2015-09-25 2015-10-25 2015-11-25 2015-12-25
How do you want to handle edge cases? 2015-12-30, 2016-01-30, 2016-02-??
No. Not unless you want to be known as a shit developer who likes working on shit systems made. Take a look at ProcessWire. It doesn't follow your typical coding patterns but is insanely powerful without a massive learning curve.
I'd not start anything new with it. It's just not got enough people behind it to survive long term. I'd go with Symfony.
More of an open source question than a PHP question. What's the etiquette for building on an existing (dead) project on github? Original user didn't get very far and I'd love to expand on it. It pretty much needs a complete rewrite so I'm not sure whether I should fork it or just start new. 
Talk about coincidence... Yesterday after looking at the amount of repeated dependency in my projects, I thought if there was a way to simlynk packages to every project, and now this... Thanks for the share :D
reference link to short syntax for those new to php that don't know about them: http://php.net/manual/en/control-structures.alternative-syntax.php
I have read/heard that Laravel's bootstraping/autoloading is a bottleneck for a big porjects. I understand that truly big project wont be build on a stock framework. So my question is what is good design and mainly performance wise solution for a bootstraping/autoloading?
Like this? function stuff($s) { return preg_match('/a-z0-9-_/i', $s); }
I tend to do the same, to the extent that I'll try and keep any more complex code out of deeply nested HTML. It makes a real mess when you need to add some display logic in tables or nested lists. &lt;table&gt; &lt;?php foreach ($users as $user): $active = 'no'; if ($user-&gt;active === true) { $active = 'yes'; } ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?php echo $user-&gt;username; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $user-&gt;email; ?&gt;&lt;/td&gt; &lt;td&gt;&lt;?php echo $active; ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach; ?&gt; &lt;/table&gt;
Only contains? Everyone is thinking about this wrong. Just try to match something that's not in that set and return the opposite which should be doable with /[\^A-Za-z0-9\-_]/. You might be able to use /[\^\w]/ instead (though test that!) 
If it's worth building on, has appropriate licensing, and you would wish to progress, then I'd suggest fork it. Github has some nice ui elements for people to follow up with forks, and it lets the original author pull in things they want. Think of it not so much from your point of view, but from others that hit that same project like you did. They'd see the project was forked, and the fork is active. If you get so far along that the original looks like the distance past, then you can always refactor into a new project or version.
The fact you need to register to download anything immediately turns me off. Phil Sturgeon isn't [particularly impressed either](https://www.youtube.com/watch?v=0ktiTRwd-pg)
Sentry is depreciated. Use it's successor [Sentinel](https://cartalyst.com/manual/sentinel)
is it bad practice to have PHP in your JavaScript code? 
Think of it like this: Whatever you're trying to accomplish, there is probably a better solution for it on composer and packagist. I've used in the past for very specific scenarios, there's the odd useful function here and there on the website. The code may or may not be compliant with PHP-FIG (it probably won't be) but there are still a few useful things in there.
Personally I think `Error` should only replace things that are historically errors. Because these random_ functions don't exist prior to PHP 7, /u/mnapoli's suggesting of using descriptive Spl Exceptions makes a lot of sense.
oh you made PEAR sorry it's just a joke I know the differences between composer and PEAR
Curious as to how this handles projects with the same packages but at different version requirements. Project X may need Guzzle 2.0.1 while Project Y may be back on Guzzle 1.9.8 until it's brought up to speed. I couldn't find reference to that use case in the documentation.
I don't remember details, but I had some problems with flexboxes. Also in case of phantomjs there was lack of support for some js apis (web sockets for example), but this important only for e2e tests.
It becomes unwieldy fast in my experience. We had a mid-sized to large codebase that used php in js heavily, but when we moved to a grunt based deployment process we had to remove those, because it didn't work well. We now use json_encode to drop our php variables in data-attributes in the html part of our views, where the javascript can easily get at it. Something like: &lt;div id="menu" data-guest="{'name': 'Somename', 'age': 21, 'funds': 320}"&gt;&lt;/div&gt; Using jQuery all you have to do to get it is: $('#menu').data('guest'); And jQuery even automatically turns your json string into a javascript object. Works fine for us, but your milage may vary.
The plugin create a subdirectory named by the version. So if you need different versions between projects X &amp; Y, the autoload will load the right version, and you'll have a folder like "guzzle/2.0.1", and "guzzle/1.9.8". See project structure example : https://github.com/Letudiant/composer-shared-package-plugin/tree/master#structure-generation-example
Facebook never permanently deletes accounts either.
No to mention confused and just plain wrong. If that's the only way they can think of to prevent vote rigging, then they're not very smart.
I've never found anything actually useful on it. The times I've looked, everything seems to be of poor quality, and lacking the conventions that make composer repos so useful. Also the design of the site hurts my delicate eyes.
As a general rule. Any code that relies on the non-public api should be avoided.
Yes, I realize. I was just playing Devil's Advocate.
&gt; Nothing prevents me from choosing min and max at runtime. That is true and I agree that throwing ``InvalidArgumentException`` would probably the better choice. &gt; Having to deal with errors and exceptions at the same time is confusing. The main reason to differentiate between them is backward compatibility: PHP 7 should not catch all errors where PHP 5.6 would fail hard in places where you catch ``Exception`` today. You can ignore errors, then your script will fail in PHP 7 like it would with PHP 5. Or you catch ``Throwable``, then you have to handle all situations. Hopefully in PHP 7.1 there will be a more fine grained ``Error``/``Exception`` hierarchy that reflects the actual error better.
I would say it depends on your needs, how many users will use it, how much data and what content you will be searching through etc. Pure database solution can often suffice, in hard-core usage elasticsearch (lucene-based product) will do.
vim w/ plugins: 'ctrlpvim/ctrlp.vim' 'scrooloose/nerdtree' 'Lokaltog/vim-easymotion' 'jlanzarotta/bufexplorer' 'scrooloose/syntastic' 'scrooloose/nerdcommenter' 'majutsushi/tagbar' 'SirVer/ultisnips' 'honza/vim-snippets' 'flazz/vim-colorschemes' 'tpope/vim-fugitive' 'bling/vim-airline' 'Shougo/neocomplete.vim' 'junegunn/vim-easy-align' 'tpope/vim-repeat' 'tpope/vim-surround' 'evidens/vim-twig' 'pangloss/vim-javascript' 'mxw/vim-jsx' 'rking/ag.vim' 'groenewege/vim-less' 
I'm using PHPStorm from JetBrains. From all IDE's I tested this has been the best so far. Also I'm working as a Java Developer with IntelliJ IDEA from JetBrains and both IDE's are identically, so changing between them is not a big change.
PHPStorm + ColorIDE + https://github.com/daylerees/colour-schemes
Just don't make the mistake of using Zend Lucene. I've used it on one project back when I was pretty stupid. THat thing is AWFUL.
The escape sequence for a whitespace is \s. Check http://php.net/manual/en/regexp.reference.escape.php
I recently got into vim as well and I'm still in the process of learning all the intricacies of the editor. I love it. However, until I master it completely, I use sublime with the Vintageous plugin. When I need to do large refactoring tasks such as renaming/moving namespaces, I use PHPStorm.
You maybe wont something like this: /^[a-z_\-0-9\s]*$/i But this will allow a leading whitespace, dash, underscore or number...
No problem. All of those are pretty nice IMHO, but probably the most useful for me are: * CtrlP - Fuzzy file searching / navigation * Syntastic - Syntax checking * Ultisnips - Snippets handling * Neocomplete - Autocomplete 
I've gone from vim to sublime and now to PHPStorm. While I *could* go through the trouble of turning both vim and sublime into IDEs, I see no reason to do so when PHPStorm has vim mode (kind of not that great vim mode, but 90% of it is fine). I thought about it this way: spend 6 hours @ $65/hour (my freelance rate) configuring the shit out of vim, or just spend $80 on PHPStorm and basically be done with it. So far it's been awesome.
What plugins are you using ? Are you using Vagrant for local dev ? 
Ugh. seems like it would be simpler to just keep them separated. This seems like a bastardized version of how Bundler does it. **EDIT** Hopefully, you come back and see this, since it's an edit I do not believe it will show any new messages if you have that option checked. What was the specific use case for this? Why wouldn't the existing Composer features of caching libraries and installing globally solve it?
The lack of the operator methods of languages like C++ has always been a bit of a pain. It would make the Value Class Pattern much easier to implement, however it's been something that's been missing for a long time, so I can only assume there is a good reason for not implementing it. There are ways around it but nothing as simple as `$ObjectA &lt; $ObjectB`
But this isn't. It's a hack that directly reads the private/protected members of classes. This breaks that rule. A better idea would be to do something like. &lt;?php interface ComparableInterface { /** * @return bool * */ public function equalTo($obj); } class Thing implements ComparableInterface { public function equalTo($obj) { if (!is_object($obj) || !$obj instanceof $this) { return false; } // compare objects by using public api return true; } } 
* Color IDE * Front End Alignment * IdeaVim * Laravel Plugin * Markdown * Markdown support * PHP Advanced AutoComplete * PHP Annotations * PHP composer.json support * PHPUnit code coverage I use Vagrant VMs for some projects, others I work on natively since it's faster. I've not had good luck with VM performance.
&gt; I don't see a reason (except BC for existing stuff) to use Error subclasses. You have to think of ``Throwable`` as the new ``Exception`` and ``Exception`` as the new ``RuntimeException`` and ``Error`` as ``ErrorException``. Then it makes more sense. It boils down to BC and a consistent exception class hierarchy.
I haven't tried to integrate any VIM plugins other than the one (IdeaVim) that comes with PHPStorm as a free download. Most of the plugins I use are for things that are already included in PHPStorm by default (project file browsing, git integration, buffer control, etc.) However, the following is from the extension's description, so you can draw your own conclusions. &gt;Vim emulation plug-in for IDEs based on the IntelliJ platform. &gt; &gt;IdeaVim supports many Vim features including normal/insert/visual modes, motion keys, deletion/changing, marks, registers, some Ex commands, Vim regexps, configuration via ~/.ideavimrc, macros, window commands, etc. EDIT: formatting 
https://wiki.php.net/rfc/comparable
This. Exceptions are much more flexible and PHP7 will be moving the previous E_ERROR, E_WARNING, etc. to Exceptions, so there's really no reason to use the error constants in your code.
Is there a version where we can actually read the screen?
I use netbeans. Its free, it has a few decent plugins and I can work on php projects and c projects.
&gt; Apache : soon... &gt; MySQL : soon... &gt; Nginx : soon... &gt; PostgreSQL : soon... &gt; MongoDB : soon... So .. it doesn't work yet?
It's not bad, but yesterday I was "cleaning" my Mac of any big file with a filesystem visualizer, and I saw the size of all the vendor directory in every project I had, and almost all of the dependencies where the same (all project based on the same framework). It's not a deal breaker, but it's nice to have (I didn't try it yet).
Nothing beats PhpStorm.
When did you last use it? It's pretty easy these days. Just add a remote interpreter and select either SSH or Vagrant: http://blog.jetbrains.com/phpstorm/2014/04/php-remote-interpreters-support-in-phpstorm-8-eap/
Its just an excuse to boost the numbers.
You may want to change the folder names for dev-master and other bleeding edge versions because a lock file in one project will probably point at a different commit hash to another project also using dev-master for that dependency. Maybe use the commit hash as the folder name. 
ITT: PhpStorm Try it out and you'll soon realize why. 
With packages, does that not create an IDE? 
I am pretty sure it would have helped many people in the past. It did have helped me. The current problem is it is vast and would have lots of old classes / stuffs spread out. But don't blame them. They all are part of the PHP community that made PHP hear loud at different times. Same for pear, wordpress, composer and yet any other things to come.
Was about to write :-) . I do recommend checking the library .
Generic and useless site.
&gt; This plugin will improve your work process to avoid to work into the vendor folder or to avoid to force you to push your package to work/test it with another project. The way I normally do this is: * composer update for the project. * delete the directory in the vendor directory that I want to work on inside the project. e.g. delete './vendor/danack/somelibrary' * go into the vendor/danack. * Do `git clone http://www.github.com/danack/somelibrary` The library is now there in the vendor directory as a proper git repo, and as composer knows about git repos, it won't get over-written by composer. You can then work on the project and the library without having to push. I know you can do almost the equivalent with `composer update --prefer-source` but I don't like messing around with detached git repos.... 
Given the typical quality of the code there, it's actually *worse* than useless because it propagates a lot of bad practices. *Actively harmful* is probably more accurate.
There's a few reasons: * The name is a bit of a misnomer, a Laravel facade is not the same thing as what [most programmers know as a facade](https://en.wikipedia.org/wiki/Facade_pattern), this can obviously lead to confusion. * They are a worse alternative to dependency injection because you can only swap out the implementations globally, you can't provide different implementations to different objects. * They basically hijack the static syntax that people are familiar with and use it for a different purpose, again, this leads to confusion. You can no longer just look at a bit of code and tell that it's calling a static method as it may be referencing a facade. * You are coupling your code to the Laravel framework (or at least the facades component). * It relies on a hefty amount of magic meaning that unless you have a very specific plugin you miss out on a bunch of nice features if you're using an IDE. Personally I don't like them at all but realistically, unless you're working on a medium to large sized project, it won't matter much. 
I mean, if you're looking to tie a bunch of pieces together, I guess you've got to do something with a microframework and an sqlite database (although I'm assuming your host might be missing that if there is no databases, per se). You should be able to squeeze all that down to 10mb fairly easily - but its probably way easier for him to just sign up for somewhere like wordpress.com or tumblr, or even just use Facebook.
Checkout Sculpin, a static site generator built w/Symfony components. https://sculpin.io/getstarted/
The logical structure of the journal is really simple : post a page, access pages, access a single page, see a picture. Even wordpress.com, tumblr, ... are way more sophisticated than this. And coding it myself means I have full leeway to make it look however I want (playing with CSS is fun). It really doesn't look like an ordinary blog page, it's very sophisticated on the outside, but it's absolutely primitive in terms of server-side functionnality. I'll look into microframeworks. Thanks for your help man :)
The logical structure of the journal is really simple : post a page, access pages, access a single page, see a picture. Even wordpress.com, tumblr, ... are way more sophisticated than this. And coding it myself means I have full leeway to make it look however I want (playing with CSS is fun). It really doesn't look like an ordinary blog page, it's very sophisticated on the outside, but it's absolutely primitive in terms of server-side functionnality. 
Looks like this is the popular opinion based on up votes. I guess the important take out is to separate the concerns well in the code, so should I need to separate the API out later, it's easier. I can get behind that. When building the public site bit, do you guys think it's worth going as far as calling the API end points over HTTP (internal network URL for speed), instead of calling the internal methods directly? Feels like "over optimization too early", but might help enforce the code separation?
I also want to point out that "short echo tags" &lt;?= ?&gt; have been made standard, These are a good practice (in my book) as they simplify the common &lt;?php echo $thing; ?&gt;. These are not to be confused with normal short tags "&lt;? ?&gt;", which are dependant on the short_open_tag being enabled and are bad practice. http://php.net/manual/en/language.basic-syntax.phpmode.php
yeah PHPStorm is really good if you are only doing web stuff/front end stuff. If you are working on back end things get intelliJ full edition - it becomes PHPStorm with the installation of the PHP plugin, 100% the same thing. Great PHP debugger, also great debugger for any language.
There aren't any libraries that do this by default as there isn't a standardized in-db ACL implementation that they could use to develop against (and personally, I just don't like the idea of something editing my queries on the fly and changing the expected behavior of it). Elgg takes this approach though and you can see the associated code here: https://github.com/Elgg/Elgg/blob/master/engine/classes/Elgg/Database/AccessCollections.php#L225
This is not a bad idea, thanks !
&gt; the last post regarding your chosen IDE was around two years ago No, it wasn't. Stop posting this and "what is your favorite framework" type questions.
I was using tcpdf then mpdf for years, and then I discovered wkhtmltopdf and it changed my life. If you can exec() then you will enjoy super fast operation, no more memory/process time outs, and overall easier and better PDFs... Check out http://wkhtmltopdf.org/ ... binaries for most platforms... Here is an example of some code I used... //Setup file parameters $cwd = getcwd(); $htmlfile = $cwd.DIRECTORY_SEPARATOR.'tmp'.DIRECTORY_SEPARATOR.date('Y-m-d-h-m-s').'.html'; $pdffile = $cwd.DIRECTORY_SEPARATOR.'tmp'.DIRECTORY_SEPARATOR.date('Y-m-d-h-m-s').'.pdf'; //Fat Free Framework code that generates a valid html file and writes to disk $html = \Template::instance()-&gt;render('pdf/order.html'); $f3-&gt;write($htmlfile, $html); //Convert HTML to PDF exec('"C:\Program Files\wkhtmltopdf\bin\wkhtmltopdf.exe" '.$htmlfile.' '.$pdffile); //Output the file to browser header('Content-Type: application/pdf'); header('Content-Length: ' . filesize($pdffile)); readfile($pdffile); //Delete the junk and bye! unlink($htmlfile); unlink($pdffile);
I have all of those exact same things configured in intelliJ it works great... I just open multiple project files to keep the java out of the web stuff. IntelliJ with the plugins is identical in every way to PHPStorm except for the name.
wrote a corporate size restful on it with the rest bundle, jms serializer and the nelmio api doc bundle. no reason to not use symfony
I guess it depends what you define by what is part of the public API. For instance what if: interface ComparableByProperties { // If implementing this interface the class supports &lt;, &lt;=, &gt;, &gt;= } class Thing implements ComparableByProperties { // ... } Would you define these operators part of the public api now?
Seconded.
&gt; For me encapsulation is about making the correct usage of a class easy and explicit whereas an incorrect usage hard or impossible. That's not what encapsulation means, it means hiding data and making it accessible only through the object's behavior (note: *object's behavior*, not language-wide behavior), which is pretty much the opposite of what we have here. We have here PHP reaching into an object's internal state and comparing values using a centralized unmodifiable algorithm. Not every two things can be compared as arrays, byte strings, or numbers. The rules are often more complex, which is why encapsulation suggests it happens through methods. You can't even properly compare two Unicode strings this way. It's brutally limited. &gt; Maybe my example below makes it more explicit that a class was designed to utilise this behaviour. Can you point to the documentation describing "this behavior"? How do you design for something that you only understand through guesswork? I want to see how is it affected not just by property order, but traits, superclasses and subclasses, implemented interfaces, and god knows what (how about magic property methods, or public properties added from outside at runtime). I want to see what's the commitment of the PHP core devs to this behavior. I want to know if it might change in every point release from now on. You found some arbitrary behavior of the PHP engine and swallowed it hook, line and sinker due to neat syntax. Asking for an interface which is exposed through the comparison operators is one thing, and asking for direct comparison against private properties to be used as if it's a standard behavior is quite another. Most of us would put object stability &amp; control over neat syntax hacks that can blow up due to unknown reasons. Relying on what PHP does here takes away control by means of it being undocumented, inefficient &amp; inflexible.
Feature request for v2: Remove the PHPun from the namespace.
Well I didn't want to just call it Physics.
Single responsibility depends on your app, it's not universal, and it doesn't mean one method. That said it will lead to less public methods overall, especially when you create interfaces. There are methods of different types, so it depends. Say my Log interface is one method: $log-&gt;log($type, $path, $message, $code, $details); But I also have LogFacade which has methods that wrap around a specific $type: -&gt;error() -&gt;warning() -&gt;info() etc. LogFacade has many methods but one responsibility: to be a fancy facade for Log instances, providing a full set of methods for typical calls to -&gt;log().
Neat. It's a useful library, thanks for sharing with us. BTW, it's unclear why UnitComposition is preferred over direct class instantiation. It's possible to design this without relying on strings.
&gt; no you see Employing the Nuh Uh defense like a boss. Nevermind that you're making reference to some nebulous definition of "argument". I know you think you're a debater, but you're an idiot and I enjoy watching you react, badly. This is how you operate. &gt; I probably know more languages than you will ever know Emotional argument generated internet tough guy trope. That's hilarious.
I'm doing something similar in a project that needs intermittent filtering based on the user's branch. I just did it in the controller actions since it's not applicable for every table/query. Example: $users = Auth::user()-&gt;branch-&gt;users-&gt;lists('id'); $manifests = Manifest::whereIn('user_id', $users)-&gt;get();
Thanks for a well explained design decision :) It'd be nice to add a sentence or two in the README too, so people know why UnitComposition is recommended.
THX!
More clear one https://www.youtube.com/watch?v=J9emzl_VmIs&amp;list=PL00vv8f4GR7Pm7CM_7dW33WLMgS8vApvh
The purpose on this is to be able to symlink a vendor between projects, locally in dev. It's mostly useful when you maintain private packages (Private repository + satis), so if you are working on your package, instead of commiting/pushing &amp; composer update every time, you can locally check all your projects that use this package. Yeah, I know it's a really specific case. It's something I will consider to add to our workflow. Nice job, /u/Divi_
I'm glad you're enjoying yourself. Calling names and stuff... as I said, says more about you...
I met the same problem trying to use e.g. Zend or Symfony ACL with Doctrine: fetching all rows from the database and then checking every one of them against permissions was just impossible. So I created [MyCLabs\ACL](http://myclabs.github.io/ACL/). It hooks up (cleanly) in Doctrine queries so that ACL filtering is done by the database (extremely efficient). Not updated in a year though, but it works, and it can be a starting point for your own implementation (it took 2 years of iterations to come up with this efficient solution, so looking at the architecture can help).
If there's no requirement to call it over http I would not. It just adds latency for the sake of it. You've identified the keypoint with separation of concerns. If you've done this well, pulling out your api and putting http in front of it should be easy.
Does anyone here doesn't use tab and switch to recent files using Ctrl + E ? I'm genuinely intrigued whether this could be more productive or not.
But why male models?
I use CTRL E frequently. The window doesn't close right away, so it's easier to type/search. And it's a bigger window with a larger history + tool panel choices. For toggling back and forth CTRL+tab is much faster.
Unfortunately it could have been a great resource, but the values at its core and its business model has halted any kind of progress and incentive to quality. By focusing on its ad-powered revenue it has forgone doing more to drive users to quality like implementing tools to report on code quality and such things. Also this core drives to all the logged in nonsense including having to use a username/pwd to download through composer. It is also very known for link bait articles and very outdated or incorrect content. This has improved in the past year after they were banned from PlanetPHP, but is still not at a level i consider acceptable, but that's me. It had a lot of potential and was created at a time when it was really needed, its a shame it stayed in those days and failed to evolve like PHP did with its renaissance in code quality, good practices and general awareness of quality. So, avoid it, there is much more to be found on Packagist. With a lot less hassle and a website that does not look like 1995.
Good luck, it looks useful.
Absolutely agree. I personally don't like Blade either, I just included them as they are, or have been popular. The other two are great though. Twig is excellent if you only need the template parsed via PHP. If you need it parsed by more than one language Mustache is fantastic.
You're obviously going to be sanity checking the input to make sure it looks good - but outside of that, Rate limit by IP/Range, rate limit anyway (how many registers a second care you expecting anyway?), send a cookie to try and track people hopping IP address and not stupid enough to remove cookie, plus any other security through obscurity. Then of course, pro-active removal of successful registration attempts that were likely automated, such as delete accounts that don't manually confirm via an email you send them after X hours or so.
Do you buy bread from the shop?
Objective-C and Perl died suddenly? .... 
Hi /u/Gahu, nice to know someone else had the same problem. I considered that approach but my concern is that whatever key you use anyone can access it just looking at the code of the app. Isn't that a big risk?
And only usable for non-public usage of the API (meaning that it won't do much good if you're providing the API as a public service, or as a backend in an application where the code is available (javascript)).
This is great, thank you for the info! I'll look into it.
Neither is doing boilerplate code which is the same for every project!
2 days is what I do...
&gt; The author has been complimented off the PHP mailing list way back, Stack Overflow Source?
Swift I think killed Objective-C
wat - Java is trending now because of enterprises/old repos being moved to GitHub (due to GitHub's tremendous raise in popularity). This will stagnate very quickly. - Python is a *tad* bit biased, but since basically every CS-related degree in the world includes so much Python in their courses nowadays I think it'll see a nice bump (in conjunction with the sheer increase of CS students). - Ruby is on its way down IMO. It's very niche, and it's hard to alter the language specs going forward (which makes it an uninteresting language :D). - Swift because it's becoming very stable as a language. Oh, and iOS.
1. Javascript 2. Java 3. PHP I have a feeling very little will change in the next three years. But i can see languages like ruby and python begin to slowly disappear, leaving a bigger gap at the top.
looks like a scheme to make money of already available opensource projects?
Java's trend up is a lot larger than you seem to think. Look at search interest and open jobs over time as well. I think it has more to do with Java 8 and micro frameworks like Dropwizard and Spark.
This is interesting, could you tell me more? I am a little bit of a noob so I am not sure I understood the last bit (what is a proxy script, for example?).
Cookies are stored at whoever is making the request, not whoever is serving the response. If you want to store cookies... store them, and send them next time you make a request.
Do the results in this graph matter? One reason I posted the link is because it seemed to validate some of the points made during discussions we've had internally about whether or not to stick with PHP as a key part of our web stack.
You would store a cookie on domain1 and then domain2 would look for the presence of that cookie. Or you could open a `$_SESSION` on domain2 and domain1 would send the sessionId via cookie or get/post parameter. 
&gt; Python is a tad bit biased, but since basically every CS-related degree in the world includes so much Python in their courses nowadays I think it'll see a nice bump (in conjunction with the sheer increase of CS students). I think this is probably selection bias on your part. I know of at least a handful of schools that do not teach Python at all. I'm not saying Python isn't widely taught, but it is more widely taught than C, C++ or Java? 
Be aware that regardless of platform, keys do and will leak if they are important enough, as an example: https://gist.github.com/rhenium/3878505
Because Composer is specifically for PHP. NPM and Bower are more general front-end dependency tools that are independent of the backend language chosen.
+1 - everything has it's place - it is possible to use an ORM vaguely 'correctly' and simplify your code and speed development up. A reasonably experienced developer should be aware of where not to use an ORM and be able to avoid performance problems. 
In the process of renaming to Samsara/Newton. Namespaces and instrumentation. **UPDATE:** Renaming complete. The library's packagist name has been changed to samsara/newton, and on September 1st or before it will be moving to v1.0.0
Hmm.. interesting. Which tools are you referring to (just curious)?
Puppet, Chef, Vagrant, Capistrano
I like to look at [HashiCorp](https://github.com/hashicorp) as an example of modern, modular tools and architecture. A lot of their recent projects have been based on Go. For DevOps, I would argue an increase in using Go for projects that center around these needs. But only time will tell.
You can use an ignored config file to store the key so it wont show up in your public repository.
? that should not stop you from uploading it... almost everything on github or bitbucket is work in progress
It's a very fun little library, but as you alluded to, it's use cases are somewhat limited. That said, it's very useful if you are dealing with real world items that need to be described and manipulated, or if you are constructing a realistic representation of the world such as in a game.
I want it to be a private work until it finishes, I do not want to pay for that on github
What do you gain from it being private? What are you trying to achieve? Github for example has a massive community, issue tracking. It makes it really easy for multiple people to contribute to a project. Are you currently using version control?
IIRC you should be able to set the cookie domain on the web servers so that both of your servers use the same session cookie. Also, If you combine the above with database sessions then you end up witha nearly seamless environment bouncing back and forth between the servers.
Then put it on bitbucket, they have private repos with the free plan. but still, if you don't want it to be public, stop calling it open source, cause it actually isn't that open. 
Even PHP fits into the "intro-level technology that may not lead to long-term usage in your career" classification :D
Then please do not call it "open-source" since it is currently not open source. If you are unable to provide a public repository for the community to evaluate and help your project then please don't try and solicit free help. The rather annoying part of this whole thing is you haven't communicated WHY you need or want help nor did you demonstrate that you are able to work with the community that you're relying on in order to build a product built on open source tools. There are a lot of really smart people that would generally be happy helping you but at this point there is no way that I would dedicate any more of my time to this and I'm sure others will feel the same way. Good luck
I'll take that bet! $5 USD via Bitcoin! RemindMe! 3 Years "did you win this bet?"
Messaging you on [**2018-08-25 21:57:05 UTC**](http://www.wolframalpha.com/input/?i=2018-08-25 21:57:05 UTC To Local Time) to remind you of [**this.**](https://www.reddit.com/r/PHP/comments/3ibh00/language_trends_on_github_20082015_php_constant/cufkgpj) [**CLICK THIS LINK**](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[https://www.reddit.com/r/PHP/comments/3ibh00/language_trends_on_github_20082015_php_constant/cufkgpj]%0A%0ARemindMe! 3 Years ) to send a PM to also be reminded and to reduce spam. ^(Parent commenter can ) [^(delete this message to hide from others.)](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Delete Comment&amp;message=Delete! cufkh1d) _____ |[^([FAQs])](http://www.reddit.com/r/RemindMeBot/comments/24duzp/remindmebot_info/)|[^([Custom])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=Reminder&amp;message=[LINK INSIDE SQUARE BRACKETS else default to FAQs]%0A%0ANOTE: Don't forget to add the time options after the command.%0A%0ARemindMe!)|[^([Your Reminders])](http://www.reddit.com/message/compose/?to=RemindMeBot&amp;subject=List Of Reminders&amp;message=MyReminders!)|[^([Feedback])](http://www.reddit.com/message/compose/?to=RemindMeBotWrangler&amp;subject=Feedback)|[^([Code])](https://github.com/SIlver--/remindmebot-reddit) |-|-|-|-|-|
Well Swift is not even in this diagram.. ;/
Why would Python go away? There's a huge push for it right now and it's a default language for mini/micro computers which I expect will get more popular as automation gets into everything. Also, it's a good teaching language for programming students. 
HEY! YOU LEAVE CSS ALONE!
I definitely do stuff like this all the time, I don't really want to but at the same time I struggle to find a better home for UI logic especially inside a loop. While we are talking about short syntax, you could save a few lines in your example like so: $active = ($user-&gt;active === true) ? 'yes' : 'no'; 
I hate python just as much as yaml. Both are whitespace dependent which sucks. Whitespace dependent languages always end up sucking for both people and machines to read. Makes it nigh impossible for an IDE to apply/enforce a coding style.
Eh, at least you can say the open source community for PHP on github doesn't seem to be giving up the 4th place spot. I'd say that's a good thing if you already have PHP in your stack.
By proxy script, he just means that you need to proxy the request to from your client, to a server-in-the-middle, to the final api server. You need to protect your secret keys server side, as you don't want to expose that on the client side. You don't want to do this on your api server, instead a "proxy script" can live somewhere on the backend of the front end application. Example flow: - On the front end, the user initiates the OAuth request flow. - On the backend to the front end, this will handle any proper signing that's necessary - This can then get sent to the API securely, and the response can then be provided to your front end. Versus.. - On the front end, the user initiates the OAuth request flow and does all the signing. Your keys are exposed. Not good. 
I'm nodding my head a lot when reading your list. I have something internal that I use for projects, but is still a bit rudimentary (no table inheritance and so on). Question: how do you imagine the query capabilities of this mapper?
Easy. Use PEP8 coding style, and have your code readable and contributeable-to by the whole python community. Also, 4-space indent is extremely universal across python, and it's hilariously easy to set any IDE to that for python files.
I have an Erlang repository that Github detects as CSS because I bundled bootstrap and it detected it as the majority of the code. I think that sort of thing is fairly common.
Sure that sounds easy but let us say your original codebase isn't PEP8 or you, the programmer, broke the PEP8 in a file some where intentionally or not. You try to tell your IDE to apply the PEP8 style to your code. What happens? More often than not you have to undo PEP8 because everything just got FUBAR'd. If you wanted to you could write a valid python script with 1 space indentions or 10 spaces. It would all work just the same. YAML too. Now if I tried to put more than one set of **{}** on a function in another language it would immediately blow up with a syntax error in the IDE/parser/compiler/whatever. Python and YAML have whitespace serving a dual purpose; readability and syntax. What if you find yourself with nothing but notepad.exe. Is this snippet from the PEP8 style guide itself is *readable*? The random spacing on line continuations gives me a headache. class Rectangle(Blob): def __init__(self, width, height, color='black', emphasis=None, highlight=0): if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong' or highlight &gt; 100): raise ValueError("sorry, you lose") if width == 0 and height == 0 and (color == 'red' or emphasis is None): raise ValueError("I don't think so -- values are %s, %s" % (width, height)) Blob.__init__(self, width, height, color, emphasis, highlight) 
https://github.com/JordanRL/Newton/issues/4
Javascript, I suspect, is including all the node.js stuff. Also, if you do the V portion of MVC with something like Angular.js, the .js stuff is pretty vital. Personally, I think we are going to see more and more .js code out there as node.js grows. To me, it's the most interesting of the web development languages out there. PHP will live on forever though just like perl is still around because it has been so important for so long.
I do not know of an answer. I am curious as to how you'd want the library to look and function. Would you define the relationships on the mapper object? How would you relate entities that are stored in Redis to entities stored in MySQL or Mongo? How would lazy loading/collections/pagination work with these relationships? How would you prioritize saving, which entity is the master? How would querying for master entities based on values on the related ones work? If your entities are just plain POPOs and you'd use a mapper and repository to translate them to existing DBALs, this may be a pretty small project (with a lot of external dependencies). 
Doctrine does everything you listed. The entities are POPOs with the exception of the proxy objects it generates to help performance. It includes functionality to do database generation but you don't have to use it and it doesn't care either, that's what the mapping is for. It also doesn't care about your setters and getters.
I've tried to get away with simple CRUD in previous attempts, but ultimately one needs to run more complex queries (and not just for reading, but also updating and deleting). In real apps raw CRUD gets only a very short distance before it falls flat on its face. For my tool I've decided to draw the abstraction line at "RDBMS neutral, but definitely relational". So I expose a way for people to specify which fields they select, filtering conditions, sorting, limit, and so on. It's technically possible to separate the query generation &amp; execution from the pure mapper, so the mapper can be used for non-relational sources. But I haven't had the time to explore this, and there will probably be some cost for the split, in terms of added complexity. &gt; Nice username btw BIIITCH My man!
I love PHARs for obvious reasons, however they come with trade offs for convenience. The primary trade off being performance. This is why we have seen them used so well on the CLI as performance rarely matters (compared to PHP on the web at least). I personally am not a fan of using PHARs _in their current form_ for libraries. Their original intention was for whole applications (my initial target was phpMyAdmin) and they definitely work better in this capacity. I will say that there is no technical limitation preventing composer/autoloaders/PHARs from working together that I know of. Also, my latest library, akamai-open/edgegrid-client *is* also available as a PHAR so we could provide people with a drop-in download. Personally, I prefer composer installation. FTR, [box](http://box-project.org) is awesome for creating PHARs, for anyone looking to do so :) 
I haven't given the relationship question much thought. If I found something that handled the rest of the requirements properly, I'd just take whatever relationship stuff it gave me and deal with it.
I haven't studied how reading PHARs is implemented, but I would imagine there's an opportunity for a speed boost over multiple PHP files. In my mind, one could load the PHAR from disk and store it in memory while it is being used. Then any request for a file inside the PHAR could read from memory and parse if necessary. Unlike a giant, single PHP file, you could parse just the files you need, but still only need to read from disk once. Some extra memory overhead, but reducing disk access would be huge. Also, I *love* Box.
[This article](http://www.sitepoint.com/boxing-apps-phars-quickly-easily-box/) is a pretty good introduction to Box, the de-facto PHAR builder. For web PHARs, [this article](http://www.sitepoint.com/packaging-your-apps-with-phar/) is pretty good too, though a little dated.
Ok ya I was confused by the original question. In the cases you guys are describing why not use a crosswalk pattern and declare each specific mapping? Propel would be best for this, utilizing multi component entities and cascading packages.
You don't have to use annotations at all. You can provide the mapping in XML files, YAML or even plain PHP. This also decouples your entities from the database. Many projects (such as FOS UserBundle) use this so their models can be used in different backends. Doctrine has the ORM (for relational databases), the ODM (for document databases such as Mongo and CouchDB) and there's even an OXM for mapping to XML. The ORM is the most popular, but not the only backend for Doctrine.
Are you sure that your code does not override the setting with ini_set()? Or maybe it is only set to show some errors but not parse errors? 
 &lt;?php echo 'hello world! ?&gt; Shows a blank page
Negative, it still shows a blank page.
Godaddy shared linux hosting
I'm currently using some form of your first option, but they're separated code bases. All business logic is in one repository and then there is one repository that exposes the API as RESTful API and another for the "usual" frontend, both use the first repository as dependency. That way they're separated and independently scalable, but don't duplicate code.
I second that. First it was fpdf, but it's a pain to work with it, not to mention the lack of utf-8 support. Then it was tcpdf. Now there is nothing better than wkhtmltopdf.
You mean the HTTP status codes? [Wikipedia](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes) has a list, and there is a nice table on [MDN](https://developer.mozilla.org/en-US/docs/Web/HTTP/Response_codes).
Doctrine mappings in PHP: http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/php-mapping.html
I am not the author. However I agree with the author's recommendation. I personally found the strategies the book talks through very useful.
I've been looking in the same subject a few weeks ago! just a hand full of notes: - theres some phar stuff in composer, but that seems for extracting packages that are offered as phar - i hit a pretty bad performance when i tried to run phar based stuff on hhvm (extremly bad) - if you had composer packages as phars, then you should extract them before you make a phar of the whole project, as you don't want nested phars - clue has build phar-composer which allows you to install apps (mostly commandline) from composer as phar https://github.com/clue/phar-composer - which is quite usefull - I've started a project (and i will go further with it at some point) which is quite similar, but has a few other goals (pharckager) about your questions: - someone who uses PHP before 5.3... most likely won't use composer anyways (and people using 5.3 deserve a slap in the face. with a fish. a frozen one.) - deepends, as mentioned, quite bad on hhvm, not as bad on php - correct, but for the signatures etc, there need better ways of actually verifying those for the enduser - probably a mix of both - unlikely, keeping the packages there would mean that packagist (which so far only has meta data) would need to become a hosting solution, but this can be build on top of githubs release system for example 
I'm also interested in ORM theory and design. Don't you Post entity miss an id property? Where should it be handled?
&gt; And I often have this situation in real projects (same hydrated objects from different mappers; same output, different sources; or same input, different possible mappings). If the same entity can be stored at different places, how do you uniquely differentiate entity? With an ID? Do you share this ID among all possible places? Then you have to generate those ID from a unique master source. If it's the a regular MySQL auto-increment ID in the Post table, you have to create all Post in MySQL first. Another solution would be having a global sequence generator across all storage places (it can also be an auto-increment, but not in the table which stores the entity, so it can be re-used anywhere). How do you figure out in a mapper that an entity is new or already exists?
I don't think so. Things such as upload max filesize exceeded would be a startup error. Parse errors can happen on runtime when including other PHP files.
independent of the fact that the recent versions, the "ajax" versions of phpmyadmin have made it unsusable for me a) you log in with the database username / password, fresh installations have root and empty password, good hosts would send you the actual data b) if the database server is NOT on the same server than the phpmyadmin instalation you might need to edit the phpmyadmin config
Oh, so in order to use phpmyadmin the website has to be online via a host? And i don't have any username password..
If your application doesn't use database (by this description, it doesn't) and you don't know anything about database (seems you don't, based on your posts), then I'd suggest to read up about database systems first. :) I unfortunately don't have any "guide" or "simple introduction" available, but hopefully someone else will post it. 
Well, no code in the script will run on a syntax error, so technically, it isn't going to run at all. I'm assuming this is a startup error, and exactly what that directive is for. You raise a good point about includes though, perhaps they raise a different error at runtime which would be after startup? OP wasn't clear if this was with included source or not.
You have a couple of options, you could either create the password for root within the command line. Or you can go to C:/wamp/etc/phpmyadmin/config.inc.php or C:/wamp/phpmyadmin/etc/config.php find `$cfg['Servers'][$i]['AllowNoPassword'] = FALSE` and change it to `$cfg['Servers'][$i]['AllowNoPassword'] = TRUE`
 /* ## Start security codes ## */ function secure($i) { return addslashes($i); } if(isset($_POST)) { foreach($_POST as $key=&gt;$value) { $_POST[$key] = secure($value); } } if(isset($_GET)) { foreach($_GET as $key=&gt;$value) { $_GET[$key] = secure($value); } } /* ## End security codes ## */ Um...we need to talk... http://www.phptherightway.com/#security
It is an old source and it has a lot of flaws, by your collaborations we will achieve a better code. Send your contact details through the website to talk. 
Let's not forget the [proposed 7XX HTTP status codes as well](https://github.com/joho/7XX-rfc).
I recently started writing a package that sounds similar to what you're after. You simply pass the input parameters into the class &amp; it modifies the eloquent query builder appropriately. Rather than having a big list of IFs, the logic for each parameter-type lives inside it's own class. **How it works In a nut-shell:** I have class called EloquentQueryModifier (EQM) that is aware of a bunch of classes called modifiers. Each of these modifiers corresponds to a parameter type (sort, filter, selecting columns etc). The EQM also knows which parameter belongs to which modifier. The modifiers all share a common interface, allowing the EQM to loop over them, passing in the parameter which in turn allows them to do their thing(which generally entails making changes to the eloquent query builder). That's the top &amp; bottom of it. **You can see how the package is consumed inside one of my repositories here:** https://github.com/johnrich85/pixelartmarket/blob/master/modules/Catalog/Repositories/ProductRepository.php **And here is the actual package (currently nested inside another git repo as it's a WIP):** https://github.com/johnrich85/pixelartmarket/tree/master/packages/johnrich85/EloquentQueryModifier Unfortunately, although it is working it's not complete. It needs a lot of polish &amp; some unit tests are missing. You could certainly use it as a reference though.
Php can't parse the file because it's syntactically wrong. So setting error levels within the file won't help. You need to change display errors and startup errors in php.ini on the server. I'm not sure how to do that on godaddy.
When you say exists, I assume you mean at a particular source, as it's not up to the mapper to figure out if something exists in general, across nodes, or not, it just maps from one source to one target. If something doesn't exist for the particular mapped source, I return an empty array of results in my mapper (as my query results can always be more than one same-typed results, so it's an array of entities, like an SQL resultset). Null is also fine if you return one or zero results, but I don't have separate methods for "just one or zero results". As for how you figure out if an entity exists at the service level - if it's namespacing, then you know which node to ask as the node is part of the id. If it's caching, you ask cache first, if not there, you ask the canonical source behind it. For UUID and other sources where it can be in any node, you need to ask all nodes, and they should all reply. Note, every node can have its own persistence layer, and so its own mapper. The last scenario (asking all nodes) can be optimized, actually, with bloom filters (look it up). A bloom filter tells you out of, say, 16 nodes, 12 nodes definitely do NOT have a given id, but 4 nodes MAY have it. You ask 4 nodes instead of all 16 nodes. There are many algorithmic tricks like that, which make the distributed approach a plausible scenario.
Legacy code? You're basically coming a long kicking someone for something that was quite common years ago. It's like someone kicking you in 5 years for using Laravel. We all make mistakes, but when someone is asking for help isn't the best time to just point out what they did wrong years ago.
If the file is not valid PHP (i.e. like syntax errors), nothing you put in *that same file* will execute.
Started learning pascal for a course in school 2 years ago, eventually ended up learning PHP to build a few dynamic sites. Got hired for a TV streaming/advertising company almost 2 months ago. I applied for several jobs before landing an interview for the place I currently work, I had no work experience just a GitHub account with a few of my projects. As for advice, perseverance. Keep learning a little bit each day. I find that building things you want to use accelerates learning and prevents boredom/frustration. Also, don't just learn php, learn how php works (the interpreter), how http works etc. Pick up a framework, build with it, take it apart to learn how other people are using PHP. 
I tried to push them into symfony last year, but my joke wasn't too popular amongst the maintainer
I have none of them. I have no certifications at all, actually. Honest question: Can you tell me in what way it helped your career?
I have none of these, but I am hoping to get zend certification sometime soon. Personally, since I do not have any degree/diploma related to IT/Web development, I think it would help in some ways for the employer to understand if I am beginner or not in PHP
Yup. Learned really basic HTML to try do a website for a friend. After loads of repetition I googled around and heard something called PHP could let me "include" one bit of HTML in numerous files. Cool. Then my friend asked for a "guestbook", whatever one of those is. Found one online and played with trying to change things with limited success, but it gave me some exposure to actual code even if I didn't understand it. It was probably a month later before I even found out what "echo" did. Built one or two more sites for other people and started adding basic CMS functionality and learning about databases. The code was still awful, but I had something working that I could show people in a browser. Blagged my way into a junior role by showing what I had managed to pick up on my own in a fairly short space of time. That was about 3 years ago. Currently Head of Technology at a marketing(ish) agency with a team of developers under me and some pretty huge clients. Spend most my time working on bespoke internal systems and improving the quality of our end client apps. If I was going to give any advice it would relate to any field, not just software development: Apply for jobs you're under qualified for and learn how to do them later. Force yourself into situations outside your comfort zone and you will learn more faster. If you ever find yourself the smartest person in the room, find a smarter room.
This. Employers can afford to take on a junior if they have aced HTML and CSS but still need some PHP hand-holding. If you can't do *anything* well unsupervised then you're gonna have a bad time.
&gt; Laravel comes with its own templating engine named “Blade”. The best thing about Blade is that it allows you to write plain PHP What a gem.
I came from java, learned the basics of PHP on WordPress, moved into oil and gas based companies, taught my self zend and other simmilar MVC frameworks. It was super easy to get a PHP job.
something that twig sometimes lacks... but one could also say if you are mixing php in your templates, you should refactor it someplace else.
If you're worried that being self taught will be a hinderance, don't be. I went to college to get a CS degree so that I could become a developer, but I ended up getting a job as a Classic ASP developer halfway through my first semester and eventually dropped out. At the time--keep in mind, this is 15ish years ago--ASP and PHP were fairly similar, so my personal experience in PHP got me the job. I've gone on to work in a wide variety of languages and frameworks for companies of all shapes and sizes, lead teams large and small, presented to hundreds of people and even spent a semester as a teaching fellow at Harvard. The only time not having a degree ever hurt me was when I was too afraid to go after a job *because* I didn't have a degree. Imposter syndrome is something that comes up a lot with developers, and you just learn to power through it. As far as how or what to learn is concerned, the best way to learn is to just do it. When I'm learning a new language or framework, I pick the tools I want to use (in your case, that might be a specific PHP framework to learn), find a blog, screencasts, online book... something like that... and start coding along with the examples. I always code *every line* they say. Never copy and paste when you're learning. Retype it so you start to build up muscle memory. That'll be enough to help you learn enough to build something, but I actually find the *next* part to be significantly harder. Now you need to build something on your own. The lizard brain paralysis that makes you want to say... I don't know enough to make something... can be hard to overcome at first, but every tiny variable assignment and every tiny condition and every tiny loop and every tiny function and every tiny class just builds and builds your confidence. You'll start to realize the difference between knowing how the language works and knowing every function available to you. And don't stress out about what you build. Everything you make while learning is going to be garbage. You're going to progress so quickly, that the thing you thought could be a real product you built a couple of weeks into that "I think I know PHP now!" phase will look like a disaster a couple of weeks past that. Anyway, just stick with it. *Anybody* can learn to program, and getting an entry level position in web development really doesn't take a significant amount of knowledge. You just need the drive to continue learning. Good luck.
Even better than using `instanceof` is using the Null Object Pattern - it conforms to the interface but doesn't return or do anything (or returns a default state, depending on what the business logic is).
You don't need to *stop* anyone, as long as we're talking about people you work with on your codebase. Proper architecture can be achieved by *encouraging* correct patterns and *discouraging* bad patterns. If the framework makes it *easy* to fetch the pre-configured dependencies, it makes it easy to abuse: @Inject('userRepo', 'UserRepository'); If the framework doesn't give you the repository, you need to build it in full right there in the middle of your template, with its dependencies, including connection passwords and everything: $pdo = new PDO("mysql://username:I#werg%gHergIgH%#@localhost:123"); $userRepo = new UserRepository($pdo); ... with that honking snippet in the middle of your template, it's very hard to claim innocence during code review. Just the mere fact you need to look up the *password* to the connection might make you think twice before you proceed. Especially because the password &amp; host will vary from environment to environment, so you need to also look up where the *environment* is stored and read the connection from *there*. All this you'll need to do *in the middle of your template*. At every step of the way, proper architecture tells you "that's obviously not the right way to do it". Think about it like the way reflection works. You can read the private properties of *every object* in your project. This doesn't mean we might as well declare everything public and give up encapsulation, or go the other extreme and start concocting hare-brained schemes to hide properties from reflection, so we can *stop* reflection users. Common sense works, as long as it's present.
Got into my first job by selling myself. Now I have over 13 years experience though, went back and learned many of the formal things I missed by not taking CS in college, and have worked with several startups. My current position is with a mobile apps company that leads its market on mobile where I make comfortably more than $100k, and I have held positions as a manager and CTO. Learning the formal stuff was crucial though, as was the experience itself. Teaching yourself is fine, but at some point you need some kind of instruction in things like complexity, algorithms, program design, etc.
As a self taught developer that's currently on the job market in SF, it does not matter that you don't have a degree. The work that you've done and your knowledge of programming and systems architecture matter far more. You'll have a better time if you get out of the mindset of being a "PHP developer" and get into a mindset of being a developer with experience in PHP. Some companies will care if you can solve basic CS questions so study up on algorithms and data structures. Can you implement a binary tree search? A stack? A queue? Spend a weekend and learn. It's not that hard. If you're looking for more frontend dev work, everybody wants you to know front end JS frameworks (Angular, React). Backend work tends to favor Ruby and Python over PHP but as long as your experience is OO + MVC (i.e. not wordpress) then you can get a foot in the door. Give yourself at least 2 years of learning if you want to be in a good spot to get hired. Do freelance work on the side in the meantime. 
Fuck what people say. Find jobs, make money, create stuff. We're only here for the blink of an eye.
I use Jasperserver and make calls to the server's API to generate documents.
Self taught, no schooling. Average about $50/hour
I got into php because I was fascinated with download sites like download.com - I built a successful download site in the 90's that was ranked #3rd highest traffic download site in the world. 20 years later I'm now a CTO of one company and president of another. Php is awesome, it has provided me freedoms I couldn't dream of otherwise, choosing php at the time I did was pretty much like winning the lottery, was relatively simple to sell a single banner ad back then for 5k/month (a single banner ad on one page) - then the boom happened and google ads came out - turned my focus into creating an organization that focused on making companies paperless. I love php, it's my life and I highly recommend it.
I'm on 9.0.1 EAP. If I download 9.5 and install it, will it keep my settings/preferences?
And you didn't learn grammar or anything either so I guess it was a waste of money... 
I developed a fascination for web development around '97, shortly after we finally got internet access, while still living with my parents. I was about 17 at the time and learned HTML and CSS up front by picking apart others' websites. My mother would yell at me to get off the computer and do something. Then got into Perl and learned a fair amount by doing the same... picking apart projects. Soon thereafter I got into PHP (I recall everyone naming their files `.php3` when PHP3 was released). For a long while I was intimidated by going full-on RDBMS and everything I wrote utilized text files as the database. I ultimately got into MySQL and now laugh at the time it took me to even give it a shot. I went to school just to get the piece of paper that said I had an education... which after the many interviews I've been through, I wonder if I've even needed. Got an instructor fired for plagiarizing my "term project" to sell to a client of his. Everyone wanted to cheat off me. I now pull in a pretty darn good pay check for the area in which we live and I really owe 100% of it all to myself! * 2006-2008: $36k/yr * 2008 (5 months): $60k/yr * 2008-2013: $65k/yr * 2013-2014: $75k/yr (100% 1099 work, would not recommend) * 2014-present: $75k/yr (back to W2, highly recommended) w/ $5k-ish in freelance Plus the wife brings in nearly $40k as a teacher. The median household income in our area is under $31k... doesn't even feel like I'm working. Plus I'm in the gym at least five days a week, in the heavy section (not bragging, just letting you know my life isn't exactly non-stop work). I wonder what my mother thinks now!
Who isn't self-taught? They actually have PHP courses in colleges now? I started out in Perl. All self-taught in the late 90s. I moved over to PHP turn of the century, as it seemed like the natural progression things were going, and Perl was getting boring. My first "PHP" job was actually doing Perl, but during it we decided to migrate to PHP. I was already self-learning PHP on the side; so, this was a way for me to move on over. My next job was solely PHP and had been since. I took every attempt at work to try and use new functionality and features of PHP, leveraging things I've learned object wise from OO languages (Java at the time). To this day, I'm still self-learning PHP. 7 is right around the corner! It's going to turn the industry on its head. Nice seeing a script language give a compiled language (java) a run for its money. ;) 
After getting a degree in psychology, playing music professionally for a couple years, in 2003 I helped a friend build a new wiring harness during an MR2 transmission swap (automatic to manual). He was approached to manage a startup which needed a "web programmer," and we both figured, "how hard could it be?" Startup failed. Several years later, I have a pretty decent job with Magento. I've met a lot of others at conferences with similar stories. Keep at it, and good luck!
me Edit: Oh, there's more than just a title. Guy approached me at 17 said build me a database management thingy I said yes he paid me like a kid it was great. Currently working remotely full-time on contract for a company based on NYC. Have worked for Marketing Agencies before. Build stuff in Laravel if you want to learn PHP and do stuff with value quickly. Otherwise, learn Javascript and built stuff using SailsJs -- Node is really popular and pays more iirc.
Not a concrete one without the context of a real application, but generally speaking it's used as sloppy error handling. Something failing to load and instead of raising an error instead returns a Null Object, that kind of thing. I think it's slightly preferable to just returning null since you avoid the method call on non object crashes, but that's going to be a catchable error in PHP7 so I'd opt to use that instead. 
Not exactly, but close: http://fatfreeframework.com/databases Here are the docs: http://fatfreeframework.com/sql-mapper Your requirements 1. Check 2. Check 3. Check 4. Sort of... You can do $mapper-&gt;column or $mapper-&gt;get('column')
I got into PHP around 2000, am entirely self-taught. I did some salaried work for a while, then went self-employed. Until about 2011, PHP was the majority of my work - but in recent years its taken a backseat to NodeJS/Javascript-based work. I enjoyed php but with the lack of direction (before 7 was announced), and the speed and async of node, I don't expect to return to php work.
#I often feel like a very lucky person# I started tinkering with ASP back in 1999 for a few months. I made some image uploading scripts and simple junk for my school's website. Then I found php3 toward the end of the year. I stayed up for days at a time doing this and that. I continued to mess around with it (with no real projects) for a couple years. In 2003 I was really starting to get in the groove of making large pieces of software for my own entertainment. I made a few full fledged frameword/cms kind of things (I called them web engines at the time... still a cool name, I think) I moved to Montreal to do some design work with some friends I had met that lived there... until I had to come back to the US. While I was there, I got exposed to more web work, like actual work that people paid for. When I moved back to the US I received a random call from someone that read my resume on monster.com to take a temporary job working on some HTML based projects for a small graphic design company 60 miles from where I lived. Eventually, I just kind of stayed there. While I was there I was basically given the freedom to do my work however I wanted, as long as it got done. I was the sole web person there. So of course I used my "web engines" to make work easy. I really honed a lot of skills administrating servers, working with CSS and Javascript, and of course beefing up on my PHP skills and started to get into OOP (considering I was working with a framework sort of system) Moving forward 2 years, I saw an ad for a company that was looking for junior developers that was WAY closer to where I lived. so I applied, got the job. They were very impressed with my ability to solve problems (which is a skill you really only get when you're self taught or you've been on the job for a while) At this point I began work as a payment system engineer. Which was awesome because it was the first time anyone referred to me as an engineer and I got a decent raise in pay (really nice considering I had a kid on the way) After working there for about two and a half years, there were large cut backs and only a small handful of people were kept. Unfortunately I wasn't one of those people. So I started doing some free lance work to keep the bills paid while I was searching for a job. This was 2008... finding a job was pretty rough. After about 6 months I finally find a temporary job working in an office where I was the only PHP developer, the other two developers was ASP guys, so every so often I had to begrudgingly help out with some ASP work. We ended up getting a client that wanted us to build a fairly large website, one that can only be referred to as online software. It had pretty in-depth business logic and the job was given to me. After completing the job, the client wanted to hire me directly. Which was a little shady, but not as shady as my current employer who was holding back on wages for over time work and things of that nature. regardless, I had no contract with them. So now, 6 years after that, I still work at that same company as the lead engineer/architect/developer/dev-op whatever you want to call it. I run the show basically. Everyone works from home because we like it that way, and we just kick ass and get things done. No one that works for our company has ever had any formal training in web development, and it really works to our advantage. We're all really happy in out little company. #TL;DR# No schooling, poked around, moved from job to job getting a better position and pay at each.. now I work from home and save the world, and basically run the joint. #salarys for those interested# * 2001: $0 * 2003: about $15k * 2004: around $20k * 2006: $47k * 2008 $65k * 2012: $76k * current: touching $100k with a little side work, working from home, making my own hours! #metrics for those interested# * no school * 100% self taught * second in command behind the owner of the company * Live in ohio * 31yr old
I started late, at around 23 or so. Dabbled in other stuff before it, but nothing serious or highly sellable. Then got thrown into the fire in my first job still during college, learned MVC there (on my own, code was a mess and no one in company capable of explaining) and it took off from that point on. I was support at first, then moved into minor feature development and fixes, and as I experimented at home and showed more promise with quick deliveries, got higher up the chain. I got promoted crazy fast, but don't get me wrong, it was far from a piece of cake - in between a conference/meetup or two, I worked 16 hours per day for a year or so - at home I just showered and slept; shitting and eating happened in the office. The main turning point from hobbyist to professional for me was the ability to finally recognize shit code, and turn it into something decent. That made me instantly hireable elsewhere, which I used and left the job to freelance. I've been freelancing from home full time ever since, and have never looked back. The advice I'd give you would be: - never stop experimenting. Build and break stuff *for fun*. - learn good decoupling and modern practices. Getting away from spaghetti code is easy with books like [these](https://leanpub.com/mlaphp). - join conferences and communities. Go to as many meetups as you can. Find mentors, peers and people to talk through your troubles with.
Spot2 has no way to map an entity field to a database column. It needs the two to be the same, thus defeating literally the entire point of a data mapper.
During your 13th something years of experience, how long did you manage to bypass features like _functions_ ? 
&gt; Personally I think it would make more sense to establish a common application plugin/bundle format atop PHARs. I can agree with that, though I can't think of too many things PHAR libraries would need extra, functionality-wise. Even now, you could just write a custom autoloader, put it in the PHAR stub, and start using it: // libcool.phar spl_autoload_register(function ($className) { $fileName = str_replace('\\', '/', ltrim($className, '\\')) . '.php'; require 'phar://' . __FILE__ . '/src/' . $fileName; }); // coolApp.php require 'libcool.phar'; // Start using libcool classes What do you have in mind that a PHAR library would also need?
I thought myself via internet mostly. Did a lot of html + css and then slowly started to do PHP because of Wordpress. Hated college so I did a bit of freelancing because I watched all TV shows that existed ever and I got bored. Got my first job by replying to a job ad - stayed there for 3 years and learned a lot of PHP mostly by myself. Got my current job by sending an email: I'm such and such, did these sites, call if you are interested. Learned a bunch more proper, modern PHP. I now have a team of 9, a high profile project, very good salary and PHP project that is nice to work on. I mostly manage now but I still love to solve problems. 
I would want to drive off a cliff if I did so much work in Magento that I needed to get certified in it.
I graduated with a degree in Computer Science. After graduation I started programming PLC's in a proprietary block programming IDE for a few years. While working there I was in a online gaming league with some friends and we needed a site to manage the league (rosters, stats, etc). Out of all the people in the league there were 2 of us that were capable of developing it. He did some web design (HTML, CSS, JS, etc) while I had the same experience plus a little Java and C++ from college. We spoke about what needed to get done and how we wanted to do it. We decided PHP was the most logical choice so I started learning PHP while he handled the design. Shortly after we finished that project I saw some ways I could use PHP to improve things at my job. Just a basic site that tracked software versions, customer support calls, PLC board versions, etc. At that point I enjoyed web development and PHP seemed to click for me. I had always gotten a lot of interest from companies but I wasn't really looking so I ignored it until one day I was contacted about a PHP position (I rarely saw any PHP positions) and it was in a city I really liked so I figured I'd check it out. I went through the interview process and was very transparent about where I was at with my learning. I'm sure they liked the fact that I did personal projects as well as used what I learned to try to help my current employer so they made me an offer. I have been here for a little less than a year and there are several people who are fresh out of college (with a few PHP courses under their belt) yet I still think I'm the weakest developer but I put in a ton of effort and I continue to make great progress so I have no concerns about my future here.
You are really overestimating your experience level imho. PEAR, Composer and abstraction levels are things that exist outside frameworks and even a mid-level developer has to be able to deal with those. Especially if you find things like CakePHP and Laravel hard or too abstracted, because they are most definitely not. Making a "decent sized web app" is (imh again) a junior level skill definition. A developer that cannot make a site on their own is no developer at all in my book. What I would suggest is just pick one framework (toss a coin) and read the entire docs and only then try going through the tutorials. This should help you to not waste the time later on.
I'm pretty sure almost all php developers are self taught.
Or Eclipse, or Netbeans, or even Vim. Or Codebug. http://codebugapp.com/
I've found that it takes me about 2 weeks MINIMUM to really start to grasp a framework, when working on it full time. It's rarely easy for me so I can sympathize. They never seem to come with simple definitions as to what they do, how they work, etc. But rather, they use slogans and strange abstract language that don't help. But, once you get a grip on a framework, you'll start to gravitate towards using one because it can be valuable to not constantly repeat yourself.
It's a harsh truth, but I think you're 100% right. The problem here isn't the tools. 
what ... there are institutions that actually TEACH php ? i havent met any non-self taught php dev so far
Amazing! That worked. The trick seems to be removing the '' from around $page-&gt;Title()-&gt;kirbytext()? 
Hours to setup an environment? There are hundreds of LAMP VMs out there that get up and running in less than an hour.
started with Python but left it early and moved to php. Started working as a freelancer for shit cash. One thing lead to another and I landed bigger and bigger gigs. Eventually I got hired by a really good company where I learned a lot and kept moving around learning from different tech peeps. I never stay in a company for more than 2 years. You have to keep moving in order to learn from new people. That's my 2 cents One thing that I've learned is that: it doesn't matter how good you are. What matters is how willing you are to learn new concepts. Degrees don't matter for shit. All that matters is the time you invest in your craft!
Thanks! That was actually the last bit of code I needed to iron out and now the news blog is up and running, but I will definitely try to learn more about PHP and grab a book. Know a good one? Now the task of filling in all the content...oof!
Yup, completely self taught and never spent a day in college. I started by picking up a couple of basic PHP books and doing all the tutorials in them. Played around building stuff and started doing little freelance jobs. Learned everything I could about HTML and CSS and did a little bit of design work. Eventually did a freelance job for a web agency and got hired full time. Since then I have worked for a bunch of different companies, travelled internationally for work multiple times, and am currently employed as a (remote) full stack developer at a (profitable) startup. ([We're hiring, btw](http://careers.wheniwork.com/).) My advice is read more books about design patterns than books about languages. You'll have way more fun and learn things much faster if you stay curious. Get involved with some open source projects (preferably ones you actually use) by reading the issue tracker and fixing bugs. Learn another language, even if you don't use it professionally. Learning other languages exposes you to new ideas and helps you understand programming as a craft. Learn stuff that your job depends on, for instance learning how to set up a Linux server with ssh, nginx, haproxy, and iptables will teach you a lot about basic devops. Learn about the "people stuff" by taking some basic leadership courses or working with a life coach... it might seem kind of silly at first, but being able to communicate with people effectively is a huge part of being successful, regardless of your career. Most of all... if you don't enjoy what you are doing, go do something else. :)
I work for a small local company in California that deals with association management and a telephone exchange. I'm 19 years old and haven't gone to college. I've been managing websites since I was around 13? Mostly running forums from myBB to vBulletin for gaming communities I was running. My friend was working for this company doing webdesign work for their clients. He was leaving for a company that is strictly a webdesign/app design company as opposed to association management. He recommended me and they told me to design a web application in PHP and email it to them. They then scheduled and interview with me and I was hired that week. Been workin there for a bit over a year. Full time IT assistant / web developer. Though we MOSTLY manage Drupal websites as opposed to writing websites from scratch. Regardless, I'm happy with my job.
Didn't read the link eh? It's the first bullet point &gt; PHP REPL (read–eval–print loop, interactive console for PHP);
I got my first job by finding freelance work online. The company I started working for had a need for more staff. They liked my work and eventually hired me on. I've changed jobs twice since then... generally without much effort. I have no degree... I've never stepped foot in a college and I currently make over double the national average annual salary.
Earlier the page said RELP... And now I look like the dummy :(
It usually does. I've had the same preferences for many versions. 
&gt;it's like an alien trying to read Esperanto. Seeing as to how logical it is, he would probably have a much easier time reading Esperanto than any other language.
I'm in your boat exactly.
I no longer try to make individuals rich. Yes, I have more apprentices than ever right now, since i started the recent training in August. But now I'm much more focused on enriching the lives of entire cities, even countries. 
I offered to mentor you guys for $100/month in 2012. Something you all ridiculed, harrassed and lynched me for so much that I was banned and left, depressed and dejected. It's too bad. The dozen or so that I've taught since Sep 2008 make on average $45/hour now. I always thought $100/month was an absolute bargain for a lifelong 6-figure career.
It has but terrible. "go to next line" and other navigation commands are under right click. No GUI buttons for that
I started developing my first qbasic "programs" when I was 14/15 years old (roughly 19 years ago). This peaked my interest in developing. I was really bored by school, only finished elementary (obligatory in Denmark). When I was 18, in 2000, I started looking at PHP. I vaguely remember it being version 3 (unsure, really) and did some basic web stuff in my spare time. I was working in factories, airports, delivery-services - all sorts of jobs for uneducated people. Time went by as I learned more and more about development in general and also more specific PHP related development. In 2006, I had a fairly large amount of people working with development on my ICQ and MSN - people I basically met via IRC, forums and similar. One of those guys knew a company who needed a cheap PHP developer working full time. He recommended me to the company and I started working professionally as a PHP developer. My first job as a professional developer ended with a termination because of the economy crisis. I got a new job three days later at another company developing video content management system. In 2012 I ditched that job to become a senior developer at another company. After three months employment I advanced to being the head of development in that company with responsibility for four employees. Late 2014 I was headhunted for a new management position within an international software company and today I have the responsibility of 9 developers across two countries. I have no education. I've had no courses. I love what I do. And I'm good at it. Be passionate about what you try to accomplish and you'll succeed. I wish you the best of luck.
I've started really young (≃ 12yo, can't remember exactly what age) with Basic on a MSX. My first professional language was Perl and from that I've got into PHP (circa 1999). Got my first PHP job in 2000, single handed developing an web application that accessed both an Oracle and a PostgreSQL database. I can't really speak for other countries, but in Brazil there's a huge demand for good PHP programmers. If you're good and serious about your code chances are you'll be hired in the blink of an eye.
I self taught the basics of programming, and PHP, but had some study. I started making dos games at about the age of 12 in megazeux, moved on to mirc scripting, then more games with Game Maker. Had a bit of a play making game websites with PHP, high scores etc. Went to tec to study ICT at 21, learned C#/Java. Got a job while still studying doing PHP. Spent 5 years doing that job, then moved onto a new one as a senior UX dev doing both PHP and Node. 
&gt; It is common knowledge that PHP’s fputcsv function does not allow enforcing the enclosure on every field What's the benefit in enforcing them?
Sometimes the best thing you can do, when trying to understand a framework, is to try to reverse engineer the framework itself from its outlined usage within the documentation. When you hit any walls you then appreciate *why* they tend to work the way that they do. That said, I do notice a lot of developers these days gravitating towards incorporating numerous frameworks into their projects, essentially creating "venn diagrams" of application intersections and bloated excess code margins. It's a strange phenomenon which I can't attribute to one reason, but I *wonder* if it has anything to do with 1) how classes are now being taught for most CS programs, 2) whether or not it has to do with an increasingly rushed climate in software companies and engineering departments, and 3) a symptom of a culture increasingly infatuated with new toys that assuredly promise new features. I realize all things change so I don't want the tone of my response to convey bitter nostalgia, but I greatly appreciate having met a few really solid old-school programmers who would scoff at the idea of using a framework because readability, in their eyes, should never take precedence over performance. I think it's something lost on a lot of newer developers which, unfortunately, means we're going to continue seeing the cumulative results of a feedback loop of dependence upon frameworks to solve problems and the necessity of learning them due to their widespread use.
Interesting. Would love to see some complete "hello world" examples just to see how all this fits together. It seems like a very solid foundation, though probably not something I'd ever recommend to less experienced developers.
I like the idea, but if I have a function `f(User $user = null)`, I think checking for null is the most expressive and sensible thing to do.
http://zend-expressive.readthedocs.org/en/latest/usage-examples/
First Job: I started programming as a child in the 80s and had already learned several languages by the 90s. In mid/end 90s i started a "web design" business besides school, and my first customer needed a database brought to the web. A friend of mine hinted me on this new language called PHP, so i gave it a try. Most of what i learned was from reading the documentation, and talking to people who where already doing PHP Second Job My business didn't really work out (i screwed up with taxes, because i was a student after all, and the subject was more complex than i thought), so after school i got hired from one of my customers as a "trainee" - basically i was the only one knowing about programming, but we did that trainee thing because at that time i wanted a paper saying that i learned a job. (that was in '99), during the same time the PHP community in germany started forming, and I was quite active in that - so one day a guy i helped on IRC offered me a job, so i quit that training thing and started working a regular job. The Company I was working for supported my activity in the PHP community, and soon some guys who where writing a book on PHP asked me to do a technical editor job on their book, then on a second one, and for the third book I was asked to join them a a co-author. Also I got active in Open Source Software during that time (which i still am) From there on out I switched jobs a few times, not all of the PHP related. Today I'm senior developer for a game publisher, and in the situation that i can basically pick my job due to my huge experience. Looking back on my own story, which sounds quite awesome, i have to add a few notes though - I worked extremly hard hours for quite a while in that, and besides regular work, i spend (and i still do that to some extend) a lot of my free time to learn more and keep up. - I got very lucky with a few jobs, a lot of right time right place situations so I wouldn't recommend anyone starting a fresh career this way nowadays because: - the industry has changed, applications today are a lot more complex than in the end of the 90s - learning how to work in a (existing) team, and learning the tools of the trade is something that training is for, there is a difference from a midnight hacker to a professional - more competition - less chance of being at the right place at the right time ;)
thank you so much 
My issue with xdebug is how much it slows down each request. 1.5-2.5 second requests with a Vagrant VM + NFS, versus 300-800 without (still working on why it's still quite high in development normally).
This looks really promising. The docs are delightfully thorough considering the relative immaturity of the library.
If you are on Windows and need a lot of pear, install vagrant and be done with it.
Yes, it's just like you have a much easier time reading Haskell than PHP. Because of how logical it is. And that's why Haskell and Esperanto are so huge right now in terms of market share. Cause they're so logical.
It looks a lot like what the next 20-30 frameworks will be. Near the end of the RoR clones age, we are. The middleware age, begun has. Just as annoying, it will be. 
Yeah I don't exactly get the hard on for middleware that is going on in PHP world at the moment, it's like none of these people have worked with Flask or Django before...
To use a monad effectively, the entire standard library has to be built as monads, so Maybe can be typed as a monad which is accepted everywhere any other monad is accepted, and you can compose various monads together. Because PHP is not Haskell, this is not the case. Instead of Maybe, we have null. If you want to avoid checking for null explicitly for optional values, read about the Null Object pattern, which is sort-of like Maybe monad, but one adapted to a specific existing class or interface. I personally don't bother with either one of those (well, I've used Null Object here and there, but rarely). Instead, have clear contracts between components. If you type an argument as FooBar and it's not optional, null won't even pass through. So avoid optionals unless you really need them. Check for null where you need them. Problem solved. Alternatively, code in Haskell.
And then what? Find some distro... so which one? And then what, I'm now running a vm so I can run another OS just so I can download a fucking phar file? Seems a bit much.
I was in the same boat and couldn't pick up any framework, however, Laravel gelled with me. It even helped me learn how to use composer and I wouldn't look back on using another framework or barebones PHP unless I ***really*** had to. You could try building a blog using Laravel or another framework of your choice to get the "feel" of it. I wouldn't worry about how it works under the hook just yet. Wait until you know how to use the framework then explore the code that makes it work.
You can do this on a Mac, called a Mamp stack but I would strongly, strongly advise against it. Not only are you bloating your OS in a nearly irreversible way, you're also binding yourself very tightly to whatever stack is used on that one project. Also, forget about trying to work on more than one project at a time without a moderate amount of hassle. Oh and deploying that project you just finished? Good luck remembering all the configuration you had to do to get the technology stack you're using to work in the first place...you did it 6 months and 3 projects ago and you don't remember much of it anymore. There are lots of good reasons NOT to use a wamp/lamp/mamp stack for development. Virtual Machines are the solution and a great one at that. There are actual fixes that address the file system mirroring imperfections; I'm pretty sure setting up vagrant to copy files via rsync (so that technically, two copies of the file exist, one on your Mac side and one inside your VM). I believe there is another alternative to rsync that fixes the file system latency issue nicely, I just can't recall them atm.
It's not WordPress. It's a *fork* of WordPress that, basically, adds composer.json. It doesn't take a lot to maintain that, I guess. And the Packagist visibility explains the popularity.
Started back in the early '90s with Mallard Basic on my dad's Amstrad. Discovered Linux, Apache, PHP, MySQL/PostgreSQL and stuff in 1999-2000. Found Ruby in 2001 which helped my general understanding of programming a lot. Kept hacking away in my spare time and on the odd freelance project and a few Open Source project all while doing a master's degree in linguistics. Today I make my living as what can probably best be described as a full stack developer. I do PHP, Bash (and whatever other language is required), minor sysadmin tasks, a little project planning/design, etc. And I couldn't possibly be happier. :)
I'll take a look at using rsync or something similar to transfer the files as opposed to running MAMP/etc locally, thank you. Just did a bit of quick googling and Vagrant + rsync seems easy enough to setup, I'll get it a shot in the morning. I'll put a copy of the code on the Vagrant boxes HDD manually first to see the difference that it'll make before I sink a lot of time into it, but I'm sure it'll solve a lot of the slowness since according to the Debugbar the bulk of the latency is typically booting the framework and the IO needed.
I know naming things is hard, but good lord...zend-stratigility, zend-diactoros
Hehe, I love the "bus factor" metaphor
Understand that a framework is really just a collection of tools. Install symfony or laravel. Go to the vendors folder and study each tool see what it does. 
The trick to frameworks isn't necessarily about learning the framework it's about learning the patterns and concepts that the framework is based on. Essentially what you're probably dealing with is a lack of familiarity with those patterns and concepts. If you're having a lot of issues with composer try playing around with autoloading separately to see if it brings you any ah-ha moments. That and package management are basically the core of what composer does for you, it's not really much deeper than that since composer packages should handle their own dependencies. Most of the time (in my experience) a framework will have [_toString](http://php.net/manual/en/language.oop5.magic.php#object.tostring) handling for the database queries it builds so you can expose the query itself and debug it rather than relying on generally unhelpful stack traces (particularly when they trim the query). If you find yourself constantly having issues with a db query try converting it to a string and debugging the query itself, you're probably not building the query you think you are. If you're using a VM for your virtual environment initialize composer from *inside* the VM. It'll save you some potential headaches. If you're using an xampp/mamp/wamp equivalent you may have issues with portability of your scripts, especially if you're in Windows, and should be using something else for actual testing. The Intellij IDEs can support newer PHP's ability to run up a server and while you won't be able to test server rules (htaccess/nginx) it will at least gives you a quick and dirty testing environment without the, somewhat, extra set up that is required for those ampp environments (obviously this doesn't include a database server). Basically between this, your debugger issue, and you're need to see the definitions of framework elements you should probably be using a true IDE, Eclipse and Netbrains are nice but I can't recall if they can easily set up a php server. PHPStorm (intellij) *can*, it can also manage your vagrant box and composer from inside the IDE giving you some GUI tools that may help you with getting started by easing you into them.
I am self taught, started out with shitty youtube tutorials and wrote horrible code until i learned what OOP, Design Patterns and PHPStorm was. I am currently a developer for ABAX, working on a SaaS web application, I do mostly back-end-y stuff like integrating with API's, creating API's and various internal tools. My advice to you is to build something from scratch, and follow through with it, master your code editor or IDE, this will increase your productivity. be a fucking spunge and extract any piece of knowledge from anyone and everywhere that you can, it will make you a much better developer. Also, don't shy away from other languages, you can easily transfer over skills in one language to another. Finally, read this book: http://shop.oreilly.com/product/0636920033868.do
&gt; And then what? Find some distro... so which one? And then what, I'm now running a vm so I can run another OS just so I can download a fucking phar file? Generally you're live and staging environment with be Linux, you should ideally be developing with a Linux distro running your code at some point, even if it's not running the same Distro as your live or staging. I'd personally recommend running the CentOS distro as that's what I've found the majority of my live code has been deployed to. But, really, you should be running a VM so that you can have an environment closer to what you're code will be running on. Unless you're code will be running on Windows live, in which case I feel sorry for you
http://imgur.com/DJGegbQ ! (just my nitpick because "middleware" sounds odd naming here).
just like Silex. 
Interesting but it looks very similar to Silex. Silex is already pretty mature though and has some good community support.
Grammatical mistakes are better than social mistakes, which is what youre doing. 
Mount the shared folders using NFS and your life will change.
&gt; "Attempt to set up the dev enviroment and send the next X amount of hours dealing with random errors and/or composer issues" If you are not using vagrant or docker in 2015, you are doing it wrong. &gt; "Find you need some random plugin that's in the PEAR suite, waste a few hours getting that to work" I have never had this issue...ever. &gt; "Fumble through the tutorials that may or may not work(*). If they don't, you're spending a few more hours finding out why" If you use tutorials to try and figure things out, you are still a junior developer. &gt; "For the frameworks that build everything via command like calls, wonder why it created the files it did, and why?" Junior Developer. &gt; "Spend your time stumbling around in the dark trying to figure out why certain things aren't working as they should (I found this especially so with routing and database issues)." See above comment. Any php developer should be able to pick up Framework X in a few weeks. Understanding the basics of Framework X should be a trivial task. Some of the larger full-stack frameworks take a bit more time because the code base is actually quite large but they all have their own conventions and it is the conventions that you are actually learning because the rest is php.
I started building websites for fun in high school, and eventually got frustrated that I had to rely on third party services to handle simple things like processing contact forms. In college I looked into what it would take to do that sort of stuff for myself. I had never done any programming before (apart from stupid little BASIC things and the tiniest bit of HyperCard), and PHP seemed the most approachable. My degree is in filmmaking, and I got a job at a local TV station doing video production work, but eventually moved into handling their website. That gave me the résumé foundation to get other jobs as a PHP dev. I currently freelance (by choice), but have worked at an agency, started and sold a web design company, and worked in-house at multiple companies.
A lot of these are false positives. The site fails to discount projects from the same owner when counting dependencies, so there's a lot of projects only used by 1 person, or otherwise small projects that have a lot of repositories (plugins). Other packages are abandoned (for example: illuminate/foundation) and these should obviously be discounted because they've been specifically marked as not being worked on (I would also hazard a guess that dependencies that are marked abandoned are also not being discounted from the dependency count as they should be).
&gt; So it's going to be like Java? But faster? "Faster"? Not sure if sarcastic or dramatically misinformed :P
Are you trolling? Or do you really not understand the benefits of using a guest linux OS?
[**@hoaproject**](https://twitter.com/hoaproject): &gt;[2015-08-27 15:19:27 UTC](https://twitter.com/hoaproject/status/636920970750595072) &gt;🎮 Guess who's who? &gt; &gt;PHP5.5.24 vs. PHP7 RC1 &gt; &gt;\(tests of Hoa central\) [*pic.twitter.com*](http://pbs.twimg.com/media/CNbMP2EUcAAuge_.png) [^[Imgur]](http://i.imgur.com/t8uaTek.png) ---- [^[Mistake?]](/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=/3ilvyo%0A%0APlease leave above link unaltered.) [^[Suggestion]](/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
My first association is F**lar**um is a **F**or**um** software built on top of **Lar**avel. Skimming docs, there's no Laravel. So maybe you might want to know the name is seen this way.
&gt; So maybe you might want to know the name is seen this way. Not sure if good thing or bad thing.jpg
Pretty much.
Maybe he's just using PHP7, since there's no xdebug for that. :&gt;
Can someone ELI5 what this is and why it's useful...?
Imagine middleware as a food line in a pro kitchen: a request for something comes in, in the end you want to return a meal. In between the time it comes in and you return it, you can do whatever you want to it. Maybe your first chef (middleware) puts down the plate, your next one puts the fries on the plate, another puts on the burger, and your last chef timed the entire process to see how slow/fast it was. You could even have a middleware in the beginning that checks if the request is even valid and rejects it right away "We don't serve veggie patties here! No food for you!". The other side to the coin here is PSR7. This is a standard for how the request/response API should be. Going back to the kitchen, you could imagine that all food requests must come in on a yellow ticket with each order written on a separate line. And then the meal must be served up on a white ceramic plate exactly 12 inches in diameter. Whatever ends up on the plate is up to the kitchen, but this way chefs could go from kitchen to kitchen and jump into the process line fairly easily. They would know exactly how to read a request, and how to deliver the response. So if you're using a PSR7 middleware framework, you can grab any component that supports PSR7 and know it will work for you. The beauty in all of this is if you decide to switch your middleware framework to another PSR7 framework, all your existing components will still work after the switch. 
&gt; Built for the modern web &gt; Uses CodeIgniter Does not compute.
To answer the question directly: if you're using Wamp then phpMyAdmin should be installed at http://localhost/phpmyadmin/ 
I would guess this is some kind of IO bottleneck. Also check how much RAM and CPU you are giving your vagrant box... If it's 512 mb you're gonna have a bad time. Finally update virtualbox and vagrant possibly. Some ideas: * https://docs.vagrantup.com/v2/synced-folders/nfs.html * https://stefanwrobel.com/how-to-make-vagrant-performance-not-suck
I have a problem with hhvm error handling as it is slightly different than in real php. Some errors are catchable while some just returns blank page and I have to cat /var/logs to find out what is going on. I prefer them popping on screen in development. Tried various settings in hack but still it didnt give me any real results. I can pastebin my ngnix &amp; hhvm config, perhaps somebody could help. second wall I approached was a hhvm bad (imo) design about tagging files. hack files MUST have .hh extension and begin with &lt;?hh - and this means my eclipse will not support it any way, treating it as plaintext files. I have tried to tune a bit hhvm and as far as I remember, it actually allowed me to use hhvm features in &lt;?php tag but static typechecker still wont fire on .php files. thats really dissapointing.
Yeah. PECL maybe to install extensions but I avoid PEAR like the plague now. 
Hahahahaha. Graham Campbell is a tool who relishes in his Github contributions (90% of which are white space removal) and "power" given to him. He will forever be that guy in society no one associates with because he's too annoying, much like mosquitos. https://cloud.githubusercontent.com/assets/612332/8635559/e176da46-27dc-11e5-9cd8-249ebe203241.jpg
This look really nice at a glance. How does this compare with other modern software for discussions like [Discourse](http://www.discourse.org/)? At a glance many of the features are the same. What advantages does one have over the other?
Yes, it's especially funny, cause I got downvoted for calling it right up there. :-) At least it gives you an idea what happens when someone mentions Laravel.
http://discuss.flarum.org
Can you explain what you mean by elegance? Also, what is the motivation to compete with instead of contribute to Discourse?
apologies, re-reading that, I can see I was presumptuous in my assumptions of knowledge level!
Flarum redirects to the non-JS version of the page if the JavaScript app crashes during boot. If you open the Firefox console, click the cog, enabled persistent logs, go back to the Console tab, and reload discuss.flarum.org – you should be able to see the JavaScript error that's causing the problem. Would be a huge help if you could [report it as a bug](http://github.com/flarum/core/issues) on GitHub!
I haven't looked over the packages but I tend to go by GitHub stars, packagist downloads, commit activity, and how they handle PRs/issues. 
Now *this* is a forum system we could use for a central location for PHP discussion. Fast, open source, very extensible and customizable, and written in PHP! Any feature we needed, like integration with the PHP mailing lists, could be easily added as an extension. *Sorry, couldn't help myself, but it is true.*
I love how Zend is being so innovative and modern, but please please please make a thorough documentation of Zend Framework 2 with lots and lots of examples; that would be MUCH more important. This framework also uses Zend components, but those are still way too poorly documented.
2 months if it's Zend Framework 2
Prior to psr7 there was no universal signature. You could build one in HttpKernel but it was still very unofficial. Python and node have those http objects baked in. So yea, with respect to php this is pretty new.
I will almost certainly, once I get to the MathOperator part of the plan, make Newton a dependency of Planck, so that you can provide units representing distance, volume, area, etc. and the MathOperator can return values which make more sense. Like before, this is in dev, not production ready, and the project is not yet commented or tested. This is an initial preview and I'm seeking input and feedback. :) NOTE: This library was completely rewritten from my initial stab at it in February, which was convoluted and difficult to work with. To see where this, or Newton, are at, I have the 1.0 releases fully ticketed in the GitHub Issues pages for each repo. EDIT: BTW, I named it Planck before renaming the other library to Newton. I named this Planck because it allows grid of arbitrary precision, and the Planck scale represents the "grid" of reality.
That's kind of my system too :)
noone's gonna use it. People have CMSes overload.
yes.
I just don't understand the angst towards laravel. so much so that people here make up new screen names just to bash it: bringthetanks larafan etc... (since deleted)
use mysql workbench
Yeah, the downvoting and flaming is silly, but the actual differences of opinion on Laravel make sense. Laravel, like any good software, chose a set of principles to excel at in order to create a niche for itself. That necessarily means that people who don't value those principles will find is bad/ugly/etc. But professionals should be able to recognize that's what's happening instead of responding with vitriol. The thing is that the PHP community is made up of professionals and non-professionals.
Well-said. Smoothing this out is a central theme in Magento 2. We'll know for sure once it starts being used regularly, then we'll update certifications based on how it's being used.
Doesn't really work: oldest/most stable systems get little github stars
We used FreeTDS at a previous job. http://www.freetds.org
&gt; The beauty in all of this is if you decide to switch your middleware framework to another PSR7 framework, all your existing components will still work after the switch. And that's a beautiful beauty, right there. As I understand it, it's basically code that's completely framework agnostic. If it's a PSR-7 compatible piece of middleware, it'll work in/with any PSR-7 compatible framework.
Oh... thats actually PHP5.x thats failing and not 7 haha
Looks extremely elegant indeed. It's a flat bulletin board though, not a forum software (threaded).
If you look careful the timezones are named for cities, mostly capitals. So you would have: - Newfoundland: `America/St_Johns` - Iran: `Asia/Tehran` - India: `Asia/Kolkata`, I guess
Yep, I seemed to have overlooked some similar ones in the list of 417 that may have shed some light. Also, this "bug" report seems to clear up the whole issue. The PHP maintainers have interpreted "linked timezone" from IANA to be the same as "deprecated". There seems to be a subtle distinction in how IANA meant the linked to be used and how PHP implemented it exactly that is now in the realm of "definitely not a bug, but clear as mud in the docs" and that has a sort of solution. https://bugs.php.net/bug.php?id=66102 This Github search made it much clearer also: https://github.com/eggert/tz/search?utf8=%E2%9C%93&amp;q=Newfoundland
Ahh the starwars nerds come out to play :D
I'd say the fact that it's PHP sets it apart. I won't use Discourse simply because it's Ruby.
It's nice to have both. Anything mature was once fancy newness. If we never came up with anything new, nothing would ever get improved.
With PHP, no one knows what they are doing it. We fake it. As long as we are self-taught, we'll never be comfortable.
&gt; I won't use Discourse simply because it's Ruby. Why is that?
I made a thing: https://github.com/fredemmott/psr7-http-message-hhi
I downloaded the test build and this was fixed for me in it. You can download it here: https://www.virtualbox.org/wiki/Testbuilds
I don't imagine this being used to represent grids that have hundreds of thousands of items with locations, but there are many use cases where it would perform well that might occur in a web app. For instance, a grid containing airports and flight paths. Which would only have a few thousand elements. Edit: I'd also like to make the point that I wouldn't automatically discount PHP at being decently fast at this. It's actually a fairly simple structure of array access and objects, both of which PHP is very, very fast at, particularly in 7.
&gt; But coming out and saying, your app may have been written in laravel and there for may be shit, is negative and unneeded. No one said. &gt; Look at the code, comment on that. Lots of people do, its why there is hatred towards certain frameworks and libraries.
Their posts have made it pretty clear why they have angst towards it.
Needs nested comments. After using reddit for so long, alternatives look primitive (not that reddit doesn't look primitive in so many other aspects).
Did they fix this with Windows 10? I made the mistake of jumping on the 10 train and workbench stopped on my laptop and desktop. I was bummed and have been forced to work with PHPMyAdmin. 
I'd love to take a look!
split router as a component,really nice
Thanks. I thought about this one briefly but moved on to the rest of it without looking into it. I'll update it. 
You need to know the PBKDF2 parameters: salt, iteration count, key length and output type (obviously you can see the key length and output type from the existing hashes, assuming you can access them) hash_pbkdf2("sha1", $password, $salt, $iterations, $key_length, $is_raw_output); Salt generation and iteration count should be found from the tracking server documentation.
I think that may be achieved using table inheritance (http://doctrine-orm.readthedocs.org/en/latest/reference/inheritance-mapping.html#single-table-inheritance) on the Doctrine side and in Sonata lists with some coding in the filters (https://sonata-project.org/bundles/doctrine-orm-admin/master/doc/reference/filter_field_definition.html#callback)
I'm just drawing a parallel. Discourse to forums is what Ghost is to CMSes.
Thanks! Sadly, I've tried that.. I've used same iteration and key length and salt(from database - was desperately testing); Guess I should re-read that java code for password hash, guess it's more obscured. Off-topic: So, turns out I'm just lazy. Is that better case or worse than being idiot?
I'm going to say the same thing I always say when I see these Vanilla style forums: How many of the top 50 largest forums in the world run a layout like that? The answer is none. There's a reason for that. The layout is confusing as hell to novice users. I'm also pretty skeptical of Flarum as a whole it's gone from a premium system claiming all modern forum systems suck (conveniently ignoring XenForo and only comparing to out of date, EOL software like vB3) to a failed kickstarter project, to a free project (with no mention on how they now plan on making money given they originally stated they needed the money to afford to build it). I'd not be at all surprised if they try copying the Ghost model of trying to get people to pay for hosting. Don't get me wrong, its nice what they've done here - it's a fine looking system. But seriously, what are they bringing to the already oversaturated PHP forum software market that isn't already out there?
Nice for zend stuff to be psr7, because sooner or later youre gonna replace it. lol, sorry
Beta. 
one important thing : client host who installed phpstorm must can be reach by remote host
So no open source project should ever publicize their existence and get community testing because you might not be interested. Open a fucking bug request or STFU. Shit talking products that openly are describing themselves as "not ready for production use" makes you look like an idiot.
I tought it was able to automagically read the polimoprhic scheme without any extra coding. 
CALL US 9215199929
Why you have wrote this? For what you were needing it?
It seems there's a market for a PHP OS, let's get started!
Hi, I am little biased here, as I work there as a developer, but perhaps its worth mentioning, that Shopware is not build on SLIM - that's just the installer / updater, which uses this framework, so that we have a small, stand-alone installer / updater. The rest of Shopware is built on Symfony components and a custom framework called Enlight, which shouldn't bother you too much, its quite simple to get into plugin / extension development and use e.g. the Symfony DI there. If you have technical questions, I'll be happy to answer them, as I also hang around in the forums a lot, you might also give that a shot (http://forum.shopware.com/). //edit: Some additional resources: New docs for SW5: https://developers.shopware.com/ Docs for SW4: http://en.community.shopware.com/Dev-Docs-Shopware-4_cat_726.html (will mostly apply for SW5 and have some additional plugin examples) Github: https://github.com/shopware/
I see, I only saw a Slim error message using the installer and made false assumptions. Right now its looking really good. Do you know how well it is known internationally? May be a reason why not many here seem to know the system.
Even after PHP7 PhalconPHP will be a lot faster than the other PHP frameworks - becuase it's written as a C extension. If you're interested in increasing the performance of the conventional PHP frameworks - have a look at a project I've been working on: http://phpfastcgi.github.io/ I managed to get the Slim framework (v3 - beta) up to 3,700 rq/s (from 1650 rq/s) which is faster than most PHP developers will ever need. [edit] Check the benchmarks to see why PhalconPHP will be faster than the others even after PHP7. Also, PHP7 is going to make PhalconPHP faster too! http://blog.a-way-out.net/blog/2015/03/27/php-framework-benchmark/ https://www.zend.com/en/resources/php7_infographic
This might not be feasible for everyone, but I'm just using ec2 instances for db servers.
&gt; I'm going to create a simple website that must be slim and super fast. Let me guess - you expect dozens and dozens visitors this year alone? Just kidding, but "must be slim and fast" means nothing without having rough estimates of the traffic you want to handle. Trying to naively shoot way, way past their performance requirements is a favorite hobby of PHP programmers. &gt; Is it worth to still use PhalconPHP knowing that PHP7 is going to be lightening fast pretty soon? Depending on Phalcon is generally undesirable IMHO because there's no PHP-only implementation of it. Not saying it can't be done, but I don't think it exists *yet*, someone correct me if I'm wrong. So this means you're wiring your entire codebase to a potentially unstable C extension, with a somewhat uncertain future, and making it impossible to deploy on client servers, where you can't install custom extensions. So to go back to performance requirements. What are they, and what is your site doing (which will determine how to make it fast)?
Hi /u/r0ck0, one reason could be [RDS Aurora](http://cloudacademy.com/blog/aws-aurora-features/). It is a MySQL-compatibly db as-a-service, but with greater performance.
I'm working on migrating a very large site over to AWS and might be able to provide a little insight. Firstly, the biggest advantage is your scalability potential (outwards and upwards) and the shear ease of said scalability. Our site we're building out is very seasonal in that it could see 5-10 hits/hour some days and upwards of 2-300,000 hits/hour others. Because of this, it's very important that we be able to scale quickly, easily, and often. We're using [Elastic Beanstalks](https://aws.amazon.com/elasticbeanstalk/) for each piece of our application which allow you to plug in a min/max number of instances and then what threshold you want to scale on, and BAM you're done. It transparently handles the spinning up of new machines and as long as you've configured your app correctly and setup your dependencies (EB extensions) correctly, then it's pretty amazingly fail-safe. It just works. Beyond that, the ease of spinning up new infrastructure pieces is just above and beyond that of any other VPS I've dealt with. While a lot of the products are "Amazony", you typically interact with them much in the same way as you would a non-"Amazony" product (e.g. their "Elasticache" instances are just a fancy name for Redis or Memcache and your code talks to them as if they are just a simple caching instance, no special drivers or anything). You no longer have to manually build this stuff out. Just point, click, and boom. Servers! Lastly, the pricing is pretty killer, especially if comparing to self-hosting (which we typically do in our company). With all their products, you pay for what you use. So if you have a tiny app, you throw it on tiny boxes, and pay a tiny price. If it grows over time, you don't have to port it over to new infrastructure or deal with hefty migrations. Just scale the box and you're done. PS - One more thing, for you sys admin types. Their product "Cloud Formation" allows templating out infrastructure, networking, etc. so you can very easily clone existing stacks. A stack, when contained in a VPC, is like a datacenter essentially. Imagine being able to build a new datacenter in a matter of minutes, not days/hours/weeks. That's fucking cool. PSS - I actually don't work for Amazon, lol, I'm just super jazzed about their stuff after fighting shitty infrastructure for years. 
It uses a completely separate .webIDE95 folder. It asks if you want to import settings (I did). It didn't took over all plugins (IdeaVIM gone, wat?) so had to do some manual.
I've been programming since I was 12, althought never seriously. Never had any formal education. Never actually got a real programmer job until my current. 1 week after quitting another semi-programmer job, got a call from a company - I was referred by a friend - because they were in serious need of a PHP coder. I new zip about the language (Had been interested in learn it over the years but never actually got serious about it). Got to the interview, asked if I could code, said yes (was never actually asked if I could code in PHP). Salary was better than expected (100 euros per hour). That was Friday, Monday was already knee deep in code. Learned enough in 1 week to get the ball rolling. 8 years later I still have the same job (BTW, I switched continents just 6 months into the job). Was the first in the company, now everybody except the sales team works off site (across 5 countries and 4 continents). Told the story about not knowing PHP to the company owner 2 years ago. He was... amused. Kinda. I'm still learning the perks of the language... but it's been fun. Gotta say pay is not that good, but the perks of the job - Work at home single dad that can take care of his 3 daughters - makes up for anything 200%. Finally, I have to say I come from a MS Basic / ASP background. Switching to PHP was like finding nirvana. 
Sounds like it's time to make a PR
&gt; And it's written in PHP So happy about this :)
Did..... you even read anything? Like, at all?
We were doing this before fully moving the db to it's own RDS instance. I migrated internal apps to just an EC2 instance and ran both web server and db on it. This is perfectly fine for apps that don't need a ton of processing power. But even with its faults, where RDS shines is in the instant scalability and bullet-proof redundancy it offers that running a MySQL db on an EC2 instance couldn't.
AWS gives you more control than a traditional VPS. You get a virtual machine running the OS of your choice. On top of that you get a VPC ( think of a private network ) where your machines can talk to each other. You also get persistent storage through EBS. EBS drives can be attached/detached from an instance. For MySQL/PostgreSQL you can use RDS ( replication, multiple availability zones, rolling backups ). You also get load balancing using the ELB service. The question should be why would anyone use a VPS?
For us, it wasn't necessarily the scalability, but more having a managed solution instead of us having to worry about infrastructure. Let Amazon worry about all of that, we will worry about the app only. 
&gt; possibly non-permanent IPs This is not the case anymore, all of our major servers have static IPs, you just have to pay a little for them.
Until they decide they lost enough money and increase the price and you can't go away because of api lokckin. Can't wait for the crying :)
This is kind of a stupid advice really. Not unit testing code that is not your own is one thing, but mocking it is aboslutely different. Imagine I use Twig or any other templating engine, and inject it into my code. The logical approach would be to mock the templating service and test whether my code passes correct parameters to it. What your advice suggests is that now I have to creat a wrapper for the Twig service to hide it behind an interface. But why would I want to do it if Twig is the only templating engine I will be using. There is no point in wrapping things that are not going to ever get swapped out. The other huge problem with wrapping everything is that in your example it is easy since the interface doesnt have a lot of methods. What about external database libraries? Let me see that wise guy writing wrapper for the entire Doctrine DBAL so that he never needs to mock it. Bottomline: stupid sensationalist advice, that looks nice on a presentation but carries 0 weight. 
&gt; While a lot of the products are "Amazony", you typically interact with them much in the same way as you would a non-"Amazony" product (e.g. their "Elasticache" instances are just a fancy name for Redis or Memcache and your code talks to them as if they are just a simple caching instance, no special drivers or anything). This includes APIs and the like. I can literally drag my application onto another non-Amazon stack with only a few endpoint changes (which will always been a concern, regardless of where you're hosting).
That example you mention only makes sense to a certain degree. Given I have the AWS Client and am using it. Having a fully functional unit test is perfectly valid in that case. To me it sounds more like an assumption was made and this caused the test to pass. But if that condition is never met under the given circumstances, it's the fault of the one who wrote the test. A passed test means nothing if the test is written poorly. This goes for all test, be it unit, integration or behavior tests.
Might you not opt to implement something like a repository access layer (or suitable alternative pattern) that abstracted away from your choice of DBAL, which could be mocked instead? Your thin concrete data access layer complete with DBAL integration could be tested with integration tests. I do agree completely that things aren't always as simple as the presentations make it seem...
I hope this doesn't come off as dickish, but I think you meant 'subscribe' instead of 'proscribe'. The latter means to forbid someone from doing something.
Am I in /r/LOLPHP again?
I don't understand the reference 
I try not to mock anyone's code, since they're probably a better coder than me since I'm using their stuff. :D
Thanks for the response. Just to clarify a couple of things... &gt; You get a virtual machine running the OS of your choice. That's what a regular VPS is. I've never seen any other definition of a VPS meaning anything else? &gt; The question should be why would anyone use a VPS? It's a regular virtual machine with no Amazon-specific stuff to learn, and persistent storage by default. But I do get the benefits when you get bigger and start using some of their cloud database / CDN / storage services. I guess I'm more asking why it would be used for your standard single-server LAMP websites.
Thanks for the response. But based on those points, I'm still a bit confused how it differs from a regular VPS with any other provider? If you don't like the VPS provider, you just move to another one, with no provider-specific config/code to worry about. It's just a regular virtual machine running what OS/distro you choose. 
Ops, I actually didn't read the docs, I assumed that was what I was looking for. http://www.ruempler.eu/2013/07/07/replicating-aws-rds-mysql-databases-to-external-slaves/ You can do it, as long as you are using MySQL 5.6. I've done it last year to migrate a multi GB database outside RDS with literally less than one minute downtime.
I agree with you. Sounds like the test writer didn't write a good test. Which is why 100% coverage shouldn't be a goal. It should be solid tests. Tests need to be refactored too. 
You realize that HHVM is an actual engine, that runs PHP code? :) It's a different implementation of PHP. So either you run PHP7 interpriter, or you run HHVM whatever the stable version is out there. Feels like friday hit this subredit today hard :D
So this isn't replacing the idea of MVC, you can still do MVC with middleware. Instead this is stripping down the idea of a framework to just the request-&gt;response pipeline. Middleware is for people who already know what a full application looks like, and don't need much direction. But it doesn't really take much work to get a simple hello world app going, and there isn't a lot of magic going on either compared to bigger frameworks. Middleware has less restraints than your typical framework. One of the nice things with Expressive is the only thing it really locks you into (which is a good thing) is PSR7. You get to pick your own container, your own router, and all the other components. Again, not for the beginner. So there are two types of middleware: routes and pipes. Routes are the familiar get('/api/books') that most microframeworks can do. I won't talk about those because they're obvious. Pipes are everything else, and is where you can do the most powerful (dangerous) things. Pipes are executed in the order you define them, and will happen for every request sent to your application. They can come before or after your routes. Pipes have access to the request and response, so they can see and alter everything related to them (body and headers). Pipes can also immediately return a response and prevent any future middleware from executing. Some examples of useful pipes: * Providing [CORS](https://en.wikipedia.org/wiki/Cross-origin_resource_sharing) headers * Protecting certain routes. If 95% of your app requires login, you can specify what routes don't require it. Then when you create a new route, it will automatically be protected. You can also add the user information to the request as an attribute, so once it gets to your route, the user information is already there and that controller doesn't need to figure it out. * [Timing the full request.](https://github.com/tonis-io/response-time/blob/master/src/ResponseTime.php) Middleware takes a request,response,next. The "next" is the next middleware in the pipeline. So your first middleware can start the stopwatch, call next(request, response) and wait till it returns and return the full time in a header in the response. * Decoding request body. Your application might support a non-native request body (such as json or your own custom format). When a request comes in, look at the content-type header and appropriately decode it. * Application level firewall. Maybe you don't want users from China using your service. You can put a middleware in the front that checks the IP and returns 404 right away. * Application level throttling. Check the IP in some sort of cache, if they're doing too many requests, return early. * Alter the response only a percentage of the time. Show a coupon on 5% of your responses. Show a survey 50% of the time. * Do some A/B testing on your entire app. Maybe you want to change what templates are used for rendering (new color scheme). Instead of doing that in the controller for each part you want to test, you can simply swap the template engine in your container in your first middlewares. Then when the controller calls render it will render using the new templates. * You can even pipe a part of your application to ANOTHER application. So if you had multiple versions of your API, you could separate the different API code bases, have 1 master pipe that pulls in the other code bases via composer or git submodule. Then when a request comes in for '/api/v2' it will go to the v2 API code base. 
You can run PHP or Hack on HHVM
Thanks for the detailed response. Looks like I will need to fast-track the move to 5.6!
Zend Engine is a run time, HHVM is a run time. "PHP7" as we have it today runs on a redesigned Zend Engine run-time, that has been engineered to be significantly faster. All the syntactical sugar that has been been added to PHP7 is separate from the run-time. You can't run 'php7' on HHVM. You can run PHP on HHVM, it just so happens to support some of the new features that PHP7 supports. 
If you are not making a simple wrapper what you are making is called an Adapter and needs to be tested. To test it you will need to mock the actual DBAL.
Yes, but it doesn't matter what "version" of PHP code you run on HHVM. It's still HHVM. Running PHP5-compatible code or running PHP7-compatible code will have approximately the same performance if you run it on HHVM. I assume that's what you're asking. Either that or you have no idea how PHP works.
[Joe Rainsberger has an excellent talk regarding this.](https://vimeo.com/80533536) And [Uncle Bob has an excellent blog post on different types of test doubles](https://blog.8thlight.com/uncle-bob/2014/05/14/TheLittleMocker.html) You shouldn't write a proper Mock of code that isn't yours. But you write things like stubs and spies to make sure your code talks to that code correctly. Actual integration tests should be few and far between, and only when you're actually talking to AWS to ensure your expectations match reality. It's the same idea as testing through the UI. You wouldn't spin up the whole application to check if your permission system works. You would take the core of the permission system and supply dummy data to it. A fake user, a fake request, you'd supply a "BlogPostStub" that has information you injected. And then you'll run your `TestNonAdminCannotEditOtherPost` using those things.
Hey ya, the "wise guy" here :) It's a shame you decided to go personal here, but I'd try to ignore that and address some of the interesting points you're making, in attempt to have a healthy conversation. "Do not mock things you do not own" is not really an advice, it is one of the core heuristics described by the same group of people that coined the term "mock" in the first place. You can find this heuristic and much more on it's context and reasoning in the original paper from 2004: http://www.jmock.org/oopsla2004.pdf (section 4). If you want more practical example, I'd recommend the 2009 book from the same guys that goes into details around motivations behind mocks: http://www.growing-object-oriented-software.com. If you want some quick read from someone else outside of that small group and/or me, Robert C. Martin also wrote on the subj couple of years ago: https://blog.8thlight.com/eric-smith/2011/10/27/thats-not-yours.html. In regards to both of your examples, whenever you feel an urge to mock a third-party service, be that Twig_Template or Doctrine DBAL, you have a very simple rule to work with it without breaking heuristic - do not pretend you can unit-test it, use an integration test instead. I will try to explain reasoning in the following paragraph. I see you're developing a framework and I assume that's where your examples came from. I presume in your framework you have an ORM layer that depends on the Doctrine DBAL and in your tests you mock it. The question is what will happen if Doctrine suddenly stops conforming to your expectations/assumptions and will start requiring calling additional `connect()` method before calling `query()` every time? I will make a guess that all your tests will still pass, even though your code wouldn't work at all. You simply wouldn't know that your framework is broken by just looking at your tests, because your tests still test your assumptions about someone's else code you have no control over. That's why I wouldn't mock Doctrine DBAL and wouldn't unit-test your ORM class - I would use a proper integration test, one that actually does prove my integration with Doctrine makes Doctrine save/retrieve things as I expect it to. Mocking is not the only way to test things, nor is it the only way of testing you should use in your codebase. Basically, the "only mock types you own" heuristic exists to save you from writing tests that look like they protected you, while actually they don't. Mocking things you don't own gives you false feeling of security, where's you actually aren't protected from anything. P.S.: "Writing wrappers for everything" wasn't really part of the discussion and at best belongs to a separate topic (of separation of concern and isolation) altogether, I'd leave it outside of this conversation.
Well you still need to mock the actual DBAL in order to test your database repository. This is the entire problem with the original statement. You can't get away without mocking the actual dependency.
A repository implementation doesn't perform any business logic itself, it's the bridge between the business logic and your persistence layer. The business logic is the interface. For example: class InvoiceRepository { /** * @param Client $client * @param ClientStatus $filteredStatus * @return \Traversable[Invoice] */ public function getInvoicesForClient(Client $client, ClientStatus $filteredStatus = null); } The interface is written in terms of the application's domain logic. The implementation, however, isn't doing any business logic, it's mapping data from a storage layer the business logic doesn't care about to actual entities. Example: class DatabaseInvoiceRepository implements InvoiceRepository { //constructor omitted for brevity public function getInvoicesForClient(Client $client, ClientStatus $filteredStatus = null) { $query = $this-&gt;invoiceTable-&gt;where('client_id', $client-&gt;getPrimaryKey() ); if( !is_null($filteredStatus) ) { $query-&gt;where('status', $filteredStatus-&gt;value() ); } $results = $query-&gt;execute(); return $this-&gt;mapResultsToCollection($results); } } If you're testing a class that implements the interface, you **should be able to substitute any particular implementation without changing the test's assertions**. That includes mocks. The query builder is an implementation detail, and you shouldn't be testing implementation details. 
Huh... no. I wouldn't mock it in the case as I just shown you the code. I would maybe mark the test as integration and test the connection directly. &gt; Mock across architecturally significant boundaries, but not within those boundaries. - Uncle Bob, in [When to Mock](https://blog.8thlight.com/uncle-bob/2014/05/10/WhenToMock.html)
 - HHVM currently supports Hack or PHP5 code. Support for PHP7 code is planned - can follow progress here (though this effort has just started): https://github.com/facebook/hhvm/issues?utf8=✓&amp;q=is%3Aissue+label%3A"php7+feature" - we aim to continue to support PHP5 code, with backwards-incompatible changes (eg uniform variable syntax) being enabled by configuration options. - HHVM and the PHP7 runtime are each are faster than the other at some things. We (the HHVM team) are confident that HHVM is faster for most heavy loads, but PHP7 can be faster for lightweight pages - though depending on the specific code, there are likely to be many exceptions both ways. If your site uses the subset of code that is both valid PHP5 and PHP7 (most is), then testing directly with a shadow copy or emulation of your production traffic is the best way to be sure. - /u/NeruoXC's comment is correct - you should expect code written for PHP7 to perform on HHVM pretty similarly to how code written for PHP5 performs on HHVM - Honestly, performance is extremely unlikely to matter to you between the PHP7 runtime and HHVM. They're both extremely fast compared to PHP5, and fairly close to each other. I'd suggest looking at other factors; for example, look into if you're likely to want extensions that have been/are being ported to PHP7 but not HHVM, and look into the benefits of Hack some more and decide if they're something you care about. Disclaimer: I work on HHVM [edit]: don't test in prod :p
&gt; How do you expect to do tdd or make sure your wrapper works if you don't have a unit test? Integration testing, typically. Don't mock external dependencies, inject instances configured specifically for testing. In terms of a DBAL, create an instance using an in-memory database driver with a known set of data you can test against. For something like AWS, set up a test bucket with known data.
Nope, you got it absolutely right. Judging by your post anyways :)
Shopware is just starting to go to e.g. netherlands or UK, so currently they are better known in the german speaking countries. 
Intergration tests are great. Trust me I love them but what you're suggesting is a functional test. S3 goes down your test suite fails. Even then you're purposing having a class that you don't know that works. This means you don't know if it's your wrapper class or all the classes going together that doesn't fit. This seems like a poor way to go about testing.
+1 on writing fcgiphp, i have no use for it now, but it's good to know something like that excists in PHP land :)
&gt; You have nothing just testing your wrapper class works. I'm afraid don't quite follow. I'm creating an instance of an instance implementing the interface, then asserting an expected output based on a known input. By what measure is that not a testing whether my wrapper class works?
So you wrapped doctrine for example fo you have tests to make sure your wrapper class does all the right calls to doctrine?
Well, "wise guy" is hardly a "getting personal" thing tbh =) But thanks for taking the time to reply. My ORM is not using Doctrine, I was just using it as an example. I read the 8thlight article you linked to, and while I see the point they are tryingto make there is one problem with it: Usually the BlogEngine class it refers to (which wraps around the actual DBAL) will contain a lot of business logic, maybe some validation even (e.g. like actual Doctrine ORM validates entities) etc. Writing only integration tests for all of it is really bad: the tests are obviously going to be slow, you will need database data to test, etc. The other arguments you use are easily avoidable: &gt; The question is what will happen if Doctrine suddenly stops conforming to your expectations/assumptions and will start requiring calling additional connect() method before calling query() every time? That is why you lock the doctrine version you are using in your composer.lock. If you lock the version the "suddenly" does not happen. Obviously when upgrading to a newer version of Doctrine you have to change your code to conform to it. By your logic you should never mock anything that a different developer may ever touch. So if you are working with 5 other guys don't ever mock anything, because what if one of them changes something? This is what versioning is for. Here is how I would approach the problem: unit test everything and have a couple of integration tests that touch upon the entire stack. These integration tests will rpotect you from the "suddenlies". But you cant hope to get decent coverage with those. 
I wouldn't. If I did, that would have three significant drawbacks: 1. If my mock doesn't conform 100% to mocked class, the test is useless. In fact, it's *actively harmful* because it will result in false negatives. The unit test passes despite the fact that the code under test is broken. 2. Any change to Doctrine's public API requires changing the tests as well, despite the fact that the behavior of the class's public API has not changed 3. Any change to the internal calls made by the class also requires updating the tests as well. The rapid process of red, green, refactor is no longer possible.
so how would you test DBALUserRepository ? Only through an integrational test?
you should consider making the build for hhvm actually work. I haven't been able to compile it on any version of gentoo, 64 bit, x32, matching all your deps, even going so far to match stupid things like my version of libevent. at the least provide a distro neutral tarball of the stuff, not just deb or rpms. and the ability to use system libs instead of the ones you're packing into the src
That's why I remarked whether or not I was in /r/lolphp haha
1. What are your project requirements? 2. How much traffic do you estimate you'll have? Without answering these questions nobody can really advice you for or against PhalconPHP or any other framework or even PHP. My advice is to cross the bridge when you get there and don't get caught up on details like performance unless you're 99.9% sure you will need it. In other cases always trade code manageability for anything else. 
You seem to be under the impression that unit tests exclude integration tests and vice versa. I don't agree with your "mock it and you have no real testing statement". For example imagine you are testing whether correct conditions are being added to the query based on your criterias, e.g. you want to test this part: $query-&gt;where('status', 'published')-&gt;andWhere('views', '&gt;', 100) ... I see absolutely no problem here in mocking the query object and testing whether correct conditions are being added. 
&gt; what exactly will tell you that your code doesn't conform anymore The changelog. And those integration tests I mentioned. &gt; I assume you are deliberately exaggerating here. Not really. I worked on projects with 30 people working on same codebase. Just imagine how much code gets touched daily. Sure, everybody worked on their own segments, but the tests still neded to change to confoorm to mocks. Using integration tests ( that need much more work to update) would kill the entire workflow. So the bottomline for me is that I always use unit testing and mocking whereever possible, and then I always have integrational and functional tests to "spike" through the entire system. This is for example how the PHPixie ORM is tested. Unit tests + functional tests have been working splendidly for me
This is why I use linux
Can we run MySQL on that?
**tlte;lmdfy** (too long to explain; let me decide for you) - If you like Hack's *features* &amp; find them essential to your *productivity* as a dev, go Hack + HHVM. If not... - If you plan to launch your enterprise API around Nov-Dec 2015 or later, go PHP 7. If not... - Go PHP 5.6 and test in PHP 7 from time to time to ensure you can migrate when convenient.
Try not to mock code, period. Sometimes it makes sense or is necessary, but if you find yourself bending over backwards to set up 50 lines of mocks to test one line of code, you're doing something wrong: either you're testing the wrong thing, or the code you're testing is not where it should really belong. Further, just because a class has a public method, doesn't mean you need to test that class or that method directly. Unit tests should test the actual public API that is meant to be consumed, and let your code coverage tool penetrate the internal structure. That leaves you free to refactor that internal structure without having to maintain any of your tests. The thing that bothers me about PHPSpec is that it deliberately wants you to test internal implementation details like `$this-&gt;foo()-&gt;shouldBeCalled()`. Well what if internally you decide that `foo()` should be renamed to `bar()`, and it doesn't affect the outward behavior you're trying to test? Well now you have to go back and fix your tests.
 - x32 will not work at all; we generate x64 instructions and require 64-bit addressing. For other architectures we're interested in, we will also require the 64-bit variants (eg arm64) - how long ago was this build? We used to require an 'unusual' libevent for our builtin http server, but that has been deprecated (and not built by default) since 3.0.0 in March 2014. If there's a problem using a recent standard version of libevent with 3.9, please could you put some details on a github issue? - We're planning on supporting docker containers shortly - would this be a sufficient replacement for distro neutral tarballs for you? If not, what would the advantages be? Making truly distro-neutral tarballs is very hard to do correctly, and would take away a significant amount of development time away from the open source team. - We use system libraries instead of the ones at https://github.com/hhvm/hhvm-third-party if they are properly versioned by upstream, and if we need them configured in a particular way (eg PCRE with JIT enabled), provide a way to detect that. If you think this isn't the case for some dependency, please can you file an issue?
I don't know why you're getting downvoted. People who argue that you need a brittle / "opinionated" framework with one side of their mouths, and argue in favor of pointless database abstractions from the other side, are the pinnacle of hypocrisy.
&gt;x32 will not work at all; we generate x64 instructions and require 64-bit addressing. For other architectures we're interested in, we will also require the 64-bit variants (eg arm64) that's completely fine. I can run x64 on this too. &gt;how long ago was this build? We used to require an 'unusual' libevent for our builtin http server, but that has been deprecated (and not built by default) since 3.0.0 in March 2014. If there's a problem using a recent standard version of libevent with 3.9, please could you put some details on a github issue? I attempted to install the latest version of hhvm manually and through the gentoo overlays just last month. couldn't get any recent version to work, using all sorts of combinations of gcc 4.9, gcc 5, libevents, drawf, everything under the sun. &gt; We're planning on supporting docker containers shortly - would this be a sufficient replacement for distro neutral tarballs for you? If not, what would the advantages be? Making truly distro-neutral tarballs is very hard to do correctly, and would take away a significant amount of development time away from the open source team. maybe. I would just gut the docker container and run it natively though. whatever files you're giving docker to run the app are the same files you'd include in the tarball honestly. I couldn't find a direct rpm, only suggestions on adding repos, but I don't know how to parse those to just get the rpm I want and gut that. &gt;We use system libraries instead of the ones at https://github.com/hhvm/hhvm-third-party if they are properly versioned by upstream, and if we need them configured in a particular way (eg PCRE with JIT enabled), provide a way to detect that. If you think this isn't the case for some dependency, please can you file an issue? I couldn't get it to compile, so I don't know. I do know if you can point me to an hhvm binary though, I could try running it and seeing if all of my third party libraries that are dynamically linked still work.
&gt; supporting both PHP5 and PHP7 doesn't help Facebook run our own code - this is just to help our external users. The short-term cost of adding options like that is low, but the long term cost, and the cognitive overload of having to think about those options both as you target or maintain &amp; test HHVM will be very high. You need to adopt an Apple-like mentality and regularly empty your backback from past concerns, so you can be free to walk towards your future. Once you ship PHP7 compat, if people want PHP5 compat, you could link them to a stable old version that has it.
Try this and skip the MySQL part: https://www.digitalocean.com/community/tutorials/how-to-install-linux-nginx-mysql-php-lemp-stack-on-centos-6
Always. Why waste time with something if you are allowed to use existing one.
I like this from the conclusion in [Mock Roles, not Objects](http://www.jmock.org/oopsla2004.pdf): &gt; Our understanding of the technique has deepened, in particular we now have a much stronger bias towards using Mock Objects for design, rather than just testing. You can't design things you don't own :)
As I said, typically this means it's integration testing. But if I consider it a part of my unit, then it's unit testing. The line is not absolute, and depends on how you factor your architecture. Just like using PHP's extensions in your code is not integration testing, typically, same can be with the database if you consider it a part of your unit. I typically split a project in many small standalone modules, each with a minimal public API. The module is my unit, and what I unit test is API behavior. That behavior is also dependent on the database.
&gt; I can't install php fpm On cent os 6 Why can't you?
I have to play on semantics, because what's the definition of a unit, really? To me running my service against mock MySQL is akin to running it against mock PHP.
I like my magento work, feels really rewarding...like I just won an all out war kind of rewarding. 
oh sorry. my bad i didnt have repos for php5.4 i just installed new repos and everything is working now.
 - we don't provide RPMs or the overlays, only packages for Debian and Ubuntu; sorry, I don't know enough about HHVM on anything else to be able to offer detailed help - the docker image is just our Ubuntu 14.04 package As for why we can't just ship the existing binaries in a tarball instead of a package and call it generic: - this isn't generally reliable unless it's a static-link-the-world binary. For example, I don't think g++ 4.x and 5.x binaries are ABI-compatible - different distributions have a different set of system libraries that we can use vs build from third-party/ - we'd have to explicitly always use the third-party/ version As for links: - http://dl.hhvm.com/ubuntu/pool/main/h/hhvm/hhvm_3.9.1~trusty_amd64.deb - can be extracted with ar and tar on a non-debian system - not sure how to extract them, but https://hub.docker.com/r/fredemmott/hhvm/ has that deb installed (if anyone has feedback on the way I've setup fredemmott/hhvm and fredemmott/hhvm-proxygen, I'd greatly appreciate it - here or https://github.com/fredemmott/hhvm-docker)
Gary Bernhardt from Destroy All Software touches on this in his "Wrapping Third Party APIs" screencast. When I first saw the example I wasn't sold but as I used more third party in my career I can see it as pretty solid advice.
Lack of features or poor documentation are the big reasons.
Sounds like me, I have to say. Over the years I've used Perl, VB, JSP, Java, ColdFusion, XML/XSL, but PHP and Javascript are my mainstay languages. In neither of them have I come to like frameworks. Fundamentally, I think it's because I don't like to "sit back and watch the magic happen". For me, the real pleasure of coding is a combination of the open-endedness, the control, and the problem-solving. I know that if I want to read from a 1980s greenscreen accounts system and an Oracle database, or bridge an ecommerce site to a POS system, it's going to take certain steps, I'm going to have to work out what those steps are, and if I'm not getting there, it's because I am not taking the right steps. Generally, I haven't found that frameworks fit with that. Sure, frameworks take a lot of the drudgery out of the work, by taking care of nuts and bolts, but frankly I've got such a massive library of nuts and bolts that a lot of that is taken care of anyway. And they don't teach me anything interesting. I don't find *them* interesting, which is a bit of a killer when it comes to learning one. Fundamentally, though, I just hate not knowing exactly what's going on. I detest abstraction, because while it's lovely when it works, it's an absolute nightmare when it doesn't. First and foremost, you don't know whether what's not working is a feature of your code, or the framework's. Maybe you've simply botched it, maybe you've hit a case that the framework's designer didn't write for, and suddenly you're limited by somebody else's thought processes. Quite a bit of my experience with various frameworks has in fact been that of being asked to work on an existing framework-based web app, and make it do things the framework-using original developers didn't. There's something of a movie trope here. You get to be the older guy who built machines laboriously from spare parts, and the framework guys get to be the new kids who laugh at him as they throw together machines ten times cooler in a tenth the time for five times the price. In the movies, of course, it always turns out that the new stuff breaks down in some unexpected way in a vital situation, and none of them can fix it because they don't know anything about what's under the hood. Cue old guy triumph, etc. But if you go on after the movie ends, people don't go back to building things the old guy's way - they just build better frameworks, and the old guy is still running a small machine shop in the cheap end of town, even if the few kids who benefited from his work maybe go on to learn a little more about under the hood stuff. So, if you're like me, there's kind of a philosophical hump you're going to have to get over. My advice to you - and to me - is to try approaching frameworks as something that works at a completely different level. As people have already said, you need to do what you always have to do - build your own Hello World project on the framework's own terms, and accept the level at which it operates. Accept that it's a toolset for building fairly specific things in a fairly predetermined way, and roll with that. For the job interviews, to be honest, I don't think you need more than that. If you've got experience with the framework on the one hand through personal projects, and experience with coding for business on the other, you're a PHP coder with experience in that framework. Stick the projects up online, and point to them - online is online, you've built them, people can use them/see them. Caveat: I'm self-employed, and that means I'm generally not talking to a recruiter. I'm talking to people who care what happens to the project, not what people think of the person they hired. And if you just can't bring yourself to do it, and you just can't work with a framework without constantly wanting to break it, consider that the C++ world is not framework dominated, and that there's probably a reason for that. 
This actually sounds like really bad advice to me. &gt; someone he knew wrote a class that depended on and sort of Amazon SDK that was injected via the constructor. It was fully unit tested all possible routes, using phpspec using things like `$amazon-&gt;method()-&gt;willReturn(true)` to force certain scenarios. In the anecdote provided, the problem wasn't that he wrote unit tests or that he mocked something. The problem was that he did not have integration tests. Unit tests and integration tests are not mutually exclusive. You can have both in your code base, and I recommend that you do have both. &gt; 100% code coverage of unit tests. Coverage above a certain threshold doesn't mean much, and in fact, if someone says they have 100% coverage, that actually raises a red flag for me. &gt; Do not mock any class you do not own. Implying that we should only mock classes we own? So if we have code that writes to a database as part of its side effects, but we didn't implement the DB server, if we want to test that code, we have to actually write to the database? We're not allowed to mock that because doing so might introduce bugs? &gt; In fact, do not unit test any code that you do not 100% own. So if you own the code 90%, you're the primary owner for the code, but you shouldn't unit test it? And nobody else is allowed to unit test it either because they own less than 10% of it? So we just don't permit anyone to write unit tests for it? Allow me to give you one of my anecdotes. I wrote some code that talks to a third party library. I own 0% of that third party library. It's pretty much a black box to me. One day, I find out that there's a bug in the library where it doesn't properly escape the string it returns under certain situations. I file a bug report with the owners of the library so they can fix it, but meanwhile, I need to ship my software to my customers. So I write a workaround that adds the escaping that they forgot to do. One day, the 3rd party library may actually fix the bug. If that happens, my workaround will actually introduce a problem: the string will be double-escaped. Which means every time I download an update for the 3rd party library, I have the risk of introducing a bug into my software. It's quite tedious to manually check whether the 3rd party library has the bug fixed. Is there some way to automate this? Yes: write a unit test that asserts that the library contains the bug. As long as this unit test passes, you know your software will do the right thing because you've introduced the workaround of an extra escaping. If one day the library gets its bug fixed, your unit test will fail, which will alert you to the fact that you need to remove the workaround you introduced. So yes, I am claiming that it is sometimes useful to writing unit tests for code which you own 0%.
I think the point was that you shouldn't unit test vendor classes directly because then you're coupling your application to that vendor. I suppose this isn't a testing problem specifically, but a lesson to not use hard dependencies to start with.
&gt; The thing that bothers me about PHPSpec is that it deliberately wants you to test internal implementation details like $this-&gt;foo()-&gt;shouldBeCalled(). Well what if internally you decide that foo() should be renamed to bar(), and it doesn't affect the outward behavior you're trying to test? Well now you have to go back and fix your tests. There's a portion of people that believe the test code documents the production code. That the test code is just as important as the production code. If you are in this camp of people, yes, you'd change it in production code and test code. If you are not in this camp of people, I question why you are testing at the unit/integration level.
What have you tried?
Maybe you can check: https://vestacp.com It configures apache + nginx out of the box for you. 
I'm unclear why this is a bad thing. I suppose the potential is there for you to tinker and never release, but I love playing with performance optimizations in applications in any language. The experience is usually useful.
And that's how you politely and subtlely tell someone to Google it 
I wouldn't go that far, but we could if we wanted to. It looks like [reputation systems are planned](http://flarum.org/features), which could be adapted. RFCs *could* be sticky posts with an "RFC" tag, with embedded voting. I don't see the current wiki system as in need of replacement as much as discussion locations.
Only difference between mocks and spies is you tell the spy what to assert *after* the SUT has sent messages to it but you tell mocks *before*. In practical terms I haven't ever come across a need to use 1 over the other, it's only aboit style and readibility. In Prophecy (PHP mocking framework), the difference is shouldHaveBeenCalled() vs shouldBeCalled(). For completeness, stubs are different to spies and mocks because they send messages *to* your SUT (willReturn() in Prophecy) and don't assert anything.
He says that he wrote this because the previous one was hard to work. That is why he wrote this one. &gt; NOTE: This library was completely rewritten from my initial stab at it in February, which was convoluted and difficult to work with. But he doesn't say why he wrote the initial version. Also, I understand for what this library can be used. But my question was "what he is trying to accomplish?". Like was he trying to write an online game? Was it to improve his PHP skills? To show as reference in CV? For fun? To solve a work related problem?
You really shouldn't care about performance as much as you do. Phalcon has their performance as key selling point, but it really doesn't matter anyway. As long as the framework you choose is not *slow*, it will do just fine. You should look at functionality and useability. Choose a framework that fits you and where you can develop with. The reason I say this is quite simple: at the moment your website attracts lots of visitors, the speed of one framework on one instance isn't important any more. At that point, you need to look at load balancing, splitting web and database-servers; and probably application/instance cloud. Thousands of requests per second on one instance is great, but with that many requests you should look to redundancy and load balancing. TLDR; Just pick a framework that works well for you. When you need to care about milliseconds, the framework is not that important any more.
Testing that you are calling the API correctly is very valuable. Imagine you have a method getPostsForFrontpage that fetches posts depending on numerous factors (current day of the week, popularity, users location etc. ). Such a method would add different conditions based on these factors, and unit testing to check if those conditions are correctly added is important. Another example is dynamic filtering, imagine you get a list of conditions from frontend and need to translate them into your dbal query conditions. Yet again you can easily unit test this.
10/10 - thanks dude!
All right, I call BS on this justification in return. :-) Can you explain why array_reverse() &amp; array_merge() return a "damn inefficient" copy? In JavaScript, for example, reverse() &amp; merge() are consistent with its push(), pop(), sort(), which modify in place. PHP has no consistency whatsoever about this. Additionally, modifying in-place requires passing by reference, which, if you have that array in two or more places (say, if it's passed in as an argument by value from somewhere, almost always the case), means *it gets copied right there and then* before the array_push() receives it, as you very well know. So much for efficiency. Also, I know PHP7 improves a bit on reference implementation, and so on, but it doesn't change the common case of mixed by-val and by-ref arrays materializing their copies during those API calls, or PHP changing its mind from function to function in the API. 
You'd do this by testing that your query builder builds the right kind of query... and personally I wouldn't build it by verifying that the right methods on the DBAL were called - i'd verify that the DBAL built the expected query string (and in this case you are operating one level above what you're talking about - you'd still be dealing with a 'real' collaborator, not a mock - you'd just be asking it for the resulting query string instead of getting it to execute the query). Because testing method calls makes the code impossible to refactor without breaking the test. And if you have to change both the test and the code simultaneously you cannot trust either side of the equation. You are moving the goal posts and you might as well not test at all. Given you know what you're testing for (lets say, posts on Monday with 4 or more stars from users in Romania), you can fill a test database with necessary data, and create an assertion that any call to the DBAL will return you the information you expect to get back (a *known* subset of what you threw in the database which matched Monday, 4 or more stars, for users in Romania). Then it doesn't matter what your DBAL ultimately does. So long as the resulting data is exactly what you wanted it to be. By running a test along the lines of what you are proposing you are really just verifying that what you have likely already typed. It's weak testing at best with dubious benefit. At worst it is brittle and a false sense of security. There *are* uses for mocks and expectations. But they not to verify that you are calling some 3rd party library in a particular way.
As always an answer bashing PHP in the slightest is downvoted probably without really reading it. I write in PHP every day and shit like this bugs the hell out of me. In some cases you pass the parameters then the subject while in others it's the opposite. The is no doubt about it, PHP is a horribly inconsistent language. Not a horrible language just one that is inconsistent. Now most of their newer OO classes clean this up but that doesn't change the fact that theirs cruft is inconsistent. Again I do like PHP overall as I learned a great deal about programming by teaching myself PHP (only used TI-BASIC before it) but this poster is correct in what they say and the downvotes really annoy me.
Isn't that still using service locator? You define services, then when you call 'make()' it locates the service you defined. Your first example also seems like a strawman to me. I've never seen anyone suggest passing a container into a constructor like that. You'd do something like this $db = $this-&gt;container-&gt;get('db'); $users = new UserRepository($db); Now your code is pretty much the same as the Auryn code, so you don't need to use Auryn at all! Not to say that it would never be useful, the best place for it is when you are creating objects on the fly as a framework/router would do.
PHP: Consistently inconsistent.
array_change_key_case is damn useful. I do a lot of work with etl, importing data from a implementer's sql query and matching it up with predefined metadata. Array_change_key_case help me keep from going insane when my implementation team asks me every day why their query fails and I have to tell them, "your columns are aliased with the wrong capitalization".
That's awesome that you're one of the nine people who has ever used this function, but I'm not sure you can make a plausible argument that this should have ever been included in stdlib.
No need to loop preg_match. function mt_time($str) { $t = false; if (preg_match('/^(?:(\d+)d)?(?:(\d+)h)?(?:(\d+)m)?(?:(\d+)s)?$/', strtolower($str), $res)) { $t = 0; if (isset($res[1])) { $t += $res[1] * 86400; } if (isset($res[2])) { $t += $res[2] * 3600; } if (isset($res[3])) { $t += $res[3] * 60; } if (isset($res[4])) { $t += $res[4]; } } return $t; } echo mt_time('2d4h6m57s')."\n"; echo mt_time('2d51m14s')."\n"; echo mt_time('4h9s')."\n"; echo mt_time('24h')."\n";
I looked at those, but they start with a P, and have T in the middle where the time part starts. It's not a 1:1 comparison.
I'm not a PHP expert by any means, but in Java I would just use a 4 indexOf() methods and go through it systematically.
What if there is no D? All the fields are optional.
This is not the kind of thing that can gain traction without a patch. It's easy enough to say "we should have that" and discuss how it should work but until someone tries to implement it and tackle the real problems, we aren't moving forward. Stack overflow, room 11, make noise, one of us will join in probably ...
Thanks! I'm not the author but I'm very much interested in this functionality. And I agree that without a patch it probably won't get enough attention from internals. At this point (at least for me) it would be nice to get an idea on demand for generics within PHP community in general. P.S.: can see you guys chatting on SO, but don't have any reputation there to be able to contribute, haha.
I don't think that will be an issue. A DHCP lease expiration should always be less than a month. They are typically less than a week.
With the assumption that the period will go only up to days: $period = preg_replace('/^(\d+d)/i', '$1T', $period); $period = 'P' . strtoupper($period); Now it can be used on a `DateTimeInterval` object.
Actually there is no argument... It's there, and it's probably going to stay there until the sun goes nova. Is there some reason you think this useless little function shouldn't be there?
Thats just weird, the types aren't "missing", the php runtime knows 1 is an int and 'test' is a string. 
Yes, because the standard library of a language should only contain language constructs and basic type manipulation and extraction / conversion functions. I'd argue arbitrarily transforming hash keys does not meet that standard. Can you name any other language that includes this function (or even something close to it) in the standard library? I can't, but I'm always prepared to learn.
The amount of people!e that don't use elastic beanstalk is too dam high
1. I consider the tests for the wrapper to be a functional test anyway 2. Correct in theory, but I can't enforce semantic versioning. In a perfect world, no dependency would break SemVer, but not everyone is as disciplined unfortunately. 3. The problem is that I can refactor the internals of a class, have its public API still function correctly, but my tests will fail because I changed `$query-&gt;where('a', $a)-&gt;where('b', $b);` to `$query-&gt;where(['a' =&gt; $a, 'b' =&gt; $b]);`. I don't see the value in writing that kind of test. For example, this is some code from my current project: $list = $this-&gt;query() -&gt;select('election_id', new Expression('COUNT(election_id) as count')) -&gt;whereIn('election_id', $electionIds) -&gt;groupBy('election_id') -&gt;lists('count', 'election_id') -&gt;toArray(); $countPerElection = []; foreach($electionIds as $id) { $countPerElection[$id] = (isset($list[$id])) ? $list[$id] : 0; } return $countPerElection; Mocking the query builder to test those exact method calls is much less robust than using an in-memory database with known data and testing the expected output. I've tested similar code both ways in the past and the mocking approach led to automated testing being abandoned because the cost of updating them for every internal change ended up being prohibitive.
I answered your question, it seems polite that you should at least take a stab at mine before asking another. Here it is again: &gt; Can you name any other language that includes this function (or even something close to it) in the standard library? 
Expect the unexpected.
Perhaps you should read some of the other posts I've made. I don't need stuff for CV references, my CV has enough in it. Virtually everything I work on is under copyright or NDA at work. And while every new project improves my skills in some way, it's been almost four years since I've done a project specifically for that purpose.
I understand generics well. I use them literally every day in Hack and Flow. This is a very hamstrung form of generics that limits the polymorphism to the parametrized class (generic). There isn't any good reason in my opinion (other than it being harder), for generics in PHP to have this limitation. If you have an Entry and an Entry is generic, why do all things that operate on Entry have to have concrete types specified. Also, again to reiterate my point about the runtime error your example produces. Why does this have to be the case. Entry does have an inferable concrete type when you initialize it with 1, and "test". It is Entry&lt;int, string&gt;, you shouldn't need to provide that information. But of course if you the pass Entry into something that expect a different concrete type it should error, likewise, when you pull the 1 out of the entry and then pass that to something that expect something other than an int it should error.
Please have a look at type polymorphism in other languages, you are missing out on a large part of its useful features. As an example, you haven't addressed covariance and contravariance or constraints. 
Does Hack support this kind of "implicit" syntax? Generic classes won't necessarily always have constructors with the same arguments as in the definition of a class, right? Let's say: class Entry&lt;K, V&gt; { public function __construct() {} public function add(K $key, V $value) {} public function remove(K $key) {} } So there is no way for runtime to know which types are expected upon construction. Such "implicit" flow just introduces really weird edge cases and will make implementation a lot more harder, in my opinion. Of course, no one is forced to use generics. If I don't need type safety then I just don't use generics. It's the same as with scalar type hints and return type declarations.
Yes I agree, but I don't understand why you are giving this example because it has no relevance to what I am discussing. Is there anything I can do to make that clearer?
iPhones automatically rotate the image according to the orientation in which they were originally taken, some apps on your desktop won't automatically re-orient them. You'll have to read the 'imageOrientation' meta-data of the image to get the rotation and re-rotate it if you want it to display correctly. 
&gt; Why do they need to do anything, on a project a corporation open sourced and gave you for free? I'm not using HHVM. The "you need to" referred to what I think is best for HHVM itself and Facebook. This is known as giving feedback, and people do it from time to time. Think about it like surprise free consulting.
That would mean you designed things that way though, which I think is great. I'm seeing more and more services designed around things like Amazon Lambda, that don't really have an immediate self-host alternative. Even S3 can be a vendor lock in if your codebase has no other way to save a file and store a reference to it for users to download. I'm all for AWS, but I think it's important to ensure your application will run somewhere else if something comes up. Stack Overflow made the case for significant gains in buying their own hardware once they hit a certain level of scale. It would be silly to say "well we can't even discuss it because our app would have to be rebuilt from the ground up", and I think a lot of current projects would be in that boat.
Think about what's between the angle brackets as arguments, except the "value" passed is a type specification. Calling without required arguments is an error, so it makes sense for it to be an error when you skip type arguments. Inferring types is possible, but that's another concern that'll need to cross-cut through everything in PHP, at which point it can work for generics as well. Until then, passing the types explicitly will work just fine.
I just saw a video of Rasmus Lerdorf who explained that php was just supposed to be a wrapper/api to C to make c fuctions available on websites. It was never supposed to be an independent language.
InfoQ.com is one I visit regularly. Another is obviously YouTube - a lot of stuff gets posted there.
Yes of course. Problem is that I'm don't know how to re-rotate them. The class I'm using (bulletproof, see first post) is using move_uploaded_file, and imagerotate() is resource. I can figure out how to solve this 
The Symfony Console component might be what you're looking for: http://symfony.com/doc/current/components/console/introduction.html AFAIK it's what Composer uses.
Yeah, you're totally right that solution with regex will never work as good as true parser and it would be best solution for php, and probably simplest too. But it would be usable for PHP only, and that wasn't my goal. In theory it's possible to do parsing using some of those libs, you just have to override 'tokenize' method of Language class and there you go - don't have to use default parsing engine. However I'm not using only regexes - they're used just for tokenization of file and then found tokens are parsed into AST-like. Thanks for feedback.
Checkout https://github.com/phptodayorg/php-must-watch. There is a bunch of conference talks you might be interested in. PS: I'm maintaining this repo.
I'm not sure if your assumption on what @throws is supposed to document is correct. UserService::logUserIn is not throwing the exception, but the method of the implemented Gateway interface at $this-&gt;gateway-&gt;retrieveUserStatus, called by said method, is. I would expect @throws to apply only to the method that actually (explicitly) throws the exception and not to implicit exceptions thrown by methods called by the documented method, but I could be wrong.
Looks like it's [pulled in as a dependency](https://github.com/umpirsky/centipede-crawler).
https://github.com/umpirsky/centipede-crawler
Same i was expecting more. Maybe it can do more but you can do this with a one liner shell script probably 
http://climate.thephpleague.com/
True, but it's probably overkill to write whole parser LL parser for just syntax highlighting purposes even, if it would produce best results. However, maybe I will try write implementation of that (it's possible to exchange parser without any trouble, it just have to return valid highlighting tokens). Thanks for suggestion!
I was simply ignoring your question because it is irrelevant. In a compiled lang, it would be pointless. In languages with cheap map functions and callbacks, equally pointless. In languages without an associative array type, well, you see my point, don't you? I didn't answer your question because it was a *stupid question*. Which is not to imply at all that you're a stupid person for asking it, it's just that you have some wrong assumptions about the nature of mature languages. We aren't arguing about whether PHP is well-designed or not. Nobody could take the 'yes' position in that debate and win. Php was written initially by the technological equivalent of a caveman. It doesn't matter that the initial authors knew very little about language design. They weren't out to design some beautiful language. It was initially meant as templates with a little extra. What matters is that millions of people started using this insane hackhob. Now that millions of people use it, there is no end of wailing and gnashing of teeth when proposals come up to reform the standard library. You think you're the first one to point out that other languages don't have this one function? Just as a thought experiment, suppose you go write an RFC proposing to remove it. What would be your justification for removing it? Would the benefit outweigh the pain of forcing the users of that function (there's more than 9 of us) to rewrite their code? I've had this same cute little argument 100 times before with people who, like yourself, miss the point and wave their arms talking about how dumb the standard library is. *Of course it's dumb.* However dumb it is though, it's not really hurting anything just by existing. PHP should be reformed, but it's not possible to do so without breaking quite a lot of stuff. Stable languages, as a rule, must not break lots of stuff. edit: https://3v4l.org/jU1Yu
From what I saw in the source, nope, this is all it does
more like the human centipede of php
Yes, the problem is that it doesn't (apparently) work with interfaces like the one in the example.
hmm I was scratching my head over this
I'm pretty sure `wget` can do this. 
I have tried the following: /* Rotate image */ $exif = @exif_read_data($files['tmp_name']); if(is_array($exif)) { if (!empty($exif['Orientation'])) { switch ($exif['Orientation']) { case(3): $img = imagerotate($files, 180, 0); break; case(6): $img = imagerotate($files, -90, 0); break; case(8): $img = imagerotate($files, 90, 0); break; } } } But this gives me either PHP Warning: imagerotate() expects parameter 1 to be resource, array given or PHP Warning: imagerotate() expects parameter 1 to be resource, string given. 
http://www.techtalkshub.com/
Ditch php after school. Ditch it even before if you can help it.
www.phptherightway.com
Seriously, what the fuck /r/PHP. Comes to php for help and specifically says no frameworks, First response says ditch php...Second response says use a framework... On a real note check out phptherightway as suggested by /u/kodemann Specifically you may want to check out the design patterns section: http://www.phptherightway.com/pages/Design-Patterns.html
&gt; I was simply ignoring your question because it is irrelevant. Plainly you ignored it because you don't like the answer, or else you wouldn't have wasted another couple of paragraphs deflecting it. PHP isn't some unicorn language, there are a bunch of other dynamic interpreted languages (most of which support hash maps and have functions or methods for manipulating them in stdlib). None of those languages include this functionality that I know of (but I'm prepared to be surprised if you know of one). &gt; I've had this same cute little argument 100 times You're arguing why it's there now and can't be removed, and I don't think anyone contends otherwise. My point was that it was stupid to put it into stdlib in the first place because it doesn't belong there. &gt; Of course it's dumb. I'm glad we agree. 
Depending on your assignment restrictions, you may find [the Aura libraries](http://auraphp.com) useful. Each package is independent of any framework, and independent of any other package as well. You can write your own code to glue them together as needed. (Full disclosure: I am the Aura lead.)
That's an open question. Depends what you know so far? Last thing you want to do is put a load of pressure on your self and get snowed under trying to learn everything. Get to grips with php and mysql at a basic level. Maybe even try to do a simple todo list app and not worry about frameworks or anything at first. In terms of books, not sure it would be a good idea just yet as you could learn more doing than reading, that depends on what type of learner you are though to be honest? At least this way allows you to get to grips with the languages. Not sure what else to suggest as you are applying for a job with next to no experience. I was using php for a year before my first job as a php developer at a junior level, all in my spare time by just building stuff. Hope that helps... 
It seems like a side effect of this is it could actually help you check the surface area of your app, too. For instance, I am building a customized eCommerce site using Magento 1.9 as the base. There are tons of URLs generated by Magento, some of which I do not want. It's not just Magento. Plenty of frameworks provide endpoints you may not know about, want, or need. Cool tool just to validate (1) you have the endpoints you expect and (2) those endpoints are delivering the proper responses. If I run Centipede without authenticating, I probably don't want to see my admin links returning a 200. Seems obvious, but mistakes happen. 
This doesn't seem to do much aside from check if the page works. 
maybe handy for some, but this isn't really an automated testing tool. it is juts a link checker that checks http header response codes.
&gt; You're arguing why it's there now and can't be removed, and I don't think anyone contends otherwise. My point was that it was stupid to put it into stdlib in the first place because it doesn't belong there. No, I'm arguing that, given the design and intended purpose of the language, array_change_key_case is a great function, and comes in really handy. The stdlib is exactly where it belongs. Try doing the same thing in PHP code, with the same performance as the native function. It's not possible. For the same very good reason, array_column was added in 5.5. Same with array_replace/array_replace_recursive in 5.3, and array_diff_key/diff_ukeys in 5.2. Same reason I'd like to see array_multiusort added. Your basic argument is that these operations *can* be done in the language itself, so they shouldn't be functions in the standard library. Your argument is ***completely missing the point***. The same argument applies to almost every array function in the standard library. There is a good use case for every one of these array functions. The reason they're in the standard library is that they're simple enough operations that they can be used in a multitude of scenarios, and they're much, much faster as library functions than they would be as PHP code. Comparing PHP to other languages is completely and utterly worthless in this discussion. Are there other languages with non-object associative array types? Yes, a few. Does it matter that they don't have all the same functions for manipulating them as PHP? No, not even a little bit. I'd love to see PHP's array become an object with methods so that everyone can quit complaining about the array_* functions cluttering up the global namespace. Is that likely to happen? No, that's almost 99% certain not to happen. I'd love to have a nice fast way to transform array keys without using array_change_key_case without having to write a PHP extension to do it. Is that likely to happen? Nope, probably not.
count me in
Make sure to install [ANSICON](https://github.com/adoxa/ansicon) and force ANSI detection on with: $cli = new League\CLImate\CLImate; $cli-&gt;forceAnsiOn();
&gt; Your basic argument is that these operations can be done in the language itself, so they shouldn't be functions in the standard library. You seem quite adept at arguing against things you imagine people said instead of what they actually said. I'll post my argument again: &gt; the standard library of a language should only contain language constructs and basic type manipulation and extraction / conversion functions. I'd argue arbitrarily transforming hash keys does not meet that standard. How many of the stdlib array functions are designed to arbitrarily transform data rather than generic manipulation or extraction? Why do we need a stdlib `array_change_key_case` but not a `array_change_key_mb_case`? How about a `array_change_key_ucwords` or `array_change_key_camelcase`? `array_change_key_:-)to😀` could be useful for some folks too, would you argue those should be stdlib as well? &gt; I'd love to have a nice fast way to transform array keys without using array_change_key_case without having to write a PHP extension to do it. Have you considered that if your needs require arbitrarily transforming large amounts of data very quickly, then perhaps you're better off choosing a tool better suited for that?
You need almost they want (all is imposible) My unique advice: learn by doing HTML &amp; CSS &amp; JS - Codeacademy (the "make" series) PHP - Youtube CodeCourse https://www.youtube.com/user/phpacademy/featured PHP -&gt; OOP -&gt; Practical Tutorials (Auth,CMS,Blog,Social Networking) Git - http://code.tutsplus.com/tutorials/git-for-designers--pre-54689 - https://try.github.io/levels/1/challenges/1 REST - http://code.tutsplus.com/tutorials/demystifying-rest--pre-58000 This is easy but not rapid
Changing keys to upper or lowercase isn't arbitrary... 
Even if you don't want to use an existing framework: As your project grows you will want to extract reusable bits and pieces. For that, it is a good idea to stick to established concepts (and naming conventions). Where to get those? Well, either at the sites others recommended, or just by looking at existing frameworks. In particular, in your case, check out some of the micro-frameworks out there. i.e. the [Lime framework](https://github.com/aheinze/lime) which consist of a single php file. In addition, follow existing conventions and tools. Make sure to use Composer, namespaces with autoloading and checkout phptherightway.com
I'm not sure why you say there isn't time to learn a framework. A framework is documented. If you bake something up yourself, it may be harder to learn for the others or coordinate on. Alternatively, you should at least take a advantage of some existing modules/components like the symfony http foundation. As others have mentioned, you might also consider a micro framework like Lumen or Slim.
I'm sick of the love affair this place has with frameworks. I was an in-house corporate developer; I hate frameworks and hardly ever used them. I also supplied technical designs, code commented, and documented my code online. I'd never ask this place for development advice because the only answer I'd get is "use a framework". EDIT: spelling
&gt; Just learn composer and use composer packages No frameworks allowed. He's in school taking a PHP class. &gt; Also, there is no such thing as OOP best practices for PHP. There are OOP best practices which you can either do or don't in PHP, but these are general programming principles. This is very true, but there might be multiple ways of implementing any particular set of 'OOP best practices'. Therefore, 'OOP best practices for PHP' actually means, "What are the best practices regarding how to implement OOP best practices, and to go along with that, what are OOP's best practices to begin with?" Such questions are perfectly valid, and actually are a good thing to ask. For a while, I was pretty lost and didn't know proper OOP best practices, until I took a Java class (I don't like Java, but it's great for learning OOP). My programming skills improved in all languages, but I still had to learn how to actually apply those OOP skills and patterns in various languages (both from making mistakes on my own, and by looking things up on the Internet). &gt; Suggest reading Code Complete or Clean Code or other general programming best practices book. it's possible that PHP is OP's first programming language, or that he doesn't have experiences in the programming languages that are used or discussed in those books. I understand that they're more general and theoretical works that deal with code as a whole, but they probably still have examples and likely use specific languages for those examples. There's nothing wrong with asking for resources that use the language you know or are already learning, even if what you really need is to understand the theoretical and more general concepts.
How much experience do these other people have with programming? If you can't teach them a framework you're not going to be able to teach them OOP, architecture, etc. If they already have experience with these things then picking up a framework, especially something like Laravel, should be a piece of cake. If the rules of your project are preventing you from using a framework then that's fair enough, if it is allowed I think you should reconsider your approach. A poorly written app in a framework is going to be miles better than a poorly written app from scratch.
Not only conference talks, but https://github.com/marcelgsantos/learning-oop-in-php has lots of good stuff. Please check it out.
&gt; No frameworks allowed. He's in school taking a PHP class. Depending on how the restriction is worded, that's not necessarily a problem here. The Laravel *framework* is made of a bunch of Illuminate *components*. It's possible a framework constructed on well-tested components would be acceptable.
The most important part about architecture is to get the separation into components, and the responsibility of each component right. This will also allow you to easily spread the work on the project across your team of 7. I don't know what you know, I'll just list typical components in a modern PHP site (framework or no framework, doesn't matter) and you can ask me questions about the responsibility of the components you're not sure about: - Composition root (aka: bootstrap; environment). - Application class. - Router (aka: front controller; dispatcher). - Controller (aka: "page handler"; action class) - View (aka: template) - Services (aka: domain; domain API; models; business logic) Does anything in that list ring a bell? Any questions? The terms vary a little, say in my own code, router and dispatcher are two distinct components that work together, but that's it in a nutshell. Most of your code will be services, followed by controllers + templates. A good way to assign work in the team is to assign a "directly responsible individual" to every well defined module in the app. Say: - You handle overall architecture, composition root + application init code + router. - Person A, B, C, D, E get assigned a distinct service each to build and manage (this is the bulk of the business logic). - Person F does the front-end for the public site (controllers + templates). - Person G does the front-end for the private, i.e. admin portion of the site (controllers + templates). And now you have 8 people working on their own thing without stepping on each other's toes a lot. 
If C were bloated it wouldn't be so prominent in systems development.
&gt; I would like to know or see examples of best practices and best OOP practices for php and absolutely zero frameworks To do what? There are examples of inheritance on the PHP website. Best practice implies an addressable concern so there could be a practice. A better question is why you would ask on reddit "how to program a PHP module"? What's a [module](http://php.net/manual-lookup.php?pattern=module&amp;scope=quickref)? You can't get "how-to the right way" for any specific functionality without, defining the bounds, defining the use cases, exploring the future roadmap, and discussing the security implications. Reddit is not a forum for that, nor is any specific website, in regards to PHP. If you aren't able to articulate a specific concern, you aren't going to make for productive discussion for any reader, anywhere. The reason people point to frameworks, is because they are not well versed in the myriad of potential concerns (it's almost limitless) or arguing about "what someone means when they say X". It saves time to indirectly move the discussions to forums where the specifics can be justified, in detail, and someone might be interested in discussing that specific concern. 
k&amp;r c has 32 key words. you can hate pointers and null-terminated strings and all that stuff if you want (and i wouldn't blame you for it!) but the one c ain't is bloated...
type safety at runtime is an oxymoron. :D you mean: "slightly better errors than the ones you are going to get anyway if your code is unsound" EDIT: I am being a bit mean, but that is mostly what I think about the idea of runtime typechecks. There is nothing typesafe about your program when you have to run it to find out it doesn't work.
When I took a PHP class, our instructor wanted all of the PHP code to be written by us, and nobody else - except for one project, which *he* had written... Which was written badly on purpose. The assignment was to take the broken and badly designed PHP code, and rewrite it to follow best practices (and actually work). It does depend on how it's worded, but at least my own instructor would at *least* mark points off for using something like 'components' - even if the syllabus was worded in a way where it was technically allowed. Best to be safe, rather than sorry.
You are right, but I think he meant that c programs tend to be obscure bloated messes. You get minimal, easier to read code by using a higher level language because a lot of the implementation detail is hidden. I work in php, but still love hacking around using c on hardware.
All those frameworks end up using all those things themselves. There is nothing wrong with learning how it works on the lower levels, and in fact it should be encouraged. Knowing what is going on only helps when it comes to doing things the right way, and especially when it comes to security. If you don't know how $_GET/$_POST work, how pages are called from the web server, etc. you will not be much good at finding out why you're being hacked by someone in China. It's probably best not to write everything 100% from scratch when you have a job, and need to pass down your code to others, work with existing code, get the project done quickly, or simply interact with other projects... But when you're in school, it's *always* best to do as much code yourself (or 'yourselves') as possible.
&gt; I don't think tesla reinvented how to mold plastic or how to form a bumper. That would be more like creating a new programming language.
Doesn't make sense. It's not really a testing tool. This will __only__ tell you if links are working correctly. If you're attempting to do something like test API endpoints you'll get a 200 response code as long as your request is successful, even if your application returns an error. Not really helpful...
The abstraction and its comprehension is what makes systems and software engineering 
Probably a more robust way of learning beyond "build a blog" projects.
I spend a lot of time on http://confreaks.tv/
I am so glad to see some others like you. This sub has made me feel insecure about my PHP skill because I don't want to use a framework for everything. It sets my mind at ease to know that I'm not the only one.
Thanks. I also was surprised when I saw the downvotes, given that I tried to take into account the constraints in the OP's question, yet share some of my own experience that really seems directly relevant to the OP's situation. I'm as tired as everyone else in /r/PHP at people constantly trying to push their favorite PHP framework. But I guess if a reply mentions Framework X or Framework Y, even in an indirect way, but doesn't mention a redditor's personal favorite, Framework Z, you'll still get downvoted. Like I said ... not the response I expected, but I've only been participating in /r/PHP for a few months. Lesson learned.
What is the proper way to supply cURL with an updatable certificate authority file? Currently the best way I've found is to download from http://curl.haxx.se/ca/cacert.pem and cache that file to be used on future cURL requests of any kind, including sending a timestamp to check for a 304 or 200 status to re-update the file or not. This is mostly for windows/mac.
Where is a good place to get more help with CakePHP? I'm just getting started with Cake, and looking for a good place to ask some questions that might seem basic to more experienced/advanced cake users. For example, I asked [this question](http://stackoverflow.com/questions/32286800/cakephp-3-0-validating-input-against-data-in-another-model) on stackoverflow, but didn't get any responses. I'd like to find a good place to seek assistance in learning cakephp (beyond the tutorials). Thx!!
Stick with it dude; it may be different when you're a contractor and time is a valuable resource; but personally I'd rather have the skill to build specific solutions rather than the generic solutions that frameworks provide. Besides, if we all used only frameworks; who'd build the frameworks?
That's exactly my spirit. I got into PHP professionally by creating custom-built solutions from scratch. I eventually wrote my own sort of framework that I used to deploy numerous projects before I even knew what a "framework" was. And by the time I subscribed to /r/PHP and saw that it was apparently the norm for everyone to install what I consider to be a whole bunch of bloat for every single project, and that now the first step to any kind of PHP tutorial is "Install Composer" - I was dumbfounded.
I personally would love to see this.... as I am quite tired of having to write concrete collections to represent a list of objects
What are you even arguing for? Are you still trying to defend your notion that he should just go with a prebuilt framework? How would going with an existing framework help him comprehend what the framework is doing, more than building his own framework?
This is good advice for any language. It's just especially hard for PHP since the language itself doesn't follow this advice.
perhaps you could try to get a hosting company to sponsor the class?
I've had very mixed responses from the PHP community. I understand why, but it still frustrates me. I built my own framework for some very specific reasons, and when I asked people (on IRC and Reddit) what they thought, I generally got these responses: 1. Don't build your own framework, use an existing one. 2. Only use PHP for things that don't require frameworks. For anything complex, use Ruby/Python/C (yes, seriously). 3. X, Y, and Z frameworks do &lt;thing I hate about frameworks that I specifically avoided at all costs&gt;, so you should too! 4. You're doing things pretty differently/weirdly. Don't do that because I don't understand why you did that. 5. I don't see anything particularly wrong with your code. Most of the time, I'd just have to describe what I was doing (or what my goals for the project are), because they wouldn't bother to look at it themselves. And I can accept that, because I understand most people have lives and don't want to act the part of some newb's schoolteacher (it is, however, encouraging that most people who do look at the code, don't really see too many problems with it.). But often it just seemed like they didn't listen to what I was saying to begin with. A specific example that kept coming up, was my insistence on well-indented HTML as output. Most of the time, they'd instead say that I should be 'minifying' my HTML, but I specifically said that I wanted to be able to humanly parse all the HTML/CSS/JS in its raw text form. One time, after quite a bit of back and forth, someone finally linked me to a framework that might allow for well-formatted HTML output. It.. Kinda did, but was set up in a way that made it much harder to work with than my own framework. You had to make a template for each separate page, so you couldn't have one template used across a whole site. The most frustrating thing for me, is that I was hoping for feedback not on the merit of my design goals, nor the merit of making 'another framework' to begin with... But specifically on whether the mechanism I was taking advantage of was stable enough that it would continue to work in the future, or if I should just abandon it and try something else. My framework takes advantage of the fact that destructors for objects are called when a PHP file is done running, so what it does is basically this: 1. Inside 'foo.php', you `include()` a file. 2. Under the include, you create a 'page' object with a single parameter (telling it the name of the template file to use). This starts output buffering. 3. Still in the 'foo.php' file, you type whatever you want for the content of the page. PHP, HTML, whatever; as long as it generates the actual content of the page, but only the content - not the header, footer, navigation panels, etc. 4. 'foo.php' finishes running, and calls the destructor of the 'page' object automatically, which does: 1. Stops output buffering. 2. `require()`s the template file (which is a PHP file, but is mostly just HTML with a few 'echo' statements to place things in certain places). 3. Template file basically is a bunch of HTML, but as stated, echos out the appropriate bits of the page into the right parts of the surrounding HTML. So the content is placed right, as are any 'modules' (which act sorta like sub-pages). 4. To get the contents to echo out, it calls a function that goes through and appropriately indents each line. I *still* have no idea if this is actually a good idea or not. It works, though, and lets me keep all my output nicely indented - while still allowing me to only have to write it once.
Man have you tried [Heroku][1] or [openshift][2]? you can get free accounts and host anything you want [1]: https://www.heroku.com/ [2]: https://openshift.redhat.com/
I suppose I mean you do learn how to properly build database relationships and how models and controllers work. I just assumed ... Either way the project is interesting.
I dont mean the project I meant forum software
I never knew that running a PHP server was this easy: &gt;php -S localhost:8000 This is probably the first time I've ever been excited about PHP. Thanks for posting this link, great site.
I run a hosting company and we are willing to donate some hosting to a good cause :) . Pm me for the sign up process Edit: wow. Our website is http://www.thewebsiteguy.org/ Edit 2: /u/haptiK if/when you are interested pm me and use our normal signup form, choose however much space you think you'll need and you will be billed for $0. I'm going to start a whole campaign for getting schools the tools they require to teach children to code.
I agree. I'm not sure "bloated" is the right word to use here, but I understand what he means. The language itself isn't bloated, but applications written in the language can be a bit... mindboggling. Especially when the creators of a project used macros to reinvent the language.
\^-- This is why I love Reddit :)
&gt; Purely for testing purposes though!! Yeah right! Everyone knows Zuck gets up early every morning with:`php -S www.facebook.com`
&gt; He asked what would be considered the "right" way. He really should be wrapping those those globals into some sort of request object to help with his testing. Then why not say that, instead of saying he should use a framework? &gt; I'm not discouraging him from teaching them how it works, but writing an entire project using them would be considered bad code, which is the opposite of what he wanted. It's not an either/or situation. He could very well *not* use a framework, and instead wrap those globals into a request object of some sort :p &gt; If they don't know how GET and POST requests work already, it's not going to save them from hackers when they learn it in PHP. I doubt getting hacked by people from China is at the top of their priority list considering 5 of them don't even know PHP. If he doesn't know how GET and POST requests work, or doesn't know how to use `$_GET[]` and `$_POST[]` in PHP, he might run into a security bug with some of his projects later on. And if he were to know about how that all worked, he'd potentially find some insecure code in the framework's code where they use `$_GET[]` or whatever incorrectly. It's possible that his codebase depends on an older version of that framework, and their boss won't let them try to change it to work with the new version (Overtime? We can't pay you overtime, get back to werk). &gt; Depending on the project, writing as much of the code themselves could prevent them from finishing and learning everything else the project could teach them. That'd be the instructor's fault for not allotting enough time for it to be completed. I assume that the instructor weighed the pros/cons of whether or not to allow them to use frameworks or not. &gt; If they spend a bunch of time trying to figure out forms and POST requests, they might not even get to the actual CRUD part where they learn SQL and databases. Wouldn't that all be separate assignments? Unless this is a final project, I'd assume that teaching form interaction, databases/CRUD/SQL, and so forth would all be separate assignments. This is just one assignment, so they're probably not going to have to worry about *everything* from the start.
LOL!
If you're going to use apache or similar I'd say setup a vagrant environment or something on each machine umm I think puphpet.com is a good start and then vagrantup.com is a good vagrant site if you're not familiar with it. It's essentially a front-end to VirtualBox to setup environments that are predefined such as a Linux box with php 5.5 and Ubuntu 14.04. I can give more info if you need it on this but I love using vagrant, docker is my new go to but a bit more advanced 
Is running a vagrant box and hosting the code they write online an option? Something that could the started and stopped at will and they would have full access to any code they wrote.
&gt; Then why not say that, instead of saying he should use a framework? I did, my #2 is for him is to write his own framework. :p &gt; It's not an either/or situation. He could very well not use a framework, and instead wrap those globals into a request object of some sort :p Either he wraps them in a request object, or he uses them directly. If he has 8 people in his group he should set a standard otherwise it would be a mess of code. &gt; he might run into a security bug...he'd potentially find some insecure code... No matter what framework/code they use they should sanitize input. I'm not sure how understanding that article.php?id=5 translates into $_GET['id']=5 is going to allow them to spot a security bug later on. &gt; Wouldn't that all be separate assignments? Unless this is a final project, I'd assume that teaching form interaction, databases/CRUD/SQL, and so forth would all be separate assignments. I don't know. I didn't read all of OPs posts, but he did say this: &gt; Were gonna be building a somewhat basic CRUD application and we're going to be doing everything from gathering requirements to testing. He didn't say how it's being broken apart, or what's being taught vs what they must learn on their own. OP didn't really give enough info to figure out what should be prioritized. If he's got 3 months to make a full CRUD app, sure, write every single line yourselves. If he's got 4 weeks...
It's been a while since I've used VirtualBox, but I'm looking forward to getting it set up during my down time. 
https://github.com/hizbul25/ahb-php-app
Try asking the school if they have a server you can use. 
Dreamhost offers free hosting to non-profit charitable organizations registered in the United States. I don't have experience with this process, other than googling to find this: http://wiki.dreamhost.com/Non-profit_Discount From business experience, though, Dreamhost works very well (much better than godaddy at least), the only difficulty you may have is that its only one ftp(sftp) account.
I would be willing to give you some space on one of my servers to host the sites. PM me if you'd like.
Which hosting company, so I might consider returning your gesture?
&gt; it's quick and easy to deploy. I wouldn't call "installing a PHP extension on a shared host" quick and easy.
Way to go!!!
GOOD LUCK with segfault debugging in Phalcon!!! ;-)
http://www.hostinger.co.uk They have a free tier php hosting, not sure how good is it though.
&gt; I don't think unit tests should be responsible for determining the efficiency of my SQL queries It's not it's testing if you've using your query builder correctly. &gt; But the fact that my experience puts me in agreement with individuals such as Uncle Bob and J. B. Rainsinger makes me suspect I'm on the right track. At the end of the day, focusing on testing behaviors instead of implementation details has led to writing less test code that is also more robust and portable. If I find that to no longer be the case in the future, I'll reconsider that approach. Those blog posts are about hand writing mocks, which you only really do at an integration level now a days. It all sounds good, but practice generally tells me that not enough unit tests results in a test suite that isn't worth that much and a major pain in the ass to use to find out what exactly broke. But that's how we all learn we do something until it hurts and then we switch to something better. Also I think it's important to note that Everzet's made point is you abstract the implementation details. When you do that your implementation tests are very small and very limited to a few wrapper classes. If you don't test implementation details in those classes what are you testing? The idea of "That's an implementation detail don't test it" sounds really bad.
You should give the link of the ticket
I tried this, however it is still severely limited with windows CMD. Can't do single line progress bar movement/change window or anything dynamic. I'm guessing it can do the first if I custom insatll ANSICON, but I would rather not require clients to have to install a 3rd party piece of software to their windows directory.
I'm still getting used to talking about code while putting it together, it's actually quite hard. I misspoke a couple of times, when I said arginfo was "just" for reflection, that's not quite right, it is used for reflection but the engine uses it too (because it reflects on functions also). The point I was trying to make there was that it's your job to make zpp and arginfo consistent, I'll make it clear next time ... I'd liked to have gone into more detail about testing, custom object layout, and many other things, but my planning is letting me down. We are trying to make them a length that's actually watchable, nobody wants to listen to me talk for 5 hours at a time ... still working on planning. Anything that wasn't covered in enough detail this time will be covered next time in more detail, we are planning another cast with a different set of classes, ones that use different handlers and are more like normal objects. I'm very eager to hear opinion from people that don't know about this stuff, what did you think was lacking in detail ?
Freelancing question: I don't want to work directly with 'clients' but for senior PHP developers , who are looking for a extra pair of hands. How can I connect with them ? I myself am at an intermediate level and have worked on PHP and related tech for years now. I tried the IRC channel ##php - but that has a strict nolance policy. Multithreading Question: What basic stuff should be a prerequisite for understanding how to use pthreads/concurrency in general ? 
Grab any of the Professional/Pro PHP book titles. Read them. Play around with things constantly. There are a ton of junior dev jobs out there that will hire you if you can grasp and do the things in the Pro books. If the job you're applying for doesn't work out hit up https://catn.com/jobs/php-systems-developer/ and ask about a junior role. It's a top company to work for.
Why are you using PHP? PHP is just a whole bunch of bloat on top of C.
YepSaysAnthony
I have used [nitrous.io](https://www.nitrious.io) for several projects. It has a LAMP development package as well as other types. Its free tier allows for use of a web editor, root access and also allows has several Apps for local use as well. Good luck mate! 
Sorry messed up the link [https://www.nitrous.io](https://www.nitrous.io)
&gt;No frameworks allowed. He's in school taking a PHP class. But OP didn't say that this was the case. Speaking from experience, a major project at Uni for me was to build a PHP app and we *were* allowed to use frameworks/components/packages/whatever. We had to justify *why* we chose to use this 3rd party code and demonstrate an understanding as to what was going on and obviously had to write enough additional code within the framework too. This may not be the case for the OP but they haven't given information one way or the other.
What is best way to create JSONs with many nested levels? On the input I have multiple rows from database in array. I'm parsing them and putting into associative arrays but it's wrong.
You probably didn't get answer because there is no "Laravel-way" working with forms. Or generally HTML for that matter. At least not anymore. You could probably start looking for reasonings as to why the Form and HTML helpers has been moved out, but I would suspect that a "one size fits all" HTML generator never really will work - and Laravel is not about that. You could find another HTML and Form generator. I for one wouldn't use one, but that's because I prefer controlling and styling my HTML on my own. 
I don't see your point in this. Automatic injections is *exactly* the same as typing 'new' in the code - except the code is now easier to refactor and you can ask for already configured objects without configuring it in an object that has no business configuring something. Like ircmaxell said above.
Yeah, that's what I'm doing now. It feels kind of bad, cause if I knew that I'll have to rebuild my views I would go with Twig or Jade instead, Laravel's Blade feels really minimalistic. 
don't ditch framworks because you think it makes it more difficult. if you use the framework to build a base skeleton application, it actually makes it more easy for people to get into it, you just have to do all the "frameworky stuff" first, so that people only need to care about the buisness logic of an actual action/endpoint/page ... take the 3 who have prior php knowledge, let them work on the classes, and code logistic, take the other people and show them where to put their php code then you have the best of both worlds, they are using a framework - withouth even knowing most of the time, but they still have a simple start in the php world. 
 Enthusiasm. And ideally as much as possible prior knowledge, but if we hire PHP Juniors, they sometimes fell fresh out of the university. Depending on how much prior knowledge and enthusiasm they bring, we sometimes offer them an internship (maximum of 3 month, paid at minimum wage) before we actually hire them. But really ... enthusiasm is the key to success, this also includes showing a) that you started learning php or about php b) that you really know the company you're aplying at. c) that you have resources where to look for help d) that you are not afraid of asking for help 
Personally, I'm using https://github.com/Kdyby/CurlCaBundle - it uses the same source for certs as you linked, but it is in a composer package and usage is really easy :)
Go back to my original post. Did I ever.. even once.. say anything specific about op? All I said is people who build roadsters from scratch have time on their hands. Lol and it turned into this. Your argument that you don't need frameworks is valid. But I also don't want to spend years reinventing wheels to solve a problem. My problems don't require me to build web frameworks. They are just a means to an end. The solution to a specific problem is what programming is all about. Obviously this kid was given a problem that required him to not use frameworks. That's a specific problem that requires you to not use a framework. Anyone that has a day job that requires them to use php and doesnt use a framework out of the reasoning that they don't like frameworks is wasting they're employers time if they aren't addressing the main problem and trying to come up with a solution for that problem. Using a framework or not should never be a damn problem. Especially in this day and age. Unless of course you're dealing with nasa level shit. 
hey ho, php-gtk is a great thing! I'm coding my own Project now, which allows you to encrypt the php code of an php-gtk programm... with a key, which is in the bat file and then just convert the bat into exe ;) If I'm ready i'll post it here ;) regards - subabrain
As I haven't found any good articles so far, could anyone point me to good resources about PDO, Database-Handlers and security-best-practices. Thanks in advance!
Some responses in this thread are completely nonsense. Let's see what the OP asks for: &gt; Were gonna be building a somewhat basic CRUD application A. basic. crud. application. Let's see what the requirements are: &gt; I would like to know or see examples of best practices and best OOP practices for php (first red flag) Sounds cool. Who is going to collaborate with OP? &gt; I'm managing an 8 person team and only 3 of us have actual experience with php (second red flag) Okay... but why do you reject the idea of using frameworks? &gt; I do not have the time to to teach 2 people how to use it, let alone all 7 Let's stop dreaming for a second. You cannot expect people to use best OOP/PHP practices if they never touched the language before. Especially, if you're asking for the "best quality much OOP PHP code examples", then you sound pretty inexperienced yourself. Your whole reasoning about "no-framework" is not to teach others, right? Won't they technically still learn your project? Who is going to help them if they get trouble using your project? Will they be able to google stuff and figure it out? Will they be able to google for some tutorials? Are you going to take the time and write a very indepth documentation for your project? Are you going to clearly explain what every class does, write docblocks? The reason people use frameworks is not because they give you a somewhat decent core to start with, but also a very decent documentation, loads of books, loads of tutorials, screencasts and an active community who can answer questions. *Just like how you got trouble installing Laravel to your Windows 10 machine last month and had to ask it on /r/laravel and got responses.* You want to things the right way, right? You can start with a DI container to be used at the core of our project. composer require pimple/pimple ~3.0 While we're at it, we can rely on a DBAL or an ORM to help us with CRUD stuff. Let's pick doctrine. composer require doctrine/orm Meanwhile you can start building the core of your project, where you will end up using Request, Response, Router components and much more. (which is basically same as developing a framework core to be honest) Also, while we're at it (you asked to see come "best quality code php examples", right?) I assume you mastered all the concepts of functional programming, OOP paradigms, SOLID principles, Design Patterns, integrated some acceptance/functional/unit testing into your project, have a decent deployment workflow, every single code of your project is being linted, you rely on continuous integration, use all the proper Git flows, very experienced about scalability, you consider time complexity of your projects and make improvements accordingly, rely on PSR standards, write tests like crazy, have a test-first mentality, keep everyone on the same track... Seriously, your expectations and the reality sounds so different and this is why this thread became a circlejerk. I just checked your post history and saw that you had alot of troubles even installing the Laravel which leaves much to be desired. To be honest, if I were you, I would get a basic CRUD tool (where all the escaping is being done automatically so people with zero experience doesn't leave SQL Injection holes, just like Doctrine DBAL or any other MySQL wrappers, perhabs even just PDO with prepared statements) along with a Router and write code with some common sense. It would be great if you can spend few minutes learning Composer and teach Composer to your collaborators, then you can just install some useful packages. You can also re-think about your no-framework policy and have a look at Silex/Slim/Lumen or something. Those are very mini, well documented and easy to get going. I repeat, if you're going to develop the core project where other 7 guys can work on in a modern way, then you're basically writing a "framework core." That's what frameworks do. Frameworks doesn't have to be macro sized to be called as frameworks. 
If you could remove all the domain/business logic from your project right now, could you use it to start a new project? If yes, then you wrote a basic framework. If not, consider relying on reusability next time. 
This would be my suggestion too. Their micro server is free for 12 months and would be perfect for this. Spinning up a PHP/MySQL server can be done by selecting one of the pre-made images from the AWS marketplace.
Yes, but he wants the fastest, most expensive and luxuriest car for his wife, who didn't even ride a bicycle before, knows nothing about traffic signs or cars, and wants her to jump right into the traffic because he cannot waste time explaining her what the gears or gas pedal does.
Yup, so the method `UserService::logUserIn` needs to let the caller know that it throws an exception. You'll need to annotation that method.
&gt; **Before you guys get all up in arms, the reason I can't use a framework is because it's for school** Literally the first sentence in OP's post. This something colleges and universities do, they make you not use a framework since they think that will make you learn the core concepts better, not sure if that's true but thats where OP finds himself/herself
Nor would it make any sense to, this place is a bit strange since everyone has a hammer and half the problems look like a screw...
you can edit posts, you know! 
Awesome! I'd recommend going through the php-src phpt tests and doing a parse-revert-parse cycle and compare whether the dump of both parses is identical. There will be a couple false positives related to INF, but this has proven to be a very good way of finding bugs :) 
Don't feed the troll 
As for development/testing, I develop all of my code locally, so it kind of forces me to build things in a very infrastructure stack-independent way. For example, for anything where I'm writing/reading files, I use [Flysystem](https://github.com/thephpleague/flysystem) and use DI to get the right adapter. Therefore, I do most of my testing locally too. If I can assume my composer packages are built correctly, and it runs on my local machine, then I can assume it will run in AWS just fine. Now of course, one shouldn't just blindly assume any of that, so we are working towards a CI solution that has AWS-based agents, but admittedly, we aren't that far along yet. &gt; Is the full stack of services (i.e. elasticache/redis/memcache) all tested? I guess I don't know what you're asking here. Are you asking if that stack has been tested by someone? If so, then it's definitely been tested and has been nothing but rock solid for us so far. If you're asking if I write my tests to include those portions of the stack, then it really depends on the use-case. I don't usually, though, because I build my tests to test my application logic and am not super concerned about testing my interaction with third-party pieces, since it's pretty trivial so long as I'm using dependable libraries and "drivers" to talk to them. Hope that makes some sense!
feel free to manually download and maintain dependencies from phpclasses.com
Firebase provides a database layer (there's a free teir, have each kid create their own account) Tumblr provides free static front-end hosting (if you ignore their blog stuff) Write a Tumblr Template that uses Javascript to talk to Firebase (and PassportJS for Oauth if you want?) There. No need for PHP or MySQL. Otherwise, do all development locally (XAMPP) and setup a central server for local development. No need to pay for anything until you're ready to push the website publicly. Edit: XAMP lets you install a server pretty quickly in any operating system. Note that you want it to be restricted to local use only if you can manage. I don't have much time, but let me know if you need help.
I need a simple CMS that I can QUICKLY integrate to a complete HTML/CSS site. Some simple admin panel where a user can change some content (add pictures) etc and then integrate in a PHP-file, like a include or something
If there is a way you can forego PHP/MySQL in favor of Jekyll, [Github Pages](https://pages.github.com/) has great free static hosting. 
Huh? That code outputs: Array ( [όνομα] =&gt; name [γενέθλια] =&gt; dob ) What's your point? It just does strtolower on the key. EDIT: Apparently other people find it useful as well: [github](https://github.com/search?utf8=%E2%9C%93&amp;q=array_change_key_case+language%3APHP+extension%3Aphp&amp;type=Code&amp;ref=advsearch&amp;l=PHP)
Internet hate against PHP make want to move to asp.net. Is like we are the clown in the programming world. 
Thanks for the tip - I'll give it a go this evening. I also think I found a bug or two in your php-ast extension, as well as a couple of potential improvements relating to the generated AST. I'll drop you an email about it in a bit :)
Yeah, for the life of me I could not find that button last night.... and now there it is clear as day :|
Do good work. Please your clients. Make cool shit. Everything else is just politics and people with bad attitudes.
I'm not saying all APIs are perfect, but what you just posted here as an example is a perfect example of bad design. The resource was not found, and instead of returning a `NOT FOUND` code (that exists for this EXACT reason), he responded with `OK` and a `null` response. Most APIs I've worked with used proper HTTP response codes. Of course, there are always some that respond with HTTP 200 no matter what (TOTVS RM), even if the response payload is an error message with the full stacktrace for an exception.
What kind of system are you running it on? 
I never had a problem with large nested arrays and json_encode. If you need to use objects, make them implement [jsonserializable](http://php.net/manual/en/class.jsonserializable.php).
Please take this advice. I think most php developers go through a phase where they want to build their own CMS (for their own selfish reasons). And thats OK; I think it's a great exercise for a developer to go through. The world does not need another CMS especially one thats poorly written and insecure. Please do not let this discourage you. Please go to https://phpmentoring.org/ and reach out to them.
&amp;#3232;_&amp;#3232; ###&amp;#3232;_&amp;#3232; #&amp;#3232;_&amp;#3232; .... I'm a fucking idiot because: 1) The idea to search for a REST bundle never occurred to me and I'm pretty sure I've read about FOSRestBundle before 2) The idea to build a simple abstract controller never occurred to me either which sounds just perfect. Thanks! 
Have you take a look on WordPress already ? Should be the best i think, but never used a cms system before =)
&gt; This should suffice I hope: https://bitbucket.org/nikhil_jain/complete-wowpictures.link-source/ I get that using Bitbucket instead of GH comes down to personal preference, but from my experience, particularly in the last couple of years, the first thing a prospective technical employer will do is look for your GH profile, even more so than LinkedIn or some other social media site. I'd strongly consider at least mirroring your repos on GH even if you do the majority of your work on Bitbucket.
&gt; Local development houses would require in house freelancers. Not necessarily: having someone be physically co-located costs resources a lot of companies are not willing to spend on a "mere" contractor. Notwithstanding local development, there's also opportunities for people working in countries that an employer may not be equipped to handle as full-time employee (e.g. they don't have a physical presence in that country) and will only hire as a remote contractor.
I would suggest upgrading your RAM to at least 8GB if you are going to have chrome and phpstorm running at the same time.
&gt; I would love to see some comparison with Sentinel's roles / permissions. I just recently started a big app and for the first time I need something more flexible than simple roles. &gt; &gt; Basically if I was using this new authorization thing I would need to manually create a basic role system for my users (around the authentication layer) just for the macro authorization (e.g. admin panel where an user with the admin role can do anything) and for the rest of the pages I would use these new features that allow granularity? &gt; &gt; Also since this isn't saving individual permissions to the database it means you can't easily make the changes directly on your website? Or you end it up re-implementing Sentinel's functionalities. &gt; 
What's insane? I run Xubutnu on a Thinkpad with 4gb of ram and can run chrome, phpstorm and a few vms simultaneously with no issue
So if my app uses umask 0 but is hosted on my dedicated server (with only me having the access via ssh) there is nothing to worry about?
http://laravel.com/docs/5.1/releases#laravel-5.1.11
it didnt read like that in his explanation ... his reasoning seemed to be "its because there are people who know 0 php" 
var_dump($cookie_alert) and var_dump($cookie). Compare the differences.
Laravel does not follow SemVer and for good reason. SemVer doesn't give you any leeway between major refactoring required to upgrade and minor. So if i change a class name and all it takes for you to upgrade is to do a find/replace it doesn't differentiate between that and if I did a framework rewrite. That first number changing scares the shit out of people and reduces the likelihood they will upgrade. IMO SemVer should have 4 numbers: MAJOR_BREAK.MINOR_BREAK.NEW_FUNCTIONALITY.BUG_FIXES
Disable any plugins you don't use.
Have to agree w/ /u/applechuck, but I love the style (template) though. 
4GB? You should be using at least 12GB now a days.
Not entirely sure exactly what point you're trying to make with that article.
The critics look at old PHP 4 stuff and use that as a basis for bashing PHP. Look at php 7 and the direction with the community we are headed and it shows that PHP is getting a lot better and is on par with ruby/python.
You're not running windows.
Right but for laravel the second number historically has meant a small BC break like i was talking about. So in this case where it broke nothing the third number was incremented.
Incidentally, there's also a Laravel 5 provider for Gatekeeper (disclaimer, I'm the author): [https://github.com/psecio/gatekeeper/tree/master/src/Psecio/Gatekeeper/Provider/Laravel5](https://github.com/psecio/gatekeeper/tree/master/src/Psecio/Gatekeeper/Provider/Laravel5)
A class rename may not have been the best example but I'm sure you got my point in general. SemVer has no way to say "hey there is a BC break here but it will only take you 5 min" vs "time to rewrite everything". To me the first number should correlate to changes in design philosophies/major rewrites/etc and the second should be BC breaks for code cleanup/speed/etc. Third for new code that is BC, fourth for bug fixes.
Also, make him check the plugins he uses for known vulnerabilities. WP has a lot of unsafe plugins that can open his system for attackers.
&gt; A class rename may not have been the best example but I'm sure you got my point in general. I get your point in general, but it doesn't help that Taylor used the same example in specific (class renames) and that he also actually does it with Laravel (I distinctly remember lots of minor updates changing silly little things like class names, interface names, minor changes in method signatures etc.). &gt; SemVer has no way to say "hey there is a BC break here but it will only take you 5 min" vs "time to rewrite everything". Ok, great, and Taylor's way also has no way of saying it, because Taylor doesn't know my project and he doesn't know if it'll take me 0 min, 5 min or 2 days. Because those 5 min don't depend just on what Laravel has changed, they also depend on how I use Laravel, which components I'm using, and what my project scope is. This is why SemVer is useful, because it carries relatively objective information, which Taylor's versions don't. Here's what SemVer says: 1. Patch version bump: no need to check the CHANGE LOG, unless you're curious or bored. 2. Minor version bump: no need to check the CHANGE LOG, but run full tests, as we added new stuff. 3. Major version bump: read carefully the CHANGE LOG and prepare to change some of your code. Here's what TaylorVer says: 1. Patch version bump: read carefully the CHANGE LOG and prepare to change some of your code. 2. Minor version bump: read carefully the CHANGE LOG and prepare to change some of your code. 3. Major version bump: read carefully the CHANGE LOG and prepare to change some of your code. I mean seriously, Laravel might as well use timestamps for versions, because the version means absolutely nothing without reading the actual changes one by one. If we assume a responsible schedule for a project, we can expect at most 4 major versions a year for SemVer (more typically 1 or less). So I need to sit down and read CHANGE LOG and go over my entire codebase up to 4 times a year. And for Laravel I need to do it *every time there's a new version never mind its scope*. It's not saving me time, it's wasting my time.
Exactly. If a hacker does compromise you, and you need to audit what files have been added (at least the ones the hackers didn't delete after use), Git will show you a list of the untracked files. After you've been compromised, the only guaranteed safe solution is to blow it all away, but knowing what may have been done on your server makes damage control easier. I'm guessing your friend's IP has been blacklisted by most mailservers by now (you can check at http://mxtoolbox.com/blacklists.aspx).
Except changing classnames can be extremely helpful sometimes when you find that the community is confused by the original. For instance Commands just got changed to Jobs in one of the last point releases because of just this. People were confusing Queue commands with the Command/Handler architecture patterns. Changing the class to Job made it instantly more familiar to people. Also I personally haven't seen a patch release in laravel break BC since before version 4.0 (besides bugs obviously). Thats three years of Major/Minor only BC which are always documented very well. You can't keep faulting someone for past mistakes which they corrected years ago.
This is a terrible excuse for the versioning that Laravel/Taylor currently uses. I have no idea if theres a BC break in 5.1.11, but my guess is (due to the history of laravel), there probably is.
&gt; Except changing classnames can be extremely helpful sometimes when you find that the community is confused by the original. Except I didn't say "don't change it ever", I said "keep it for the next major version". Additionally, there are B.C. ways of renaming a class, if you keep the old one around as an alias.
Maybe not in a patch release, but a BC break is not a minor release. It requires me changing code. EDIT: /u/CliffEdgeOrg pointed some out
&gt; Again, when the first number changing is scary to people you can only change it every year or two. &gt; Thats a long time to wait for something that is confusing to a lot of people and putting a damper on the growth of the community. That's Monty Python logic: customers don't like dead parrots, so don't tell them their parrot is dead. People don't fear *the number*, they fear *breaking changes*. If you will potentially have breaking changes in every release, you've fixed nothing to stop scaring your users. A responsible handling of a popular public project requires you hold up on incompatible changes and have a predictable schedule. You *don't* need to wait 1-2 years, that's nonsense. Laravel has a LTS version, so it can *easily* follow SemVer and release up to 4 major versions a year if needed. Those who are scared will stick to LTS.
I use X10 Hosting. Their free services include a full LAMP stack, FTP, and no ads. There's modules for things like Wordpress and such too, if that's useful.
Yep, already installed ;)
This is a repost of the draft, but as it's not under discussion, it's worth posting again imo.
I still have trouble buying chrome and PHPstorm eating up 4 gigs of ram, regardless of underlying OS
Only if there's absolutely no other issues at play that could compromise your server. Statistically speaking, that's not the case. 
I respect and am grateful for his work, but sometimes it just seems like he does some things differently just to do it differently.
meh, it's a lot of extra work to keep up things like semantic versioning. I'm not saying it's not useful but depending on the level of help your getting how many features/bugs/requests you have up on your board I can see it being one of the things to say screw it. 
That RFC is highly controversial ;-) … Also, AFAIK, the original author isn't persuaded of that RFC anymore himself… so, I doubt that's going anywhere.
Just do something like myfunc(['param3' =&gt; 5, 'yes' =&gt; true]); Granted it doesn't work with built in functions, but if it's really important you can make some wrappers.
Ask [php-langspec](https://github.com/php/php-langspec) if they want it, or simply redirect to them.
SemVer is an optional standard - it's not the only project in the world that doesn't follow it. It would be *nice* if it did, but Taylor is under no compulsion to do so.
Are you using any preprocessors which create intermediate temp files? I know when authoring Ember apps using phpstorm via ember-cli, there are a crapload of intermediate files created....and these are recreated on every single file change if the development server is running. The IDE becomes locked in a never ending loop of rescanning the entire project (looks as though enough files change that it drops the entire index and reindexes from scratch)... Trick is to exclude the temp folders from scanning. options-&gt; search for "directories" -&gt; right click the folder you want to exclude and select "exclude". Then trash the local index and restart for good measure.
Some of the API and a lot of the concept appears to be inspired by the popular [elabs/pundit](https://github.com/elabs/pundit) ruby gem. If you like the idea of 'policies' as a method of dead simple authorization via PHP classes, my implementation of this at **[deefour/authorizer](https://github.com/deefour/authorizer)** might be of some interest.
Laravel is OK choice. I think it is best framework, even though it has some serious issues...
No, you said: &gt; sometimes it just seems like he does some things differently just to do it differently. As if to imply that **everybody** uses semver, except him. From a communication point of view I don't really see the problem. Anytime there is an upgrade which requires you to make code changes a migration guide is provided. I get that it could be done better, but I take issue with the implication from some on this sub that semver is somehow the law that everyone must follow...
What are the advantages of this over just using json_encode/json_decode on objects? It seems that there is a different namespace between multi-dimensional and flat arrays, but shouldn't that just be one function that determines it for you?
Yes. I stand by my point. He does not follow semver or any standard that provides context as to what changed. Im sorry if pointing that out upset you
That was a (wrong) assumption about available folder permissions more than anything else. Mistakes were made.
Yeah, I do shop floor control applications for clients. I find it way more interesting than typical web dev stuff. Plus it lets me make use of all of that manufacturing experience from my younger days.
Well I'm of the opinion that a project used by so many people should follow certain standards, especially good ones, like semver or many of the php-fig ones. I dont think he is right in not using semver and I think his versioning system -if he has one, at all- is flawed and detrimental.
&gt; the sentiments of the internals list When you say "the internals list", do you actually mean one guy?
I feel PHP based ERPs are going to dominate the market for next decade. ERP is still a niche market for PHP developers and there are only couple of decent ERPs (inoERP is a great product and quite an alternate for Oracle...Dollibarr is also nice.Simple but good enough for small industries). There is a huge difference between developing/working on an ERP and a CMS application. You can learn PHP from the beginning and work in a CMS within 1-2 months of serious effort. If you pick a product like inoERP then you can spend 6 months and still feel you dont understand even 20-30% of it's functionalities. 
You might want to sign him up for a monitoring/scanning service like Sitelock. A lot of them have free tiers, even if you don't use their (somewhat expensive) cleaning services, it can still let you know right away when something's amiss.
I disagree but for the same same reason you agree. The current closure syntax is way too verbose and harms readability. A simple statement is bloated to two the size at least. All that extra syntax adds nothing. I typically work in C# which also has short and long closure syntax and nobody bothers with the long form anymore. 
I agree. I use ronan-gloo's but the general deadness of both repos makes me want to not use jade. An actively maintained version of JadePHP would be absolutely splendid. 
Well that will never happen as there will be no PHP 6 ;)
Fair enough. That's a rational position to take. Incidentally I think his reasoning for his version largely comes down to marketing (he likes the "big bang" releases) - and this is important *to him* and his project, even if it doesn't seem particularly helpful for those on the receiving end. Like i said, it could be done better. But there is nothing mandating he must *or even should* adopt any standard whatsoever. There are plenty of projects which don't use semver... or stick on sub 1.0 releases indefinitely for the express purposes of remaining in the zone where you are allowed to break whatever you want, whenever you want while still being able to claim "Hey, we're semver!".. 
Do you have the name of the two books?
While that is your opinion, I seem to find it easier to read. But I also use Hack and ES6, so I'm pretty familiar with the short syntax.
No.
Awesome work
The "long" form won't disappear in PHP, as it's not "real" Closures, but just binding variables by value. You still need a way to share by reference (recursive Closures come to mind ;-)). But yes, simple statements and partial application are the two strong points of the RFC. For everything else, the classical form is just fine too, I think.
hes a diva, somewhat talented, but unrefined. I cant get behind this project even if great for amateurs. y le downboats?
I apologize if I may sound a bit harsh, but I have a somewhat strong opinion on this topic. Thank you for the RFC and work on creating the patch and related work to get it going. "Binding by value" is a bit of a nonsense statement, isn't it? Either they're bound, or copied, semantically. Here they're copied, which destroys a lot of use cases for those short closures. I remember there being discussions about this here before, and the conclusion was we need to either truly bind variables from the environment, or at least allow a way to specify "pass by reference". How can I do this without true binding: $results = []; $collection-&gt;each($item ~&gt; $results[] = $item * 2); A closure should in essence act like an inline code block that you can assign to a variable and call on demand. The syntax that you lift from other closure implementations intentionally blends into the surrounding code, because it has to feel mentally and work practically like it's inline with the other code. Which includes: when I modify a variable inside the closure, it modifies it outside the closure as well. Otherwise it's plain confusing and a lot less useful. I don't know. I want short syntax for closure, I want it *a lot*, but if we'll just add syntax without doing it right, I'd rather spell out my intent with the full syntax and not have a crippled short syntax that works in a confusing way. Either do it right, or don't do it IMHO.
&gt; I'm not asking this to start an argument, because in my head, it's going to sound aggressive and very "fanboy". Nope, that's a good question and I'm glad someone brought it up. &gt; But, my impression of semver was that you can ADD features to the Z of an X.Y.Z dot notation versioned program, as long as you don't disrupt the existing API in place. Adding to it is fine, as long as you can use it in EXACTLY the same way as you did in the previous Z version. It's like this: - Z is for patching minor issues, like bugs. Typically Z releases modify a few lines of code, even just one. - Y is if you add new features or do major internal refactoring (while keeping B.C.) - X is for any changes where you break B.C. (not only, but also including if you rewrite the API completely) You can check the description on semver.org it's relatively short. I agree in an ideal world it'd be R.X.Y.Z, where we have "R" for major API rewrites. But in practice we don't need this much, because we have two situations only: 1. The library is not popular, which means you can make very sharp moves (like rewrites) from X version to another. 2. The library is very popular, which means you should not completely change everything from release to release, or you'll lose your audience. Change management is an art form. It's very possible to want to completely rewrite your library, and have that as a goal that you achieve after *several major version* releases, making the change more palatable for your users, by bringing them along for the journey, instead of making sharp and confusing moves. It requires discipline to do it this way, but that's part of being popular and serving users, versus doing.... whatever.
&gt; Except I didn't say "don't change it ever", I said "keep it for the next major version". I think you have a valid point that that would be the proper SemVer way to do it, but in reality it would have sucked if we had to keep using the badly named class and all the confusion it caused for another 2 years until there was a major release. I'm glad he just fixed it in the next minor release. Yes it's a "breaking change", but it's also a tiny one that's an easy fix. I've just gotten used to the idea that when it comes to Laravel, minor releases may fix things that cause minor "breaking changes". It's not SemVer, but it works well for most of us and I think it's worth the trade-off.
&gt; I think you have a valid point that that would be the proper SemVer way to do it, but in reality it would have sucked if we had to keep using the badly named class and all the confusion it caused for another 2 years until there was a major release. I'm glad he just fixed it in the next minor release. Yes it's a "breaking change", but it's also a tiny one that's an easy fix. I don't know why I have to repeat myself, but I will: 1. There's absolutely nothing forcing people to wait 2 years before a major release. Numbers are free. 2. Changing the number isn't scary, breaking B.C. is scary. Keeping the number and breaking B.C. fixes nothing. 3. You can rename a class without breaking B.C. through aliases. And I'll add one more: why were there no sufficiently public alpha/beta/r.c. releases where a confusing class name or anything other like this would be caught? Is this how you think it's responsible to handle things? Just release it as stable and let the stupid users figure out the problems, then we break B.C. in next release? Things like that don't happen with a well thought-out release process, and this is not a demonstration of a well-thought release process. It's just Taylor doing whatever, and using arbitrary numbers to hide his behavior.
&gt; But then how do you know when there really is a major release? Bump the version number up by 10? I really don't feel like repeating myself anymore, but please read my other comments in this thread where I've spelled out the answer to this and the rest you say. Search for the one containing "change management".
Thanks Taylor, it was a sincere question on the topic of SRP, I was kind of surprised to see it. What if happenes if an application doesn't do user management? Is $request-&gt;user null?
All ACL checks will return false. I think that's noted in the documentation if I remember correctly.
Yeah, that's definitely interesting. Well, that explains why I've never truly been able to 'at a glance' read the exploits I've seen on here. Of course, it all makes perfect sense - keep your targets from knowing what you're up to for as long as possible. Thanks for the clarification :)
&gt; $user-&gt;can(...) seems like breaking single class responsibility here. It seems like asking the user object what a user can do would be a reasonable thing for the use object to handle. Even if it did actually break single class responsibility, we should keep in mind that Martin's SOLID principles aren't absolute laws, they're just guidelines that are useful in some situations, and not useful in others. If you want to be strict about that kind of design, you probably would rather be using a data mapper rather than Laravel's active record models anyway. &gt; checking authorizes from controllers seems like a conflict with form requests for me. Not all controllers use form requests, there are other actions that we also need to check for authorization. The controller can be an appropriate place to check for validation, or for other design patterns you may choose to check somewhere else in the code. You aren't forced to do it at the controller level, but that is a common place to do it.
Sweet thanks, I've been meaning to do like a weekend hackathon w/ Laravel, just been super busy. Does Eloquent have a way to build schemas from an existing db? Even just the basics and I can setup relations after they repositories are generated. We have an old legacy app at work that we've thought about putting on Laravel instead but the db has some 1000 tables and that would be extremely laborus if we had to generate all the schemas and repos buy hand/ artisan.
Yes real business applications are always interesting and engrossing compared to typical IT works. It's not that IT Engineers can’t learn and became good business consultants but most of them don’t put the effort. Now a days, all big companies (IBM, Oracle, SAP, etc ) are making different career paths . If you are coming from an Engineering/IT back ground then join the Technical stream (or Software Development). If you are from MBA background then you’ll join the function (or Consulting stream). So it's quite difficult to get the experience and knowledge to move from Software/development to Consulting/Functional area. The problem in working in your entire life as a technical guru, you 'll never understand how you are impacting the real business. Career wise also, it’s quite difficult to move up in the lader only with technical skills. 
This is great advice
I don't understand the rationale of introducing a "not real closure" version of the short closure syntax, when there's an opportunity to do it right.
Yep... that's what we do around here :(
Yes, I agree it's tough to start and get going but if you put time &amp; effort you can LEARN &amp; EARN a lot 
[removed]
[removed]
[removed]
What makes you say that? Symfony is ran extremely well in my opinion, [the league](https://thephpleague.com/) sets a rather high standard, and a lot of the smaller libraries out there are managed quite well.
Of course, the benefit of it being incorporated into 5.1 is that it falls under LTS.
named params need like a new syntax `myfunc($a, $b, {'param3' =&gt; 5, 'yes' =&gt; true})` or something
- You cannot json encode / decode objects...unless they implement JsonSerializable interface, which needs to be done manually on every class. So certainly there's a use for this. - ArrayTransformer and FlatArrayTransformer share the same namespace, *NilPortugues\Serializer\Transformer* - No, it should not be determined by one function, they are 2 different use cases and one class should handle only one use case, so 2 classes are needed.
I'm offering an alternative, that works now. I also don't think that's a viable implementation of named parameters.
The part about symbol choice.. It says `==&gt;` can be mistaken with array `=&gt;` but.. For me `~&gt;` can be easily mistaken with object `-&gt;`. I know we have PSR which forbids spaces around `-&gt;` but they may happen - `$item ~&gt; $item * 2` and `$item -&gt; $item * 2` can be confusing. Also `~` is hard to write on windows as it requires pressing spacebar.
It would help if you stated exactly what you're looking for, your current HR, and a little about your team (or yourself). E.g. We're currently a team of 3. We live all over, but have HipChat setup for communication. We're looking for people who are comfortable with Symfony and OOP/MVC (intermediate and up), know AngularJS, and love open source. While we have specific requirements, we promote team members to pitch new ideas. ^ Something along those lines will help get your message across :).
I would love this addition very much but I have a remark. In the keyboards layout of many countries the tilde symbol is not present. Of course you can always bind shortcuts and whatever but a more standard symbol/pattern (like ==&gt;) would be so much better.
thanks, will update now
Have you looked at Google Analytics?
[removed]
&gt; Can you please define "we" so we know who's trying to speak for the entire PHP community? &gt; I never said I was speaking for the entire community. When I said we, I mean a few other internals developers who've been talking about and working out ideas on this particular subject for a few years... &gt; Also, may I ask where you're getting this "90%+" number from? I program in Node.JS a lot, where this way of using a closure (i.e. updating a variable from a parent scope) is essential, and exceedingly common. It's completely not essential. Look at other programming languages that don't even have mutability yet still do this exact thing (like Haskell). So it's most definitely not necessary. As far as being helpful, it's definitely debatable. But rather than go off, I guess we should just agree to disagree here.
[removed]
Yea good idea. I'm thinking I'll need way more than 3 columns. id, page_id, impression_count, link_url, link_click_count, timestamp, referrer and probably a few others. If I insert all that info into the database on every page load, I would imagine I would then need a tracking.php file to update information in the database before redirecting. I'm new at this so I have no idea if that's the totally wrong approach
&gt; See? no one cares! he he... I posted this on a Monday night; I wasn't expecting an immediate response from the community. If people are going to respond, they will respond today. Probably after their second cup of coffee during the slow period immediately after their morning scrum. &gt; You better take your efforts to some other platforms... Why? 5/6 websites run PHP. If I can: * Increase the good:bad advice ratio * Promote the adoption of a superior cryptography library * And get feedback so I can improve my writing ...it's a win-win for everyone involved, except the haters. Frankly, people who insist that "PHP can never be secure" motivate me to find and fix more problems. **Out of spite!** My reasoning is that, even if they were correct at one point in time about PHP being less secure than $other_lanaguage, working to make PHP better will eventually make them wrong. Being spiteful towards these remarks might seem immature, but I feel that it turns a negative (unfunny internet trolls) into a positive (safer websites, lowered incidence or impact of data breaches). "Hmm, make the ecosystem that powers over 80% of the Internet cleaner and more secure, or be a dumb hipster about everything." TL;DR - NO U
with jquery create a click event listener on all "a" (links) and when a click is happen, you inject a track.gif?url=something&amp;other=data this track.gif is actually a track.php (with mod_rewrite) with $_GET parameters
The decisions made at the beginning of a project have long consequences. Code is easy to change. File structure, project setup and such can be quite hard. Setting up a new project takes some time. It sounds like you are in the stage where you are knowledgeable about many things, but not others. It's part of learning but setting up new projects does take some time. It's a good investment to get it right. To work around your specifically referenced issue: Make a small library then use it another of your own projects. Then you see both how it is created and consumed.
Not in the core, but it really seems like I've seen a package to do that at some point.
&gt; It's just disrespectful. Someone saying that they disagree with you but don't want to argue any more isn't disrespectful. &gt; "Binding by value" is a bit of a nonsense statement, isn't it? See, saying someone else is talking nonsense is how you go about being properly disrespectful. 
You are of course entitled to your opinion, but I'm not interested in hearing it.
I see no willingness to discuss any of the points raised by me or the others here. /u/ircmaxell cited eyebrow-raising numbers with no source, gave objectively irrelevant examples like Haskell, then dropped the mike and quit. You don't engage in any debate at all, except for a couple of sarcastic or personal remarks, including the one I'm replying to. Honestly, what was the purpose of this thread? Next time instead of posting here only expecting to hear praise and cheers, just keep it private and bicker about it on the internals mailing list. They're all great guys, friendly and reasonable.
[removed]
Neither of those are readable.
I'll just tell this story (I'm sure you know most of it but anyway): When JavaScript was initially specified, it had closures from the start, but they had some semantics wrong, such as what is "this" within a closure (the parent scope this, or the object that hosts the method). Like PHP, the original syntax for closures is a verbose "function () { .... }". So, when ECMAScript came around to introducing a short syntax for closures, [arrow functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions), they also had the chance to improve on the closure semantics so it'd fit better what people expect and need out of it. So while the full syntax resolves "this" to the object owner, the arrow functions resolve it to the parent scope this. This is what a short closure syntax can be for PHP. A chance to get closures right. Is it more work? Yes. But it's also more value. If you define a short closure syntax for PHP and you go the easy way by literally making it a "save a few chars" thing, then that's it. We'll have short closure syntax defined and locked forever in PHP and for B.C. reasons we'll never be able to redefine it. So, my overall point is. Closures are increasingly important in imperative languages and people find more and more uses for them every day, even beyond what functional languages do with them. So if the work of getting it right is too much, or there are technical hurdles at this stage, it's best to wait. Implementing this poorly will do more damage than help. It'd be best to at least have PHP's options open for getting it right, once an opportunity arises. 
As I wrote before, that it didn't happen was for implementation reasons in the first place. I sure could have passed everything by reference, but that has it's own semantics (e.g. when reassigning a reference, it won't be propagated to parent scope), which might be even more counter-intuitive. Also, for the 90%+ number, look at PHP code using Closures and tell me how often (except of passing the variable holding the Closure itself for recursion) variables are used by reference.
You could write a PHP wrapper for Hubot. You'd have to json-encode the robot object and pass-through all API calls in wrapper methods. Otherwise, learn Node
[removed]
Nope, this is polish layout which is similar to us international.
Wait… are you proposing Closures to inherit the $this of their _called scope_?! Don't know, but that sounds unlike the most usages of Closures I personally have encountered... (Sure, sometimes you need that (Closure rebinding), but rarely?) I'm not convinced these technical hurdles will be resolved in the next five years. That issue is bound to the very fundamental VM structures; even PHP 7 didn't really touch them...
I often pass things in by reference in closures, or I wouldn't say it, would I? As for implementation, I feel you think in terms of linking variables instead of stack frames. Conceptually a closure has the same stack frame as its parent function or method. So it might be worth exploring this option: the ability for a closure to be instantiated with a link to its parent's stack frame, instead of binding specific variables. I can foresee some issues with name conflicts in arguments, but this can be resolved by remapping names, and forbidding extract/eval/var vars within short closures. Who uses that anyway, I bet it'll be deprecated as a whole at some point, just like it is in Hack (var vars also have big negative implications for JIT performance when PHP comes around to having JIT).
Well if you're familiar with SQL this is a pretty trivial challenge. In short what you're looking for is a SQL JOIN statement. Something like: SELECT fish.name FROM species INNER JOIN fish ON species.type_id = fish.id https://dev.mysql.com/doc/refman/5.0/en/join.html
I see two different things here. Learning programming and choosing a framework for development projects. Your programming skills should be such that choosing a framework is a formality and your choice of framework depends on your project and your taste. If you do want to use a framework that doesn't have to do too much for you I can vouch for Yii. One of the things I like about it is that you don't have to do any certain thing in a set way. You can use Yii features or not while working with the framework.
&gt; Yea definitely, but I want to start making my own simple projects like this just so I can get better at programming. I'm also a little bit neurotic where I want to understand how something works, haha He literally just said it.
There's also Phabricator as alternative to Atlassian. (http://phabricator.org/)
There was a time, when i was writing chatbot for XMPP chats. You can find it [on github](https://github.com/kadet1090/xpbot), talking implementation is [here](https://github.com/kadet1090/xpbot/blob/master/Plugins/Ai/Lib/Chatter.php). It's simple implementation based on markov chains but can be super funny. Oh and code is little bit cancerous. 
You can't paid for the hosting, but maybe you can contact some provider that is willing to throw some free basic hosting for your class. The guys of /u/RamNode are really cool :P
- validation (to catch mistakes/typo, as you said) - autocompletion (we can expect IDEs to catch up on the feature) - slightly simpler syntax (few characters less isn't much, but when it's a soup of `['']` it definitely helps) I guess same reasons some ORMs ship with query builders using method chaining (and not arrays).
Thanks to your help, I got it to work with this: SELECT Phylo_SP.Species FROM Phylo_SP INNER JOIN Species_Traits_ST ON Phylo_SP.SP_ID = Species_Traits_ST.SP_ID Problem is, it generated another table. I tried going to insert more data in the Species_Traits_ST and it still shows all the items as ID's rather than Species.
I do agree that function composition in PHP is a bit less readable than it could be. Something like: $items = chain( map($el ~&gt; $el-&gt;getStuff()), filter() )($collection); Would be better. Even with current closures that would be better: $items = chain( map(function ($el) { return $el-&gt;getStuff();}), filter() )($collection); 
That's fair since I never use functional programming nor do I think PHP really needs those features. I personally prefer a proper object oriented approach and possible anonymous classes over more of this %^&amp;*()#(*@#@(*) any day of the week. $collection-&gt;filter(new Filter(){/* ... */});
MVC is a pattern for UI and CQRS is a pattern for backend services. CQRS can be thought of as a way of architecting the M in your MVC. There's really zero overlap between those, and you can't really move on from one to the other. &gt; There seems to be some debate (what a surprise) between proponents of CQRS over whether or not it requires the use of different models for writing and reading data. There is no debate. CQS means separating at the API layer. CQRS means having a Read model and Write model, which are distinct. The "R" stands for "Responsibility". You can't have responsibility separation if it's the same model. The article suggests moving business logic from controllers to the models, and designing model API according to CQS. That's a very good thing, but it's not CQRS by a long shot. In fact, it's more MVC than it was before.
&gt;ADR Which has literally nothing to do with what we're discussing. Again, just with MVC there's zero overlap between the two. 
Let's just say it isn't the best, and there are "better" alternatives. It depends on how you look at it, if you look from a performance view... yea php is quite bad. If you look from a community view PHP has the largest.
I wish it provided the source for UserCommandService and UserQueryService, specially when it comes to handling input. The original controller used Input::all() which I suppose isn't recommend on classes other than controllers.
I agree that the tilde symbol is not uncommon at all and configuring your pc with some shortcuts is a must in case your keyboard is funny. But I can guarantee you that using a language that requires characters you don't have on your keyboard is very off putting (hello backtick). If it's not strictly necessary to use symbols that generate these problem, don't use them.
The beauty of the functional version is that it works with any kind of iterable. That's pretty amazing. Each datatype doesn't have to reimplement `filter`, `map`, `reduce`, etc – all it needs to do is implement `Traversable`.
This seems to advocate for reading HTTP data inside of the command bus, which is **definitely** not proper separation of concerns.
full quote... &gt;"Many forms of Government have been tried, and will be tried in this world of sin and woe. No one pretends that democracy is perfect or all-wise. Indeed, it has been said that democracy is the worst form of Government except all those others that have been tried from time to time." –Winston Churchill and seems relevant.. almost &gt;"Success is stumbling from failure to failure with no loss of enthusiasm." –Winston Churchill
I don't think it is the worst. Performance wise sure isn't the best but also isn't the worst. As far as picking up a language to learn.. probably one of the best the community support is amazing. 
A while back I was working on my wedding website and wanted to do something similar as I was getting a bunch of spam on a comment field and wanted to know where it was coming from and what path they were taking to get to my comment field. The solution I came up with was an include that tracked IP address, date/time, page viewed, and http referrer. While this solution was far from perfect, it was definitely practical. I got some great information about where my traffic was coming from, the IP's used, and was able to trace a route through to my comments page by tracking that particular IP and referring pages in a date/time range.
It's true in the same sense that English is one of the worst actual languages. Both English and PHP are: * Hodge-podges taken from other languages. * Internally inconsistent. * Considered very impure by people who would prefer to use something that was *designed properly* (whatever that means). * People who use them don't even try to defend them against criticism. And yet, somehow, English is the language used internationally by business; PHP runs 80% of the worlds websites. For both of them they must be doing enough things right to overcome their known flaws.....so I wouldn't say that PHP is a bad language, it's just that PHP is bad in obvious ways (which people can point to) and good in subtle ways, whereas most other languages are good in obvious ways, and then bad in subtle ways. 
&gt; I always try to write code that's easy to read and understand instead of short and simple. Fair enough, although I'd argue that the above example is both short and easy to understand, provided you are familiar with the very common `filter` and `map` idioms.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/programming] [ShitPHPProgrammersSay: PHP is good in subtle ways. Flawless /r/php logic.](https://np.reddit.com/r/programming/comments/3j8akz/shitphpprogrammerssay_php_is_good_in_subtle_ways/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I spot globals all over the place. Take the advice from /u/mathewpeterson and for the love of god, don't use globals. Also, check out www.phptherightway.com
You pass input as an argument to the service's methods. In the article there's a suspicious lack of arguments, which may mean the author screwed up.
This is what I'm most interested in. I'm accustomed to placing tracking pixels on thank you pages and always wondered how a .gif file could possibly ping a server and update a database. So that gif file is just run as a php file? Can you link me to more information on how to set something like this up? Because then I could track sales too, which is my ultimate goal. 
I agree with the OP on this one; it's a terrible design. Using arrays for function extendability is terrible design. Hey /u/ircmaxell, here is a good place for [named parameters](https://www.reddit.com/r/PHP/comments/3j4p3u/rfc_short_closures_for_71/cumt7tu). But they really should have just created a new function for this: safe_unserialize(string $value, [array $class_list]); 
Reading the HTTP data from within the command bus is the convention that Jeffrey Way's Command Bus brought into Laravel. If you want the command bus to be delivery-agnostic and truly SRP, pass in the HTTP data from the controller with a DTO.
when doing this, you don't actually link to an image, you link to a php script, that at the end will output an image.