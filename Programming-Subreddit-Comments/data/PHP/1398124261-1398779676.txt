This is really more of a sql question... http://sqlfiddle.com/#!2/3953a0/5 Basically use a group and a having clause, if you're using MySQL. This basically joins the songs table to itself with a restriction on how many related rows there are over the past X seconds where the row id has gone up (e.g. distinct) but the artist id is the same. In the example, using the 300 as the time and 5 as the count, that would filter out any songs where the same artist_id has been posted more than 4 times in the last 5 minutes (300 seconds). Play with the numbers and the data, check it out. Disclaimer, I am not a SQL expert, this could be terrible.
I can't wait for full PostgreSQL support.
Thanks for your reply! The package in my first post is classified as an "MVC framework" by its devs, do you think that will be sufficient to use to build a web app? Or does that not qualify as a framework?
This is barely about PHP...
It does qualify as a framework, but it's very barebones. A framework like Laravel is what I would consider to be full-featured as it comes with quite a few libraries and things meant to make development not only faster, but easier and better. For instance, Laravel comes with an ORM to make database interactions a breeze. This framework you're currently using just uses PHP's built-in PDO class which requires you to hand code all of your SQL. For someone starting out, an ORM will be incredibly useful and that's just one benefit of using something with more features. You can build an application using the framework you've chosen, but it will require you to do more work to use. It follows a different philosophy than something like Laravel. Laravel gives you as many tools and pre-built components as possible (within reason) so that you can build a functioning application as quickly as possible. Whereas your framework is more focused on solving one particular problem and letting you do everything else yourself however you see fit, thereby giving you more control over every aspect.
I worked for EA doing game design for $95k for a while living near their Playa Vista campus, and when they shut down the studio I moved back home. I'm now taking home MORE net pay making $30k less. LA is one expensive mother of a city :( That's why if I could get to even low 6 figures where I currently live (and there are 6 figure jobs in my area, just few and far between), I would be living like a king.
For your OS you want to use Vagrant - and therefore be able to setup a development environment that closely (or identically) resemembes your production server (which is usually linux). http://code.tutsplus.com/tutorials/vagrant-what-why-and-how--net-26500
Vagrant, Ubuntu inside. PHPStorm and sometimes Vim. Host machine home - Mac OS, work - Ubuntu.
- Ubuntu 14.04LTS - PHP/MariaDB (PHP compiled from source, but you can skip that) - Sublime Text 3 beta 
&gt; reactphp &gt; ratchet oh sweet
Why Do so Many developers Use linux? Is it still not normal to Use Windows? Now in the beginning I would prefer a simple But workable solution 
Do you also recommend using Laravel? 
Just to be Sure, why Do People say "in the production environment" instead of "on The Web server". Have I missed something or over-simplified? 
Probably with private git repos
For larger sites, there is more than 1 server. There can be servers using the application code, hosting portions of the data-set (it could be multiple database servers), multiple caching servers, etc. The pool of all of those that are for your example.com are your production environment.
Do you know of any good videos that explain The typical architecture for larger sites? Or What should I google? I doubt My website will make it Big though. 
You cannot detect or block when clients (or their extensions) are manipulating POST / GET values or other HTTP headers. In short, you can't trust any data that comes from the client - besides extensions such as livehttpheader there are plenty of other methods of submitting custom crafted HTTP requests such as curl. This is why you must check / validate / sanitize all incoming data.
According to the standard you need to specify for each vendor namespace the subdirectory in the vendor directory that is used. NB: The standard could have relied on the directory matching the vendor namespace, but it does not. So if you want to use the GuzzleHttp vendor namespace you have to manually tell the loader where that resides. This allows for more flexible directory structures. For instance, this allows the Guzzle package to have a "src" directory holding the classes.
to clarify, Vagrant isn't an OS!
I am on Win 7, PHPStorm, running hand built VM's inside VMWare Workstation. At home, I have switched to Ubuntu Gnome, PHPStorm, and VM's on Vagrant. Over the Easter weekend I made the switch on my office PC to Ubuntu Gnome... and this morning have had no end of trouble, so am back to Windows again. Frustrating. If you can get a Linux desktop working, you can be so much more productive - native shell with tmux, vagrant works a lot easier, PyCharm runs without any messing, PHPStorm setup is a breeze... life is better in Linux, when the bugger works. 
* Kubuntu 13.10 (will upgrade to 14.04 soon) * Apache 2.2 and PHP 5.4 manually compiled/installed, as I need to match production and the repo versions are newer * MySQL 5.5 * Sublime Text 3 * git (CLI) I have a Bash script that will automatically git clone a project, configure vhosts, create a Sublime project and even add it to my Sublime history so I can switch to it easily. I can go from having no code on my machine to having my IDE ready and the site displayed in my browser in around 5 seconds. I have a Bash script which is a wrapper around grep and sets exclusions for files I'm not interested in (compiled templates and .git directory). I have keyboard shortcuts configured so I can launch programs with Win + some letter and close them with Win + X. I spend heaps of time in the terminal. I use it for managing git, using find and grep, and sometimes vi if I'm doing a minor change to a file. I'm no stranger to tools like strace, tcpdump and netcat if I need to do some hardcore troubleshooting.
Do you need to register in order to check an open source project? It would be great if you could put in a github repo and get a report.
https://www.google.com/search?q=php+captcha
Can someone explain to me how this gets upvotes? Is there a joke I don't understand?
There is a lot of antisemitism on Internet
There are many ways to get unique* user identifier, but nothing can stop 100% of them to start faking the results... - email and phone (this should be validated and written in a unique format) - ip (do not allow proxy-forwarded and no-referer users) - browser fingerprint (smth like https://github.com/Valve/fingerprintjs, but please be careful to avoid collisions) - evercookie like data (store some data in cookies, flash, local storage, etc) All of this should be parts of a bigger validation mechanism that will "vote" for the users ability to vote (smth like symfony security voters) =) For example if the uniqueness of the user is more than 90% - than just allow him to vote... 
Better topic would be "Checking file upload mime types" as that's the only thing it actually talks about.
thanks man
You can't get stuck if you stick to plain old PHP, if HHVM breaks, just switch back to the "old" interpreter, et voila.
My actual OS at work is Windows 7. The Linux I was referring to is the OS on the virtual machine I use, which is built to mirror my production server's environment.
I don't get it, are you complaining for the sake of it? Because nobody forces you to use HHVM, it's just a choice given to you, **and most of the time**, you can switch back and forth with minimal impact.
Set up an account with mandrill . Com and use the smtp-seti go they provide you with. 
WAMP is fine. I usually go with a bundle like xampp og easy php which installs it all in one go. 
Welcome to the learning curve :-) This will happen whatever system you use. Oh and look up a version control system like Git or something. You should be versioning your code so if you run into a problem (update and it all breaks) you can just go back to a working version.
No down vote, but it sounds to me like your setup needs some work more than the framework needing a change. Think for a moment, if your code is checked into a repo using GIT you can easily roll back code changes. If you are using composer to load packages then you can easily upgrade / downgrade packages if something goes wrong - namely specify the version. This said, I have not used laravel (more a zend guy) but pretty sure composer is available and version control is a must for anyone who is even mildly serious. Yes, frameworks may seem slow compared to knocking something together yourself but I guarantee you will be better off. The added security and pre built components are incredibly useful to name a few key things but more importantly you will improve yourself as a developer which i would not underestimate. A note on Yii, I use it in production in a work capacity, not a huge fan over other frameworks but if you need speed over features then it has it's uses.
You mean no one answers your questions in any of the framework communities?
Fulltime employee.
The best practice on doing this is to define a driver interface and determine the API you need for your app. Than implement connection (both interface and implementation) and then just add drivers to the factory- that will be reusable, decoupled, extensible and pretty much better that a simple function with a lot of logic. Trust me- you'll get your mind fu*ed after a several providers added and more usecases and reported bugs...
Try #laravel on IRC.
I would always sacrifice speed for code manageability, and you should too. Performance can be improved on many levels not just in your code.
You could also go with [Phalcon](http://phalconphp.com/en/) if you're looking for speed.
I am offline.
First point: Your site's down? Why on earth are you deploying untested changes to your production site? I'm not much of a fan of Laravel, but I have to say this mess sounds like your fault, not Laravel's. If you do development work in your production environment, this is what you get. Second point: If your site's down, the first thing you do is rollback the update. I understand wanting to use the latest code. But you aren't achieving that goal with a broken production site. You should rollback immediately, and update again once you've resolved the issues in a development environment.
I said I was fine sacrificing a little speed for maintainability.
I said I was fine sacrificing a little speed for maintainability.
This hurts to hear :( But I never used Sentry so I have no idea if it really is that bad. Overall I am very happy with Laravel (personal opinion). Did you read this? http://laravel.com/docs/upgrade#upgrade-4.1.26 There was a breaking change introduced in 4.1.26 you might not have seen.
I had followed those directions to the detail.
The update changed files throughout the framework. I've stripped my code down to bare-bone. I'm not going through every singe framework file and compare the changes.
I know this is a rant, but I just want to post this information here for anyone's benefit. If a DB table is getting hit multiple times per request it's because of Eloquent queries or relations being called in slightly different contexts. Say your app is checking for an authenticated user and is grabbing `Auth::user()` to load the user. That user's ID happens to be 5. Then you're viewing a profile for the same user (e.g. site.com/user/5) and then your controller calls `User::find(5)`. Well these are in fact two separate queries. `Auth::user()` might be getting called in the header to fetch the user's name to show that you're logged in, but then `User::find(5)` is being called in the controller. That will show up as two identical, but separate select queries. Or, you are accessing a user relation from some other object for the current user: `$Purchase-&gt;user-&gt;id` Well, calling `$Purchase-&gt;user` is a database hit because it's a separate context from either `Auth::user()` or `User::find(5)`. Now, if you called `$Purchase-&gt;user-&gt;id` and then `$Purchase-&gt;user-&gt;email`, then it won't hit the database twice, as the eloquent relation query gets cached. Concerning the forums, this is Laravel's biggest problem. It has thin documentation, and a generally inactive support community. I've been trying to convince my work to give me ~30 hours over the next few months to contribute to Laravel docs as I don't have much time to do it on my own. So many simple examples can be added just by skimming through the source code.
&gt; Laravel was/is my first ever PHP framework. Why lame? 
What you are saying about multiple database hits per page is exactly what I am seeing which is why I needed to create a singleton. However, I've not been able to figure out how to stop the throttle table being hit multiple times. I just find this unacceptable behavior and I've spent way too much time fixing a problem that I shouldn't have to. Is it considered OK for a framework to spam the database as many times as it wants? It's not OK in my book. But with the update breaking the framework there's not much I can do about it now. Thanks for sharing though.
Getting ignored in IRC is as common as getting ignored in the forum.
&gt; Concerning the forums, this is Laravel's biggest problem. It has thin documentation, and a generally inactive support community. This.
No, I was not talking about you directly. My statement was meant in a more general context.
Great! Glad to hear that. I always supported this "strategy" as I believe it is the only right one (and I'm also using it myself).
I agree and this is why I only use two extensions which I thought were community vetted - Sentinel and Ardent. This was one of the draws for me to Laravel - extensions and packages - but if I can't trust them... I think it may be better to just code that stuff myself.
I use Ctrl-P, with nerdTree and three plugins I wrote, Buffet plugin for buffer management. 'vawa' plugin to highlight all the occurance of the php variable under cursor and another unnamed plugin that lists all the functions in the current php file in a side window where I can click on function names to go to that location. I have also some plugins like vim sneak, tabular and multiple cursors plugin which I does not use much.
I think the reason I am enjoying Symfony is that it really feels like you’re developing your skills in the best possible way. Its incredibly verbose, but because its all best practice it feels like its worth the investment… and there is so much material on it. There has only been a handful of times where I couldnt find the answer to a question and usually it turned out to be me being retarded, or needing to ask Google the right question.
As suggested by /u/foo13 use captcha. Using IP to check unique could disadvantage people in an office or shared network with 1 exit IP. Phone numbers are the best way to ensure uniqueness. If a number is used already, reject the vote. When selecting winner, call the number. If inactive or invalid, pick another number.
I do not use plugins. But ctags with omnicomplete gives autocomplete and allows jumping to method and class definitions. C-x C-o for autocomplete. C-] for jumping. Relevant vim config: `syntax on filetype plugin on set omnifunc=syntaxcomplete#Complete` 
http://www.reactiongifs.com//wp-content/gallery/no/tracey-morgan-nope.gif
I use PHPStorm with the IdeaVim plugin. The latest build of IdeaVim fixes some long standing issues I've had with the plugin. It's not as nice as pure vim, but the IDE features of PHPStorm more than make up for that imo.
No
Most VIM users will try and use `ctags`, but its native support is a little rough. There's a great solution, though: [phpctags](https://github.com/vim-php/phpctags) As far as my plugins go: - [tagbar](https://github.com/majutsushi/tagbar) - because of course - [tagbar-phpctags.vim](https://github.com/vim-php/tagbar-phpctags.vim) - to go along with the `phpctags` and `tagbar` plugins - [vim-php-namespace](https://github.com/arnaud-lb/vim-php-namespace) - auto insert `use` statements - [Vim-PHP-Stuff](https://github.com/paulyg/Vim-PHP-Stuff) - Generic updates to VIM's PHP syntax handling - [PHP-Indenting-for-Vim](https://github.com/2072/PHP-Indenting-for-VIm) - Fixes the awkward auto indentation in VIM with newer PHP versions - [php-doc-modded](https://github.com/Rican7/php-doc-modded) - An updated version of PHP-Doc to work with the newer syntax of PHP 5.4+ - [phpcomplete.vim](https://github.com/shawncplus/phpcomplete.vim) - better omnicompletion of PHP with contextual suggestions And a ton more...: https://github.com/Rican7/dotfiles/tree/master/.vim/bundle
Is extermely slow though
Check out https://github.com/vim-php/phpctags Mind = blown
Why did you roll broken code to production? Why aren't you rolling back, and setting up a branch to work out the issues? I'm not gonna downvote, I understand that you're just venting, but it really just sounds like typical problems that have to be solved in the course of developing an application. There's no framework that can completely fulfill all of your application's needs with absolutely no fuss - there's always going to be some dark patches you'll have to claw through. It can be ugly and frustrating, especially when the docs/community don't have the answers, and I can respect the fact that you've been bending your brain trying to solve these problems. That shit sucks. I know you said no advice, and I won't pretend I know your situation or anything, but I'd probably recommend rolling the app back to a working state, and let your frustration levels drop a bit. Take some time away from the thing, get your brain cleared out, and then give it a fresh look after a couple of weeks; maybe shuffling to a new framework is indeed the right idea - but don't decide that in the heat of the moment. Good luck with it, whatever you end up doing! Hope you can work it out.
OS: Windows 7 IDE: PHPStorm Dev Environment: Openstack VM servers hosting Ubuntu Server 14.04 with a LAMP stack. Version Control: Git
&gt; PHP-Indenting-for-Vim[6] - Fixes the awkward auto indentation in VIM with newer PHP versions Will this correctly indent closures? I just tried and it is not working for me. 
PHPStorm or IdeaVim? I haven't used either yet but I plan to try PHPStorm
you also should try https://github.com/spf13/PIV
PHPStorm is of course much slower than plain vim. Whether the advantages of PHPStorm make up for the slowness is up to you to decide. You can test it free for 30 days, so no harm in trying!
yeah, the old forum was way better, every time I asked something there I got immediate answers. I think that it take some time to learn how to properly use a framework. It's very frustrating at the beginning. Trust me, I've felt that way with every framework that I've used (even rails). But when you reach certain level you're going to start to solve your problems faster and faster. So don't give up :)
Oh man, what do you get in return for these comments?
&gt; Why did you roll broken code to production? As the post says, it's not production. &gt; I know you said no advice, and I won't pretend I know your situation or anything, but I'd probably recommend rolling the app back to a working state, and let your frustration levels drop a bit. Take some time away from the thing, get your brain cleared out, and then give it a fresh look after a couple of weeks; maybe shuffling to a new framework is indeed the right idea - but don't decide that in the heat of the moment. I will take this into consideration.
Sorry figured it out. http://stackoverflow.com/questions/3059044/google-maps-js-api-v3-simple-multiple-marker-example
Oh goodness gracious I feel silly
This is what I'm considering at the moment but have not made a final decision yet. What do you use?
"Tell 'em what they win Bob!" "A full week's supply of Gartenion's Onion rings! Bronco's new Bondage-In-A-Bottle! It won't crack, it won't stink, it won't peel, it won't budge, it won't bite, it won't fade... And of course a brand new, absolutely brand new, new, new, and of course, but also a new car!" http://youtu.be/_-gICWP1Zuw?t=2m5s
since this is the wrong sub reddit after all i will just throw in coffeescript. if i can avoid it i will never again write plain javascript :)
As you are looking for alternatives have a look at http://auraphp.com/ . Lots of libraries, no magic, everything in PHP. Checkout v2 framework coming along from the components http://github.com/auraphp/Aura.Framework_Project , http://github.com/auraphp/Aura.Web_Project , http://github.com/auraphp/Aura.Cli_Project I don't say you go and jump start it, but it will help you really to learn the inner working of the framework, and if you need any different component as always can install via composer.
&gt; the old forum was way better It looks better. &gt; I think that it take some time to learn how to properly use a framework. It's very frustrating at the beginning. I am happy to learn things but having to bump my questions in the forum once a day because they get buried tends to make me want to look else ware.
And maximal bitching, apparently. 
Quit being a drama queen. What this is called is a difference in opinion. Something leftists never seem to understand...
Bundle 'scrooloose/syntastic' ... let g:syntastic_php_checkers = ['php'] And never again shall you have to wait until you load the page to find out that you had syntax errors. You need Vundle for this.
Post your questions to stackoverflow. The point of stackoverflow is that your problem might be encountered by someone else. Google does not index reddit or the laravel forums nearly as high as stackoverflow. Think of others and get your questions answered some place where the answers aren't so temporary like here on reddit or ignored like the laravel forums.
There's no real style guide for JS as it can be completely written multiple ways. My personal favorite is Google's. https://google-styleguide.googlecode.com/svn/trunk/javascriptguide.xml
&gt; dd($redirect_route); $redirect_route NULL The other issues can be summed up by my frustration of the same database tables called multiple times for one page request as described: http://www.reddit.com/r/laravel/comments/229w8p/how_do_i_reduce_the_number_of_queries/ http://www.reddit.com/r/laravel/comments/22iz6p/how_do_i_make_sentry_get_the_throttle_data_from/ And summed up in this thread here: http://www.reddit.com/r/PHP/comments/23ocgv/i_think_i_may_have_to_abandon_laravel/cgz0q49
Yeah, Laravel has a ton of answers on Stack as well.
#php should forward you to ##php
&gt; dd(Config::get('Sentinel')); Config::get(...) array (0) &gt; That problem seems to be specific to the libraries you're using, so you need to look at either extending that library or speak to the developers about it. Someone here suggested dumping the extensions and writing what I need by hand which is what it sounds like I need to do.
No, I'm not using the wildcard anywhere.
&gt; I recommend dropping ardent Thanks. I believe I will. Maybe Sentinel too.
That seems like a strange reason to reject a framework outright. The 'community' page on their site lists an IRC channel and links to the Google Group. What would you want to see there instead?
My point is OP is complaining about backwards-compatibility; and it's an issue that exists in any framework.
To the moon!
Best comment in the post. Well stated.
&gt; Hurrah! So there we have it, your problem is because there's a missing configuration value: post_login. Cool! &gt; Did you publish your configuration for the package? I don't know. All I did was run this: composer update --dev --prefer-dist I'm not publishing anywhere. This is just local development. Did I miss a step? 
My setup is almost same as `u/Rican7`'s except for autocompletion/code browsing I use [phpcomplete-extended](https://github.com/m2mdas/phpcomplete-extended) which I wrote(shameless plug :) ). Currently it works with `PSR-0` projects only. It has context aware code completion, goto definition of a method/class, built-in PHP core documentation so you can read documentation right inside vim, also shows method/class docs. I have also added more code navigation features such as [Unite.vim](https://github.com/Shougo/unite.vim) plugin for listing files in a project, lists child hierarchy of a class The plugin itself is extendible so framework specific autocompletion is also possible. Currently there are two extensions, [phpcomplete-extended-symfony](https://github.com/m2mdas/phpcomplete-extended-symfony) and [phpcomplete-extended-laravel](https://github.com/m2mdas/phpcomplete-extended-laravel). Both have framework specific enhancements. Checkout the demos of the plugins, * [Autocomplete demo](http://www.youtube.com/watch?v=yZYFKslqkC8) * [Unite sources demo](http://www.youtube.com/watch?v=Wd5G7QA3OFw) * [Symfony2 plugin demo](http://www.youtube.com/watch?v=4MkDlWryWbw) * [Laravel plugin demo](http://www.youtube.com/watch?v=UYMNjMH9TVE) 
Just a regular forum like phpbb or mybb. What Laravel calls a forum doesn't seem to work and I have never gotten an answer on IRC.
Yes: http://www.reddit.com/r/laravel/comments/23h9p1/ran_composer_update_and_now_getting_error/
Those tax dollars hard at work ._.
PHP specific: * scrooloose/syntastic * Valloric/MatchTagAlways * evidens/vim-twig * arnaud-lb/vim-php-namespace ( this one is really great) * stephpy/vim-php-cs-fixer * xsbeats/vim-blade * docteurklein/php-getter-setter.vim * sumpygump/php-documentor-vim
Long answer: you might not want to use multiple objects to refer to the same database connection, BUT many applications and probably yours will want to refer to **multiple different** database connections - for example a read-write master and a read-only slave connection. Or even a huge pool of connections if that's what it takes. So it's better to not use singletons and just properly inject a connection to the services that need one (or many).
As I mentioned in that thread, your errors are clearly with the Sentinel package. Laravel isn't always the answer, but you can't blame it for problems where the stacktrace points to another package you installed. **edit**: PM me if you'd like more 1 on 1 help trying to figure it out
Try PHPixie and see if it fits you better. There are no external components, everything is done in a simple and efficient manner and its dead easy to debug and modify.
Bahhhh! Why does every LINQ clone copy C#'s MethodNamingConvention?! Otherwise this looks great!
From your code, I can't really tell what it's trying to do. What are modules? Where does $files come from? What about layouts/wrappers? Why is View extending Model? Why exactly are you not using a templating engine? The major selling point behind a template engine is the template lookup and combination process. No reason to roll your own, just use Twig or Plates.
Don't want to come off as a smart-ass, but take my advice in consideration. 1. Shake the [NIH](http://en.wikipedia.org/wiki/Not_invented_here) off. 2. Use a well-documented template engine [1](http://twig.sensiolabs.org/) [2] (http://www.smarty.net/v3_overview). 3. Enjoy peace of mind knowing that your views rely on proven stable code used in production environments by many, many others. Good luck!
Going completely to just using Laravel for the lower level stuff is OK. However, do understand that just because some packages have quirks doesn't mean every other one has the same quirks. Using other people's packages is very useful. Especially if they follow semantic versioning so you know things won't outright break on an update. On the note of things being 'community vetted', you may not really get that. Laravel has become the most starred PHP project on Github. Its user-base is massive. One part of the community may not link the same kind of thing another part does. So it completely depends on whom and where you ask what kind of a response you get to different packages. One part of building SOLID applications is making them in such a way that you can swap out components on-the-fly without any major (if done right none at all) recoding of your application logic. However, this doesn't really protect you from things like Ardent. Finally, on the note of "trusting the packages". Don't trust a package, that is the wrong way to go about it. Do research into whomever develops it. See if you can trust them to know what they are doing and to be able to fix it if issues come up. Once you have established trust with the developer maintaining it, all you need to do is ask yourself if you like the packages API and abilities.
&gt;Concerning the forums, this is Laravel's biggest problem. It has thin documentation, and a generally inactive support community. I've been trying to convince my work to give me ~30 hours over the next few months to contribute to Laravel docs as I don't have much time to do it on my own. So many simple examples can be added just by skimming through the source code. This is what happens when you deal with a framework that's maintained by just one person. 
Sorry for the lack of comments. The modules ( modules called in English ) are just tiny piece that will hang in the left or right panes. $files comes from the controller. It's an array with the view files that the controller is needed for it's own. -View extending Model- That was just for some testing, but it isn't needed anymore... The reason i don't pick a template engine? Well, i must confess that i don't really have an "reason". It's just that i don't want to use an extra layer, so that i can use fancy tags, if I can do it without it. But then again, I must confess that i'm not really into this subject, so any advice would be great...
'inactive support community'. As I stated in my other reply, this depends on where you go. SO and IRC are both two highly active areas for getting support. The forums were once a decent place, but they've kinda fallen off here lately. Thin docs. Yes, this is absolutely an issue. However, where is the limit drawn? Doing proper and thorough documentation is rough. I see people every day asking questions that actually have nothing to do with Laravel, they are basic programming structures. But, they are using Laravel and it isn't pointed out in the docs. Rolling on that, how do you decide how far to go into usage? Do you begin to tell people exactly when to use what, where, and when? Because that ends up getting into a huge if this then that structure. Because it really depends most of the time on your goals and needs when to use things. Docs are a *really* tough thing to take on. I contribute to the Laravel docs as I can and I also work on [Web Platform Docs](http://www.webplatform.org). It is something people complain about, but it is a far more complicated thing to actually do well.
I'm sorry, if you want guaranteed attention pay for support. Otherwise, you kinda just need to take what you get. Other people are busy and have things to do, free support isn't always at the top of our list.
Well, i did expect this type of answer. I'll look at the links, but can you give me an answer to this question that i also asked /u/gearvOsh ? `The reason i don't pick a template engine? Well, i must confess that i don't really have an "reason". It's just that i don't want to use an extra layer, so that i can use fancy tags, if I can do it without it. But then again, I must confess that i'm not really into this subject, so any advice would be great...`
If you are using Sentry (which Sentinel you mentioned implements) then it isn't affected by that issue. So you could have actually made things worse by following those instructions. Please check with the package maintainer if you needed to do that, since it only applied if you were using Laravel's built in auth system.
PHP methods (and classes) are case insensitive anyways.
As far as getting *free* support for *free* code, it is always hit-and-miss.
Vagrant is a little daunting if you are just starting out. Check out https://puphpet.com for help.
Last I knew, it's not "invite only" but they do require that your IRC nickname be registered with nickserv
True, but your auto-complete probably isn't (nor should it be). People really ought to follow PHP's style guides for PHP libraries. Even if PHP itself doesn't…
This scratches an itch I wanted with RandomLib, so consider me and mine users :)
That's great! Please feedback anything whatsoever that you dislike whether about the implementation or the features and I will turn it around.
Well you can use Plates, which is a template engine but uses PHP for its templates, instead of introducing a new syntax.
I'm reasonably new to VIM but what helped immensely coming from SublimeText is Subvim. https://github.com/fatih/subvim
It has been invite only for a long time.
Based on the description: &gt; When a column ends in "_id" and the first part is a database table, the edit and create form automatically generates a select with the "name", "title", "username" or "email" column of this table. Also, on listings, that value is displayed instead of the "id". But since it's a one time generation, it doesn't update these over time. This also might be a problem if I run it on my table with over 10,000 items referred to with item_id...
~~Laravel is "maintained by one person" in the same sense that Linux is "maintained by one person" - that is to say, it isn't.~~ It has a benevolent dictator, who handles all merges, and ultimately decides what's "in" and what's "out" of the framework, ~~but he doesn't write every scrap of code by himself.~~ In fact, the model of having one person ruling an opensource project with an iron fist is widely considered "best practice". Compare with a "committee" based project like PHP itself - it is an absolute clusterfuck. The issue of *support* has very little to do with the framework having a benevolent dictator and more to do with the community that has surrounded the project. Laravel's support is actually pretty amazing. I had an issue yesterday. I set up a paste and jumped on IRC. This was outside of US/EU prime time as I am in Australia. Within 5 minutes I had 3 people jumping all over my problem, one of whom sat with it for a good 45 minutes until we had it solved. I've bought products with worse *paid* support than that. As for Thin documentation - maybe. But again, it certainly isn't the worst documentation of an opensource project I've ever seen. It is actually pretty good. Sure it doesn't show you how you should program, but that isn't the job of the documentation. It shows enough that if combined with a solid programming background you can build an app.. which sounds like mission accomplished for documentation to me?
Just curious. Why would you code in VIM when there are so many other great, and free, code editors out there. 
You're free to do whatever you find fun and exciting, like writing your own proprietary view engine or even a whole MVC framework, if that's what you want to do. The whole idea of learning to use popular existing libraries is that a. To save time b. To put a well-known item on your skills list (yup!) c. Most importantly, to write code that's as bug free as possible. In the beginning writing your own layer may seem easier, until you do need some fancy tag (that day *will* come) and suddenly you have to implement it yourself. Or when your implementation is buggy and costing time that you don't have to fix it in the middle of the night, then you'll pay the *debt* of not just having picked an off-the-shelf, debugged-by-others, proven solution.
Question to all: Should this be integrated with RandomLib? I talked with @kuizinas about it before, and am definitely open to it. Once I saw the implementation, I was slightly taken aback by the complexity required (not that it's implemented poorly, it's actually pretty clean). So my gut reaction is that it can live as a separate repo. What do you think though? Should it be a separate repository and package? Or should it all be merged into one?
I agree. I'm not blaming the framework. I'm not blaming anyone or anything. If anything I'm blaming myself for not being able to figure it out and needing a larger, more robust, and more active community. I appreciate the offer for help. I'm going to remove the extensions, do some cleanup and see where I am. Thanks.
Thank you for the advice. I will follow it.
Thanks.
The closures tell me that the evalation of the where and order clauses are being done completely in memory.. or am i missing something?
#
Hey, this fixed it! Thanks, man!
&gt; Is it considered OK for a framework to spam the database as many times as it wants? It's not OK in my book. It's a framework. It's not magic. If you call methods or properties that invoke a database query, it's going to do a database query. It's up to you to know what does what. Put something like this at the top of `routes.php` DB::listen(function($sql) { Log::info($sql); }); (remove for production) And keep an eye on what queries are being generated. If you think more queries than necessary are happening, then store the result in a variable, and use that rather than re-invoking things. If queries are happening in a loop, figure out how to prefetch the data using `-&gt;with()` or `-&gt;leftJoin`. It really sounds like all these issues you're having are due to misunderstandings, not problems with the framework. You would have these same problems without a framework too, you'd just be more aware of what's going on under the hood so you wouldn't fall into the same traps. You're going to have to invest some time to learn how things behave. I think you'll find that the amount of time you save by not re-inventing the wheel is a net positive even after you factor in all the research you have to do to understand how everything fits together. I recommend using PhpStorm and [ide-helper](https://github.com/barryvdh/laravel-ide-helper). This will help you find what methods are available, and you can ctrl-click through to the Laravel source code whenever documentation is lacking. Laracasts is also a pretty good resource if you have the patience to sit through videos.
I dont use linux, but i would presume that some servers do not have a X system on them, and the only editors installed with the bare bones OS are VI and Emacs or some other variation. I work on over 20 machines that have no X system on them and use EDT. I also have TPU but dont like it. 
/u/phpperson rejecting a framework for there is no hosted forum sounds a bad idea to me. You should join the group and ask if any of them have not got an answer or not. And if you are not fond of google groups why not ask in http://stackoverflow.com/ or github issues ? Everything will be answered I bet you for I am one among them who help there ;) .
Never saw it. Surprised that there is even the case about this string.
Many have recommended stackoverflow and I will try them. Thank you.
I wrote [ReverseRegex](https://github.com/icomefromthenet/ReverseRegex) last year to support simple string gen using regex like syntax. convert \(0[23478]\)9[0-9]{3}-[0-9]{4}' into a phone number like 02-986-5555.
Very interesting
Mother of god...
Thanks, Plates looks very promising. I'll play with it and see if i can put all the pieces together :D
Great article. Writing high quality reusable and maintainable code *is* easier than ever. Many of the most egregious inconsistencies have been fixed in the past few years. The language and the tools are more robust and performant than ever. And all despite the voluminous amounts of opinionated self-righteous BS that happens in any community of a reasonable size.
nice. I like it.
I'm interested in the auto-vhosts-config script, can you share it?
Php provides the functions serialize and deserialize which basically export objects to Strings and import them back again, in theory to make it easier to persist them between pages, etc. In practice this is a nonstandard format and many people prefer JSON, XML, whatever. But the magic of the PHP functions is that your whole object, including all current instance variables, etc, are automagically packed and unpacked for you. 
That's really strange. If array is empty why serialize and base64 encode it ? Sounds like excessive html in the output.
I don't know about this project, but a similar one (posted here a month ago) parsed the PHP code to be able to build SQL queries out of it.
There's a few separate scripts that get called by one single script. Here's the script that handles the vhost config: http://pastebin.com/g9XXABPt Here's the vhost template file (vhost.tpl): http://pastebin.com/H524SNM1 You'll need to set $WWW_DIR. I have this defined in my ~/.bashrc as I use it in multiple scripts, but you may want to set it directly in the script. My $WWW_DIR is "$HOME/www". Create /etc/sudoers.d/service with this content: yourusername ALL=(ALL) NOPASSWD: /usr/sbin/service You'll need to mkdir /etc/apache2/vhosts and make it writeable. If you configure NameVirtualHost *:443 and have a certificate/key configured in Apache's global config then all your vhosts should be accessible on SSL, though with a certificate warning. Lastly, I have a DNS wildcard record for *.localhost which resolves to 127.0.0.1.
You should not assert that scalar hinting *will* be supported in a future release, that is not certain, or even likely. 
I'm not disputing your points, but I will say that you've confused the roles of maintainers and contributors.
What are the numbers before the lines? If they're line numbers, why are they in reverse order?
&gt; 4 close votes Sometimes StackOverflow's moderation is so frustrating…
&gt; Memorize this: arrays = needle, haystack; strings = haystack, needle. Nope. * str_replace: needle, param, haystack * substr_replace: haystack, param, needle * strstr: hackstack, needle, param * array_walk: array, callback * array_map: callback, array * array_key_exists: needle, haystack * property_exists: haystack, needle
Isn't that how LINQ works? I'm not a C# dev, but I understand that LINQ is, long story short, a query language for variables, hence completely in memory as well.
Just keep the first two then. edit: the author seems to speak about array_* and str* functions in general and used a more restrictive example, that's why I listed all those.
Well those two examples _need_ three arguments. It's hard to be "haystack, needle" when you have 3 things, right? 
Laravel isn't making your site slow, it's your lack of experience. There's nothing wrong with lacking experience, as long as you're aware of it. I suggest you read up on various caching tools and techniques (like Varnish, Memcached, APC or PHP 5.5's opcache), work queues (like Beanstalkd, RabbitMQ), database optimizations (why indexing matters, why normal forms matter) etc. 
As a sibling comment said, you're confusing maintainers and contributors. And you're pulling things out of thin air. &gt; he doesn't write every scrap of code by himself This says otherwise: https://github.com/laravel/framework/graphs/contributors Taylor has almost 2,000 commits and the second most active contributor has 76. That means that at least 90% of the framework was written by one person.
The problem with the Laravel IRC is that they can answer easy questions but ignore anything that's a little more complicated. That said, the framework's code is nicely written. You can figure out pretty much anything by just browsing the code. 
Ha, gotcha. You can keep your first two examples then, but the rest don't make sense here. :)
Now we can use every bodies two favorite technologies together.
At least it's community moderation. If it gets closed, I'll certainly vote to re-open immediately. It's definitely on-topic for SO.
I still think they do, the original intent of the author was not to limit his generalization to search/replace functions, or so I believe.
I have been using phpctags (mostly for the sake of tagbar), but it seems like phpcomplete can't complete basic methods or static properties. It always says "Omni completion (^O^N^P) Pattern not found". Is there something else I have to do to make it work with phpctags?
Don't knock it if you haven't tried it.
There are parsing and AST transformations going on. Which seem to indicate that it's actually parsing the closure, and turning it into SQL (or in this case, a query builder syntax). 
relevant edits made. However, your link doesn't say "otherwise" - it supports the notion that he does not in fact write all the code. The % of lines is significantly higher than I thought it was though.
&gt; What are the numbers before the lines? If they're line numbers, why are they in reverse order? Perhaps that's 'relativenumber'? :h 'relativenumber'
NIce, didn't know about that, but it seems to be the case. Thanx!
Discussion in hacker news: https://news.ycombinator.com/item?id=7633254
https://eval.in/140293 Interesting. I just had to try it.
best discussion on the topic https://www.youtube.com/watch?v=KtHQGs3zFAM
While it is an improvement over ExpertSexChange, it is so frustrating to Google an issue, and arrive at a StackOverflow page that has been closed as a duplicate, better suited for X, off topic, or opinion based.
&gt; Ubuntu inside Why? You're not, or at least shouldn't, be using Ubuntu for your production server so why on Vagrant? Vagrant should match your production server.
I think we'd both agree on the statement: "Functions that only contain a haystack and a needle (not some other third required argument) are consistent based on their type, string or array." Trying to throw in replaces and callback related functions distracts from the point, that PHP genuinely is: "arrays = needle, haystack; strings = haystack, needle."
Merging pull requests may skew that a bit, but he's certainly the primary contributor. No doubting that.
Why not Ubuntu?
Unpopular Opinion: Be wary of Vagrant. It’s great in theory but can be troublesome to set up sometimes. Give it a go. If it works it can be great. I’ve also known lots of people that spent many hours trying to get it set up. Personally, I just have one pretty generic Ubuntu server VM. In my position I rarely have to deploy. I hand off the code base to the client and be done with it. One VM that I have tweaked here and there to fit my needs. One is not better than the other but I wanted to give a different perspective on all the Vagrant love in this thread.
yea, its the improved relative number handling in Vim 7.4
This is why we have autocomplete in our editors. It's completely a non-issue.
Lots of open source PHP out there, not all of them best practice. That being said: phpBB, WordPress, Joomla!, Drupal, MediaWiki. I suggest writing plugins/mods/extensions for the CMS systems. PHP should be used for any data processing or page construction, including reading the client's user agent to determine desktop or mobile. JavaScript should be used to adjust to client side elements such as user input, viewport size, but not whether or not on mobile. Javascript can also be used to display dynamic content. See JQuery for more advanced functions.
Many projects use Ubuntu in prod. What are you talking about?
Ah brilliant. Thanks for the heads-up. I'll play with it later and it could well become part of my standard arsenal :) Edit: Pinq is fantastic!
Didn't read much, but I guess basically man saying that TDD is shit, DDD is future. Kinda agree with this statement because I never was able to TDD my own projects in spare time and only DDD helped me to get what I want from mind and put it directly into code. Behat, Mink.
Check out http://phptherightway.com/ which has lots of best practices that apply across all kinds of problems.
Interesting. I love the functionality, but not so much the syntax. What about something like this? function foo() returns array { return array(1, 2, 3, 4); }
I said you shouldn't not what is.
It's not really an OS I believe is really worthy of using as a production server. I like it as a client OS.
It is an option but is considerably more verbose; I personally like concise and small syntax. Additionally, this isn't some syntax I pulled out of nowhere; it is used by Hack and I have no reason not to use it; it is concise and similar to the way functional languages declare their return types.
Of course he doesn't literally write every single line by himself, but I think the difference between 90% and 100% is not that significant. Effectively, Laravel is still pretty much a one man shop. 
It's an option we can have, see the references section ... that syntax is one that was decided suitable before, but when they decided that they overlooked that it requires adding the keyword "returns", immediately breaking any code that defines a "returns" function ... there is a 10 line patch attached in references section to have that syntax if it is deemed worth adding yet-another-keyword ...
That looks almost identical to (one of the syntaxes of) Perl 6: sub foo() returns Array { return [1, 2, 3, 4]; }
No worries, I totally understand that the syntax proposed is inspired by other languages. I do like the Java/C++ style too, which is almost as verbose as what I suggested. I really like the functionality but the only other place that I generally use a colon in PHP is doing ternary or the old "::" scope resolution thing. I know it's a symbol that will be familiar to many, it just feels (IMO) a bit foreign to PHP in this context, that's all.
This is a great resource, thanks for sharing. By the way, their navigation is awesome.
That's not at all what it says.
Did you hear about Ubuntu Server? I dunno, upstart is useful, apt-get is nice.
For a site that uses Laravel, check out https://github.com/CodepadME/laravel-tricks. 
What happens when your database goes down? Yes, not if, when. I would be very hesitant to store something so basic and essential to site functionality as URL redirects in the DB. At the very least, output all redirects to a .json file or similar and then check against that in a production setting. Defensive programming will save you lots of headaches down the line.
It's common just to include it when bootstrapping the application, [here](https://github.com/laravel/laravel/blob/master/bootstrap/autoload.php#L17) is how Laravel does it.
I can see that approach working if you route all traffic thru index.php, but otherwise? This particular experiment is an old one that has multiple .php pages (no MVC framework). Is the .htaccess trick my best option here?
This is really good, everyone should watch this.
I have found that TDD has a place in what I would like to call CDD or contract driven development. This where a system is very specifically spec'd out with a client down to the finest detail and that any variation needs to go through a rigorous change request protocol. Then TDD tests can be written that exactly match each of the contracted bits of functionality. Then when all the tests pass you are done and the client can't sue you even if you have delivered a huge steaming pile of excrement. Then you get into these absurd situations where you have conversations like, "Oh you wanted the users to be able to print the reports? Well you should have mentioned that and we would have put it into the original spec. Now it will cost you 20x as much to implement that as part of maintenance." 
I agree with /u/ircmaxell here. It's not the best option because it's hidden magic. It sucks, but I'd say put it in every page.
I'd be asking yourself it's possible to refactor the site into something driven by some form of routing layer. You don't *need* to rewrite the entire site, there are a lot of smaller routing packages (I love [klein](https://github.com/chriso/klein.php)) that could be effectively used to introduce routing without needing to go full MVC. If you're still working on the site (so much so that you're introducing new packages) you're probably just making it more difficult for yourself in the future by trying to keep the site as it is while still advancing it.
Yep! I'm actually in the process of rewriting it using Laravel (first time using Laravel, too!). I was looking for a temporary solution, I guess. Thanks
&gt; What are some recommendations for an Oauth2 extension / library for php? [PHPoAuthLib](https://github.com/Lusitanian/PHPoAuthLib) has been highly recommended, but I have no experience with it myself. &gt; PECL extensions PECL extensions need to be compiled and installed, something that *most* shared hosting providers don't support... and the ones that do support it are insane. Don't assume that you can ever require a user to install a PECL extension. Avoid them unless you *know* that they're running their own servers or *you* are the one doing the hosting.
[This discussion](http://www.reddit.com/r/PHP/comments/1mpek8/do_you_want_to_cover_your_legacy_code_with/ccbq57z) is probably relevant.
I do not own a car, therefore it is impossible for me to ever own a car.
My god... First impression - you did a lot of work! I'll try using auto complete with VIM tomorrow, but anyway thank you for your good work!
Why not just replace the keyword "function"? Like so: public array foo() { return []; }
Yes. My bad. Also this doesn't really mean anything now (I mean my post), because I really did not fully read article when posted an answer.
Are you referring to the same kind of tests? TDD is more than unit tests - it's acceptance tests (user stories), functional / integration tests, unit tests etc... What /u/EmperorOfCanada is referring to seems to be acceptance tests with regards to the user stories the client agrees to. Maybe several QA functional tests might compose one client acceptance test, while dozens of developer unit tests might compose one functional test. (also note that there is a parallel of separation of concerns between code and test types: a project manager, QA, or client shouldn't have knowledge of, or care about, the developer unit tests. A unit test test delivers no measurable business value. Meanwhile, a functional or acceptance test is something the PM or QA would care about. The PM can't sign off on delivery until the functional &amp; acceptance tests for the business value they are delivering, pass). While you may not know the final design of your code up front, you SHOULD have knowledge of some target that is bigger than code units. Make the client give you a target if you don't have one.
2 mySQL instances in separate DC's performing Active/Active synchronisation, so I'm covered. But thanks for the concern, it's much appreciated.
Adding a separate composer dependency just for a few exceptions seems unnecessary. You'll find that many composer based projects generally create project specific exceptions: &gt; \PHPPixie\Router\RuntimeException extends \RuntimeException and then more specific exceptions: &gt; \PHPPixie\Router\RouteNotFoundException extends \PHPPixie\Router\RuntimeException or something like that. 
The point was that if you're someone who remembers today, there's no problem, if you're someone who has to use the manual today then is anything really going to change because we have changed the order of parameters for a few functions, it would certainly break a lot of code ... There is just nothing to gain from changing anything at this point ... this is not a real problem at all ;)
See [Differences from Past RFCs](https://wiki.php.net/rfc/returntypehinting#differences_from_past_rfcs).
So here's possibly the most important question: *why* do you need to inherit from `\Exception`? Is there something inherently interesting about exceptions from PHPixie that I would ever actually write `catch (\PHPixie\Exception $e)` instead? If not, then just throw \Exception instead. Subclassing is for when you can do something specific about an exception.
This reply contains a succinct yet thourough explanation without perceivable bias regarding choice of technique. Good on you. Gold star. 
Great choice of name too, can't believe it hasn't been used before in sOme similar context. 
Do what I did- start with Wordpress and Smashing Wordpress, then just kinda go. If you're on windows- install xampp and all that, or if on linux/mac- get your environment setup as you need. Then just go. There are few other jobs besides cooking and web design/devlelopment that you can learn from thousands of recipe books. Make some shitty websites, its fine. You're going to suck for awhile, just remember that if you do what I just said- when you look back six months from now you'll be able to say "man I sucked *back then*"
bumping this in addition to my other comment.
Normal form Only matters in a relational database. Storing serialized objects, you've kind of left the building. See: ORD. 
If it's closed as a duplicate, then there's already a good answer - you just need to follow the link.
What does PHPixie\Exception indicate? I'm hard pressed to imagine a case where I want to catch all exceptions from a framework (and all its components) but no other exception. 
Since PHP is a dynamically-typed language, you don't ever declare variables without defining them - the variable is just a name that happens to be attached to a data structure in memory. $emptyArray = [];
There's a fundamental difference between `ConnectionException` (which I can do something about--like requeue the action to be tried again later) and any arbitrary framework exception (which I likely just want to show an "oops" page and notify me somehow).
this guy is a moron, the end. downvote me to oblivion. 
If you want to make you libraries interchangeable, you shouldn't really have a base exception class to begin with. In fact, I'd say a framework-wide exception is a code smell. Shouldn't your code have some general idea of what (non-generic) exceptions it should be catching when it's utilizing a specific component?
True! But my point was that extending exceptions a good practice is. Having a custom catch-all exception? Not so much indeed...
&gt; building a complex system A complex system should be comprised of several simple systems. The simple systems then can be tested much simpler.
So, I ask what you will do when something catastrophic happens, and your reply is: don't worry about it, that won't happen? Good luck with that attitude.
Well its still going to be a partof of a framework. So catching a \PHPixie\Exception would catch all of the framework exceptions. Looks pretty convenient to me.
Have you looked at Mustache before? It's a spec, so a mustache template may be rendered and any language that implements the spec, including PHP. It's also by far the most simple templating engine from a syntax point of view.
But than you get some unrelated \PHPixie\RouterException and \PHPixie\DatabaseException . I don't see much of a benefit of relating them to a single parent, but I kind of got used to that (hence why I started the topic)
I'm guessing some sort of XML parsing would be needed, perhaps maybe something like SimpleXML might solve your problem. You'd want to get at the content, then iterate through it only allowing text and ``a`` nodes. Personally, I find splitting at line breaks (``&lt;br /&gt;``) easier to do.
Once the user changes the state, create a javascript event to fetch the towns for the state. Otherwise you could just make it, when the user selects the state, you post onto the same page but then towns will have a state to load from. Theres multiple ways to go around this. I'd go with loading via ajax just for usability (less full page loads).
Thanks. I'm going to try and muddle through an ajax solution. I'm just not very good with java.
skrawg is right with the XML parsing, please don't use regular expressions as well :) http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags/1732454#1732454
Insight: // javascript $(document).ready(function(){ $("#state_id").change(function(){ $.ajax({ async: false, url: "getTowns.php?state_id=" + $(this).val(), method: "GET", success: function(data) { $.each(data.towns, function(index, town){ $("#town_id").append("&lt;option value='" + town.id + "'&gt;" + town.name + "&lt;/option&gt;"); }); }, error: function(data) { //handle your error } }); }); }); // getTowns.php &lt;?php header("Content-type: application/json"); if(isset($_GET["state_id"]) &amp;&amp; strlen($_GET["state_id"]) &gt; 0) { $db = new PDO("mysql:host=localhost;dbname=yourDatabase;charset=utf8", "username", "password"); $result = $db-&gt;prepare("SELECT id, name FROM database.towns WHERE state_id = :state_id"); $result-&gt;bindParam(":state_id", $_GET["state_id"], PDO::PARAM_STR); $result-&gt;execute(); echo json_encode( ($result-&gt;rowCount() &gt; 0 ? $result-&gt;fetchAll(PDO::FETCH_CLASS, "stdClass") : array()) ); } else { echo json_encode(array()); }
I wasn't knocking anything. I use vim quite often when doing admin work on servers. In fact vim is one of the first things I install. I was just curious why people would use it for things like PHP for anything beyond a single edit. 
Wow, thank you!
Extending exceptions is exactly like extending anything else: best used in moderation. In the case of `ConnectionException`, it adds value--I can handle a connection failure by doing something specific. It's "actionable". But a general, framework-level exception? Not so much at all.
What makes a framework exception any different from any other exception that I would want to catch *just* framework exceptions? What am I going to do with the framework exception, other than log it and display an oops page to the user?
Try == instead of = in your if statements
"==="
"==="
Thank you very much McGlockenshire! I'll stay away from looking at PECL extensions. with regards to installing a library, do i just need to have the folder in my plugin resources and it's all god to use from that point on server side?
Please God no - my head just exploded. Please steer clear of Access!
&gt; It shows enough that if combined with a solid programming background you can build an app.. which sounds like mission accomplished for documentation to me? No, there are in fact completely absent references to public APIs or API behaviors that could stand to be enumerated by the documentation. To the framework's credit, it has been architected well enough that I was able to guess at a few pieces of functionality that behaved exactly as expected, which was oddly surprising and unsurprising at the same time. Thus the framework is pretty damn intuitive to use. Still, no reason why the documentation couldn't provide a few more examples or at least explain a few things for you.
True, SO is active but SO's (frankly silly) policy regarding "opinion questions" makes it difficult to seek *guidance* where there isn't necessarily one objective, concrete answer.
This looks quite amazing, but to be quite honest (and I may not be seeing the bigger picture, so correct me if I'm wrong), I don't see any application of this outside of vim. I'm using IntelliJ with the PHP plugin, what does this give me that IntelliJ doesn't?
Frames works like Rails are awful to unit test for. Logic is either in the controller or in the database with a thin model layer. You end up testing the whole stack which is hard to debug, slow to run and slow to develop for. You end up concluding that TDD is wrong. 
&gt; I don't see any application of this outside of vim.. I assume you are referring to the auto completion feature. The vim layer is very thin one that just send the file path and location of the cursor to the Cliche's code via its interface to execute shell command. It also parses the json encoded string returned from Cliche to build the completion list. So you will be able to get the same auto completion features for any editor that can call a shell command and fetch and process the results (via a plugin probably). &gt; I'm using IntelliJ with the PHP plugin, what does this give me that IntelliJ doesn't? This is a different approach by which the majority of processing to provide these features is offloaded to external tool that runs the same environment as the code being edited. So this can use the introspection features of php like the Reflection api in place of static analysis, if it was to be done from a different language. And when it is time for static analysis, it can use the Php's tokenizer so that it does not have to 'deal with the language specification at the lexical level. ' I guess this makes the tool have simpler implementation, and can provide more powerful features. I am not saying that it does currently, but this approach has the potential to do so. It may also help the editor stay light weight and let it do what it is supposed to do best, which is to edit the text. As for specific features, I will need your help to compare this with Intellij. 1. When you create a new class, how do you make sure you are putting the class in the correct path as expected by the auto loader? If you use Cliche, it will make sure that the class file is placed in the same directory as expected by the autoloader and also fills in the correct namespace and Classname. When you use the class in your code, the namespace auto completion make sure that the class name is actually resolvable in the context of the file you are currently working on. So the class file creation and the namespace auto complete feature can work together to make sure you will never encounter 'Class not found' type errors... 2. How do check if you objects have cyclic dependencies? 3. For auto completion, does Intellij plugin has some kind of access to Php's language features like Reflection API or Tokenizer? 
That's quite an interesting approach. As far as I'm aware IntelliJ does only do static checking, but for me this has always been more than enough *if* you document your code properly (namely PhpDoc and type hinting). This is the case for most of the libraries I use so static checking has been sufficient for me. I'll admit that using PHP's reflections sounds somewhat more sophisticated and more accurate, however, that does mean it has to execute the code you need to get the type hint from does it not? If not, again, static checking to me sounds more than enough, because the only advantage I see of using reflection is the fact that it can resolve magic methods, which I've learned to stay away from (the hard way). To answer your questions: 1. IntelliJ has a project browser window ([screenshot](http://i.imgur.com/M0D7IcL.png)). Then it's mostly key shortcuts for me (bear in mind these are IntelliJ's default shortcuts).I just find out where I need to put the class (`Ctrl+Shfit+N` and type the namespace I want to be) &gt; then `Alt + Ins` &gt; PHP Class &gt; Type the class name. IntelliJ automatically fills in the namespace for me which it bases on PSR0 with PSR4 support is in the current EAP (see [screenshot](http://i.imgur.com/KkLeE6E.png)). You can set the classes root, but I think it also takes `composer.json` into account if you set it up. 2. I've only come across this once, while I was working with Doctrine's [DependentFixtureInterface](https://github.com/doctrine/data-fixtures#dependentfixtureinterface). I was rewriting a bunch of fixtures to make them easier. I couldn't set up the dependencies until I finished redoing all the fixtures, which in turn meant I couldn't run the fixtures until I finished rewriting them all. This lead to several cycles. I wrote a simple script that works with Doctrine's `DependantFixtureInterface` and echo's out all the dependencies (which of course leads to infinite dependencies), you stop execution of the script and find the pattern of the output and fix accordingly. So your tool will be used in the future should it be needed. 3. As I said before, from what I know it uses static checking, but it does take into account type hinting and only shows you what the variable contains or the method returns (i.e. exactly what your tool does). I'm not trying to knock your tool, I think it's actually quite impressive and I can see some applications, but I don't see it replacing my current workflow. I can imagine this will be loved and warmly welcomed by people who don't use IDEs.
Are you talking about a backend that talks to another backend via REST calls?
that didn't clarify anything. Give us an example of a "app native to a browser" and give us an example of an "app driven by an API". All angular, ember, backbone, etc apps are both native to a browser that are also "driven by an API". 
You still need to know the big picture if you want to avoid code duplication with regard to similar functionality between those simple systems. You cannot tunnel vision several simple systems, just like you cannot tunnel vision units. Keeping your eye on the big picture to understand the communication between those simple systems is vital. It's all fine and dandy to write unit tests for what will be a well encapsulated, very focused class. *But whether you even need a class that provides that functionality at all* is something that should at least be considered at an architecture level before you write a single unit test. Diving right into unit tests without any sense of the big picture is an absurd approach to writing code.
Have a look into this application https://github.com/beberlei/githubpr_to_jira . There are lots I can link to github. If you find it useful start creating and learning your self. If you looking for PHP specific ones do check http://github.com/auraphp/ and the different libraries to see how it is made standalone without keeping dependencies.
A use case on your site would be extremely useful. I'm not sure what this does by looking at the site. I use grunt as a task runner, what does this do in the php world?
Those GIFs were way too long for my impatient self. This seems really promising, though. Could this be extended to generate a list of problems like undefined method calls?
Please don't advertise closed source products here. 
But once again: what good does that do you? Will you route that exception differently? Attempt to recover from it in a different way? If not, then don't bother creating a different exception class, because that's the primary purpose of doing so: routing the exception to a different handler. Also, he's creating a base exception that all other framework exceptions inherit from. So, he's doing exactly what you recommend not doing.
No its not, TDD is pretty much just about unit tests. Acceptance testing is something totally different and functional / integration tests come latter.
&gt; Those GIFs were way too long for my impatient self. I am really sorry. I know I should have added a narration, instead of typing out my comments. But I am not a native English speaker, (I am from India), and I was worried that people may have trouble understanding me. I spent nearly two days trying different options for adding videos. Gifs were found to be the best option but I had to add some crappy JS to make the play, restart buttons Thank you for trying to watch my lame presentation... &gt;Could this be extended to generate a list of problems like undefined method calls? Yes, it can be done. One just need to throw an exception to notify that a method is not found in the routine for inferring the return type of a method. Now it just returns null silently, after catching the \ReflectionException caused by the \ReflectionClass::getMethod() call.. 
I think you could optimise this by building the string in the foreach loop, adding continue; in the for each to prevent unnecessary if statements and I think in most cases while(strpos($content, ' ') !== false) {$content=str_replace(' ', ' ',$content);} will out perform your regex
Do you mean native PHP versus an MVC framework or something? I'm also confused.
&gt; As far as I'm aware IntelliJ does only do static checking, but for me this has always been more than enough if you document your code properly (namely PhpDoc and type hinting). I agree. I am just trying a different approach. You are correct that the file you are working on should not contain syntax errors for this to work. Here are some details. 1. When you invoke the auto completion, the VIM plugin saves the contents to a temporary file, and sends the real file path, temporary file path and byte offset of the cursor in buffer to cliches auto completion command. 2. Cliche loads the autoloaders for your project using the real file path. Then it adds a bit of autoloading code over the current autoloaders , so that if the autoloading is called on the file user is working on, it is created using the temporary file, but with the current statement commented. So if this is the state of your file on disk. class abc { public function getName(User $user) { $my_user = $user; } } and this is the state of the contents of the buffer when you invoke autocompletion class abc { public function getName(User $user) { $my_user = $user $same_user = $my_user; $same_user-&gt; } } This will be what php sees of the file when it is reqired to load class abc class abc { public function getName(User $user) { $my_user = $user $same_user = $my_user; /*$same_user-&gt;*/ } } &gt; I just find out where I need to put the class... First of all, Thank you for the screen shots. I think you still need to find out where to put the class, right? If you use Cliche, it will invoke the actual autoloader used by your project (by default it is 'vendor/autoload.php'. But you can configure any number of bootstrap files) and make it load the class your are attempting create, and monitors the include calls it make. If there is more than one location that the autoload is looking for the class file, then you are provided with those path, and you can just select the one which you want. You only type the classname once. If the sub-directories leading to the path does not exist (if there is a typo), then it will inform you that and then you can rerun the command with --force option and all the required sub-directories will be created and a skeletal class file will be placed in the proper location. Because this works by monitoring the actual autoloader, the class file Cliche makes is guaranteed to be found by the autoloader in a live context. &gt; I've only come across this once, while I was working with Doctrine's DependentFixtureInterface[3] .. Although I have worked with Doctrine, I have not come across Fixtures yet. Looking at github page you linked, I think the dependency involved here is a bit different, right? The dependency problem that Cliche warns you about are the dependencies that an object requires to be instantiated, which is usually the required parameters for its constructor. And this can only work with containers that load the objects using pure php, using new statements like pimple. It cannot, at the moment work with XML or non-php configurable dependency injection containers. &gt; I'm not trying to knock your tool, I think it's actually quite impressive and I can see some applications, but I don't see it replacing my current workflow. I can this will be loved and warmly welcomed by people who don't use IDEs. Actually, Thank you for your great feedback. And I don't imagine it replacing anything, but I see it as one more tool to save you from manually doing stuff that can be automated. 
Sorry, was typing in a hurry, let me give an overview of my infrastructure for web hosting: **SQL:** * Two servers, each in a separate DC, each configured as a master in two way replication. * Should either server fail the other will continue seamlessly. * Transaction logs are backed up hourly so should database corruption occur, the worst case scenario is up to 1 hours data loss **Web:** * Same two servers, configured as master / secondary * One way, real time file replication from master to secondary of all shared web data * Should the master server fail DNS will be manually flipped to secondary **DNS:** * CloudFlare Pro for CDN, Cacheing, etc * Direct DNS entries configured to bypass CloudFlare for testing individual servers * All traffic directed through CloudFlare caches to master web server * Should failure of server occur, DNS settings with CloudFlare are on a 1 second TTL so manual flip to secondary server takes effect instantly **Failsafe:** * All data has an incremental backup to my home on a nightly basis So hopefully you see that my attitude isn't "don't worry about it, that won't happen", but instead, "don't worry about it, I have taken every precaution available to ensure that won't happen".
Please don't upvote this. This is pornography. It is immoral. **EDIT (Two Weeks Later)**: I'm deleting my account because I change accounts every few months. This doesn't mean that I am withdrawing this comment. I was right. All of you were wrong. God will punish all of you.
Subbed to /r/watchpeopledie
brave little warrior
Can you please see if this works? This one uses a recursive function.. $string = &lt;&lt;&lt;EOB There &lt;a href="http://some.url.com/page" target="_blank"&gt;is a&lt;/a&gt; consistent &lt;a href="http://some.url.com/page" target="_blank"&gt;message on Russian state&lt;/a&gt; media concerning the situation in &lt;a href="http://some.url.com/page" target="_blank"&gt;Ukraine&lt;/a&gt;. The revolving 'crisis in Ukraine' bug on state news channel Rossiya 24 sums it up. It shows the players on the ground on loop. Unmasked, kindly looking pro-Russian separatists against the background of the orange and black ribbon of St. George ubiquitous symbol of pro-Russian sentiment and of Soviet military glory; masked, authoritarian-looking Ukrainian state security against the national flag; and finally a balaclava-clad ultra-nationalist against the red and black flag of Ukraine's Pravvy Sektor (Right Sector) party -- the ultimate bogeyman of the conflict, as far as Russia is concerned. It's all part of the Kremlin narrative that Ukraine is at risk of a fascist takeover. EOB; function getTagsStripped($string, $length) { $full_required_length_string = substr ($string, 0, $length); $initial_string = strip_tags ($full_required_length_string); $result_length = strlen ($initial_string); if ($result_length &lt; $length) { $required_chars = $length - $result_length; $remaining_string = substr($string, $length); if ($remaining_string !== false) { return strip_tags($full_required_length_string, '&lt;a&gt;') . getTagsStripped($remaining_string, $required_chars); } } return strip_tags($full_required_length_string, '&lt;a&gt;'); } $output = getTagsStripped($string, 155); echo $output, "\n"; echo strlen(strip_tags($output)), "\n"; // outputs 155 $output will contain There &lt;a href="http://some.url.com/page" target="_blank"&gt;is a&lt;/a&gt; consistent &lt;a href="http://some.url.com/page" target="_blank"&gt;message on Russian state&gt; media concerning the situation in &lt;a href="http://some.url.com/page" target="_blank"&gt;Ukraine&lt;/a&gt;. The revolving 'crisis in Ukraine' bug on state news channel Ross 
Personally I use a windows 8.1 machine for development. I use Zend Server Free on it. Installed MySQL seperately to get a 64bit version. As IDE I use Netbeans. This works pretty well for me. Our production servers all run linux. Most of them are on Debian stable with Zend Server. Besides the windows dev enviroment we also have a development server running Debian stable and Zend Server Free for stuff that specifically needs to run on linux. 
LINQ can also do LINQ to SQL, which transforms it to sql that is then executed on the sql server.
 Can't tell if troll or retard. If the latter, then you just went full retard. I'd be willing to bet you fap it to all that manga. Some people just prefer video instead of pictures. But ignoring all of that, the talk is still valid. And useful for anyone to watch to see how painful scaling is. 
Good presentation, but his voice is so shakey :/
You only need an API when you are sharing data between different applications. If your website is only going to be one application then you don't need an API. If your website is going to be in Angular/Ember/Backbone, you probably need an API. If you are building an iPhone/Andriod/etc application, you definitely need an API. They're becoming very popular, but don't just make one for the sake of it. You should know if you need one or not. :)
I think its fairly clear what he meant. Are you just trying to be a dick to somebody who is having trouble explaining himself?
Lol. Nope.
I'm not actually subscribed to it. Also, there's nothing immoral about /r/watchpeopledie. The subreddit says it is there to teach people to cope with death, and avoid it.
That's an alternative I was considering as well, especially since with a file storage I may need to rewrite the logic in my repositories. It would be cool if I could write the same Doctrine queries for a flat file storage, then just switch the data source.
One thing I didn't understand is why did they stick with MySQL? Isn't Postgres much better for large scale applications?
Once you achieve proficiency with Vim's text objects and motions, it becomes the most efficient method of editing text with the least wrist strain overall that I believe exists. That isn't reason enough by itself for most, though, in the face of editor IDEs like Sublime Text boasting many seemingly intelligent features even for dynamically typed languages like PHP. Fortunately, Vim is quite capable of all of those functions using the tools listed in this thread. The combination of ctags-driven reflection and Vim's modal editing makes it unstoppable in the hands of an experienced user. Let me also be the first to say that most of my co-workers use Sublime and I see a broad range of experience among them as well. Some people use Sublime very well while others use it quite poorly. It all boils down to your willingness to learn the commands or shortcuts. 
Yea, I have other issues with SO so I don't even contribute there at all. I'm not feeding their moderators egos. Someone really needs to make a good alternative to SO that is more open to "opinion" questions (since actually if people don't degrade to outright childish manners then you can get some of the most productive stuff from that in figuring out what to do.) However, the moment you go online, you need to be ready to deal with SO mods spamming your system telling you to go use them. :/
Why would you want to mock the database? When doing unit tests you should mock the repositories and/or entity manager that are injected into your services.
Just wanted to say that your English, at least when typing, is very good!
Wow, dude.. you really have quite a few issues. Good luck with life, that’s all i can say. 
Probably watching YouPorn.
An API in your case I would say means a RESTful API. That is, one where you communicate with it using GET, POST, DELETE, etc - a bit like Twitter / Facebook / other big companies offer. The main reason to go that route is when you want to create one access point to your data which can be reused by most any type of 'front end' client. Examples being a nice AngularJS based approach, or Ember, or even just JQuery on it's own... or even command line. The native app - which is a confusing term to use, as native apps means something else usually (like when you code in Objective C for an iOS app, or Java for Android) - would be perhaps if you don't ever envisage a use case for multiple front ends, or you want to make a minimum viable product ASAP, or similar. So generally an API will give you flexibility. It keeps your data layer separate from your front end. It can be built separately to your front end allowing your front end guys to simply mock the expected return values whilst you go ahead and code the actual implementation. This is a good separation of concerns. However, it will also add complexity. Not just in learning this new fangled approach, which isn't that hard - but still, extra stuff to learn - but also learning how to secure it can be tricky. OAuth is no fun. So the other way - the way you probably know / call a native app - is simpler, but also ties your front end to your back end. Try adding a mobile app to that, and you end up basically saying rude words frequently as you curse your original design decisions. 
I would make an init.php file that your index.php includes and all your other entry points include. And in that you should require the vendor/autoload.php file You are evil for having many entry points to your project, but you can repent by using a common init php script &gt;: )
Is there any simple explanation as to which scenarios are served better with MySQL and Postgres? I'm going to do some researching on my own (I've never used Postgres so I'm interested). I just wanted to see if you or anyone else has some quick insight.
Let me get this straight, its ok for you to do translation which means reading and looking at material, but it's immoral to listen to a tech talk for a porn site? Cognitive dissonance much?
If you're going to do that (and there's nothing wrong with that), make yourself some pretty clear documentation around the assumptions the old code makes (that composer will be included via auto_prepend_file, etc). That way, if you need to debug or anything happens, at least you have a way of figuring out what saving yourself a ton of time...
PHP FIG wants to have a word with you.
Sounds like a plan! Thanks for your input!
I guess it depends on the storage engine you use in MySQL and for what type of data. Besides, the number of rows and the type of operations also matters. So to answer your question, I would say that you need to try both in your application to know what fits best. 
Nope. More information is needed to have any sort of meaningful discussion here.
&gt; You still need to know the big picture if you want to avoid code duplication with regard to similar functionality between those simple systems. I never meant to suggest otherwise. Your big picture can be sort of a high-level of what everything is doing. Let the individual systems determine *how* it is done, all the big picture should care about is that it gets its desired result.
For multi-tenancy applications I think postgres is definitly better because of the schemas feature
Isn't facebook a PHP/MySQL platform?
&gt;Is there any reason to use sessions vs. just using cookies? My understanding was that sessions themselves set a cookie, so would it just be adding overhead? Sessions generate a key which is given to the user in the form of a cookie. This key is used to identify and tie a specific session to a user. The actual session storage on the, other hand, takes place on the server. Storing the data in a cookie would be a major security vulnerability. &gt;I'm currently writing a simple login system There's no such thing as a simple login system. A login system needs to be designed with proper security in mind, and that takes some now-how. It's not just your system that gets compromised by an improperly built system, it's the user's credentials and information, potentially compromising all his/her accounts all across the web. I've written about the different aspects of authentication systems before: http://www.reddit.com/r/PHP/comments/1wa1j0/security_sessions_sql_injection_and_encryption/cf01o0g http://www.reddit.com/r/PHP/comments/1wa1j0/security_sessions_sql_injection_and_encryption/cf0851r?context=5 http://www.reddit.com/r/PHP/comments/1wa1j0/security_sessions_sql_injection_and_encryption/cf039hp?context=2 http://www.reddit.com/r/PHP/comments/1aitay/simple_powerful_and_easy_to_use_authorization_and/c8xwswq 
Actually they dont use MySQL directly on the webpage, its ONLY used to build Redis tables. Around 36 minute in the video its explained
&gt; I'm going to email everyone who's ever purchased from us This is a terrible idea and will be much less productive than you expect.
So, it seems like you can break this down into three basic aspects * Getting a list of purchases per email address * Generating a page that accepts and validates a hash of the email address and captures a user's product ratings * Generating and sending emails to each address listing their purchases Breaking this down further, I come up with these steps: **1. Getting a list of purchases per email address** 1.1. Create some kind of email_product_ratings table, something like: * id - integer, unsigned, primary key, autoincrement * email - varchar, not null * email_hash - varchar, not null * email_sent - tinyint(1), default 0 * product_id - integer, unsigned, not null * rating - tinyint, unsigned, default null 1.2. Create a SQL query that will populate the previous table (you're on your own for that one ;) ) **2. Generate a page that captures the user's product ratings** 2.1. Record the email hash from a specified GET param 2.2. Get a list of unrated products for this email hash eg: SELECT * FROM email_product_ratings WHERE email_hash = ? AND rating IS NULL 2.3. Generate a form with an array input for each product id, ie: &lt;input type='text' name='ratings[2701]' required maxlength="2" /&gt; where "2701" is the product ID 2.4. Record the result of the submitted form in the database **3. Generate and Send the Emails** 3.1. Iterate through each email address in email_product_ratings that hasn't yet been emailed 3.2. Create an HTML email template listing each purchase 3.3. Send the first N emails, preferably through a service like Mandrill or Mailchimp 3.4. Update the email_product_ratings table to specify the email addresses to which the email has been sent 3.5. Set up a cron job to periodically run the email script until all emails have been sent
That is basically what I'm doing-- creating a token in a cookie, which I'd then use to look up the user. Actually, this gets to the heart of it-- using my own token, I'd have to hit the database every time a user loads a page to look up their account ID before doing anything else. Is a PHP session stored in memory? That would be one concrete advantage I could latch onto. (MySQL is very good and fast these days, but I still don't like unnecessary overhead.)
MySQL is more light weight and generally faster for the use-cases that PHP deals with most often. Its not fully ANSI compliant last time I checked, while PostgreSQL is fully standard compliant. MySQL can have multiple storage engines, even though usually InnoDB only is used and the preferred one in later versions, in PosgreSQL there are no different engines. PostgreSQL has much much much more features built-in and in terms of capabilities is closer to an enterprise product like Oracle. Generally if you need the database for CMS like work MySQL should be more than enough. If your use case demands mission critical applicatons (like ecommerce, transactions done right - since they are a bit sketchy on mysql) or you will be doing a lot of intricate manipulation with the data on the SQL server than Postgres is definitely much better choice.
Yes, I've looked at Mustache and it's a great template engine. I love that is it logic-less, but I've found it requires more code because loop and conditional structures are required in most of the templates I create so I end up adding another layer with both HTML and PHP anyway. I've also looked at Handlebars, but need something in PHP.
Not my call, came from higher in the food chain.
By default, PHP sessions are stored on the filesystem.
I have a similar trace function, although it doesn't halt execution -- if you want to halt execution and generate a stack trace, then just throw an exception! It doesn't even require extra code. Something else I do is at the entry point(s) of my scripts, I have some code that prints a demarcation line to the logs, so that as I log stuff out, I can tell when one request ends and the next begins. Also, directly after this line, I dump out `$_REQUEST` to check what the inputs are. I also use this sometimes (usually for messy 3rd party code): function getScopeVars(array $vars) { $local = $vars; $ignore = array('_GET', '_POST', '_COOKIE', '_FILES', 'argv', 'argc', '_SERVER', '_ENV'); foreach ($ignore as $key) { unset($local[$key]); } return $local; } And then a demo: &gt; $foo = 'bar'; &gt; var_dump(getScopeVars(get_defined_vars())); array(1) { ["foo"]=&gt; string(3) "bar" } There might be an easier way to do that, but it works for me. I then have these that I use: function findConstantVals($val, $onlyUser = true, $fuzzy = false) { $consts = get_defined_constants($onlyUser); if ($onlyUser) { $consts = $consts['user']; } $ks = array(); foreach ($consts as $id =&gt; $k) { if (($k === $val) || ($fuzzy &amp;&amp; (($k == $val) || (stripos($k, $val) !== false)))) { $ks[$id] = $k; } } return $ks; } function findConstantNames($val, $onlyUser = true, $fuzzy = false) { $consts = get_defined_constants($onlyUser); if ($onlyUser) { $consts = $consts['user']; } $ks = array(); foreach ($consts as $id =&gt; $k) { if (($id === $val) || ($fuzzy &amp;&amp; (($id == $val) || stripos($id, $val) !== false))) { $ks[$id] = $k; } } return $ks; } Quick demo for `findConstantVals()`: &gt; const FOO = 2147483647; &gt; var_dump(findConstantVals(2147483647)); array(1) { ["FOO"]=&gt; int(2147483647) } &gt; const FOO = 2147483647; &gt; var_dump(findConstantVals(2147483647, false)); array(2) { ["PHP_INT_MAX"]=&gt; int(2147483647) ["FOO"]=&gt; int(2147483647) } Quick demo for `findConstantNames()`: &gt; var_dump(findConstantNames('CURL', false, true)); ::list of all (274 for me) cURL constants:: They are not that great and I don't even use them that often, but on occassion they do come in handy!
This settles it, I think. Sessions will give me a slightly faster speed and moderately better convenience (since I won't have to handle the token-&gt;account lookup myself, and can store information in the session arbitrarily, which I can't do in a database without altering tables). Thanks guys!
The 19th Century called. They want you to translate some anti-masturbation propaganda.
They are both fine at it. One project I worked on used MySQL in their own cloud, and postgresql on individual units that connected to the cloud. It worked fine.
I think there's some misinformation here. You don't **only** need an API when sharing data between different applications. Thanks to angular, ember, etc. it's becoming more and more popular to build an API and have a javascript frontend even if you're not communicating with other apps. You don't necessarily need to build an API for an iPhone/Android app. Internet independent apps don't need an API(games). This goes back to my previous comment, there's not enough distinction/context here to help the guy. 
That's great! I especially like the demarkation trick. It might be a bad idea on heavy traffic sites, but generally, it is lovely. I will think how these can be integrated into bugger.
This is what I have been using, but not because it convenient – simply because I did not have a portable/reusable library that would carry across my debugging functions.
&gt;if you're someone who has to use the manual today then is anything really going to change because we have changed the order of parameters for a few functions Yes! If all the functions followed a logical and consistent pattern (ie. "I'm looking for X in Y") then remembering it would be trivial. &gt;it would certainly break a lot of code ... &gt;There is just nothing to gain from changing anything at this point ... I wasn't commenting on the feasibility of changing a bunch of core functions, or anything in the article for that matter.
I know what you mean by not liking unnecessary overhead.. sessions are not stored in a database. I don't know if it's cached in memory somehow. i just know it's located on the filesystem as small files (one for each session). But don't know if it reads the file on every page request (if it does, i think it would still be better than a mysql query connect + query)
And getting blown under the podium.
And that is the right answer. To exploit various engines based on the feature set while keeping the management overhead to minimal. 
&gt; If by routing you mean a different catch clause then yes, otherwise what would be the point. I'm asking *what you would do differently with it that you wouldn't do with plain old `\Exception`*, and I have yet to get a sufficient answer from anyone. Including you.
For modern applications, the frameworks and xdebug usually do most of the heavy lifting when debugging the most annoying of bugs. For older applications or just spaghetti code that somehow works, I had to write a php parser in php to do things like give me a visual representation of an execution tree. A simple backtrace or execution stack helps a lot when there's various scoping and encapsulation to make things sane, but when a highly complex application is written completely procedurally in global scope, it's a royal pain to work through it at times. When there's an enormous amount of copy/paste code and renamed files for backups instead of version control, grepping doesn't work. Stepping through an execution and/or inserting breakpoints also doesn't always help provide an overall picture when dealing with a disaster so I had to write some tools to help out. It's not something like pypy, but it does go through requires and includes building out the tree structure and evaluates variables along the way. It's crude and frequently wrong since it wasn't designed for OOP, but it's a lifesaver when trying to find out which files are executed in which order with which variables in a system that wasn't designed with any notion of sense or logic.
Sessions: they are stored at server side. If you implement some kind of cache system outside of PHP (e.g. via some kind of proxy system) you won't be able to access the session user data during a page request. You can store big amount of data inside the session. Cookies: they are stored at client side. If you use a cache system that caches your entire page you still able to access the user saved data during the request with Javascript. But cookie has several size limitations that you must consider. e.g. Many browsers will not operate properly if you exceed 6kB of information.
Is there any simple explanation as to which scenarios are better served with Ruby and PHP? Bottom line: you can get the same shit done with either, anyone who says otherwise is an argumentative fanboy.
this dude made 10% of all the youporn traffic masturbation is mad
Here is another one - [Zurmo](http://zurmo.org/) - open source CRM application. You can find Bitnami full stack VM for this that can get you up and running within minutes. If on Windows, install Samba, map drive and load it up in your favorite IDE.
Good points. Another factor to be aware of is development vs. production database. Chances are that ORM generated code would work just fine in dev/test environment and then pick a different plan in production due to data size/quality. Be sure to test with production copy of data and not rely on development database. Depending on your work, various outfits might not let you make copy of production data in development environment for obvious reasons.
I really, *really* want return types in general, but not allowing `null` returns (unlike *every* other language) is a **huge** dealbreaker. Yes, I know there is [a related RFC](https://wiki.php.net/rfc/nullable_typehints) for nullable types, but what if one passes and the other doesn't? PHP would once again get a feature that is ever-so-slightly broken in a retarded way... So at the very least, those two RFCs should be voted together...
Why should I use this instead of PDO?
I'd just use option 1. It's only for a confirmation email so you don't have to *really* worry about it being slow-ish. If you do look into mass mailing, queues are definitely the way to go.
Actually, not allowing null returns **by default** is a **massive** win for type sanity and programming correctness. Let me point you to a quote by the inventor of the null object reference: &gt;Abstract: I call it my billion-dollar mistake. It was the invention of the null reference in 1965. At that time, I was designing the first comprehensive type system for references in an object oriented language (ALGOL W). My goal was to ensure that all use of references should be absolutely safe, with checking performed automatically by the compiler. But I couldn't resist the temptation to put in a null reference, simply because it was so easy to implement. This has led to innumerable errors, vulnerabilities, and system crashes, which have probably caused a billion dollars of pain and damage in the last forty years. In recent years, a number of program analysers like PREfix and PREfast in Microsoft have been used to check references, and give warnings if there is a risk they may be non-null. More recent programming languages like Spec# have introduced declarations for non-null references. This is the solution, which I rejected in 1965. [Tony Hoare](http://catless.ncl.ac.uk/Risks/25.51.html#subj9.1) So, I am exactly the opposite. I want types to be non-nullable by default. As that's the major usecase. If you need a nullable, then you declare it nullable. But the number of times you should support nullable types is *extremely* limited. Or at least should be. Otherwise you're setting yourself up for a pretty huge stability mess...
&gt; Putting too much into one RFC is precisely why previous RFCs on this very topic have failed. I realize this and understand your concern, but wouldn't you agree that if the nullable types rfc fails, this feature would become broken?
I consider a JavaScript frontend application to be a separate application to any API, backend system, etc. Just because you can shove Angular into your Laravel codebase does not mean they are the same application. :) So no, I don't feel the need to be corrected on my statement.
Thanks for the quote! I guess that is a reasonable point, but still, I think null checking around call sites, i.e: if ($this-&gt;method() !== null) {} is, whether right or wrong, the *expected* thing in *almost every language* with return types. At the very least, PHP shouldn't break convention here. Tony Hoare might have been right *back then*, but it's way too late (and wrong) for PHP to go against the grain here...
Less useful perhaps, but not broken. Also, perhaps you don't realize this but parameter type hints do not allow `null` either* \* unless you specify a default `= null`
&gt; * unless you specify a default = null This is exactly what people do for nullable type hints in PHP :)
You don't have to write SQL query anymore. Just forget the SQL syntax and sentence. And you will get better experience for operating database with less code.
THIS. There needs to be a way to return an "empty" value. Returning an object that matches the return type hint with an empty state is not the solution.
If you don't want to use a third party service like /u/p0llk4t mentioned (though I would probably recommend that), you can just set up a cron to check for emails that need to be sent. 1. User signs up with email, puts in appointment time/info, etc. 2. That user gets put into a database with their appointment time (UTC) 3. You run a cron on the server every X minutes (depending on the interval between appointment starts, also UTC) 4. For each job that gets run, check which users need to be sent an email based on the time and send it (30 minutes before, 1 hour before, etc.)
To be clear: the Nullable Type RFC is intended to support this behavior. We are not going against the grain. We are providing you with two tools: function getUser($id): User; and function getUser($id): ?User; It is up to the programmer to decide. We aren't going against the grain at all.
&gt; Tony Hoare might have been right back then, but it's way too late (and wrong) for PHP to go against the grain here... Null pointers are one of the biggest pains in the asses of any other OO language that allows them. You need to check **everything**. Because you can't trust anything. (Note that Objective-C just ignores null pointer dereferences and turns them into no-ops. Which I'm not sure if is a better way of handling or not). So much is this a problem, that [Java 8 even documents how to make a `@NonNull` annotation](http://docs.oracle.com/javase/tutorial/java/annotations/type_annotations.html) to automate that for you. I consider nullable types just like variable references. When you need them, you really need them and they make the code a lot cleaner. But more often than not, you don't need them. So why penalize the cases where you don't need them with all sorts of extra checks, when you can make the default the sane case? As far as *Almost every language*, you're talking about languages where this feature was designed in literally 20+ years ago. The **only** modern language that I can find that implements this is Go (while having a strong type system for objects that would allow it or not). So I would ask this: what's more important? Duplicating a pattern that many consider harmful, and are constantly asking to go away? Or actually looking at how people use code and realize that it needs to go away, so making it go away. So no, it's not "going against the grain". It's realizing a mistake when you see one, and fixing it while you still can. Other languages are stuck, and have to resort to hacks like `@NonNull` to get this support. Which is a nightmare from a maintainability standpoint. Let's do it right the first time...
You do realize that failing once is not a big deal, right? It's not final. Return type hinting has had three failed RFCs in the past yet here we are. And honestly, I think this is by far the best RFC to date because I was able to learn from past mistakes and discussions.
&gt; I think this is by far the best RFC to date I completely agree :) &gt; You do realize that failing once is not a big deal, right? It's not final. Return type hinting has had three failed RFCs in the past Sure, and I think no return types is better than weirdly-implemented return types. But again, this is my personal opinion and I don't get to vote :)
I like it, just one nitpick, not really a massive fan of the fact it has no tests
Well, with non-nullable return types, you could simply omit the type if you wanted to be able to return null. You're no better than today, but you're also no worse (which is a key point). While the case where you don't want null, you can type the return, and therefore get a gain. And that's why I think they belong as 2 RFCs. The return hinting gives you a gain if you don't want nullables. The nullable hint gives you a gain if you do. By themselves, both are useful. But together, they are even more so. Yet another reason to separate them is because the nullable RFC also touches parameters (for consistency). Having a return hint RFC touch parameters seems weird. And grows larger. Just like objects, I like RFCs to be reasonably small and self-sustaining. Make each in a disgestable chunk. Not to mention if the nullable RFC does fail, a new one can be proposed (or that one can be re-proposed after modification) to address the reasons it failed... All in all, I think it's a lot of hub-bub over nothing. We have time. And honestly I think the chances of Return hints passing and Nullables not, is quite low. I think the two most likely outcomes (by far) are either both pass, or both fail. I doubt one but not the other... But I could be wrong...
I've had very few problems with option 1 using Symfony, Twig and Swiftmailer. It's absolutely essential that your IP address have a reverse DNS PTR record which resolves forward to the same IP address. I don't know how much it really helps but you should setup SPF which means creating an appropriate TXT record. That's all I've done. I probably should but I haven't bothered with or studied DKIM. If you're on shared hosting or have inherited a blacklisted IP address then I can understand using a third party service like SendGrid would be a good idea.
Please read the other replies to the parent thread, and if you have any specific disagreements (other than a generic want), can you please post them? I get the want for nulls, but there are specific reasons to avoid (which I address above). If you have specific objections or examples to the contrary, let's definitely discuss. Mainly because from my standpoint, returning nullable types is generally not useful (which I go into detail of why in other replies to this thread)...
I don't think we're communicating effectively. I'm simply not asking about your infrastructure set up. Your application has a *hard dependency* on your database being available. *When* your database is not available, your app will not work, it won't even redirect properly. Personally, I would not be okay with making that design decision.
If there is no object found you can just throw an exception
Two problems with that: * Exceptions are for *exceptional, unexpected* situations. What if that method is designed to return an optional value? `null` is, by its very definition, the lack of value, so it is perfectly suited here. * Even if we ignore the first point, using exceptions would simply replace null checks with try/catch blocks which is even more verbose / error prone.
I don't understand why exposing the inners of a server can be seen as immoral unless you are thinking of yourself doing nasty things with it, maybe you need to unsubscribe from /r/cableporn
I'm using [Mandrill](http://mandrillapp.com). It seems to be working well. Offers free service up to a certain amount. If I'm understanding correctly, you get 250 emails/hr and up to 12,000 emails a month. Their PHP API is pretty simple to use. Setup templates through their web interface, pass in your variables (username/validation keys) and off they go. They then let you know if they bounce, were opened, yadda yadda.
What you have described would vary depending per every execution, as far as I can think. Have you made it open-source? XHProf does something similar.
&gt; What tricks/hacks/strategies have you invented to debug PHP code? Just one ... http://phpdbg.com ;)
Definitely agree here. There are two alternatives that don't require nullable return hints though: 1. Not typing the return. Just like we do today 2. A return object The return object, is basically a result object that stores the value, as well as metadata (was it successful, what was the error if there was one, etc), but for non-exceptional events. Now, I'm not saying both are ideal for all cases, and having a nullable return definitely is important. So in reality, we would have 4 options in the case you didn't find (or couldn't create an object): 1. Don't type the return 2. Type is as a nullable return 3. Return a result object wrapper 4. Throw an exception. Which happens would depend on the code and situation...
You'd be using PDO either way, but with his framework you don't need to write the CRUD boilerplate code. So I'd prefer that over pure PDO :)
&gt; didn't find (or couldn't create an object): In the later case (couldn't create) throwing an Exception would be the correct way I'd say. Maybe instead of returning a return object you would chose to return a collection of objects, be it just one. In case none was found you would return an empty collection. 
There should be more articles about it. I have tried using it several and ended up disappointed. I either overlook something or it is a stripped down version of xdebug.
As a throw away: echo "&lt;pre&gt;".print_r($n,true)."&lt;/pre&gt;"; or a nicer print_r: [dump_r](https://github.com/leeoniya/dump_r.php) with a [screenshot](https://raw.githubusercontent.com/leeoniya/dump_r.php/master/dump_r_th.png) or [php-ref](https://github.com/digitalnature/php-ref) with [even more features](http://dev.digitalnature.eu/php-ref/tests/index.php?mode=html) (press x on your keyboard to expand/collapse for example)
Thanks for sharing. I have researched all of them as part of developing Bugger. However, they focus on method of reformatting "var_dump" output, as opposed to general debugging utilities.
So what else is new?
as every language out there my friend.
I haven't opened it up because it is not flexible enough to be of much value to most operations, but it's something I would like to expand on and eventually release if I'm available to find the time to do so. If I were fully executing and evaluating the php, then the result would absolutely change per execution. Instead, it's more of a static file analyzer with representational variable evaluation to provide information on the path traveled instead of the result. There's limited scoping capabilities since this was developed originally for purely procedural stuff, so most variables are maintained in a hash table with historical entries. As a file is processed, the variable assignments are extracted and evaluated against what's known and pushed onto the historical stack for that variable with some additional information for filename, line, etc. If the value was known, the variable shows this value, otherwise it's the raw code of what's being assigned. If the program has $ip = '127.0.0.1'; then $ip will evaluate to '127.0.0.1'. If instead it has an unknown variable like $ip = $_SERVER['REMOTE_ADDR']; then "$_SERVER['REMOTE_ADDR']" is what's stored as the value since it's unknown. The variable history also tracks an evaluated flag to differentiate between an unknown variable and say a variable string value of "$foo". For the execution tree, it doesn't traverse a single execution path, but instead traverses the entire tree with loop detection to prevent problems. If there's a series of conditionals or a switch to include different files, then this branches and traverses all of them. The displayed result is a full tree and not just a single execution path. Each file is stored as a linked list with all child files linked sequentially. The file names are evaluated like variables; if there's a variable with a value, the value is provided otherwise the entire function parameter is stored as an unevaluated file. If the filename is evaluated, then it looks to read the file and go in and parse through that as well. Just like variables, the files can have multiple states: evaluated and found, evaluated and not found, unevaluated. The files are processed line by line so the variable evaluations and file inclusions don't overwrite each other. It doesn't take into consideration environment paths and variables or autoloaders so you need to already have a firm grasp of the setup for it to be of value. It's crude and ugly, but it's a useful tool for me right now.
In fairness, this code is from 2010, before they did a massive rewrite. 
Ok, this may be the stupid idea..but anyway.. What if we forbid assigning the return value of a method to a variable in the usual manner, like this.. $special_plan = $user-&gt;getSpecialPlan(); Instead, we force the user to define a scope where $special_plan is gauranteed to contain a SpecialPlan object as defined by the return type declaration of getSpecialPlan method. So it would be something like ($special_plan := $user-&gt;getSpecialPlan()) { // do processing with $special_plan } //$special_plan is not available here... This is similar to doing if (($special_plan = $user-&gt;getSpecialPlan()) !== null) { } But the difference is $special_plan variable is not available outside the block and one does not have to worry about its value outside the block. If it is in the block it is a valid object. Outside of it, it is undefined. 
&gt; why do you want to return null? its horrible style and makes no sense at all Please read all the responses to the parent thread.
That's cool... I should point out that sublime is not an IDE (though it is quite capable)
I was under the impression that it was stored on the server. If all of the data is saved in cookies then a session is useless to me.
I'm curious but too lazy right now; Is there any incompatible difference in this rfc compared to hack's return type hints?
I agree. If you want logic-less templates that work in multiple languages, try out Mustache.
That manga didn't contain NSFW material.
Love it. Wish people would stop calling them typehints when they are typechecks.
[The PHP manual calls them type hints.]( http://www.php.net/manual/en/language.oop5.typehinting.php)
That's part of the problem.
What problem?
I'd go with #1 and use swiftmailer. http://swiftmailer.org/ 
Of people parroting bad naming.
Fuck off.
I can partially see where you're coming from, but... This is a specific redirection service for my wife's photography website. If the SQL side fails, the website itself goes down as well making the redirections useless anyway. Your comments have made me incorporate a new 503 page specifically for this redirection service so that if it's unable to query the database it displays a more customised "service will be resumed as soon as possible" message and emails me.
You just told me nothing. It's hilarious (much like their architecture). Tell me exactly why Symfony's architecture is "good'. No generic terms. No tech speak. Tell me exactly why Symfony is good. 
&gt;This will be what php sees of the file when it is reqired to load class abc That's quite interesting. So if I'm understanding it correctly, if there's a syntax error on a different line, it may fail? This is also the case for IntelliJ and every other IDE I've worked with (for PHP anyway, I do not have enough experience with other languages). Quite interesting. On a side note, implementing a plugin for Sublime would be nice. As far as I'm aware Sublime doesn't have any context aware auto completion. I always tend to call it 'garbage completion'. &gt;I think you still need to find out where to put the class, right? I guess, but only as much as I'd need to if I was using your tool unless I'm not understand Cliche properly. &gt; Although I have worked with Doctrine, I have not come across Fixtures yet. Looking at github page you linked, I think the dependency involved here is a bit different, right? I guess it is different, but obviously the same principle, e.g. your `LanguageFixtures` are dependent on the `CountryFixtures`, except all dependent fixtures implement the `DependentFixtureInterface` which requires an implementation to have the `public function getDependencies()` which just returns an array of class names of other fixtures. When I get a chance, I will fork your code and see if I can implement Doctrine's dependencies as well as Symfony's IoC (albeit, I've a feeling Symfony will somewhat work by default). &gt; And this can only work with containers that load the objects using pure php, using new statements like pimple. So I guess it should technically work with Symfony's dependencies? Anyway would it not be better to use the IoC of the library as opposed to directly opening the class files? Anyway, the idea is pretty cool, and I will probably use some of the features, especially the dependencies check. One last thing, I had a quick look at the code, one of the biggest thing I saw is the [`while(1);`](https://bitbucket.org/sras/cliche/src/605aeb7066e0e8c4234e91a0b3d48d69d4fc2ec7/src/Commands/Classes/AddCommand.php?at=default#cl-58) with everything `break`ing within the while loop. On first sight, it looks like it will never go to the second iteration. Is there a reason you've done this?
Well done! Just want to add my voice to the chorus of those in favor of this feature.
Most of the features of "true" IDEs, like automatic refactoring, aren't really possible in dynamically typed languages, anyway. You can get really far in PHP with just ctags.
It's unfortunate that this RFC chooses not to address multiple return types, as it seems like that would be the ideal solution to this problem. e.g: function foo(): [array, null] { ... }
This thread has been linked to from elsewhere on reddit. - [/r/bestof] [A reddit who respects moral decency, /u/champaign6cf0, stands up for himself while being downvoted.](http://np.reddit.com/r/bestof/comments/23wg83/a_reddit_who_respects_moral_decency/) - [/r/programming] [We need to revise the moderation of /r/php. Submissions like this shouldn&amp;#x27;t be upvoted, nor moral comments like this downvoted. /r/programming pls help.](http://np.reddit.com/r/programming/comments/23wh81/we_need_to_revise_the_moderation_of_rphp/) - [/r/SubredditDrama] [Porn, morality, and PHP](http://np.reddit.com/r/SubredditDrama/comments/23wlyl/porn_morality_and_php/) *^I ^am ^a ^bot. ^Comments? ^Complaints? [^Message ^me ^here.](http://www.reddit.com/message/compose?to=%2Fr%2Fmeta_bot_mailbag) ^I ^don't ^read ^PMs!* 
Please note that 'the moral redditor' nominated HIS OWN COMMENT for bestof.
I don't find it silly, because the type of method arguments and return values are important when interfacing with that method. A typehinted method tells you exactly what it wants and will ensure that it get it. On the other hand, variables are constrained locally to a small method body and their types don't matter to anything else. My main reason to have full&lt; typed variables would be the ability for compile-time type verification, which isn't really realistic with just partial typing.
I fully agree. I think allowing null cheapens the value of having a declared return type to the point that you don't even need them. You're not returning what you SAID you were returning...so what's the point in saying you're returning that kind of thing? It leads to messy and lazy coding where you are always reactive instead of proactive in your application design.
This is great, really well written RFC - great addition to core if it gets the votes. Like the [nullable typehint RFC](https://wiki.php.net/rfc/nullable_typehints) that goes alongside it too.
Nitpick with the title: Neither `self::` nor `static::` have anything to do with **object** oriented programming. (And both are, with some exceptions, a sign of bad design.)
Thank you! Medoo has been a wonderful addition to my projects. The biggest advantage for me is in not having to update my insert / update statements when I add a field. Now I never mess up a sql statement because I had the wrong number of question marks. 
From the manual: &gt; Type hints can **not** be used with scalar types such as int or string. Resources and Traits are not allowed either. Why not?? There has to be a good reason. I'd love to do "function foo(array $foo, int $bar)"
Also use sendgrid here. If you take some more time to log the outbound e-mail with a unique id in the db, and you can even track and run reports on bounces.
I love the RFC and I love how the syntax is similar to that of Go: func (T *Type) FuncName() *Type {}
Because it gives you a great separation of concerns, it has a great DI container, everything is decoupled, thus extremely easy to create adapters to tie symfony with legacy or old code, it is very well engineer in the way that there is no DRY and the interfaces are crystal clear, great documentation, great community, constant updates (especially security and performance), a lot of decoupled third party bundles (which are very easy to extend and modify without having to change their code - the DI part), clear release and update cycle makes it easy to plan. Lastly if you dont wanna take my word for it, almost every other major PHP framework and recent versions of opensource projects (drupal 8, phpbb, etc) use some or most of the symfony components under the hood, which obviously is a recognition that they are indeed well written and though of. I dont understand how people say its complex, there is a difference between complex for you and complex in general, when I read the APIs it really couldnt be more straightforward... Here is a more comprehensive list of projects that use symfony: http://symfony.com/projects Those are a good part of the popular projects in the PHP community...
I just want you to know that given your reaction in this thread... you're awesome. You're braver than most of these other redditors here put together, while they developed their personalities &amp; opinions from upvotes. They redefine blind sheep. 
I look at your list and the only thing I can think of is dysfunction begetting dysfunction. You only need a community, layers of documentation, and constant updates because the thing is so insanely bloated. It's a Java-like interpretation of PHP and guess what PHP is a scripting language. The best part about ridiculous models like these are that they sucker junior developers with the "emperor has no clothes" trap. By the time you have learned their absolutely ridiculous pattern and grown accustomed to the bloat that has no place in a scripting language you can't admit that it's a mess because now your ego is on the line. You can't admit that you have been duped (just like all the other developers). Something that needs to be updated constantly isn't very good now is it. Drupal is a bloated mismarketed (on purpose) disaster so listing that really doesn't impress me. PHPBB is a mess. Honestly the only framework I can think of that isn't a steaming pile is CI and guess what ... it runs a hello world faster than anyone else without any caching.
Can you elaborate some? I've used these keywords for accessing constants, creating a class instance inside a static factory method, etc. The example in the article is never something I'd do, but I'd like to know what your opinion of "bad design" is.
Take a deep breath. http://i.imgur.com/7AZRUDE.gif
As someone who actually enjoys both pornographic and non-pornographic Japanese artwork, I'd like to point out that "manga" is an umbrella term for both. If you're fapping to it, it's a specific type of manga called *hentai*, and using the terms interchangeably is the equivalent of calling all photos porn, or all books erotica. I 100% agree to the point you're making to this moron, but if you keep using incorrect terminology like that someone other than me is liable to get pretty angry at you at some point in the future.
We should get together and refactor this ;)
I agree. I always made sure that no different types get returned by myself, but its way better if the compiler actually checks it. 
LOL is all i can say and i will leave it there. The more experience you start gaining the more you will learn, there is no point to waste time arguing with you if you dont understand what I am saying ;)
This is why executives look at development expenditures and go "let's outsource ... these idiots are not worth it. It takes two of them to make a form on a page"
Oh god, heaven forbid somebody see genitalia!!! THE WORLD IS GOING TO BE BATHED IN FIRE BECAUSE SOMEBODY SAW GENITALIA!!!!
Apologies for the wall of text. There are, in my experience, two broad categories of reasons: horse shit and true fax. **HORSE SHIT** If you want examples of these, I'm sure someone will helpfully link "PHP: A Fractal of Bad Design" for you. Basically this is a mix of misunderstanding of PHP's fundamental nature as a loosely "duck" typed language, and some out of date nonsense. A lot of criticisms of PHP are either subjective (it's so ugly!) or trivial (OMG, \ for namespaces lol!) and can be dismissed with little comment. A lot of other criticism is out of date, or could be applied to any language. Comments about security and best-practise often are of this type. You can derp in everything from C++ to Ruby, and baddies are gonna bad. **TRUE FAX** Then there are these ones. Yes. PHP has some flaws. We need to, as a community, not ignore, but instead address these, and hopefully demand fixes. Indeed, IMO the community is most of the problem with PHP. If you look all over the interwebs you'll see "tutorials" in how to do basic things in PHP, like getting data from a DB. These tutorials often use techniques that are out of date, deprecated, and/or insecure. Some of these tutorials are **not** old, but are still popping up. It's not just the "outer" community either. Reddit, even on /r/php has some brainfart herpaderp repeatedly coming up. **Opinion follows: ** In no other language would "I don't really bother to use a framework, I just code it from scracth so I have full control" or "I don't bother using templates because PHP is a templating language" not be considered the risible opinions of the ignorant or incompetent. Unfortunately, some of PHP's greatest assets, such a gentle learning curve, volumes of online resources, and low barrier to entry are also, ultimately, some of its most problematic. Because of these things a lot of PHP developers have shallow experience, they're self-taught developers who picked up PHP and ran with it, lacking formal education in design patterns, object oriented programming, and fundamentals of good coding. I should note that I'm not criticising these people and **I am one of these people**. They/we can become great coders, but have to acknowledge our weaknesses before we can correct them. As a result of this, the PHP space, particularly in terms of legacy and existing applications, is one highly dominated by "cowboy" coders. Basic expectations in other languages, such as unit testing, are considered "Oh, you know, maybe one day we'll try that". Codebases are often held captive by some autism spectrum auteur whose narrow domain knowledge is mistaken for skill. Management is often 10+ year veterans unaware of the improvements to the language, who insist on adhering to The Old Ways like they are the pagan priests in a fantasy novel. Many development studios are essentially Wordpress hacks, dumping that toxic waste into our environment. The language itself does have flaws. PHP is designed by committee, which is basically like saying it wasn't designed at all. It has grown over time from some shit some guy made to one of the dominant global languages and everything that's been added and changed has largely been organic and unguided. The API as a result has some spectacular (and embarrassing) inconsistencies and idiocies. Changes and additions are managed by a group that has been referred to memorably as a "toxic kindergarten". Considering all of the above, though, PHP has evolved drastically over the years I've been using it. It is at present in the best state its been in. Agreement on a number of coding standards has made frameworks more interoperable, and allowed an impressive array of great systems such as Symfony and (my preference) Laravel. Unit testing, static analysis and disciplined development focused on maintainability and code quality has become the expectation at least in more enthusiast circles. It's getting better all the time, and we should expect and demand that it does so.
That was an excellent explanation! I especially liked: &gt; Do not tell me that “good developers can write good code in any language”, or bad developers blah blah. That doesn’t mean anything. A good carpenter can drive in a nail with either a rock or a hammer, but how many carpenters do you see bashing stuff with rocks? Part of what makes a good developer is the ability to choose the tools that work best.
I considered that as an option but I'll leave that as a last resort. I do have a MySQL database available. I've never done that before but if you pick a storage engine like ARCHIVE, would it be relatively harmless and not too taxing on the database server? I just don't want to slow down the site or any others on the server if MySQL's serving up six 500K images.
Storing your files as a blob in MySQL is probably your best bet, so long as you're not doing 'SELECT * FROM images' and only selecting the primary key `id` or an index you should be fine for a small site. It may not be recommended, however if you do it correctly it can be done without taking a performance hit. **More info:** http://www.phpro.org/tutorials/Storing-Images-in-MySQL-with-PHP.html 
Crap. Just saw the other line Join #phpc on Freenode! please disregard.
Can you not get the server admin to create the directory with the correct permissions for you? Or alternatively suggest creating the directory outside of the web root directory. Then use a script to render images or serve files as required.
What happens when I call `foo([], '12lol');` ? There are at least three schools of thought: 1. Fatal, even though it could be cast, 2. Coerce, even though it would lose information, and 3. Warn, which does not really enforce the typehint at all Internals can't agree on any one behavior, so we're unlikely to see scalar typehints any time soon.
I could see but he has things siloed so I couldn't have a directory outside of the web directory. The "private" directory is in the web directory but just blocked when someone tries to serve it up with Apache. He was very much against having any directories set to 777 no matter where they were and said if he noticed any set to 777, he would change them.
Yes because adding (in both cases) opt-in stronger typing instantly makes it so similar to Java that we might as well use Java.... Really this argument needs to stop. It is completely nonsensical.
What happens if there's a &lt; or &gt; character that doesn't belong to a HTML tag?
&gt; This is also the case for IntelliJ and every other IDE I've worked with.. That is interesting. I didn't know this. Thank you. &gt; guess, but only as much as I'd need to if I was using your tool unless I'm not understand Cliche properly. With cliche, you don't have to figure out the path. it detects the path to a namespace automatically from the include calls which your projects autoloader makes when it attempt to load the new class. If there are multiple places where an autoloader looks for a certain class, then you are provided with the paths it detects and you can select the correct path. This means, what ever logic your autoloader uses to map class names to path, Cliche will be able to put the new class in the right directory. This is shown in [this gif](http://imakesnowflakes.com/cliche/media/cliche-class-creation.gif) where I create a PSR-0 type class with underscores acting as path separators. &gt; One last thing, I had a quick look at the code, one of the biggest thing I saw is the while(1); with everything breaking within the while loop. On first sight, it looks like it will never go to the second iteration. Is there a reason you've done this? Yes. It will go to the second iteration if the class creation results in an ambiguous paths exception, which is thrown when the class name user entered resolves to multiple file system paths. After the exception is caught, the user is asked to select the correct path from the set of paths it detected. This is done in the catch block and after the user select the correct path, the class creation has to be attempted again with the path user selected. Using a goto was the easiest thing to do, but I went with this wile loop with breaks from every other block. Can you think of any better way to handle this. 
glad that you find it interesting..) &gt; I mean, if you went that far, why not support anonymous blocks: I am not sure I get you. Using those blocks for a local variable is not very useful. As the variable is local and the contained function controls what is being assigned to it. But when you assign it a return value of another method, you don't have control of what the remote method returns. The syntax I mentioned is a way to check if the called function has honored its return type declaration, it is not a method to check for nulls values. And I think it will improve readablity, by forcing the developer to put all the statements that depend on the varable in the same block. &gt;Thanks for the idea!!! You are most welcome )
I recently got a 25%+ raise to swap to a full time job working from home. Feels Goodman... I definitely +1 this approach.
Analogies are often cheap cop-outs, and this is no exception. Simply claiming that using PHP is "like hammering a nail in with a rock" is meaningless. Using Ruby is like painting a wall with snakes. Using NodeJS is like carpentry with a hovercraft. See how easy, and meaningless, that is? Unless you can provide legitimate concrete concerns you're just spreading FUD, and that article is full of that. While it DOES raise some actual issues with consistency and a cluttered API, most of it is a fundamental misunderstanding of PHP's typing. 
The day that goddamn blog post actually describes modern PHP is the day monkeys finish that fucking collected works of Shakespeare they've been banging on for millenia.
&gt; more than a code-monkey Totally agree with this. You need to be paid to think, not to "program". 
This. I edited the post... for some reason, I had that written down somewhere, spot checked on a few functions I normally used, and put it in the post. Apparently that's the straw that broke the camel's back, wrt other discussions (like /r/programming)... some people can't get over the fact that functions have differing argument order, even though it hasn't been a *real* problem for years.
I refer to them as 'type-demands'. Sometimes I pronounce the dash, sometimes I don't.
The quick and dirty solution is to make an .htaccess file to prevent direct access to the files. Then use php to serve the files using readfile( ).
I will always downvote any comment that references this shite as a valid criticism. It just isn't.
Use S3? Upload files to the tmp folder (the $_FILES already is)?
I wrote titon/debug which provides a set of debug(), dump(), etc functions that output the data in a pretty format using templates. The functions: https://github.com/titon/debug/blob/master/src/bootstrap.php The templates: https://github.com/titon/debug/tree/master/src/views
Without knowing what the error is, it's impossible to help you here. The code is also unclear, it should have been posted in proper tags. Finally, instead of doing SQL queries like that, please look into using PDO.
Option #1 provided you are on a server that doesn't have a blacklisted IP or is in some known bad neighborhood. It's pretty easy to set up a PostFix mail server correctly for just sending email. 
I'm not really looking to use S3 since there are about 6 images total so I feel like S3 would be a little overkill to integrate. I don't want to shove everything in tmp since the folder is periodically cleaned by a cron script from time to time.
I tried something like that, but the issue is still that files won't upload unless the directory is 0777 and the admin doesn't want me changing directories to 0777 even if an .htaccess file is there.
They don't have enough to do with their time, so they spend their time bashing PHP and masturbating to how massively scalable their clojure twitter clone is.
This. I fail to see the point of declaring a return type if that return type can be more than one thing (e.g. the define type, and a null).
That is very nice of you to say..Thank you ). 
It is fun, keep that attitude and learn as much as you can. 
Ask him what are his concerns about uploading files and making it 777. Its probably going to be malicious shell scripts upload and directory traversal. Give a proof of concept that your scripts are checking against that. Basically, you will need to make sure that - uploaded files are checked against mime and file extension. Use whitelisting instead of blacklist. Please don't write your own, Symfony and Zend have reusable package for this. I think flysystem does this too but I'm not sure. - uploaded files are referenced by either an ID, or to the file directly. Example: /image.php?id=4 or /uploads/image4.jpg Don't do something like /image.php?file=image4.JPEG. That's a big no no. If it's public images, you're better off serving the static, if it's sensitive images, better off with the id (so you can deny the request if the user is not logged in, for example) - you can go the extra step and make sure that the uploads directory only serve static content and of limited extensions. - if it's image, you can go another step and resize the image instead of copying 1-1. That will make sure that the file uploaded are really images, plus you'll be able to serve the correct and optimized dimensions. I can understand why your admin is reluctant. Most of the exploits I come across is with file uploading system. Ask him to vet your system and cross your fingers. Remember, security is not a joke! Even for simple site, your server can be compromised and used for botnets. 
In addition to alternatives suggested already, ask them to setup a separate vhost that has no PHP execution handler and a 777 docroot folder. Upload there. Since nothing in that folder will ever execute, there's zero chance of malware getting in there.
That is a specific exception. Show me a case where you would catch `&lt;Framework&gt;Exception` and do something specific with it.
&gt; about 6 images total so I feel like S3 would be a little overkill to integrate. If it's only 6, then maybe just do the database thing mentioned elsewhere. Just use a normal innodb table. Don't worry about performance at that scale. It will simplify your backups too. Sounds like the sysadmin isn't going to be happy with any filesystem solution you come up with anyway. So no point wasting any time on it.
* Strict hinting, only accept integers: `function foo(int $bar)` * Accept numeric values approved by `is_numeric()`: `function foo(numeric $bar)` * Accept anything and cast to integer: `function foo((int) $bar)`
Thank fucking allah ive been dying for this
Coerce and warn seems the logical choice as the rest of PHP handles scalar types as such everywhere. `str_repeat(1, "2")` will give you `"11"`. Plus, stricter frameworks like Symfony throw an Exception when any kind of error (warn, notice, etc.) occurs so everyone is happy. I always found it dumb that native functions have scalar type hints but user function don't.
I like CodeIgniter because it is lite and it doesn't use an ORM for models by default (I hate these frameworks that get these junior guys going with an ORM so they think that's the only way ... learn up so you know what to pick for the job.). It's got one of the lightest abstraction layers that is really quite elegant. You can easily add an ORM though and honestly that is my point. That being said Laravel has become my new favorite toy. Laravel got it really right with composer. Their basic abstraction is very nice when you don't need this massive ORM .... but then they have Elegant ORM which is great if you are running a major user data collection site and need serious abstraction for the sake of maintainability. Loving it. Symfony started out OK ... then they pulled a Zend and just went insane.
Wow. If the strangeness of his post wasn't enough, that's some level 10 immature douchebaggery right there.
You overlooked somethhing ... try "help" ;)
So... you're saying that your "example" isn't really an example? Cool.
Why would porn be immoral? How strange. Ah, perhaps you've accidentally extended your own values onto others. Oops!
Why the hate? How can you support this RFC which advocates types, the same as already implemented in Hack? Are you so blinded by your hatred of Facebook that you can't see Hack for its merits, or do you have legitimate concerns?
Yes
Interesting syntax. Opposite of [where C# puts the `?`](http://msdn.microsoft.com/en-us/library/1t3y8s4s.aspx). I wonder why that was chosen over existing conventions? 
I actually don't mind this new fangled backwards syntax. It bothered me when I first starting see it crop up in languages like Go, Rust and ActionScript but it's kind of growing on me. You're usually more interested in the names of things than their types, so I think it's more natural to read that way.
I think that's the wrong choice of syntax. function foo(): array|null { } would be better IMO. It's what doc-comments already use (at least in PhpStorm), `|` is the [bitwise] or operator, so it makes sense to read it that way, whereas square-brackets denote an array. Perhaps you are annotating that `foo()` returns a two-element array containing another array and a null ?
My bad, I didn't see that the `AmbigousPath` catch wasn't breaking (misspelt btw, should be `AmbiguousPath`). The only reason I commented on that was because (I thought) all blocks were breaking. I oversaw the fact that the `AmbigousPath` was not breaking, so really it is fine as it is. Anyway, last time I implemented something like this I used recursive method calls. Something like this (untested): protected function execute(InputInterface $input, OutputInterface $output) { $app = $this-&gt;getApplication(); $dialog = $app-&gt;getHelperSet()-&gt;get('dialog'); $this-&gt;configuration-&gt;findAndLoadConfigurationFromPath("."); $bootstraps = $this-&gt;configuration-&gt;getBootstrapPaths($input); $fqcn = $input-&gt;getArgument('classname'); $force = $input-&gt;getOption('force'); $segments = explode("\\", $fqcn); $class_name= array_pop($segments); $name_space = join("\\", $segments); $class = new Entities\ClassEntity($class_name, new Entities\NamespaceEntity($name_space)); $this-&gt;classManager-&gt;reset(); $this-&gt;classManager-&gt;setForce($force); $this-&gt;createClass($class, $fqcn, $bootstraps); } protected function createClass($class, $fqcn, $bootstraps) { try { $full_path = $this-&gt;classManager-&gt;create($class, function() use ($bootstraps) { $this-&gt;loadBootstrap($bootstraps); }); if ($real_path = \realpath($full_path)) { $output-&gt;writeln("&lt;info&gt;Class $fqcn created at $real_path&lt;/info&gt;"); } else { $output-&gt;writeln("&lt;error&gt;Class $fqcn could not be created at $full_path&lt;/error&gt;"); } break; } catch (Services\Namespaces\Exceptions\PathNotFound $e) { $output-&gt;writeln("&lt;error&gt;Cannot find path to namespace for class \"$fqcn\"&lt;/error&gt;"); break; } catch (Services\Files\Exceptions\PathNotFound $e) { $output-&gt;writeln("&lt;error&gt;Directory \"{$e-&gt;getMessage()}\" does not exist. Use '--force' flag to create it.&lt;/error&gt;"); break; } catch (Services\Files\Exceptions\PathExists $e) { $output-&gt;writeln("&lt;error&gt;File {$e-&gt;getMessage()} exists!&lt;/error&gt;"); break; } catch (Services\Namespaces\Exceptions\AmbigousPath $e) { $output-&gt;writeln("&lt;comment&gt;Class name was resolved to multiple paths. Select one.&lt;/comment&gt;"); $paths = $e-&gt;getPaths(); foreach ($paths as $k =&gt; $path) { $count = $k + 1; $output-&gt;writeln("&lt;info&gt;[ $count ]&lt;/info&gt;". $path); } do { $output-&gt;writeln(""); $selection = (int)$dialog-&gt;ask($output, "Enter your selection (1 to $count) : "); } while($selection &lt; 1 || $selection &gt; $count); $this-&gt;classManager-&gt;setDestinationPath($paths[$selection - 1]); $this-&gt;createClass($class, $fqcn, $bootstraps); } catch(\Exception $e) { $output-&gt;writeln($e-&gt;getMessage()); break; } } By the way, on line 22 (of the code I just posted) you're using `$this` within an anonymous function. Just wanted to make sure that you're aware that in PHP5.3 `$this` is not accessible in anonymous methods (see the [changelog of Anonymous Functions](http://php.net/manual/en/functions.anonymous.php). You'll have to work around it in some way (plenty of ways to do so, easiest is to replace it with a callable).
^ This is correct, yeah ...
I'll take that as a yes you're full of hate, and no you don't have any legit concerns.
Can be a sign of poor design when accessing variables sure, but accessing static methods is perfectly reasonable. In general static makes more sense and follows normal OO inheritance and acts more like languages such as Java. Unless there is a specific reason it makes more sense to avoid self.
Accessing class constants via `self::` (but not `static::` of course, because that would imply that you expect the *constant* to change in an inheriting class) is one of the aforementioned "exceptions" of valid use :)
I'm not being a dick, I'm pointing out that you yourself are acknowledging that your example didn't, in fact, answer the question.
I have lately been exprimenting with Amazon SES: http://aws.amazon.com/ses/ Cant beat the price... ($0.10 per 1000) Reliable provider that keep dropping prices... Anyone else have some thoughts?
too much broken windows
When we have generics, we can also write a Maybe&lt;T&gt; generic, e.g. (Pseudo-Syntax) interface Maybe&lt;T&gt; { public function isNotNull() : boolean; public function get() : T; } If you want to return null, you return a implementation of Maybe which says this. class IsNull&lt;T&gt; implements Maybe&lt;T&gt; { public function isNotNull() : boolean { return false; } public function get() : T { throw new \Exception(); } } And if you have a non-null, return a NotNull implementation class NotNull&lt;T&gt; implements Maybe&lt;T&gt; { /** @var T */ private $obj; public function __construct(T $obj) { $this-&gt;obj = $obj; } public function isNotNull() : boolean { return true; } public function get() : T { return $this-&gt;obj; } } This way, you can make the possibility of a null absolutely clear to the user of your method. 
The post says "Why what Jamie did was completely in line with his character." Not "Why what Jamie did was right." Also, I'm not the author of it. You're so far off the mark.
I'd really prefer adding proper support for decorators and annotations to allow people to use libraries to extend the "kind of PHP they want", instead of having to add all new features to the core and introduce even more syntax issues into the parser each time. @arguments(Foo $foo, Bar $bar) @returns(Foo) public function (..) {} would allow us to have a single concept of "how to extend the language for runtime checks" (one issue here would be that the type definition (in @arguments) are moved from the actual function declaration, but I don't see that as a show stopper). It would also allow people to use native types in their type checks if they really want to do that, as well as having a general "metadata about functions" API.
&gt; I sincerely believe that pornography is immoral and that it ruins people's minds. Morality is subjective, whether you like to think so or not. I do not consider this talk immoral at all, so please upvote it as I think it's a valuable source of information. I think religion ruins people's minds. I think the whole thing is immoral and all it does is slow the progression of humanity. It's a disease. The world will be a better place when people stop blindly placing faith in imaginary supernatural beings. 
I suspect it might be related to [Hack's choice to prepend the ?](http://docs.hhvm.com/manual/en/hack.nullable.php). Closing the syntax gap between Hack and PHP is a net win for both languages, IMO.
"Why do people bash on PHP" &lt;-- well , those are the people who never used php. or they just have experience in one language (python, ruby), who believes the world is perfect (btw: I hate ruby). And lastly they just want to convince themselves when they want to rewrite their piece of s/w to the new hipster language, so they start to talk trash on other languages.
It was kind of crappy in the 5.2 days.
Its because of you. People like you. You come here and start using PHP and next thing you know, you have actually written a decent working website that is updating databases and making a contribution to some small business. Just like that. And you are having fun!! Some people just do not like this. :-) 
Dat logic. Quit now kid. This post of yours, and your subsequent strange self promotion in other subs is turning you into a minor reddit celeb. And if you hadn't noticed, not a single person thinks you're thinking straight. Or keep going. It's already quite amusing.
"One cited issue is that many developers wanted to preserve the ability to search for function foo to be able to find the definition for foo." If that is a reason, this RFC might never become a reality: https://wiki.php.net/rfc/optional-t-function Not that it's very important
Awesome... keep up the good work.
I'm not sure if you saw my edit introducing an option/maybe type. That solves this case? It's the standard pattern in other langs. And it is *a* case, " an empy object would be in an invalid state" is not generally true. In PHP depending on whether you wanted a hard fail (throw) or a pythonic Nullable (/slightly more monadic Nothing()) then you could have: class Nothing extends Maybe { public function __call() { return $this; } } etc. 
As someone who knows the difference, I meant what I said. Why do you think I have neko in my name?
I'm not really a fan of one class with underscore method names. But anyway. Why this and not Doctrine DBAL? I know we're talking about size, but it's 2014, so the size doesn't matter that much.
About to start looking into php pretty much as soon as I wake up(damn you reddit), where should I be looking online for current best practices for php? Thanks
You are using the files as two different users, www-data and another. Have your admin add the other use to the www-data group, and then 775 will be enough.
While the RFC doesn't mention it, there are a number of additional advantages for a postfix syntax: * The more important information (the function name) occurs first. (Also: Function names align.) * The syntax is compatible with Hack. * Should we introduce generics in the future, a prefix type syntax would force an ugly syntax for method generics. E.g. Java needs the extremely convoluted `public static &lt;T&gt; List &lt;T&gt; toList(T[]);` instead of the much more sane `public static toList&lt;T&gt;(T[]) : List&lt;T&gt;;`. It also has potential issues with advanced type deduction, which is why C++11 also had to introduce a postfix return type syntax. I was somewhat skeptical about the syntax as well, but after extensive discussion concluded that a postfix syntax is actually superior in *every* way - apart from deviating from familiar C notation. If you take a look around, you'll find that a lot of *modern* (as in, created in the recent years, like Go, Rust, etc) languages go for a postfix type syntax.
Mandrill is a great service. Did you know that you don't HAVE to use their API ? You can simply use their SMTP service directly by using your login and API key as credentials.
&gt; if that return type can be more than one thing Well, `null` is not "a thing". By its very definition, `null` is the lack of "a thing". Hence, not returning anything is the same as returning `null`: function foo() { $foo = 2; } $bar = foo(); var_dump($var); This will output `NULL`.
Good luck. A reverse image search is not trivial to implement. You're going to want to look into feature detection algorithms such as SURF/SIFT ( http://en.wikipedia.org/wiki/Feature_detection_(computer_vision) ) and how you can store the output of these in a database. You'll then need to run that algo for each of your potential matches and store the result. When you want to check an image you'll need to run the algorithms again and compare the results to the ones you have stored in the database. Maybe find an API you can use rather than trying to roll your own solution?
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Feature detection (computer vision)**](https://en.wikipedia.org/wiki/Feature%20detection%20(computer%20vision\)): [](#sfw) --- &gt; &gt;In [computer vision](https://en.wikipedia.org/wiki/Computer_vision) and [image processing](https://en.wikipedia.org/wiki/Image_processing) the concept of __feature detection__ refers to methods that aim at computing abstractions of image information and making local decisions at every image point whether there is an [image feature](https://en.wikipedia.org/wiki/Image_feature) of a given type at that point or not. The resulting features will be subsets of the image domain, often in the form of isolated points, continuous curves or connected regions. &gt;==== &gt;[**Image**](https://i.imgur.com/tGBULqz.png) [^(i)](https://commons.wikimedia.org/wiki/File:Corner.png) --- ^Interesting: [^Computer ^vision](https://en.wikipedia.org/wiki/Computer_vision) ^| [^Edge ^detection](https://en.wikipedia.org/wiki/Edge_detection) ^| [^Scale ^space](https://en.wikipedia.org/wiki/Scale_space) ^| [^Corner ^detection](https://en.wikipedia.org/wiki/Corner_detection) ^Parent ^commenter ^can [^toggle ^NSFW](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+ch1mj3e) ^or[](#or) [^delete](http://www.np.reddit.com/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+ch1mj3e)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
This is a curiosity of a number of dynamic languages. The equivalent piece of code in most mainstream static languages would be illegal. It isn't entirely sensible to treat "void" functions in PHP as returning `null` as it's an implementation detail resulting from the lack of a true `void` specifier. tl;dr: the example is valid but nonsensical.
Static variables and methods are **NOT** part of OOP paradigm. They are used to apply procedural programming paradigm. When it comes to constant's you will be better off by using `ClassName::CONST_NAME` So the short answer is: **NONE**.
accessing constants has nothing to do with static methods
The official repository of PHP best practises is [PHP: The Right Way](http://www.phptherightway.com/). While it isn't strictly necessary to be doing **everything** the way they say, it's good enough standard that if you are choosing to do something different you should probably think about why.
I don't really that educated in this topic, but anyway I'll try. Doctrine has ability to be easily extended with caching etc, without writing your code for cachin, so again, Doctrine's usability, good code standarts and practics plus easiness of caching for quick queries results - I think there is no such problem as "Doctrine is slow because of abstractions". Abstractions are helpers, especially for people who try to code better and try not to do premature optimization. Because if there is such thing like many data in your db and you have serious project - using Medoo is not a good, extendable and friendly option.
Check out ghost
There's a Grunt plugin available https://github.com/SaschaGalley/grunt-phpunit
Link for ~~the lazy~~ convenience: [Ghost](https://ghost.org/)
Great ! Never seen it before, thanks for mentioning it.
I was looking for an API but couldn't find one, as I know there would be a lot of work in writing my own implementation of it. I'll have to do a boat load of research to get all the information I'll need, then just getting a prototype together. I see someone has mentioned OpenCV, so I may have a look at that, but I have a feeling I'll end up knee deep in algorithms, fun stuff! 
I also use ghost and I'm quite found of it as it's using markdown and doesn't require hours of configuration (in fact, no config at all) to look nice and simple.
Yea, I had considered making the function recursive, but didn't go that was because I would either have to pass around the $output and $dialog variables, or make them properties of the command object. I guess I was a bit tired at the moment and didn't want to deal with any issues that might come up with that change, and ended up with the while loop. Anyway [I have changed it to be recursive](https://bitbucket.org/sras/cliche/src/650b747744afa0d7614953ef27b3dd2b6ba836f2/src/Commands/AddCommand.php?at=default#cl-79) now, as I could see another of advantages of doing so, which is to avoid the loading of bootstrap code during the second call. 
OpenCV has a few feature detectors built in, check out the docs: http://docs.opencv.org/modules/features2d/doc/common_interfaces_of_feature_detectors.html
Also a Ghost user, it's excellent and is only getting better. Absolutely love that they use markdown, and the editor is great. There's a good selection of both free and premium themes, and the default one is nice, it's not actually that difficult to make your own too. Worth looking into for sure.
Fair point and I agree because there are always a million and one solutions to the same problem. I understand that you can get the same things done I was just wondering if there was a particular aspect that one or the other excelled at.
No. It should be fully compatible. And one point I'd like to make is that it wasn't designed to be explicitly compatible. That was a design pressure, but the priority was to make a sane implementation. If we could do a sane implementation that fit with Hack's, then doubly awesome. But I don't think it makes sense to do it some way *just because hack does it that way*. It needs to make sense as well. And in this case, I think it definitely does. Compatibility where possible, breaks where justified... I think that's a pretty good way to look at this, no?
Ok. I believe you can also control htaccess thru php. Check this link: http://stackoverflow.com/questions/8899805/edit-htaccess-with-php Otherwise, please validate requested matches a (regex) pattern before you query your database. You're leaving yourself open for injection attacks.
If you've ever *actually* used Java, you'd realize that what's being proposed here is really nothing of the sort. In Java, you can't get away from the type system if you try. Here, the type system is there when you want it, there when you need it, and out of your way when you don't. It lets you code defensively without needing to worry about it when you don't need to.
Hi. Can you give me some simple app example that being developed using medoo. I can't grasp the concept. Sorry just started learning pdo.
&gt; Using those blocks for a local variable is not very useful. No, I was implying an arbitrary expression. So you could do: $foo = bar() { } or $foo { } or $foo-&gt;bar { } etc. Not sure if a good idea or not, just something off the top of my head...
[Octopress](http://octopress.org) is another one or if that's too much, you can use [Jekyll](http://jekyllrb.com) which is what Octopress is built on top of.
Yeah, I think his point was that your comparative analogy was flawed. A snake would make for a poor paint brush where as a rock could actually functionally work as a hammer.
Nah, he's just messing around. I know him well IRL. :)
Have you heard of silex, it's a liter version of symfony. It is developed by the same guy that created symfony. 
Actually Symfony. There are many tools and bundles to help you building RESTful web service. Example: https://github.com/FriendsOfSymfony/FOSRestBundle If simple - Silex.
Not used it myself, but always wanted to put RedBeans "Beancan" to good use for this kinda thing. http://redbeanphp.com/extra/beancan_server
I think it has more to do with those people being insecure with their own programming knowledge. They need an enemy to bash to justify their language of choice.
I read Fabien's blog so I read a little bit about Silex but it doesn't seem like a REST focused framework. If I go that route I will probably have to figure out how to integrate other libraries aswel. Have you created any applications with Silex? What is your opinion about it?
You've got a great answer. I'd like to add that while its not really "php" per se, Hack is doing a lot to further php. Making a strongly typed language that php developers can get into with little to no resistance. I'm embracing Hack, it seems like what php should be, well at this point in its life. Also I work with a company (not for, but with, as a consultant) that has built their entire web development department around Wordpress. I'm constantly crapping on their practice. I tell them it's a cancer. Their "developers" can't even do the simplest of things... Like edit some CSS! Sometimes I force them to do the work themselves when they come to me for help on something little. Kind of a "I'm not going to do your job, you're going to expose your lack of qualifications eventually" those are the people that make php so bad. The people who say they work with php but couldn't write a "hello world" if their life depended on it. (Sorry for the rant, I just get a tad bent out of shape when I think about it)
I have been spending alot of time learning symfony. However, I think the learning curve is extremely steep and it takes me a long time to achieve trivial things. For now my preference goes to Laravel, eventhough it doesn't use Doctrine. It just seems like I can accomplish alot more in my limited timeframe with Laravel than I can with Symfony. Have you used Symfony to build a RESTful api yet? How long have you been working with it? Do you find it hard to figure out how to use bundles with it?
How much in common does the target image have with the potential matches? are the matches a 100% copy? are they partial? are they resized? There's ways to cheat if you have a simple idea of how they "match". If you're trying to see if a cropped section, slightly more compressed, matches a segment of a potential image, then you're in for a headache. if you're looking at duplicate images, then it's easy. The rest fall between those posts.
To be honest, these days pretty much any framework is equally powered to help you with a RESTful API. Most have RESTful routing (meaning they respond differently to HTTP verbs) and everything else is "can I read and return headers easily", which all of them of course support. Laravel has worked well for me on a few API projects, but play around. I would say that a combination of Symfony2 and Doctrine could lead to a VERY slow API. In general, any ORM is going to eventually slow you down so whatever you build try and separate out your models and controllers with services, so you can switch various data interactions. I usually start off with ORM for most of it, then switch out the slow queries with manual (raw) SQL or a stored procedures as I weed out various slow queries. Trying to do all of that up front would be a huge waste of dev time in most cases. Whichever framework you use, implement [Fractal](https://github.com/thephpleague/fractal). I've not seen any framework help you with this sort of thing so definitely look into it. Shitty and hardcoded data returns are one of my biggest gripes with most frameworks, regardless of which framework was used to build them.
Well I assumed you didn't from the fact that fapping to non-hentai wouldn't, uh, be very effective.
You obviously have not been on the internet for long.. people fap to anything. Even things that isn't considered "porn". Its porn to them. 
&gt; I like CodeIgniter because it is lite and it doesn't use an ORM for models by default fuck off you're dumb
True enough. I guess I'm just used to culturally impaired people who still go around calling all manga pron.
I've had good results with Silex + Doctrine2 + [swagger-php](https://github.com/zircote/swagger-php) [swagger-ui](https://github.com/wordnik/swagger-ui) is very useful in all stages of an API project, and many languages are able to bootstrap API clients based on swagger metadata. You could also swap out Silex for a [Phalcon 'micro' application](http://docs.phalconphp.com/en/latest/reference/micro.html) if you need more performance/capacity potential.
While its pretty easy to setup postfix, IMO you're better off using Amazon SES/Mandrill/Mailgun/etc. It's one less service that is consuming resources, needs attentions, and could be exploited or abused by malicious users.
Great answer, just want to pick up on this: &gt; Basic expectations in other languages, such as unit testing This is absolutely irrelevant to PHP. I've seen loads of codebases, including from large companies, in several different languages, that had no unit testing. If it's a "basic expectation" in any language, it's a basic expectation in PHP too.
This is pretty damned cool, I don't know why I ever put it together in my head (even though I've seen the Grunt shell task).
And notice that `ResourceNotFoundException` is *not* `&lt;Framework&gt;Exception`? Because that's what the question was *actually asking*.
Probably true, but if you have a look at job ads, and I have been because I'm in the market at the moment, you'll see that position descriptions for PHP don't mention unit testing ever, whereas ones for other languages frequently do. I can only go by my own experiences and locations, so this might be purely regional. My area is a medium sized city by world standards (Brisbane, Australia). Other than that, I can also speak of environments I've worked. In the last role I was in, there was a split team of PHP developers and .NET developers. The .NET developers had strict standards, used standard tools and frameworks, and had continuous integration and comprehensive unit testing. The PHP devs didn't even have a coding standard or code reviews. I get what you're saying, but (in my experience anyway) what you're describing is an exception in other languages compared to a rule in PHP. Your experience may well vary.
I know your pain. I took on a job briefly as "tech lead" for a small studio. They were doing everything in Silverstripe. Oddly enough they sneered derisively about Wordpress while actually doing the same thing in Wordpress 2.0. My first job there was to copy a site that hadn't been updated since 2007 (tables for layout, etc) and put it into Silverstripe. They didn't use Silverstripe for everything, of course. For really advanced stuff they used... CodeIgniter. After a week of this I decided this wasn't the role for me. I should note that this wasn't years ago. It was about three weeks. Sad place.
Wasn't intended to be a useful comparison. Was intended to illustrate that analogies don't always serve as useful guides and can be cheap and meaningless arguments to make. :)
I think that's getting a bit dogmatic, and that it's not as bad as you make it out to be. For instance, consider you have an `AbstractWidget`, and all children to inherit from it need a unique `label`. This value should never change throughout the lifetime of the object, so it's functionally a constant. Sure, you can implement the cruft for making a variable _act like a constant_ -- `protected $label`, `final public getLabel()`, etc. -- but you still can't guarantee that the value of `$label` won't change throughout the object's lifetime (unless of course you want to implement even more cruft). So you need a data element that's _constant_ for each child object, but can be accessed in a generic manner by a parent (or outside callers) -- `static::LABEL` solves this problem, with a minimal amount of code.
Thanks. I haven't done any web development for like 10 years so a lot of what I was doing then isn't as applicable now. 
Yes my experience does vary. Maybe I've just worked in shit companies ;) You are right that there is *less* unit testing or coding standards than in other languages (part of which is historically due to lack of good tools/IDEs). But I don't think it's anywhere near as bad as people are suggesting.
Yes because starting with something that runs as fast as possible is such a terrible idea. You prove my point very well. Complexity for the sake of complexity because most developers have less than 5 years of experience and are insecure. The emperor has no clothes and many of you have not figured that out.
This is exactly what I was thinking when reading that RFC. What does it provide that `ParamClass $param = null` does not?
There is a chance it could work, I'll need to have an investigate, thanks!
I love Medoo, and we've been using it in two of our projects, but I dislike that it doesn't seem to handle timestamps well. I'd like to set *=NOW(), and have to manually modify the class to allow this.
&gt; Yes because starting with something that runs as fast as possible is such a terrible idea. Why not start with machine code? You're as dumb as a bag of rocks. 
Are you a woman?
Are you mentally handicapped?
Yep I am arguing with a woman. It must be hard knowing that you can't compartmentalize. All those chemicals constantly working to thwart logical thought processes as emotion fights for dominance. Then children come into the equation and serotonin works against you all day long. It must make this kind of work nearly impossible.
I must admit that in the past I was rather dismissive of PHP. After recently working on a PHP project was really enjoyed using it, was able to make it as structured and OO as I wanted it.
Just search Medoo on Github. [https://github.com/search?q=medoo&amp;ref=cmdform&amp;type=Code](https://github.com/search?q=medoo&amp;ref=cmdform&amp;type=Code)
&gt; Indeed, IMO the community is most of the problem with PHP This is one of the largest problems. I have "watched" a few of the php chats, and people are just plain fucking rude to others. I've been doing PHP for over 15 years now, and I am still learning. But when I am in the chats and someone asks a question, I generally try to give the answer instead of the 'stop doing that, you are being retarded, use this, etc...' So much negativity coming from the leaders of these chats, it is painful to watch and I end up leaving the chat 
1. Most of PHP native method names are underscored. Except for last_query() and other protected methods, most of Medoo APIs are with only one word. 2. Just try and find out the difference. I believe the difference is obviously clear, if you are using it.
I'd love feedback on this, if anyone has any constructive criticism. I'll also answer any questions of use-cases, etc if anyone's curious about anything.
[official answer, please upvote] Hey swedish_cleavage (nice nickname btw), I'm the main author of php-login and want to answer your questions. Short answer: Everything you just said is either some kind of wrong or is described en detail in the extremely detailed readme and install tutorials. Beside that, the script is clearly labeled as NOT FOR BEGINNERS. No offending, I just want to help you sorting out the problems. :) Long answer: 1.) You say "the simpler versions aren't supported and they recommend using this version". That's not true, the simpler versions (one-file and minimal version) are highly recommended for beginners, and for sure they are supported, bugfixed and maintained. I don't know where you get this information from. Version #3 (advanced) is not supported anymore (except for bugfixes) as this is the natural lifetime cycle of software: if an improved version comes out, then there's no need to use or work on the old version. 2.) php-login is - as the readme, the install tutorial, the requirements list etc. clearly say - not for beginners. It also says that you need to know the basics of MVC, OOP, Composer and server setup. You say you are a newbie, so why are you trying to use this quite professional version, especially when there are 3 (!) alternatives that are clearly linked and bespoken right in the first lines of the php-login readme ? I really don't understand you guys. There are a lot of people in exactly the same situation like you, and they always ask things like "I started with PHP a week ago and now I don't know how to setup the script please help me.". 3.) php-login offers install tutorials for Ubuntu 12.04 LTS, 14.04 LTS and Windows 7/8. These tutorials are so detailed and explain even the most simply steps that it's just a copy &amp; paste job to install it, even if this doesn't qualify it to be used by beginners. 4.) "But I really want to run this skeleton website". Yes, and I want to perform dental surgery and build a 10-story building, but you cannot do this by watching a 5min Youtube video. You have to learn this for years, by learning, doing and working a lot. Development is a serious job and has nothing to do with creating a simple static HTML website. There's a reason why developers spend years in universities, have to read a lof of thick books, pass a lot of hard tests, and then, after learning this for years, they are still just more advanced beginners. Please accept that development is not a weekend job. 5.) When you already have massive problems following a copy&amp;paste-tutorial and have no idea what the code says, then how do you want to build a serious and secure application with it ? Do yourself a favour and don't do it, as this will just frustrate you and you'll end up with a horribly broken and half-working product. 6.) The problem you describe with SMTP, well, that's clearly described in all details in the extremely detailed install tutorials. There are also links to services that offer free or paid SMTP services and there are links to a tool that does fake-SMTP for local development under Windows 7 / 8. So what's your problem ? I really don't understand why you write a reddit article and search for hours fixing a non-existing problem instead of simply reading the install tutorial. Weeeird! To sum it up: Please don't use php-login, have a look at php-login-minimal or php-login-one-file instead. If they are not self-explaining to you, then jump deeply into PHP for some more years. Also consider working without a login system, maybe you don't really need it. Have a great day Chris 
https://www.quora.com/Do-a-large-majority-of-people-hate-PHP-solely-because-other-people-do-so
Is .htaccess already in git? If it is, you need to remove it from gitignore, remove htaccess, then add it back to git ignore. But you should not be using git as a release management tool. It works to a point, but you're abusing git and abusing yourself by using the wrong tool for the job.
Some argue that you should treat child classes as consumers of their base class's interface, in the same way you would treat external classes. In that respect, what you're proposing violates encapsulation. The base class has no need to know or care that the child widget labels are constant - this is an implementation detail of the child widget. Instead, consider giving your child widgets their own class constants that are exposed via protected methods using standard polymorphism. This allows the base class to do general things with the widget's label without knowing or caring about its constantness. In this way, should the label paradigm ever change in one or more child classes, you don't have to refactor your whole app.
Thank you so much!! I appreciate it! I found the need when working with large MAC addresses (they extend to an `2**64` (unsigned 64-bit) space, and PHP only has `2**63 - 1` (signed 64-bit) on 64-bit machines. 128-bit UUID's too. I was tired of writing code in both GMP and BC Math depending on the machine as the API's are very different. :/ This kind of library is also very helpful for crypto uses where larger prime numbers are used for more secure algos. :)
Similar to this there is a [php-unit plugin](https://github.com/ramon/guard-phpunit2) for [guard](https://github.com/guard/guard). Here is a nice blog article, that gives a basic overview: http://erichogue.ca/2012/09/php/continuous-testing-in-php-with-guard/
In that scenario, why even bother with parent/child relationships? What role does an abstract class play there? It also seems counter-intuitive for a provider/consumer paradigm to also share a familial relationship; I'm struggling to see how one could implement that and not break the Liskov substitution principle.
What would you recomend?
A continuous integration server like [Jenkins](https://jenkins-ci.org/).
I am from Eastern Europe, the guy is just plain retard...full on...there are those everywhere...
Thank you. The server is running CentOS 5.7 I saw the remi mentioned but wasnt sure.
Fractal seems interesting and something that I miss in my day job, however I don't see any documentation on how to transform incoming json back to an array/domain object. And I'm not quite sure I understand what you mean by hardcoded data returns. Can you give an example?
Thank you, definetly should consider incorporating swagger. Seems like a very useful library.
Session files are created empty, so I don't think this is a big problem. If you have a malicious client hammering pages on your site, you're likely to run into other issues long before you run out of disk space due to session creation.
Then you would know what Yep means.
The positive confirmation of a question but considering the trauma your brain has undergone it's not surprising its proper usage confuses you.
Jenkins is good, but a bit heavy. Your application should probably have a build script, if nothing else, especially if you use composer, need to set up and clear cache, etc.
Now I know you work with Feras Salim. Keep giving it away.
you're so dumb I feel I could do this enjoyably all day
I agree, that is a much better syntax. Now go submit a new RFC! ;)
PS: I put a **"Why?"** section in the README to answer this type of question.
Have you tried Codeigniter ?? its very useful for both frontend and backend. and there is another guy named Yii.. 
In a similar vein to Ghost is [Stacey](http://www.staceyapp.com/), a super light-weight file-based CMS that converts markdown text files into web pages. It's reeeeally tiny.
So basically you want to build a firewall within your app. That won't be helpful because each of those calls is still triggering PHP. I'd use a server-level firewall and/or [CloudFlare](https://www.cloudflare.com).
Many hosts have low default inode limits - [Servergrove](http://servergrove.com) comes to mind - that will have similar effects to filling the disk. 
Where'd you go? I feel like there is more fun to be had here, like I am entranced wondering how much more braindead shit I can get you to spew out of your vacant skull. Tell me about your parents: are they related in anyway?
After the failed RFC about decorators last time I think that the issue is kind of dead .. at least it'll need some more time before being raised again, and possibly a few issues addressed. :-)
&gt; Each way has it's benefits and **you should be intelligent enough to articulate both** ...and therein lies his problem, /u/Jack9 
At the moment TOP php micro framework is Slim framework. With some query builder interface - e.g. Illuminate component from laravel framework - you can create excelent and performant Rest Api. Don't use ORM in PHP it is not for dynamic langs - usualy queries are 4 times slower. I'm not sure if you are aware of Composer - if not you should definitelly try it. Cheers, Vukasin 
try finding your dick first
Best way to prevent it is to only use sessions if you really need them. IE for authenticated users. 
I've kind of wondered if this was a problem for other people as well. I'm using Redis sessions and have had this same "What if?" cross my mind. I went round and round until I came to the conclusion that this would probably be an issue for ANY web framework and is not unique to PHP. I then decided that the issue should probably be solved outside of PHP. I've not taken my research much further than that... But I know that if this issue does arise, I will not be looking to come up with a solution in PHP.
Link to my employee profile?
I had the same problem some time ago, that's when I found this beast ... `PDO::FETCH_PROPS_LATE` to the rescue
I have not tried CodeIgniter, however from what I have read so far it looks pretty much like a dead end to me. So I intend to stay away from it. Yii framework I read a bit about, didnt apeal to me that much.
Thanks for your advice. I am aware of Composer and fully intend to make use of it. Do you have any sources on the slowness of ORM's in PHP? Would like to read up on that.
I've heard nice things about KirbyCMS
As if I would take that bait. Not here.
Is there stuff between the open and close?
Why not take your own life instead?
That could make the job, but it could be hard to follow on the screen for the developer since it will continuously run. My solution has the advantage to only run on modifications.
IMO, don't have the drivers automatically return objects for you. Just return an array that gets wrapped by entity objects.
I always liked PHP because it's easy to get into as a first language. Error-handling is pretty nice and you see what you do immediately, without compiling. Of course it has it's downsides, but in the end, it's like the Mac vs. windows vs. linux-debate. All have their ups and downs, depending on what you want to do and what your preferences are, some make more sense than others. 
&gt; compare it, to begin with, with a different photo of the same thing Welcome to the pain side of the goalposts. You're going to have to do SIFT (or even try your hand at [SURF](ftp://ftp.vision.ee.ethz.ch/publications/articles/eth_biwi_00517.pdf)). SIFT in PHP would be absurd, so I'd suggest to try use something like [SIFT++](http://www.robots.ox.ac.uk/~vedaldi/code/siftpp.html) or it's newer version [VLFeat](http://www.vlfeat.org/) and use passthru or similar to obtain the results back from it. I don't envy this, mind, as it'll not be quick.
Thank you sir! Super helpful.
Consider WordPress with the Capsule plugin.
If you need to keep the file in the repo, use assume-unchanged git update-index --assume-unchanged .htaccess
If there is anything between the tags, such as a space, then php will automatically send the headers, and that will usually mess up your session and cookies.
A presenter model pattern is a class that uses a model object and provide view specific data. For example, if you have a member model and you have first_name and last_name. When you need a full name of the member, you could add a new method "getFullName()", but that should not belong to the model. That's when a presenter model pattern comes in. You pass a model object to a presenter class and the presenter takes care of formatting the data for the view. So..I think you're right. 
If this is a template file mixing html and php, go through and close any php tags that you open. Wordpress is such a birds nest of php code that you never know what might get loaded after this particular block of code. I've also found that it helps to use the alternative syntax for control structures in Wordpress and swap out if(){...} with if(): ... endif; it just makes the whole template process cleaner and easier to see where things start and end. If you find yourself mixing a lot of php and template snippets, especially in the functions.php file, you might want to consider putting those snippets in separate files and then including them within the function. Lastly, check that you didn't mix php tag styles &lt;?php vs &lt;? I've seen that cause a lot of issues with developing custom themes, especially if you move to a server with a much different php ini setup.
Thank you. Is using "template" in the context of Dora correct?
What's wrong with PHP's built-in sessions?
Using MemCache to store the session data works quite well too in addition to your suggestion. But I assume that if someone has the intention of DoS'ing your site, something else is more likely to break first than sessions filling up your disk space before the cron comes around to clearing out old session files.
Alright. I'm convinced. So how do we go about changing the type hinting to be postfix as well for consistency? 
Nothing. He's talking about the [PHP setting](http://www.php.net/manual/en/session.configuration.php#ini.session.auto-start) that creates/resumes a session automatically every time a script is run. 
Sounds useful; what's wrong with it?
Why bother? Because polymorphism. I agree that this approach seems counter-intuitive at first, but so does favoring composition over inheritance. Which is to say, it isn't the "natural" architecture that most programmers would instinctively lean toward, but when your object graph becomes significantly more complex, its benefits become much more apparent. I'm not sure what you meant about breaking Liskov, as nothing about this approach would break substitutability of child classes.
A few more things to help you appreciate the chosen syntax: - Consider anonymous function declarations using a C style syntax: $map = function array(array $data, callable $f){} This is a resolvable parser conflict, but this is still a pretty bad spot to be in where your return type looks exactly like the function name. - Consider the phrasing when reading and scanning a function declaration from left to right: function map(array $data, callable $f): array {} &gt; A function map takes array $data and callable $f and returns array. Compared to a C style syntax: function array map(array $data, callable $f) {} &gt; A function returns array, its name is map and takes array $data and callable $f and returns array. Not nearly as clear. - Consider the possibility of generics in PHP. One attractive place to put the generic information is just after the function name: function map&lt;T,R&gt;(T $data, callable $f): R {} With a C style syntax you can't put it there because the return type has already been declared: // PHP can't easily know this is a template until it reads &lt;T,R&gt; function R map&lt;T,R&gt;(T $data, callable $f) {} So what about something C++ like: template&lt;T,R&gt; function R map(T $data, callable $f): T {} I find this very verbose and pointless. The only advantage this has is that it is similar to C++ templates. It introduces a keyword and is really verbose compared to the first . There's absolutely no way that keyword can be `template` because it would immediately break every class out there named `Template`. Then there's the Java way, which as far as I know uses the command pattern and looks like: interface Mappable&lt;T,R&gt; { public R map(T data); } Which you then have to implement on a class. If this is for one time use then that's a LOT of overhead. 
What is the best way to bootstrap an application though? I can't figure out how to do this using vagrant. For example, If my project x is a small component in a bigger project Y, what I would like is for users to do "vagrant up", then they can ssh into the machine, run a script to privision component Y (any version they like), THEN provision the actual project x, inside of component Y. This means that project x is actually the only code of interest, and we're only concerned with how it behaves in component Y. If that makes sense, at this point. Obviously the best way is to isolate project x from component y and vagrant so it can be independently maintained, however, during this "bootstrapping" process, the best way to keep a component separate and decoupled on a filesystem, is to use symlinks to "inject" it into the bigger components (in this case, component Y). The problem is, symlinks are not support in a vm, in the sense that a symlink in the guest OS is a broken link in the host OS. Thus, development of the project kind of falls apart on the host since symlinks aren't followed. Any thoughts on this? 
All of my webservers are Ubuntu. Except for the Application specific ones that require IIS. Ubuntu is the bees knees for simple LAMP servers
Fractal is definitely just for output. Output requires typecasting data, pagination or cursors for collections, custom fields, specifying structure of data, etc, but input just requires bog standard pagination and saving of stuff like any other controller you've ever made. Hardcoded data returns being "I assume every podcast episode should include a full track listing", then another developer says "I assume every podcast should include the list of episodes." Then you're stuck with a list of podcasts, with a list of episodes, that all have a list of tracks! That should be flexible and requestable, which is something Fractal can do.
I am aware of that (use php-storm). It is that the list presented isn't as discoverable as it could be, since they are all top level functions it has no information to go on so gives me all of them, it is good that most of the array functions start with array, that helps, but I just find myself hitting the php manual more often then I do with other languages. It is a bit of a nit pick. 
I suppose it depends on the type of website. Some websites would want to store information for every visitor, some wouldn't.
Have a look at wp-includes/load.php in the wp_debug_mode() function and check that errors aren't being muted and/or logged to disk instead. This is a real pain point of WordPress the default error reporting is so relaxed to the point of making it a real pain to work with - enabling error_reporting( E_ALL ); ends up usually with a stream of warnings and fatals which you really want to see rather than hide away due to lazy programming. Did this recently for a website I was helping to fix, the amount of times the theme was trying to access array indexes that didn't exist - rather than simple isset()/empty() checks around said code blocks, which ends up being much nicer self documented code.
Interesting problem, one I hadn't ever thought of. And not unique to PHP either. I would probably tackle at the firewall or even web server layer. Nginx can do this very easily with the [ngx_http_limit_req_module](http://nginx.org/en/docs/http/ngx_http_limit_req_module.html) module. You could add the limiter to just the location {} block that does your FastCGI passing to PHP-FPM if you like. If you limit PHP requests to even 5-10 a second per IP (more than enough for actual real world site use from a single user) by the time a user hammers a PHP end point to the point of flooding the first bogus sessions they would have created would be garbage collected by PHP or even better something like this in /etc/crontab, which is what I do and then disable [session.gc_probability](https://github.com/magnetikonline/webserverinstall.ubuntu12.04/blob/master/00root/etc/php5/php.ini#L1454): find /tmp -name "sess_*" -cmin +24 -print0 | xargs -0r rm &gt;/dev/null 2&gt;&amp;1 
Have you considered why static languages don't allow multiple return types? Just something to think about.
Particularly with strings, arrays and other 'collection' style objects this is a very effective way to do thing. There are other cases, though.
If you read the RFC there is a significant lack of the word 'typehint' :)
Is a session needed for every new call to an API? Definitely not. When you start thinking of your site as an API things make more sense. You have a narrow view of the use-case for PHP. Also, the user details you seem to be referring to would be better stored and aggregated using an Analytics package. Google, newRelic, etc are all much better ways of storing general unauthenticated visitor data.
As the RFC author I think this fear is unjustified. Thanks for you comment, though.
I'm more talking about things like... That 'Flappy Bird MMO' website, or forums that allow you to post anonymously without logging in or signing up. Things that deal with *your* database and *your* business logic, but which would be shared equally with members and non-members.
This RFC actually opens the gateway for more type checks in other places. Let me explain it by example: class BinaryTree { public $value; private $left; private $right; function __construct($value) { $this-&gt;value = $value } function left(): ?BinaryTree { return $this-&gt;left; } function right(): ?BinaryTree { return $this-&gt;right; } function setLeft(?BinaryTree $node) { $this-&gt;left = $node; } function setRight(?BinaryTree $node) { $this-&gt;right= $node; } } Compare that to this: class BinaryTree { public $value; public ?BinaryTree $left; public ?BinaryTree $right; } There is likely at least one RFC that would need to be implemented before property types could even be considered and that's a sane property getter/setter RFC. Hopefully this example showed one way that this RFC is working towards stronger types for those who want it. 
One huge difference: PHP does not allow null to be passed to type declarations by default. In Java null is always allowed and they've been fighting it ever since. PHP is actually *better* than Java in this regard.
At the moment I know of no technical advantages of one over the other. As such, Hack is more relevant to the PHP community than C# so that's where it falls. I have begun correspondence with some of the Hack team members and I intend to ask them why they didn't follow C# in this regard.
The easiest thing you could do is make use of a linux server environment with PHP installed. Upload a PDF to a temporary space and use a command line tool such as [pdftohtml](http://pdftohtml.sourceforge.net/) to translate uploaded content to an HTML page instead. Use some CSS tricks to have it displayed nicely, and you're all set. 
I found it after I asked a question. Thank you!
I too use ghost and love it.
Do you have any examples of code? Also, do you know any website which is doing it right now? Newbie question: How are websites like SpeakerDeck designed? Tech stack and all? 
The Java way is actually `public &lt;T,R&gt; R map(T data)` - which is of course a lot worse than all the other possibilities, as far as readability is concerned ;)
Aha, I see it's even more useful than I thought. I understand now. Thank you for your suggestion. I will definetly make use of Fractal.
A forum with posting anonymously without signing up or logging in. I'm guessing you mean slashdot as an example of this kind of behavior? I would bet that you don't start a session on the slashdot site until logged in or submitting/commenting. There are reasons for this. (Technically, they are running on Perl, but the theory stays the same)
Precisely. Having PHP automatically start and maintain sessions is in many cases unnecessary overhead. Limiting sessions to where they are needed, ie. doing it manually, is often a more sensible approach. And in case my previous comment was misunderstood, there is nothing wrong using PHPs session functionality - just enabling it globally without consideration to where it is actually needed is a bad idea.
Thank you, I hope it helps! 
[AnchorCMS](http://anchorcms.com/) is pretty nice and lightweight
IMO AOP is a practice that should be avoided whenever possible.
Upload the image to S3 or similar and serve from there. Getting the file off your server is a security measure as well. S3 is dirt cheap and nearly free at low volumes.
I tend to disagree, since there are some very common uses for “static” variables. For instance, the singleton pattern requires static variables to be applied. see: http://en.wikipedia.org/wiki/Singleton_pattern
The "slow" parts of frameworks are typically the data layer. ORMs look great on paper but work for shit in real applications that want to be fast unless you massage them heavily. Knowing when to use the framework way and when to break convention is critical.
Can you be more specific? Returning arrays or returning field name indexed arrays?
Hm, I see. Thanks :)
We use both their API and their SMTP interface with complete success! I definitely mirror the recommendation.
Which is not an OO construct. It is a procedural pattern implemented using classes. Just because you're using classes, doesn't make it OO. OO is more about messaging and polymorphism. You lose polymorphism with static *anything*, therefore `Foo::bar()` will never really be OO (the one exception is `parent::blah()`). Which is why the OP said that static never really has anything to do with OO. Because it doesn't.
I went into far more detail about how everything is resolved in [this SO answer](http://stackoverflow.com/questions/151969/when-to-use-self-vs-this/17027307#17027307)...
Why?
just create a small memcache for php sessions, its usually the most convenient as you do not want to use local storage anyway as it sticks you to a single server
That could work, or an `array_merge`. I ended up wrapping that statement in an `if(!empty($data))` block. 
Hi, and thanks for your reply :) I found the tutorial, for some reason I gave up the first time around because it insisted on using EasyPHP and other programs which I didn't have installed, and I kept on getting lots of minor errors until I basically set up my PC to match exactly your recommendations :) Now it works, stage 2 is to understand the code which requires learning (as you say) MVC, OOP, Composer and some other things. I am hoping it won't take 2 years, I'm a smart girl! :D Is three months reasonable? I will be hopefully be able to delete some of the functionality which I don't need right now for my little website :) The reason for using the MVC pro version was that whilst my website is "simple", I am worried that people won't use the website unless I have a very professional structure and security. Do you think this is possible with the minimal version? I read the note on the advanced version: "Please also note: This version is not maintained anymore. The php-login project will focus on developing the Professional MVC Version and highly recommends you to also use that version." .. and I figured it applied for ALL versions except the Professional version. So because I really want it to WORK and be updated to be in line with the latest versions of PHP, I was worried about using the minimal version. I was thinking the large amount of initial work would "pay off" in not running into problems later, if I used the pro version. I saw that you guys wrote that you get tons of support mail from noobs, thats why I didn't write to you guys!. I was just hoping someone here had a moment of time to help a noob :)
This is a poor way to accomplish what it does. It creates a lot of problems because the entire class is static, which means that its state must be changed for every URL you want to traverse the HTML of. Just looking at the example code is enough for me to know that the implementation should be rethought. Here's a solution implemented practically the same way (except when setting the URL initially) using objects built from URLs that cannot change. (NOTE: This is still not the best solution. It does not follow the Single Responsibility Principle. It can be further pulled into different classes to encapsulate the URL and the individual Page, making the "Scraper" class only need once instance and do all the heavy lifting, and making Page a Data Transfer Object / Plain Old PHP Object) &lt;?php $url = "http://codetrash.com/category/php/79/accessing-controller-layout-inside-route-in-laravel-4"; try { $page = new UrlScraper($url); } catch(DomainException $e) { return Response::error('The URL to parse is an invalid URL'); } if ($page-&gt;isAccessibleUrl()) { echo "&lt;b&gt;Title : &lt;/b&gt;".$page-&gt;getTitle()."&lt;br/&gt;"; echo "&lt;b&gt;Description : &lt;/b&gt;".$page-&gt;getMeta('description')."&lt;br/&gt;"; echo "&lt;b&gt;Author &lt;/b&gt;: ".$page-&gt;getMeta('author')."&lt;br/&gt;"; echo "&lt;b&gt;Image &lt;/b&gt;: ".$page-&gt;getImg()."&lt;br/&gt;"; } else { echo 'Invalid domain'; } class UrlScraper { protected $defaultImage = 'http://codetrash/assets/images/sains.png'; protected $url; public function __construct($url) { $this-&gt;setUrl($url); } protected function setUrl($url) { if (filter_var($url, FILTER_VALIDATE_URL) === false) { throw new DomainException('The URL must be a valid URL format'); } $this-&gt;url = $url; } public function getUrl() { return $this-&gt;url; } protected function isAccessibleUrl($url) { $array = @get_headers($this-&gt;getUrl()); $status = $array[0]; if (!strpos($status, "200") &amp;&amp; !strpos($status, "301")) { return false; } return true; } public function getMeta($key = null) { $meta = get_meta_tags($this-&gt;getUrl()); if ($key === null) { return $meta; } return array_key_exists($key, $meta) ? $meta[$key] : null; } public function getTitle() { $contents = file_get_contents($this-&gt;getUrl()); $y = explode("&lt;title&gt;", $contents); $x = explode("&lt;/title&gt;", $y[1]); return $x[0]; } public function getDomain() { return parse_url($this-&gt;getUrl(), PHP_URL_HOST); } public function getFirstImage() { $html = file_get_contents($this-&gt;getUrl()); $doc = new DOMDocument; @$doc-&gt;loadHTML($html); $tags = $doc -&gt;getElementsByTagName('img'); $images = array(); foreach ($tags as $tag) { $images[] = $tag-&gt;getAttribute('src'); } if (empty($images)) { return $this-&gt;getDefaultImage(); } return $images[0]; } protected function getDefaultImage() { return $this-&gt;defaultImage; } } 
Firstly it seems pretty bizarre to dismiss an entire language just because the IDE you chose did a minor feature not exactly how you like it. I use Sublime Text, and honestly if anything I find it *too* recoverable! By which I mean it's always matching functions when I don't want it to; if I type "step" it will match "str_replace" since those letters appear somewhere within the function name.
Interesting. So why can I open and close php tags within the markup/template files? To be honest I started with php in drupal and then learned the basics of symfony. It wasn't until I started playing around with wordpress that I even knew you could open and close php tags as a method to output text. Also strange that the space between tags doesn't break anything on my localhost...
&gt; Note that mysqli_fetch_object() sets the properties of the object before calling the object constructor. http://us2.php.net/manual/en/mysqli-result.fetch-object.php There is also a blog post about the usage: http://zaemis.blogspot.com/2011/07/avoid-fetch-object-abuse.html I would say that this is an expected feature if it is documented. The easiest way to avoid this would be to have it return a stdObject (or array) and hydrate the objects yourself. I'd personally stay away from having to modify my constructors to check if things are already initialized. It nearly mimics setting scalar values on the object variables directly and you're not really getting any advantage to it over setting them yourselves. It wouldn't be very hard to write a method that takes an stdClass and assigns each value to it via __set(). EDIT: Here's why the "bug" doesn't seem to be fixed: https://github.com/php/php-src/commit/eb0de2af90bf4b2f07b56d48355e02b73e4c7ee4
On a side note, why is `get_meta_tags` even a thing in CORE PHP?
Then you dont understand AOP, or have never worked in a multi tenant app environment with significant shared complexities and "cross cutting concerns". When you have hundreds of client instances of an application, code replication becomes a serious management and design challenge. AOP allows you to separate your concerns to the degree that general 'plumbing' behaviors (logging, distribution, file generation, cascading events etc) can occur without reintroducing that replicated code into all of your code bases, and polluting your business logic. It is not code injection as a trick or a hack, it is your app making decisions and performing actions at runtime that occur across all implementations of your logic without concern for what is taking place in the business layer of your app. It allows you to write and manage those low level behaviors in one facet of your class hierarchy without having to manage duplication and replication of code, wich in a non AOP environment tends to lead to significant code fragmentation. It can be difficult to get your head around the approach, which explains your opinion and perhaps frustration in identifying why this approach is valuable or necessary. It's not for everyone, as it requires you to adhere to a strict separation of concerns, and truly design the functional 'aspects' of your app logic in a layered fashion. You may look at AOP classes and feel like 'wtf is going on here, the code doesn't describe everything that's happening'. Once you perceive the value in the approach, you may likely say to yourself 'thank god, I don't have to write X again, and I can focus solely on the specific implementation requirements instead of copying or retyping a bunch of procedural logic that has nothing to do with the model.' it's really about looking at your application as a set of interoperating applications, a stack; each handling separate aspects of the sum total application. Consider it. Php isn't particularly well suited for this approach, given its state of operation, but it can be done and done well. Short of writing your own AOP framework, Go is one of your better options to be sure. 
PHP is a language built on web. It has been part of it since PHP 4. Meta is information much like headers, so it was probably implemented as part of the URL functions for that reason: http://us3.php.net/manual/en/ref.url.php
I get the header ones, as you don't get them easily, but getting the meta is as simple as one regular expression...
The mark up files aren't included until after the headers are sent, so it's fine to do that. The difference between your other host could be the session auto_start setting.
It looks like a helper function from the pre-release days of PHP (written in 1999, PHP 3?) Regex wasn't implemented until PHP 4
But isn't that already built-in php with magic methods? Are you saying magic methods are unnecessary given a properly abstracted code-base? 
See, that's one of the problems with PHP - you put silly stuff like that in THE CORE. There is no need to add functions like that that only serve one purpouse, are rarely used and can be written by hand in 1 line. It's like adding: function pre_echo($string) { echo '&lt;pre&gt;' . $string . '&lt;/pre&gt;'; } to the CORE of the language.
Amazing, detailed answer! I know that AOP is very promising technology and try to do my best to implement it well in PHP. Of course, there are many use cases where traditional OOP will be enough, however cross-cutting things always annoys me, so I try to separate them into more reusable classes and this can give me more clear code and overall control over the application. Thank you for your answer! Really like it :)
Thank you. Will keep that in mind. Just an FYI, I am not trying to build something like SpeakerDeck, just a small service for teachers.
This is the best way. Look into mockery or prophecy which are really good mocking libraries. What I did for my Symfony site was I changed my controllers to services (there is a symfony2 tutorial on this) and inject my repositories as services as well. This means doing away with the service container, and injecting things like templating, routing, whatever you need (which you can mock too, or get from the service container in your tests). 
IMO, the wrapper pattern is a better option than AOP. It allows you to achieve the same results: execute A before B, execute C after D, return the result of D when you execute B without changing the API. http://stackphp.com/ implements it. 
In a general use case you'd want to display some sort of user information / link on every web page, so a session has to be started on each of them.
Regexes are generally a bad way to deal with XML/HTML. There are some valid use-cases, but it's so easy to get into trouble, ESPECIALLY if you're scraping different sites which may have malformed HTML. 
Sounds like homework to me :)
http://us3.php.net/manual/en/language.operators.arithmetic.php
In most web application and modern frameworks you always need a session and you often store data for every visitor. I never had any problems with session storage.
well to be fair you even can do a lot of crap with java. And I have seen plenty of horrible C projects. 
Octopress is terrible, give a try to Sculpin maybe (PHP based).
I would call that a presenter. A template is more about structure and less about logic. Imho.
I really need to install dora and see what it does exactly, but I agree with /user/dwitte.
Introduced in the PHP &lt;= 3 core, probably before the language became public.
Why are you insisting to confuse "views" and "templates"? Also, why the hell you are using procedural paradigm?
Force of habit.
I'm getting a russian hosting site frontpage. Am I missing something?
sonarqube is pretty good. I know it has PHP support, but I've only used for javascript and C#. You should give it a try.
Its something I've been looking into recently too Apparently PHP Code Sniffer is quite well respected.. https://github.com/squizlabs/PHP_CodeSniffer There's also PHP Mess Detector, but I didn't look into this too much because the default rules were not to my tastes http://phpmd.org/
If you can, always use a third party with email. Email is a huge PITA and not an easy problem. Getting it off your infrastructure and away from the concerns of your ops is well worth the cost of whatever platform you use This also gets around the issue of your IP possibly being black-listed by a previous tenant (which is a higher probability on hosting which re-uses IP addresses as they add/drop servers for users - think Amazon EC2). As a bonus, you usually get reporting, email sending re-tries, and can use usually an API instead of slower direct SMTP connections. I'd add a queue on top of this so you don't send API requests out to email platforms in the same request cycle (less waiting for the user). However again, that's up to your application constraints and how much server management you can do. Note: I stated that pretty definitively, but of course always use whatever works best for you given whatever constraints.
(Then your concern is more centered around DKIM and SPF records, which just boil down to some TXT records on your DNS and are usually explained pretty well and provided by whatever email service you use).
They lack reporting and fancier features you pay for from other providers, but you get a very very cheap price and pretty good reliability in return. Like anything, there's a trade off - features vs price in this case. Depending on the level of reporting you may need in your application...
Magic methods and AOP address different problems, but are certainly part of the implementation in php. Honestly, php is a poor basis for example because of the language architecture; traditionally AOP is implemented in a language that supports multiple inheritance (C++, Lisp, Python) or supports mixins like Java. Traits in php is probably the closest you can get, without using annotations or runtime class composition (which is all that traits are doing under the hood, rewriting a file to disk with the traits embedded into the materialized using class). Multiple inheritance has always been met with controversy, but it's typically misunderstood, because implementation examples are usually very case specific, and dont solve simple, easy to digest problems. Therein lies its power though, when things become sufficiently complex, new ways of looking at things become necessary. I hated it until the moment I fell in love with it. One of the bigger 'aha!' moments in my 15 or so years as an engineer, and it didn't come until about year 10, when those sort of epiphanies start to grow pretty scarce. I think its the absence of those new challenges that make someone start considering a shift to the managent track. So I'm grateful for the approach, it's kept things interesting, and fosters an elegance in writing code that I didn't even know existed up until that point. And it's kept me out of management, but allowed me to demand a six figure salary at management levels, while still doing cool stuff (TM) on a daily basis. Another thing, if you are selling your software as a service- it makes it easy to encapsulate and sell plugins or modules that you can literally turn on like a switch; true ala carte application packaging. I could go on ad infinitium, my point is, it has a valid use case, and it could save your bacon someday, so I think it's Ill advised to simply write it off as sleight of hand. You just may need it. 
The pleasures mine! Thanks, I like what you've done, and to be honest, I ended up scrapping a framework I was working on 2 or 3 years ago, once I came across Go, because it already handled most of what I had planned on doing myself in the first place. Thanks for saving me some time, nothing is more valuable than that, most days. 
I've set this up for PHP. Definitely useful for tracking how your code metrics change over time. You can get graphs for phpcs output, code coverage, etc. Highly recommended.
You can try http://www.sonarqube.org/ , which has many language supports including PHP. Though I haven't tried any custom check myself, most probably you will be able to. 
&gt; elobaret elaborate No offense; just in an anal-retentive mood.
Though AOP based code can be sometime difficult to track/understand, still, I guess, AOP is doing its job to separate concerns very well.
Hey! Sorry, I caught the flu and haven't used a PC since the day I wrote that last comment. I have not used Laravel, so I cannot personally recommend it. However, in my view, Laravel is part of the modern PHP toolkit (PSR interop compliance, namespaces, Composer, testing, etc.). I haven't gotten around to giving it its fair shake because I have a lot of other things that I've been learning, that to me are higher priority than Laravel for the moment
That sounds like quite a good setup you have at work. I use PHPStorm as well, how did you integrate phpcs with it?
What's wrong with CodeIgniter...?
We do so similar at our work. It's a bit awkward as you need php installed on your machine. Google phpstorm + code sniffer. It pretty simple to set up. Specify the path to phpcs in project settings, click ok, then specify which rule set you want to validate your code against.
Except for performance and enforcing variables and documenting your code, of course... 
It's terrible. CodeIgniter is drastically out of date. When CI started to get out of date and really lacked features that were needed for modern development, it was forked, and developers added them. And even **that** project (called Kohana) has now been stopped. CodeIgniter is so old that even its child is out of date. I'm guessing that your question is being asked because you either use CI or you don't use anything and were looking into it. Unfortunately for anyone using current modern PHP frameworks, CI is kind of... Fisher-Price. The appeal is clear. It's very easy to understand, and lacks "magic" that abstracts functionality. However, that magic is actually super great. CodeIgniter is missing a lot of key features: composer, autoloading, an ORM, migrations, routing, built in support for JSON and REST. I watched a CodeIgniter tutorial a while ago and actually laughed out loud a few times.
That's not dirty. That's called abstraction.
&gt; The only way i could think of is to make a new class that implements the interface and is coupled to the vendor class and then use it here, but that solution seems a "little" dirty to me. That's pretty much it. You create a wrapper class that wires the functionality up to use *your* interface. The injected class has to implement your interface otherwise it's not going to have the right methods for you to call on.
[Adapter Pattern](https://www.youtube.com/watch?v=qG286LQM6BU)
What about using a ramdisk?
that was my first idea, but i wasn't quite sure how to do it.
No, PHP does not share any of it's memory unless you use the specific shared memory functions (shm_ etc.). 
oh interesting, thank you :D
Yep, like I said, that part is more controversial. I actually kind of agree on templates. I think two parallel questions get tangled up when talking about PHP templates. One is whether you need templating of any kind at all. This one is the clearer cut, in my opinion. In order to get the benefits from MVC you need to split into clear layers. Not just in terms of files and behaviour, but scope and structure. It should have discrete objects handling presentation and views, it should create a specific scope for that view, and inject in the required data. The other argument is whether that template system should use native PHP controls or some other syntax. This is **not the same argument** as above, it's unrelated. I've always been against templating engines that use drastically different syntax to PHP, such as Smarty. The argument seems to be that they're "easier", but I think that's silly. {foreach from=$myArray item=foo} or &lt;?php foreach($array as $foo): ?&gt; Why is the first syntax somehow easier? It's really about the same. Additional syntax serves no real purpose. Where syntax changes are necessary for matching/parsing purposes such as Laravel's Blade, keeping syntax basically the same with `@foreach($array as $item)` seems reasonable. So when people talk about "PHP is already a templating language" they can be saying two different things. One is that introducing new syntax and limiting the presentational capabilities of PHP for no reason is something to be avoided. The other is that they don't see the benefit of a clear separation of concerns, or thinks that doesn't apply to the view layer. The first argument is valid. The second is, I maintain, woefully ignorant. As for the framework argument... I do and don't agree. I don't actually agree with your point about frameworks. IMO development in a modern framework should almost always provide more benefits than downsides, and while there is a level of commitment required to invest the time in a framework, I really don't think it's the "till death do us part" that it's often seen as. I personally think you get a better result with an end-to-end solution like Laravel than you would with disparate libraries. That said, you have an opinion and can argue that well. That's really fine. But there are an awful lot of people out there who will say "Meh, I don't bother using frameworks *or libraries* because I prefer to write the code myself so I really understand it." I suppose I've seen a lot more dumb criticisms of frameworks in general than I've seen reasonable support for it. I also have seen a lot more people saying that you should do **nothing** in frameworks than I've seen advocating using the appropriate tools for the task. I agree that there are situations that frameworks aren't suited for. But I also suggest those are edge cases. Probably an "agree to disagree" situation here. :)
It depends on the OS. Look up tmpfs you are using a Unix-like system.
Why do you have to write any files to the filesystem? Can't you just POST your XML data directly? Here are some examples: http://stackoverflow.com/questions/5647461/how-do-i-send-a-post-request-with-php
Yeah, this is the Adapter design pattern. You have object A that needs to fulfill the contract of interface B, you make an A-to-B adapter. The A-to-B adapter will have object A as a dependency and expose all of the methods from interface B. This is why it's a good decision to make interfaces for your dependencies. If you type hint on an interface instead of an actual object, you're contracting to the behavior of the object and not the object itself. Later, if you want to change the actual object, you can just make an adapter to corral your new dependency into that behavior.
You should probably run a packet capture and check out what the difference between the two methods of POST is. If your server is running Linux, I would use tcpdump on it to sniff the communications and write them to a file, then download that dump locally to poke through it with Wireshark: https://workaround.org/using-tcpdump-and-wireshark It's probably something weird with Transfer-Encoding or a failure to set the Content-Type header.
I was in Portland last year, and watched a discussion of Stack. I like the approach, but I don't so much like the dependency on Symphony/ HTTPkernel. I wont even open the door on having several hundred instances of Symphony deployed and the performant issues associated with that, but that could become enough work to require a full time position with the sole responsibility of maintaining the framework deployments. Not fun, especially if you're the New Guy, and this gets dropped in your lap! I will agree that the proxy / decorator pattern (which I'm assuming is what you mean by wrapper) does address many of the same problems that AOP attempts to solve, and is probably the approach that should be taken in MOST cases, when the complexity lies below a certain threshold; This is fine when you have a couple interfaces and 1 or 2 logging and caching decorators. The problem comes in when you have several hundred interfaces and implementations, you have potentially hundreds of caching and logging decorators as well, with much of the same boilerplate code replicated over and over again. With AOP, those several hundred interfaces and implementations still have only 1 instance of the aspect, or intercepting class. Instead of deploying/replicating your codebase once for every tenant, you can have a single shared core, that materializes classes at runtime on a per-tenant basis. This significantly cuts down on the replication of systemic code, not to mention the management problem of making 1 small change to your logging interface, which with decorators, you'd have to apply to EACH deployed instance. That could mean hundreds of edits; Invariably, this leads to fragmentation, either by human error, or design. If you are not looking at this level of deployment/parallelism in your code, you probably don't NEED AOP. Thats why I'm not arguing that AOP is 'better' than a proxy, simply that it solves a very specific use case. 
Most frameworks don't come with "all the necessary screens," for any functionality. A framework is just a collection of utilities that help cut down on the repeated-work from project to project. For example, your framework will probably include Routing, Mailing, Logging, Sessions, etc. Generally, the front-end is up to you. You can either look for a CMS with this functionality built in and try to work in your data layer, or find a framework you like and write your authentication front-end yourself. 
hmm this is probably a better idea to explore than my own. thanks :)
Yes, framework is probably not the best word to describe what I'm looking for. Maybe "starter site" is a better description. But just something that has all the user security screens done in a secure way. I'll look into CMS options but I think that may be overkill for what I'm looking for. Thanks!
Layers upon layers of abstraction...
Here is one: http://stackoverflow.com/questions/4439541/how-to-improve-doctrine-performance-plain-sql-is-4x-faster
The more I think about this, the more I strongly dislike it. Not the concept of decorators or annotations, etc, mind you, but the concept of using them as typing mechanisms. The reason is that since it's user-land code, it only really benefits runtime checking. Whereas engine-supplied checks (like proposed here) would enable static analysis and compile-time optimizations to occur.
dont create files, just post them .. theres no reason in this process to ever create a file ... use CURL for posting it to the destination
that's what i'm doing, but for some reason when i posted it to the other guys website it didn't update properly.
well ... have them log the xml they received i'd always assume your script is right and theirs isnt :)
Practically any CMS will already have a complete user system built-in for you to use, for better or for worse. If you simply do not want to deal with that crud, look for a flexible CMS to work with instead.
Sounds like a problem with your headers. When you hit your script from a browser you should be prompted to download the xml file.
Why not use either a shared db or cache? A shared db as well as cache are even accessible if you move one website to another server eventually.
And don't close the PHP tag at the end of PHP files, it's discouraged because of the possibility of accidentally outputting text (like a space) before you want to output headers. PHP doesn't require the PHP tag to be closed unless you're about to output something.
[php/manual/shared memory](http://www.php.net/manual/en/book.shmop.php). The process control extensions are generally fascinating and underused. Also doubtless a minefield for the unwary. 
Yes, they would be runtime options. Although there is nothing stopping a static analyser from being aware of the decorators and their meaning; that could be inferred from the content of the decorator itself and the domain it'll allow through. The problem I'm having is that PHP has, since the introduction of type hints, moved closer to being neither a flexible dynamic or a typed-ish language (Java does the latter better). For PHP I wished we'd have implemented native casting hints instead of type hints, and instead relying on errors being thrown when an invalid method is called (based on duck typing instead). But it's kind of hard to argue against "more type information is always a good thing" as it will always feel "more correct". It'll enable analysis in the compile step, it'll ensure that you receive "correct" classes as arguments and back (.. and it'll still be runtime checked when running the actual PHP code, because of the (still) dynamic nature of PHP and it's paths - it'll be useful for hints to JITs, though). Each step does however make it less dynamic and flexible.
This one provides what you want: http://emr.ge
A mystery, wrapped in an enigma, wrapped in a function, wrapped in a wrapper. We're through the looking class here, people.
I thought that PDO with named items meant that injection attacks weren't possible? Unfortunately the htaccess won't work for me as this is nginx and not Apache :(
Well, if you use [Google](https://google.com) you will find there are plenty of these around. Just use the keywords "sentry" and "bootstrap". Here is one from a member of the Cartalyst team though, [https://github.com/brunogaspar/laravel4-starter-kit](Laravel 4 Starter Kit).
Much appreciated :-)
&gt; Most of you redditors have condemned the use of PHP saying it is badly designed and there are better alternatives (Python, Ruby etc.) You're thinking of /r/programming. This is /r/PHP. I think many here in /r/PHP acknowledge some flaws in PHP, but think most of the criticism out there is based out of ignorance about how far PHP has come over the last few years As for anyone caring about the launch of PHP6, yes I believe a subreddit dedicated to PHP would care about this.
i thought it was supposed to add proper unicode support? but...that's what i heard years ago.
nope. not worth it. the fact that it would break all existing apps and libraries also means that it breaks all future apps and libraries -- who's going to start a fresh project and not be able to use anything? no framework, no nothing. plus...get over it. php is a hodgepodge of messily named things. i'm starting to embrace this. makes me feel not so bad when i realize i named one of my own functions pretty retardedly.
The guys who are complaining about PHP are still stuck in the year 2002. Old dinosaur programmers.
The guys who are complaining are not stuck themselves, they just assume PHP is. 
Thats not happening in 6. 
yep! That's precisely it. 
In some respects maybe Facebook's [Hack](http://hacklang.org/) is the new PHP6. edit: oh wow sorry if I offended.
Save a copy of your local output and ask them to test loading that file in?
This is simply not true. PHP could quite easily (afaik) decide on a common API standard and then alias "backward compatible" versions of functions with a notice -&gt; warning -&gt; error. For example, `is_array`, `is_empty`, `is_null`, 'str_to_time', `str_case_upper`, `str_case_lower`, `str_case_title`, `json_encode`, `url_encode`. Trying to use `empty` or `ucwords` would give a notice. Nothing would die. Nothing would break, but we could move forward to being less... *frankly embarrassing*. And it's nonsense to think that no frameworks would work. Currently in-development frameworks would of course update. Yii 2, Phalcon, Laravel, Symfony, these would all (imo) **embrace** the opportunity to clean out BC clutter from their codebase and would probably happily provide 5.8 and 6.1 versions. Wordpress and CodeIgniter won't work? What a tragic damn loss.
It was going to. Most of its features were rolled into 5.3, a lot of the unicode stuff was scrapped. There is no roadmap for any concept of PHP6.
There is no such product, it's purely speculative.
&gt; The only way i could think of is to make a new class that implements the interface and is coupled to the vendor class and then use it here, but that solution seems a "little" dirty to me. Nope, that's not dirty. Take a look at [PSR-3](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md) and you can see that PHP's best and brightest are trying to accomplish the same thing.
Silex + Symfony Security component. There are great docs to get you started. 
What I would love to see, was that they started putting a lot of those methods you mention, onto the objects instead: $myString = "Hello World"; $newString = $myString.str_to_lower(); echo $newString; //hello world that would also eliminate a lot of the parameter-order-hodgepodge. 
I've just posted on this, but yes, I'd love to see PHP6. I'd love to see a version of PHP with a more mature and consistent API. I'd love to see a version of PHP that I didn't have to say "Ha ha ha, yeah, it's weird, huh?" to critics, or look up argument order for basic functions. I'd love a PHP that didn't have functions named like my "version control" in 2003. mysql_real_escape_string = final_site_logo_actual.jpg. That's some dopey shit. I'd love a PHP that instead of creating new functions like `mt_rand()` defined as "Generate a better random value" instead made `rand()` less shit. rand_new_better_final()? I'd love a PHP that didn't have dumb duplicate functions for what could just be arguments. ksort and krsort, arsort, asort, sort, rsort? Seriously? Personally, and feel free to criticise me for this, but I'd like a PHP where Rasmus Lerdorf didn't have the opportunity to repeatedly fuck it up. I'd like a PHP where backward compatibility was a reasonable consideration, rather than a thought terminating cliche. 
 $mystring.lower().replace('cat', 'dog'); After all, it's on a string object... It looks a bit javascript at that point, but it's still a reasonable expectation, imo. And yes, I agree. That would be ideal. I would like to see a lot of PHP's global functions moved into objects, and the global namespace pruned. And this sort of thing could be **added** to the language. IE, no BC breaks, just new features for now and deprecation of old syntax.
lol you said nothing downvote worthy... don't feel bad. Have an upvote, although I would probably disagree with that statement :D
Whats the difference? 
&gt;still not up to scratch with my usual languages (Python, JavaScript, Erlang). &gt;(Python, JavaScript, Erlang). &gt; JavaScript &gt; JavaScri.. *facepalm*
&gt; but just a mention that PHP6 will be released sometime this year. It will not be released this year. The new major PHP version is being discussed right now. What you probably saw is a remainder of what was planned for PHP 6 years ago: this (old) v6 and the development branch related was abandoned (because of problems while converting the codebase to support UTF-8).
This looks interesting. Checking it out now.
PHP itself is pretty portable and this script is fairly simple. If it runs on your machine it would run fine on a production one. But as you mention, using a Virtual OS you can simulate a production environment more closely. A virtual OS runs as a window as a "guest" in its "host" OS, and is a fully working version of the guest OS. This way you can, as an example, run Windows XP as a guest while on a Mac (host). Virtual boxes can also run 'headless' (without the 'window'), so that you only talk with your virtual environment from the command line. Vagrant is the only example I know of this, though I'm sure there's more. I would suggest you [try out Vagrant](https://www.vagrantup.com) to get the feel for a headless virtual environment, their instructions are crystal clear on how to get a vagrant box up and running.
A bit off topic... but, yeah, I agree.
I've used Silex as a Rest micro framework and it works nice.
If you pay attention, there's significant communities which care about well-designed architecture within the JavaScript communities. Certainly, ReactJS is a brilliant toolkit for managing UI components, and node.js has some very good libraries for managing stream-based and service-oriented architectures. It's not a tool for all uses, by any means - I tend to augment it with backend code written in other languages - but for some it has a very solid community of people using it for serious work.
Somebody is stuck its either PHP or the dinosaur programmers. (and i can argue its NOT PHP ) What is your point? If they assume they are as good as stuck
I like this library. Thank for team!
No disrespect to the OP, but are we really still making posts about basic composer functionality? 
You should see /r/javascript. "=== versus ==" "always use ===" "weird javascript type rules you need to know" It never stops.
I've never had any particular issues with JavaScript's variable scope. Nor variable lifecycle, for that matter. Maybe I just don't write the sort of code that is affected by it? The OOP design might be a mistake, but is easily patched over by use of a library where necessary. Additionally, I never attacked PHP as a language. I commented on practices which popular PHP frameworks follow which I do not feel are up to scratch with the practices that frameworks and application designs for the languages that I use tend to follow. Whether the language has warts or not is entirely irrelevant; I think PHP as a language isn't particularly bad, although it has nothing special, and the "throw the state away after every request" design makes it difficult to write most apps I tend to write.
&gt; and the "throw the state away after every request" design makes it difficult to write most apps I tend to write. I'm sorry but you come off as an idiot. There is a reason that 82% of the web is ran by PHP[*](http://w3techs.com/technologies/overview/programming_language/all). If "throw the state away after every request" was on the menu how do you login to websites? Do you know what web sockets are? 
I don't write 82% of the web, so I'm not really sure what you're getting at. I write applications which have real-time requirements, which constantly have data from a multitude of sources flowing through them, and for which it is very useful to have state held in the application even when there are no requests to the server. Simple website development is a solved problem in the majority of cases. I could offload my temporary state to Postgres or Redis, but that doesn't solve the entire problem, nor is it particularly performant, nor does it let me stream from Input X through System Y to Websockets A, B, and C without a complicated architecture, probably involving an external message bus. I find this very easy to do in languages which do not throw the application's state away between requests. Additionally, given the fact that PHP requires a full OS process per request (unless you skip being able to use any major framework and build a web server into your PHP app), it is a very poor choice for a websocket server.
Well I still see "namespaces in php" posts come up a lot. its sad
The version numbers themselves mean nothing to me - but if you look back at all the point releases (5.3, 5.4, 5.5 and soon to be 5.6) the features added at each of these milestones have been pretty awesome - e.g. 5.5 added generators which I'm in absolute love with and can't live without now. So keep the features coming - it's all good :) In the end PHP 6 will just end up being another point release but if you then compare PHP 5.0 vs. 6.0 as a feature set the difference is going to be huge anyway.
It really depends. If it provides compelling reasons to upgrade, the transition will happen.
Redis would/could be good here - push your data blobs onto a redis LIST, the second system can then POP the data blobs off the same list. 
I swear, Brandon Savage's website feels like one big advertisement.
This sounds really nice, doesn't it? Realistically we have to break it down to costs and benefits; this is where your suggestion breaks down. The costs are high and the benefit is minimal. Another major point is that a PHP programmer should be able to reasonably write code that works on PHP 5 and PHP 6 simultaneously; you can't break too much code at once. That doesn't mean that they won't have to adjust any code to work, just that it should be very minimal. If you change too much you end up like Python 3 where it has taken 5 years to catch on and is still missing lots of libraries. 
&gt; redudancy of inventing a language within a language Like Puppet.
You'll have to sharpen those sticks yourself buddy. :)
I don't even know how to respond to that. Polymorphism is *the* fundamental tenant of OOP (with encapsulation being a VERY close 2nd). Without that, you don't have anything. To say that it's defined by inheritance is simply missing the point of it. You could argue if inheritance is needed or not, that's up for debate. But that polymorphism is necessary for OOP is not up for debate (it's agreed upon by pretty much everybody in the industry). Every paper, text book, etc all contain references to polymorphism in the context of OO. And considering static constructs are not polymorphic by very nature, my original point stands. Static methods/variables are not OO constructs. That doesn't mean they are bad. It doesn't mean they are useless. It just means they don't fit the OO paradigm. They are perfectly useful in procedural code.
Again, as has been said many times, Singletons are not object oriented constructs, as they are not polymorphic by nature. Just because it uses a class doesn't make it OO. And just because it uses an "object" doesn't make it OO.
I'm pretty sure you mean the [Decorator Pattern](http://sourcemaking.com/design_patterns/decorator). Names do matter...
Are you describing differences in programming languages by pointing out differences in frameworks? If you are then that is completely irrelevant. If you aren't then I am confused by your statement. &gt; got really frustrated at practices which are still not up to scratch with my usual languages (Python, JavaScript, Erlang). Interesting. Like what? I program in Ruby, Python and JavaScript daily and have done for years. Not sure what you mean. &gt; There's generally a lack of flexibility in the frameworks, along with a lot of magic. There are lots of frameworks in PHP. Some focus on convention, some focus on configuration. Use whichever you prefer. &gt; In fact, even where Symfony 2 has been designed for flexibility, there's a couple of places where it entirely negates that, especially in the authn/authz layers. What the shit is authn and authz? &gt; I feel that the multitude of dependency injection frameworks are a poor idea Lots of people release PHP code. That has nothing to do with PHP as a language, and competition has never been something I would use as a negative factor for a community. &gt; It's not so easy to understand the app as a whole when it's hidden behind a DI framework which parses comments and YaML files. Oh yeah I definitely would not like a DI based on YAML, but after programming with PHP for 12 years I've never used one, so that is not much of an issue. I guess I have no idea what your point is, but you said a few weird things that made me want to say... what?
They had a hard enough time getting most standard web hosts to upgrade to PHP 5, and that was with minimal breaking changes. Considering a great majority of PHP development occurs on these cheap, run-of-the-mill hosts I can't see the transition to a breaking release of PHP 6 going smoothly.
I'm just gonna put this here. http://philsturgeon.co.uk/blog/2013/08/php-static-analysis-in-sublime-text
Well, I never said it isn't *art*.
Thanks - we'd really be looking to run it alongside a continuous integration suite but useful info regardless!
Don't have any idea about that, sorry. But CI tools like http://www.cloudbees.com/ , which have code analysis as part of their steps, might have include that.
mysql_* was deprecated a long time ago. look how well that worked out. new users are *still* picking it up. it's not worth deprecating things just to rename them. 
When I was looking for a job over Jan (contracting), almost every job I applied for asked for Unit Testing, and my lack of experience (Because I hadn't been in a job that Unit Tested before) was a sticking point for those jobs. Not sure if it's because of the pay grade I was after, but I think the market is moving towards Unit Testing a lot more. Or at least the jobs you'd *want* to work at
lol, I just reused the previous poster's syntax without even looking at it. Of course the fluent $myString-&gt;lower()-&gt;replace() is correct, and mine is hilariously dumb. In my defence I've been writing more javascript lately than PHP. :)
STOP RUINING MY FOREPLAY
This is a post from another discussion, and I think apt: It's terrible. CodeIgniter is drastically out of date. When CI started to get out of date and really lacked features that were needed for modern development, it was forked, and developers added them. And even that project (called Kohana) has now been stopped. CodeIgniter is so old that even its child is out of date. I'm guessing that your question is being asked because you either use CI or you don't use anything and were looking into it. Unfortunately for anyone using current modern PHP frameworks, CI is kind of... Fisher-Price. The appeal is clear. It's very easy to understand, and lacks "magic" that abstracts functionality, which can confuse learners. However, that magic is actually super great. CodeIgniter is missing a lot of key features: composer, autoloading, an ORM, migrations, routing, built in support for JSON and REST. I watched a CodeIgniter tutorial a while ago and actually laughed out loud a few times.
&gt; I'm guessing that your question is being asked because you either use CI or you don't use anything and were looking into it. Neither. When I was evaluating frameworks years ago I chose Cake. Then switched to Django for a bit. Dabbled with Node and ASP.NET MVC. Laravel brought my back to PHP-land, but I'm not entirely sure I've made the right decision. It's easy to work with and featureful, but there's some shoddy code under the hood, and it's a little bit slow.
I am not against you moving with Slim or Symfony. But do checkout https://github.com/auraphp/Aura.Web_Project if you are only looking for a web based application, if you need web + cli checkout https://github.com/auraphp/Aura.Framework_Project Currently in beta for v2. Build with some components like Aura.Router, Aura.Web, Aura.Dispatcher and Aura.Di . Very light and don't have any other dependencies. You can use any ORM ( Doctrine, Propel etc ) via the composer and integrate with the framework or you can use Aura.Sql itself. Good documentation from the eyes of me, we have a bunch of good contributors from the PHP http://auraphp.com/contributors/ As it is build on top of components you can replace any components if you need. See how you can create REST routes https://github.com/auraphp/Aura.Router/#attaching-rest-resource-routes
To be honest I've never been a fan of learning through someone screen recording, or really by video. It just feels like the wrong format for something that you really have to try out yourself. I find the documentation on the PHP Manual of 5.6 features to be good enough to get started on the new features
I sometimes watch programming videos as a tv show. Very cool to see how other people approach a problem. 
Off-topic: is that php storm running in presentation mode? 
&gt; Neither. As previously mentioned, that comment was a copy and paste from someone else asking about it. &gt; there's some shoddy code under the hood Can you clarify what you mean by this? I personally think Laravel is great, but I'd be interested to know what you consider "shoddy" here.
I stand corrected.
I find videos really helpful to get a general overview of something that I'm completely new to. Works much better for me due to my shitty attention span. Most things are tl;dr for me. I find a video with speech and visuals is much more engaging, and therefore easier to concentrate on. The joys of being a programmer with ADD! Of course to "learn" these things properly, I'll need to follow up with actually doing them. So when I'm actually working on something and want to find out something specific, text will always be better.
yes
You need to define it as *global $product;* if you want to use a variable defined in another file.
&gt;If you look all over the interwebs you'll see "tutorials" in how to do basic things in PHP, like getting data from a DB. These tutorials often use techniques that are out of date, deprecated, and/or insecure. &gt;Agreement on a number of coding standards has made frameworks more interoperable, and allowed an impressive array of great systems such as Symfony and (my preference) Laravel. Unit testing, static analysis and disciplined development focused on maintainability and code quality has become the expectation at least in more enthusiast circles. I'm a self taught developer, more or less forced into this field. For us the biggest problem is not even being aware of the existence of good practices, bad tutorials and community "help" from other beginners aggravates this problem. The core team should acknowledge the fact that many php users aren't trained programmers, who need early guidance to avoid becoming "cowboys", and make official resources point to or reference some good resources like phptherightway, the PSRs and some of the current frameworks. I know this would require agreeing on what is considered good and that simpler problems have been buried by endless arguments, however official endorsement (i.e. being prominently displayed on the central php.net site) would certainly improve the situation. Make good resources more easy to find for those who cannot yet judge good from bad and don't even know what they should be looking for.
yeah in theory but not in practice, hired guns are just that and they will often do everything to the wire and leave you with code that has little chance of extending or building on. When i write code i write it to grow as the project does.
This is actually a very good point. Unfortunately, PHP seems to have a philosophy of being pretty much agnostic to usage. Instead of encouraging specific practises it tends to simply provide the tools and leave usage up to the programmer. I think that's... unfortunate, but reasonable. It leaves it up to the community to encourage and teach good practise, which is what PHP: The Right Way is all about. I do agree that links from the official site would be helpful, though, I have to say.
Sorry but this is complete bollocks. You'll more than likely end up with an unmaintanable pile of spaghetti code and spend a lot of money throwing it away and rewriting it all.
I wanted to avoid making variables global. I think i have a pretty nice workaround: function template($template,$vars){ if(is_array($vars)){ foreach($vars as $var =&gt; $val){ $$var = $val; } } ... } that way i can define which variables i want in my template
Instead of that loop use extract(): http://de3.php.net/manual/en/function.extract.php But why don't you use a Templating Engine like Twig (http://twig.sensiolabs.org) or something like Plates (http://platesphp.com). Anyway, you code would be much more concise written like this: function template($template, array $vars = array()){ extract($vars); ... } 
Totally this. Video tutorials are great for manual tasks or to explain GUIs. I never understood their appeal for programming.
&gt; A presenter model pattern is a class that uses a model object and provide view specific data. [...] You pass a model object to a presenter class and the presenter takes care of formatting the data for the view. Isn't that typically the job of the controller in a MVC architecture? Why would one need a separate pattern for this? 
Ditto. I really can't bothered sitting through a ten minute video when I'm sure I could pick this up in a more interesting way that is (importantly) more likely to take hold in my brain.
Be sure to either use a prefix (the 4th parameter to extract), or use `EXTR_SKIP`. Otherwise you can open a very significant security vulnerability. For example: template("foo.php", array("template" =&gt; "bar.php")); Without using a prefix or `EXTR_SKIP`, it would overwrite `$template`, and hence include a different file from the one you're intending. So, either extract(["foo" =&gt; "bar"], null, "prefix_"); echo $foo; // undefined echo $prefix_foo; // bar Or, $a = 1; extract(["a" =&gt; "b", "foo" =&gt; "bar"], EXTR_SKIP); echo $a; // 1 - since it would have overwritten, it skips. echo $foo; // bar 
This may be a bug. That's fine. But you shouldn't be using functionality like this anyway. Magic construction and population? No thanks. Instead, write your code in a clear, and explicit way. Do not leverage magic. Make it easy to read, and easy to understand. $data = $result-&gt;fetch_assoc(); $entity = new Entity($data); It's far more clear, far more explicit, and relies far less on magic. Better code FTW. As far as the bug still being present, add a test case for it, so that regressions don't happen again.
&gt;Instead of encouraging specific practises it tends to simply provide the tools and leave usage up to the programmer. I think that's... unfortunate, but reasonable. Quite. In a way this is separation of concerns, which is good; developers should keep to development. I can relate to the feeling of not wanting to get caught up in, for lack of a better word, brand management. Nevertheless, if the community is concerned about the criticism the language receives due to poorly educated programmers, part of the core team should be engaged in helping spread good practices. Some of the organizers and creators from outside should be invited in as a... department...? I'm not sure about the wording, but hopefully the point is still understandable. Microsoft has MSDN, frontend technologies have MDN, why couldn't we have somehing similar, connected to the main site? We wouldn't need to link every good article from the main site, just link to this would-be PHPDN where useful links, practical descriptions of available features, etc... could be collected.
Never again.
&gt; Can't the compiler simply infer it and detect it's a function or const you want to use rather than having it to explicitly specify? No. Take for example: namespace Foo { class Bar { } function bar(); } And: namespace { use Foo\Bar; bar(); } What should be run there? The import is for a class (since all imports are always for classes). But you don't know if you wanted it to be a function as well, or not. That ambiguity is the problem. You could argue that it should be both, but then that would be a MASSIVE BC break, as it would also muck with function hoisting (not needing to prefix the function name with the root namespace for global functions). You could argue that it's bad practice to have functions named the same as classes or constants. But the point is that from the language perspective, it's impossible to know clearly, hence it doesn't try to know. Take another real world example from [my CryptLib](https://github.com/ircmaxell/PHP-CryptLib/blob/master/lib/CryptLib/Hash/Hash.php): use CryptLib\Hash\Hash; if (Hash::isSecure($algo)) { return hash($algo, $data); } In that case, the class clearly is pointing to the cryptlib one, but the `hash` function call could be pointing to cryptlib, or it could (correctly) be pointing to the global one. Hence why "can't the compiler simply infer it" isn't possible. Not robustly at least.
When i want to crunch things, i will definitely go directly to the docs but watching or listening to casts is a relaxing (especially jeffrey way) way to passively get some information you probably didn't wanted ASAP. it's not always about efficiency 
Authn and authz are common shorthand for authentication and authorization. I believe that there's a few places in Symfony 2 where although it uses interfaces, allowing it to be extended to allow for alternative authorization rules, it actually checks to make sure that what's passed to it is a specific class. Some further googling suggested that the developers refused to remove this check, because it was there because they didn't trust their framework's users to implement security mechanisms properly. I have no particular issue with PHP as a language, but you can't look at languages just for their syntax; especially within the context of imperative, object-oriented, dynamic languages, the libraries and how developers approach their code tends to be much more important. I can cope with any syntax, and most reasonable patterns, but I don't have the time to write tons of library code because the existing libraries are inflexible. Can you point me towards a decent, full-stack framework (along the lines of something like Django) that doesn't try to force me into a DI framework or restrict how I can use it like Symfony 2 does? I'd like to not run into this issue next time I get the idea that PHP might be useful for a project to whatever reason; I used Symfony 2 because it seemed the current most popular full-stack framework, and various people on this subreddit seem to be under the impression that it follows current best practices the closest.
For anyone else like me who would prefer a text version, [I found a text version from the official PHP website](http://docs.php.net/manual/en/migration56.new-features.php).
Wouldn't it be better to avoid doing that entirely?
You shouldn't rely on variables defined in random places. Even if they are not marked as "global" that is basically what you are doing. A better way would be something like this: // config.php includes functions like getSite() that return the appropriate value include("config.php"); // include the template $site = getSite(); include("templates/{$site}.php");
You could say that. :-)
&gt; Can't the compiler simply infer it and detect it's a function or const It would be kinda crazy for PHP to do that. ``` define('foo'); function foo() {} class foo() {} ``` If I then say... ``` use foo; ``` Well, which do I want? It could be any of them. Just the one that is defined first? That would mean if I was expecting a function and somebody elsewhere happened to declare a constant with a matching name earlier in the proceedings then suddenly I would be using a constant as a function... app-splode! It's not nice, It's not pretty, but it is the card PHP has dealt itself, and it does make sense.
Everyone learns in different ways. Seeing, hearing and doing are all important in varying levels to different people. Many could look at a manual and have a go, some benefit from being shown exactly how to do it THEN having a go at the manual. It all works.
Yeah of course, you do both. 1. Check your code while you're writing it. 2. Run unit tests, lint checker and all that jazz again before you push. 3. Have CI catching all incoming commits to run them again, and potentially run more / slower tests. It's all the same tools each time, they just get triggered in slightly different ways. 
I'm using http://jumpstarter.io for hosting PHP demos just like yours. It's free until a limit.
I didn't even realize PHP allowed such namespace collisions. I always assumed having a function and class of the same name in the same namespace would generate an error... you know... because sanity. For your last example I would expect a developer to have to use the global namespace prefix on \hash() else receive an ambiguity error. 
Well, unless there's some dark magic I'm unaware of then this code doesn't do a whole lot of anything. You are missing &lt;form method="POST" action=""&gt; &lt;!-- your select and options go here --&gt; &lt;input type=submit&gt; &lt;/form&gt; wrapping around the select tag. Then when someone clicks the submit button your form posts the selected option, which then gets read into the $picked variable. There are other ways you could go about it to make things more dynamic. You should be able to add an onchange="myajaxcall()" to your select tag, and then have in your javascript function "myajaxcall" read the currently selected option, POST with ajax to a file that only handles spitting out the result of the sql query, and then update a div on your page with the result of that ajax call. tl;dr you don't seem to actually have any way of posting the selected option.
There's also #phpc on freenode.
Wow, uhm, Thanks! I should delete this Post, because I feel stupid now.. thank you!^^
Also, note that this "fix" never actually reached a production version of the software. It was added in the [5.3.3 cycle](https://github.com/php/php-src/commit/614fd65795468be21901581e2962510620fcf5b4). And reverted in [5.3.3RC1](https://github.com/php/php-src/commit/eb0de2af90bf4b2f07b56d48355e02b73e4c7ee4). As far as why the revert, you'd have to ask Johannes.
The test case that was present was deleted when the fix was reverted here: https://github.com/php/php-src/commit/eb0de2af90bf4b2f07b56d48355e02b73e4c7ee4 - so re-adding a test-case isn't going to help if it's just going to be removed again. The common answer in this thread is to not use the driver in this way, to return data from the driver and then wrap it with the Entity, as you said. I agree that that's probably best, because it is more explicit and you're not relying on the driver working correctly (or even some drivers that don't have this functionality). That doesn't, however, negate the fact that this is certainly weird and unexpected behavior, even if it is documented as such.
Good catch - I did not see that. 
I think breaking backward compatibility is generally a bad thing, for obvious reasons. But damn it can be a frustrating roadblock at times.
I think you should build it in CodeIgniter, why learn a new framework when CodeIgniter does the trick? 
I feel the same way. Videos are so inefficient. In the time that video takes to play I could have read and absorbed 5 times that information.
Why Phalcon? Why HHVM? Premature optimization much?
If this is your first project on the new job, I would stick with what I know: Build it in CodeIgniter, and learn a new/better framework after that, or on the side. 
I suppose I'll go with what I know since this is a short deadline and look at the roadmap for the future thereafter. Thanks, everyone!
I think it would take more that 4-5 weeks to learn. Even though Symfony 2 rocks, it can be complicated and unruly at times - and the fundamental change in philosophy versus other frameworks can really slow things down for some.
CodeIgniter is no longer supported. Unfortunately, anything built on that framework at this point is already obsolete...
Wise decision...
shh it's what op wants to hear
I love ghost, but not NodeJS. :(
Nothing really dirty about that. As per /u/moonpi3's post, what you're describing is an adapter, and it's a very common solution to exactly this problem. What can feel dirty is if you have a big library and you're trying to make one big adapter that almost wraps the library 1:1. The way you should be tackling this problem is via the interface segregation principle. The process for this is fairly simple in theory, but harder in practice: 1. Let your client code dictate the interface it needs to use. You don't tell it what interface it wants, it tells YOU what interface it wants. If your client codes has a single, focused responsibility, then chances are it will need a simple, focused interface. E.g. Valet (client class) might have a parkCar(Parkable $Car) method. In order for the Valet to park the car, it needs to perform a few actions: shift(), move(), turn(), park(). Since this is what the Valet needs, then that's what Parkable should define. 2. Implement that interface in an adapter called AutomaticCarAdapter which takes say, an AutomaticCar (the 3rd party library) as a dependency. If you had a manual car, you would create an adapter called ManualCarAdapter that takes a ManualCar (different 3rd party library) as a dependency. 3. Do whatever you need to inside of those 4 interface methods to translate the Valet commands, into results of the 3rd party library. So even if the AutomaticCar and ManualCar libraries are 8000 lines long with hundreds of different methods, that makes them shitty libraries, but adapting them to the interface the Valet wants is trivial since that interface is highly focused and cohesive. Thus you as a developer never has to write behemoth wrappers for huge libraries, and your client code never has to be exposed to anything other than what it needs to accomplish its task. Maybe you need several different adapters/interfaces that a single massive library can satisfy, but at least your domain code is well segregated. 
Just bash it out in CodeIgniter and have another run at it with something else further down the line. The framework choice for simple applications is often not all that relevant. I'm not sure what you mean about the Laravel syntax though. If its statics they are optional. If you're taling about the blade template engine, that is optional too. :) 
can't cite specific examples without compromising my identity :P but i've found functions in the source which simply won't work given certain (valid) arguments, or depending on how the dice rolls. I wasn't even looking for them, I was just perusing the API (since much of it seems to be undocumented) and stumbled across some fishy looking code. it's not *completely* terrible, but it was immediately obvious when I saw it, so I don't know why it would be written that way in the first place. there's also a few inefficiencies here and there. nothing that can't be fixed though. my biggest complaint with laravel right now is that it's not very IDE-friendly. even with [barry's IDE-helper](https://github.com/barryvdh/laravel-ide-helper), there's a few things PhpStorm cannot compute, particularly in the Schema and Query builders. oh, and I don't like the way they did models. AFAIK, the framework has no idea which fields are available to it, or what their types are because they decided to go with this willy-nilly whatever-the-database-gives-me crap. I get that it makes it all nice and agile, but I prefer to work the other way around. specify your fields in the model and sync it to the database ("code first"). instead you have this stupid `getDates` function which forces you to list out all your date fields anyway, and I don't think it supports any other data type. more-over, they should have used joins and left-joins for one-to-one and many-to-one relations so that you can orderBy them. also, you can't alias the table names without fucking everything up which makes writing joins (which you have to do manually) and selects ugly... except that they *can't* do that, because the field names might conflict, and they can't alias the fields to something unique because of the aforementioned reason -- they have no idea what fields each table contains.
Yes, this is a problem typically handled by a [stateful firewall](http://en.wikipedia.org/wiki/Stateful_firewall), which is designed to apply rules &amp; heuristics to distinguish legitimate application traffic from any attacks (as opposed to a static list of ports to block like in simple routers).
It's "Creating an object of type" and it's a non-standard way. I'd say the only discrepancy is that this "feature" would be impossible to replicate in a user defined function, and is instead a "feature" of language level library. The fact that it's documented on the [php.net](http://us3.php.net/manual/en/mysqli-result.fetch-object.php) page means it is an intended (if unexpected) behaviour. You may not like it, but it doesn't mean it's a bug.
Phalcon and HVVM should not even be on your mind. Phalcon (and HVVM) are designed for projects where you need to get a lot of performance out of the same hardware as compared to standard PHP. They should not be used for a project getting the traffic of Twitter, Facebook, Google, etc... There's no real need to use it and if there is, then the issue is more likely in the logic and not related to the runtime. Sticking with CodeIgniter would be my recommendation. However, if you have the time to learn another framework: try Laravel. The API is very similar with the advantages of the Symfony core. CodeIgniter lacks a separated system due to the coupling between all of the components and the super object $CI. Sticking to a familiar to you is almost always the best way to meet your due date. 
Im the same way, mainly because many people recording videos do it "live" and basically fire from the hip, so you get a lot of "whoops!", "hold on", "uhhhhhh", "ummmmmm", &lt;random chatting with people on skype in the middle of explaining something&gt; followed by "where was I?", and it makes me want to murder my keyboard with my face. Jeffrey actually plans out his videos, and edits them to be nice and terse and to the point, so I enjoy watching his casts. Other random YouTubers? Nope nope nope nope.
For a member...do you really have just one single page that displays a member's full name? If that's the case, it would be okay...to format a data in a controller method. If you use the full name more than one places, why would anyone want to do that in a controller method, making a fat controller? 
It may have been "fixed" by someone who didn't realize it was intended behaviour, and that's why the "fix" was reverted. The definition of a bug is "unintended behaviour" so if it's intentional, which it clearly seems to be, it's not a bug. It's possible it started as a bug and was kept as a feature, but that seems unlikely in such an integral piece of code.
&gt; video I find that I can't really learn anything by video. I want text and diagrams that I can go over at my own pace. With videos I spend more time managing the pace of the playback than actually paying attention. Either it's going too quickly, or much more likely, it's going way too slowly, causing my focus to wander.
Can php://input read multipart/form-data POSTs yet?
Regex is slow.
I think in that case it'd still be acceptable to have the model "process" the full name, since it's still data relative to the model after all. I guess the presenter is one of those patterns that make sense in certain very specific use cases, e.g. if there's an gigantic amount of model data formatting logic needed in multiple controllers.
I would delegate. Personally, I have a well set-up email server with reverse lookups and trusted keys. But for anything outside my normal domains I delegate to Amazon SES. Their free tier lets you send up to 10,000 emails per week, I believe.
or you could go with some "microframework" like silex or slim. This does not take long to learn but you have to be sure about your own architectural skills.
Well, I personally think that's not acceptable. Why does a business layer has to concern about a view specific data? And why does the view has to know about the entire business layer object? It just doesn't make sense. I mean..unless you're working on a simple blog app...it's really bad practice to mix up the view specific methods into your model. I'm not saying you have to use a presenter pattern. My point is that whether you use a presenter object or not, it's not a good idea to have a model to represent your views.
There are a couple of advantages like type hinting and better static analysis. But you are right, it's mostly syntax sugar. Sweet syntax sugar.
If I want to programatically call this (say I wish to write a DBA layer wrapping MySQLi): http://www.php.net/manual/en/mysqli-stmt.bind-param.php I can't unless I use call_user_func() or variadic argument passing. There are a tonne of these examples in both the baked in PHP methods and external 3rd party libraries.
Git? You have a 'commit' phase, but no version system can work without it - otherwise when does the tool know when to take the version snapshot? But the idea of 'check out' - hell, that hasn't come into my vocabulary since Microsoft's pathetic source safe? Or well, possibly if you wanted to do "exclusive lock" on a file in SVN - another turd of an idea. Maybe a a read over at /r/git - but it will be all Git based, probably wont be getting help on alternative solutions.
What I need is just saving the file = commit... that's what my current app does and another that worked worse did. The option to only grab one change every 10 minutes would be fine too (one app did that). Thanks re: /r/git - I'll try that if nothing comes up here =) And yeah - I think it was MS VSS I was using... no choice, corporate shop years ago lol
You could set this up with git easily enough but fair warning, automatic check-ins aren't the *greatest* idea. If you create a git repository and then run: git commit -am "Checking in at (put a timestamp here) " &amp;&amp; git push It would check in all your changes every hour with a timestamped commit message.
If this is seriously what you want, just use dropbox or any other cloud storage solutions. Other options would be to use git, but have a watched running in the background that committed for you on each file change, really OTT though and i'd question the usefulness of it when reverting. Is it really that hard to commit at a point when the changes are meaningful? I mean you'll get so many error prone revisions it would be a nightmare to find the one you actually want.
What you are describing (automatic saving on file change) is not what version control systems were made for. You are probably better off using Dropbox if that's what you want.
Local git repository
Don't delete this, because it might solve a problem for someone in the future.
Since you mention windows, I recommend subversion + tortiosesvn + trac. It won't automatically checkin, but it does decorate directories directly in explorer so you can always see if something needs to be checked in. Also, with any version control system, it is simple enough to write a script that will run once every hour/day to do a checkin. And it won't pollute the history with empty checkins if nothing has changed. Trac is nice wiki/ticket/project management/etc. system that integrates well with subversion. You can use it to view and search history. However, I strongly recommend against automatic checkins. You should get into the habit of manual checkins. No only would the changesets themselves make more sense (features/bugfixes/etc wouldn't be unnecessarily split between changesets), but it would encourage you to add meaningful comments for each changeset. 
 interface ParserInterface { public function parse($input); } interface TwigInterface { public function parseTwig($input); } interface SmartyInterface { public function parseSmarty($input); } class Parser implements ParserInterface { private $_parser; public function __construct(ParserInterface $parser) { $this-&gt;_parser = $parser; } public function parse($input) { $this-&gt;_parser-&gt;parse($input); } } class TwigAdapter implements ParserInterface { protected $twig; public function __construct(TwigInterface $twig) { $this-&gt;twig = $twig; } public function parse($input) { $this-&gt;twig-&gt;parseTwig($input); } } class SmartyAdapter implements ParserInterface { protected $smarty; public function __construct(SmartyInterface $smarty) { $this-&gt;smarty = $smarty; } public function parse($input) { $this-&gt;smarty-&gt;parseSmarty($input); } } class Twig implements TwigInterface { public function parseTwig($input) { } } class Smarty implements SmartyInterface { public function parseSmarty($input) { } } $twigData = "twig"; $twig = new Twig; $parser = new Parser($twig); $parser-&gt;parse($twigData);
That is amazing!
 ON News.id = Users.author_id'; You're almost there, but the IDs being joined up aren't right. Without knowing more about the table I can't tell you which one of these is more likely to be correct; try them both and see if one works: ON News.author_id = Users.id'; ...or... ON News.author_id = Users.author_id';
Thanks for the link mention, joellarson! Relevant paragraph for those who might not want to click through: An object is a data structure that encapsulates variables to maintain state and related functions to manipulate the state. A stdClass data object just collects values and then exposes them as public properties. It does not observe proper encapsulation, there is no state, and there are no methods to interact with the object. It is no more than an array that uses object-syntax. My rule of thumb is: if you call mysql_fetch_object() without specifying a class name [to "hydrate" an object instance], you're "doing it wrong." I wrote about mysql_* at the time, but the same holds true for MySQLi. 
Documentation is always a question for any approach. That would not be relevant. As for performance, PHP5 in and above there is negligible performance difference. http://stackoverflow.com/questions/15688633/php-array-or-objects-to-store-data-what-is-better-solution
I wish people would explain when they down vote. Is this not as good of an idea as it sounds? I am looking to hit the reset on my development process as I still do everything from notepad and manually configured headless servers. When using Vagrant as a dev env what do you use to edit the code?
I tried it it gives the error "You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near 'FROM News INNER JOIN Users ON News.author_id = Users.id' at line 2" my tables are like this: Users: | id | name | email | password | avatar | type | News: | id | title | info | author_id | date | 
&gt; Users.author_id, FROM Get rid of the comma in there, you are telling MySQL to expect another column to select but giving it nothing. There should be no comma after the final column when you proceed to the FROM portion, so use: $sqlJoined = 'SELECT News.id, News.title, Users.author_id FROM News INNER JOIN Users ON News.author_id = Users.id';
now it's telling me "Unknown column 'Users.author_id' in 'field list'"
/u/shaunc and /u/Pejoo Thank you so much for your help!!! :)
 $base_dir = realpath(__DIR__ . str_repeat("/..",6) . "/"); It was a joke people. ಠ_ಠ
You make synced folders from virtual machine and just edit those files on your host machine with any editor you want.
I don't think you understand what a commit is intended to do. It's not intended to capture every time you saved a file to disk, it's intended to capture some changeset representing identifiable functionality, improvement, etc. There's zero value at all in preserving every every save without context. If you're too "adhd" to use a basic workflow that's been proven to improve work quality, stability, and recoverability, then you need to go find another profession. No joke.
Why would you need type in a dynamic language?
There isn't much, if any. The difference is how the different server programs are packaged together and what the app to configure and control them looks like. One is as good as another, you just need to spend a small amount of time learning how to setup.
Some explanation might be useful. This is for a web based game. The game has a config file, which today is an ini file. Those settings are then stored into the database, and later, when the game is running, the settings are pulled from the database and used. When you use things like "true" or "false", and try to do a ===, it doesn't work. Yes, we can (and have) worked around that issue, but its not ideal. Hence, we'd like to be able to store the data as its correct data type, but haven't found a good solution.
Create your own development environment in your system &amp; write some sample code. Check out the following links &amp; select any one according to your OS type. https://www.apachefriends.org/index.html http://www.wampserver.com/en/ https://www.mamp.info/en/ For any kind fo DB transaction try to use PDO(http://www.php.net/manual/en/book.pdo.php). For all rest DB related stuff Google can help you a lot. 
Maybe use a gist or something? or at least format your stuff in your post as code... that is really hard to read.
You could store your configuration in just a straight php array. Similar to CI and Laravel. I'm sure there are other frameworks that do it. &lt;?php return [ 'maxPlayer' =&gt; 500, 'isAFunGame' =&gt; true ]; Then in your application code you can include the result: &lt;?php $configs = require 'config.php'; 
Honestly unless you're already an experienced developer in some other language (and that doesn't sound like it's the case), then I'd recommend you simply explain that you don't know PHP and hope for the best. If you go into a coding test on a 2 day crash course, you're just going to make yourself look bad (if the company has any clue). Believe it or not, but writing good code is not easy, and I've worked with / interviewed many engineers who don't do all that well even after years of practice.
We were originally using a php file for it, and at the time, I felt like it was too complex for the average game admin to dig into. But I have to admit, it seems to be the most functional choice that is still close to straightforward to edit.
As other's noted, if you just want automatic saves, dropbox would do the trick. However, there's a lot of power in learning git, even just locally. Ever been working on a project and have a moment of brilliance where you want to try something out? You start hacking on it and 3 hours later realize that you've gone waaaay off course and it's not really right? Then you spend the next 40 minutes finding every weird change you made and code you refactored cleaning it all out hoping that you're not deleteing away something you really did want during those 3 hours? Here's how that works in git: # on master $ git checkout -b awesome-new-idea # hack for hours $ git add -A &amp;&amp; git commit -m 'That was awesome and fun, but ultimately not quite right' $ git checkout master # You are now back to the "safe" very you last worked on You can branch a very, very large number of ways and merge them all back together in so many ways you *will* get lost. But after you've gotten it down and wrapped your head around it you're going to want to version control **everything**. Plus, it's a marketable skill. One last thing, for auto commits to git there is also [SparkleShare](http://sparkleshare.org/) -- a very fancy auto-commit+ui on top of, guess what, git!
dead simple and yet nobody is using this -- can't understand why
Thats even less clear.
&gt; Are there any good solutions that I'm missing? Yes ... you are a programmer, therefore ... program ... Given the following ini: # my ini is better than yours, yes my ini, is better than yours foo = bar baz = fat [strings] foo=bars bar = yes please baz = "qux" [numbers] double = 2.6 integer = 1000 [booleans] truthy = yes falsy = no upper = TRUE mixed = False quoted = "Yes" squoted = 'No' This code will parse it: &lt;?php function config($file) { $config = []; $lineno = 0; $pointer =&amp; $config; foreach (file($file) as $line) { $lineno++; $line = trim($line); if (!$line || $line{0} == "#") continue; if (preg_match("~\[([^\]]+)\]~", $line, $section)) { $pointer = &amp;$config[$section[1]]; continue; } if (($var = preg_split("~=~", $line, 2)) &amp;&amp; ($var = array_map("trim", $var)) &amp;&amp; (count($var) == 2)) { if (is_numeric($var[1])) { $pointer[$var[0]] = (strpos($var[1], ".") !== false) ? doubleval($var[1]) : intval($var[1]); } else { if (preg_match("~^\"(.*)\"$~", $var[1]) || preg_match("~^'(.*)'$~", $var[1])) { $var[1] = substr($var[1], 1, strlen($var[1])-2); } switch (strtolower($var[1])) { case "true": case "yes": $pointer[$var[0]] = true; break; case "false": case "no": $pointer[$var[0]] = false; break; default: $pointer[$var[0]] = stripcslashes($var[1]); } } } else throw new \RuntimeException("parse error on line {$lineno} of {$file}: {$line}"); } return $config; } var_dump(config("../test.ini")); ?&gt; And produce: array(5) { ["foo"]=&gt; string(3) "bar" ["baz"]=&gt; string(3) "fat" ["strings"]=&gt; array(3) { ["foo"]=&gt; string(4) "bars" ["bar"]=&gt; string(10) "yes please" ["baz"]=&gt; string(3) "qux" } ["numbers"]=&gt; array(2) { ["double"]=&gt; float(2.6) ["integer"]=&gt; int(1000) } ["booleans"]=&gt; array(6) { ["truthy"]=&gt; bool(true) ["falsy"]=&gt; bool(false) ["upper"]=&gt; bool(true) ["mixed"]=&gt; bool(false) ["quoted"]=&gt; bool(true) ["squoted"]=&gt; bool(false) } } You could do a better job of quoted strings and maybe choose a different character to comment lines, but doesn't sound like your users will be escaping quotes or know what it means to escape a quote ... sure you can work it out from here ;)
I don't get it. Isn't syntax ...$bars available only in 5.6? And if you use Bar ...$bars you tell that $bars arguments will be all Bar?
You should learn about XSS, or cross site scripting. Basically if you are writing anything in PHP, you want to prevent any data that comes from a user to ever be presented on the page. This allows malicious users to inject javascript and other executable code into your script. So that $_POST variable is stuff that I can just push into your server, and you're displaying whatever I tell you to. That can be all kinds of bad in a lot of scenarios (maybe not this one as its very simple and not saving my bad data anywhere, but its a good idea to learn the concepts) One of the top hits on hacker news right now is a link to a github search that shows all the people using PHP in an insecure way. "https://github.com/search?q=exec%28%24_GET&amp;ref=cmdform&amp;type=Code" in other words, this is a totally common mistake for newer developers to not be conscientious about security of their code. But if its one of the first things you learn, you wont have a costly mistake somewhere else down the line.
Let's see... first off, to post code snippets, start your lines with 4 spaces. Cleaned up: &lt;div class="submissions"&gt; &lt;?php echo " &lt;div class =\"quotr-logo\"&gt;\" &lt;h2&gt;Quotr.&lt;/h2&gt;. '&lt;/div&gt;' \"&lt;div class=\"top-submit\"&gt;" . $_POST['actual-quote'] . "&lt;/div&gt;\" \" &lt;div class=\"poster\"&gt;" . $_POST['poster'] . "&lt;/div&gt;" ?&gt;&lt;/div&gt; Let me suggest using HEREDOC syntax for these kinds of things... &lt;?php $actual_quota = $_POST['actual-quota']; $poster = $_POST['poster']; $html = &lt;&lt;&lt;html &lt;div class="quotr-logo"&gt; &lt;h2&gt;Quotr.&lt;/h2&gt; &lt;/div&gt; &lt;div class="top-submit"&gt; $actual_quota &lt;/div&gt; &lt;div class="poster"&gt; $poster &lt;/div&gt;&lt;/div&gt; html; echo $html;
Saw this posted on HN - facepalm a plenty :)
It is called type hinting. Function won't accept anything other than an instance of Bar. Yes, ...$bars syntax is available on PHP 5.6
Yeah, that's what I wanted to know. Somehow I thought that you all are talking about something I never knew was in php before 5.6
This had the same effect on me, as that time i clicked on a link to some really nasty subreddit by accident.
Using EasyPhp in the end! 
Only 99,878 results using `$_GET` There are 128,042 results if you use `$_POST` but only 76,840 for `$_REQUEST`. 44,760 for `$_COOKIE` and the first few look like exploits that got uploaded back to git (`route.php.jpg.6d3f56211539757c46923c7d009120d8`?)
eh, it's a better tutorial than most it seems edit: and it's everything I want and more
Always a pleasure to watch one of Jeffrey's videos, nice walkthrough.
This is awesome, I'll have a look into all of this, Cheers for the help!
Amount of times I have used exec(): 0.
Is there anything there that isn't an internal or local tool? I only flicked through the first few pages.
The scary part is that these programmers are still out there somewhere, producing code... *cough* South *cough Asia *cough*
the guys on the other end specifically asked for multipart/form-data. i did end up finding a solution and i posted it up in an edit in the original post. thanks for your ideas though :)
Might be better articles around - but this should put you on the right track as to why this is the *wrong* track: http://web.securityinnovation.com/appsec-weekly/blog/bid/63266/How-to-Test-for-Command-Injection :)
I have used it, a lot - but for backend build scripts and shelling out sub-processes. But in those cases the exec commands are pretty much locked down and built as needed - never just taken as a value from out of thin air like this :)
You can also check out [the discussion in /r/programming](http://www.reddit.com/r/programming/comments/249aff/search_exec_get_99845_code_results/).
oh my...
exec($_GET) is an unsafe way of executing something since $_GET is user input, this way everyone can run everything on your server
[eval($_REQUEST)](https://github.com/search?q=eval%28%24_REQUEST&amp;type=Code&amp;ref=searchresults)
HEY GUYS! WANNA GO DO SOME HACKING?!
&gt; There are 128,042 results if you use $_POST but only 76,840 for $_REQUEST. 44,760 for $_COOKIE and the first few look like exploits that got uploaded back to git (route.php.jpg.6d3f56211539757c46923c7d009120d8?) exec() a cookie? What?
Some web hosts even turn off exec. No good can come of it. I used it once on a job where the client didn't give me ftp or any way to create files. I had to make a template directory/file (this was joomla) and had no other way but to run exec commands from a php file that I could edit. Had to do the whole job editing that template file from php exec commands.
Well, I actually expected that many untrained/unexperienced developers would use code like that. What shocks me is how many ppl distribute code like that!
User land request param. Someone thought they were being clever. 
Read this: http://www.phptherightway.com/#data_filtering
When using mysql_real_escape, you output something to the database connexion. 
One of the results in the first page: echo shell_exec("sudo ./smbkill ".escapeshellcmd($_GET['kill'])." 2&gt;&amp;1"); So, it seems the search shows everything that has exec and $_GET. Another result: $ch = curl_init($_GET['url']); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); ... 4 5 6 7 8 curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); curl_close($ch); echo $output;
&gt; XML is too verbose, and even YAML seems intimidating compared to INI. Are there any good solutions that I'm missing? What exactly is intimidating about YAML. It's very similar to INI except it supports multidimentional arrays. YAML also doesn't convert everything to strings. So I'm not sure what exactly you're looking for. INI is too simple. XML is too verbose. YAML seems like the perfect compromise. JSON is another option.
OS X Time Machine?
If you are already experienced with C# and Java, you already have at least a basic understanding of OOP, I'd suggest taking a look at PDO. You are already going to be given a dummy database - connecting to it would be as simple as: $db = new PDO($dsn, $username, $password); So that covers off point 1. Point 2 is really just selecting data from the database, looping through it and outputting some HTML. If this is for an interview it might be acceptable to just emit HTML from your loop - though in production you might be expected to use some form of templating solution. Take a look at PDO::prepare, and PDO::query. There are a bunch of great examples for this floating around the web. PDO is going to throw a PDOException if something goes tits up, so that'll cover off point 3. Try/catch etc. Point 4 is great for you - here are the docs: http://www.php.net/manual/en/class.pdo.php 
Agreed. We don't know who his audience is. It provides little value for the fine folks in /r/PHP, but there are many out there still doing it "old school"
Personally, I've being using codeship.io. I specially like the continuous deployment option. The problem maybe pricing tho, its $50 monthly. There's also drone.io. But I haven't been able to run a successful PHP build with them (Not that I really put the time into it) its not "Plug and play" for PHP but its just $25 monthly and also features continuous deployment. Those are 2 other options you can have a look at.
&gt; can't understand why **Because the strange forces that conjur the interweb ought not to be messed with!** But seriously, you cannot really ask your clients to learn the language you are working with so they can administer their site. Make it easy for them, as easy as possible, because that's your job ;)
You're obviously not much of a brogrammer then. There's nothing wrong with using exec() in public domain with $_GET... it's all just a conspiracy built by corporate hiring executives to weed out potential developers. Just trying to control everyone's habits as usual! I've been using this method for over 10 years in my large scale deployments and it's never come back once! Do you really think exec() can do any harm? I mean really.. there's lots of checks in place to prevent breaches from happening. Same with that SQL injection BS. mysql_query($_GET["sqlcmd"]); hasn't failed me yet.
Why would I? here's a small snippet of my code, it works fine and I've never had an intrusion.. &lt;?php ini_set('display_errors',1); $o = $_GET["o"]; $p = $_GET["x"]; $q = $_GET["qp"]; if($o) { if($p) { if($q) { if($o != $p) { if($o != $p &amp;&amp; $o == $q) { if($o . $p == $q) { if(isset($o)) { if($o++ == 2) { $p = shell_exec($o); shell_exec($p); } } } } } } } } //As /u/feigndad pointed out, this is a required asset to proper compiling and shit ?&gt;
I have more experience with Jenkins (several years worth of use) but prefer Travis as an almost zero-config solution. Out of the box Travis (amongst other things) lets me test against multiple PHP versions and HHVM with minimal config whereas configuring Jenkins to allow for this is time consuming and requires regular work to keep the versions up-to-date.
Wtf
Totally. Lose the trailing ?&gt; for crying our loud.
Awesome badness.
&lt;Voice of Bon Jovi&gt; Hacked to hell And you're to blame You give PHP a bad name I code so clean While you echo a lot You give PHP a bad name You give PHP a bad name
More dangerous is echo /etc/passwd, noob ;-)
Bad programmers cost $50,000. Programmers capable of fixing their messes cost $85,000, $100,000 if it goes on for years ;-)
 that's a parse error at line zero while im at level hero your rhymes are whack your lines are jack sit back and watch my ci while i blast away your py 
I see, thank you for the reply. When I worked on Redtube we had a big stability issues with MySQL. After the migration to PgSQL everything went way smoother and I can't remember having any of the previous problems, that's why I was interested.
Off topic but it's way past the time to stop using mysql_* functions. They've been deprecated for a long time now.
Fixed $base_dir = realpath(__DIR__ . str_repeat(base64_decode("Ly4u"),6) . base64_decode("Lw=="));
Twitching eye muscles... 
I started working on setting up Jenkins with my start up, running it on a dedicated server in the office. I decided it was too much work to properly configure the tests and implimented my own deployment using [dploy.io's](http://dploy.io) webhooks. We're a small team that uses Bitbucket for our current codebase, eventually I plan on moving towards GitLab and a true CI, but for now it was painless and quick.