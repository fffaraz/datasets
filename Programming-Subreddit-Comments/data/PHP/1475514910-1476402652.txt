I was referring to my reasoning for creating a new package. Obviously a developer would be hesitant to choose my package based on downloads and support, you're right. But that's the issue with any new package. I'm sharing it here to get some backing by the community and build it to have features everyone will find useful. Originally I made it for myself, but after using it I felt it would be something the community could use.
I feel you on the CodeIgnitor 2 pain. I'm also working on slowly migrating an old CodeIgnitor app to Laravel. At least there's never a dull moment.
You've got a job closer to home with better pay and you get to learn a tech that makes you even more marketable. Sounds like a good move.
Wouldn't you consider this post an education?
&gt;I don't understand /r/php at all. It is easy. /r/php is the worst kind of people from the dev community with a king size ego. It is infantile and utterly moronic. The weird down votes that you see are the moronic, knee jerk response of such a collective hive mind in action. This is mostly true regarding the whole of reddit. But some subs rises a bit above, and some like /r/php revel in it... When you think that the langauge developement is driven by such a community (not /r/php but the php community at large share similar personality), you will understand why there is no future for Php.
Sorry, I'm a little slow, but is this just an in-memory cache using the private cache attribute of the Cache class? It doesn't appear to be a wrapper for things like Memcache, Redis, or the Filesystem, unless I'm missing something...
You know, you got me thinking. I worked with Drupal about... 11 years or so ago. Back then, I think it was Drupal 3 or 4... Brand spanking new, and using some of the most cutting edge PHP OOP patterns (think actual model objects) while vast majority of the other projects were still in procedural and basic OOP classes (think classes as collection of functions). I was very junior and self taught dancing circles around my peers in early under grad, so naturally, I barely understood OOP concepts and absolutely hated the codebase. Looking back at it, they were definitely ahead of the curve then. This does not goes to say that they were doing everything right. Their hooks system was abysmal, and massive pain to work with; their highly opinionated views meant every time they insert a record, instead of trusting the DBMS to do auto increment, they'd do a full table scan to find the next available primary id counter; and their templating system was a steamy pile of mess. I haven't touched their code base for ages. Quickly looking at their git repository, it looks like very much what you'd expect from a dinosaur project: A monolith project that is fairly well polished. It is not a fresh modern microservices API driven project, but it is relatively workable with good IDE to help. You'll probably hate it if you've been building more modern projects, but honestly, it doesn't look too horrendously bad all things considered. At least you're not trading your commute for a legacy codebase that will decrease your life expectancy further ;)
One of the difficult lessons I've learned over the years is how many technical problems have non-technical roots... Which are often too big to solve without a big dose of luck.
MFW i log into a clients wp-admin and see it transformed into a site builder to the point where noone dares to touch anything or press any update button.
&gt; However, your solution is imperative. Data fetching in a declarative way is one of the point of GraphQL and why was created. Maybe I'm missing something, but what's the significant difference here between both approaches? The query in my case is built in PHP, imperatively, sure. But the result is a *declarative* query with the same exact effect as calling a directive with the given parameters, on a parametric query. Then it's sent to a server API for processing. If I want to obtain different versions of the query I just need to call my function/method with different parameters and send the resulting query to the server API. I see no reason to compute this directly in the server API, when the client is perfectly capable of doing that itself. Is anything lost here? To use pseudo-code here, with GraphQL you basically send this: query foo($flag) { if ($flag) this; else that; } foo(true) and this: query foo($flag) { if ($flag) this; else that; } foo(false) Instead I compute those in a simple PHP/JavaScript/Ruby/Python/etc. function and I directly send this: foo { this } and this: foo { that } Thoughts? 
All I can say is that it sounds like you aren't actually connecting with the real PHP community. As there are tons of great developers out there (recently some extremely senior ones were looking for jobs actually, but they've all gotten snapped up quickly). I might suggest that you look at connecting with various PHP user groups, consider sponsoring some PHP conferences, or taking out some advertising in php[architect] magazine if you are wanting to really connect with senior developers. Also there are recruiting firms that work exclusively with PHP developers, such as phpdevhired.com
I always have this argument with people.. totally depends where you're at. Most agencies, the client is sold something that isn't realistic.. and time constraints turn production into either a) unfinished testable code or b) finished untestable code... guess which happens 99% of the time ;) However in startups, product branches at agencies, internal products, etc.. That's different... I can never compare production work to "app" work... if that makes sense.
I don't think you made a mistake (based on these information), you get more money, and more time what you can devote to learn anything you want. A good developer is a good developer on any language or with any technology. I don't think that working with Drupal so much worse than working with Laravel or Symfony. So, after we cleared this, there are two options: 1. You have to work with Drupal 7 (or 6): The bad thing is you can't use your previous experience that much, and anything you learn is dated, and won't be that much useful in the future, but you get tons of good tutorials, examples, documentations. 2. You have to work with Drupal 8: The good thing is you can use some of your Symfony knowledge, and in general it will be more familiar territory. It isn't that complex, and actually you have an advantage if you have never worked with the earlier version, because it changed that much. But there are downsides too. It came out almost a year ago, but it need one more minimum. The core is somewhat good now, but the contrib modules are mostly in alpha. Almost no documentations, examples, etc.. If you need something Symfony related then luckily you can check in the Symfony docs, but other than that you have to dig through the core code for anything useful.
Could be worse. Like Magento.
I've worked with drupal, wordpress, and laravel. Comparatively speaking most laravel codebases tend to be fairly low in complexity compared to most drupal codebases. Drupal by itself is fairly inocuous and highly flexible, as long as you don't have too many customizations, but the amount of plugins and custom-plugins you can have is mind-boggling. If your codebase is like what I've normally seen, it's going to probably be a kludge of various calcified layers of code by various developers ranging from rockstars, to well-meaning dabblers, to people that should be slapped. Due to the complex nature of drupal, this can mean something as simple as changing the sort order on a view can be a rabbit hole that you can get lost in for days. You'll definitely have to learn to do things the "drupal" way. One of the best things I did when I started drupal is to watch a few tutorial drupal videos (signed up for free on Lynda.com) just so I can learn the lingo and what a normal drupal install is going to look like. 
So it basically just boils down to an associative array?
&gt; To make sure. We treat your PHP implementation as an example, because querying on client side can be only done in JavaScript. I probably should've written the example in JavaScript. When I say "client side" I mean any sort of client, including, say, when a PHP script connects to *another server*. You're right JavaScript would be more typical. &gt; - imperative code (logic) should be placed in the server as much as possible (we should not trust client side code, especially in terms of data) I'm not sure why this is relevant. I'm not advocating that imperative code is *sent to the server*, I'm only saying the *result of it*, the query, is sent to the server. The query itself is 100% declarative, so there's no security issue whatsoever. &gt; there is a trend to make client side code as much declarative as possible &gt; declarative way is more legible &gt; you just write what fields you need with arguments and directives next to them (we find imperative approach more complicated in terms of readability - nesting functions etc.) Those parametric queries and directives are simply functions, reinvented. Basically 100% of our client environments have functions (JavaScript, PHP, Python, Ruby, C#, Java...), so why should this be *duplicated* in the query language? I don't see any reason for this. Once again, the query is *always declarative*. How the query is computed is irrelevant, as it's a client-side concern. The server only cares of the query is valid, not how it was assembled. &gt; If the server receives something like this: friends @include(if: false) { name } So I'm asking, why should the server side even receive an expression which obviously will *not* be included. Can't you just *not send that text*? Seems quite redundant. &gt; You are right that it could not be even send to the server, but then, at least part of parsing would be performed at client side. There's no parsing, because if you use JSON, then you use existing structures in the relevant language: objects and arrays in JavaScript, dicts and lists in Python, arrays in PHP etc. Those are very easy to manipulate and assemble programmatically, as demonstrated, i.e. if ($someParam) $select[] = 'friends'; No parsing required, just arrays. &gt; It was decided to do parsing at server side, because in all cases it has to be done there: for instance to return fields in the correct order. Well, aside from what I noted above (that there's no "parsing" on the client, per se), there's no complex parsing on the server either, if you just use JSON. It's just a simple data structure.
PHP is slightly inconsistent in this regard. Ideally you'd be able to specify if the type in the parent class is co-variant, contra-variant, or exact. Co-variant would be what you say, and it's typically expressed like: class Foo { public function baz(): +Foo { return $this; } } This means "I return Foo and subclasses of Foo". PHP doesn't support this notation. Hack supports co-variance and contra-variance, if interested. As it is in PHP, instead "Foo" means just "I return exactly Foo". Of course, at runtime you can return Bar, because it's instanceof Foo. But you can't statically specify it. 
Class types are inferred during lexing, not runtime. This means that if you redefine a function on a class, the upper class must fully comply with the lower classes definition. `PHP Fatal error: Declaration of Bar::baz(): Bar must be compatible with Foo::baz(): Foo` This is just a property of how class inheritance works in PHP, you can't overload a class method with a different signature. You can achieve what you want by setting a return type of `Bar::baz` as `Foo` but then your type checking is only going to work under the `Foo` class, not the `Baz` class.
You said biast answers are welcome - well here comes one. Choosing Drupal was by far the best career decision I ever made. I chose it in 2007 for a project where it fit very well. I got lost in its complexity and got frustrated...but then I found it's community. While you may look at things and think that they are over complicated or just plain bad, you'd be surprised at how considered and measured every feature really is. The community is full of very very smart, humble, helpful people who truly want to create the best product there is. Every pattern, class, and function in core has been through many rounds of review and tested in anger over literally millions of sites. Take a look at a git blame/log against some line of code that you find perplexing or annoying (the commit message will have a link to an issue on drupal.org) - I guarantee there's a lot of history and thought behind it. Drupal is big project and can feel exasperatingly bloated or complex at times, but on balance it's a great framework that enables some really cool things if you submit to its Drupalisms. Drupal has taken me from a VBA/Delphi programmer in a little town in NZ to working with some of the biggest companies in the world on _very_ large scale problems. One of the projects I am working on at the moment uses Drupal to manage in-store advertising displays in over 23,000 retail locations internationally. The client is a Fortune 150. Drupal provides a full management UI, IA and permissions management, content scheduling, and secure web services. We delivered the first release in 4 sprints (8 weeks). The client LOVES it and can't believe what we can achieve at a much lower cost and much more rapidly than their incumbent techs. Like I say, if you drink the Kool Ade you can really do some cool shit. Last week I spoke at a week-long Drupal conference that was held in Dublin and attracted 1800 attendees. The conference (DrupalCon) is held 2-3 times a year in Europe, Asia, and North America. NA regularly attracts over 3000 attendees. Over 3000 people committed to Drupal 8 core and there's 30,000 active developer accounts on Drupal.org. By some measures Drupal is the biggest open source project in the world. If Drupal sucked, do you think it would inspire this level of engagement? One other thing that is maybe less well known: Dries Buytaert, the project lead, is legit. His doctoral thesis was on performance monitoring and optimisation of Java JIT compilers. It was accepted for publication via the ACM/OOPSLA, and he defended it to James Gosling, the original author of the Java language. He also wrote a clean room JVM. The dude is not winging it. Full disclosure - I work for Acquia, the company that Dries founded to provide Drupal services. I wouldn't have it any other way! You may have made a great career move :)
&gt; you don't have to clutter your code with checking, setting and reading the cache yourself The following 6 out of 7 lines are followed by boilerplate. How is this different than memoization?
&gt; Class types are inferred during lexing Class types are parsed at compile-time and are checked when the class is defined, which may or may not be at runtime (conditional class definition, for example).
Why not use existing solutions like http://www.stashphp.com/Drivers.html#ephemeral
You know, it almost sounds like you didn't know what you were doing. Drupal is not even remotely suited for a blog (and I say that as a core developer and as someone who has made a good living as a Drupal developer for nearly a decade), and nobody in their right mind would go down the road of trying to merge two databases. There are much better solutions that make it so that you don't have to do that. Theming was not intuitive in d7 and below. You're absolutely right. D8 is a whole new ball game, though, and the theme system is now beautiful.
Drupal can be annoying, so many shitty modules, so many confusing modules and a crapload of hooks to learn so you can create your own confusing and shitty modules. To be honest though my preference is just to use raw php which seems to be unpopular these days so take my opinion with a grain of salt. 
And that's why we have test suites. 
Tried to get into it... Too much verbose stuff which makes little sense, all to configure what feels like a CMS rather than a framework.
100% test coverage by every module wouldn't solve this issue. When any module can hook into almost anywhere and modify the code flow, the expectations you've written into your tests can change out from underneath you at any moment. So every module's tests could be running green, but a new release could still absolutely break a site. This is why you need tests written for your own site to cover the integration points between modules. ...but if you do an update and your own tests start failing, all that tells you is that someone changed something somewhere that violated your assumptions, or the assumption of one of the modules in your stack. Even if you manage to track down who changed what and why it broke, good luck convincing the maintainer on either side that their change is "wrong" because from each of their perspectives their code is doing what it's supposed to. So what do you do? You write a hack, put it in your patches directory, add it to your drush build file, and hope you never have to update the module ever again.
Why not use an associative array? It doesn't need to be any harder than that...
I see someone's a big Casey Neistat fan.
Drupal is very good for the tasks it was made for. If you like Laravel, well, it's not laravel. If you like Symphony, it's not that either. A good and powerful CMS it sure is. It's lacking in a few areas as well, but not so greatly as to call it a mistake. It's a great chance to see what they're trying to accomplish and to see IF it could be done better without somehow running amok of the CMS principles they're trying to accomplish. People develop web apps and naively assume that there's only one way to write good web code.. it's funny because we're talking PHP here, so we should realize that we're starting with duct tape and string anyway.. granted, it's not Gorilla tape and space age string-- but tape and string none-the-less. The comment saying that technical problems have non-technical roots is SPOT ON. You don't always start a CMS with most of it pluggable and write it in the same way you write an app infrastructure.. I say all of that to say, give Drupal a try-- I absolutely love the concept-- I think it's a bit off the mark, but I love how powerful it is (the core parts of it) compared to something like wordpress. They're working on front end issues moreso than programming issues recently from what I can tell-- and when they get those ironed out, a reboot will likely be in order-- but I love the things that drupal has trailblazed. Still too techie for the average person and a little more difficult for simple scenarios, but pretty powerful none-the-less. Complaining about Drupal is compared to how I (as a DBA) complain about about various ORM's and how they abstract away the power of modern databases (ones with features like postgres or oracle)... but those same ORMs have enabled many developers to develop apps they'd never had done had they spent the time to learn SQL. I think drupal is a similar scenario--- every part of it is not perfect, nor is it efficient, but it's enabled some people to make some powerful websites that wouldn't be possible as easily in Wordpress without re-engineering it.
read: and it's API is like HELL yes. 
Damn right man!
And see where it could be improved. It's not a bad idea, it's just got a different goal than you're used to. When you get on board with the goal (and don't abuse it), you may find a way to help the community in a huge way.
tl;dr: PHP has invariant return types because implementing covariant return types that work consistently turned out to be quite difficult. It may get covariant types yet in the future, but PHP lacks them right now. In any case, it doesn't matter that much: if Bar extends Foo and `-&gt;baz()` returns a Foo in the parent and you'd like to return a Bar in the child, you can simply keep the return type the same in the child. It's not as specific as would be ideal, though.
&gt; `+Foo` No need for that, covariance is the clear choice, if PHP were to support it there'd be no sigil required. Indeed, PHP does actually have covariant return types, just only a very limited form thereof which doesn't currently support classes.
So why isn't it supported. RFC says it's due to "some problems". 
Not sure why you're getting downvoted. If people assume that because Drupal uses some Symfony components that it will be anything like the framework, they are in for tears and sadness.
I assume that implementing keywords such as `self` or `static` would be the same as the covariant return types mentioned?
In answer to the only part of your comment that's worth reading - no, it doesn't fucking well bother anyone else. /u/sarciszewski may be an asshole sometimes but he knows his stuff when it comes to PHP security. Go sit over there in the corner, all alone, with your cowardly, shitty attitude.
Most organisations that are serious about writing high-performance web sites are using nginx + php-fpm these days.
really? So running big old Apache 2.4.x is considered slow ? I am not so sure about your marketing.
I am very experienced in Drupal 7 and work with it exclusively all day. I can tell you it is complete shit. The "Drupal Way" is complete shit. Drupal 8 might be better because it uses some Symphony components (it is not based on Symphony at all), but then why not just use Symphony or Laravel? 
https://www.sammyk.me/how-to-contribute-to-php-documentation
holy crap .. the docs on the php site are essentially useless. There is no mention at all of a reasonable version of MySQL and the --with-mysql option doesn't even exist in version 7! What the hell! bork bork bork http://php.net/manual/en/mysql.installation.php
Thing is, there's so much work out there it's unlikely not being fully booked for the year. It's been like this for all the years I've been contracting with no sign of abating... Save brexit.
It's just not "cool." For most people, Apache 2.4 with mod_php should be just fine, and Apache 2.4 with PHP-FPM shouldn't be noticeably slower than nginx. 
I don't build from source, but I know PHP 7 removed mysql extension, it has only the mysqli extension, maybe it can help you: http://php.net/manual/en/mysqli.installation.php
According to the OP the only vulnerabilities /u/sarciszewski has found are crypto related vulnerabilities. Weak ciphers, unauthenticated encryption, timing attacks, etc. From what I've seen that would seem to be a true statement. If it isn't true then it should be easy enough to disprove. Has /u/sarciszewski ever found a vulnerability like XSS, SQL injection, remote command execution, etc? Has he ever shamed projects for having vulnerabilities like that as he has for much less impactful crypto vulnerabilities?
Test suites in drupal 7 modules ? I want to see this.
&gt; If it isn't true then it should be easy enough to disprove. Has /u/sarciszewski ever found a vulnerability like XSS, SQL injection, remote command execution, etc? Most recently, [PHP Object Injection in Simple Machines Forums](http://seclists.org/oss-sec/2016/q2/521) (CVE-2016-5726, CVE-2016-5727). Even more recently, but not yet publicly, there are some unspecified flaws I found in Magento as well. &gt; Has he ever shamed projects for having vulnerabilities like that as he has for much less impactful crypto vulnerabilities? I disagree with the premise of this narrative.
Magento 2 is actually looking better and better every month. And has plenty of unit tests.
Whether you like it or not nginx is coming up in the world. That leaves one way for apache to go
Can confirm. I'm also self-educated. 
I have a BS in CS and 20 years of professional programming behind me. I recall correcting my professors a few times (sorry fellow class mates that got irked by that). I also recall a professor giving a test based on a book we were using that had wrong information in it. I know because I was implementing the item in question with AT&amp;T at the time. Needless to say the professor went by the book and not the "real world experience." The best thing, in my opinion, about college is that you get a ton of free time to spend learning a lot of stuff with your fellow class mates. We must have installed linux 5 million times and created so many stupid little games. My friends and I drove from Connecticut to Florida to hear Brian Hook talk (id software developer) and when he walked in he said something like "I didn't expect this many people. I am going to have to change my speech because I don't want the professors to get pissed at me when you all drop out." The gist of his talk was "college is great if you don't have anything better to do" and I honestly cannot sum it up any better. You have people like Gates and Dell that were in college and found better things to do so they quit and went and did the better thing. College is all about sharing ideas and learning. Sure you are forced to do scheduling in your operating systems class when you create your own operating system that you probably wouldn't do on your own but beyond that what do you think we learn? EDIT: I should note that https://www.youtube.com/watch?v=e1DnltskkWk is a great way to sum it up. I must watch this clip at least once a month :) 
1. Jesus 2. Christ 3. The 4. WIND 
`self` is already supported. `static` isn't. In any case, both are essentially aliases of the current class name, so yes, they would be subject to the same invariant return type restrictions as other class names.
We all know that market share estimators are pretty terrible but they'd all have to be off by a factor of over one hundred for iplanet to have half the market share of nginx. It makes sense for big companies to go the proprietary (and supported) route with Oracle, the same reason that many companies use ERP systems like Epicor instead of open source alternatives. It doesn't make as much sense to go that route when you're running a smaller company though. The question ends up being about which tool is right for the problem at hand, obviously a lot of people think nginx is it, whatever that problem is.
My advice to someone who wants to freelance without living in a city; become business partners with tech consultants who operate in the cities. City wages, rural lifestyle. Can't complain.
i got a ba in visual and performing arts and didn't get into php until a year after college. my college experience has been helpful in terms of being a jack (off) of all trades for the company where i am at. i sometimes wonder if i had taken computer science classes and learned some things about basic algorithms and whatnot. but most of my day is made up of solving common web problems on a variety of web platforms. on the company i'm at we recently just out out a request for resumes and honestly after reading through a bunch of them i was intimidated to interview them. i have about 16 years of experience now on the web but these guys all have said the right things and used the right acronyms. 95% of them were not only bad programmers but many were dishonest and had a pretty big history of changing jobs every year. which for me at least is a red flag professionally. there will always be someone better than you. and you can look at that in a couple different ways. one that you can decide to work hard and be better at them, or you can hire them and pick there brain and get better. if you are worried about not knowing enough, well you don't. but its there for learning. 
I went to a community college and got a certificate, which was basically just a boot camp that taught programming basics and then some vanilla js, jQuery, and minimal php. It was EXTREMELY basic, so I considered myself mostly self taught. When I got my first job, I was terrible at programming. I didn't know any frameworks or flexbox, yet I made sure to continue educating myself on the job and outside of it. A year later, and I'm considered an Angular guru, both 1 and 2. I lucked out, because that's the in-demand framework right now, and I landed a pretty amazing job. And yet I still feel the same way, like I'm not doing it how it's supposed to be done sometimes. I think it just comes with the territory of being self taught. It's almost like imposter syndrome. Just know that you can always learn more, but there is a point where you'll feel much more confident.
Self education without direction will lead you no where. And if you stick to Php, any direction you might get is often 'mis' direction. So get out of it, and get exposed to better languages and communities if you want to be a good developer someday. And stop bragging about 100% test coverage. It doesn't mean shit. &gt;in your opinion am I an imposter fraud.. If you are given a web application to develop, and you don't know anything better than Php to do it, then yes. You are an imposter.
Just throwing this out there I've experimented with Express JS, python, and ruby. Just because php pays my bills and I enjoy using it write software doesn't make an imposter.
Hi, and welcome to Drupal. Disclaimer: I have been a Drupal core developer for 11 years, and was one of the de facto lead architects of Drupal 8 that drove the major rewrite that was Drupal 8. (Officially I was the "Web Services Initiative Lead".) Drupal has long had a bad rap from many quarters. Like PHP. Some of it is deserved. Like PHP. Much of it, perhaps most, was once true but hasn't been for a long time but people keep repeating it without actually verifying if it's true. Like PHP. Drupal is one of the most popular CMSes on the market. Wordpress is far and away the largest by an order of magnitude over anything. I think Drupal is #2, leading the "everyone else" pack by a slim margin over Joomla. (If not, then it's very close between the two.) Drupal tends to be more popular in larger, more complex sites and enterprise usage, because it is designed to support complex content modeling use cases. That's its "sweet spot", but you'll find successful Drupal deployments from small mom-and-pop shops through major sites like the Emmys or WhiteHouse.gov. Drupal has also changed dramatically in the last year. Drupal 7 (the current legacy support version) came out in 2011, and is the most widely deployed version today. It does have a very idiomatic API that is unlike most other PHP frameworks. It's extremely powerful and flexible, but does take time to learn and get used to. Drupal 8 (released November 2015) was a (deliberate) major BC break to revamp the system as a relatively modern application. That includes being largely OOP (although not exclusively), leveraging over a dozen 3rd party libraries (including the core bits of Symfony), Composer, PHPUnit, etc. The old template system (which just about everyone hated) is gone, replaced with Twig. The core system is far more robust, so you'll generally need far fewer modules to get things done. (Although the modular design is very deliberate.) It's still quirky in places but it's far, far less idiomatic than in the past. The vast majority of people who have taken the time to learn Drupal 8 after using Drupal 7 have said it was challenging at first because it was so different, but now they never want to go back. As other commenters have noted, bear in mind the kind of system Drupal is. Comparing Drupal to Laravel or Symfony fullstack or Silex is a poor comparison, as Drupal is not a pure framework. It's about as accurate as comparing PHP to Ruby on Rails. (The former is a language, the latter is a framework.) Drupal (7 or 8) is a Content Management Framework. If your use case is largely around defining, editing, manipulating, and displaying structured content, Drupal is one of the best tools on the market. It's a tool designed for content strategists and content editors, primarily. Code-writers are *not* the primary audience! If you approach Drupal as a "bigger Laravel" or "Symfony with lots of extras", then yes you'll be very disappointed. That's because it was never built with that intent. Right tool for the job blah blah blah. :-) Similarly, if you approach it as an "over-engineered Wordpress" you'll miss Drupal's actual strengths, which is in robust content modeling and separation of content from presentation. I know nothing else on the market that can touch it in that regard. But that does mean using Drupal for a "5 pages and a blog" site is massive overkill. Use Squarespace for that. :-) If you approach Drupal as a content management framework, on which you can build the content management and content curation system appropriate for your business with an emphasis on a tailored end-user experience (that you, as the site builder, get to define), then Drupal kicks major ass. As others have noted, the Drupal community is one of the most robust and energized in all of Open Source. Our developers-per-lines-of-code ratio is higher than almost any other project. Whatever it is you're trying to do, there's someone in the community (probably several someones) who knows how to do it and would be eager to help you. (There are the periodic jerks, as in any community, but the jerk-rate is really quite low for how large and loosely-structured it is.) If you approach Drupal honestly and judge it as the tool it tries to be, rather than what trolls 7 years ago compared it to in ignorance, I think you'll be very happy with it. Especially if you're using Drupal 8. Whether or not you'll hate the job itself depends far more on your boss and your coworkers than on the tool you're using. Welcome to the community! Addendum: A few other commenters have been debating whether knowing Symfony will help or hurt you. Drupal 8 leverages the core Symfony pipeline (HttpKernel, Routing, etc.), but it is *not* Symfony fullstack. It's more a cousin of Symfony fullstack, much like Silex is, or Laravel. In practice you won't see the Symfony bits except in a few key places (event dispatcher, selected listeners, etc.). If you get deep into the system you'll recognize some Symfony-isms, but it is *not* Symfony fullstack. Don't expect it to be and you'l be fine.
fwiw, i'm a self taught developer and i felt some of the same concerns you describe for a long time. the nag comes back now and then, but the biggest thing that helped me get over it (i swear i'm not trolling, completely serious) was to branch out from php. php is a totally valid way to get shit done, but it's also a sloppy mess of a language with a crazy low barrier to entry. push yourself to learn some "harder" languages, either languages with stricter standards in their community (eg python, ruby) or languages with challenging paradigms (eg haskell, elm.) i can confidently say that each of these moves (i made them in the order listed) progressively built me up to a level where i can concretely demonstrate my ability, even among developers who have formal education behind them and more years in the field. being self taught means you know how to learn, and that's an asset. be aggressive about putting it to work and don't be complacent with the first toolset/paradigm that you learned, and you may be surprised to realize what you are capable of.
I'm self-taught. A few years ago I took an elective college class in web development (because I needed to hit a certain number of credit-hours for financial aid purposes) and ended up teaching the professor how to secure his server. They touched on PHP towards the end, so I decided to write a very basic templating engine for fun. My impression is: College curricula largely haven't caught up to technology yet.
Bashing PHP is what all the hipster coders get off on. Don't hate what you don't understand.
If you're working on Drupal 6 sites then you're working on unsupported end of life Drupal. It's not really fair to judge it based on that! &gt;Simply by naming functions a certain way You're complaining about naming conventions in a framework? &gt;nigh impossible without Xdebug Untrue, there's the very helpful devel module. But why not use Xdebug anyway? That's the defacto standard for debugging. Using anything else is just inefficient. &gt;as I see it as a career dead end to continue working with it If you're a PHP developer it's literally one of the most in demand technologies to have on your CV's. Maybe stop using out of date software and learn something new instead of bashing something without any knowledge.
Ok so what did i miss, when did pmjones became the dumping ground for the reddit scientists
Because: * Object wrapper can have some sugar in in (defaults, config merging, etc) * environment variables are flat, whereas the config may be multi dimensional (see the „dot notation” in the lib) * PHP is faster than parsing XML / JSON / YAML / INI (the lib says nothing about storing the config, just how to process it and use it once it’s in PHP) As mentioned elsewhere in the thread, you can use the env variables with this lib, just pass `$_ENV` (or some form of it) in the constructor.
Everyone in our office (bar two holdouts) use Scotchbox all dev work...it's got its drawbacks. E.g randomly wiping your config files, but we've worked around those by using a nfs drive mounted back to the users machine. I'd like to move to docker but lack the time to actually learn it properly :) For deployment we're (reluctantly) using Rocketeer but most of us hate it as we used to be on Capistrano, which was so much faster and more reliable.
Hahahaaaaa cheers! I have all that gear, I just wasn't expecting to end up at Hadleigh Castle amongst the wind when I was running errands ;)
[removed]
I used to be self educated but college ruined me. 
&gt; Not looking forward to trying to upgrade it to 2. You're not going to be able to, Magento 2 is a full rewrite, there is no clear migration path. You'll have to reboot everything. The Magento team kept the same features from 1 to 2, but rewrote every modules in a somewhat modular way. All these outdated PHP frameworks ... that's so sad. I'm lucky I've always been able to promote and enforce Symfony instead of Joomla/Drupal6,7/WP/Magento1... Magento 2 is really nice though once you're over the WTF phase the first 3 months to uncover the tons of codes they put together to deliver features. The Theming/JS/CSS is fucked up and can't be saved though.
If you "enjoy" writing Php, then you I will consider you as an imposter. Not because the fact that you use Php, but because you don't know a piece of shit language when you see one, which follows you don't know good stuff from bad. Which means that when presented with multiple options, not only you don't know to evaluate and choose the best option, you don't even know how not to choose the worst option. Because of all the options you have experimented with, you seem to have came back to Php. You look at Php, and you fail to see all the things that can *potentially* go wrong if you code in it. You are a novice who thinks that Php is fine. Because you don't know the language good enough. This is why I call you an Imposter. Sure, it pays your bills. But it is not the langauge that pays your bills. It is the people/clients who trusted you to use the most efficient tool to build their software, that pays your bills. Instead of using the best tool, you choose to write it in the worst language ever, just because you don't know better, or haven't spent the effort to know better, so that you can be worthy of the money paid by your clients. You asked if you are an Imposter. I say, Yes, you are....Sorry. If that pisses you off, you shouldn't have asked the damn question in a public forum in the first place.
&gt; can't write program for prime numbers I can't either without some googling, so I don't think that's an indicator of anything.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] ["You say Php5 had OOP and even Php7 cannot do this?" "Yea, too hard!"](https://np.reddit.com/r/lolphp/comments/55sogy/you_say_php5_had_oop_and_even_php7_cannot_do_this/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Thanks. I guess I can just hope that it will get fixed/changed in a future version.
&gt; But you know what else is often mocked and derided? PHP. &gt; If you have used a plane to travel from Paris to Rome, and suddenly you are forced to use a bike, people are going to complain. PHP is an horrible language. For all its flaws and dubious behaviour, I do like to work with it, but I would never call PHP a good language. The same can be said about Drupal. It is an horrible abysmal convoluted project. That doesn't mean it can't be useful. But saying 'well it pays my bills' doesn't make it _good_ It is your prerogative to use it if it fits your usecase, but defending it on the premise it pays your bills to me just sounds silly to me.
He wont. I'm a full-time D8 Developer and its not fun at all. Yea, there is Twig now and some yaml files, but thats all what you really notice as a developer. And the Twig files are not even using inheritance.
The crux of the problem is that the inheritance and interface implementation form a DAG, while type-hints may cause cyclic references. This means that if the return type variance is checked too greedily (at the time of declaration of the class) you have no way to declare a cyclic type-hint reference in a single file (i.e. without autoloading), as there is no valid class ordering. There are a number of possible ways to fix it, but they come with tradeoffs (e.g. checking LSP only when the method is called) or implementational issues (e.g. checking LSP after all classes in the file are loaded). Additionally it could increase the number of unused classes that need to be loaded (for the sole purpose of LSP checking).
who gives a shit?!
Wow. Maybe you should go back to lurking.
I think I see it; in the example below, it would happen when checking covariance for `B::foo`, correct? Statically it's easy, but that's not how PHP works. At runtime I can see how it would be difficult. class A { public function foo(): A; } class B extends A { public function foo(): C; } class C extends B { } Have you considered a hybrid approach? Try to check the return type at declaration time, this should be the most common case by far. If however the return type is not available at declaration time, store a reference to the method. Whenever a new class is declared, check the collection of unchecked methods that reference it. If the check fails at this point, the error message would be something like "Error: C must extend A to satisfy B::foo".
I am quasi college educated. I took some introductory courses. I can say it is nice having someone hold your hand while you are walked through a planned* introduction to some topic. Let's use SQL. I took an Oracle DB class at my local community college, (cool story bro). It was like a SQL for Dummies Book but with a live person I could ask questions to. I had someone that gave me the installer for the DB, which ran unusually well on a 300MHz PII IBM Thinkpad now that I think about it. We did some exercises. I learned very little that has directly helped me with my job from my college classes. What it did was give me an accellerated understanding, a foundation for my own self-study later-- my undergrad work was eventually in Accounting. Because you probably won't learn to be a good developer in college, that comes from sitting your butt in front of computers and getting it wrong, then doing it better next time as a result of a peer saying something, or showing you something either in person or at the other end of an ungodly amount of google searches in official and wonky third-party documentation. There are those super high level jobs where you need to know quicksort from b-tree and whatnot-- but most of the time it is not advanced math... Where this super ethereal theoretical stuff is happening is not where I nor hundreds of other developers live. You would benefit strongly from college if you need to advance the theory or you are pushing technology on the bleeding edges and you don't actually have to get in the trenches and process automatic email replies or make a website.
In the latest release, using `@` is optional. however, you can customize the pattern and the list of keys to match (in the configuration file) if the default pattern doesn't meet your requirements.
down-votes bring me down to earth. :)
&gt; I know close to nothing about Drupal, but what I have heard is not good. Good chance to make up your own mind about it.
If you're getting anything done, it means you're self educated. Getting a CS degree teaches a bunch of algorithms and data structures. This is a good thing, but it's not the same as building usable software. College education or not, career viability depends on teaching yourself new things. For what it's worth, many of best coworkers either did not have degrees or had something in an unrelated field like literature. If you are capable of and willing to read and think, other people will notice.
&gt;100% test coverage by every module wouldn't solve this issue. When any module can hook into almost anywhere and modify the code flow, the expectations you've written into your tests can change out from underneath you at any moment. No, you are right. But at the same time, whenever you go through a green traffic light, someone could ignore the red. In the vast majority of cases, that doesn't happen. So we should have barriers at every intersection to prevent that accident? Convert all roads into one-way streets so that people can get from A to Z, even if it does take 10x time and fuel? Or we could jail the bad players. &gt; This is why you need tests written for your own site to cover the integration points between modules. Yes, and this is what happens for well funded sites. &gt; ...but if you do an update and your own tests start failing, all that tells you is that someone changed something somewhere that violated your assumptions, or the assumption of one of the modules in your stack. Which is the point of tests. We could minimize those problems if we restrict the breadth of what Drupal does. E.g. want to produce a list with your own special ordering? We don't want to say 'Sorry, Drupal can't do that'. At the same time, we want to be a framework, and an application, and a construction kit, and have sites buildable by people who don't know PHP. &gt; Even if you manage to track down who changed what and why it broke, good luck convincing the maintainer on either side that their change is "wrong" because from each of their perspectives their code is doing what it's supposed to. 1. The sky is falling! The sky is falling! (Later: sorry, that sounds snarky, but you are catastrophizing.) 2. You could try talking to people, and writing a patch/es. Mostly maintainers are pretty receptive to people helping. &gt; So what do you do? You write a hack, put it in your patches directory, add it to your drush build file, and hope you never have to update the module ever again. That really is a disaster. (Edit: Ok, apparently my coffee hasn't taken effect yet.) Look, there are two things going on. * Drupal is a community. Everybody in the community wants the right thing to happen. Sometimes we fall short of what we'd like, but on the other hand it's better to have code than to have a perfect system next year. And things like the hook system were choices made for good reason. It's about choosing trade-offs. * This is the same as with all the free stuff you use... Every time you download a module or Drupal you are getting some work for free - and sometimes it's millions. You are right to criticise when it's constructive, but complaints without constructive suggestion sound churlish. How do you suggest we move Drupal from the situation you describe to the situation you would like? Realistic steps are welcome. Remember that the vast majority of the work done on Drupal is done in spare time, so things that save time or make development easier are most likely to gain traction. The best thing of all that you could do is bring code. That's gold. And the best place to present your ideas are in the Core Conversations stream at the next Drupalcon. If you are persuasive, your idea will be taken up. You have obviously used Drupal in depth, and your experience of Laravel and other stacks gives you great insight into what could be better in Drupal. Please help us be better.
sorry if it's not your case but if you upgraded MySQL as well, then MySQL 5.6 if I remember correctly has strict mode as default which might trigger some errors on data that worked previously
It's a difficult topic. I'm suspicious of people who say they already know everything and don't need to learn anymore. The self-educated way is definitely a longer and rockier one, but it works too. The annoying part are first-year-college and self-educated people, who insist that they know php, because they can work with wordpress... tl;dr: Self-education is a vital part of becoming a developer, but if you take help to get there faster, you make it easier on yourself. But in the end, the job requires self-education on a regular basis. If you are not willing to learn while you do the job, no matter if you went to university or learned in a basement, you'll never be a good dev. 
Thank you. This could indeed be it. Since the error is not from PHP itself, but only returns after the call to the DB is made. I have 5.5.52 in the old dev server, and 5.7.15 in the new one. Now to look into disabling the strict mode...
Security measures are insufficient. In 20 seconds, I managed to make `exec.php` always echo "fail". PM me if you wish to know how. Not gonna post it here for obvious reasons. At least I plugged the hole for potential malicious attacks. Edit I also managed to create a file outside the `public_html` folder, meaning large parts of your server could be compromised. Don't worry, though. I am not doing anything else nor am I sharing information.
I wasn't a down voter by the way, I'm just speculating as to why. Posts like this normally get down voted, people don't like other people who boast even more so without being able to back it up. As for the library, it has no use to me as the apps I manage on a daily basis have extensive logging in place anyway as I would imagine most people will.
&gt; echo date('Y-m-d', strtotime('monday')); Sorry for the delayed reply, wasn't able to test until now. I rearranged the date to form m/d/y, but otherwise this was perfect! Thank you for your suggestion
[removed]
whoops, posted this to the wrong sub, deleting and posting to phphelp
For what it is worth we had working implementation that would trigger the autoloader and some people felt it was alright. However, I did not feel good about it because this would be the first case I know of in the language that would have *forced* you to use the autoloader. I think the best way to do this is to put inheritance conformance checking into a later pass than the one that registers the class and method signatures. NikiC, the engine has changed a lot since my initial patch so maybe you know: would this still require an additional pass or can we fit it into existing ones?
No, sadly, that was a LONG LONG time ago. Almost 20 years at this point. 1997 if I recall correctly.
I did not get a college degree, but I did take some programming classes, and then the core computer science classes at a community college. I would say real world experience and college education go well together. College helped me to learn the basics, build a solid understanding of data types and OO principals, and learn about generic algorithms and data structures. Real world experience is where I taught myself all the little things you need to learn to actually make whatever specific thing you are making. One of the projects I worked on was failing hugely. I took it upon myself to learn project management techniques, like agile software development. This made the difference and the project was eventually successful. The company I worked at knew nothing about managing software projects, and I was never assigned any kind of management role, but this is still something I learned in the real world out of necessity, and it was never necessary in my college classes. One of the great things about programming classes at a college, is it is still really hands on. You are not just learning concepts, but actually write real code, have to get it to work, and get graded on it. Of course the scenarios can be somewhat contrived, but that can actually be a good thing for someone new to programming as it prevents them from getting overwhelmed and allows them to keep learning. A lot of the things I learned in college I would not have learned on my own, and vice versa. For example I don't think I would have learned and really understood different data structures and algorithms if I didn't have a good teacher, classes that spent a lot of time focusing on that, the extra motivation of getting graded on it, and feeling like it must be important if they are teaching it. Everything I learned in college has been helpful, everything I learned on the job has been necessary. I know there are self taught programmers out there that learned all the same things I did in college, and there are so many online resources out there now. I don't think college is necessary at all. I think if you have a knack for programming, you can do well with teaching yourself. Even then, I think most programmers would learn some useful things in college that would help them. If you don't have a knack for programming, you probably should not be doing it professionally, or at the very least you should like programming.
Oh, that was you. Haha, I was wondering why was I seeing a 'fail' message everytime.
I recommend reading this [book](http://shop.oreilly.com/product/0636920033158.do) It covers all your questions and you can see some examples. Here's a [talk](https://www.youtube.com/watch?v=PFQnNFe27kU) the author made a couple months ago 
&gt; You are right that there is much field to add more "pre-parsing" at clide side. Maybe it will be added in the future in such frameworks as Apollo and Relay. I'm not sure if we're on the same page if we're still talking about "parsing" on the client side. Adding values to a basic dictionary/list is not "parsing". Nor you need a framework for it. Every language comes equipped for it. &gt; It is more about debate imperative vs declarative. We find getting data fully in a declarative way more convenient. We just ask What we want and not How. The query is 100% declarative. Maybe we have a language barrier, I don't know. *Building the query* and *the query* are two different stages of the process. The former *may* be functional, imperative, declarative. The latter is *always* declarative. There's nothing imperative in the resulting query that the server gets. Do you see anything imperative? &gt; Even if you use JSON, you need to go through this structure to return data in the correct order, so we cannot omit it fully. I'm sorry if I'm a bit frustrated, but the sentence you're replying to was about the *client side building a query*, and GraphQL clients don't *return data*, GraphQL *servers* do. I'm unsure why it's so hard to get across what I'm talking about. It seems fairly basic. &gt; We received also information from the author of one package that JSON would make harder to write such developer tools like: https://medium.com/apollo-stack/power-tools-for-your-api-42529706ae78#.rh8jjgh5f How would JSON make this harder? Introspection is an entirely separate topic from the query format. You can still easily have introspection. &gt; To sum up. The new query language was introduced for the sake of simplicity. How is a new query format that should be ported to every single language you use as a client and server, and which has features like directives, whose value was never explained (and only complicate the query) resulting in "simplicity"? &gt; writing quotation marks &gt; writing trailing commas &gt; cannot write comments in raw JSON I think you're confusing the format of *transmission* with the client code building the query. As my examples demonstrate you don't have to *build* the query in JSON, just *encode* it in JSON. For example, in the browser, in JavaScript, your query could look like this: var f = getHumanFields(); var u = getUnits(); var query = { human: { // We want this human. id: 1000, // With these fields. select: [ f.name, f.friends, { unit: u.FOOT }, ], }, // Trailing comma! } query = JSON.stringify(query); JavaScript *allows* trailing commas, *doesn't require quotes around keys*, and *allows comments*. Also "commas and quotes" are honestly not a reason to *have an entirely new language* just to eliminate those, right? It makes no sense as an argument. Now... also would you please spend a moment to think about it. Why would you want the query to *contain your comments*? Can the server do anything with them? No. It's just noise and extra traffic.
guess I better quit my bitching and get involved 
&gt; You have no idea in how many situations library would randomly return numbers or numeric strings, integers or float, for the same data. Why do you think that would be a problem? Unless you're editing the files that comprise the library to include `declare(strict_types=1);` then the library won't be affected by putting that in your own files.
&gt;&gt; Good lord, we run tests on our configurations now? Isn't the configuration implicitly included by any app/business-level testing? It's a package, yes we run tests. Maybe if you read the docs you'd see why there's tests ;) As for static properties on a class. Sure, expressive. Until you have configurations for mail, database, API integrations, the list goes on. There's no grouping of your values. "Seriously, what are you working on that is _so complex it requires anything more than that?". You seem like you know what you're talking about which is why I'm so surprised that you're being so naive about this. In the end though, there's multiple ways to get to the same place. If you're using proper design patterns and standards, then I couldn't care less how you manage your configuration. I prefer it this way. German cars are over-engineered, doubt you'd complain if you drove an Audi. 
Docs on docs on docs
Here is a working build script: https://gist.github.com/m1st0/1c41b8d0eb42169ce71a Btw, your communication skills suck.
A few notes: Why aren't you using the official PHP docker image? It's already been optimized for installing for ease of adding extensions with `docker-php-ext-install` and whatnot. Why are you using ubuntu as your base image? Ubuntu is very bloated as a base image. Alpine is often touted as the better base image due to its tiny size (5MB) and great package manager (apk) for docker. I do like your approach to docker-compose though. I really appreciate that you've put this together, I'm working on setting up an application similarly, so I'm definitely going to steal some stuff from this. Thanks :)
Whole heartedly agree that I have holes in my skill set. I'm constantly trying to learn all I can. The photoshop zoom thing reminds me of when I was first introduced to service containers, and how you didn't have to instantiate instances of objects all over the place. Blew my mind that you could do that. The guy who brought up insecurity is right, I'm not sure why I feel the way I do, but that is the root of it. You're right though, I do have a job and I am secure in it so I suppose there is no need to worry the way I do. (hard for me since I was brought up to always fear thine job security, was how my family kept themselves motivated in there work)
Funny you say that, I've been involved with my local meetup group for 8 months now, and I'm heading to zend con this year. Very excited to be going to the conference and cant wait to hear the talks that they're going to have. Also can't wait to have a few days to just talk and get information from other developers in the industry. Thanks for the comment!
&gt;It didn't seem to bother anyone else for the last 7 years The right thing to do is to get out of such a community. 
Your timeline sounds familiar to me, I think I was around 3 years in when I first changed over from PHP to Ruby. I'm 7 years in now and work full time in Scala. Things look very different than they did even 2 years ago and I would bet they will for you too.
That made my day 
&gt; (...) SensioLabs has recently begin to offer a service (...) "recently"? More like over 3 years ago :)
What database admin tools does everyone use now rather than phpmyadmin?
As with ALL frameworks, operations have to be tweaked and often caching mecanism need to be implemented for things to be snappy. You DID know Drupal ships with a caching api?
&gt; don't even comment if you have no clue about building from sources. We get it, you vape!
Thank you. I fear I misunderstood you. Apologies if I was pointed. My experience of brittleness doesn't exactly match yours; I find that things are remarkably stable despite a huge mix of versions of modules and core. I don't see contrib as a wild west - I see it like an onion: if you choose one of the widely used modules, you are protected, but if you choose a rarely used module, then you are much more likely to experience problems. But at the same time you are more likely to find something brilliant. Views was once at the edge. I find that it's relatively easy to figure out if a module is going to be a problem by looking at the issue queue - how big, how frequent, the fix rate, the patches, etc. And if you look at the code it's easy to see if the author understands what they are doing and the level of polish. But it takes work. On the other hand, it's almost always more work to build your own. My worries though are usually about security which is critical for most of my clients. I worry that a version change will introduce a security hole. Or that the giant matrix of roles and rights has a small misconfiguration with a big impact. (Readers, I do not mean that Drupal has a security problem; in my experience it's better than most software. Nor even that it's hard to configure. Rather that flexibility means many, many choices to make.) Similarly, I don't see an easy way around this while retaining power and flexibility. What I'd really like to know from you, is if there are great Laravel, Yii, etc ideas that can be imported in Drupal? 
http://www.programmerinterview.com/index.php/php-questions/php-interview-questions-and-answers/
I'll definitely read up those topics, thanks !
This is a really bad solution. The gone error is a proof that either your configuration is wrong for your workload or your client side handling is bad. The reconnect hides the problem and can cause you even more problems.
You're right. I usually write traditional Apps in PHP with Zf2 or from Scratch but this Apigility grinds my gears - I'm looking for a starter Application where I have to configure some endpoints in a config file and on the Provider side (Facebook, Google, Twitter...) but I'm little confused and need some hints. 
[Sigh](https://www.reddit.com/r/PHP/search?q=interview&amp;restrict_sr=on&amp;sort=relevance&amp;t=all) Hope you are better at interviewing than finding information. :P
You should check this out. http://phusion.github.io/baseimage-docker/
You could use the [Laravel Generator](http://labs.infyom.com/laravelgenerator/) package to build out the backend boilerplate for your API if you use Laravel. Most of the other major frameworks (Symfony, Cake, Yii) have something like that built in or have third-party packages that provide similar functionality.
Can't upvote this enough!
S'ok, junior dev won't ever have to know how to search for information.
Junior dev response: $str = strrev('string'); Senior dev response: $str = implode('', array_reverse(str_split($str))); Technical director: exec('npm install underscore some_fancy_unstable_framework'); exec('echo "exec(\'echo \'+string+\' | rev\');" &gt; ' . $_GET['script_name']); exec('python -c os.system(\'node -p ' . $_GET['script_name'] . '\');'); Any resemblance to actual persons, living or dead, or actual events is purely coincidental.
This is very hard to read on mobile. Can you try a gist?
Brilliant.
&gt;I'm not sure if we're on the same page if we're still talking about "parsing" on the client side. Adding values to a basic dictionary/list is not "parsing". We used words "pre-parsing" for removing not necessary fields on the client side before sending a query. We agree with your opinion that these fields do not have to be sent to the server and proposed "pre-parsing". Regarding declarative vs imperative. We find that we could be not specific writing: &gt; Data fetching in a declarative way is one of the point of GraphQL and why was created. As you pointed out data are always sent in a declarative way per se. Maybe we could earlier write: in a fully declarative way, so, in the way were a developer writes declarative code. We never wrote that the query is imperative. &gt; I'm sorry if I'm a bit frustrated, but the sentence you're replying to was about the client side building a query, and GraphQL clients don't return data, GraphQL servers do. We meant that there is no parsing on the client side, but is on the server side to return data in the correct order. &gt; How would JSON make this harder? Introspection is an entirely separate topic from the query format. You can still easily have introspection. You can ask about details the author of the package, as we are currently quite busy and do not have enough time to evaluate the decision made by the author. &gt; How is a new query format that should be ported to every single language you use as a client and server, and which has features like directives, whose value was never explained (and only complicate the query) resulting in "simplicity"? For us, it is simpler, but we can imagine that for someone not. You can compare the code above with GraphQL in Apollo: graphql(gql` query { human (id: 1000) { name friends (unit: FOOT) } } `) &gt; JavaScript allows trailing commas, doesn't require quotes around keys, and allows comments. Also "commas and quotes" are honestly not a reason to have an entirely new language just to eliminate those, right? It makes no sense as an argument. Now... also would you please spend a moment to think about it. Why would you want the query to contain your comments? Can the server do anything with them? No. It's just noise and extra traffic. You are right. We have to admit that made a fault by not checking received information.
I suggest checking out the FizzBuzz stuff. It, and puzzles like it, are reasonable ones to ask a Junior. When I am interviewing I'm trying to find out how the interviewee thinks, not necessarily that they know the % operator. And yes, I've had interviewees for a Senior position fail the FizzBuzz - SMH. 
What about learning how to learn? 
And how long does a reddit thread take?
Or even https://hub.docker.com/_/php/
What do you do about data retention? Like, I would like to keep or populate the database on each compose up. Usually you're just supposed to set a volume on the db container but whenever I do that on windows the container crashes.
1,6s uncached. It is not a hello world. Decent.
https://github.com/yeoman/generator-angular You can make your backend in whatever framework you want. Don't mix them together into one monolithic app though. They should run as two different apps.
Yeah... write me a class that does something cool. Go!
Have you tried a simple index.php with echo 'hello world'? i'm curious about how fast it would be
"For a while now" :)
I still use phpMyAdmin.
Nice, the docker-compose.yml and file structure very nicely structured. I wish I found it earlier, spent two late nights setting up something similar. (nowhere near as customized) Small question though, why use Dockerfile for everything? especially using Ubuntu as base image, why not just base on stuff from official repository? (i.e. https://hub.docker.com/_/php/) 
Yes i tried base image first before ubuntu. But it seems its more heavier and did not find any advantages in using that for my dev purpose
&gt; I wanted to have only the things I needed and keep the image size smaller I prefer ubuntu over debian because of its large repository and I will keep working on this to reduce the image size further
DB data will be retained . As you can see in the volumes section mysql data will saved at data/mysql ./data/mysql:/var/lib/mysql So every time you up a mysql service db details will be import from mysql data folders. just don't docker-compose down for stopping the services and you will be fine
I'm not entirely sure what you're asking. Are you after something like this? function calculateTotals(array &amp;$category) { $total = 0.0; foreach ($category['children'] as $child) { calculateTotals($child); $total += $child['total']; } $category['total'] = $total; } calculateTotals($root);
I use the same OS as our target production server (Ubuntu), so it's the same version of PHP, running as a VM in VirtualBox on Windows. Works like a charm.
Thank you very much! It is under construction. I updated. Could you please try again? 
Thanks. I got it.
After about 5 years of using Windows and fighting with all weird settings, I got a MacBook and honestly, even though I still own a PC, I don't wanna go back. If not Mac, I would definitely get some Linux distribution for development.
true, but fast ring has updates to the subsystem that has better Linux syscall compatibility. 
I tried this some weeks ago: https://github.com/awspilot/aws-lambda-php-template Was 500-1000ms cold and 50-100 warm on 128mb
API development. They're not selling a front-end framework.
I've used and still use windows 10, openSUSE (linux) and a mac. They're all fine. I enjoy linux the most. The only thing you can't get past with windows is the shitty console. 
some shared hosting wont have shell access, so we cant use CLI right ..? But most of the frameworks require that right ..?
How does that work in practice? Do you have the SSH console on one screen, and the host OS's browser open to view the result? Also, don't you use an IDE?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Everything the same down to a letter. Fedora can be a tricky choice because they break it a lot, but worth it.
Right now I have a few computers to work and the choose of OS depends on quantity of RAM inside. On my main PC(16 Gb ram) I use Linux Mint Cinnamon (based on ubuntu 16.04) and also I have an old laptop(4Gb) with Arch linux and XFCE (for advanced users only). Yes it will spend a little time to switch from windows and understand the linux architecture but it's worth it. SSH, Docker - are the main tools, I don't speak about curl and other tools.
My recent 6 years mostly consisted on working on VMs/Vagrant projects (before that it was Windows with XAMPP etc.) so my experience is this: * Tried working on Linux (Ubuntu, then Fedora) but it was a pain for me. Yes of course, CLI tools, daemons, VM, NFS etc work out of the box but gui apps (like IDE, sql client, gfx editor and many more) were a big pain to use. And these consistent problems with nvidia drivers... I really like linux for server stuff but I couldn't make myself a stable and comfortable development os. * Been also using OS X at work for 2 years, pretty good experience, like "Linux That Just Works" but overall I don't like Apple's hermetic environment (when you go Apple, you should go full Apple to take advantage of this whole ecosystem). So right now it is W10. And that's only because [winnfsd](https://github.com/winnfsd/winnfsd) got pretty stable and fast, so the biggest pain for VM/Vagrant projects (which was buggy/slow NFS server implementations) gone away. And there's also WSL (Bash On Windows) for some tools.
This is exactly the answer I despise. &gt;Better readability Why is me encapsulating a set of data and functions in a class, in a separate file, more readable than just storing that data in variables, manipulating them and the outputting them in the current script all together? Surely separating a set of data and functions that only get used on that specific page from that page is pointless. &gt;more quality Uh, what? &gt;(and ofc this other stuff oop is rly made for). Again, what?
I am not the guy to really answer that question since I dont know all definitions quite well. But when I started to write in the OO way, the code was ways better to read and it was more easy to find informations. (for example you have a class, its only containing methods that its probably using, not more nor less.) OOP is also better for coding in a team, if you're coding alone on a project nobody will really ever care about the code. Last but not least: Other, better languages (c#, java, cpp) are also mostly written in OO, so why not starting learning it in an easy language like php? dont kill me for my english pls
Very insightful, thanks. I always feared there are edge cases were this would bite back. We switched to fully strict types in our code base half a year back and never had such an encounter, probably because this is handled by the Framework (Laravel) in my case which doesn't use strict types.
One reason is it's easier to write tests for your classes. If you just have a script that handles the request with one entry point then you can't unit test parts of it.
Often on a big enough project you'll find the best variable names for things related to idea A are the same as the best variable names for things related to idea B even though they are 2 different ideas. And sometimes you need to use both A and B in the same php file. And sometimes you need 10 of A and 20 of B and doing it in a foreach loop where you can re-use variable names for each iteration isn't quite going to work. With an object, all variables and functions related to idea A can be *scoped together* in a class. And the same for idea B. Then everything within A can have the perfect name. And everything within B can have the perfect name. And A and B can be used in the same place and never shall their internals meet and conflict with each other. Also, have you done any javascript? Yes? Does OOP in javascript bother you? Would you prefer if js was purely procedural? Also when debugging and you look at the stack of all the variables in scope, if you've got 20 vars related to your html template and 15 related to sessions and 10 related to user access level and 38 for advanced searching parameters and 9 for pagination and 18 for search result item html output and other things, that's a big flat puddle of shit to sift though. If all vars that had a meaningful relationship to each other were encapsulated within a single object built for that purpose, the number of vars you need to dig through would be reduced because "If the bug is related to pagination I only need to inspect the pagination object internals and the few lines of external code that utilize the pagination object". 
Another vote for Fedora - I was getting annoyed with Win10, Ubuntu never really worked well for me, and so far, Fedora 24 has been smooth and stable for me.
&gt; why do people insist on using OOP, which splits up your code into classes which are driven by a main index page, when you can simple write each separate piece of functionality in it's own file and call it when necessary? The simple answer is they don't. Most developers will probably insist that you choose the right tools for the right job; also when it comes to OOP. Even though I usually use a framework for larger things, I wouldn't necessarily use OOP for simpler stuff. Most cronjob scripts I've made is either written in procedural PHP (or even just a Python script). When it comes to routing of URI's, I tend to find a suitable Router class (written by someone else) very useful instead of using plain PHP files - this also gives me the ability to easily get pretty URL's. But again, if it's a single page landingpage - no need for this. &gt; Should I only be using classes and objects for things that are called many times across different files? "Should" is a misplaced word - I would use "could" instead. I use OOP when I want extendable reusability or if I want to share something with the community (also because of extendable reusability). Combining your OOP programming with Composer's autoloading and PSR-4, developing gets so much more easy (IMO). &gt; If so, why is this better than a globally defined function and set of variables, that don't require the -&gt; to access? Well, global functions and variables could quickly become quite a mess if the project gets large enough. With namespaces you've enabled yourself to scope your methods and variables in a more local context for your uses. This might seem unnecessary to you when thinking about use cases, but it's not uncommon to suddenly have multiple class names that are identical, only separated by the namespace. Pretty handy. The conclusion probably is; do whatever rocks your boat.
last time i tried it, it can't run vagrant nor docker yet
I have tested all Ubuntu distros and it's flavours. The LAMP stack is running "out of the box" and that's fine. But the main problem (in real life) was Microsoft Office (Word, Excel) and everything that has to do what special hardware (drivers etc). After a long and arduous journey I am back at Windows 10 + MS Office + XAMPP + Special developer tools and happy with it.
Umm, whenever you need `state` maybe?
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; using OOP, which splits up your code into classes which are driven by a main index page Having a single point of entry to the application has many benefits. All major configuration at the point of entry. All access to any part of the app has to go through the front door and can be properly logged / redirected / blocked etc. I've got old projects with php files in all kinds of sub folders and I have no immediate idea what some of those files do. There was a 3rd party who is supposed to be copying lots of data from our client's database once every 12 hours via php file in some subfolder. It turned out they were doing it for every page load on their site! We missed that for years because nobody remembered that php file was there and we couldn't simply add some logging to the **single entry point** of the app to discover it. Sure we probably could have done some logging at the server / apache level and spotted it but nobody there was a server / apache expert.
Open/LibreOffice was not enough? I haven't had MS Office installed for many, many years..
OS X for me. Moved over from Windows about 10 years ago and would never touch a Windows machine again. To be honest any *nix based OS would be acceptable for development. Windows however is just, bluntly, a pile of shit.
Debian Jessie with i3. I wouldn't trade it for anything in the world. The native docker support allows me to isolate my work environments without incurring any performance overhead. i3s customizability keeps my screens free of any distraction. Application windows accessible to sensible shortcuts and separated into workspaces so my shell can stay pinned when I switch between browser and IDE. This last one saves me the rage and loss of focus of using alt+tab/cmd+tab on dual-screen windows/OS X. Since I got this setup, my RMBP became a $3000 facebook machine. To all the Windows users at least, making use of Linux features might come with a learning curve, but once you get accustomed to having a proper shell and a package manager you just can't go back.
&gt; so why create an object to hold and manage that data when you are dealing with one user? Why not simply collect that data into a set of variables and manipulate it how you wish in a procedural fashion, which to me seems much easier than having a separate class file, including the class file, creating and initializing the object with the data and then accessing the object to manipulate it. So I have this database table with 80 fields. Over 60 of those fields need some kind of enhancement to turn their value into something worth showing to a visitor. 90% of the time any record from that table is show to the user, at least 20 of those fields are shown. I have a dozen other tables with far fewer fields. But some of the field names are the same in all tables. I have 1 field containing JSON data in all tables. I have a function named categorizationFromJSON that enhances that json data. But in almost every table that function needs to do some things completely differently from the others. So for each "idea" or "entity" that is represented by a database table, I have a corresponding class that contains all functions that are specifically built to work with that table. That means each class has a method named -&gt;categorizationFromJSON. categorizationFromJSON is the absolute best function name for the job it does and I think it makes the code more understandable to be able to have that same method name attached to each entity object instead of a bunch of similarly named global functions. The same can be said for every same-named field that exists in every table that needs enhancement before being shown to a visitor. But I also have a general DisplayEnhancer class that contains functions that can be applied to fields that always need exactly the same enhancement no matter what table they are in. I realized one day that the 1 field most often shown from all tables should be enhanced differently based on some global configuration option. And there were a dozen other fields that also reacted to that same configration. And to go to every location in the code where that field is echoed and change the logic around it was arduous! It made sense to collect all those value enhancement functions that involve that config option into a single class that takes in an array of raw database values and then use a method of that object whenever I want to echo the nice, user friendly version of certain values. No more duplication of a bunch of damn if-statements and string manipulation in dozens of places. No more bunch of similar but different global function names. The DisplayEnhancer class also caches the enhanced values after an enhancement has been done. So, on a page that lists a "summary" involving 18 fields, followed by a "full report" involving all fields, the 18 enhanced fields displayed at the top are cached so when they are displayed again at the bottom, no work needs to be repeated. Could that have been done procedurally, yes of course. On that one page. Then done again, procedurally, on the other page where it's needed. Then done a 3rd time, procedurally, on the other page where it's needed. Or I just identify something that happens a lot and gather it into a reusable, configurable, *inheritable* class. Sometimes classes can be used as just a function with far more options for making it flexible. Imagine someone using a programming language that didn't have variables or functions or classes or closures. That doesn't sound very flexible does it? Sounds like hell. Now upgrade them to a language with variables. Would they ever want to go back? Now upgrade them to a language with functions. Would they ever want to go back? Now upgrade them to a language with classes/objects. Would they ever want to go back? Now upgrade them to a language where the value of a variable can be a function (closures). Would they ever want to go back?
[removed]
Docker and Vagrant has worked pretty well since Windows 10 got officially released. Docker can now be run natively on Windows 10 so no need for VB. Vagrant runs really well on Windows 10 as well, you should probably give it a try. :)
At work I use Ubuntu with Vagrant to replicate our servers. For home use, I use Windows 10 and Vagrant. 
[removed]
OSX (or macOS now). I might give new windows with ubuntu built in a try though out of curiosity.
When? When your project roughly grows over a thousand lines of code. Why? Because is organises your code nicely without too much extra work.
Well, for perm employees in the UK, most do not need an accountant and so do not have one. Yes, most of them will pay into their own pension, but their employer will make contributions too. True, not many perm employees have a company car, but some packages include one. I guess the point I'm making is that contractors are opting out of more things than at first is obvious. 
I was lucky enough to "learn to learn", or at least, "learn that I needed to learn how to learn" in high school. I had a teacher that was working on his masters and I said something to him. I don't recall what I said to him at all but I recall the gist of his response which was "Professors in college don't care if you show up to class or not. They aren't going to make you learn. You are going to have to learn on your own." His response blew my mind. I was like wait... I come to school and sit in class to learn don't I? I come here so teachers can teach me... don't I? Then a light bulb just kind of clicked. I can learn all this on my own. They had to learn it on their own. Ever since then it's just been a matter of what I wanted to learn.
Elementary OS, its Ubuntu based but looks very mac like, its probably the most well polished Linux distro there is.
The tool chain in Linux is far more mature than that of Windows, you have to constantly force things to happen in Windows that a re a breeze to do on Linux or Mac. I always find it bizarre that people use Windows to develop then all their tool chain is Linux based (testing, revision history, integration, deployment and servers).
For pensions, an employer will make a contribution, but it is largely paid for by the employee. As a contractor, I personally pay zero pension, but my limited company makes a large contribution and it's tax deductible. So pension wise, I'm far better off as a contractor. As for transport etc, again, I'm better off as a contractor, because I claim it all as an expense to my company, which pays me back, and again, it's tax deductible to my company. Company cars are heavily taxed if you are an employee either way, so they aren't really a benefit one way or the other. Things you are mentioning as issues with becoming a contractor, really aren't, they are benefits. I also disagree with your remarks about companies letting you go. It's very easy for a company to let you go with very little in terms of a "reason". I think I've had more job security in my years as a contractor than I did as a permanent worker.
&gt; but I simply I wouldn't use anything without a decent command line anymore. http://cmder.net/
Of course. My question is about the just about the PHP Backend 
Your repository was actually very helpful in my efforts to get PHP and Laravel working on Lambda. Thank you for publishing it!
Unfortunately it still doesn't come close to a *nix terminal :(
$array = [3,4]; foreach ($array as $key =&gt; &amp;$value) { $value += 2; } $value++; var_dump($array); // Result ? // A. array(2) { [0]=&gt; 5, [1]=&gt; 6 } // B. array(2) { [0]=&gt; 5, [1]=&gt; 7 } // C. array(2) { [0]=&gt; 3, [1]=&gt; 4 }
Arch Linux. 
I feel the same way about my Chromebook
no need for boot2docker vm anymore?
Cygwin does the job for me whenever I have to work with a Windows machine. I'm far happier using iTerm 2 though.
Linux Mint + i3 as window manager works perfect for me.
No, people sign their posts with "The Secretaries".
OpenBSD whenever I can (e.g. home) It' the most stable OS in existance. Its so amazing that their OpenSSH becamse the standard ssh server everyone uses
Thats insanely slow though compared to a native solution.
Obviously, a wrong packet size should not be fixed with our package, that is crystal clear. Pinging, instead, it's not always a feasible solution: i.e., you can have a single blocking call (external WS, I\O bound call...) and, when you get back from that call, it may be too late to ping the DB. This package simply reconnects to the DB for you; it also avoids doing that in edge cases, for example if you lost the DB during an open transaction, which (obviously) could not be recovered.
 var $state = "stuff"; What’s wrong with this state? Procedural programming has it as well. It’s just managed and moved around differently when using OOP 
Same here, except I'm on stretch because I prefer up to date packages to system stability, but that's just a preference thing. Once I started using i3 on my laptop I installed it on my main and work computer as well and I could never go back. Once you get used to the tiling layout everything else just seems like unorganized clutter.
I'm currently on kubuntu mainly because it has php 7 and Debian stable doesn't yet. 
So you say its like 50-200ms for a request. But the real question is, is it still 50-200ms with 100 concurrent requests? 
I guess ubuntu is more up your alley then.
I had some permission issues causing the docker GUI to crash right after installation. It went away when I configured hyper-V to store the image files on D:\
Last time I checked stretch packages were more up to date then the latest Ubuntu release. Also free software is important to me and I'm kind of a minimalist so I'm quite happy with debian.
How long have you been using it? I tried it like 3 years ago and it was kinda buggy and clunky, even though it looked nice. I'm just wondering if they made some progress.
&gt; Function-as-a-Service (FaaS) product. Dear God, how many *aaS are there. I'm gonna create my own lemonade stand where you mix your own lemonade and call it LaaS. At least i know that the developers and IT people will rush to buy it. 
Thanks . looks like i am using external volumes only:) Never knew this benefit
I prefer to write small bash scripts instead of TL;DR instruction manuals for the devs, whenever possible. The other day I was trying to make one of these scripts work on the machine of the last guy on the team to still run windows. I got stuck at escalating privileges on demand to be able to write to C:/windows/system32/drivers/etc/hosts. Something as trivial as sudo is [a major pain in the ass on windows](http://stackoverflow.com/questions/19098101/how-to-open-an-elevated-cmd-using-command-line-for-windows). You can instruct the user to run bash as administrator by searching for the binary and right click -&gt; run as administrator, but I also needed the '-i' flag to bash.exe which you can only add if you run bash from command prompt. Dude I just wanna add a line to /etc/hosts.
I myself really like the hooking system of Drupal. It's a simple and really powerful tool and makes Drupal really modular.
I was going to, but I'm off on holiday tomorrow and ran out of time :-) Theoretically this is exactly what Lambda excels at, but you're right, concrete benchmarks would be useful. I'll see what I can do.
I've been using it as 0.1 and went full time as my main desktop on version 0.3. Even at 0.3 it was 'okay' for daily use but as you found yourself there was a few annoying little things, nothing that would stop you working but things you thought I wish they would fix that. 0.4 now though has pretty much smashed all the bug reports and has made it a massive release, its definitely worth giving it another look, even if it is just in a VM, its come a long way even from 0.3 to 0.4
sry, should have been clearer: not my repository, just tested it. All credit to awspilot :)
Ah okay :D
Adminer
You can „return data” using events. [Look at Symfony Framework Events](http://symfony.com/doc/current/reference/events.html#kernel-controller) for example. You have some state, pass it along with the event and allow the listeners to modify it. Then, after the dispatcher notified all the listeners, you retrieve the state back from the event. It may be the same, it may be completely different.
But you can also fire hooks whenever you want and pass data to the hook. I am not sure what the difference between events and hooks are..
Been using it for nearly two years, across two major version upgrades, and it hasn't broken once. In my experience it's the perfect mix of stability and new packages.
That's not true. It just doesn't need VirtualBox anymore, but it still runs on a boot2docker linux vm via Hyper-V. They just improved the toolkit so greatly that it's harder to notice.
I have no problem with the toolset. It works very well I agree. But in my personal opinion Microsoft is making some poort decisions, one of which is randomly restarting my pc when I'm getting coffee and destroying any unsaved work without asking me and then incapacitating my machine for 30 minutes while it updates. Don't want to rant, I'm just looking at alternatives as I see my satisfaction declining. There's other reasons but that's the main one. 
still no boot2docker anymore though
Not that this solves the issue mentioned by /u/RichardFuchs, but that isn't the case at all. Simply run notepad as administrator and you can edit it. Even better, if you edit it with notepad++ and forget to run as administrator first, notepad++ will warn you that it needs to run as admin and it will then close itself, re-open as admin, and you don't lose the changes you typed before it was running as admin. 
What makes you say that? I'm using both Win10 and Ubuntu for development on different machines (not VMs) and I don't see any performance differences when using the terminals nor when using the various tools/programs (reverse search, grep, less, curl, ls, etc.).
Honestly, for me it really boils down to logic. I'm not sure how to phrase it - but if you think about it, our world consists of objects. A street lamp for example is an object with a height and it can glow and all that. A printer is an object with information about what components it has or needs and that it can print. Now, when I talk to a client, they also use these abstractions as they are normal for a human to use. They say "I want a blog where I can create posts, edit them and have them be displayed. I want them to consist of a title and a body". And doing that in a reusable fashion is so much easier with OOP than with procedural programming - I write my post object (and have it be auto-filled using Doctrine since my model is a mirror of my database structure), let the user create them (and persist them automatically, because again, they have a structure), and all that. Basically, it's about being able to do what the client wants without having to think "how would a computer do it" and about being able to reuse code as well as having everything neatly split up.
Because Photoshop and Excel are still a part of people's work. Also Outlook, I guess. edit: Downvoted for describing actual work circumstances. I also wish it wasn't real, but it is. 
I don't have a Windows system to hand but I think in the past I've typed `notepad` into the Start menu, right clicked Notepad's application icon and then clicked on "Run as Administrator" to edit the hosts file as Administrator. Which is nowhere near as fluid as just typing `sudo vi /etc/hosts`, but it beats copying files around.
Can confirm (at least if the updates are configured correctly so you don't miss Kernel security updates etc). I have been using pretty much all the main Linux desktop environments and Cinnamon 3 is my today's choice. A few Virtualbox guest systems for development servers and additional operating systems + development tools like PhpStorm and that's a wrap.
Same. The forced updates are too much. I'd switch to Linux if my games would still work.
Count me in. Debian SID. XFCE and Sublime Text. I like having all the [php7 stuff](https://packages.debian.org/search?suite=sid&amp;arch=amd64&amp;searchon=names&amp;keywords=php7) apt-getable easily. Switched from Windows last year. Still have it dual booted for the games that are not on linux. Have not boot on it for a month now.
If you have Car with method getYear(), and a subclass Truck which extends Car, you know both have getYear, thats why you can narrow the return type without breaking the contract, what you can't do is make it wider, i mean returning a superclass. Just because Car has getYear() doesn't mean Vehicle has it
`&gt;&gt;` is already a token. 
I recently switched from a Windows 8 PC to a Macbook pro with Thunderbolt display. It's easier than keeping two or three computers in sync (not just talking about git for files but settings, browser tabs, everything is the same everywhere I go). I like this setup way better.
Everyone's situation is different, but I personally wouldn't stray from Mac or Windows machines. I'd love to use a Linux machine for development, but: 1. I need support for the common productivity tools, especially in regards to things like word/excel docs sent from customers / customer support (Hard to get right in Linux-based machines). 2. Linux issues with things like video/sound drivers, microphone support, wifi, the list goes on - these are a huge time suck. Valuing time highly (sometimes directly by paying money to waste less time) is an important skill Mostly my experience with Linux desktop machines has been wasting time learning about weird edge cases that don't aid in getting work done, and actively work against me in other activities that are already getting in the way of work (remote sessions, skype - or similar - meetings, video playback, reviewing files).
Damn, if only I'd suggested some other alternatives...
Cmder is an expedient, and is by no means close by any measure of functionality, power, or speed. A quadriplegic is still a person, but my money's on Usain every time. Don't kid yourself.
Those are really good points! $this-&gt;assertEquals($time, $money);
Debian Testing with PHPStorm. I'll follow Stretch into Stable for this system, though probably make heavy use of Backports to keep up with the latest and greatest on a few programs. Running Vagrant for my actual environments. The specific environments vary from project to project. One is using Scotchbox, which is Ubuntu Trusty Tahr and PHP 5.6. Another is using a vagrant box that I built myself that's also running Debian Testing (again with plans to follow it into Stable) and PHP 7.0
My work laptop has to run Windows, but I have admin rights and they don't care what I install on top of it (as long as it's legitimately work-related), so I have a Centos VM that I use for my development stuff. Our servers all run RHEL, so it works pretty well as a test bed.
OSX. Need actual unix tools and the ability to run programs like Photoshop without the hassle of Wine. 
And yet people vehemently defend Windows as a legitimate open source development platform. I like Windows as a general purpose operating system, but there's no substitute for a *nix system for doing open source development. If all you're doing all day is writing C# and .Net I can see Windows being your main OS, but not for literally everything else....
I have no idea why there are so many fanboys of VS. It's the slowest IDE I've ever used. Even Eclipse is faster. And I'm using an i7 with 12GB RAM and an SSD. Intellisense is very very buggy and sloooooooow. Often waiting for 5 seconds untill *anything* sensible happens. oh and every few minutes VS appears to scan the project for half a minute which makes it even slower
All these suggestions are fine. I honestly don't think your local environment matters much as long as you understand how it relates to your test/prod environment and you're comfortable. I think it's very valid to try to match your environments as close as possible, but as long as you understand differences and can compensate for them non-idiotic ways there's no reason to force it. Use what makes accomplishing your tasks easiest/most comfortable/intuitive/whatever you find important. I personally find the Linux shell to be a huge advantage over a Windows environment. OS X has a great terminal, but I can't stand window management on OS X. I work in a virtual machine 99% of the time, Ubuntu 14.04 most often at the moment. I use Windows the other 1% of the time, mostly for quick things like an update to a test server or something where I'm not really working locally anyway. My primary work machine is a Windows 10 host with Linux VMs as needed. I'm rotating between 3 Ubuntu machines right now for different projects. I recommend virtual machines any time someone asks because you can try things without disrupting your established workflow. Try it, decide if it's something you like, keep it or throw it away. All while having your familiar setup untouched. I destroy my VMs constantly because I'm not scared to do it. I can just reload a snapshot or backup and be right back where I was. If you don't need high performance graphics, I don't see any reason to work native anymore.
I'm using Arch Linux as a OS and VIM. 
Same here. I need Windows for Photoshop, though.
I am not alone
I wouldn't say pile of shit. What I would say is that it doesn't bring anything to the table. Unless you're doing Windows-specific development I just don't feel it does anything better than OSX or Linux. Except for gaming. Hopefully that problem will get solved eventually and I can leave it behind.
I am so glad I haven't had to deal with Office in several years.
OSX with [Fish Shell](https://fishshell.com/), with [MAMP Pro](https://www.mamp.info/en/) as my local server, and [Pantheon](https://pantheon.io/) as my development/production environment.
I would like to obtain the connexion string created by oci_connect so I can fill the information in sql developer like what sid is used.
[removed]
I use OS X at work and Xubuntu 16.04 at home. A lot of my development is done within a Vagrant box running what ever the production environment will be. Some times Ubuntu 14.04, Debian 8, or CentOS 7.
I'm with you. Although I wouldn't mind any OS anymore. Since the production servers rarely run on windows, having a Linux distribution or MacOS doesn't give the immediate benefit you want to have by emulating the production environment. So I would always run with it in the future, since I am comfortable using it.
If you're programming for a propitiatory environment using something like C# then Windows makes sense. It's tool chain is touchable in this circumstance, Visual Studio is one of the best IDE's I have ever used. For open source languages I just can't for the life of me understand peoples decision to develop in a Windows environment rather than Linux/Mac, it really doesn't make sense.
Microsofts best decision is trying to shoehorn a Linux command line into its system
You sound decidedly anti-MS for no other reason than to be anti-MS. As a developer who touches both OS's on a **daily** basis, I can tell you both environments have their pros and cons and while I personally prefer *nix, there's no sense in painting the Windows environment in such an unreasonably harsh light.
&gt; OpenSUSE I must give this another look, I never got on with it years ago, might be worth another try
I went from Windows to Linux to OSX when starting development using php and Python. Windows to Linux was a game changer, but ended up on OS X because I found a good deal on Craigslist and needed applications like photoshop, illustrator, etc. Tried getting a php project running on Windows again last week...I gave up. I'll stick to OS X/Linux for Linux development and Windows for .Net and gamedev. 
I still was having a hell of a time setting up my VM to work with a local folder and server on Windows. I ended up giving up since I was only doing it to see if Windows had gotten better. 
Another i3 user in the house! wut wut! /kidding seriously though, I love i3 to death. I've tried and tried to find something similar in windows and virtua-win is the closest I've gotten. I've even remapped the desktops to alt-1/alt-2, etc, although it pales in comparison to i3.
Out of interest what advantage does using Windows give you over Linux or Mac? Obviously you've now seen the advantage of a proper terminal with the Bash On Windows stuff, does it not tempt you to enjoy all the other goodness?
I use OS X but have a gaming machine with Windows 10. Just can't hater into the Witcher 3. I swear I have started and stopped at least 15 times now. 
You can use a chromebook for development?
I do the same, linux guests on a windows host. It also means I can tailor my environments to my clients while maintaining my gaming habit :)
Interesting points, I wonder how long ago it was you actually tried Linux for these to be an issue. 1) Libreoffice has never failed me in this department, its always been able to handle the propriety formats without issue even though my current role the office is completely on GoogleDocs. 2) This is the biggest surprise and makes me think your trail of Linux was dated because driver coverage is extensive. I as given a new Dell laptop for work along with the Dell USB3.0 dock, I thought there is no way this dock would power 2 external monitors, handle the networking, the 5 extra USB ports and audio through one USB cable.... fired up Linux installed the display link driver and it just worked... even I was pretty taken back by that.
I did the same as this guy but only 4 years ago. I still like Windows and have a machine with it (gaming rig, .net development), but if I'm working on an open source OS server, I'm developing on my Mac. I even recently tried to get my Windows machine setup to work on a php project I have going and after a week of fiddling, I gave up. I got it running, but ran into issue after issue and finally had to run everything inside a VM which basically means I was developing in Ubuntu and not Windows. I still love Windows though. I prefer the UX and the UI, and working in .Net recently has actually been really good. 
I actually like Windows 10 a lot. A lot more than I thought I would. 
MacOS is the answer. 
mac
Mac or Linux is the easiest. I started to dev only on my mac just for ease.
Ubuntu 16.04
&gt; I worked on a java project for about a year using Eclipse - it was the worst piece of shit I've ever had the displeasure of using. Buggy, slow, crappy, wouldn't compile, error messages were convoluted and cryptic, crashed more often than not. It made me want to quit being a programmer, it was that bad. I absolutely agree and I still stand by my point of eclipse being better ;) &gt; What version are you using? 2015 Community Edition
&gt;2015 Community Edition Haven't used that version. I'm on VS2015 Enterprise. Works great for me and the stuff I do.
&gt; you can manage non-global state using procedural style of programming, it’s just different How? Care to give an actual example?
I wonder which one is better: 1. Install commonly used `ext-*` on your php image, even if you don't need it, and share it on every project. Or, 2. Install only `ext-*` you need, but you need to build your php image on every project.
I do webdevelopment. I host my own [codiad](http://codiad.com/) instance (Open Source cloud IDE) and use [Secure Shell Chrome plugin](https://chrome.google.com/webstore/detail/secure-shell/pnhechapfaindjhompbnflcldabbghjo?hl=de) to connect to my servers. I love the Chromebook becaues it's amazingly fast and the battery holds a whole day of work (8-9hrs) Also I use stock ChromeOS (not corouton to run linux on the thing) because I simply don't need more. For Docker I have my remote machines I SSH into. At first I was skeptical too and to be honest the first half year after I got the Chromebook I almost never used it but now I love it and almost use it exclusively. I'm also a sysadmin and thanks to the RDP Plugins I can use my Chromebook for that too. Even made a [blog post about it some years ago](https://blog.haschek.at/post/f3661)
I solved this issue a different way: Ubuntu at work, Windows at home + Ubuntu on VMWare for the emergencies
I regret that I have but one upvote to give you, sir. /salutes
HeidiSQL is amazing. Wish there was a native Linux version. 
i feel for you bro
&gt; Install only ext-* you need, but you need to build your php image on every project. If found its better to install what we need 
my serve box runs Ubuntu Server from command line - its like a more awesome version of DOS to me. can also run the server with no GUI to save some resources, not sure if windows can do that. my personal pc has windows 7 and i refuse to update to any newer OS. 
Does codiad handle bash, dependencies, etc? Is there version control support like git? How do you handle image editing? Can you have multiple instances of the ide open at once? Can to get plugins for it? Does it have laravel support (linting, intelligence, etc)?
Because Photoshop is not available for OSX?
Manjaro Linux. After the intial learning curve, I found it is WAY better than Ubuntu: at least for me. I am heavily involved in Wordpress development.
... could've used a better analogy.
[phpmailer](https://github.com/PHPMailer/PHPMailer) and [tutorial/guide](http://phpmailer.worxware.com/?pg=tutorial)
Nice!
Mod abuse.
Yes this is official! We sent out announcement emails (https://app.mailerlite.com/c4b7x6) to all the email signups yesterday, you should have received one. It might have gotten caught in another email folder?
Awesome. I've recently started getting into C# because I got sick of JavaScript ad they didn't have php. Time to start on that now
CHRIS WHITE IS MY FRIEND
Windows 10 because I do alot of other development and gaming.
We do our config management in Ansible and deployments from bamboo and jenkins (which will hopefully all be migrated to jenkins some day). We use the default vagrant generated key for our local dev environments. We devs rightfully don't have direct access to the production systems. I couldn't tell you what we use for SSH management in QA, staging, and production. That stuff's all hidden away in the spooky sysadmin forest.
I am self-educated and I ruined college.
Oh no you caught me.
Seems to me that supporting Debian while also trying to provide pre-release software was doomed to fail from the beginning. Debian is one of the more stable OS's; why is anyone trying to get pre-release software on it?
You could use middleware too, event driven programming can drive you insane if you have to much stuff going on.
Great to hear it! We're just officially announcing it beyond the Codewars community itself. To this point we've only shared the support with our users. 
If the post were titled "Hey, does anyone know how to update this sentence", I might have replied with a link to the documentation on how to contribute, then taken the 10 seconds to just do it. Instead, you've opted to whine, so I've decided that doing something nice for you wouldn't be a good idea. Instead, I'm going to sit back and watch you have your tantrum because the free thing you make a living on doesn't have enough people doing free work on it to keep a digit in documentation up to date. At least, I have to assume that's what you're on about since this post doesn't even rise to the level of bug report. You only cite "Something is out of date". That's super helpful.
For somebody who complains about documentation, you seem to have an inordinate amount of trouble with reading comprehension. The site clearly says that for 7.1. Not 7.0. Do you know how semver works?
Ah so that what might be confusing me: events (as used in symphony) are really hooks, or quite similar to hooks. So they are both bad practice? I will definitely take a look at your article, sounds really interesting! Hopefully interfaces can provide enough flexibility to extend my framework.
Just FYI, "functional" is not a synonym of "procedural". You're doing procedural programming. &gt; So why should I encapsulate those into a class when I could just have them in global.php, included across my project and call them whenever I want. Because in any bigger project you'll have more than one database, and more than one database connection. That's guaranteed. Maybe you'll never reach that scope, maybe you will. Why risk it? An object is not more complicated than what you have. Instead of this: createConnection(... login...); $result = queryDb($query); You have this: $db = new DB(); $result = $db-&gt;query($query); But now you can have multiple $db. You couldn't before. &gt; At the end of the day, my question is, why do people insist on using OOP, which splits up your code into classes which are driven by a main index page, when you can simple write each separate piece of functionality in it's own file and call it when necessary? A class is also "separate piece of functionality in its own file [you] call it when necessary". The key difference is that objects have **state**, and functions don't. State means each object can be configured to behave differently depending on data you pass in constructors and methods, and then pass this configured object to those who need it. Imagine your database grows and you split your data in "archive" and "production". You will write stale data to "archive". The rest to "production". How will your functions do this. Will you copy/paste all the database functions? OOP makes this simple: $productionDb = new DB(... production login...); $archiveDb = new DB(... archive login...); With functions, you can use globals to configure them... but then you have one possible configuration throughout your entire project. And that doesn't promote code reuse, it's almost always short-sighted, because often it's the case you can reuse the *same class* through *differently configured objects* in the *same project*.
your comparison is a bit unfair though you are comparing Windows GUI with Linux CLI. It would be more fair to compare either GUI for both or CLI for both.
windows equivalent is: runas /user:administrator notepad c:\windows\system32\drivers\etc\hosts 
1. yes 2. just webserver + php 3. Yes, git supported (can also be done via SSH) 4. Free tools by google 5. Yes but the IDE has support for more projects so you wouldn't need multiple instances 6. Yes, quite a few actually 7. probably not
The problem with chromebooks is their ugly useless keyboard too :( How can you live without F1-F12 keys or home/end/pgup/pgdn/Del/Ins? Especially for programming I can't do without those keys. This is why I use Thinkpads, their keyboards are just much better.
Any plan on creating docker-compose files with puphpet's configuration interface? I love your interface and used it for the longest time. It's the best server configuration interface I've tried. but stuff just randomly fails over time, for all sorts of reasons. To a level, I have to gitignore them from my projects, because each config is only good for a period of time. i.e. same config used 1 month ago may not build correctly anymore, due to version problem. Or, even for newly generated config, I have to get rid of some apps so it can build smoothly. Recently went to learn docker, it's tricky some times, but easy, and gets up much faster. 
&gt; I love your interface and used it for the longest time. It's the best server configuration interface I've tried. I've tried trimming the GUI down as much as possible, going through several iterations before coming up with what you see now. It's good to know someone thinks it's a good interface! As for the stuff randomly breaking after a time, this is what's given me the most headaches since I started puphpet several years ago. Things working _today_ have no guarantee of working tomorrow, due to the nature of the project. What I mean is puphpet depends on several 3rd party repos I have no control over. Sometimes it's little things that change, like in [CentOS the `centos-release-SCL` packaged being renamed to `centos-release-scl`](https://github.com/puphpet/puphpet/commit/f45f20d59fabab2a095e46cd2dc8e1b6d21b1885). Sometimes it's huge things like [repos being deprecated and no longer working](https://launchpad.net/~ondrej/+archive/ubuntu/php5). The problem is there's millions of VMs generated by puphpet in the wild that continue having this old code, which simply no longer works. Big or small, each separate problem can completely break the provisioning process, and all I can do is react to changes and push fixes as soon as I can. I'm currently learning Docker, and while it is interesting technology, I do not believe it would benefit puphpet much. Most companies do not deploy via docker, and docker seems to be more suited for fairly static configs, not this pick-and-choose method from puphpet.
Yes, totally understand why it's happening, that's why I feel docker might be a good fit with puphpet's interface. 1. each application page in puphpet, there's very likely an image in official repository to handle it, and ensure versions work (i.e. this is for PHP: https://hub.docker.com/_/php/). So, each app enabled, can be based on these official images. 2. for detailed configurations, like php extensions, docker already prepared lots of them, just need to call `docker-php-ext-install` in php's DockerFile. (details in https://hub.docker.com/_/php/ as well). 3. other configurations like nginx site conf, just need to generate the corresponding file, and link the file into docker image. 4. for docker's file structures, you may take a look at this project, I'm not sure about his decision to use ubuntu as base image for each app component, but the way he place all the configurations seems really nice. https://www.reddit.com/r/PHP/comments/55tnsa/docker_lamplemp_dev_setup_mysql_v80_dr_now/ It might turn out to be a surprisingly easier adaptation.
I can deal with the F keys but without delete it sucks 
$str = "racecar"; $str == strrev($str); Right?
Basically, yup. It's super super easy. But it can be a stumper, and one we like to ask to JR Devs.
I once interviewed a guy with 10 years php experience for a senior web dev role. He knew the trick with the % operator, but for some fucking reason, I dunno, he started using an array he hadnt initialised and included a count() of said array for fuck knows why. when he presented the code it didnt even do what he reckoned it did. I was aghast. He didnt get the job.
&gt; So they are both bad practice? Well it works fine for Symfony so it can't be all bad, but in some scenarios it's limiting. For example for dealing with HTTP requests I prefer using PHP middlewares instead of hooks because they use composition around a simple PHP interface. In most scenarios I prefer having clear interfaces and a clear workflow of "who calls who" (which, with interfaces, doesn't mean more coupling) rather than hooks which make the whole thing very fuzzy. However hooks have the advantage of being easy to subscribe to (at least until you meet the problems of priority between subscribers, then it's a mess). When using interfaces instead of hooks having a good dependency injection container (with module support/extensions) often helps because wiring everything together is a bit more work.
What do you find to be the big improvements?
Windows 8.1 + Vagrant
These needs to be a thing. Im very not used to coding without syntax XD First world problems
Hi Reddit, We/RealPage are still hiring PHP Developers as leadership has added more to other groups, some are working on Rentjoy, ActiveBuilding, OneSite, Answer Automation and various other legacy or new projects. We still want onsite ideally in North Dallas or Louisville, KY (based on last comments, I want to state that we are Talent/Recruiting and do not make policy, this is Hiring Manager descretion). We are open to help with relocation if you are open to it; we will sponsor/transfer visas, but doing both for one person seems like it might get out of range budget-wise. Most of this work is with Laravel framework but some of our best have come from other mvc type frameworks. We have placed 9 of the 10 original spots, and are looking to add to the teams. We just moved into a large new corporate HQ, you can see pictures on the @realpagecareers twitter page or www.facebook.com/realpagecareers. If you are in Romania, Hyderabad India, Barcelona Spain or the Philippines (Manila or Cebu), please reach out to me as we offices in most of those locations. 
PHP WTF? var_dump(new \DateTime('first day of this week')); https://3v4l.org/GIPKR http://imgur.com/a/acG5r 
&gt; it seems its more heavier and did not find any advantages in using that It creates a LOT smaller images. It could even less than 30MB, if we use minimal `ext-*` or only using default `ext-*`. It just needs some time to learn how to install the `ext-*`, what dependencies to install, and what/how to configure it. But it worth
Awesome, thanks! I've been waiting for 16.04 for a while now, glad to see it's ready.
I actually hide it. But in case of maximum execution error, PHP process is terminated. Do you have any ideas to catch it?
I feel like it's kind of a big jump between &gt; how do i share methods between classes in php? and &gt; what is a dependency injection container? Maybe it's because DI confused the shit out of me when I was learning.
I started using OS X at my new job and I just can't do Windows anymore. I bought an iMac and I'm waiting on delivery. The wait. It's killing me....
SOLID Third one means Liskov Substitution Principle. In practical terms it means the child class must pass all the parent's unit tests (present and future). In more technical terms, it means the overriding method's preconditions must be of equal or weaker strength, and its postconditions must be equal or stronger. &gt; Java, for example, always calls a parent implementation automatically. I wasn't aware of this. How does this work?
&gt; Java, for example, always calls a parent implementation automatically. Only for the constructor, not every method AFAIK. So you can do this in Java, as well. &gt; I believe if there is a need for such a replacement, then a composition should be used instead. What are your thoughts on this? Composition is always preferred, when possible. Inheritance is just a shortcut, and it allows us to break the encapsulation of an object, as you yourself have noticed. It's a useful shortcut sometimes, but only when used with care. In terms of replacing a method without calling the parent, I'd say it may be ok if you maintain the method contract, even if the implementation differs. In other words both the external and *internal* consumer of this method should achieve what they intend by calling it. By internal consumers I mean the chain of parent classes.
When you write classes, and you don't have a clear story yet if this class will be extended, and by whom, what do you prefer by default for non-public members: - protected - private There are pros/cons to each, if you know how the class will be extended. But I'm curious what your *default* is.
&gt; I was raised to abhor globals and leaky scopes, so closures feel a bit icky to me. Why people seem ok now and so interested in letting a closure access the entire parent scope? Closures have nothing to do with "leaky scopes" or "globals". When you write this: $x = 123; $foo = function () use ($x) { ... } It actually gets roughly compiled to this: $x = 123; $foo = new Closure($x); So, you tell me. Do you feel "icky" when you pass parameters to constructors, methods, functions? Even in languages where this access is implicit, unlike PHP, the "parent scope" is not some foreign entity, it's also the scope that defines the closure. So a closure accessing a variable is as "icky" as the code inside an if {} or a foreach {} block accessing a function-scope variable.
Wow, the problems are very broken. eg; ✘ Failed asserting that two strings are equal. Expected: 'Hello $guest, my name is Bob' Actual : 'Hello Alice, my name is Bob' So, mine actually works... But it's not correct? 
OSX for a long time. Before that, Debian/Ubuntu.
Just read the ODM's docs. There are some instructions on how to configure it. Doctrine is framework agnostic, so you are free to use it anywhere. I just initialized everything in one of my ServiceProviders and registered Doctrine's Document manager as a Singleton.
How to get your DB hacked 101, plus you aren't even including the salt in the hash function.
Why do you think so?
mysql_* extension has been deprecated in php7 , so you will get a fatal error . you may use PDO or mysqli_* instead 
Too be honest, if it's an internal function that is only called when you've already validated the username it wouldn't be too bad. Whole function stinks though.
Another +1 on Windows here. Been using it for over 10 years and it still does the job just fine for me. In some rare cases I need Vagrant but that must have been a few times only.
I've never had issues with using php to solve problems, except for when I needed to use php's soap module. Php soap is pretty bad at pointing out exactly goes wrong when there are errors.
&gt; It's not a problem at all. Actually it is. In an office environment, you wouldn't be using a custom build. You'd be using a significantly more reliable machine from someone like Dell or HP. Your custom build will clearly be a better spec, but generally businesses wont touch custom builds when its so easy to just have a contract with Dell or similar. Compare an office grade dev machine with say, an iMac and the cost is very similar - you cant possibly try to compare the component/hardware costs and end it there - there's so much more to take into account.
Used to. But PHP is becoming an actual programming language, a lot has changed (to the better) in recent time. PHP 5.4+, or even 7, with some decent framework like Symfony and coding in PHP can be really good :)
The whole 'PHP Sucks' thing is a 10+ year old meme from when PHP was an inline scripting language. It isn't true any more, but the meme continues to propagate as a joke and is unfortunately also believed by the ignorant.
TL;DR just an advert for http://www.heliossolutions.in Every time I have outsourced to India it has been nothing but a train wreak of poor quality, un-tested, dangerous code
Omg can you get off of PHP backs already. Everybody hating on PHP yet 99% of people that jumped on this bandwagon 10 years late won't even be able to tell yku why...
&gt; 'first day of' Sets the day of the first of the **current month**. This phrase is best used together with a month name following it. [PHP DOCS](http://php.net/manual/en/datetime.formats.relative.php) What you're looking for is: https://3v4l.org/eQcJi
More like bring a huge multi-purpose tool to pick up a key. Associative array = numeric array = hashmap with order, and most of the times used as a linked list.
Lets see: Fatal from `mysql_*` in PHP 7. Obvious sql injection. md5 `$this-&gt;tblprefix` probabil would be better off with `{$this-&gt;tblprefix}` even better drop the `"` altogether, not really needed. For argument's sake things like `passwordsalt` should probably be enclosed in backticks, altough they're not reserved words. Just saying. Unnecessary assignment before `return`, might as well just return `md5($password).$row['passwordsalt'];` `"SELECT passwordsalt FROM $tablename WHERE mail =\"$username\" "` could simply be written as `"SELECT passwordsalt FROM $tablename WHERE mail = '{$username}' "` Salt should probably be stored in a file somehwere above the web dir not in a table Still using `mysq_l*` Still using `mysq_l*` Not necessary but would be nice: specify a return type, enforce a type for arguments. Even more: Not checking if the query actually returned something. I see a trying to get property of non-object in the near future. Or expected object got boolean. Taking a wild guess here but I'll bet dollars to donuts that the column `email` is not `unique` and doesn't have an `index`(given that it's not unique). Complete nitpick: Table name should be plural, model singular. So `user` should in fact be `users`. 
Depends specifically what kind of castle the princess in and what rescuing requires. If it involves creating a GUI desktop application with real-time 3D graphics, then uh, I might not like having to use PHP.
Humour is healthy.
No.
*Expected* is the output of your code.
Agreed, there's no difference, but as much as it pains me to say it. This is PHP, just because you can really doesn't mean you should.
I'm not gonna say PHP is completely suck-free, it's easy to take a scalpel to the language and find faults but you can do this for any programming language. I would rather comics like the ops find a humorous quirk or distinction with the language for that comparison rather than fall back on 'PHP Sucks' as the punchline without any context. I started working with PHP from PHP3, and I guess it just frustrates me when I see how far the language has come and how little the criticisms against it have changed.
Clearly.. example is an public facing API we're using that forwards requests to another service, we implement all the validation/security in the API so when a call is forwarded we know is safe to trust any data. No need to implement it in several places is there?
[removed]
So that public facing API knows details of the services it uses? So if e.g. you want to exchange the storage technology of such a service, you'll have to update that API as well, so that it avoids injections for the new storage. Does that sound right to you?
LI've used virtual box and vagrant in the past. I still use virtual box. I've used docker but I just don't get it. I don't know what it is and what it does :( So I don't need to install PHP on my workstation? How will I get linting?
I think it fit's well with the rest of PHP's oddities to be honest. Keep in mind that the constructor is technically just a magic method, same as __call, __get, __set, etc. So being able to override it without calling it's super method makes sense to me. And as always with the magic methods, magic always comes at a price ;D
This is a framework I've been working on recently called Synful that's not quite finished. The documentation is way overdue for an update, I'll hopefully be getting on that soon. Essentially the idea behind the framework originally was to stray from common practices for API Development while still maintaining speed, reliability and security. Keeping it specifically simple so that developers that are new to PHP could easily implement it. While this might be frowned upon being that it strays so far from common practices, that was my initial intent behind it. Originally it was just for fun, but it started to grow and now I have loads of things I want to implement into it. While it doesn't operate in the same way as common API Packages, it's still very versatile. With features such as simultaneous database connections, overridable encryption, the ability to run independent of a web server using pThreads and PHP Sockets, and customizable 'endpoints'. In Synful 'endpoints' don't work in the traditional manor. Instead, they are called 'Request Handlers'. These Request Handlers aren't defined in the tradition sense with a route. Instead, you pass a "handler" parameter with the JSON Request sent to the API. You then can create your own Request Handler that matches that "handler" parameter to manage the request and return a response. For end users, using the framework should be as simple as cloning it, configuring the database settings and tweaking the other configurations to your liking, and then creating your request handlers using ./synful createhandler The idea behind the name of the framework was attributed to the plan to create something that goes against the grain as far as common API Standards go while still maintaining a secure, fast and reliable framework. The name came from a mixture of two things. Firstly, the idea of sinning, derivative of the latin 'sons' which translates to 'guilty' in regards to omitting current standards. And secondly one of the primary current standards, RESTful. Like I said before, the documentation is somewhat lacking and outdated, but I'm working on an update for the docs very soon. You're welcome to browse the current code base and send me back any constructive criticism. Thanks for reading! :) You can view the actual framework via it's GitHub repo bound to this site: http://synful.io/
&gt; Also "Sunday last week" doesn't work if today is Sunday. true.
Having developed on Windows, OS X and several Linux distributions (mostly Debian-based, although I've used Arch before), I always tend to switch back to Windows and I'm currently using Windows 10 on both my desktop and laptop. My least favorite OS to develop on would be OS X. Sure, you can get a lot of stuff done with a proper terminal (iTerm2), shell (ZSH) and CLI tools (Brew &amp;&amp; Brew Cask), but there's always some caveats you'd have to keep in mind when working on OS X vs Linux. Weird filesystem paths, existing and often outdated software present on OS X, and BSD variants of CLI tools which are marginally different compared to GNU/Linux (looking at you, `sed`), but different enough to break things existing custom scripts. Growing up with Windows, the Apple keyboard layout and OS X established shortcuts are just kinda cumbersome to remember, too. I guess one gets used to it if one only uses OS X. It's not that I hate Apple or OS X or anything, it's just that I'm not really comfortable with using it on a daily base. So my Mac Mini is just functioning as a buildserver at the moment. Now, the main reason why I'd use Windows over Linux is that because I actually like Windows and I can play all my games on it, with proper gpu drivers, without having to fight Wine. Sure, Windows has its quirks, but I think Windows got really improved since 8.1 and I actually like Windows 10 quite a lot. It's fast, responsive, tablet mode is actually pretty cool on my 2-in-1 convertible laptop, and Xbox integration app is nice when I can stream Xbox games on my PC or laptop, which actually works surprisingly well. Linux is cool and I definitely use it for my servers, but I don't really need all the customization it brings on the desktop. I'm actually fine with using a Windows installation tailored to my developer needs. This includes a proper terminal and shell (Git Bash for Windows), IDE (PhpStorm) and either virtualization (Homestead/PuPHPet/Vagrant/Vbox) or containerization (Docker). Honestly, most of the time I'm just using `php -S` as a webserver and a SQLite database when developing. Most other tools related to my workflow are mostly web-based anyway (Bitbucket/GitHub, Travis/Codeship etc).
Naah. The PHP knight cobbled together a cart based on instructions from dubious but confident joiners who recommended a dodgy supply of wood for the wheels. He rescued the princess, so got the job done, and at an impressive budget too, and everyone was happy. The princess continued to use the cart to get around, without any maintenance, then it fell apart due to a woodworm infestation a year later and killed her. That was PHP circa 2004. Those joiners still exist, but it's easy to avoid them these days.
WTF? Where are you people coming up with this stuff? In my office, I can use whatever PC I want. It's completely reliable. I haven't had to reboot it in over 6 months. I don't need to compare the price of something that I would never use. It's not an option. You can't just pick out random things to make the prices seem similar.
Instead of trying to rescue the princess and all that noise we just marry the barmaid.
Why can't I compare it? Mac doesn't make a fair match. You aren't making any sense. I have two options for a PC for work, the PC I made or a Mac. I am comparing my options. I'm not about to compare something that is not even an option. If you want me to include the monitors, you are really going to get out of wack. Mac monitors are way more expensive. Keyboard and mouse cost about $10 together. $20 if you want to splurge.
The problem I see with this is that the construction of the object is not clear and also you lose the type hinting. Besides, you could argue that having more than 3 arguments may be a sign that you need to break even more.
Mostly, no but here is a few yes. 1. At some point it will segfault at your face, taking the time to debug or fill a bug report takes times. 2. SimpleXML is an horrible interface, DOMElement is better but the immutable one is also bad in its own way. 3. The weak typing will bite you at some point. If you want to do the thing well you have to put strange test (like '&amp;&amp; $a === '0') and type asserts every now and then because you cannot trust you workmates or your old self. 4. The array is a list and a hash table at the same time where you always want them separated and a Set datastruct and good manipulation function. 5. Non lexical scope, meta-programming stuff when you have to make sense of others code. 6. Symfony is slow in tests and more moderatly when developing. 7. PHP doesn't have a REPL where you can re-evalutate a definition. Feel free to downvote but keep in mind those blames are not mocking they are honest disappointment i get time to time.
People are still design in photoshop? For banners and product images that need retouching, sure I get that, but a full layout? Sketch seems to be the main software used if you do ever have to design a layout although the majority of the stuff done now is built in the browser skipping any design tool altogether 
Think you killed it guys - it's just throwing back cloudflare error pages when you try to validate any answers.
Some objects just hold data and there is nothing wrong with those having lots of arguments.
Looks more like a very biast author who likes to talk bullshit. See the C++ one...according to that all his work was already done for him. As for his PHP opinion, chances are he's never use it or if he has, used it wrong and wasn't technically capable enough of learning how to use it correctly.
yeah it was so broken I thought something was up too or I missing some crazy subtle edge case with type juggling.
I'm wondering, how do you handle the speed of shared folders of your VM ? The performance seems te be so slow (For example VirtualBox shared folders)
Can you tell what fields can be initialised using this constructor? Which of them are required? Which have default values? Are there any type restrictions for them? public function __construct($params = []) Same question: public function __construct($foo, array $bar, $baz = "") I have a feeling that you’re not using an IDE or an editor that would help you with the boilerplate. In my day-to-day work I just define the private members, and all the rest — the getters, the setters and the constructor — is generated by the IDE.
wow his code can connect to phpmysql database, I've never even heard of that database before yet his code can use it. I can't wait to see the end result of this train crash, I can only imagine the security vulnerabilities and the mass of spaghetti code being produced. The sad things is, I will be fixing shit like this in a few months time when someone has hired a 'developer' on freelancer for $5 an hour to build something like this.
The job market for web-app security will surely be booming even more in a few months. Imagine all the websites and IoT products that are contracted to these developers. Fun times are coming. Imagine all the botnet administrators' eagerness to own all these sweet PHP PDO Ecommerce sites.
why make one call to the object when you can make 2?
While I agree that having more than 3 arguments could require more refactoring, I think that it's simply ugly to have a constructor that just initializes class properties and nothing else. The point of this is that any class that uses it implicitly tells the person that ALL class properties can be initialized from the constructor. That way, you can do away with the ugly constructor and simply see 'Oh, this class is using the Object trait (or as stated below, rename it to something like ConstructorExtension), that means I can initialize any of the class properties from the constructor' In regards to the type hinting, that is a flaw in it. Probably the most blatant now that you point it out. Not sure if that's something I could resolve while maintaining the original idea though. 
You: *You should buy a Mac because something you would never even use costs the same amount as one!* I'm comparing the two actual things that are my options. Any other comparison is just hypothetical nonsense. I'm so glad that I don't work with you. I can build a PC in under an hour. You know you just plug things in, right? There are less than 10 components. You are right, I'm not comparing Dell's service, because from experience, I know their service sucks. When I put the pieces in myself, I know they will work.
I see no reason to throw out the entirety of OO just simply to get rid of some ugly constructors that only forward parameters to class properties? 
It's not just this guy but there's a whole host of them on youtube giving out shocking advice and truly awful code and in some cases like this even charge people for the bad advice! 
I'm looking for a library that makes multiple languages easy! I've got 0 experience with libraries for PHP that do this, and Googling gives me results, but not necessarily biased towards best ones. So any advice, is welcome!
You are the princess.
&gt; PHP doesn't have a REPL [Boris](https://github.com/borisrepl/boris).
No, I use Vagrant to run VirtualBox images which gives me something to run code and databases on but can easily set up remote xdebug
Exactly, I use value objects fairly often. Often times I will replace a large associative array with an immutable value object. Whether or not that is right or wrong - it feels right to me.
Did learn to use puppet, didn't like it as much as I would have hoped. I miss the back and forth curl and gets and remote commands give me in bash-- Puppet is mostly one way and conditionals on external conditions are not what it does well. Specifically, I tried setting up users without a LDAP box and no joy.
&gt; don't you lose debugging at this setup? No. It's not quite a straight forward as it would be if you were running and debugging on the same machine without a VM but it's quite doable.
There are a number of disadvantages to installing your development environment locally. It's really easy to get yourself attached to certain versions of your tools (like PHP, Apache, etc) that can make it difficult if you need to bounce between different projects. [Vagrant](https://www.vagrantup.com/) is the most popular solution for running isolated development environments in Virtual Machines. Some docker-centric approach will probably replace Vagrant in the long term, but Vagrant is fine for most cases if you just want a small number of different environments. If you go with vagrant, I'd highly recommend Laravel's [Homestead](https://laravel.com/docs/5.3/homestead) box. Even if you don't use Laravel, this one comes prepackaged with composer, PHP7, mysql 5.7, Redis, and practically anything else you'd need for local development work. Remote debugging is possible and isn't too difficult to setup. I wrote a [gist] (https://gist.github.com/thejettdurham/bd2a80d292bebe4a3c3bc0f34acc2d47) for my team at work on how they can get remote debugging setup with Phpstorm and Homestead (or any Vagrant box). Maybe you'll find it useful too.
I actually had a good chuckle at the Monty Python squire in the first frame. If you get your panties in a twist every time someone uses PHP as a bunching bag, you're going to end up with a very uncomfortable rash. PHP gets shit done, and does it solidly enough to be EVERYWHERE. Stop defending its honor at ever minor slight and just be proud.
Docker.
Use Linux on Windows, like using VMBox for Linux and Windows for anything else. It's so convenient that I could write proposals while reviewing my code on Linux. About distros, it's your choice! I prefer something so CLI like Ubuntu Server so I can customize the system as much as I want (and not being weightened by interfaces).
Here is a Vagrant configuration which is using Docker for provisioner: https://github.com/czettnersandor/vagrant-docker-lamp
Start with a framework, reading the source code. This will show you what the different things (or "first principles") are that one has to take into consideration, and how the particular framework goes about solving them. Use the framework, to see how well the framework's ideas turn out. This way, you will take advantage from others' experience, instead of starting all the way from scratch. Maybe you will see where to improve the framework, or come up with a revolutionary way.
Man, I use this service. Fuck these guys.
&gt; '&amp;&amp; $a === '0' I've never done that. However, it looks like you are checking if the input is a zero. I suppose that would imply you are looking for an int on the input. Why not just cast that shit to an int and be done with it? public function foo($a) { $a = (int)$a; // $a is now an int no matter what. // "null" and '0' both convert to 0 and that makes sense. // in PHP7 this is not even needed. } // PHP7 public function foo(int $a) { // $a is an int guaranfuckingteed } &gt; PHP doesn't have a REPL Never needed one. Use a proper debugger instead. I've programmed heavily in Java and C# and the REPL is not used there either. In fact, I've never used a REPL in Visual Studio, ever. REPL's are needed for langs like Ruby and JS where you don't know what the fuck you have or what you can call it. &gt; Symfony is slow Yes. Fairly slow. Don't use that shit. Use whatever the fuck floats your boat. I don't even use a heavy framework anymore. I pull components in via composer as needed. Find your favorite libraries and go for it. Besides, PHP7 makes even Symfony fast now. But still, fuck Symfony if it doesn't work for you. &gt; Non lexical scope, Bullshit. "this" is always this. You must have JavaScript on the brain. Variables are scoped to the function. Most IDE's will complain if you declare a variable in an "if" and then try to use it outside. Just declare your variable right above the "if" and your done. &gt; meta-programming More bullshit. Nobody uses meta programming anymore. Sometimes I see an odd case of it in way legacy code. When I do, I refactor that garbage out. &gt; array is a list and a hash table PHP arrays do everything you could want and they are fast. If you want to use it as a stack, then only call push and pop. If you want to use it as a queue, then only call queue and dequeue. Btw, proper stacks and queues are included in the language now. However, I have never had a reason to use them because arrays rock. So, this argument is total horseshit too.
I thought union types were pushed back until after null types were added?
dunno, to me rejecting the idea of constructors seems just plain weird. I don't know what's "ugly" about them: they are here to inject dependencies and/or state. If state management is not a problem or you don't like the safety of typehint, you can also just put all properties as public or create a static constructor that maps your `create($params)` to your properties.
We have an inside joke at work-- the guy that keeps the tech ship pointed in the right direction has an unusual fascination with Netflix's stack (automated with chef...) and often heard is "should've used chef...".
&gt; and all the rest — the getters, the setters and the constructor — is generated by the IDE. `ALT+INSERT` :D
&gt; "Proper" is a very loaded term Especially with nobody saying "this is the right way" but a bunch of people just dumping a version of their process.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm glad to see several users of Vagrant, 99% of developers I know haven't heard of it or haven't used it yet.
Maybe it also helps you a bit when you think about events being written to a queue (for example a RabbitMQ server) and listeners actually are entirely different programs in different servers. This is also why events should be serializable. 
&gt; Making it more scalable is about separating domain, following SOLID in that separated layer, introducing proper unit testing etc. I agree 100%. &gt; It's developer who can do so, not the framework itself. I strongly disagree here, because the framework you are using can greatly hinder your ability to follow those principles. I can't follow SOLID in my domain if the ORM I'm using implements the ActiveRecord pattern, which violates SRP with wild abandon. I can't introduce proper unit testing if my domain classes need to extend your base components and call static methods (which are not mockable) everywhere. I can't even have a proper separate domain layer with Yii2, because it's so opinionated it forces me to extend portions of the framework while having hardcoded dependencies through static methods everywhere.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Because there isn't really a right way. The destination should be try to duplicate your production environment as much as you can. How you get there is up to you. I go the full blown VM route, oithers do vagarant, others docker. Chose the easiest/more comfortable route to get to that destination and roll with it. 
I develop on windows with VMware. Why? Because I love it. Mostly do jobs based on Symfony 2. Tried VirtualBox but holy hell is that thing slow. On a modest 3 man project the frontpage takes 4 seconds on the frontpage through a simple shared folder. Same page, same setup with VMware is below a second with simple shared folders enabled. Vagrant seems ok with VMware plugin, never tried docker... but the thing is, customers never paid to get a "server setup", so I just do it by notes and setup.sh scripts. I know, it sounds like a drag, but that way I know exactly what a setting does on a given tech, how to even improve that, understand the underlying structure. I never had the need to automate it. If a collegue wants a working dev enviroment just mirror my current image. Some updates to the VM? By god just cut&amp;paste the commands from a skype log, never failed me, worst case scenario is a new snapshot of the currently working master VM and everyone is set. Last time I tried vagrant, and different setup "frameworks" it was a huge waste of time. Failed at 10% of the machines, needed fiddling anyway, a company even had a dedicated man for that... I got no time for that, need to pay the rent. Every time we join a new project and get a vagrant script I roll with my eyes, because there are always 3rd and 4th steps involved, because no one had the time to update that script with a current dump, updat elastic search or the imagick lib. There is always something. Just shoot me a working VM copy, I adjust the network, mount the folder and can proceed with what my job is. /rant over. I'm just not the guy for this setup-fiddling. 
Yeah, sorry that's what I meant by vagrant. The automated setup. I use a self-managed VM since I use it for many different things. Lately I have been using docker with a couple of my projects within my VM.
I liked docker, but had some issues with my windows setup and shared folders on some containers so I went back to good old VMs (though with vagrant in this case)
I've used apache with Vagrant for as long as I remember. New project had me using NGINX. I felt like an idiot for a few hours, even switched code editors, upgraded Node, etc... Was rough.
Which IDE would generate the constructor for you?
Well, why would it be a bad one. It's not as if a hydrator doesn't something very different. Except through slower means (reflection).
Union Types failed 11 - 18 Unless something substantial in voting happens I'm not sure how it could pass. So from my perspective it's political.
I like to play the "avoid the recruiter" game. It's challenging because those fuckers will do anything and everything to shove this *awesome* 3 month contract in West Butthole, Texas with no relocation assistance right in your face. Bonus points if you can hang up the phone/close the email before they can finish the sentence "Would you be willing to relocate to the Bay Area?" Seriously though, try finding an open source project and learn if you can contribute to it. Check out http://www.firsttimersonly.com/ if you're so inclined. Also, if you're just starting out, try http://www.phptherightway.com/ to avoid all the completely disgusting, buggy, insecure code that's out there, or at least learn to recognize it.
Idk why you got down voted for the best answer...
* https://sculpin.io * http://spress.yosymfony.com * https://www.staticgen.com
Im learning as well and I'd advise to not go about it thinking you have to do it "fast". Maybe efficiently? 
[Silex](http://silex.sensiolabs.org/) uses Symfony components and is pretty useful for quick prototyping.
Well, the symfony cli application they have now generates a skeleton app for you to get started. `symfony new my_project` - https://symfony.com/download
Yeah I recognise that, I just think it feels a bit odd having the article start out with "before Elasticsearch having a decent search functionality on a PHP website was a distant dream" and then having no immediate example of searching on the index. But like you said, the API is easy to learn and the documentation is great. I started working with Elasticsearch a few weeks ago and there's so much nuance to knowing how you should analyse and query your indexes to get the most out of it, it's really great.
I was thinking more along the lines of how Metalsmith handles plugins and user defined run order.
But not with scissors!
Thanks for the gist link. Will have another attempt at getting phpStorm and Homestead to debug.
That's not specific to Vagrant. You can use an NFS or CIFS share without it.
It depends on the app I guess, but for me, being a Symfony user I decided to use Laravel (Spark in particular) for my last MVP type thing. Sorry to say, but it's far easier to be more productive than with Symfony.
It's like 3 settings to make xdebug work remotely with PHPStorm. It almost couldn't be easier.
[Codewars](https://www.codewars.com) just added PHP support. Lots of different programming challenges, but nothing grounded in real-world problem solving unfortunately.
"but writing another CRUD-ish prototype seems boring and repetitive" I've built over a few years my own bundles to speed up setting up a standard yet powerful Crud API for any Doctrine Entity. Here is the list of my features: - Controller Helper so that CRUD is a one line in my controllers. (getAll/Page, get, post, put, delete). Of course you can build custom methods and rely on the helper methods. The put method is a partial update, this is quite difficult to achieve, you need to extend FOSRest RequestBodyParamConverter. I did it once and now I rely on it a lot inside my web-apps. - Pagination - JSON serialization (think GraphQL, the app can request for fields/sub entities) - Helper repository for each entity (I can define which fields you can filter, date, lat/lng, sort, or even tokenize to do a global search over multiple fields and sub entities). - Test helper (for unit and functional tests with a custom doctrine data fixtures loader) Unless you have some experience with FOS Rest, FOS User, JMS Serializer, you won't get this setup running smooth in less than a few weeks. I would suggest using any other framework dedicated to building API. NodeJS/Express is way faster for rapid prototyping an API. And you can always refactor later and add tests in a clean way. Also using javascript (ES6 ideally) on both your frontend and backend is obviously a plus in terms of source code management on the long term. However, using FOS Rest + JMS Serializer without my improvements might give you enough firepower, totally depends on your requirements.
Try to build in PHP a minimal viable version of: - A blog - A forum - A comment system on top of the blog - A simple CMS Then compare what you did to a popular implementation of each of these.
You can try to write a blog or twitter clone and use framework like Lavarel 5. 
Just use hyper v instead of vagrant. Edit: Meant to write Virtual Box, not vagrant.
To be honest this is probably the most constructive of the criticism this trait has received. I can actually learn something from the links you've provided and from what you've said, and this is what I wanted. So I appreciate the feedback. This trait was something I did on a whim for a personal project, but based on the feedback I've been getting I will probably switch back over to using basic constructors for property initialization. I've been spending a lot of time trying to make things look nicer, and I suppose that's turned into me not putting enough time into functionality and implementation. 
Use only Linux system , in my case it's Elementary OS (irl look very pretty) and dont have any problems with virtual PATH like in Windows. 
AFAIK, Twig is the most popular ones. If you want more simpler, maybe someting like [Mustache](https://mustache.github.io/).
+1 to this This is exactly how i ended up in docker now
&gt; which splits up your code into classes which are driven by a main index page I want to clarify a few things. The "Driven by a main index page" thing is not related to OO. It's called the [front controller pattern](https://en.wikipedia.org/wiki/Front_controller), and it exists to eliminate code duplication. You can implement the front controller pattern using OO, procedural, or FP. Now, regarding splitting code into classes: Before we get into classes, lets talk about code splitting in general. Code splitting is usually good (unless you overdo it, but that's another topic). It allows code to be reused, and it also lets files themselves stay lean and focused. Consider this travesty from Wordpress Core: https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php over 5500 lines, and a kaleidoscope of disparate functionality. It's impossible to describe what this file does to someone who might ask, because you'd need to write a book explaining it. Simply *navigating* it is a pain in the ass, even with support from an IDE. Ultimately the problem is that this file places high cognitive load on whoever has to maintain it, explain it, or even use it. Caveat: splitting code also creates its own cognitive load because now you have to know which file contains which functionality. In the long term, the cost of many different single-purpose files and functions is *usually* lower than the cost of a few very large files containing lots of unrelated functions. Now, getting back to classes and objects. Classes and objects are just a different way of splitting code. You could re-write that WP `functions.php` file by breaking it up into dozens or so smaller files that do specific things. It's still not OO, but it's at least been split so that unrelated code is no longer grouped together. Similarly, you could break all that code up into a series of classes (1 class per file is typically how your write OO PHP). What is the advantage to OO? There's no technical advantage. Anything you can achieve with OO you can achieve with functional programming or procedural programming. It may require different approaches to solving problems, but the end result is the same: if you wanted to build Facebook, you can build Facebook no matter which paradigm you choose. From my experience, the advantage to OO is being able to split your codebase into named "chunks" that act as a label which describes a lot of underlying complexity in a simple way. If I have a `User` object in my app, it's a single word that describes a critical component of my application. Much like the word "gravity" is a label for a lot of extremely complex physics, so too `User` is a label for a complex element of my application. Moreover, I can write my application in such a way that there are very specific rules governing how an instance of my `User` class may be modified, or passed around, reducing inappropriate usages and thus eliminating certain classes of bugs. When I see a `$user` variable in a function and know that it's an instance of User (due to the typehint that should be there), it allows me to narrow my cognitive focus to just the behavior and state defined on the `User` class. I don't need to think about the whole application, I just need to worry about only what that `$user` object can and cannot do. Again, this is more psychological than technical. That said, good OO design is *hard as fuck*. If you get it wrong, you've created more cognitive load than you've reduced. If we were to take that WP `functions.php` file and simply copy/paste all of those functions into a class, we wouldn't have done anything useful. Arguably we would have made our application more complicated. So just because one writes OO syntax, doesn't mean they're actually doing OO programming. Much like someone who writes a bunch of functions, isn't doing functional programming. Just because that WP `functions.php` is called `functions.php`, and has a bunch of functions in it, doesn't make it functional. It's still very much a procedural mess. It should also be noted that it's actually very rare for a codebase to use only a single paradigm. Many object methods use a procedural implementation. Object methods can also be nothing more than "pure functions" with zero dependencies on any sort of state, and no side effects. The fact that they're attached to an object instead of the global namespace is just a matter of organization. 
Or just use docker.
What i'm doing now is, 1 container for 1 process/tools/app. So i have container for each php-fpm, nginx, redis, postgres and even composer, codeception/phpunit, phpcs. Not really sure if i'm doing it right...
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
In a lot of cases I'm able to move the heavy writes out of my NFS share. For example, in Symfony2, the log and cache directories get hammered pretty good. It cripples page loads. So I kick them out to other directories inside my Vagrant, since I don't really need to share that stuff with my codebase. There's also a couple of NFS options that might help in some cases. But really, the best way is to just not write to NFS shares frequently.
Vagrant isn't a hypervisor.
Sorry, you are quite right. I meant to write Hyper-V instead of Virtualbox. Hyper-V lets you use SMB shares instead of VBox shared folders or NFS and is heaps faster.
You don't need to do all of the steps he listed. Like, the xdebug bookmarklets. This is my remote xdebug config for PHPStorm+Vagrant: xdebug.default_enable = 1 xdebug.remote_autostart = 1 xdebug.remote_enable = 1 xdebug.remote_connect_back = 1 xdebug.remote_handler = dbgp xdebug.remote_port = 9000 xdebug.remote_host = 192.168.10.10 Set **xdebug.remote_host** to your host machine IP address. That's it for xdebug config. Next, in PHPStorm, find the servers configuration within the main settings. I think it's like Language &gt; PHP &gt; Servers, but not 100% - just search for "servers". Add a new server, making sure to use the host domain or IP of your vagrant box. Then, just set the path mappings. This is a very important part because the remote debugging won't work properly without the path mappings. And that's it. Super simple. 
Twig http://twig.sensiolabs.org/ 
I work on a huge codebase (&gt;150MB of php files) and it takes about 2 minutes to get working.
Those do support plugins...
I use Apache virtual hosts, although I wouldn't really call myself a professional yet. 
You're not doing it properly (or not hip enough) if you're not neck-deep in docker. 
From the Smarty website: "People seem to assume Smarty is old and lethargic just because it has been around awhile. Truth is, it is a very modern and actively developed template engine". Also: "Smarty is fast and lean with a small memory footprint" and it's tested in PHP 7. 
Buy a month of Laracasts and build it in Laravel... that's got to be one of the quickest ways. 
Save The Princess
Christ why is everyone so salty
lmao get a sense of humour
I use Windows 10 + Bash, have my work on Win partitions and accessing it through /mnt/. Works perfectly.
I think you mean this https://toggl.com/programming-princess
Please name the new function real_parse_url().....
Why port mapping should be a problem? In my setup, I have 3 different projects under Docker (two can even communicate between them) and I bind the ports to 127.0.0.1/20/30... Problem solved!
There is an awesome plugin for CakePHP called [CRUD](https://github.com/friendsofcake/crud) that takes all of the boring and repetitive CRUDish things and abstracts them away into handy classes.
you can read more about it on http://externals.io/thread/356 I would be in favor of: - creating `parse_uri` in PHP7.2 and signal `parse_url` as being deprecated (E_DEPRECATED) - removing `parse_url` in PHP8 IMHO `parse_url` has been EOL for far too long and needs to be removed.
I like your style. Have an upvote.
my money is on thisTimeReallyParseTheUTRL()
Or memorise the argument order of each string function ;)
I agree, if you want to have super rapid development, use a rapid development framework like CakePHP. The less code you need to write the faster you will most likely be.
[Symfony](https://gnugat.github.io/2015/12/23/symfony-micro-framework.html) uses Symfony components and is pretty useful for quick prototyping. _Yes, Symfony can be used as a micro framework_.
Take a look at this: https://shippingdocker.com/ With docker-compose is so much easier. My test/uat server are on AWS and I used docker for them as well. Not in Production yet.
I propose jarves.io. It gives you a CRUD framework, frontend stuff, filemanager, full rest API, it's just a Symfony bundle etc. Also integrated Propel gives you a very fast way to build a prototype that is using a sql database. Use https://github.com/jarves/jarves-standard.
And while they are at it, it would probably also make sense to have proper support for building and changing URLs. For a language that has been made for web development, the built-in functionality to dealing with URLs is comically limited. Sure. There are third-party solutions, but they should not be required.
Because reddit is being reddit…
&gt; Everything just works™ I know a lot of people think Arch is just for tinkerers and people who actually enjoy configuring Linux and having a hyper level of customization. But even if you don't care about any of that and you just want to get your work done, Arch is still a solid choice. Like you said: Everything just works.
Hi all, actually i'm very shocked about many misinformations that are floating around in the answers. Like the global scoping of functions... that's a thing of the past since PHP 5.3 (http://php.net/manual/en/language.namespaces.basics.php). Like you have mentioned, it might be a (computational, mental) overhead to work with classes. I'm not so sure about the computational overhead (creating objects, memory consumption etc.) but i think working with classes is consuming more memory and CPU. Like seen in the JS World, working with pure functions is doable AND has some benefits. So right now i also started working more with scoped functions and they seem to be more "composable". Objects are a nice analogy for the real world, but we are programmers and are not always working with "real" objects. There is a famous example with a cat that meows, a dog that barks and the "Liveform" Object that both inherit from ... build it mentally in your head ... now try to have an animal that meows AND barks. Its hard to restructure Objects to reflect this "new liveform" but its a breeze using functions. In conclusion, like your first poster (@danstorm): Use the right tools for the job. Greets, Chris
&gt; Arch just works. vs &gt; You might spend more time setting up your environment at first I'm not trying to bash Arch users, but those statements are the exact opposite of each other... *Just works* implies very few (if any) requirements from the user just to get up and running. "spend more time setting up your environment" != "just works"
"sudo echo" does not actually run echo with su privileges. You would need "sudo bash -c 'echo xxx &gt; xxx' "
The problem is that you can not simply do that because `parse_url/parse_uri` goal is to **only** parse the URI, they do not validate the URI. Any valid RFC3986 compliant URI should be parsed *but* to construct a valid scheme specific URI you need first to validate the URI against each scheme specific rules. I would not be surprise to see this future function correctly parse the following URI `data://example.com/p?q` knowing that this Data URI is completely wrong according to its RFC https://tools.ietf.org/html/rfc2397 your proposed URI object should take into account each scheme specific URI or it will be so general that I won't be usable. IMHO fixing `http_build_query` and `parse_str` and `_GET/_POST` superglobals is much easier. the URIs classes would then be easier to create in user land. 
That should work, I'm not terribly familiar with the "tee" command however.
are there any good resources for how to go about open sourcing a project? for example: - how to pick a license? - is github/bitbucket preferred, or a project specific website, or both? - what is the significance of composer and does my project really need it? - etc...
I found this also, Symfony is very robust but Laravel is much more productive and never leaves me wanting
It's not specific to my setup. You can't bind a port to two different things on the same IP. And like I said elsewhere, if I have to use a VM anyway, I'll just stick with my Vagrant workflow.
Because I don't want to try to remember which project had which set of port mappings. That's a huge pain, and makes setting everything up one step harder.
of course there are 3rd party solutions. That's not the point. As a language invented for web programming, something like this should be built in. During the PHP 5 times, I have done a benchmark of the various 3rd party userland libraries. All of them had abysmal performance compared to `parse_url` and a quick manual string concatenation. This, of course, is understandable, because C code will always be faster.
In all seriousness though, here's a few things I noticed: 1. Input type 'username' does not exist afaik and the browser will automatically convert it to input type 'text'. 2. Htmlentities shouldn't be needed on username/password for login checking. Htmlentities is mostly really useful when printing (user input) data from the database into the page. Mysqli real escape string should suffice. 3. You're assigning a SQL string to $query, yet you check `if ($query == true)` right after before actually executing it against the db. Why's that?
it's dead jim
I believe /u/SirQuackTheDuck only suggested that league/uri to be used as inspiration for the built-in solution.
Erh... Maybe you should use docker-compose? Or add an entry to /etc/hosts to map the IPs to meaningful names?
is vagrant the same as docker? I am more familiar with vagrant as of the moment.
Sure, but localhost:80 can only go one place at a time.
yeah if you want it done in a way that'll likely break something you make.
&gt; It's bad because it forces itself into the class whilst a hydrator performs its work externally, thus freeing the class from unrelated hydration logic and permitting it to implement its own constructor. You just said that breaking object encapsulation is better than maintaining it. I don't get it. Am I understanding you correctly? "Hydration" is simply a special case of construction. There is plenty you can't just blindly serialize and restore, without knowing how an object uses it. For PHP specifically, resources come to mind, references come to mind, and data relative to other objects' state comes to mind. It works for simple ValueObject types, but in general "automagic" hydration without the object's involvement is like throwing dice.
This is exactly why I asked the question :P So many people give examples like you talk about, that really don't make sense when combined.
I'm gearing up to rerelease a Vagrant+Docker based dev environment which basically removes this problem (although not in any of the ways suggested in that thread) If you don't mind me asking, what other key issues are on your list?
I don't think we'll ever do function overloading. From a technical perspective PHP is not a good language for it. Arity overloading, which is normally easier than type overloading, has problems as well because passing too many arguments to a function is not an error (or a warning or even considered bad). This is because of old-style varargs before `...` came. But even if we can do arity overloading this doesn't help the type-overloading situation at all, which is probably the overloading you were alluding to because of union types.
Great brain teasers, but this will not help you specifically out with PHP.
No real benefit, there are literally no benefits that I can think of. Arguably the only sort of benefit I can think of is the ability to log all the exceptions in one place, but that's about it. 
Leaving verbosity aside(which I completely agree with), yey or nay on the above?
That just swaps Silex for gnugat/micro-framework-bundle -- how is that any better than what the guy above you suggested? Both are minimal shims over symphony.
If there is no benefit then the default answer is typically not to do it. Further, logging all exceptions is dubious. Logging exceptions that propagate to the top level scope of your app is a good idea but logging all exceptions that are successfully handled during normal flow might not yield much actionable information.
I'm pretty sure PhpStorm has ways of doing that. I don't really use that feature myself, but I use it for generating getters and setters based on the properties of a class for example, which is a huge timesaver.
That's why I told you that I use: - 127.0.0.1 - 127.0.0.10 - 127.0.0.20 - ... You get 255 * 255 * 255 of them!
Ah, gotcha. I thought you were talking about ports with "/20/30". That's basically the workflow I'm trying to create with LXD which will then hold Docker containers. I'm still learning Docker, and haven't really found any resources that set it up the way I want it to be setup. It seems everyone just uses default networking I guess. If you're saying that you can do all of that with just docker/docker-compose, then I guess I'll have to do some more digging.
Like I said, I don't even define any ports with the setup I have. I guess vagrant is fine if you have the luxury of running the same stack for every project. I personally require multiple versions of php, often need things like redis and docker allows me to easily switch versions or add new stuff without hassle. It literally takes minutes. We used to use vagrant at work but it was a pain to maintain with all the requirements our many different projects had - not to mention the long provisioning. With the docker setup, we just have a docker-compose file and sometimes add a new service in there if we want to add something like elasticsearch or anything at all. No more long provisioning time or spending time on ansible roles. I guess it just matters what/how you're developing, I just wanted to point out that there's solutions for your port problems.
Silex provides it's own Dependency Injection Container and its own routing. That means when your application becomes too big for a micro framework (and it will eventually), you'll have to pull your hair to migrate it to Symfony, or even start from scratch. MicroFrameworkBundle is just Symfony's framework bundle, but with just the bare minimum components. It uses Symfony's Dependency Injection Container and Strong's routing, and it declares the core services the same way Symfony's FrameworkBundle does. That means that when your application becomes too big for a micro framework, you can swap MicroFrameworkBundle with Symfony's FrameworkBundle. That's the difference.
The whole point of vagrant is to make a provisioned environment. You can most definitely have different versions of things and install different services. But, you'll be using something like Puppet, so it's definitely not as easy as Docker. Vagrant has served me well and I quite like it, but there are some annoying things that soak up time and energy sometimes. Docker is definitely where I want to be in the future, I just have to find the time to get it working smoothly with my workflow.
Sorry for the issues, we've been updating our infrastructure for added support and it was offline briefly yesterday. 
Sorry for the issues, we've been updating our infrastructure for added support and it was offline briefly yesterday. 
&gt; they consider that opening a class to extension should be something you do explicitly when you have a good reason It's a good point, but I wonder if they really follow through. To truly encapsulate an object, all public methods should also be declared as final, otherwise the encapsulation can be broken. **EDIT**: Alternatively an object should never call its own public methods but have a private version, ex. public getFoo() -&gt; private getFooInternal(). This way if the public version is overridden, the object maintains its encapsulation.
Quote from RFC proposal: "The function can return ... NULL when we can not parse the URI, or, the component request contains no value" Why not just throwing an exception? Silent error handling (in this case just returning NULL) is what makes life really hard. I honestly think it should just throw an exception if the function cannot parse the URL - before calling the parse_url() function, a developer should already validate the URL. If he does not validate the URL before AND still is okay if the URL parsing is not working, he should just catch the exception.
I'm not sure I understand, if you are aware of the limitations and issues of your in-house framework why are you sharing it (on Github I mean)? Or is it more like an educational thing?
in scrutinizer, not in my editor.
i do use psr-2, there is no rule that the equal signs must be aligned.
(Aside: if someone starts getting spiteful, it is best to just report them and move on - no value in arguing with people who are looking for a fight. Well, not in this sub anyway!). 
That's good! The language still doesn't want you to use spacing like that though. But if you insist, there's a way to turn off warnings, although then you'll miss warnings for other issues http://php.net/manual/en/function.error-reporting.php Or suppress them on an individual basis http://php.net/manual/en/language.operators.errorcontrol.php Either way it's clearly not the format the language expects. Still better to just change your coding style. 
We use this package. Thanks for building it. 
I'd say educational. We've put a ton of work into it and don't want to abandon it so the other day we agreed to put it on GitHub and have fun working on it with others.
[removed]
Why would it be exceptional behaviour? Urls can be anything, it would be common for them to fall to parse.
I'd be interested in helping. Do you have a task list anywhere?
Yeah, well, that's just, like, your opinion, man.
Have you tried contacting their support? You are paying to use the product so I would think they would be willing to at least help you configure it. There also seems to be a big section online on how to configure it. Of course it might turn out that you can't suppress what you want. In which case, don't use it. But if it is a standard in your workplace then you might just have to suck it up.
First off, I would suggest running any PHP code that is web-based on the RPi with the internal PHP Webserver. That will be lightweight enough to run on RPi and you won't have to worry about configuring Apache or nginx or any other webserver. Also, make sure that the RPi is only going to be using PHP locally. DO NOT HAVE IT SERVE TO THE WEB. There are a couple of ways to accomplish the frontend. You can grab [Electron](https://electron.atom.io) for ARM and compile an application that runs on Raspbian. This would allow you to have a "native" desktop application that can interact with your PHP API. OR You can grab [FullPageOS](https://github.com/guysoft/FullPageOS), which can display your page in the browser, and you can run the frontend on the internal PHP WebServer. *NOTE:* I haven't tried PHP on RPi yet, but I have heard people have had great success running it. 
I may be oversimplifying this, but can't you just configure the Pi's desktop to boot a browser in Kiosk mode pointing to your (locally-hosted) web app? You can then use any existing tools you're comfortable with to run that any way you want, presumably with an nginx or apache server (unlike the other poster, I'd avoid the PHP built-in one, since last I've heard it can't serve requests in parallel so any static resources will be horribly slow to load)
Alright, i've decided to make a simple image hosting site. Almost halfway done now
What's exceptionally hard about it?
I am hoping too see some big app running on Laravel, that proves Laravels architecture and scalability in the coming future. Don't get me wrong, I really appreciate Laravel, and it's community, without any concrete examples it's hard to sell to a client.
Vice Video, Starbucks, Sochi Olympic APIs, Remax, Fox Sports, etc...
I'm self-taught. One person I used to direct was in college studying for his degree, and the crap they were teaching him was incredibly out-dated. His code was horrible, mixed with embedded CSS everywhere, sloppy and insecure. I was laid off and he took over my position. Go figure.
Sounds interesting, but we know how to modernize the framework. Just not enough "hands" :)
I can't recall ever seeing style warnings, only potential issues such as duplicate code, dead code, etc. Is this a somewhat recent addition? --- PS, I would write it like this personally: echo "hi my name is {$name}."; Helps re-enforce where the variables are and in some cases would be required anyway.
Trying connecting via telnet is the same whether I specify HTTP 1.0 or 1.1. In both cases, I receive the whole output, so it never works. It seems that it's a decision from the caller to disconnect after the Content-Length has been reached. That explains it.
GNU GetText has been around since 1995 and is the de-facto translation solution for many projects, including PHP projects. You may have to find a nice way to use it at your template engine (if any) but for anything else, it's pretty supported (the PHP extension usually comes already loaded).
&gt; `header("Connection: close");` If you're outputting a `Connection:` header in your PHP script, you're doing something wrong. It is very much not PHP's job to interfere with the web server's connection management. A PHP script receives a single request and produces headers and raw output, and the server handles the details of encoding the output (e.g. as `Transfer-Encoding: chunked`) and connection management (e.g. `Connection: close`). If you want to prevent the server from keeping the connection open (why? this makes your site slower!) after one request completes, find the relevant configuration setting for your web server. &gt; `header("Content-Length: ".ob_get_length());` Why are you outputting an inaccurate `Content-Length` header? You're producing further output after that first line. If you don't want that output to show up, don't output it in the first place. &gt; Call this script via the CLI and it doesn't work. It output "ONE", "TWO", then wait some seconds, and finally outputs "THREE". Ok, so it's only works when calling the script from the web server. Understandable. The command line interface is not a web server and does not respect HTTP headers. `Content-Length` doesn't do anything there. Moreover, even if it did, your script is still running after it flushes its output, you haven't exited yet. &gt; If I call this through the browser, it waits three seconds before showing "ONE TWO THREE". Why is that? Well, the PHP HTTP client connected to your web server and requested the `/x1.php` page. Your web server took three seconds to complete the request and close the connection, and so PHP waited for it to do so. Your web server returned `"ONE\nTWO\n\nTHREE"` to the HTTP client, so `file_get_contents` returned that. It ignored your `Content-Length` header, but I'm not sure that's unreasonable behaviour (PHP's HTTP client uses HTTP/1.0, not HTTP/1.1, so it doesn't have to worry about message framing). After all, it was wrong. You delivered content that was longer! ---- Ignoring the strange things your code does… what you're trying to do, well, I'm not sure it can be done. By definition, a request to a PHP page completes when the PHP script finishes executing, you can't end it without ending the script. The browsers may stop showing the page as loading if you produce enough output to fit the `Content-Length`, but the request is still ongoing and blocking your browser from loading other resources (if not using HTTP/2.0) and your server from serving other requests (depending on the server). If you want to do some action after serving a request, consider handing it off to some sort of separate worker process.
that makes sense but would throw the same warning
Read on xinit, its pretty simple you just write a shell script to launch everything on boot. 
You may find [this project](https://github.com/guysoft/FullPageOS) does what you require.
&gt; Since all of the APIs I will be working with are web based Javascript SPA setup since you're already needing to communicate with an API. That way you don't have to worry with any server side language on the Pi.
PHP's recommended purpose for the built-in web server is that it doesn't serve non-localhost connections. Technically, the built-in server is meant for development, but it's low power enough to be run on the RPi for this project. If OP was trying to create a server to host a blog on a domain name or something like that, then yeah, the RPi could handle it, but you couldn't handle too many connections to the device. The Ethernet is hampered because it's tied to the USB 2.0 bus, instead of like a normal computer, so it's bandwidth isn't a full 100Mbps, which can cause connection issues. There are other issues, but it's a fun project to actually try and set it up.
Ah.. that's what you meant. I thought you meant in general not have any sort of webserver running that's publicly accessible. 
Yeah, this is how it's usually done. Check out the "magic mirrors" going around and you'll see this approach, for instance. 
There's this, but it's FastCGI specific: http://php.net/manual/en/function.fastcgi-finish-request.php If you do long tasks in a web-thread you'll eventually run out of web-threads if you get a few requests in parallel, so that's a poor practice to begin with. You need to have a separate process, running through, say, cron jobs, and process the long-running tasks there, which I assume are sending emails (did I guess? :-) ).
Drupal 7 is not very nice if you come from a Symfony background :-/ It is procedural code and the whole stack is built on their own self-invented logic which has a 10 year legacy. It's really hard to understand, everything they do is done in their own way and the only thing you can do is to read the documentation which is not fantastic. I would fight really hard to NOT work on any Drupal 7 projects. This is a waste of time career wise, Drupal 7 is incredibly hard to learn and will be obsolete in 12 months when it goes into "long term support", meaning there will only be security fixes. All this knowledge you get will just go down the drain then. If they do force you to work on Drupal 7 then I would demand at least a couple of days every month to work on Drupal 8 projects, so your OOP skills won't get rusty. Financially Drupal can be very rewarding though, they are among the best paid PHP jobs, but again, in 12 months time when Drupal 7 is obsolete every employer will be looking for developers with Drupal 8 / Symfony experience, and all your D7 knowledge will be worthless.
That was probably in Drupal 7 or before, these problems have been addressed in Drupal 8.
I see, My code is not sql injection vulnerable, and i use SHA2 to encrypt the passwords. 
Technically that's not income. Also I'd like to hear what more you would put into a beginners tutorial, because explaining background info and cryptographic principles might be super cool, but they're not benefiting people who just opened a terminal for the third time in their life ;)
What line?
If you remove the function 'die' does it work? Die is already a function and I assume you're redeclaring it.
Happy to review it if you like. SHA2 does not sound strong enough - it may be too fast. Do you salt as well?
The function.php file declares a function called die. Php already has a function with that name. You should check php error logs and/or configure your runtime to log errors.
I built a signage system for my movie theatres which works exactly this way. At one location I have an Apache server running PHP and MySQL. Then I have a Pi at each sign location running a 'web' page from the server. At the other location I have a graphics card with multiple HDMI outputs so I just run the signs from that server. FWIW, the difference is because the construction of the first theatre prevented running HDMI cables directly to the sign locations. 
&gt; most language's code needs to be formatted correctly to be read by the interpreter No it doesn't. Most languages are the opposite. 
It won't kill PHP, but every BC break delays version adoption, which in turn delays when most people can practically use new functionality. As always, there's a tradeoff :)
As others have already said, the problem is the `die()` function as [it's already a PHP function](http://php.net/manual/en/function.die.php). PHP has a built-in linter that you can run from the command line: ``` php -l functions.php ``` Your file has this output: ``` PHP Parse error: syntax error, unexpected 'die' (T_EXIT), expecting '(' in ../functions.php on line 69 Errors parsing ../functions.php ```
??? "web-based" probably means the OP's own PHP code running on a web server. "Essentially, it'll be a tiny php server with all kinds of APIs "
Really fun comic. Really hate how other programmers feel about PHP
Congrats on releasing!
Thanks :) Laravel integration in progress https://github.com/florianv/laravel-swap/tree/swap3
Another video tut? Have we learned nothing?
Hey Leo, what do you mean?
Thanks, but no thanks.
Thanks for the tip. I'll check out laracasts. Out of the frameworks, I was going to learn Laravel first since it seems most popular and has the most longevity.
I recommend using on of linux OSs, with docker machine. And this is what I used to do, having a clean Ubuntu, and I just build my docker file on top of it which is just taking several minutes to be built.
I don't actually own them, 'just' the GM and IT person. 
I fail to see why anyone would recommend Go. E.g. Java is faster (much faster), more expressive and more mature.
He might just be overwhelmed. If you have passed on the knowledge of the projects, and the company has interviewed &amp; tested him, and they are confident he is suitable, what more can you do? You could maybe give him your contact details, if you are that invested. I really wouldn't recommend it tho! It would mean that any problem he remotely struggles with, he is likely to call you, instead of actually figuring it out &amp; learning. At some point you have to let go, and it is the companies choice at the end of the day.
I just started a new job last week as a front-end dev, and I completely sold myself as an Angular guru (and thus got a pretty decent salary). Unfortunately I know next to nothing about Macs, so I really came across as an idiot during the (very extensive!) setup process. Also, they use MASSIVE AMOUNTS of code and in a way I'm unfamiliar, so I still seem like maybe I oversold myself. This is the problem with any new dev jumping into a project. I'm sure once he gets familiar with the code base, he'll be fine. Every project is different, and it will always take time to get up to speed. If he knows his shit (which hopefully his technical test showed) then I'm sure the project is in the right hands.
I lol'd.
Yes, and I am saying that it is not an appropriate place to throw an exception. See http://stackoverflow.com/a/77164
Laravel, hands down. Avoid Code Igniter at all costs. It applies many anti-patterns right out of the box and was not designed for modern web app development. Which isn't it's fault. It was a product of its time, but we all need to move on from it. Laravel or Symfony is the way to go. Let me put it this way. I've worked on many projects. Of all of them, the CI one's have always been the most problematic, while the Laravel ones have always been the most fun and productive.
Laravel - especially if you plan to seek employment with it.
Could you elaborate on why you think this? Or are you just parroting what you think is popular sentiment? I imagine it's the latter.
If you really want to study a framework, I suggest something like Slim, Silex, or Lumen. These are referred to as microframeworks. They are less opinionated about how they want you to do things and can help you understand how components of a framework talk to each other before you start working with something larger like Laravel or even Symfony. Two other options would be Building a framework using Symfony components: http://symfony.com/doc/current/create_framework/index.html and the No Framework tutorial: https://github.com/PatrickLouys/no-framework-tutorial. Both of these tutorials will give you an excellent understanding of how different components can be wired together to form a working application.
I still disagree. Trying to parse an invalid URL is definitely a case that should throw an exception and not silently fail (e.g. returning null). The URL validation should be done beforehand already.
What kind of delusion would lead you to believe anyone else could possibly derive any kind of *fun* from this?
=== true Surely new programmers must know not to phrase a question like this.... Whats the goal? The requirements? Maybe I can answer OPs question with a question - Should I get the blue Ford or the Red Harley for my next vehicle? what can the answer possibly mean - you get Ford affectionardoes explaining how this is the best option and Harley addicts telling you the Ford guys are all boring idiots with no ambition. None of these comments helps me because my question sucked, is out of context, does not explain my goals etc. 
Haha, fair enough!
Wordpress: set him a site development - review it when done and go over it with him. Magento: Give him a module development task - review it with him when he is done. Laravel: Set him a task to create something the business can use to their advantage. Ask him how he imagines himself tackling the task, and if it is timely enough let him at it and again review it with him. After each task ask him how he could improve upon the work he has done, whether it be optimization or additional feature additions. I'm a Magento/Symphony dev myself and the best way to scope out someones skill is not with questions but with action. Never sit over their shoulder, do not persecute for them asking for help or googling, and during the review stage always have the mindset of "Help them improve" the dev may end up not the right fit for the company but you both should gain from the experience. 
Sorry for being to lazy to check. Currently on mobile with shitty Internet. does it cover code coverage as well? Been trying to get that to work for ages... 
Laravel is the new Codeigniter, so Laravel I guess. But then again, not sure what either framework has to do with OOP, they're both doing it wrong. 
Well, i agree, docker is a bit PITA in the old days, but it gets better now &gt; There is no ability to override the docker config per local environment. Something like a a docker-compose.dist.yml whose settings may be overriden by a docker-compose.yml which has been added to the .gitignore. You could extends `docker-compose.yml` now, by using `docker-compose.override.yml` that would be called automatically, or extending it manually by using something like `docker-compose -f docker-compose.yml -f docker-compose.prod.yml up -d`. You could find out about it more here: [Multiple Compose Files](https://docs.docker.com/compose/extends/#multiple-compose-files)
Would you tell me more how to achieve this? An article on the net maybe?
OSX/macOS with docker/vagrant as my dev environments. Have tried on numerous occasions to run Linux as my desktop environment but I find it a struggle and it just doesn't suit the way I work. Still far too much config to deal with for my liking. I've got macOS set up in as pretty minimal desktop environment and it just gets out of the way. I generally have my browser open and iTerm2 sat at Cmd-Shift-~ ready to pop up when needed.
I know this isn't exactly real-world advice, but if your client is dictating your tech stack to you, you need a better client...
1. No. Breaking backwards compatibility when there's another option is a non-starter. 2. No. This doesn't need to be implemented in C/internals. Make a composer package, you'll be done quicker. 3. Fine, you can put it in php-src, but you're not changing parse_url()'s current behavior. You can call it parse_rfc3986()
I might advise against jumping straight into Laravel as you probably won't learn much. It intentionally hides or abstracts away a lot of the logic so you don't learn much besides how to use Laravel when using it. Something like Silex (a paired down version of symfony) or symfony itself will teach you a lot more about the logic in a framework by taking away the nice friendly already done and thought out stuff of Laravel and forcing you to think about how and why everything works the way it does.
Now that you have a solid base with vanilla PHP, I'd learn some MVC style framework. Zend Framework 2/3 are great. MVC style and can be very modular. Symfony is great as well. Most of these frameworks are pretty similar, really. Once you learn one of them, the others are easy to pick up
Thanks!
I must disagree. If the company delegates the job hiring a replacement to OP, because he is the only one that can do so, then not properly doing it is a neglect. Not at least communicating and discussing potential doubts with the higher ups could leave some scorched earth behind. Yes "the company" is responsible, but at the current point he is part of that company, so I would expect the best work until the end.
If you have xdebug installed, add xdebug.force_display_errors=1 to your ini 
Because someone who needs this guide gives half a shit about multi byte strings or installing an extension to write hello worlds. 0/10, completely useless.
Hiding of logic is why I went so long without trying the frameworks. I want to go really deep into learning something so the skill is valuable but I don't want to invest that kind of time into a framework and have that not be in vogue a couple years later.
Surely if you've already interviewed, tested and recruited him, it's done. He's your replacement and your duty is now to pass on your knowledge of your company's systems and processes.
Fun? It doesn't look fun in the slightest. Good luck with your endeavours.
Thanks I'll look into those too. I'm still reluctant on frameworks for some reason but I need to learn more about them.
Sequel Pro
And not a year too late. Oh, wait...
Nice!
I can't imagine why anyone would choose something like NetBeans given today's options.
For me it's two things: there's an inertia to switching to and learning a new system, and free is a compelling price. I hear good things about PHPStorm, but NetBeans has been excellent over the years (minor Java slowdowns notwithstanding). TBH I don't know what Oracle get out of keeping the PHP side of things under such good maintenance. Assuming you're a PHPStorm user, does Storm have a project groups window? I love this feature of NB - related projects can be grouped together and viewed in the project tab in one go. I can therefore switch between my work context and side project context very easily. 
This is called ramp up time, any company not factoring in ramp up time is going to have a bad time when hiring developers.
Yeah, it still has its oddities - but as you said it's mainly in obscure places that you have to dig deep to find. I expect every language has its quirky commands that you rarely if ever need to use.
Faster? Not really [1]. At some highly optimized, very specific tasks like sorting and tree operations, sure, but not overall, and I doubt it'll last long as Go gets faster almost every release. On top of that a Java program will also use tens to hundreds of times more memory to do the same task, it's an absolute dog when it comes to memory consumption. What Go provides is simplicity. "Expressiveness" is largely a fault of a language instead of a pro. It lets you make code that was really easy for you to write but hard for anyone else to understand and maintain aka "write only" languages. You can learn Go in a weekend, top to bottom, and be ready to build. Go itself is written in Go, so the source of Go is dead simple and VERY readable. When I'm curious how something works I often check the actual Go source code, which VSCode brings up for me automatically, and this has been a remarkable source of enlightenment. Speaking as someone who has written a fair deal of Java, albeit years ago, it will take a person months to get a similar understanding of Java. In Go, it's remarkably easy to manage threads with channels, which makes writing multi threaded code a breeze, letting you easily take advantage of multiple cores. You, ollehar should give it a try at the very least. I promise it's worth your time seeing how simple life could really be. Build a damn simple web server using the http package, get a little deeper and understand how their interfaces work is how all interfaces should have worked. Gain some insight. On top of everything else Go's binaries are statically linked. Once compiled they should basically work for the foreseeable future and beyond. No worrying about JVM versions or dependencies or anything of the like. I send our DevOPs guy a single binary and he is good to go. This saves as much time and hassle as anything else. Yes Java is mature, but I'd argue to the point of senility. I tried to save all my snark for the last line. [1] http://benchmarksgame.alioth.debian.org/u64q/compare.php?lang=java&amp;lang2=go
"Oh hey, PHP7 support? Let me up and leave PHPStorm for Netbeans!" said literally no one ever
It's more like a drop in the bucket for those of us who can't afford PHPStorm's annual fee
PHPStorm operates on one project at a time. You can however open a new window for a different project. I used to be an Eclipse user and this bugged me a lot initially. I've completely gotten over it though and really don't find it to be a problem at all. You can very quickly switch between projects, and it's not very likely that I'd be working on two separate projects simultaneously anyway.
I guess that's where we disagree. I think that if you're using PHP in a capacity to need an IDE, then paying for a top quality one is a good investment. If that's not the case, well then there are lots of excellent free text editors that would be a good fit. 
Not everyone could afford it, so free alternatives is always welcomed, and netbeans is still the best free IDE for php development.
For an individual who needs the pro version, it's literally **$8.90** paid monthly, and that gets reduced to **$5.30** after 12 consecutive months. You can save some dollars by paying annually. Personally, I pay for phpstorm, pycharm, and datagrip because **nothing comes close** to the productivity gained by using an IDE from Jetbrains.
If you're an open source developer, you can get PHPStorm for free.
Oh yeah, that's an even better point. By the way I'm not against NetBeans I just don't use it. I'm glad to see them keeping up with new features.
I worded that poorly. My point is that if you need the power of an IDE, don't use a shitty free one.
Even if not. I wrote PHP in a text editor for YEARS before I bought PHPStorm. There are rich tools, including debugging, surrounding today's text editors
We all did. But there's a difference between working hard and working smart!
I've used NuSphere PHPEd for a while. I really liked it, though I like PHPStorm better. One of my major gripes with PHPEd, is that it tends to crash if you have a huge amount of files in your project (such as when using a framework).
On the contrary, anything that operates on strings without being multi-byte aware is completely useless.
In your string replacement example, you're using `strpos()` instead of `str_replace()`: `echo strpos( $str_to_replace, $replace_with, $my_string );`
PHP internals community is quite hard to please with any typing-related issue. Just see how long for them took creating what we have in PHP7 today. And still, it is not possible to hint thrown exceptions. 
Symfony isn't going anywhere anytime soon. If it does the whole PHP community would get turned on it's head since almost everything uses a few of it's components. Silex probably has a limited life-span, but that doesn't change that it's built using almost entirely symfony components and the principals of it are applicable to a lot of things outside of frameworks. It's a good way to get your feet wet and learn more about how and why a framework is built the way it is before investing into the "hip" or "now" framework. Just my 2 cents at least.
Because Free Open Source Software. Do *everyone* a favor, take your annual license fees and contrib that to your favorite FOSS project.
It is indeed true that phpstorm is strictly one project per window. However, you can easily attach multiple file system directories to the project. Which in turn can be browsed and searched as easy as you can with netbean's multiple project approach. Lack of multiple projects almost made me give up phpstorm when I first tried it but eventually I found the directory settings and things have been fine since.
I stand corrected regarding performance. It's not how I remembered it. With regard to how fast it is to learn, I'd say both Java and Go uses very established paradigms. Still, Go doesn't really add anything new in the language repertoire. But whatever floats your boat. 
Unless I am absolutely, positively, indubitably sure it's supposed to be private, by default I'm making it protected. I've had too many unnecessary problems with bending libraries/code that couldn't (or rather their authors) fully anticipate and thus fit my specific needs. 
I have a Mac, 16 GB ram, use phpstorm. One thing, I am sick of these java based, resource hogs tools. I understand why, but to me, they are in the same category as flash. Destined to die. I hope sooner than later. Working with sublime and some atom, it's such a different experience... These popular IDEs seem so bloated.
PHPStorm isn't bloated, it's feature-full. Stuff like Eclipse or NetBeans are bloated because they're full-fledged Java IDE's with a whole bunch of PHP IDE stuff thrown on top of them. What is slow to you about PHPStorm? It's just as fast as ST2 for me. Instant searches, instant auto-complete, instant refactoring. I'm only sitting at around 1.5GB of RAM used by PHPStorm right now, with a pretty large SF2 project loaded.
You should have entities that mimic your business needs. The example you showed should require two queries: 1. A query to fetch the venue. 2. A query to fetch the listing of each event, along with the top competitors. However, the second query will result in some complicated joins, so you may be better off having a third query that fetches the competitors separately. The most important thing here is that your database is indexed properly and, if necessary, you only fetch the data required to display the necessary output.
OOP and SOLID don't, in themselves, cause more DB queries. What causes more DB queries is the naive implementation of architecture intended for in-memory objects, to logic and state which is ultimately executed remotely, and accessed concurrently by multiple processes, as is the case with a database accessed from PHP scripts. Read up on CQRS, it's an architecture that is better prepared to deal with such restrictions. With CQRS, you can model commands, and queries, each of which can be implemented through one *or more* SQL queries by your service classes. You may find this model also more similar to your older procedural style of programming. To improve how maintainable your code is, focus on splitting your domain in separate "bounded contexts" (you can read more about this in articles discussing DDD), each of which handles as few entities as possible, and have their own storage (i.e. one bounded context doesn't read from the DB tables of another). You can do this in an object oriented way, or procedural, or functional, that's less important, than keeping the bounded contexts small, so you can fit each in your mind, and refactor it in isolation.
You have a few problems. 1) you can't treat the whole array in one go like that, you need to visit each item separately. You could use array_map to apply a function to each item, or a foreach loop. I prefer the latter as it's more readable imho. 2) your if condition is always going to return true. You're asking "if the number divided by 2 is something other than 0", which is true whether the number is 1, 2, 3, 19828782, whatever. Instead you want the modulus operator (%). That performs integer division and returns the remained. E.g. 87 % 4 = 21, remainder 3 = 3. And you need to check that it's equal TO zero, as you're testing for numbers that can be perfectly divided by 2 with no remainder. $numbers = [32, 12, 83, 13, 4, 28]; foreach($numbers as &amp;$number) { if ($number % 2 === 0) { $number /= 2; } else { $number *= 2; } } unset($number); The unset line at the end isn't important in this simple example, but is something you should **always** do when using a foreach with passing-by-reference (the &amp; sign on the foreach line). Otherwise you could easily accidentally modify the array after the foreach loop has finished if you do anything with $number later in your code. Another looping option without the reference (and the recommended unsetting) as /u/GFandango pointed out would be $numbers = [32, 12, 83, 13, 4, 28]; for($i = 0; $i &lt; count($numbers); $i++) { if ($numbers[$i] % 2 === 0) { $numbers[$i] /= 2; } else { $numbers[$i] *= 2; } } Either can be further shortened with a ternary operator, but again, at the expense of readability. Each to their own.
My book as well, but why? I want arguments to present him other than "your code sucks."
&gt; At the moment I do my utmost to pull all that data in a single query, using multiple joins. Yes, good practice. &gt; Now my gut feeling regarding modelling these entities with OOP is that I'm supposed to create classes that come close to matching my database entities. So "Competitor", "Event", "Venue", "Series", etc. And the Single Responsibility Principle suggests that only the Venue class should contain the venue name, the Event class shouldn't ever even know it. Is that right? Sure, that works. You don't *have* to have a one-to-one mapping between entities and tables, but it works fine to do it that way, and it's a good default if you don't have a reason to do something else. &gt; If so, what I don't understand is how I'm supposed to utilise those when that page is called, while sticking to one single query. Multiple joins, same as now. Why would it change? Moving to OOP wouldn't change how your DB is structured, why would it change how you query the DB? The process is: &gt; suddenly my one large query is replaced by a mutltitude of (admittedly simpler) smaller queries. Is this correct? No, don't do that. Use the same query you do now, and then use the data you fetch to create your entities. You mention the SRP, earlier. If it helps, consider that having a `Competitor` or `Venue` object which knows about persistence violates the SRP. Keep your entity classes focused on business logic, and then have a data mapper that is focused on persistence and creating needed objects with the minimal number of efficient queries.
&gt; I prefer the latter as it's more readable imho. Though for what it's worth, map is specifically designed for this kind of thing (and you don't need to do the reference thing, which is generally preferable). I do have to agree that map is less readable in PHP, but that's just the nature of closures in the language. Oh well :( e.g. in Swift, it would be something like `let new = old.map { $0 % 2 === 0 ? $0 / 2 : $0 * 2 }`
The if condition is wrong because it will always be true if the variable is a number. 
SQLyog is pretty good in addition to the ones already mentioned.
How often do you have new articles? More than 1 per minute: try websocket, server-sent events, etc. Less: just poll with XHR every now and then. As for PHP, just get a page returning the last of last n articles where n is the number of articles you want to get…
hah you are right thats what i get for responding while sitting at a bar
OOP is a superset of procedural, at least as implemented in most OOP languages you'll get to use. So don't worry. Think of OOP as a way to pack procedural logic, with its own private state, in little standalone boxes, so their scope doesn't get out of hand. The odd thing is how long can you study PHP in a procedural way before you bump into an object, even one of the built-in ones, like DateTime, or PDO. I'd say not very long at all.
I learnt PHP the procedural way (PHP/FI 2.0 days), then evolved to PHP 3, 4, 5, 6 (yup, I did a project in PHP 6, loved the Unicode support :( ) and 7 to OOP, and I'm fine. But you might want to just learn directly OOP, try a few things in procedural, but you will probably like OOP better and find it easier to work with for large code bases. So you should probably now it's there, how to use it, but you will probably prefer OOP still. But I don't think it would be hurtful.
* What is `form_validation-&gt;run()` supposed to do? `run()` is very vague, and doesn't tell me what a success or failure will be * Ternaries are mostly suited to single actions. What if you need to do more than one thing if form validation fails? * The second example has no need for a ternary, because the empty string functionality is just getting thrown away. Overall, functionally it isn't going to cause major issues. It's just a pain to read and understand at a glance, and can cause unnecessary headache when needing to update it and/or add functionality.
CQRS and DDD are nice, but this answer is complete overkill. OP is having issues with basic OOP and you are recommending advanced level stuff as a solution. This should not be the highest rated comment here. Shame, /r/PHP.
CQRS is a very simple concept: you model interactions with the domain as a set of "commands" and a set of "queries". There are plenty of advanced techniques you *could* implement with CQRS, like event sourcing, multiple read-models and so on, but *all of this is optional*, and the fact you *can* do it is simply result of a sound baseline architecture. And I deliberately didn't mention any of that. As for DDD, I specifically mentioned "bounded contexts" and nothing else. There are other ways to call this, but DDD seems to discuss it with greatest clarity, so if you have to Google it, that would be a good set of keywords. Microservices, for example, are a strict materialization of bounded contexts, despite not part of DDD, formally. It's something you need to grasp to be effective in OOP at all, period. I wish that factoring a domain with database-driven state in PHP could be "basic OOP". The language is relatively simple, but the problem to be solved isn't. And plenty of applications take wrong turns while doing it, and suffer in various small and big ways, such as performance, data consistency, lack of flexibility to refactor and add features over time and so on.
Most languages introduce procedural programming before introducing the Object Oriented methodology. My experience with C++ and Java was like this, and Java is straight up OOP all the way. It's important to learn OOP, but procedural programming is an excellent beginner methodology to start learning.
I'm running phpStorm on a late 2013 MBP, and it's barely useful. No network drives, no antivirus scans. phpStorm, a VM, a Node file watch and Chrome. Those things together eat all my CPU and memory. The blame shouldn't be entirely on phpStorm in that set-up, but if everything else I mentioned is closed, it's still slow as shit.
OOP code is just encapsulated chunks of procedural code. If you crank through an undergraduate CS degree you learn procedural, then OO before you ever actually use any of it. If you learn it all through work/on your own you might glom on to procedural for a while then learn that OO can help you become organized. Then you probably realize OO is overkill for certain things with small scope (scripts vs. apps). It probably doesn't matter, but while learning OO you'd learn procedural.
Depends on the coding style. With native functions that take objects as arguments, you could choose not to use OOP. With PHP, many things are a matter of preference :)
Good advice, as per the sidebar. Also /u/brianmonks48, if you could edit your post to indent your code by four spaces for every line, that will block format everything, rather than just the indented structures. The `class Question4Test...` stuff has not been rendered correctly. A tip to do this quickly: select your code in your editor, tab it to the right, copy to clip board, undo the tab right, then paste it here. It'll save you putting the spaces in manually. 
You can do multiple projects in a single window in the latest EAP, and it works well. At work we have one our main site in Symfony 2, and the backend tools in Laravel; neither projects choke and index very well.
Learning procedural PHP is wrong in my opinion. In modern PHP world nobody uses it as that, aside from wordpress, and learning these methods could potentialy harm your self-development as programmer, as you will think that is the optimal way to code in PHP. If your professor press you to use procedural PHP, there is nothing you can do, but to listen. However, then, you should really consider learning yourself from a book or professional guide of some sort.
&gt; If you can't handle brutal honesty, then skip this post. I can't tell if the teacher is bad or the student is or both... array() when it's almost 2017 - it came out with PHP 5.4 (March 1st 2012 aka 4.5 years ago) Trying to divide the array itself, either somebody didn't pay any attention or you should try to get your money back for the class
If the student uses array_map, for sure the student will get in trouble for cheating...
Please remove this... No help posts allowed.
php-fpm has nothing to do with rewrite rules, url rewrites are handled by webserver before the request is passed to php.
Thanks. That helps! The run function is an internal CI function that will do God knows what... 
&gt; in fact it's possible to move to a heavily-OOP structure but retain the low number of DB queries? No. it is not possible, nor is it necessary.. &gt;Is this correct? And if so, am I right to feel uneasy about it, or is it often the case that splitting up one big multi-JOIN query into lots of smaller simple queries is actually just as performant, possibly even quicker? You are right to feel uneasy about it. Because you have a little good sense left in you. If you wait any longer, this Php community will over write any of that remaining good sense with a load of overengineering bullshit... The only thing you need to do is to standardise pieces of Data. For example, the event data, the venue data etc. Better langauges have dedicated constructs for this. But since Php is a piece of shit, you need to use classes. For example, for event data, just make the class contain properties eventname, eventdescription ....and venueid. You don't need to attach a fully hydrated Venue object in the event object. Sure, it would be nice if you can access the location object of an event as "event.venue.location" and have a fully functional location entity. But it is just not possible to know all the usage patterns in your app in advance so that you can have an optimal hydration depth/pattern for your entities. It is just not possible. Hence my suggestion to have a flat structure for your entities. So when ever you need to do processing over a bunch of Events, just run a big join query, and fetch all the data *relavant to the particular task*, and make the required entities out of them (still flat), and store them is so that they can be easily looked up (using Id or something), and do your thing....
Good points. I'd like to introduce one subtlety about one big join vs many smaller queries. The one big join idea is the classic way to go and until this day there's nothing wrong with it. However as machines get faster, database engines get better, latency goes down, etc. I see more people preferring multiple simple queries over 1 big one. Here's why: It's easier to read the code and more straight forward to map to your objects. There's also less chance of slow queries through poorly optimized queries and indexes. Wheigh that against the slight increase in overhead of contacting the db several times, it might just be that having multiple small queries is a better way in some cases. Keep it simple. Future you will thank you for it. 
I haven't tested yet, but it looks like they totally forgot about PHP7.1.
[removed]
&gt; CQRS is not a simple concept in practice, especially if you are ultra-rigid about it and don't even allow return values from your commands. The only reliable way to actually put CQRS into practice is to use UUIDs, which immediately adds complexity to the problem that OP is facing. Or you can simply not be ultra-rigid about it. The different levels of CQRS strictness come with specific benefits. Commands that return literally nothing are only beneficial to extremely high-scale systems. And this is optional, especially as returning data through a read model async is isomorphic to returning data from a command synchronously. The latter is simply more binding for the write-model as it needs to execute and return within a reasonable time. But in the real world, that's also the case when you expect the data from an "eventually consistent read-model". You can't wait all day to get back a confirmation that your tweet was tweeted, for example. In other words, I know that big, complex implementations of CQRS are big and complex. But in a small app, it's a very simple principle, which if applied with common sense brings immediate benefits without requiring zealous rigidness. Just being exposed to this level of factoring can do wonders to your app, versus the "classic" entity-focused factoring, which is very damaging for the kind of execution model a PHP app has. IOW, PDO::lastInsertId is fine.
Check out [Refactoring to Collections](https://adamwathan.me/refactoring-to-collections/)!
If I said "my cat is fluffy", would you also come and reply "if it's just fluffy, it's not a cat"? The logical contortions some go through in order to appear smart is astounding in these places. An object is state + procedures. Of course, this simple construct has many emergent properties, but it's that simple.
I scrolled too far down for this. In my opinion Debian is linux that use less resources then any linux and ubuntu is based on it. So pretty much Debian is a rockstar.
&gt;Unlike PHP, OOP is a really complex science. Yea. Really. It is right up there with general relativity and quantum physics...\s &gt;no more than 5% of PHP users are able to grasp the object oriented programming. Bet you consider yourself in that creamy layer of the 5% of php users who has attained the enlightenment... Can you share some of those awesome code that you have done with your zen like understanding of OOP? &gt;knowing that silly sintax has nothing in common with object-oriented programming... Obviously, because that would blow your 5% theory out of the water. So please tell us O wise one. How shall we know when we have attained the OOP enlightenment? Will we be able to punch through walls and stop bullets?
I'm providing an approachable one-sentence introduction to something who's starting. I don't want to see you stand next to a teacher explaining math to first-graders, dude... You'll be screaming at her *"why aren't you talking about calculus, combinatorics and differential geometry!"* and make all the kids cry. Take your pills, and chill.
I am not even a half-way through. If you were a real user, I would have tried to explain. But for the anon created to fight for the injured pride I've got an analogy: knowing how chess figures move doesn't make you a chess player. Think of it. 
are you beginner at math as well?
&gt; array() when it's almost 2017 What do you mean by this? Do you mean use [] instead? 
Procedural code is perfectly fine. It took us to the moon. Different usecases require different strategies. Procedural is one of them. Don't dismiss them just because you think OOP is the holy grail.
And this has what to do with PHP?
If you want to learn more about what Alan Kay meant, read about the Actor model, defined by his colleague Carl Hewitt, which describes said messaging semantics precisely, and as a mathematical model. Alan Kay has said many thing about OOP, including that what the likes of C++, Java and so on call "OOP" is not his idea of "OOP". Both perspectives of OOP have their uses, and because PHP would suck quite badly in implementing the Actor model, not the least because Actor messaging (like Alan Kay's OOP messaging) is **asynchronous**, chances are we're talking about the Java style of OOP here, which PHP 5.0 is based upon. **tl;dr** Don't be a smartass.
You just have to state that your introduction is on OO syntax, not programming. And yes, to warn a kid that his schooling on the matter will take several years is a good thing. You should have said that to him, not me.
I said nothing about syntax. For a guy who's so keen on nitpicking others' terminology, you're not accurate yourself. You also said methods are "functions" in your other post, where the correct comp-sci term for an imperative language is a "procedure". And that's where "procedural" and "functional" programming come from as terms. A function is a mapping of input to output through equations, with no effects. It can also be executed out of order, as far as the written equations can be solved in that arbitrary other order. A procedure is a series of imperative statements, executed in order, which can produce effects, such as mutating state and doing IO. So my message is specifically to you. Take your pills, and chill. 
&gt; knowing how chess figures move doesn't make you a chess player. Think of it. Whoa! dude!
[This is the only response I could come up with](https://www.youtube.com/watch?v=LQCU36pkH7c)
[removed]
Ok, got you. It is not an excuse but ignorance. You *genuinely* cannot tell an object from programming. It makes any further conversation useless. Come back when you learn the difference. 
Very true; I was sort of thinking about that when I wrote about using a "minimal number of efficient queries", but I didn't want to get too deep since OP already was struggling with the concepts. Another point to mention is the importance of cacheing, because not doing a database query at all is always going to be faster than any number of queries, however fast and efficient they are. :) (Especially for the type of application OP seems to have in mind, which sounds like it is read-heavy.)
Don't be shy, leave the rest of my sentence there, as well.
FTFY: If the student uses array_map and he or she does not understand it, for sure the student will get in trouble for cheating...
Yeah, others in other comments suggested the same, that the allowed size is often the root cause of this error. This is not our case, we have high latency when processing PDFs or using web spiders...
It's absolutely doable with docker-compose; localhost it's not 127.0.0.1, but the whole range of addresses. So, in docker-compose.yml: services: nginx: image: nginx ports: - "127.0.0.10:80:80" 
You should understand the difference between OO and procedural programming. The difference is just isolation of state and side effects. To simplify concepts, let's say we have two edge cases: 1. We have global state and we have set of procedures to work this this state. In this case you will have global side effects, no encapsulation at all, complexity will be very high. 2. You have an objects which contains state and procedures related to this state. So one object will never will pass some of it's own state to another object (no getters at all). You just pass messages like "do something" and maybe pass anything object needs to do the job. For example change password will look like that: public function changePassword(string $password, PasswordHasher $hasher) { $this-&gt;password = $hasher-&gt;hash($password); } "Ask don't tell" principle. But most of developers usually mix this. So you can see objects with isolated state and getters, which will pass it's state to another objects. We could have object with part of the state and object with related procedures. And it's ok since we don't have global state anymore and we can decrease complexity. But this more like "procedural programming with classes". In languages which has modules you could pretty much the same, but without classes (since you has modules). So you should understand the idea of encapsulation, state and side effects, why global state leads to more complexity and how global variable (which is read only) different from global state. One friend of my usually says that programmer should learn: - structural programming first - then functional programming (to learn about state, side effects, functional abstraction and so one). - and then OOP 
s/PHP/Laravel
I would probably separate this out into a REST API and separate front end. Build a REST API returning JSON responses and build a frontend, probably in complete Javascript, Angular or Vue seem like good candidates for that and consume the API with them. At the API level I would leverage caching heavily, maybe a 60second cache so your database isn't hit constantly by AJAX requests. The beauty of this is you can then scale your API back end separately to the front end giving you much more flexibility as your application gorws
you'll still need the basic constructs for OOP, but the general structure of your code is different. Since you should focus on learning to write code, not to write a specific language, learning those concepts is a good thing. If you understand procedural and oop in php, you'll understand it in any other language too. It's mainly the syntax that's different. The ideas behind it are very similar. 
I didn't know there were Wordpress standards?
I use phpstorm on an ancient MBP (far older than yours) and have no problems. Are you sure it's not the case that phpstorm is reindexing as (for example) phpunit has generated a load of new coverage files? (Solution: tell phpstorm to ignore the offending directory...)
Vagrant is like a manager for Virtualbox. Docker is more faster than Vagrant and you can also run the same Dockerfile in production
Nope. Not how most of us feel. Just some developer got PO'd at the language and instead of trying to become a better developer they made a joke. 
At work (corporate environment) I use Windows (primarily in phpStorm). At home I use my MacBook (again, phpStorm). On the go I use my cheap little Chromebook loaded with Win10, OSX &amp; Linux, which I generally use Ubuntu on (and, you guessed it, phpStorm). I've definitely been using the Chromebook with Ubuntu at home more than my MacBook lately, also. Ubuntu 16.04 is pretty sweet! 
From the same source: &gt; I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages (so messaging came at the very beginning -- it took a while to see how to do messaging in a programming language efficiently enough to be useful). So OOP is most definitely about objects. Anyway, I was only taking the piss out of such a silly sentence as "OOP is not about objects". No need for the dramatic sigh.
My sigh has more to do with the pervasive PoV that "classes" and "objects" are what makes your program Object Oriented, and much less with your statement. Not saying you hold this opinion, but it's a common one nonetheless. This is where a lot of confusion comes from for beginners. They are taught to use classes, and basically use them as data containers, or namespaced functions. Because no one explains that it's a different way of thinking and reasoning about your application, they just use the same mindset they applied to 1 paradigm, and apply it to OOP. To add to this confusion , there are those that just say 'oh it's just the same as procedural' and I just give up. 
This sounds like an interesting route. Using Python to trigger PHP sounds like what I was missing. I was wondering if PHP could "compile" to run like a real continuously running program rather than PHPs once and done. I guess using python to watch the events and trigger PHP is the best approach, even if I run PHP directly on the Pi by using Python to run PHP from the command line whenever it needs it. Shouldn't be too hard to learn basic Python. Any idea if Pi has a javascript compiler like the Pebble watch is doing with https://github.com/pebble/jerryscript That would be the most ideal, maybe someday. Thanks for the help!
Interesting, this might work. Wasn't sure if you could do kiosk mode and also run a backend server off the same machine. This sounds like a possible route until I learn enough Pi scripting to build my own custom solution. Thanks for the help guys!
For those knowledgeable in multithreaded database development: how would you design a program that uploads data to MySQL within a transaction but using multiple threads? I'm creating a PHP migration app that takes a DBF (but it could be any data source), convert it to the corresponding INSERT statement, and send it to a MySQL server. The source DB is very old and denormalized but still actively used, whereas the target DB has been extensively &amp; sanely normalized to prepare it for future applications that will use the same data. At its core, the app will take a row of data, process it as needed, and fling it as fast as possible to the MySQL server while retaining DB-level integrity. My current single-thread implementation makes heavy use of DB transactions, try-catch blocks that roll back at the first sign of trouble, and batched INSERT statements to reduce the syntax and statement overhead when sending the data to the much weaker (we're talking P4 here) MySQL server. Considering the processing and data integrity requirements, I'm very proud of how fast the app can transmit the data, which is an order of magnitude faster than the old version. That being said, after countless times doing uploads with this app, I have made two observations/insights: a) the entire app-database architecture runs only as fast as the weaker server's single thread (again, P4), and b) at any point during the upload, one of the servers are just idling while they wait for the other's response. Addressing these two observations became my motivation for learning about multithreading in PHP. One solid week of webcrawling and prototyping later, I created a successful proof-of-concept of the performance gains (after some disheartening initial results; debugging a multithreaded app is HARD!): up to a 2x improvement on my local machine using pthreads. Excitingly too, the CPU usage during the upload shot to near 100%, which never happened before. The problem now relates to everything I sacrifice for this performance. Google fu has taught/reminded me that transactions are isolated to a given session aka connection ID, and personal experiments failed to create a multithreaded program that shares that ID without missing the point of splitting the workload. The only design that makes some sort of sense in my head (and still only knowing the most rudimentary aspects of multithreaded programming) is for each worker to open its own transaction, communicate to the main thread whether it encountered an error or succeeded, and have the main thread propagate either a commit or roll back to all workers. Even with this design however, I have no idea how to actually implement it (something to do with synchronized(), wait(), and notify()...?). I would very much like to hear from people much more knowledgeable in the matter than me what their thoughts are.
A short aside: thank god for this weekly thread, because I seriously feel like all of my questions are silly. Despite being a professional PHP dev for 3 years, I feel like there's so much I'm ignorant of, and every time I see seemingly competent and reasonable questions being posted as threads on /r/PHP that have really low/negative scores, it makes me doubt my own competence in relation to most of you guys.
I know there's Illuminate\Database, PropelORM and Doctrine2 ORM, etc... but is anyone doing the whole repository/datamapping/relationship stuff without those libraries? I was tempted at doing so and just relying on PDO directly just for the sake of PDO being simple by itself, only thing stopping me is I have no idea (mostly don't have the time to spend figuring this out) how I'd do the relationship associations outside of those libraries and it'd probably take me weeks/months to study those libraries on how they did it. So I'm wondering, to anyone who isn't using those libraries but are accomplishing a simpler but similar experience you'd have with those libraries, how are you writing your classes and which, if any, design patterns are you using to accomplish it?
Speaking on a tangent from the OP, I'm a big fan of Scala's (and Martin Oedersky's) interpretation of OOP and procedural programming as being on orthogonal axes - OOP's opposite on the "code organization" axis is a single flat file of global variables, while FP is the opposite of procedural on the "code logic" axis. FP is its own level of awesome, and I appreciate the course I took on it with Scala the more I find uses for the array_* functions.
As a stab in the dark, check `/var/log/audit` for SELinux issues.
Have you considered a single thread with asynchronous queries? Might be a much simpler solution than the can of worms PHP threading is. It's pretty easy to wait for a few queries to return. Alternatively, would your application be fine if it *is* slow, but just happening in the background? you could have a PHP process running somewhere in the background that handles the inserts, but your main PHP script could return immediately.
&gt; Think of OOP as a way to pack procedural logic, with its own private state, in little standalone boxes, so their scope doesn't get out of hand. Well put.
I agree with the resources mentioned here, especially Laracasts. However, you also mentioned passive income. I've built several products, including [Shift](https://laravelshift.com), and recently began offering [1-1 coaching sessions](https://jason.pureconcepts.net/2016/04/mentoring-pair-programming-development-coaching/). You might find this combination particularly interesting.
Yeah think of this approach as your PHP scripts are an external API and your Python script simply calls the external url to grab the output. You can create an entire web app/mobile app in JavaScript/HTML/PHP that runs on the external server. Your external app could have buttons that turn things on/off and adds those statuses into a database. Then have another PHP script that simply reads the status code from the database. Your Pi Python script calls that status PHP script to grab the current status and does something on the Pi based on that. I have an example I can dig up and stick on GitHub if that would be helpful. You can install Node on the Pi and then write js scripts. Ref: http://weworkweplay.com/play/raspberry-pi-nodejs/
In order to sound like a "smartass", one first needs to sound "smart".
No, nice to know there are other options. Mailcatcher was pretty easy to install, there was an error I encountered, but the fix was documented.
Those are kind of things you should determine on your own. Personally I like the MIT license cause its very small, I use github for public projects as do many other open source projects, and composer is preferable nowadays. But those all depend on your project.
Not OP but the only way to throw runtime ~~error~~ exception is if you type the setter parameter, whereas doc typing is at the mercy of the IDE code inspector, which will only highlight and not error. Obviously very situational to what's going on the app, but if you have try-catches somewhere in the callstack, you will want the exception to be thrown at the point of setting rather than saving (to database usually)
[Code is poetry](https://github.com/WordPress/WordPress/blob/master/wp-includes/functions.php#L779)
&gt;Login ID: admin &gt;Password: admin@111 default logins??? external libraries like bootstrap, fontawesome and a shitton of others not loaded via a package manager? two images folders in public [that mess of a gulpfile](https://github.com/akhileshdarjee/origin-cms/blob/master/gulpfile.js) [not following psr2](https://github.com/akhileshdarjee/origin-cms/blob/master/app/Http/Controllers/UserController.php) uhh
The default authentication doesn't work. Register does not work. Your submit button on the form is just a link to index.html which doesn't exist. I'd like to provide more feedback but don't have time to fix the authentication at the moment. I may try again later. 
The student is trying to divide an array by an integer. With such a simple problem, there's no way that the student will be able to understand a function of that complexity in time to explain it to the teacher.
&gt; In a perfect script, everything is an object. Please somebody take out my eyes with a spoon
Going backwards implies recording history. It's more practical for PHP because it has a short run time and relatively tight amount of state. Smart idea. 
Found the Amerifat.
Not exactly what you're asking, but xdebug _can_ step backwards to the line that called the current function.
Do you mean something like a feedback or support board ?
Hi @draven714. As someone who have been in a similar situation, I hope you will find my advice relevant. After failing to adopt PHPLIB over 15 years ago I began my own journey to create www.agiletoolkit.org. The first version was out in 2000 and I used it myself. I rewrote it when Zend2 came out using objects and exceptions entirely resulting in version 2. I then founded a company who would use the framework for developing web apps and developers I hired hated it. I kept refining it into version 3, which gone public in 2005. Now my developers were able to follow it, but sharing it online it still didn't generate any interest. I started yet another rewrite combining everything that I've learned so far resulting in the version 4.0 released in 2011. I have paid extra attention to differentiate my "framework" from others positioning it as PHP UI Framework. As it became increasingly popular more flaws showed up - lack of decent database layer, poor documentation, lack of UI extensions and so fourth. It also became evident for me that I can't guarantee "long-life" support for any user who decided to "adopt" my framework, simply because the product wasn't financially sustainable. Additionally the PHP industry hasn't been standing still. It kept evolving, so a lot of new concepts appeared. Composer and namespaces are now essential, PSR standards, a much more comprehensive documentation, traits, etc. Once again I had to invest a huge amount of time into research and making sure that my next refactor will bring the framework to the relevancy. It's a long and hard road, and the PHP community is not encouraging at all when it comes to new frameworks. You should not underestimate the collective knowledge that is out there in the current frameworks and projects. It takes a lot of effort if you want to have a framework other developers would use. The reason is simple - for most developer learning new framework is time investment. If they use it in their app it's also financial risk. So you either need a framework which is easy-to-learn and very similar to traditional frameworks (and there are plenty like that) or something that very niche and unique, which is the strategy I'm following with UI-focused toolkit. In this case you need to be very specific about your goals. If you continue on your path, I wish that you are successful. Good frameworks are the driving force behind the language. 
There are two layers of confusion in this article. First is that having getters/setters reveals internal implementation. While this may be the case for a naive/default implementation of getters/setters, the fact we *do* have getters and setters allows techniques like: 1. Virtual properties (don't exist as distinct state, but computed from other properties). Example: $circle-&gt;getCircumference() where internal state is just "private $radius". 2. Alternate internal representations. Example: lazy deserialization of content you get over the wire (you store internally as blob, as received over the wire and only deserialize on first access). 3. Proxies. Example: storing the state of all instances of class Point3D statically in a compact array of floats (x, y, z), and the object only contains the start index to the coordinates, not the actual coordinates of the point. Second, while it's true that objects should only expose methods that only directly pertain to their use cases, the use cases for some objects *are to be data holders* for operations in other objects. The so-called DTO (Data Transfer Objects). These are not objects in a classical sense, as much as they are values, structs, which out of necessity are factored as objects, because that's the only primitive many OOP languages have. When a language has native structs, then the need to have DTO as objects disappears, and we can use each primitive the way it's intended. In PHP we don't have structs, but we have arrays, which often play the role of a DTO. Unfortunately, we can't declare the *type* of an array (what fields it has, what type those fields are etc.), so we miss on IDE auto-completion and error detection. So many people still use DTO. Ideally PHP could support something like Hack's "shapes" to solve this. Some people think that OOP is about "everything is an object" approach to programming, but it's about objects and the messages their exchange. And what many don't realize is that an ideal message contains *as few object references as possible*. Instead, it contains predominantly values, which are contextual, immediately consumable, without object reference indirection. Sending object references to objects is very powerful, but very easy to abuse, and result in an object graph full of hard to untangle dependencies (even if you prefer to program to interfaces). As an extra benefit, value-based messages are trivial to serialize and send over the wire. The industry is slowly waking up to this fact, especially with the modern needs for highly distributed architectures, but languages are lagging. Java 10 will support value types natively (distinct from objects). Swift already does. C# does. Eventually we'll catch on. Anyway, we're getting off-topic.
I wrote a few traits for my own needs that implement the hook patterns and some other useful things. You are welcome to explore and use: https://github.com/atk4/core
Ehh not really. It's a big refactoring project. I might throw in symfony. 
He is looking for a system where a buyer can go online and say "I want xyz" and then sellers can, at least it seems, say "I can create xyz for you at a cost of $xx.xx"
Thank you! I don't even care if others don't use it. We just put it out there for those that *are* interested in updating it, and for other reasons I've already mentioned.
Are you missing something from this post?
`*shrug*` Insult only hurts if hits a weak spot or goes from a person whose opinion is important So feel free to use whatever words you're familiar with. 
Is learning procedural PHP a bad thing? Not at all. Just know your professor is going to be handing you a hammer, and sometimes you might want to reach for the screw driver.
As someone who's in a similar situation, I would say don't feel that bad about crushing their spirit or freaking out the owner, telling someone they have an ugly baby always sucks, but at least they buy it cuter clothes. In all actually there are a bunch of different avenues to take. I started with version control, testing and continuous integration and after a few months we've got it mostly going with room to grow. Next we'll be tackling refactoring from PHP 4 procedural code to MVC and implementing proper coding standards. Honestly you can do it any order, I think my best advice is be honest about what's bad, pick the thing that makes you most want to gouge your eyes out and starting writing down what's wrong with it and how it should be fixed. Once you start making progress everyone's lives will improve and they will be a lot more on board with whatever you put out moving forward.
Seems like they missed the part where they post more than just an image...
&gt; Cards for any work done. &gt; Branch per card What does that mean? I never heard that expression before. 
Exactly. 
I tried this once, but it still wasn't good enough to work with Symfony and xdebug enabled. In development mode the page request would take like 10 seconds. Running on a decent computer with an SSD.
ah, thank you for your explanation :)
The link : https://www.storat.com/mustapha/how-did-we-settle-the-heated-debate-about-which-platform-to-use-for-storatcom-1 Not much inside though, the images are also funny, 3 programming languages and a framework for another.
Yes agree with this. To make it easier you can try this which I've done before: select e.id as e_id, e.name as e_name, ..., v.name as v_name, ... from events e left join venues v on ... Then you can automatically hydrate your Event and Venue objects using the `e_*` fields and `v_*` fields respectively. 
I really like the idea. Are there any plans for a native macOS implementation? Is there a way to start debugging at the end of a script? So if you get a white page error, you could faster debug where the error happended.
[GROWS](http://growsmethod.com/) is an agile methodology designed for the entire company to use, not just the developers. It helps you get started in stages, learning the most important practices first.
&gt; Virtual properties - is just computed values. It's not an getters. Just remove 'get' prefix and it will be just usual method. From the outside you can't tell this. I can decide to implement class Circle with a single $circumference property and compute from it for the getRadius() method instead. What changes outside? Nothing. A "getter" doesn't imply there's a 1:1 mapping between internal state and a getFoo() method. That's simply the naive implementation, and something an IDE might autogenerate for you. But not necessarily the only option. &gt; You don't need alternate internal implementation since no data exposed to external world. You didn't understand the example. You have getters, but you don't decode the state until first access. "Access" as in via a getter. &gt; You could add method like "isLessThan" or even static function "sort" which will have access to private properties. Not sure what's the relation to the Proxy example? I gave it more to demonstrate how internal implementation can be very different despite on the outside it looks like a boring set of "getters" and "setters".
Swap is a wrapper around Exchanger to simplify its usage but you can use Exchanger directly if you want.
It seems excessive, but for long running projects made of many components (with each component having it's own ticket or card and it's own dev), there's really no other way to do it. Peer review on a decent sized component in the range of 500-1000 lines of code is hard enough. I can't imagine trying to do effective peer review on feature with half a dozen components all of that size. If you're using Jira (which for better or worse, seems to be the standard de jour these days), then having one 'Epic' card with a bunch of sub-cards is fairly normal.
cool thanks! Will do. Amazing work!
Yes. Just record the screen when you are forward stepping. And play it back when you want to see the past states...Easy!
Thanks. Enjoy!
not sure how you get to 320 files changed in one commit?
I knew! :D
Why do people value stepping back so highly as opposed to executing code while debugging? If I had to choose I would pick the later. What is so great about the former?
We sometimes have really wide reaching changes to our systems that can accumulate changes in lots and lots of different files. Most of my colleagues and I try to group things into smaller commits, but sometimes one slips through...
Thanks!
F8, F8, F8, F8, F8, F8, Oh shit! I just passed the breakpoint I wanted... **stop** F5, F8, F8, F8, F8.... 
I'm sorry I did watch, but yes I know this for a fact (I am working with Drupal so the array keyword is 99% of my time) that array_merge() looses numeric indexes.
&gt;However, if the merging happened always by key (as OP suggests) the result would be [4, 5, 6], which is pretty useless. Well, the sensible thing to do was to implement this behaviour in array_merge() and to use another function, array_append(), to implement the former behaviour. It would have been a little more saner... 
but branching for each ticket won't prevent "slipping through", will it?
Why can't you just set the break point there?
&gt; It's a long and hard road, and the PHP community is not encouraging at all when it comes to new frameworks. You seem to be mistaking this subreddit for "the PHP community". We are not "the PHP community". Only a small part of it. We do not speak for the PHP community, and nobody should mistake this particular subreddit's outlook and beliefs as the attitude of the community itself.
What I learned a while ago, after a lot of pain: the proper answer for array union/merging (by keys) is [array_replace](http://php.net/array_replace)
sometimes you've got a breakpoint in a loop and you're waiting for a specific record to come through so you can see what's up.
So set a conditional break point...
Author of Dontbug here. Dontbug depends significantly on mozilla/rr ( https://github.com/mozilla/rr ) which is only for Linux. And its very difficult to port mozilla/rr to other operating systems as it requires some very specific capabilities that are either only available on Linux or undocumented/unavailable/unexposed in other operating systems like macOS. So sadly at this point I would say its unlikely that Dontbug is going to be available on other operating systems anytime soon. Your best bet is to run Dontbug in a Linux VM on those other OSes.
Yeah, but the people who use composer wrong are unlikely to also separate those out to begin with. Oh well. I'm not going to complain more about that, as the devs I know who do it are otherwise _extremely_ capable, something that I _am_ thankful for. Then again, that makes the whole deal even more puzzling.
How many can answer this without looking? I'd say 14. Am I close? How did you determine how many could answer it?
[Bican Roles](https://github.com/romanbican/roles) works well in Laravel applications. Never had any issues with it. 
linux and mac, both have their strenght and weaknesses. i strongly prefer linux for the development part of my job, but i rely on the mac a lot for pm/office stuff where linux still lacks widely used applications to some degree. 
as soon as your project grows beyond a trivial page/job/script you should definitely consider oop. in my opinion you can write clean procedural php projects, but it takes an enormous amount of disciplin and knowledge (same stands for plain c vs. c++). as soon as more programmers join the team you are just asking for trouble if you stick to procedural.
the sad thing is: wordpress works really well for a lot of people. still looking at the core code makes baby jesus cry ...
I could... or I could be lazy :D
Use something like Slim or Silex ... since they offer you nothing except a nice way to execute code for a given URL.
&gt;Say you have a bug thats occurring but are not sure where its arising from. You can keep stepping backwards/forwards in the code in an exploratory fashion to home in on the bug... The thing is, in real life, this does not work this way. The whole execution of a program often spans hundreds of thousands of statements, that finding a bug by single stepping in either forward or backward direction is not really feasible. You often need to find a rough estimate of the location/conditions when the bug happens, and have to step from there. And if you can set a conditional break point, the advantage of something like this becomes not that great...Because even if you miss a step, you can just execute and break on the condition one more time. So if your programme is so trivial that a bug can be found by single stepping through it, then you don't need something like this at all. And if not, this is not going to help much... I mean, this is something that looks great on paper. But not so in reality. 
Instead of breaking on condition 'break if i = 50', you would rather keep stepping through all the 50 iterations? And you call that lazy?
Honestly, with the amount that laravel does for authorisation, it's worth rolling your own. Have a roles table and a permissions table, and a couple of many-to-many relationships. And some methods on your user model. I've often found with these kinda packages, they either try to do too much, and it gets complicated. Or they don't do what I want.
So I guess reading the docs for this function or using Php arrays more than a couple of times makes you swap the meaning of 'append' and 'merge' in your heads. I heard somewhere that learning php can make you brain dead for further learning...Now I can see why.
Why is this being upvoted? What is interesting about this?
You're correct about your description about bugs in "real life". The appearance of a bug and its cause can be separated by thousands of lines of code. But you've probably misunderstood how I intend Dontbug to be used. There is nothing preventing you from running backwards and forwards thousands of lines in an effort to find the bug. Dontbug not only does step backwards it can run backwards too -- till it hits a breakpoint. You can run backwards an arbitrary amount of code. If you don't have access to reverse debugging you'll often need to start the debugger many times for a complex bug. The restarts waste precious time. Also sometimes you might miss a carefully constructed situation and need to start the debugger again. Using reverse debugging you can avoid having to restart. Yes conditional breakpoints help but still don't solve the problem in all situations. For instance while debugging a complex bug you're not sure _what_ conditional breakpoint you need at first. Also, if you have a bug that is tough to reproduce/occurs intermittently all you need to do is reproduce that bug only *once* in a recording. Then subsequent replays will always result in that bug occurring. How amazing is that :-) ? Actually, in "reality" reverse debugging is better than on "paper" (according to me). That because its a concept that you need to use a bit to really appreciate. My request is: use it a bit and then come to a final conclusion. In recent years, reverse debuggers are cropping up all over the place. A cursory internet search will convince you of that. There are also some nice articles on how reverse debugging has been used to find out complex bugs in other languages like C/C++ (mozilla/rr does reverse debugging for C/C++ programs) -- just do an internet search. Reverse debugging is not a silver bullet (nothing is). It just increases the tools you have in your arsenal to squash bugs. I think you will like it. Try it out :-)
People who use Typo3 may be interested in the benefits it can bring them and their development/deployment workflow? Also, since this follows Drupal Commerce, Magento, and eZ Systems, it marks a significant trend in the PHP world. Full disclosure, I work for Platform.sh.
I'll repost a comment of mine from last time this came up: --- I help out a lot in #laravel on Freenode IRC. A lot of people want to implement ACL. Here are some of my thoughts: * I've rarely seen someone come into #laravel with good things to say about Sentinel, Bounce, or Entrust, the three major ACL packages for Laravel. They're always asking for help with them, and their problems usually wind up being due either to bugs in those packages, rather than user error, or because they want to do something those packages don't support out of the box. * I believe that in 99% of use-cases, the built-in Gate/Policy feature is more than enough. For most users, all you need is basic ACL questions like "Can this user access this resource?" "Can this user perform this action"? Those are very simply defined in Gates and using the expressive API like `if ($user-&gt;can('create')) {...}`. * In my opinion, if you don't know enough about ACL to roll your own, then you're probably in the above category of only needing basic ACL, so again, I'd go with the built-in Gates/Policies. * If you DO want more complex ACL, it's unlikely that a pre-produced package like Sentinel will solve your problems out of the box, which means you'll still have to write custom extensions and code. And since you're using a userland package, it's not officially supported by Laravel. * Finally, piggy-backing on that last sentence, if you use Gates/Policies, it's officially supported by Laravel, which means you'll get tons of help in #laravel, in larachat.io's Slack chat, on Github issues, and in laravel.io forums. In short, I'd suggest following the Laracasts videos on ACL and rolling your own versus using a pre-existing package like Sentinel. Keep the Gates simple and compose-able, and you should be fine. (No offense to any Sentinel maintainers here, hopefully.)
All right, from what I've gathered, there really is no single package which does what I want. I'll extend Laravel's core features and add the things which aren't already there. I think I can simply add Gates/Policies based on permissions. Thank you for your comment!
How are you dealing with relationship stuff between entities? I just want it so if I do a left join inside my repository I could tell the data mapper what's going on and it would assign an entity to the main entity that you had a relationship with eg.: we have a user with many posts and we some how tell the mapper to deal with that data and format the join data and we can then access all the post data `$user-&gt;Posts` or `$user-&gt;getPosts()`
Look, if it isn't interesting to you, downvote it. Whatever. It's industry news. It matters to some people. By the way, have you tried Typo3 recently?
In this particular case, I don't have to. If I had to deal with problems like eager loading, relationships, or aggregate roots I'd probably switch to an established ORM - I don't think I have any ideas that are better than Eloquent, Doctrine, Propel, etc. In my case the underlying data is really denormalized, so using an ActiveRecord ORM would be really clunky. EDIT: I realize now a big part of your question was about handling relationships, so my answer is kind of unhelpful. Sorry. :/
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
No. It started out as an acronym, but no longer: http://growsmethod.com/faq/ (last question)
Jesus, you're right. What the fuck, I didn't even notice.
&gt; For instance while debugging a complex bug you're not sure what conditional breakpoint you need at first. But if you don't know what condition to look for, how will singe stepping in either direction will help you? Because you don't know what to look for in every step... &gt;That because its a concept that you need to use a bit to really appreciate. I think the opposite. The concept sounds amazing. But as I said before, I am afraid in real cases, it won't be as useful as it sounds. And I did search the net for "reverse debugging is great" hoping to find articles where people have solved complex bugs using reverse debugging, but the very first result was [Why is reverse debugging rarely used? - Programmers Stack Exchange](http://programmers.stackexchange.com/questions/181527/why-is-reverse-debugging-rarely-used).
Can you define what consist of a 'list' and what consist of a 'map' in the context of Php arrays?
A list is an ordered sequence of values. In the context of PHP arrays it's an array with monotonically increasing integer keys, starting at 0 and not having "holes" (i.e. list != sparse list). PHP throws in a curve-ball by allowing you to have an array where the order of the key/val pairs (during iteration) doesn't match the indexes. Quite unfortunate, but my convention is to always look at the indexes and ignore the implicit order (also my list functions always output arrays where order matches the indexes, but for input I look at indexes). So I iterate lists with for() not with foreach(), unless the kind of processing I do can be done out of order without changing the output. As for a map, it's a set of unique keys (string or int), each linking to a value. Order is not significant and should be seen as arbitrary, and even when the keys are numeric, there's no semantic meaning ascribed to this. From a morphological PoV you can take "a list" and choose to process it as a "a map". The data is compatible, but the outcome will be different, because the semantics are different. Just like your original example with array_merge(). That's why it's important to have clarity in interfaces if what you're working with is "a map" or "a list".
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; I'd think that going backwards is stepping back in history; it sounds like instead you're replaying from the beginning up to the previous point. You are correct in your understanding from a conceptual point of view. It's indeed like running replay always from the beginning upto the previous point. In practice this would be extremely slow so this is only an approximation what *actually* happens under the covers. &gt; I'd still think you could resume execution going forward with the current context, even if some values were changed. Yes, thats possible but changing PHP variable values at a point in the past and running from there will cause "divergence". For most programs this "divergence" will cause replay to be impossible. This probably did not make much sense. So I suggest you to please read https://github.com/sidkshatriya/dontbug/wiki/How-the-Dontbug-Debugger-works at least upto to the "How RR works (briefly)" section. Once you've read it, you will appreciate that system calls are emulated during replay. Once you do a replay from an arbitrary point in the past after changing PHP variables, the program could access, for example, a socket file corresponding to the mysql database. Since there wont be any data for this system call in the replay log, it will fail. In certain cases where there are no system calls and only user space code, you can do precisely what you're talking about. But system calls are generally quite ubiquitous so one really can't go around changing PHP variables in the debugger at arbitrary points in the past and hope for it to run without divergence. 
i had read it (which is where I got my approximation from) but admit it's still a bit beyond my experience (and I've not actually used your code yet). The 'divergence' you're speaking of is what I was getting at with file/streams. Certainly not all things could be changed going backwards then forwards again, but there are many situations I've been in where it would be handy to go back 2 steps, change a value in an array, then re-step-debug to see what effect the changed value has. In any event, thank you for your contribution, and thanks for the write-up. I'll try to dig in some more in the coming days and keep an eye on this.
Right now you're at the peak of that lost/confused feeling. It's all downhill from here (regarding that feeling specifically). Stick with PHP/MySQL, as these are the easiest for newcomers because there's so many guides out there for first time programmers. PHP also has the most helpful error reporting I've seen for any programming language, and also the best documentation, with lots of examples. Don't worry too much about doing things "the right way" or learning frameworks right now. These will lead to further confusion that isn't necessary right now for you to get started with programming. If you've never done any programming before, using a framework or even object oriented programming will be quite confusing. But you should come back to those things later. Just keep at it and you'll soon make progress. Rather than learning specific concepts separately, you might be better off with a goal project. For me back in the late 90s, it was to program my own web based address book. I find it very hard to learn/remember concepts that I don't need to use right now. So I just focused on working out how to build my address book, it's much easier to retain knowledge and learn when you have a specific need to achieve your immediate goal. Once I built my crappy little address book, I understood the basics of PHP and interacting with MySQL. 
Not sure how he's mistaken anything since he never said this subreddit was the entire PHP community. I sure didn't take it like that either.
Thanks! :-) The key point to remember is that calls to databases/files/networks in your PHP code all work fine during replay. (And thats because these calls are simply emulated and not re-executed during replay). Each replay sees the database/file/network exactly as it did during the record phase. The problem only arises when you want to _change_ PHP variable values in the debugger as you want to do. So, its not allowed. Yes that useful but its a limitation of the record/replay architecture..
The replay is "exact" in the sense that it is the same every time you replay that specific execution recording in the debugger. Even if certain files that your script had accessed or a database that your script accessed has now changed in the interim, the replay will be the same. Not being able to change variable values in the debugger is a limitation of most record/replay frameworks in general. We still have huge gains with this limitation though. Checkout the previously mentioned http://fitzgeraldnick.com/2015/11/02/back-to-the-futurre.html and other similar blog posts on the internet. 
Hire dedicated CakePHP experts from ARKA Softwares and enjoy the benefits of best CakePHP web development in USA. Contact affordable CakePHP Development Company in USA at + 1-682-235-3275. https://www.arkasoftwares.com/cake-php-development.html
It is you who does the exploratory debugging. Sample Example: Run forward to a breakpoint, step into a function, run forwards in the function a bit, decide that is not what you're looking for, step out of the function, rack your brains, take an educated guess and set a breakpoint in another place in the code which might be possibly causing the bug and which is in the past, run backwards... and so on. Its tough to explain all this is with words. You can possibly look up videos on youtube on reverse debugging too. **Edit:** My original example was not a good one. Changed it to make the case for reverse debugging clearer.
i upvoted cause i find it interesting, i've worked with typo and now with Neos, compared to wordpress its so much better 
I tried to learn and love Vagrant for 3 whole months. After messing around enough with unstable connectivity and behavior under Windows and not to mention incomplete, obscure and lacking Ruby configuration for many packages... I just started using VirtualBox directly. Never looked back. I'd say something like XAMPP remains a better choice for beginners and casual users as well (or direct installation of PHP and desired dependencies).
So you've learned to program but you haven't learned about setting up an environment. These websites have environments set up so you don't learn what's going on behind the scene. For what you want you need php and mysql on your system. You can use xampp or wampserver to install these on windows. Not sure what you have. It also gives you apache which will serve the page to your browser when you visit 127.0.0.1 google 'setting up php environment' or something similar and that will get you started. Once things are set up properly on your system then you can just focus on programming.
I have not used Vagrant alone, I used it with ansible and I cannot handle my stuff without it. XAMPP can help beginner quickly to get started but actually the package I built, It can totally replace #xampp and even faster
Thank you @danstorm for your comment, my package is actually simpler that but my blog seems make it complicated. I will find a way to make it useful to our community.
Add introduce single step deployment to your list. I've found that convoluted deployment processes hide other bad practices - forcing deployment to be entirely hands off pushes these problems into the light. I also like "at the end of every iteration the code needs to be deployable" - whether it is deployed or not doesn't matter but you should be able to do it if asked. "If it's not deployable, it's not done"
Never had a problem on Linux, for beginners docker is actually easier in my opinion because it takes 3 commands to get everything installed and running, you can easily choose which directory represents your /var/www on the host with the volume parameter.
You could add the installation steps to the repository README for starters; linking to the blog post should be a secondary information. Note, tagging users on Reddit is done with /u/ (i.e. /u/phanvuglap ) and hashtags in Reddit titles has no effect in Reddit context.
sudo apt-get install apache2?
It's the nuclear option but uninstalling Vagrant, deleting ```%UserProfile%\.vagrant.d```, then reinstalling can fix weird issues.
Ain't every cool kids using Docker now?
Unfortunately, there is no Ansible client for windows yet :'(
If you run it like this then it will use the current directory. php -S 127.0.0.1:8000 If you run it like this then you can specify the directory it serves from. php -S 127.0.0.1:8000 -t webroot You can even set up some basic URL rewriting. http://lornajane.net/posts/2012/php-5-4-built-in-webserver Check out the docs for more information. http://php.net/manual/en/features.commandline.webserver.php
you can try this repository:https://github.com/hidehalo/Emoji
If I where you, I'll do the following: - Download a "development webserver" package like WAMP or XAMPP. They are all about the same, they bring you: - A webserver (most often Apache) - A database (most often MySQL and SQLite) - PHP (most often php 7.0 now) When you installed that application, you get a really simple control panel where you can turn these things on and off. Also, you'll get the following: - An interface where you can 'manage' your database. Most often that will be PHPMyAdmin, which is a web based admin panel, and it's fine. - A folder (most often called htdocs, public_html or similair) where you can put the PHP scripts that are being run when you visit your own webserver. - A port where you can reach your own webserver in the browser. This is most often :80 (try turning the webserver on and going to http://localhost:80) or port :8080 (try turning the webserver on and going to http://localhost:8080) You'll most likely find all that stuff in the control panel. I would suggest you do the following: - Install WAMPP / XAMPP or similair - Start Apache + PHP + MySQL (or whatever they have as an Apache or MySQL alternative) - Most often you can start all of these at once with one button from the control panel. - Look in your browser at localhost:80 or localhost:8080 to see a working 'welcome' page. - Start changing the .php files in the htdocs folder to get coding! The next step, when you get the hang of the basics of PHP, you can use a small framework to help you coding and start structing your code. There are many frameworks, and most of them are good. I'd suggest using a micro framework, because they are easy to get a hang on. One example of a PHP microframework is Slim. The database is already there, so you can just use PDO on localhost to start talking to that. If you need any help to get started with talking to a database from your application, just post a new topic! :) Good luck!
If you check this file https://github.com/giappv/hello_vagrant/blob/master/devops/ansible/windows.sh, you will see the idea. It actually do provisioning inside VM
Hi guys, I'm the developer of this CMS from MUMBAI, INDIA. I'm glad that you all took your time to look into this CMS. It's still in alpha stage and I'm working everyday to make this better. Would like to hear more suggestions. Thank you all. 
Hi @iAMthePRONY, 1. In the next update, will load external libraries directly from package manager. 2. 'img' folder is for website images and 'images' folders is for application images. Thank you, your feedback are always welcome :)
I feel like this headline was generated with dack.com bullshit generator.
Well, it would create a kind of mental barricade to the "do all the things in this branch" mode. Of course you'd have to make sure that the tickets are small enough and not something overarching like "write a business to business solution that creates a win win situation and turns us into a global player. Also, make the background color pop!"
https://github.com/imarc/auth
Some time ago I've made a Behat extension that displays user deprecated features like the **symfony/phpunit-bridge** package. More info on the github repo: https://github.com/caciobanu/behat-deprecation-extension Feedback is appreciated.
Even though it may seem daunting, I recommend you check out [composer](https://getcomposer.org/) early on. It'll save you many headaches over learning how to enable and use e.g. Perl extensions.
if you've already got Apache or IIS serving PHP, is there any advantage the built in option provides?
&gt;simple user management ...OK... &gt;\[full featured user management specs with SSO, roles and permissions, and extendability, possibly as an API/SPA \] Once you've had a go at it, my standard rate is $60 NZD per hour plus tax, although higher for short term projects. You will have to allow some time for me to refactor existing code... :)
There are still many companies with legacy architecture that is using 'old skool' LAMP or LEMP stacks. Unless you are going to work for a cool web agency in a major city center with cubes, swings, coffee machines and all the silicon valley bling learning how to install and configure a LAMP stack is a major skill
Yes, thats it. Even Brexit leaders after a "victory" said "we did it, bois, we f'd britain in 'the A**'", and left. As much as you care about the company, you really dont care what will happen next, all you should do if you want to feel better is make sure he knows what php stands for, and if he is main candidate, then maybe show him a tutorial on current structure, show him documentation, all that stuff, and thats it.
The problem most of these devs are having is that they are using Windows..... Windows is a nightmare of a development platform
The problem is hes developing on Windows yet deploying to *nix systems.... I know, I know its really a backwards thing to do but most people on Windows wouldn't even know what a LAMP stack is, they simply use XAMPP (awfully configured LAMP stack 'out of the box') and drag and drop their code onto a shared host. I had the same issue when first reading this post looking at it thinking WTF?? But you have to look at it from the prospective that the writer is brand new to development and is just learning about dev-ops and how to start continues integration correctly.
Ah your're on Windows.... I see the point in your post now, the way the title reads is like this is some new amazing discovery but its now clear actually you're really new to development which makes sense why you've been using XAMPP and developing on a Windows box. Good luck with your programming adventure but I would seriously look into continues integration and continues delivery (GitLab is a good all in one solution to get started with) and switching to either Linux or Mac for development will save you a whole lot of pain in the future 
and because typing `uri` into packagist search box yelds no results
Not really. If you have multiple php projects then you need some sort of virtual host capability which usually requires at least a minor tweak to your web server configuration when you add a new project. With the built in server you can just start it and go. 
But typing "php parse url" into any of the relevant search engines does :)
Looks very promising, starred :) !
Docker works fine on windows, it runs Linux VM and within that uses containers (all managed for you). Vagrant ONLY uses VMs. Additionally, when containers for windows are ready, migration will be much easier
If you are using Doctrine at all [Laravel Doctrine has a simple ACL](http://www.laraveldoctrine.org/docs/1.2/acl) that I use and enjoy. It's just barebones enough that it stays out of your way but has more features (permissions and roles with permissions) than the built in Gate and works on top of Doctrine's authorization system.
Very nice work, especially amazing that it runs faster than node.js. I have a technical related question though. It's stated that this framework requires pthreads, and that it runs on unix based system. But as far as I know pthreads works only with PHP on windows. So how does Kraken framework use pthreads? Does it require thread safe version of PHP? I am just a bit confused, but anyway I am really liking it so far.
Instead of blindly doing vanilla PHP coding, I highly recommend using a state of art rapid development framework - like https://github.com/cakephp/cakephp - and start doing tutorials and alike. After a few hours you are already capable of building medium complex applications, including DB layer and whatever, and that even without the typical beginners mistakes, like XSS or SQL injection. So you are - productive from the beginning - future proof - dont have to learn everything at the beginning - have guidelines and conventions to guide you :) Problem solved.
They even both have a kraken logo. At least they do different things. Wait what? Krakenjs is a PayPal open source project? I'm definitely avoiding that. Their website barely even works...
Sendind redirect headers after content?
There is also - https://www.gitkraken.com/ 
If you're developing for the Windows platform then yeah sure it makes sense.... but to develop on Windows and then cross your figures and hope it deploys okay on a Unix like system? I just don't understand the logic behind it. If Windows made development easier than Mac or Linux then it would make sense but its actually *harder* to develop on Windows than Mac or Linux, its just madeness
Also just discovered there was already a Kraken PHP... https://github.com/kraken-io/kraken-php
Speaking of which, are there any underscore naming standards our there that tools support in PHP? I really hate camel casing for names.
This might just be the most harmful "advice", that I have seen for weeks. 
No tests will result in massive amounts of time spent on manual testing and debugging. Automated testing ALWAYS pays off.
This is terrible advice, "instead of blindly doing vanilla PHP coding, blindly use our framework instead". 
You'll get memory leaks anyway because not having any (Doctrine among other) would require to manually clean after yourself. Sure it's doable, but in the case of Doctrine for example, it's something PHP is quite much better at. Again, doctrine is an example, PHP has not been designed for long living process, at its core, extensions and libraries. I don't see the point in background processes: after all it's where performances matters the least. And for the foreground, you have a lot of things to look after before considering to bring yourself the trouble of long living applications: you can disable the Composer lookup file (i.e. just use the dumped classmap), make use of APCu for the bootstrapping for example, and fix your performance bottleneck at your application level, not pushing it elsewhere.
Symfony doesn't provide a HTTP server, so it cannot be compared directly with Kraken, which does. That's why in order to have a fair comparison, we need to run Symfony in a HTTP server like ReactPHP, IcicleIO, Aerys, etc. And I strongly disagree with comments like "PHP wasn't built for this": When Rasmus created PHP in the first place he didn't have in mind any of our use cases, and we can still build amazing stuff. `stream_select`, which allows us to create a server in PHP, has been available since PHP 4.3, so I'd say it definitely was built for this.
TL;DR - Streamline your work by splitting it into small tasks - Avoid multitasking - Practice coding problems every day, beyond just your project’s tasks - Memorize A Universe of Wizdom
PHP itself doesn't leak any memory, neither does Doctrine if you flush the entity manager. Memory leaks will come from global/static variables (e.g. an array that continues to grow), which you should avoid (that's why people keep repeating your application should be stateless). Autoloading will still have an impact on your performance, even when using the dumped class map (I'm assuming you're using the authoritative class map option): each time you'll use a class that isn't loaded yet in your code, Composer will require it from the filesystem. In my personal experience (I'm not saying it's the same for everyone, by the way) autoloading is the main bottleneck, so optimizing the application doesn't yield enough performance gain overall. Once again "PHP wasn't designed for this" is just plain FUD, it is based on a subjective assumptions. You're pointing out memory leaks, but it's a strawman argument to use another language, but the truth is that memory leaks are an issue in every language.
I just drink beer while coding..
They say you only need pthread if you intend to use threading, which makes sense. &gt; Requirements: Pthreads extension enabled (**only if you want to use threading**).
Ah. reminds me that I need to update my website on glorifying satanism and paganism in Typo3 soon...
Popular, yes. Industry standard, no. Being Linux only is great, but being unable to port Dontbug to Mac/Windows will prevent it from being "industry standard". 
I'd add: - stay away from distractions (people, noises, tv... whatever one might consider to be a distraction)
Currently building a simple role and context based identity and access system with event sourcing, but not ready for production yet. https://github.com/hollodotme/identity-and-access Contributions welcome. ;)
[removed]
Otherwise: http://www.openldap.org And: http://phpldapadmin.sourceforge.net/wiki/index.php/Main_Page Is old school but works fine.
&gt;each time you'll use a class that isn't loaded yet in your code, Composer will require it from the filesystem Yes, I was saying to turn that off. Well it's not always doable for example if you are using SwiftMailer (although it would be weird to use it in the foreground in the first place). You can also use the ApcuClassLoader. &gt;Once again "PHP wasn't designed for this" is just plain FUD, it is based on a subjective assumptions. Claims made by PHP maintainers. I'm not familiar with PHP internals, but I know 1. they are far from being the best and 2. they are much more aware on how they built it, and why it is thread safe or long living safe or not. &gt;You're pointing out memory leaks, but it's a strawman argument to use another language, but the truth is that memory leaks are an issue in every language. Well first memory leaks are more likely to be an issue in PHP, simply because it was never meant to be used for long-living processes. Take the intl extension for example, it does have memory leaks. And so are likely to be most of the libraries and extensions. I'm not saying it's not possible to fix it, but I'm saying nobody cared much in the first place because unless it was an horrendous one it was always mitigated by having the script killed at the end of execution. But to be honest memory leaks are only the tip of the iceberg. One reason PHP is so great is precisely because you are 100% sure you are not sharing state between requests. Break that and you bring a whole lot of problems, security notably. In the end if you make sure to design your application for it and test it properly (that does imply to test your application more thoroughly) it is perfectly doable sure. But that implies more than just checking your own code: you have to check each library and extension your are using as well, or at least the part you are using, which is definitely more tedious. So "PHP wasn't designed for this" is not just plain FUD, it has very good reasons. If you do it knowing the risks, it's ok (and I have no doubt that you are), if you do it because performance are an issue and this looks like a simple solution, then no it is not, far from it. If it was an easy solution, it would have been a long time since companies like Google, Facebook and Apple would have worked on solutions like ReactPHP. The fact they didn't is that the risks your bring with this solution may not be worth the effort. NB: just to make clear: I'm not saying one should rule this out either. It is a very interesting project and there is definitely cases where some projects/apps could benefit from it. But let's not ignore the misery this brought in other languages either, it needs to be used with great carefulness.
&gt; At the end of the day he's been exposed as a complete fraud now Which is why I've had you tagged as this: http://i.imgur.com/sXdLkaZ.png (It was between that and 'Pixie Fucker'... I stand by my decision)
PHP garbage collector is not 100% deterministic, and calling the unset function on each variable in destructor might in some cases prevent memory leaks. This is visible for example in evenement which on some configurations leak memory that cases to exist when unset is applied, even if GC should do that by itself. 
Please provide a reproduce script for this claim. It may make sense to unset properties *outside* the destructor to manually break cycles and preempt the GC, but I don't see how unsetting properties *inside* `__destruct()` makes any sense. If `__destruct()` is getting called, PHP would have unset those properties anyway. (Nitpick: Destruct and destroy are decoupled during shutdown, but this is not relevant here.)
In theory yes, __destruct() and GC should have done all that you describe, but in reality if you have ever worked with React PHP you might notice that PHP sometimes behaves strangly in that matter. How can I provide a reproduce script for non-deterministic behaviour? I gave you library in which it is visible, go and experiment yourself with it, with and without addition of these 'unecessary' unsets.
Reddit's first users and posts were also fake.
and https://www.kraken.com/
Standards are nice, but it would also be nice if tools supported multiple standards so projects could have choices of which standard they want to use and still have good tooling support.
true, but that doesnt mean we should actively support it or not call it out when we see it
Please keep it to the facts. Personal insults aren't acceptable here.
I've used it years back when it was superior than zend studio (before merging into eclipse). Right now I can only say that PhpStorm is a proper IDE, simply because I don't run on windows. I've seen colleagues work with NetBeans and it seriously makes me want to pull out my hair when sitting next to them. I'm more productive spamming random buttons in vim and ending up in recording mode, than working in NetBeans (or Eclipse). 
&gt; Tried VirtualBox but holy hell is that thing slow. &gt; never tried docker. You should. On linux, so that you don't need a vm or sharing it's way faster than anything else.
But that would just use 6% of my brain.
[removed]
relevant. Probably true for Digg and Ashley Madison and and and...I clicked through hoping to find some reason this matters.
Unless your own database is another popular product, if you want third party software to work with something of your own proprietary, you will have to expect a bunch of added work. For starters, there's no PSR (or equivalent RFC) on Authentication API, so there is no common API to work against. Furthermore, no one knows the database schema of your database, so there's no easy way for them to bridge into it. Now, if you offer some form of OAuth workflow out of the box, it might be easier. But, that would require the forum solution you're looking supporting that kind of workflow out of the box, or you might be able to monkey hack FB / Twitter / Google Auth to work against your OAuth workflow.
"Laravel loves it so much to the extent that you'll find a new yarn.lock file in your project root, each time you use its command line installer to run laravel new app" I think it is a relevant post.
How about https://github.com/jwage/purl ?
Im pretty sure that there's many other words and made up words that are left to use.
If I'm understanding you correctly, when my mock fails the test stops execution. However, with a spy the test would continue to run because the checks would be run after the fact. 
Double Reply!!! I think you have to make sure, otherwise you could be passing the wrong params or have some math go wrong: public function foo($fizz) { $this-&gt;bar_dependency-&gt;fizz($fizz / 2); } You would need to test that what's passed to `fizz` is actually half of `$fizz`. 
It did kinda surprise me when it popped up in the top 5 tending repos of the day on Github back in September: http://imgur.com/a/VduoG
I've always had to use a switch to build with ZTS. Don't know enough to comment about where it's default or not.
It boggles my mind how often this gets left till after people have a problem. If you get single step deployment in early, you save so much time because new deployment requirements get added to that step. When it's done later, it takes ages to get all the deployment cruft into a script, and in the mean time, you still have to deploy manually!
It seems there's some confusion here. MySQL user authentication implies how you connect to MySQL itself. And in this context "custom authentication" makes no sense. Try to phrase your question better.
It is [a little bit](http://imgur.com/a/NTVmt) PHP though. 
I agree with that statement, but I don't agree this is two levels removed. 
I wouldn't go this far, at least not without supporting a solid argument (which I attempted to do above). I just think testing for method calls, with spies or mocks, results in brittle tests.
One beer per feature (must include tests, docs) works pretty well and keeps you at Ballmer's Peak.
Yeah, well, If I do bother to do so, perhaps I'll try a platform that is sane..
 $solution = $solutionFactory-&gt;elegant()-&gt;complex(); That aught to do it.
&gt;The Director at this company request a code sample of object oriented to elegant solution to complex problem. This isn't much of a specification. Are people "failing" because the solution isn't considered "elegant" or "complex" enough? It's reasonable someone given a vague spec like this would spend less than an hour on it. If you're expecting days worth of work, that would be your issue.
I'd add a couple more to the list, continuous learning: Monday morning schedule 30 minutes to an hour for the team to learn something you'd like them to try and implement during the week. Example: how to write a unit test or what is an interface and how can I use it Pair programming: two developers work together on the same task but only one types, after one hour have the other developer type Coding style standard, making a tool format your code into a psr before commits VM or Ansible, infrastructure as a service, this eliminates the "it works on my machine" and help CI/CD efforts Tools, standardize them, easier if everyone is learning and using the same tools. There are exceptions but they are rare One week sprints with the goal of releasing at least once during that week, using the one card per branch allows you to release much faster Use semantic versioning Don't be afraid to fail, we have fail huddles to discuss what went wrong and how do we not do it again, it's not about blame 
You know what they say about publicity.
the JavaScript world is a mess - I'll keep my lamp stack with Jquery
Even that's a pretty rare use case. Destructors are guaranteed to be called immediately once the last reference to an object goes away^1, which means that well behaved resources (i.e. defect free native extensions) do not have to be closed. In other words, SQL links, web sockets and files are all closed automatically. There are of course times that you will want to close a resource manually like to make sure a file has fully flushed to disk, but this can't be done in `__destruct` anyway since throwing an exception in `__destruct` results in a fatal error, and there's not a very pleasant way to handle that situation otherwise. ----- ^1 [__destruct documentation](http://php.net/manual/en/language.oop5.decon.php): &gt; The destructor method will be called as soon as there are no other references to a particular object, or in any order during the shutdown sequence.
definitely true for ashley madison. like 80% of the females on there were faked.
Hire Laravel Web Developers in USA and make your complex website easy for your customers. ARKA Softwares Laravel development services in USA are affordable and effective for everyone. https://www.arkasoftwares.com/laravel-development.html
Yarn is not used in conjunction with any PHP. Yarn may pull down Node modules that assist in linting or some other task that may interface or coincide with PHP, and *those* would perhaps be relevant posts for this subreddit, but Yarn itself is not interfacing with or utilizing PHP itself. We might as well post articles about `bootstrap-sass` in here as well, seeing as Laravel also uses that in it's build tools as well. /s
I think it's the same dev? Could be mistaken tho
I've used ReactPHP, thought this could be pretty sweet. Of course the argument still persists "why not use Node?" but if you want to leverage your PHP skills and do this stuff then it's great to see stuff like this getting made. He could have chosen a less taken name for it maybe, or maybe this is future Westeros and all these things are made by Greyjoy descendants?
&gt; Google is smart enough to know what you mean when you type "kraken php". Did you actually try it? Because the top result for me is actually a completely *different* "kraken php" project: https://github.com/kraken-io/kraken-php Unique names are hard, but not this hard.
&gt; As far as I know, PHP on linux is by default not thread-safe, since thread-safety on linux system is essentially impossible to achieve. Where did you hear that from? PHP's TSRM will use pthreads (the C library, that is) when ZTS mode is enabled, or will fall back to some other threading library if pthreads is unavailable. Very likely, ZTS mode is disabled by default because it comes with a small performance hit when performing global lookups in ZE. Given that very few PHP installations typically require thread safety, it generally makes sense to keep ZTS mode disabled unless it is explicitly required.
There actually are. First of all there's [php-codesniffer](https://github.com/squizlabs/PHP_CodeSniffer) with which you can create [your own ruleset](https://github.com/squizlabs/PHP_CodeSniffer/wiki/Annotated-ruleset.xml) and pick from existing ones like PSR-2. Also there is [php-cs-fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) which allows you to change code according to your code style. You can manually select which rules you want to apply or not. If you use an editor like PhpStorm you have a huge set of code style-options which you can change for each project and even reformat code to match your current style. Obviously this is intended to help you stick to your own guidelines and not for switching them around for each developer, but there are plenty of tools that allow you to have your own flavour. When it comes to underscoring there are plugins for PhpStorm which allow you to quickly switch between camelCase and snake_case and there are plenty projects using camel_case for example phpspec. As far as I know (I haven't read it in ages, so don't take my word for it) PSR-2 does not force you to use camelCase, so I don't see why you need any standards for using snake_case instead. 
"Async / non-blocking I/O" has nothing to do with multithreading. Here's how it works: when you create a HTTP server, you need to execute the following system calls: 1. create a HTTP server socket, bind it to a port and host and then start listening. From now on, HTTP clients trying to connect will be queued 2. accept connections on the HTTP server socket. If there are no client in the queue, this call will block. If there is at least one client, it will unqueue the first and create a dedicated HTTP client socket for it 3. read data from the HTTP client socket. If the client doesn't send anything, this call will block. If there is data, then you can parse it and create a representation of a HTTP request that your application will understand. Then you call your application with the HTTP request and receive a HTTP response from it. Anything inside the application will be blocking / synchronous 4. write data to the HTTP client socket (that means convert the response representation to text) 5. close the HTTP client socket, and start again at step 2 The above description is a synchronous, blocking I/O HTTP server. It can handle a 100 simultaneous client connections, above that and the queue becomes full and you get errors. in order to manage more than that (say concurrently 10K clients, also known as the C10K problem) you can: 1. handle things from step 3 in a new process / thread, like apache does. The issue with that is that you can't truely handle concurrently an infinite number of process / threads. 2. realise that the only issue with the above is that we're spending a lot of time waiting. So rethinking our system to make use of this waiting time can fix our issue Servers like nginx, NodeJs, Python WSGI, Java, Ruby on Rail's server and ReactPHP opted for the second solution, which looks like this: 1. create a HTTP server socket, bind it to a port and host and then start listening. From now on, HTTP clients trying to connect will be queued 2. add this HTTP server socket in a collection of socket to watch 3. call poll with this collection of sockets. This call will block until one of the sockets is ready, which can be either the HTTP server socket receiving a new client, or a HTTP client socket receiving data. 4. if it is a HTTP server socket receiving a new client, call accept and add the resulting HTTP client socket to the collection of sockets (go back to step 3) 5. if it is a HTTP client socjet receiving data, call read, make a Request, call the application (again blocking / sychronous), get a response, write the response to the HTTP client socket, close the socket and remove the socket from the collection (go back to step 3) It might not seem like much, but that's actually how all MMORPG, databases and even Graphical User Interface work. They call those incoming client connection and incoming data "events", and they treat it in a loop. Hence the name Event Loop, if you wondered what that was. If you're more the "learning by coding" type and want to learn more, have a look at: https://gnugat.github.io/2016/04/27/event-driven-architecture.html
I usually ask candidates to show me code they've done before, without specifying what traits I'm looking for. Ideally something small they did and published on GitHub.
It has absolutely nothing to do with anyone's colour of skin. My main contacts for outsourcing are also in Asia, Vietnam to be specific one of whom I've become good friends with and visited a few times, they don't produce this absolute dribble coming out of India and they take great pride in what they produce. It's well known that India's culture of management is king pushes people into the industry that they have no interest in being there and in case, don't care about the quality of whats produced as long as it gets them to management position. People have given him feedback about how bad this code is (on the other subredits hes spammed with this crap as well) and he has ignored all of it and continues to spam it. We all produce bad code but to ignore advice on how to fix it because you can't be arsed speaks volumes
&gt; Lets assume I'm doing unit tests. Do I test that make receives the expected arguments? Nope. I'm assuming we're testing "performAction" and not your validator library, correct? I'll proceed using this assumption. &gt; Do I only test that an exception is thrown if the validator fails? Yes, you can feed performAction() bad input, and make sure it fails. An exception (or returning an error object, or whatever you use) would be "output" here in the context of my previous remarks. I'd probably refactor the validator rules as their own object, however, especially if you use the same $name format in multiple places. This way you can test the validated format as its own unit, and not test this in detail for every action that uses the format. &gt; Do I test that I can copy and paste my array correctly from my function? Not sure what you mean. &gt; My thoughts as of right now are, functional tests should only test that invalid data results in an InvalidArgumentException being throw. Then have functional tests that test the different data and their rules. Well this action only validates data and does nothing else, so I seem to agree with what you say (with the note that, again, I'd probably refactor my reusable input formats as their own code, for reuse and testing). If performAction() was doing something, say emailing a user, I'd probably test it by passing a *reusable* mock for the mailer, not something I've constructed ad-hoc, and then query the mailer if an email of a specific type was sent. The difference here is that I'm not checking which method of the mailer is being called (so no need for "shouldExpectCall" rules and so on), and also this mock mailer is *not made just for the test*, it's provided by the original mailer library, and reusable across tests.
Yeah, but I think you'd have a more intelligent definition of "failed" than is discussed here. If I wrote something "small" and you reviewed it, I wouldn't expect you'd get upset that it wasn't "complex", as per the original post.
&gt; not implying it was the owner of the repository You totally are.
Coming from you.. sure.
I agree with everything you say about not spamming the sub-reddit with bad code and ignoring feedback from other developers. The only thing I don't agree with is your generalisation that just because the developer is from India it can be assumed they are likely to produce bad code. Your experiences are real, and should inform your choices. Unfortunately, that doesn't make your classification of India developers factually correct. That's all I'm saying. :)
I definitely agree that the docbloc fixes the issue. Interesting tho that when you replace this: public static function newJohn(){ $c = static::newInstance(); $c-&gt;name = "John"; return $c; } for public static function newJohn(){ $c = new static(); $c-&gt;name = "John"; return $c; } It does recognize it correctly without further documentation.
Ashley Maddison was basically a joe job on a large number of Joes.
That breaks the chain. Now you have a static() declaration in the method you're calling. Your IDE does have all the information needed to make sense out of it, which it does not in your first example. It's only when you call another method from the parent class that the IDE fails, due to the method being part of the parent scope.
&gt; You should be really thinking a bit more about what you are saying. We don't use frameworks to learn PHP, like we don't use Macbeth, or the King James Bible to learn English ... Macbeth is beautifully written, the KJB informs modern English in many ways, but both of them are absolutely and utterly useless to someone who is *blind* to English. Someone who is blind to the basics of PHP, or web development in general, cannot reasonably be expected to understand the principles the framework uses to provide functionality. Using a (monolithic) framework is a trade-off, but you are not qualified to make the decision to use any framework until you understand exactly what you are getting, and what you are loosing, the details of the trade-off. &gt; productive from the beginning Learning *is* productive; You don't have to be writing code to be making progress ... less still should you be writing, or worse, deploying code you don't understand in the name of progress ... that isn't progress at all.
It's because you used `sleep(5)` here, which isn't non-blocking but blocking. You need to set a timer with a callback end end the request there in React. With Amp (and Aerys) you can use coroutines and program like if it was synchronous code: $response-&gt;setStatus(200); $response-&gt;stream("First few bytes ... "); yield new Pause(5000); $response-&gt;end("Done.");
There's more to the world than the top result. For me it's the 5th link currently. Not bad considering the first commit of this project was in 30 Jan. It will probably go up as it gains traction (i.e. links of articles pointing to it).
&gt; The whole concept of asynchronous non-blocking still requires execution to be on a single thread, since it's loop based. Just want to point out this is half true. Yes, all userland code in an event loop based system runs in the main loop, but the non-blocking work is often dispatched to worker threads. A lot of people don't realize this.
&gt; amazing that it runs faster than node.js I kinda doubt this. I'm guessing they compared multiple kraken workers to a single node.js process. No way to know since the benchmark details are not available.
&gt; How can I provide a reproduce script for non-deterministic behaviour? Write a script that looks deterministic but behaves differently when you run it several times.
try here: https://www.youtube.com/feed/history
Tell that the guys who made No Mans Sky.
This is indeed The Great Struggle when it comes to writing tests. The more details you cover, the more confidence you have that your code works as intended, but the more brittle and rigid the tests become.
It looks like this library is a bit more convenient than purl since it uses dedicated methods rather than a generic setter e.g. ```$url-&gt;withScheme('https')``` vs. ```$url-&gt;set('scheme', 'https')```. Anything that saves me typing and exposes the API is nice.
PSR-2 forces camelCase on method names. `method_names,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel,lower_under,camel,camel,camel,camel,camel,camel,camel,camel,camel,camel` 
2016, the year in which your package manager installs your package manager. Well, why not, let's face it, the way NPM works is not optimal. Competition is always a good thing. Even though, this would be better placed in /r/javascript
&gt; It's hard to say if it's him There is literally nobody else on the planet who could give enough fucks to boost the project's stats let alone *frame him* for boosting the project's stats, especially *after* he's *already* been incriminated for such malpractice. Occam's Razor.
Looks good. A feature that would be nice to have is an optional query parameter. It would allow you to replace if ($request-&gt;query-&gt;has('foo')) { $url-&gt;withQueryParameter('foo', $request-&gt;query-&gt;get('foo')); } if ($request-&gt;query-&gt;has('bar')) { $url-&gt;withQueryParameter('bar', $request-&gt;query-&gt;get('bar')); } with $url -&gt;withOptionalQueryParameter('foo', $request-&gt;query-&gt;get('foo')) -&gt;withOptionalQueryParameter('bar', $request-&gt;query-&gt;get('bar')); Also, what's the deal with all the postcardware/MIT dual licensing lately? MIT specifically grants a license without restriction while postcardware grants a license with restriction. Even though it's a nice package I wouldn't use it on any corporate project with the ambiguity and inability to prove you have a valid license. (How do you prove you sent someone a postcard?)
How simple? https://github.com/domcode/rafflers/tree/master/ramondelafuente-php-array-insanity
Some people may take stars into account. But the fact is that GitHub has a 'trending' system and a quick uptick in stargazer count will put you on that list and in front of many users' eyes.
I disagree - if you had the intention of building and testing a GitHub spam account platform then PHPixie would be the obvious candidate for a trial run. Don't get me wrong - I don't trust him at all, as he clearly gives zero fucks about the whole thing. I just wouldn't bet my life savings on it (like I would with the first reports).
Spammy spam spam.
every single post you made is for that website of yours, which is pretty terrible. SPAM ALL THE WAY ....
I'd rather trust stories from people who actually tried rather than guesses from people who didn't, as arguments from authorities don't impress me if they're not backed up with actual proof. I guess the point I was trying to make was: believe in your dream, don't let anyone tell you it's impossible because you won't know unless you actually try.
If there is a non-deterministic reproduce case in PHP, there also is a deterministic reproduce case, you just have to track the exact circumstances causing it down. In any case, Nikita is absolutely right here.
Your comparison is flawed. First of all you have to distinguish between learning for fun and learning while already writing live code. The first is trivial and of course here you can stick to vanilla PHP stuff. With the latter the exact opposite of what you both are saying is actually true. Those developers tend to early on deploy things they don't know about, and you can't. It is 2016, you both are kind of stuck in 2001-2005 thinking, where this would indeed have been true. But nowaways every day a lot changes, you can't possibly keep up with all the issues, security holes and alike arising on ALL fronts of the rather complex system these days. So breaking it down to manageable things must be the goal. Also, you can't take care of the whole thing all the time, only as a collective this is possible, thus using a framework. So everything you said is exactly the opposite of the truth...
Yes, with *functions* you can do it all right. Or even with selected language constructs (1 == 1) ? print "one" : print "two"; while for the multiple statements I doubt there is a way to stack them like that. Besides, I think I'd drown a person who would wrote it in the project I am working on.
Exactly, I saw them listed in the daily trending repos email from GitHub a few weeks back, which no doubt provides a great deal of visibility. I just laughed when I saw how obviously fake all their new 'stars' were.
I recommend you edit.exe or this older version of eclipse with PDT + the incredible broken SVN adapter.
I should not tell this, don't use it in anything serious, but for the lolz, [eval](http://php.net/manual/fr/function.eval.php) ? If any newbie reads this, DON'T EVER USE `eval`. EVER.
I don't get why you want to use a shorthand for something that does more than one thing. I don't like the shorthand that much, but multiple actions in a shorthand seems counter productive to me. It is harder to read than regular if-else in order to save bytes for the keyword else.
more than 1000 people think sublime text editor is the best PHP IDE. I think its because you can write code, have editing features, debugging ability - its an IDE 
good try for sharing knowledge to other people for best struggle for the best way
Increasing the pool is exactly what I'm in the process of doing while I work out a better solution. Ultimately I have determined that the only way to really solve this will be to have unique versions that the different company's phones hit, so I can identify which company it came from and track things that way. I appreciate the input!
I like this idea. It doesn't solve my exact issue at hand since there are 400 different companies operating independently yet in a way that the script can't know who is who because the current environment doesn't support it (which is the thing I'm ultimately going to have to change to really solve this problem), but specifically picking the least recently chosen one is smart. Thanks.
It is close to be really random :) &lt;?php $counter = []; $numbers = [701, 702, 703, 704, 705, 706, 707, 708, 709]; for($i = 0; $i &lt; 1000000; $i++) { shuffle($numbers); $random = $numbers[array_rand($numbers)]; if (! isset($counter[$random])) { $counter[$random] = 0; } $counter[$random]++; } var_dump($counter); array(9) { [701]=&gt; int(111219) [708]=&gt; int(111094) [702]=&gt; int(111529) [703]=&gt; int(111530) [709]=&gt; int(111243) [707]=&gt; int(110704) [704]=&gt; int(111279) [706]=&gt; int(110709) [705]=&gt; int(110693) }
If having those IDs don't let random people access anything, then it doesn't matter. `random_bytes` uses `/dev/urandom` if it's available, and is almost as cryptographically secure as you can get.
So you don't want random. The problem is common for "random" play in music players. You don't want the same song to play twice close to each other. Neither do you want to shuffle once and then repeat the shuffle. There are lots of solutions to this but basically they all boil down to a list of items the randomizer can pick from and an exclusion/wait list for items that have recently been picked. A very simple form of this is an array that you select a random item from BUT only the section. Say you have ten element 0 1 2 3 4 5 6 7 8 9 Now you do a rand(0, 4), this gives you 3, you shift 3 out and push it on the end. 0 1 2 4 5 6 7 8 9 3 The next rand(0, 4) Cannot find the same song again. In fact, it can't play until a couple more songs have played and then it might or might not be picked up. With each iteration the list moves and is randomized. There are a lot of variations on this but in your case where you want to randomly distribute something but make sure the same destination is not picked in quick succession, this is the approach. If you did this in a database, update a date field when an item is picked and order the select to fill the array by date, limit to half off the list and voila same result.
You are right but If you base your project file on a single root directory you use atom or sublime the same as any IDE. 
&gt; PHP stands for “Personal Home Page.” Like many things in PHP, I believe this changed after it was clear it was not well thought out. &gt; PHP originally stood for Personal Home Page, but it now stands for the recursive acronym PHP: Hypertext Preprocessor. ([wikipedia](https://en.wikipedia.org/wiki/PHP))
For simple stuff ternary is great: &lt;?php echo (count($products) === 1) ? 'product' : 'products' ?&gt; Or: $trueOrNull = ($var) ?: null; When doing anything that might confuse future-you or collegues, please use an if/else. When there are multiple cases (if/elsif/elseif/else), use a case/switch
Well-written, and honest. PHP is a flawed but powerful language.
You really don't. Sublime Text describes itself as a text editor on its own website. Nobody sane considers notepad++ to be an IDE any more than notepad.exe is an IDE.
Notepad++, vista... Xampp... 2016... what?
&gt; On the gripping hand Hah, never thought I'd see a reference to *A Mote in God's Eye* in this subreddit.
I've occasionally used the number of stars, issues, and contributors to get an at-a-glance impression of whether a particular library is supported. I've found it to be a helpful heuristic.
dude is trying to get hit.. 
So simple that a beginner like me can easily do it and understand it.
So we found 324 insane visitors who answered the question "what is the best IDE for PHP development?" - notepad++. :)
That is from a survey they used as basis for the PSR, but if you read the actual PSR especially [section 4: classes, properties and methods](http://www.php-fig.org/psr/psr-2/#4-classes-properties-and-methods) you will notice that it doesn't say anything about camelCase. I wouldn't consider the survey and it's result as binding parts of the specification. If you go through the list of fixers in php-cs-fixer you will also notice that none refers to camel or snake case. It is commonly used, but nothing hints at it being part of the specification.
Hell no. Pay me and I'll write in BASIC if that's what you want. It's just another tool to get the job done. 
I'm using those IDs to allow cohesion between multiple services in a logging system. So it would be better to have unicity, but not required. You confirm what I was thinking. Thanks. I new /dev/urandom is directly used by random_bytes, but the same collegue is "doubting" its actual cryptographical security...
I occasionally get into arguments where I find myself having to defend PHP, and I usually don't bring up the features in PHP7. Doing so can work against your you, because you can't win people over with the position that PHP only very recently started to suck less. "Hey, we have a type system now!" "Yeah, too bad you're 30 years late to the party."
I wouldn't say it's just as powerful, it is powerful though, and robust. But it's not going to be faster than C, or handle neural nets with aplomb. 
I can understand that. But the author brings up Hack. In the end part about recent advancements it'd have been a good place for PHP 7. Though now I'm imagining slack uses hack
oh wordpress... thats simple, ask how big his functions.php gets, if its less than 1mill lines of code then hes a noob
That's true. While he was mentioning the speed improvements in Hack, I was thinking, "Stock PHP7 is pretty fast too." I know my sites were 3x faster after the upgrade.
PHP #1!
I didn't see a separate process for my interpreter until I was already a man. And by then, it was nothing but *blinding*!
PHP is an interpreted language built upon C. Since it relies on C, it's inherently slower than C. This is a really lazy explanation though. 
In the case of C, it's because there's no object overhead in the form of OO programming, and C compiles to machine code which will almost always run faster than an interpreter language. However PHP is easier to learn and for what it's used for its quick to develop with so the cost-benefit of PHP is that it's quicker to make a program that does something and works on many systems. Because handling http requests is built in it does handle that better than raw Java or C. And PHP7 tests well VS other language's frameworks that are meant to handle the same sort of problems so you do have a point there. While PHP has libraries or CMS's that support caching, it is possible to overwhelm a PHP engine with simultaneous HTTP requests. (that's not unique to PHP though) Because of how PHP is usually ran, with an HTTP request triggering a script to run, each request triggers a script. So 30,000 requests can equate to 30,000 scripts of identical data consuming ram and cpu cycles. Statelessness and Caching can help with this problem but the best solution would be to intercept these requests and send static content from a constantly running program that doesn't instantiate with each request -- which is what Apache's caching mod_caching does. I think the worst thing PHP does is making deleting objects difficult. I wish it had an option for a manual method of erasing vars or parts of vars. A script in PHP will grow to consume its entire aloted RAM space before trashing unused data. Neural Nets can actually be pretty simple - they're an elegant algorithm that gains power through iterations. Where PHP struggles with NNs and say science or financial calculations is that the Floats have a tangible machine precision problem. There are libraries that help but it's just not like Cobalt (very strong in science fields for it's machine percision). Compared to Cobalt PHP is very young and it's support for objects makes it pretty modern. I guess that's another thing that bothers me with PHP -- virtually everything is an object. You have to dig deep to make sense of any variable typing. It barely ever matters it just impacts how resources are used.
My examples still show unit tests. 
https://mobile.twitter.com/SlackHQ/status/426469205005705217
Just the messaging queue. The server side is a lot more than just the messaging queue.
&gt; is C inherently faster than PHP C is faster than PHP for the same exact reason machine code or binary is faster than C. They are built on top of each other specifically because of your next question &gt;some are just custom made to handle certain jobs better than others Sure, you could run a web page straight from binary. But that's really fucking hard, like impossible hard. So we use a language to compile into binary so we don't have to manually write out simple functions in a base 2 number for every single thing. So now we are using something like C, which is great because it can communicate with the hardware easily, like the server itself and the OS. But, now you're going to have to custom write a way from C to talk to webservers, but in a standardized way, so you'll have to manually write how an http connection is established, entire driver libraries for a simple database connection, etc. So now what? You have this super fast language that can interact with the OS and hardware, but it takes too long to make websites. Why not write another specialized language that can do common things that take too long to write out each time in C, so instead of a giant unstandardized mess of code just to establish a connection with a webserver like apache and deal with things like uploading files, we have PHP that uses C to run on the server in binary. You can do anything PHP can do in C, but you can't do everything C can do in PHP. Well, you could, but you would have to personally compile your own PHP extension, which some people do to add more low-level functionality. So yes, C will always be faster than PHP if you code both languages to do the same thing in the most ideal possible way for each language individually. For the same reason vanilla JS will always be faster than JQuery at the same final outcomes since it needs everything about JS and then itself, PHP needs everything about C and then itself. 
&gt;but the same collegue is "doubting" its actual cryptographical security... /dev/urandom is literally the most random possible source you can get without dedicated hardware which is certainly not needed for your use-case. Your colleague doesn't know what they are talking about and should be ignored.
Magento feels less like programming and more like copying/pasting and modifying configurations. 
Fair enough.
Who cares about the number of likes a project gets seriously?
But don't forget that Slack may use PHP to another level. They may require asynchronous calls, more type safety or some structures that you can only find in Hack. PHP is getting better at that at a number of things via extensions or user-land libraries, but that might be a reason of the why.
Yeah with PHP7 and pthreads it easily beats node.
English also has a vast and inconsistent vocabulary that is a mish-mash of words borrowed and mangled from other languages, just like PHP! English doesn't have all the odd conjugation rules or inflections but it has a gigantic pool of _words_. PHP likewise (until recently) is pretty mechanically shallow, but just look at all those _functions_ man.