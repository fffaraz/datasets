Gosh guys PHP is so dead!
You can't abstract input validation as what is valid input depends on you domain, not on some framework. Also the term "sanitization" is completely the wrong mental model to have for this. Input can't be "sanitized". It's not dirty. It's valid or not valid. If it's not valid, you reject it. If it's valid, there's nothing to sanitize.
Okay, it was a little more subtle than I remembered. It was also much more recently than I remembered. [Here's the blog post](https://blog.laravel.com/unique-rule-sql-injection-warning). Either way, it is a great example of where one would assume the framework is covering their ass, but it actually isn't. The documentation didn't really say anything on the topic either.
Did anyone unit test that counter? Can we trust the result?
100k subs, feels like 10
PHP's problem was never quantity. But the other "q" thing. What was it... Anyway.
quivers?
quibbles?
Ah, I remember ‚Äî QUITTERS! We have no room for quitters around here üòÅ
At work we had our GIT repos not letting us login and they thought it was an error with a couple people, turns out everyone was having the error but they just kept trying again next week =P
Something along the lines of if ($\_GET\["71740e549bf23d7ecfdc07d589218c05"\] == "61c66d185aa6482d0024f5f5b3187f19") { .. TRUNCATE TABLES .. } This kid thought I wouldn't notice and tried to blackmail us..
I did that with a DELETE command. I died inside. Thankfully client had backed up before giving me access. This was in my early months so knock on wood hasn't happened since..
Quick critique: Do not sanitize inputs. Validate them. Sanitize outputs. That is, if you're expecting a birthday, and you get "o'Malley" instead, don't turn that into "o\\'Malley"; start gathering error messages to show to your users. If your error message includes user input, *then* sanitize that *as you're generating output*. I.e., "`Error in field birthday: "&amp;lt;script&amp;rt;alert(&amp;apos;foo&amp;apos;);&amp;lt;/script&amp;lt;" is not a valid date.`". When you sanitize as you're generating the output, you know exactly what you should be sanitizing for... I.e., the apostrophes shouldn't be escaped by a backslash, they should be changed to their HTML entities, etc. This also means that you won't un-escape things in dangerous ways... I.e., if you convert the HTML entities before stuffing the data into the database, you'll also be parsing them back out afterwards. Where if things are never sanitized until they're being rendered for that particular output, you're *never* de-sanitizing things. Keep in mind: Your database is only one output. The browser is a different output, as are any APIs you might interact with. Your database is also an input. Validate it just like you'd validate things that a user is sending directly over HTTP.
QUALIFIED developers don't quit... They just find a new job for more money.
It's written in Python, so no.
And that was a serious reply... While modern cars have great safety features, just like modern frameworks have great sanitation that doesn't mean the burden is lifted off you, the developer or passenger, to protect yourself. Anyone who says differently is...just a huge security risk.
It‚Äôs not about excusing anything, it‚Äôs about not being a shitty developer.
Let me spell it for you again: Laravel's DB layer takes input labelled as "column" and allows SQL injection in it. Developers are not supposed to open and read the entire implementation of an API with a misleading interface. It's the responsibility of the API developer to do one of these: 1. Implement the interface according to the expectations they set, or... 2. Alter the API, so it sets the right expectations. Designing misleading APIs is what a "shitty developer" does. Using the API as documented and presented doesn't make you a "shitty developer".
Ahh so it‚Äôs (was?) on unique specifically. The bit at the end is reasonable: &gt; It may be possible for the framework to prevent SQL injection even when developers accidentally allow user controlled input to be passed to this rule. We will explore this thoroughly in an upcoming Laravel release.
If you were doing and About Me site, or let's say, a small dentist office ( about us, map, contact form) what would you recommend?
Some thoughts: I think something like this is already is built into PHPStorm: https://www.jetbrains.com/help/phpstorm/configuring-synchronization-with-a-remote-host.html From experience, when I read "vagrant" and "slow" in the same paragraph it's usually because the developer didn't turn on NFS: https://www.vagrantup.com/docs/synced-folders/nfs.html The vagrant docs say that NFS doesn't work in Windows, but that's not really true, it works with bindfs: https://github.com/gael-ian/vagrant-bindfs The linked page focuses on `npm`. My experience is that, before I upgraded to a SSD hard drive (I had a Hybrid SSD before) npm sucked. After I upgraded, `npm` stopped sucking (`composer`, on the other hand, did not suck, and I still don't know why...)
&gt; the ones I found seem to be inactive and/or use other strategies to make this work I wouldn't dare discourage you from giving it a go, but that line is a clue. I guess I'm wondering what problem you are solving.
 $date = new DateTime('2019-06-19'); print $date-&gt;format('D'); // Wed I would hope all systems are using 64 bit numbers by 2038
 $date = DateTime::createFromFormat('Y-m-d', '2019-06-19'); $date-&gt;format('l');
&gt;epoch will soon overflow Are you talking about the 2038 problem?
yes... I know I know. I just would rather know a better solution then something that will break in 20 years :-)
&gt; Your only limitation for fuckup is incompetence and imagination. /thread
If it is a simple brochure website where the only programmable content is a contact form, I would use a static HTML site and probably a single PHP script incorporating form, validation, and mailer libraries.
Is it PHP running on a system that is vulnerable to that issue and assuming that it will still be running and not updated for the next 20 years?
I tried to outline the problem in the readme. But that clue is certainly valid.
(Have you looked at this one?](https://old.babeljs.io/php/#?evaluate=true&amp;lineWrap=false&amp;code_lz=DwfgDgFmBQAkBGBDATgAgLyoNrVagRAGYD2x-GAfAUsvgDS4EAe56VWAugxwNzTQBTAMYRiqBCh5A) Source: https://gitlab.com/kornelski/babel-preset-php
PHP, as well as any system it runs on, will most certainly experience breaking changes that will prevent your app from running between now and 2038. You should focus on actually developing your app or library instead of chasing things like this.
No. Thx, a lot!
Don't pay attention... if you're a maker, I guess you do that to keep up to date with development technique and mostly do those things for you, just like me with PHPTree. I'm trying to push the limit of what I know every time I have a new idea in mind. What other people think... I don't really care unless it's said with respect and politeness.
I've had the same thought (wouldn't it be great if this code magically worked in the Javascript runtime). But it's really good to be fluent in more than one language. Let Javascript do what Javascript does well, and let PHP do what PHP does well.
Ah, I see now. I do a LOT of legacy PHP refactors and updates, so I think I get your angle. I made my team learn Vue, and I think your goal is to skip that learning curve when an old project needs some fresh skin and front end functionality and labor/time resources are prohibitively constrained. Fun times; probably worth having in your portfolio. Could see some use before web assembly catches up.
The correct term is "Quibblies". &lt;?php if ($str === 'quibbles') { throw new WorldsWorstException("No. Just no."); } :D
Hehe, that "fluent in js"-thing is definitely coming while building that compiler =)
Fair point about PhpStorm providing something similar. This is fine if you use PhpStorm anyway, otherwise it's not :). I think NFS requires the UID/GID to match on both sides? If so, that's *very* annoying. Strange that switching hard drive type fixed things for you. I have been on an SSD for a few years now and never noticed a difference.
No problem. The demo seems broken now. It wasn't the last time I looked. I hope someone fixes it. It was quite good.
Maybe because no one can post questions with descriptions here...
More like.. username: admin, password: your own password, welcome inside, admin.
First, once you have defined your domain logic, you can abstract input validation a great deal using your framework as a very high-level enforcer of specific rules rather than implementing every single rule yourself. Consider reading Validate::isValid(, ['user_email' =&gt; 'email|required|etc|oetc|unique|...']) vs ( !empty() &amp;&amp; is_string() &amp;&amp; stripos(, '@') &amp;&amp; checkEtc() &amp;&amp; checkOtherEtc() &amp;&amp; checkUnique() &amp;&amp; ... ) Second, input can absolutely be sanitized after its submission, and it is often (most of the time?) quite dirty before transformation is applied to it, all the while being sufficiently valid not to be worth rejecting. Consider email addresses (app accepts "Mr Scott" &lt;mr.scott@foo.bar&gt; but stores mr.scott@foo.bar), phone numbers (app accepts +33xxx, 0033xxx and +33(0)xxx but stores everything under the international +33xxx format), postal addresses (app accepts "CITY, postcode", "CITY postcode" and "CITY - postcode" but extracts subfields and stores them after making them all-capps, trimming spaces and converting special chars), titles (app accepts Mr, Mister and M but stores it as Mr), etc. etc. Each of those sanitization operation helps your teams and your users down the line. If in doubt, you can always show the transformed data to your users so that they can confirm it (that's what Amazon, eBay, etc. all do with postal addresses), it's still better than forcing your users to conform to your app's or your domain's quirks which only internal staff should be even aware of.
&gt; ConsoleArtistGuild What's with this interface name?
eval() is not directly bad by itself, but it is not needed, and many times either abused by the original developer, or abused by hackers. In 15 years of PHP development I haven't needed it once, and I've found it various times injected in hacked websites. After disabling eval() and assert(), and making server files read only, all those hacks disappeared.
Have you looked at all at WebAssembly? I would think that would be a more practical/useful long term goal.
great idea
I really can't imagine anyone cares.
To be honest, for such things i'll tend to WordPress. Yes, its codebase is extreme terribly (mixed OOP w/ functional programming, global variables, bad design decisions et cetera) - but it "Just works" (if you avoid too much 3rd-party plugins). For more complex tasks or a more 'professional' work, dont touch WordPress.
Laravel is a good framework for beginners, because you do not have to learn OOP design patterns (like repository, Adapters and so on), dependency injection, single responsibility principle and more. Laravel makes you feel like you're creating a professional codebase, but as the tasks become more complex, you reach your limits (or you're forced to use questionable solutions). Getting into Symfony is more complex, but as every project is known to be getting more and more complex, Symfony is, in my view, the right choice, and above all, the more professional.
I see, so it's like unison. Seems worth checking out, thanks.
&gt;Let me spell it for you again: Laravel's DB layer takes input labelled as "column" and allows SQL injection in it. Er, [so does Doctrine](https://www.doctrine-project.org/projects/doctrine-dbal/en/2.9/reference/security.html) and most other ORMs. You don't seem to understand what the actual issue was wit the `ignore()` method of Laravel's validation rule (note that that's where the potential vulnerability lay, not in the DB layer). &gt;Using the API as documented and presented doesn't make you a "shitty developer". If you used the validation rule as documented, it wasn't possible to exploit this, it was only using it in a way that didn't make a huge amount of sense that led to it being vulnerable. Putting a big warning about how the function worked in the documentation was a reasonable step going forward.
Can I ask what the use case is? I haven't noticed a major speed impact (in human perception terms) outside of profiling.
You can always check for 64-bit support during install or runtime.
Why would you want to do that? You're depending too much on the clients, instead of the server? Or would you run serverside js? Wouldn't run js slower than php?
Yes, lol. Bad policy.
dbeaver is great but it so slow =(
and I know HeidiSQL is the best but only available on windows
Very nice work! I had a similar idea also the other way. I had a repo at [Rector](https://github.com/rectorphp/) project for this, but then I refocused only on PHP for now. My idea was basically using nikic/php-parser to parse PHP and custom Javascript printer does the job. It seems you've picked the same approach with https://github.com/lechimp-p/php2js/blob/master/src/JS/AST/Printer.php - right? :) - *What do you think about the general idea and the rationale? Are they sound?* - Yes :) it's a matter of business, some companies and programmer prefer to use one language for server and client side. Javascript is way to go and rewrite PHP to JS manually would be too expensive. - *What are your thoughts on using such a tool, for more or less professional projects? Would you use it?* - If Javascript would improve our work performance, hiring rate, increase ecosystem value - yes! - *If you are not convinced that this is a good idea: What would it need to convince you?* - I think proof of concept on commercial project makes this happen. You can inspire at [How we Migrated 54 357-lines Application from Nette to Symfony in 2 People under 80 Hours](https://pehapkari.cz/blog/2019/04/20/how-we-migrated-54-357-lines-of-code-nette-to-symfony-in-2-people-under-80-hours/). Until then, people didn't believe in instant migrations of legacy projets in days. - *How do you feel about contributing to the development of such a tool? This won't work as a one-man-show.* - I've been into AST last 2 years, contributing to php-parser with most of PHP 7.4 features, so if you need some mentoring in that area, I'm happy to code-review. Just ping me at PR. - *Any other questions, remarks, comments?* - Great job man, this is the future. It will take time, like AI, but it really is.
Yeah, there's a dev support problem on SequalPro. Official releases are crash prone on the version of macOS that shipped last fall. The nightlies don't crash here, but "nightly" is a bit generous. New builds are infrequent and lack the polish that you would expect for an official release - but at least it doesn't crash when you close a tab.
&gt; 3. Excessive self-promotion &gt; &gt;It is okay to post links to your own content, but be sure that this is not primarily what you are doing. Engage the PHP community on a larger scale by commenting on others' posts, linking to content made by others, etc. If your purpose in using [/r/PHP](https://www.reddit.com/r/PHP) is primarily to draw attention to your own work, we're not interested.
Garbage.
A lot of programmers try to break-through the framework limitations and forget that frameworks dont run on magic. Say, you are using your framework's ORM, but every now and then you wish to create a raw SQL query to take advantage of your RDBMS of choice. A lot of programmers shove user input into the raw query, which, admittedly is not sanitized for obvious reason. But since they're used to their framework sanitizing the input, they dont' even blink. Until the shit hits the fan.
&gt;However, criminal? I've been stolen from a certain someone who gave me permission to take it back, which I did, and then I'm getting criminal charges over it? I would like to understand your logic here. In the US, under the Computer Fraud and Abuse Act, _any_ unauthorised access to a computer system is a criminal offence. That includes using a password that you once had legitimately, but are no longer supposed to have. It's an extremely broad act. If the developer had legitimate access to the server, there would be no need to have this dodgy backdoor, they could just disable or remove the site with their normal access. The only reason for this code to exist is that they're handing the code over to run on a server they don't have access to, in which case, in the eyes of the law it makes no difference whether the client is or isn't allowed to use the code, running arbitrary commands on the server that you're not supposed to be able to is a criminal offence. The CFAA is a ridiculously broad act and a lot of developers will breach it at some point in the ordinary course of business, that doesn't make what the developer did any less of an offence.
So 99,999 people looking for help and 1 guy spamming this isn't /r/PHPhelp?
Quickness
Will always suggest to use carbon to work with dates https://carbon.nesbot.com/
I've been using SequelPro for a long time, switched to Table Plus a little month ago, so far it seems faster and the UI is a better experience for me.
To clarify, it wasn't a vulnerability in the database layer. It was a specific method, `ignore()`, on the `unique` rule in Laravel's validation library. By default you pass it an ID and it will ignore that enrity when checking for uniqueness, for example, when allowing a user to update their profile and you don't want it to fail validation because they haven't changed their email, so it already exists in the database. The `ignore()` method accepts an optional second parameter that you can use if your ID field isn't `id`. The vulnerability occurs if you allow a user to provide the column to ignore, as like Doctrine and most other ORMs, Laravel's Eloquent won't sanitise column names. There's not really any good reason that you _should_ let a user specify an arbitrary column to use as the primary key when validating their own input. If for some reason (I can't think of one) you did need this, it would be best to provide a whitelist of allowed column names that the user could specify, not just allow them to enter absolutely anything as a column name, as even if you did sanitise it, they could still easily break the query by entering a non-existent column.
[Chronos](https://github.com/cakephp/chronos/) is better IMO.
Someone sent me a link to an online photo gallery that was password protected. It went something like this: http://site.com/gallery?user=idiot&amp;password=pleasehackme
Looks really nice. I'll bring it to the powers that be and try to convince them to buy it for the team.
You can download the free version and see if it's some thing you like. It's the exact same as the paid, but with these limitations: * Maximum 2 active tabs at a time. * Maximum 2 active connections at a time. * Maximum 2 filters at a time. Read more about it [here.](https://tableplus.io/blog/2018/10/tableplus-free-vs-paid.html) &amp;#x200B; I've been using the free version and the limitations have not really bothered me yet, but i will upgrade in the future to support them.
I'm perhaps a bit too late to this, but I just put together a personal blog so it can be read without any of Medium's popups getting in the way. Syntax highlighting is a bonus considering this is a code-heavy article, too. https://liamhammett.com/a-look-at-phps-isset-N3zx8z7q
Of course Linux isn't affected as it pioneered this approach is the definition of the native support implementation for this. All others (OSX, Windows) require running Linux in a VM and thus the downward spiral starts‚Ä¶
I worked for a guy who would start a query, pass it to page 2 as a GET var, add to it, and then run it.
Hope i get a job soon so we can both celebrate.
Probably for the same reason your post is lacking any information.
Nope, good policy. I sub for posts only about PHP, features, implementations, projects, blogs etc. Nothing ruins a sub more than a load of beginner questions.
For my very first framework, I went with yii2. It‚Äôs relatively easy if you understand MVC and quite fast. Pretty good for the semi-complex web applications I had built.
You should look at line 26 of your script.
If you build a backdoor into your PHP app you might as well do it properly.
We are talking about someone who built a backdoor into an app they delivered to a client, they might have gone the extra step and gave it root access. Ideally, PHP should only be able to read/write to specific directories like uploads and cache. But if that was the case here then the backdoor could not even delete the code, it could only delete customer data.
probably q3schools
Hello there, Youtube user! Here on reddit, we don't really announce when we are the first person to read a post, because its just stupid and annoying, just like it is on Youtube. Enjoy your time on reddit!
Great response, cheers.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What does GIT stand for?
You‚Äôre not describing sanitization but formatting.
Not sure if there is a consensus, but I do see people doing something like this, in an autoloaded `helpers.php` file. ``` if (!function_exists('foo')) { function foo(): string { return 'bar'; } } ``` Though, I am not sure it leaves much room for the developer to choose which function wins or loads first.
I really like your library. Will absolutely give this a try!
&gt; Write Multiplayer Mini Games Module.
&gt; Write Multiplayer Mini Games Module. https://github.com/TinkeSoftware/CerberusCMS/blob/master/Source/In-Development/PurePHP/Version%20-%204/Build%20-%200.6/Edit%20Number%20-%2010/Cerberus/To-Do.txt#L79 This CMS project looks pretty fun, lol.
Do you want to help write that? I am still writing an emulator module with flash. Nintendo 64, Super Nintendo, etc.. With multiplayer support.
&gt; Er, so does Doctrine and most other ORMs. I don't have particularly high opinion of Doctrine, so that's a bad example. &gt; Even in the best case, where you manage to perfectly sanitise column names for every database supported by the ORM, allowing the user to specify an arbitrary column name means they can break your query by entering a valid but non-existent column, or any column that isn't an ID field. Do I have to explain that allowing a non-existent column to be specified is still a few orders of magnitude better than arbitrary SQL injections. Also an ORM should have a whitelist of valid column names already as they're defined in the entities. But you know, let's fix the damn SQL injections first, I guess. Anyway, on second though anyone using Doctrine or Laravel deserves what's coming for them.
Thanks i didn't knew zip file could work like that. So simply we should not extract file to path specified in zip entries right ? I am not sure how to avoid zip bombs.
no thanks
[removed]
that's either cause: a. I'm just a dumb retard and you've completely bamboozled me with your in depth knowledge of nominations and shearing; or b. wrestling with a pig
You can on old.reddit.com Long live old reddit.
&gt; that's either cause: &gt; a. I'm just a dumb retard and you've completely bamboozled me with your in depth knowledge of nominations and shearing; or &gt; b. wrestling with a pig At this point it can't be any more clear to anyone reading this thread that it's "a". You kept asking for "substance" in the conversation", now you're squirming like a fish out of water trying to avoid that substance.
congratulations, you guessed right, it was B. To anyone reading this thread 1. wtf is wrong with you - it's bad enough being in it, and 2. I have been totally and completely pwned by this absolute genius here, it is a sad day that I just did not manage to learn anything at all and have squandered such an opportunity to soak up what wisdom I could from someone so learned as this guy. On the bright side I do get to carry the knowledge with me forever that ditching type systems will mean my: &gt;Source code can better resemble pseudo-code rather than bureaucratic mumbo-jumbo Fuck I hate it when my code is bureaucratic, I just wish it was pseudo instead.
[removed]
What the fuck is going on in this repository. &gt; data security $_Module_Administrators_POST_MESSAGE_MEMBER_MESSAGE = $_POST['Module_Administrators_Form_Member_Message']; $DB-&gt;query("INSERT INTO {$_ACCESS_DATABASE_PREFIX}_system_message(system_message_data,system_message_member)VALUES('$_Module_Administrators_POST_MESSAGE_MEMBER_MESSAGE','$_Module_Administrators_POST_MESSAGE_MEMBER_USERNAME')"); Literally pasting incoming post params into SQL queries. &gt; incredibly clean $_Module_BotMonitor_LIST_MEMBER_ID = $_Module_BotMonitor_DB_Query_SELECT_MEMBERS_Fetch_Array['id']; $_Module_BotMonitor_LIST_MEMBER_USERNAME = $_Module_BotMonitor_DB_Query_SELECT_MEMBERS_Fetch_Array['member_username']; $_Module_BotMonitor_LIST_MEMBER_EMAIL_ADDRESS = $_Module_BotMonitor_DB_Query_SELECT_MEMBERS_Fetch_Array['member_email_address']; $_Module_BotMonitor_LIST_MEMBER_JOIN_DATE = $_Module_BotMonitor_DB_Query_SELECT_MEMBERS_Fetch_Array['member_join_date']; $_Module_BotMonitor_LIST_MEMBER_LOGGED = $_Module_BotMonitor_DB_Query_SELECT_MEMBERS_Fetch_Array['member_t_logged']; What purity we have been graced with.
Lmao. Such sarcasm! The whole thing is in early alpha. Not even close to being done yet. It's an ooold project of mine I started working on again. This thing is like 10 years old. I'm bringing it up to date.
That's awesome dude and i mean that sincerely. But if it's an old project and an early alpha why are you touting it so much? It's better for everyone to just describe it as you said to me, an old alpha you want to bring up to speed and what you want help with.
Well that is what I am recruiting for. Are you interested? Join our discord server!
wtf
&gt; Cerberus Content Management System source code is completely handwritten by the author(s) whose names are credited in each release. Approximately 30,000 incredibly clean uhm thats not at all clean.
and all we get is just random links to whatever blogs explaining yet another time how to use standard php functionality -- 'explaining namespaces', or 'explaining autoload'.
Yep good catch, meant self!
You realise that Flash is end of life, right?
What is the deal with the folder versioning system while having git?
I'm sorry, I saw your code the other day when you posted for help. You were having trouble reading it yourself. PHP 7.0 was End of life 6 months ago, and I'm not sure what you mean by JavaScript being "incredibly vulnerable".
The blog spam is becoming a little tedious but very little hits my front page fortunately
lol, I thought you were kidding
We have this thread every three days. How about you master the search function.
If you can explain why that's could be cool :)
Or just scroll down 2 posts. Its not like you have to go to page 2 or something like that :P
There is also project which uses WebAssebbly and Emscripten to compile PHP: https://github.com/oraoto/pib
You should master your own framework at least 1 time in your life.
If responding is boring to you you can just ignore, you save your time and mine for reading that kind of bad community members. I'm asking here to see people experience and feelings about frameworks. Nobody need you to respond "If you search something search on google LEL" thanks captain obvious, next time your wife tells you "What is a good wine ?" You could say "Ask to google or someone who works in a winehouse". Thank for your utility, really appreciate.
Thats just the badest thing a community can have.
And 2 times at most
You have to make a good plan if youre gonna plan legacy!
Your also have to adapt to the current IT workflow. If there is any huge task everybody has to do its made 1 week before the deadline. Not 20 years before.
I'm happy with laravel. However, the thing is that you get good at one fw, you can work with any. As someone with a very bad memory, it's always "I kind of know how I do this but I still need to check the docs". I spouse they are all similar enough that this will be the case for all of them once you get good at one fw. Cheers
There's r/phphelp or something
Anything active and popular will do the job with flying colors. But mostly it depends on the use-case Are you an advanced developer that wants to do their own architecture and their own thing (which usually ends up as a shit) ? - Symfony Are you a developer that's tired of writing boilerplate and just wants to get the job done? - Laravel Are you building a microservice? Lumen / Slim Are you looking to expand your knowledge? Yii, CakePHP, PhalconPHP (this one is interesting as an idea)
Indeed. At the start all that matters is working prototype, not perfect final product. It will only get better then :)
Someone saved "backUserId" as cookie at some point in some process. Good that the admin user ids are always the same and good documented for everybody!
And there is a old wordpress hosted on some customerservers with highload from a importand shop software. They are asking for something to happen. But i dont care after 2 years saying that this should be deleted fast.
The wordpress is already hacked to ground but i think the hacker doesnt know yet what hes got. But the customer doesnt care.
Looking at the router I think you were a bit inconsistent with inversion of control. Your objects should be build with the correct dependencies for the current env, not decide about their correct dependency in the constructor. Also in my opinion it is a bad practice to inject di-containers in other classes. A class should be transparent with their dependencies, defining them as properties. This eases readability for others and yourself as we don't have to search the whole class for what you do with the container. Id also avoid returning arrays with obscure content. $info[0] has a handler and $info[1] some args, but that's only for you to know and everyone else to find out. Info btw is not a very descriptive name for a variable ;) Overall good effort though!
There are a tons of options for xdebug. Im no dev... uhm i am.
Knowing and writing unit tests are something completely different. Most hobby projects have more time for tests. So do you ever worked as non bobbyist?
Profiling with xdebug doesnt get you the real numbers at all. But still xdebug users are forcing everybody to use this tool and nothing else kekedikek.
We share the very same story! Still love and use Laravel, but I‚Äôll choose Symfony whenever a new project comes.
Yes, and the reason is only because it is simple to learn it. Any why it is simple? Because of offers basically nothing; symfony/forms documentation is larger than documentation for entire Laravel.
it's a bad attitude, I agree. But the person was right, there were plenty (overly plenty) of posts about frameworks on this subreddit and they are basically the same in questions and answers. After a while it gets boring! But we should be helpful so I found some posts for you which might help to answer your question [some inspiration](https://www.reddit.com/r/PHP/comments/9m6csh/what_is_the_absolute_worst_and_still_around_today/) [and more](https://www.reddit.com/r/PHP/comments/by9rzj/what_is_your_opinion_on_writing_your_own_php/)
The one that is relevant for your current job. Otherwise try all of them if you're still learning starting from the most popular ones like Symfony, Laravel ([some more from the list](https://www.jetbrains.com/lp/devecosystem-2019/php/)), just don't do codeigniter. It's not really following good practices.
&gt; soon Twenty years
Symfony and Laravel are the most used actually. You should also learn Angular, React and VueJS and how to use them with Symfony and Laravel.
Why are you not using file extensions for php-class files?
I can only speak with work experience of Symfony, Laravel, Magento: Symfony : it‚Äôs incredible, a bit of a learning curve but you can pretty much do anything you want and even incorporate components you want while not using the whole framework. Small gripe I have is that they tend to deprecate tons of things on each release so you need to keep up with the changes aka not ignore the toolbar warnings if you want symfony up to date. Laravel : quite good and packed with features (while symfony is more an ¬´ add things as you go ¬ª ) but I‚Äôm not a fan of the whole middleware approach: after extensive use on very large corporates project I tend to agree with people saying it‚Äôs an anti-pattern. Magento : don‚Äôt make eye contact with it, the xml will burn your brain while Magento will eat your server ram. Too bad big companies ¬´ need ¬ª it for their ecom site, kinda like small ones saying they ¬´ need ¬ª a wordpress and do not use it past the first week. If you need to build an API of any kind, I suggest you dive into api-platform (built around symfony, but it‚Äôs kinda becoming sentient at this point), it‚Äôs the best thing to touch in the past ten years. Literally 15 min of config/entity declaration and you have a fully featured rest+graphql Api with sandbox, documentation, admin interface, cache, etc...
Here are some things that went through my head as I read it. It may come off as harsh in places, but it's not meant to be. &gt; On the one hand, client-side demands new skills and knowledge. Oh, suck it up. You're a developer, it's part of your job to learn. &gt; In both scenarios we will add new layers of complexity to our project. And adding php2js doesn't? &gt; would need to be hold in sync afterwards Alright, that's a good reason. In general, I'm skeptical of this idea. Partly because I don't trust generated code that much^(*), and also because I think that it doesn't really solve the problem. You're still going to have to vet and test the generated code, so how much time are you actually saving? Also, server side and client side are fundamentally different environments. Cookies and sessions aren't really going to translate well. Some code should execute on submit, or even on blur or on keypress. Other code should run on page load, and still other code will replace ajax/fetch calls. How do you deal with that? More generally, because of those differences, I think that's something that shouldn't be trusted to automated tools. I think it's something that really needs to be considered, both on the whole and in individual functions. It may well make sense to rewrite it instead of just translating it. Maybe different algorithms make more sense on the client. Maybe you could take advantage of browser/js features like web workers or websockets. Hell, some code could be replaced entirely by HTML attributes like `required` and `pattern`. * OK, typescript works, but that was specifically designed to transpile to js.
Php being a general purpose programming language means that it can do whatever other languages can (in theory), so if we may compile typescript to js, we might as well do the same with php.
Laravel or Symfony, both are great, just different approaches. You should also look at Lumen and Slim at some point. There are other frameworks, but every one of them is some combination of: outdated, unpopular, terrible code, terrible docs, or just plain dead.
In fact I use laravel but seems locked to their own vision. I m going to try symfony because now can be installed light without the whole things
&gt;vulne Opened some random 'module': [https://github.com/TinkeSoftware/CerberusCMS/blob/master/Source/In-Development/PurePHP/Version%20-%204/Build%20-%200.6/Edit%20Number%20-%2012/Cerberus/Module/Administration/Administrators](https://github.com/TinkeSoftware/CerberusCMS/blob/master/Source/In-Development/PurePHP/Version%20-%204/Build%20-%200.6/Edit%20Number%20-%2012/Cerberus/Module/Administration/Administrators) &amp;#x200B; Nope, this is not clean at all...
&gt; I don't have particularly high opinion of Doctrine, so that's a bad example. Great, presumably you have an example of a DBAL that will always _safely_ sanitise any column name across all major databases and can't be exploited in all the ways you can bypass sanitisation of non-prepared parameters? Or is your suggestion that it's better to always have to manually take care of this yourself and never have _any_ protection from the ORM/DBAL? &gt;Do I have to explain that allowing a non-existent column to be specified is still a few orders of magnitude better than arbitrary SQL injections. Only if you _actually_ manage to perfectly sanitise identifiers regardless of the database being targetted and don't just provide a false sense of a security that can be broken out of. &gt;Also an ORM should have a whitelist of valid column names already as they're defined in the entities. This is not true of many ORMs or DBALs, where a schema query would be required to get this information. Perhaps that is a worthy trade-off to protect developers from the themselves if they don't read the documentation, but I certainly don't think it's as clear cut as you make it out to be. There is only so far that you can protect a developer from themselves and the Laravel database documentation specifically warns that column names aren't bound (because PDO doesn't support it) and if they're specified by user input should always be whitelisted, the same warning is present in the documentation for the validation library. Perhaps it's better to not let a user specify which column is checked against when running a validation check _on the user's input_, no? Maybe I'm biased, because developers blindly relying on the framework to protect them from all vulnerabilities and never actually reading the documentation or understanding basic application security has kept me steadily employed for well over a decade. Tools should do what they can to protect the developers from shooting themselves in the foot while still remaining flexible and usable, there is always going to be a trade-off where you have to rely on the developer actually understanding the tools they are using. For what it's worth, I was vocally critical of the handling of this vulnerability when it was announced, but for different reasons.
You keep talking about how hard it is to "sanitize" identifiers. It's letters, numbers, and dot. It's not complicated. I feel as if this answers most of your concerns...
&gt;50% comment lines means clean code.
Also this structure. The CMS can do nothing without all the external modules. Iam not sure if they are a part of a "release" or something.
Have fun in a big softwarestack with only constructor dependency injection. Very much fun. It will end in an unclean code because you have to inject a class from the very beginning deep down. Also you cant create an instance of an class if you dont have all the dependencies yet. So you gonna refactor your current class to get this in the constructor and so on. Uncle Bob said and showed this 20 years ago.
&gt; It's ASCII letters, numbers, and dot. I hate to break it to you, but most databases support way more characters than that for identifiers, including a delightful selection of Unicode characters that can be used to break out of naive filtering, it's only ANSI SQL that limits it to those characters. You can use the backtick in MySQL identifiers and PostgreSQL lets you use absolutely anything except character code zero. If your DBAL needs to support connecting to any arbitrary database and so can't rely on offering a restrictive set of identifiers, you can't just naively sanitise column names, which is why DBALs generally don't do it and why developers should be aware of that fact. PDO doesn't support binding column names because the database itself creates the execution plan for the query before binding parameters to the query and it needs the table and column identifiers before that can happen.
Yes, I indeed gave it a thought, and I also found https://github.com/oraoto/pib which u/123filips123 mentioned below. I cannot see that compiling PHP directly to webassembly would work out. If this would be a viable strategy, I would expect that we'd have a (at least medium) successfull PHP to some-other-native-code compiler, which we do not have (right?). The general strategy in that field seems to be php -&gt; some other lang -&gt; native. The first step is essentially what I'm trying here, adding the second step would just add another problem. Building php -&gt; wasm directly is beyond my skill set. I'm not looking into changing this here, though, because I cannot see benefit in the direct compilation. This would essentially mean to disregard any existing knowledge about compilation and performance on the php-side and the wasm-side as well. The strategy to compile the PHP-interpreter to wasm and then use it to execute PHP (like https://github.com/oraoto/pib) didn't convice me for two reasons: For one, I cannot see a clear path how client-side JS-APIs, which a tool like this would definitely need to support, could be added in the mix. Second, pib's performance and general handling is horrible and I cannot see a clear path to improve that. In both cases this might just be me and my skillset, though, and someone with stronger C and even more low-level skills might see that different. On the other hand, I expect PHP+JS-skills to be more common than PHP+C/low-level, so PHP -&gt; JS is also about possible contributors and support in such an endeavour.
&gt; I hate to break it to you, but most databases support way more characters than that for identifiers, including a delightful selection of Unicode characters that can be used to break out of naive filtering, it's only ANSI SQL that limits it to those characters. You can use the backtick in MySQL identifiers and PostgreSQL lets you use absolutely anything except character code zero. I hate to break it to you, but ORM's biggest selling point is supposed to be database-agnostic persistence layer over SQL. You're telling me this was abandoned so we can have emoji in our column names? Yes, no? Which is it? &gt; PDO doesn't support binding column names... That's irrelevant to the discussion.
&gt;You're telling me this was abandoned so we can have emoji in our column names? Yes, no? Which is it? No, a basic requirement of a DBAL is to be able to deal with arbitrary databases. It's not exactly uncommon that you need to connect a modern application to an existing database, that may not follow the same requirements you would like to impose on Also, you may be unaware, but there are other alphabets than Latin that are used around the world, often with complex characters that can be abused in fun ways. Emojis aren't the only reason (or even a good one) to support Unicode identifiers. Databases have supported arbitrary characters in identifiers for decades now, it's pretty basic that a DBAL should be able to support them to, even if the ORM built on top of it doesn't allow them. The `unique` validation rule can rightly validate against any arbitrary table, not just ones created by Laravel's Eloquent ORM, as the validation library isn't dependent on Eloquent.
Dear god what is this? It's like you took a look at all the 'best practices' of coding and threw them into the wind. No composer? No (unit/functional) tests? No namespaces? No PSR? etc... Im sorry mate, if i were you, i'd take this behind the barn and shoot it... in the face. This is like PHP 4 era level code. &amp;#x200B; Also, you're using GIT... stop with the directory structure versioning
&gt; No, a basic requirement of a DBAL is to be able to deal with arbitrary databases. This DBAL is designed for ORMs. ORMs don't have this goal. And Doctrine's DBAL is severely limited to begin with. It doesn't support the vast majority of transaction attributes of MySQL, SQLite and Postgres in my uses, only complete basics. Not to mention stored procedures, etc. The picture that's forming here is that you have an excuse in your pocket for every flaw Doctrine has. What you **don't** have is a cohesive argument what Doctrine's purpose is and how its implementation fits this purpose. If Doctrine's DBAL is supposed to be a generic DBAL that abstracts every database, it's extremely rudimentary for that purpose. If its goal is to be a DBAL for Doctrine's ORM, then again, none of this applies. ORMs, including this one, are "objects first" not "DB first". &gt; Also, you may be unaware, but there are other alphabets than Latin that are used around the world, often with complex characters that can be abused in fun ways. Can you please drop this arrogant dismissive "you may be unaware". I'm from Bulgaria. We use Cyrillic. If someone starts using Cyrillic in source code identifiers, it means he should be fired, and the person who hired him also should be fired. This is not about holding hands and using all our alphabets together, and yadda yadda. This is source code. ASCII identifiers are universally accepted as standard, and nothing else has a reason to be in an identifier. I don't have to have identifiers in BULGARIAN in order to write an app for Bulgarians. But *you may be unaware*... Are you? You seem unaware :-)
Thanks for your honest feedback! &gt; Oh, suck it up. You're a developer, it's part of your job to learn. Yes, it is. But also: there's always so much to learn and so little time, and, especially in js-country, the half-life of knowledge isn't that good. So we have to choose carefully and wisely what we learn. &gt; And adding php2js doesn't? Yes, it does. What I'm assuming here, basically, is, that adding php2js would mean less new complexity than adding a complete js-stack + according people. This certainly is a gamble. &gt; Also, server side and client side are fundamentally different environments. [...] How do you deal with that? Your indeed correct, they are different environments with different APIs and execution models. This is why I do not plan to implement every PHP-API and consider the question how JS-APIs (or maybe even libraries) could be included in the mix important. Besides typescript, there are other languages that compile to js as well, some even available on server- and client-side. They do not solve the problem that different APIs are required and available on client and server, but they all tackle two problems that exist in the mixed-lang-scenarios: people do not have to write in two different languages (and switch between lang-constructs, idioms, tools, ...) and general purpose code does not need to duplicated. Still, this certainly is a gamble that hinges on circumstances that well might be different for different cases: Do we have that much code that we would want to use on client and server? Do two languages really add that much problems? Does the project have a clear and separate client and server side? Which people and ressources are available? About the code generation: I see a lot of languages that compile to JS, and even people in js-country mix other languages into their js-code, which is demonstrated impressively by babel. From my perspective, JS itself is very simple yet powerful, but also does not provide much guidenance and patterns and possibility for abstraction out of the box, which is why it is used as a compilation target instead of original language in so many cases. This, however, is a different thing from the APIs that browsers offer, which are certainly required to do anything interesting on the client-side. I'm looking to compile PHP to JS, not PHP-API to JS-API, though.
Honestly I don't think adding more functions with obscure names for the sake of "consistency" is the right thing to do. In my opinion there should be a focus on a built-in OO string manipulations library, and let the functional approach fade in the past.
It's all being brought up to date.
Cross Site Scripting
Flash is still good.
Let's see something you wrote.
&gt;The picture that's forming here is that you have an excuse in your pocket for every flaw Doctrine has. What you don't have is a cohesive argument what Doctrine's purpose is and how its implementation fits this purpose. Because that's not what we're discussing. For one I'm talking about Laravel's DBAL, which uses Doctrine's in some places, but I'm also not trying to make any arguments about the validity of the DBAL itself, only the fact that Laravel's validation library is designed to work with arbitrary databases. You'll get no argument from me that either of them aren't basic, aiming to support the widest posible selection of features across RDBMSs, but it's not really material in the real world. Do you also think that PDO shouldn't support arbitrary identifiers, despite their dissapointingly widespread usage? &gt;Can you please drop this arrogant dismissive "you may be unaware". I did actually edit that out before you responded, as I didn't think it was warranted, but you seem to be arguing from a perspective that doesn't take into account reality, just how you wish reality was. &gt; This is not about holding hands and using all our alphabets together, and yadda yadda. This is source code. ASCII identifiers are universally accepted as standard, and nothing else has a reason to be in an identifier. I don't disagree in the slightest, that doesn't mean that there aren't plenty of databases out there which do and still need to be supported. I once worked with a large financial services database that used identifiers from multiple different alphabets across its 2000+ tables. Saying "sorry, I'm not a fan of choices you made 20 years and a few billion records ago" isn't really useful in that situation. I had to change my editor font to work with their code because whatever I was using at the time didn't support all the characters their various contractors had used across the span of a couple of decades.
Function: Sure Function Name: Please god, No. I mean, I know it has some consistency with what already, but being consistent with crap means it's consistently crap. It might as well be a jumble of letters.
I highly doubt you'd be able to interact with this 20 year old database from a PHP DBAL. As I said, these DBAL are highly rudimentary. Ever seen a DBAL expose readonly transactions? Defferable? Storepoints? Unions? Just to name a few. If you really need to get down and dirty on a legacy codebase, DBAL is not the way to do. Unless maybe you're not *really* working with those 2000+ tables, but rather just reading a couple of tables for a one-off reporting app or whatever (then who cares I guess). But once again, you can validate a Unicode identifier. It's just that I *personally* would wait for the GitHub Issue to come before I shove that piece of shit in my codebase. But it's not hard to do.
I have nothing to prove to you, you came here asking for coders on a project. People will look at the code and compare it to their own experience. So i did, and i typed up my opinion. if you want to refactor this code, don't. Refactoring this means rewriting all of it and copying the functionality it has. You're better off just binning it and making something new that people would want to use and work on. Which in my opinion, is something that does use Javascript. A headless CMS, PHP providing the data and React/Vue/whatever the GUI.
By that reasoning, PHP is insecure because of the risk of SQL injection.
PHP was always at risk. In fact it was so bad they changed it over to PDO statements.
Different problems. We need to shape up the current API, and we need a new API. But I actually don't agree we need it to be OOP. We're focusing a lot on form over function with this. I also like OOP interfaces, they're short and neat. You can chain them. But in a dynamically typed language like PHP, it'll also introduce more bugs. In JS I have to often do stuff like this, to make sure my script doesn't bomb: (foo + '').substr(1) Why did I do this? Because the argument is listed as string, but someone decided their number is actually a string and passed it this way. We have scalar typehints in PHP to fix this in the basic case. But if that scalar is in an array etc.? Tough luck. One advantage of this: substr($foo, 1); ...is that no matter what $foo is, I don't risk suddenly the string API not being available for it, if it's not a string. It gets converted to string and the code continues. Maybe one way we could make an omelette without breaking any eggs would be to... 1. Have an OOP interface for scalars anyway, but... 2. Have all APIs for numbers, booleans, strings under a single class, the "Scalar" class, which Float, Int, String, and Bool extend. This means no matter what scalar you have, the same API is present, avoiding type errors. Yeah I can hear the moaning or r/php already, but I'm trying to be pragmatic here...
Thanks for your kind words and the offer for support. I have some experience with PHP-Parser and AST as well (https://github.com/lechimp-p/dicto.php) but I might ask for a review some day. Rector is on my list as well, so chances are good we'll get in touch again one day or the other =) &gt; [...] custom Javascript printer [...] right? My pipeline currently looks as such: PHP-Files -&gt; PHP-AST -&gt; add information/simplify/rewrite -&gt; JS-AST -&gt; JS-string. So a little more elaborate than just printing php as js. The third step is crucial to e.g. turn array code to calls to a class that emulates an PHP-Array in JS. There will be more situations where some PHP feature needs to be emulated in JS when the tool gets more elaborate.
Like said in my email to internals I'm really torn about this myself as the naming is, well, shit but for whatever reason when strchr got converted to strstr it's reverse counterpart didn't get the same treatment which doesn't make sense IMHO, so now there is this weird situation which is super suboptimal. &amp;#x200B; I would love to manage to get a string object (or object like) in PHP for PHP 8 which would allows us a cleaner API, less crap in it, and having it traversable such that it can be used in a foreach loop easily. However with my minuscule knowledge of C and the PHP Engine I don't think I can figure that out even if I may be able to base myself of Nikita's scalar object extension.
Magento isn't a framework. its an e-commerce system. Big difference.
Laravel or Symfony. Both are very capable and widely used.
Firefox and Chrome disable Flash by default (Firefox insists that you install it manually, as well), Microsoft are discontinuing support in Edge/IE this year, Adobe is supposedly ending support entirely in 2020. Security wise, Flash is a minefield and in comparison to HTML5 it is clunky and slow. Adobe got fed up fixing the critical security vulnerabilities that people kept finding - which is why they're EOL'ing it next year. Unless your emulator is running in the next month or two, there's not much point continuing with it, because nobody will be able to use it. &amp;#x200B; I get that this is your project, but you yourself say it is old, and sometimes old things need to be replaced, and not renewed.
For " consistency" they should rearrange all the parameters to follow one common order. Then they can make new shitty functions.
Trufax I'm changing the emulators over to html5 instead of flash. /sarcasm.
I would bet on that....
Cross site scripting with JavaScript is only a problem if you're allowing users to inject code onto your pages. Equally, SQLi is only a problem if you allow user inputs to modify a query. &amp;#x200B; Neither is inherently insecure because of the language, they are insecure due to the usage of the language by the developer. If this is how far your knowledge of security vulnerabilities goes, I would not pin much on your statement that that it is a secure CMS. I would be fascinated to see a professional pen-test result for a bare copy of your CMS.
You have WebGL and highly optimized JIT compiler in "HTML5". So performance should be comparable. Obviously you won't be using actual HTML.
Like I said, I highly appreciate the time and effort you put into contributing to the core. However, I'm not as torn about the subject as you might be. I simply don't think we should add these functions. As you state in the RFC: it's easy to implement this functionality in userland if someone really needs it, for now. So let's focus on the right solution for PHP 8.
Dear God it isn't even done yet. And, I am a penetration tester as well. It's painfully obvious you don't even know what you're talking about. I'm a famed hacker actually. I'm featured in 3 documentaries.
I admire bad code that achieves what it set out to do through hustle. I would've stopped and refactored, or get depressed and quit before I ever finish something like that. But they did it. Respect.
 The magento devdocs has a whole section called ¬´ Magento Framework ¬ª explaining routing, components and request flow. It‚Äôs literally a framework.
&gt;I highly doubt you'd be able to interact with this 20 year old database from a PHP DBAL. As I said, these DBAL are highly rudimentary. Not at all. It was ported to MySQL sometime in the early 2000s from a proprietary database that had gone out of business. It was just a dumb data store with a lot of data, which is very common. We work with even older databases, sometimes a DBAL doesn't provide the functionality we use, but then we just don't use it, there's nothing wrong with pragmatism. &gt;Unless maybe you're not really working with those 2000+ tables, but rather just reading a couple of tables for a one-off reporting app or whatever (then who cares I guess). There were never any queries dealing with all the tables, but single queries would often deal with tens and occasionally hundreds of tables (it was very poorly designed, which was part of the reason we were hired). &gt;But it's not hard to do. Famous last words before people discover the fun of Unicode homoglyphs (or the numerous other techniques for abusing Unicode characters) when their poorly devised sanitisation function doesn't actually sanitise what they thought if the user happens to be using SQL Server or some other database they didn't think to test every Unicode code point combination against. It is far safer to just make the limitation clear to the developer and let them implement a whitelist if they _need_ dynamic column names based on user input than to try and implement something that is platform agnostic and bulletproof.
No, it's really not. It's an ecommerce system. The fact that it has docs on how to extend it to do other things is just common sense. You may as well be calling Wordpress, Drupal, Joomla and any other package built on php a framework. https://stackoverflow.com/questions/13988057/is-magento-a-framework-or-platform
Don't master frameworks, master the ideas behind frameworks, and you can apply them to almost any framework
It's a framework from Varien, mixed with pieces of Zend Framework 1, with an e-commerce clusterfuck on top of it.
also the ide wont mark the typo str\*r\*str anymore. It will just not work. But yes this feature has to be in php. I wonder how much this will be used at all.
Where to begin: &amp;#x200B; No testing (even though you specifically mention testing in the readme) Using folder versioning when you are using GIT No namespacing Not using composer Not proper OOP or Functional - what exactly is your approach here? Not using any known software design patterns Not declaring visibility for methods/properties Echoing out HTML in PHP files Completely unnecessary and superfluous comments &amp;#x200B; If you are under the impression this codebase is indicative of quality software craftmanship you are deluded. You mention 'we' but I can only see one contributor to the project. &amp;#x200B; It is genuinely in such a state its not worth developing on. It would essentially need to be re-architectured from scratch. You should start learning about software design patterns and best practices before you start something like this again. Good luck
&gt; Famous last words before people discover the fun of Unicode homoglyphs (or the numerous other techniques for abusing Unicode characters) As I said, I've researched Unicode, and it's not that complicated to validate an identifier. It's not like I have to implement everything in Unicode for this one simple task. Also homoglyphs have nothing to do with validating an identifier (but I did mention them as one reason why you'd stick to ASCII for identifiers). The idea you need to test "every code point combination" is... I honestly am starting to think you believe you can B.S. your way through an argument... Unicode doesn't work this way. You're making this sound more complicated than it is. There are classes of characters you'd allow (letter uppercase, lowercase, modifier, number decimal, letter, etc.) Everything else, punctuation, whitespace, control characters are out. New characters not in your Unicode implementation are out. Databases don't use Unicode letter classes for special tokens with a string. **I guarantee you that**. &gt; It is far safer to just make the limitation clear to the developer and let them implement a whitelist if they need dynamic column names based on user input than to try and implement something that is platform agnostic and bulletproof. You know what's safer? It's safer to research your domain, like I did, and not waffle through, let everything in and put a "WARNING!" in your PHPDoc, like you're telling me to do. When someone has to right a DBAL, they need to do their fucking job, not pass it along to the users.
A pen tester that has his DB credentials in source and whose own website doesn't even have an SSL certificate ...
I... have no idea how to respond to this. You cannot say things like that without providing proof, otherwise you look like a complete tool. It reads like you're paraphrasing Trump. Not in a good way.
Don't forget 'famed hacker'.
&gt; There are classes of characters you'd allow (letter uppercase, lowercase, modifier, number decimal, letter, etc.) Everything else, punctuation, whitespace, control characters are out. You're still missing the point. This only works if you're happy for your DBAL not to support a common feature of the majority of RDBMSs, which is absolutely fine if that's the goal of it, but it isn't the goal of most of them. As I said several posts ago, I completely agree with you on sticking to ASCII identifiers, I have never used anything other than ASCII or underscores when naming identifiers, but that doesn't mean that a general purpose DBAL doesn't need to be able to deal with them. You are clearly just arguing for the sake of arguing and you've yet to provide any real world examples of DBALs that do this and support most mainstream RDBMSs. &gt;Also homoglyphs have nothing to do with validating an identifier There are classic injection attacks that use homoglyphs to work around poorly implemented sanitisation functions that don't properly escape delimiters. This isn't theory. &gt;You don't know how to deal with Unicode, that's apparent, but your excuse is you're a DBAL user. So that's fine. If you were one of the DBAL writers arguing with me, I'd tell you your code is shit and go do your homework. I'm done here, you're incapable of discussion without resorting to ad homonym. Have a nice day.
&gt;epoch will soon overflow 2038 will not be a problem, do you remember 2000? similar issue and we bypass it without any problems
Call that what you want, it has it‚Äôs own way of handling the request flow, models, views, handling component interactions, conventions and configurations. Event if most is inherited from Zend (but it‚Äôs like saying a framework using Symfony component is not a framework). As far as I‚Äôm concerned it‚Äôs a framework and a cluster of bad design, calling it a ¬´ system ¬ª or a ¬´ platform ¬ª is more of a marketing standpoint for Adobe. Half our clients have a magento based e-commerce with custom-but-never-used-once-in-prod modules everywhere, hundreds of thousands of products and references, and a few millions clients. That ¬´ ecommerce platform-solution-app system ¬ª is terrible to develop on by modern PHP standard (and we worked on magento 1.7, 1.9, and all the 2.X): it‚Äôs less scalable and maintainable than a bad symfony custom solution, we had to handle those too, and it‚Äôs way easier to fix crap built in symfony and laravel than crap built in magento, even on multi-million users ecom sites.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
This almost belongs at /r/programminghorror
Thank you for sharing. I've dealt with this for many years using various solutions. One that our team has settled on is using the vagrant-fsnotify plugin, which basically monitors folders on the windows machine and forwards changes to the vm. &amp;#x200B; I have tried the phpstorm sync methods in the past, but found issues when changing the files in the vm not being reflected in the ide without comparing the state. &amp;#x200B; I wonder if mutagen could replace our current solution without too much friction.
&gt; You're still missing the point. This only works if you're happy for your DBAL not to support a common feature of the majority of RDBMSs, which is absolutely fine if that's the goal of it, but it isn't the goal of most of them. You continue to assume random things without any research. Which gives me the opportunity to do some research and verify your hypothesis. So turns out PostgreSQL requires Unicode characters to be encoded in identifiers in a very specific way. This is the only way it works. Passing them as-is doesn't work (SQL syntax error). Guess what Doctrine DBAL does? Nothing. So Doctrine DBAL does **NOT** support Unicode on Postgres, despite you sung its praises over half a dozen comments for how it should support everything. That throws quite the wrench in your entire theory. But it's interestingly in support of mine: they just didn't bother researching this AT ALL. &gt; You are clearly just arguing for the sake of arguing Irony... &gt; There are classic injection attacks that use homoglyphs to work around poorly implemented sanitisation functions that don't properly escape delimiters. This isn't theory. "Homoglyphs" means two distinct letters (and codepoints) that happen to look the same to a human eye. For example the latin "capital bee" B and the cyrillic "capital vee" –í. A homoglyph can be used to spoof a domain in phishing email for example. It can fool a human eye, it can't fool a machine. To a machine, that's just two different codepoints. And so it has no relevance to machine validation. So "homoglyph" is the wrong word here, you're talking about something else...
Thanks for the tip about vagrant-winnfsd, I'll have to check it out.
I don't even know what these functions would do, and with those names I can't possibly tell, and this makes me not want them. Old C-style naming is awful and makes no sense any more. Array functions lately seem to be much better in naming (array_key_first/array_key_last), so we should 100% go in the same direction.
Lmao. And you showed proof for your statements? I'm done with reddit. Aaron Swartz would be rolling in his grave.
You remind me of that annoying troll that badgers a work in progress. We have all yet to see anything you have ever written.
Yeah I couldn't figure it out either.
Youre looking for shopware if youre looking for a good ecommerce "system". The framework behind is symfony. Wordpress has also its own routing and this things. But lol thats no framework its a shitton of code which was made for a blog but then people implemented all the things into a blog software. Now they call it "cms" but its not near a real cms.
It's easy to troll and criticize, isn't it.
Way to go! You must be so elite and the best! You can criticize a work in progress and troll behind an account with no picture! You get +1 Internets. Heh.
Yeah that's not true at all. Javascript is a horrible language. It's just ugly all the way around.
Right.
The problem with Laravel is that it is crossing responsibilities (validation layer vs database layer) which may not (and clearly was not) be obvious to everybody. The problem *was* that is was never properly documented as opposed to Doctrine where they do their best to make it clear by documenting what actions are considered safe and which are not. Further more Otwell blamed users (kinda like is happening here) by saying it was user errors and not using things as documented (which is wrong as it was not documented at all). &amp;#x200B; The good thing that came out of it is that it is now properly documented and there should not be any surprises (regarding this security issue) for users anymore. The IMO bad thing is that especially for security related things one should err on the safe side and make it clear for users what is safe to do either through the API (prefered) or through the docs instead of blaming your innocent users.
I agree, there‚Äôs plenty of good alternatives, but sadly we‚Äôre either stuck from the client side ¬´ we want everything in magento because X competitor use magento while we won‚Äôt use 10% of magento capabilities, oh and we want extra custom modules with deep integration with [insert ancient undocumented api from another company to handle stock and prices if we‚Äôre lucky, xml with millions of entry sent over ftp of we‚Äôre screwed] ¬ª, or stuck because the client comes with a backstory ¬´ our system is legacy and critical, of course we will not pay for security updates or huge backend changes, only features, moarrrr features ¬ª (worst case being legacy magento 1.7 app with custom security patches and modules built upon changes over changes over changes on magento core...urg) Ecommerce was a mistake :(
To me, this function is all about substr, so I'd probably go for something like: substr_from_first, substr_from_last However, I don't like the original function at all if I'm being honest, it feels like it's only doing half the job it should have been doing, and including the needle in one case, and excluding it in another is an odd choice, I'm not sure what problem it was trying to solve. I think what these functions *should* have been designed with was an $occurrence parameter, and $occurrence &gt; 0 would have been the nth occurrence from the start of the haystack, and $occurrence &lt; 0 should have been the nth occurrence from the end.
Lold. This is a very old project. I started playing with it over 10 years ago when I was first learning PHP. It probably does need to be completely rewritten. I had stopped developing it in 2009. Now I'm bringing it up to date. The comments are there to later assist in development or maintenance by a user of it.
So the source can be seen from the browser.
Surely with your professional pen-tester (or hacker) hat on, you would know that this isn't a good thing **at all**?
Since the source can be downloaded anyway it really doesn't matter. The ability for the browser to see the source is part of another feature. I made it like that deliberately.
&gt; So turns out PostgreSQL requires Unicode characters to be encoded in identifiers in a very specific way. This is the only way it works. Passing them as-is doesn't work (SQL syntax error). It works fine in PostgreSQL, it just requires the identifier to be enclosed in double quotes and only double quotes, [as the documentation states](https://www.postgresql.org/docs/current/sql-syntax-lexical.html#SQL-SYNTAX-IDENTIFIERS). The following executes without any errors: CREATE TABLE test( "–â–©—â”É" VARCHAR (50) NOT NULL ); INSERT INTO test("–â–©—â”É") VALUES ('Test Record'); SELECT * from test; I also have no issues creating that tables using Doctrine's DBAL, or Laravel's DB layer. [Insert](https://i.imgur.com/hl3Olra.png) and [select](https://i.imgur.com/4jtJdg1.png). &gt;A homoglyph can be used to spoof a domain in phishing email for example. It can fool a human eye, it can't fool a machine. To a machine, that's just two different codepoints. And so it has no relevance to machine validation. Which is what many developers thought when they implemented their own sanitisation methods until they discovered that, for example, [SQL Server will convert a homoglyph](https://hackernoon.com/%CA%BC-%C5%9B%E2%84%87%E2%84%92%E2%84%87%E2%84%82%CA%88-how-unicode-homoglyphs-will-break-your-custom-sql-injection-sanitizing-functions-1224377f7b51) to it's closest ASCII alternative when using it in certain fields. I was just using this as an example of the complexities of dealing with mulitple different RDBMS's and Unicode, because you keep repeating how simple it all is. I'm guessing you still don't have an example of a DBAL that implements what you keep referring to as being simple while supporting most mainstream databases.
You are asking a software community to contribute to a project with no quality or craftsmanship. Anytime somebody anyone has a valid criticism you simply respond with inane whatboutism. &amp;#x200B; I'm not hiding behind anything - my username is the same on GitHub and from there you can find my LinkedIn amongst other social channels. I'm a lead software engineer at a start up in the UK and am definitely qualified to question any self proclaimed 'pen tester' and 'elite hacker' who can't even install an SSL certificate on their own site.
It's in progress. Thanks for your invalid input!
Yeah, I don't disagree with that, it's basically [what I said](https://www.reddit.com/r/PHP/comments/b2yy9q/sql_injection_vulnerability_in_laravel/eiwftb5/) when it first broke. Although my stance has softened slightly after looking into the issue in morfe depth.
All it takes is a working ssh setup on your local machine. When I tried it the first time I was up and running in about 5 minutes. It's also somewhat set and forget because the synchronization session automatically restart after a reboot.
Oh, incredibly so - it's effectively like PHP4 or older in terms of functionality and use - but that doesn't make it insecure. As to it not being true - please show me how to create a viable XSS attack without having a way to inject code into a page via insecure CMS or file inclusion / upload / etc. Note: Editing the DOM in your own browser is not actually a cross-site-scripting attack, as it is only affecting your own instance of a site. Editing the DOM in your browser to change validation to allow you to submit values that you would not normally be able to submit is a vulnerability, but it's still not an XSS vulnerability.
Your to do list and this post is specifically requesting the building of new features and bragging about clean code. Dont be surprised or defensive when we point out otherwise.
I can't share that with you.
Great food post but no php or some dev things to see.
i hope they dont follow js. With js we wont have that big php ecosystem now.
So, you built it either just out of university, or similar. Probably before you were exposed to professional development practices. I built my own CMS in my early 20's as well, it even ran the website of an MP for a couple of years. It was objectively crap, but it worked for that period of time, until I had to try and maintain it later down the line. Sometimes you just need to apply that bit of introspection or critical thinking to what you're doing, and realise that sure, it worked, it did the job, but there are far better ways of doing it, and you tear it down and start again. In the first month of working alongside other developers professionally, I learned more about secure and sensible development than I had in three years of university. A lot of your comments come across as vaguely narcissistic (actually, so does your twiter), you're asking for people to "try out" for an open source project, which I can only assume is unpaid, as if we wouldn't be good enough for your codebase, which may well be true in some cases, but you're not going to get any help by striding in, saying your package is amazing, and asking for freebies. Check the attitude at the door, particularly when you need to ask for help in debugging a sql query that you couldn't identify or locate initially because of the state of your own code.
&gt;my issue was more with how it was handled at the time, rather than how it was solved going forward. Fully agree there with you.
People need to stop agonising over this "consistency" thing. Seriously I feel that whoever wrote this RFC has so little to contribute that they chose this as a low effort way of looking as though they are contributing. - I may be wrong, I haven't checked out the person who submitted it or their history. But seriously just leave it with stuff like this, it's just noise. &amp;#x200B; The API is the API, there is no point in adding function aliases. Please explain to me what "strrstr" and "strristr" actually mean, both of them seem utterly meaningless and actually the way that these are named are inconsistent with best practice for naming things.
So let me sum up your argument. We should let everything through, because some databases support Unicode, while SQLServer doesn‚Äôt and convert to ASCII analogs. Gee I wonder what other option there may have been. Like allow Unicode as specified where supported, and not allow it where it‚Äôs not. I know. Mind. Blown.
Speak for yourself! My first commercial (and first ecommerce) site I ever built was https://flyfood.arl.arizona.edu/ and it was done in early 2000 in PHP 3.0. I, personally, updated it to 4.0 through 4.2. People who came after me updated it, they said relatively trivially, all the way up to 7.2, in 2018, at which point the entire server was discontinued.
I do and now I hold jordie9669 in higher regard. A true inspiration.
Isn't there an RFC for new PHP function names?
I'm not following. Can you expand on this? Profiling is relative and not meant to express production execution time (most cache grind parsers will express times in terms of percentages by default). It's also an optional feature Xdebug has disabled by default.
Just look at pro/con pages at every other profiler. I just called the profiling feature out because you mentioned it.
Which features are causing slowdowns? I've used Xdebug on projects over 400k LOC without issue.
Has nothing to do with pho. Please leave
I remember this well!
I'm not coming up with anything. Have some links?
&gt;It's not. It's intentional damage punishable by several years in prison. I'm not sure where you're from but here in the UK its a civil matter not a crimnal one.
&gt;Then you'd go to court over it. Imagine you had a contractor do work on your house and you don't pay so he burns it down. Something like this happened in the UK very recently. Some woman scammed a number of tradesman for different jobs, not paying so the people who did her garden turned up and smashed the patio and all the fencing that they have done. Police was called due to disturbances of the peace and asked them to keep the noise down and stop using the tools as it was causing alarm and distress but couldn't do anything about them destroying whats technically still theirs. In short, in the UK it's a civil matter and not a criminal one.
I'm from the UK and it's the computer missuse act that establishes criminal offences: https://www.legislation.gov.uk/ukpga/1990/18/contents Unauthorised modification of computer material is punishable up to a 10 year prison sentence on indictment. http://www.legislation.gov.uk/ukpga/1990/18/section/3
holy shit, thanks for that. I've been following this one wondering "why doesn't anyone post??"
$soc\_sec\_number = base64\_encode(base64\_encode(base64\_encode($soc\_sec\_number) . "\_\_" . $customSalt)); no words...
 [https://www.youtube.com/watch?v=c\_w6EMRrPPU&amp;t=1s](https://www.youtube.com/watch?v=c_w6EMRrPPU&amp;t=1s)
&gt; The third step is crucial to e.g. turn array code to calls to a class that emulates an PHP-Array in JS. There will be more situations where some PHP feature needs to be emulated in JS when the tool gets more elaborate. Cool, pretty neat and it makes sense! (I'm js noob) I think this will be very well accepted as a conference talk.
But you had to make changes to accommodate breaking changes introduced in new versions, correct? My point still stands that OP should not be trying to fix a problem that is 19 years away with an app they are deploying today.
Why would you do it three times? I feel like if that was the case, recursion and if not, then you only need it once.
I apologies, I have left for user add/edit, I will share new tutorial for this soon.
thanks for rectify
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
First criticism: No link.
Can't reject my code if they can't see it, 200 IQ move.
Haha, u deserve an award for this one.
I still haven't uploaded it in github or anywhere, what about going through teamviewer ?
Haha, u deserve an award for this one.
which programming language or framework you used ?
I used PHP (mvc)
&gt;What do you think about the general idea and the rationale? Are they sound? The idea is mad, but I like it. &gt;What are your thoughts on using such a tool, for more or less professional projects? Would you use it? I wouldn't actually &gt;If you are not convinced that this is a good idea: What would it need to convince you? unless there is a good community behind the project and it is developed enough. What I mean is that no one would want to invest time in learning a dead or unpopular or badly written tool. &gt;How do you feel about contributing to the development of such a tool? This won't work as a one-man-show. I don't have experience participating in an open source project tbh, but I might &gt;Any other questions, remarks, comments? Nice idea overall, if typescript, scala.js and etc exist, there may exist a php version of it.
What the fucking shit is this?!
White background, dark texts
Well this would be the perfect time to also learn how to upload it to GitHub
Dark background, white texts
It‚Äôs still not finished, I have some other projects to upload too so will soon.
Use whichever one you prefer. There is no right or wrong despite what people may ferociously defend. :P
Vampire mode
Absolutelly. That's what I am thinking now.
I just got new monitors and have to use dark mode to not kill my eyes. May try switching back to light mode though because I do have astigmatism and white text on dark background is a bit hard to read.
I also have astigmatism (very mild vertical) and agree that black-on-white is easier to read. However, I get headaches fairly quickly from bright backgrounds so I stick with white-on-black anyways.
In our codebase there are some model classes with methods like $model-&gt;delete([‚Äòcol_name‚Äô=&gt;‚Äôvalue‚Äô]) where the array acts as a where clause. The models validate the column name against the table‚Äôs columns and if it isn‚Äôt valid (e.g. a typo) it ignores it and runs the query anyway... without the where clause
great reply! by explaining that, it's not all about preference- I completely understand why some would believe one is better or preferred over the other. Thanks so much for taking the time to reply and explain!
Telling people to install any framework or tool that doesn't come from the tool's primary namespace seems shady AF. I don't know `phpexpertsinc` or what they do to Laravel but I don't want it. Give me that clean install right from laravel/laravel so I know what I'm getting (especially version wise)
GraphQL?, phhhhff, i prefer GraphSQL /s
&gt;Use whichever one you prefer. Totally! But, that requires that there's a choice. That's the important point here -- **developers need to make sure they offer a choice of light AND dark mode.** Dark mode gives me migraines, so I can't use Dark Mode at all. But, there's a trend starting where developers are doing dark mode apps without any light mode alternatives (looking straight at you: Panic's Coda, Mozilla's Firefox Focus, for only 2 examples). And apps that don't have a light mode are not accessible to people like me, at all.
White/light mode
Brent from stitcher.io recently [wrote](https://us20.campaign-archive.com/?u=ca00be85f8183f513ec127063&amp;id=eadb09d8b5) about this
You are correct. My links to my own content are only a small portion of my engagement. Thank you.
PHP storm defaults is good
I have a some astigmatism, and naturally preferred white mode to start with. Today however I have customised my PHP storm with a dark materials theme (dark ocean) and added a brackets extension which assigns different colours to symbols at different levels. I also drilled quite deep into caret highlighting etc. Now I love my dark mode, a lot more than white mode. It is true that black writing on white is clearer if that's all you will use. But once you start colour coding syntax parts, dark mode is much clearer for me and makes a huge difference to my rapid scanning and traversing of the codebase.
I have astigmatism and prefer light on dark patterns. it may be because I've always used them, since long before I needed glasses, I guess. I have no more trouble reading one than the other... at least I've never noticed such a thing.
Most people have their monitor far too bright. 120 cd/m (ideal brightness) is actually pretty dim compared to the defaults.
But in this moment there are only 10 persons online.
Incidentally, the research back in the 70s and 80s indicated that "green screens" and screens with white (or bright) text on black backgrounds were the worst for readability and eye strain/fatigue, and that the *amber* text on black background was the best for readability and lessening visual fatigue.
I've seen worse: username and plain text password as params in the url for login.
Been using dark mode for years. Just can't look at any code on white background unless it's GitHub as it feels like someone's shining light in my face. I also have astigmatism by the way. I think it's all individual and depends on the colour scheme you're using. It's not really white text on black background, it's coloured text on dark grey background normally so slightly different. I don't think I could stare at white text on black background for hours.
Dark mode all the way. I also have astigmatism, but that's why I wear glasses for.
always dark, actually I also use b/w filters on my monitor and phone and only switch back to colors when I absolutely need to
I don't like *white* as a background, but I do find light text on a dark background hard to read. My current VS Code theme is [Bluloco Light](https://marketplace.visualstudio.com/items?itemName=uloco.theme-bluloco-light).
Well, for me case is different. I wear glasses, and somewhat like you I like Light theme rather than Dark. But I use both. I use Visual Studio Code and mostly Vim. On Visual Studio Code, I change theme manually, Light for day. And Dark for night. On Vim &amp; Terminal, I've automated my task that sets Light theme for hours between 7A.m. to 7p.m. And Dark for other 12 hours.
To me the only real requirement to this would be to choose an execution function for your chained builder. So for example the `run()` function should halt chaining and return something, this should be obviously communicated in the use of your class.
This one, so much. Applications (and even web apps now with [CSS prefers-color-scheme](https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme)) should try to respect the user/system preference.
Where is the link /u/Admicos
We also need something better than var_dump and var_export for debugging. Laravel has dd(), it is awesome but that does not come with stock php.
I have fairly mild astigmatism and use [Atom](https://atom.io/) with [atom-material-ui](https://github.com/atom-material/atom-material-ui). atom-material-ui uses #263238 as the background color and I found it much easier to read than the same text colors on darker backgrounds. Even thin light text is easy to read.
Well, I don't know what happened, but it seems to have disappeared for some reason. Here: https://github.com/Admicos/yap
I thought about creating a transpiler myself, but came to realize it's much harder than it seems. To emulate 100% how PHP behaves you can't just replace dots for arrows. You'll have dozens of edge cases where you'll need to wrap things in a kind of "VM". simple comparisons, for example, the way type juggling works, the way arrays are copied only when needed, references, and so on. This layer will much likely make code slower than the pure PHP version. And when your VM gets 100% compatible you still won't have things like PDO, SPL, Curl, Mcrypt... If your project plans to run existing PHP code like Wordpress it will have to support all that. If the goal is to write new software with PHP that runs on the JavaScript engines, i guess it just isn't worth it. But if despite all that you manage to write such transpiler I'd be really interested in testing it.
Briefly read through most of it pretty fast. Only knee jerk reaction i had was your management of environments. The way i manage this at the moment is to load in configuration settings for different environments when the framework is bootstrapped. Then pass through your environment settings class or whatever you want through DI. I guess you basically want to get to the point where you can define dev, test and production settings and pass any of them through the framework in particular. `define("PROD", false);` ect feels uncomfortable to me. But i'm still a learner, might be wrong on this.
I cut my teeth in default Sublime/Monokai. I use PHPStorm now, with the 'True ST3 Monokai' theme. It'd be difficult for me to transition away from Monokai.
Dark. Easier on the eyes for me so long as the text coloring is also not harsh on the eyes. Visual Studio and Eclipse have been good to me.
If I'm doing .NET stuff in Visual Studio, for some reason the default light theme just feels right to me. If I'm doing pretty much anything else, it's in VS Code or PhpStorm with a dark theme. This is unrelated, but I do think that the "dark mode" fad that is sweeping every software GUI right now is going to look pretty dated in a few years.
I never understand when someone is claiming "dark is better" without any additional arguments \- first of all, globally it is not true, "white mode" should be better for most of the people \- note that is also depends on other aspects (display contrast, day time, what you are reading, how tired you are, ...) \- mainly it always depends on person who is using the IDE as you mention, with some eyes problem you will have completely different preferences, maybe "blue-based mode" or yellow... so my point is: try alternatives what you actually prefer I am working with computer (programming/reading) since the end of elementary school so more than 20 years now at least 6-8 hours per working day in average \- and I still don't have any eye problem (luckily, but I know it is matter of time) and I am used to and I prefer simple "white/light mode" during a night I am using that darknes-contrast adjustment (available in Windows and MacOS) - I don't know what is the name of this actually but you can find it &gt;Research shows that the human eye is better equipped to read dark text on light backgrounds, than the other way around reference: [https://stitcher.io/blog/a-programmers-cognitive-load](https://stitcher.io/blog/a-programmers-cognitive-load) [https://dl.acm.org/citation.cfm?id=578434](https://dl.acm.org/citation.cfm?id=578434)
I have pretty bad astigmatism, but I strongly prefer to dark mode everything possible. I fiddle a bit with fonts, sizes, and shades, but staring at white backgrounds all day gives me headaches and eye strain.
Does it like really matter?
Most of the talk at the moment is about leaving the existing functions to rot as backwards compatible versions, and re-implementing them using something called scalar objects, which is a way of using object access notation on a scalar (number, boolean, string etc). By its very nature, that would solve most of the needle / haystack problems as the haystack is implicit in the variable its called on. $haystack = "My name is bob"; strpos($haystack, "name") Becomes $haystack.find("name"); There's already a working prototype Nikita made, but that is an extension. If it ever hits core you will probably see code analysers come out to re-write things from procedural to scalar object notation. echo ["Enough", "Soon", "Come", "Can't" ].reverse().join(" ")
Interesting - I have astigmatism and extremely nearsightedness and I prefer dark mode.
Light theme. Recently I started using dark theme but I still love light theme.
Scalar objects would be so awesome if it ever got accepted.
Ruby!
I would love that. And there could be some python-style backwards-compat require or extension.
Its ongoing debate for years. I would like to deprecate this mess and create clean consistend stabdatd library.
No.
You are welcome. Php is open source, just fix everything you find appropriate and create a pull request. Just make sure it won't break the backward compatibility.
I am an amateur developer, so I guess all of my code falls in to this category)
... along with the majority of other high level languages.
DateTime object would be a good example of this currently out vs the old date() . Would be nice to keep building these out.
i cringed thinking about PHP as a 3d language
How many of us use Carbon package for example? Having a PHP package would be a wonderful goal by use case. I get tired of recreating Address cruds or Phone cruds based on framework / and version. Knowing damn well I could make a singular one using PHP/PDO (if needed) The bottom line, we are only dependent on PHP itself, and we should achieve what we can to use that without too many dependencies.
Solarized dark :)
I kind of chuckled at this, because of your Flysystem comment From Laravel's filesystem page: &gt; Laravel provides a powerful filesystem abstraction thanks to the wonderful Flysystem do we not know that Laravel just uses all the packages we are already talking about? :)
I asked Rasmus Lerdorf this exact same question during a conference two years ago and he bluntly said ‚Äúno‚Äù. So it seems he‚Äôs not a fan of this idea :)
Why does part of this post repeat itself, and why does this part repeat when it is not always true. &amp;#x200B; &gt; The progressive web app uses less data than a native app, loads swiftly and can be seen in search engines because it exists on the web.
Not exactly a PHP-related question, ist it ;)
Started with a single file and using composer and fastroute I did a look up on a table with 30,000 records, limit 10 Find it interesting what toll Bells and Whistles can give you Using PHP/PDO 18 Files (mostly route files) Load Time is 0.0037 Memory Usage 491.57 kb &amp;#x200B; Using NETTE/Database 3 5 Files Load Time is 0.0049 Memory Usage 580.55 kb &amp;#x200B; Using Illuminate/Database 60 Files Load Time is 0.0048 Memory Usage 864 kb &amp;#x200B; Using Illuminate/Database w/ Eloquent Model 67 Files Load Time is 0.0056 Memory Usage 1.05 mb
I've spent a lot of time looking into this over the last 20 years or so... Programming and reading paragraphs of text are quite different tasks. Regular linear text reading is usually better on light bg. Dark bg is better for locating/differentiating different text colours and shapes/blocks. Which is relevant to programming seeing your eyes are jumping around the place more.
Rasmus Lerdorf bad.
Not sure why you're getting down voted...
Thanks for pointing me
That's clearly the best route IMO, but I'm wondering why work hasn't actually started on it. I mean nikic's PoC extension has been around for years and it seems to me (I might be completely wrong) that it should be somewhat easier to implement than something like JIT, while tremendously improving PHP's image and developer happiness..
&gt; Php is open source, just fix everything you find appropriate and create a pull request. Large changes have to go through an acceptance process. This most surely wouldn't get accepted as just a PR.
This is such a minor non-issue IMHO. My IDE takes care of reminding me quickly.
And `doctrine/dbal`?
$haystack, $need : string operations $needle, $haystack : array operations I thinks it's a nice distinction to have, certainly in a dynamically typed language.
When im working, I dont want my retina's to be burning allll day.
Such a whine as in the OP won't be accepted either. Of course, I perfectly realize that the OP clearly aren't going to write any code. They are just wanting someone would do it for them. Sort of a monkey paw. And I just hinted gently that things aren't done this way :)
Array_filter has $haystack first.
I use light mode. I find it very hard to switch from a dark theme to a light theme, and since most websites have a light background and the rest of the office is light as well, I prefer working in light mode all the time. I don't use a white background in my IDE though, I use Solarized.
After op wrote the title he realized that doctrine is from a complete diffrent category of components. You cant compare them because it uses them as a driver lol
I mainly work in darkmode although I have astigmatism, too. I‚Äôm wearing glasses and this seems to help me quite a bit. I‚Äôve used the light mode on some IDEs and honestly it‚Äôs a little bit easier to read, but I find it‚Äôs less pleasing to look at from an aesthetic point of view... So I guess anyone should use the mode they want and we should all stop saying that dark mode is better for your eyes... In reality, we are all different and we all need different settings on our machines.
Or, probably more relevant to PHP users, JavaScript.
I just moved off laravel and wanted to use their amazing tinker package. took me fucking ages (ok I wasn't trying v hard) to realise it was just psysh ...
I rock a white background (IDE and console) with the Solarized Light text color scheme.
These function names are hard to get. PHP needs to improve consistency in many common function names and arguments but this RFC keeps the old bad naming. Maybe there could be functions aliases to implement with clever naming etc, to give time to the PHP community to get used to a new basis while the old functions are still available, and then delete all old functions. Could be done in 2 major versions maybe.
Ha awesome. What a dick.
No you just dont know how big software is developed. You can just waste your time working for nothing or you work within the right process. And this change doesnt start with a PR.
Because its bullshit.
Dark on dark. That way my boss (but ironically also myself) can't tell if I'm working or watching porn.
Thank you. Now im getting rich. Im combining that with php
He does all the time. He is the PHPExpert\~!
Yes it doesn't. It is not the point, though. As a usual redditor, you are making blunt trivial remarks unable to get the context of a single message, let alone the whole discussion :)
"Trolling" lol that defense. Just stop
no, bluntly.
Its really hard to get. Wordpress is a lot easier. You just have to run: apt-get install wordpress Wordpress is the absolut best software/framework out there
You can set doctrine o use the mysql-pdo driver in its config
&gt;Telling people to install any framework or tool that doesn't come from the tool's primary namespace seems shady AF. You talked to the php expert himself! Its his stuff.
I'm over 40, so black on white.
Waste of time.
Wow, this hits home. We were faced with this decision years ago - chose the gradual pattern refactoring route with repositories, as well as many other patterns. It‚Äôs always a sprint to get the pattern implemented app wide ASAP before someone commits code the old way. Or, even the dev that created it forgets. We‚Äôve come out the other side with defined patterns for most everything, leaving little doubt. I question if this was the right decision and will obviously never know. What I can say is that it‚Äôs boring and tedious work and makes dev employee retention more challenging. This is a factor that must be considered.
I'm really happy to hear that! :D You might actually be its first active user. If you have any ideas, bugs, troubles, feel free to contact me directly for help! :) Great! I'm so happy!
Yes! You're absolutely right, I've actually stared working on that! It's going to utilise Dependency Injection, mostly. I was thinking about something like two constructors for `Pattern`: - `new Pattern('\w+')` - `new Pattern('\w+', new Facade( new MatchingStrategy(new ApiBase()), new ReplaceStrategy(new ReplaceBase()), etc... )); ` Keeping in mind that I have a few entry points: `Pattern::of()` + `Pattern::prepare()`/`Pattern::inject()` - they both return `Pattern` interface.
Yes, I've done that in my `helpers.php` file, but the user of the library can chose **not to load** it, right? I think so. What would be a better way to create a helper global-function factory? What do you suggest? :)
Why not?
It‚Äôs an independent from the PHP project extension. So don‚Äôt blame PHP for this.
What exactly is it you think is uncalled for?
Why not... composer in Symfony 4 promotes the 'thanks' package for starring Github projects that are in your deps... Fair game, IMHO.
because it's not info.
an ad where you're looking for technical information
It's not an ad. It's a link for you to follow if you want to contribute to the continuous development and maintenance of Xdebug.
IDE can write code, IDE can't read code. A human has to do the review and understand everything. Not a non-issue.
I don't think you understand how much time goes into the making of these projects. The amount of money the author gets back is likely not covering 10% of what he put in. The more promotion they make the more support they get the better the product will become. Nothing wrong with that.
I disagree, I think it's pretty clever. XDebug is a great product available for free. I don't see how this causes any harm and seems like a pretty small ask for what we get from XDebug
 imports: - { resource: parameters.yml } - { resource: security.yml } - { resource: services.yml } framework: secret: '%secret%' router: { resource: '%kernel.project_dir%/app/config/routing.yml' } __ ___ __ .ama , ,d888a ,d88888888888ba. ,88"I) d a88']8i a88".8"8) `"8888:88 " _a8' .d8P' PP .d8P'.8 d) "8:88:baad8P' ,d8P' ,ama, .aa, .ama.g ,mmm d8P' 8 .8' 88):888P' ,d88' d8[ "8..a8"88 ,8I"88[ I88' d88 ]IaI" d8[ a88' dP "bm8mP8'(8'.8I 8[ d88' `" .88 ,88I ]8' .d'.8 88' ,8' I[ ,88P ,ama ,ama, d8[ .ama.g [88' I8, .d' ]8, ,88B ,d8 aI (88',88"8) d8[ "8. 88 ,8I"88[ ]88 `888P' `8888" "88P"8m" I88 88[ 8[ dP "bm8m88[.8I 8[ ]88, _,,aaaaaa,_ I88 8" 8 ]P' .d' 88 88' ,8' I[ `888a,. ,aadd88888888888bma. )88, ,]I I8, .d' )88a8B ,d8 aI "888888PP"' `8""""""8 "888PP' `888P' `88P"88P"8m" # ... # Twig Configuration twig: debug: '%kernel.debug%' strict_variables: '%kernel.debug%' # ...
I cringed imagining all those "hacking in 3D" scenes in movies being actually PHP.
Good luck.
I'm not a lawyer but this applies to people destroying other peoples (virtual) property, which is obviously a good thing if hackers gain access to your network and destroy your system. In this case, they haven't paid for the code it's not there's, so there is no criminal offence committed, they will delete what is rightful theirs. As mentioned in another post there was something very recently (in the UK) where a woman refused to pay for garden work done so they came back and smashed everything up, patio included. The police said it was a civil matter and not a criminal one because she hadn't paid so the resources were still the builders/gardeners. [https://www.dailymail.co.uk/news/article-6988579/Gardeners-destroy-brand-new-patio-sledgehammer.html](https://www.dailymail.co.uk/news/article-6988579/Gardeners-destroy-brand-new-patio-sledgehammer.html) "A spokesman for Cheshire Police confirmed officers attended the incident but decided it was a civil matter." If they haven't paid it's not theirs and they have no rights to it.
Some IDEs can read code. In PHPStorm, literal arguments can have their names spelled out in the code (no need to roll over with the mouse or anything). You can adjust if you want this for all arguments, or some (or none). But it helps take care of these things.
Can't see any harm in this, the developer is asking for help for something you use for free. He gives his time and 99% of the time gets nothing in return for it. Asking for a donation is hardly uncalled for.
I'm a fan of the idea, but if approached like this I'd probably say "no" as well. There are nice-to-haves that don't work out when you draw the bottom line of effort/value.
Oh whaaa, boo hoo, developers that spend tons of time developing software you use for *free* are requesting support. It's placed in a page only you the developer should see and doesn't detract in any way from the technical info you expect.
sorry, what information does it provide? maybe youmissed it but that was the php**info** call. you might be mistaking it with phpallaboutdevelopersandwhereyoucansendthemmoney()?
Well, you're in luck! All you have to do is to uninstall the xDebug and you'll be fine!
Then develop an alternative to xdebug yourself so you don't have to see it.
&gt;The more promotion they make the more support they get the better the product will become. except that's patently not true.
would you also recommend anyone that complains about facebook breaching privacy should just develop their own facebook? quite surprised at the reaction to this tbh, that's not just a link, it's a bright red ad in an otherwise subdued info page
\*You\* develop a replacement for Xdebug without any funding then?
ok i can understand your code , share your code upload on github/gitlab Waiting. I have 3 years of experience in working in purely MVC php , Laravel specifically.
If you can offer a compelling argument for how the link in phpinfo is a breach of privacy and therefore a comparable scenario, I'll answer your question.
&gt; sorry, what information does it provide? No one like to repeat themselves, but sometimes it's apparently necessary: It's a link for you to follow if you want to contribute to the continuous development and maintenance of Xdebug. &gt; maybe youmissed it but that was the phpinfo call. I don't see any other option for placing a link related to the project. &gt; you might be mistaking it with phpallaboutdevelopersandwhereyoucansendthemmoney()? Hey, if you don't like it, don't support it. Stop being a dick about people politely to support a project that people use for free. Don't like the link in phpinfo() link? Uninstall or disable the extension. Or you could make your own Xdebug alternative without a link. Good luck with that, btw.
As a user of their software you might be interested in knowing that they need some form of support in order to maintain the project, so I‚Äôd argue it is.
Would you know he had a patreon if he didn't put it there?
Its even often already set as default driver.
Reading this in portrait mode made me blind. I rate 2 stars.
&gt; If they haven't paid it's not theirs and they have no rights to it. Yeah that's not how it works, and loathed as I am to believe anything in the Daily Mail is entirely accurate, there's about 10 different ways in which those idiots committed various offences, not to mention the gross stupidity of it from their part, all that it would need is for one occupier or visitor to get injured due to the mess they intentionally made and they're on the line for hundreds of thousands in compensation. We have a court system for these things. That's why bailiffs require a court order and there are strict limits on using forced entry. Those police officers were, IMO, ignorant to their duty. They witnessed individuals acting in a threatening manner, maliciously creating a hazardous environment, which makes it a criminal offence. https://researchbriefings.files.parliament.uk/documents/SN05116/SN05116.pdf But that's besides the point, if the owner had given clear indication that he or she had removed their implied right of access, they would then be committing criminal trespass if they stayed for longer than it would take to reach the property boundaries. This is a technique commonly used by people dealing with non-court debt collectors. Stick a notice clearly visible on the wall removing the right of access to the debt collectors and if they enter the property, they're breaking the law. Installing backdoors, or using server access after steps have been taken to deny them that access, is just the same, and regardless of your personal view, is illegal under various pieces of legislation. I'm not ignorant to the knowledge, as a full time software consultant for more than a decade, I have credentials to access the servers of many former and current clients, but I know if I used any of them to go in and make changes it is clear the owner of those servers wouldn't approve of (or even access some of them in the first place) I would be breaking several criminal laws. If I write a piece of software that requires post-installation payment, then I would write a licensing check into the code that non-destructively disabled its functionality if payment was not made, and I would ensure a contract was signed before anything was handed over, with a clause allowing me to seek proof that the software or data was not being used. Because I'd rather the non-paying party ended up in front of a judge, rather than myself.
the comparable is that you can't just make your own. the fact that breaching privacy is so much worse just highlights how much you cannot just make your own, no matter the cost. I have no problem with authors linking, but this is a bit more than a link. Do you want everyone else to jump on the band waggon and make that file or the cli output a giant indecipherable mess of "links"?
It‚Äôs still not finished
**xdebug** # BECOME A PATRON directive | local value | master value
or you could just fork it and remove this line https://github.com/xdebug/xdebug/blob/1b32dd88419888458d49ce978b34592be0368744/xdebug.c#L1538
Right if you want an review and suggestion you are most welcome.
Yeah. Still, they let you use their software for free and if this message is the price you pay I think it‚Äôs a bit entitled to claim it should go. Just don‚Äôt use it if you don‚Äôt like it.
You're right, you can't just make your own, which is exactly why they deserve support. You acknowledge that you don't have either the time or the expertise to create an alternative. Then let them try to recoup some of the cost that goes into development. The sad fact is that if you don't make the link stand out, many people won't see or notice it. I do understand and can appreciate that too much of this can lead to clutter over time, but for now, practical reality is what it is, and it's not a significant problem. If more developers start upping the ante and the situation gets messier (which could very well happen), then I'll say there's a problem.
&gt; a bit entitled to claim it should go What's so entitled about it? They can do whatever the fuck they want with their software and we are free to complain about it. The issue for me is that it's an intrusive way to promote your patreon. **Do I think they deserve to be sponsored?** Of course. **Is it an asshole design?** Yes.
How about you make your own free language and stop complaining you entitled schmuck.
&gt;The sad fact is that if you don't make the link stand out, many people won't see or notice it This is why ad-blockers exist. &gt;then I'll say there's a problem. too late, you're existing in the new norm and removing those "ads" will actually take money from someone's pocket
I disagree, Derick has worked incredibly hard on XDebug and it's one of the best things in PHP-land. He deserves to advertise it. If you don't like it, you can uninstall or it fork it.
Figure out a better way to get the developers the funding they need and I'll be ready to listen. Hell, if you can accomplish that, you might just have a really popular platform that can change the world. That's a day I look forward to. Until then, we all do the best we can in an imperfect world.
&gt; Or you could make your own Xdebug alternative without a link. Good luck with that, btw. [Done](https://www.reddit.com/r/PHP/comments/c38idw/i_am_all_for_donating_to_php_and_supporting/erpedh9/)
Yeah, so why don't we all put some ads in phpInfo and make it nice, colorful and full of some "plz subscribe to my patreon!!!!1!!1" ^(/s)
It's just the ridiculous color scheme and huge font that does it for me. There are tons of less obstructing alternatives which still stand out enough for people to notice. However, they put it in the phpinfo() so how many times are you really affected by this..
Thanks for pointing out that Xdebug has this donation scheme. I didn‚Äôt know about it so will now donate some cash to support something that I find useful almost every day.
I'm not sure your test is quite comprehensive. The discrepancy gets way worse when you have: 1. Problems where you need JOIN (rather where you'd normally use one). 2. Problems where you need writes. 3. Problems where you need custom expressions and procedures.
You went from "make your own xdebug" to "make a platform to change the world". I guess I might as well sort out the middle east while I'm on a roll.
I personally don‚Äôt have anything against it but I would argue that it didn‚Äôt need to be this flashy. It grabs the attention immediately and I understand some of the users frustration.
I'm being fair and open minded rather than antagonistic because I'm not a dick who feels like he has to win an argument. I'm done now. Have a great day!
Derick (the author of XDebug) said exactly that on his blog: &gt;You can become a patron [here](https://www.patreon.com/bePatron?u=7864328) to support my work on Xdebug. More supporters, means that I can dedicate more of my time to improving Xdebug. [https://derickrethans.nl/xdebug-update-may-2019.html](https://derickrethans.nl/xdebug-update-may-2019.html)
Of course, and in the same category, you are free to complain that the government doesn‚Äôt give you $10,000 for free every month.
If your advert comes packaged with some software that's as useful as Xdebug, sure.
Good for you. Now stop complaining and use your own version.
`array_filter` doesn't really accept a `$haystack`. In the docs, it's named as `$array` and the reason it's the first argument is because the callback is optional.
I get why you're getting downvoted, but I love Ruby and I think this is one of the big strengths of the language.
Because you can call it without a filter function to remove falsely array elements
&gt; To emulate 100% how PHP behaves you can't just replace dots for arrows. Yes, indeed. This is why I put "Compiles _sane_ PHP to JavaScript" in the headline =) I do not plan to support every PHP-construct but instead will try to limit the stuff that compiles to some "modern and sane" subset of PHP. I probably won't support to pass vars by reference e.g.. Of course, even a "sane" subset probably won't be easy. I'm sufficiently confident that I'm able to emulate array in JS, though. I picked "array" to explore that emulation problem because I felt this to be exemplary for the problem you mention and also to be extremly important even for the "sane and modern" subset I'm looking to support. &gt; If your project plans to run existing PHP code like Wordpress it will have to support all that. No, I do not plan to run Wordpress completely in a browser =) This also probably won't support PDO or curl ever. What would I do with these APIs in the browser anyway? But even wordpress (don't know to much of that though) might have _some_ code that one would like to run in a browser, e.g. html-rendering, some DTOs or validation. &gt; But if despite all that you manage to write such transpiler I'd be really interested in testing it. If you like send me a DM and I'll keep you posted.
I would not use a package with a git log like yours.
I second this.
Here's an example POST request using this library, as taken from the [example directory](https://github.com/PhpGt/Fetch/tree/master/example). use Gt\Fetch\Http; use Gt\Fetch\Response\BodyResponse; use Gt\Fetch\Response\Json; /* * This example uses postman-echo.com do test the request/response. * See https://docs.postman-echo.com/ for more information. */ // Example: Post form data to the echo server. $http = new Http(); $http-&gt;fetch("https://postman-echo.com/post", [ // All of the request parameters can be passed directly here, or alternatively // the fetch() function can take a PSR-7 RequestInterface object. "method" =&gt; "POST", "headers" =&gt; [ "Content-Type" =&gt; "application/x-www-form-urlencoded", ], "body" =&gt; http_build_query([ "name" =&gt; "Mark Zuckerberg", "dob" =&gt; "1984-05-14", "email" =&gt; "zuck@fb.com", ]), ]) -&gt;then(function(BodyResponse $response) { if(!$response-&gt;ok) { echo "Error posting to Postman Echo." . PHP_EOL; exit(1); } // Postman Echo servers respond with a JSON representation of the request // that was received. return $response-&gt;json(); }) -&gt;then(function(Json $json) { echo "The Postman Echo server received the following form fields:"; echo PHP_EOL; foreach($json-&gt;form as $key =&gt; $value) { echo "$key = $value" . PHP_EOL; } }, function($error) { var_dump($error); }); // To execute the above Promise(s), call wait() or all(). $http-&gt;wait(); die("done waiting");
Yikes. You weren't kidding.
Is this influenced by CakePHP?
and i think its beautiful , Good luck with the launch. Docs are clean and to the point like laravel. GL Mate
Pay up and shut up, you ungrateful SoB.
It'll be impossible to search for with that name.
Can you suggest a better name? It's an implementation of the Fetch API, so I thought Fetch made perfect sense.
We do not need another terrible Cake clone. This thing is filled with bad practices and anti-patterns. And, of course, it has **absolutely nothing** to do with MVC. I don't think you even have the vaguest clue what MVC is.
Thank you for your comment. May I point out that in the Change Log it says 'Getting ready for initial release announcement. After the version 1.0.0 was released, I decided to add more functionality and change some design, this led to a number of breaking changes, this only happened as I had not announced the release to the world. '.
Thank you for the kind words.
Because you will read normaly all the commit messages? Or it is just because of it?
Just DI your Singletons. Would be totally the same.
The name will conflict with all the things kek
Yes, I used CakePHP 1.2 and 2.x for many years. The framework is modelled upon CakePHP and Ruby On Rails (which CakePHP is also modelled upon) and a private framework (Nocarbs) which was modelled upon CakePHP 1.x and 2.x
The first thing that strikes me is how professional the documentation looks. It reads well, and feels easy to consume. I opted to use Docker to run through the example, which went smoothly. Five minutes of waiting for things to download and start and I saw the purple header "OriginPHP" on [http://localhost:8000](http://localhost:8000) However, that's as far as I got, because even though using Docker, this is all I saw: **Fatal error**: Uncaught ErrorException: file\_put\_contents(/var/www/logs/development.log): failed to open stream: Permission denied in /var/www/vendor/originphp/framework/src/Core/Logger.php:183 I tried to create a view to get started, but this issue was preventing me from continuing. I'm sure it is easy for me to fix the permissions, but I thought it would be valuable for you to know where a total newbie to the project got caught up, so you can fix the dockerisation scripts.
This looks like a gruzzle http client clone and feels like it.
Yea no wonder. I was using it in the 1 and 2 era, and moved to laravel. It was nostalgic to see ctp, layout property in controller.
Its a lot cleaner than anythingelse here.
He compared wrappers of pdo to pdo. How should that be "comprehensive"
It will be very similar to Guzzle (and the many other HTTP clients for PHP), especially due to the compatibility with PSR-7 ([https://www.php-fig.org/psr/psr-7/](https://www.php-fig.org/psr/psr-7/)), but the purpose of this repository is to provide an accurate implementation of the W3C Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch\_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)).
On the first sight it seems the framework pretty much narrows what you can do with it. And it contains some design flaws. For example one thing that hit me: ``` &lt;?php class Product extends AppModel { public $table = 'productz'; } ``` Why would I want an entity to know a table name. Whats worse it can be modified any time. WTF? Maybe I understand it wrong, maybe this is not the entity but the repository, I am actualy quite confused about the magic how the repositories are obtained. This really stopped me wanting to look deeper, its not very intuitive... Also where is some DI? Also, really? https://github.com/originphp/framework/blob/master/src/bootstrap.php Really? https://github.com/originphp/framework/blob/master/src/functions.php I wouldnt want this...
The donation note is not very pretty indeed. Since you, as a developer, only see the phpinfo() page once (and the end user never at all), it is justifiable for such a valuable product to advertise.
Thanks for raising awareness of the project, I've just donated.
I laughted so hard as i saw that last week.
I love that a "micro" payments model for open source is finally emerging via patreon. $1/month to help xdebug is something I will never notice, but if a couple thousand people do it, xdebug will get much better. A good chunk of Varnish's development is funded by people (mostly companies) paying the "Varnish Moral License". I think of this as a micro version of that. If you work at a company where fulltime PHP developers use xDebug on a weekly basis, I bet you could put the $25 tier on the company card and no one would give it a second thought.
Correct, pardon. The headline said DBAL/ORM and I didn‚Äôt pay close attention to the packages used. I thought the comparison is also with ORM.
Sorry. I think it the logs folder was not created. I thought it was fixed. I will check again. &amp;#x200B; In the meantime, i think this will fix it $ docker-compose run app bash $ mkdir logs
The framework is considered outdated in many ways. This would not change a CodeIgniter 5.x, 6.x, and so on. Modern development paradigms are not taken into account here (or even implemented incorrectly). I implemented my first semi-professional project with CodeIgniter 1.x, but the CodeIgniter team just did not keep up with the times. It's time to say goodbye.
Those are the model settings (Repository) not the entity.
That fixed it for me, but then I get into another permission issue: session\_start(): open(/var/www/tmp/sessions/sess\_dvcomgfmami5up3hsuopraacud, O\_RDWR) failed: Permission denied (13) May I suggest you run through the docs using a fresh Docker install, so it mimics people's computer setups like mine? The beauty of Docker is to ensure every developer is working in the same conditions, so I expect the issues I'm having will be shared by others.
I always wanted to do something like this: ```php $str = 'Hello, World'; echo $str-&gt;toUpper()-&gt;reverse(); // DLROW ,OLLEH $arr = ['One', 'two', 'three']; $filtered = $arr-&gt;filter(function($val) { return $val === 'three'; }); echo $filtered-&gt;first()-&gt;toUpper(); // THREE ``` OO Scalar types would be THE big thing for PHP 8.x
It would be nice if the client was using [PSR-18 ClientInterface](https://github.com/php-fig/http-client/blob/master/src/ClientInterface.php) under the hood, so I can decide if I want curl or something else.
I would like to get the bottom of this, as I am not getting the same issues on my machine when creating the project. Did you create the logs folder from within the Docker container or From your machine. Delete the logs folder, then gointo the docker container and create the folder. I would like to assist. How can we chat.
This subreddit is terrible with constructive criticism. On the topic, I haven't tested the framework so I can't say anything about it. I can say that I liked how clean your documentation is. Certainly good job on that one!
That's a good point. I've already got a Github issue tracking this, please could you cast your vote there? [https://github.com/PhpGt/Fetch/issues/34](https://github.com/PhpGt/Fetch/issues/34)
What can this framework do, what other (established) frameworks can not do? I did not look at everything exactly, but there is a lot that would bother me. Is there a service container? Is Dependency Injection (with Auto Wiring) possible? &amp;#x200B; It's still impressive how many components your framework offers, and you've thought of something that other projects are missing: A good documentation. Good Luck!
I tend to run away screaming when I encounter a functions.php... :D Too much stuff in global scopes and / or publicly accessible (the Controller is way too magic and scary). Docs seem lovely, good job on that. But, as a die-hard Symfony man, not my cup of tea. Way too opinionated.
I have this in the manual at [https://www.originphp.com/docs/models/](https://www.originphp.com/docs/models/) under conventions, I will rewrite so make it clearer about the magic.
Congrats and way to put yourself out there, but this is /r/php where all the retarded neckbeards hangout and be toxic.
Why are you trying to provide an implementation of a browser API for a server side language?
[https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller)
I never search for anything directly on packagist. I'll use one of the regular search engines (usually the big G), and you'll have a hard time getting anything relevant to your package with a name like that there. Discovery usually happens that way, not through packagist.
I personally really enjoy using the Fetch API, and thought others would enjoy using it in PHP too. As far as I can tell, there's nothing in the spec at [https://fetch.spec.whatwg.org/](https://fetch.spec.whatwg.org/) that says this API can't be run on a server-side context.
Thank you for your kind words.
https://github.com/originphp/framework/commit/9709892331e511eaf8ed86be3c63824b0789bc2f "no message", but an argument was removed.
Thank you. What is offers is Performance , scalability, and easy to use. You can build high performance apps very quickly. Documentation (As you pointed out) is clear and well organized (hopefully) - this is also a key to developing fast. If you look at some of the small details, such as using the some of the utilities, things can become painless as the designs are much more intuitive. There are also hidden extras like really good code completion help, out of the box, even with code which has been generated with the code generator, especially working with models in controllers. It contains the core components to build apps, plus a little bit more.
PSR-18 has been approved for a few months now. Why would you now release an HTTP abstraction that does not comply to that? Especially since you use PSR-7 objects.
Yeah, ok, but how they get created? How can I inject dependencies to them? How do I change the entity class?
Just because you link wikipedia, does not mean that you have and idea what you are talking about. - why do your "views" have a dependency on a "controller"? - why do you think that "model" is an ORM instance?
Because if the project can't follow a simple good practice as write good commit messages I can assure you that will not follow good practices in the code.
Don't worry about Cranky McCrankypants over here, thanks for sharing your work!
PSR-18 is excellent and full support is planned ([https://github.com/PhpGt/Fetch/issues/34](https://github.com/PhpGt/Fetch/issues/34)) .
This is the definition of useless code added for no good reason: [https://github.com/originphp/framework/blob/master/src/functions.php#L369-L400](https://github.com/originphp/framework/blob/master/src/functions.php#L369-L400)
This is one of the worst comments I have seen in this sub. I'd expect more comments like this on /r/webdev , but much less on /r/php. You have made absolutely 0 concrete points, and nothing you have said is even remotely constructive (well, you haven't even said much). If you saw it was "filled with bad practices and anti-patterns", it would imply you had time to look through the whole project - and as such, would have time to list all said bad practices and anti-patterns. But you didn't. Which means you either skimmed through a few lines, saw a few things you don't like, and declared "aha! lots of bad anti-practices!", or that you just saw a few things you personally don't like because they didn't fit into your little box of patterns you are familiar with, and you decided it's easier to discard all of it as bad anti-practice patters rather than actually make proper arguments against them that'd probably be dismissed 10 times over. This is not to say I'm endorsing this project personally, but your comment is the absolute worst of this sub, and it tells a bit about the sub that it got upvoted.
Thank you. I appreciate your response. Symfony has functions too, e.g. [https://github.com/symfony/var-dumper/tree/master/Resources/functions](https://github.com/symfony/var-dumper/tree/master/Resources/functions) ;) If i create a file for each function it would just reduce performance and offer no real benefit to users. Re opionated, yes, convention of configuration is not everybodies cup of tea.
And to further extend the "really, really?" thing, it seems you're spoiling global scope with constants of very generic form (i.e. "DS" or "CONFIG") and global functions with weird names (i.e. "h()" or "pr()").
1. It's a great reminder 2. Why do you think you get to dictate what one should and shouldn't? Remove XDebug if you don't like that warning, problem solved. 3. So what if it's written in giant red font? It stands out. It's not like you show phpinfo() page to customers, and in production - XDebug should be off, so you're "safe" from customer seeing a big red paragraph 4. Don't be ungrateful and entitled.
The Model, View and Controller Logic is separated which is the core essence of MVC, that is ok. But you are also saying that to improve i should 1. Not inject the Controller into the View, even though it depends upon various items from the controller, such as request,response and view vars. 2. Set the status codes and body for the response object somewhere else other than the controller Am i understanding correctly?
https://github.com/originphp/framework/blob/master/src/View/View.php#L131 https://github.com/originphp/framework/blob/master/src/Model/Model.php#L255 https://github.com/originphp/framework/blob/master/src/Core/Autoloader.php#L44 https://github.com/originphp/framework/blob/master/src/Core/ObjectRegistry.php#L24 https://github.com/originphp/framework/blob/master/src/Controller/Controller.php#L175 You obliviously have NOT looked at the source code.
1. read about what is "Law of Demeter" 2. the view is responsible for producing a response
You're mental if you think that it's in the same category as being annoyed by ads in phpinfo.
I wonder what the PHP creators would think of this behaviour?
From the docs : &gt; Windows users can use Sequel Pro or Mac users can use Heidi SQL. It's the opposite.
I never knew CocaCola sponsered symfony.. They must have spend a lot of time on the project.
The entity object is simply the result object, you cannot change the class. Database logic remains in the Model class. So you create a model called Product. This is accessible from the controller, as $this-&gt;Product. Any db logic you keep in the model. The entity simply is the result object, which gives some extra feature to work with the entity result. &amp;#x200B; See the demo app src to help get an idea. [https://github.com/originphp/bookmarks/tree/master/src](https://github.com/originphp/bookmarks/tree/master/src)
Like if you were able to read all the "messages" in everything that you use. Good job, i will test it this weekend.
I'll definitely try and help. Reddit has a chat thing now doesn't it?
Seriously. This is some petty bullshit in this thread. xdebug could ship with a picture of the dev's genitalia that shows every time you hit a break point and I would still gladly use it.
I dont think that this is the real world. the code of the cms isnt as bad as the non existing commits. if you compare this code to the other stuff in the reddit this is super clean lol.
A change log is not an excuse for the lack of git log detail. It's nice to have for large broad announcements but you really should get in the habit of detailing each commit. This will make you a better developer, someone more likely to get hired, and more openness to using your opensource project https://chris.beams.io/posts/git-commit/ https://news.ycombinator.com/item?id=18663032 (comments and main linked article)
Its fun! And js was hip and cool for running the same stuff everywhere. The idea behind it isnt so bad.
I looked at those pieces of code you linked. Would you kindly specify what, exactly, is wrong in most of them? Apart in a few unnecessary gets of public variables, which isn't a crime, or allowing dynamic variable names (something that I never recall being called "bad practice" in JS), I don't see anything out of the ordinary in this code..
As you know there are many people complaining about the PHP string functions, see [https://www.reddit.com/r/PHP/comments/c2vall/rfc\_for\_strrstr\_and\_strristr/](https://www.reddit.com/r/PHP/comments/c2vall/rfc_for_strrstr_and_strristr/) And how hard they are to use and remember, these are small little helpers which i have added as convienience at the last moment. Trying to remember the difference between str\_xx or strxx can be difficult for some people. I did not really want to put them in the string class, which many PHP developers are calling for, just wanted it fast. That said i will remove them. thanks for taking the time to look at the code and give feedback.
&gt; What is offers is Performance , scalability This will always get eyes! However, I would suggest you provide some benchmarks of a non-trivial example. Do a couple comparison examples with Symfony and Laravel I think you would get a lot more traction. As it is now, it sounds nice but I have no incentive to test and prove these claims myself
&gt; It‚Äôs always a sprint to get the pattern implemented app wide ASAP before someone commits code the old way. Or, even the dev that created it forgets. With pattern refactoring, you don't care about this at all. The same way they use ClangMR in Google. You create a refactoring rule, that converts all X to Y. If anyone creates code in the old way - X, you don't care about that and just run the refactoring rule. Instant result :) &gt; What I can say is that it‚Äôs boring and tedious work and makes dev employee retention more challenging. This is a factor that must be considered. This is removed with pattern refactoring as well.
I'm not sure what you mean by the \`refactoring rule\` and how the issue of employee retention is solved by this. Can you please elaborate.
1. public variable-variables and method chaining 2. magic getters in core classes and public variable-variables 3. use of singletons 4. magic getter by reference 5. public variable-variables and global state If you do not understand how these pieces of code (that took me about 2 minutes to find) signify the lack of quality for the codebase .... or do not see how those are problem, then I can't help you.
\&gt; People who need these will obviously stay on their php versions for their legacy code It's the simplest part now. Rector removes this problem. If this happens with PHP 8 or PHP 9, there will be set that will replace function names, keys positions instantly. No maintenance, no troubles with upgrading. &amp;#x200B; The difficult part is to agree on the order of arguments, functions names etc. Obviously there are 2 ways to do things.
This is silly, the Change Log details everything, I commit all the time locally, as you can see. Just say hey, going forward you should add a message with each commit, instead of trying to find where i made a mistake and blast me for it. Show me how to improve instead of ridicule me.
This was actually intended to be constructive, that's why I chose specific examples. In the first one, a simple "removed options from storage engine" would suffice.
Simply put, this library was started before PSR-18 was approved. PSR-18 is excellent and full support is planned ([https://github.com/PhpGt/Fetch/issues/34](https://github.com/PhpGt/Fetch/issues/34)), but there are a few questions that I need to answer before adding full support.
To be honest I wasn't going to waste my time reading the code without knowing what to look for. While some of this stuff os bad and clunky, I amd probably enough for me not to use this Framework (if I were going to before), don't make those claims and expect people to just take your word for it, or waste time digging into the code looking for what you talked about. Also, regarding one point - singletons are perfectly valid in many situations. And if you can't see why, and state their existance alone like it says something about the code, because you read some hipster blog on it and blindly repeat 'singletons antiputtorn!' without understanding why it was written, then I can't help you either.
I dont understand what you mean i am spoiling the gloabl scope with generic constants. These are the constants that the framework uses internally, to know the locations, define('DS', DIRECTORY\_SEPARATOR); define('ROOT', dirname(dirname(dirname(dirname(\_\_DIR\_\_))))); define('CONFIG', ROOT . DS . 'config'); define('LOGS', ROOT . DS . 'logs'); define('ORIGIN', ROOT . DS . 'vendor'. DS . 'originphp'. DS . 'framework'); define('PLUGINS', ROOT . DS . 'plugins'); define('SRC', ROOT . DS . 'src'); define('APP', ROOT); define('TESTS', ROOT . DS . 'tests'); define('TMP', ROOT . DS . 'tmp'); define('WEBROOT', ROOT . DS . 'public');
This would let me use that!. Nope it wont change anything. The people are only looking into commits to criticize something. This is no constructive feedback at all.
Why are logs in the web root?
Pretty all software beginns with some random commits without a message. You wont even be mad if he just squash all the commits to one. If its even pre release its totally ok. The people arent looking into the software and bashing hin alone on the commits. Thats so sad.
&gt; Show me how to improve instead of ridicule me. Make coherent and useful commit messages, that detail the changes made to the code. An external change log is great to have, but you need to include changes in commit messages. Look at pretty much any other popular project on Github to see how other projects do it. Also, generally you should have more meaningful commits, instead of just a ton of little tiny commits. Committing often while working is great, but when you go to push, squash those down into meaningful commits. It makes the log much nicer and more readable. If you don't like to work that way, I would encourage you make use of your branches. Your development branch can be loaded up with random commits, but you should have release branches where those are merged in in batches that sum up larger sets of changes. Maintaining a clean repository is very important for a project like this.
Symfony 4 just made me like frameworks again. Its the modular component based "framework" so you dont have to use all the things. Eventually you can take on that approach?
Great point, it makes a lot of sense. I will look into this. For an example in use , see the bookmarks app. Uses about 800kb without debug. [https://bookmarks.originphp.com/users/login](https://bookmarks.originphp.com/users/login) username: [demo@example.com](mailto:demo@example.com) password: secret
I am on the slack channel PHPChat.
Thanks for pointing this out. Corrected.
Thank you.
Do you only read books or do you implement real world software? To make the autoloader a singleton dont smell at all.
Teresko. Lets talk about you what framework do you use? A simple hello world web application consumes how much memory? Is there anything nice that you can say about what i have done? I suppose, next you are going to say its a crime how i redesigned middleware so its simpler to work with [https://www.originphp.com/docs/middleware/](https://www.originphp.com/docs/middleware/)
&gt; Yeah, so why don't we all put some ads in phpInfo Are you the author of one of the most critical and popular PHP modules, ever? Do you have something approaching its usefulness and popularity? If you do, have at it.
Incorrect username or password.
I don't use frameworks. I know how to find libraries on packagist.
So when someone is using the options argument in the framework, and you remove it with no indication, that isn't a problem?
A colleague of mine still use CodeIgniter, but he's 56 years old and he doesn't care to use PHP 7+ because he's used to 5.6. Sorry, but CodeIgniter belongs to the past.
This is the sort of feedback that should be given, helpful and kind. The mistake I made was rely to heavily upon the changelog and ignoring the messages aspect of non vital commits, plus the odd release, where i did put the change message in. I have spent the last 6 months working on this without help, and I think i have achieved a great product, its a shame that I did not know that a little detail like not putting a message on every commit, even in branches was killing point. Also regarding the employer, this is useful advice to many people not just me. So well done. Thanks.
 [https://github.com/originphp/framework/blob/master/src/Core/Logger.php](https://github.com/originphp/framework/blob/master/src/Core/Logger.php) What if i want to change this logger to any PSR logger? Your logger is hard-coded into the framework: [https://github.com/originphp/framework/blob/master/src/functions.php#L257](https://github.com/originphp/framework/blob/master/src/functions.php#L257)
If you think they have their place, keep them! It's your framework after all. But IMHO it's just adding overhead for no good reason. Think also about maintenance in the long term, the less code, the better! :)
Stop posting, your attitude is hurting my eyes
I'm a bit confused why we need the name "pattern refactoring". A "pattern" is not a thing. It's a trait of your code. One component may implement dozens of patterns, and one pattern may be spread over a dozen of components. The question "should we rewrite fully or gradually" suggest a highly monolithic codebase. Because in a modular codebase this question doesn't sit. You can rewrite a component "fully", but in the context of a project with a 100 components, that's rewriting gradually in an isolated spot of code. So first step is identify and isolate components (or modules). Small interfaces on the "outside" of the component, making reimplementation easier (much easier). Then refactor component by component at will. Seems like that covers it all. Or...? What am I missing. How is "pattern refactoring" different here?
If needed you can rewrite the commit history with rebase. But only do this on code that is not online or has not been forked in order to avoir issues and conflicts with others copies of your repository.
I reset the password and disabled saving user details, since somebody changed the password.
Honestly "convert all X to Y" is an awfully fuzzy definition for whatever "pattern refactoring" is supposed to mean. Additionally "convert all X to Y" is a bad change management. The old should be able to co-exist with the new for a time, so refactoring doesn't halt the development of new features and bugfixes in other areas of the code. I'll use your example: you want to get rid of AR models and use Doctrine, or whatever. Fine. Here's it done in gradual steps: 1. Abstract AR by replacing classes with interfaces. The original classes implement the new interfaces. All code looks and works like it did. 2. Implement the same AR interfaces with Doctrine (or another data mapper ORM you choose). All code using the AR interfaces looks and works like it did. Elimionate the original AR classes, they're no longer needed. 3. Gradually replace AR interface use with Doctrine. No hurry. No need for "all X to Y" at once. Every team does their component at their own pace. 4. When all uses of AR are complete, eliminate the AR interfaces and implementations. Change management is the art of changing crucial platform components without disruption. It's like magic, if done right. We don't have to fret about slowdown and interruptions - we just need proper change management.
Please, for the love of the PHP community, when you ask for feedback and get some, read it without lashing out at the person who provides it.. no matter how mundane. Also why is you documents on Jigsaw and not Origin?
Asking for donations I think is fine. It's a bit obnoxious the way it's presented but whatever. The bigger issue to me is that there aren't any guidelines on this. What if tomorrow it's a political statement?
Same.
Developers are notoriously petty. ü§∑‚Äç‚ôÇÔ∏è
Recator it? Nothing starts 100% perfect. All things change with time
Thanks.
First of all nice job and good and clean documentation (also the doc blocks). I worked with CakePHP 3.x and the docs are horrible and not so clean. In the next week I will give it a try.
The last time I used "random commits" was when I was learning git years ago. Yes he would have been better to squash everything and go with "initial commit" however even better still would have been proper commits and thoughts all the way through. Think of it as good developer hygiene. Just because you brush your teeth later in the day doesn't mean you should skip brushing your teeth in the morning. Also, people can both look at the code AND critique how it is put together. /u/jsharief is looking for feedback. I am trying to help. The original comment was poor and nonconstructive I will give you that, but the point remains: that kind of attitude towards the git log raises a red flag with people (or original comment wouldn't be so upvoted) Also it is clearly a needed criticism since his reply was &gt; This is silly, the Change Log details everything
It seems that even if i am working with local branches, and commiting, regardless if when i merge i put a message with all changes, it seems the community want to see a message with each commit even if they are something like 'mega work done' which offer no value as opposed to blank. I would be worried about trying to do something like that and create a massive problem.
Hi, the example you gave is from the var dumper component not the framework itself, and this exact example is just a shorthand for \`VarDumper::dump()\` to be more convenient when developping. &amp;#x200B; The point isn't to make a file per function, you shouldn't make it at all (except if there is a real utility to it, e.g: var-dumper) to not pollute the global namespace. &amp;#x200B; Tbh, i don't believe that someone using your framework will look into the functions.php to see every existing functions that have been declared and keep them in mind. And this could create potential conflicts. In general, people have their habits and will use some kind of library to debug their code, create uuid and so on (which are functions that are declared into your functions.php)
On top of all the other valid comments by others: &amp;#x200B; \- Collection is broken for iterators: [https://github.com/originphp/framework/blob/master/src/Model/Collection.php#L148](https://github.com/originphp/framework/blob/master/src/Model/Collection.php#L148) \- Email is vulnerable to header injection attacks \- Using the broken uniqid call to create filenames [https://github.com/originphp/framework/blob/master/src/Utility/File.php#L101](https://github.com/originphp/framework/blob/master/src/Utility/File.php#L101) \- It uses regex to parse HTML [https://github.com/originphp/framework/blob/master/src/Utility/Html2Text.php](https://github.com/originphp/framework/blob/master/src/Utility/Html2Text.php) \- It has no idea how currency notation works in different countries [https://github.com/originphp/framework/blob/master/src/Utility/Number.php#L25](https://github.com/originphp/framework/blob/master/src/Utility/Number.php#L25) \- It does not understand the difference between salt and pepper [https://github.com/originphp/framework/blob/master/src/Utility/Security.php#L33](https://github.com/originphp/framework/blob/master/src/Utility/Security.php#L33) \- It uses floats for money [https://github.com/originphp/framework/blob/master/src/I18n/Number.php#L67](https://github.com/originphp/framework/blob/master/src/I18n/Number.php#L67) \- No check whether ANSI escape codes are supported [https://github.com/originphp/framework/blob/master/src/Console/ConsoleIo.php#L322](https://github.com/originphp/framework/blob/master/src/Console/ConsoleIo.php#L322) \- There is no CLI escaping whatsoever \- The cache only has global (per cache instance) TTLs [https://github.com/originphp/framework/blob/master/src/Engine/Cache/FileEngine.php#L27](https://github.com/originphp/framework/blob/master/src/Engine/Cache/FileEngine.php#L27) if it even uses TTls [https://github.com/originphp/framework/blob/master/src/Engine/Cache/ArrayEngine.php#L27](https://github.com/originphp/framework/blob/master/src/Engine/Cache/ArrayEngine.php#L27) \- CSRF token validation is vulnerable to timing attacks [https://github.com/originphp/framework/blob/master/src/Middleware/CsrfProtectionMiddleware.php#L109](https://github.com/originphp/framework/blob/master/src/Middleware/CsrfProtectionMiddleware.php#L109) \- Use of magic globals [https://github.com/originphp/framework/blob/master/src/Migration/Migration.php#L184](https://github.com/originphp/framework/blob/master/src/Migration/Migration.php#L184) &amp;#x200B; And that is just from a quick glance.
What is wrong with those global constants and functions? If someone uses this framework it wouldn't be hard to avoid collision with those names. Perhaps the functions aren't perfectly named but that has nothing to do with them being global.
Seeing as Derick is a core contributor, they're probably ok with it
The reason docs are made with Jigsaw, is because i am working full time on OriginPHP including writing docs, and have not had the time for anything else.
No PSR support? Not even PSR-3 or PSR-16?
will do thanks.
The public folder is the webroot.
Well, yes, but sanitized for what? It could even give you a false sense of security: $_POST = filter_input_array(INPUT_POST, FILTER_SANITIZE_STRING); $task = $_POST["task"]; // This was changed $result = mysqli_query($db, "SELECT * FROM tasks WHERE id=".$task); // Easy SQL Injection here
This can be easily changed in the future, probably in the config setting.
I would recommend a DIC
Thank you. I am the slack PHP Chat workspace, you can reach me on there if you need any help.
Probably at some point being able to split the Web App from the Console Commands, but not everything else. I really want this and need this framework to be 1. Easy to use, fast development 2. Good performance - Low memory usage and reading/writing files etc
If you want to sanitize $\_POST array values for use in SQL queries, don't. Use prepared statements.
So feedback nowadays is being a jerk? The feedback provided at the top of this thread is not feedback. It‚Äôs an insult. Would you allow that in a workplace? No, you‚Äôd bring it up in a polite manner. Being offensive is not a good way to make change as the person will get defensive, I think OP has handled it pretty well. Most people would just say, I‚Äôm right you‚Äôre wrong and not learn anything.
I can't see anyone who is offended by even seeing a message from someone who's work they are using actually taking the time to fork it. Even if they did, the experience of maintaing forks could be a win for the maintainer too. To keep these forks up to date, the forkers will have to merge in the upstream and be exposed to the number of commits and work that goes into improvements and big fixes. If they share their fork, they'll have to deal with other users complaining that updates aren't happening fast enough.
This is /r/PHP where when one ask for constructive feedback they are actually looking for praise and glory. Do not confuse it with people genuinely asking for constructive feedback instead of getting salty. &amp;#x200B; The best we can (/ should do) is steer innocent people away from things that are outright dangerous or just plain wrong.
A overview glance looking good. Keep adding newer features.
Yeah, I was going to say something similar. If your POST structure is so untrustworthy, you need much more specific checking.
The usage of global constants without any namespace prefix means that the framework will collide with any other library or framework package that also happens to do the same. They're being declared globally but will likely only be used in a few very specific places. The usage of constants means that those values can't ever be changed once they're defined. If, for example, you wanted to put the logs in a different directory based on the environment being run from or whether it's being run as CLI or Web, then the framework file has to be locally modified and committed somehow (or, if you pre-define them then this will error out). This pattern also encourages people who use the framework to define their paths the same way, which mixes usages and could cause collisions in the future if the framework decides to introduce a new path that collides with a constant the user started using locally.
It's worse than useless as it mangles totally valid utf-8 encoded data willingly.
I recently came across this brilliant article on the matter. Since me and my team started using this a guideline, our repositories got so much more readable. I'd definetely recommend to read it :) https://chris.beams.io/posts/git-commit/
I disagree. This is what the feedback should look like, it \&gt; I have looked at your framework and i think you should focus on adding messages to each commit regardless if it feels pointless, this is a good habbit to acquire. I will not use a product which does not follow this. Here are some good resources on git best practices etc. \&gt; You are over committing, and not putting messages in commits. This is off puttting. \&gt; I don't think you should be generating the response inside the controller, this should be in the view \&gt; I have seen a number of practices that are considered bad, these are \_\_\_\_ and by doing \_\_\_ you can make things better. \&gt; Despite seeing that you have used references and some static calls, and for some evil reason, you used some public properties, you have done this \_\_\_\_\_
I have added to list. Thanks.
I used to use mysqli, but I've recently switched to PDO, because I heard that it's more secure than mysqli. The rumor is that writing something like this will already be secure, because it's built into PDO `$this-&gt;db-&gt;query('INSERT INTO users (username, email, password) VALUES (:username, :email, :password)');` `$this-&gt;db-&gt;bind(':username', $_POST['username']);` `$this-&gt;db-&gt;bind(':email', $_POST['email']);` `$this-&gt;db-&gt;bind(':password', $_POST['password']);` &amp;#x200B; But I don't know if that's true, that's just what I've seen recently. The problem is, it's so difficult to get FACTUAL information on the internet, because everyone has a different skill level. So one person could tell me "this is wrong", but that same person could be wrong and ill informed.
declare StrictTypes is crucial for me. It is not implemented.
Squash everything in one commit call it initial release then the ppl. focus on your code and not useless commit messages. Of course its not nice the no messages commits but considering that even bigger frameworks just start in the middle this is not a big deal.
I want you in my code reviews.
This is interesting...and a lot of work. Thank you for posting it. But I'm sorry to say I don't think the PHP world needs another framework. If I want to start a new project I pull in a few libs, Slim, and whatever else I need. I have a project skeleton generator that pulls in many wonderful, performant, PSR compliant, PHP projects. &amp;#x200B; I think this is a lot of work that you've done and it's impressive the time and commitment made here, but I would caution developing something like this in isolation. There's a lot to learn from the community and by the time you get to the "Here's the framework!" stage it's too late to back peddle on some assumptions without breaking changes or large / risky refactors. &amp;#x200B; Apart form any major architectural concerns (of which I have many) at the very least you could have implemented PSR interface specs and a DI. I see you honor the method names in your Logger, for example, but don't specifically import and use the PSR interface. In fact, I couldn't find a single interface at all. That means your project can't and won't benefit from any other project's code and that's an alarming assumption on your part. Is your code really better than everyone else's at literally everything? &amp;#x200B; But back to my original point...if you had contributed to CakePHP, Slim, Laravel, Symfony, etc. the community here would get more benefit from your work. I see you're in love with performance and I'm sure there are some performance wins you could contribute to those frameworks. What we've got now is a brand new framework that doesn't offer any PSR compat, is in love with itself, and is going to be riddled with bugs. The frameworks already out in the world are fairly hardened from being used so often. It's a huge fresh start for not a lot of gains. &amp;#x200B; I totally understand that it's fun to completely roll your own, but I just don't see what this offers for teams and businesses. Performance has been the smallest (by issue count) problem I've ever faced. What slows my team down is poorly designed, highly coupled, clever / performance driven (unintelligible), untested, brittle code.
Okay looking more through the code. Is this highly inspired by cakephp? Part, patterns, structure of the code are almost the same like cakephp. Even some class names. I like cakephp therefore your code...
Thank you for this, I will look into all these things. Note: \- I am first release, done this all alone with no help. \- The Html2Text is an old class of mine, that I slipped into the framework before launch to ensure that Email utility meets the objective for release, it does the job and will be rewritten in future. \- Currency Notation. Originally I used the Intl extension, however i came accross a number of issues and found it not really reliable, for example ([https://bugs.php.net/bug.php?id=77733](https://bugs.php.net/bug.php?id=77733) ) . Saying that, I am using a hybrid approach, see [https://github.com/originphp/framework/blob/master/src/I18n/I18n.php#L91](https://github.com/originphp/framework/blob/master/src/I18n/I18n.php#L91) This will automatically create the currency be used by country locale. The IntlNumber formatter class I have kept incase somebody just needs to format, but using for other things I am staying away from it. &amp;#x200B; thanks
This. I use "Brightness controller" on Ubuntu and Flux on Windows to dim the screen and save my eyes. Bonus: it works everywhere, not only in PHP Storm!
So sorry, it was just a mockup, by all means never use mysqli. PDO is the a great alternative. My advice is: don't look only into "what's best" but also about why something is the best, the reasoning behind it. For example, I just told you PDO is best, but didn't tell you why, so this could be just an uninformed opinion, which is useless just because of this possibility. This is why when someone says "this code is trash" it is so very pointless: I don't know if that person has 5 years of experience or zero. Now, mysql is a vendor variation and PDO is an interface for accessing databases (not for a specific vendor), PDO means **P**HP **D**ata **O**bjects and by using PDO you have flexibility on which sql provider you use (for example: PostgreSQL, SQLite, MS SQLServer, etc). Not only that, but binding, named parameters and other features of PDO are superior and easier and safer to use. Safety is important because of how frequent SQL injection were in the past, it was like a plague and every old system should be tested against it. Hell, I still have to use public systems today which are very susceptible to SQL injections.
I have been thinking about this post and I was just wondering... A framework like Symphony is built out of decoupled components that can (and will) be used completely seperately of each other. A component like Symfony's http-foundation is being used by Drupal and if I'm not mistaken also by Laravel and many more. If I need http handling somewhere I install that package of off we go. You wrote a whole new http foundation in your framework that is currently not capable of being used standalone (which is a downside if you ask me). If your code is better, lighter, faster or whatever: wouldn't it be better to contribute your insights to Symfony's http-foundation instead and that way helping a whole big community, instead of creating a new one? The above ofcourse works for every little component you have written. I believe we should strive for standardation and contribute to all the good work that is already out there instead of re-inventing the wheel. That is apart from the fact that - as a programmer - I do ofcourse understand the fun and learning you can get out of writing your own framework :) What are your insights on this?
By refactoring rule I mean mostly AST rule, e.g. rename method, add argument, replace static call with dynamic call etc Basically anything you need to do, when you upgrade or refactor PHP code.
Why dont you help by making issues? you took some time to look through all that. So share your helps there will help.
If someone find a a bug with a proper git history he can find the commit that introduced the bug just looking at the message. Let's say you have a recent commit with "feature: improve email templating", If something strange happens after upgrading to the email system well... The commit is right there with a self explanatory message. I can look quickly at the diff and search the bug.
Coverting X to Y means exactly what you've described. E.g. Active record to entity + repository. Old code doesn't exist anymore, it's instantly refactored by AST rule. That's the mind shift. You refactor one pattern to another, X to Y, AR to non-AR.
Is there anything that you liked? Also regarding what you said of magic globals: [https://github.com/originphp/framework/blob/master/src/Migration/Migration.php#L184](https://github.com/originphp/framework/blob/master/src/Migration/Migration.php#L184) I am offering a framework, for development. This function makes it easier for the user to develop with, without having to remember stuff, and it follows a standard used throughout the application for getting objects. public function connection() { return ConnectionManager::get($this-&gt;datasource); } Sorry, but I don't understand why you say this is bad?
Sounds a bit auto-magic like. How are these "rules" created and "run"?
That's exactly the mind shift issue. Most people think in files or classes. There is ProductController and we need to do something about this one class. That's where you use gradual refactoring. It's very expensive and not practical nowadays. Typical representative of such paradigm is what you've written "that's rewriting gradually in an isolated spot of code" Instead, you go for a pattern, e.g. a controller. You refactor all the occurances of the pattern in your whole code base. For exact same cost as one class
Sorry I am not following 'Squash everything in one commit call it initial release then the ppl.'
Because this isn‚Äôt a serious project, clearly.
This looks very good, I am going to read it and bookmark it. Thanks.
&gt; I am first release No it is not. It's a stable release (v1+) and there have been numerous releases: [https://github.com/originphp/framework/releases](https://github.com/originphp/framework/releases) &gt; done this all alone with no help That is no excuse to release vulnerable software in the wild. &gt;The Html2Text is an old class of mine \[snip\] it does the job No it does not do its job... Your broken regex non solution fails already for something as simple as elements having attributes. &gt;Originally I used the Intl extension, however i came accross a number of issues and found it not really reliable, for example That bug report is about dates, not currencies. Also it seems to me &gt; This will automatically create the currency be used by country locale. No it does not, because it is keyed based on the [currency](https://github.com/originphp/framework/blob/master/src/Utility/Number.php#L103) and not a locale. ‚Ç¨ has different positions in different countries / locales.
Hey, phordijk, just a quick heads-up: **accross** is actually spelled **across**. You can remember it by **one c**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Thank you for the clear explanation. This makes sense. p.s the logger allows you to change log file etc. This is just used for the default place.
&gt;Sorry, but I don't understand why you say this is bad? Because magic global state is bad. It: * Hides dependencies * Results in flaky tests * Makes things hard to test * Tightly couples code * Results in flaky run time
delete
Why not? In general this code is good. He worked a long time on that alone. Its now gonna public and i bet he would like to see some other guys posting there. its not like you didnt have the 10 seconds for 1 more shitpost.
i dont know the others but kirby will win. I played that a lot.
Woah, hostile. Look, I‚Äôm not gonna go back and forth with you, because you‚Äôve already shown me how you debate. If you read the rest of the comments, especially the top, you‚Äôll see a number of reasons why this is a dangerous framework to use and it is, at best, pre-alpha. More like hobby level. It‚Äôs very doubtful that this person will maintain it to beta, let alone continue the development after its release. You seem to be complaining about my negativity, but you respond with negativity. That‚Äôs not going to get you anywhere. Goodbye/block.
Actually I forced into my own framework many years ago, when CakePHP decided to go a different direction, whilst things use to be piece of cake with Cake, now you need a PHD in my opinion. Having a framework that is easy to use and develop fast with, and performs well is top priority for me. But I understand where you are coming from.
hahaha gg
Yes. It is. Originally when I set out to do this i wanted it to be compatible with all my existing CakePHP apps and for CakePHP 2.x users to be able to use this without a learning curve. Then I decided to switch to objects, which I had to then look at CakePHP 3.x. Many function names are the same, the same design pattern structure etc. It modelled upon CakePHP and Ruby On Rails (Which CakePHP is modelled upon).
ppl. = people ```` rm -rf .git git init git add README.md git commit -m "Initial" git add . git commit -m "WIP: Initial release" ```` If you would do this then people can't complain anymore because there are only two commits.
I didn't say files and classes, I said, and very deliberately, "components". Components are cohesive units that are loosely coupled to other components, making them ideal for isolated refactoring. I'm sorry but your analysis that gradual refactoring is "not practical" is just nonsense. I seriously doubt you've worked on a large project that's used by hundreds, let alone thousands, or god forbid millions of people. Halt everything so you can "refactor a pattern". By the way, a "controller" is not a pattern. The MVC is the pattern. And if in a typical MVC app to "refactor the entire pattern" literally would mean to rewrite the entire app in one go. I'd suggest stop inventing B.S. terms and start reading on change management and how big companies evolve large codebases with many users. Here's the thing about refactoring small CRUD projects, blogs and so on: **it doesn't matter how you do it**. So I wouldn't get too excited about something you believe you've invented, simply because it works on a small project. Make it work on a giant project while keeping everyone afloat and happy, *then* write a book about it... I'll read it.
just make a wrapper class if you want . /thread
Really? Check out the code coverage report. That is how serious this is. [https://www.originphp.com/assets/images/coverage.png](https://www.originphp.com/assets/images/coverage.png)
Are you sure? He scares me. lol
Give the guy a break, he's literally only been working on this since march \[per the releases\] and at least he's asking for feedback and looking to improve it. That's more than can be said for most of us.
Not OP, but the author **explicitly** came looking for feedback. OP took the time (which has value in itself) to review the code and provided said feedback -- at this point I'd say it's up to the author to choose what to do with it. If that means making issues to track, then so be it.
I am getting the impression you are just trying to smear me. $string = '&lt;p class="foo"&gt;Abc&lt;/p&gt;&lt;h1 class="phordijk-is-wrong"&gt;My Heading&lt;/h2&gt;'; pr(Html2Text::convert($string)); // Outputs Abc My Heading
Keep improving it. You got some good feedback here, even though people were kinda douchy with their opinions. I don't know why PHP devs always have to be so salty. Fuck....most of them are not creating anything like this that other people can use, but they're just ready to come talk shit to someone who is. Fuck em. Keep working on it. Keep improving it. Take the feedback and create tickets and fix all these things. In six months repost it again and shove it in their faces so they'll shut up. Just don't give up like they did.
&gt; It‚Äôs always a sprint to get the pattern implemented app wide ASAP before someone commits code the old way. Or, even the dev that created it forgets. Which should by itself demonstrate something is wrong in this approach... Refactoring shouldn't feel like you're starring lead role in a Die Hard movie.
Yes suuuure... That must be it. I did my job trying to warn people of this utterly broken project and trying to answer your questions and point out the many many flaws. If you think I am trying to "smear" you all I can say is: good luck with your project... You are going to need it!
Regardless of what others have said so far, it's not type safe. I won't use it simply because of that. Not making use of that language feature is a huge nono for me.
Hi r/PHP... popping over from the frontend React &amp; Angular world. You guys are f@!king brutal with your feedback FYI. Maybe be nicer instead of gating it by expecting people to roll out perfect frameworks on their first post? OP, any iteration over the current landscape is good. Check out ExpressJS‚Äôs first commit message...
Is he literally saying he has scripts that do the refactoring with no human involvement? I mean this *is* something people do out there, for example Apple's Swift language regularly changes APIs and syntax and the IDE upgrades the code for you automatically. Two things though: 1. Swift is very, very strongly typed. Which makes this possible. 2. There are still edge cases where of course this might blow up, so you still need to test and fix up by hand some things.
AST rule in a dynamically typed script like PHP? I mean we're in r/PHP not r/Haskell right? So no, you can't just write an AST rule. You'll catch a few instances, you'll fuck up the rest. You need humans for this work.
Interfaces are great, but by no means define a pattern. And while I may be reading and interpreting ‚Äúpattern‚Äù differently from the OP, for us, patterns define a lot of things, almost everything. We have a naming pattern for directories/files/variables/tables/everything. We have repository patterns, factory patterns, trait patterns, ways of dealing with our ORM for schema, migration patterns, the list goes on. The point I‚Äôm making, at least for us, was that there isn‚Äôt any way, that I‚Äôm aware, to enforce these patterns, aside from actually making them so dominant, it‚Äôs just ‚Äúthe way it‚Äôs done‚Äù. That‚Äôs where the sprint comes in, because if a pattern doesn‚Äôt take enough of a dominant role in the codebase, it can easily be forgotten or overlooked. I‚Äôve seen this happen many times with competing pattern/approaches.
If you want to only add commit messages when you merge your code back to master, use `git merge &lt;branch name&gt; --squash`, this will squash all your commits into a single commit that you can detail. It's better to document everything with individual commits, though. Your commit history is your documentation on *why* things were changed, if you use it right.
That‚Äôs what I was assuming. But once the refactor/script has run across the codebase, why would there be a need to run it again. Why would someone commit code using some old pattern that isn‚Äôt even in the codebase anymore. Also, how would a script be used in an iterative refactoring approach?
I have created this, because I need a framework that is easy to use, intuitive, fast to develop with and powerful at the same time, Whether build a HTTP app or console application, it just works - There is nothing like that on the market right now in PHP. Lets look at the Middleware standard, the first one, was prone to issues now the new standard has come out. With a slight redesign I have made middleware simple. (You can use handle/process instead of startup/shutdown) Look at this: [https://www.originphp.com/docs/middleware/](https://www.originphp.com/docs/middleware/) That saves time, and is easier to develop with. That what my framework is about.
Thanks.
Thats good advice, that what i am doing now.
Thank you so much for your support.
&gt; We have a naming pattern for directories/files/variables/tables/everything. We have repository patterns, factory patterns, trait patterns, ways of dealing with our ORM for schema, migration patterns, the list goes on. I think if we start using more conventional words for this like "conventions" and "standards" we'd understand each other better. Nobody calls their directory layout a "pattern". Until now I guess. &gt; The point I‚Äôm making, at least for us, was that there isn‚Äôt any way, that I‚Äôm aware, to enforce these patterns, aside from actually making them so dominant that it‚Äôs just ‚Äúthe way it‚Äôs done‚Äù. Enforcement of these practices and conventions is in my opinion the job of two things: 1. You need to design your code so that compliance becomes natural, i.e. path of least resistance. Interfaces have a great role here. But also you can design your autoloader to require certain directory layout and so on. 2. That's the job of the architect (or lead programmer, in smaller studios). Someone has to review commits and give feedback. No way around it. But I do take pleasure doing as much as I can the first way. Honestly you can encourage compliance through code architecture in surprisingly effective ways. Most people aren't even scratching the surface. For example, one way I've found is extremely effective in enforcing who uses which dependencies in which component etc. is dependency injection. Not "DI containers" mind you, but "real dependency injection". Where me and the other side decide on a constructor and that's it. Can't tweak it and add more stuff willy-nilly. No singletons, container access and static registries either.
I am using Source Tree, I think i need to figure out how to do this with that in a consistent manner. I am going to try and find an option to force me to put a commit message in on every commit. Thanks.
This is a huge security hole. Now every web server needs to be configured to exclude serving sensitive directories.
yes, I am doing this. Even the abusive stuff, I am translating into a action.
Hi doing now., I'm dad.
I don't know, I mean we all have refactored with regex, and using static analysis (which uses the AST) in IDEs, but it's still very much a human-driven and gradual process. "Instant refactoring" only works on small projects. Heck large projects are not even in a single repository (unless you're Facebook and have a monorepo I guess).
Clearly, PSR-3 and PSR-16 can be useful and wont effect usability. I am adding this to my todo list.
If he just admitted his mistakes, it'd be ok. But instead he's like "this is release #1 so buggy insecure code is ok". Not cool. Also I don't think the world needs another badly written framework.
Makes sense for the paths, those really should be configurable. But I don't buy the namespace pollution. Libraries shouldn't and usually don't pollute the global namespace because you might want to install multiple libraries without collisions. But it is perfectly fine for the application itself to use the global namespace and since applications tend to use at most one framework it is okay in my eyes for the framework to use the global namespace. Especially for defining convenience constants like `DS` (assuming that is even needed, doesn't PHP translate paths automatically?) and `ROOT` or debug functions.
Cheers!!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What was not constructive about phordijk's criticism?
I'd like to give him the benefit of the doubt. If he's already put 3 months of work into it and has a good site, good documentation and is asking for feedback, at least it shows he's trying? If he comes back in a few months with all those issues fixed, wouldn't that be a good thing? I do agree we don't need more crap frontend stuff....there's already far too many.
[Combining getters and setters](https://github.com/originphp/framework/blob/645bcc9c01394d4b3e74a0e5a15810483609ce9f/src/Core/Logger.php#L52-L64) into a single method can lead to surprising results for developers. Embrace the single responsibility principle everywhere possible. The minimum PHP version for the framework is at end of life. Bumping the min to those still [actively supported](https://www.php.net/supported-versions.php) will encourage best practices. Testing dependencies are [intermingled with the core](https://github.com/originphp/framework/tree/master/src/TestSuite). Split them off completely into ```tests```, configure [Composer's autoload-dev](https://getcomposer.org/doc/04-schema.md#autoload-dev), and update your .gitignore to exclude the entire ```/tests``` base directory. On a broader note, splitting the framework into multiple packages and embracing dependency injection will make it versatile and easier for developers to pick up.
Then change all the releases to alpha/beta &amp; not a 1.x tag.
100% agreed. I can't believe (well... I mean I can, and do) you're getting downvoted for this. It's so aggravating when people choose only to pay attention to 50% of what you're saying, and then change your words to somehow out you on a "side" you never took. Xdebug is sweet, and deserves money, no denying that. Putting an obviously out of place eyesore of an ad into system information is just plain scummy. If it were simply it's own row in the xdebug information, that would be totally acceptable, as we have links in all sorts of software printed with version and author information, etc.
I've encountered scenarios in the past where I've worked in projects that needed to have multiple frameworks running at the same time. When migrating to a new framework or a new version that isn't backward compatible there would be one Controller in the new (or old) framework that would then invoke the other framework and return the response as its own. It's a good way of switching API engines when going from `/v1/ to `/v2/` as well and you might still want to share some of the code between each engine. This was especially true when moving from a homegrown internal framework that might also have its own constants defined. &gt; assuming that is even needed, doesn't PHP translate paths automatically? Yes, it does. I try not to run PHP from within Windows, though, so I can't say with much confidence than "should". :)
See also https://github.com/dlsniper/forked-php-orm-benchmark (I have a fork with Atlas included at (https://github.com/pmjones/forked-php-orm-benchmark)
Rather have the truth than nice words telling me to merge without worry.
Yea, his points were valid. Still, it's gotta hurt when someone grabs your balls and squeezes them so hard.
Oh, absolutely, especially on something that OP is obviously passionate about.
I flip back and forth based on how glossy my monitors are and how bright the environment I am in is. Dark mode in a dark room or light mode if I am outside or in a room with plenty of sunshine coming through the windows.
I ended up buying a colorimeter, cost around ¬£100 (colormunki, essentially a slower i1 display pro) and as well as having the brightness at the correct level my two external monitors and laptop match very closely.
Yes, PHP. You can, yet not many people know about it and still migrate the old manual way, that is extreemly slow, unreliable and expensive. &gt; Also it'd have been nice if you covered what you wrote your "AST rules" in and how they look. This is the most common and simple one one to change a method by type, e.g. `EventDispatcher-&gt;dispatch()` to `EventDispatcher-&gt;dispatchEvent()`: https://github.com/rectorphp/rector/blob/d5ba035db10a56ff3df223f41812bc233050dafa/src/Rector/MethodCall/RenameMethodRector.php#L71-L88 But it can scale to more complex like [stdatic method to service method passed via constructor](https://github.com/rectorphp/rector/blob/master/packages/RemovingStatic/src/Rector/Class_/PassFactoryToUniqueObjectRector.php).
It's not about "knowing about it". I actually have used AST implementation for PHP and even written toy languages from scratch. That's not the point. There's no AST rule to analyze the runtime type of an argument that's not typed statically.
Exactly as zimzat said. Just the fact that this is a framework, doesn't make it right to spoil the global scope. It doesn't have to collide with what a framework user writes, but with libs that the framework user imports. If you admit that it is bad idea to spoil global scope by a lib, I don't understand why you think differently about a framework? It's all third party code for the users. Isn't there even a psr saying all vendor code goes to vendor namespace?
&gt; I'm sorry but your analysis that gradual refactoring is "not practical" is just nonsense. What makes it "not practical" exactly? I do this almost on a daily basis, give me your insight. If refactoring of 1 case and 100000 cases has different complexity, you're doing it wrong. With pattern refactoring the complexity is constant. &gt; I'm sorry but your analysis that gradual refactoring is "not practical" is just nonsense. What makes it "not practical" exactly? I do this almost on a daily basis, give me your insight. That's a typical reaction because it seems way too simple. I understand that. I'm surprised myself this is not yet spread in PHP, but it's possible this technology is already used in private vendors to commercial benefits without putting it out for free. We've already migrated PHP project from one framework to another. &gt; I seriously doubt you've worked on a large project that's used by hundreds, let alone thousands, or god forbid millions of people. Halt everything so you can "refactor a pattern"? No. The amount of people/code/classes is not relevant. If it's at least PHP 5.3+ code of course. &gt; Make it work on a giant project while keeping everyone afloat and happy, then write a book about it... I'll read it. I know this will take time, I'm getting there and book after 5-10 case studies in a plan of course :) Next one is Zend 1 to Symfony 4. Btw, much simpler than migrating Laravel &lt;--&gt; Symfony.
With php-parser and AST.
&gt; no human involvement That's too much ideal, I think human is always needed and the best is the cooperation of both worlds. &gt; Apple's Swift language regularly changes APIs and syntax and the IDE upgrades the code for you automatically Exactly, Google does it at least since 2013 (by first public mention). Just imagine it's not IDE based, but rather CI-based. Instead of one project opened in IDE, it's the number of projects the server (or AWS) can handle. If we'd take it to the extreme and somebody would pay for the machine time on the AWS, all PHP projects on Github could be upgraded to PHP 8 the day PHP 8 will be released. That's already possible now.
$con=mysqli_connect($this-&gt;host,$this-&gt;user,$this-&gt;pass,$this-&gt;db);
Seems like a missing include/require
&gt; why would there be a need to run it again Because it's not only limited to the single upgrade. 2 things are continual: - PHP, frameworks, packages and software develops; the more OSS you use, the more you're vendor locked to know the ugprade path - Pick anything that you've mentioned at least twice in code-reviews and can be automated. The continual CI would check every PR for: - new PHP - new Symfony/Laravel/Zend/CakePHP... - constructor injection over static - composition over inheritance - entity + repository use over active rector pattern - interface over implementation - autocomplete of known type declarations - protection to SQL injection - auto CSRF - etc. All you'd do is just hire junior PHP devs that can create classes and click "OK". The time you'd save by this you could invest into real mentoring/coaching of your developers, that only you can do. It improves your team in scale.
&gt; If refactoring of 1 case and 100000 cases has different complexity, you're doing it wrong. With pattern refactoring the complexity is constant. You're extremely arrogant to call me "wrong" when you haven't even bothered realizing your AST approach only works for very simple 1:1 mapping cases, where the original call is statically typed. This actually represents maybe around 1% of the refactoring I do on a daily basis. And by the time I open a file to start testing and debugging AST rules, I would've gone through and refactored it all with a simple regex search. Additionally in a large project you don't control all the code. You have component, and N users of it. You can't just centrally access all those repositories and squeeze them through your AST transform. &gt; Next one is Zend 1 to Symfony 4. Btw, much simpler than migrating Laravel &lt;--&gt; Symfony. You want to write an AST transform that converts Zend 1 to Symfony 4... Do you realize you're not the first one to do this and your approach is extremely restricted? I remember actually Microsoft pushing their C# to PHP converter at one point, when trying to convince people to use Windows Server. The code it produced is garbage, of course. But I'm sure you're much smarted than the tens of thousands of PhD software engineers in a multi-billion company and you have solved this somehow, and your AST rules produce excellent code. Just kidding.
Remove the `$` in front of `mysqli_connect`. It's not a variable.
&gt; I don't know, I mean we all have refactored with regex, and using static analysis (which uses the AST) in IDEs, but it's still very much a human-driven and gradual process. Exactly, that's very crapy, single-human locker, slow and thus expensive. &gt; "Instant refactoring" only works on small projects. If we think in "manual refactoring" paradigm that is deprecated, then yes. If you think in "pattern refactoring", the size doesn't matter for pattern refactoring. Multiple repositories doesn't matter again. Complexity for 1 repo = complexity for 100 repo.
&gt; There's no AST rule to analyze the runtime type of an argument that's not typed statically. You can actually deploy one rule to check these types, collect them at 1 % of requests and week later autocomplete them. That's pretty easy. &gt; Your examples are mostly catching static calls. Which is fine, but good code already DOESN'T HAVE these static calls. So you refactor once, get rid of statics... and then your approach ceases to be useful. The code quality or developer skill doesn't matter. You take care about this for the developer.
Maybe someone should write a lib like phpcs that does this.
How about we continue this conversation when you get off your cocain high.
That's already in PHP CS Fixer and it's very crappy. Slightly beter one is https://github.com/PHPCompatibility/PHPCompatibility, but still based on tokens (strings)
&gt; Exactly, Google does it at least since 2013 (by first public mention). It's not "exactly". I said Swift is strongly statically typed. PHP isn't. That throws a giant wrench in your plans.
&gt; it seems the community want to see a message with each commit even if they are something like 'mega work done' which offer no value as opposed to blank. No. You're still missing the point. The community wants to see meaningful commit messages for each commit, which describes the work that was done. Also you realize you can have more than one line right? Typically you'll write a short summary which is &lt; 80 characters. Just briefly describe the work. Maybe you're completely a ticket so you can put the ticket id, with a descriptor, something like that. Then, you can add more detail beneath, separated by a blank line. You can write as much as you want here. Describe the work done so that someone could just look at the commit and understand what changes were made, and why they were made. You may think this has no value if you're the only one working on your stuff, but when you start maintaining a public repository, or working as part of a team, this stuff is very important.
&gt; You're extremely arrogant to call me "wrong" when you haven't even bothered realizing your AST approach only works for very simple 1:1 mapping cases, where the original call is statically typed. Please don't take it personally, it's a matter of knowledge and I've met just very few people who use AST to instant upgrades to its maximal potential. Myself I've "migrated" the #1 one commercial drugstore project manually from scratch, that turned into for 3,5 years. Now it would take 1-2 months with AST tooling. &gt; Do you realize you're not the first one to do this and your approach is extremely restricted? If you have some open-source solution, please share. I'd love to inspire and skip few blind paths. In my surrounding, it's the most requested migration that many people are lost int. Mostly because they've learned something new in the last 10 years. &gt; To the rest of us, it's like someone running around telling us he invented sliced bread, and we just can't comprehend how awesome sliced bread is. Yes, I'm new to this for last 2 years and excited. I haven't found any OSS and free solution that would have the features I've described. If you know about one, please share, so I don't reinvent the wheel :D
Thanks for the constructive debate! It's very inspiring and challenging to try to convince people who know AST about its potential.
That is terrible advice, please nobody listen to that.
&gt; You can actually deploy one rule to check these types, collect them at 1 % of requests and week later autocomplete them. That's pretty easy. "Deploy one rule"? Is it hard for you to name specific technologies and software, or must you always speak in this vague abstract language? Thing is you can't deploy shit because if there's no static way to determine type, there's no static way to determine type. Here's a simple scenario: interface Foo { function hello(); } interface Bar { function hello(); } function test($a, $b) { $a-&gt;hello(); $b-&gt;hello(); } Now. I need to change the name of method Foo-&gt;hello() to -&gt;helloWorld() and preserve Bar as-is. How will your magic "rules" change the code in function test()?
That's not what I reacted to :D The language limits are what we work with, of course.
&gt; "AST has limited utility in a dynamic script" What do you mean by that?
I posted a code sample elsewhere in the thread. Solve the problem and you'll figure it out. Maybe.
How did you figure all that out? &lt;o&gt;
Do you need an example? No problem. Imagine you have code with no tests, no docblocks, no type declarations. I'd say 95 % of the production PHP code out in the wild. I barely see this OSS as well. It's not static analysis, it's recorded type. ```php public function someMethod($unknownType) { TypeStorage::rectodType($unknownType, __METHOD__); // code } ``` This takes: - 5 minutes to deploy - week to wait to collect types at fraction of request - 5 minutes to autocomplete certain types - 1 minute to remove
Done :)
Oh so your INSTANT REFACTORING takes "one week". In which week: - Your production code runs with tons of debug logging code inserted, doing extra IO and slowing it down (not to mention the risk of side-effects). - The code in question may never run. - The type information you collect may be conflicting (i.e. $unknownType is multiple types, not just one type, depending on runtime conditions), based on configuration that may change, or countless other variables you're ignoring. So we waited one week, slowed down our site, and we may end up with code that bombs the moment it's deployed. Good job?
Hmm, no.
Convince me to use your framework over Laravel :)
What directory is the root directory that I need to set my start script to have: `heroku-php-apache2 /` &amp;#x200B; I am getting this error in the logs: `Cannot serve directory /app/: No matching DirectoryIndex (index.php,index.html,index.htm) found, and server-generated directory index forbidden by Options directive, referer:` [`https://dashboard.heroku.com/`](https://dashboard.heroku.com/) &amp;#x200B; I tried to have my start script as: `heroku-php-apache2 /public` since it has a index.php file but I am getting an Internal Server Error 500.
Mysqlli is not a variable
thanks a lot, got it!
That's one of the specific solution you asked for.
Their `encrypt()` and `decrypt()` is also vulnerable to chosen-ciphertext attacks.
The performance issue is the smaller issue. You ignored the elephant in the room. Let me repeat again in a more systematic way: - You may get zero information for many variables (code doesn't run that particular week). - You may get "type X" for a variable, this doesn't mean it's not "type Y" in some circumstances. - You may get "type X, Y, Z" for the same variable. Furthermore the even bigger flaw in your approach seems to be: good code doesn't have thousands of similar calls to framework code scattered around. This only happens in projects that lack architecture in the first place. No AST rule will refactor that code into something better. That will take humans (who also need to be good software architects).
The elephant‚Äôs trunk is able to sense the size, shape and temperature of an object. An elephant uses its trunk to lift food and suck up water then pour it into its mouth.
it's literally 2 lines of code, you just rebase on master and fix them again, probably take all of 38 seconds once a month.
Look earlier I was upset, because whilst i asked for feedback, phordijk went a step further and gave me some excellent things to look at, but then he told people to stay away from the project, warning them and later added some other things which are incorrect, saying that code does not work etc. etc. I know the project has a way to go, and I am working on stuff. I happy for somebody like him to look at the code, i was just not happy for somebody like him to "warn" people, unfairly before giving me chance.
&gt; PSR-18 has been approved for a few months now. Why would you now release a new HTTP abstraction that does not comply to that? Especially since you use PSR-7 objects. I keep seeing this type of question and it makes me extremely sad. FIG, the organization that produces the PSR, stands for "Framework **Interoperability** Group", and not the "Framework **Compliance** Group". When writing a library, you're not supposed to make everything "compliant" with the PSRs. The PSRs are there so if you ever have to write an interoperable adapter for a library, you can target one interface, rather than many ad-hoc solutions. The nature of PSRs is that they're the lowest common denominator, a compromised solution. But it's an interoperable solution. There are tradeoffs in being interoperable, it comes at the cost of flexibility, configurability, efficiency and fitness for a specific domain that isn't precisely the domain of the PSR. So for the love of god, stop making everything PSR "compliant" and stop demanding other library writers to "comply" with PSRs. Wanna help? Take fetch and write a PSR adapter. Adapters are easy to write.
Wasn't intended to be overly comprehensive. Simply pointing out that when adding Layers in PHP you are adding some overhead. Your requests per seconds drop, your memory usage goes up. This, for example, is a much more comprehensive list.. (as mentioned in other comment) [https://github.com/pmjones/forked-php-orm-benchmark](https://github.com/pmjones/forked-php-orm-benchmark)
well hopefully you've now learned that coverage isn't necessarily a good metric.
Not tried Kirby, but kicked the tyres on Statamic. Done dozens of Craft sites. Craft isn‚Äôt flat file, the other two are. Also craft has twig. Probably enough reason right there. Statamic‚Äôs interface is nice. Crafts is good. Stat is laravel backed, whereas Craft is Yii. Yii‚Äôs conventions are a bit weird to me. Use craft.
&gt; The mistake I made was rely to heavily upon the changelog and ignoring the messages aspect of non vital commits I think anyone who puts this much effort into a project has done a great thing, but it's more of a personal thing tbh. The mistake you made is creating an open source framework for all the world to use while being so inexperienced you haven't learned to write decent commit messages.
Not sure if it is something I could use, but you solved an issue I had with FastRoute so THANKS !! :)
Lpplppl
The PHP community here can be pretty brutal, sometimes unnecessarily so. It partly stems from PHP's history of being infamous for large amounts of shoddy code and a desire to not repeat the mistakes of the past, especially when a lot of us work with legacy code on a regular basis. With that said, much of the criticism here is warranted, if you are publishing something with a stable version number and not warning people that it shouldn't be used in production, you should expect criticism if there are a lot of security issues. When you see the same anti-patterns and vulnerabilities repeated in the "I've released a framework" thread of the week, some people find it hard to not just bluntly point them out. For example /u/phordijk's review might be terse, but every point is worthwhile, some serious issues were highlighted and it was by no means antagonistic. If you hired someone to review your code like that you'd expect to pay them hundreds. The community could certainly be more polite when it comes to non-security related issues and encouraging of new developers, but I'd suggest that the JS community could do with being more brutal when it comes to application security.
IMHO your framework is not easier to use than symfony or laravel. Maybe it looks like that to you since you wrote it from scratch and know how everything works internally. But when you get experienced enough with any framework things become really easy to do. Don't take me wrong, I know how much effort you have put into it, and I'm sure that you've learnt a lot by coding it. tbh I did something similar many years ago. In my opinion creating a framework is a full time job, it's almost impossible to reach the same quality of a well stablished framework by working alone, plus keeping it up to date with PHP releases, best practices, PSR and so on. Don't even mention fixing bugs. If you are a freelancer and this framework works for you go for it, but if you work for regular companies, I think you might get more benefit investing your time in mastering some well stablished framework than creating your own. if you want to have an open source project is better to focus in making a tool that does one thing very well instead of trying to cover too much. You have more chances of people actually using it. Anyways, coding and having own projects is way better than doing nothing or just complain about others people work. I think whatever you do, as long you keep coding, will be beneficial for you.
Its just for showing it heree, so that people will not complain about commit messages. Later he could revert it to his old state.
That's......completely missing the point.
Exactly and quit bitching
I just got upset, as he told people to stay away its dangerous and at least one his points was incorrect. BTW. They were not squeezed, they were put in a grinder......
What point would be missed?
I don't quite understand the apologists here. I mean, is he going to pay for the people who also contribute on the project. Surely he isn't the only person in this project?? These patreon scams just rub me the wrong way. You don't start open source to demand money later on. You share code to improve yourself.
Don't use absolute paths like `/`, try just using `public` (It's been a long time since I've used Heroku, I don't recall their exact server structure)
He'd still have shitty commit messages, and the project would be worse off for it.
It's also a third party extension. By definition, it's not under the purview of the PHP core team.
Yes but to just show it here on reddit commit messages are not needed. He asked about what he can improve code wise but a lot of comments are just about his commit messages if he would had leave them out then people would talk more about his code and not about git.
Of course, the point is not solve all problems of the code world.
&gt; The point I‚Äôm making, at least for us, was that there isn‚Äôt any way, that I‚Äôm aware, to enforce these patterns, aside from actually making them so dominant that it‚Äôs just ‚Äúthe way it‚Äôs done‚Äù. That‚Äôs where the sprint comes in, because if a pattern doesn‚Äôt take enough of a dominant role in the codebase, it can easily be forgotten or overlooked. I‚Äôve seen this happen many times with competing pattern/approaches. You enforce this the same way you enforce coding standards. The same way you don't forget space of comma in the end of the array, it's part of CI.
It's a legitimate point of criticism though.
That's great!
OP, congrats on getting something written. It seems to be a labor of love. I however do not get all these relatively junior programmers who think that they're going to write a new framework that's better than what exists today. Between Symfrony and laravel, you're got a really high bar to get over. In general, this is something I'm never going to use. Why? Your only claimed advantages are ease of use and speed. Of course you think it's easy to use, you wrote it. As for speed. Sure, maybe it's a tick faster than Symfony or Laravel, but that's because it's nowhere near as flexible/powerful as those frameworks. Once you get to feature parity with them, you will no longer be fast and it will be just as complicated to use as they are. I've been writing code for over 30 years now. I've seen all sorts of trends come and go, and with frameworks it's always the same. New framework (it's lighter and easier than old Framework) Hey, new framework can't do this, let's add it. Hey, what about this? Let's add it. This is critical, let's add it. This is insecure, let's fix it. several iterations later Wait a minute, look at that new framework, it's fast and simple, not like this bloated piece of shit! repeat ad nauseum. Best of luck to you...
One way to do it is to have all your urls redirected to the same file, for instance index.php, then from there you would call a router function that will analyze the url and then will call the appropriate scripts. If you want to learn more about this you should read about MVC, controllers and routers.
When I coded for Windows Phone, you could use a dark mode or a light mode. So, I have looked around which mode could be best. From what I've read, dark mode is easier to read when there is not much content, but white mode is preferred when there is a lot of text. Finally I've left it to the users to decide XD Personally I use white background with PHPStorm.
You don't like it, remove the module.
If you have a chance, could you explain what you mean by "CSRF token validation is vulnerable to timing attacks"? This is not immediately obvious to me and this worries me
Windows 3.1 candy/hot dog stand colors pls.
An IDE shouldn't be necessary for development. It can aide it and make it more productive, but saying "my IDE can show me the names of the parameters" is a weak excuse
Please read the sidebar. So few people seem to do so.
Aside from the differences in the API, is there a reason to use this over guzzle?
This is called a [clean URL](https://en.wikipedia.org/wiki/Clean_URL) and it's achieved by routing. This [Symfony article](https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html) takes you from start to finish.
A site I inherited logged all the steps to encrypt a credit card in a public directory.
It is clean. Go look at it. Then come back and show me something you wrote.
I have made people go back and re-commit with a message several weeks of work. Was it necessary? Usually no, but sometimes yes. Did the exercise greatly improve their ability to make easier to understand smaller commits with useful messages? YES.
I would be very hesitant to contribute to a project with commits like you describe. Projects with one commit (or similar) per release are also problematic. They're often harder to reconcile changes with others' ongoing work, less open to community contributions, harder to review or diagnose new bugs, and in general a sign that a project does not want to be community driven. I could go on, but the tldr is that your advice is pretty bad and wont solve the problem or criticism-- while introducing more concerns/criticisms, like that for for authenticity.
I have never worked for or with a kind person. Even my favorite bosses and favorite co-workers were not kind.
A "timing attack" is a way for someone to use the response time and multiple guesses (brute force) to figure out a password or other user-supplied string. In PHP, a standard string comparison will return false as soon as there's a reason to return false (as soon as a single character doesn't match). [https://blog.ircmaxell.com/2014/11/its-all-about-time.html](https://blog.ircmaxell.com/2014/11/its-all-about-time.html)
I love it! Great library!
Just picked a random sample but your phpdoc/types seems very inconsistent and have errors. https://github.com/originphp/framework/blob/32cbf64290fcf1e24f00529d4e7946289fc920bc/src/Core/Logger.php#L41-L44 =&gt; documents two arguments but there's only one https://github.com/originphp/framework/blob/32cbf64290fcf1e24f00529d4e7946289fc920bc/src/Core/Logger.php#L55-L58 =&gt; the return type is not `Logger` but `Logger|null` because you don't always return it =&gt; also, in this case, you can use an actual return type of `?Logger`. Or just always return something anyway https://github.com/originphp/framework/blob/32cbf64290fcf1e24f00529d4e7946289fc920bc/src/Core/Logger.php#L177-L183 =&gt; says it returns void though it returns the return value of `file_get_contents` Stopped looking further, but I may suggest you go through your code base and fix them. Also: you should ASAP start to set up a CI pipeline to run your tests. Also: best practice is to keep the `phpunit.xml` a) in the root and b) named `phpunit.xml.dist` In composer.json the `"Origin\\Test\\": "tests/"` should be in `autoload-dev`, it's not relevant for production From your README: ``` ![build](https://img.shields.io/badge/build-passing-brightGreen.svg) ![coverage](https://img.shields.io/badge/coverage-91%25-green.svg) ``` Do NOT to this, don't fake them. Set up actual pipelines and correctly link to them! Do not to this: https://github.com/originphp/framework/blob/4df72e21970bd230dbf31cdc89273eb799b9868c/src/bootstrap.php#L23-L36 . Don't define 1000+1 constants. This looks like it straights out of CakePHP or something. Your framework will have problems integration with our solutions with something like this. Same concept applies to https://github.com/originphp/framework/blob/master/src/functions.php . Never use global functions as a framework. Was this inspired by CakePHP?
Got it thanks !
someone has slipped a request for money in what should be a technical info output. why is it so terrible to have an opinion on that?
Can you give an example of this modern development paradigms that is missing in codeigniter?
I think if you actually understood three bullet points you would understand you didn‚Äôt solve any problem.
tgh
While for the most part I agree, I think Xdebug is in its own League where you could say "this has done so much for us that we'll allow it.". Would it be fine if every small extension had this so your \`phpinfo()\` would look like a rainbow? No.
I feel like you should add October CMS to this list.
lol
Or the SQL prepared statement template is created and sent to the database for each request?
If your php script is dropping the reference of $statement you will create a new for each ajax request.
I am doing something like this: &amp;#x200B; `$a_php_dynamic_var = $_POST['ajaxVar']; //this is dynamic` &amp;#x200B; `$sql = "Select cities from countries where id= :id";` &amp;#x200B; `$sql_pst = oci_parse($conn,$sql);` &amp;#x200B; `oci_bind_by_name($sql_pst , ":id", $a_php_dynamic_var);`
The statement will be prepared for each request *but* your SQL server may cache the query internally. (This is more likely when using placeholders instead of concatenation because you can just hash the query) This varies by SQL server of course. &gt; Considering that the binding variables for a single prepared statement are dynamic This has nothing to do with it - the query plan is built with no regard for the parameters, the database has all it needs in the query structure. &gt; Is a prepared statement efficient on multiple AJAX requests? What else were you planning on using? There's no difference between a prepared statement with no parameters and a query under the hood. Now if you're looking for tips on making it more efficient, you could try [pooled connections](https://www.php.net/manual/en/mysqlnd-ms.pooling.php) which keeps the connection open for a few seconds after the request then reuses it on the next one (With the downside of leaking connection state between requests)
Why did you post a full symfony tutorial instead of the routing component?
Make for every post a file and a folder struture for the pathes. Works out of the box.
Why dont you read the error message?
php oracle extension has a way of connecting with he database with a persistent connection: [https://www.php.net/manual/en/function.oci-pconnect.php](https://www.php.net/manual/en/function.oci-pconnect.php) &amp;#x200B; So a prepare statement executes the same statement repeatedly with high efficiency. &amp;#x200B; When sending variables to the server via AJAX the statement remains the same, only the variables change. &amp;#x200B; So the statement template is created and sent to the database for each request? That's not efficient.
I feel you are looking at this from the wrong angle; if I try really hard I can see a reason for your stand - if you‚Äôre looking from a framework point of view. In that case a new PSR means a fair amount of refactoring. From the standpoint of a library maintainer these recommendations are great. Because now the workload of having to build these adapters you apparently so crave are no longer the responsibility of the library maintainer, but is something a framework maintainer should do. It is after all the choice of a framework not to follow a PSR. By following a PSR you are making your library *interoperable*. Just look at Symfony‚Äôs new HttpClient; they have chosen not to follow PSR-7 - fine - and therefore are not following PSR-18 either. But they *do* offer an adapter that is compliant with PSR-18. If you have read my addition to the comment you would have seen that I am actually curious. Not hostile. I‚Äôm in the process of converting a large project to PSR-18 as we speak and I can‚Äôt wait for the day I can switch to the new Guzzle version with a PR that will change three files. All because I don‚Äôt need adapters because I follow a PSR. I feel there is some hostility against the Http Foundation - PSR-7, -15, -17 &amp; -18 - that I haven‚Äôt seen with logging, caching and the more recent event handling. I am not making you follow these recommendations, but I *am* curious as to why one would deliberately choose *not* to follow them. I am still learning and maybe someone has a very good argument why I should stop following these recommendations, but up until now I have not heard one strong argument to not be compliant.
I bet youre a real pro expert whos writing the best code which has never to be changed. Wow. Can i hire you asshole?
You could behave complely diffrent. Should be great to work with you. Not...
Have you tried Grav? https://getgrav.org
&gt;I tend to run away screaming when I encounter a functions.php Why is functions.php bad?
&gt; Just look at Symfony‚Äôs new HttpClient; they have chosen not to follow PSR-7 - fine - and therefore are not following PSR-18 either. But they do offer an adapter that is compliant with PSR-18. But... that was my whole point. &gt; I‚Äôm in the process of converting a large project to PSR-18 So let's analyze this. Why did you decide to do this, and what benefits you're yielding. I just hope you won't say "well because it's interoperable". I mean specific benefits and reason you chose to do this for, aside from peer pressure and "it's a best practice". &gt; I feel there is some hostility against the Http Foundation - PSR-7, -15, -17 &amp; -18 - that I haven‚Äôt seen with logging There is, mostly because PSR-7 is deeply flawed. Few points that stand out: - It's both immutable, and mutable. Thus yielding no benefits over a mutable version, but also being significantly more inconvenient (and poorly performing) than a mutable version. - It's based on HTTP 1.1 and not HTTP 2.0. While HTTP 2 is backwards compatible, it's also a significant simplification and at the same time extension of the original protocol, and PSR-7 takes none of this into account. You're stuck with an outdated abstraction. - PSR-7 is underspecified. Many minor behaviors are not documented, and implementations have taken their own interpretations to them. There's no test suite. There's no reference implementation. Which brings me to my next point... - PSR-7 has spawned a million nearly identical (but not actually identical) implementations of its interfaces. The whole point of PSR is to make interoperable code. And the whole point of interoperable code is that every one of us stops implementing the same thing over and over and over again. PSR-7 has clearly failed at that goal. &gt; I am not making you follow these recommendations, but I am curious as to why one would deliberately choose not to follow them. Hope that gives some answers.
Thanks!
Can be acheived with .htaccess routing aswell!
Try searching for ‚Äúmod_rewrite‚Äù. If you‚Äôre stuck still, post question to r/phphelp - this is not the place.
# WE DID IT REDDIT
Less about the file, more it‚Äôs contents, which is usually a bunch of utility functions polluting the global namespace. Goes completely against OO programming principles.
1. Good capsulation, well designed public interfaces &amp; sensible component structure is what makes software easy to use &amp; fast to develop with. Global functions and unclean public interfaces kind of fly in the face of that. This is also important with ‚Äúconvention over configuration‚Äù frameworks, I would even say it is more important! 2. Don‚Äôt worry about performance until you have performance issues. Well designed software performs. And, if the framework is your bottle neck, you are probably using it wrong, using the wrong framework, or ultimately, using the wrong language...
qLaravel.
&gt;i was just not happy for somebody like him to "warn" people, unfairly Some of the security falls are quite large and advising people not to use it because of those I think is a fair comment. I understand it getting to you as it can seem personal but you asked for the feedback and got it. Reddit is THE WORST platform to ask for feedback on, people here love to be negative you have to expect serious and harsh negatives about any project you do. It's not just you so don't take it to heart read any thread on /r/php and the vast majority of the comments are negative in nature.
&gt;What was not constructive about phordijk's criticism? It's a typical reddit r/php comment. Love to highlight all the negatives (and they where valid negatives to make that clear) but offers nothing in the way to fix them, what could be a better choice and nothing in the way of anything positive about good things in the project. The feedback was technically correct but not very constructive. Every post on /r/php is pretty similar though, negatives only, so it's to be expected.
Ah thanks, that's the one.
Where should we then place common helper functions?
You're upset because, in your mind, you are the God programmer, the √úbermensch, the Alpha and the Omega. You just got a reality check. That's not how other people see you. They see you as just another """""""""""REDDITOR""""""""""", which is exactly what you are. A shit-eating, upvote-mongering """""""""""REDDITOR""""""""""".
I am getting the same error. Where should I look to solve this problem?
Had a little play the admin system wasn‚Äôt great. Depends what your goals are and what level the people doing the content management are at. Craft (like Wordpress) is very approachable for ‚Äònormals‚Äô.
FetchQuest, a quest to implement the Fetch API. üòÄ
I know but he asked to review code not git History. Half of this thread is about the git history and not his code. He could squash it here for reddit to one wip commit. The ppl. need to focus on his code.
&gt;I'd expect more comments like this on /r/webdev , but much less on /r/php. I guess you don't frequent here often haha
MVC is not technically possible in a web application, at least not MVC in its original defined context. It's a user interface pattern designed for GUI software not a request/response style system. What you have produced is called Model 2 invented by Sun Microsystems and not MVC.
nice work. make the changes suggested by the smarter people and keeping going at it.
&gt; But... that was my whole point. But...that does not apply to this situation. Following your logic the OP can freely introduce a new interface and someone - maybe the OP, maybe someone else - should create adapters. That‚Äôs the same situation as before the PHP-FIG was introduced. Of course everyone can create their own interface and start writing adapters. I don‚Äôt want to write adapters. I want to spend my time writing functional code. There is nothing that stops you from adding convenience methods on your own implementations. And if your interface extends the PSR interface you‚Äôre still awesome interoperable. What kind of HTTP/2 things are you missing in PSR-7? Maybe you can write a proposal for a new PSR to follow HTTP/2 better. What is underspecified? Maybe you can suggest improved specification. You are right about the mutability - the streams are mutable. Do you have a better solution for this? I hear a lot of complaining and don‚Äôt see a lot of action. PHP-FIG is constantly looking for people. Offer your help. Larry Garfield gave a nice talk on DPC - video was not yet up, will be shortly I assume - about PSR-14 and for a large part about the process of authoring the PSR. Maybe that will give you some insight into what a difficult task it is to come up with these recommendations. Reason we are migrating is because Guzzle released a new major - and this backwards incompatible - version. The options are to convert all the occurrences at once - inherited codebase with plain Guzzle usage - or introduce a new interface. Now we can decide on our own interface or use one that already exists and that suffices. Not a difficult choice, right?
I mainly need a CMS for 1 site, and I would be the only content editor. There would be very little updates (no blog). I have to migrate a Wordpress site. I considered [Jigsaw](https://jigsaw.tighten.co/) since it seems to be Laravel's cousin and the only reason I didn't go with it it's because it isn't prepared for multi-language.
Alright OP, I've just been reading the comments for a bit. Yes, some are being really to the point with their feedback. Yes, you clearly poured your heart and soul into this project and to have several people take a dump on it with honest, but a little emotionless, feedback can be a hard pill to swallow. But take my advice; take all their feedback points out of context, write them down in your own words and then work on fixing them. Because they are not making these up, and you will have to accept that before you can start really improving this project. Best of luck to you!
&gt; That‚Äôs the same situation as before the PHP-FIG was introduced. Of course everyone can create their own interface and start writing adapters. I don‚Äôt want to write adapters. I want to spend my time writing functional code. The point of PSR isn't to avoid writing adapters. It's to write one adapter instead of infinite adapters. &gt; You are right about the mutability - the streams are mutable. Do you have a better solution for this? Yes, keep the whole thing mutable, at least get your money's worth, instead of getting stuck midway between both solutions. &gt; I hear a lot of complaining and don‚Äôt see a lot of action. What "action" do you exactly expect here? You expect the community at large just craves to participate into a process that takes two years of endless online arguments in order to poop out a badly designed interface that doesn't even have a test suite and a reference implementation? No, the far healthier choice is to do precisely as FIG originally intended: 1. Ignore FIG. 2. Want to be interoperable? Add a PSR adapter to you package as a separate thing. Done. We've exhausted the range of actions necessary.
&gt; I know but he asked to review code not git History Actually, this post only asks us to take a look at the docs, not the code. &gt; He could squash it here for reddit to one wip commit. Then the ppl. need to focus on his code. And I, and others, would promptly see it as a project we wouldn't be able to use-- which is a part of the project/community-level feedback. /u.jsharief has the opportunity to make a better project, a better community, and a better process: not just better code. Your suggestion denies that to them and sends the project in the wrong direction. Sorry, it's just plain bad advice for _any_ project. It's like excluding a LICENSE file because people don't like a license: Congratulations, now no one can use the project. Make it better by making it better-- not by avoiding things people might not like.
I recommend that you look to micro frameworks. Most popular for PHP are [Slim](http://www.slimframework.com/), [Lumen](https://lumen.laravel.com/) and [Fat-Free](https://fatfreeframework.com/).
Laravel which lumen is a light version of. IMO it won the framework wars.
Nope.
lol no. Symfony is the big player alot of other frameworks rely on
Well I would like to prefer "decoupled" instead of big.
But it has like a billion upvotes on Reddit so your argument is invalid.
Symfony as in "components/libraries made by the Symfony project" is more popular than Laravel as in "components/libraries made by the Laravel project". But Laravel as in "Laravel the framework" is more popular than Symfony as in "Symfony the framework". See [this recent Jetbrains survey](https://www.jetbrains.com/lp/devecosystem-2019/php/), for example. I probably wouldn't say that Laravel **won** the "framework wars", but it's definitely leading over Symfony in terms of popularity.
Why would you want MVC? I find the architecture to be terribly suited to API backends. You don‚Äôt need a view layer. Just encode and return your data. You don‚Äôt need a controller layer, it only encourages sloppy code and practices by allowing too much freedom. Consider a custom request routing middleware with a DTO layer for data transformation.
A ‚Äúhelper function‚Äù seldom is completely stand-alone. Folder / file traversal? -&gt; belongs in a File component. Dump methods? -&gt; belong in a debugging component. This way things aren‚Äôt just kicking around in the global namespace, but can be depended on as needed.
Check out Symphony, it's broken down into the different pieces you need to build an application so you can put them together how you find best. It's what laravel is built on top of and it has great guides and docs
Theese real world number say something different. [https://www.tomasvotruba.cz/php-framework-trends/](https://www.tomasvotruba.cz/php-framework-trends/) I dont want to start a "framework war" here, just stating that for example in germany laravel relatively unknown
I concur, just get the Symfony skeleton and build from there adding a component when you need one. If your company uses a lot of single page apps, I would definitely recommend taking a look at API platform, the API component for Symfony which is bloody awesome.
He was a bit of a dick about it. Which is a shame because his comment seeming like he was trying to be helpful.
I do not agree. I think the MVC approach is very well suited to API design. Even if it‚Äôs really only MC the separation of concerns at that level is very practical. Imagine building an abstraction layer as a starting point for retiring an old schema that is no longer efficient. The initial work of the API is not as simple as just returning your data. And the controller layer is extremely valuable.
Symfony is the big player but it's a bit complex, Laravel was made with parts of Symfony and is a bit simpler, but not quite as popular. Whichever you choose, I can strongly recommend Traversy Media on YouTube. He has great basic guides in both. And they both have great documentation as well! (Even for beginners)
Counting individual package downloads is probably not the best methodology if you're trying to measure framework popularity. I work as a Laravel developer in Germany and I'd say it's about as well-known as Symfony. At least among people who like to stay up-to-date on PHP-related stuff.
Symfoni, Laravel and CakePHP are all great frameworks if you want to delve into the source code and see how not only MVC, but a large number of other general programming principles can be implemented. When in it comes to learning resources there is no better place these days than Laracasts. It's mainly targeted towards Laravel, but there are lots of general tutorials there as well, even stuff about JavaScript and frontend. The Laravel from scratch series is free, and explains MVC very well, https://laracasts.com/series/laravel-from-scratch-2018/episodes/8 If you get a grasp on the basics from that video series, you will also be able to understand the workings of CakePHP and Symfony very well. I wish that people on Reddit would try to give more consise advice instead of bashing on any technological implementation they don't either use or don't like. You do not come across as very smart when you do so, neither is it very helpful for anyone. Good luck with your endeavors, OP. Remember to take your time and accept that it will take time to master and understand this stuff.
&gt; he doesn't care to use PHP 7+ because he's used to 5.6 Does he understand that 5.6 is ELO? This guy sounds lazy and horrible to work with.
community-wire u may be right. But if u look at job offers on plattforms like indeed, xing and so on, symfony almost doubles laravel.
Don‚Äôt use MVC
No, it's not Model2 MVC (which is the full name of it ... that you somehow manager to forget ... odd). What he has produced is another Rails clone with all of it's default flaws while adding new ones.
There's also a YouTube playlist by Codecourse called Build a PHP MVC Application. It's 9 videos long I think. It walks you through setting up your own framework so you get an understanding of how it works.
Very mature! But I won't go to your level of personal attacks and curses. Now, OP didn't ask us to evaluate if he's a good coder. He asked us to criticize **the project**. I get it that OP was working on this project alone and not for a long time, so I never said they're a bad coder. But if we're evaluating the project, not the author, it's completely irrelevant how much time was spent on it and how many people worked on it. And if people ask for criticism, they should be ready to accept it, not become defensive and take it personally.
My next step was to get CI working as all tests run through the docker container right now. However given the broad amount of feedback, I am working through these now. No i am not faking, you can see image on this page which shows the coverage. Yes, heavily inspired by CakePHP and Ruby On Rails(which CakePHPP is modelled on. Originally when I set out I wanted compatibility with CakePHP 2.0, which i liked but was clunky. Thanks for advice.
Thanks.
The book "Modernizing Legacy Applications in PHP" will teach you the important part of MVC architecture in a step by step fashion, without immediately introducing a framework dependency. I think it's a good fit since you don't want to throw a full blown framework at your code. Moreover, it teaches you how to move away from the classic "collection of PHP scripts" which you have if I understand your post correctly.
&gt; This guy sounds lazy and horrible to work with. Yes he is. I tried teaching him Laravel but he couldn't understand its basics, he always reinvented the wheel instead of using framework-provided features. It's a shitty company who works for the public administration (they make websites and other services for municipalities) and so nobody cares, and he continues to use outdated PHP. Luckily I no longer have to work with him.
In my understanding constructive criticism means to try to find negatives (hence "criticism") but state them without unnecessary emotion and without getting personal. So criticize the project, not the author. I think phordijk did it fairly well. Sure, his response would be even better if he proposed how to fix stuff but it's not always easy to explain without getting too much in the weeds and also it's just a person on the internet and they're not obliged to spend even more of their time. I think pointing out the issues is more than enough to be able to improve this project.
I learned quickly of MVC using Yii2 framework. At first I wanted to get into Laravel, but I've found Laracast is not beginner friendly. It oriented towards Mac, not Windows.
\&gt; An IDE shouldn't be necessary for development It's far from "necessary". If the other option is breaking lots of existing code, then I don't concur in such a case.
To put it straight: no, there is **no way** to preserve a once prepared statement across different phone instances. You will find it easily discover it the moment you try it. A statement is bound to a phone close instance and there is no way to preserve a class instance across requests. Do not expect too great an efficiency though. 1-2 percent if you get lucky.
I would just use few of Symfony's standalone components (like routing and DIC).
Don't use Laravel. Don't use Yii. Don't use any of the RAD frameworks. They are not meant for long term project like APIs.
Go for Laravel, is the most popular php framework, and for a good reason. Dont go around learning each framework, that will drain you. If you learn Laravel in deep will be extremely easy for you add a new framework to your tool box. Get a Laracast account and go for it.
Laravel is the best!
I don't think his tone is inappropriate considering how incessantly arrogant OP has been
If you want to go down that road, you can check out this article from Symfony'S docs, that answer your exact question: https://symfony.com/doc/current/introduction/from_flat_php_to_symfony.html
&gt; Why would you want MVC? I find the architecture to be terribly suited for API backends. You might find [Action Domain Responder](http://pmjones.io/adr) more to your liking.
Yes, Dave H's PHP MVC framework course on udemy. You'll code one from start to finish with the very basics you'll need. He does use composer to install twig, but from what I understand it's better practise to use this. If you don't want to pay money for the course, you can still get it on GitHub. If you want to understand it id advise his course. FYI I am not him. https://github.com/daveh/php-mvc
Just read over it. I like it.
The folder structure follows best practices, and is the very similar to all frameworks. The Dockerized Development Environment, is not locked down as it serves the files from the users local hardrive. Without or without docker those files are accessible. That said, I will modify configuration to serve from the public folder incase somebody tries to deploy the DDE to a remote server.
&gt;https://blog.ircmaxell.com/2014/11/its-all-about-time.html Thanks for this.
I second that first sentence. Just to extend the second, there is a way to preserve instances across requests. Through the serialization/deserialization mechanism. Unfortunately, PDOStatement does not support this. And even if it did, the performance gain would be questionable. Preparing statement has more to do with string sanitization and replacements, rather then interacting with the db connection. The reason it is part of the PDO layer, is because the sanitization is done according to used sql dialect, and that is known by the PDO.
/u/phordikj spent time at no charge going through code, pointing exactly where there's an issue, and indicating an easily-searched set of terms to find out why he's taking issue with that code. The fact they didn't also go to the extra unpaid effort of explaining what you can find readily with a search engine doesn't count as a negative in my mind. Certainly if you're talking to friends or even coworkers a bit more care should be taken to be gentle and friendly, but that's not what this is: it's someone asking the world at large to 'take a few minutes and provide feedback'. If the feedback is just "uniqid is broken, don't use" fortunately it's easy to find out from the official docs [why it's broken](https://www.php.net/manual/en/function.uniqid.php). No need for someone already providing advice for free on their own time to do the work of paraphrasing that for you. Similarly you can search "html regex" or "float for money" and find plenty of explanations of why they're bad ideas, and alternatives. The feedback isn't constructive per se, but combined with basic web searches it's incredibly informative. Either the OP didn't know about some of these issues already, in which case them looking up and reading why, say, html parsing can't be done reasonably with regexes is something they should do anyway, or else the OP does understand why, say, email header injection is bad but just sort of derped out and wrote vulnerable code in which case the OP benefits from just being told "the email stuff is vulnerable to header injections."
He doesn't need to build big apps. He asked from what he can starts.
When I ran OnlyTrump.us, it got something like 300,000+ visitors and over 50,000 people signing up for it. I proudly proclaimed in small text on the bottom that it was made in KirbyCMS, which cost money, and via my referral link, over 10 sales were made from exposure to that site. One day, I had a technical question and I reached out to Bastian. He asked the site domain (this is after I had bought 20+ licenses from him [hundreds of dollars] for my own corp and dozens more for clients). Then when he found it was for Trump, he basically sent me a cease and desist for using Kirby, which I questioned was even legal. I had to scrape the site's HTML and then I removed Kirby from all but 1 of my non-active sites. I just couldn't believe someone whom I had had such a profitable business relationship with for years would do that. I don't even think he's an American.
Will keep that in mind, thanks!
Please explain why they aren‚Äôt suitable for long term projects like APIs? That‚Äôs nonsensical.
Most popular is definitely Laravel, which you left out.
Chances are, if you've a lot of experience doing things simple, that one particular framework would be trying to do too much for you, and it would be difficult to change to that paradigm of programming. &amp;#x200B; If you always use plain PHP, you must be aware of the repetition you do for every project, and what pain points you always find with PHP. Different frameworks aim to remove these problems and generally make your development life easier. I suggest you look back on one of your previous projects and try to analyse where the "M", "V" and "C" would be maintained, and then produce a simple app yourself that adheres to these separate areas of the application. Then you'll be able to see a tangible example of how an architectural style such as MVC will help, which will massively help you make decisions of what full framework to choose. It might be that a full framework is the wrong choice for your coding style, and a project that breaks the responsibilities up into smaller consumable modules is a better choice.
Start with codeigniter. I switched from core php to ci too. Its relatively simple than laravel.
Laravel =/= microframework
Ah.. I read too fast. My bad.
BAD BOT! GTFO!
Because these RAD frameworks are intended to "rapid prototyping". In simple terms: when you need to throw ideas (with a kinda-working website) at the wall and see what stick, with the intention to later delete that prototype and *do it properly* later. That's why you see these type of frameworks bundled with active-record ORMs and scaffolding tools. You could say that RAD frameworks are optimized for building a blog in a live presentation :) - API system itself is not a website. That meas you will have to re-implement a large subset of code for JSON/XML, which initially was intended for HTML (for example, consider the fact that escaping for HTML will be completely different from escaping for JSON). The ORM will become a stone around the neck of your project. It's all fine while you are making the simple parts, but when the API development starts to hit the actual business logic, you will have to start using various workarounds. And at that point getting rid of ORM, that has become a detriment, will be very expensive proposal. And of course, you will be stuck with said framework's bundled unit testing system. Because RAD frameworks are so tightly coupled, that the classes are not actually testable without initializing large parts of the framework itself. This in turn will make the whole testing experience somewhat nightmarish.
I was in your exact same position last month, but I started learning the Symfony framework here https://symfonycasts.com/tracks/symfony! Now I know you may not want to pay a monthly subscription fee, but they offer each course as a one time payment for less money. Other users have recommended laravel and daveh and those are both excellent resources as well.
Wow, sounds like this guy is a german! You won't believe how much left ideology we have here, it is just like in socialism! If you say Merkel's refugee policy is bad then many people will call you a Nazi until your boss fires you! That is Germany in year 2019 :( :( :( &amp;#x200B; Check out this revolutionary CMS/Framework (coded by me and free of ideology): [https://php-ucms.com/features/](https://php-ucms.com/features/)
Silverstripe is a good one. It helped me learn mcv.
Thanks. On it.
It‚Äôs poor architecture, but it doesn‚Äôt result in ‚Äúflaky runtime‚Äù.
So basically you are saying the string functions in functions.php, put them in a String class. What do you mean exactly unclean public interfaces? &amp;#x200B; Performance is important, since I am offering a framework, one of the reasons cake lost its ground in my opinion, is because experienced developers did not want to use it because it was clunky and used lots of memory and was slow.
DIC is one of those framework fads everyone will call an anti pattern few years from now. DI != DIC. Just my opinion.
You‚Äôre right, but the most popular framework shoved a bunch of functions in global space and talk about how handy that is. Damned if you do. Damned if you don‚Äôt.
This is a really cool project with a great goal, but I‚Äôm going to be honest: I don‚Äôt want the overhead of extra php function calls every time I‚Äôm casting, that could get expensive in large loops. I think this hits the low hanging fruit of the functionality, but I would recommend you implement this as a PHP _extension_. I think that would hit the sweet spot and wouldn‚Äôt be overly complex, really. Just something to think about. Then you end up with: $int = (stringToInt) $string;
Emulating copy-on-write for arrays in JS would be rather painful.
Funny you say that‚Ä¶
The takedown notice: https://imgur.com/a/XxZQfcf
^(Hi, I'm a bot for linking direct images of albums with only 1 image) **https://i.imgur.com/SQfaDN3.png** ^^[Source](https://github.com/AUTplayed/imguralbumbot) ^^| ^^[Why?](https://github.com/AUTplayed/imguralbumbot/blob/master/README.md) ^^| ^^[Creator](https://np.reddit.com/user/AUTplayed/) ^^| ^^[ignoreme](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=ignoreme&amp;message=ignoreme)^^| ^^[deletthis](https://np.reddit.com/message/compose/?to=imguralbumbot&amp;subject=delet%20this&amp;message=delet%20this%20ersodl1)
This is AWESOME! It looks like my DataTypeValidator project would work fantastic with you'rs... https://github.com/phpexpertsinc/DataTypeValidator
Understood, thanks. I'm going to put together some performance tests to measure the real impact of it, and put the results in the readme!
Thanks for your kind words, and your PR :)
The link on that page is broken... While it's an easy change to fix the vulnerability and so should be done, I've yet to see a practical example of nanosecond level timing attacks conducted on a real-world PHP websites for CSRF. There just seems to be so much noise from other operations that you would need an ungodly amount of requests to be sent.
The reason you don't get it, is because I am not a junior programmer. My first programming was in basic on dos, which most people on here probably don't know.
Could you point me to where making the project root the webroot the same is a best practice? It seems much safer to me to have a public directory inside your project root that serves your front controller, js, css, images, etc. Everything else is kept out of the public directory. &gt; incase somebody tries to deploy the DDE to a remote server. This is confusing to me. Is this meant to be used in production?
&gt; No i am not faking, you can see image on this page which shows the coverage. But it's not an automated accurate representation of anything, that's the point. Only a service connected to your repo which runs every time a change is pushed dynamically generates these images on actual data is of value, everything else is fake. &gt; Yes, heavily inspired by CakePHP This is a very personal response now and totally fine if you ignore it ;) I've worked my fair share with CakePHP2. It.is.the.worst. Like.Literally.The.Worst. Building something inspired by it nowadays multiplies the worse-ness. Alone the fact that I could see this from your sources probably saddens me a bit for the rest of my life, given your poor soul having dedicated so much into this. Sorry had to get this out. Carry on and good luck :-)
PHP in particular has a larger market than most for what could charitably be described as low quality crap. Because it has such a low barrier to entry, there's a lot of hacked-together barely-functioning often-need-fixing projects that a skilled programmer can demand a decent fee in exchange for repairing and improving. On the other end of the scale, PHP probably runs the majority of the world's corporate websites, APIs, internal services and things like that, but those are much, much less likely to be solo endeavours.
watch the Stefan Mischook videos on YT. He is a big PHP consulting advocate.
Majority of the world's corporate websites? Are you sure about that? I'd wager Java and .Net play dominate the corporate sector.
PHP (especially the Laravel) framework is perfect for solo work! :)
Yes, quite sure. There's a colossal amount of PHP code out there in business. It's not as fashionable now as it once was, but it was the right tool and the right time that it saw massive uptake, and now there's innumerable legacy projects using it. Java and .NET are extremely popular without a doubt, but you'd probably be surprised at how much PHP there is out there in business. If you have to ask about PHP's market segments, you'll *definitely* be surprised at how much there is out there.
So I've heard. Just puzzled why there's so little so Rails work around here in the UK when Laravel is really a PHP clone of Rails?
I'm not that familiar with Rails but yes, Laravel is a full stack framework for MVC applications or rest APIs. It has everything you need out of the box! :D
PHP is just easier to get up and running than rails on both Linux and Windows IMO. Plus PHP has just been in the game longer than rails.
Just on a note for anyone reading this so they aren't mislead, in PHP7, the performance impact of return and parameter typing is an _improvement_. Strong typing of functions allows the runtime to do less type juggling and checking for conversions when performing operations - improving performance.
Why not go a step further and put this as RFC.
Well, to be honest the syntax for it isn't particularly nice as: $int = (stringToInt) $string; So for "elegance" we would probably want some sort of assignment syntax, for example: $int = (string) -&gt; (int) $string; I'm bad at language design. Someone else could do a better job. :P
The `toX` APIs seem pretty odd to me. You have very strict `XtoY` functions, and then `toX` will use those if they exist ... but otherwise just let *everything* through. For example, `toInt([1, 2, 3])` will happily (and silently) return `1`. I would suggest to instead reject everything that is not explicitly supported.
That's a good point. I was thinking in terms of easy migration from using existing `(int) $var` casts where the develop doesn't necessarily know the type of the variable (though they should!), as it would allow them to use strict casting for the most weird conversions (string to float/int), but still accept other types. I agree it's a bit weird, I will think about it!
Thanks for your kind words :) I always thought there was a tiny performance penalty when it came to parameter and return type declaration, see https://stackoverflow.com/a/39561261 &gt; With that being said, currently (PHP 7.0) there is actually a small performance penalty when type declarations are used, because PHP now has to check the types of the values you pass in and out of functions. It is faster to not check at all, which is what happens when you don't have a type declaration. However, I agree 100% with this part, and think it applies well to my library: &gt; Ultimately, performance should not be your concern when adding type declarations. They exist to make the programmer's life easier, not the interpreter's. Use them if you think they will be helpful to you. Whether or not you use type declarations is unlikely to be the main determiner of your code's performance. Unless you're calling functions millions of times in a loop, it's unlikely you will see any noticeable performance drop. I believe, without tooting my own horn too much, that the benefits of using strict casting over native casting would likely be higher.
Well that's cool but I would never give or be pleased to read documentation in pdf format..
I would happily write and RFC for something like this if it was a popular idea. However, you'd have to consider that I'm pretty arbitrarily defining what an integer and a float in string form should look like in this library, and whatever decision was reached would be in the PHP core forever if the RFC passed.
dont print you the docs?????
Nah. I write it on post-it and then I give them to the next dev. ( Õ°¬∞ Õú ñ Õ°¬∞)
I know that feel.
You're comparing PHP, a language, to Rails, a framework.
If you want to focus on 2 languages I would say PHP and Javascript. Wordpress is built with PHP and still has a gigantic market share and Javascript has never been more popular thanks to the rise of both NodeJS and the major frontend frameworks like React, Angular, Vue
Aside from all the issues here, please don‚Äôt. We have a ton of frameworks that are developed by professionals and looking through your code, I‚Äôd say your maybe a new programmer. There‚Äôs nothing wrong with that. But releasing a framework when it seems you have no professional experience with other frameworks and I mean modern, not legacy. Maybe take a job as a junior and work your way up to senior and then try again, this was a good side project, taught you a lot. But there is nothing here that would be useful to any one, and is considered by others and my self to be very insecure and broken.
yes, I actually referred to this extension in my post. I created the whole package to be able avoid installing the extension : )
Yeah but people hate me around here. I get -5'd every time I show one of my creations when it's really relevant. I personally think that submitting a PR, etc., deserves more than a -5. I figure most of them have never actually Made an open source project that they wish to share.
No, they are comparing Laravel to Rails.
Then you should.know better.
Man, tell me about it! For the first time in my career, I received API docs as a PDF, for WorldPay's Card-Not-Present API, and it's 66 pages of monstrous small fonts, highly unsearchable, a full TOC like a frickin book, and all grayscale. What idiot would think promoting that sort of stuff is good?
I second Wordpress because it can be use for a small business to a big multisite with e-commerce and much more functionalities ! Also tons of plugins are available so if you customer want a solution you'll almost have one for him !
You sound like a total junior dev. &gt; In simple terms: when you need to throw ideas (with a kinda-working website) at the wall and see what stick, with the intention to later delete that prototype and do it properly later. No. You can fully feature anything with Laravel with no need to delete it later. Please explain why, say, a feature which returns a JWT token representing user authentication would need to be... redone properly later......? If it returns the JWT in the correct format after receiving the correct input there is absolutely nothing missing or done improperly. &gt; API system itself is not a website. That meas you will have to re-implement a large subset of code for JSON/XML, which initially was intended for HTML Wtf are you talking about... you just use any range of methods like respondJson...? Did you last use one of these frameworks 10 years ago or something? &gt; The ORM will become a stone around the neck of your project. It's all fine while you are making the simple parts, but when the API development starts to hit the actual business logic, you will have to start using various workarounds. And at that point getting rid of ORM, that has become a detriment, will be very expensive proposal. No? The ORM in, again, Laravel is fine. If you are concerned by it then abstract it out and extend as needed, and reuse the parts you want to keep? &gt; And of course, you will be stuck with said framework's bundled unit testing system. Because RAD frameworks are so tightly coupled, that the classes are not actually testable without initializing large parts of the framework itself. This in turn will make the whole testing experience somewhat nightmarish Again... no. You sound utterly clueless. You build tests for what you've just made, run those tests, done. Then you push it up to staging which reruns all tests in about 2 minutes flat (and I've worked on mammoth codebases which ran even faster) so you have tested for regression. I assume you either are a junior developer responding for the sake of it or haven't used a modern framework in a while, because the term "RAD" is not in use in the industry as much as it was 5 to 10 years ago. You sound really outdated.
There has been one already, which was rejected: [https://wiki.php.net/rfc/safe\_cast](https://wiki.php.net/rfc/safe_cast) &amp;#x200B; With some discussion here: [https://marc.info/?t=141029089500003&amp;r=1&amp;w=2](https://marc.info/?t=141029089500003&amp;r=1&amp;w=2)
I use `declare(strict_types=1)` and I am quite happy with it. What does this in addition do more?
The last example you gave where it was like stringToInt(‚Äò123,456‚Äô) Is that not a valid integer in some countries? Especially if they format numbers as, as above, thousands,hundreds?
I don't remember the actual name for it, but I can see changing how calling functions works in PHP would benefit from this. &amp;#x200B; For example, int-&gt;toString(); int-&gt;toBool(); string-&gt;toInt(); string-&gt;trim();
Just want to say good for you. Cheers
Tighter casting is still useful when validating user input. Less necessary internally. So someone who knows how to use it will get good advantage of your library.
Those aren't trends, more like a wish-list I feel. Most websites will continue to be "crudely designed, technically mobile responsive" sites because "won't cut it" is not a business reason. And "my site costs $500, some Indian guy did it in WordPress in a week" is a business reason when the alternative is "my site costs $50000, a team of super professional did it over 6 months with PWA techniques and everything". Things don't have to be perfect for them to do the job.
Sound like how Wirecard sended me their docs.
Stupid fucking bot
Hi there. I had a look at your library, because I was interested to see if this was something I'd like to use. Here are some things I found stopping me from using it. Perhaps something you'd want to look into. 1) The documentation of your library is not great, so the example docs you generated from it are sparse and don't show any elaborate documentation. 2) Your package requirements for the most part use dev versions of other libraries, even when there are perfectly fine stable versions out there. If for some (not familiar with all of the packages) there isn't a stable version, you have not of to lock to a specific commit. Committing a Composer lock doesn't help me out there, if I so desire to use this package as a library, instead of downloading the Phar. 3) The readme mentions your package is built upon PhpUnit. Although I don't mind that it isn't, it's also not used for testing, because composer.json contradicts this, as it is not listed in require-dev or even require. 4) For an application/library like this, I'd want to see a good integration test that at least asserts the HTML you generate for any given class, before you let that be generated as PDF. 5) The package does not seem to automate building the Phar. In fact, even for manual building steps, there seems no evidence of the files required to creating it. That makes me look for a signature or checksum I can validate against the downloaded Phar instead, which is also not present. The Phar as it is can therefore not be validated to be safe, currently.
Please learn something diffrent than wordpress if you not gonna make a blog. Omg. Thats the worst possible.
It is indeed valid in some countries, the output of PHP's string conversion depends on the locale you've set. Not sure how this package deals with that.
Why should we trust your comments about security. Can you show one of your projects to check you are not a junior?
‚Äπironic‚Ä∫ I don't get it. Do we really need yet another Framework? There are professionals there building Symfony and Laravel, nothing else should be invented, that's the best we will ever have. I don't understand why you try to make something less bloated than the other ones. You should be using a tone of pointless classes and files to you, because 100mb for a hello world page is the way to go, space is cheap. Blame the Raspberry Pi foundation for making Symfony lag on it. Performance is not a matter of refactoring or coding something different, just buy new hardware. You must be a junior and we all know juniors don't have a brain and have no idea so they can just type what master senior says. A senior is born never done. Do you think Taylor or Fabien have been juniors? Never! And last by not least, how come your framework has bugs, am I supposed to use it? I understand its new but man, some lines are larger than 12characters and no PSR67 compatible. Good luck, but it's a no from me. ‚Äπ/ironic‚Ä∫ ;)
godo bot
This guy "released" a framework with an incredibly professional looking website with absolutely no disclaimer that there could be security flaws. So no /u/phordijk 's tone and behaviour is completely appropriate.
you should at least use the `mb_` functions
&gt; DIC Are you saying this because retrieving things from the container directly through something like `$this-&gt;container-&gt;get('service')` is an anti pattern. Or do you think having some abstract component taking care of instance creation and constructor argument injection is also an anti pattern?
Everyone needs a trophy
Both are bad, because both are alternative interfaces for the exact same feature. In DI, your constructor signature is a contract on both sides. I.e. it's not just "here's what I want you to give me", it's also just as importantly "here's what I want to give you". A DIC doesn't discriminate what it "wants" to give. It's like a shitty parent. If the kid says "wanna" it gives. The result is spoiled kids. And in the case of DIC, it's spoiled architecture. There's no discipline about which components have access to which dependencies. Architecture is, to a large degree, an exercise in setting the right limitations for every component, so you know what it takes and what it produces, and who it produces it for. DIC is a "everything has access to everything" culture, that encourages spaghetti code, under the pretense it's all so modern and best practice. It's anything but.
I'm convinced by your criticism but I'm not sure how I would go about "doing it right"
I don't know what to recommend to you. The fact is in the current climate if you don't use DIC, people will look at your weird. On the other hand, I've had great success just doing DI "manually". I construct what needs to be constructed at start-up in the app constructor. For everything else I write super basic factory methods. Who gets access to which factory depends on what I decide at the architecture stage. For example, I choose all public site controllers have access to the domain APIs, then they get a factory for those APIs. They can't access the database directly etc. So they don't get access to that. You don't need to differentiate dependencies per file, it's enough to separate them by component, or even by layer to begin with. But, again, that's just my approach. If you have questions, I'd be happy to tell you what I do.
I don't think you want a simple toInt like function to have to deal with different locales. Probably best to just support whatever the language already supports like `123.123`
Do you think there is a meaning full difference between "doing DI manually" and for instance using the Symfony container, but without auto-wiring, and without using the container directly. So basically defining all your instances and dependencies manually in .yml. I guess the advantage would be that it could at least help you figure out the order in which to initialise things? *Thanks for your detailed responses btw, I had you tagged in RES as "smart" so apparently you've said stuff before that made me care about your opinion* üòÇ
how about we create some pull requests? at least that way he will learn and many of us will also benefit cause we may not now how half the things that were pointed out here are wrong to start with. &amp;#x200B; I for one admire the fact that the spent the time to build this project even if its flawed. All he has to do is just point out that its not production ready and he is accepting PRs to fix any issues.
we value the work you put in your project and the dedication you showed. I think the problem is more of calling it production-ready when its not. so just change the version number back to sub 1.0. From the amount of comments people posted here its obvious they didn't dismiss it without going through the code. Fix the problems that were pointed out and ask for another review. There's no bug free code ever but at least you can leverage the community to improve both your project and your skills. &amp;#x200B; good luck
&gt; Do you think there is a meaning full difference between "doing DI manually" and for instance using the Symfony container, but without auto-wiring, and without using the container directly. So basically defining all your instances and dependencies manually in .yml. There's difference in two aspects: - YAML is in a format where they presume you autowire most of the time, otherwise your YAML would be several times longer than just writing it in PHP. You also don't get the same autocompletion and type checks a full PHP editor offers for PHP code. - YAML offers limited flexibility, for example when you don't have to think "how do I specifically make this object usable in a DIC" you may want to accept, for ex. a closure as an argument, because that's a thing in PHP, so why not? It's a very effective, lean way to implement the Strategy pattern etc. instead of writing full classes every time. You can't pass a closure in YAML as far as I know. So you have to specify a factory method in YAML and then go write that factory method in PHP, which defeats the purpose of YAML. So TLDR; it's architecturally better to use YAML without autowiring than with autowiring; but it'll be more restricted, much more verbose, and more error-prone than just writing PHP outright. Also one thing the Symfony container doesn't offer is a hierarchy. I.e. in theory you can have many containers. So one container for your models, one container for your controllers, one controller for this module, another for that module. That would be architecturally much superior. But I don't see anything in the API that helps you choose to use multiple containers. So most people use one container. This has two unfortunate effects: - The container in practice becomes like a make-shift $GLOBALS, everything is in that container. - You can't specify logic once for "layers". I.e. you can't specify construction logic for all controllers in a given module at once. You instead have to spell out the construction logic for every single controller.
What you could instead suggest as an RFC is to enable this strict conversion in a declare statement. So the syntax remains exactly the same. Similar to how declare(strict_types=1) works. You could for example have declare(strict_conversions=1). This would change the way (int)$myVar works instead providing new syntax.
The RFC should at least explain what they do on their own merits.
Note that just because a similar RFC has been rejected in the past, that doesn't mean another like it will definitely fail. Read the discussions to try and understand why it failed. Don't be afraid to bring the topic up again on internals to find out more information and/or gauge reaction to your ideas. Others might have ideas for solving issues you're having trouble with like syntax. 5 years is a long time in PHP land - the type system has evolved and there's even talk of something like scalar objects and core using namespaces to fix inconsistencies. These ideas would give opportunities to implement ideas which were previously rejected.
Sounds like [scalar objects](https://github.com/nikic/scalar_objects).
Still does not belong to phpinfo.
Why ? Did you ever work with ? I mean for real ? Not just installing the first plugin you saw ? We are using Wordpress as a base for many websites. We did build our custom theme and everything is great so far...
Thank you. The security issues that were posted have been fixed, they were minor, really worrying about a timing attack before I have one user? I have had not even had the chance to get feedback. But yes you are 100% right, I should have announced in beta.
Maybe you should look here [https://github.com/laravel/framework/issues](https://github.com/laravel/framework/issues) .
thanks.
My advice to you is to check the facts first, have you looked through the commits to see that its really 50% no comments? How many people jumped on the bandwagon, without forming their own opinion. I can throw in a few interfaces and implement some PSR101, but whilst that might make you think you are an experienced programmer, solving the problems with better design and less code is more a deciding factor. And OMG i have some public properties, its not the end of the world. Have you looked at larvaels git history, 'mega work done' - i got raped on here for short comments. Yes, one my first day of release, there were a few things, which were easily fixed, but did the people who mentioned issues, actually praise about other security issues which it handles very well , no . Give me a frickin chance. Whilst the person who mentioned the security and other issues, some of them were right, others were not. He even mistook some regex for parsing, when it was just replacing and said it would break on attributes, when i showed him the test he denied. Can't blame him he was looking quickly, somethings he mentioned were right, i have fixed, they were easy fixes. He did give valuable feedback, and thats what i wanted, just without the scaremongering. This is something you get with feedback, quite frankly, i as hoping to get some users before worrying every single possible security flaw. Salt and Pepper a flawed premise, see [https://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html](https://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html) . Besides the actual password hashing is done using BCRYPT which is the best practice. So before you believe everything you read, and insult people, think first.
Sorry, i think we have got things mixed up. The folder structure is as follows \- config \- logs \- src \- tests \- vendor \- public etc the public folder is the apache webroot e.g. public/css, the url will only show css. Note, I cant find the link to the web application structure best practices, but it done this way. You can see laravel, ruby on rails etc. I will change the apache config for the docker development environment, so that it points to the public folder.
I am not looking to replace laravel or symfony, thats not why i am doing this. I am filling a gap.
Thanks for your feedback, I will try to fix the issues you mentioned.
I'm most excited about the idea of this working on callables (which it probably won't)
&gt; Modern development paradigms are not taken into account here Examples? I haven‚Äôt taken a close look at CI4 but it requires PHP 7 and uses namespaces and other modern features.
yOu CoUlDnT dO aNy BeTtEr!!!!!1
That's really unfortunate. I wonder if this means they use a custom (java?) based git protocol implementation? In comparison, it works in Jetbrains because they simply use the regular systems git command. Same when you add PGP signing, it just works in Jetbrains because they're not doing anything special.
&gt; I've done a few Rails projects as a freelancer but finding solo Rails gigs is difficult http://harmful.cat-v.org/software/ruby/rails/is-a-ghetto
I am getting abused, insulted left right and center due to this post and other unfounded posts, such as 50% of git commits have no comments before releasing. Firstly, not all the things you have said are correct , and I don't blame you how can you look through almost 9,000 lines of code. However, many things you said are correct, and the security issues were fixed simply with simple one liners but you never once told people of the good security things i covered, instead you warned them about timing attacks before i could even get one user to download. I was hoping to get feedback (Code review) similar to yours, but without the telling people its shit and broken on my first day of release before i could even get one user, that was damaging and confusing, because you seemed that you wanted to help. You told people there was a security issue due to the salt and pepper. I am not hashing passwords with the hash function, i am using the best practice (brcypt), this hash function is a simple hasher. According to [https://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html](https://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html) it says there is no proof that peppering provides better security etc. I hope you find the article interesting. You also said my regex would break on attributes, but it would not, because actually i was using it too pre format instead of parse, only the links were parsed, but i followed your advice and changed it to use dom, i just had not had the time to do so, i had to port the old class of mine as I need to get this out there. I have been working on this 6 months+ almost full time, except when i was in really ill, and I know you are genius, maybe it in the words it came across the wrong way and i have been sensitive because you did not give me chance to fix things and it was my moment, of telling the world. I am sorry to accuse you of smearing me, I felt that way, because i was being attacked from all angles, and not given a chance. Think about the abuse i have taken for short commit messages, if you go through the laravel source code, its the same there, yet here i am abused because of this, its really unfair. Regardless some of the feedback you have given me has taught me some new things, things that most people wont know because the frameworks do this automatically, such as the timing attacks etc, after so many years. The escaping of output in the form helper, i forgot to do it. It was mistake, but i fixed that now. its in the master. The feedback part was really great, i have learnt alot from you. I would like to send you some beer or an amazon gift card to show my gratitude, for actually going through the code and giving me your feedback.
Hey, jsharief, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Well spotted. Thank you. There are some places i should of used it, i will go through and look for these.
Namespaces not considered as "modern", they exist since PHP 5.3. Modern features are loose coupling, DI/DIC, PSR-compatible Components and many more. Have a look at the Symfony or Laravel Docs to see examples.
Thanks for finding it - I already fixed the link :) Thank you
&gt; You told people there was a security issue due to the salt and pepper. I am not hashing passwords with the hash function, i am using the best practice (brcypt), this hash function is a simple hasher. According to https://blog.ircmaxell.com/2012/04/properly-salting-passwords-case-against.html it says there is no proof that peppering provides better security etc. I hope you find the article interesting. The point /u/phordijk was making is that you are _only_ using a pepper, but you are referring to it as a salt. A salt should be unique to every single password and stored alongside it in the database. You are instead creating a static site-wide string and calling it a salt, but this is actually a pepper, which as you correctly point out doesn't really add any great measure of security. The point of a salt is that every single password has it's own unique salt, forcing an attacker to break each hash individually rather than generating a massive table of possible password hashes that will work for every single hash in the database. PHP's `password_hash()` function already automatically generates a salt, so there's no need for you to do this yourself.
this is such a simple set of simple functions. Not sure what all this praise is about. Sorry to say it but to install a dependency to make &gt;function intToBool(int $int): bool { &gt; &gt;if ($int === 1) { &gt; &gt;return true; &gt; &gt;} &gt; &gt;if ($int === 0) { &gt; &gt; return false; &gt; &gt;} &gt; &gt;throw new Uncastable("Int {$int} cannot be cast to bool"); &gt; &gt;} is beyond me.
write a cronjob with an update query
I'm actually pretty new in PHP and SQL, do you have any Sample-Template ? I don't have Access to the Server directly just via PHPmyAdmin and Plesk. Thx for the quick reply
You can absolutely hire me.
I would actually pay some $$$ if this could fix my Problem properly
Pardon me: if you have 3900 rows as a property for each object, I bet something is wrong with your database layout: Are there values constantly repating all over the DB? Then you should consider 1:n or n:m relations instead. Anything will get much faster and efficient then.
What are you talking about? 3900 rows in database table is absolutely fine.
The Database is a collection of every Player i met in CSGO, so every Row is just | Profile-link | Name | SteamID | Avatar | Ban-Status | And i want that the Table is updating every single Entry when it gets changed. You can visit the Site [Here](www.meckeofficial.com)
PM me
Not much? What's great fake-news and fear-mongering access
15years of programming and you didn't know to add test before refactoring?
In all my years of programming - until phordijk pointed it out, i had no idea of the correct terminology of this, I was taught and everybody referred to this as salt, especially in the old when had to hash passwords manually. I think many developers here would say the same, that we call the 'pepper' salt. I am sure if follow the correct terminology, i will be blasted for not following the accepted standard term salt until they PSR it. Thanks
What's is X+C?
The problem is, That i find it very difficult to use.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You don't have to install it if you don't want to! Btw you took the simplest one to prove your point ;)
wat
Welcome to open source dude. If you dislike this kind of shit go full proprietary.
wat
I'm just now thinking, how funny would it be if an extension like xdebug put actual full page adds in phpinfo ü§£
 LINK [https://github.com/gazmendsahiti/mvcprojectcreator](https://github.com/gazmendsahiti/mvcprojectcreator)
It's missing any documentation. And seems useless anyway, since most MVC frameworks have their own directory structure and tools to create it.
Yes but there are people who use pure php too
Thanks for sharing
Have you tried turning if off and on again
&gt;Sorry, but I don't understand why you say this is bad? At best, nothing which holds state should be statically initialized (gobal). Or to put it in another way: the fix is simple to inject the manager (in the constructor)
Having down two rewrites, never again. Yes, we ended up with better code and a better product....BUT! It took FOREVER. We are not effectively using the strangler pattern: https://www.michielrook.nl/2016/11/strangler-pattern-practice/ Allows for delivering clean code, faster, without rocking the entire boat. I actually feel like I get MORE time to focus on clean code and effective unit tests when using this approach due to the limited scope of the refactor.
Yep, I figured it out. The issue was that you linked to the framework, not the library that has all those other directories so it was confusing.
Indeed. The timing attack only works if the delay is considerable. If it is in the fraction of microseconds then no, it is impossible to test it. Why?. **Because the latency of the network is anything but stable and it generates enough entropy to simply be impossible to test a timing attack.** &amp;#x200B; Most of the timing attack vulnerabilities are FUD.
Show us your code and tell us exactly what is not working.
Hi there: Personally, I'm against framework but I checked it anyway. What I don't like is the view and it is a personal opinion. Your view is not based on a template but in code (the same than the code of React), it breaks SRP. So, I don't think it is true MVC. You could use my library for that. [https://github.com/EFTEC/bladeone](https://github.com/EFTEC/bladeone) (MIT, one class, no dependency and it's quite fast cause it is compiled, also it's based on Laravel's Blade, so the documentation is done). I already tested it in production. &amp;#x200B; About cache, tsk tsk, it will not work. Do you know what is really hard about cache? invalidation. I have a library about cache, it's more basic than yours (it's already tested on production). [https://github.com/EFTEC/cacheone](https://github.com/EFTEC/cacheone) But in a nutshell: let's say we have a table Customer and we want to cache the information. &amp;#x200B; // read from the database $success = Cache::write('customers',$listCustomer); &amp;#x200B; Now, let's say we want to cache a list of customers but filtered by a condition, for example: Male Customers. &amp;#x200B; // read from the database filtered by query. $success = Cache::write('customers_filter',$listCustomer); &amp;#x200B; But this cache misses the condition (**customers\_filter** will returns male customers regardless of the condition). But even more. Let's say I insert a new customer. It must invalidate some cache. In my case, I invalidate the whole group. &amp;#x200B; And about the Model (note: it's funny how the PHP developers call the REPOSITORY, DAL/ DAL class as MODEL). Rule of thumb: SQL &gt; OOP. SQL is way more powerful, flexible and efficient. For example, JAVA Developers has JPA and Hibernate but they could rely on the native/ raw query. C# developers (with Entity Framework) too.
&gt; A framework like Symphony is built out of decoupled components that can &amp;#x200B; In the paper, yes but it is not in a real-world scenario. &amp;#x200B; I
I don't get the relevance of this.
PHP &amp; JS yes, certainly but WordPress is definitely not something I want to get into.
It could be worse, for example, to add ajax or pixel tracking.
Yes, `"value = {$obj-&gt;getValue()}"` will work. Was that your question?
&gt;"value = {$obj-&gt;getValue()}" I tried something similar earlier today, but I was getting an error message, I wasn't sure if this syntax worked with method calls. I replaced it with the dot notation. I retried it now with an simple echo and it worked. Thanks for answering.
Wait, you're using a web interface to create a bunch of local files / directories? You know that PHP is a multi purpose language and has a fantastic CLI SAPI? This really should be a couple of lines of CLI script.
I really didn‚Äôt use CLI that much but I will have this in mind
I know, I know you guys LOVE to downvote my stuff to hell. But here's a much better alternative: https://github.com/phpexpertsinc/skeleton You just run it like `composer create-project phpexperts/skeleton my-project` and it will set up a directory structure that conforms to the Standard PHP Project Layout: see https://blog.nikolaposa.in.rs/2017/01/16/on-structuring-php-projects/ It includes a complete TravisCI config that will run phpstan, phpunit, phpcs (to detect PSR12 for src/ and PSR1 for tests/), and more. Plus, it stays up with the latest and best from all of my projects.
&gt; My advice to you is to check the facts first, have you looked through the commits to see that its really 50% no comments? How many people jumped on the bandwagon, without forming their own opinion. I can throw in a few interfaces and implement some PSR101, but whilst that might make you think you are an experienced programmer, solving the problems with better design and less code is more a deciding factor. And OMG i have some public properties, its not the end of the world This right here makes me wonder how seriously you take the project. Developing a framework is a lot more work then building a web platform or a web app of any kind. When it comes to a framework, you have to ask, what problems am I solving that another framework is not solving, or how can I approach the same solution more effectively. Your framework doesn‚Äôt really solve anything that Laravel or symfony solves. &gt;Yes, one my first day of release, there were a few things, which were easily fixed, but did the people who mentioned issues, actually praise about other security issues which it handles very well , no . Give me a frickin chance. This is more of a 0.01 or a 0.1.0 release not a 1.0 release. You have major issues, as others have mentioned around security. Issues with csrf, sql injection just to name a few. This is not a secure framework, if you have any security issue, such as a sql injection issue, then the framework is basically garbage. Your first impression that you gave us was that you should have created wrappers around symfony components as opposed to rolling your own. My biggest issue is that your responses are being downvoted, into the negatives, and reading your responses, you seem - even in this response - defensive, which you cannot afford to be, millions of developers do not use this, you are not Dhh or even Taylor. I would caution agains5 being so defensive, and act a little more professional.
If you‚Äôre going to use that logic, then you might as well comment this question on every ones post. Don‚Äôt be a dick is the point I‚Äôm getting to.
That would be interesting to see.
Wtf there is almost no difference between 7.x and 5.6... well not enough that can be learn in 2-3 hours
As I understand it: // Existing function strstr('foobarbaz', 'bar'); // 'barbaz' strstr('foobarbaz', 'bar', true); // 'foo' // Proposed function strrstr('foobarbaz', 'bar'); // 'foobar' strrstr('foobarbaz', 'bar', true); // 'baz'
You should submit this to the official PHP build!
I agree with other posters particularly regarding PHP the right way. In terms of frameworks I would look at PhalconPHP. PhalconPHP is most often referenced in relation to it's speed but in terms of an easy introduction it excels in relation to the others. Both Laravel and Symfony have quite a steep learning curve and require you to become familiar with a bunch of third party components/bundles/generators before you can do anything significant. Phalcon, once you get the PHP extension installed, has everything you need in the box. The basic folder structure is also much simpler to get your head around than many other frameworks. The standard documentation is just okay but this guide -[www.learnphalcon.com](https://www.learnphalcon.com), can get you up and running very quickly.
Calling it a fantastic is a bit too much
Flex was my true introduction to symfony, love how quickly I spun up an invoicing site with stripe after my bank banned a clients country lol. (yikes, needed my money so had to get it done) Before that I relied mostly on Slim3 as a router and Auryn/PHP-DI for auto configuration. Gave me a lot of flexibility and control over my code and I feel like flex does a good job of essentially doing all that and more. I couldn't wrap my head around bundles in 2/3 a few years ago, not sure what the reason for it was, could've just been me being stubborn. Before Slim3, I was using Laravel 4, really liked laravel 4 back then, but I came to terms that I wasn't a fan of all the static classes (laravel's facades) littered in my code. Made a lot of my custom classes coupled, and this became a problem when I wanted to pull some of that stuff out and reuse it in other projects that wasn't using laravel. That was probably a fault on myself for using laravel the way it was meant to be used rather than using laravel in a way that benefited me 1, 2 or even 5 years later. Will be honest though around that time SOLID wasn't really ingrained in my brain and with Slim3 I started writing code completely different. I'm excited for the future of Symfony &amp; Slim. They've done me a great service over the years and I still maintain code for both.
He‚Äôs not demanding, he‚Äôs asking.
You should really programm in english, even its a non english video.
&gt;Plus, it stays up with the latest and best from all of my projects. "up to date". Your SSL is not up to date Sir.
Como ejemplo para estudiantes est√° bien. Pero no creo que deba ser tomado como referencia como buenas pr√°cticas. Para hacer exactamente lo mismo que hay en el v√≠deo hay ORM's que est√°n a una d√©cada de ese c√≥digo. Por ejemplo Eloquent o Doctrine. &amp;#x200B; As an example for students it is fine. But I do not think it should be taken as a reference as good practices. To do exactly what is in the video there are ORM's that are a decade away from that code. For example Eloquent or Doctrine.
&gt; Which is more time than most of the people complaining have ever spent contributing to a project. Ah, my bad, I forgot that you know everything and are always right. Carry on, great job by the way, I just want to thank you on behalf of people like me everywhere. &gt;Many of the people complaining in this thread will invest FAR more time complaining than contributing. Those bastards! I feel like grabbing my pitchfork right now.
Stop using mysql_*, it's been 6 years since it's been deprecated already
I saw someone took a star away from T-Regx. That's too bad :/ If by some chance you're reading this post, please, could you tell me what was the reason for the stare revoke? :D It would help me out making the library better.
And yea, it does count :D
White background, white text.
Yes, it does! Check out [Prepared Patterns](https://t-regx.com/docs/handling-user-input)!
&gt;In my understanding constructive criticism means to try to find negatives (hence "criticism") but state them without unnecessary emotion and without getting personal. I think we just have different definitions then. I did a quick Google for a definition (in the UK so your results might vary) and the top 5 all mention positive and negative feedback. 4 of the 5 also mention along the lines of what to change or positive suggestions. So from that definition, I think my above comment was valid but maybe I should have defined how I understood the term constructive criticism before giving my view based on that understanding.
&gt;/u/phordikj spent time at no charge going through code, pointing exactly where there's an issue, and indicating an easily-searched set of terms to find out why he's taking issue with that code. Of course, I have no doubt they spent time going through it, as mentioned they where technically correct in their assertions in the code. &gt;The fact they didn't also go to the extra unpaid effort of explaining what you can find readily with a search engine doesn't count as a negative in my mind. This is why, with my understanding of the term, I don't believe the feedback was constructive criticism. It was only negative in nature, which from my understanding of the definition it wasn't constructive criticism, it was just criticism. &gt;The feedback isn't constructive per se, but combined with basic web searches it's incredibly informative. I completely agree and agree with most of the points you made, however, the post above to which I replied to asked: "What was not constructive about phordijk's criticism?" and from my understanding of the term constructive criticism, the reply wasn't constructive as I understand the term.
Sorry, I have just been getting tired of being insulted and people being condescending. Where is the issue with the SQL injection you are talking about? You can see using prepared statements from day one.
&gt;No, it's not Model2 MVC (which is the full name of it ... that you somehow managed to forget ... odd). I'm simply going from the creator's original definition, it was never called Model2 MVC, the actual full technical name he gave, the first time it appeared in the JSP specification was JSP Model 2 architecture. He never used the term MVC in its name and I didn't write out "JSP Model 2 architecture" as most people simply know it by the name of model 2, at least coming from the Java world anyway.
Ah I'm sorry, I mistook that for columns. My bad.
I'm sorry, I mistook rows for columns. My bad, will erase my post. Have fun :)
While i appreciate the fact there's a new framework, it is my personal opinion that it would be better to help with development of current frameworks like Symfony, Laravel, Yii, etc. Rather than making your own. It may seem cool, but making it a success requires enormous work and effort and chances are very high you wont reach anywhere near what current mature frameworks can do. So, while i do like that you made a new one yourself, i would advise you help with development in existing frameworks.
This doesn't refute anything that I'm saying. You either create a product that you ask for money from the get go or you provision donations for EVERY contributor - that's fair. I'm sure we would've had xDebug without Dereck. Don't turn him into a saint now. He's not the only contributor there. xDebug grew bigger than its creator. So is Linux. Another open-source solution btw, which doesn't ask for Patreon funding. Neither is Laravel / Taylor asking for money and countless of other great examples of open-source done right. See, I'm not minimizing the effort of the contributors. Time is money and a lot of time went into xDebug. However starting to put shady links in phpinfo() is kind of shady. He could set up the link in xDebug's project page. Nobody would complain. That's what 99% of open-source projects do. In the grand scheme of things, it's fucked up that debugging is an extension in PHP and not a core and something taht the core team should work toward. Like, imagine developing in C# or Java without a debugger? Crazy.
I was thinking like you but had to explain myself and realized ... how fucked up it is to ship a language without official debugger support?
This is an extension we're talking about here, not the language itself.
&gt; Figure out a better way to get the developers the funding they need and I'll be ready to listen. https://venturebeat.com/2019/05/23/github-adds-donation-button-token-scanning-and-enterprise-tools/
I appreciate your feedback. Thanks.
phetch?
&gt; how fucked up we're talking about PHP here
Ha, I like it.