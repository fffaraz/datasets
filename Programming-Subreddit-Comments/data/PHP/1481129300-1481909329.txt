i mean i can do a basic php oop login and register and crud using php oop, and do password hash from scratch, i also done wordpress codex php so i think im confident i think, but the thing is, i never had a php job, so i wouldn't know what most of them expect you to know how to do.
The reason is that you can see if you get along with other frameworks. But to be fair, Symfony is pretty similar to Laravel. Also a lot of people are using Symfony, so if you want to get a PHP job it is useful to have some experience with it.
I just installed the 2016.2 icon pack and moved on. The weirder one was the change to the highlighting of the tabs for which file you are currently working on.
I don't know the reason of this behavior, but I think it's because three different part of the code deal with these numbers. Intval has a special, more resilient method to parse numbers from strings than the PHP parser so the code that deal with edge cases could be different. But I would expect 1e10 and 420000000000000000000 to have the same behavior.
Still no fix for the reopen dialog regression. :(
I'll just leave this here. Whether or not you choose to use WordPress is on your own conscience. https://easydigitaldownloads.com/
The cert file on haxx.se is a list maintained by Mozilla. I don't know how often it's updated on haxx.se (probably all the time) or how often you need to update it locally (probably make a cron job to grab it from time to time just in case something changes that affects you).
Out of curiosity, did you tweak opcache settings from their default values?
&gt; i'll be interested knowing in what people consider a good implementation of the "security" layer in a web framework. I have kind of a controversial attitude on this topic. One of the things that [Action-Domain-Responder](http://pmjones.io/adr) made apparent to me was that authentication/authorization/security belong in the **domain** (or model) layer, not in the Action+Responder (or controller+view) layer. The controller/action might collect input from the request for the model/domain to use, but the model/domain should be doing the heavy lifting there. Tying security to URLs, in that sense, breaks the separation of concerns between the user interface (i.e., the request &amp; response) and the underlying domain logic. So to me, the "'security' layer" doesn't belong in "a web framework", per se. It belongs in the domain.
You probably know enough to get a junior job, but you need to generalise a little more on code design and frameworks, and make yourself familiar with the command line, Unix-like systems and the technology stack your software runs on top of. 
Have you worked as a junior php dev ?
Yeah...gross. You'd have to type your own namespaces and stuff.
mysqli will stay as it is the replacement of the old mysql-stuff
Well, as long as your certs don't get out of date (or you don't rely on whatever you send being secure and whatever is returned over encrypted channels, just like it were unencrypted), no issue.
And that's what the (relatively) new security guard is for, making logging in with _any_ type of credentials pretty straight forward :-)
i love the command line thanks man, any tips on getting a php job like the one you got, if you have no professional job experience but have a portfolio and freelance jobs to back your experience up ?
try PDO however
From what I've seen so far - I'm totally sold. While laravel is easy to use and symfony is very decoupled, symfony is a bit cumbersome and laravel uses magic almost everywhere. Opulence seems to have functionality, elegance and transparency. It's pretty much how I have implemented similar components - or in some places would have/will given enough time :) One general thing - I have noticed a frequent use of classes extending abstract base classes in order to share some core functionality.... which is certainly legitimate, but personally, I feel an interfaces + traits pattern is more flexible and expressive. This way, we extract singular capacities as traits, and can combine as many as we wish to help provide a base implementation of an interface. Traits can be used by any class without having to become part of an inheritance hierarchy, they allow for finer granularity and and most of all - we can use as many traits as we want, all of which provides the added flexibility. Also, since there is very little magic, I think this project could benefit from using php 7.1 scalar type hints and return type declarations for more transparency, more static-inspection-time instead of runtime errors, less cognitive load and better performance. But to reiterate - so far, from what I've seen, these are pretty much the only things I would change. Very well done!
You really should check out PDO. MySQLi is okay for patching legacy code, otherwise all new projects **should** use PDO
Thank you! Do you have examples of classes in Opulence that you feel could be refactored? I do use PHP 7.0's scalar type hints and return types, but I cannot take advantage of PHP 7.1's nullable types and void return types because it's just too new to force on people.
You won't find HHVM on a typical customer server, so the question is who do you target. If you want compatibility with 80% of the hosted sites out there, you need to target PHP, and so you need to go PHP 7. If not... then you don't need to use a PHP derivative at all, you can use any language on the planet, depending on your needs. What are your needs. Is it just speed? Is it truly *just raw speed you need*? Then the likes of C++, Rust, Java, Go are *at least an order of magnitude faster* than either PHP 7 or HHVM. Even a more moderate offering like Node.JS, using JavaScript you should be familiar with, is leaving PHP in the dust. But I seriously doubt you'd need that speed, even if you see high (for you) traffic. So make sure you know what you need, first. P.S.: If you ask me, HHVM's greatest value was to push PHP to improve. PHP had fallen asleep for almost a decade, and its future was bleak. Not anymore, thanks HHVM. But unless your name is "Facebook", the reasons to use HHVM are simply not there. You either need PHP 7, or you should consider another language (or a combination of multiple languages). 
No.
Please don't spread misconceptions. MySQLi provides features like multiple statement queries and async queries, among others, that PDO doesn't provide. PDO is just a baseline solution. There's no "**should**" in there. Both solutions are well supported and will continue to be.
He's asking about PHP skills not YAML skills.
Downloading it now, going to give it a whirl! Edit: Actually - getting a 500 handle error.
Ah, thanks for catching my mixup between the 7 and 7.1 features :) I did mean to refer to nullables types, void return types and class constant visibility. Since 7.1 has been released, I don't think it's too early to take advantage of its features - it's the most current released version. But you do have a point - one might consider a separate 7.1 branch which can then become the master when people have had the chance to get used to it. I generally try to refactor all uses of abstract base classes to traits and interfaces where possible for the added flexibility - though I do use inheritance for interfaces (lacking a proper way to compose or mix in api-requirements) and for Exceptions, variations on SPL classes etc. But looking around the repo, at a first glance I notice the Validator component and its rules. The NotIn rule extends the InRule (for set-element checking) - which looks to me like a violation of the Liskov substitution principle, since the defining invariant of the InRule is not maintained. The subtype cannot be used to same effect as the supertype. Depending on what granularity might be of use in the rest of the codebase, we might extract a "ChecksSetMembership" faculty. The same seems to apply to the QueryBuilder's InCondition and NotInCondition, which could be represented by a "BuildsSQLSetMembershipCondition" faculty without violating LSP. I've also found it valuable that traits share abstract classes' capacity to declare abstract methods, which I use for non-public methods required to enact the trait's faculty by providing individually varying data or processes for the concrete implementations which use the traits, and to which methods of the trait can dispatch. Thus you have basically all of the power of abstract classes without the limitation to singular inheritance hierarchies *and the danger of playing a little too fast and loose with LSP.
Auth is probably one of the most complex parts of Symfony, it doesn't surprise me that it is more complicated than, say, routing. However, I think it's flexible enough that if you spend a couple of hours figuring it out, you can configure any kind of authentication mechanism in Symfony. 
Yeah I did! :(
What exception message are you seeing?
Source is here: http://mpm-itk.sesse.net/ ITK is widely used by mass vhosting providers, is very easy to use, is available directly in Debian, and allows to nice and limit the number of connections per vhost. But if you have time to go through the pains of setting up fpm yeah it may provide better performance. But for most common uses ITK is more than enough.
Yeah, I may require 7.1 in a future, major version release. I wish 7.1 included more features; I feel like it was just a few features that honestly should've been part of 7.0. As a C# developer professionally, I long for non-magical getter/setter properties and generics. Oh well, might have to wait a while for those features. You definitely have a point with the examples you listed - they're violating LSP, and I'll patch those (thanks for pointing that out!). If you find any other similar cases, please let me know. I appreciate the constructive feedback!
The project.x page isnâ€™t working project.x is currently unable to handle this request. HTTP ERROR 500
What's your setup? What OS are you running? Are you running PHP 7.0 or higher? Is there a stack trace or anything being output to your error logs?
Oh my god, I didn't bother checking the logs because I'm obviously an idiot.... -.- There was some recursive permission issues! Okay, first challenge out of the way.... get it working XD sorry! Edit: "You just successfully created your first Opulence application. That wasn't too hard, was it?" - for a moron like me... X'D just a bit!
haha I'm glad it was nothing too serious!
Yes pre-gaurd, authentication was a nightmare. Now I can do authentication in a single class.
HHVM is pretty badass, but it will take more work to get your server up and running with it. For example, on DigitalOcean I can spin up a LAMP Server running PHP 7 with one click. But if I wanted to run HHVM, I'd have to install and configure everything myself from the command line.
I was hoping they included Touch bar support. It'd be great for going through steps when debugging. 
[removed]
If you're asking ONLY about performance, go with PHP7. It's quite competitive with HHVM on perf and has a much broader ecosystem and support network. HOWEVER, HackLang is the language PHP deserves to be, and there are some very compelling reasons to use it. HHVM runs HackLang, PHP does not.
[removed]
&gt; We accomplish this by utilising Public Key Encryption to create a unique key pair with a 4096 bit key on registration. Oh god. * https://github.com/captain-redbeard/php-messenger/blob/959362459c5e387ebc1c6ab47d845a005236cebc/app/Core/PublicPrivateKey.php#L88 * https://github.com/captain-redbeard/php-messenger/blob/959362459c5e387ebc1c6ab47d845a005236cebc/app/Core/PublicPrivateKey.php#L129 Please see: https://framework.zend.com/security/advisory/ZF2015-10
Forget mysqli extension. Go for PDO.
The complexity to symfony's security system isn't on surrounding how it hashes/salts/compares/whatever passwords. Its complexity comes from the many many many different ways it can be set up depending on the use case of the developer. Security is FAR more than just a simple login screen with password hashing.
There are far more edge cases for security than the other components. They did make security a LOT simpler with the Guard Authentication stuff. I'll admit the docs could be a bit better, and they could have prefab classes for people, but, generally, those wouldn't get used, as peoples use-cases are more complicated.
Haha, okay, I'm quite impressed then. Thought you maybe meant CPM instead of WPM, thanks for explanation. :)
You should continue to use MySQL, or PostgreSQL, as both have now sharding solutions in case your data become really big. Simply use SQL and proper indexes.
Sure thing. It's not really that impressive, lol. More a sign of a wasted life ;)
Got a source for that bold statement?
https://3v4l.org/n0aKX
Are you sure that you properly read the PHP docs? All you have to do is, just open any mysql\_* function and open any mysqli\_* function and the deprecation note / support is listed: http://php.net/manual/en/function.mysql-connect.php: "(PHP 4, PHP 5) This extension was deprecated in PHP 5.5.0, and it was removed in PHP 7.0.0." http://php.net/manual/en/function.mysqli-connect.php: "(PHP 5, PHP 7)" 
Thanks. I'm starting to somewhat dislike the design principles behind PDO... 
[removed]
This, plus some sort of e-commerce add on. I've been part of a project that used http://www.coursemerchant.com/ before I'm sure there are tons of options.
[removed]
Looks good! However, isn't it possible to use `Illuminate\Validation` outside of Laravel? One big feature that seems to be missing is to check whether or not a value is present in a DB table.
Looks good. My personal preference would be something with a more fluent interface like the [CakePHP validation library](https://github.com/cakephp/validation).
wat?
&gt;&gt; Throws catcheable exceptions for better error handling (quality) &gt; &gt; This is the only 100% true item in your list. Even then, you can turn exceptions on right? mysqli_report(MYSQLI_REPORT_ERROR | MYSQLI_REPORT_STRICT); MYSQLI_REPORT_ERROR Report errors from mysqli function calls MYSQLI_REPORT_STRICT Throw mysqli_sql_exception for errors instead of warnings 
mysql_ has been officially deprecated since 2013 its not something new to 2016 or PHP 7, I'm amazed your project still has it. mysqli_ is 'ok' but i worry you're seeing it (as almost every enter level dev does) as oh I will simply just put 'i' at the end of all my mysql statements and everything will be ok, then you're certainly doing it wrong. mysqli_ introduces many new features the main one of note is the ability to bind parameters. As many have said though you need to be looking at PDO, it gives you the greatest flexibility and is used in a OO way which is a good way to start thinking when developing your applications. 
Note that these descriptions nowhere explains why it should be used exactly the way it shown in your example ;) It took me quite a time to realize the proper format. MYSQLI_REPORT_ALL is really a nuisance sometimes.
Do you have some proof or just your guts. Seriously interested. 
I never used mysql_* but mysqli which is why asked if it was getting removed aswell :)
nikic doesn't blow hot air.
Since when does anything good come out of that website?
PDO is Ok with multiple statements though. Nevertheless, I wholeheartedly agree with your general statement.
When you take mysqli and start building something even remotely as useful as PDO, you'll begin to understand and appreciate these principles.
Java Message Service like implementation of AMQP protocol. It is based on AMQP php extension (which is fast). Could be used to send or consume messages from RabbitMQ. https://github.com/formapro/amqp-ext-transport
Considering these benches are for CPU-heavy situations, does that mean that the majority of real applications are bottlenecked by other factors?
sure, a lot of web applications are IO bound: database queries, API calls, file access. WordPress or any other CMS for example.
&gt; it does personally seem to me, a little late in the request to handle security for others. If you'll indulge me, can you say why you think that might be so? (I understand if it's difficult to articulate.)
Just a list of the top of my head, and in no particular order: * Easier to maintain * Easier to transfer to another person * Software is used by 1000ths of people: battletested * Software is scrutinized by 1000ths of people: more secure * The less you write your own code, the less bugs you will have * Your own knowledge pales in comparison to wisdom of the crowd * Usually you can be way more productive: most of the hard work has already been done &gt; I've made a number of web apps for the company I work for some of which they are heavily reliant on This to me sounds like a great risk to the company and borderline irresponsible. You seem to be THE bus factor.
One primary reason to use PHP frameworks is that you can get started more quickly and conveniently as the frameworks provide a rich library so you dont have to reinvent the wheels, thus saving your time and money for developers. Frameworks also abstract away some lower-level details that you dont have to worry about in most circumstances, allowing you to focus on what is the most important to your business domain. Moreover, large and popular frameworks are maintained by dedicated, competent and trustworthy open source teams, so you are guaranteed to have issues/bugs fixed quickly. Vanilla PHP only works for small and hobbyist websites, once you need complex business and data-access logic, you will have to write a lot of classes/functions. In the end, you will have built your own framework that resembles the popular frameworks, only it will take your precious time, money and it will be less reliable. But of course, there are times when Vanilla PHP will do, such as some freelancer work, for which full-fledged frameworks like Symfony and Zend may be overkill. All you need is to use the right tools for your job, theres no definite answer to what will certainly work for you. 
1000ths of people = people divided into a 1000 pieces 1000s of people = thousands of people
You're absolutely correct. The bus factor is a thing. The app in question was required to win a huge contract, my company didn't have the time or budget to have a bespoke software package made that fitted this clients requirement. The management are not tech savvy enough to really understand, and for me it means job security. 
ARE YOU TRYING TO TELL ME THE DEFAULTS ARE NOT GOOD ENOUGH TAYLOR? :D
Ask for a pay rise.
[removed]
Depends from where you're measuring. From below 7.0 there sure are huge improvements, but I don't know any mayor site which already runs 7.1 since it's just out there for a few days. And I think MarceauKa was referring to the bump from 7.0 to 7.1.
Haha I'm content with the job security :)
Let those dudes continue coding Python. I'll continue with PHP (7). I get lots of stuff done with my PHP: I write productive code (useful for users), which is performant, scalable and well-tested. I write code to solve problems. With the new abilities of PHP, that works great. Btw. I also know people developing websites with Perl. ;-)
&gt; I have no idea if he's a contributor to that or just a user and advocate, but "main dev of libsodium" is not quite right. A minor contributor to the PECL extension, and I contributed documentation, and use it in my projects.
Ah, ok, that makes sense. 
This was submitted before with a misleading title (I'm not the main libsodium dev). I'm making the initial repo public soon. (Just have to finish implementing some features and ensuring complete test coverage.) I will **not** be signing/releasing anything until it's audited by a third party.
It is easy enough to create an account and push your code there. All this thread will give you is the same generalities that the thousand or so other threads on the exact same topic would give you. One assumes that your case is unique which is why you decided to ignore the existing threads ask a new question. And yet without some idea of how your existing code actually works, it's difficult to see how anything new could be added.
I'm new to this sub and didn't realise it was a common theme 
It is possible to make use of Laravel's validation library outside the framework but it has too many dependencies I think. The dB functionality should be workable if the author adds "rules registration" (the db rule would be hard to implement in the core as the code is trying to stay "un-tied" to any framework, so that probably would be something you write yourself).
That's why you wrap it via https://github.com/cakephp/chronos (well not only because of that^^) - and it will internally take care of this small BC issue: https://github.com/cakephp/chronos/releases/tag/1.0.1 solved this as patch.
&gt; I've managed to remove most PHP 4 content last year Oh, are you a core contributor or something like that? Thanks for your work then \^_^ &gt; What do you find annoying, unclear, missing or bad in any other way? * **PHP at the Core: A Hacker's Guide** is basically empty * Is there a git repository for documentation?
It is not reddit specific. Copy your title into a google search bar and then start reading. And if you are really bored, copy some of the responses into the search bar as well just to see how often the exact same response is used across the internet. But do think about posting some code. It is often difficult to see how abstract concepts and generalities can be applied to your specific case. Having some actual code to look at would be a nice change of pace. It is entirely possible that you may have developed your very own framework without realizing it.
Not this thread again.
With that code, your job is absolutely secure. Ask for a raise :)
Translations are managed by volounteers all around the world. The sad truth is... maybe only 5 or 6 of them are really kept up to date. You can take a look at http://doc.php.net (http://doc.php.net/revcheck.php plus "Graph" view for each language should tell you most) if you like numbers &amp; data. We do, however, considering some ways to prevent such issues: https://bugs.php.net/bug.php?id=44903 do you think solution like this would help?
&gt; I'm afraid that it's almost impossible due to the fact that manual translations rely on Might be time to rethink the need for translations as well. Given the rather remarkable translation capabilities provided by today's browser, I wonder if the effort of manually translating the docs is well spent.
All languages are great if you use them properly, for what they're good at. A great developer understand that there's no one language that does it all, PHP included, and picks the best language for the job.
Do you have some proof or just your guts. Seriously interested. 
I think the comment system could use some kind of revamp. There's an enormous amount of helpful examples in there, but also a lot of ancient advice that's now either inaccurate, broken, or even outright dangerous. Bots (or something) have rendered the voting system useless over the years. I don't really know what I'd suggest to fix it, because anything is going to be a huge undertaking. Maybe as a start, wipe all existing votes and only allow registered users to comment/vote going forward.
I find it unclear what the best way is to report minor issues. I have reported doc bugs to bugs.php.net on some occasions and I have posted comments on others. But sometimes I leave it be. For example, the new JSON_UNESCAPED_LINE_TERMINATORS is mentioned on http://php.net/manual/en/json.constants.php but not on http://php.net/json_encode. That is an issue but I'm not sure if it's good to report it to bugs.php.net. I don't think a comment is good in that case (it really should be mentioned in the docs among the others). And I end up thinking: maybe the work is in progress - since 7.1 is new? Suggestion: add a quick way to report minor things.
The JIT engine hitting stable is going to open up a lot of possibilities. How very exciting! I could see PHP really benefiting from an ART style run time where everything is "compiled" before hand.
Also, the code snippets are hard to follow: $res = mysqli_query($mysqli, "SELECT 'Please, do not use ' AS _msg FROM DUAL"); Couldn't the SQL there be a little bit simpler? Maybe something like: "SELECT * FROM myTable;" If you compare the code snippets on W3Schools to PHP.NET, the W3Schools examples are much easier to follow. If you want to make PHP.NET better, follow W3Schools lead. 
Just a word of encouragement: the PHP documentation is some of the best documentation I use. Thanks for your hard work! I do wish that some of the more useful user comments would be made part of the documentation itself. Some of those comments include important clarifications or improved examples.
I got the expected results from a few tries, do you have an example of one that breaks? echo convert_to_float("1 1/2") . "\n"; echo convert_to_float("75 1/3") . "\n"; echo convert_to_float("6 10/20") . "\n"; echo convert_to_float("4021 10/5") . "\n"; //output 1.5 75.33333333333333 6.5 4023 
All languages get "looked down on". It's common for younger and less-than-expert devs to dis the languages they do not use or understand. Considering that PHP is far more popular than other languages it could be that other languages get dissed more than PHP. I dis .NET anytime I can :)
Why is the release schedule accelerating? It's still once a year.
We really need a better search. It's fine when using Google, but the internal search is not. Example: http://php.net/manual-lookup.php?pattern=ssl+context&amp;src={referrer:source?}
Does JIT compiler bring any performance improvement when using Opcache and hitting a cached opcode ? Or are the opcodes already getting every possible gain from compilation ?
That being said, I do use NodeJS and Python in similar ways I use bash-- NodeJS mostly for gulp and front end package management. Python is sometimes easier to use than bash-- say for low resource usage when parsing of Excel files. I upload an excel file via PHP. A cron job checks for new files and fires up a python script if it finds any. The extracted data gets shoved into MySQL unceremoniously. The new data becomes available to the PHP via the database...
Works for me too. The only thing of note in the code is that you are escaping the forward slash when you don't need to, ie you can use `/` instead of `\/` because you are not using slashes for the regex delimiter. But that should have no effect on output. 
Would it be possible to over time migrate to a git repository? The structure for it could be docs - en - pl - es - ... The docs will work based on the `en` structure of the English documentation, but if you visit for example `de.php.net/.../function.name.php` it will look for the file in the `de` folder, if it doesn't exist, it will fallback to say `view in english` and `offer to translate`. This seems like a pretty standard and sensible option, and make contributions easier to deal with. The way that the laravel documentation is built and displayed works remarkably well, both in terms of how easy it is to contribute, and also how easy it is to work your way around. Whilst it is in only one language, it has multiple versions, which is essentially the same thing. I'd be willing to help build the system with you if you are looking for assistance. Edit. It should be completely possible to migrate all existing comments over from SVN, and have them all setup so we lose no current translations.
That's a bit vague. Do you mean each function would have a drop down for the version? Or that there is a page listing all functions, where the drop down shows you what's in each version? TBH in either case I see little value. With the former, each function page already has a list of changes per version where applicable. They are fairly few and far between. With the latter, there aren't a huge number of functions introduced in each version, so it doesn't seem that helpful to me. 
Hi. There's no problem with displaying translated versions really. But there is one when it comes to checking the difference between current translation and its English counterpart. If you are really interested, I suggest you to read http://doc.php.net/tutorial/translating.php and something like http://doc.php.net/revcheck.php?p=files&amp;lang=pl Then you'll see what I'm talking about and why the way SVN revisions work is important here. Thank you for the reply and interest!
PHP Parse error: syntax error, unexpected 'this' (T_STRING) in php reddit code on line 1
For simple things like, i only want ROLE_ADMIN to be able to access a simple page (especially if its just a static page, that has no model), I'd think it would make more sense to throw a 403 before it even gets into the controller
I don't think relying on automated translations is a good idea. Even today they are far from perfect, especially for technical content. I worry that a bad translation could be misleading or even dangerous. Plus they are less accessible: not every browser has auto translate, you won't get your language showing up in Google, etc. 
Having over 25k notes in the manual, we have maybe 4 or 5 people actively looking after them. Plus me, for a few weeks. I'm sure everyone is giving their best to clean that mess up, but it just takes huge amounts of time. Feel free to point me to specific notes, if you wish. I will happily look into incorporating them.
Yes. Opcode is still interpreted. The JIT compiler generated CPU specific instructions.
I can see the logic of this. And really, Symfony does not prevent you from doing things this way, the security features are all wrapped up in services after all. But I think from a practical matter, 99% of the time you do not need this kind of granularity. Having to communicate from the mode/domain that access to some resource is disallowed for *every* controller within a certain logical namespace seems inconvenient and error-prone. Unless you have a certain architecture in mind that I haven't considered?
Why do you think voting system became useless? Do you have an example of notes which you think were upvoted by bots and are inaccurately promoted?
Well, strictly speaking, the one release per year is just a target. I think the 7.0 =&gt; 7.1 release was the first time the target was actually met. [PHPReleaseHistory](https://en.wikipedia.org/wiki/PHP#Release_history) Which of course is fine. Releasing software before it is ready just to meet a deadline is one of worse things that can be done. Perhaps I should have said "ever accelerating introduction of new features". Or maybe it's just a perception caused by getting old.
I was one of the people working on these optimizations, so I've done benchmarks against a number of applications. The benefit was between non-existent and 1%. Some library components that do more "computational" stuff sometimes see a larger impact on the order of ~10%.
Sure.
Even if you discount the I/O component (which is often smaller than people are led to believe, though this does heavily depend on the application), applications typically perform very different operations from micro-benchmarks. Micro-benchmarks are all about numeric code, while applications deal with strings, arrays and objects a lot. Making an arithmetic operation 50% faster through specialization is relatively easy, because the overhead of type checks etc. is large compared to the cost of the actual operation (like a single integer add). For string operations this is often not the case: the expensive part of a concatenation is the memory allocation and memory copying, not some type checking or instruction dispatch overhead. That makes the types of operations you see in real applications harder to optimize. In addition to that, applications have very different structure. Micro-benchmarks are generally a single function (or few functions) with tightly looped code. Applications have large codebases across many files, with large call graphs. For micro-benchmarks we're often able to infer fully accurate type information, because everything essentially happens locally. For applications this is not the case. E.g. for WordPress we aren't able to infer *any* (not even high-cardinality union types) for half of the (SSA) variables. Generally, if we don't have type information, we can't optimize. There's more factors involved here, but these are the main points.
Post the output (and input, when necessary) for function examples. I.e. for the strpos func, the first example is: &lt;?php $mystring = 'abc'; $findme = 'a'; $pos = strpos($mystring, $findme); // Note our use of ===. Simply == would not work as expected // because the position of 'a' was the 0th (first) character. if ($pos === false) { echo "The string '$findme' was not found in the string '$mystring'"; } else { echo "The string '$findme' was found in the string '$mystring'"; echo " and exists at position $pos"; } ?&gt; And below it would be: ____ Output: The string 'a' was found in the string 'abc' and exists at position 0
Perhaps a commenting system similar to Stack Overflow where trusted members could edit old comments to keep them relevant.
So why is time spent on it if real life benefits are so small? Marketing? May be the spent isn't that much, or maybe 1% is actually a real benefit? 
This might just be me, but I would prefer to swap the aliases for array and string language definition pages with the function overview pages. When visiting http://php.net/array is now redirecting to http://php.net/manual/en/language.types.array.php page. While this is useful if you are new to php you are most likely not aware of the aliases. For most programmer the http://php.net/manual/en/ref.array.php is a way more useful page. (I know how to define an array, tell me what I can do with it). Same with the string page. http://php.net/string now refers to http://php.net/manual/en/language.types.string.php while http://php.net/manual/en/ref.strings.php is way more usefull (I know how to define a string, tell me what I can do with it)
If you are doing your markup like this, you are doing it wrong
Because you don't know a priori whether or not a particular optimization will work out. You have to implement it before you can measure ;) Additionally, large parts of the code that are necessary to perform such optimizations are also necessary to improve codegen in a JIT compiler.
Not only trendy hipsters, don't forget .NET and Java developers! We also look down on PHP.
Honestly speaking, I've never had an issue with PHP.net's documentation, and to this day find it a shining example of easy to find indexed information for what ails me that moment. No facetiousness, I get frustrated with most other technology documentation and would kill for them to follow php.net's example. My biggest gripe is some extensions in the php.net site have incomplete manuals and references. But I havent had that issue in a long time and I can no longer remember what it was the last time that happened to me.
My main concern is that cURL would check against a list separate from the system keychain, so if a system update (or the machine owner) revokes a root, it would still be trusted by cURL/PHP. Maybe it's possible to wire this up with a symlink (or, better yet, recompile the extension pointing it at the correct path for the OS), since I believe the system's install of cURL does this. But I could be remembering wrong or it may not apply on macOS.
It's the opposite, actually, I notice good comments with a lot of downvotes. I'd point at [mysqli_connect()](https://secure.php.net/mysqli_connect) as an example. The comment from tuxedobob is a perfectly valid contribution but it's scored at -8. I don't know about the accuracy of the second comment (it does have syntax errors) but it's scored at -13. It took me a minute to find that one, so maybe votes were normalized at some point and I didn't notice. I know for a long time I could pull up pretty much any page and most comments had scores in the negative-dozens range; they still showed at the top of the list, but the ordering isn't chronological either, so it was hard to figure out which comments were worthwhile, why they were scored so low, etc. Since the up/down voting is a GET action, I always figured bots and crawlers were to blame.
The MySQL docs do a good job of this. You can access the manual for each version separately: http://imgur.com/a/g1MgZ The organization is nearly identical for each version, so if you want to look at, say, the INSERT query syntax, you can just change the URL to go from version 5.5 to 5.7 and see if there's any differences.
PHP suffered years ago with the exact thing that's happening to Javascript right now: it's really easy to get started, but difficult to master. That means that there's a lot of garbage PHP code out there, so the odds are people are running across that more than good code. With all the stupid Javascript frameworks out now, it's starting to feel the same kind of backlash. The only difference is you almost have to use JS these days. You don't have to use PHP, so people continue to cling to the "PHP SUCKS!" mantra. As a front-end dev, I stand up for it pretty heavily, but having never built anything of substance, I don't really have a leg to stand on. I'm right now in a class to learn Java, and fuck Java. PHP is so much better, in my opinion.
10 years ago all the web sucked and PHP was the most popular language for server-side. A lot of people tried PHP, hated it and then moved to something else. But when you switch languages in a fast moving field, you're likely switching from an old version of PHP to a newer version of whatever. You know how PHP7 was cool? Imagine moving from PHP 5 to the latest asp.NET without so much as reading about PHP7. You'd get the impression that those guys are ahead. Then as you use .NET for half a decade, it evolves and you compare it to your experience with PHP 5. It's important to compare languages at the same generation. Sure, 5 years ago we were just getting a proper package manager and PSR-2 wasn't out yet. But [5 years ago you couldn't have 2 forms on the same page in asp.NET](http://stackoverflow.com/questions/7544454/can-we-use-multiple-forms-in-a-web-page), because it would automatically wrap your entire page into a form.
The manual is great, however it would be nice to either moderate the User Contributed Notes or just loose them.
Auth layer is easy if you only support username/email and password authentication. It gets more complicated when you have to support other kinds of authentication or MFA. But at that point, your authentication mechanism is already complex. There's nothing much Symfony can do about that, and actually Symfony makes it pretty straight forward. 
Don't think i saw your second paragraph 0.o
it's all good
That's an excellent example; bear with me for a bit. *Even if* it's as simple as allowing ROLE_ADMIN to access a static page, you still need to check if the user actually has ROLE_ADMIN. Unless you are completely trusting the user input from the request (which I know you are not ;-) you will need to touch storage at some point to retrieve the user's roles. You either need to hit the database, or load up a session (and yes, session_start() counts as touching storage). Only then can you check to see if ROLE_ADMIN is applicable to the current request. The question I have begun to ask is: why is the *user interface* layer (router, dispatcher, front controller, controller/action, view/responder) interacting with storage in that way? That kind of interaction with storage is, to me, an indicator that the work belongs in the domain layer. In this case, it would probably be a very simple domain element, perhaps as easy as "receive the user credential, check that it exists in the database as ROLE_ADMIN, return true/false". Then the calling code can either render the static page into the response, or redirect to an access-not-allowed page. Do you kind of see where I'm coming from?
I personally look down upon PHP. I have no trust for the PHP engine developers, for PHP library writers and for the pain, bugs and insecurity they inflict on themselves and others. PHP is not okay.
speaking of translations. I absolutely hate that the manual tries to force the German version on me based on my geo location instead of honoring my browser's language settings which clearly indicate that I prefer the English version.
It's hard to improve on perfection. 
How difficult was it to make that switch? I've been considering doing the same because every time I look for a job there are always tons more .NET jobs posted than PHP jobs.
&gt; PHP does not let me do this. ... What? You mean when someone writes bastardized non OO php. Yes it is a problem that the language lets you write totally horrible yet working code.
The most expedient method would probably be to have a standardised submodule in your module in which an admin module is placed. I couldn't really say much more then that without knowing more about your implementation. Also, is there a particular reason that you're working on a laravel based CMS? There's already a few of them floating around, IIRC.
I will take a look into the event docs. I thought of doing something similar to have the admin module simply scan through the other modules, looking for certain files. For example a config file for the admin menu or something similar. You have any though of doing that compared to possibily using events? Thanks for the time and answers btw!
I have, actually... I wrap both PDO and the other extensions in a Connection object and I've not seen issues with non-PDO extensions, in fact, as I say above, I prefer the "native" ones as they try to expose everything from the driver, and as-is. 
If only php could handle event driven and persistent applications, I'd use it for literally everything. If I could have 1 wish, I would ask for PHP to be natively supported on all the new IOTs. I don't wanna learn NodeJS :( I wanna be able to use PHP on my Arduino!
A learning project is a perfectly reasonable reason to do something. Within each module folder, have an Admin folder. Have *that* folder contain what is basically another module, but one that lives in your admin panel and does any admin stuff your CMS needs doing.
It's on my list. I also noted the comment "Dokeos has a lower learning curve than Moodle", but Dokeos is on my list too. I got bored after looking at about 5, so I quickly opened remaining search results (inc crappy "top 30 dms" review lists/posts) and made a list of those that didn't seem vastly off the "thing" I'm looking for.
My number 1 issue is that it should always be up-to-date. For example, as I write this, the DateTime documentation is still missing the 7.1 milliseconds support changes, which include breaking changes in behavior of DateTime objects. For a project as popular as PHP, updating the manual needs to be part of the release process (and I don't think just the "migrating" section suffices) - a new version shouldn't be released until the documentation has also been updated. I don't know much about the current manual development other than what I see as a user, but I think this also shows why better versioning is needed - if the manual was clearly versioned in a similar way to many other projects, it would be much easier to update for each new version without having to touch the manual for the current stable version. Better versioning would also make the manual easier to read - obsolete concepts could be removed much quicker (for example, I don't think the PHP 7 manual needs any mention of things like HTTP\_*\_VAR, register_globals and magic quotes) Some areas of the documentation I've noticed that are lacking / horrible to read: * Sessions - it seems like someone got half way through making a bunch of changes, but never got round to finishing it or getting someone else to proof read it. It's muddled, repeatedly mentions things that (at least as of 7.0, when I was reading it) weren't actually in the latest stable PHP (I was trying to refresh myself on how GC works by default and how to change it so GC is handled by a cron instead of web requests). There's far too many note / warning boxes and they're too big. * PDO (particularly PDO / MySQL) - needs a better "quick start" that guides people to enabling exceptions, disabling emulated prepares and changing the other horrible defaults that are around purely for BC reasons (IMO these should have been updated in 7.0). Also, I'm not sure the default settings are even documented anywhere (certainly not somewhere that's easy to find) I also believe the tutorial should be expanded. One of PHP's biggest issues is the huge amount of blog spam copy-pasted tutorials, some of which can still be found using code from the early days of PHP 5. I believe the only way to combat this, short of buying Google and changing their algorithms, is to provide a better official tutorial.
The homepage looks promising. "training materials" is more what this is going to be about, rather than people doing courses online. Hence I don't want an LMS too much. Will add it to my list.
For an example that I think is well done, see the PostgreSQL documentation. eg: https://www.postgresql.org/docs/9.0/static/sql-select.html You can quickly see which version you're currently looking at as well as switching to other versions or the "current" version (latest stable). Properly versioned documentation is valuable because it allows the documentation to be decluttered of obsolete information and clearly show the current (recommended) way of doing things. This makes it clearer and faster to read - especially for new (and often impatient) users.
I agree. And i go further, it should send everyone to the english version since this is the only version that they really know is updated. If someone chooses to read the japanese version it's their choice, but let them be warned it's not updated frequently. 
Well with .NET you'll pretty much only use Visual Studio as an IDE, which in my opinion is the best IDE. Before that I used various JetBrains products which I thought were good at the time, but wow VS blew it out of the water. Intellisense is amazing and newer VS versions have so many cool things built in like TypeScript, Node.JS, SASS, etc. Full integration with TFS (project compiling/deployment, VCS, bug tracking) is also fantastic and all within the IDE itself so I don't need to use multiple tools to go through my daily workflow. In terms of programming, its a bit more constricting, but that also makes it simpler at times. If you've only used PHP, which is loosely typed, you'll feel a bit lost at times because there so many more types of data and you'll have to learn when it is best to use them. But after the initial hurdle it all starts to make sense. It's also simpler because there's usually only one way to do things, for example MVC. In PHP there's dozens of frameworks that handle MVC and they could all be completely different, in .NET there's just one. It's been in use by nearly every .NET web project since 2009 and it's part of the .NET core code and maintained by Microsoft. There's never any guessing on how to do things because it's just not complex and you can easily find solutions from other people online because it's so prevalent. I guess my point is you never really have to figure out *how* to use the tools you have to accomplish the task, you can just get straight to creating the logic that will solve the problem. However, it did take me some time because it really was my first time with .NET so it was all overwhelming when I also had to learn the massive project and business logic here. If you have any other questions then let me know! I mean it when I say I can't go back to PHP, it just feels like a gigantic mess now haha.
This reminds me of form elements and decorators from ZF1. I vowed never to go back.
Trying to find driver-specific information like DSN keywords for PDO always takes longer than expected. That's basically the only annoyance that has repeatedly showed up recently. 
nikic is a sufficient proof really
If you want event driven PHP, there's reactPHP. Its been useful in a couple of edge cases for me.
On the PHP side of things I have mostly seen Symfony and Laravel. But people are using them in very different ways so I would say being flexible and generally aware of working in a framework is most important. Lots of companies around me are looking for people with front-end knowledge of the JS Frameworks as well (I see a ton of React jobs out there). 
Scanning through the files has 2 main drawbacks. First, it's a lot slower than using observers - you're blocking execution of your code until you load the file into memory, then scan it for certain things. If you're scanning for the existence of certain actual functions or classes, you'll also have to parse the file. Second, you'll have to make the scan on every page load. If you only have a few files, this won't hurt very much. If there are a couple dozen, the OS can block execution of your script while you wait for file handles to clear and whatever else it has to do. The one time I've had to construct something like this, I only scanned the files on the specific page where the admin had the option of enabling or disabling a plugin, and I followed the Wordpress way of only caring about the comment block at the beginning of the file. After a plugin was enabled, it's folder name was stored in the database, and then `include`d in a loop as if it were a core file on every other page.
Can we just sticky this in the sidebar since it's posted about every week? I guarantee even if I stopped using frameworks \ micro frameworks I would sure as hell end up inventing my own framework. At some point it's going to be obvious there is a common scaffolding starting to appear that you don't want to copy paste to every project. Unless the apps are 1 off's without any similarities I don't understand how someone could not arrive at the reason why frameworks are used on their own. IMO If you're rolling your own for a complex use case you're just creating a shit ton of technical debt for no reason.
I have updated the [website](https://www.opulencephp.com) to have better print styling. Thanks for the feedback!
Don't use them if you don't want to, with that said. SQL: The thought of writing raw SQL makes me sick nowadays. I prefer ORMs though there are edge cases where I write raw SQL. It's easier to read and they take care of binding parameters internally. Design patterns: Built-in. Ubiquitous: Easier for new developers to come in if you are using a widely adopted framework. You can accomplish all this and more without a framework, but why? They are cumbersome at first, but worth it the long run IMO. The main reasons against are bloat, learning curve, and performance. The first two are silly arguments as most of the framework bloat is stuffed inside a vendor package that you don't need to look at it. No programmer should complain about a learning curve as we are in an industry where learning is a constant. As for performance, if you've optimized everything else and the framework is the bottleneck then you my want to look at moving stuff out of a framework or even changing languages. For most projects, the latter is not a concern from the beginning.
Also, if you change the first \d+ to \d* you can get rid of the second preg_match entirely. In the likely case where the numerator is nonzero, empty string plus a float is just the float (cause empty string is zeroish). In the 0 deniminator case, you should probably wrap $matches[1] in an intval (but you should have had that anyway, because types).
Better comments and voting system. There's some outdated crap in there, a few good tips but not as much content as there could be.
And here you are on /r/php
&gt;microsoft ecosystem Ugh. I'd rather write microservices in C with only socket.h.
&gt;bro people still use php? its an **outdated language** use python or something According to Wikipedia, Python first appeared on the 20th February 1991. 25 years ago. It's 5 years older than PHP.
And this response, one of most worthless response that you can see frequently here in response to criticism of the language, comes from you who is one of the most respected of the Php "people", which further justifies the "no trust for PHP engine developers" part.. 
There are valid complaints about PHP, but on the whole, it is about personal preference, these days. The fundamentals of the language have gotten remarkably better, and the biggest warts (particularly with regard to security) have been deprecated. A lot of people don't *like* PHP, but that's a different issue, and often their criticisms are based on outdated information. I, personally, don't like coding in PHP, and most of the code I have to work on in PHP is *really* awful. But, my complaints are mostly stylistic rather than fundamental flaws in the language. It is a common feeling among Python and Ruby devs to look down on PHP, and they often even believe it is due to real major differences between the languages; but, again, it's often based on outdated information. PHP7 is a really powerful language, with few major shortcomings (aside from what I consider ugly/verbose syntax, a clumsily huge and poorly designed standard library which is being fixed over time, and a bunch of example code in the wild that is horrifically bad). I'm primarily a Perl developer, and I've seen Perl go through the same set of complaints over the years. I think the general opinion of Perl is finally starting to recover its reputation in recent years, and I would guess PHP will reform eventually, as well, as the language continues to improve, and bad habits get excised from how people commonly do things in PHP (Perl had to live down a huge variety of early examples of CGI scripts that were insecure by design and poorly implemented in general, and PHP has to do the same, now).
You should substantiate your claims a bit more, because right now it's just random drivel that's disproportionately angry to anything I've said. If you think something is "evident", point out the "evidence". If you think I've "slandered" something, say how exactly.
Well you work on HHVM and yet you are on /r/php? We both dislike some of the problems of PHP and wish to alleviate them where possible. If I can find some library that alleviates PHP problems or some static analysis tools that can help cut down on PHP bugs that might be nice. Maybe I can also help newbs out with some common PHP pitfalls? I know I won't convince anyone to code web services in Ada Spark and verify their timing properties using TLA+ (I know I don't) but I might be able to convince some people to split their code up into micro services and move onto Hack Lang. Also, if I can convince people not to use MongoDB and other traps that would also be good.
&gt; Now we're on a NodeJS bandwagon - Node is the coolest shit since sliced bread. I've been coding PHP since 2000, have written some [useful](http://chir.ag/projects/pdfb/) and [useless](http://chir.ag/projects/tagline/) stuff, and continue to maintain old code and write new code in PHP almost daily. I also code in JS daily. I like both languages and think they both have their weaknesses and strengths so like you, I use the best tool for the job. I also use Go, ObjC, Powershell, and Python if they are the better tool for the job. That being said, Node is nothing like Rails. Node actually lets me do things I cannot do in PHP, Ruby, or even Python without going insane. Last month I wrote a streaming Postgres to MSSQL/Azure sync tool in Node. Give it a source db and it will mirror table structure and data to the destination in "parallel" - can easily handle 8-32 tables/views simultaneously, writing 16-64 rows per table to Azure without loading all of the source data in RAM. Using [some](https://github.com/vitaly-t/pg-promise) [neat](https://github.com/brianc/node-pg-query-stream) npm modules, I can do cursor-based SELECT * FROM table1-N and stream K rows as needed, no matter how large the table is. I don't read additional rows from Postgres until Azure INSERT/UPDATEs are successful. Uses very little CPU/RAM and performance is pretty much dependent on database I/O and network. Barely a few hundred lines of JS code that uses Node nightly with async-await (no more callback hell). The beauty of this is that the tool performs like it is multi-threaded or concurrent while the code is straight up procedural and OO thanks to async-await. It's nice to not have to worry about mutex and semaphores and just write code that works reliably. So yeah, Node is not in the same league as RoR.
You've been told that PDO is parsing the query and immediately it made you to dislike it. You said you are wrapping your db calls in a some sort of "connection" but didn't mention whatever benefits PDO offers proving that you are unaware of any. Neither you mentioned any mysqli's hardships, of which you are unaware too. So I suppose that all your experience with "native extensions" is just old ways similar to query/while/fetch. Before "disliking" PDO try to create something as nearly as useful. It will take you hundreds lines of quite sophisticated code using mysqli. When finish, you may consider how PDO is really bad compared to your product 
I see, I didn't sit down to make a detailed list of PDO benefits and MySQLi "hardships" to directly support your opinion, so therefore I evidently am slandering PDO. You don't have many friends, do you?
Are you not the author? There is no way to currently add rules? I recently wrote a more explicit validator library that uses Respect\Validation for much of the rules, but because it doesn't try to abstract things away it provides quite a bit of flexibility. I actually define explicit validator classes, for example: &lt;?php use Checkpoint\Inspector; class PersonValidator extends Inspector { /** * */ public function __construct(People $people) { $this-&gt;people = $people; } /** * */ protected function validate($data) { $this-&gt;define('state', 'Please select a state from the drop down') -&gt;notBlank(); $this-&gt;define('postalCode', 'Please enter a valid postal code e.g. 02019-3422') -&gt;postalCode('US'); $this -&gt;check('firstName', $data['firstName'], ['notBlank']) -&gt;check('lastName', $data['lastName'], ['notBlank']) -&gt;check('mobilePhone',$data['mobilePhone'], ['phone']) -&gt;check('addressLine1', $data['addressLine1'], ['notBlank']) -&gt;check('city', $data['city'], ['notBlank']) -&gt;check('state', $data['state'], ['state']) -&gt;check('postalCode', $data['postalCode'], ['postalCode']) -&gt;check('email', $data['email'], ['email', 'lowercase']) ; } } But these are also modular, so you can inject the above into a dependency on an aggregate validator: &lt;?php use Checkpoint\Inspector; class RegistrationValidator extends Inspector { /** * */ public function __construct(PersonValidator $person, PasswordValidator $password, People $people) { $this-&gt;people = $people; $this-&gt;add('person', $person); $this-&gt;add('account', $password); } /** * */ protected function validate($data) { if ($this-&gt;people-&gt;findOneByEmail($data['email'])) { $this-&gt;log('duplicate', TRUE); return; } $this-&gt;fetch('person')-&gt;run($data); $this-&gt;fetch('account')-&gt;run($data['account']); } } Anyway, I'd be curious to see how rules are registered/added. 
Every time I'm looking for PHP's datetime formats, I end up clicking 30 datetime links inside the manual before I actually find it. There's also a lot of constants that exist that I don't know about.
MySQLi is more verbose, but that's quite irrelevant when you're programming a wrapper, because you need to write the implementation only once. The only thing that matters is: can I implement this or can't I. And MySQLi exposes more features of the client, than PDO, so that's the *only* thing I care about. You know, when we talk about "experience", experience should teach you to not spray your application logic with either direct calls to PDO nor MySQLi.
This right here. [Examples, examples, examples, and more examples.](https://www.youtube.com/watch?v=FKTxC9pl-WM). Keep them terse and scannable / skimmable, but link to more information if it would be helpful. Not enough documentation does this :/
Cake has its strengths and weaknesses. Their approach is subject to opinions. But I think I overall get stuff done faster and with fewer lines of code with cake. The takeaway is robustness / fragility.
&gt; Should i feel confident in my php skills if all i know how to do is use laravel Not enough information. If you can do literally anything in Laravel (write apps, write libraries, extend the framework, install symphony libraries, install libraries that are completely framework agnostic, etc..) then maybe you should be confident.
Type system stuff. function getAuthor (User $user, BookCollection $books): BookAuthor { ... }
I like your classy burn, sir
God no. HTML is ubiquitous and easy, please don't. An HTML button is the same in PHP as Ruby as Python.
Markup? Nope, just buttons. Why it's wrong?
Thanks, good feedback.
no. HTML button is different in every bloody project. Suppose I create add-on that adds extra button to a toolbar that application have. What HTML would my add-on output that would be consistent with the design theme of the application?
If you can convert your query results into JSON you can feed it to a charting library such as www.zoomcharts.com.
I would love to see missing documentation to be added (such as http://nl1.php.net/manual/en/reflectionclass.getnamespacename.php) However, I have to admit that the php documentation is quite good actually. One feature I'd love to see, is is what they did with symfony: http://symfony.com/doc/current/setup.html Here you have a button under the version where it lets you submit a change for the documentation in case you want to add something or fix something. Community driven documentation is quite powerful!
Who konws I tyep too fas tto recnosize .
Hi, I've submitted bug report for it https://bugs.php.net/bug.php?id=73698 I encourage you to read it, as I also explained why (I think) things are structured that way, not another.
Hello! &gt; For what it's worth, I'd really like to see improvement to the way contributing to the documentation works right now. Every time I've tried, I gave up in frustration. Have you read http://doc.php.net/tutorial/? I created it last year, replacing all other resources, which were complementary, sometimes contradictory and and scattered all over the place. I try to keep it up to date. Let me know if you find it helpful. I'm aware that contributing process can be hard no matter how good the tutorial is (if it's good at all). If so, what annoys you the most when trying to contribute PHP Manual? 
Thank you for your post. As a total noob, I found the documentation hard to read at times. So instead, I read noob books and grew from there... now when I have to reference the documentation, I understand it. PHP is a really great language that I use everyday. Thank you to everyone who makes it possible to use and understand by providing documentation.
To be fair Java Developers don't like Java either. Everyone hates on Java.
Remove comments below a certain threshold, and allow a community of users to remove comments. It's full of bad advice, at one point I even started collecting some of the most ridiculous comments on PHP.net because they were just so stupid it became funny.
I've used this one. As someone who hates wordpress with a passion, it's actually been pretty good. It just gets very expensive with addons.
The voting system is broken because the votes don't degrade over time. What once was the right comment (and usually the top voted comment) was written 5 years ago and is now wrong. New comers or people who don't understand the function (hence the reason they are looking at the docs) think 'oh this is the top comment it must be ok'
&gt; Python also has async/await. And it also has multithreading and multiprocessing. So, I find that claim hard to swallow. But I get your point. I think the difference is in how *most* (if not, all) of the client libraries in node js are implemented with async/await as the accepted model of execution. 
&gt; 10 years ago all the web sucked I would argue with all this technology the web has actually regressed in terms of usability. Now most websites are overly engineered, convoluted pieces of shit loaded with frontend code that is rarely used. For those whom have disabilities, accessibility has barely improved and if anything has also regressed. And on a political point, the freedom of the internet is now being curtailed and is controlled by monopolies (google, facebook).
To scootstah and OP; https://repl.it/languages/php has an embedder, if you need a quick one. See https://repl.it/El6g as an example. (You'll need to press `run` on the top left)
IMO the mark of an experienced developer in a major language is that you can say: "I love X about it, and hate Y about it." Not just, like, hate entirely.
I am not the author, I only contributed (or fix a bug, https://github.com/rakit/validation/pull/2 ) in the library the day I found it.. The readme file says "registration is coming soon" so I think it's not available yet.. Maybe I'd run through the code again and see if it's available but undocumented OR try to add the feature, then send a PR.. 
No you wouldn't.
Programming languages are like political parties?
You don't want to inject the entire container for a few reasons. The most clear cut reason IMO is that it's a lot harder to look at the class and see what dependencies it actually needs. This would be a perfect scenario for [middleware](http://weierophinney.github.io/2015-10-20-PSR-7-and-Middleware/#/). Create a middleware class, inject only the session handler and modify the response object as needed before it gets to your controller.
That sounds just what I'm trying to make. Are there any good HTML generator classes/libraries you can point me towards?
very nice, was needing this for a while. thanks
The Laravel collective HTML library is good. It may be a bit much or tied to much to eloquent though if you want something more generic.
Fair enough.
I never wanted to get into Microsoft back in the day either. These days they make almost everything open source, even .NET, and hardly ever make a new product that I'm disappointed with.
You should see how much things have changed since the past 5 years ;)
Oh interesting! What made you transition?
Official documentation is too hard to read for some? 
PHP's syntax is fucking glorious. It's the bastardization of static method calls that is the real atrocity here.
`die` and `exit` aren't identical, die closes the HTTP connection and exit doesn't: http://stackoverflow.com/a/20932511/1058739
&gt; However, it is the case that I want to produce work that is GUARANTEED to be bug free. I think it's time for a career change then. &gt; I never want to have another occasion where PHP trips me up with dumb bullshit again. There you go blaming your racket again.
It's called comical overreaction. Of course I wouldn't write microservices in C... there's assembly for that: https://github.com/nemasu/asmttpd
&gt; If you want event driven PHP, there's reactPHP. Eh. I feel unclean doing that, when there are better options with that stuff out of the box. This is one of those "use the right tool for the job" instances.
&gt; I wanna be able to use PHP on my Arduino! Ew, god no! PHP has its place, and that is *not* it.
I agree, which is why I learnt node when faced with a bigger problem that wasn't literally pushing updates out some a few websocket listeners.
Seems like it's svn and quite cumbersome to contribute, this is another thing that can be improved. I personally won't bother installing svn just for this, next to having to read a dozen of pages simply to get started. I love contributing, but only if it's easy.
This will always be true since all values in $matches are strings: $matches[3] !== 0 Try this instead: intval($matches[3]) !== 0 
Writing code all day in a language that looks a lot like Java, using a web framework that was inspired by Java web frameworks, mapping data to a database using a Hibernate clone.. I'm just sitting here, asking myself why I'm not using Java.
That didn't seem right to me, so I checked the [source](https://github.com/php/php-src/blob/dd35ba08ef5de7a87b5666dd87b58d084ede1e56/Zend/zend_language_scanner.l#L1125). Both `exit` and `die` are parsed as the same token, which means they should act identically. &lt;ST_IN_SCRIPTING&gt;"exit" { RETURN_TOKEN(T_EXIT); } &lt;ST_IN_SCRIPTING&gt;"die" { RETURN_TOKEN(T_EXIT); }
Glad you like it ^_^
Nice ideas, will consider in future update ;)
You would fire an event anywhere you want to let 3rd-party (or plugin) code potentially modify the contents of a variable (parsing markdown before display, for example), or trigger an action (like a log entry, notification, etc.).
It's way too basic, but I suppose it's in a right direction. 
I'd want an option for the default language to override everything, so I always get the English version when I click a localized URL.
I agree. I work on tools which can be installed on different PHP versions, and I like the fact that I can see what I can and can't do in a single page.
NodeJS is so 2015, it's all Golang now.
It was somewhat better than the alternatives in 2006 during the blogging boom. And it's still a 2006 PHP app. That's 10 years ago, in case you didn't feel old yet.
I don't have the Python knowledge to argue either way regarding system tools. I'd suspect for handling data and putting it into a database a #!/usr/bin/php script would work fine, and the string handling, regexing and type checking would be somewhat nicer with PHP7 than either Python.
It has its merits. The code is awful, but it gets the job done...
And you can pound nails with a brick, but I don't recommend it.
&gt; but not based on objective factors You sure? The fact that `DATE_ISO8601` does not return a valid ISO8601 formatted date (just to name one example) is a fairly **objective** criticism of the language. Say what you want about those other languages; none of them **lie** to the developer the way PHP does.
&gt; Someone, thinking themselves enlightened, goes off and reads "PHP: A Fractal of Bad Design" and styles themselves an expert, having written a few lines in that language and having tried to read a program and not quite being able to. Have you actually read it, though? Specifically, did you read the section labeled "Stance"? The author expresses fairly reasonable expectations from a "good" language. If you don't agree with those qualities, then you may disregard the rest of the content. However, that immediately calls into question your attitude toward programming languages. Do you not think a language should be predictable, consistent, concise, reliable, and debuggable? Do you think PHP somehow fits these criteria? I worked professionally in PHP many years ago. I formed my opinion all on my own (long before the famous fractal post). Sure, PHP has come a long way in the intervening years, but none of the releases have addressed the broken foundation the language sits upon. Version 7.1 finally merged `rand` and `mt_rand`. Why were they ever separate? PHP's infatuation with keeping old code working at the cost of those attributes (predictable, consistent, etc.) is what keeps it firmly in the realm of being built by amateurs for amateurs.
I believe my thinking has been that I don't want to clutter bugs.php.net with minor bugs - that also might be known already (eg since PHP 7.1 is new, as in the example with the JSON constant above). One idea would be to add a way to report simple doc bugs, things that are really obvious. This could be done by selecting text â†’ clicking report. Something similar to some Whatwg standard documents. Two examples of such obvious doc bugs, both on http://php.net/manual/en/errorfunc.configuration.php 1) Typing error: "error_log()()" 2) No longer relevant: "The system logger is not supported on Windows 95" 
The tutorial needs rewriting.
&gt;There you go blaming your racket again. Except that a racket is the wrong analogy. PHP isn't the hammer it's the timber. If you use substandard building materials your house is going to collapse. Doesn't matter how skilled you are. And besides, honestly, why shouldn't I use a better racket? Especially if these better rackets are open source and free.
Fair enough!
Nice! I actually like the Laravel validation, simple but powerful. Sometimes things can get out of hand, but TBH I don't know any validation library where complex validations don't look messy. Anyway, sorely missing: - adding custom validation rules (basically a must have for any serious validation library) - where's the "string" validation type ... ? Am I blind :-) Some questions: - how are `null` values handled? Laravel has had quite a bumpy history with them. In 5.2, `string` would accept `null` too, in 5.3 it doesn't anymore. - I can tell you that in practice `array` isn't enough. If you ever made an API which accepts arrays which you may even store later, you need to make sure that a) keys are e.g. successive and not have gaps or weird keys and b) their values match a certain type Oh btw, I like it that every validation basically is it's own class. This is a mess in Laravel if you scan the code, a single class with gazillion of `validate*` methods and quite some dynamic invocation magic.
Can someone please explain because I'm not getting it. It seems like the author is dumping out an object which contains a container. And the container has lots of services defined. So what was the expected output?
Use xdebug and step through that shit
Looks like someone should be using __debugInfo() method ;)
How can you tell from the post that DI is being misused? There are times when it makes sense to inject the container and use the service locator pattern. And a container tends to have lots of services. So where exactly is the misuse?
&gt; However, because I have a drive to succeed I want to write code which cannot be bad. You can write bad code in absolutely every language. And you can write absolutely beautiful code in PHP. I agree with the guy above - sounds like you just want something to hold your hand.
Quite a lot of the examples are like this: echo sampleCode(1); echo sampleCode(2); echo sampleCode(3); Would output: 1 2 3 It would be easier to follow if they just showed the output on the same line as a quote (they do in some places, generally newer pages)... echo sampleCode(1); // 1 echo sampleCode(2); // 2 echo sampleCode(3); // 3 
I either hadn't found that or it didn't exist the last time to contribute to the docs. I'll give it a look over the next time I have an edit to make. The last time I had tried to make a change, it was with some odd web-based editor, nothing involving SVN. Maybe I got pulled into the wrong workflow or something; it's been a while. Either way, thank you for your contributions! I'll send you additional feedback as I have it, if you'd like.
&gt; â€‹Don't tell me I need to use a framework-specific dumping method that filters out the shit. You should be using a debugger. 
Abuse of variable variables. Nice. 
I'd like to hear an example of something that you view as extremely difficult and error-prone in PHP, but which is a breeze with no possible chance of error in &lt;insert your favorite language&gt;.
IMO concatenation vs interpolation should have made the list. (I do see it's mentioned in the footer) Up to PHP 5.3 (or maybe 5.2) tgere were (arguably) noticable performance differences between them, but even that distinction is long gone.
&gt; I think you've misunderstood my post. "Mark" is not the same as "cause". Being covered in black soot is the mark of a coal miner, but it's not the cause. No, I didn't. &gt;Then they aren't experienced to see the downsides of design-tradeoffs the language has made, or haven't used it enough to encounter rough patches. Not using a language enough to find something about it you like is not a feature that can help you point out inexperienced developers. It's what can help you find inexperienced X developers. However just because you haven't spent long enough with the language to find something you like, maybe that just means for what you do that language isn't designed for. So you just hate it. &gt; Then they're not experienced enough to understand what benefits it brings (or once brought) compared to other languages. The same but inverted. They love it because every time they goto the language to solve a problem things just work and it all works they want it to work. This may not be because they are inexperience, it's that their experience with that language is one that is good. Loving and hating a tool is difference from knowing when and where it can be used and the flaws. I for one hate Laravel, I just hate it, it's kinda an irrational hate. However if I have repeated pointed where in which cases it would be good when I've seen threads asking for the differences between Frameworks. It may be a good choice for those use cases, but I hate those use cases too. 
neither of these packages seem to do much more than an array_map...what am i missing?
to be fair, dump ANY variable in Drupal from versions 5 - 8, it looks a lot like this 
Generally speaking, if you're passing around what's in the container it's DI and if you're providing the container itself it's SL. Slightly more nuanced than that, but I'm on mobile. Your example looks like DI. 
True, however it shouldn't be up to the framework to decide what your application needs. And yes, Symfony advocates smaller containers: [Avoiding your Code Becoming Dependent on the Container](http://symfony.com/doc/current/components/dependency_injection.html) &gt; Whilst you can retrieve services from the container directly it is best to minimize this. 
You register the plugin at the blog, and the blog invokes a "setup" method / closure on the plugin, while also passing an API object that contains all necessary access hooks, such as menu modification: $blog-&gt;addPlugin(function (BlogPluginApi $api) { $api-&gt;menu-&gt;addItem(...); }); These should be distinct from the objects the blog uses for reading and building the menu in many ways, one being there aren't read method on that menu object (unless the blog author specifically decides to expose this to plugins... but this opens the system to load order conflicts and spaghetti dependencies). It may look similar, but note that: 1. The API is specifically made for and made up from objects designed to be exposed to the plugins ($api-&gt;menu is not the same as the internal menu in the blog). 2. There are no multiple events, just a single "setup" point, where the plugin is given the API to configure its entry points. 3. Conceptually, instead of the plugin intermingling with core rendering code, it only "asks" for what resources it wants to modify, but ultimately decisions like where the menu item appears, or does it appear at all may be up to the blog, and the user, not the plugin. I'm sorry is this remains vague, but the topic is not short. Essentially the patterns used are strategy, delegation and injection. How each feature of the plugins should be provided is very specific to the feature. Unlike the WordPress system where everyone can do everything, it requires more thought, and is more limited, but it results in a higher-performing system that's less prone to breakage. For real-world example of both approaches, see the old Firefox plugin system as an example of the "WordPress hook" system. And see Chrome's new plugin system as an example of the "limited declarative plugin" system. If you're wondering how I'd design specific features, you can ask for specific features. Also aside from the "generic plugin" there may be plugins for specific type of functionality, like say authentication, which will have different setup points: $blog-&gt;setAuthSystem(function ($user, $pass) { if ($user === 'Foo' &amp;&amp; $pass === 'Bar') { return [ 'id' =&gt; 123, 'name' =&gt; 'John Smith', ]; } else { throw new \Exception('Bad user or pass.'); } }); Naturally, there may be a UI where the user can install plugins instead of actually editing code and calling $blog's methods, but in the end the code will be the same.
I've been reading through it and I find sub-templates quite interesting :) As a fellow open-source developer, I appreciate that you invest time into a good quality code. I also wish you best of luck.
Didn't really see anything in there about smaller containers, just the usual good advice to avoid service locator unless it is needed. Perhaps instructive to note the the default Symfony 3.2 framework creates some 220+ service definitions out of the box. Not exactly small. Just imagine var dumping it. On the other hand, this proposal might help with interface segregation: [Replace container injection by explicit service locators](https://github.com/symfony/symfony/issues/20658)
For any sizeable programming task, not using a framework is not the "easy solution", when they give you so many useful libraries.
how is this even remotely related to DI?
Please check https://github.com/xtreamwayz/html-form-validator In 99.9% of scenarios, form APIs are to be used with HTML. Since a form HTML specification exists, so let's use it as base DSL for writing them. This means writing HTML first, and then either generating or attaching a validator for server-side processing and error handling. The library I linked solves that, removing most of the complexity of forms generated from domain models (which usually leads to terrible coupling).
Exactly. Dumping variables is pretty amateur compared to using a debugger.
If I could upvote more than once, I would.
[removed]
`var_dump` *is* useless. Learn to use a debugger.
This looks like an interesting project. I will definitely play around with it.
To echo what everyone else has said: That's not DI, but it is an excellent example of one of the reasons why you should be using DI. "Sure, I'll just pass my entire app to every part of my app; that can't possibly cause any issues with coupling, separation of concerns, testability, or debugging, right?"
Both. Ideally it should be prefixed with "Ad:"
Then, more like 2003, https://sourceforge.net/projects/amodules2/. I have rephrased my post.
This describes the modern state of JS development too. Describes so good it hurts.
Any complex project or framework will have hundreads or thousands of included files, don't worry. Tip: Learn about composer and autoloading
I had the exact same question when this came out. The original thread for fractal was filled with praises as if what it's doing was ground breaking.
Come on, I don't think anyone here is interested in n00b articles like "how to install XYZ". :-/ Looks more like an ad anyway.
Been where OP is - read everything about DI there is to be found at least 4 times (not only PHP but also how they do it in other languages like C#, Java, Ruby, Python, ...). This all sounds really good on talks and slides and example cases but when trying to apply this in practice nothing feels like elegant enough. Yeah, pass it in. "Tell, dont ask". But eventually have to wire it all together in some bootstrap and config file - they call it "Composition Root" So eventually learn about hexagonal architecture and calm down a bit. So ...will learn about different layers and that DI is mostly applicable to domain layer. So yeah, i was overthinking. 
I think you're not giving OP credit enough - when he says 'login.php' class is called, he's likely referring to the one class contained within login.php. Beyond that - caring about performance is something everyone should do- for best practice, for pride, for programming skill, for whatever. It's one of the most important parts of programming. If a program can't be optimized, it's 100% optimized. If it's not, it can be improved. Caring about scaling to 1,000, or 1,000,000 users may not be something a "newbie" should care about, but they should still write the most optimized code that they can. What's the point of programming if not to make a process more efficient?
Laravel should work fine on shared LAMP hosting, so don't let that restriction stop you. Find a shared host you are comfortable with and then when you are deploying you can just use them, knowing it will work. Also, VPS are _so_ cheap now. Have you seen [Low End Box](https://www.lowendbox.com/), which advertises cheap VPS deals? There are some cowboys featured on there, but I found an excellent one for my needs. 
I'd go with Slim. It's more like a router and a dependency container than a framework, but you can build it into whatever you like, just composer in anything you need.
If you building small website (especially heavily depended on API), try [Slimframework](https://www.slimframework.com/). Another lightweight is [Silex](http://silex.sensiolabs.org/), witch is small framework from Symphony components. 
Details please. Are you talking about having to change the constructor signature when the dependencies change? If so, the container isolates those changes from the rest of your code. If not, I'm struggling to see the relation between DI and method signatures.
Any framework will do
Symfony is very versatile
This will probably be a bit overwhelming but you might try skimming some of the Symfony Security component documentation. I suspect it is probably the most complicated one out there. And it clearly shows the breaking functionality up in classes and having classes invoke other classes is not a bad idea. http://symfony.com/doc/current/components/security/authentication.html Here is their equivalent to your check_password functionality: http://symfony.com/doc/current/components/security/authentication.html#using-password-encoders Understand that I am not suggesting that you start out using this component. But rather as sort of a big picture overview of what has been done before.
Money is one of the most important parts of our life. Yet a little baby will likely be impressed with shiny dimes, while boring green bills will tear apart. So PHP noobs are. They just have no measure. Every time they talk about optimization, they *always* miss. I've seen tens of thousands questions on Stack Overflow and I know what I am talking about. Every time they start optimizing their code, the outcome is just terrible. Old man Knuth said his famous quip for a reason.
It's a solid foundation though and widely used. If you built a layer on top of it it would use a known interface/class api and the core functionality is right there. Then you layer on the part that is actually new and interesting.
Laravel without SSH isn't much fun though
[removed]
If you're already learning Laravel, why not give Lumen a try? It's basically a slim version of Laravel with focus on speed instead of features. The big plus in my opinion: If the project suddenly gets bigger, you can switch to a full Laravel setup later on.
I didn't say superior, I said "revolutionary". It works like this (I'm simplifying): 1) You write your permissions as classes with two methods: columns(), rows() 2) You write the method for your model, you can use two useful parameters: columns (an array containing the fields readable by the user for the resource he's asking) and rows (a piece of where clause containing a filter on the rows the user can view for the specified resource ) 3) You fill a table "authorizations", the fields are: AUTH: the authorization level of the user METHOD: the method PERMISSION: the permission OBJECT: the resource asked FIELDS: the accessible fields An example The table: AUTH: 1 METHOD: show PERMISSION: my OBJECT: users FIELDS: * the permission: class my { function columns(){} // if not set takes fields from table function rows($model){ return $model-&gt;table.".".$model-&gt;own_field." = ".Auth::user('id') } } the method: class show { function call($permission_row_filter, $permission_column_filter){ return "SELECT ". $permission_column_filter ." WHERE ".$permission_row_filter; } } Of cours the code is just to explain the idea, hope it is easy to understand.
Well here obviously. But twitter as well. Write blog posts about it. 
Have been through the steps, so I've got a few notes on things which you should include in your descriptions / readmes: - what prompted you to make this framework? what were you trying to achieve? - what problems you solve with your code. - try to use general accepted terms, add some comparisons - don't over-promote yourself, simply state what it does, cleanly (i found this utility useful: http://www.blablameter.com) - make sure it's free and open-source under MIT If your post gets down-voted, don't loose heart, try to improve then try again.
Pronouncing some general relations between x and y in classes isn't really that revolutionary. I also don't think that classes are the correct way of going about authentication in this manner, but then again I'm partial to procedural/functional programming.
That's kind of my point, you just said it in a less whiskeyed manner. Frameworks more often than not add unnecessary complexity, always add project bloat, create debugging nightmares, and can be a steep learning curve when onboarding new team members. But have an opposing view of frameworks on /r/PHP an prepare for a prolapsed anus after all the framework junkies have their turn railing you.
Flight is my go to as well. Very well written, IMO.
Ok, first lesson I learn today is: never-ever use this kind of terms when advertising. Sorry, I'm writing code not ad :/ 
I think they mean the older style shared, where you can't access any of the server configs, you just get a folder on a host and cpanel. I wonder how much I can run on an AWS nano server...
That doesn't mean they shouldn't try. It just means they need to fail enough to eventually succeed.
PHP is amazing language. Whatever schoolbook case spawns a discussion afresh. They should try. To optimize something that is slow already. Instead of devising pointless "optimizations" off their imagination.
I think this [tutorial](https://github.com/PatrickLouys/no-framework-tutorial) would be beneficial to you. It covers DI and how to set up other things from scratch (with components). Never inject the DI container, otherwise you have a service locator antipattern.Your controller never instantiates things that it needs, only its responses (depending on your setup).
Fat Free Framework
Think about the steps. When we register what are our constraints? Are there usernames or is email the login? First step in registering is attempting to select the previous mentioned items. If they exist, throw an error that the username/email is taken. If not, gather the rest of your register details and insert. Login is similiar. A common method is using bcrypt. When the user goes to login we select the email and see if the password hashes match. If they match we can set a session variable to signify the user is logged in. There's much more you can do and should do. But thinking along these lines should help.
How much are you paying for shared hosting? A t2 nano AWS on demand VPS costs yoy $5 per month. There is no reason to go for a shared host. Also, while other frameworks maybe faster lighter whatever, it's generally not worth it to use anything else given how quickly they die or aren't supported anymore after a short time. Go with Laravel LTS and you'll find many libraries already exist for it and it gets maintainence updates for the longest time. 
Mostly negative connotations, I'd like to add.
This, absolutely. Not having unit tests and a significant amount of test coverage is a deal breaker for me.
they could still practically run any framework that doesn't require any cmd line calls, just build the dependencies locally while building and package it up like the olden days (which means including the vendor folder in the zip). Still allows you develop normally for the client and can keep track of changes w/ git locally.
I don't think that hostgator plan limits domains: https://www.hostgator.com/cloud-hosting 
It does just enough for you to avoid wasting time fitting the pieces together yourself. It's great.
This is exceptionally helpful however it is my first time doing php and no time to learn how to do the basics. I'm jumping in the deep end.
&gt;Watching various educational videos they say that it is not a good idea to use Laravel on Shared Hosting Which ones? I want to know what idiots to avoid. Lumen is Laravel light. If I need to go really light but need REST routing I use the Klein router. If I don't need routing, I use zero extra code and just do it in raw PHP (which is about 95% of the time if I'm just putting up a json service for a mobile app)
Then I suggest you pack up and go find another hobby. If you have no time to learn the basics, you're going to build shitty code and never understand why it's shit, till someone comes along and dumps all your user tables and you fuck over a bunch of people because you had no time to learn. Learn you basics, expand on your foundations. And for the love of God don't handle actual user passwords with such reckless abandon.
What's this for coursework, freelance?
It's for school. None of it is going to be actual emails or passwords or any important details. Just testing purposes. As I only have until Christmas to get the registering parts working I really don't have time for the basics. I would never go into an actual job and just do the shit part I need to do for it to "just" work. 
My bad for not being explicit.
Their cheapest plan ($12.95/mo), has Domains: 1 in the expanded feature list. Also, the price is hidden until you go to buy the package. It's $7 a month if you pay for 3 years. Most VPSs nowadays charge by the hour. 
My secondary school science teacher wouldn't be happy with these graphs. Charts need to have titles, along with labelled axes, and units. Also, the first sentence after the first chart appears to be missing the closing words: &gt; For the cold boot there is no difference in memory use, but PHP 7.1 does have an advantage of 6% or so in. 
.NET Core is probably the thing that has excited me most in the past year or so. I have absolutely no interest in targeting a Windows server environment, but C# and the .NET ecosystem are very strong. I suspect there's a very good chance that I'll be adopting it for heavy-lifting back-end projects some time in the next 12-18 months.
Surprised that no one suggested CodeIgniter yet. Its one of the most popular on shared or minimal hosting plans I guess.
Do "larger" frameworks like Laravel, Symphony, etc. also actually have a larger memory footprint too? I was under the impression that they just come bundled with too many composer packages and the idle memory usage (in a hello-world app) isn't quite much. Is comparing Laravel to Slim pretty much like comparing KDE to XFCE in terms of memory footprint?
I wish there were more options for frameworks in HackLang.
Doesn't mean you can't just take advantage of it for the api and build the front end in something like react.
Big frameworks that work on shared hosting: Symfony, Laravel, and ZF2, ZF3 (LOOOOOT of files though, not fun for FTP uploading) Microframeworks of bigger ideas: Silex (Symfony), Lumen (Laravel) (Still lots of files thanks to composer though) Frameworks designed around shared hosting restraints: Codeigniter, ZF1, CakePHP (at least.. before v3, I know nothing of v3) (Far less files and far less complex, great starting point if newish) Static site generators: [take your pick](http://staticgen.com) (I personally use Pelican, but Jekylls been nice if you don't mind installing Ruby. Static sites benefit from less bandwidth and nothing dynamic to "hack") 
Nette, Symfony, Yii2, Slim. Laravel is hell of a overkill. 
Depends on the framework. Can't really say much about Symfony - it's stack traces are usually pretty short, but Laravel, oh my god - a 50-70 level deep stacktraces with a ton of abstraction classes means all that crap needs to be loaded, even with opcache usually it stats the file on disk to see if it has changed. As other people said, it really also depends on the host you are using. For some Symfony will run just fine, for others a Laravel app can be slow as hell.
Also (shameless advertising) you could try [ClusterCS](http://clustercs.com) as a nice free control panel so you can get going fast (ssh manager coming next build soon^TM )
I like code igniter as well, but I think it's because it's my first baby step into MVC stuff. 
What IDE are you using? 
You could use xpath for this, like $res = $xml-&gt;xpath('LighterVehicle[VehicleName = "Volvo12"]'); echo $res[0];
&gt; What have you done? 
No, they are not. Like I said, it just uses less memory but it's slower. In my case, I needed it because it was using over 4GB of RAM =/
Yes, you need to change the name OP. It's even worse than PHPixie. No female dev is going to use a library with a name synonymous with sexism.
Why does this trash have 28 upvotes? It amounts to "Frameworks and dependency injection suck because I'm not a good enough programmer to debug my PHP applications" It isn't fucking rocket science. 
Or, you know, just have some common sense to logically find what you do need to actually `var_dump()` instead of blaming something completely unrelated.......
Even still, I can't fathom what kind of debugging problems are so severe with service location that you need to rant about it online. A container is merely one step removed from the actual dependency you want to use, so if there's a bug, you simply `var_dump` that particular aspect of the container/service locator and sequentially work your way to the source of the problem. If you are retarded enough to `var_dump()` the container and then effectively *give up in frustration*, you need to put the keyboard down, permanently.
Hey look everyone! Found the person who doesn't know how to use one of the simplest frameworks in the ecosystem, and then blames the framework for it!
~~Well, what I think he's doing is trying to do is run `var_dump` on a domain object, but he's running into grief because the container is stored on the object. I don't think he's trying to dump the container; I think he's trying to *not* dump the container but it's coming along for free.~~ ~~And that is a legit concern, I think. The standard service locator anti-pattern is to pass the container into the constructor and keep it around just in case you need to locate a service, and once you do that, then you can no longer do `var_dump($this)` and get a useful representation of your domain object.~~ ~~Of course, there's a number of ways around it, starting with not relying on being able to call `var_dump` on your domain objects. :)~~ Edit: I have no idea what he's trying to do actually. Apparently he's trying to run var_dump on a third party library, which is never going to work out well for him. Since I'm struggling to understand exactly what the author is doing or why I can't say for certain, but I suspect saner usage of DI would still help. Still, I don't think you can blame everything that's gone wrong here on service locators...but ultimately this post is too confused and full of bad practices. Thanks to /u/phpdevster for pointing out I'd jumped to the wrong conclusion.
&gt; Let's say I have a class called Billing that takes a PaymentMethod as an argument. Later, I change my Billing code to do some logging, and so I also need to include a Logger service as an argument If you're using DI, that is true. &gt; but now I have to go through my entire codebase and change every reference to my Billing module to also add the Logger as a parameter. No, you'd just change your DI container so that the logger component is being passed in when a new Billing module is instantiated. That's the point. &gt; I genuinely don't understand why we seem to have decided in PHPland that moving wholesale to DI is a good idea and am genuinely receptive to arguments in its favour Because it makes complex codebases much easier to deal with. I'm currently working on a legacy codebase that uses the singletons and static methods everywhere, and it's an enormous pain. Anytime something wants to use a logger (or talk to the DB, or send an email, or do basically anything), it just goes `GlobalLogger::info('stuff');`. Which is easy to write, but a nightmare to maintain. 
[removed]
[removed]
/r/redpill 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Heh, fun trick. Too bad it won't work for arbitrary nesting levels.
As Rasmus has said many times, PHP frameworks all suck. A generic solution, most of it you don't need. A framework to handle the routing process? Dafuq. That runs on a webserver. That should make your head hurt. You want to expand your knowledge? Stop using frameworks. 
Maybe you should try nginx+php-fpm. I'm using it for some years, and I want to say that I never had the need to use Apache for small or big projects.
shared hostings generally support .zip so you can upload 1 big file and unzip it there. Also, Silex FTW
Void is now a reserved word in PHP 7.1 for typehinting and such. As Magento is a commerce application, with payment processing, a common part of processing payments is being able to void payments. So they have a Void class (or maybe one per payment method class/module) which now cannot exist in 7.1. This could be as easy as a mass find-replace, but it might not be the only incompatibility (there might be more corner case syntax changes, or more reserved words) or maybe their bug tracker is busier with other issues than being "bleeding edge" at the moment.
How much experience do you have in this field you're trying to revolutionise? Do you feel like you familiarised yourself very well with at least 2 other tools which attempt to solve related problems? Have you ever heard about the Dunning-Kruger effect? How do I know the answers are "Barely any", "No" and "No"?
The name "redpill" is more a project name. I will use a more specific name in the future. Thanks
No self respecting male dev is going to use it either!
First of all, the fact that you do something for free doesn't make you immune to criticism. The intention is good and nobody is criticizing that. What we are criticizing is the fact that you are attempting to solve a problem without a good understanding of it. The first step to improving laravel's acl is understanding how it works and what its drawbacks are. What you did was try to come up with your own solution as a replacement to understanding an existing one. Lastly, criticism is not hate. When you hate someone you let him continue down a wrong path if it doesn't harm you. You came here expecting praise and that's the underlying issue. You didn't write a framework to solve a problem. You did it for recognition. We all like recognition, but those who end up getting it didn't do it for the recognition, but rather did a great job because they enjoyed doing something and getting better at it, which happened to bring recognition If you wanted to get better, you would have embraced the criticism, dusted yourself off and looked for ways to improve.
Using such conversion myself, you'd think it's obvious E_DEPRECATED shouldn't be converted to exception. But it's Magento.
I'm thanking everyone is giving me tips, but I repeat, what you wrote is free hate. I mean why don't simply ask "Have you ever used Laravel's policies?". I would have replied "Yes, my idea came from that concept, but it is implemented in a different way."
&gt; I would argue with all this technology the web has actually regressed in terms of usability. Now most websites are overly engineered, convoluted pieces of shit loaded with frontend code that is rarely used. God yes. I can remember when I could have 100 tabs open in my browser, now it struggles with ten, constantly eating CPU and therefore my battery, and gobbling up all the RAM it can get its hands on.
Justified criticism is the opposite of free hate.
Mcrypt is also a common culprit - it is actually used in a lot of code and libraries. Even I had some uses still floating around, which then generates a lot of E_DEPRECATED warnings. This was the only upgrade-to-PHP-7.1 problem in my applications.
You can use it in creational patterns like factories. It should never be injected into anything else. If you disagree with this, you are probably writing bad code.
You can use codeigniter restserver, just create new controllers for your api endpoints which inherit from the restserver controller. Authentication will not be out of the box so you'll need to implement it. If you need more help let me know. 
&gt; If you disagree with this, you are probably writing bad code. Entirely possible though I'd sort of like to see some sort of request handler be written without using the service locator pattern. Got any links? The Symfony folks might also disagree. Out of the box their base controller class provides a number of useful helper functions which access a total of 12 (for S3.2) different services. Furthermore, if you look at their examples, the action methods themselves use service locator to pull out additional services such as database repositories as needed. Hence, the container is indeed injected into each controller. I suppose you can argue that Symfony promotes bad coding practices but then you are arguing against what is, by most measures, by far the most widely used PHP framework out there. Especially for "heavy duty" apps. Keep in mind that this is the out of the box behavior. When applicable, the developer can chose to not user service locator for controllers. Bit more code in exchange for somewhat more robust code. Classic trade off. I think I'll stick with never say never.
[not all symfony folks disagree with me](https://symfony.com/doc/current/controller/service.html). Do you mean just controllers by request handlers or something else? Symfony is also full of bad practices, they use strings instead of objects all over the place. It is ok-ish because you can still write good code on top of it and follow OOP, but it should not be taken as an example for good code (I'm sure they know better by now, but you can't just rewrite everything from scratch). 
[removed]
Ok, but why would you let some idiots dictate your decisions? Especially some fringe group on reddit that most people never heard of.
Looks like you forgot to change back to your alt account... You asked for opinions, you got some people replying saying it's a bad name. Accept it. If someone released a library called "Auschwitz", would you use it? No, because it has terrible connotations, looks bad on your CV, and no company would ever use it so it's useless professionally. Same for a library named after a pro-rape community.
Sorry I just can't resist. From the link you posted: &gt; Defining controllers as services is **not officially recommended** by Symfony. They are used by some developers for very specific use cases, such as DDD (domain-driven design) and Hexagonal Architecture applications. And while I'm pretty sure I know your answer already, in the spirit of being open-minded and optimistic, can you provide links to any github repositories containing application(s) you have written that follows your ideas of "good code"?
Get a copy of [clean code](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882). I work on proprietary software, my employer would not appreciate me sharing the code...
[removed]
There's also simple helix. Not sure about GoDaddy. I remember there were others as well. I use digital ocean these days though. 
&gt; You asked for opinions, you got some people replying saying it's a bad name. Accept it. Accept it? Wow. You got my opinion, why don't *you* accept it? If you don't like your statements being challenged then I suggest you don't state them. Let's not forget that we're in this discussion because you were imposing your will on someone because of your personal conviction. &gt; If someone released a library called "Auschwitz" If someone chooses the name Auschwitz then it has the intention of making the connection to a historical event *because* everyone knows it. In case of the name of this framework, the relation seems to be quite obviously pointing to the matrix, not a few loons nobody ever heard about. This is another example of people not caring about the *intentions* behind a name or a statement and taking the opportunity of being offended just because they can, not because there's a real reason.
It's singleton
He's working with an existing web app, rewriting it in laravel is likely beyond the project scope. 
You serious? * No composer * No PSR standards * No namespaces * No CLI interactions * [Incomplete tests](https://github.com/bcit-ci/CodeIgniter/tree/develop/tests) I'm sure there's more that I'm missing, but that's some of the stuff that I'm seeing at first glance. I've also seen grumblings in the past about CI's attempts at security being naive, but I don't know if that applies to the recent versions (so that's probably a moot point). ***With all of that said*** That doesn't mean it can't be used. Phil Sturgeon had written an [article](https://philsturgeon.uk/codeigniter/2012/12/05/5-things-codeigniter-cannot-do-without-a-rewrite/) a few years ago on CodeIgniter. The majority of it is still dated, but there is one piece that I think still holds true: &gt; Is CodeIgniter Dead? &gt; Absolutely not; and nobody is in a position to suggest that it is (looking at you Shawn McCool). CodeIgniter is simply never going to change, and maybe that is ok. &gt; Thousands of companies of all sizes are using CodeIgniter so whatever happens the framework is always going to be around, but it will be exactly the same as it is now for years to come, which means you aren't going to have to upgrade any legacy apps any time soon. Yay! &gt; I wrote this because people have been asking why I've ditched CodeIgniter for PyroCMS, and started moving it to Laravel 4 instead. I'm sure people will think I'm just wildly slagging CodeIgniter off, but I think its possible to respectfully highlight a products shortcomings without there being any hatred or resentment. CI was my first framework, and for what it did in the past, I think it did it very well. The problem I have is that because of how it was written in the past and then the sudden and rapid expansion of PHP, Composer, and the FIG - coupled *also* with the fact that CI had a change in ownership that brought active development to a screeching halt for a time - CI just fell way behind and had to make a very difficult decision in either: 1. Overhauling the entire codebase to fall in line with the changes in the PHP ecosystem, but risk alienating an already established userbase 2. Incrementally refactor and rebuild as best as possible to keep everything familiar for that same userbase Personally, I would hate to have to make that decision, but they did it, and they're still chugging along just fine. **tl;dr;** There's nothing *wrong* with using CodeIgniter. The problem is that it's showing its age due to things that have happened in its history, and there are more modern and more maintainable solutions out there that help developers get into better practices and coding standards.
For example https://www.youtube.com/watch?v=5Y4STYfvpk4 If you know where to find instructions for setting Laravel on Shared Hosting or would you like to create such a tutorial it would be great
OOP is not about data types with methods. OOP is about sending messages between object via executing methods on objects. Why everyone wants to write about OOP but ends with descriptions of turbo pascal
There's a deep ocean of legacy codeigniter code around, much of which isn't going to be rewritten any time soon, if ever. "The ~~poor~~ legacy code you will always have with you"
That readme doesn't really explain the use case. I can duckduckgo the buzzwords but I'd rather not. I would like to know where this database (?) fits into an application?
I always get a chuckle when I encounter someone who is an expert on telling people their code is bad. But oddly enough, when you ask them for examples of good code, nothing but crickets. 
Most popular, probably not, but it's the up-and-comer to be most likely.
I think for the Reddit community. 
I have no numbers, but it seems like it. Per Evan, it's popularity is due to /u/utotwel tweeting about it. I've been neck deep in Vue 2.1.x for a month now and am enjoying it. I tried Angular 1.x back in the day but abandoned it due to the 2.x bc breaks that were incoming.
There's nothing wrong with it, it just doesn't make much sense. * ~~Angular is a full-stack framework, if you know Angular there's no need to use it alongside PHP.~~ **Edited below.** * React and VueJs are front-end frameworks. They both need a backend API (hence PHP) in order to retrieve information from a database. **Edit:** Angular is not a full-stack framework, I meant to say fully fledged MVC.
Thank you for the correction - updating my response accordingly.
Outch. What if $_GET['file'] is "/etc/passwd"? this would read that fileâ€¦ Bad code. First you want to check that you are only reading files that are in your application directory, then you want to use mime_content_type to get the type of your file instead of using the extension. And then main thing just don't rely on the filename, just use a hash or something like that. Mostly you want to read, re-read and tattoo that article on your forehead: https://paragonie.com/blog/2015/10/how-securely-allow-users-upload-files
I think you should do a quick search for it on a job board and see how popular it is compared to others. This will give you a better idea of what is popular in the market at the moment
React also has React-Native. Just from sheer number of boilerplate examples and projects (redux, flux, altjs, oh my) I think React is the quiet winner. [Google Trends Comparison](https://www.google.com/trends/explore?q=%2Fm%2F012l1vxv,vue%20js) Yes yes I know "vue js" in the chart above is just a search term - but VueJS is not a recognized term in Google Trends and that should speak for itself.
\#YOLO
I prefer it. I've really come to enjoy Typescript and the angular ecosystem. 
VueJS is the absolute easiest way to upgrade pre-existing projects to some of the SPA-like features commonly associated with projects started in React and Angular.
I don't trust a developer who expects me to assume their code works correctly based on their personal assurance. Unit Tests demonstrate the following to me: 1. The developer cares enough about his library that he went through the extra effort to actually write and run tests 2. The developer is writing code in a way that it is actually testable Unit tests aren't perfect by any means, obviously, because they can be poorly-written or incomplete, but the fact there's even a `tests` folder in the project suggests a higher level of quality and attention than it would be otherwise.
I think you're missing the point. Unless you actually look at the unit tests, there's absolutely no guarantee of #2, and you can probably just as easily look at the code itself to determine that (if the docs don't demonstrate it already). As for #1, well sure, I'd love to see every library I use have it's own webpage with support forums for that library and a live chat with a 1,000,000 member community. &gt; ...but the fact there's even a tests folder in the project suggests a higher level of quality and attention than it would be otherwise... This is the point of disagreement which I've realized on more than one occasion by actually bothering to look at the tests. Indeed, in my opinion, the mentality that you're pushing here is precisely what causes this problem. People think that by adding tests even if those tests don't really do anything or test the library properly, they get some sort of credence, so they'll take the time to write tests but not actually put much more thought into overall architecture and flexibility. I've seen great libraries with no tests and terrible libraries with lots of tests.
Message me, I literally just passed this stage in the past week. I know the "what they don't tell you" 's. There aren't many useful tutorials out there. It's easy once you understand at the simple CRUD level. I'm redoing my awful, insecure to-do list with OOP in PHP 7.
Message me, I literally just passed this stage in the past week. I know the "what they don't tell you" 's. There aren't many useful tutorials out there. It's easy once you understand at the simple CRUD level. I'm redoing my awful, insecure to-do list with OOP in PHP 7.
Verify that you can write to the directory and that you're running as root: echo $_FILES['file']['error']."&lt;br&gt;"; $a = shell_exec("whoami"); echo "$a&lt;br/&gt;"; exec("echo `whoami` &gt;&gt; /media/webuploads/test",$a,$i); print_r($a); echo "$i&lt;/br&gt;"; copy($_FILES['file']['tmp_name'], $path) or die("nope"); Also see what happens if you `$ chmod 777 /media/webuploads/`
Sorry, I didn't read enough. You want to provide the full destination to `copy()` - including destination filename.
There's something wrong about asking the PHP community which is their most popular JavaScript UI framework.
Maybe guy is a natural, just needed the syntax.
Yeah, a better way to word it would be that an experienced developer in a language is able to say "X is good about it, X is bad about it." As in, if you know enough, you've done enough research, etc. you should know its strengths and weaknesses.
Still think react is the most popular lib. It has a huge community, and a ton of available plugins, and with facebook as its biggest user and backer, react will probably be out there for years to come.
I'm just going with the general feels of the thread.
I'm pretty sure the copy function will run under the same user as everything else. The "whoami" output should be helpful to understand what's actually going on. I don't remember if you need the full path or not, actually. But maybe it is that easy. I think what he meant is you're just pointing to the directory without giving an actual file destination. So you could try adding this before the copy line $path .= $_FILES["file"]['name']; //now $path = "/media/webuploads/VJXiGGH.jpg" copy($_FILES['file']['tmp_name'], "$path")` If that doesn't work please try with the code I added above so we'll know who you're actually running as and if you have write access to the directory.
&gt; I'm basically a decent person and I want absolutely nothing to do with /r/theredpill Sure, but what irks me about this is that you invent a problem where really non exist. The author, I assume, is not making the connection to the subreddit, so it's the people who raise the issue creating it and in turn empowering the subreddit. I would personally not waste energy on worrying about things that are out of your control and in essence not at all important to what you're trying to do. Just do your thing and let people be offensive and offended if they so choose, seems to me that the right counter to that is to lead by example and not be either.
At my internship, we used React but they were working on phasing in Elm. Truth be told, I like Elm a lot and use it in my personal projects. That said, you can't really go wrong picking a modern JavaScript framework like Angular, React (possibly with Redux), or Vue.
Composer, by default, requires dev dependencies last I checked. Furthermore, I do like having my dev dependencies installed by default (for dev), but most of my dev dependencies have no additional dependencies. This on the otherhand, pretty sure pulls in like half of the nette framework and a few symfony components. Like I said, I'll wait until it's capable of being installed globally.
I'm not sure. In my framework essentially everything is a module, so generally I write everything as a separate component and then provide the necessary stuff to make it plug into my framework easily. I guess in that sense the decision is already made, because nothing goes into the framework core except what's already in there which is basically bootstrapping, dependency injection, and a small application class that mostly interfaces with the installation/runtime environment.
[Fixed Google Trends Comparison](https://www.google.com/trends/explore?q=%2Fm%2F012l1vxv,vuejs,%2Fm%2F0j45p7w)
&gt;your sleeves and do some work.. I will do the work elsewhere. The only work that I am willing to put in relation to Php is telling people not to use it. &gt;You want respect? Try being civil for a start. Will contact you for more advice when I start looking for respect in shitty internet forums. Bye bye for now.
I mean... you're usually running composer commands in a development environment, so it makes sense that those are the defaults. Doesn't mean you shouldn't use `--no-dev` in your production deployments. I don't need PHPUnit on my servers either. In general see little reason to care about how many dependencies are installed so long as the software works. It's often better for it to be broken down into smaller pieces, although this can be taken to crazy extremes (*glares at NodeJS*) Still, to each their own; I was merely suggesting an approach that may solve the issues you have. Sounds like that's not the case though.
[removed]
Uncopied files are killed automatically after script finishes its work. You have to copy file while you'r processing request, and it's better done with special [move_uploaded_file()](http://php.net/manual/en/function.move-uploaded-file.php) function.
I bounce around contact jobs, mostly building APIs and in my experience angular and react are the most commonly used front-end frameworks right now. In reality if you build out am API as your backed it should not matter what front-end framework you use so just go with what you know or what you are most interested in working with. If it were me, id go with react these days, but angular2 is a solid option as well if you like typescript.
[removed]
And Joomla and WordPress. Yes, they are dying.
DomPDF is a pure-PHP library for going from HTML &gt; PDF. I hear it's really good too. 
You won't learn OOP, but it's written so hilariously, it's worth a read if you're trying to kill some time.
&gt; It's hard to trust this website for cryptology advise when their own website seems vulnerable... Your site is also vulnerable.
[removed]
Hmm, I see the standard PHP session cookie, but I don't see where session storage is ever used for something interesting. There's no even login in sight. Furthermore the site is HTTPS, which means that stealing that cookie is not *that* trivial, as it's encrypted in transit.
Thank you for the explanation. Much clearer now :) 
Two reasons for me: adding more dependencies slows down build times, and increases the possibility for security issues and other bugs. &gt; would you stop using PHPUnit if it added a few more dependencies? (It currently has 17.) Well, would you use PHPUnit if it had 1700 dependencies? I wouldn't. As for where the threshold is... I don't think that's easy to define. But as a general rule, the fewer dependencies the better.
Sarcasm aside, the language is OK, but the audience...
Thank you for the vote of confidence :) just what I needed after a long week of coding. I hope you have a good Monday! 
Haha not yet. Just messaged them now. We will wait and see........
Message sent!!
Thank you for the reply and link. I have not read it yet but will do with proper time. You say not to use the name, and I do not intend to, but I assume you are concerned about malicious files uploaded with names that can inject code right? 
This is the original title: &gt; Has Drupal adoption stalled because it's so "enterprisey"? They've spent last few years stagnating in features that bring value to the users, so they can rewrite the entire codebase to run on Symfony components. The result being it's just slower overall and not that much more feature capable. I guess there's a lesson in there.
I'd like to have whatever you're having.
[removed]
There is much more to OOP than what you learn in a year of Java. Read up on clean code and SOLID. Once you grasped the basics, [this tutorial](https://github.com/PatrickLouys/no-framework-tutorial) might also be helpful as it covers some of those OOP concepts.
Halite has [less than 6000 downloads after over a year](https://packagist.org/packages/paragonie/halite), and the lion's share of that is probably my own projects (e.g. caused by Travis CI and test VMs). Compare to [this abandoned PHP encryption library](https://packagist.org/packages/keboola/php-encryption), which has over 32,000 downloads. From the metrics, very few people use Halite. This was written for the majority, not the corner cases. :)
TIL I'm a corner case. Well, I didn't have to implement some crypto myself, but if I'll have to, then I know you are the one to trust.
Thanks I'll take a look :)
All right, let's peal away one layer of B.S., then. Even for just one of those important principles. Give me a definition of "single responsibility" that's non-ambiguous. Bonus points if the definition also doesn't conflict with another principle, YAGNI.
agreed. strange argument :p
&gt; (and did you meet this months spamming quota for your company?) If contributing something of value without getting anything in return (i.e. not even ad revenue, since we don't serve advertisements) is considered spamming, then I highly recommend everyone become spammers. I find it amusing that the people who are quick to accuse others of spamming [aren't significantly contributing themselves](https://www.reddit.com/user/wevesez/submitted/).
It all comes down to low coupling/high cohesion in the end anyways. But you can't just teach that and be done with it. The SOLID principles are not as bad as you make them out to be. They made me understand proper OOP and they helped many other people to do the same. I learned it in the way that I am suggesting here, so that approach clearly works (from my perspective). Maybe your approach works too for some people, but it didn't for me. I was in the dark until i came across the clean code talks on youtube, wasting many years writing shitty code on top of codeigniter. 
"a priori" - theoretically, in principle, in theory
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Sounds nice. One could say, proper OOP already implies an application is factored into modules. It's kind of unfortunate people expect frameworks to do the job for them.
&gt; what makes you think angular is not commonly used with php? It's purely opinion based, mostly from the offerings I see on the job boards I frequent. Admittedly my insight into Angular is dated, I was one of those who jumped off-board when the Angular 1 deprecation news came out, and haven't since kept up with Angular 2. I do believe PHP/Angular pairings are less common than PHP/React or PHP/Vue, but I think this is mostly attributed to the fact that out of the box Angular is an MVC (I mistakenly said "full-stack framework" above), whereas Vue/React come out of the box with only the capacity to handle the view aspect of the application. Since the idea of an MVC is compartmentalizing the logic of a complex application for ease-of-use, common sense would say that having two MVC's is only muddying your app logic. Moving forward with that logic.. in a situation where your PHP framework and front-end framework reside on the same server, Angular would be better utilized within a MEAN stack. That being said, once you start moving toward enterprise applications where the Database, API, and user-facing portions of your application are spread throughout various server clusters (or if you simply want an SPA), none of the above really applies and Angular is a fantastic choice. I actually maintain a few API's where this is the case - Our Laravel API handles data integrity and consistency across multiple platforms, while the desktop user-facing portion of the webapp runs Angular on a separate cluster. Just to sum up this wall of text - Angular is a fantastic framework, it's a very viable option that I even utilize within a few builds. With that being said, it's my opinion that pairing a PHP framework and Angular is overkill for most common projects (eg: smaller apps with single devs). In those instances It's going to be easier for a developer to maintain using one of the "view-only" JS frameworks.
&gt; Why reinvent this wheel of teaching OOP to beginners when there are hundreds of tutorials out there that do the same thing? Because that is what they do. Most tutorials are by and for newbies.
Laravel is en vogue right now. I doubt anyone can tell you if it's *truly* right as your first go, but why not. It's a framework. It'll let you make sites. The end. Do try to keep your business logic isolated in service objects that aren't intertwined with Laravel though. Maybe not initially, but I mean for your real projects. Treat Laravel as your "web layer", not as your entire platform.
Get yourself a subscription to Laracasts (even if for just one month) and you'll get a very practical education on PHP/Laravel/VueJS and see if you're comfortable with the stack. WP will give you a very good amount of freelance opportunities, albeit not very well paid. Laravel is for bigger customers.
Thanks. Yes, plan on subscribing to Laracasts soon!
Seeing your code I noticed that you're calling the variable $conn but haven't initialized it. What is the exact error message you're getting?
Basically it's DI to the "blahblah" class, an a SL to *whatever is creating* the "blahblah" instance. The problem with Service Locators is not that they locate services, nor that they're container objects. The problem is they contain everything, and you don't want everything to see everything, the goal of DI is every object gets/sees only what it needs, nothing else. It helps with flexibility and maintenance. BTW it's best your container is not static, because at some point your top level code may end up as a configurable module itself, and configuring statics is full of issues, i.e. $newblahblah = new blahblah($di-&gt;getKeyValueStorage(), $di-&gt;getLogger()); 
Technically you don't need a locator at all, but yeah.
You can inject **a** container, I agree thus far, but it should contain only what the object reportedly needs. If you insert the root container, you risk everything depending on everything, because this object gains access to all your dependencies. And I know it's all made with the good intentions of having discipline and using only a few things from the container, but juniors on your team, switching people responsible for a module, and most of all - deadlines... all of those trump discipline like magic.
You should learn PHP before laravel...
Wait, what about versions 1 - 4?
Might be indicative of the learning curve. I found Vue made way more sense straight up than React or Angular did. I spent a fair while just searching how to do anything with React (JSX, events, state it just kept growing) and a bit on all of Angular's different structures (services, factories, etc) compared to an article or two on Vue that basically said "you have components inside components and you write them in JS".
&gt; What have you done? I baked a pie recently. ^^^I ^^^burned ^^^it.
I don't understand this amalgamation of input validation/filtering object, with UI output responsibilities in the first place. I realize it's popular, but I see two distinct concerns there, and I treat them as such. Form output is a responsibility of the template engine, which converts *data models* into HTML through fully user-configurable logic. And validation/filtering is on the service side which accepts said input. But that's just me I guess.
&gt; Serve your content from github or something domain like that. Them may be I will buy this argument. Other than that your domain is your advertising. Who are you kidding pal. This is a stupid demand that isn't even worth responding to. I post technical blog posts on paragonie.com because I control the infrastructure. Content hosted on Github is one bogus DMCA takedown away from being removed. DoS via DMCA is a well known internet troll / harassment tactic. &gt; I am surprised at the naivety in your comment....You should really think the reads of this sub are Idiots if you think you can get away with arguments such as this. Let me flip the script here: What makes you think submitting a link to *free technical insight about cryptography* (once again: without ads, but also without annoying "call[s] to action" to subscribe to a mailing list and/or CSS popups) qualifies as spam? And if that *is* considered spam, [isn't this the sort of "spam" we want](https://xkcd.com/810)? No, I don't think I can "get away with arguments such as this" because "the reads of this sub are Idiots". I think they're far wiser, better informed, and more level-headed than you're portraying yourself to be in the comment I'm replying to. &gt; Combine with your sensationalist bullshit title, shows you aren't much better than the lowest of spammers. We have a lot of [blog](https://paragonie.com/blog/2015/07/common-uses-for-csprngs-cryptographically-secure-pseudo-random-number-generators) [posts](https://paragonie.com/blog/2015/09/state-cryptography-in-php) [with](https://paragonie.com/blog/2015/11/preventing-timing-attacks-on-string-comparison-with-double-hmac-strategy) [boring](https://paragonie.com/blog/2016/02/how-safely-store-password-in-2016) [titles](https://paragonie.com/blog/2016/06/constant-time-encoding-boring-cryptography-rfc-4648-and-you). God forbid we use one that grabs peoples' attention. &gt; Not really surprising, considering your past... What past? And why are you looking in that direction, we aren't headed there?
Is there any performance issues (or any other kind of issue) if I do a foreach loop with an anonymous function that returns an array rather than the array itself? For example: $data = function () { // fetch data from db return $data; }; foreach ($data() as $foo) { // do stuff }
[removed]
# WE NEED TO GO DEEPER
I think so, yeah. VueJS is the "Laravel of JS frameworks" - very easy to get into, quite intuitive, removes all the cruft of the others, and - most importantly imo - doesn't need Node. You can just plug it into an HTML page and it works, as opposed to many others out there. As someone who [prefers a Nodeless life](https://www.sitepoint.com/look-ma-no-nodejs-a-php-front-end-workflow-without-node/), I appreciate that greatly. Of course, being able to nicely structure my apps and have them perform well, too, is a good bonus.
Not sure learning Php is a wise thing now. Why not learn something like Go? The only reason you should be learning Php is if you want to work for people who can only afford shitty shared hosting providers....
Found the guy who can't use PHP properly
VueJS has https://alibaba.github.io/weex/ for native apps.
Single file components are so much easier than having functions strewn all over the place, for me at least. Also, I ran into issues with React where I had to create classes in different ways if I wanted different behaviors. E.g., handling route changes (intercepting the user leaving the page). That then had a domino effect of changing how other parts of my component worked. I forget exactly. The only thing I miss from react/redux is the ability for reducers to respond any pattern of action name. I haven't found a way to do that in vuejs/vuex yet, but it's also not much trouble to just handle each action. It's just a little more verbose there. 
Try yarn sometime, if you haven't. It'll give you the warm and fuzzies like composer. :)
I doubt it, but why?
Sadly it is
Why am I doing this or why am I asking? I am asking because I remember reading something about how foreach worked internally creating a copy of the array or something like that, and I was wondering if passing a closure to it would have a bigger impact in performance. I'm just dealing with a legacy codebase and trying to encapsulate some shit without having to do some major rewrites.
&gt; internally creating a copy of the array it only happens in [specific circumstances](https://nikic.github.io/2011/11/11/PHP-Internals-When-does-foreach-copy.html)
He created it: https://www.reddit.com/r/PHP/comments/5gi9b4/phpstan_find_bugs_in_your_code_without_writing/
I guess I literally mean plugins. As with WordPress and Magento, drag the code into the app and it's done. 
Not completely relevant, but one interesting I noticed in a couple of VueJS meetups I've been to was that many people there came from a PHP/Laravel background. So basically you get a lot less PHP bashing in the VueJS community which can be considered a breath of fresh air.
I'd say Symfony, understand the components, and trace the source code, try to put together your own framework using the components. Laravel (and all other frameworks) will come naturally after. IMO, Symfony is probably the best written frameworks out there, the code is a piece of art. Don't wast your time with WP if you want to learn good PHP and PHP frameworks, its code is garbage.
While PHP-Stan would be extremely useful right now for me, I tried to set it up with a ZendFramework 1 application. When I run analyse, nothing happens, nothing is shown, no output file is created. This tool looked really promissing.
Maybe try to increase your memory limit.
Okay, makes sense.
You're just feeding the trolls bro, the content is solid, it's yours and it's on your site. Someone's always gonna complain. Keep up the good work. I always walk away from your posts knowing a little more, and knowing that I know very little about crypto, even more, which is great. The best knowledge is knowing what you don't know.
Phan would have been redundant, but what about Mess Detector?
&gt; I am asking because I remember reading something about how foreach worked internally creating a copy of the array or something like that The ``foreach`` is happening *after* your function returns a result, so whether you call the function inside the foreach or save the result before it in a variable is basically equivalent (not exactly, but for all practical purposes). Therefore what ``foreach`` does regarding copying is irrelevant. Also the copying is copy-on-write as usual I believe, so it only matters if you modify the array you're looping through, otherwise the only thing "copied" is the iteration cursor of the array (someone correct me if I'm wrong). Basically, call away in ``foreach``, don't think about it.
Hmm, there's another good reason to use ``for`` when the array is a strict indexed list: PHP doesn't guarantee you'll iterate the list in order for integer keys. But at least that's a semantic reason, not a micro-optimization one.
i've returned it to a variable i call usercheck i want it then to talk to ajax and do its thing there i know the ajax call isn't connecting to the database not entirely sure why and my database connects i was able to mess around with it and ive got a new class. &lt;?php class userCheck extends DbConn { public function UsernameCheck($username) { try { $db = new DbConn; $tbl_members = $db-&gt;tbl_members; // prepare sql and bind parameters $stmt = $db-&gt;conn-&gt;prepare("SELECT username FROM members WHERE username = :name"); $stmt-&gt;bindParam(':name', $username); $stmt-&gt;execute(); $result = $stmt-&gt;fetch(PDO::FETCH_ASSOC); if($stmt-&gt;rowCount() &gt; 0){ echo $rows_returned = $stmt-&gt;rowCount(); } }catch(PDOExpection $e) { echo 'ERROR:'. $e-&gt;getMessage(); } return $usercheck; } } ?&gt; i pass my post variable from ajax this way to the above class &lt;?php include "\..\config\config.php"; require __DIR__. '\..\includes\functions.php'; $username = $_POST['username']; // To protect MySQL injection $username = stripslashes($username); $usercheck= new userCheck; $usercheck-&gt;UsernameCheck($username); echo $usercheck; i send it via ajax this way: script type="text/javascript" src="web/js/jquery-1.9.1.js"&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; $(document).ready(function(){ $('#username').keyup(function(){ var username = $('#username').val(); if(username.length &gt; 3) { $('#username_availability_result').html('&lt;?php echo "Loading..";?&gt;'); var post_string = 'username='+username; $.ajax({ type : 'POST', data : post_string, url : 'l{ocation of second php script i in this post).php', success: function(responseText){ if(responseText == 0){ $('#username_availability_result').html('&lt;span class="success"&gt;Username name available&lt;/span&gt;'); }else if(responseText &gt; 0){ $('#username_availability_result').html('&lt;span class="error"&gt;Username already taken&lt;/span&gt;'); }else{ alert('Connection issue please report it and we will fix it'); } } }); }else{ $('#username_availability_result').html(''); } }); }); ?&gt; 
&gt; PHP doesn't guarantee you'll iterate the list in order for integer keys. yup, as far as I remember it will iterate in the order items were stored. anyway, not the issue OP was asking about :)
Every once in a while when that subreddit is mentioned I'll drop in to see what silly shit is going on there. For the sake of impressing the connotations associated with the term "RedPill" I'll just give you the title of their most upvoted post for the month: &gt; HOW TO GET LAID LIKE A WARLORD: 37 Rules of Approaching Model-Tier Girls [Bonus post, bit more vulgar so it's in spoiler form](/s "You Owe Women You Just Met Absolutely Nothing Except a Proper Fucking")
Hi everybody. I am PHP and JavaScript + TypeScript developer. I have developed an open-source library called TypeORM which is highly inspired by Doctrine ORM. I always thought Doctrine ORM is one of the best thing ever created for PHP by humanity. Now I want to bring same experience to JavaScript and TypeScript community. Also if you are interested in using languages other then PHP but want to have same (or close) experience, I recommend you to checkout [my libraries](https://github.com/pleerock), if you are good with Symfony, Lavarel or other PHP frameworks youâ€™ll enjoy these tools in TypeScript/JavaScript world too.
That makes perfect sense. Thanks.
Here is my current reference code: $form = new ui\Form(); $form-&gt;setModel($client); $form-&gt;addSubmit('Register'); $form-&gt;onSubmit(function($form){ $form-&gt;model-&gt;save(); $form-&gt;model-&gt;emailConfirmation(); return $form-&gt;js()-&gt;successMessage('Well done!'); }); I think this mostly fits MVP pattern, where the above code is "presenter" and controls "model" ($client) object and "view" ($form) object, by providing some bindings between. The distinction with the big MVP framework is that connection is made on the "view" component and not on the page/route level. Presentation code must be concise and bind views, models with potentially some JS events (e.g. clicking button submits a form). In the end, you can decide to either `$form-&gt;render()` or `$layout-&gt;add($form)` depending on how the form fits into the rest of your application. Ideally, of course, you would rely on the UI framework entirely to perform all of your HTML generation, but if you only need a form you can just do that. Most frameworks rely on "echo"ing HTML fragments anyway, so my UI toolkit should be pretty portable. Here are how other components would fit in: - Field UI logic - should you need a new type of field, you can create a separate Field class, that would be just like any View (much more testable and portable) - Form layouts - if you desire, you can use custom HTML template for form layout, but it's optional. Form class will be able to output various forms types that CSS framework supports (horizontal, vertical, stacked, etc) without the need to supply layout: (http://semantic-ui.com/collections/form.html) - Validation logic - i see that as a domain model operation. Either there should be a method to run validation or you could get "validation exception" when you perform operation. In both cases, Form should be able to handle them and visualise using best practices of CSS framework (http://semantic-ui.com/behaviors/form.html) - Routing: form should either register some sort of in-bound route, so that it could communicate with itself, or pass some trigger argument to identify and handle the request (such as file upload). - Meta Information: Can be picked up from Domain Model as well. I am supporting free-form meta in my Data framework (https://github.com/atk4/data#explorability). If your model is JSON/ARRAY you might need to pass meta information yourself. Each of the Field Logic, Layouting, Submission, Validation and Meta information handling is done by Form object by outsourcing it to relevant components. When going from project-to-project, you would only write the "presenter logic" (as i typed above) and you can expect for everything to JUST WORKâ„¢. If the application framework requires a different way to register route, validate field or acquire meta-information, then "Form" UI class can be extended to offer a tighter integration and remain simple and full-featured. At the end, adding a form to any of your application is a matter of few lines of code, but what's most important, is that "Form" can now be a sub-component of a higher-level component such as CRUD (that uses form to add or edit records). 
Maybe in Drupal 9 ;-)
Yes, but you may just want to get really good at WP first, as that is where a lot of work is.
You don't have to listen to me, that's just my humble opinion, but what I see is so much abstraction here, that I can't even begin to untangle what happens where, and how. From a first glance, it appears that my server-side view object (ui\\Form) is triggering JS notifications (client-side concern), is doing routing (controller concern), is invoking and messing around with the model (business logic layer concern), and so on. This may be just failing to grasp the logic behind this design. So I'll instead ask a question about the implications of this design: how would I avoid duplicating all my business logic (form validation, model interaction etc.) when I have to expose more or less the same form as an input in four different clients: - Desktop site - Mobile site - Mobile native application - Command line This is not atypical. Clients which are fused with the backend don't have long legs, because the name of the game these days is "APIs". APIs which are independent of the clients that use them. And I don't see how the API is isolated from an HTML/JS form here.
In a way you are correct. Form will handle presentation, routing, notifications and model access, but it will rely on separate systems that would deal with it. Because, see, if I manage to do this correctly, the need to look "under the hood" for a common developer would be very rare. To answer your question: - FORM will present your Domain Model for HTML browser (desktop/mobile) and handle input. - REST-API app will present your Domain Model to Mobile API and handle input. - COMMAND LINE API will do the same for command-line operations. Validation sitting in your Domain Model will apply for all of the cases. Other business logic is also in domain model. So with the HTML UI being "still needed" but lesser of a focus, throwing a generic Form implementation and using generic UI layouts could be sufficient for 90% of use cases.
Look, have you never done marketing of any kind? This is basically marketing. It's got nothing to do with people being offended by trivial shit. It's playing to the audience by avoiding messaging with negative connotations. You say the problem doesn't really exist, but again - look at the response here. I think there's enough of a representative sample that the problem exists regardless of whether the OP cares or even knows about it. (Not sure why you think changing the name is empowering the subreddit though - historically, shunning the crap out of something or someone has been a pretty solid tactic. Anyway... ) Sure, it'd be nice if no one cared, but right now, naming your code or package after something that your audience will associate with negatively = less people looking at or using your code. It ain't exactly rocket science to recognize this and go with a neutral or positive name instead to avoid it. It's just good marketing.
Ain't that the truth! 
Thanks for sharing the code; it would really be more important to see the error message that you get from PHP. Since you don't print the reply from server you can use your browser's developer tools, Network tab to see the response of the AJAX request. If you do not see an error message add the following two lines on top of your script: error_reporting(E_ALL); ini_set("display_errors", 1); 
The problem remains that all the orchestration logic is in a UI component, so it'll need to be replicated across multiple UI components, for every type of UI (HTML, REST, CLI). So the problem of this code not being reusable across media types remains IMHO. A modern workflow for a project, at least for me, is figure out the APIs, and then my job is done. The various client teams can handle the client logic using the APIs I created. In your proposal, these aren't separated, so neither can each team do its work independently, nor is my job done when I define an API as the API orchestration and routing is in the UI...
I have a sense of deja vu, as if I remember /u/pmjones/ already making the exact point in a post (or was it elsewhere).
by 'final' I meant non-beta/alpha/RC/etc, i.e. official major release.. so did they?
What is the link with PHP?
It depends.
For something that amounts to a compiler's error checker? Certainly. &gt; As far as security, don't deploy dev stuff. What is this even supposed to mean?
Very well done!
I live in Brasilia...
Lifehack: Instead of a long-term organization, make decisions based on an ephemeral working group with **no long-term positions to be filled**. 1. Form a working group. 2. Solve the damn problem. 3. Dissolve the group forever. The second group of people, should they find themselves a party to the group, will be left with nothing once the problem is solved. Their only logical move is to actively stall the efforts of the group as long as possible-- but since groups are ephemeral, the cost of forming a new one without the influence of these people is low. Power is lent, not given or taken.
Run `composer install --no-dev` to make a lighter package with your application to deploy.
&gt; It's got nothing to do with people being offended by trivial shit. It's playing to the audience by avoiding messaging with negative connotations. But that's *exactly* what it is about, you think it is a bad marketing move *because* you're afraid people will be offended by it. And while I get that, most of the times these issues deserve a well rounded "fuck it" instead of a "oh we better give this the attention it doesn't deserve". I can easily turn it around as well, if you're worried that something insignificant is going to influence the popularity of your product, then doesn't that speak volumes about the product in the first place? &gt; but again - look at the response here All of 4 people, not to mention that the first to raise the issue had the nickname 'estrocide' and had issues with the name "PHPixie" as well... It's easy to get the wrong impression from the reddit echo chamber, you can invent any topic on the spot and find a group of people to support it. &gt; Not sure why you think changing the name is empowering the subreddit though - historically, shunning the crap out of something or someone has been a pretty solid tactic. Anyway. If something is of no importance then you don't let it dictate what you do. Since you do let it dictate your own actions, it must be important. So you empower the sub by acknowledging its importance.
Thank you for such warm words :)
Breaks rule 2 in the reporting dialogue: "Remain civil". Reported. 
But, the brand... You don't understand how hipsterware is programmed. You're supposed to keep asking your colleagues online and at work "aren't you following the recommendations of the FIG?", "I use 5 PSRs in my project", and so on. Without a consistent brand, you can't peer pressure people into adopting random PHP interfaces.
I don't know. My "separation of concerns" sense is tingling too strong when I see things coupled in this way. Such features like the form orchestrating a ton of unrelated functionality, or your DAL being exposed over REST makes for monoliths which are hard to disentangle and evolve as a modular, or let alone *distributed* architecture later on. In most of my apps, the business logic, or what you call "the model" is literally not on the same server as the controllers and templates that make up the website. You had some interesting insights about how ORMs pretend the database is "nearby" and so Agile Data models its APIs differently to account for the reality that the database is remote. I think your UI also has to be modeled to account for the fact the browser is remote, the model may be remote, and each of those services may even have separate teams working on them. So there should be as little magic as possible, and the flow of data should be transparent, not hidden, and the components should communicate through narrow, simple interfaces so components are easy to replace and extend. Making a Form object the hub of processing just feels wrong. It's like how WordPress, a blog application, became the hub of people's corporate websites, e-commerce shops and what not. It works, but it's kind of horrible to work on it. Nobody loves it.
to be honest I already did it. I have ported ~70k symfony2 project into ~30k node project using all my libraries with a team of 4 devs just in 2 weeks.
All right. What pros and cons do you see from the move?
Exactly. BTW, are you some sort of superhero? It's nearly impossible to find something from Reddit's archives.
Do you use Reddit Enhancement Suite at all? I always forget what features it adds. It has a feature called "Never Ending Reddit" that loads the next page of whatever, in this case comment history, in the same window when you hit the end of the current content. So I just held down "end" until I got to comments from ~8 months ago then ctrl+f "organization"
I see, so technically no superpowers, like Superman, but more like Iron Man or Batman. Thanks!
Zend is a large monolithic framework. Laravel is not. Are there smaller ones? Certainly. But don't tell me it's huge without comparing it to other PHP frameworks. 
Thanks for your feedback! I do find it suspicious there wouldn't be even one tiny drawback to the move, though :-) I can name a few as I work with both platforms, at least from my PoV: - A blocking or crashing bug will break the current response in PHP, and the entire server in Node. - I miss having a copy-on-write value type like PHP's arrays in JavaScript. PHP's arrays, despite all their faults, are excellent for a more functional approach to data transformation, filtering, aggregation and so on, without fearing you might change the data your caller sees (or somewhere further up the chain). - Deterministic destructors: very helpful when managing object pools (say database connection, since we're talking about it). JS has nothing like this. Newer versions have WeakMap, but that's also not deterministic. The result: explicit object finalization, when you need it. Verbose and error-prone. - Nominal type system: I love TypeScript's structural type system *most of the time*, but sometimes, when two interfaces have the same method signature, doesn't mean *they're the same interface*. Have you encountered the above? Any solutions? :-) Thanks
&gt; I think your UI also has to be modeled to account for the fact the browser is remote, the model may be remote, and each of those services may even have separate teams working on them. Precisely! Well, that's the beauty of software, you separate concepts first so that they are modular and independent and then you pull them under one "roof" of abstraction which allows you to step up to a next level. Next time you write the app, you become 5 times more efficient just by dropping objects on your page. Agile Data abstracts away database query languages and UI abstracts HTML. What is there left for developer? Just to define "models" or define "components" and then stitch them together. You may say it does not feel right but this will be incredibly efficient way to build software. So if you wouldn't use the concept, then some younger and less experienced developers will find it very attractive. Previously there were too many obstacles to this approach (php being slow language and CSS frameworks being very basic), but now is the right time. And speaking of wordpress - I know a lot of non-technical people who love wordpress. They don't care if it has a spaghetti code, for them it hides the complexity of managing a website and they love it. I'm not defending wordpress, but this is where things are moving, look at Drupal: https://www.drupal.org/node/2702061. I just thought to consult with community and do it "right".
&gt; Don't wast your time with WP To be fair if OP wants to make some relatively easy money WP is worth learning. That being said most WP gigs are soul sucking and I always look forward to getting off work so I can go work on my laravel projects instead.
My point is it's better you build your foundations from symfony and move to solve wp problems than the other way around.
One of the first steps I personally take when evaluating a new library / package / framework etc is to look through the tests for some of the core functionality. In addition to the points raised above about code quality and maintainability, I find the tests are the best place to get a feel for how well the architecture is actually laid out to address the problem space. If testing the core functionality involves clean test cases with minimal / logical mocking and building of dependencies or stubs and the actual functional calls in the tests are fairly clean, then usually the package code itself is going to be pretty clean / well designed. If, by contrast, the tests require lots of carefully built stubs to operate and lots of obtuse or complicated mocks to test / monitor, it's a very quick indication that the implementation is either brittle or has a poorly constructed API. Of course, evaluating a package's tests (or docs, or samples, or existing implementations etc etc) will never replace the knowledge or experience with it you gain by doing a full reference implementation of your domain using it. That said, when it comes to very quickly doing a "first line" evaluation of new or unknown packages I believe 90% of devs would probably choose to further evaluate the package with clean and logical tests. 
I think there are plugins for QGIS that can convert points to lat long strings or similar, but it's been a while...
He asked for the link with php :-)
Good find. Thought I had mentioned it elsewhere, thought to blog it for a more memorable location.
&gt; Wouldn't it be better to get the developers to change defaults? Well, the best move is **don't use RSA**. Instead: * Public-key * Encryption: X25519 then secret-key encryption * Authentication: Ed25519 * Secret-key * Encryption: xsalsa20poly1305 * Authentication: keyed BLAKE2b or HMAC-SHA512/256 There are several discussion threads [including one from today](http://externals.io/thread/560) to do exactly that. But it gets stonewalled by kneejerk backwards compatibility concerns. /u/kemmeta already solved that problem in a previous thread, but the Internals team seems to ignore my comments that suggest it.
I needed this. Great work. 
Sure, I don't disagree with that assessment. What I took issue with was the following (which seemed a bit too absolutist in my opinion): _Not having unit tests and a significant amount of test coverage is a deal breaker for me._ The vast majority of my evaluation is based on docs. There are plenty of well tested packages I've rejected because the docs demonstrate lack of foresight. Docs also tend to be a lot easier the parse than some tests. My point is rather simple. If you throw me a very specifically scoped library with docs that reveal a simple API, a very clear goal, and the requisite features to meet that goal, I couldn't care less about tests. Now, if you throw me some highly complex system with very indirect documentation and a lot more features than I ask for (even if I may be able to use them later), I might be very much more worried about testing, not for the least of reasons would be the potential of anyone to _accidentally_ introduce regressions. But even then, whether or not the tests are valuable is still going to require me to look at them. I forget which library it was, but recently I was looking at a library that was basically calling methods then testing against the internal data structures. So basically they were testing whether or not PHP's assignment functionality was working and that their internal data structures hadn't changed. That's not only brittle tests, but says fuck all with respect to the scope of the object. Sure, you test the API with respect to incoming data, but not at all with respect to processing and output. As ridiculous as that was, I still opted to use the library based on other factors, despite knowing the tests were essentially useless.
I have a feeling if create-react-app existed the week Taylor was trying to pick up React, Vue wouldn't even be a thing right now. Timing is everything.
On that page it says "vuejs" by Region is only US (as in "the only Region that has searched for 'vuejs'") Vuejs is created by a Chinese Guy, supported by Alibaba (weex), so that graph should include China. It doesn't, so its wrong. I often lookup stuff about Vue.js. I'm from the Netherlands. Nowhere to be found in the graph (like I said: only the US). The Legend is wrong or the data is wrong? [ttbf] IANASD (i am not a Statisticianous D), but... This is not the greatest graph of the world. This is just a tribute? [/ttbf] Footnote: I just invented the [ttbf] tag for illustrational purposes. If you're wondering what the hell it means (had the same wondering with ELI5 et cetera), it's the totally non-cool phrase "Trying To Be Funny". IANAC (I am not a comedian...)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
3rd party, checking in. I can answer 2 of those at least. &gt; A blocking or crashing bug will break the current response in PHP, and the entire server in Node. I think you typically have another daemon like pm2 to restart the server if it crashes. I suppose it's possible that if one request catastrophically fails it might take out a few others, which does suck. Try not to make fatal bugs ;) &gt; I miss having a copy-on-write value type like PHP's arrays in JavaScript. I'd much rather have purpose-built data structures than a generic blob that can't even tell you if it's an object/dictionary or a real array. If immutability is a concern, there's always ImmutableJS. &gt; Deterministic destructors I haven't personally ran into this problem. &gt; Nominal type system I haven't used TS too much yet. I think I'd prefer a type system even stronger than TS like you're suggesting, but I haven't found a better compile-to-JS language than TS. I think once WebAssembly takes off we'll see some new web-based languages start to appear. 
[See my reply on your bug post](https://github.com/robmorgan/phinx/issues/999#issuecomment-266544679), i.e. [use GeomFromText()](https://dev.mysql.com/doc/refman/5.5/en/populating-spatial-columns.html)
I'm not sold on ORMs. How do you solve the object-relational impedance mismatch problem?
I have zero experience with Drupal's 1 - 4, so I have no idea what those would look like, if too much different at all 
This one is actually pretty good if you ask me. And while that's true, people rarely give practical examples these days.
Posted this for the author of the blog post, credit goes to him. Thanks /u/patricklouys!
If you edit that much, you should probably apply for docs karma though.
Replied.
Ok well, go ahead and call your packages by names that people will view negatively because 'fuck you, I do what I want'. If it's that important to you, or whatever, knock yourself out. I still think that keeping a name that some people are going to instantly dislike out of belligerence alone is a stupid idea.
This is hardly true but will get upvoted because people here hate Drupal. Drupal 8 is the most feature rich of any of the releases. Configuration management is absolutely amazing. Entities everywhere makes content and configuration models and relations extremely easy to build and extend. The services API is more powerful out of the box for headless websites than you find with just about any framework or CMS. Dynamic page cache allows for contextually aware page caching for anonymous and authenticated traffic. Perhaps it's 'slower' if you bootstrap non-cached pages(which hardly ever happens), but dynamic page cache allows for nearly everything to be cached and it's significantly faster than the anonymous-only full page caching in 7. Drupal's learning curve and movement toward enterprise definitely distances itself from hobbyist and tinkerers, but in the enterprise world where it's actually being used by a ton of major content-heavy sites, it's made major strides both feature and code wise. It's not perfect, but a project used by such a large amount of people doesn't get the luxury of rapidly changing direction and implementing the most hip new coding philosophies at the drop of a hat. You can keep hating on something you don't understand, but there is a huge market for it and for good reason. OP's article even highlights that there is more money dollars in the Drupal industry than ever.
I'll consider it. "Work with XML" isn't on my todo list. 
Problem solved :)
&gt; I have no numbers, but it seems like it. Agreed. I think the best we'll get for Laravel users specifically is anecdata, but there's great, actual data on front-end framework popularity (and lots of other JavaScript ecosystem bits) here: http://stateofjs.com/2016/frontend/ As they conclude, "Vue is the new up-and-comer." My guess is that by the time they do this again for 2017, React and Vue will still be the stars.
I have made some updates to Amazo web framework. I could use some feedback. Some stuff are still a work in progress like comments for functions as well as composer. https://github.com/kemoycampbell/amazo
It's funny that as a PHP + JS + TS developer, I can't relate to any of that :o - Node.js being better in terms of perf: untrue, it largely depends on what (for IO it is better for example) - Node.js is much more greedy in terms of resources (a nodejs server runs continuously, even if is idle) - TS being a better language: I have mixed feelings about it tbh, I find it less flexible than PHP and sometimes I need it - TS do have less weirdness than PHP, but in the end you still to deal with JS at some point, and JS has way more weirdness than PHP - JS community is much bigger yes, but not nodejs and much less TS. Besides I tend to find the JS community much less mature than the PHP one - JS is the future... then why TS? JS is becoming a target of compilation true, but JS as a language this is much more arguable, proof is transpiling languages: Coffee, TS, Dart and a lot of other languages which are not happy with JS. Another major drawback I see with TS is that: - You cannot use regular JS with it: you need to change all the code (even if it's just adding `any` types everywhere this is annoying - You cannot use a third-library like that: you need to do the bindings (or import it if you're lucky enough to have it) And the thing I miss the most from PHP: you're application dies after each request, this avoid sooooo much shit. Also I'm still waiting to see tools as good as Blackfire for example in JS :)
Amazo / AWF? Sounds like a trademark dispute waiting to happen. 
There is a reason for not using composer at the moment. The dependencies are still a work in progress and I dont want to throw them into packagist without first receive feedback. 
&gt; I'd much rather have purpose-built data structures than a generic blob that can't even tell you if it's an object/dictionary or a real array. If immutability is a concern, there's always ImmutableJS. I don't like the lack of types in arrays, but when your app's main purpose in life is communicating with the world, then all this data will far more likely come in the form of JSON than ImmutableJS's primitives. So this means every piece of data that comes in, and every piece of data that goes out has to be painstakingly "hydrated" and "dehydrated" on the way in/out. I've tried this approach and it represents a significant amount of boilerplate, and performance hit. Also I don't have to say how much of a hell it is to work with deeply nested immutable structures, as the joke goes, if you want to turn up the thermostat in an immutable house, you need to replace the house. TypeScript now has something better, the "readonly" modifier, which lets you declare mutable structures (such as incoming JSON from servers) as immutable, without actually converting the data type, which is a bit better than using dedicated structures. But when you need to transform/convert/filter, you still basically have to make a deep copy of the entire structure at every step. Copy-on-write structures are making a comeback with new languages, like Swift and Rust, so it's one of those things that are unexpectedly brilliant in PHP, as hard it is to believe. We need value types with *local mutability*, and this is something that can't be just slapped on top as a library, if it's to be expected to be fast, efficient and comfortable to work with. It needs native language support.
Wait....... **THEY AREN'T REAL!?!?**
Every point made in this article is of value to anyone trying to implement encryption, and there isn't a lot of PHP content in this area. The downvotes you have suggest you can't really speak for everyone.
Well this is where I can bikeshed. Nothing you said if wrong, however, given the backwards compat complaints, the other response would be to have openssl_private_decrypt return nothing back to PHP that differentiates between "invalid key" and "invalid ASN when decoded", ensuring that this padding Oracle doesn't happen. After all, TLS still uses PKCS1 without continuing to be vulnerable.
&gt; ###what makes Amazo different from other web framework &gt; Skeleton-like framework - Instead of giving developers a large version of framework and force them to learn the whole layout in order to develop a website. We provide the minimum "bones" the developers need to build a web application. All need is to call the necessary methods/functions to build the desired component. &gt; Easy learning curve - Amazo is a straightforward webframework. Amazo is designed to be an instinctive framework. Method calling and usages should be straightforward and do without thinking. &gt; Native code interaction framework - Unlike other web framework, Amazo doesnt force developrs to build their application using GUI based interaction. But rather Amazo is a framework that allows developers to acutally write code and interact with it natvely. &gt; Built in secured database operations - In today's world, security have never been more important than it is today. Amazo database interactions are written in PDO using prepare statements in order to protect against sql injection and other known attacks. Developers are still required to perform their own string santiziation and validations. &gt; Flexibility - We all fell in love with coding because of the ability to do anything and have it submit to our wills. Unlike another web framework, Amazo doesnt take away the flexiblity from the developers. For example, we leave all exception handlings up to the developers so they can decide what action they want to take should an exception occured. Literally none of these things make your framework any different than anything else.
Maybe "bad programming" is a poor phrase, but clearly if omitting the tag is good practice then leaving it in is not good practice. 
So here's what I've learned so far about you: - You basically lied and said OP's site is vulnerable over a vector they don't even seem to use. - You don't understand the attacks linked in the article, you instead prefer to talk about quantum computers. - You have an extremely trivial point, that's irrelevant to the article and its addressees. I'm not particularly impressed. 
The SRP, OCP, ISP and DI principles in SOLID are a series of popular Rorschach tests for programmers. The "Open/Closed Principle" name contains an antonym pair: **open** and **closed**. Whatever you do it's either "open" or "closed" already, so you just need to take everything you already do and change absolutely nothing. Now, if it's about changing objects from outside, put it in the "open" category. If it's forbidding such change, put it in the "closed" category. Voila, you're following principles. Once you graduate from SOLID, there are other things you can try, like GRASP, DRY and YAGNI. The basic mechanism is the same. Say, YAGNI. Take everything you already do, and change absolutely nothing. If you already do something then "You're Gonna Need It". If you don't want to do it, then "You Ain't Gonna Need It".
You can't. You learn to live with it.
Skipping the closing tag avoids accidentally printing whitespace in your page from your code-only files. That's all. We don't need to enter a debate about highly subjective categories like "bad" and "good".
I'm glad. If you have more questions about it, I'll be happy to answer.
Well, look at the comment above again, and tell me what you see.
Leaving ?&gt; out prevents white space from accidentally ending up in the output, which can cause issues when trying to modify response headers. This is why omitting them is recommended by the [PSR-2 Guidelines](http://www.php-fig.org/psr/psr-2/). The only "downside" is that the code looks unbalanced (just like forgetting a closing parenthesis.
I don't understand meta things. I'm not smart enough. 
Along with the name, though? Doesn't stop them from getting pissed either way :)
Fuck you for playing with my OCD).
Yes, it was a [bug](https://bugs.php.net/bug.php?id=53432) that has been [fixed](http://php.net/ChangeLog-7.php#7.1.0) in 7.1 By the way, your fancy syntax for the output is unnecessary and potentially harmful. Variables in PHP should be addressed without quotes. So it should be just echo $string_array[0]; 
Yup, along with the name. I've done logos for some small companies, as a side job or a favor, and the illusion of uniqueness is unfortunately only this. An illusion. Once you start digging, and start browsing logos by style, shape, color and what not, and see all the similar ideas, the illusion breaks down. The same applies to names, and so on. Even more complex creations like music, paintings. In trademark, when you trademark something, a dispute can be had only if both trademarks participate in a similar trade, most trademarks aren't registered as trademarks for everything. Say when Apple Records sued Apple Inc. it was when they started their iTunes business of selling music, as Apple Records was also selling music. But Apple Records couldn't sue Apple for making computers branded "Apple". There simply wouldn't be any reasonable suspicion that people would confuse a computer with a CD album. So the above logo of Aboda. I could see a dispute if, say, Aboda was a software company selling a photo processing software called "Aboda Photoshake" or something. But as it is, if they're selling, say, air conditioners, it's fine.
I wouldn't blame a language bug on the user (and I'm saying this as someone who compulsively initializes all their PHP variables).
I don't think the bug you're linking is the same bug.
Hi, OP. I can't reproduce this: https://3v4l.org/TOGjP https://3v4l.org/bg7Zj
Wow, thanks for the great work! can it used on hybrid app based on cordova-sqlite or ionic framework?
I'm in good company: https://3v4l.org/TOGjP https://3v4l.org/bg7Zj
His problem actually is the $string_array that has been initialized as a string before. Were it just unset, he'd have his array first class. So there is noone to blame but himself
Yes. that's what I am talking about. https://3v4l.org/8VnKV 
Oh, I know the conditions, but a dispute doesn't mean they have to actually win, let alone start a lawsuit. :)
Thanks colshrapenl. I'm running 7.0.8 on DigitalOcean, so that's good to know that it's just a bug.
I appreciate your enthusiasm for your project, but this is /r/php, not /r/javascript 
Oh, you mean don't deploy development packages. Yes, that would be pointless anyhow. I misread/misunderstood what you were saying.
No I'm well aware of the full meaning, you're underestimating my exposure to the daily flood of SOLID-related blog posts and video presentations. It really doesn't change anything about what I said, it merely makes it more mouthful. When you want to allow a change to an object's configuration, behavior, state, call it "I opened it for extension". When you don't want to, call it "I closed it for modification". In the end, the important thing is you don't have to change absolutely anything about what you're already doing. You just need to change how you talk about it, and this means you can push your PoV on blog posts, while backing your opinion with well-established industry principles that sound authoritative.
It's PSR-2 standard to omit the PHP closing tag for a file that consists of only PHP http://www.php-fig.org/psr/psr-2/ section 2.2 In my opinion, not following PSR standards is bad practice, but 'bad programming' is certainly subjective
So there is an advantage to not closing them because white space will be introduced. Roger that. I encountered this in the wild once when a rookie committed a bunch of code... it took a while to find that white space. Serious question though... are there any advantages to including it? FWIW I like including it, but I like the finality and symmetry of it. I'm just wondering if there is any actual reason to other than preference.
Some consider using php tags at all bad programming. Edit: Geesh you guys cannot take a joke.
Anyway, I'm always trying to improve the usability and friendliness of tools so it's possible this will work out of the box in the future, even with misconfigured autoloaders.
really cool! 
&gt; Some consider using php ~~tags~~ at all bad programming. Fixed :trollface:
?&gt; is not bad, just useless
I tried to make it less confusing but I was at a loss as to other ways I could write selecting a number from my database, incrementing that number, and updating the value. If you've got another way, I'm all ears. I assumed mysql_query() queried my database with a certain query like I've seen on numerous other sites. I was using fetch object because it turns out that the query doesn't return a solid value and that I have to extract it some way but I'm confused as to how to extract it.
First of all you have to understand that mysql_query(), as well as well as any other function starting from `mysql_` won't work with mysqli. Do you realize that?
He's trying to say mysql**i**\_ and mysql\_ are two separate libraries, so don't mix them together.
Most people leave it out because PHP handles whitespace poorly where most other languages do not have this issue. Its considered a good practice to get around the poor way PHP handles it. This was later "fixed" by the output_buffer option in the config, I say "fixed" because simply putting a config option isn't really fixing the issue, more hiding it. So if your server has output_buffer on then it really doesn't matter and is simply a style choice 
Sadly it is. V4 is making huge steps to bring the framework into 2006 but its 10 years too late to the party.
Technically true that the "R" stands for recommendations, but not adhering to any standards at all is bad practice, and for me it makes sense to just adopt all PSR-2 recommendations, otherwise you have to create and maintain whole standard of standards and exceptions when working wiht a team to learn and follow which seems like wasted productivity to me. EDIT: yay, downvoted for suggesting that writing disorganized spaghetti might not be the optimal practice. Way to go /r/php, no wonder PHP has such a stellar reputation amongst programmers in general.
"It looks pretty"
Does this whitespace occur if your last line of each PHP file that does not output html is ?&gt; Or does it only occur if programmers accidentally insert one or more blank lines after the last ?&gt; e.g. &lt;?php // config file $db="test"; ?&gt; &lt;-------------blank line accidently put in file by a programmer Im just curious because I have never come across this issue and I have been doing php for quite a while. But then the last line of every file is always ?&gt; 
ITT: a lot of whitespace
Yeah I've never understood why you would use it over array_map or a simple custom class
&gt; Yeah but... why do you assume developers want to abstract away HTML? I don't. HTML itself is already an abstraction so thick, it can't be thicker. What's needed is a solution to work effectively with HTML, not a solution that lets us pretend HTML doesn't exist. I'm still working out the phrasing of my approach :) Abstract the UI, not HTML. - developer should be free to use HTML anywhere. - templates are component-based, e.g. you don't have to create template for each of your "page". Simply create "component" templates and re-use. - OK, if you want template for each of your page - you can have it! I want make it POSSIBLE not to use HTML, not to eliminate it entirely. I need to get the wording right or this instantly alienates a huge chunk of developers. &gt; ASP.NET Web Forms embarrassment Looking at user response, it wasn't a complete failure, but it was riddled with performance, scalability and other technical issues. Besides the forms were ugly. If failure would discourage humanity, we wouldn't reach north pole. &gt; It's a request/response communication. Which is a technical implementation detail, if you think about it. As soon as technology lets you not to work about technical details, you can be much more efficient with your time. &gt; Varied and Rich pages Another great example on timing. Look at Semantic UI layout demos. Look into www.linkedfinance.com, can you tell that it's built using component UI framework? There are ways now to theme things and still have a good looking consistent UI. No wonder CSS frameworks are so popular, that they are included in any guide now. It's a new standard. &gt; JavaScript apps Frontend JS development / Backend Web development is a very popular technology, but it comes at a cost. First you need to hire 2 developers to complete the job. Second it significantly complicates the things you need to do to build something. Looking at development budgets and start-up funding, those are shrinking now and we can't afford to spend $50K for a web app anymore. The UI solutions have always existed, just like people exist who refuse to use any framework. My desire is to bring a good UI solution into open-source. It would compete with phpgrid, phpcrud, formbuilder and all of those other $5 per project wigets. But the greatest thing is that your approach of "not bothering with the server" fits extremely well with my design. Just use whatever HTML as template, load your JS dependency, augment the frontend, and communicate using using the API between your JS and server'-side component code. The benefit is that your solution can now be used anywhere: $view-&gt;add(new \1110101010\ui\InterractiveWidget)-&gt;setModel($any_data_source); Well, might not give you any benefit, but for the sake of a bigger picture.
The constructor is not part of the interface contract. We are not breaking anything because it is actually no big deal if you use composition and dependency injection (with or without a container, you can just use factories if you prefer that). You assume that you always want to write to the file and send an email. But the situation in the post was "send an email in some cases". So how would you change the code you posted to adapt to that situation? 
&gt; &gt; It's a request/response communication. &gt; Which is a technical implementation detail, if you think about it. If you can ignore this and somehow eliminate the server/client latency, the server overhead in maintaining client UI state, and somehow bypass the fact PHP can't keep a two-way socket opened for a long time to the browser, then that would be quite the miracle. As it is, saying "it's a technical implementation detail" is like sitting at the edge of a cliff and boldly making a step forward, because gravity is just a physics detail. All the constraints still apply, I've not seen anything from the approach you're attempting to address this. &gt; Frontend JS development / Backend Web development is a very popular technology, but it comes at a cost. First you need to hire 2 developers to complete the job. Whether I sit down and write the application UI in PHP or JS doesn't make any difference in the amount of developers are required. There is still one application UI to write. In fact I'd argue that if I can write the client in the language that the client is running, I can do a lot more in a lot less time, with a lot less WTF/hour.
I learn something new everyday. I had no idea about the white space.
Indeed, also it's more fun and it can be fruitful to try and experiment with the techniques php offers by default.
LMA
Do editors attempt to alert the developer of this problem? Couldn't an editor attempt to scan the last closing tag and highlight any white space after it? 
This is a really good and concise piece of advice. Also, this is one of the most commonly used patterns in my code; together with [Registry Compiler](https://github.com/mlebkowski/registry-compiler) to reduce the DIC boilerplate
&gt; You just need to change how you talk about it, and this means you can push your PoV on blog posts, while backing your opinion with well-established industry principles that sound authoritative. That is absolutely disgusting. 
If there is a chance, i have to keep going :) It's too big to pass by.
That's the point.
Who is "we"? I like both Java and Php. To bad "you" don't have the temper to learn both ;)
* Create domain specific exceptions, so you can catch only them in your `try/catch` blocks (for example, when using guzzle you only want to handle the connection-related exceptions, and let others bubble up) * Pass only the data you will later use when debugging / looking at the logs / handling the exception. If you wonâ€™t ever use the `A450` error code â€” feel free to skip it (for example, the guzzleâ€™s error response may contain the HTTP status code, so one can make decisions basing on it) * Instead of an array, as in your example, pass two parameters: `$error` and `$message`; then provide a getter for each
Please consult the manual, the section about [Extending Exceptions](http://php.net/manual/en/language.exceptions.extending.php). It also shows you what parameters the constructor accepts.
I use a custom base exception class with the following modifications: 1. I allow the $code to be a string, instead of number, which is usually far easier to work with. 2. I make the third parameter array $details where you can specify the machine readable information contained in $message, as a dictionary of suitable key/values. So: throw new MyException( 'Please provide a string between 8 and 64 characters.', 'badStringLength', [ 'minLength' =&gt; 8, 'maxLength' =&gt; 64, ], $previous );
I'm pretty sure they used dynamo as an example for session storage in aws reinvent boot camp. I was wondering the same, what would be the consequences of it...
Then I guess you probably noticed the fact that the bug is talking about an empty string. Do you see an empty string anywhere in OP's example?
Thanks, this helps. There's no PSR standard, right..?
Nope.
I see the behavior that is possible for the empty string only. There is a thing called *logic,* you know, that makes you able to deduce events by their consequences. 
[removed]
Redis has a maximum key lifetime only if the TTL is set. PHP sessions expiration time are renewed for each session based page load. Thus for many scenarios you can persist a PHP session for a long time just by remaining intermittently active. I'm not sure if you can use Redis as PHP session storage without a TTL though.
you want /r/phphelp
@random314 - that's the previous version - here's the current v3 version: https://docs.aws.amazon.com/aws-sdk-php/v3/guide/service/dynamodb-session-handler.html (in case anyone reads up on it)
I'd recommend Symfony over Laravel. Laravel isn't a bad choice for sure but it is so opinionated with basically everything and it will do so much magic for you that you might have no clue what is going on or how it is working. I especially dislike the use of globals/facades which imo is bad design. In Symfony it is much more forced to use dependency injection which should lead to more decoupled code.
[Better Whitespace](https://github.com/ntpeters/vim-better-whitespace) is a nice plugin for vim that handles this problem.
https://www.reddit.com/r/PHP/comments/3lwxlw/hash_and_verify_passwords_in_php_the_right_way/cva6y6p/
What's up with the rudeness this morning? If y'all don't agree, discuss. Maybe we all learn something from it. 
Yup, the query is working fine. I'm honestly not that knowledgeable in PHP at all; i'm using similar code to a different report already in production that does the exact same thing just for different data. 
Apples and oranges ? ~~And no php 7~~ (edit)
Since you only pasted a link I'm going to assume what you meant. - you don't need an extra table column with our approach, actually you don't need to modify your DB at all so it's much simpler - the rest is exactly what I would document on the readme Having a comment somewhere on reddit containing that information is great, but having it on GitHub, maintained and with some code to help do the migration, is better (IMO).
What would the client code looks like that actually utilizes this Logger? At what point in our code does a concrete object get created for the logger? 
It could be interesting to see your code! I already dealt with this problem when migrating an old database containing md5 passwords to a password_hash alternative. I didn't think about your alternative :)
I've had the same issue. I just did the password check, and if that failed the md5 checked. If the latter worked, immediately rehash. You can also destroy their md5 hash and the next time they login send them an email with a recovery link. It's more secure than the former, tho a bit of extra work. 
It's always interesting to see how other people solve different problems, so unless it's super complicated for you to open source it I would say go for it. Usually it's better to just publish it rather than ask if there is any interest first, especially if you already have the code. 
Consider reviewing the margins and padding on your page...at least on the iPad, the code section is very narrow and must be scrolled from side to side to review each line and between the blue sidebar and then padding/margins, the actual article is about 1/3 of the page. I'll have to come back later on a computer to review your article's content due to its lack of readability on the iPad. Sounds like it's worth coming back to based on the comments. Ty 
What are some things that you can only learn by working for a company that you won't instantly pick up from freelancing? I'd love to read an article on this topic. Also what's one thing that you didn't think you'd use until you actually needed it and didn't know you needed it until after doing intensive research? (eg.: worker queues)
That's the right approach. Leave as few traces of the old system behind. they should also not use the same password. Asking people to change their password to the new system is the best way to ensure you don't leave holes in your security. What I do is treat the login using the old password as a "forgot my password" action and have them create a new password over the new system. I also like to add a column to the old table to keep track of who changed and who hasn't (date of when they changed and I delete the hash). It's a quick way to know who is inactive and either send them an email asking to update their password or whatever you want to do with their account. 
Couldn't you just check the length of the hashes in the DB? If it's 32 characters it's MD5, otherwise it's password_hash().
You guys were right, I initialized the variable as a string first and that's why I was getting the funky results... WHOOOPS!
Sorry, I initialized the variable as a string first and that's why I was getting the funky results... WHOOOPS! Sorry for wasting everyone's time.
`sqlsrv_fetch_array` likely returns an array. So in your loop you want to get that return value like: `while($row = sqlsrv_fetch_array){...`. Then you can use row like an array to get the values you want like: `$ord_hdrnumber = $row['ORD_hdrNUMber'];`...etc for the rest of the columns.
As usual, Phalcon and Fat-Free Framework are rocking the charts all around, and Laravel and Symfony2 lag like whoah - proving once again that devs prioritize ease of development and familiarity over pure performance. So no real change there. I thought I'd recognize most frameworks on the list, but I've never heard of ClanCats before. Anyone used that? ~~Also - no PHP7, as /u/Lelectrolux said. I am disappoint.~~
I've seen some systems that prepend the hash with what type of hash it is. 
I think this is unsafe since some of the weaknesses in md5 apply to the entire chain. Paging /u/sarciszewski to confirm.
why would they? won't the new hash obfuscate the hash as well as it would obfuscate plain text? Would a user using a password set to a md5 hash of something be less secure than a user using some other password?
I'm a Drupal developer and very familiar with the Form API. I'm not looking for a replacement any time soon, but this is what I need in a form: * Labels should be translatable. * I guess the language of names of values in select lists/checkboxes is out-of-scope for your project? * I need to be able to create repeating sets of fields * For repeating sets of fields, some fields must be allowed to be empty, but I guess this is about server side logic. * Repeating sets of fields may be reordered * A single repeating set of fields may be removed * A chosen value in one select list/checkboxes may filter/alter values in a different select list/checkboxes * A select list/checkbox may trigger state change somewhere else, like checking box "A" hides all fields Y, also when Y is in a repeating set of fields. Adding a new set with field Y, must know that A is checked and also hide Y in the new form set. States may be hidden, mandatory... probably more... refresh maybe, to handle filter/alter values above. * Embed arbitratry forms within other forms with a combined save button. * Checkbox tables: rows and columns are text, checkboxes in every cell to create pairs/coordinates. * I don't use this, but some people really like multistep forms. There are javascripts functions called tabledrag.js that I implement many places. It lets you reorder elements and also shift elements (depth) to create hierarchies. Here's the Form API docs for Drupal 7: https://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7.x Here are examples of state changes: https://api.drupal.org/api/drupal/includes!common.inc/function/drupal_process_states/7.x I wish you good luck. This is all very complicated!
And once you've hit a certain percentage, you can just drop md5 support and force them to use password reset if they ever decide to log in. Otherwise you'll be waiting forever.
Is that a philosophical question? What is an error.
I have a question, I admiitadly know very little about cryptology, however I am tasked with encrypting data in a C# application, and decrypting that data in a PHP application. I have been using your posts as a major resource. I currently came up with the following. * C# Create a random 256Bit key using RNGCryptoServiceProvider * Encypt the key using RSA private key with OAEP * Encrypt data using AES-256-CBC with randomly generated IV * HMAC the data Decryption is done in C# using openssl_decrypt. From your article in appears I should update my code to use Hybrid ECDH + Xsalsa20-Poly1305 It doesn't appear that .NET supports this encryption method. My preference is to not use third party libraries. I am not sure how familiar you are with .NET but am wondering if my solution is alright, or if there are better encryption methods using the build in .NET cryptology libraries (that also works with PHP). Not knowing anything about cryptology, this stuff is making my head spin, but is something I want to take seriously. I learned a lot over the past few weeks, but it still a drop in the bucket. 
What doesn't produce an integer? '$value-&gt;wins'? It's probably because you are still using mysql_fetch_object instead of mysqli_fetch_object. http://php.net/manual/en/mysqli-result.fetch-object.php If you're not using a debugger then you can use var_dump($value) to see what the type of variable is, so it will tell you that null is null where echo null will just echo nothing. I assume that by box, you mean '[]' which usually means an empty array. You're probably better off doing a mysqli_fetch_array for simplicity sake, but the code should still work with a fetch_object
I think the idea is to force a login more immediately 
While true, imagine you're trying to fill out a form and get kicked out... customers would be pretty pissed off, so I don't think it would be worth it unless it's a small site. 
1. Use console.log(data); to view the results in your browsers console instead of alert (as it's much more informative). 2. I don't see an echo anywhere, so presumably you aren't echoing anything for there to be data returned.
Very true. Especially while making a purchase. There are better ways to do it. 
As someone else has said, it's really a non-issue because you can just rehash the MD5 hashes. Then when someone logs in, MD5 hash it, and verify that against the hash in the database. It's very easy to implement with the built in PHP password functions.
AAhhhhh this worked!!! Thank you!!! 1 tiny problem is that the datetime value is still blank :S Any idea why that is? $sqlquery = " set transaction isolation level read uncommitted select o.ord_hdrnumber ,o.mov_number , n.last_updatedby, REPLACE(REPLACE(n.not_text,CHAR(10),' '),CHAR(13),' ') as 'notes', CAST(n.last_updatedatetime AS datetime) as 'updateDateTime' from orderheader o left join notes n on o.ord_hdrnumber=n.nre_tablekey and n.ntb_table='orderheader' where o.ord_hdrnumber='1324846'"; $process = sqlsrv_query($conn, $sqlquery); while( $row = sqlsrv_fetch_array($process)) { $ord_hdrnumber = $row['ord_hdrnumber']; $mov_number = $row['mov_number']; $last_updatedby = $row['last_updatedby']; $notes = $row['notes']; $updateDate = $row['updateDateTime']; echo "&lt;tr&gt;"; echo "&lt;td width=120 align=center&gt;"; echo $ord_hdrnumber; echo "&lt;/td&gt;"; echo "&lt;td width=100 align=center&gt;"; echo $mov_number; echo "&lt;/td&gt;"; echo "&lt;td width=280 align=center&gt;"; echo $last_updatedby; echo "&lt;/td&gt;"; echo "&lt;td&gt;"; echo $notes; echo "&lt;/td&gt;"; echo "&lt;td&gt;"; echo $updateDateTime; echo "&lt;/td&gt;"; echo "&lt;/tr&gt;"; 
That's what [password_hash()](http://php.net/manual/en/function.password-hash.php) does by the way. And instead of prefixing `md5` to existing hashes, we use [password_get_info()](http://php.net/manual/en/function.password-get-info.php) to see if it's a new hash or an old (MD5) hash, which works very well without having to do any DB migration.
CMS Airship: You're using libsodium, so that's a non-issue. Everything else: You're lucky to get symmetric-key crypto; asymmetric-key is usually not provided.
Trailing whitespace can cause issues with WordPress when developing a WordPress plugin, but that's all I can think of.
Just going to leave this here: [securepasswords.info](https://securepasswords.info).
I would really just be guessing. It's been about 10 years since I worked with sql server. If you run the query directly against the database (management studio or similar), do you see the expected result? Next I would `print_r($row)` within the while loop. This will dump out all the data so you can double check that you have stuff like the key spelled correctly and that you can see the expected column at all.
...and on which websites exactly? ;) ;) ;)
In C, yes. PHP treats them differently.
1. You're looking for /r/PHPhelp 2. You didn't share the code that attempts to save to the DB. Have you written that yet?
We have a script that runs once a day that cleans up old sessions. Works just fine.
Actually just tore out the last of some old md5 code. We did similar to you - difference is that we rewrote the password to the new type (since it's done during login and after verification, we have valid plaintext in hand). We finally reached the point where only a handful of people were still MD5 (which means they hadn't logged in in ages, so would probably need a standard password reset *anyway*). Detection was done with hashtype identifier prefix (eg, `$2y$...`) - the original author actually had a massive comment block apologjustifying for MD5, so he clearly knew this was coming and made sure there was a hash identifier. That said, even without hashtype prefix on the old version, as long as the new format does, you can still just detect for a *lack of* prefix (`$` is not a valid output for an md5 sum, so it's fine).
Now let's say it's an investment website where people only login once a year (or in some cases with long term investments, many years). Those old passwords from users who haven't logged in are still stored in an non-secure manner.
You would just have a dependency on the logger interface. Then it is up to either a dependency injection container or factory to provide the client class with an instance of a logger.
Company i work for still has plain-text passwords....
The main disadvantage to this is that you're now effectively treating `md5(password)` as the plaintext, so you (more or less) have plaintext passwords sitting around in backups/archives[1]. It also increases the complexity of your application's password handling without offering anything of a material improvement in security, comparing to doing a normal `password_hash` on next login or just wiping everything and forcing all of your users to go through your password recovery process. It's not *less secure*, but you should (broadly speaking) aim to have as little complexity as possible in what *you* do with passwords, and let all of that exist in the actual algorithms. [1] Granted, if you had unsalted MD5s stored in the first place, they may as well have been plaintext.
Aren't they still busy dealing with people from [this list](http://plaintextoffenders.com/)?
we did this 5y ago, worked like a charm.
Please look into [PDO prepared statements](http://php.net/manual/en/pdo.prepared-statements.php) to safely insert user input into database or this kid will ruin your day: https://xkcd.com/327/
same. sitting in a directory on the webserver, unhidden. At least it's named something like ".thisisanindescriptfilename". God I've been begging for access to our webserver at work for years. They have no idea. I've even logged in as someone else and they refuse.
Good one. I love simple solutions for legacy code
Lumen is after Laravel wtf how can the micro framework have less performance as the full stack ???
&gt; so you (more or less) have plaintext passwords sitting around in backups/archives[1] Valid point
1. You haven't given us enough code to provide a good answer. For example, we don't know if the form attributes are set properly. (i.e., code above references `$_POST`, but if `method=post` isn't set on form, then you're sending data via GET, which would explain why your code doesn't work) 2. Like /u/BubuX said, you should switch to prepared statements. directly injecting user provided data into a SQL statement is ASKING for a security breach. Even after some 'clean' function.
The easiest way to handle this is to force logout, and then create the new hash the next time they authenticate. If, after a few months, there are still remaining MD5 hashes (meaning they haven't logged in yet), just go ahead and delete the hash and force a password reset. There won't really be any interruption or knowledge of the upgrade for the vast majority of your active userbase.
Nope, plain text for the win!
Ah, good to know.
fantastic; thanks @phpfatalerror - I think we are going to try it out
I throw exactly what the error is, i don't bother with custom error codes unless there are too many potential failure points. I do not show errors in production, throwing it will be delivered to Sentry automatically with a specific message. I also throw when it's "exceptional" (see pragmatic programmer). In the legacy codebase I'm on now, for the sake of not ever throwing an exception, the original creators swallowed a lot of edge cases which warrant an error. For instance, missing cache data for a critical component will instead return "unknown" instead of throwing, which causes unintended behavior further down the chain. To narrow down these cases, we add in these exceptions to these blocks so sentry can help us narrow down conditions in which it got there. Eventually, we can tie it up nicely so it won't happen. 
No, as the name copy-on-write is trying to suggest, the copying doesn't happen at the moment you "make a copy", the copy is virtual, and only refers to the original without any duplication happening. Then as the original is modified, or the copy is modified, only the parts that have been modified are copied, the rest still remains shared. Copy-on-write can be thought of as "looks like a copy, works like immutables", for most practical purposes.
There are actually a number of frameworks running on php7. You can read a more detailed response to Lelectrolux's post [here](https://www.reddit.com/r/PHP/comments/5i3r1t/new_round_of_techempower_framework_benchmarks_is/db5xn28/).
``` &lt;?php $string = "really?"; echo $string[2]; ?&gt; ``` returns a
do you need more information from me 
If only there were a fully type safe variant of PHP that would catch this kind of thing the instant you press `Save`...
I noticed the other day that RDS uses latin1 by default so that may be your problem. You'll need to create a new option group (or parameter group, idr what it was called), change the values you need (character set, collation, etc) and apply that group to your instance.
But you can know about classes and files by reading the files, you don't need to dynamically include them. It's still not static in my view. 
Check your parameter group for your RDS instance. By default the character set settings are not set to anything which *should* mean use whatever you define on the database/table but after using AWS RDS for a while I've realized some of the settings you need to explicitly override using a custom parameter group. Note you cannot edit the default param group you need to create a new one in the correct db version family and then add your overrides.
That's my point exactly. Reason why you could ask them to provide a new password is in the event that your site was compromised and someone had access to the table. Seeing md5 hashes, someone could easily get the passwords from it. And since humans are idiots and we sometime reuse passwords, combining the email and password for other services could become an issue. So asking a user to change their password for the new hashing system helps. It's not mandatory. But I'd do it.
Exactly. Because these benchmarks have been clearly wrong for a long time.
Even better is to re-hash all md5 hashes right away, putting a flag in the DB next to it saying if it's been updated or not. Then in your login routine you take their password, check if the flag is set, then go MD5-&gt;bcrypt and if it's valid update the hash or of its not set just do the bcrypt directly. If your smart you can set your "has been updated" field an integer and increment it every time you change your algorithm. After a reasonable number have been updated from logging in, you can just remove the hashes that still haven't been updated, remove the old code, and just force those users to do a password reset. There are some timing attacks that you need to watch out for here so do your homework.
Put a flag in your DB saying if that pass has been updated, and skip the md5 of it has. Combine that with updating the hashes on algorithm (and in the future its time/iterations), and you can get rid of the MD5 hash component over time. 
I dont understand some of those on that list. Some of them look like account creation which perhaps the system randomly generates them a password and emailed it to them. Doesn't mean it is stored in plaintext/encrypted. Still not great as it should send them to a link to create a password but still. 
CakePHP doesn't do public-key crypto, which is what's being discussed in this blog post.
PBKDF2 is recommended be used as an algorithm for generating a key from a password, but not for hashing a password for safe storage any longer. It's not a bad idea by any means, but bcrypt is more resistant to hardware accelerated attacks which have become easier and easier with Bitcoin becoming more widespread, and something like scrypt is even better if you feel comfortable using something not as proven. Realistically the writing is already on the wall for PBKDF2 and bcrypt as well. Custom hardware is getting significantly faster than commodity hardware which means eventually a password that takes a second to hash and check on an average server will be hashable in a fraction of the time on an attackers hardware (it's mainly the amount of memory that's available to the hardware that's the limiting factor now). That's why argon2 needs scrutiny now as it's going to one day be needed. (Specifically the argon2id variant which is meant to be used as a general purpose password hash)
&gt; You know what, I think I'll stick with what's recommended by NIST, which is PBKDF2. PBKDF2 is approved for generating Symmetric Key(s) from a password for use in cryptography (this comes from SP-800-133, section 7.4). That said, the only suggestion for using it by the NIST is if you are a federal agency. If you're not, pick something better (bcrypt/scrypt/argon2).
Great reply, thanks. I'll definitely look into argon2
Why does this seem like a decade behind?
Mine was a joke too, though there is a currently a lot of "hate" for php (mainly from hyped js devs from what I've seen)
Joomla still uses md5, althought it is salted. 
Then just delete their cookie or whatever you're using to keep them logged in long-term. They can play out the rest of their session. Or rather, change their cookie to a session one rather than a long-term one.
That's exactly what we did.
*Less* explicit IMO. There are many things for which that'd return null, but not too many things are 32-chars of hex. Not that it matters if it can only be one of two algos.
After all the serious things happened in the UK regarding to the GCHQ, anti-privacy laws and so on: who would like to host his business data there?
Very generally, with DI you inject the dependencies. With SL, you inject the container.
Grooving on "behat" recently. http://behat.org/ Not mine but it should be more widely known. It's a PHP implementation of "Gherkin" from the Ruby world. It lets you write behavioral (acceptance?) tests in plain language, then implement the parsing of that language simply. I'm still trying to figure out what's a behavioral test and what's a unit test, but check the tool out. 
Hillary 
As a UK based developer...me. At least for anything targeting a UK audience. You'd be foolish to think that the recent anti-privacy stuff is exclusive to the UK. The US is just as bad with privacy, and has been for many years. The only difference is that they don't make it public. 99% of people couldn't care less. Businesses still need to operate, and they'll do that in the region that is closest/best for their customers.
I'll keep it short: Ok another validation library that thinks it's better/easier/more powerful. I'm using Symfony, therefore the Symfony Validation Component. Can you compare both solutions? Actually I never had problems validating something.
You seem to be spamming this everywhere. What market does this fill? It seems very light on features compared to the other opensource, well established, well tested alternatives.
It's hard since everyone is already using some library. If I understood correctly the rules are passed as strings to check(), Laravel validation already works with a set of string rules, maybe if each rule was a method that the IDE can autocomplete it could get more attention 
What do you use? -&gt; https://github.com/nelmio/NelmioApiDocBundle Why? -&gt; Symfony Bundle (well integrated), tested, it works What's the learning curves and gotcha's on your solution? -&gt; Read the documentation once and you're fine I think. Not sure how good it works outside of symfony context.
This doesn't seem like PHP.
The buyback code will probably use authorization, form validation and DB from Wordpress. It would be quite difficult to divorce it from WP later. You could look at something like [Bolt](https://bolt.cm/), a CMS similar to Wordpress but built on Symfony, which means your code will also be built on SF, which is much better (in terms of cleanliness and reusability) than having something built on WP.
Sphinx that deploys to ReadTheDocs. Needed something that auto-generates a big chunk and supports multi-language. Skeleton [here](https://github.com/sitepoint/rtdsphinx-php). Example implementation [here](http://diffbot-php-client-docs.readthedocs.io/en/latest/). Explanation [here](https://www.sitepoint.com/fast-multi-language-docs-with-sitepoints-rtdsphinx-php/).
Metric butt-ton ... lol
( /his/their/ ) You raise a damn good question. Certainly if I was an international business I'd be thinking carefully right now. However, for British based businesses, with British customers, there may be reasons. For one thing, our Data Protection Laws currently cross the EU so using the Irish Amazon zone is fine for us. Post Brexit? We currently have no clue what our data protection regime will be then. And I'm sure that's top of their list to sort out.&lt;/sarcasm&gt;.
True, tho given details of the new law like the British Gov needs to be told of new tech pre-launch so they can require back doors if they want (!!!!) I'd argue international businesses should still be looking at this very closely.
This. I had the same thing in the back of my mind when reading your readme.md.
Neither is "Faceboo" on Facebook's but that won't stop them from sending you a C&amp;D
I mean, I don't disagree with your privacy non-concerns. Ireland is really going to be no different to London. But, lets look at the figures. I just launched a few clusters, and from where I am in the UK, Ireland (which appears marginally cheaper), is 10ms further away on our line than London, ironically, going via London (18ms vs 8ms). So really, you're going to be only worried about this in lowest possibly latency senarios.
I'd probably be better off doing this in PHP though, it would probably much easier would it not? That's why it was my idea to run the queries, possibly order them by the answer columns selected, then compare them as sets to get an intersection point in PHP..
There are not many applications for which the extra 5ms to Dublin makes a real difference.
*Specifications are for the weak and timid!*
Try **RAML** http://raml.org/developers/raml-100-tutorial it is very easy to use. When I asked myself the same question that I found this and I feel very comfortable with this tool.
This is the best solution if you want more than just API doc's IMO. With the PHP an HTTP domains it's very easy to make decent API doc's aswell
Yes it does, because PHP lets you index into strings. But `$string[2]` produces another string, not a char, and `$string` isn't an array (try using `$string[]`).
The most interesting part would be https://github.com/shieldfy/shieldfy-php-client/tree/master/src/data. But thats empty...?
Actually its an intrusion detection system , when detecting a threat it provide the developer useful informations about the steps hacker take , also analyse total information to know which parts of your application targeted a lot and can be vulnerable.
But it has instant notifications that can be integrated in seconds into a visibility dashboard used by people working in teams. What more do you need to know? Edit: Seriously though, the [how it works](https://shieldfy.io/how-it-works) page doesn't actually tell you how it works and just has a few misleading loading animations and a bunch of grammatic errors.
So can you tell us what kind of rules are available?
this help me to install pecl extensions in new Centos servers.
APIDoc http://apidocjs.com/
The rules are actually whatever you like them to be. The define()/check() methods are purely to work with respect validation. But your rules can literally be a bunch of if statements without the help of anything if you like.
+1 for Slate. I re-wrote our current API documentation from static documents using this tool in a long weekend. It's easy, looks nice for the boss, and functions really well for outside developers. That said, we're looking at documenting our next-gen API in either RAML or Swagger.
So many people trash talk WP. It's nice to seeing some actual data. TLDR: It's not that bad, but better sanitization is needed. 
I only really see Laravel framework utilization. Most other gigs are roll your own frameworks with either Zend or Symfony components.
Laravel 4.2 on PHP7.01 Lumen 5.0.1 on PHP5 Apples, Oranges as u/Lelectrolux says https://github.com/TechEmpower/FrameworkBenchmarks/tree/master/frameworks/PHP/laravel https://github.com/TechEmpower/FrameworkBenchmarks/blob/master/frameworks/PHP/lumen/benchmark_config.json 
No worries, all fine :)
I'm in Chicago, working on dismantling a CodeIgnitor app and replacing it with a few Laravel apps. I've come across CodeIgnitor before (disguised as Kohana), but aside from that, I've only encountered Symfony (and Silex), ZF, and Laravel in production.
When discussing the state of WordPress security, we can't overlook [the deficits that plague its core](http://www.openwall.com/lists/oss-security/2016/11/21/3) (which [isn't a theoretical concern](https://www.wordfence.com/blog/2016/11/hacking-27-web-via-wordpress-auto-update/)). It's good that you were able to perform an automated analysis and identify these vulnerabilities. Hopefully they can be fixed quickly. However, a lot of vulnerabilities are *not* trivial to identify with a quick code scan. [For example](https://paragonie.com/blog/2016/01/on-design-and-implementation-stealth-backdoor-for-web-applications). After seeing these results, I'm more worried about subtle logic bugs (which are sometimes predicated on the use of insecure RNGs in security contexts) remaining than I am about e.g. scan-and-patch SQL injection vulnerabilities.
Symfony here, I think it's the closest you can currently get to an Enterprise solution that works for big projects. Although I have to admit I don't really know how Zend is doing these days.
I was a bit surprised that the article seems to say nothing about the WP core. Did they actually do a separate analysis that I didn't see?
You hear so little about it. I'm not entirely sure anyone uses it in North America at all.
Ah, recommending it.... that's a different story. Still, it does get the job done... You can't argue that you can't kill flies with rifles... I bet you can...
I've seen Laravel, Code Igniter, Yii (1.1), Silex, and Kohana in production environments.
F3 is so good. If I weren't at a Laravel shop, that is what I would try to get out the door most of the time.
I've seen Nette around in job postings out of Europe. It is interesting that there seems to be such a geographical split with these things. CodeIgniter has had the slowest death of anything I've seen in a long time.
Slim is nice. Is there a particular reason for using it over others?
Why does it not surprise me that a plugin called "All In One WP Security and Firewall" had major security issues? The number of SQL injections they found worries me a lot. One of the problems with WordPress is that the userbase is almost entirely uneducated in web security. This in itself isn't a problem, but it means that absolutely horrid plugins can get very popular and have lots of stellar reviews. One of my favorite examples was when we found out that two plugins downloaded 6 million times [executed any PHP found in a particular comment tag in comments on posts](http://blog.sucuri.net/2013/04/update-wp-super-cache-and-w3tc-immediately-remote-code-execution-vulnerability-disclosed.html) (!). This shows an author who is completely oblivious to basic application security practices, yet it appeared to function, so people used it. I'm not sure what the best approach is to combat this sort of thing. Include automatic scanning for common vulnerabilities on WordPress's site when you upload a plugin? Rank reviews according to how "trusted" the reviewer is, technologically?
Silex in production here! Doubt I'd choose it for something greenfield, but served me well moving our site from script.php to something more robust.
Regarding your first problem, the `max_execution_time` ini setting is not affected by the `sleep()` function (along with system calls, DB queries, etc) for non Windows-based installations. It only sets the maximum time for which the script itself may execute for. In your case, PHP only executes your loop 96 times (8 * 12, where 8 = minutes of execution, 12 = 60 / 5 = time spent sleeping) before the 8 minute timeout. That's something PHP can easily do in the 10 second time limit you've given. Likely, it's Apache that has the timeout set to 8 minutes which is why your script times out then. I don't know if it has always been this way, but it certainly has been for all of PHP 5+.
Me too, APIDoc is very simple to use.
You are correct, I discovered that shortly after posting. Which makes sense because the real script I was timing died after about 30 seconds. I've upped it to 60 for now. Is there anyway to make PHP log that the execution time was exceeded before it dies?
There are plenty of code sniffers that can detect potential XSS stuff, but the problem is that they have a lot of false positives as well. If you pass sanitized data to an output function you might have to unescape and reescape it just to satisfy the sniffer. Our shop turned that part of Jenkins off after long, because real errors would be buried under a mound of false positive XSS ones.
Las Vegas, NV. I use Symfony for long term applications that will be around for a while and Laravel for short term small scale things like websites and quick stuff that will get either scrapped or re written later.
&gt; *This shows an author who is completely oblivious to basic application security practices, yet it appeared to function, so people used it.* Unfortunately, that is true for any popular platform that supports plugins, especially commercial ones. If a platform is popular, you can bet there are code monkeys slinging insecure code for it, and uneducated users are eating it up. For example, look at Magento extensions or themes. XSS is abound, every second plugin you find breaks with developer mode enabled, every third one does something crazy and incompatible. And if you're really lucky, the plugin your customer wants the most is [actually made of swiss cheese](https://news.ycombinator.com/item?id=13100162).
we mostly use ZF2 &amp; ZF3. US, CT.
In my experience most jobs/gigs involving PHP have been native PHP. Only recently have I started working for a company that uses a framework, a mix of Yii &amp; Yii2 powering a multitude of sites. I have also used Slim for small APIs. 
Bernhard Schussek is the author of the Symfony Form component https://github.com/symfony/form/blob/master/Form.php#L59
Cake was nice when I worked with it. Cake2. I get the feeling that its real segment are CRUD applications. It scaffolds those extremely well. I kind of get the feeling that things are leveling out in the backend side of things. With JS being the hot stuff, I figure there is going to be a lot catching up in that area before we see huge changes.
I've worked companies using all sorts of frameworks. Zend, Yii2, laravel, symphony, cakephp, codeigniter etc Frameworks I havnt seen used in practice lumen, slim, phalcon, 
That interesting to know. I'm in the Southern United States, and it is too easy to be ignorant of what our friends in other countries use. It really does make sense that Symfony would popular in France though, local pride and all. BTW, how is Nantes? I've always heard it was worth a visit.
Is there a reason for Yii? I've only seen a handful of companies that use it. I'm only really getting into Frameworks at my current job, prior gigs were native as well. 
NOTE: I have added the Wiki page to list of various scenarios. That should help me plan features and implement. If you come up with any extra ideas, please contribute: https://github.com/atk4/ui/wiki/Scenarios
Why not include a set of XSS based tests to the API instead?
Our MD has a fetish for WordPress because admin panels. I've been secretly building all our recent projects in Laravel.
What are you using to display your raml docs?
What might you choose for a greenfield project?
Industry standard? Elaborate on that please.
Berlin here, we are using yii2 for our shop.
It's quite straightforward after the first setup, but I guess by now it's my experience talking. You'd best give it a go, it's half an hour at most to go from zero to end result described in the tutorial linked above, and it'll be the fastest way to get to grips with it and see what works and what doesn't.
Working with CakePHP 2 at my current place, but switching to a different company that is using Laravel next year
In house thing and Silex. We might have one more recent one that's Laravel.
Silex here too, with assistance of mobile app, the app is maintain log of power generator and its equipment
There are quite a few places in Salt Lake County, Utah and also in Utah County that use PHP. Do keep in mind that the cost of living here is fairly low compared to many other places, so do some research in that area before looking at salaries here.
Yii / Yii2 and Laravel - based in NZ but don't think either is all that common
https://en.m.wikipedia.org/wiki/OpenAPI_Specification
I left a job where I used Laravel (learned PHP with it) and took a job where we use ZF2. The curve hasn't been too bad, especially since the way things are done in v3 are much closer than what I was used to. I still prefer Laravel though.
Worked at a Yii shop to build enterprise telco projects. Mostly integrations and middle ware type systems. It's not the most fabulous framework but it's the one with least amount of magic and cleverness. The team understood the core classes thoroughly and extended functionality as necessary without any problems. Also the official support for the framework is fantastic. Yii 1.x is still supported and receives security patches as needed. Performance, Translations, Tooling and the general no-hype all-work attitude around Yii community are some of the other factors that were seen positively. 
&gt; The reason I give wordpress shit is because "professional" companies higher people who call themselves "web developers" because they can upload a theme and some plugins to wordpress.... and they doesn't see a problem with using seven 4mb photos in a slider on the home page of a site! From a puritanical developer's perspective, it's pretty bad. It'll be interesting to see these type of people pick up the pieces *when things go wrong*. From a business perspective, it doesn't matter, if there is a good ROI.
Right..but I could also just *not* convert my arrays and objects to immutable until just before I was about to write to them, and then only make a shallow copy. That would have roughly the same performance, but be much more tedious, no?
I use Yii2 everyday. It comes with a CRUD generator that includes a list table views (GridView) that provides server side AJAX filtering, sorting and pagination without writing a single code. I couldn't find the official example but here's a plugin that add extra functionality to the default one: http://demos.krajee.com/grid-demo Another thing I like about Yii2 is the class structure is very simple which makes it easy to extends. It's not the most popular framework out there but you wouldn't know if you look at their GitHub account.
can confirm, am PHP dev in Columbus, there are exactly none of us :-(
You think it's the thing best for enterprise projects but admit you're unaware of other offerings? Lol
It's not so interesting... It means I have to painstakingly explain to someone how one of the thirteen plugins they're using to add google analytics to their page is interfering with either one of the six "slider" plugins or one of the four "contact us" plugging they're using. 
What's so funny? It seems a great deal of effort has gone into it, and looks decent enough at a first glance.
Can be accidental. Years ago (perhaps not relevant now) there would be Windows vs Unix new line issues that would sometimes result in there being a new line added during FTP transfers. Edge case but I remember dealing with it a few times as we sold PHP scripts back in the day and had it occur with a buncha customers. 
&gt; It'll be interesting to see these type of people pick up the pieces when things go wrong. 1) they generally don't even know that things *are* wrong 2) when things get really bad, the people who made the mess generally aren't around to pick up the pieces anymore (or simply don't know how to do it - adding more plugins is not the answer). 
Looks great
In Michigan. We support probably 25 or so CodeIgniter apps. Anything new is Laravel.
I saw a phalcon app in the wild once, boss at my last job was a big performance elitist. I never worked on it but I remember lots of people struggling mightily to get it running locally.
Czech republic reporting in, I personally use Laravel for a fairly large e-commerce application, but everybody uses a framework called Nette here. It's a czech-made framework, and czechs are known for love of their own products I guess ... Hard to hire developers here because of that.
No it just means you didn't solve anything at all from the original problem set of making this unobtrusive, automatic and efficient. 
I just happened to do this today. It required installation of the entire LAMP stack using the Linux command line. This was in an E2C Amazon Linux instance. I did a microserver to start, which is FREE! I had never set up a server but there was a guide. Just Google "setup LAMP on E2C Amazon linux" and you'll find it. You can literally copy an paste the commands into the terminal once you ssh in.
But why do it? Why not scale your app on BlueHost? Is there a downside to it? or is it simply viewed as "unprofessional" or "newbie".
Just put your bluehost behind free cloudflare caching if your site is mostly static. Forget Amazon, they're way too complicated for a simple small biz site. 
When your site consume a lot of system resources, some shared hosting provider may ask you to move to VPS or dedicated server. (I don't know if that is the case at BlueHost though) Another reason for managing your own system is that you are free to choose your stack. If you want to use PostgreSQL, NoSQL or message queue system they might not be available on shared hosting, but you are free to install them on your own system.
`0?: 'Default'` seems completely useless since `??` already behaves the way you seem to be looking for: `$var ?? 'Default'`. https://wiki.php.net/rfc/isset_ternary
Yes.. there is learning a 'operator'. If I keep it together as `??0?:` then it's just like learning a new operator like ?? or ?:. 
If you're asking this, you should not try building a large scalable web app.
Maybe the weird porny anime mascot thing, I chuckled
&gt; That ignores the very real possibility that you don't accidentally produce logs that contain results from the crack Definitely. I don't think a certain technology is evil. It's how you use it. Einstein is not evil for splitting the atom, the assholes using it to blow things / people are. But yeah, I agree it's better to stay away from these things in case you mess up.
Because you need much more control over your resources than a simple host will provide, you want to use the advanced products that Amazon offers, or you need automation as a core part of your infrastructure. Or all three, usually. You don't use AWS because it's easy (it's a pain in the ass); you use it because it provides the tools you need to solve your problems.
Exceptions are for exceptional things. If the user caused it, it's not exceptional. User input validation is definitely not a proper use for exceptions.
The idea behind cloud hosting is that you can increase the size of your servers because they're "virtual". So you can beef up a $5 / month server to a $500 / month server. And when the $500 / month server isn't enough, you can start spinning up more $500 / month servers.
Came here looking for FirstData library. Much disappoint. Didn't figure that running a credit card required an entire framework, but was interested in the results anyway.
We get java developers all the time that we just teach PHP. What's the big deal? 
Nice nice...!
Sigh. First, your comment is out of context - I'm not answering a "when do I throw an exception" question. Second, there's nothing above referring to a **user**. PDO will also throw exceptions when you feed it a bad query or data. My code is a simple example demonstrating what goes in each constructor argument. Third, believe it or not, the "exceptions are for exceptional things" meme doesn't blow anyone's mind. If you think about it, it means nothing, because whether something is "exceptional" is dependent on how you *choose* to model your domain.
All hosting is cloud hosting unless you own a physical server.
Gee, and nobody even started the oversexualized-logo-burn-it-with-fire holywar yet? Brace yourself /u/ScriptFUSION
By far the most popular framework in germany aswell. Laravel, for example doesn't even get a glimpse by most of the community I had contact with. They know if, of course, but there is just no better tool around. Also it's easier to hire since france is right around the corner. That said I never worked with a frenchman, though.
Are you done?
Symfony in the Netherlands as well.
I was well aware of that. Even the latest Google Trends shows Zend high up there, and again, I haven't heard anyone mention Zend at all in the last 2 years.
TRIGGERED
I don't change jobs very often, but here's my experience in Northern England: * 2000-2002: In-house "framework" (basically just a big function library) written in PHP3 + PHPLIB templates, with a move to PHP4 as I was leaving. * *2002-2007: Lived in France and Netherlands, wasn't working with PHP.* * 2008-2012: In-house "framework", XML-based. * 2012-2015: Same company, but we replaced in-house framework with Symfony 2. * 2015-2016: Different company, Laravel 5.x.
No blog post. I am just legitimately curious about how other people code. It wasn't a discussion I had seen in a while either. I live in a .NET/Node town so it is cool to have some perspective on the language I use everyday.
I'm sorry, I don't know what you're talking about.
I'm sorry, but it's not clear enough to someone coming to the project for a first time. Let's go over the items: &gt; Provides a framework for structuring data import concepts, such a providers offering data via one or more resources. PHP comes with data providers out of the box for many common sources: SQL, sockets, JSON/XML/CSV data. It's not clear why using a framework makes this significantly better rather than using PHP, its extensions, and specialized libraries for given APIs one can find on Packagist or the vendor's site. &gt; Offers useful post-import data augmentation operations such as filtering and mapping. It's not clear why such "augmentation" operations would be significantly better than directly manipulating arrays, PHP comes with a rich (if a bit messy, but you get used to it) library for manipulating arrays. &gt; Protects against intermittent network failure with durability features. This sounds interesting, but there isn't enough clarity what exactly happens at Porter, and how it recovers from network failure. Typically this is up to the protocol, i.e. it requires support on both ends of the transmission. For example let's say you're streaming data from SQL, the connection interrupts. Would Porter quietly re-do the query? That's not a good idea, because now we're in a brand new transaction, and combining data from multiple DB snapshots may result in quietly corrupted import. &gt; Supports raw data caching, at the connector level, for each import. It's unclear which operation during import requires caching. I.e. what is being cached? Why does it have to be cached? Etc. &gt; Joins many data sets together using sub-imports. Unclear what this means, other than "can combine arrays", so I'll refer back to the point about PHP arrays being easy to manipulate and transform. I think it'd help if you could create several non-trivial (i.e. not useless "hello, world") **before / after** examples that *convincingly* demonstrate Ported provides additional clarity, code density, or features, over what we can already do in PHP. I see no such comparison.
Look up the history of the Sass logo.
Maybe, but again... it shouldn't be that the users should be sweating figuring out a way to make the author's library seem useful. It's up to the author to demonstrate how it's useful. Some realistic before/after (i.e. plain PHP vs. Porter) examples would go a long way to shutting me up :-)
Most of the current projects at my work are on CakePHP. I have also worked on some CodeIgniter projects. My personal sites are mostly made without any frameworks, or on CakePHP.
Latency on dynamodb for one. You really should switch to redis. 
Wow, that escalated quickly.
While your points do have some validity, as someone who frequently works with very large and continuous data import sets from multiple providers (think TV listing data from all the major providers) there is a lot here that I have had to write from scratch that I would have loved first time round. Data imports are rarely simple as 8-10 lines of code, for example the situation where fragment imports have remote dependencies in as yet un-processed files. This framework gives some of the tools I would use to be able to handle this quite effectively from what I can see. Although I have not used this yet, I do intend to trial it on a smaller upcoming project and see how it works in anger.
the only way to lance a boil is to bring it to a head. Fuck everything about that guy. Theres no reason to shit on somebodys something like that. If he had ever made a significant effort to build something useful and share it with strangers maybe he would understand why he is human trash. 
I'm curious what are your biggest pain points in importing data that you'd like to get resolved (and also which of them this project addresses).
Silex here too! Used for small websites that would be static html and simple API.
Building web apps is fine on any cloud host like Bluehost, Digital Ocean, Rackspace, AWS, (insert your fav host here). No user cares if you are hosted on Bluehost or AWS. They care that the app does what they want quickly and reliably. The issue is not in which host you choose but in how highly scaleable apps are designed. If you do not have experience designing highly scaleable apps then you need to research how that is done. Research first, then design the system. During the design phase you will discover what host is the best fit your app. Be warned - you will make bad choices in hosting. No one gets it right the fist time, or the second, or the third. Keep learning and use your experiences to make the app better. 
Yet another abstraction layer that will eventually lead to more code in real world applications that is poorly readable. Fantastic that your particular "Hello World!" is only one line of code! Who the F*K cares?
Just native PHP. For my type of work, frameworks are mostly "one size fits none". I'm better off rolling my own.
Thanks for your feedback. Regarding your first point, the benefits should be conveyed by the keywords, *framework* and *abstraction*. It is assuming the reader already understands why these are beneficial because it is out of scope to digress into these concepts, particularly in a bullet list. However, this could be expanded on elsewhere. Perhaps it is easy to take for granted the domain language presented to you in this documentation, but for example, what are now known as *resources* were originally called *data types*, then *data fetchers*, then *data sources* and finally *resources*. If it seems to you the concepts are obvious or self-explanatory then I consider the domain language of the current iteration to be a success. &gt;It's not clear why such "augmentation" operations would be significantly better than directly manipulating arrays It's nice to be able to wrap up both the import and the transformations in the `ImportSpecification` so that what you get back from calling `Porter::import()` is something you can work with straight away. Nevertheless, if you do not enjoy working with Mapper or prefer using native array functions, this is perfectly valid, too. The issue is that you will need to remember to perform those steps every time you import that data since you are no longer letting Porter take care of it for you. In the near future I plan to refactor mappings and filters as plugins so you could use your preferred plugin for post-import transformations. &gt;For example let's say you're streaming data from SQL, the connection interrupts. Would Porter quietly re-do the query? That's not a good idea As you correctly identify, Porter doesn't know what to do, which is why it delegates that decision to the specific connector implementation. It is up to the connector to decide whether an exception is recoverable or fatal by throwing the appropriate exception type as described [here](https://github.com/ScriptFUSION/Porter#durability-1). Porter then responds accordingly by retrying if the error is recoverable, or halting if it is not. With respect to your point about caching and sub-imports being unclear, it seems you haven't taken the time to read about those topics; correct me if I'm wrong. If you have specific questions after reading about them I'll happily answer those. Regarding improvements to the documentation, if you have ideas you could put down in writing I'd love to see a pull request. Thanks again for your input!
Hmm, my impression is you started with the idea of writing your own CMS, then got bogged down into dependencies by trying to use existing packages for most of the work, although they were ill-fitting. Existing CMS are indeed not great, they are mostly glorified blog/forum engines extended to hell and back with plugins into doing whatever people want out of them. Writing a solid solution would require a clear vision, and more commitment than trying to get it done in a few days, like you folks did. Drupal's rewrite from 7 to 8 alone took what... 2-3 years?
Yeah, you're right, we got a job for a client to create a small cms, hence the reason we thought about writing our own cms. That's also the reason why we didn't have time to spend more than a few months on it. That was one of our learnings :-D 
Very well. As long as you're prepared a few people to mention it every time you post about the project.
We did it because our dedicated Bluehost server is running a bunch of old code on it and we needed to set our new project up with a newer version of PHP. Not to mention Bluehost was down for like 10 hours on friday.
I would also like an answer to that question
There are different kind of bottlenecks your app may hit. Here are a few: - Network bandwidth/latency - Disk speed/latency - Memory capacity/speed - CPU speed Even if BlueHost would not limit you at all (and they do), at some point you'll hit an upper boundary defined by the physical machine your site is running on. A single computer is only that fast, has only so much memory, has only so fast network card etc. From that point on your application will have to be split across multiple machines, to keep scaling. And there's no automatic way of doing this. Your *application architecture* has to be designed to utilize multiple machines, BlueHost won't re-write the application for you. I hope that gives you a few starting points to do your own research.
I once created my own blog CMS. It was fun and did exactly what I wanted (and had zero dependencies to external libraries neither for the frontend nor the backend). It used markdown for creating blog posts, had categories and tags, and some more convenience features and was able to either use a database or files in a directory. It never made it into production nor was ever released somewhere. But I learned a little from creating it.
This is also how I approach projects (when the client can afford a custom CMS), but there's something that still bugs me about this approach. I wonder if you ever thought how limited we are by HTML / markdown editors in CMS. It seems like no single CMS I've seen tackles how limited our expression is there. We can have headings, lists, bold, italic, links, images maybe, and a few custom CSS classes. When it comes to more complicated content, we need to defer back to a bunch of fields in a form. Ideally we'd have a fully declarative model, say a custom XML schema, where we can describe exactly the elements of content we want, customers will be able to play freely re-organizing and nesting blocks, and then our code can transform this to HTML and other media. Unfortunately we can't ask of content-writers to write XML, so the next problem is, how the heck do you make a decent editor for this... When you design the higher-level blocks around your customer's needs, the need for such custom content schema lessens, but I find that all this custom work is merely a workaround for our inability to declaratively define content models and let people just use them to define their content.
Don't see why not. So yeah, stick with BlueHost since you like them.
&gt; a general purpose CMS is a fundamentally flawed approach. It has layers upon layers of abstraction and assumptions which invariably get in the way of building the specific thing you want to build. This. *This.* THIS.
&gt; You shouldn't attempt to build a general purpose CMS, which is what Drupal/WP are. Why? Because a general purpose CMS is a fundamentally flawed approach. Quoted for emphasis.
It seems developer oriented. We can't talk about "content management" when a lot of it is about HTML snippets etc. I'm sure it has its uses, but it's not what I think about when I imagine a CMS.
Can we also get an article on how to cook meth but shouldn't?
Thanks! Ill give Utah a look. I don't mind a low salary if the cost of living is proportional 
It depends, really. It manages content very well - I don't understand by it's not what you imagine with a CMS - what do you imagine with a CMS? Are you talking about a friendly "I've never seen any code in my life" UI to manage content with databases/assets/ACL?
I gave a chance to your framework, and I can say that saved me a ton of work. Well done!
You fail to explain why this is necessary or useful. You've linked a bunch of articles but those just describe example project structures and give no motivation for why everyone should follow the same structure. 
Good to see that there are still jobs that skip frameworks. Keeps you sharp I bet.
ðŸ‘Œ thats awesome thank you. Also, I was speaking about senior positions, preferably enterprise products with agile development. Yes, I bet it's not as expensive as in Ca but I want to be sure does LV happen to be a good choice for me. 
For Sr. Positions I've seen positions for 80k-150k (the 150k was for William Hill as a Sr. Dev/Architect). You can make some really good money here. Just be sure you're okay working in Gambling/Payday/Entertainment.
Netherlands, Symfony ftw :-)
Agreed...and honestly [Satis](https://github.com/composer/satis) isn't that hard to configure.
Satis doesn't give you a whole lot out of the box though, feel free to give the free trial a shot, you can easily import your entire satis config (or composer.json if you still have many VCS repositories defined in there) on the package page, and then play around/try the install/etc. And we are only getting started, we have a lot more features in the pipeline that I really believe will make it easier to deal with your dependencies and project updates on a day to day basis. It may not be for everyone, but I hope some will see the value in what we built :)
I'll open an issue for it, but where should I put source code like JS, SCSS? Laravel has a folder for this: resources/assets/
It's northern european.
Youre right that I haven't used CMS recently, but nothing has really changed about their nature - they attempt to be tools that can simplify infinite specific problems, in a very one-size-fits-all kind of way, and that ultimately means abstractions and assumptions are baked very deeply into their architecture and design. I have worked on enough projects involving a pre-built, general purpose CMS that I know the pain and drag they put on your productivity. I've seen projects blow waaaaaay past their budget because of those CMSes, when they could have been delivered under budget with a proper framework. I'm sure a guru who has invested their life into a particular CMS can really push that CMS into territory it probably doesn't belong, but as a developer, I find more value and safety in learning lower-level tools and general programming - not which modules/plugins can be bent far enough to solve which problems.
For about two hours of developer time, you get something with almost zero configuration required and no ongoing maintenance? Businesses will pay that without a second thought, assuming it does actually get the job done well. 
That's right, my compiled js via webpack goes in public, but where are the source files suposed to be ok in?
&gt; Businesses will pay that without a second thought. No, they won't. Source: owns business.
&gt; source files If I had to guess where source files would go... Sorry, shouldn't be shitty -- I think you have the option to put them under `/src` but there is nothing in the spec that says you cannot make your own root level `/resources` dir.
Regardless of drama, I really wish something like this existed when I first learned PHP. The lack of standards made things more difficult than it should have been.
Some absolutely garbage comments here from people who fail to consider that there are business profiles different than their own. Perhaps if the features and/or pricing aren't right for your needs, state your use case or desired price point (like /u/bowersbros [has done](https://www.reddit.com/r/PHP/comments/5iif84/private_packagist/db8fwrb/)) as a suggestion to /u/Seldaek and move on. 
It is a shame someone would revoke art due to peer pressure.
This is the kind of thing I like to read and is the ideal I aspire to. Unfortunately though this how a conversation with either the boss or the client will go: Client: "Hi, we want a website that we can update ourselves and a simple blog. We need to integrate with our XYZ system too" Us: "That's great, we'd love to help. It'll probably be around 15 days for us to build something like that" Client: "15 days?! Oh crumbs no we don't have that budget, we have been shopping around and another company said they could get it done in 4 days but we liked your ideas better" Us: "Okay fine. We'll just build it in WordPress instead and write a plugin" My first reaction is turn the work away and I sometimes do if I feel like it's more trouble than it's worth. I do get challenged as to why I'm actively turning away paying customers though. "If they want WordPress, give them WordPress".
&gt; The most time consuming part was getting our heads around the client's diabolical Salesforce data knot After working on a project that needed to use Salesforce's API, I will try to avoid any project ever again that uses it. There should be a premium attached to having to work with that monstrosity of an API
The North is in the centre. Czechmate.
Quick question, Where is the service level agreement? 
I don't get the salt in this thread: it's monetization of a project which pretty much put PHP back on the map. I'm guessing this will in some way pay for open source part of Composer and Packagist.org which is awesome. Good luck guys, hope it works out.
Should I really spend more than 2X the monthly cost of the IDE I develop my packages with just for a proxy to those same packages? Particularly when free tools exist that can achieve the same thing? When utilities cost more than a dedicated server or far more integral software to my business I am going to seriously question their value.
It just came out, so let's not judge too quickly. It's not rare for a service to launch with plans a bit overpriced, it helps to get good customers to refine the product without having too many customers. If they are confident in their product and want to target a larger audience, they'll either lower the prices later or they may plan more features which would justify that price. Anyway really happy to see that service launched, it's more than welcomed and it's great of the Composer team can find some way to get money for their work. 
cool concept, but our vanilla satis instance gives us everything we need.
For all the detractors here, I'm curious what they think about pricing of Toran, assuming they are part of an 8-dev company? I don't recall so much acrimony around it.
Same as most of the other people here: Looks pretty cool, but it's *way* to expensive. Our product consists of many packages (30+) and we could definately use this, but at â‚¬ 50 per month we'll just stick to Satis. I think we'd pay for it at like â‚¬ 5 or maybe 10 if it's *really* awesome.
&gt; It has layers upon layers of abstraction and assumptions which invariably get in the way of building the specific thing you want to build Can you go a bit more into detail about this? Any examples? From my experience, certainly with Drupal, it really does quite the opposite. It assumes almost nothing and provides some basic building blocks, but you're on your own beyond that. In fact, it appears to be something of a common complaint against Drupal in as far as it doesn't actually do or assume anything. Many people new to Drupal expect Wordpress but get little more than a shell of a blog because Drupal assumes pretty much nothing about your project. Genuinely interested in your perspective. Cheers 
https://www.jetbrains.com/phpstorm/buy/#edition=commercial
Right. And how do I justify an increase in my package delivery costs from about $10/month, to over $300/month with this kind of pricing? I can colo two more VM hosts for that price.
If I add all my devs (including part-timers) to this user pricing model I'm looking at a roughly 30x cost increase.
Is this from the same author or composer/packagist.org?
&gt; (and had zero dependencies to external libraries neither for the frontend nor the backend). It used markdown Did you write your own markdown parser?
Yes, see https://packagist.com/about/
How many developers are working on your product? Give the tool a try for free to see if it would help and send us an email at contact@packagist.com with details about how many you are and what you'd be using it for :-)
How many developers are working at your company? Have you considered how much the developer salaries for time you end up spending on maintaining an alternative solution yourself would be? Give it a try for free and email us if you think you can't afford it, but we do believe it's worth its price.
trust this man's opinion.
You have to know the context in which this post was writen. I am a developer at a company that provides online solutions for clients. We don't have the luxury of spending 3 years writing an awesome CMS that could compete with other available CMS's. Hence the title of not even bothering to write your own and looking into other CMS that are available
thanks. I just added the tag. 
As you grow your business you should fully expect to turn away work, and in time will likely turn away more and more work. You should specialize and not try to be all things to all people. You can't possibly out compete a specialty shop on their specialty because you haven't built the tools and strategy to be as efficient at it. However, please realize that this should be the companies discretion and not your own personal agenda. You should also encourage partnerships with companies that specialize in things that compliment your knowledge. It's a good way to be both flexible and cheaper. Lastly, always be evaluating the market for what you specialize in, you will have to evolve your specialty. 
Cool but I could never justify that expense to my employer. I appreciate it's a new service and so they're still figuring out their pricing, but â‚¬199 *a month* for a team of our size to not have to include private repository links and a keypair is beyond explainable
Since you're trying to monetize Composer one thing that ya'll could do is what this guy tried to do: https://www.reddit.com/r/PHP/comments/4jqm00/packagestudio_an_online_marketplace_for_composer/ eg. make it so people can sell packages through Composer / Packagist and ya'll can get a cut of the profits. It doesn't look like there are any packages on the website in the /r/php link but maybe if the actual people behind Packagist developed the idea instead of Joe Schmoe it might gain more traction!
The only part I disagree with is charging a premium for bespoke works. You should charge a client as much as you can regardless of if you are copy-pasting or building the next big thing. Even if you have boilerplate, you came up with it. That took time, as will maintaining it. 
i hear ya. for my team we have maybe 4 php developers and we don't currently use any private packages but we could in the future. It is of course time/labor expensive to provision and maintain an alternative solution and I would love to see something like this for smaller teams maybe with slightly less features for a lower price.
Drupal's Paragraphs module pretty much does this and is quite popular.
It's an interesting point, but I've never seen a single project or contract I didn't think was worth more than tender amount; even with larger bids, so I avoid public tenders (although the ones my business can participate are all &lt; $1 million value per annum). TBF it's not just financial, it's also the risk of being saddled with someone I'm not happy with for an extended period; the fixed cost (but not requirement) nature of tenders too is a concern. I Often rail on governments and megacorps for failures despite being aware most of their problems are process problems that make it hard if not virtually impossible for them to ever get a good deal and then pass on the value of that deal. On not paying for boilerplate as a decision, I believe and have experienced that any time anyone decides not to pay for the boilerplate, they are just building up a debt, either financial or technical (likely both), for a bit of vanity (750k is ~7 people's pay + business costs for a year or less) I'm not sure it's worth it. Happy to have my mind changed if you have time and a compelling counter, but please don't neg rates or suggest we should be willing to work for &lt; $100k pro-rata.
No, I don't have a counter. I think everything you said makes perfect sense. Every company operates different which effects how you estimate, bid and the measures you take to protect yourself. In our case we don't do fixed bids at all. Hourly work is the great motivator of all. We are motivated to come in at/under budget to keep our client happy, our client is motivated to work through process problems and keep the ball rolling.
I'm from Argentina and I use Slim for freelance web apps (invoice, inventory, etc). For me, it's easy and it just work. Am I crazy? Maybe.
If your current server costs are $10/month, this is not targeted at you. It's for companies (with many employees), not freelancers and "web design guys". My previous employer spent easily five figures a month (I wouldn't surprised if it's six now) on servers. They'd drop this amount in the blink of an eye for how much developer time it could free up.
All of the focus in the thread here is about pricing, but I'm curious about the security. The code example on the homepage says that integrating to your current project is as simple as adding `{"type": "composer", "url": "https://repo.packagist.com/org/"},` to composer.json (simple, yay!) What's happening behind the scenes to stop me from adding `{"type": "composer", "url": "https://repo.packagist.com/someotherorg/"},` and stealing their code?
Probably a separate repo that you include as a dependency or submodule, if not just deploy it completely independently. But if you don't want to do that, I'd suggest `src/js` or similar.
Based on looking at similar tools and services, it's much more about being able to deploy your code even if GitHub is down.
Yes, see https://packagist.com/about/
To the authors: congrats on releasing and don't listen to the people saying your price is too high. That price is basically free to any business of moderate size.
I agree completely. I have a team of 5 developers (self included) and we maintain a fair number of public and private repos. We currently use the manual hookup for private package integration. We loved when we found this new private solution, but were immediately discouraged by the monthly cost. I wouldn't be mad about $15-20 per month, but the cost for our intermediate team size is just crazy... We're going to stick with the manual method for now, but we will surely keep an eye out for price drops.
I'm also from the Netherlands and a bit curious. Which platforms are you talking about if you don't mind me asking? I know Ticketswap was hiring a while back, but I haven't heard about any other large Symfony projects over here (or maybe Beslist's new shopping cart?).
This is the argument we've been trying to make at work for almost a year and no one is listening. We're getting Drupal rammed down our throats and it just... hurts. I love Laravel so much, and trying to do anything remotely productive in Drupal just takes so damned long, and it ends up feeling awful knowing I could have spent 1/5 of our budget on a purpose built cms. 
Wow, you must not read very well. My current server cost for dependency package delivery is $10/month, but the rest of my server costs are not even in the same stratosphere (I fucking wish they were.)
Couple of notes: - I think the default syntax coloring is "semantic", this is more of a "depth coloring" or "scope coloring". - Scope coloring is interesting, but it only works when it's *not* mixed with the usual syntax coloring. Otherwise it seems like it becomes messy.
I checked it out. It's definitely a step up from the default approach. Unfortunately it stops at blocks, i.e. paragraphs. You can't insert custom components in a similar way inline in the content, and also the structure is not hierarchical, paragraphs can't be nested within one another, in order to define more complex structures. Of course I realize if what I'm talking about was realized naively, it'd be hard for users to figure out.
Does it have a way to persist and load a complete graph? That'd be a very useful function for apps.
I had to import products/categories from multiple third-party APIs. The processing of the data required so many steps I had to create a class for each third-party channel. I don't know if Porter would have made things easier, but importing data is often more complex than a 10-line foreach snippet.
Your point being?
When I say a 10 line snippet, I am not referring to data source parsing logic which this product wouldn't help you with.
Apparently, I don't know what this framework is for. Can you ELI5?
except satis already does that and costs nothing other than hosting costs (so for most people, a $5/mo DO box)
Haha, yes, I did. And it was bad. It was for learning purposes only. Hey kids: don't do that ðŸ˜‚
At first glance it looks pretty messy. But I'm going to try it for a day! (I use [Power Mode II](https://plugins.jetbrains.com/plugin/8251) so I'm used to the mess)
https://laracasts.com/series/php-for-beginners This is a good one on Laracasts. Not sure if it is free though
&gt; Take the iOS AppStore for example. The problem is that the AppStore has zero quality. Every single thing ever produced there is some trivial bland crap in terms of business or creativity. I've bought apps from there from reputable vendors that were PoS apps and had nothing beyond superficial entertainment value. The really hard thing is encouraging people to fail on your outlet because it kills them and your outlet, but more dangerous is not letting them fail or try because nothing can grow on impenetrable concrete. Envato is really the worst example of a walled garden store as they encourage purposeless plugins but have a similar model to AppStore. "Look this new plugin has 25 features you never asked for, but your client is going to enable anyway because.... they just don't know any better." The real solution is to limit how many things a plugin can officially do and provide tags and categories for plugins so that site-owners and admins have atomic control over all the things. To give some recent examples I've taken to using hooks to augment client plugins in plugins of their own. It means at worst case the functionality they "have to have" for the next {n} months can be switched off, we can still upgrade the plugins, enabling security to trickle in. The other facet I think everyone is ignoring is that security in general is horrendous and that it's a good thing we know we are not secure. With this knowledge we can focus on remitting said problems in making our infra HA, in providing a good backup strategy that works below layer of WP and above layer of OS. This week I put in a tiny shell script to all hosts I manage that lets me know who logged in and from what IP (including me and any agents representing me). I can use that to trigger a server reboot. I Can use that to say oh cluster 3 had a node fail so we deleted the node and used ansible to setup a new one. The real power is not in securing the plugins but altering your systems so that a failed plugin doesn't pull it all down. Of course in all this back-patting of self there are probably a few million issues I've yet to solve...
* Porter will provide structure (a place for you to put your parsing logic) but it won't write any parsing logic for you. * Porter can help you transform all third party sources into a consistent first-party format (with help from [Mapper](https://github.com/ScriptFUSION/Mapper)). * Porter can help you merge linked data sets (where one set references another, even if it has to be imported separately) using sub-imports.
PHP The Right Way and Laracasts are usually the default recommendation in this type of thread, but I'd like to take the opportunity to shamelessly plug my book, [Jump Start PHP Environment](https://www.sitepoint.com/premium/books/jump-start-php-environment), which deals with the "before PHP" stage. It focuses on how to develop in virtualized, isolated environments, achieving a near identical setup for both your development and production (something very handy when it's time to deploy, or when you work in teams). It's basically a super-extended and up to date version of [this post](https://www.sitepoint.com/re-introducing-vagrant-right-way-start-php/). Allegedly, it's easy to go through and the knowledge sticks with you because it's hands-on - I did my best to include real-world examples, and the book goes through both a local dev setup and a deployment procedure. It's very newbie friendly (explains the basics of internet responses and requests, too, because it ties into it all), so if you're past that point it's probably not for you. Here's a [sample chapter](https://www.sitepoint.com/php-application-environment/) to see if you like the style. --- Additionally, if you have experience with old-school PHP, I can't praise a book better than [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp) by /u/pmjones. It's a fantastic step-by-step introduction into the modern PHP world (autoloading, testing, OOP) applied to an old and decrepit spaghetti app. Covers each area well before moving on.
I started to use it and after while its very cool. 
I'm reposting the link to externals.io to let you know that search has been added. Please keep in mind that only the discussions that have happened since that website is online are indexed. I'm looking for a way to crawl and index all messages since forever (by using NNTP), if you want to help pop in the repository on Github :) Feedback is welcome!
:\^)
&gt; ya'll 
One thing you'll probably have the hardest time researching is directory structure. I don't think any modern article or book properly covers this topic at all. Closest thing you'll get is how [symfony does it](http://symfony.com/doc/current/quick_tour/the_architecture.html), but I'm not sure if copying symfony when not using symfony is always the correct way to do things. Especially since most people don't properly write bundles correctly when you go to research on symfony bundle examples eg.: &gt; a bundle is meant to be something that can be reused as a stand-alone piece of software. If UserBundle cannot be used "as is" in other Symfony apps, then it shouldn't be its own bundle. **Moreover, if InvoiceBundle depends on ProductBundle, then there's no advantage to having two separate bundles.**
I use Symfony, Laravel and Slim for my personal projects but in the office, we use *-drums please-* a hybrid codeigniter version from 2009 + wordpress alike anonymous functions.php + and another fucking codeigniter from 2009 for frontend (they weren't know how to handle both admin and frontend with one framework). Here's the result: https://www.reddit.com/r/shittyprogramming/comments/4ik5yd/we_can_look_at_error_lo_oh/
Rather than `die'ing` it is a lot better to use an early return. Which is the standard name for solving this problem. http://blog.timoxley.com/post/47041269194/avoid-else-return-early In fact, some people recommend just almost never using an else keyword. http://williamdurand.fr/2013/06/03/object-calisthenics/#dont-use-the-else-keyword 
We had to build this exactly for Magento Marketplace. Would much rather Jordi &amp; Nils built it! 
http://www.phpthewrongway.com/ ;)
[Return early](https://pear.php.net/manual/en/standards.bestpractices.php#standards.bestpractices.returnearly) is the standard name for syntax readability while [fail fast](http://www.practical-programming.org/ppl/docs/articles/fail_fast_principle/fail_fast_principle.html) is the programming principle name e.g. that fits with login/password transactions. In other terms, you may return early but not necessarily while failing fast. [edit] also I used `die`statement to avoid adding an extra nesting context to my code example :-)
Your reply: Composer support is just a little JSON file and a registration in Packagist. Thats support for packagist, support for composer means you have composer.json and are using psr or something relevant to build up autoload files. + it also means you are able to easily install new packages from packagist or what ever it has nothing to do with registration in packagist
JetBrains feels the Christmas spirit and wanted to create a Christmas tree, how sweet!
&gt; Your reply: &gt; Composer support is just a little **JSON file** and a registration in Packagist. &gt; Thats support for packagist, support for composer means you have **composer.json**... Now spend a few seconds thinking about it. Which **JSON file** might I have been talking about? Hmm. &gt; ...and are using psr or something relevant to build up autoload files. [You don't need to follow PSR to autoload with Composer.](https://getcomposer.org/doc/04-schema.md#classmap) &gt; it also means you are able to easily install new **packages from packagist** or what ever &gt; it has nothing to do with **registration in packagist** You have to be messing with me... Do you have some sort of short term memory loss where by the end of a sentence you forget how you started it? 
[Don't skip the braces](http://embeddedgurus.com/barr-code/2014/03/apples-gotofail-ssl-security-bug-was-easily-preventable/) And please don't use `die` for this.
&gt; In fact, some people recommend just almost never using an else keyword. Every time someone comes up with a good idea, the zealots are not far behind...
A routine promotional cloudways post without any actual value. "Key" features for different frameworks are picked up at random and could be shared by any other framework as well.
&gt; implementation can be very similar So similar that there are no differences at all; they're both "containers." And if you use a container, even Auryn, from inside another object, to "make" a dependency, you are using it as a Service Locator.
"cant go with big houses" sounds a bit unbacked a statement. Other requirements also sound quite random (why RHEL *and* Centos? why Composer "of course" goes with PHP, but not with a framework? So is it "PostGres or MariaDB" finally?) Either way, for me to choose between Postgres and Mysql is way bigger a dilemma than between Slim or whatever Hazaar (anyone have an idea what the hell is this?). From all of above I could tell that your "problem of choice", just like any other such problem, is actually taken out of nowhere and the answer could be anything. And your actual problem is that you just have no idea what are you doing but want to do as less as possible.
&gt; WTF Hazaar is? Nevermind, got it: http://prntscr.com/dk6wpk
Don't try to be a smart-ass then. Go for Laravel. Surely you don't want to fuck with installing Phalcon (do you have an idea what its main feature is?) or hassle with unknown Hazaar. While Slim is surely insufficient for your needs.
I also recommend Josh Lockhart's Modern PHP. He's the PHP The Right Way guy and he's super dreamy.
&gt; I think we'd pay for it at like â‚¬ 5 or maybe 10 if it's really awesome. What do you expect for 5â‚¬? You want the hosting, bandwidth, server maintenance. I guess you want rapid support and high availability. Do you think 5â‚¬ are enough for that? How much do you pay for hosting Satis on our own? How much time can you invest into your Satis instance for 5â‚¬ per month?
**Shameless sell promotion here** but I'm the Editor for php[architect] magazine, &lt;https://www.phparch.com&gt;. I think we're a good source for seeing modern PHP techniques. I try to curate 4 features each month that we review for technical accuracy (and grammar and just "makes sense") before publishing. We also have columnists like @enygma writing about security and @calevans about community. Each issue has a free sample article to check out and review. Hit the link above to learn more. If you're getting back into PHP, a good, free article to read is this one about storing passwords correctly: &lt;https://www.phparch.com/magazine/2016-2/january/&gt;
No. 
Nice.
Semver much?
Shouldn't it be Laravel 6 then? Or does Laravel not use semantic versioning maybe?
 if (!isset ($_POST['register'])) return; if ($_POST['password]] != $_post['passwordconfirm]) return; if (strlen($_post['password]) == 0 || strlen ($_post['username']) == 0) return; ...
`public $birthDate = new DateTime();` Hmm. 
Why are you doing this on your companies time? It's not there duty to allow you to mess with tools that you know aren't right for the job. Pick the right tool (ie. Drupal since you're replacing sharepoint), and don't waste your companies money and assets on selfishness.
Bumping dependency versions is not a semver violation. Summoning /u/ocramius.
I would immediately start using this if it had a JSON serializer
he is going to want to hire someone who has already done it. otherwise he is just wasting both time and money
Your statement is true, a dependency version increase is not a semver violation in and of itself. However, because PHP7 is _required_ does that not mean code in Laravel 5.5 explicitly depends on new features in PHP7 and will not work on PHP5? &gt; MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards-compatible manner, and PATCH version when you make backwards-compatible bug fixes. This is kind of fuzzy because I am assuming the "API" is not changed but the code required to run that same API now will break due to relying on new PHP7 features
&gt; My point was, couldn't Bluehost move me seamlessly to a higher bandwidth plan, No. that is not how their infrastructure works. &gt; Is it even possible to have a world class app on something like BlueHost? No it is not. Here's a top 3 reasons why, I found in about 3 minutes. Let's take a look at BlueHost's infrastructure. The company operates its servers in-house in a 50,000 square feet (4,600 m2) facility in Provo, Utah, which is now shared with sister company HostMonster. Problem 1. BlueHost is not globe Problem 2. BlueHost does not have backup data centers. Problem 3. BlueHost shares it's space with another company. Big Applications span the global. Big Applications have resiliency across multiple data-centers. Big applications do not share space, they own space. 
&gt; What is the reason behind the Symfony being the framework of frameworks prediction? It's very powerful and fast, while also having loads of freedom. Everything is very decoupled to the point that you can pick and choose which features you want to use. There are no complicated rules or limitations to follow. The Symfony team is also very diligent with non-breaking updates and long-term support. That makes Symfony a great choice for enterprisey stuff. &gt; It benefited the least by the speed improvements according to that infographic. It was already very fast and well-written.
Summoning successful: you are correct, but I'm too drunk to provide useful insights.
The version market shares are a bit misleading. It only applies to PHP projects which use both Composer *and* Packagist (i.e doesn't count Satis installations behind firewalls). The vast majority of PHP out there is Wordpress which doesn't use Composer and there is also huge amount of enterprise code which won't switch to PHP7 ever. I personally know *active projects* being developed with 5.2. 
You probably want to handle each failure differently. Like if password !== passwordconfirm errorMsg 'passwords don't match fuckface'. There's no reason to keep nesting the checks. You can do an if wrong, else if wrong2 else if wrong3 else if wrong4. I mean it's a signup form, it's likely you'll add debugging / extra code / tracking so a big if else if isn't the end of the world. If it gets thru your 7 if checks and lands at the else you're good. It's easy to follow. Easy to update and maintain. Signup form validation / processing shouldn't be spread out or broken up. You're getting important info, you're validating and handling it right here. You should be more worrying about doing it properly, not making it look pretty. Just from the code you posted, you probably aren't even doing it properly so making it look pretty for someone else down the road is the least of your worries. 