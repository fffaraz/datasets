It's almost a certainty I wrote some code like that in my first project at my first dev job..
I agree with you, but I can do this is any language that supports IF statements. 
Quick, what's your favorite part of this code? Is it: * The mashed up PHP, HTML, and SQL in a single massive file? * The completely raw incoming post data being saved directly into the database? * The use of mysql_query() instead of mysqli or pdo? * The giant arrow code if structure? * The lack of opening braces for the else statements? * The md5(md5('pepper'.$password.'salt')) password hashing strategy? I don't know what to choose from. They're all so amazing. 
It's not my fault that what you're saying now doesn't line up with what you wrote originally, that you're repeatedly contradicting yourself, and that you consistently fail to explain what you mean. That tells me that it's probably not so much that my initial interpretation was wrong, but that all of this is just a bunch of back-pedalling. But hey, if you're going to snap at me for asking you to clarify what you supposedly meant after telling me that my interpretation is wrong, I'm so done with this thread.
The lack of semicolons, which caused his actual errors, would be helped if he used Python at least.
Why? Why would you ever change such a beautiful, natural thing? You're sick.
Or hold the original author at gunpoint, and force them to refactor it. And if they make any wrong movements, shout at them the correct way to do it, including reasons why and the general proper thought process behind it.
Nearly every beginner programming class I take (yes I've taken more than one; first class of several different languages) teaches you 'if' statements before functions, and the result is that everyone is forced to do things like this the wrong way, and then we're taught the right way. I find that HORRIBLE. People should be taught the right way from the start.
I had the same problem back when I started. I didn't use that tutorial, and I haven't looked at it, but for me it was a security problem. There were protected words in the username (and would probably be the same in the password). For example, I had 'house' as someone's username, and that contains USE, which is a protected word. I had to work with the DBA for my hosting company and they patched it right up.
Because it didn't need clarification. Because what you wrote in the article doesn't match what you're saying here. How about you go read your own damn article, then continue to read your responses here and try to line them up. I'm done. Bye.
It's REALLY strange how in academia, practice is so firmly separated from principle. Imagine an engineer with no applied math courses of any kind, completely unable to use tools of the trade to actually solve a problem.
At least as far as web development goes, the absolute best articles and tutorials (for HTML/CSS) I've ever read were from [HTML Dog](http://www.htmldog.com/). This guy goes through and teaches HTML and CSS from the bottom up, starting with and sticking to only best practices, explaining why they are best practices as well. I've not really gone through it, but I believe that [PHP: The Right Way](http://www.phptherightway.com/) does the same thing.
This shit is evil. 
What? Your hosting company somehow had implemented global safe words on everything, such as variable values and database values? Change host asap. 
IIRC usually internal service errors correspond with some sort of syntax error. You can check your webserver's error logs or turn on error logging. Maybe try adding error_reporting(E_ALL); in your script
Well you choose the right username. Dude, this is a 16(!) year old guy talking about OOP. Ofcourse he isn't at graduated CS level, but don't be so fucking negative without any fundation!
The whole tutorial looks ancient. It doesn't use `mysqli`, `session_register()` doesn't even EXIST anymore. While I appreciate the idea of having something that a beginner can follow along and build something that opens in a browser, if OP goes through with this they'll have to unlearn 90% of it. Sadly, it looks like there's not much in the way of modern newbie tutorials that I can find, stuff like [phptherightway.com](http://www.phptherightway.com/) is excellent as a reference for those of us who know PHP but it doesn't have or appear to link to anything for people starting from scratch.
Some hosting companies have anti spam software installed; I had to contact tech support once for the host of a client once, because the word "casino" in their content triggered an anti-spam program that served up some kind of error page. Of course, the USE thing is not the same thing, and I agree, /u/alectronic should switch hosts because that is a bad sign! *edit: I accidentally two switched words*
This. Error reporting should be on always during development so you know what went wrong. Don't forget to disable error reporting afterward, though
I host on Surpass, and so far they've always been awesome. They claimed it had been an automatic thing because another person on my shared server had spam issues or whatnot. I've never had the problem before then and haven't seen it since. Normally though, I would agree with you.
I wonder why you got downvoted Phil X_x
First you need to create a html form. And on submitting you want to validate and sanitize the form data. Something like [Aura.Filter](http://github.com/auraphp/Aura.Filter) Once all is passed you can connect to the sql, and insert the data via [Aura.Sql](http://github.com/auraphp/Aura.Sql) or something similar. ( Aura.Sql is extended PDO or you can use Doctrine )
As someone who has been on both sides of such interviews on many occasions, I can tell you that oftimes the coding questions are not intended to place you on a skill spectrum; rather the interviewer is simply establishing that you meet their minimum competence threshold. This is especially true in the "softer" programming technologies such as PHP. If you do make that cut, the deciding factor is how friendly and communicative you seem to be. If people have to spend all day with someone, they are very motivated to select a person they feel they'll get along with. In short, being "extra right" can be detrimental in an interview, as it can translate into arrogance and/or muddled communication. 
You come across a little arrogant in the post, maybe you do in interviews too? I've always find in interviews it's personality that more often than not that gets you the job. Skills can be taught, so employers choose the best fit for the company. Have you ever asked for feedback after a rejection? That might point you in the right direction.
with our team, we've since stopped hiring based on language-specific competency. we still see on a more general level how familiar they are with common concepts, as well as in architecting apps (handling high traffic, caching concepts), but we focus more on team compatibility and attitude. because frankly speaking, implementations of algorithms (established and ongoing research) is not really what everyone's using PHP for. all those things, companies have people implementing them in C/C++ or Java. PHP is the glue, and everything you need to know to use PHP effectively (or probably any other language), google can help you teach yourself.
Because every job is completely different, making it nearly impossible to interview, because each job makes you completely unprepared for the next one.
&gt; I'm getting to the age where should be deciding No you shouldn't. Up until 24 years you brain is still adapting and quite keen on absorbing extra material. Due continue programming, but try a few other domains on the sideline, and only then decide on your career. Want to do NLP, study pragmatics on the sideline and parsing. Want to do AI, study neuroscience on the sideline and bayesian statistics. There are many other fields that are missing programmers; and bridging such gaps will only benefit the world as a whole. "Next gen" applications and tools. If you think you have a good grasp with OOP, I'd usually ask in an interview; have you tried other OO languages? There are many "flavours" of OOP, and implementations have varying benefits that others may not have. Freelance maybe for a while on small project so you understand why developing communication skills are important, and contribute to open source software so you learn to detach yourself from the code you write and accept critical feedback. The entire comment isn't about answering your question, but rather about not attaching yourself to a single role/position at this point. And for your early passion in programming +/u/dogetipbot 50 doge
What no for loops?? comeon guys! for( $i = 0; $i &lt; count( $keys = array_keys( $x ) ); $i ++ ){ $x[ $keys[ $i ] ]++; }
my first thought too, someone with a good set of [soft skills](http://en.wikipedia.org/wiki/Big_Five_personality_traits) but mediocre professional skils will get the job over someone with good pro skills but a weak personality. not saying op is lacking those but this is definitely something to consider 
we arent spoiled, you are just old and nostalgic... Why should we learn outdated stuff?
I honestly think it is nothing to do with your PHP skills. I have been doing 'low-key' development, (eg hacking bits of wordpress), for a long time, had many interviews, run my own business etc. I have never discussed programming patterns in an interview. TBH I have no idea what half the stuff you discussed does. However I think I have only been turned down from 1 job in about 15 years. You have to focus much more on how you come across socially. What would happen if you were put in front of the clients, could you have a friendly chat and explain the pros/cons of different approaches to THEIR problem. William 
I didn't mean to imply you were wrong. I still don't really know what that means. My programming experience is limited to text manipulation with perl, and some system automation stuff with python/bash. I'm trying to broaden my horizons with some web stuff, really just trying to conceptualize all these new terms.
Looks useful! Also, if those who downvoted this could explain themselves a little bit, that would'd be great.
I've done a lot of interviews, on both sides of the table. If you'd like to do a mock interview via Skype I'd be happy to give you some feedback. 
"The library supports the magic methods __sleep() and __wakeup()." and "The library handles code recursion." I certainly like that. Bookmarking to see if it handles binary data well. Otherwise, this is a neat little tool to remember.
I'm currently taking a look at http://processwire.com/
From the OP, your programming skills look pretty high-end for a run-of-the-mill PHP position. Could it be that you give off the impression of being overqualified? You talk mostly about hardcore programming, but are you up to date on the current PHP landscape? Most of the times it would be a plus to refer to web technologies (a bit of HTML, CSS). Have you put some of your personal projects on GitHub? I always like that.
so we all agree its not your skill, maybe you should jump over your shadow and ask for some feedback of someone who actually interviewed you? i know might be awkward, but its worth it if they are willing to answer honestly. 
Yeah, so the way we work is: * 1) Write BDD style tests (we get the business analysts to write the feature files, which is great for speccing out requirements and communication between the business and the developers) * 2) Use TDD behind the scenes so we know all our backend code is working. * 3) Refactor our backend code when we get green unit tests * 4) Keep repeating the process until the BDD style tests pass Best of both worlds.
I can't understand why some replies in this thread tell you that you sound arrogant. Your post sounds OK. I think it's about presentation or something. You can try applying for remote jobs so that you don't have to worry about presenting yourself. Depending on the employer, the code often speaks for itself.
His tl;dr sums up his arrogance. He thinks the reason he's not getting the jobs is because of the interviewers and not himself.
If you're interviewing at places that care about FizzBuzz and patterns, it sounds like you've found the right companies. As long as you're pricing yourself appropriately, it's going to come down to soft skills. I'd highly recommend checking out *Being Geek* or the Manager Tools podcasts on interviewing. Heck, it might even be time to bust out *How To Win Friends and Influence People*. As someone who's done a ton of interviewing and hiring, I know exactly what I want and the code part of the interview is only a "you must be this tall to ride" type of check. Fit is much more important and, to me, that means you're a craftsman and not just a hacker. You also have to be someone I'd be comfortable putting in front of my peers without having to worry you'll say something like "this is an ID-10-T error!"
OP - if you don't take up this offer, I'll be **personally** around to box your lugs. And if anything comes out of it hat you are happy to share, please do so, and we can all learn.
It's possible that you are too senior for these positions. A lot of interviewers are themselves the managers or the existing senior devs, and sometimes they get nervous about hiring someone who's not afraid of correcting them.
You don't know me.
I agree
I once had a multiple choice exam at an interview. One of the questions, the grammar was so bad that none of the answers were technically correct. But I thought I could see what they intended, so I corrected the grammar on one answer and ticked it. I was turned down for being over qualified. :-)
Definitely this. Coders often have a reputation for being arrogant and overly verbose. In any company, the most important factor of each and every candidate, is communication. If you can't communicate with other people without round-about insulting their intelligence, huffing to yourself in a manner which reads as "God! why doesn't everybody understand what I understand? everyone's a moron!", then you'll get nowhere. Management are more often than anything, looking for cohesion. Somebody who's flexible and can have a friendly conversation not only with clients, but with co-workers. Somebody who can explain a technical problem in a simple and non-patronising manner, and somebody who manages conflict for themselves.
It's not arrogance if it's true ;). That is, don't put words in his mouth.
Graduated CS level checking in, still no idea what I'm doing. 
I wanna learn how to put all of my stuff into one project
Kind of like how he's putting words in their mouths.
Haha I was surprised no one mentioned grooming yet, maybe OP smells :D
Here's a good place to start getting up to speed on what's been going on. http://www.phptherightway.com/ In terms of books, I don't have any specific references but topics you should read up on are general programming subjects like SOLID and DDD. Once you know those principles, your Google-Fu will kick in and you'll be able to find a lot of info out there. EDIT: One more thing, learn git (or mercurial or some other popular VCS) and composer if you haven't already. Those are kind of prerequisite skills for doing most things with PHP these days.
I didn't downvote, but I was tempted to based on: * JSON is already a serialization format, and so to say that it's a "JSON Serializer" is confusing (and redundant) at best. * JSON is a data exchange format, intended to pass _portable_ data over the wire, and any other API that understands JSON should be able to consume it without issue or special handling. If you generate JSON with the given technique, it's only going to be useful if you have the backing PHP classes to reconstitute it. That makes it non-portable. * Why would you want to serialize PHP domain objects as JSON? It's going to be less efficient than the [alternatives](https://github.com/igbinary/igbinary), and you won't be able to leverage the added functionality anywhere else (JS, C#, etc.) except your special PHP environment.
Judging people based on first impressions is how the world works. http://www.youtube.com/watch?v=0iyeUcFKRv4
... and those are all valid points! I just wanted to hear some explanations :)
Where are you located? We're looking for a PHP candidate for a QA engineer position.
Would be nice if this post, or the blog post, actually explained what the failed php code was intended to do. Some kind of quickbooks API or something?
[Here you go](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1). This will benefit you if you want: *To learn more about the low level architecture of modern web frameworks in general and about the Symfony2 full-stack framework internals in particular; *To create a framework tailored to your very specific needs (just be sure first that your needs are really specific); *To experiment creating a framework for fun (in a learn-and-throw-away approach); *To refactor an old/existing application that needs a good dose of recent web development best practices; *To prove the world that you can actually create a framework on your own (... but with little effort). --This list is taken directly from the first article of the set
I agree - breadth is more important than depth when I’m interviewing. You don’t know PHP but have done some C, Ruby on Rails, and learned Smalltalk in school? I much prefer you to the guy who has only done PHP and nothing else since he hacked his first web site from scratch eight years ago. Biggest warning sign I know is when people identify too strongly with a single language/technology — or — when you ask them what’s wrong with their favorite tool they can’t come up with anything sensible. Nothing is perfect - everything has flaws. If you have some perspective, you know what they are.
It will not remember... $get_row is only in scope in the navcategories() function but you COULD pass it in like this: navsubcategories($get_row); Then... function navsubcategories($parentRow) { ... echo '&lt;li&gt;&lt;a href="jewellery2.php?category=' .$parentRow['category_id'] ...... ... }
You should have your category and subcategory database tables linked. This only applies if your system is setup such that each category has unique subcategories only related to that category. So in your subcategory database table, you would also have a column to store the category_id of the related category for each subcategory. Pass the category_id to your navsubcategories() function call on line 8 of the code you posted: navsubcategories($get_row['category_id']); Change function navsubcategories() to function navsubcategories($categoryID) and change your database query on line 18 to: "SELECT * FROM subcategory WHERE category_id = '$categoryID' Now when you call your navcategories() it will display category and then subcategories linked by category_id. Hope that helps.
Sorry to hear that your startup failed. I did some integration with Foxycart, Sugarcrm and quickbooks way back. it would 've been easy if we had the quickbooks api back then. {PS: i dont work there now :-) }
&gt;MajorApi was a service that made it very easy to connect to QuickBooks. It created a REST API between the QuickBooks WebConnector application and QuickBooks Desktop. Unfortunately, the service failed to take off, so we shut it down after a year of use and open sourced the code.o *https://github.com/brightmarch/major-api*
a really good way to get into it again is to have the need to do it again. start a side project, try to clone something, accept a small project. this will really drive you and give you context to what are the things that you need to know (ie, user registration, authentication, add/remove records, etc). the key is identifying the things you need to learn through purpose/necessity.
Seriously. Maybe the guy didn't even own a car and borrowed his parents to get to a job interview.
Programmers do not need to only be able to speak to computers, they need to be able to speak to humans too. In fact, interpersonal communication skills might be more important than coding skills. If I were you I would focus on coming across as calm, confidant, friendly, approachable and able to explain complicated things in simple terms. 
Learning how to put your stuff into one project should have no baring on a framework. What the most common frameworks provide is a method to use what's been done a million times already. The most basic operation of a framework is a bootstrap and router which is what I'd recommend them for. With an MV* design pattern, all of your code is in the Model layer, the View layer is dependent on what the framework uses for templates, but that's still your stuff. Whatever the * is for the framework (eg C, P, VP) is usually the framework. Some frameworks do more automation and magic than others so it's a choice of flavor; I prefer having a bootstrap and router and use everything else as a library. Now if you're wanting to learn and understand why people push for the use of a framework, then go for it. Take an existing framework and try to reverse engineer how it works, then try to write your own. You'll quickly come to understand how much dirt they sweep away for you that really has nothing to do with your project yet must be done.
Thank you for the gold, whoever it was! Nobody's messaged me yet about taking me up on this, but if any non-OPs are interested too I'm totally willing. 
I think he means something a bit more encompassing. I did some research in Quickbooks integration and know what the WebConnector and Desktop application do, and still your description doesn't clarify what it does. Perhaps a use case, or bit more detail on what it does? Also, unrelated, but I noticed you're using Phing for your build scripts. I've been using Rake for mine, and am curious if you could speak to why you decided to use Phing over other options?
Hello! Before Intuit released their IPP - Intuit Partner Platform - the only way to connect to QuickBooks Desktop was called the WebConnector. To integrate with the WebConnector, you literally had to write your own SOAP server that an instance of QuickBooks Desktop communicated with. To do a basic integration took several hundred hours of time. So, since we did the hard work, we figured if we wrapped a nice REST API on top of it, developers would rejoice. They didn't, and we shut it down. I'll have a complete post-mortem released soon as to why it failed.
I'm sure you'd get a lot of brownie points and reddit karma if you were to record and post this online. Plus you might help a bunch of people either way.
Why would I need to?
It's kind of hard to pin the exact reason, but when I've done interviews for Python or JavaScript positions the results tend to be opposite.
I understand your first basis, but the other two are weak. 1. The output is not a complex JSON object that is "only going to be useful if you have the backing PHP classes to reconstitute" the data. The library merely adds a key `@type` to the resulting JSON for the parent object and children entities; any outside system can read the JSON data with zero additional effort. 2. Your final point links to a binary solution that is certainly not portable, yet claims that the JSON solution can only be used in a special PHP environment; to which I think you've got it backwards.
Overall I generally do my best to fit in, this includes doing things like bringing freshly bake cookies from home. Try to be socially open and befriend others in the office. As far as saying something like "this is an ID-10-T error!" I don't do things like that unless we've established a code review process. I do however do push heavily for a continuous integration process, because it helps prevent people from breaking something that could be a house of cards.
That sucks that your startup didn't work out. Your next idea of business intelligence on top of quickbooks sounds interesting. I find the built in reporting for QB to really suck. Good luck.
I agree with youngsteveo. If you read the article, it explains most of the points that are you complaining about and also give real use cases. About the first point, is json_serialize function in php also confusing and redundant? I don't think so. JSON is not a serialization format, but can be used as serialization format.
It's an awfully specific solution to an awfully specific problem that happens to be directly related to money. They just didn't catch a lucky break. 
I just read some of the IPP REST documentation. It reeks of barely having left the swamp of POX. And their PHP "SDK" is arguably even worse. Sounds like a good next FOSS project :D Anyway, it's at least neat to see I'm not the only one trying to write modern accounting software for the web. Good luck with your next project. 
There's a ton of businesses looking for this solution. Webgility seems to be the only ones running a plug and chug solution and from personal experience I'd never recommend using them. I'm very vague on details like everyone else but I'm guessing they should have released several plugins for major open source ecommerce platforms and charged a subscription. I know of at least one client that would pay 50-100$ a month for this. In fact...
What a dense answer. You can do well in interviews along other candidates who also did well, but ultimately got the job before you.
If you say you get the js/python gigs, maybe you are not as good at PHP as you think. Also, if you think we assume things without additional information, maybe you need to add said additional information. At last, the *Big O Notation* is not useful if it doesn't help to communicate with your team.
 $query = 'SELECT yourtable WHERE yourfruitId IN (' . implode(',', $yourfruit_array) . ')'; You'll want to use sql's "IN" Here's a link from stack overflow that explains it a bit better. http://stackoverflow.com/questions/16320869/select-query-based-on-checkboxes-selected
Coworkers have suggested a nice feature would be to have a flag so as to only highlight other occurrences and not the one you're not
Judging people based on how they present themselves to the world is excessive?
To those interested ... I just added a [new section](https://wiki.php.net/rfc/improved-tls-defaults#stream_wrapper_creep) that's at least as important (to me, anyway) as the others in the RFC. The plan is to initiate a vote on Feb 11 so the changes can sneak in for 5.6 if approved.
Thanks!
Yeah, it wasn't something that was going to be a billion dollar idea, but I wasn't looking to grow something like that.
I don't know of any libraries that do this directly, but if I was building one: You should first [sniff for Open Graph properties](http://ogp.me/), which will be present in many newer sites. Second, look for `&lt;div&gt;`, `&lt;article&gt;`, `&lt;main&gt;` and/or `&lt;section&gt;` tags using your favorite DOM library. You'll almost certainly find one with a content-worthy CSS class name. Images inside of there may be candidates. Third, consider looking into hard-coding selectors for popular sites. Reddit's thumbnail will be `div.link &gt; a.thumbnail &gt; img`. Whatever you do, don't copy what reddit does. Thumbnail picking can be kinda broken, if you hadn't noticed. Instead, do what Facebook does and grab the list of images in the main content and let the user pick, or optionally pick no image. If you're trying to do this automatically, you're gonna have a bad time. 
I've been too busy to learn the insides of Bolt, but I've always been really interested in it.
I wrote that mostly in jest. But yes I am old(er) and nostalgic.
No. There's nothing wrong with a fucking BMW. Who gives a shit what he spends his own fucking money on? What the fuck is the matter with you people. "Oooh, he's not frugal, he must be a douchebag!" Fuck you.
In a word... No (At least not that I know of) I think in this case the comment syntax kind of makes sense since it allows the items returned by the provider to be passed as arguments to the function. 
no, but so what?
I don't have any library recommendations, but you should definately look for Open Graph tags, they are widely adopted. However, there is also **[standards](http://www.whatwg.org/specs/web-apps/current-work/multipage/microdata.html)** in the HTML specification made just for this. [Here's](http://html5doctor.com/microdata/) a little more human-readable article about microdata. Guessing css class names should be your last option. edit: wrong link
http://www.php.net/manual/en/jsonserializable.jsonserialize.php
Did you reset the permissions *after* dropping in the full site? Make sure it's done recursively. Also, this should be posted to /r/phphelp
You might want to take a look at [Gaufrette](https://github.com/KnpLabs/Gaufrette), which is a library that provides a filesystem abstraction layer. It allows you to develop your application without the actual commitment to a CDN or to a local filestystem. This way you could start with setting up your image hosting on the server itself, and migrate it to cloudfront or SW3 whenever necessary. It can be integrated into your Symfony2 application by using the [GaufretteBundle](https://github.com/KnpLabs/KnpGaufretteBundle). If you want to use Imagine and LiipImagineBunle with gaufrette, you should take a look at [this](https://github.com/liip/LiipImagineBundle/blob/master/Resources/doc/data-loader/stream.md). Good luck!
If you have any questions about Bolt, don't hesitate to ask!
Sounds like you've been stuck being interviews by a bunch of twats. What area are you looking for work in?
This section is a good one, it makes it very hard to misunderstand the purposes of this RFC and theoretically impossible to dispute. Good luck.
I call this ... _Work Insurance_!
Question has been deleted, so here it is in all its glory! ------ For some reason I get these errors: **Notice:** Undefined index: rbtn in **/Applications/XAMPP/xamppfiles/htdocs/signup.php** on line 23 **Notice:** Undefined variable: errormsg in **/Applications/XAMPP/xamppfiles/htdocs/signup.php** on line 124 **Notice:** Undefined variable: getuser in **/Applications/XAMPP/xamppfiles/htdocs/signup.php** on line 137 **Notice:** Undefined variable: getemail in **/Applications/XAMPP/xamppfiles/htdocs/signup.php** on line 182 And if I comment all of the stuff from the If statement with the error down to the end of the else with the error it just moves 1 below the first else. Here is my code: &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Podzol Network&lt;/title&gt; &lt;meta name='viewport' content='width=device-width, initial-scale=1.0'&gt; &lt;!-- Bootstrap --&gt; &lt;link href='css/bootstrap.css' rel='stylesheet'&gt; &lt;link href='//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css' rel='stylesheet'&gt; &lt;link rel='stylesheet' href='http://code.jquery.com/ui/1.10.4/themes/smoothness/jquery-ui.css'&gt; &lt;script src='http://code.jquery.com/ui/1.10.4/jquery-ui.js'&gt;&lt;/script&gt; &lt;!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries --&gt; &lt;!-- WARNING: Respond.js doesn't work if you view the page via file:// --&gt; &lt;!--[if lt IE 9]&gt; &lt;script src='https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js'&gt;&lt;/script&gt; &lt;script src='https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js'&gt;&lt;/script&gt; &lt;![endif]--&gt; &lt;/head&gt; &lt;body&gt; &lt;section style='margin:25px 400px;'&gt; &lt;?php if ( $_POST['registerbtn'] ){ $getuser = $_POST['user']; $getemail = $_POST['email']; $getpass = $_POST['pass']; $getcpass = $_POST['cpass']; if ($getuser){ if ($getemail){ if ($getpass){ if ($getcpass){ if ($getpass === $getcpass){ if ((strlen($getemail) &gt;= 7) &amp;&amp; (strstr($getemail, "@")) &amp;&amp; (strstr($getemail, "."))){ require ("./connect.php"); $query = mysql_query("SELECT * FROM users WHERE username='$getuser'"); $numrows = mysql_num_rows($query); if ($numrows == 0){ $query = mysql_query("SELECT * FROM users WHERE email='$getemail'"); $numrows = mysql_num_rows($query); if ($numrows == 0){ $password = md5(md5("cesnored".$getpass."censored")); $date = date("F d, Y"); $code = md5(rand()); mysql_query("INSERT INTO users VALUES ('', '$getuser', '$password', '$getemail', '0', '$code', '$date','$getyear', '')"); $query = mysql_query("SELECT * FROM users WHERE username='$getuser'"); $numrows = mysql_num_rows($query); if ($numrows == 1){ $site = "http://localhost"; $webmaster = "Test &lt;noreply@test.net&gt;"; $headers = "From: $webmaster"; $subject = "Account Activation"; $message = "&lt;h1&gt;Test&lt;/h1&gt; &lt;br&gt; &lt;h2&gt;Account Activation&lt;/h2&gt; &lt;hr&gt; &lt;br&gt; &lt;p&gt;Thanks for registering on the Test Website $getuser! &lt;a href='$site/activate.php?user=$getuser&amp;code=$code'&gt;Click Here&lt;/a&gt; to confirm your email and receive your 300 free Gems! Make sure that you are logged out when you click the link, but you must log in to again to get the Gems.&lt;/p&gt; Or Copy and paste this into your browser window &lt;a href='$site/activate.php?user=$getuser&amp;code=$code'&gt;$site/activate.php?user=$getuser&amp;code=$code&lt;/a&gt; &lt;br&gt; &lt;hr&gt; &lt;footer&gt;If you did not register, ignore this email, we will not send you any further emails. &lt;/footer&gt;"; if (mail($getemail, $subject, $message, $headers)){ $errormsg = "You have been successfully registered. Check your email (&lt;b&gt;$getemail&lt;/b&gt;) to activate your account and receive your free gems. Make sure to check your spam/junk folder if you don't receive the email"; $getuser = ""; $getemail = ""; } else $errormsg = "An error has occurred during the email sending process. Please try again. If this issue persists, &lt;a href='/support.php'&gt;contact our support team&lt;/a&gt;."; } else $errormsg = "An error occurred during signup, please try again later. If this persists &lt;a href='/support.php'&gt;contact our support team&lt;/a&gt;."; } else $errormsg = "That email has already registered, if you forgot your password, &lt;a href='/forgot.php'&gt;Click Here&lt;/a&gt;."; } else $errormsg = "That username is already registered, if you forgot your password, &lt;a href='/forgot.php'&gt;Click Here&lt;/a&gt;."; } else $errormsg = "That is not a real email, Silly!"; } else $errormsg = "The two passwords must be the same!"; } else $errormsg = "You forgot to confirm your password, Silly!"; } else $errormsg = "You forgot your password, Silly!"; } else $errormsg = "You forgot your email, Silly!"; } else $errormsg = "You forgot your username, Silly!"; } else $form = " &lt;font color='red'&gt;$errormsg&lt;/font&gt; &lt;div class='panel panel-default' style='padding-top:0px'&gt; &lt;div class='panel-heading'&gt; &lt;h3 class='panel-title'&gt;Sign Up&lt;/h3&gt; &lt;/div&gt; &lt;div class='panel-body'&gt; &lt;table class='table'&gt; &lt;tr&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; &lt;form action='./register.php' method='post'&gt; &lt;div class='form-group'&gt; &lt;label class='col-md-4 control-label' for='mcname'&gt;Minecraft Username&lt;/label&gt; &lt;div class='col-md-5'&gt; &lt;input name='user' class='form-control' placeholder='Minecraft Username' type='text' required='' value='$getuser'&gt; &lt;/div&gt; &lt;/div&gt; &lt;/tr&gt; &lt;/td&gt; &lt;tr&gt; &lt;td&gt; &lt;br&gt; &lt;br&gt; &lt;div class='form-group'&gt; &lt;label class='col-md-4 control-label' for='email'&gt;Email&lt;/label&gt; &lt;div class='col-md-5'&gt; &lt;input name='email' type='text' placeholder='example@example.com' class='form-control input-md' required='' value='$getemail'&gt; &lt;/div&gt; &lt;/div&gt; &lt;/tr&gt; &lt;/td&gt; &lt;tr&gt; &lt;td&gt; &lt;br&gt; &lt;br&gt; &lt;div class='form-group'&gt; &lt;label class='col-md-4 control-label' for='password'&gt;Password&lt;/label&gt; &lt;div class='col-md-5'&gt; &lt;input name='pass' type='password' placeholder='&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;' class='form-control input-md'&gt; &lt;span class='help-block'&gt;8 Characters, 1 Number&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/tr&gt; &lt;/td&gt; &lt;tr&gt; &lt;td&gt; &lt;br&gt; &lt;br&gt; &lt;div class='form-group'&gt; &lt;label class='col-md-4 control-label' for='cpass'&gt;Confirm Password&lt;/label&gt; &lt;div class='col-md-5'&gt; &lt;input name='cpass' type='password' placeholder='&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;&amp;#8226;' class='form-control input-md' required=''&gt; &lt;span class='help-block'&gt;Same as your passowrd&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/tr&gt; &lt;/td&gt; &lt;tr&gt; &lt;td&gt; &lt;br&gt; &lt;br&gt; &lt;input type='submit' name='registerbtn' value='Register' class='btn btn-success'&gt;&lt;/input&gt; &lt;/table&gt; &lt;/fieldset&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;"; echo $form; ?&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;script src='http://code.jquery.com/jquery-2.1.0.min.js'&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src='js/bootstrap.js'&gt;&lt;/script&gt; &lt;/section&gt; &lt;section style='margin:25px 180px;'&gt; &lt;hr&gt; &lt;footer&gt; Copyright 2013 &lt;/footer&gt; &lt;/section&gt; &lt;/body&gt; &lt;/html&gt; 
&gt; The md5(md5('pepper'.$password.'salt')) password hashing strategy? Now it's doubly secure!
Did it fail because you turned *open source* into a verb?
&gt; in interviews it's personality that more often than not that gets you the job Ding ding ding! We have a winner.
No idea why this got gilded or even upvoted. The benefit of this, if any, is entirely superficial. Read the other comments.
You focus too much on improving your knowledge but not improving yourself.
What the fuck is this asinine jibber-jabber doing on the Internet?
Nevermind, i realized it by myself, i just needed to ask. The problem was that behaves_like: needs to be category, grouping or tags
[HAHAHAHAHAHAHAHA](http://3.bp.blogspot.com/-KpR6j7et3Qg/UB5uJtHNSTI/AAAAAAAACG8/8ES5mYVuKeI/s1600/mr-chow-haha.gif)
Yes, it's recursive. I'll post it there and see what they have, thanks.
I think that actually a use case would be usefully illustrative. For example, if I take payments online via some website could my website then notify the QuickBooks webconnector (soap server) which then the QuickBooks desktop could pull accounting entries (xml) from?
&gt; THIS is why people hate on php as a language. It's really not about the code. It's about PHP itself.
/r/phphelp might be better for this
ops I didn't realize we had that sub reddit. Thank you ./
"The great corrupter of man is the ego. Looking at the mirror distracts one's attention from the problem."
Yes, that was actually one of the features. We started integrating with Stripe because Stripe is awesome and met with us in San Francisco. Here's most of the code that did that: * https://github.com/brightmarch/major-api/blob/master/src/MajorApi/AppBundle/Controller/WebConnectionStripeController.php * https://github.com/brightmarch/major-api/blob/master/src/MajorApi/AppBundle/Controller/ApiQuickbooksStripeController.php We had plans to expand to PayPal, Braintree, and Balanced but never got around to it.
I hope you mean that you don't want to highlight the variable under the cursor but highlight the rest of its occurrences. I have pushed an update to the repo. Now you can set the global variable g:vawanohlcurrent to 1 and it will not highlight the instance of the variable under cursor.
Yeah that's what I mean, I was confused when they asked me about it too.
I'll second this statement. Considering how hard it is to find remotely qualified php developers you should have no issues landing a job with half your skills. If you haven't even gotten an offer then it means they didn't like you personally.
one of the hardest problem is getting the right image. I recommend you to go with a python solution which can be run as a service. https://github.com/grangier/python-goose/
There's your market... I used to work at PayPal, and there were a ton of merchants asking for help connecting PayPal to quickbooks, because PayPal's reporting (as of a year ago afaik) sucks balls. Consequently, if you pick things back up and need help at least on the PayPal API side of things, shoot me a message!
In my current job interview I even said I am not a good coder. I phrased it as; 'I am not a good coder in the academic sense, but I am good from a business point of view. I like to make code which makes a profit.' During a different interview, the interviewer finished the interview by saying: 'Your technical skills are about the same as the other people, but you can talk socially. Most of the others are freaks!! Where do I get more people like you?' Also, dress smartly, and have good manners. Even if the dress code in the office is jeans and t-shirt, where a suit, clean white shirt, polished shoes. Be polite, speak clearly. This helps them feel re-assured you came from a good family, and can be trusted. Some people may take exception to this opinion, but you are trying to make it easy for the interviewer to choose you. They have probably been interviewing several people and are nervous about hiring the wrong person. It can be a very expensive mistake!! (Being good looking is also a help, but that's for another thread.) Be open to talking about all sorts of subjects. The majority of people who have a full time job working with code love to be able to talk about other subjects too. Bonus points if you can impress them with fun stories about you have been doing recently. Be sympathetic to the business, and understand how you could help them. Most companies have a hard time trying to find developers. They want some one to work with their staff, not some one who is going cause a chasm. The pace of development in most business' is very slow compared to the freelance world. Bosses LOVE it when all the staff get on well and display camarade. It makes them feel if they have built a great team.
Yes, I contribute to open source projects regularly. Plus it also includes BitBucket and Launch Pad. My contributions have been to project both big and small in community.
They are hacked-on annotations moreso than "logic in comments". PHPUnit is not the only library to use them, big players like Doctrine and Symfony use them a lot.
I've been around in a lot of contract positions, so I get to pickup and learn new things quite frequently. As far as staying up to date in PHP I'm always watching the release notes for minor versions and keeping in mind what's been added to the core so I don't have to bother with pecl or pear packages. As far as web technologies I'm heavily focused on it, when I say JavaScript it's in reference to "HTML5" since it's essentially 80% of it. This includes taking advantage of ECMAScript 5 features, I'm hope IE 8 support ends soon so I can stop having to deal with ECMAScript 3. I've also taken a liking to the new ECMAScript 6 features and have been tinkering with cross compilers to backport code. TypeScript fits this build in some ways, but do some other miscellaneous ES6 compilers. It's essentially building for the future and then have it work on todays tech. As far as GitHub goes, I do use it regularly to submit patches to open source projects as well as post my projects.
There might be some truth to that, but then again they do label it as senior level position. Although I've seen senior level to actually cover a wider range than mid or junior levels.
That does sound great, but what about the number of available jobs.
Don't use mysql_* functions, they are deprecated, use mysqli or PDO instead. The query you want is something like this: SELECT users.name, group.name FROM users INNER JOIN group ON users.group_id = group.id ORDER BY group.id This will fetch a list of users and their associated group. Only groups that contain users will be included. It is ordered by the group therefore you can loop over the result in order and only display the title of the group when the group name changes from the previous result.
I'm US based, although if you know of any easy ins to get a non-sponsored work visa I wouldn't mind making the jump. I've actually traveled around Europe/the world a decent amount and would jump at the chance to work in Belgium or Netherlands.
I general look at doing web applications development (full-stack).
I'd start with the group table. So start by querying the groups table to select every group and then try fetching any users that belong to that group. If you get no user results, don't display the group.
I don't think this is an issue, none of the girls I date complain about it.
The last interview I had done was through a recruiter I've worked with before, so they have a good level of confidence when trying to place me. Although this interview they were surprised about not getting any feedback other than not interested.
Oh shit.. sry I forgot about yo u :(. i'll find it tonight.. Can you give me a myimouto-based website or demo? That'll probably help..
My friends and I actually do semi-regular coding interviews with each other, whiteboard and all. As our guide we tend to pull a lot of examples from [Cracking the Coding Interview](http://www.crackingthecodinginterview.com/). Although I'd still be interested in trying to do a google hangout or skype.
Hi metazai, I have been on the same path... I had an old code base which was with ~500 functions and didn't used any OOP. When i decided to rewrite this on OOP it was looking hard at the beggining. In order to maintain compatibility I slowly starded to write my classes and migrate each function; Then i just used the old function as a wrapper to call the OOP method. At the end the old code was working the same way and any new code was written in OOP I can tell you its totally worth it to migrate to OOP Cheers 
Overall I'm generally easy going in job interviews and do my best to be amicable, although there have been some situations that have left me jaded. Such as one time, I was in an "interview" that turned into being used for free consulting. It was quite obvious after the fact because the company completely change the requirements for the position. Another time I've run into a situation where I've had an over zealous interviewer that loved to markup my code with irrelevant corrections. In the same sort of manor of an english teacher that marks you down for using colour instead of color or cheque instead of check.
That is a shame, it is really tough to get into Europe without ancestry visas/passports. You could get a German woman pregnant (if you are a guy that is, alternatively just get preggers to a German man), that is an easy in! I'll still chat with my HR team to see if they have any strategy for getting non EU hires, but I think that is quite difficult nowadays.
&gt; I was asked to illustrate it, so I used a dynamic menu example from a previous project. I'm not sure if you read the sentence bellow the one you quoted. So I included in the hopes that it would clarify that it wasn't really a question of favorite. More of a pick something and give an example of how you would use it in code. 
Do whatever you think is fun. It will take you the furthest.
If they felt that questions like that should be removed, I'm sure they would. I don't see the point of asking this question since us regular users don't have the means to delete questions, and the ones that do are also the ones that set the rules, so....
My personal opinion is that they should be allowed to stay, the PHP help subreddit feels dead. It can be argued that stackoverflow should be used though. If posts were tagged with [question] or [news] etc people could easily avoid posts they don't want to look at.
This is why you use git... I don't think anyone can really help you, was that file part of a package, it looks like Wordpress. What's the full file name, including path? If it was custom written code, you're gonna have to rewrite it to display the contact form. 
You're not giving much information to go off. What exactly isn't working? I'm assuming this is WordPress you're working with, right? One thing I notice right off the bat is that you have an 'endwhile;' statement, but I can't see any corresponding 'while()' statement. I'm also not seeing the closing &lt;/div&gt; for your &lt;div id="post-area"&gt;, which I'm assuming is supposed to be closed in the same file it was opened.
Yes, I read it. A piece of advice: an interview is not purely mechanical as you make it out to be; subtleties are employer's best friends. 
Use prepared statements, or at least escape the input. 
you have &lt;?php endwhile; ?&gt; but no &lt;?php while(): ?&gt; 
&gt; No releases available for package "pecl.php.net/ssh2" install failed This is probably because only beta packages are listed on the website. No stable releases available. It seems that you have downloaded and compiled the module so now we just need to make sure it's in the right location and that your config loads it. php -i | grep 'extension_dir' This will find out where the extension should be. It's probably the same location as it currently is. Once you've moved the file to the correct location you should load it into PHP using the following line: extension = ssh2.so This should be placed at the end of the php.ini file.
I work extensively in Symfony, and I still spend a great deal of time exploring the problem domain and speaking directly with clients to get the most accurate possible business model. This is mostly a factor of working for smaller organizations where everyone is expected to wear many hats, and I'm sure there are magical places where you are handed a perfect requirements document by your benevolent project manager. However, I think having someone who is hands on with the client and involved in the whole process from design through delivery is what a lot of web companies are looking for right now.
Even so, it fills up this subreddit with crap. Stuff like [this](http://en.reddit.com/r/PHP/comments/1wjzl7/why_isnt_my_code_working/) is really waste of everyone's time.
No. 
There are lots of "my code doesn't work", which are not really questions about something specific. So that doesn't work.
Well those questions are clearly violating the rules: &gt; Please note that /r/PHP is not a support subreddit. Please direct all support-related posts to /r/phphelp, or connect to ##php on Freenode IRC. So this is a valid question.
This is not a busy subreddit so I don't see the problem. 2 day old posts are visible on the front-page so it's hard to miss anything.
&gt; the PHP help subreddit feels dead Maybe because people don't want to answer them? This subreddit brings a lot of value with interesting discussions and very good links IMO, it's a shame it's getting more and more unreadable each day. I'm not saying every discussion is crap, but "support" questions definitely belong to stackoverflow or some forum or /r/PHPhelp
Am I the only person who is OK with questions being re-answered? Newbies are better asking 'stupid' questions and getting up-to-date answers rather than finding some outdated PHP 4.3 tutorial from ~8 years ago. 
well if the conditions (such as php version or a different interpreter) have changed I think they should be kept. but if pretty much the same question was asked 4 months ago and is still relevent(!) then it should be deleted
well all "my code doesn't work" questions boild down to a specific problem, most noobies just dont know which one) if said problem has been answered before, the mods should just link to this question and remove the thread. 
That's a request for them to post in r/phphelp. If the moderators thought that the posts doesn't belong, they'd remove them. It's up to the rulemakers to uphold the rules. I don't see the point in asking them this question if the intention is to clarify how posts like this should be handled. Had you been a newly-made moderator, sure, it'd make sense for you to make sure that you follow in line with the other moderators, but you're not. You're a regular user like me, and we have no power over the content submitted here. If we have no power to remove content, I also see no reason to ask if content should be removed. If the moderators are of the opinion that posts like the ones you describe should be removed, they'd do it. Had this post been about trying to convince them to delete those posts, I'd get it, but it's not, so.... 
I tend to delete the more basic questions that could be solved with a little bit of Googling or studying on the language. Also, if a question is asked that provides in-depth steps that the user has taken up to the point of posting on Reddit, and it can be seen that the user has made a non-trivial amount of effort to get it working but still doesn't know what's going on, then I leave those. Most of the mods are on American time, as well, so during the night a bunch of crap can be posted and we may not be around to clean it up.
I'm split on this issue. I don't mind intelligent questions, which by their nature don't necessarily need to be complex. If someone comes out and clearly explains their problem, provides a clear concise code snippet that showcases the behavior, all error output, and a list of things they've tried that didn't work then my attitude shifts from "waste of time" to "help a brother out". Answering bad questions gets mentally exhausting. People who can't be bothered to read their own errors when they're self explanatory. People who dump 800 lines of badly formatted code on you and try to get you to play "find the cause of the parse error". People who refuse to read a manual link which would help them with their issue.... There are more examples, but I'm sure you get the idea. If anything, I'd prefer removing bad questions. Those are really what wastes everyone's time. Working out a well presented problem makes you feel like you actually accomplished something for someone who is genuinely trying.
Delete the support garbage.
&gt;during the night a bunch of crap can be posted Thanks for sharing that exploit.
Your approach is basically exactly how I'd handle it too. Good job and thanks for your time &amp; effort!
I made [a comment](http://www.reddit.com/r/javascript/comments/1we6zi/why_help_requests_in_this_subreddit_should/cf1ul60) regarding this in /r/javascript recently which mirrors some of your concerns, I'll just copy the relevant parts here because it applies all the same: &gt; And I may be in the minority, but I would much prefer that most code help posts be removed. Reddit does not work well as a Q&amp;A site, at least not in the same capacity that StackOverflow does. I would much rather host the "unanswerable" type questions that SO won't allow, as those are the most interesting IMO. _"Why isn't my onclick firing"_ just gets old, and there's very little chance of someone with a similar problem finding it again here on reddit even a week later... &gt; I don't come here to put in time doing Q&amp;A, I come here for news and discussions on industry happenings, new projects, and generally just more of the higher-level concepts around the language. It's not so much a problem currently, but if /r/javascript turns into simply a Q&amp;A site then that will kill the sub, at least for me. So I'd rather not encourage these types of posts at all.
As others have said, it's not logic really, but closer to configuration. They're declarative in nature, and while they are semi-hacky right now in PHP, there's been a strong drive to get the feature -- commonly known as annotations, and found in many other languages including Java, C#, etc. -- [included in PHP](https://wiki.php.net/rfc/annotations). It is a very divisive argument, being every bit as volatile as the various typing proposals.
Off for me.
You should check out http://sphinxsearch.com or ElasticSearch
I almost completely agree, but the "no logic" thing is slightly overstated. The point is that the logic should be in "the right place". If there is logic to the display, then by all means put it in the view. The view should absolutely contain **display** logic.
If your result set isn't large you can use DataTables to search on some of the other fields. Its a jquery thing, so all the processing is done on the browser. Not sure if that is going to fit your needs or not, but it might be worth checking out. http://datatables.net/ 
I disagree w/ the title of this post. Data providers do little more than a for loop and show each of your tests as separate in the output. But what problems they do have is they usually run out of band which loses many benefits of the encapsulation of a test (wrt to setUp, tearDown and other things). People tend to abuse them to do heavy lifting.
asp_tags tells php to use &lt;% %&gt; to indicate &lt;?php ?&gt; - Microsoft's ASP (original ASP, before .NET) used these % tags to start and stop demarking asp code. I assume this was added to placate an early adopter who didn't want to replace them all. I don't really know why it's still available.
[ElasticSearch](http://www.elasticsearch.org/) is all you need. Super easy to setup, easy to scale out, easy to load data, libraries for almost any language out there, geo location, etc. It's awesome. 
That's not true. And it's also got nothing to do with the question OP asked. PHP 5.4+ only enables short echo tags: &lt;?= $foo ?&gt; Short open tags are still disabled, as are ASP-style tags. &lt;% echo $foo %&gt;
Thanks for the reply. Not sure if you missed my other comments, but I really don't like the idea of going to university. I should have stated it in the OP, but that's why I posted the thread. I've been in education for over a decade, and it's getting old. I just want to get out into the "big wide world".
author here. i see where you are coming from and agree that the potential for abuse exists. i do disagree with your sentiment that they "do little more than a for loop".
Haha, I'm not exactly the party type. :P
Anyway just quickly to say, I'm 21, started doing freelance web development at 14, got a full time job working remotely for America at 16, did that for five years and I'm now back to freelancing so I can make more money. One thing you should do is learn negotiation, whether you're negotiating salary or negotiating contracts for freelance clients. You can make a fuck load of money, more than the general average, but only if you make that happen yourself.
It's not money I'm looking for. As long as I have a roof over my head and something to eat, I'm perfectly happy. What I'm looking for is to be able to do the thing that I love, as a profession. :)
Can anyone tell me how to do a hello world in PHP?
Oh yeah, I'm perfectly content having enough to pay my cost of living, but more money is always good to have. If you get criminally underpaid as well, that's not fair on you. You need to understand your value, and what you're worth to a company or client. You also run the risk of not being taken seriously if (if you go down the freelancing route) you quote something way too low. Companies pay big sums of money to ensure quality work.
There is no real reason to remove them. Downvoting them will also take care of this problem. But please answer them first if you want to downvote them.
/r/gamedev recently did something very similar. They removed all "help" posts... or questions about how to use engines / getting started questions... I cant help but feel the community / frequency of posts has declined..... 
In other words: blame Australia?
Um, don't make pages for everything-- but you don't have to use MVC if you don't want to.
I agree. Looping through an array to build your HTML belongs in the view. Basically and code that outputs HTML belongs to the View layer.
I have a basic question. What's a REM statement do? They are the only ones I understand, and I keep changing them, but nothing actually happens. Note: this was actually my first programming experience, ever.
Caveat: I'm usually up until 1 or 2am CST working on projects. /u/frozenfire is by Vancouver so he's 2 hours behind me. There's really only a small window available, and Reddit's internal spam filter is usually pretty good about catching most crap. edit: I don't know my Canadian geography.
ASP style tags are off, and have always been off by default. I would assume the *vast* majority of servers have them disabled, and your client's previous dev enabled them manually.
I'm not a big fan of stored procedures. However, if you're in an enterprise environment, you have no choice. You have to treat the DB interactions as just another remote API, because that's basically what it'll be.
&gt; asp_tags = Off xampp 1.8.1
That really depend on what you put into "pages for everything". Running everything through one file doesn't make things magically adhere to MVC, while having separate .php-files for each page to display can be used for a MVC structured app as anything else (think of each file as a controller). So .. there's not much to say in either direction about what the structure of the code is, based on the file layout of the directory served through the web server.
Probably guilty of this myself, before I realised that there was a more appropriate subreddit. Surely just politely asking people to post their questions in the correct sub is the way forward, even if the ever helpful members of r/php/ still choose to offer advice here. 
I like stored procedures because they can result in faster code due to less remote SQL calls if the procedures are designed that way-- they also can contain a lot more "sanity check" type code that will be executed every time (if implemented as triggers).. especially if you have many developers or different applications interacting with the same DB.
Would simple logic like if statements to hide/show features or rename labels be considered good practice?
I manage 20+ servers... all are off.
I think for small sites, &lt; 10 pages, with little dynamic content and/or data, then not having a strict code architecture isn't really a problem. In this case, you can sort of think of it using just the VC part (just HTML and a little bit of programming and minimal data(base) interaction). When you're working with larger projects or data intensive stuff, then MVC just makes sense as it provides a reliable and standard framework for those interacting components. It abstracts the application into its main components. Fundamentally, data isn't related to the logic, logic isn't related to the layout and vice versa etc., so developing those parts all separately gives you a lot more flexibility and increases the ease with which you can re-use code. Side note, using a framework is addictive and once you start using it you won't want to do any project any other way! Also, you can use components from MVC frameworks on their own, for example if you have a lot of data but no frontend (an API for example) then you can just use the MC parts, or if you have no data but lots of logic/pages, just use the VC parts.
Does it do average cpu or memory usage? 
First off, my condolences. I've been dealing with almost the same exact thing. I hope your stored procedures are designed better than some of ours. What we've done is abstract the functionality out of the procedural code and make each area its own class. I think the hardest part is categorizing the stored procedures and getting a better abstraction on the overall functionality. E.g. spGetUser with spFindUser or spGetPrivateMessages - how far do you abstract functionality. Other things have been done to reduce the legacy code. We've wrapped [Silex](http://silex.sensiolabs.org/) around the legacy application which gives us the power of pimple and routing (for writing new, oop code). Basically the legacy app gets routed and called via a legacyController function which can inject the service container into a global variable (stored in $GLOBALS) so you can start using newer tools.
Yep. Otherwise you would be building HTML outside of your view. That would be bad.
I've run into this problem before, and a method I've used as a successful work around is to use Curl to create a custom time out. The method was found here: http://www.darqbyte.com/2009/10/21/timing-out-php-soap-calls/
I'm going to tell you with confidence: Use ElasticSearch over Sphinx, if you are doing anything relatively modern. Ask if you want more details. - Oops, meant to reply to OP. Guy above me is right. - 
Another useful step: Watch Paul M. Jones' presentation to the Nashville PHP User group on modernizing legacy codebases. http://paul-m-jones.com/archives/2667 The concepts discussed are being made into a book as well. 
It's certainly looking this way. They don't seem to know *why* it's on, so we're turning it off.
Thanks for verifying.
I want more details.
Why not both? Move the router to your server layer (NGINX) and you can have single file pages. Snap in a DBAL like Doctrine, and bam, MVC, the 2014 way.
I had a tough time finding setup info for Windows. Are you running *nix/iOs? 
Yes. Or something like sale price. I.e. if this product has a sale price, show that with the normal price crossed out. Otherwise just show the regular price.
No, that belongs in a template. Please stop confusing views and templates.
It runs on windows or *nix. Here is a quick guide to getting it up on windows: http://joelabrahamsson.com/elasticsearch-101/ (The tricky part is running it as a windows service, a google search will find plenty of people who have solutions for that). 
I have a question about point 1: &gt; If you are echoing HTML through a PHP function, you're doing it very wrong. Very, VERY VERY wrong. For my website, I have a basic markup template for a specific purpose: showing preview images and text for links. [Here's what I'm talking about.](http://wednesdaywolf.com/) I keep that one bundle of echoed html in a function, calling it and passing it information on how to populate the markup. I reuse that one function constantly (mostly in loops after SQL queries, find paintings in this or that category, that sort of thing), as it's a omnitool. I can populate it with anything from the database so long as it has a image, category, author, and information, across all pages. But I'm still echoing html with php. If this is VERY, VERY wrong, then what would be the better solution?
In MVC, templates are part of the view layer.
oh okay, so this allows me to query my database table using the drop down based on the query return.. however, PHP requires the user to refresh and AJAX doesn't? So say they select apple, the second drop down wont populate because the user has not refreshed yet?
Thanks for the advice! Ya, I have a pretty good idea how I will modernize the legacy app, but in terms of abstracting the stored procedures, it's a toughy. However, anything is better than sticking random SP calls in the middle of procedural code. I'm thinking of your approach where I'll abstract the SPs into categories. This will make the classes reusable for writing an rest or soap API down the road.
I enjoyed that talk very much. Watched it about a week ago. I also enjoyed this talk as well; https://www.youtube.com/watch?v=Aq5Hi6PasFg
I used this as a drop in replacement for the built in soap client for 3 different services without any problems. It just overrides the __doRequest() method so the wsdl request xml is still parsed by the built in soap client.
With just PHP, a user selects "Apple". You either have a button that submits that selection, then refreshes the page with the second list populated, or you can have some JavaScript that will refresh the page for you when the user selects the fruit. With AJAX, everything works behind the scenes. A user selects "Apple", the AJAX function picks that up, queries the database, gets the returned results, then re-draws the second drop-down list with the new values. All of that is done without a page refresh.
You have no obligation to answer a bad question. Downvote it and move on. Reddit has a built-in system for handling poor content, I say we use that before asking the moderators to judge which questions are good and which ones are bad.
I assume that specifically you're referring to [this answer](http://programmers.stackexchange.com/a/40610) which is exceptionally well written.
I've used sphinx in a couple different places and found it rather easy to set up out of the boxes. Here are a couple of opinions on your comments &gt; Indexes generally happen faster (sphinx uses deltas). Latest versions of sphinx allows for live updating of indexes; you no longer have to setup delta indexes. &gt; It's endpoints are json by default. I think sphinx's PHP api pretty much makes this a moot point from a php perspective. I think this also ties into the support with in languages. &gt; Schema can be generated on the fly. This is a pretty interesting notion. It's definitely nice to not have to restart the indexer for a schema update. Sphinx's schema's aren't stored in XML though. Sphinx statistics are a definitely lacking. I wish there was support for importing JSON columns out of a database and parsing them.. 
Thanks, that sounds like the direction I need to go. 
Holy shit. I use MVC but it leaves me utterly confused to the point I don't know what goes where. This comment has made something click; I get it now! Thanks so much. 
This is the message I get back from the other end when I use curl. its running a .net solution I believe. If I don't use curl then it works just fine so I take it its missing the Action message. Do I need to add more to the header? http://stackoverflow.com/questions/18327843/calling-soapaction-via-php-curl The message with Action '' cannot be processed at the receiver, due to a ContractFilter mismatch at the EndpointDispatcher. This may be because of either a contract mismatch (mismatched Actions between sender and receiver) or a binding/security mismatch between the sender and the receiver. Check that sender and receiver have the same contract and the same binding (including security requirements, e.g. Message, Transport, None
Thanks for the plug dude :-) The book based on that talk is available in "early access" mode at &lt;https://leanpub.com/mlaphp&gt;, although if you prefer you can get notices about it via the mailing-list signup at &lt;http://mlaphp.com&gt;.
Thank you, this is what I was trying to, unfortunately just the word singleton seems to invoke wrath from the pits of hell. :D
I'm not completely sure, but I think this may have to do with CURLOPT_SSL_VERIFYPEER and CURLOPT_SSL_VERIFYHOST. You could try to set these to 0 to see if that is the culprit, but it's insecure to leave it that way. See: http://stackoverflow.com/questions/13467648/configuring-curl-for-ssl
Bummer.. sorry to hear that, but thanks for open sourcing your code!
&gt; If you have to enforce single instance it's a problem with your design This is simply not true at all. Single instances are unavoidable in all kinds of applications. *How* you choose to enforce them is up to you, and using a singleton pattern to do so is never *required*, but it's still a valid solution. Your logger example is apples to oranges, since you can't enforce single instances with service locators (because you can't enforce a single instance of the service locator itself). Besides which, the service locator pattern is as ill-advised and suffers some of the same drawbacks as singletons do. In any case, the point is that there is virtually no such thing as "X is *always* better than Y" in our field, and the singleton pattern is no exception.
It's interesting that you're continuing to bring this up as not too long ago someone made a pretty good post about all of this. You can find it [here](http://www.reddit.com/r/PHP/comments/1wkso5/so_singletons_are_bad_then_what/). Since I'm not getting through to you, it's my sincere hope that this helps to better educate you on the subject.
I feel like this is a false dichotomy, likely reinforced by working with the various popular CMSes of the day. I'm a big Concrete5 fan myself, and while I'll be the first to point out its flaws and why it's not a perfect MVC, it's the most literally 'pages for everything' implementation I've ever used (your data model is basically just 'everything is a page'), and still maintains a good separation between model (mostly managed at the database layer via db.xmls), controllers (which occasionally overstep and start directly echoing html tags, but otherwise do what controllers do), and the views (which usually read like HTML with a few quick &lt;?= ?&gt;s in there to show data the controller took from the model.) I don't think this is the sort of question well-served by one-paragraph answers, so all I want to get across is that if this is something you're interested in, work a bit with C5 and see how they do it, and you'll learn something.
Sorry to burst your bubble, but the author of that answer said nothing that I haven't said already in the past few replies to you. In fact, amusingly enough, he makes several points that are almost word-for-word identical to things I've said, including countering your claim that single instances are "problem[s] with your design." Singletons have a lot of drawbacks. Dependency injection is often a better solution, for various definitions of "better." It's up to you to decide whether or not the benefits outweigh the drawbacks. There is no One True Architecture(tm) in software engineering. It's for this reason that there are dozens of design patterns for a lot of common problems.
But he's done well in interviews for positions in other languages. Perhaps his problem isn't that he's not as good in PHP as the other languages, but that he's so much better in PHP than the other languages. He can be more relatable with his experience in JavaScript because he has less to say.
That might work, but I need to have the SSL encryption between the two points.
It blows my mind that you're that thick. It's literally like you didn't read the article at all- particularly the part where he specifically makes a distinction between single instance, and singleton.
Cool idea, I'm not sure how it would benefit from being open source though. No mobile app?
No mobile app, the idea is people can use whatever QR code scanner they want. The rest is web optimised. Making it open source was just an idea, maybe someone has some use for it.
Even if nginx as the reverse proxy and your HTTP server serving up this PHP are the same machine?
I think all PHP related questions should be allowed. I find it helps me learn by helping other people anyway.
I understand the concept behind the separation of concerns, but there doesn't seem to be a better solution. My idea, as it exists: function item($value1, $value2, $value3){ echo '&lt;div class="whatever"&gt; &lt;div class="inform"&gt; . $value1 . &lt;/div&gt; &lt;div class="info"&gt; . $value2 . &lt;/div&gt; &lt;div class="more info"&gt; . $value3 . &lt;/div&gt; &lt;/div&gt;'; } And then just calling it when needed, populating it from the database: function list(){ //database stuff to get info, putting it in to a while loop with $row as key $this-&gt;item($row['value1'],$row['value2'],$row['value3']); } And then calling $show-&gt;list() on the page itself. This allows the presentation to be modular, as I just need to update the database and the rest takes care of itself. But echoing HTML with PHP is a key element of this design. Am I missing something? Is there a better way to do this?
Sure thing! Hope you can learn something from it.
&gt; The @link tag indicates a custom relation between associated Structural Elements and a website, which is identified by an absolute URI. http://www.phpdoc.org/docs/latest/references/phpdoc/tags/link.html
Sorry, I assumed that you would remember what you posted. Let me quote you to clear up the confusion (emphasis mine): &gt; If you have to enforce **single instance** it's a problem with your design And from the article you linked: &gt; **Single instances** are simply a reality. And from my reply to your comment: &gt; **Single instances** are unavoidable in all kinds of applications. Hope that helps.
Well if there's no ASP start/close tags then go for it.
The key word you're completely blind to is "enforce". A singleton enforces a single instance by controlling your ability to construct new objects. A single instance of a regular class on its own is not enforced, meaning while your application may only use one instance at any given point in time it does not stop you from instantiating the class again. Or extending it. Or replacing it. I can't believe I have to explain that. It's a point he makes very early in the article - the difference between "singleton" and "single instance".
Fair point. I suppose I was just taken aback by the quality of it. It covered the subject matter so well that it just felt like it should be the focus of attention.
Indeed. My last app (internal company tool) was "pages for everything", but the start of nearly every file was to include my core code base (essentially a framework and utility functions). Said code base included the database interaction (PDO with custom extensions), a template / page handling system, etc. It did everything and had an autoloader for classes I didn't always need. Main files contained the "controller" and business logic, template system loaded "views", etc. All in all, it was a small MVC framework without the M and without a central file for everything to run through. I am actually currently in the midst of rewriting it using Yii, which was going very well until I hit some major walls trying to figure out how to use models for my database access. (Right now, I can't figure out how to SUM a column three relations away from the model I'm working with).
If your understanding is that making instances handle specific responsibilities is better than making one huge object that does everything, then yes you are absolutely correct. This pertains to maintainability. The two main things I try to remember is that a singleton does not abstract out the classes well enough for easy code maintenance (classes with specific responsibilities are much easier to maintain), and that they're not as testable. [Further reading](http://stackoverflow.com/a/2085988/592760) I apologize if I read your question wrong, but I'm not quite you understand Dependency Injection (DI) fully. I'm simplifying and generalizing a lot here, but this is how I understand things. Dependency injection allows you to create a this-&gt;do() class and method, where do() is anything from save, read, write, mail, to speak. The class, this, in this example would also contain some private/protected property that contains a reference to the injected 'doer' which implements some known interface that the class aware of. Going deeper down the rabbit hole: For an example, say that the main class is Pet, and it implements an animal interface, IAnimal, and you have one implementation of that interface, Dog. What DI does, is promote the type of coding that would allow you to create a second/third/fourth implementation of the IAnimal interface, such as Cat, Fish, or Hamster, without changing your Pet or IAnimal classes at all. Since the Pet class knows what the IAnimal interface looks like, it can use any of the classes that extend that interface. *Sure, that's all fine and dandy.. but where are the dependencies getting injected!?* Here is the kicker for how it works: Instead of hard-coding each implementation of your IAnimal in your Pet class, and instantiated it by saying what type it is. You simply have one property $_IAnimal in your class and have your constructor function set that paramater to whatever 'dependency' is 'injected' during instantiation. --- 1. public class Dog implements IAnimal 2. class Pet { __construct(IAnimal animal){ this-&gt;_IAnimal = animal; }} 3. $pet1= new Pet(new Dog()); 4. $pet1.speak(); //dog implementation of IAnimal interface speak method. 'ruff' 5. $pet2= new Pet(new Cat()); 6. $pet2.speak(); //cat implementation of IAnimal interface speak method. 'meow' --- *I think the "injected dependencies" can also be known as providers. This method is much more loosely coupled, and allows you to easily test each class, interface, and implementation. [Further reading1] (http://richardmiller.co.uk/2011/07/07/dependency-injection-moving-from-basics-to-container/), [Further reading 2](http://martinfowler.com/articles/injection.html) I learned most of my DI/Repository/Interface pattern knowledge in the .NET web dev world. It gets super complex over there, for me at least, but if you can have a .NET guy explain things to you, they're generally very very good at explaining these patterns since they use them daily for 99% of their projects.
I can't fault you there.. Its so clearly and simply written and yet so detailed..
you don't want to echo too early and then get the "content sent before headers" if you later need to set a cookie or redirect the user. So save the echo for the your template file when you're sure you're displaying stuff to the user.
I think you need to work on your reading comprehension. ;-) &gt; the primary benefit is pretty obvious: it **enforces** a single instance &gt; How you choose to **enforce** them is up to you &gt; since you can't **enforce** single instances with service locators
Check that out: http://m.wikihow.com/Create-a-Secure-Login-Script-in-PHP-and-MySQL
Templates are **used by** views. Each view can use several (or none) templates to build the page. Alongside the [presentation objects](http://martinfowler.com/eaaDev/PresentationModel.html) and [services](http://martinfowler.com/eaaCatalog/serviceLayer.html). *"Looping over array to build HTML"* belongs in a template.
In ZF2, for most projects, all you will find in the view folder are templates. The same is true for Symfony 2. I believe the same is true with Laravel.
OK, let's go ahead and assume you're right. What would the proper use case for a singleton be that is better than any other implementation? Be specific please.
&gt; What would the proper use case for a singleton be that is better than any other implementation? I would never make that claim about *anything*, because "better" is meaningless and completely subjective without metrics to define it. *Better at what, and how shall we measure that?* Anyway, you seemed to be advocating that one should never use singletons because they're never the best choice, and I found that to be a pretty bold (and faulty) statement. As with anything else, you should always learn about your options and make an informed decision based on your own priorities. With respect to singletons in particular, I don't personally use them, because testability is usually my top priority. The difference between my stance and yours is that I respect the fact that not everyone has the same priorities as me, and the "worth" of a given design pattern is not constant or objective. Someone who cares nothing about global state or testability may find singletons to be the most desirable option for them, and I don't personally feel like there's anything wrong with that, as long as they understand the drawbacks.
You say startup - do you really mean that or are you just saying that because they are trendy right now? A full time start up that actually makes money is really hard - a lot of work. Or it looks like your still at Uni - do you really just want a fun project that others use and that you can use as a CV? And a bit of bonus money would be a great extra? Basically, what are your goals with this? I've been running http://opentechcalendar.co.uk/ for almost 2 years, even made a bit of money, and I've just decieded to Open Source it at http://ican.openacalendar.org/ (Php to!). It was a hard decision, pluses and minuses each way that are hard to compare, don't have time to list them now but can do later if you want. But at the end of the day, I just realised that both Open Source and Closed Source are very hard ... and if I'm doing all the work anyway, I'd much rather have Open Source. So I'm doing it. Nice idea tho. I've seen this done for specific uses but don't think I've seen a general purpose one before.
&gt; No mobile app, the idea is people can use whatever QR code scanner they want. The rest is web optimised. Nice idea, keep that, good technical thinking. But I've sat in research groups before, and I think you underestimate how much some people really like their apps, even if there is no technical need for them :-)
You're being overly aggressive for no good reason. I suggest you go take a break or something until you've calmed down. 
&gt; **I would much rather host the "unanswerable" type questions that SO won't allow, as those are the most interesting IMO.** I can't agree more with that. Those are the kind of question that deserve a discussion, not an answer (and that's why it's a bad fit for SO).
Undergrad CPE here, bits go in bits come out, can't explain that
What do you think could be the use of `@link` followed by a link in a documentation?
This is a review?
This is nice, although the nested set model is based on traversing a tree via left and right domains. This is more of an adjacency list. It's converting a flat array of adjacency list data to a multidimensional array. I've put up a library on github which works with nested sets and adjacency lists. Although it doesn't convert flat arrays to multidimensional ones, it does convert an ajacency list to a nested set and vice versa. I would love to plug your code snippet into my library to offer that multidimensional functionality. For anyone interested here's my library: https://github.com/Humen/Tree
Memcache is useful for caching data (sql results, api responses etc.) when you are running your app on multiple servers. If you want to make ('normal') PHP faster to run, you should use some kind of opcache extension (Opcache on PHP 5.5+ or Apc/WinCache/Xcache on older PHP versions). Hiphop (usually called hhvm nowadays) is extremely fast without any kind of additional extensions.
This is a good tutorial for beginners I guess, but it doesn't teach the best practices. Using SHA to hash passwords; using procedural code; embedding PHP in HTML. If you're into video tutorials, check out phpacademy's [PHP OOP Login/Register System](http://www.youtube.com/watch?v=c_hNNAdyfQk). He uses the Singleton pattern, which is considered by some to be an anti-pattern (including me), but it's not *too* difficult to alter the code to use dependancy injection instead.
Fortunately I have access to see all of the stored procedures and exactly what they expect. i think the problem you mentioned can be mitigated if you enforce the same rules in your methods in terms of expected input/output, as the stored procedures have. The rules would probably go something like this: * Check that all required parameters have been passed * Check that all parameters passed are of the same datatype as those expected by the SP * Validate the output (ie: ensure it's what you expected when you wrote the method)
If they're going to be implemented I guess they'll use the C#/Java syntax of `[Annotation]` the line above the class/method declaration.
&gt; What is the point of @link? To... ummm... link stuff? Maybe? http://www.phpdoc.org/docs/latest/for-users/phpdoc/basic-syntax.html They all have different meanings. They provide inline documentation and if you use an IDE you will see them being leveraged quite heavily.
It's hard to interpret this as both a joke or something serious.
Depending on how dynamic/static your content is the lowest effort for maximum gain is often as simple as making sure you specify appropriate caching headers coupled with a reverse proxy - the fastest code is the code that's never executed. Beyond that make sure you're deploying to PHP &gt;=5.5, the performance bumps between 5.3 &gt; 5.4 &gt; 5.5 have been fairly significant. Additionally, as /u/_sgtk has said make sure you use _an_ opcode cache - 5.5 ships with one by default but if you're stuck with an older version i've previously had good experience with APC. HHVM can itself yield a good performance bump, but many of the PHP extensions most commonly used have not yet been ported so for a non-trivial application not written with this environment in mind this often simply isn't yet feasible. Beyond that you start getting into the realm of better/more hardware - faster disks, additional ram, extra load-balanced servers etc. At the end of the day it's a rare application written in PHP where the bottleneck is PHP itself; in most cases i've dealt with the best performance increases for time invested has come from optimisations at the database level - reducing the number of queries, optimising the ones that remain and tweaking the database configuration for the workload you experience.
You are talking about an "if" statement. There's not much you can do to optimize that. Only thing I can see is use APC if it's not already installed on your server. High demand/high availability systems have absolutely no optimizations for that kind of trivial language things. When talking about optimizations for an app, first thing that comes to mind is usually database performance...or even better, the use a cache layer to avoid the DB whenever you can.
* Structure is ok * Content is so-so because there's no syntax highlighting I want my 45 seconds back !
You know, the tense you're using is not too helpful. Does it still have a PHP section or did it only use to have one?
Well this is a wrong approach. Optimizing without knowing what you are optimizing makes no sense. This may sound like bullshit talk, but this is true. Performances boils down to: - measure - optimize the most expensive part - goto step 1 In a standard web app, most of the time it's database access that will be at fault. But some times it's not DB or queries that you need to optimize, but the shitty code that makes a query in a loop, because the developer was stupid. So it's always a different reason, and a different solution. *Edit*: only exception I see in PHP is "use an opcache". You should always use an opcache, but with PHP 5.5 it is embedded and enabled by default.
&gt;I was wondering how the "primary" image of the page is decided Reddit also has this feature (it's disabled by default). You can enable it in your user settings. Reddit is open source so you will find your answer [there](https://github.com/reddit/reddit/).
This book does both of those things. The 10 projects are good and practical. It's worth the read if you want to build one of them and the Laravel documentation isn't sufficient for you to know how to.
I've done this with CI before. I would use an mvc framework with auth libraries.
Yeah I'm not sure the author knows what a book review is. It's a 260 page book that someone spent months writing. It's can't be summed up in 2 paragraphs complaining about Packt's handling of the publishing process. I'm no closer to knowing whether I want to buy this book after reading the "review". Also, this guy has posted his blog twice in the past couple of hours. I thought that was against subreddit policy.
Sorry you didn't find it useful. As far as posting policy is concerned, I think I do need to cool it a bit. I'm posting this stuff far too frequently. Thanks for the grounding.
google phpdoc, @link is part of phpdoc to link something
yes
What do you mean by "stepping through the header"? Are you referring to something like a database-driven navbar, with sections and submenus? You would run the query once: `select * from navigation`. Then you would take the result and build an array in the right structure for your needs.
I mean foreach (datafield fldHeader in fldsHeader) { fldsDetail = "select * from Detail where keyHeader='" + fldHeader.keyHeader + "'" foreach (datafield fldDetail in fldsDetail) { } }
I certainly hope so. I spent (and am still spending) a non-trivial amount of time implementing these improvements. Always remember: *each time you fail to verify TLS peers a baby seal gets clubbed.*
Why would you use PHP sockets or streams to make HTTPS requests when there's a libcurl wrapper that ships with PHP? What am I missing? 
Yeah, I hope they will too. I think the main problem is continuing to push out the blog posts, tweets and security vuln reports so there's motivation. I was pretty surprised to find disable_compression so rarely enabled (and I'm reporting it to some projects directly). Another thing I may do is compare the before and after using something like https://www.howsmyssl.com/ to gauge progress and give PHP programmers a measurable sense of how PHP and various libraries actually compare.
phpDocumentor can export you a nice report of your php code if you have that phpdoc style '@link' comment text. Editors like Aptana Studio can also read all of it and then build 'helper' tooltips so that when you hover over functions you get extra information on how to use them etc. based on what you wrote. Just a structured universal way to comment PHP code that multiple programs/people can understand.
The article specifically uses HTTPS as an example, which is why I ask. `file_get_contents` is a very poor way to get HTTP content. How does it return the headers to you? The HTTP status code? How do you tell it how many redirects to follow? How do you send custom headers? How do you make non-GET requests with it? `file_get_contents` for HTTP is code smell at best. I use Windows servers with vanilla PHP installed, they have libcurl. libcurl's PHP API is libcurl's API. The calls are the same as the calls you use to work with it in C. Besides, why are you worrying about that? Wrap it in a class and never think about it again. I think you're confusing libcurl -- the C library -- and curl -- the command line utility. 
Learn Redis, use the phpredis extension, write the whole thing yourself to do exactly what you need. It will be super fast, highly extendable, and you'll understand what is going on. I started with SphinxSearch http://sphinxsearch.com/ , you could use that first to get an idea of how 'key-&gt;value dictionary tables' speed up search and common ideas like stopwords/wordforms/etc. Sphinx has a php api that it comes with.
&gt;Anyway, you seemed to be advocating that one should never use singletons because they're never the best choice, and I found that to be a pretty bold (and faulty) statement I am advocating this, and I will continue to advocate it until someone can show me conclusive evidence that there is a place where using a singleton is the best possible option. I'm not closed to changing my mind, I just think if you're going to try to defend it, you had best be able to come up with something better than what you're saying. &gt;I respect the fact that not everyone has the same priorities as me, and the "worth" of a given design pattern is not constant or objective. I agree with this to a point. When something can be extremely useful, and the best choice in at least some situations, and less useful and maybe not the best choice in others. However this statement falls apart when you can't find even one good use case. &gt;Someone who cares nothing about global state or testability may find singletons to be the most desirable option for them We have a name for these people, they're called bad programmers. These are the guys who create the software you dread maintaining. &gt;I don't personally feel like there's anything wrong with that, as long as they understand the drawbacks I find everything wrong with that, *especially* if they know the drawbacks. At least if you're unaware you can claim ignorance and work towards being a better programmer. You're one hell of a troll. I'm betting you probably could make a solid case for why Pol Pot isn't such a bad guy after all and have at least a few weak minds believing it by the end of the day. I'm not buying it though.
The difference is that PHP streams are everywhere. file_get_contents() was just a simple example. You also should have read the PHP manual about it's second parameter.
Go ahead and check it out, I have not been on that page in a while.
The more the merrier!
I was about to write a follow-up to Drainedsoul that supported everything they said, but then I read up on how file_get_contents returns $http_response_header so you can parse out status codes and whatnot. Huh. Didn't even know that existed. I guess that's the problem with PHP...a million ways to skin a cat.
Can you post some examples of what you're talking about?
I would add that no one is suggesting `file_get_contents` is the ideal way to retrieve HTTP resources. It must be stressed that encryption has farther reaching tendrils than HTTP requests. The biggest win for improved encryption support lies in those areas.
What is this you are talking about?
I wish I had done this. I did three years of university and two years of college with eight months of working a IT help desk for coop. Plus I was an OAC student ( grade 13 in Ontario Canada ). I had it stuck in my head that I needed a completed education to be a "professional". Even though I'd been coding one way or another since I was 16. I could have entered the development job market in some capacity YEARS before I was done college, and possibly done even away with working as a merchandiser / factory worker / cleaner and all the other stuff I did to pay for my education. It was worthwhile to see how other businesses functioned, and slinging a mop has really made me appreciate the opportunity to work in this field. I'd have rather been coding professionally though. Edit: Missed word.
See also [Sslurp](https://github.com/EvanDotPro/Sslurp) by EvanDotPro (a core ZF2 contributor).
Thank you. It's kinda strange because I never programmed in Python or Ruby but I like the indentation-base mechanism for a tree structure like HTML. I'm not the first to have this idea, "Hamlbars" (which is a Ruby thing) which renders Haml into Hamlebars. Also Emblem.js (templating from Ember.js, which is not related to Ruby/Python) has the same principle.
I'm confused... your code doesn't appear to be PHP. Possibly a template? Short answer is no. This is bad. It has to run repeated queries to get data. You should be making an array from the result. $sql = 'SELECT * FROM Detail'; foreach ($conn-&gt;query($sql) as $row) { $header[$row['keyHeader']][] = $row; } 
Thank you for this feedback. Are the bullets points sorted by order of importance? &gt; No tests &amp; Haphazardly documented code I will definitely work on better documentation and add some tests, but I could use some help for the latter, I'm not very proficient at testing yet. If you read "Internal.md" you'll find that the compilation is done in 3 steps. Should I start testing that feeding a specific input string and options returns an appropriate output string? Or should I start testing each step of my "compilation" (this seems more complicated since I have to compare deep nested arrays). I'm aware that both would be best, but I'm taking it one step at the time. &gt; Overuse of statics leading to "objects are just containers for functions" syndrome. I used static functions because they're "simple" step from the algorithm which doesn't rely on external parameters. They all take max 2 parameters: * either a string or array to work with ; * and optionally some options to do the job. I could remove the static to make them non-static but it wouldn't change anything imo (or did I miss something here?). &gt; Methods feel like they're taking on too much responsibility Do you mean they individually contain too much LOC? Or is it just a feeling? &gt; SimpleXML :( This could be replace by some other algorithm. In fact I originally had 3 different implementations for the same task, but this one was the most efficient, so that's why I kept it. &gt; Provides no real benefit to regular PHP, and increases the learning curve of a project for no good reason This is just a matter of opinion and subjective thinking. I think of my tool as a pre-processor like Sass &gt; CSS or CoffeeScript &gt; JS. At least for myself it's just a more convenient/faster way to write my Handlebars template. If you answer me, thank you for the time you take, I really appreciate it and look forward to learn more :)
Thanks for taking the time to write that up! Oversimplified, classes that would repeat code (e.g. Dog and Cat) should be factored into a base class (Pet). Dog and Cat as Singleton patterns are bad. I've got a lot of reading to do thanks for this. Edit: Also, I've seen DI used in Angular.js but PHP DI/providers look a bit different. I'm a bit stiff now but I think your example's a good starting point.
Who or what is Otwell, and what is he/she/it marketing?
Even it something like that was happening, probably not.
Ok thanks. I think at a super basic level, that DI accepts parameters as a template to be "injected" variables into, as opposed to hardcoding variable definitions within the method itself. Is that about what you're getting at with DI? Thanks for taking the time to write that.
Since we're talking micro-optimizations here, you should throw in using interpolated strings vs concatenated strings. :P
I don't know what you're referring to, but looking at your post history, I think a more apt question is whether the moderators should remove you.
No. He's just an idiot who hates Laravel with a stupid noisy rage.
(Oh, I know. Perhaps I was too subtle. ;-) )
if you really want to talk about micro optimization: using objects as a data structure rather than a associative array is 10% slower! &lt;?php $obj = new StdClass(); $obj-&gt;prop = 0; $start = microtime(true); for($i=0; $i&lt;1000000; $i++) $obj-&gt;prop = 10; $end = microtime(true); echo "assigned 100k to an object in " . ($end - $start) . " seconds\n"; $obj = ['prop' =&gt; 0]; $start = microtime(true); for($i=0; $i&lt;1000000; $i++) $obj['prop'] = 10; $end = microtime(true); echo "assigned 100k to an assoc. array in " . ($end - $start) . " seconds\n"; 
That's a dumb argument. Did they take away all the PHP books in order to make a Laravel book or something? Do they no longer make generic books? Is there a quota? There has always been books that cover specialisations, in any field. You can find law books, just as you can find books on corporate law, or maritime law, or international maritime law from the 18th century. None of that means you can't get plenty of books on law. You can get books on IT. Books on programming. Books on programming in Javascript. Books on programming in Javascript using jQuery. Books on programming using jQuery and Ember... None of this stops there being books on IT. tl;dr - There are still plenty of books. Grow up.
I get what you are saying. I deal with business applications. I have MANY customers who have thousands and 10's of thousands of header/detail records. If I were to create an array of both the header and detail tables completely I would find myself with a memory issue. What I am saying is if I have a header table with 1000 rows and a detail with say 2000 rows to create an array of each would be a waste of memory. Instead using the same connection execute a query to the header then start your loop and execute a detail query. If you are working with a database server that is on the local machine or local network the overhead would be minimal as would the memory. While you way with my example maybe a better way the memory requirements can get out of hand quickly and your method will not scale to larger volumes.
I know that, but I wanted to know why people used @link, @author like that.
- Define count() before using it in a for loop. - in_array() is slow unless you've got thousands of values, array_flip() &amp; isset() is generally faster. Edit: also see http://www.phpbench.com probably what you're after
Sorry, you're doing an awful job of explaining your need. There certainly are edge cases where you have to break down your results.
Or Laravel prevented him from molesting his sister?
&gt;Thank you for this feedback. Are the bullets points sorted by order of importance? It wasn't my intention to order them by importance. If they seem ordered by importance, it's coincidental. &gt;I will definitely work on better documentation and add some tests, but I could use some help for the latter, I'm not very proficient at testing yet. Excellent. Testing something like this isn't going to be very easy, but it's going to help you in the long run. I think the big thing that makes this so hard to test is the amount of work each method is doing. Methods should be responsible for a very specific thing, and when they take on too much responsibility it becomes harder and harder to test smaller state changes. &gt;I used static functions because they're "simple" step from the algorithm which doesn't rely on external parameters. They all take max 2 parameters: * either a string or array to work with ; * and optionally some options to do the job. To quote my first OOP mentor from 20 years ago, "an object with no internal state is a questionable thing". The statics themselves are not really the problem, they're a symptom of a problem. Generally when one makes an object it's because they want to contain a state of some kind, and this doesn't really do that. In fact, very little in the object itself manipulates object state. It's more like a collection of functions that talk to each other and disregard the object entirely. &gt;Do you mean they individually contain too much LOC? Or is it just a feeling? I think it's a bit of both. To me it screams [code smell](http://www.codinghorror.com/blog/2006/05/code-smells.html). I get the distinct impression this could be implemented in a much more logical way that is both easier to read, easier to test, and easier to understand. In your case a balance likely needs to be struck between readability and performance, and without performing proper profiling on the code it's hard to know how far is too far for your use case. &gt;This could be replace by some other algorithm. In fact I originally had 3 different implementations for the same task, but this one was the most efficient, so that's why I kept it. Efficiency can be measured a few different ways, so before I can respond I need to know what it means in your context. Are we talking execution time? Consumed memory? Ease of implementation? &gt;This is just a matter of opinion and subjective thinking. I think of my tool as a pre-processor like Sass &gt; CSS or CoffeeScript &gt; JS. At least for myself it's just a more convenient/faster way to write my Handlebars template. You are correct, it is subjective when the only metric you look at is preference. I think there are other things to consider, and preference should not be the sole determining factor. Usually when I decide a DSL is appropriate it's because I want to limit an interface to the point where it can only perform a specific task. For example, using markdown in a wiki makes a whole lot of sense because you want to avoid letting your users execute arbitrary code, but you want to give them as much power to format text as possible. In the case of a programmer it makes no sense to artificially limit the ability to do things where a template is concerned. Yes, you save some time because you're not typing as much, but you're also increasing the complexity of the project. You're also making it more difficult to debug because a problem that occurs in a fully rendered template may not be as easy to spot in the unrendered template. The other argument that is very common is that programmers don't want to let designers use PHP, which I believe is an attitude based on incomplete logic. yes, your designer could learn this. On the other hand, it could be argued that if your designer can learn this, that PHP should not be significantly more complex to learn well enough for basic templating. It's also arguable that knowing PHP is more valuable than knowing a very specific DSL. I appreciate you taking my criticisms in stride, let me know if you require further clarification.
+1. Just saw OP's post history, perhaps he should be given a timeout.
If you are already using S3, Elastic Beanstalk is worth a look. http://aws.amazon.com/elasticbeanstalk/ AWS ticks all the boxes you list. Deploying to EB is as easy as "git aws.push".
People are giving you snarky answers because the time taken to do something as simple as connecting to a MySQL database is probably 1000 times longer than all these optimizations put together. The only way to actually optimize code is to profile it and figure out where the time is really being spent. Once you start this process you realize micro-optimizations aren't very important. In a worst case scenario they get in the way - e.g. classes are "slow", lets only use procedural code. Oh performance sucks we need to replace X component lets do that. Oh wait we can't do that because all the code is tightly coupled and makes no sense.
Wouldn't go as far to call /u/BilgeXA an idiot. Different, may be, but not an idiot. 
&gt; I think I do need to cool it a bit. While you are at it, please try to keep Laravel posts to /r/laravel too.
Am I allowed to mention [Engine Yard](http://engineyard.com)? I work for them. Happy to answer any questions you might have. :)
He's an obnoxious insulting asshole. What he says is invariably rude and unhelpful. "Different" doesn't cover a damn thing. He's an utter ass. For the record, I have YOU tagged as "says really stupid shit", so your opinion on him is kind of not helping.
They want to know their hire is going to be in indentured servitude
I've been posting them in both since the /r/laravel is quite empty. I will confine them to /r/laravel in future.
I get your OOP problem, and a bunch of plain-old functions could fit my needs. But then how can it be distributed with ease using PHP and Composer? Autoloading is a must and we need class for that :'( The word "efficiency" was indeed vague and I was referring to execution time (I didn't measure memory and easy of implementation was the last of my concerns, even if both other solutions were more difficult / more LOC). If you were in the impression that you have to either learn a new DSL or increase the complexity of the project, you understood wrong. As I said, I see it as a tool for lazy developer to write their Handlebars template faster, a bit like your IDE can auto-expand Emmet/CSS-like `div#header.with_sidebar` automatically to `&lt;div id="header" class="with_sidebar"&gt;&lt;/div&gt;`. Since IDE expand HTML automatically my project could seem a bit pointless, but I plan to add some nice features later (like auto-generating micro-formats attributes based on CSS syntax rules). It's not meant at all to be run by the actual code of an application. If an application is doing it then it's doing it wrong (I get it's tempting, I'm doing it myself during the development phase, but it's won't ever hit production as is). It's no use at all if you don't use/know Handlebars from the start. I was more in the thinking "if it's useful for me, maybe it's useful for someone else, too". --- Thinking about the whole thing a bit, I think I got a easier algorithm which would this time benefit from a class and an object :) It involves treating each line truly independent and generating the output as we are reading each line.
And he'll probably get it wrong. Hell, I'd probably get it wrong. If I recall correctly, double-quoted interpolated strings are faster than single quoted strings with concatenation, but single quoted strings with concatenation are faster than double quoted strings with concatenation.
You really shouldn't try to address micro-optimizations in PHP. They're just not worth thinking about in any practical application. Instead, focus on more all-encompassing optimizations like opcode cache tuning, data caching (redis, memcached, etc), autoloader tuning (for an interesting example, check out EdpSuperLuminal for ZF2), etc. Also, APC is *not* Zend Optimizer. They're two completely different projects. The three most popular opcaches are xcache, APC and OPcache (formerly Zend Optimizer+). If you're writing a thesis for an actual university, then I would recommend starting off on a good foundation. Pop into #phpc on Freenode and don't make any assumptions, because everything you know about performance tuning is probably wholly wrong.
&gt; He's an obnoxious insulting asshole. What he says is invariably rude and unhelpful. Still does not make him an idiot. May be you like to throw your insults left and right without giving much thought to what is being said. &gt; For the record, I have YOU tagged as "says really stupid shit", so your opinion on him is kind of not helping. Ok. 
Why are you always posting a link and a comment together. Why cant you make a text post with link. Is this for increasing the ranking of the comment or something like that?
It's a tl;dr
no, this is just a reference link. It can be a pattern, bugfix or whatever link.
What drove your decision to use Redis instead of a tool built for memory database caching, like Memcached?
Please, keep it civil.
Please, write some kind of automated system that submits a new post about every single Aura release/blog post/commit you make.
Heroku is amazing. FortRabbit is pretty good. I thought [2012 would be the year of PHP PaaS](http://philsturgeon.co.uk/blog/2012/01/2012-the-year-of-php-cloud-hosting), and [it wasn't](http://philsturgeon.co.uk/blog/2012/10/cloud-hosting-php-pipe-dream). Heroku hired a great dev whos name I've forgotten to work on the official PHP buildpack, but [this one](https://github.com/CHH/heroku-buildpack-php) is excellent already.
It's probably this one.
Yeah, Phil, I wondered the same. Top Tier internet hosting wholesale infrastructures don't just fall down. Ultimately, though, it makes no difference. My site is down because your service is broken, or my site is down because your network provider is broken... either way... 
I sure didn't know Box used PHP!
[Aura](http://auraphp.com) was entirely incidental to the post; the main point is about how to solve an issue with Composer.
I didn't say that this particular post was about Aura. It was however, a blog post.
Memcached requires your data to come from some where, like a MySQL database; Redis can be used like Memcached, or it can be used like Memcached but also persist the information to disk as well, its a NoSQL database then. 
That's getting dated, and I'm sure Core Concepts will be a bit more topical and relevant to today's PHP ecosystem. If not, I'll tar and feather the author ;).
Redis is much, much more than an object cache. Advanced data types and persistence of data to disk are just the start. 
Yeah I just wanted to know how angry to be with them after I ragequit. You built something that was hampered by a shitty third-party? That sucks, im sorry. You built something that didnt scale very well and tried to blame a third-party who did nothing wrong instead of owning up to your mistakes and fixing the situation? FUCK YOU.
See the example's that they provided (last commit) https://github.com/box/augmented_types/commit/dbbf97432a8418789fba0509a18be1407b0865ea wow
Yes, one that I hope is helpful to to at least some people here.
Hhvm's implementation doesn't mix code and comments.
yeah that's what i thought through the whole presentation. the doc-style parsing would give you strong typing for free, although only for parameters and return types.
You bet, I am glad you could make use of it! Pet may have been a bad example.. the further reading has better examples, but the idea is that you have an interface, and multiple implementations of that interface. Maybe breeds of cat following a cat interface would work better.. because you usually will use/interact with any breed following the cat interface in the same manner. That is different than having two objects that inherit from or extend a base class. These interfaces are not technically part of Dependency Injection, but you will usually see them used together. Using interfaces like this is called [Dependency Inversion](http://en.wikipedia.org/wiki/Dependency_inversion_principle) and can technically be used in the same way that you would use a base class, but they should not be used interchangeably and there are specific scenarios each are better for. I found [this during some quick googling, which uses another cat/dog animal example](http://stackoverflow.com/questions/56867/interface-vs-base-class) :) 
Have you ever created a proof-of-concept? Was it perfectly testable, scalable, and maintainable? Unless you're a freak of nature, the answer to that last question is very likely "no", as it would be for the rest of us. But that's completely okay, because you were just tailoring your code to suit your priorities. A POC doesn't need to be testable, or maintainable. That doesn't make the code "bad". Likewise, the worth of any design pattern is dependent on your priorities. If your design goal is to enforce a single instance of some class globally in your application, then you have several options. Of these options, the singleton pattern has certain benefits - one of them being a very low barrier of entry, and quick implementation time. In contrast, maintaining proper dependency injection throughout your entire application's object graph is another option, but is much more involved and will take you much longer to get right. So - which is "better"? It depends on your priorities. Anyway, I feel like I'm just reiterating the same points here, and you seem to have reverted to childish name-calling, so I'll leave it at this.
upload to S3
As /u/p0lt and /u/magnetik79 pointed out persistence and data types are definitely something to love in Redis. I must, however, note that I only use Redis as in-memory configured cache without any persistence. In the end, I found Redis just as easy to start with as Memcached + I really like how easy it is to use the documentation on their website.
https://www.digitalocean.com looks good but I cant comment on their reliability
Just implemented it in one of our APIs to see how it would respond, and I caught a couple nasty Strings passing for ints. I'll definitely start spreading that through our codebase locally and on stage environment. Good to see a company like Box contributing !
That was the first thing I noticed! :). Another big name to drop of those who use PHP. It seems I always have one or two clients say PHP is not enterprise. 
That's like, fuckin' sweet.
Probably not.
- Use a CDN style service (e.g. Amazon S3 as mentioned) - Alternatively if you wish to keep everything "in house" you could have a machine dedicated to the serving of static content (e.g. what is uploaded) - this can be simply an Nginx server, no PHP/etc. needed answering on a subdomain/alternative domain for your site. The docroot of this machine can then be shared over each PHP app server in your pool using NFS and adding a mount point to /etc/fstab
It depends. Easiest route is probably Amazon S3 or Rackspace Cloud Files. The approach I favor is to use Amazon EBS or Rackspace Cloud Block Storage on each cloud server and using DRBD to keep everything in sync. Both solutions have their pros and cons, and depend a great deal on backend storage support of your application, your comfort level with server management, and of course budget. 
Exactly. Redis seemed like feature overkill to me considering this from OP's architecture doc: &gt; Redis is configured as cache-only. There is no persistance enabled. We are only interested in temporary caching database fetched items and using them on client READ requests.
Fair enough. I don't know enough about Redis to know whether you're sacrificing anything by using it over Memcached. I tend to gravitate towards tools that do exactly what I want and nothing more, if I can help it, but that's more a matter of personal taste.
I wonder why I never see stuff like class Foo {} class Bar { public function theMethod(Foo $foo) { } } Are people too lazy?
This seems like a combination of https://wiki.php.net/rfc/scalar_type_hinting_with_cast and https://wiki.php.net/rfc/arrayof Why make up a new name for it when this type of thing already has a name (type hinting)? You're not augmenting any types, you're enforcing types. 
Yes, but it's done by hijacking the existing docblock, so it's not *language built-in* typehinting. Note that it also enforces return values. PHP doesn't define any specific parsing rules for the docblock, it just exposes the text contents via reflection.
I personally _despise_ "annotations" also known completely defenestrating the purpose of comments more or less just because it's easier to parse. It'd be nice if the core team could stop being fucking insane and just pass scalar type hinting already.
What use case do you have that isn't solved by class constants? Keep in mind that PHP 5.6 lets you [use expressions in property definitions ("constant scalar expressions")](http://docs.php.net/manual/en/migration56.new-features.php), which makes the usual powers-of-two pattern much more sane than it is right now. It also features `use const`, which lets you import/alias constants from another namespace.
We're not likely to see real scalar typehinting any time soon because [there are too many opinions on how to do it](http://www.reddit.com/r/PHP/comments/1wocpo/making_php_safer_introducing_augmented_types/cf48ohc?context=3), and they all suck.
If only it was the purpose of the core team to make decisions instead of say "That's hard. Next!" If the current core team was active in the early years of PHP I swear it would have never existed because they'd still be fighting over we should prefix variables with $ or % or ^ or / or \, or @ With bullshit reasons like, well $foo is hard to Google so let's go with &amp;. The truth is they don't all suck, each is just a different way of doing it and it's a feature that's valuable enough that they just have to fucking settle on one and the people that don't like it will get used to it.
Why do you recommend using disable compression? I was of the impression that tokens could only be recovered when the attacker could get a string into the the message that was prefixed with what the token was prefixed by. So for example: If you have `&lt;input name="csrf" value="sometoken" /&gt;` You would need to be able to get something like `csrf" value="` into the body so you can start checking whether the content is smaller than would be expected when trying to find the token value i.e. compressions is occurring because part of your testing token matches the real token. EDIT: Or is what I am saying only applicable for `BREACH`? 
After reading that I have very simple question: if you want static typing why don't you use statically typed language?
S3 isn't a CDN.
Because you can type-hint your enum type to make sure that you only get a valid value. See an example [here with this implementation in userland code](https://github.com/myclabs/php-enum).
To provide a very simple answer: significant existing codebase and existing team skill set. 
Dear lord. I never thought for a second that I'd find a conspiracy theory in this subreddit of all subreddits. Excuse me whilst I go laugh myself into depression. 
Yawn.
Hi, I don't use Laravel, have no inclination to use Laravel and don't think I ever will. Bit of a Symfony geek myself. You're just making yourself look incredibly stupid. /end of discussion
Doesn't Facebook use their own fork of PHP with implemented strong typing? I've seen it mentioned here, but can't find any sources on it.
I thought about Twig, but decided to go with pure PHP for the View. For database, I think PDO is enough right now. I don't need to overweight the app. Maybe just simple Sql Query Builder I've got.
it can, technically, effectively deliver content over a network, though...
It's a storage system. If you're gonna use S3, use it as a backing store to CloudFront.
It is just a concept of 'stack' of objects implementing HttpKernelInterface and wrapped inside each other. In this example, actual application is wrapped inside a reverse proxy that caches responses based their headers. // they both implement Symfony\Component\HttpKernel\HttpKernelInterface $app = new Myapp\Kernel; $proxy = new MyApp\Cache\ReverseProxy($app); $request = Symfony\Component\HttpFoundation\Request::createFromGlobals(); $response = $proxy-&gt;handle($request); $response-&gt;send(); I hope this explains idea...
http://www.php.net/manual/en/class.splenum.php
I see. However stacking them like that sounds pretty messy if you have many objects, no?
Yes. I can't provide any valid reason other than that I'm interested in the code.
That's pretty good! I did not discover that one myself, thanks for the link. The double colon throws me a little, but it is quite acceptable as it indicates the base type.
Why would you want to get them started on something other than what is currently being used on your projects? It would seem silly in my book to get them learning CI when you are using Laravel... 
We have a few sites we support that were built using CodeIgniter so they are going to get exposed to it. I'm not entirely sold on Laravel yet and was wondering if young developers had any positive experiences with other frameworks early on in there learning/work experience.
If you're going to use straight PHP templates, consider using [Plates](http://platesphp.com/). It makes working with native PHP templates much nicer.
We have a shared file system that the uploads go to. At first, I was using glusterfs, but I ran into very bad performance issues with directory enumeration, so now I'm back to NFS exported DRBD volumes (the latter for HA). Works like a charm.
It is known as [Decorator pattern](http://en.wikipedia.org/wiki/Decorator_pattern). Whether it is messy or not is quite relative. If you are coming from a procedural background, it probably looks bit messy (that's what I thought when I saw it first time). For those familiar with oop designs, it is a very convenient way to 'extend' an object without actually extending or modifying its class.
What are the Enterprise MVCs?
I'll try to explain as well, as it's not an easy one to understand. Don't look at stacks as something that happens within a single PHP app. Rather, look at stacks as a series of PHP apps that pass their responses to one-another sequentially. If you're at all familiar with Unix, this concept will be familiar to you. Pipping (using the `|` symbol), allows you to send the results of one Unix command/program to another. For example: program1 | program2 | program3 ls -l | grep key | more This technique is really powerful. It keeps each program very focused on one task, while allowing programs to work together. Stack PHP accomplishes the same thing, except in PHP. The difference being that it doesn't share the response between programs as plain text (as the Unix pipeline does), but rather as a PHP interface (HttpKernelInterface). Stacks are not meant for everything, and tend to be most useful for HTTP layer functionality, such as caching, sessions, authentication, etc. Hope that helps!
Smarty/CodeIgniter IMO.
I learnt Laravel at school. Currently I am using Yii at my first developer job. I can easily pick up both framework primarily because it is relatively simple framework compared to Symfony etc. ,but also because both framework has well written beginner book on the market. Code Bright and The Yii Book are two of the book that I used to learn the concept of MVC and the usage of both Laravel and Yii in about a week. With that said, If I have to give a recommendation, I would go for Yii simply because its documentation is more comprehensive which makes extending classes much more easier. Also the fact that it is an older framework you could find solution to your problem more likely.
This is one of the use cases for [Aura](http://auraphp.com). Completely independent components, truly and fully decoupled from every other package in the project, with Router, Dispatcher, an ExtendedPDO object in the SQL package, a pure-PHP view system, etc.
Do you like Yii? I worked with it last year and was really unhappy with it (lack of native namespacing, not part of the PHP-FIG, lacking documentation). 
It's kind of embarrassing to say it, while I probably should be concern of all the downside that you have listed, those doesn't matter to me for the work that I do everyday, which is building relatively simple website and CMS. By the way, although I have no idea what's the purpose of PHP-FIG, you might be interested to know that Yii has joined the group recently. https://groups.google.com/forum/#!topic/php-fig/8cNsxj0YhGs
Take a look at Yii Framework and its components.
Thanks for that. Its amazing how many features PHP has that I'm unaware of. I think that PHP 5.2 needs to just die already. Then a lot of optional features will be be raised to a highler level of awareness.
A lot of people are completely unaware of the spl. I think I first came accross it with arrayobject. Check it out sometime, lots of useful data structures.
I'd have to check out my code but I think that I'm using some queues. I agree its pretty powerful.
How are you closed on Symfony? It is completely modular. You can swap in your own routing/templates/orm etc. You can try Laravel if you want to see how another framework uses Symfony components while still being a very different framework.
I'm sorry for being nosy, but *which* school teaches Laravel? I'd consider it a new framework (at least for school curriculum), so it is a bold move from the teacher, isn't it?
The recommendation is for general, broad-based security. Disabling TLS compression is a low-cost way to prevent the attack entirely. Newer client software (read: browsers) disable this feature across the board and we're simply following suit. For user's who don't know or aren't sure if they need it it's best to err on the side of safety and this is why PHP 5.6 will likely [disable TLS compression by default](https://wiki.php.net/rfc/improved-tls-defaults#tls_compression). It's always preferable to use the most secure and conservative defaults while retaining the capacity for modification at the user layer. The option is always available to enable compression manually for those users unconcerned about injectable output (many HTTP client use-cases in PHP will not act like normal browsers and are generally less vulnerable to this class of attack). However, while the CRIME/BEAST family of attacks is largely mitigated client-side these days, the ability to disable this functionality is still very useful for encrypted *server* streams written in PHP who may need to service outdated clients. As for the `BREACH` attack, it targets *HTTP compression* (e.g. when your web server sends a `Content-Encoding: gzip` header). Though the attacks are related, this is not the same thing as compression at the TLS layer which we're disabling in our PHP stream contexts.
&gt; we use s3fs to mount a bucket as a local directory I understand the reasons for this: &gt; That way, our CMS file manager that doesn't have any support for S3 can save it's files to S3. But, to provide folks with another option, AWS's PHP SDK has a [stream handler that you can register](http://docs.aws.amazon.com/aws-sdk-php/guide/latest/feature-s3-stream-wrapper.html). Then you can just use `s3://bucket_name/` as the directory for moving your files around. $new_name = somehow_generate_a_safe_filename(); move_uploaded_file($the_uploaded_file, "s3://some_bucket/{$new_name}"); // or with symfony... $file = $request-&gt;files-&gt;get('some_file'); // make sure $file is okay $file-&gt;move('s3://some_bucket', $new_name); Makes it very easy to support storing files on S3, just add the AWS SDK as a dependency. 
There seems to be a misconception in this comment thread: this *is not* part of PHP. The link points to a *PECL extension* that is not bundled with PHP. You can compile it manually (or procure a pre-built .so or .dll file) just like any other extension for use with your PHP binary. However, this *will not* be present in the vast majority of installations and cannot be relied upon for broad compatibility unless you take steps to ensure you have this extension available in a given environment.
According to the manual spl is compiled and included by default 5.0 and above and as of 5.3 always available and cannot be disabled.
And the manual is correct: `ext/spl` does come with PHP. However, you've linked to the [SPL_Types](http://www.php.net/manual/en/spl-types.installation.php) extension which is not the same thing: &gt; This » PECL extension is not bundled with PHP.
Unfortunately, this *is not* part of the SPL extension bundled with PHP.
Can you recommend a current guide/book/tutorial?
One of the largest differences between the two is that Redis is fully atomic and has a single thread, where Memcached is not and runs with some x number of threads you specify. Certain calls in Memcached are fully atomic like incr,decr,cas, and a few more, but there are others that aren't like set, get, del. He's probably not sacrificing that much, since its not persisting to disk, but there is the possibility at extreme scale Redis' single threaded nature may work against it. It really depends on what he's doing, I haven't gone through the code, but I know Redis can definitely withstand some abuse ;)
Just FYI ... The peer verification and host name matching routines wouldn't have anything to do with timeouts as they're conducted on the certificate received from the other party. The only way this could affect timeouts is if the remote server or underlying client curl (or OpenSSL lib used by curl) is *seriously* broken. And like you mentioned disabling these checks is very problematic. Always remember: if short-circuiting peer verification is the answer then you're solving the wrong problem.
Makes sense as to why I haven't heard of it. Thanks.
I did not notice that, I assumed it was part of the standard spl. Thanks for the info.
Yeah it's an easy mistake to make. It might make sense to look at changing some colors or something in the UI on manual pages for un-bundled extensions to make this distinction easy to see.
I just compiled 2.3 few days ago... Here I go again.
That makes sense, and helps me narrow down my question. With this design flow, I would have to rewrite this block: // bunch of other html above here &lt;?php foreach ($books as $book): ?&gt; &lt;div class="book"&gt; &lt;h3&gt;&lt;?= $book-&gt;title ?&gt;&lt;/h3&gt; &lt;p&gt;By &lt;?= $book-&gt;author ?&gt;/p&gt; &lt;/div&gt; &lt;?php endforeach; ?&gt; Multiple times across multiple pages. If I wanted to update how it displays this information, or update the function of the display, say to this: // bunch of other html above here &lt;?php foreach ($books as $book): ?&gt; &lt;div class="book"&gt; &lt;h3&gt;&lt;?= $book-&gt;title ?&gt;&lt;/h3&gt; &lt;h2&gt;&lt;?=$book-&gt;genre ?&gt;&lt;/h3&gt; &lt;p&gt;By &lt;?= $book-&gt;author ?&gt;/p&gt; &lt;/div&gt; &lt;?php endforeach; ?&gt; I would have to track each one down individually, and make sure each update is error-free. A function call that echos HTML solves this problem. What is the benefit of not just storing it within a function?
Are you complaining that there are some new stuff and bugfixes?
After installing php through home brew, you will then run something like "brew install php55-augmentedtypes"
Gotcha. So first homebrew php55 then afterwards run that to install the extension. Cheers!
It's difficult to read due to bad formatting, but it looks like you've got something hinky in the move_uploaded_file function call; $ C:/Program Files/Apache Software Foundation/Apache2.2/htdocs/upload) The dollar symbol (sigil) should be followed by a variable identifier; it looks like you want the directory path for the second argument so simply drop the "$" and wrap the directory path in quotes (either single or double).
PHP is really lucky to have Facebook pour their resources into making HHVM. A free open source JIT with one of the biggest tech company using it in their stack, making it rock solid.
That's right. Follow the instructions for install php through homebrew here: https://github.com/josegonzalez/homebrew-php brew tap homebrew/dupes brew tap josegonzalez/homebrew-php brew install php55 brew install php55-augmentedtypes #when available 
funny thing is if i did $result = $statement-&gt;query(); $result is considered a object.
Sorry I didn't make it clear. I learnt Laravel while I was still at school.
Great. Thanks!
We use gluster for the files and a database cluster for the file list/pointers 
the error is that $result isn't considered an object but i don't know how to fix it with out taking out the prepared statement.
yea thanks. i guess ill just use query. global $connection; $query="SELECT internshipId, internTitle, payAmount, hoursWeek, startDate, endDate FROM `internship` WHERE categoryId = $id"; $statement=$connection-&gt;query($query); return $statement-&gt;rowCount; this worked
The only issue with this approach is you're wide open to sql injection. Make sure to bind the id variable appropriately. [PDO has a rowcount function](http://www.php.net/manual/en/pdostatement.rowcount.php), if that's what your after. Note, rowcount doesn't return an int when you are running a SELECT statement as per the second example on the link above. What you could do, if another solution isn't better, is either run a count query or find the command for your db. Again, per the link: $this-&gt;query($sql_statement)-&gt;execute(); Example: This returns 4 records(rows). Then $rowCount = $this-&gt;query("SELECT FOUND_ROWS()")-&gt;fetchColumn(); $rowCount == 4;
And, Lets Not forget the Open Compute Project. That too deserves an applause www.opencompute.org 
I appreciate that the reference is trying to help others, and I encourage more resources (documentation, tutorials, etc), but isn't this essentially a copy of the [PHP manual](http://www.php.net/manual/en/function.date.php) for date (), with some minor changes? If the manual was difficult to understand, or incomplete, I can see the point, but it's very straightforward.
Basically it's a really really really fast implementation of PHP. Most people (like, 99.99999% of php users) are using the Zend engine because that was literally the only one that existed for awhile. The people at Facebook created a compiler for PHP called HipHop that made ultra fact runtime objects out of PHP, and HHVM is the next level of that in that it compiles things as needed.
but is it not very clear than the manual?
Look at the log files.
No, it just took so long to compile (did it on a pretty old machine).
Paste the code you're having issues with? 
Do you mean HHVM is 64 bits only? Where did you read that?
Late to the party, so let me know if I'm understanding correctly. Now HHVM will run my CodeIgniter and Laravel apps without me making any code changes? And once compiled, hhvm is a drop-in replacement for php, including CLI equivalent to php -i ./test.php can be replicated with hhvm -i ./test.php ?
You can also try the serialize function, it causes a great botleneck on some of my applications and is used by plenty of systems to store sessions or some random structure PHP variable persistently on systems like APC, Redis, Memcache and even MySQL.
i think this would be fastest: die('hello'); comparing a car with a van used for accomplishing the same task is a valid comparison. this "apples-to-oranges" nonsense is always pulled out whenever symfony2/laravel's costs are made apparent. the only difference among the three is that Phalcon is an extension, but the architecture is the same.
&gt;the only difference among the three is that Phalcon is an extension Why isn't everyone using Phalcon then?
Yes, it is 64-bit only. See here: [CMakeLists.txt](https://github.com/facebook/hhvm/blob/master/CMakeLists.txt#L5). Also, a Facebook engineer working on the project has stated that they have [no plans on supporting 32-bit operating systems](https://github.com/facebook/hhvm/commit/ff58f003aa42a130cf0096c223584ff19096b496).
If you care about performance **so** much that everything must be benchmarked to all hell, what are you doing using PHP at all? Why not write your website in C, C++ or Go? After all, if you care about microseconds so much, why the heck would you use a non-compiled language? You picked PHP for one of two reasons: 1. You don't know a compiled language 2. Performance isn't the #1 goal, there are more important factors. If 1, then get learning! If 2, point made.
They provide pre-built packages for a few major distros now.
So just because PHP itself is slow compared to compiled languages, no regard should be given to any form of performance at all? This is such a bad way of looking at the big picture. Performance is not just about shaving a few milliseconds here or there, it's also about maximizing resources -- money from costs of operations, how many servers or instances you have to spin up to serve a certain amount of traffic. It's sad that the most popular frameworks for PHP is the bottom of the barrel when it comes to performance, and yet one of them claims that it is a "high performance framework". The frameworks being promoted are VERY expensive to deploy. Too much emphasis is put on engineering/testability/correctness to the point that everything is abstracted to oblivion.
I like Twig for templates and klein.php for routing.
Normally, in mvc system I use a thing that I called library.. I can reach libraries and helpers from every controller but I'm not able to use models or other things from there..
For those interested, this is the stack I'm running: http://sharecomposer.org/v/52ee61a090fb92332b8b4567
IMO both login and register actions should be in a user controller 
Because I need look database if user registered etc.
I don't think that is what he was getting at. I think he was getting at the fact that micro optimizations are not beneficial in the real world. Sure, you might be *technically* faster, but 10x faster than already incredibly fast isn't really much of a real gain. As for too much emphasis on testability and correctness... this sounds like you've never had to manage a giant legacy code base written by people who cared only for micro optimizations. In terms of the total cost of ownership of a body of code, maximizing resources (in terms of server capacity) ranks pretty low. That isn't to say it's not important, but really shouldn't be the first consideration in most cases (although I'll grant that there are cases where it would be considered the most important, in the main I don't believe this to be the case). The most expensive thing a project will ever have to pay for is development and maintenance. There are always technical solutions to going faster and these are generally a fixed cost. A difficult to maintain/untested/built on piss poor engineering principles piece of code is going to cost you more **by an order of magnitude** than a few extra application servers. That isn't to say performance isn't important, but emphasizing it like it is the only reason for your framework to exist isn't going to help you out compete more mainstream approaches given that phalcon requires you to install an extension which rules it out on a large number of hosting solutions available to other frameworks. 
I love lower memory footprints and increased speed of execution as much as the next guy, but my main criticism of "Extensions-as-Frameworks" (e.g. yaf, phalcon) would be that they're incredibly difficult to debug and explore. I don't know whether this is a fault of my development style, but I find it very convenient to be able to dig down into framework method and then see how that works which can be easier than tracking down the right piece of documentation. Xdebug, step through - "oh right, that's how it works". Boom, move on. I would've assumed that the process is considerably more fraught (or even impossible) if you can't debug a phalcon feature. 
Sounds like a cool project. Would this somehow be able to talk to serial devices? Arduino perhaps?
OK perfect thanks you're what I needed. I'm new to object oriented programming so thanks for helping out
Check out the service locator pattern
I understand the importance of testing and code maintainability, and the long term costs associated with development and maintenance. What I'm saying is that Phalcon is actually offering us both. It follows good engineering practices, good architecture, AND excellent performance. It's not making us choose between cost of development/maintenance and cost of deployment. It's giving us both.
Why?
Just a tip.. You should change the docs to reccommend FallbackResource and not the resource intensive mod rewrite.
A nice idea, still i dont see the point. The composer.json file is just for dependencies, so atleast for me its totally diffrent on each project. And the composer file is always in version control, so theres really no use in sharing it, without the rest of the app files?
The title of the post emphasizes on the performance because it is the main differentiator when compared to other frameworks (MVC pattern, amount of abstractions, documentation). [Here's a discussion forum for Phalcon](http://forum.phalconphp.com/) My post is titled poorly, but I am not saying that performance is everything. I am trying to point out that Phalcon is actually a framework that has both -- good architecture and good performance.
For those asking, I think the idea is that you might notice an interesting dependency name that you haven't heard of, and would look it up to find that it's a better solution to a problem you've been dealing with, too. Op, it'd be nice if you set up the HTML generation so that it links dependencies to their respective websites or repo sources.
Php 5.5.x has some good performance boost compared to 5.3.x just using it will speed up things alot. It very rare that PHP itself is the bottleneck on any app, usually io is the slow part, and this applies to apps in all languages. I could say that serving your app on nginx, hhvm and having a decent cache like mamcahced or redis will make it snappy enough for almost any requirement today. Having a php extension as a framework sounds like a overkill, still i have no exp with phalcon so i cannot judge it. Will five ih a try when time lets me.
To be perfectly honest, I'm much more excited about Zephir than I am Phalcon. So, I suppose there is a lot of good coming out of this project, even if it's not the framework.
I can answer that, there's no real reason behind this site besides of it being a weekend project to mess about with. I guess the purpose behind the site could be to look up interesting stacks. Instead of always going for your usual ZF2 + Doctrine + Twig stack you might come across a Silex + Redbean + Blade stack which you'd fancy trying. The site is basically an equivalent of "Which framework do you use?"
Being at the "bottom of the barrel" means nothing if your selection of frameworks in said barrel are all performant *enough*. I mean, do you have any evidence to suggest that these bottom feeders are causing any real world problems for any real world applications? I've never heard of even a single instance where this was the case. In short, I think Phalcon is trying to solve an imagined problem.
That could be a reason to visit the site. It's basically a forum for "Which framework do you use?". Thanks for the suggestion, I might add it when I feel like working on it again :)
Love the idea, keep us informed!
I recently started to pick up PHP again (previous experience being an intro class at school 3 years ago). I looked around for frameworks and I personally liked Laravel the most. I liked how the quickstart was short, fast, and still gave a good introduction. After the quickstart it was very easy for me to start creating my own CRUD application, and easily find answers in the official documentation when needed.
I think it's a good idea and I'm sure it was fun to bring from start to finish.
That sounds awesome!
I shared the composer.json for one project I contribute to. http://sharecomposer.org/v/52eeabe990fb92e92b8b4568 Be gentle, we know our code is in bad shape. We have limited resources, and we are working on it. :)
No real drama - I can't think of many (any situations) where I would want/need a 32bit sever OS for PHP/MySQL/etc.
It would be better if you processed the composer.json files, and displayed them in a more readable way. If presented nicely, you could find out what the most common stacks are, and provide filters for stacks that contain certain libraries/frameworks etc. Then it might become quite useful
I've got a VPS that only has 1 GB RAM so I wanted to get best usage of the RAM. I think 64-bit uses more RAM because memory addresses (and thus pointers) take more space. 
And this is where you really want 64bit, to correctly address all of that juicy memory without using PAE or some other funky memory addressing method. :)
Python is a nicer language but it's not web oriented like PHP. Meaning that you will have an easier time building a web page with just PHP. That said, if you're an experienced developer and you're trying to pick up a 3rd/4th etc. language the difference is not that significant. 
Google "[php vs python](http://lmgtfy.com/?q=php+vs+python)" and you'll find a ton of information.
You could broaden this question to "What's the point in using a framework for my web applications?" I guess. Some advantages of using frameworks / Laravel are: * Large community behind it, providing support and components that can be used with it. * Frameworks like Laravel that are open source and have large communities are usually written well, and quite secure as a result. Basically, you alone will probably not write code as well as the hundreds of people that have contributed to a framework like Laravel. * Code is kept organised, and using a framework like Laravel helps enforce some best practises. * If you're using a framework you don't have to write all of that code for the standard features yourself every time. * They're usually well optimised too, otherwise they wouldn't be used! * Frameworks come with a lot of features built in that help you out, like template engines, dependency injection containers, service layers, and well structured code. As for template engines, they help keep your code a little more clean, and if you're working with templates how you should be (i.e. using as little logic as possible!) then you won't have to learn much to write a template. Generally template engines aim to make writing templates easier than using standard PHP. Templates become easier to identify by file name, and some template engines have some extra very nice features like caching and the like. ~~I'm going to close my opinion on this by just saying, you should of course use what works for you, that's a given.~~ You should always aim to be improving yourself and using technology that's new, and well recognised. If however in a professional environment that is impossible, then you may want to do so in your own time.
/u/SeerUD has covered the general point of a framework, so I'll focus more specifically on the Blade question. &gt; In particular, I don't understand the purpose of Blade Templates and the general syntax. It takes just as much code to write a simple input, AND I have to learn a whole new syntax to do so. I have some sympathy for this view. It always put me off Smarty, for example. Still does. But really... "a whole new syntax" is a stretch in the case of Blade. // standard PHP foreach($users as $user){ } // Alternative PHP format // relevant because it's often used for templates foreach($users as $user): endforeach // Blade format @foreach($users as $user) @endforeach Let's be honest here, it's not really going to break your brain. The question really is what does Blade give you that PHP doesn't. The answer, quite simply, is inheritance. There's a simple template class I used to use previously to working with Laravel. You would define a template object, then pass it values. It was simple, and effective. To a degree. $template_tpl = new Template('index.tpl.php'); $menu_tpl = new Template('menu.tpl.php'); $content_tpl = new Template('content.tpl.php'); $content = $page-&gt;getContentForPage(12); $content_tpl-&gt;set('page_content', $content); $template-&gt;set('content', $content_tpl-&gt;fetch()); $template-&gt;set('menu', $menu_tpl-&gt;fetch()); echo $template-&gt;fetch(); This is the **exact same functionality** with Blade templates. $content = Content::find(12); return View::make('content', compact('content')); As you can see, it's much, much shorter. Shorter is, as a general rule, better. That's not to say you should make things arbitrarily smaller for no good reason, but code you don't write is the easiest to debug. Not only that, but you can see the version at the top is quite confusing. Lots of similarly named things (content, etc) and the requirement to do things in the right order. Fetch before you set and you find yourself with invalid objects or missing data. The reason it's so much more concise is that it's inherited. The template for `Content` tells it what belongs to, what its parents layouts are. When the view is generated, it goes and gets all that stuff in the background and assembles it. The other big advantage is something called *Sections*. This is harder to explain, but essentially it's declaring an area as being a particular... well... section. Sections are part of the inheritance system and let you set, for example, the required menu for a "page" within the template for the page. You can also leave a default, so if nothing is set it uses that menu. In terms of Laravel itself... if you really *get* Laravel it should speak for itself in terms of use. The ORM lets you vastly simplify data retrieval. The routing lets you make nice clear paths for your application. Migrations make database schema management (as well as deployment) much simpler. There are built-in generators that stub out functionality, or third party generators that allow you to generate highly functional scaffolding. In short, the point of Laravel is to make your code more maintainable, faster, shorter, clearer, testable, and overall better. As a last point: &gt; I have spend the last couple days scouring the docs and youtube videos to learn the framework. Two things on that. One is that "days" is a trivial amount of time to put towards a new skill. Especially if (as you seem to be) you're doing it unenthusiastically and with resistance. Secondly, but most importantly **you were able to look this shit up on google**. If this was a bespoke application, you would have still not understood it, but you would have absolutely zero chance of ever doing so without extensive reading of the code. You couldn't watch youtube video of someone *explaining how it works* or read one of 12 different tutorials on the internet explaining it. You'd have had to make do with whatever handover you get, or whatever documentation was provided. Which usually.... 
&gt; I'm going to close my opinion on this by just saying, you should of course use what works for you, that's a given. I don't actually agree with this. It's a cop-out. Some people will just say "Well, this procedural mess I've been copy-pasting since 1996 works for me, so I'll keep using that." Make an informed decision about what's the best option. That may **or may not** be to learn a new technology. But don't take "works for you" to mean you should not bother to progress in your learning. Too many PHP programmers sit back and stagnate.
I was like this as well when I was first introduced to frameworks. They seemed cool, lots of features, people talking about them, but the concepts were foreign to me at the time. I will say that it can be more work understanding what is going on, but ultimately you will be doing less of the underlying work (routing, security, database design &amp; mapping, validation, etc, etc). They have objects/components for all that stuff, and when you learn it, you just have to use a few of those objects and you are done. So yes, more work at first learning all this, but ultimately less work over time.
When I first started learning PHP I tried to build an app without using a framework. At first it was fine but as it got bigger it became a gigantic mess of code and really hard to maintain. And I was completely not confident that my code was secure from injection and xss attacks because I didn't know how any of that stuff works. So I searched for solutions and I started using Codeigniter. The main reasons I love it are: * Built-in protection from injection and xss attacks * Form validation is wicked simple to set up and customize * Keeping all my SQL code in separate model files makes my code so much easier to maintain and to know where everything is and what does what * I don't have to worry about if I'm doing PHP the "right way". Using a framework prevents you from writing stupid code * Pagination is so easy to get working. What a massive time saver. * I recently started using database migrations - its version control for your database schema to go along with your GIT version control. Keeps changes to your DB from wrecking your app if your versions are not in sync * Numerous helpers to help you send emails, resize image uploads, create ZIP files, the list goes on * URI routing * Built-in caching. I use database caching a lot to prevent unnecessary database queries. You can do page caching too. * I'm sure I'm forgetting many things but these features make it all so worth it Now my app is beautifully organized, clean, high-performance, secure, and maintainable. I would have never been able to do that with just plain vanilla PHP. If I had to start over I would probably go with Laravel, but Codeigniter is still a great framework for what it is. If you are building a regular website, then a framework is useless. You're better off using a CMS like Wordpress. But if you are building an *application*, frameworks are indispensable. I agree about the Blade templates... I'm not on board with that yet. I just use regular PHP syntax in my views.
This seems like a security nightmare
Does the way you do templating allow inheritance? I think it's worth doing Blade just for that. &gt; If I had to start over I would probably go with Laravel, but Codeigniter is still a great framework for what it is. I partially agree. But Laravel uses Composer, namespacing, etc. Features that Codeigniter either doesn't use or doesn't enforce. I think it's worth using or rather learning Laravel now, just to have those skills under your belt. BTW, I'm not saying you should change to Laravel for these reasons. They're just reasons I would agree that it's probably a better choice for someone starting frameworks now.
I actually know what you were saying. That "best case" isn't always an option and sometimes business realities can affect decision-making. But there was the risk of it being misread to seem to be saying what I posted. :)
Why would you recommend Laravel instead of CodeIgniter? And how on earth does database migrations work? I just don't understand what it's supposed to be doing.
because you're exposing which open source packages on github/packagist your application is using?
maybe he needed some set operations (atomic) in his cache. i had to choose redis over memcached because of these, once.
I don't know how CodeIgniter's migrations work, but Laravel has the same process, so I'll explain that. Basically migrations are a class file that are generated generally by an artisan script or install script or something. `php artisan migrate:make` You then use the Laravel Schema builder to make changes to the database structure. Here's one I prepared earlier: 2013_12_29_115257_create_clients_table.php &lt;?php use Illuminate\Database\Migrations\Migration; use Illuminate\Database\Schema\Blueprint; class CreateClientsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create('clients', function(Blueprint $table) { $table-&gt;increments('id'); $table-&gt;string('name'); $table-&gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop('clients'); } } That should be relatively readable. Basically it's creating a clients table. You tell it what fields are needed and it will build the table. There are two "directions", up and down. Up is what happens when you run a migration, but it is possible to step back through migrations. "Down" is basically the undo option. Basically there's a database, which lists which migrations have been run. Any that have not are run when you run the command line `php artisan migrate`. The benefit of this is that this migration file is now version controlled too. Making the table on my live server is just a matter of going `php artisan migrate` there too. A later change to the table was needed. &lt;?php use Illuminate\Database\Migrations\Migration; use Illuminate\Database\Schema\Blueprint; class AddHashToClientsTable extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::table('clients', function(Blueprint $table) { $table-&gt;string('hash'); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::table('clients', function(Blueprint $table) { $table-&gt;dropColumn('hash'); }); } } Commit, push, and run `php artisan migrate` and you're gold. No faffing about with db dumps, version conflicts or forgetting to update the schema when you push a change live and having the whole effing thing break. You can even send data with it, using the related (sort of) "seed" functionality. I'm not sure how CI's migrations work, but I'd assume it's similar. 
I used to write spagetti code apps but now I moved to MVC frameworks. Started out with CI and now Laravel. Just do it man, the apps will get 100 times better/more secure and you will save so much time. 
I concede to this point. Thanks.
&gt; Frameworks, like Laravel, are considered best practice by everyone everywhere. Sadly not true. They should be, but there are still an awful lot of people defending bespoke production for a range of stupid reasons. :(
I would recommend Laravel mainly because Codeigniter's development has completely halted for the time being. It is no longer being updated. Laravel on the other hand is in very active development, and has many new modern features and has more new features on the way. I don't know exactly what all those features are and why I need them, but I'd rather be involved with an actively evolving framework rather than a dead one. Database migrations are like having different versions of your database schema, and you can go back and forth between versions. When you're developing an app, you have to build the database structure. But sometimes when you add a new feature, it requires a new table in the db, or a new column in a table, or you have to drop a column or change the data type of a column. Then you write new code to work with your new database structure. What if that new feature you're working on doesn't work and you have to go back to a previous version... WOOPS! What changes did I make to the db? What did it look like before? I can't remember. Now your app is broken. No problem! Just migrate back to the previous migration, and you have your old db structure back.
Yeah I was talking to a PHP dev who worked on Spain's version of Facebook, and I was asking him about frameworks. He said they don't use frameworks because they're too slow and bloated (he was referring to Symfony). Well, there are other options besides Symfony that are less bloated and less slow.
The template engine should help with validating input/output and generally have code for helping with xss. You can replicate this yourself but most who do have probably moved on to using frameworks.
Shorter version of migrations: You script changes to the database and the framework versions them. Each change should have an "up" script to make some change, and a "down" to roll back. The framework will only apply migrations that have not yet been applied. Basically: git pull, migrations:migrate, boom - database schema is up to date, even if your last command was drop db. Also, if you're using an ORM then you typically just update the object and migrations:generate to get the migrations to run (sql in a php class).
sigh, what they really mean is they don't understand caching and can't be bothered to learn something new. Opcodes + memory cache + varnish = Symfony is not slow. If the actual execution of a script mattered even a tiny bit, then no-one would be using interpreted languages.
At this point I'm only using SET/GET and HSET/HGET. Nothing really sophisticated I guess. I've also made caching optional and decoupled. At some point, if needed, I may also implement a Memcached version of my Cache interface. **btw**, thank you for giving me some insights on the atomic &amp; single threaded nature of Redis. I definitely need to better understand it even though I think I'm only using 2% of what Redis offers. :) 
But it does not matter if your framework executes in .1 ms or .5 ms, because it becomes insignificant when database communications can take much longer. So I am not sure what one gains by going through the extra trouble of setting up this extension and dealing with portability maintenance issues that comes with it.
L4
Not everyone uses Packagist :) That said there isn't much reason for me to share internal apps' depfiles. 
Just chiming in here to say I've successfully used Phalcon in commercial projects and it worked like a charm. It's so rounded up it needs almost no external libraries. That said, I'm looking forward to seeing how well it performs against HHVM 2.4. When considering only those two approaches, both have their downsides, but I think Phalcon wins for now because it gets installed into the default Zend Engine which supports other extensions, unlike HHVM (for now).
I started with cake due to it's name - but I didn't get too far. Then I did the ZF2 tutorial where I copied everything out line by line (or so I thought), but it didnt work. It was something I had missed as the official git repo of the tutorial did work. But I wasn't able to bug fix it whilst still learning it. Then I switched to Yii, which I now had a bit of additional knowledge which helped me click with. After making a smallish site in Yii, I switched to Laravel as reddit was big on it, so I figured something was good. I made a bigger site in Laravel. From there, learning Symfony was made easier, yet still challenging. I would not recommend Symfony or ZF2 to be the first framework developers work with - but I would suggest making one of them the target of their learning. The main thing is - build something with the framework, don't just learn it for learnings sake. 
&gt; [...] use the MVC model stolen from Rails. Just to be pedantic I, and presumably many other developers (PHP and otherwise), have been building MVC apps for far longer than rails has existed. It was one of the patterns that I studied as part of the Software Engineering/Software Design modules of my undergrad degree and has been around since the 70s, probably being one of the earliest recognised design patterns. 
I agree. It's so powerful, yet so fast. But it's only a text editor. For my development, I mainly use PhpStorm IDE.
Just programmers period.. I don't understand why you would tack on the open-source bit, especially when trying to describe a closed source program.
It doesn't go into much detail, but if you're looking for a quick overview, check [this](http://www.phpframeworks.com/) link out.
Great answer. Only thing I'd say is that you are missing the PHP tags from your example templates. Sounds trivial, but it does show up raw PHP templates to be quite ugly: // Raw PHP &lt;?php foreach ($users as $user) : ?&gt; &lt;p&gt;Hello &lt;?=htmlspecialchars($name)?&gt;&lt;/p&gt; &lt;?php endforeach; ?&gt; // Blade template @foreach ($users as $user) &lt;p&gt;Hello {{{ $name }}}&lt;/p&gt; @endforeach 
&gt;for starter's it's not free. You can use the [EAP version](http://confluence.jetbrains.com/display/PhpStorm/PhpStorm+Early+Access+Program) and beta test it for them. It's usually quite stable, and while it's got a limited lifetime, all you need to do to continue using PHPStorm is to upgrade to the latest EAP version (which buys you another 30 days). Rince and repeat once a month, and you can keep using PHPStorm indefinitely. &gt;It is slow It isn't for me, and I haven't experienced any of the issues you've described. Maybe it's just you..?
Sublime Text isn't free either.. *Feed their developers!*
The F12 button is freaking magic
Emacs and Vim users look on with disdain and bewilderment. A closed source, propriety, mediocre to "decent" text editor being heralded as the "best thing ever for open source"... WAT? EDIT: Additionally, if you want to pitch your editor as the "best thing ever" -- it would make sense to actually point out examples of useful things you can do with it. 
If you're talking about importing namespaces, yes it does. Write the beginning of the class/interface you want to import, and when you get an auto-completion suggestion, make sure the right one is selected, then press tab. 
&gt; 1. Auto complete doesn't know the variable type unless you use @var annotations everywhere. (Which we haven't done) You do realise PHP is a weakly typed language right? Unless you specifically tell it what type a variable should contain, how is the IDE ever going to know? 
Agreed. Why would I use an editor outside of a terminal when I already have my terminal open?
So. much. facepalm. http://i.imgur.com/qrCmj0W.jpg
&gt;Your PhpStorm evaluation has expired. Your session will be limited to 30 minutes. That's because you're not using the EAP license (or you're launching an old copy of PHPStorm). &gt;Auto complete doesn't know the variable type unless you use @var annotations everywhere. It knows the variable type if you: 1. specified the type of the parameter in the method signature 2. instantiated a class and assigned it to the variable 3. get the value from another method/function which has @return specified 4. specified the type of your properties. 5. specify @var when it can't resolve the type on its own. &gt;There is no way to organize imports meaning, I press a key and all classes get used like in Eclipse (with Java). I assume this is what you're after: https://www.jetbrains.com/phpstorm/webhelp/optimizing-imports.html &gt;There are a lot of things I do like, but it doesn't justify buying a 179 euro license for 3 people. PHPStorm is a cost that can be *easily* justified if you're using it in a commercial setting. The thing basically pays for itself. 
The problem you'll have with all articles is that they'll be opinionated. Even the better ones are to some degree. You're almost better off just to pick the most popular frameworks, consider your specific needs, build something simple with each, and then read articles to fill in the gaps in your experience.
PHP 5.5 was built with rocket engines. Phalcon are doing one thing wrong. Their public benchmark was run on PHP 5.3, a version reaching end of life very very soon. It's clearly outdated.
Like I said in the other thread, your use case doesn't make sense. This feature is only suitable for cleanup, which is why it only removes unused imports. Why do you need to import namespaces outside from doing it while writing the actual code? If you got missing imports then quick fix that shit.
hard to not disagree with invalid opinions
That's not a good assumption. Not every web application that uses PHP deals with highly cacheable data, not everyone's working on a CMS or a blog. Applications that need close-to-realtime reflections of freshness (APIs, ratings and reviews, analytics, even streams, etc) are important use cases. For these use cases, this is where companies are choosing to skip frameworks, even with extensive caching architectures.
Again, why? I don't understand the scenario in which you would need to do this. You already get the imports *while you are writing the code*, why do you want to wait and import them after the code has been written? And again, if your code is broken and is missing a namespace, quick fix it. 
Alt+Enter.
I'm not saying it's invalid, I said I can't imagine a use-case where you'd use such a mind-boggingly strange workflow when you can get imports instantly as you write the code. 
&gt;Because over 3000 files are already written? So? Do you mean to say that you have 3000 defunct files which you need to go and fix? If the files are working, I don't see what the problem is. If they're not, first of all, what the fuck, and secondly, use the inspect code feature and fix them. &gt;Because code might have been written by someone that doesn't use PHPStorm? So what? You mean you guys don't test the code at all before pushing against the repository?
&gt; If I can't have proper functioning auto complete I'd rather not have it at all. It's functioning perfectly assuming you supply it with the needed meta-data, by using PhpDoc. You *do* document your code, right? 
&gt;If you forget to add a use statement to your code it won't throw an error unless the code that uses the class is actually executed. You have a tab in PhpStorm which will list all problems detected by its lexer. That includes use statements. &gt;lack of a fuzzy search Like this? https://www.jetbrains.com/phpstorm/webhelp/navigating-to-class-file-or-symbol-by-name.html &gt;multi line typing It's planned for PhpStorm 8. 
No IDE or text editor will ever help you resolve something like that in a weakly typed environment. However, the issue is more likely to be architectural. I adhere to the SOLID principles and I rarely run into problems like these. The one situation I do run into it is with the IoC container, but that is easily remedied with a @var comment, which is fine. 
Someone who's asking for comparisons? Right on. My entire [benchmarking category](http://paul-m-jones.com/archives/category/benchmarks) is full of baseline comparisons, e.g. the [Labor Day benchmarks](http://paul-m-jones.com/archives/315) and where I "pass the torch" to the TechEmpower guys [here](http://paul-m-jones.com/archives/5863). Here's a series of three comparing [Aura](http://auraphp.com) with Symfony and Zend: &lt;http://paul-m-jones.com/archives/4152&gt;, &lt;http://paul-m-jones.com/archives/4176&gt;, &lt;http://paul-m-jones.com/archives/4263&gt;. (Not a fanboy, have experience as an author of parts of Zend Framework, as well as being lead on two others (Solar, Aura) and researching on more (Symfony 1 and 2, Cake, CodeIgniter, Lithium, etc.).)
Opinions are unavoidable. Writing an opinion-free article is simply not possible. The important thing is not that the article is free of opinion, but that the biases are stated clearly. Then each reader can judge which biases he favors, and thereafter which conclusions he agrees with.
Thanks for the heads up. I could use some brushing up. As a mostly .NET programmer, I am sure I don't "PHP the right way" and it bugs me sometimes. 
 /** @var Car[] $objCar */ foreach ($objSomething-&gt;getCollection('cars') as $objCar) { $objCar-&gt;(auto complete fails) }
After switching all my work processes to PHPstorm (rest api console, composer integration, git integration, unit testing) I cannot go back to sublime. Once you go full IDE, you never want to go back to a glorified text editor
I would start with CakePHP and then jump to Symfony. Cake is easier to pick up. If you want something lighter then go for Silex.
This sounds similar to something I used to do before... I would record my SQL sessions on the test server and copy the commands I wanted to apply to a .sql file. Rollback the test database and test the sql file. If it works, push to production and run the sql file. I also had sql files for database and table creation, as well as seed data so that if I needed to create a complete virgin copy of the website without data, I could. I can see that migrations might be a safer way of initializing and modifying a database, but I still need to `php artisan migrate` after a push (which I might forget to do), I still need to `db_dump` on cron for backups, and those dumps could still have version conflicts (especially between test and production server). Right?
Isn't Laravel's development driven by essentially one person? It could suddenly stop being maintained, too, right? Or are there enough people behind it now that it probably won't? This probably shouldn't be a concern for me anyway... I think I understand your explanation of migrations. For every db modification, I'm forced to write some code that can undo it so that I can go back and forth with changes to the database structure without losing the data contained in it. Since I would be writing the migrations on the test database, I can make sure the migrations work perfectly before pushing live. Why can't I just accomplish this by writing a file with relevant SQL commands for the updates and putting those in the repository?
Why not just use SQL scripts then? Also if I dropped db, then the data it contained is lost, right? I'd need to restore from a prior db dump.
A good template system will also allow for code reuse by implementing partials that you can call from within a template. Here's how its done in [Twig](http://symfony.com/doc/current/book/templating.html#including-other-templates), [Aura PHP Views](http://auraphp.com/packages/Aura.View/1.2.1/), Laravel calls them [Sub Views](http://laravel.com/docs/templates), and Zend Framework uses a [Partials Helper](http://framework.zend.com/manual/2.1/en/modules/zend.view.helpers.partial.html)
If you have need for interacting with social media in your framework / app, then I'd suggest taking a look at the social components found in the Joomla Framework. We have really good coverage of most of the popular networks. - GitHub - https://github.com/joomla/joomla-framework/tree/staging/src/Joomla/Github - Facebook - https://github.com/joomla/joomla-framework/tree/staging/src/Joomla/Facebook - Twitter - https://github.com/joomla/joomla-framework/tree/staging/src/Joomla/Twitter
Yii is a PHP-FIG member, and has been since about Q3 last year. Source: I'm also a FIG member, representing Joomla
For a text editor, it takes quite a lot to load (At least on my computer), so i couldn't migrate from PhpStorm
I would recommend focusing some time on your soft skills. 
Small note: Magento runs much faster on HHVM. Maybe you can consider that.
Liferay. Open source - best EC platform out there. 
Smalltalk was the first, not Rails. 
Thanks, but it's not PHP :(
Umm, gotta try it out, but i'm not sure if i'll be able to install HHVM on our production server, since we have other projects there. Thanks!
Downvoters: how come?
Magento really needs its own server, either VM or bare metal.
Best today for serious applications is: Laravel, Symfony, Zend. They all good, just try everything it's not hard.
Since i know both of them, i can tell you. &gt; Does PHP work better than Python in areas? PHP have much more CMS systems and they are very mature, but Python beats PHP at frameworks, testing, web scrapping. &gt; Can they do the same? Sure &gt; What do they do best? well that's hard to tell, but PHP is only good at web development (especially CMS oriented web), Python is more all-around language it have nice binding for Qt, better frameworks for web development, it is a de-facto scripting language in many applications, it's having very nice software for system manage (ansible, salt, fabric, etc) &gt; Which is better to learn? Python, it is having much more mature infrastructure and many courses from academic grade institutions (udacity, coursera, edx, etc), it is easier to understand and more "right", but PHP maybe better to learn depends on your region, in my region there is many work for PHP, so learn both
http://www.techempower.com/benchmarks/ It's not just PHP frameworks but PHP frameworks are included.
You may want to look into RedHat's [OpenShift](https://www.openshift.com). Even though Redis is not listed under [supported technologies](https://www.openshift.com/developers/technologies) you may [install](https://www.openshift.com/blogs/enabling-redis-for-your-app) it from a custom cartridge. That's what I did.
Is this the same thing as the website or does it have some schanges?
I have my own server, but there are other things in it (They're small php sites)
It looks like it's the same as the website, you can read it online: https://leanpub.com/phptherightway/read
It's the exact same thing, for now, as confirmed by Phil Sturgeon here: http://www.sitepoint.com/php-right-way-book/
The tool that you use to (hopefully) make a decent salary isn't worth paying $200 USD for?
Sitepoint has one "Best PHP Frameworks for 2014" http://www.sitepoint.com/best-php-frameworks-2014/ . &gt; The problem you'll have with all articles is that they'll be opinionated. And I agree with /u/padraicb and /u/pmjones &gt; Opinions are unavoidable .
This article is... kinda nonsense. One script per page is not equivalent to a front controller, router &amp; dispatcher; by _definition_ the front controller is a single entry point for your application. More than that, if your controller is satisfying it's own dependencies it does not achieve appropriate separation of concerns; this leaves it more brittle when it comes to change, more difficult to test &amp; very difficult to compose (eg subrequests).
&gt;One script per page is not equivalent to a front controller, router &amp; dispatcher; by definition the front controller is a single entry point for your application. From the article: &gt; The web server itself becomes a simplifed front controller+router+dispatcher, picking the “controller” (page script) to run based on the URL path mapped to the file system. In this exercise, we think of the *server* performing those functions, not the page script.
Hey try the DynamicReturnType plugin. Thank me later! 
Oh, I understood what was written - what i'm saying is that the fact the server is preforming these functions means that they are by definition not equivalent, either functionally or conceptually. Again, a trivial example is the difficulty of handling sub-requests (without using something like Guzzle to _literally_ make a new request) in an application that does not have a front-controller.
You should take a look at [OpenCart](http://www.opencart.com/). It's very easy to use, and it can handle a lot of products ( we have now more than 35.000 products, and with [some](https://www.opencart.com/index.php?route=account/download/info&amp;order_id=326910) [extensions](https://www.opencart.com/index.php?route=account/download/info&amp;order_id=405488), you can make it even faster )...
Good point. Yeah I suppose Laravel could halt development at any point too. Yes you can totally write your own SQL commands into a PHP file and run it to update your schema. I think the only extra thing that migrations give you is the ability to go from any version of the DB to any other version. Say you're on version 7 and you need to go back to version 4. Or you have an old installation on version 2 and you need to bring it up to version 7. Each version is a separate PHP file with SQL commands in it, and the migrations system just runs each one sequentially until you get to the right version. You could totally build your own thing that does that. Codeigniter already has it for your convenience. One more benefit of a framework: when you bring other devs onto your project they're more likely to be familiar with a framework than with your custom code so they can hit the ground running rather than having to spend time getting familiar with the way you coded your app. If I had to maintain someone else's Codeingiter app, I already know where to look for everything before even looking at the code.
Yeah I just run a shitty little PHP script now and then to update things based on the web content, and it does some regex. I'm considering pulling in some of the wiki content and whatnot too, but I'm not trying to make this into a different resource, just a different format for those who want it on their kindle for plane journeys.
Yes and therefore you expose yourself to any security risks in those packages. As an attacker this means all I have to do is find a security hole in one of these projects, scrape this site for who is using it and then I've got myself a zombie server herd to command.
&gt; a trivial example is the difficulty of handling sub-requests /me nods We do have to remember that we are talking about legacy page-based applications here, thus the caveats of "degenerate" and "simplified". Sub-requests of the kind you are talking about are not generally part of that kind of architecture. In this kind of setup, the only way to perform a sub-request of the kind you talk about would only be possible with an actual secondary HTTP request against the server, thus passing through (again) the simplified versions of a front-controller/router/dispatcher.
I think I threw up a little.
Fair enough, I guess I caught onto the terminology used without considering in in the wider context within which it was presented. 
I use open cart as well with no problems. 
I didn't know you could edit the test, so I did and it seems I cannot go back to your original code. Anyway, it seems `strtotime` returns different results in each PHP version. I bet it has to do with the format of the string. Edit: this is the code http://3v4l.org/fAilW &lt;?php echo var_dump(strtotime("February")) . ' ' . date('F',strtotime("February"));
strtotime() only added correct support for parsing "February" in 5.2. Before that, it returned an error saying it couldn't parse it. For 5.1, the handling of an unparsable returned FALSE whereas previously it returned -1. Now for date(), it takes the timestamp so 5.2+ works as expected since it's the correct timestamp. For the others, it's using an incorrect timestamp (0 and -1) around the unix timestamp epoch "01 Januaray 1970" which is when the timestamp is zero 0. 5.1 is zero because FALSE is loosly equivalent and caste to 0 in such false == 0 is true, but false === 0 is false. So what you have is the evaluation of date("F", 0) for 5.1 and date("F", -1) for &lt;5.1. Since the epoch is 1 Jan 1970, 0 would return "January" and -1 would be 1 second before 1 Jan 1970, 31 Dec 1969, so would return "December". More info can be found in its [Changelog](http://us1.php.net/strtotime)
i dont even ... 
[Sylius](http://sylius.org/) is gaining traction in the Symfony world and seems interesting, take a look. And of course, you can always give Commerce another chance now that you're not externalizing the development and know which mistakes to avoid. It's an option to consider. (Disclaimer: I'm a Commerce dev)
It's an interesting concept but he's final thoughts give the impression it's more theoretical than practical. Would be great to see it over a range of differing images so we can judge just how good it is.
FYI reddit themselves use(d) a variant of this for all thumbnails.
I wonder if there would be a way to add a threshold, where the image would just default to a center crop if there wasn't a clear-cut area in the image to choose.
Valid, still going to share with the PHP community.
I've got to say that I find that incredibly untrue. There's no way on this good earth that you can knock out something even close to magento in a short period of time, nor do I believe it's possible to develop an entire ecommerce platform in the time that it typically takes to configure a magento installation. Magento tries to be a jack of all trades with regards to ecommerce, and it's packing a lot of features which cause it to be far heavier than a bespoke system. I admittedly last looked at the magento platform a few years back now, so I'm sure it's better than it was (I believe it was about to get a rewrite the last I saw of it), but in any case, if you're unable to throw the tens of thousands of pounds required to have a bespoke platform built, then magento is a really good plan b. Yes, you'll want to tinker with it, but to be honest something like HVHM seems like it should speed up magento to a point whereby you shouldn't need to get neck-deep in source code. That said, this question is hard to answer without knowing roughly how many orders you're taking a day, and how many concurrent users you have as this is where you'll start to see the bottlenecks. When you're looking at dozens of requests per second, magento isn't going to hold up too well, but that's largely down to the infrastructure as much as anything else, but it'll be fine for a smaller site. Besides, if you're getting dozens of requests per second and plenty of orders, this question likely wouldn't be asked, as there'd be a custom platform in place anyway. My point here really is that magento (and other off the shelf packages) are fine to get you started with, and the only worry you have is data exporting if and when you outgrow the platform you're on. Get Google analytics in there early and monitor performance, and you'll see when it's starting to stick. If you have a good server admin, they'll find out where your bottlenecks are so you can concentrate on those. Trying to rush something on the cheap to rival something which has taken years upon years to perfect is asking for trouble. You'll likely have poor performance and bugs, or worse security holes, and it's really not worth it. Either spend the money to do it right or don't, but don't half-arse something that's going to be dealing with money is all I'll say there. Source... Half a decade of ecommerce experience, having witnessed both sides of this particular coin. I personally believe that if you can go custom, do it early, as it's easier to maintain later on, but if you can't, don't be scared to go off the shelf. 
This totally explains it.
+1. /u/nikic is crushing it. I wonder how many years it will take the PHP community to realize the power of the generators he added in 5.5 ... *that's* bananas.
 $dbal = new DBAL(); $driver = new SessionDrive(); $drive-&gt;setDatabase($dbal); $session = new Session($driver); 
It is "SQL scripts", with a bonus that they are versioned, only run when necessary, and should provide down migrations as well. Auto generating them from an ORM is a huge bonus as well, but technically not part of migrations. &gt;I'd need to restore from a prior db dump Only if you need the production dataset, you might be just deploying to a test environment with fixtures. Drop DB isn't something you do a lot, I just mentioned it for illustration.
 $driver = new MagicalSessionDriver(); $session = new Session($driver); You should not be instantiating the driver inside session. You should be injecting an instance of SessionDriver into the session. The Session should have zero-knowledge of the creation of the driver. All it should care about is that it is getting an object that implements the SessionDriver interface. I agree with Baileylo's example. This works for multiple driver types.
Having www-data do it might end up becoming a security risk.
I'm running Magento on Webfaction with Nginx + PHP-FPM, 768MB of RAM, 8-core processor, and I'll tell you what: it's pretty damn fast. Great thing about WebFaction is that you don't manage the server, it's about as close to having your own box as you can get, but w/o all the sysadmin nastiness (give it up for the SA's! I don't want your job...). Anyway, I've come around to the idea that Magento can be pretty awesome, it just needs a reasonably decent environment. WF has a nice setup, but I'm sure there's other shared hosts out there that can support a snappy Magento site. Other benefits include a large ecosystem of free/paid plugins (things you wouldn't think that you needed, like shipping tools, inventory integration, Quickbooks integration, etc), large community of fellow users, large(r) pool of developers to help you out over the years. Considering the size of the catalog, I'd say you should start from the position of "what's going to integrate with our existing inventory/sales software?" If Magento has some plugins to bridge that gap, I'd be all over it.
what do they use now?
Create a library...
Volusion!
exactly. that's why a sweeping assumption that people who complain about slow frameworks don't understand caching is neither good nor fair. thanks for proving my point?
I assume the user is the customer and the customer is always right. So I just put whatever the user says straight into my database. That having been said, when I was looking at input validation for my company I checked out a couple different libraries * [Zend Validator](http://framework.zend.com/manual/2.0/en/modules/zend.validator.set.html) * [Symfony Validation](http://symfony.com/doc/current/book/validation.html) * [Aura Input](http://auraphp.com/packages/Aura.Input/) * [Laravel Valdation](http://laravel.com/docs/validation) * [Respect Validation](https://github.com/Respect/Validation) I eventually decided to go with Laravel. I'd say that is a pretty comprehensive list of the validators that most new sites will probably use. You can also try [php's array_filter](http://php.net/array_filter). As for best practices? 1. Never trust user data, validate everything. 2. Use prepared statements went saving data to the database, see mysqli or pdo. 3. Escape any data a user can manipulate when displaying it, check html_encode.
Interesting! So instead of having a function that populates echoed html, I should be doing this: **/templates/_itemsInList.php** *Contents* &lt;div class="style"&gt; &lt;div&gt;&lt;?= $variable ?&gt;&lt;/div&gt; &lt;/div? And then including it in the loop, passing it information from the returned mysqli query object. So: function list(){ //database stuff to get info, putting it in to a while loop with $row as key while($row = $result-&gt;fetch_assoc()) $this-&gt;box($row['variable '); } And having the *$box($variable)* function: function box($variable){ //a bunch of logic to clean up the variable include '/templates/_itemsInList.php'; } This way my controller logic isn't echoing html, and view can be updated in a easy and unified way. Am I going wrong anywhere? is **include** the way to go?
It works. You'll hate yourself forever and burn in developer hell, but it works. Sometimes. Kinda.
SOAP + SSL? Immediately proceed to replace the internal _doRequest() method with a CURL request instead. PHP's internal handling of SOAP over SSL is pretty awful for a lot of edge cases which you're going to run into. Client certs, older systems your talking to not quite working right, TLS versions that PHP doesn't quite agree with, timeouts, etc, etc. The list goes on -- curl solves all of these much better, with error messages that make far more sense and (most importantly) is *much* easier to debug. I see the comment else where showing how to override this -- use it, you'll save some much hair on your head.
We're talking about web frameworks, it's not a "sweeping assumption" that people are, in general, using them to build cacheable web apps. The web is latent by nature. Load a rating and review and half a nano second later someone just voted and submitted another, meaning your data will be out of date for the next 5 minutes while you read the review. Is it crucial that the rating updates in real time to change from 5.01 to 5.02? Likewise for API's and analytics. On top of that you're ignoring that you can still cache most of a page and then update more time critical data via an ESI, or ajax. At which point your "slow bloat" is competing with network/fs latency, which is orders of magnitude larger making the whole argument that whatever framework is too slow moot.
y u no composer
Sounds like you're trying to make a [package](http://laravel.com/docs/packages)
This gave me an amazing idea. Thanks!
&gt; For example, static calls It's the Laravel way as far as I can tell. 
By far the easiest way to get running with newer versions of PHP and various PHP modules but...is this really submission worthy?
network/fs latency in PHP does not compete with framework overhead. all latency introduced at any point stacks on top of each other. in applications where you get a high volume of user data that needs to reflect back to your application, you can have a very good cache hit rate of 99% but the remaining 1% misses could be very big depending on your traffic. the heavier your back-end, the more expensive your cache hits become. you need to pay attention to those misses. ESIs and partial ajax fetches call your back-end which runs on PHP. the very existance of those work-arounds/features prove that not everything can be stale/come from cache all the time. so no, saying that "people who think frameworks are slow don't understand caching" is not good/not fair.
Symfony2? Zend? By far the most complex of the frameworks, with their architecture akin to Java. They are always dead last in the TechEmpower benchmarks. http://www.techempower.com/benchmarks/#section=data-r8&amp;hw=i7&amp;test=json&amp;l=sg
I usually used xampp in the past and these days use vagrant but the fact that the brew was not part of the "normal" homebrew repo kind of made me a little wary. So it's probably a decent way to vouch for its bonafides. 
Any reason why you're not using a [session handler](http://www.php.net/manual/en/class.sessionhandler.php)? 
Well, then you just had some bad luck. I've had to create some extensions ( very specific ) for my client, and if you ( the developer ) follow just the common way of implementing things to the front - and - back-end of the site, then there isn't any problem. You just select in the back-end where you wan't to display it ( footer, or content-left/right ) and that's it. The only thing that you maybe have to do, is to change the view of that extension, so that it looks nicer, that's all... And most of the extensions are designed by this way. Just some people doesn't care about it, which is a shame...
Do you have some actual data to support your claim that Symfony is too slow (don't mean to put words) for some application? Perhaps you've worked on a project where you found removing Symfony and going bespoke gave significant gains that couldn't be compensated for elsewhere? I would really be interested in that data if you have it. To reply to your points: &gt; network/fs latency in PHP does not compete with framework overhead Of course it does, you're talking micro optimizations. What is the actual bloat overhead? It's microseconds vs milliseconds competing for developer/hardware resource. &gt;you need to pay attention to those misses You're not really saying anything concrete. Of course you do, but you will see a gain by adding a web server vs an alternate gain by having your developers construct some bespoke system that needs to be documented, taught to every new developer, audited, etc, etc. It's a trade off of productivity (and security) vs performance and the performance gain is absolutely trivial when compared to the entire stack. &gt;ESIs and partial ajax fetches call your back-end which runs on PHP The point was that you still leverage a large amount from caching. Deal with your edge cases when you need to, don't design the entire framework around them.
This is true.
i've run this over about 4000 images, mostly concert-photos, also a set of wedding, portrait and landscape photos. i've run centercrop, balanced and entropy, always a square crop from a 4:3 ore 3:4 image. sadly i did not manae it to get face-recognition up and running. my experience: faces have no entropy! i've almost always got images cropd throu the faces to get a chair, a guitar, grass or something else... balanced did a greater job for a lot of images but then again the pictures i've used are nt a valid set of generic images...
Thanks for the tip :). I was wondering however, is there anyway to know when this was last updated? the last comment is from 2012 so I'm just curious if the source is still up to date? 
Easier to use a virtual machine, then you can continue to use your mac to develop while using a server configured linux or unix to run the code. I doubt most people will use a mac as a server deployment target for production anyway, and it's better to develop to specs that are as close to your deployment target as possible.
If you honestly believe that you have a lot to learn.
You should think of a way to abstract these things. Basically you need to be able to define your models and create some way for a form to be generated based on the model' specs. This way you could reuse the slider module so that it does not depend on the existance of specific fields. Similarly, your category module may have an additional table called "category_meta" (check Wordpress database architecture) so that you can add additional fields on per project basis.
for one, applications that are not view-heavy -- write-heavy apps like APIs, beacons, data collection. applications of this type rely heavily on throughput. it's a case where being able to serve 100 rps vs 2000 rps matters. we can always throw more money on it and fire up more instances, but that depends on what resources are available to you and your company. developers are expensive because they are expected to make sensible decisions and maximize profits down the line. again, that depends on priorities -- time-to-market, cost of operations, system stability, etc. with regards to the added overhead being negligible compared to other parts of the system, the problem is you can't take and evaluate overhead piece by piece. you can't say your application is okay because out of the 1 or 2 second delay, just 200ms is caused by some slow moving part. cache misses are not edge cases, and so is the need to have updated data.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Seam carving**](http://en.wikipedia.org/wiki/Seam%20carving): --- &gt;**Seam carving** (also known as **image retargeting**, **content-aware image resizing**, **content-aware scaling**, **liquid resizing**, or **liquid rescaling**), is an algorithm for [image resizing](http://en.wikipedia.org/wiki/Image_scaling), developed by [Shai Avidan](/w/index.php?title=Shai_Avidan&amp;action=edit&amp;redlink=1), of [Mitsubishi Electric Research Laboratories](http://en.wikipedia.org/wiki/Mitsubishi_Electric_Research_Laboratories) (MERL), and [Ariel Shamir](/w/index.php?title=Ariel_Shamir&amp;action=edit&amp;redlink=1), of the [Interdisciplinary Center](http://en.wikipedia.org/wiki/Interdisciplinary_Center) and MERL. It functions by establishing a number of seams (paths of least importance) in an image and automatically removes seams to reduce image size or inserts seams to extend it. Seam carving also allows manually defining areas in which pixels may not be modified, and features the ability to remove whole objects from photographs. The purpose of the algorithm is to display images without distortion on various media (cell phones, PDAs) using document standards, like HTML, that already support dynamic changes in page layout and text, but not images. &gt;==== &gt;[**Image**](http://i.imgur.com/5dMVxL6.jpg) [^(i)](http://commons.wikimedia.org/wiki/File:Broadway_tower_edit.jpg) - *Original image* --- ^Interesting: [^Inpainting](http://en.wikipedia.org/wiki/Inpainting) ^| [^Texture ^synthesis](http://en.wikipedia.org/wiki/Texture_synthesis) ^| [^Image ^scaling](http://en.wikipedia.org/wiki/Image_scaling) *^\/u/alganet ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/wiki/modfaqs) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 42982:%0Ahttp://www.reddit.com/r/PHP/comments/1wwhon/cropping_images_in_php_based_on_their_entropy/cf6omty)
Using a container has nothing to do with doing Dependency Injection correctly. Your suggestion is good however: class Session { public function __construct(SessionDriver $driver) { ... } } But using a container is absolutely not a requirement.
Probably because he's spelling it as "sanitised"... you know.. the correct spelling. :P
The weird thing about this is "framework" is so hard to define that it's very hard to argue against this sort of statement. I'm not trying to say that Wordpress **is** a framework, just that defining it in such a way that it doesn't look like special pleading is a difficult thing to do. There are a few words like that - *religion* and *art* also jump to mind. Any useful definitions are either too strict, and omit valid options, or too loose and allow things that really shouldn't fit. The best you can do is some sort of "tends to have this" and "is aiming to do that", but it's all a bit vague and subjective. At least we have that option to just point and laugh, though. This is my favourite bit: &gt; WordPress is by no means a drop-in replacement for other frameworks, but makes for a decent alternative, providing most, if not all features covered by already popular frameworks. Errr... No.
I think we woefully misuse the term "works" sometimes, to mask a range of sins.
You're still not saying anything solid. Sorry, I am telling you that the bloat you think comes hand in hand with a framework is probably 10 microseconds of execution time in a 100+ millisecond request. If you optimize that by an order of magnitude you have successfully speeded up the app by 0.00009%. You mention a write-heavy app. Are you aware how much more overhead is involved in writing to a persistent data store vs executing in memory scripts? Unless you have some data to support your argument you are exactly the person that was described at the beginning of this thread: refuses to use frameworks because of bloat but can't demonstrate ill effects of bloat. 
The thing is, real world uses of `strtotime("month")` are pretty scarce, if at all existent. When would you use that? And why would you parse only the current month in strtotime? Wouldn't you want to cover a more exact date, at least with a day and year? And if you don't normalize your dates, that's bad practice because you need things to be consistent.
Wordpress :(
Try this: www-data ALL=NOPASSWD: /etc/init.d/isc-dhcp-server then you do: sudo /etc/init.d/isc-dhcp-server restart from PHP script which run by www-data user
I was just looking into this the other day. Here's some info from the composer documentation: https://getcomposer.org/doc/05-repositories.md#using-private-repositories
I've recently been working on a project where the previous cowboy developers had used wordpress as a framework. The client had spent £500,000 with them and had hardly anything to show for it. Needless to say, we're starting from scratch with Symfony 2.
Why no GD variant?
FYI A good resource that actually tells you how to address the specific "legacy application" issues that you see in that paste bin code can be found at Laracasts, a tut site by Jeffrey Way. Specifically, watch his "Coding with Intent" video - https://laracasts.com/lessons/coding-with-intent Note: It's $9 / month, but if you're coding in Laravel regularly, it's a great investment, and the videos are short enough you could get through them all in a month and then cancel if you really wanted to.
Are you wanting to know best practices of _how_ to validate? or more as in _where_ to validate? For the how, /u/baileylo outlined it pretty well. As for the where, I'm a fan of putting input validation in the models themselves, so that every time the model is accessed or added to, it also processes the validation logic. Jeffrey Way outlines this nicely in his video "Coding with Intent" https://laracasts.com/lessons/coding-with-intent
If you're looking at writing all the PHP yourself, have a look at this: http://be2.php.net/manual/en/function.filter-input.php It's the function that's at the basis of many of the larger libraries.
Thought the same thing honestly. 
Yes it is.
This seems like the kind of problem that PHP is really not suited to solve. Seems like a prime SaaS opportunity, so I did a little searching and the offerings from these guys are really impressive: http://imagga.com/
Neat! I was thining of writing a super simple API doc generator for my own projects but may just use this instead.
Yeah this book is part English, part American, and lots of other.
I'm running it in Safari no problem.
This looks great. I've been writing PHP for years and have yet to encounter a doc generator I was personally happy with out of the box. Question: *Does it have the ability to optionally hide things with non-public accessibility?*
That's a good point, it doesn't at the moment but I can see it being a valid requirement when you need to swear at clients or project managers without it turning up in the API docs. I'll have a think about the best way to cover this.
Controllers do things. Models know things. Views show things.
MVC is a design pattern that keeps your code organized and is easy for team management. View is the CSS and HTML, so a web designer can do this part without fiddling with much php code Model is the data, this is where the queries are made to the database Controller is where the business logic is done, such as parsing a string or if blocks.
That's a bit of an oversimplification. Controllers doing "things" is a bit broad. One could interpret that as "we put all logic in the controller and use models as plain data sources." Models are actually the core of MVC. All application 'intelligence' should be in your model. Controllers can change the state of a model, or perform a certain action. A model modifies the data it manages using that state change or action. The view then independently from the controller goes to the model to fetch the data it needs to present it to the user.
[This always made sense to me.](http://nuts-and-bolts-of-cakephp.com/2009/01/06/another-way-to-think-about-mvc/)
I totally agree, but OP asked for ELI5, so that's what they got.
C# and I suspect other languages are the same. "Private" is private to the class, not the instance.
Spam Spam Spam
yea, I just checked and its how Java works too. Its not that PHP is doing it WRONG, it just seems counter-intuitive and I thought mentioning it would be helpful. :)
check out /r/dailyprogrammer
This is a horrible tutorial that is EXPLOITABLE via [email injection](http://www.securephpwiki.com/index.php/Email_Injection). DO NOT USE THIS TUTORIAL. Use something like [Swift Mailer](http://swiftmailer.org/) instead, which will protect you from email injection techniques.
MVC is an approach at creating a separation of concerns in software projects. http://en.wikipedia.org/wiki/Separation_of_concerns When you write a program where all the parts are intimately entangled with each other, it is hard to make a change in one place that does not effect code in another place. By separating out the code into different domains, and by having a standardized way of communicating between those domains, you make it much easier to change and alter code without breaking things. It also allows for an organization that makes finding the code you need to change easier. 
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Separation of concerns**](http://en.wikipedia.org/wiki/Separation%20of%20concerns): --- &gt;In [computer science](http://en.wikipedia.org/wiki/Computer_science), **separation of concerns** (**SoC**) is a design principle for separating a [computer program](http://en.wikipedia.org/wiki/Computer_program) into distinct sections, such that each section addresses a separate [concern](http://en.wikipedia.org/wiki/Concern_(computer_science\)). A concern is a set of information that affects the code of a computer program. A concern can be as general as the details of the hardware the code is being optimized for, or as specific as the name of a class to instantiate. A program that embodies SoC well is called a [modular](http://en.wikipedia.org/wiki/Modularity_(programming\)) program. Modularity, and hence separation of concerns, is achieved by [encapsulating](http://en.wikipedia.org/wiki/Encapsulation_(computer_science\)) information inside a section of code that has a well defined interface. Encapsulation is a means of [information hiding](http://en.wikipedia.org/wiki/Information_hiding). Layered designs in information systems are another embodiment of separation of concerns (e.g., presentation layer, business logic layer, data access layer, persistence layer). &gt; --- ^Interesting: [^Subject-oriented ^programming](http://en.wikipedia.org/wiki/Subject-oriented_programming) ^| [^Modular ^programming](http://en.wikipedia.org/wiki/Modular_programming) ^| [^Aspect-oriented ^software ^development](http://en.wikipedia.org/wiki/Aspect-oriented_software_development) ^| [^Concern ^\(computer ^science)](http://en.wikipedia.org/wiki/Concern_\(computer_science\)) *^\/u/BucketHarmony ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 43412:%0Ahttp://www.reddit.com/r/PHP/comments/1wzuea/please_eli5_what_mvc_is/cf6wwkh)
yes
Yes, the verbosity of classes, abstracts, interfaces, design patterns, bundles, what have you, are akin to the verbosity of Java's class architecture. Symfony2's configuration layer is similar to Java/Spring XML configurations. Etc, etc. And by complex, I mean the amount of code it takes to complete certain tasks, some of which are pretty simple. It's entirely possible to get things done without multiple layers of abstraction, most of which are not necessary part of the time. It's also part personal preference, as I prefer more lightweight libraries.
This is pretty fantastic, great job!
When people first started building websites with PHP it was a mess. Different types of code would go into the same files. * Connecting to your database * Fetching lists of posts, or comments * Headers, CSS, Tables, text, everything It was a complete mess! People started separating things out to make this less gross. Presentation layers like Smarty popped up, to take the "Presentation" layer out of this mess, and make it separate. This could also be considered a "View". That was a nice start, but meant that there was still a lot of logic mixed in together. Frameworks popped up implementing what they called MVC, with a presentation/view layer they split the remaining code into Models and Controllers. Basically they suggest that anything to do with data interaction should go into their own structure, which is usually class. With M and V in their own files, this only left C. C ends up being a dumping ground for all sorts of stuff, which could be moved into other components. "ViewPresenters" or "ViewModels" help you prepare data for the view without doing it all in your controller. M can be split into "Business Logic" (sometimes called "Domain" code) and "Respositories" (which specifically interact with a MySQL database, or Mongo, etc, hidden behind a Repository Interface). MVC is the very basic requirements of not making clusterfuck code, then you need to read some design pattern books or just fudge things along for a decade to learn how to make it cleaner. I'm constantly finding new ways to pull bits of code out into their own layer, and now my architecture is more like MTVFCDOEM... or something. 
I think you misread the post. Final simply disallows redefining the property or method, it doesn't change its accessibility/visibility.
So... a less intense version of /r/dailyprogrammer ?
Woah... you just blew my mind. I didn't expect Java and C# to do this, just figured it was a lazy/wrong implementation. But no, it's right, valid, and other, very real OO languages use it... sweet, TIL too (I already knew you could do this).
http://emr.ge/manual/models http://emr.ge/manual/controllers http://emr.ge/manual/views Hope that helps
Is the last part sarcasm or are you saying that you already knew PHP could do that but not Java and C#?
Should have said ELI10 if he wanted the other explanation.
Not sarcastic, I already knew PHP did this, did not know Java/C# did it. So I learned its valid and other languages do it too, basically.
Ah, ok. :) Yea, I'm glad it helped you too, then. Pretty crazy, right?
Break down an application into three parts: * The data * The logic * The part the user sees **Models** are the part of the program that deals with the *data* **Controllers** are the *logic* part of the program. They ask for stuff from **models**, generally they process it, and pass it in a tangible form to the **view** and vice versa. **Views** take this and display it to the user. ---- **Analogy** Think of your program like a car. You could either build the car as one big specialised piece of equipment. Overall, this may result in better performance (think Lamborghini) however, it will be very expensive and take a lot of time. Now, you could, say, build the car as separate parts, e.g the *Bodywork*, the *Engine*, the *Fuel tank*, etc. By making all these parts separately, you can then, for example, take the engine, and put it in a different body, or have the same bodywork but multiple different engine options. By developing each part separately, you're enforcing a modular way of looking at things and abstracting it away from the end product. Engine development can be better for each engine because it is re-used in multiple end products. ---- I hope this helps!
Yea! I always thought this was the oddest behavior ever and it seemed so... *wrong* to me, like dirty to do this. Knowing Java does this makes it really clear why PHP does it, and I feel much less dirty about this. I can accept that, Java and C# are some of the top OO languages in my mind (that don't use Smalltalk style classes), so I respect their decisions, a lot.
Yea, it seems so strange and should just be disallowed, but I guess I always just thought of "private" as describing the instance and not the class itself. And yea, Java/C# are great examples of classical inheritance in a language.
We do this at work and I highly recommend it for continuous deployment. However lately I've stumbled on an issue though. If you have lots of cli file watchers for example for your frontend CSS and coffeescript then it's better to install those command line tools on your Mac. NFS is fast, but it's just not fast enough for those file batch tasks. If only it were, then we could completely chef/puppet our dev machines...
 &lt;?php class Foo { private $name; public function __construct($name) { $this-&gt;name = $name; } public function getNameFrom(Foo $foo) { return $foo-&gt;name; } } class Bar extends Foo { private $name; public function __construct($number) { parent::__construct("derp"); $this-&gt;name = $number; } } $foo = new Foo("foo"); $bar = new Bar(42); echo $foo-&gt;getNameFrom($bar), "\n"; var_export($bar); output: derp Bar::__set_state(array( 'name' =&gt; 42, 'name' =&gt; 'derp', )) Magic!
I'm with you, I always considered private as describing the instance too, or applying on the instance level, not the class level. I guess this makes sense. Made me wonder about `protected` though, apparently, with `protected`, it's like `private`, but the parent class also has access to the new protected properties/methods added in the subclass.
I would love to know why multiple people downvoted you.
Interesting – never knew about this sub; but browsing through them, a lot of them are impractical for PHP, and a lot of the discussions are talking about other languages. I think it'd still be nice to have a PHP specific challenge.
Me too :/ Maybe it wasn't ELI5 enough
Yep, there is the original definition of MVC and the definition of MVC in regards to PHP programming. I figured in /r/php, the OP would want the latter.
I'd disagree with the idea that the model should be the core of the application (though I had this view for a long time). You aren't limited to just models, views, and controllers in an MVC application. For complex logic cases, I prefer to have service classes that handle the heavy lifting.
"but MVC is the best" -- kill me naow
I'd love to know who you're quoting so I can make sure that *they* are killed naow.
Well , i would like this, because php is just a totally different language, and thus it would be nice to have those challenges
If you're curious, check out this tutorial that compares old-school PHP to using a framework like Symfony: http://symfony.com/doc/master/book/from_flat_php_to_symfony2.html
&gt; Yes, the verbosity of classes, abstracts, interfaces, design patterns, bundles, what have you, are akin to the verbosity of Java's class architecture again, you make the mistake of comparing to a language. Java is perfectly fine at letting you ignore abstraction and write god objects and balls of mud. It tends not to happen, I think largely because the Java developer community tends to be made up of formally trained programmers who see this as a bad idea. Both Java and PHP offer tools to allow for abstraction, inheritance, interfaces, and so forth. The use of those tools is a natural consequence of following SOLID principles. &gt; Symfony2's configuration layer is similar to Java/Spring XML configurations. Etc, etc. Maybe - but Symfony2's configuration can equally be yaml, similar to rails. Or plain old PHP if you prefer. all 3 are valid. I don't see how this is a thing. &gt; And by complex, I mean the amount of code it takes to complete certain tasks, some of which are pretty simple. With proper abstraction you tend to write *less* code, especially once you start reusing that code elsewhere. The code is also more maintainable and testable which is a worthy trade off against what amounts to a couple of extra *minutes* spent setting up a few extra files &gt; It's entirely possible to get things done without multiple layers of abstraction, most of which are not necessary part of the time. And here is where I'll strongly disagree. It is necessary in order to insure code adheres to SOLID principles. Which are necessary in order to prevent maintenance issues and promote code reuse. A consequence of doing this is that you will drive the complexity of the code *down*. It becomes clear what each part is responsible for and where everything goes. A "simple" class which is actually a giant ball of mud is many times harder to work with. &gt; It's also part personal preference, as I prefer more lightweight libraries. this is confusing - you prefer more lightweight libraries, which implies libraries which do less stuff, yet you are against separating code out into discrete areas of responsibility which is the very essence of simple light weight libraries? care to elaborate or am I missing something? 
You're missing the point of this. I don't want to improve **myself** as a developer. I want it to be a community thing where we can discuss techniques, etc.
oh man, I didn't even think of that. The class "kind of" has two different name properties, because their private and one's defined in the subclass.
how hard is it to work in an environment using MVC if you hadn't previously?
The model is the logic of your app. It will handle what your app actually do, manage inventory, add items to users etc.. Model = business logic. The views is the most simple, it's the templates and layouts of your app. The controller is the part that will handle the interactions, depending on what you ask to your app, it will get the data from the model, and put it in the views. In a web app, the controller will intercept a get request, call the model to get the data you want, and then call the correct view that will display the data to the user. An example, user want to see last blogs post, and scroll (yes my crazy syntax is stupid, but it is not real code): get index #the controller index intercept the call The controller do posts = PostModel.givemeposts.order(creation Desc) In your model you can simply ask for last posts or only give published posts, it handle the logic. the controller then do something like : Render IndexView(posts) After that the user browse the marvellous blog, and the blog is modern, so it use ajax to allow you to see aaaaall the posts on the same page. After a bit of scrolldown, the embedded ajax in the page launch a request to the web server get js_posts(offset=20) The controller identify it's a js request, so it call the model again : posts = PostModel.givemeposts(offset=20).order(creation Desc) As it was js, it uses the js view instead of the html one. Render IndexViewJS(posts) And it send a nice json or whatever to the user's browser If you want to learn MVC, look at Django(python) or Ruby on Rails, they both use it.
There is, in fact, a slight bug (quirk) here in that the output from var\_export can not be used to reconstruct the object. Because the keys of the object are the same, the second "name" (derp) will override and Bar::__set_state will receive array('name' =&gt; 'derp') only.
Grab a few craigslist jobs. Get some real work experience under your belt. Learn a specialty like a framework or CMS plugin. There is high enough demand these days that someone will give you a shot.
Reddit intentionally distorts downvotes as a security measure. the total vote count is true, but they downvotes is often not.
It will have a learning curve and some frustration at first, but there are enough "ah-hah" moments to make it worth it.
Controllers should hardly contain any logic. The controller is responsible for providing the model with information from the user/actor.
kind of cool.
C++ does it too, so I would assume that every language allows that
There's also an iPad app (Kodiak) that allows you to test and execute PHP on an iPad. It's available on the App Store.
I am aware of that. However, when I posted, the comment had a negative score.
Yeah, looks like some folks are real grumpy when it comes to MVC
Maybe someone got mad at /r/php as a whole and unleashed a downvote bot. I know there had been one running in /r/ouya for months now.
I'm well aware of SOLID. I follow SOLID, GRASP, KISS, YAGNI, and DRY principles, but it's still entirely possible to write lighter code (less lines of code to achieve the same results) with enough abstraction for full extensibility. I can tell we have different mindsets on code philosophies, but I'll give you some quick examples on how I align. I have a side project called Titon that I write for fun in my free time. All of its functionality can be found in Symfony, but my goal is to achieve similar functionality with less code and lighter classes. Just compare the following projects. Event: https://github.com/titon/event VS https://github.com/symfony/EventDispatcher L10n/I18n: https://github.com/titon/g11n VS https://github.com/symfony/Translation HTTP: https://github.com/titon/http VS https://github.com/symfony/HttpFoundation Sure Symfony has classes for one off cases, but for the majority of cases they are not needed. I'd rather use a lightweight library that provides sufficient or minimum functionality with the least amount of integration and bootstrapping required. We can go back and forth forever, but I understand where you are coming from, even though I don't entirely align with it.
I have to disagree a bit here: &gt; "I think the war is won on "Models are not just an instance of an ORM" for developers who care" Even Laravel, which is arguably the most modern, "best practice" framework PHP has right now, explicitly defines a model as an ORM entity, and its a bit annoying. PHP land is still very much stuck in "model = ORM / single class", and it tends to reinforce some bad architectural habits.
I think it's because php feels like a procedural language when you start out. Objects wrap up data and functions and keep them focused on doing one thing. Let's say you want to make a table. You could write a table class that handled it. You would still need to interact with the class like $myTable = new Table(); $myTable-&gt;addColumn('test_col_id','Test Col Label'); //create new cell in the Test Col column with the value of 5 $myTable-&gt;addCell('test_col_id', 5); //render html $myTable-&gt;render(); Do you see how the table handles all of the data and processes relating to itself? So if you had 10 reports that needed to be rendered in tables and you wanted to add odd/even styles to the rows, now you can just change one render function to add it. This is a very basic example I pulled out of thin air but once you dig into patterns and objects you will see their power. If this is where you are with objects I think you should look for a text book that covers the basics of OOP. Follow with the design patterns book or it won't make sense. 
EDIT: Fix typos. Also, look at http://www.phptherightway.com Well if you understand the basics of OOP, you'll realize that MVC is just a way to organize your objects. In OOP, you could have one guy, let's call him John, (he is an object of a class in this story) design a product, create the product, and sell the product. MVC is just a way of saying, "Well, John is good at designing products, but he spends so much time (read 'complexity') selling, he doesn't design so well anymore, let alone having time making them. Let's hire Juan, and Janet to take over some of his tasks." Taking the story a bit further... if John is starting a company making and selling water pumps (that is his product), sure, in the beginning, John can do everything. But most successful, long lived companies don't have just one employee. They hire a product designer, a manager, a researcher, a marketer, a salesman, etc., etc. As the business grows, the more specialized 'roles' are needed to help maintain efficiency, much in the same way more specialized 'objects' in your code keep things clear as your code increases in complexity. 'complexity' here does not need to be large scale, or beyond a single developer. A simple blog could benefit from MVC. One object to represent posts in the database, one to direct that object about which post to load from the database or update, one to handle making the HTML for the post, etc. Sure, a single class/object could do it, but it would be better as a team. In OOP, it's easy to have a 'God' object that tries to do everything, or like in procedural PHP, a 'functions' file that tries to do everything. MVC combats this by having you create classes that deal with very specific things, for cleaner, clearer, more readable and maintainable code. Often less buggy and less prone to fall over too. Switching gears a bit, if by 'how they all talk to each other', you mean literally in code, with PHP, a class loader is often used - an object or function that will load all the classes in a folder or folders, either all at once when the app starts, or as needed. You could also use 'require' statements. Say, in our story from before, that Juan became the salesman, and Janet was also a translator. Say Juan is talking to a person one day who speaks only Russian. Juan knows Janet can translate Russian, so he "require"s her help. Juan didn't need to know Russian himself - it does not directly concern him: &lt;?php require('Janet.php'); class Juan { function spokenTo($words, $language) { if ($language === 'english') { $this-&gt;respond($words); } else { $translation = Janet::translate($language, 'english', $words); $this-&gt;respond($translation); } } } You can think of MVC as a bigger, more solid, continuation of this exact thought experiment.
Er... no. The controller's job is to control flow. To take an incoming request, and pass that request along. To receive a response and hand that off to the user/actor. If business logic is landing in the controller than your controller is doing too much. You are certainly not following MVC best practice at this point, and you are probably in violation of the single responsibility principle.
My advice: go get a junior job. I genuinely think you could get a junior level position with what you have, assuming that you can get along with people and you haven't exaggerated what you've done.
Oh wait I think I may have misunderstood here, I agree with you, anything related to processing of the data and whatnot should reside in the model, yeah absolutely, I mean program running logic should reside in the controllers. Example, a simple contact form on a website: View -&gt; displays form, submits data Controller -&gt; takes data, creates a contact data object, calls contact-&gt;validate() Model -&gt; validates all the data, returns true or false Controller -&gt; Decides what to do: True: Call contact-&gt;send(), persist model to database False: Don't call contact-&gt;send(), don't persist model Controller -&gt; Passes this information to view/redirects/whatever View -&gt; Displays appropriate messages In a simplified view, the controller in this case could be seen as handling the logic, I think this is the best practices way of doing things. What I really meant was, between your models and your view, your controller decides what to do and where to go. Sometimes this can be complex itself and require a fat controller. What I **didn't** mean is, for example in my example, that validation/sending should be done in the controller.
Cheers mate, am picking up and learning Symfony2 atm and continuing to practice until I get some small jobs under my belt per the earlier suggestion.
Thanks for the suggestion will look into seeing what I can find.
I found this CodeIgniter tutorial to be extremely easy to follow. Maybe you could start them off with this? http://www.youtube.com/watch?v=9hRNFgSLLAQ
Yeah I kind of disagree still.. The model isn't "data and what not"; the model is "the application". The controller's job is to broker access to that application and in conjunction with other objects in the presentation layer/server layer, serve up responses based on information obtained from the model. In your above example the controller should receive the information and pass it off to the model layer, which should deal with any validation logic, any application logic (sending or what not), deal with persistence etc... and then should return to the controller success or failure. The controller really should be dealing with things like...the request (how was the resource requested? who requested it? are they allowed to request it?), handing the payload in that request off to the application logic in the model, receiving information back from the model and then figuring out how best to compose the response (was the request json? return json... is a redirect required, and so forth). The controller's job really is one of getting stuff, figuring out what handles that stuff and handing it off. At no point in your example would I allow the controller to take the decision as to whether or not the record needed to be persisted. 
Good point about Taylor's suggestion. Now if we can just get Eloquent to be a data mapper instead of an activerecord, I'll be happy :P
Because it was there.
Models are the shoe, controllers are the shoelaces, and views are the color of the shoes &amp; shoe laces
I hated ORMs too, mainly because I was perfectly at home writing efficient SQL myself, and also because most of the work I've done with PHP required queries more complex than an ORM is meant to really handle. But then for the hell of it, I decided to write my own mini framework from scratch. It started off as a simple authentication/session system that tried to follow some good architectural patterns and make use of password_compat since I was stuck on 5.3. I started with Pimple for dependency management(which I hadn't done before), and ended up writing my own auto-resolving IoC container. I used mapper objects to fetch records from the database, and implemented simple common methods like findOne, findAll, update, insertOne, insertMany etc. The sole function of these objects were to take some plain old PHP object, map its properties to a database, and save it (or get some query back, and map it to the plain old PHP object). Then I saw how PDO's fetch_class() and fetch_object() methods can do that for you automatically, saving you a ton of writing manually mapping fields. I fell in love with the data mapper pattern because my domain objects remained 100% pure and portable, and had precisely ZERO knowledge of any persistence. And there was something really elegant about: $User = new User; $User-&gt;name = 'Joe'; $UserMapper = new UserMapper; $UserMapper-&gt;save($User); where you just pass in a complete $User object instead of some ugly, hard to construct data array. And then I realized I wanted objects that were aggregate roots (parents that contained many sibling objects), so I started making factories and repositories that assembled these aggregate roots. And then I felt like I was repeating a lot of similar factory code over and over and thought there was probably an easy way to let my data mappers automatically query and assemble objects and their children for me, so I wrote some code that referenced NORMAL doc comments to get the relevant data I needed to do that (not Doctrine's ghastly doc comment syntax, but simply reflected the normal doc comment code a sane programmer would write, no special syntax at all). And then I discovered the N+1 problem before I even knew that problem had a name, so I implemented some strategies for eager loading vs lazy loading objects, and before I knew it, I had created a really basic ORM (no query builder though). So now that I sort of "get" ORMs and have a do-it-yourself understanding of what goes into the magic they perform, I'm ok with using them. I learned an absolute truck ton of how "magical" things like an auto-resolving DiC container and an ORM work conceptually, just by writing really simple, bare-bones versions of what's already out there. My advice is to face your fear of magic head on, and try to build your own versions of those magical things yourself. They don't have to be fully featured, just enough to let you see how they work conceptually.
So it's like Pimple, but way more complicated? 
Learning Symfony will only make you sad when you realize most of the projects you're going to work on have nowhere near the coherence of Symfony. I would honestly recommend you learn WordPress because it will help you appreciate Symfony more.
Just use Doctrine instead of Eloquent if you want :) 
What? If by complicated you mean, it saves you the hassle of manually wiring a bunch of dependencies, and encourages good development practice by type hinting your dependencies in your constructors, then yes. This is what a DIC *should do*. Pimple is great for really simple projects, but it becomes a pain in the ass to manually wire everything in a larger project. I wrote my own "for fun" framework a little while ago, and I quickly abandoned Pimple in favor of taking the time to write my own reflection DI container just to save myself the hassle of manual wiring what wasn't even a very complex framework at that point (let alone any app built on top of that framework).
I'm pleased that you find your own achievements more impressive.
Complicated, yes, but not in the "complicated things are bad" kind of way. Pimple allows for _very_ simply DI, and IMO it's not really even a true Dependency Injection Container. It has no ability to do autowiring; you have to set up everything yourself with factory closures. It's really more like a registry in that it can only return what you give it, but if what you give it happens to be callable, it will invoke it first, then give you the results.
After long, you're going to find yourself doing very impractical things in PHP simply because that's been requested. Get used to it! :)
If they use a framework, it's probably an older version of a framework you've never worked with.
It may be a matter of personal preference. But I would like to keep magic and reflection stuff out of/to a minimum in application code. It is fine for testing and mocking purposes. And I guess this type of auto wiring only works in case of constructor injection. I like pimple because using it makes code clear and consistent even if it takes a little bit more code. There is not much magic going on and the process of injection is more apparent/explicit. You have got more control on what is happening. 
Partly to see if I could, partly because I was toying with the idea of a PHP dev environment on iPad.
A junior dev should have the following characteristics: **1. Resourcefulness** Resourcefulness is everything. Unless you've been building websites for 20 years, you will never have integrated Mailchimp API into Wordpress, or Salesforce API into Phonegap so often you can do it from memory. Every project is basically a unique problem that few developers already know exactly how to do. As such, you need to know how to read documentation, know where to FIND documentation (believe me, this is harder than it should be....), and know when to ask a team member for help. The fact that you were able to set up 12.04 and a lamp stack already demonstrates you have this resourcefulness. Sounds crazy, but the attitude that "*every problem has a solution, and you just need to know where to find it*", is key. **2. Concept-oriented** Developing anything requires you to understand concepts. Developing and programming are not the same as cooking. You can't just follow a recipe. Even Fisher Price "frameworks" like Wordpress require a conceptual understanding of their approach to the request lifecycle so you can understand what the framework considers legal and illegal. Being mindful of concepts, and geared towards understanding them, is key to learning and applying various patterns down the line (MVC being one such pattern). Though it's not enough to simply follow MVC like it is a recipe. Regurgitating "MVC stands for Model View Controller...." in an interview won't cut it. You have to know that MVC is one of many different architectural patterns whose purpose is merely to maintain a separation of concerns. MVC is simply a way to organize your project into logically separated layers so that they're easier to build, and easier to maintain. **3. Code-articulate** Being verbally articulate means speaking clearly, and organizing your thoughts. Writing code follows the same concept. Your code should be consistently formatted, it should be documented, and it should be fairly readable. You're not expected to write fully abstracted code with super slim single-purpose methods and classes, but your code shouldn't *look* like a total mess either. This also means you should have a natural tendency to want to refactor your code. **4. Flexibility, and basic teamwork and communication skills** Working well with a team is vital. I've seen some super smart, EXTREMELY gifted programmers come and go at my company. They often go because they don't communicate or collaborate well. Working with a project manager can be challenging at times. Sometimes a project manager will try to micromanage you. Sometimes they want constant updates. Sometimes they flat out won't believe you when you say implementing a feature is too hard given the scope of work and time you have allocated. Sometimes they simply won't understand WHY something might take 16 hours to implement when it was originally estimated at 2 hours, and you have to patiently explain in excruciating detail what the complications are. All of this takes some good communication and teamwork skills. **5. Basic version control experience** Version control isn't tough to learn, but you need to be familiar with version control workflow. Git is kind of the standard these days, but SVN knowledge is good. Obviously you're using Github as you've already stated, so no issue there. That's really it, those are the foundations of any good junior developer. It goes without saying that a junior dev is not expected to have much experience, or understand advanced concepts. Most dev shops will put a tech lead on a project with you, and the tech lead will be responsible for giving you direction, and filling in the gaps you cant (e.g. doing deployments if you need). So that said, sell those 5 points in an interview. Any other actual experience is a bonus as far as I'm concerned. Certainly sell your bonuses if you have them, but those 5 points are your foundation. If you feel comfortable with those foundational characteristics, just go ahead and start applying to junior dev positions (front or back-end, you'll likely end up doing a mix of both either way). Don't worry about getting more experience under your belt before you apply, just apply to jobs and go on interviews (of course, still strive for more experience, even if it's just coding for fun and pushing to github). The interviews will be good experience, and you'll likely find one that sticks.
Too high. ELI7-1/2.
&gt; it's not really even a true Dependency Injection Container. It has no ability to do autowiring; Where does this notion of 'true dependency injection container' come from? You will have to specify somewhere, what all dependencies a class is having. For this, some uses reflection, some uses xml/yaml configuration files. Pimple uses the most powerful, flexible option, the php code itself, but at the expense of being verbose. 
Thanks for the advice! I'll definitely take a look into AWS free tier, sounds promising. 
&gt; Pimple uses the most powerful, flexible option, the php code itself, but at the expense of being verbose. Ah, but typehinted dependencies is also PHP code itself. An annotation meta-language is not PHP, but core PHP supports typehinting. By declaring: public function __construct(UserRepository $UserRepository) {...} You have, at a language level, declared an EXPLICIT contract with that code. You can't pass in anything that isn't a UserRepository or that doesn't implement a UserRepository interface. Try as you might, you can't inject a PostRepository into that constructor with Pimple either. PHP, at a language level, enforces that contract. Thus it's perfectly fine to let a reflector read that contract, instantiate the required object, and inject it for you. You still have control over defining the implementation if it's an abstracted type hint. And presumably, you also still have control over defining a specific implementation for that specific class, rather than doing it globally. I would have to read a little more about this component to know if it allows for it, but a good DIC will let you be as specific as manually wiring in Pimple.
For people wondering how this works, allow me to explain it. This is all implemented through an Objective-C iPhone app that starts a web server built upon [CocoaHTTPServer](https://github.com/robbiehanson/CocoaHTTPServer). When the server gets a request, it does very basic file extension checking to see if you're requesting a PHP file. If you are, it routes it through a custom module for interfacing the PHP interpreter with CocoaHTTPServer (hence the "Objective-C Module" for the Server API). To get PHP to work, I had to compile it as a static library from source to support the ARM architecture. That took a while to get working, as it was a lot of disabling and enabling of different extensions based off of what libraries the iOS SDK has, as well as just figuring out how to compile PHP with the compiler options used for iOS development. From there, you compile multiple versions of PHP to support the different ARM architectures (armv7, armv7s, arm64), as well as supporting the simulator that runs on OS X (i386). Fortunately, you can merge all those libraries into one file so you don't have to worry about managing it yourself. So after that, it's all about writing the code that integrates PHP with CocoaHTTPServer. CocoaHTTPServer uses a connection class for generating a response to a request. We create a subclass that does that file extension checking, and invokes the PHP module if the request is asking for a PHP file. We also need to create a class the implements the protocol that describes am HTTP response (a protocol is basically the Objective-C equivalent of an interface). We need to do this as we need a response class that has a dynamic sized buffer we can write bytes to. So, we start the server, which uses our custom connection subclass for any connections made to the server. The connection creates an instance of our response class for PHP requests. The PHP module hooks into our connection class to read data from our request (HTTP method, headers, POST data, etc), as well as write data to our response instance (the actual output from PHP, any headers set, etc). After PHP finishes executing, we send the response to the client. TLDR: This is a custom iPhone app that runs an HTTP server that integrates with a custom PHP module. The code is [on Github](https://github.com/grantjbutler/PHPTest) if you're interested in poking around in it. Feel free to download, compile, and test it yourself (requires a Mac because iOS development).
Wow!!! That's great, that's like the 5 commandments or something. :) Jokes aside, that's some great points you have listed there and clearly defined and well thought out. Very inspiring and lays out a lot of guidance. Thank you so much for that, it would seem I'm not that far off at all when it comes to landing that first gig in a new industry. Many thanks for this sageful advice.
&gt; I am assuming this is jailbroken? Nope, not jailbroken. Done through an iOS application. &gt; How do the extensions work? Extensions work based off of what libraries the iOS SDK has (only successfully compiled the MySQL extension, but have not tested it). &gt; How's performance so far? No idea how performance is. I wasn't really focused on that, just on seeing if I could get this crazy idea to work. &gt; Did you follow a guide? Trying to get it to work was looking at the [configure options](http://www.php.net/manual/en/configure.about.php), reading the [Unix installation guide](http://www.php.net/manual/en/install.unix.php), and just playing with things until I got it to work.
That sounds pretty cool. 
Lucky for you, I [wrote up how I did it](http://www.reddit.com/r/PHP/comments/1x0pab/following_the_guy_who_got_php_running_on_android/cf7fnkf), and put the code [on Github](https://github.com/grantjbutler/PHPTest) for you to try it, too.
I think more accurate wording might have been "true dependency injection *framework*", which Pimple is not. It's a perfectly valid container, and does very well exactly what it should do. But it's not a framework per se, with framework implying more advanced features. I would personally not use Pimple in many production environments, unless it was to add a decent architecture layer on top of some gross legacy code that won't play nice with an auto-injector.
I went with Php storm and have loved it for 3 months
FYI for those who have never heard of this, the brand new home page (http://php-di.org) explains clearly what this container does and how it differentiate from others. The blog post is more of "what has changed".
I use it as my primary framework for production purposes and prior to ZF2 I used ZF1. The reason you can barely find any material on it is the same reason you have a hard time finding good material on ZF1, the documentation isn't there nor is it a priority. The target audience isn't for newcomers to the landscape or for those who want a framework to handle everything for them with what we refer to as "magic". Instead, the target audience is more for the software engineers who just want it as a trivial application stack and router that will eventually get phased out with a massive library on the side for them to dig through the code manually to use and extend. The only real contemporary to ZF in the larger industries is Symfony. If you aren't doing large custom applications with 100k+ kloc, distributed systems, and a plethora of other stuff, then it's not something many would consider. I've thought about putting together a tutorial on both frameworks at multiple points in time, but it really gets down to the audience already being inclined to just examine the framework source to determine what's going on. ZF2 is pretty straight forward since they reworked everything from ZF1. The application bootstraps itself, loads the configs, fires off the module for various closures and definitions, and the router triggers the controller action. From there it's dependency injection via the defined closures and you're off to the races in whatever direction you desire. Whether or not I'd recommend it for a new project depends on your skill level and understanding of various software designs and intended usages. For instance, understanding the differences between service locators, factories, and dependency injection is a requirement. If you want something up and running quickly, then check out something else. If you want complete and absolute control over everything you're building, then take a look to see if it's for you; it was for me.
There is this http://zf2.readthedocs.org/en/latest/
Thank you for the thorough answer. It kinda makes sense. Quick tutorials exists for frameworks that are possible to pick up in a short time. Zend is not one of them.
There's plenty of "magic" in ZF2 as well. The fact that the service locator can give you access to a DB connection just because your application config file has parameters for a DB connection is "magic". The fact that your controllers can return an array and the response object gets the JSON headers just because the request was done via AJAX, is "magic". http://zendframework2.de/cheat-sheet.html sorry, it's in german but it shows there is magic.
Yaf, never even heard of it. HHVM is not a framework. As I understand it (I don't really) it's a way of compiling PHP projects into machine code and serving them that way. Phalcon is a framework, but it adds it's libraries via a PHP extension rather than a folder structure. Why do they do this? Because compiled code is **significantly** faster than code interpreted at runtime. By making Phalcon a PHP extension you are essentially making the framework native to PHP, the compiler doesn't have to do any extra work, it's already in machine code. With HHVM you are compiling the entire project at runtime so it's extremely fast. I honestly haven't looked into them much but that's the basic theory. I think.
About 1st point - I think that isValid() method should belong to Service not Entity, because in addition to simple validations (for example, type and range checking), we also have domain specific validators which can use external resources (for example, we may need DB to check if "username" is not already in use). About 2nd point - I see no big difference besides unneeded complexity between [$user = new \App\Entity\User] and [$user = $user_service-&gt;create()]. Suppose we want to rename entity: in both cases to get places (lines of code) where specific entity is created, we need to do search, the difference is by what we search, by factory class name + create method name or simply by entity class name. About 3rd point - yes, this looks like valid argument.
ok let's try this. say you have 2 front-end servers, 1 beefy DB setup, 50ms latency between your front-end servers and your DB. 1. let's say your DB is beefy enough to handle 5000 connections + writes per second. 2. your app is gaining traction and you started getting 2000 API calls per second. first scenario, you have symfony2 or laravel running your app. given you're using an ORM with it (doctrine, eloquent), your app can handle 600 reqs/sec per box. that means your capacity is 1200 reqs/sec. you're 800 req/secs short. that means you either fire up more instances or you make those 800 wait a bit more, slowing down your app. your DB is also under utilized (1200 req/sec vs 5000/sec) second scenario, you're running something faster (ie phalcon or raw php), which can achieve 1500 reqs/sec. that means you can handle 3000 reqs/sec. you're well above your 2000 req/sec demand. it can be solved by firing up more instances, but it shouldn't be the end of the solution. you're paying for expensive engineers because you expect them to give you a performant and maintainable system. Nailing performance should minimize this part. what about the latency between the front-end servers and the db servers? won't that neutralize performance? it depends on how capable your DB servers are, which usually, is more powerful than your front-end servers. using something other than your mainstream frameworks doesn't mean testability/maintainability goes to zero, nor does it mean poor architectural/engineering choices and principles.
The thing is, the company I work for will be utilising drupal for a bit of work (if the job requires it) and D8 is built using packages from Symfony - so do you think it would be wise to get my head around that, or Laravel which seems to be a derivative of Symfony(?) Is it a case of know one you can use them all, or is it better to specialise?
Malt blue has some great ZF2 tuts - http://www.maltblue.com/ I was seriously considering learning ZF2 in more depth, but there just isn't enough work out there at the moment demanding it to justify the investment of my time. Symfony is killing it in the enterprise space at the moment. I really don't get their approach to documentation. It is lacking. Yes, it's not aimed at beginners, but you don't go from beginner to expert without working your way up a framework or two, and why wouldn't Zend want you to learn theirs on your way? I mean, it's financially in their interests for devs to do so. It's not a dead project though, and I don't want (nor do I expect) it to die. Oh, also - http://mwop.net/ Honestly though, right now, if you want to learn a framework that will get you interviews and more, learn Symfony 2. In my humble opinion of course :)
I'm not entirely sold on auto-wiring. I think it's great for smaller projects, but as things get more complicated, I think I prefer the explicit wiring. Here's a quote paraphrased from Nat Pryce: &gt; If a big tangle of wiring means you can't see the wood for the trees, with an auto-wiring container, you can't see the wood or the trees. I use Pimple extensively and have coded up auto-wiring as a trait, it worked nicely enough, but I just didn't find myself using it. I don't know if PHP-DI has some sort of tracing/logging/debugging available, but that would certainly make autowiring more appealing or perhaps when the compiled container is ready, it could be commented to describe where things come from. This is an interesting article, where the author considers only using explicit wiring is "pointless", although I don't think the same rules apply to PHP's shared nothing architecture: http://blog.ploeh.dk/2012/11/06/WhentouseaDIContainer/.
I fail to see how this different from what I said - I missed out a few extraneous details, e.g. request types, return types, redirects etc, but the point is still there: Models are an abstract way of representing data types with associated methods and properties. Controllers hold the business logic. As far as whether object persistence should be handled by the controller - I can't really see how it could be otherwise? Having used Zend and Doctrine for a long time, at no point have I seen models persisting themselves - the actual doing of it is handled by an application layer, but the control of it comes from the controller. See the [first answer on this SO question](http://stackoverflow.com/questions/8429248/create-an-entity-inside-an-entity-how-to-persist): &gt; As this is business logic, I would not hide it in the model itself but rather have in the service layer. And [this link](http://martinfowler.com/bliki/AnemicDomainModel.html) 
It's funny I would have said the contrary: in a small project explicit definitions are manageable, but in a larger project convention of configuration is much more simple and maintenable. Anyway if there is one thing definite about DI and containers, it's that there is no "one right way", everyone has a different opinion. That's why this library offers autowiring, annotations, but also explicit definitions (autowiring and annotations can be disabled). &gt; if PHP-DI has some sort of tracing/logging/debugging available, but that would certainly make autowiring more appealing That's interesting! But what would that be concretely? A way to dump the definition of a service (i.e. all its dependencies)?
Having a good understanding of one modern framework helps a lot with understanding other frameworks (even when crossing over to other languages). For productivity's sake I wouldn't recommend learning three frameworks at the same time. Master one, than take a look at a different one. Laravel uses a number of Symfony2 components - just like D8 will. I'd suggest you take a look at Symfony2 instead of Laravel as the latter isn't using some of the Symfony2 components that will be essential for D8, most prominently the Dependency Injection component. As your main focus seems to be Drupal, it might be helpful to follow this tutorial: http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1 (it has 12 parts) It will give you better understanding of the individual components and how they interact.
For the ones with a jailbroken iPhone, theres a tweak for that(PHP and mysql): http://ios-webstack.tk/ Works on iOS 7 on my iPhone 5: [Imgur](http://i.imgur.com/xw2qr2N)
Can't find the article about Android &amp; PHP link please?
My main reason not to do that is because it becomes messy real quick. Your future self in 6 or 12 months should be able to grasp what is going on in a piece of quick at first sight. Mixing different kind of statements will mess that up.
I think you should look in to frameworks. As someone who started as a vanilla PHP dev, it was honestly a walk in the park to pick up frameworks. Just get nuts deep in to one, "reverse engineer" it, and you'll be golden. They all pretty much work the same way.
Probably _framework_ agnostic code ?! And by that, they probably mean plain php without any framework around it.
This is the first time that I have heard someone mention "MVC agnostic" and on the face of it I would question their own understanding of the phrase. However with that said, I believe what they may mean is either of the two: * Having a front end view interface with the controller part of the app via an API (RESTful or otherwise) rather than being tightly bound. * Write a library package that doesn't follow the MVC pattern, and which could be dropped in to any project, framework driven or procedural and work regardless of project design pattern.
This. They want code that is not written using a framework. Write your own class along with a client for it perhaps?
Hi triskycar, Thanks for your response, how long did it take to learn a framework? Most seem to use symfony framework. I did create a small project based on the following tutorial (http://symfony.com/legacy/doc/jobeet/1_4/en/01?orm=Doctrine) but lost interest quickly :( I know frameworks are good, but I miss the flexibility of native PHP code. 
DO NOT ALLOW yourself to turn into a dinosaur. Do invest energy, even if you loose interest 1h after, think as if your boss put you to this. Think your job/life depends on it. So start learning. Read books. Find a way to punish you if you get bored and stand up from your desk. Find a way to repay your effort somehow (maybe an ice cream) You need to find the power and will, to start to adapt, to a new world. Been there, and i am almost in your spot. I am learning, and pushing myself, even if i do not like it, or find interest in it. I know it's for the good, so i do it. Good luck.
This is the mantra I keep touting at work. A developer who does not develop his/her skills is not a developer at all.
So I'm dead? Thanks, now I feel much better. I have evolved my native PHP and MySQL skills all the time. All my projects are well written and lean, but using one size fits all framework seems to throw this in my face when it comes to these practices.
Will look at symfony again using version 2.x. 
If in 7 years you haven't tried to work with a framework (in your free time if your company doesn't use it) than I recommend you start something that you're more passionate about. Try to avoid the ["Sunken cost fallacy"](http://en.wikipedia.org/wiki/Sunk_costs#Loss_aversion_and_the_sunk_cost_fallacy) when you make your decision. 
I fully understand MVC structures, I've created a couple for the travel industry. My point is that I have to learn a new scheme for PHP when I already know it.
#####&amp;#009; ######&amp;#009; ####&amp;#009; Section 5. [**Loss aversion and the sunk cost fallacy**](http://en.wikipedia.org/wiki/Sunk_costs#Loss_aversion_and_the_sunk_cost_fallacy) of article [**Sunk costs**](http://en.wikipedia.org/wiki/Sunk%20costs): --- &gt;Many people have strong misgivings about "wasting" resources (loss aversion). In the above example involving a non-refundable movie ticket, many people, for example, would feel obliged to go to the movie despite not really wanting to, because doing otherwise would be wasting the ticket price; they feel they've passed the [point of no return](http://en.wikipedia.org/wiki/Point_of_no_return). This is sometimes referred to as the sunk cost fallacy. Economists would label this behavior "irrational": it is inefficient because it misallocates resources by depending on information that is irrelevant to the decision being made. Colloquially, this is known as "throwing good money after bad". &gt; --- ^Interesting: [^Relevant ^cost](http://en.wikipedia.org/wiki/Relevant_cost) ^| [^Psychology ^of ^previous ^investment](http://en.wikipedia.org/wiki/Psychology_of_previous_investment) ^| [^Contestable ^market](http://en.wikipedia.org/wiki/Contestable_market) ^| [^Conditional ^budgeting](http://en.wikipedia.org/wiki/Conditional_budgeting) *^\/u/adrianmiu ^can ^reply ^with ^'delete'. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less.* ^| [^(FAQs)](http://www.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/) ^| [^flag ^a ^glitch](http://www.reddit.com/message/compose?to=/r/autowikibot&amp;subject=Glitched comment report&amp;message=What seems wrong: (optional description goes here\)%0A%0A---%0A%0AReply no. 45203:%0Ahttp://www.reddit.com/r/PHP/comments/1x2x88/midlife_crisis_native_php_developer/cf7mv3e)
Primarily time.
Here's a secret: no one knows 100% of a framework except probably it's developer. Frameworks are a shotgun approach in that they attempt to solve a majority of common use cases. As such, most people only know the parts of the framework that they happen to need. You're not dead if you choose to devote some of your own time, outside of work, to learning a framework. Take a weekend, and do some tutorials, view some videos, throw an example app up on Github and post it on /r/phphelp for feedback. You'll get there, but it isn't going to fall in your lap. 
Ha, I was a project manager and developer. During my whole time nobody suggested to use symfony or another framework. The framework created in-house worked extremely well and responsive with new and old developers.
Why wouldn't you take look at symfony, understand the basics, get to know why so many uses it... and then when you go look for a job, you can clearly tell them how your skills can be an asset with or without any framework ?
[Clean coding](http://blog.8thlight.com/uncle-bob/2012/08/13/the-clean-architecture.html) and [Composer](https://getcomposer.org/) is what you need and you'll be all right.
We use ZF2 in our office and I've often wondered if we made a mistake in picking it. ZF2 almost feels like a cheap imitation of SF2 on first glance. Documentation is lacking. Things don't seem very polished. Core devs have moved on to apigility for the time being. Contributors are going crazy with backwards incompatible changes for ZF3. It's all a mess! But then you look deeper in to the code and you find nice gems. Pair it up with Doctrine, some SF2 components, and baby you got a stew going. You definitely need to massage it though. It's a framework in name only. For our office we have a somewhat extensive library that sits on top of ZF2 and makes it a nice cohesive framework. So, if you are willing to put in the time and if your business reqs are such that you need a very powerful yet simple framework - ZF2 might be the way to go.
It would probably take a weekend or two to get the basics down. This last year I did some interviews and they all asked about frameworks. They just want to know if you can do oop, mvc stuff and can read and use api.
Sorry, wasn't try to be harsh. Its very easy to be comfortable in your knowledge zone but in this industry you have to stay on the trends. That being said, your surely not dead. .just need to catch up and that can feel daunting
What should I do? - what do you want to do? 
They loved my native programming skills and were prepared to hire me that day but said I was lacking symfony basics :(
Did you also wiki-ed your self?
I don't think that's an issue. How much time have you been pondering on what to do? All that could have gone into learning a framework so far. You simply need to approach everything with a beginners mind and never stop learning. Its the stagnation that ultimately leads to self-defeat.
Yes, you will need to learn another schema or even another technology. That's the career you've chosen. In my case, that career has spanned over 30 years. 
Thanks mate. I do get it, I just feel down at the moment... Allot has happened in my personal life and losing my job was the final straw that broke the back.
That makes more sense, I think people are getting completely the wrong idea of your competency, at least when I think "native" PHP developer I think PHP4 functional spaghetti code. I guess your company just had a [Not Invented Here](http://en.wikipedia.org/wiki/Not_invented_here) syndrome. Learning to use other libraries and frameworks really reduces your workload and scale of projects, obviously you have to familiarise yourself with framework syntax and flow but really it will be much easier because of the community than a new colleague joining your old team and working with your in house framework.
Really, so you learnt native PHP first. Having the experience of working with generic frameworks or natively, what do you prefer?
Small teams will do that to you, best of luck and there are plenty of jobs around London to get so you just have to familiarise yourself a bit on some of the modern frameworks and let your experience carry you, really picking theses things up should be fairly trivial for you and you can always learn on the job.
I had to give up pursuing a career with PHP &amp; MySQL to learn VB/C#.net and MSSQL. Granted I'm only just starting with my career, but I've learned early to not rely on what you are comfortable with if you want to be successful.
I don't know anymore... Will PHP even exist in the next 20 years, let alone the frameworks. I'm on a downer :(
Anything new will feel like that. And that's a good thing. Means you're outside your comfort zone and that you're learning. I felt the exact same way when I started learning object-oriented programming. However, once I started using it, it became like second nature. 
A workplace that hires you because of specific framework knowledge isn't a solid job anyways. They should be hiring developers with the ability to learn any stack required. Yes, if you know the specific stack they are using it's an advantage, but you will still have to delve into the business logic, which is different everywhere. Even though someone may know Symfony2 better than the back of their hand, every workplace will still be doing things a little differently, which makes it a terrible idea to hire someone solely on the basis that they know Symfony/Laravel/etc. They should be hiring a smart and tech savvy individual who can not only learn the stack and code well, but communicate with others and contribute to the product. Not a Symfony2 Ninja Rockstar (tm). In my opinion, you have no reason to be worried. What I would do is brush up on the newer PHP technologies if you haven't already. Mostly the object oriented aspect, since that's what is hot right now. On larger team oriented projects, design patterns are fairly important but a lot of those write themselves, example: [The Strategy Pattern](http://en.wikipedia.org/wiki/Strategy_pattern). Most people implement this and don't even realize it's a common design pattern because it's very natural in OO programming.
It was not my achievement, but I was able replicate it.
Who the hell turns down a good applicant because they didn't know a framework?! Frameworks are simple, it'd take you not even a month to become completely competent in most of the major components of symfony
Wikis were not a big thing back then.
Hi input, haha... Thanks for pointing this out. I don't do spaghetti code, all my code has a MVC structure tailored to specific needs all designed to be lean and responsive. The big question is why would a custom framework be confusing when you should know PHP language? Its not hard to structure code and create SQL queries, why do you need to outsource it to a generic framework thats fat and will expire? I heard you cannot update Symfony from 1.4 to 2 easily?
I like to take /u/pmjones view of what makes a DI container &gt; The main point is that whenever the Dependency Injection container creates a class, it can do so without having to define that class as a reusable service. &gt; &gt;In contrast, a Service Locator requires that you define a service, and then you can retrieve a shared instance of that service from the container. via: http://paul-m-jones.com/archives/5843 So no, Pimple by that definition is a Service Locator, not a DI Container. It has no ability to build an instance of `Foo` unless you define exactly what it should do when you request it from the container. It can't instantiate the object even if it has not a single dependency, you must verbosely tell it exactly what you want it to do. For me, "a true DIC" knows how to use core PHP functionality to figure that stuff out for you.
You really should check out [Create Your Own Framework on top of the Symfony2 Components](http://fabien.potencier.org/article/59/create-your-own-framework-on-top-of-the-symfony2-components-part-1) . It's by the creator of Symfony, and is a great way to understand the basic layout of the components used in Symfony. I had done MVC, but Symfony was way over my head - this cleared up a lot of confusion for me.
They wanted develops to start coding on the first day without any support.
Looks like I'll be working hard this weekend ;) Thanks mate.
He's out of work because his company closed, not because he failed. 
They are either saying "framework agnostic" in a weird way, which means abstracting or removing your dependencies on core functionality in any particular framework. The other option is that they don't want to see an application written with a framework, because if they are not experienced with the framework then they probably don't know where the framework ends and your application begins. They _I think_ specifically want to see what you can do with "vanilla PHP", to see what architectural decisions you make. But... that was a really weird way of putting that question, so you're not wrong to be stumped. 
&gt;I don't have much experience with frameworks. What should I do? Learn to use frameworks. I'd suggest CodeIgniter is the easiest one to learn the basic concepts. Laravel and Symfony are maybe more useful for production. You might want to familiarise yourself with composer and git and stuff too, if you're not already. &gt;I'm beginning to think to dropping my career altogether and looking for something else with longevity. If you didn't think straight away that the answer is just to learn this stuff, then maybe this career isn't for you. I've been a developer much longer than you, and I spend about ~50% of my time learning new stuff. I started with Pascal.. not much call for that nowadays.. **tl:dr;** if you don't enjoy learning new things, and do it instinctively, this probably isn't the career for you.
Considering it's built by "The PHP Company" (you know, the guys who built the Zend Engine that all your PHP runs on), I think it's safe to assume that ZF2 is not a dead project. 
What is native PHP?
I will start investing time, I just feel really down at the moment. Not going to slit my wrists.
Nice idea, duly noted :) (https://github.com/mnapoli/PHP-DI/issues/152)
Sorry, I sent you a link to part 10. [Here's part 1](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1).
Sure, I learned a bit of PHP, but I'm not a developer. From Windows/LAMP servers to routers, electronics, scripting and LAMP servers and web sites, I'm all over the map. If I WERE primarily a PHP developer, you can be rest assured I'd learn Frameworks. My point was that I have learned (and forgotten) a ton of shit over the years. I had to be pro-active with my education or I'd have been pigeon holed as a 'one trick pony', living in the past.
Normally custom frameworks are a cluster fuck, why rework something that has already been done 100x better? &gt; Its not hard to structure code and create SQL queries. See stuff like this worries me, obviously you can do it correctly but working with raw SQL is never really ideal, why not just use an ORM such as doctrine. &gt; why do you need to outsource it to a generic framework thats fat and will expire? So there are micro frameworks which it sounds like you would be interested in, see [Silex](http://silex.sensiolabs.org/). As for frameworks expiring, it is a side affect but required for bug fixing and feature upgrading, major version changes are always problematic (Symfony 2 is massively different). If you were on Symfony 1.4 you would just stay on it.
My advice is to learn *concepts*, not *tools*. For example, learn MVC and routing, not Symfony. Learn HTTP specs and basics, not Symfony's HttpFoundation. Learn caching concepts like TTL, freshness strategies, etc. not Symfony's implementation. So on, and so forth. In this way, it's trivial to learn new tools when you're already familiar with the underlying concepts, and it won't feel like such a daunting endeavor. You'll also be more flexible as a developer, which will make you more valuable.
Fair enough, I've had some good advice. I think deadman87 hit the nail on the head.
To put it in perspective, the symfony components may as well be extremely popular libraries for the php language at the current point. There's nothing wrong with native PHP, but knowing the libraries of your chosen language is part of knowing the language, so this is really an essential skill of the modern PHP dev.
I don't want to start a debate. I've heard arguments for and against ORM/doctrine. But it always comes back to one simple truth. Once a system is created its extremely unlikely that it will change to another platform. I've created and developed MSSQL, MySQL and SQLite and functions and procedures seemed the better option each time (except SQLite). If you have developed a bespoke framework that is already optimised why would you need to 'upgrade'?
If you are at all interested in Laravel, I would highly recommend Jeffery Way's Laracasts. It's not free, but very much worth the price of admission. 
It's not a good idea to use it in production maybe, it's still the easiest way to learn the basics if you're scared of jumping straight into one of the others with a steeper learning curve.
Initially I said I would never work with MS products because in school I always hated programming with their languages. I knew linux servers more than IIS and embraced the open source nature of PHP. After school when I found it difficult to get a decent PHP job (the PHP jobs in Albany, NY seem to be entry level/intern positions ~$30-35k) I decided to broaden my horizons and apply to position available, as long as the job would train me in the skills that were necessary. I found that place and have been working in C#/VB.net for 8 months and to be honest I've never enjoyed programming more. My career is looking great for the next few years at least and this new experience will only help me in the future.
This was my though, but assumed this was normal practice now? When we got new programmers I'd force them to review the site for a week, then give them a task would introduce them and walk them all the way through their first project to ensure they were comfortable.
I don't see anything wrong with this. I do stuff like this all the time if (!$Auth = $this-&gt;AuthMapper-&gt;fetchWhere($identifier, $value)) { throw new \Exceptions\Login\UserNotFoundException('User does not exist'); } if (!$Auth-&gt;verifyPassword($password)) { throw new \Exceptions\Login\PasswordNotValidException('Password invalid'); } if ($Auth-&gt;rehashPassword($password)) { $this-&gt;AuthMapper-&gt;save($Auth); } Where I do the assignment inside of the conditional check so that I can do both the assignment, and the conditional check, at the same time. I can glance at that if statement and know exactly what's going on just as easily as if I had written: $Auth = $this-&gt;AuthMapper-&gt;fetchWhere('email', $email); if (!$Auth) { throw new \Exceptions\Login\UserNotFoundException('User does not exist'); } I'm not a one line jockey by any means, but if I can remove a line without hurting readability, then I do it. Maintaining readability is key. 
I think you (and /u/pmjones, possibly) are confusing the service locator pattern with the actual container itself. Service locator pattern means that the container is passed around to all the objects, which in turn use the container to fetch what ever object they need at run time. So you can use the service locator pattern with any type of container regardless of whether it supports auto wiring or not. But with service locator pattern, you will not require much auto wiring, as every object will only have one dependency. The container object. So the point is, it is not how pimple, or any other container, works internally, but how it is being used, that decides if it is a service locator or a IoC container. This is made clear by Martin Fowler [here](http://martinfowler.com/articles/injection.html#UsingAServiceLocator). (Service Locator vs Dependency Injection section.) &gt;The fundamental choice is between Service Locator and Dependency Injection. The first point is that both implementations provide the fundamental decoupling that's missing in the naive example - in both cases application code is independent of the concrete implementation of the service interface. The important difference between the two patterns is about how that implementation is provided to the application class. With service locator the application class asks for it explicitly by a message to the locator. With injection there is no explicit request, the service appears in the application class - hence the inversion of control. 
analogy: People knew how to cook, now they only know how to buy pre-made meals. You forget what goes into it and how to cook it. "1-step forward and 2-steps back."
I love programming, just feeling down. Sorry.
i use this for two reasons, in order of priority 1. to make function calls more verbose 2. save a line from my code a sample use for me would be // this makes it clear what the boolean argument is for $conn = create_connection($persistent = true); // then maybe somewhere down the line if (!$persistent) close_connection($conn); the first use case for me is important, as it somewhat looks like a named argument, and for me, is easy to catch and digest.
Ha... I learnt Pascal in college. That takes me back. Most of my time has been devoted to developing native PHP skills. Its been a shock to the system to learn frameworks.
To be pedantic, that quote doesn't say what you describe, he says "it can do so without having to define that class as a reusable service.". Pimple can do that.
I don't understand this...? Are you not a skilled developer? With 7 years of PHP experience, you should be able to teach yourself symphony or any of the other 'new' frameworks in a week tops. Honestly, it shouldn't take you more than a weekend to learn enough to claim proficiency with a framework. Will you be an expert? No, of course not. I don't want to pile on negativity so here is a document literally written for you. It will walk through the process of going from a flat-php style blog to implementing one using Symfony. There is NO reason you can't be reading this today, implementing a project in Symfony tomorrow and then interviewing with confidence after that. http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html
"Framework agnostic" is a relatively new term, so I'd bet they're not saying that "in a weird way." (You might be interpreting them in that way, though. ;-) No, I think it's more accurate to say that what they want to know is that you actually know PHP, and not merely a set of tools on top of PHP that make you productive in the way you prefer. They want you to be productive in the way *they* prefer, and you being able to work in PHP without a framework as an aid will help them determine that. As someone who has done hiring and firing, I wrote about this issue almost exactly two years ago: &gt; If I ask you to perform a simple task, such as parsing a string in a well-known format, saying “Framework X does that for me” is likely to be seen as a negative. &gt; ... &gt; Saying that you use a feature of “Framework X” for simple things is a negative. It sounds like you’re dependent on that framework for basic tasks. That means we (the employers) will need to train you how to do it without that framework, and that’s a hassle for us. &gt; &gt; -- [Interview Tip: Avoid Mentioning PHP Frameworks](http://paul-m-jones.com/archives/2325) Although that article talks about "simple tasks" in PHP, the idea extends to your entire body of public work. If all your examples are in CodeIgniter, and they don't use CodeIgniter, then you're probably not going to be useful to them because they see you not as a PHP guy but as a CodeIgniter guy.
Basically writing native PHP language is using the core PHP functions provided without frameworks. It doesn't mean spaghetti code. Example: &lt;?php date_default_timezone_set('UTC'); $filename = dirname(dirname(__FILE__)).'/schedule.csv'; $timeformat = 'l, jS \of F Y'; if(file_exists($filename)) { @unlink($filename); } $fp = fopen($filename, 'w'); fputcsv($fp, array('Month','Mid Month Meeting Date','End of Month Testing Date')); ... ?&gt;
Yeah it seems Symfony is cooperates dream framework or Zend.
Cheers mate, everyone's advice has made me feel a allot better. Feeling a little down.
Thanks for pointing that out.
I already understand MVC and routing (rewriting). I have full understanding of TTL. What do you mean by 'freshness strategies'?
I'm beginning to realise this fact :(
Thanks.
I know what you mean and understand your reasoning. Major coops use Microsoft because its Microsoft and they pay to make sure it works. At least the governments are moving to Linux ;) FYI: http://arstechnica.com/information-technology/2013/10/the-navys-newest-warship-is-powered-by-linux/ http://www.techweekeurope.co.uk/news/nsa-xkeyscore-vpn-cracking-123499?ModPagespeed=noscript
Somebody with your experience will definitely be fine. You've been learning best practices through native PHP dev, picking up a couple of frameworks will be easy as pie for somebody with your experience. Plus, you have the wonderful world of frameworks to look forward to. Most everything is built on them today for a reason; they vastly accelerate development time by allowing for rapid prototyping and extension by accounting for common use functionality.
You need to consider the average user of the framework. Most frameworks are not developed for, or even *by* enterprise-level developers. Doing things "the right way" is **hard**, and would alienate a large portion of your user base.
Look at CakePhp. The learning curve is easier. Once you get hold of it, you can jump to Symphony or Laravel. (i have too hard time understanding Laravel :) so you are not the only dinosaur around :) )
Yes, I noticed that while referencing the quote, and almost edited it, but didn't want to change the original words because then it's no longer a quote. I think the point stands though, at least in my mind. For me a DIC should be able to build objects without me telling it exactly how. But, who knows. You say tomato I say tomáto.
I understand Laravel is the most popular framework, but it seems coops prefer the fully featured symfony? I might be wrong, I haven't seen any jobs requesting it.
&gt; With HHVM you are compiling the entire project at runtime Not true. The Zend VM compiles the entire project at runtime, that's the original overhead of an application, and why HHVM even exists. HHVM is a JIT (just in time) compiler, which reduces the actual amount of compute time to boot a project, and only compiles the code for path of the request. (At least I'm fairly certain that's how it works.)
What kind of weird, backwards advice is this? "Learn something shitty, so you can appreciate learning something better later on." No. Learn Symfony and skip the legacy spaghetti code.
Laravel is newer, and hasn't seen as much industry adoption. It's actually based on Symfony components though. It's a fantastic framework. 
The legacy spaghetti code has probably 100 to 1000 times the install base of Symfony, and as a PHP dev, unless you are really good at finding work, you'll be working with WordPress on and off in some capacity, even if it's just "Can we put this on our blog?" 
Don't get me wrong, this isn't a competition its friendly banter between Linux vs Windows or Mac vs Windows... I couldn't learn every language and I had better experience with Linux, that's it. Please don't judge me on a single comment.
I will do, promise.
Cheers mate. After today Im on it. You probably wont hear from me until next week.
To answer the HHVM question: In order for PHP code to run, it requires an engine to execute run. In programming, this "engine" is referred to as a Virtual Machine or VM. Java runs in the JVM (Java Virtual Machine), Erlang has erl, Python has several (PyPy, IronPython) and "native" PHP uses the ZendVM. Most languages have a few implementations. Heck, /u/ircmaxell wrote a PHP VM using PHP, called [PHPPHP](https://github.com/ircmaxell/PHPPHP). HHVM offers another alternative VM for PHP to run on. It gives additional features such as the JIT (just in time) compiler that greatly reduces overhead of code by only compiling the path taken by any particular request (I'm pretty sure). It also grants new language features by way of the `&lt;?hh` style code blocks for their "Hack" language which introduces "gradual typing" for PHP code. I'm sure a lot of this is over your head, but that's ok. Take it for what it is, do your own research, and continue to grow as a developer.
Thanks for making this clear, its much appreciated. Cheers.
You have no idea if hes writing procedural code. All you know is he has never used a framework. If your comparing frameworks to an IDE its like never using an IDE.
I've been using php/mysql for about the same amount of time. I would assume by now that you know how to read documentation and follow instructions. My advice from one pro to another would be to spend some time looking at job postings and figure out what frameworks people are using. Once you know what the job market wants, you should find the docs for those tools. Most good projects have a "Getting started" guide. Follow it, get familiar with developing in that environment. Build a simple blog, doesn't have to be pretty. Make sure you can upload a file, and resize an image. Covering those bases should help. 
&gt; I think your experience should be enough to convince any employer that you've got the skill under your belt, despite having never worked with a specific framework, you still speak the same language. This may or may not be true. We don't know enough about OP to say this, but an employer could judge it. I don't know too many companies that would refuse to hire a good developer just because they're not familiar with framework X. Any good developer can pick it up. On the flip side, I know lots of companies that would not hire someone who only knows how to create .php files with includes full of functions, as that person would likely struggle to master modern web development practices. In such a case even with 7 years of experience you are basically at a junior level when it comes to modern development. I can't say which is the case of OP. I can say that generally in my experience the best developers love what they do, love talking about what they do and love looking into new ways to do what they do. Though it's not universal, if someone has spent 7 years doing php and doesn't even know what a modern php framework is, that's going to be a huge red flag for me. There are, obviously, still jobs out there that don't care about frameworks and dependency injection and ORM's and all the other fun modern things developers do, so one could always search out those gigs. However based on my experience they tend to be fewer, pay worse and tend to be the type of gigs where you are the lone web guy for a smaller manufacturer or something. 
This dont look like MVC.
If relatively new means "been around for a decade" then sure it's new. And as for weird, saying "MVC agnostic" is pretty fucking weird. You want my code to be agnostic of the MVC design pattern? You want my application to be built with multiple architectural philsophies? That's what it sounds like, and thats pretty odd. The rest of your comment sounds like what I said, assuming that they meant to say "dont use a framework because we want to see vanilla stuff". That's fairly standard advice for an interview. :)
Also, try looking into everything in [PHP the Right Way](http://phptherightway.com/), as those are the most current correct way of doing things. I'd also pick a framework that's PHP 5.5 compatible (so not CakePHP or CodeIgniter or other older frameworks). Also look into micro frameworks, as they will best translate from your home-brewed MVC experience. It took me only a weekend to get up to the basics of Symfony 2, and a month to become more familiar with the "Symfony" way of doing things. I suspect the learning curve for Zend Framework 2 is similar. I haven't tried Laravel, but I have tried some micro frameworks and they're usually quite easy to pick up and let you do things "your way" and don't hinder best practices. So I'd suggest picking one easy-to-get-into framework like Laravel or a micro framework and then an enterprise-y framework like Symfony 2 or ZF2. Also, look into a local PHP user group. You can keep up by just going once a month or less as well as get into the community, which is good at promoting best practices (testing, SOLID, virtual dev environments, Composer, etc.). http://php.net has a list of user groups.
Thanks, I will go with Symfony and Magento.
Thanks for the extensive reply, we sell music CDs and discs, so we don't have any complex product configuration (Some products might have different formats, like 2CD+DVD and 7'). What would be your alternative then? Prestashop? openCart?...
Thanks, gotta try it!
Please understand I follow MVC pattern with all projects and fully understand OOP programming. We created a bespoke framework tailored towards the travel agencies.
hey man, I don't want to sound harsh, but if you showed me that in an interview, I wouldn't hire you. While it's pretty straightforward (logic from top to bottom), this is a nightmare to maintain. - How can you unit test that? - it's echoing stuff =| ... - No functions, no class... how do you reuse that part? - Lack of comments If that's vanilla PHP, I don't wanna use that! 
Pick your framework and watch 12 youtube videos and you will be up and running! Good luck!
So true. I was hired out of university where I was trained strictly in Java and C. I only did a couple projects in PHP and MySQL in school. Over the years working for this company I've learned Zend, Yii, Symfony, ActionScript, Perl, message queuing and a whole bunch of other frameworks, design patterns, and tools. It's not about being great at any of those things though, it's about your ability to take business logic and translate it into good code. If you can't do that, no matter what language it is or framework or tools you have to work with, you will always have a hard time finding work.
You know what? I'm in the same situation as you, for the most part. However, a little while back I set up a basic Laravel install and it was *easy as fuck*. With your skill you will have ZERO problems understanding a framework. Spend a week or two of unemployed time spinning up a simple website on a popular framework, make a bunch of forms that do some CRUD, make some views and reports, and by the end you'll be as productive as you need to be to get a job somewhere. It's not going to be that hard, and PHP is here to stay for a long time.
You're not evolving because you're being stubborn. The "it worked for me" attitude isn't going to fly. If you're serious about being a better php developer, stop looking for the rare blogger that agrees with your approach and start trying to learn one of the big frameworks. You don't truly know the advantage until you've tried it. Here's a secret, you don't need to learn all frameworks out there. Learn one of the popular ones (laravel, Symfony, silex, or Zend2). There are a lot of companies that will hire based on just knowing a framework and not any specific one because it will show that you understand the main concepts behind them. Tip #2: put up some code on github. It'll show you have a basic understanding of git and you can showcase your open work there. Throw in a composer.json so you can demonstrate some knowledge of what this dependency manager is I mean this with love. Stop being stubborn and evolve
You're essentially recommending that someone dumb down their choice of workload (and thus, their abilities and experience) because it's "more convenient / readily available". As you learn Symfony, you'll develop knowledge and skills that will make you a better developer overall. As you learn Wordpress, you'll be restricted to *just* WP.
Should've taken the time to add some content yourself before making it public and encouraging others to do so. If you can't put effort into your own product, why would your community do it for you? (Hypothetical question there, not a direct statement/opinion about PHPixie, which I've never used.)
Different strategies to keeping your cached data fresh. There is a pretty famous quote whose source and exact wording escapes me, but it goes something like "there are only two hard problems in computer science - invalidating cache and naming things." Anyway, these were just examples. The general point is that you should focus on keeping yourself up-to-date with the concepts driving all these tools, rather than the tools themselves. There isn't much benefit in being able to say "I know Symfony" from a very broad point of view. Good employers are looking for good problem solvers who have a solid core knowledgebase of concepts within their domain. It's trivial to "learn New Framework X" if you already understand the principles behind it.
What have you got to lose? Worse possible scenario is someone telling you: Not interested. Just respond with "Have a nice day sir!", smile and leave. Edit: Good Luck buddy :)
what stuff can you do with the marval api?
Currently its a read-only API. you can query for comics, creators, series, events and characters. As an example find all comics that spider man appeared in or find all series that were written by Stan Lee.
Fake it till you make it. But in all seriousness, just read over the docs of a major framework to get a basic understanding. All you really need to do is *understand* the concepts. I got hired as a Laravel developer even though I've never used it, nor do I like it.
Wow, I had no idea Marvel had a comic API. Thanks for this!
I add content to "main" sections of the website (tutorials, blog, etc). The community wiki is for letting others add to those. take a look at the site and you'll find a lot of my own content )
While I personally hate using one of the larger frameworks, they're still fun to use every now and then to see what's new. Plus it helps me sharpen my "native" PHP skills by seeing different ways code is done. You got this!
'Senior' developer here...understanding frameworks comes on many levels. Understanding the mechanics and how everything works is one thing...and will get you writing code that *works*. Taking it to a whole other level is understanding **why** someone would use these software patterns (and frameworks), and understanding how best to apply different patterns (and frameworks) - is an entirely different level of 'understanding'. It takes a while (from my experience) to truly get to the deeper understanding (and I am *still* learning...). But it is critical to get there...and to keep going deeper and deeper down the rabit hole. As for the OP...I recommend you do as /u/mike_sol said...learn a (or even better a few) framework(s)...play around with them....and find yourself a job. ...and then never stop learning...that's what it takes in this industry. If you are not comfortable with *that*...well then I really would recommend finding other work.
Knowing the programming language isn't even essential to hiring a developer in a lot of cases. For more senior jobs dealing with more difficult problems it becomes more and more about your problem solving skills (think major companies that need to scale, that do a lot of r&amp;d, etc).
Magento is a big one to jump in to - it took me 6+ months to become really familiar with where laravel took me under a week. Don't let that scare you away though, Magento is in very high demand and pays much better than most other PHP related specializations.
We use it heavily in a pretty large system. Perfect fit for us in that everything can be extended and customized. In an environment with a lot of legacy code like ours where we want to glue the two together, this is a perfect fit for us. Patches/Fixes in github that we submit are quick to be accepted.
Except if a job asked me to know dreamweaver I'd run :D
I don't know if someone has already answered like I'm going to answer, so apologies in advance if this me being a broken record. You are a PHP developer. You can work with any framework they want you to. When applying for a job, during your interview (if you get that far), just so confidence in your ability. It won't matter so much that you don't know the framework, what matters is your ability to pick it up and run with it. It's no different then asking a house painter to use a new kind/formula of paint. They might have never of used it, but given their background it should be little effort to learn and pick it up. You are no different. Just be confident and always say that you can learn. That's my 2¢.
According to your line of thinking we should code everything in C, 'cause that's going to give us the most performant solution, allowing us to fire up the least instances. Do you really think the trade off of swapping a mature, rw proven, audited framework out for the price of a webserver is a good one? You're dismissing an entire ecosystem of documentation, plugins, and help; you're raising the barrier of entry for new developers; and you're going to create code that is guaranteed to be buggier than an established, well tested framework. 
Not knowing how to setup your server is the first step to a giant clusterfuck. All this stuff is now mostly plug and play, so getting it down and knowing how it works, is probably the best things you can do.
discontinued CodeIgniter is a red light in itself.
I can setup servers, but this is a "sensitive" project where security is key and I'm not confident enough to keep a VPS highly secure.
As they say, the proof is in the pudding :) If you are familiar with modern PHP development and already have written your own framework, picking up another one should be no big deal. I would also strongly suggest you get some code up on github, even if it's just demo code you use to write blog posts about proper techniques. It goes a long way. Honestly, I've seen plenty of in house frameworks created using MVC patterns that are absolutely terrible so hearing someone say that in an interview doesn't mean much to me. Someone interviewing you wants to know that you can code well and showing is much more important than telling. 
Don't get too discouraged. It honestly doesn't take a ton of time to get back up to speed. If you understand/learn the MVC pattern, most of the frameworks will at least make SOME sense to you when you start out. Learning Symphony or Laravel may be a good place to start because they have really good docs. Same with Codeigniter. Zend Framework tends to have more raw power and a huge number of available modules/packages, but it's a bit esoteric.
The system gets hundreds of thousands of live page views a day and it works! It has bugs but they do not affect the core functionality. It's very hard changing a successful working system. I can't just fire developers, change platforms and start from scratch.
PHP has fucking changed a lot. Build hobby project. Only way to learn.
That's a terrible analogy. PHP frameworks aren't buying pre-made meals. They are buying ingredients. To put it another way, straight php from scratch with no 3rd party code is like building a farm to grow your own ingredients which you then cook in pots you mined and forged yourself over a campfire you built, all to make a meal. Using a framework is like having a lovely little grocery store where you can go buy flour rather than growing and milling it yourself. Imagine how much longer it would take you to make a cake if you had to do EVERYTHING yourself rather than relying on other people to contribute some of the work of growing, harvesting, processing, etc. That's what it's like to do everything from scratch in PHP. The point of a framework isn't to be a ready made app. The point is to provide a ready made solution for common functionality that almost every app needs. Who wants to write a user authentication system from scratch every time? Not me. By having a framework that provides the basic functionality an app needs you focus your time on the actual problem the application is trying to solve, not the busy work that every app needs.
Link to your client?
Will I get paid extra for that =))) ?
In 20 years, the web as we know it will likely be entirely different. But, if you understand concepts... like MVC - and core constructs, you can adapt your PHP knowledge to Ruby on Rails and Javascript frameworks and applications.
I've been working with frameworks and the like for a few years, but have only relatively recently started looking into things like design patterns, the SOLID principle etc. It's a real eye-opener.
I agree with the previous post. You're more than qualified for any job using a php framework, and possibly even jobs using other languages if your programming skills are high enough. At some point it's mostly learning syntax. 
I was in the same boat, a Drupal dev in procedural land. I saw the writing on the wal and plunged into Symfony 2. Now I have a job as a Zend Framework dev. If I knew then what i know now, i would have started with Silex. You can learn a lot of what is needed by starting with Silex and going forward from there.
Learning Symfony2 will give you that tool set. There will be many projects where straight Symfony2 will make much more sense than Drupal. 
a lot
brand yourself the "naked php developer", start blogging about how you do all your PHP naked - as in, not using a framework - and start getting invited to speak at companies and conferences about the joys of frameworkless PHP. this is another way of suggesting that you find ways of getting people to come to you vs the other way around. Turn your perceived (by you) in to a strength.
Nah, that's just a shitty company where you probably dodged a bullet. It's pretty commonly accepted that adding a new dev to a project will take a good bit of ramp-up time for them to get familiar with the project, tools used, and those kinds of details. Good companies plan to have as much as six months before a new dev is up to full productivity on a new project of any complexity. Don't let a bad experience with a bad company set your expectations low - any respectable company should expect to take some time to ramp things up and get you familiar with things. That isn't something that has changed in the last 7 years. Specific note on frameworks: you know one MVC framework, you pretty much know them all - it's trivial to pick up a new one. Being an expert in the various frameworks is a little different, they all have their idiosyncracies, but knowing it enough to be useful and get started is pretty simple. That being the case, it might be worth just picking a really simple project and implementing it in a few of the more popular frameworks, just so you have an idea of what that might look like. Even if you're not an expert in any of them, being able to discuss the differences between various frameworks (including your in-house one) in an interview would be a big plus, I would think.
&gt; If relatively new means "been around for a decade" then sure it's new. Maybe it's new-to-me. I'd never heard the term before you used it in a blog post a few weeks ago. Do you know its provenance? &gt; And as for weird, saying "MVC agnostic" is pretty ... weird. Agreed; I'm willing to allow that there has been a game of "telephone" going on here, from the original exchange to the OP.
Here ya go https://github.com/chadicus/marvel-api-client
A quick google finds plenty of results. http://james.padolsey.com/javascript/a-framework-agnostic-model/ That dates it to 2009, so we've gone from a few weeks to a few years. https://www.ruby-forum.com/topic/67298 That's 2006. I'd assume the phrase has been around about as long as people have been using the word framework.
I mentioned this in another comment to you, but I think it's worth mentioning again if you keep running into people wanting Symfony: while you're looking for employment, take some time to sit down and build a small project in Symfony. It doesn't have to be anything fancy. A blog, a twitter clone, a quote database, a to-do list, a recipe handler, whatever: just enough that it's doable and will let you try out the various aspects of the framework. If there's some app you've been wanting, even better, just build that. In any case, build something small and doable in an established framework. You'll get familiar enough with the basics of Symfony that you can say in an interview, "we used an internal MVC framework at my previous job, but I've built some small apps in Symfony, and I really liked &lt;x y z&gt; about it" - this will let them know that you have some familiarity with Symfony, and aren't going to turn your nose up at using something you didn't build.
Yaf is basically Phalcon before Phalcon was the new hotness. It's actually very well documented in the official PHP docs being a PECL extension. 
Just logon to peer1 or another dedicated host and setup your own. Dedicated gives you a lot more bang for buck and security than vps. the rest is pretty simple
&gt; https://github.com/chadicus/marvel-api-client Sweet thanks! I was about to role my own, but since you've already done so...
Is it not more dangerous to provide documentation that says one thing and then immediately tell people when they start showing off their code that they should do it a different way? 
Evolve == Know Everything
I'm interested - why don't you like Laravel?
It is different because I am specifically talking about not putting business logic in the controller. I'm talking about putting flow control in the controller but this does not equal business logic. An example of flow control logic: * If the log on fails then redirect to the log on page and display an error (edit: note figuring out whether the log on was successful or not isn't a job for the controller either... it should pass credentials to something in the model layer which deals with the log on, and then redirect according to the result given by that something) An example of business logic: * When the record is saved, send an email to the person saving the record The controller's only job is taking the request and figuring out what the hell to do with it. That's it. Business logic never belongs in the controller, under any circumstance. Your next misconception is that the model is "an abstract way of representing data types with associated methods and properties". That is perhaps PART of the model **layer's** job. Another part is the service layer that the SO answer you linked to is talking about. The model isn't just "User.php" - the model is made up of many many objects. The model is a LAYER of code. Contained within that layer are many structures and patterns which deal with everything from persistence to data abstraction to business logic to application logic.
Maintaining your own framework just turns into hell...good for practice and understanding what is actually happening but in the end you will always be lagging behind.
Think of frameworks as just the dialect of a language. Still the same language but just sounds different than you are used too.
He ssid he doess MVC in another comment.
I'm sorry, but you missed my point entirely. I was answering the question directly and nowhere did I say documentation wasn't needed. Documentation is always...always needed; I just said it wasn't a priority. We might also be referring to different types of documentation here, code documentation vs online tutorials and blog usage postings. The former is exceptional, but it's the latter that's lacking and not the priority. You don't need a community to be successful in industry, just contracts. Whenever I did Java and C work in the past, I wouldn't refer to online communities. Instead, I'd refer to the API documentation provided for different systems. It's a completely different mindset when equating the two. Their documentation consists of a skeleton application for guidance and phpdocumentor output which is sufficient for everything else. Their target audience isn't small startups trying to create something quick and new by copying and pasting and mixing and matching modules. The audience is corporate. To illustrate this, look at the principle parties for ZF and Symfony. Symfony is largely community driven even with Sensio whereas ZF relies more on their principle corporate developer, Zend Technologies. What ZT does is sign those service contracts with companies to provide support and the documentation that's missing in the community. The ecosystems are completely different. Pertaining to your comment about replacing existing enterprise systems, I've done it successfully numerous times. Here's how it works, the software engineers and architects decide what to use while the manager makes sure it's on time and budget. That's an oversimplification obviously since contractual situations like when a company is locked into windows and must build on .NET also play a factor. If a non-software manager is making framework decisions based on popularity, then the project's in trouble before it's even begun. What I have seen that dictates decisions is a requirement by a company to sign service contracts with anything that isn't developed in-house. This means a contract must be signed with the company behind a framework in order for it to be used. I have never once tried to sell a ZF-coder; I sell a software engineer complete with education and experience. If you ever try to sell a framework-specific developer, then you've typecast yourself into a corner. It doesn't matter how good someone is, if they come to me and say "here's a wordpress developer" I'm showing them the door. They should learn the craft and the framework is the tool; I see too many "web developers" now who can't write javascript because they've locked themselves into jquery. The same principle applies here. So to answer it again, what is up with Zend Framework 2 is their focus is on industry and not community.
Laravel is built on symphony2. I'd argue if you're just learning do symphony2; moving from it to Laravel is easier.
&gt; I don't have much experience with frameworks. What should I do? Uhhhmmm...there is a clue in the question, but just can't put my finger on it. Pick on up, run with it, and see where it takes you. Learning a framework is about learning how to grab hold of the ideas that the developers that came before you had, and building upon them. That is a skill in itself.
New-to-me, then. Thanks!