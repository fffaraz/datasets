I don't agree with your characterization of 3 ways for PHP6 to go. That said, I think your #1 is closest -- i.e. there'll be incremental updates that go to great lengths to avoid breaking old code ("ridiculous lengths" is unnecessarily pejorative). Perl 6 does not currently provide backward compatibility with the majority of legacy **Perl 5** code, let alone PHP code, so listing "Backward compatibility with the majority of legacy code" as a bullet point and then suggesting Perl 6 covers that is, well, let me say it stretches credulity beyond breaking point. Putting aside the facts that the Perl 6 team haven't finished a 6.0.0 specification yet, let alone implemented it, and that the Rakudo compiler is slow as molasses, is poorly documented, and isn't practical for much of anything at the moment, I do like many other aspects of Perl 6 and I think I understand where you're going with your comment. I'm guessing your claim is that P6 is designed to interop well with other dynamic langs, such as P5, so if they can deliver on that with P5 then they might be able to do that with PHP. But that's going to take years if it *ever* happens. In [another comment in this thread](http://www.reddit.com/r/PHP/comments/1iw0cj/what_would_you_change_about_php_if_you_could/cb94mvz) I've suggested PHP6 steals the best P6 ideas and ignores its failures. I think this is a much more realistic way for PHP to profit from Perl 6.
Laravel4 uses things called facades. When you issue a static request for a function that is defined in your /app/config/app.php aliases array; laravel uses the mechanism provided by the facade class which can be found here https://github.com/illuminate/support/blob/master/Facades/Facade.php The magic method __callStatic is what does the clever work here and calls the original class. For this to work you need a service provider class that is loaded into the global $app array so that the facade class knows where to find the original class. Here is an example of the provider class for the DB class https://github.com/illuminate/database/blob/master/DatabaseServiceProvider.php I am not the best at explaining these things, and do not have time to write an example right now, but that is the gist of things as I understand them - if you would like to know more simply ask :) edit: Facade Design Pattern: http://en.wikipedia.org/wiki/Facade_pattern
The Perl 6 project seems to both prove and disprove your point. It has "gradual" or "optional" typing. So dynamic typing is one of the basic mechanisms of Perl 6, but it also supports strict typing, when and where you want to use that. But it appears to prove your point in a couple ways. First, Perl 6 is indeed a whole new language (compared to Perl 5). Second, it's taken them 13 years and counting to not even yet get to 6.0.0, so we can be pretty confident PHP6 ain't going take on major changes like that!
Nothing wrong with going with python. What language you choose sort of depends on what you would like to do. For example, if you think you might like to break away from doing php/web stuff, you might consider java or objective C as alternatives to get in to mobile development.
Do some GitHub and open source projects. That's a real portfolio, many recruiters now are as much interested now in a github profile than a resume.
&gt; we can be pretty confident PHP6 ain't going take on major changes like that! That's obvious, considering that some members of the team are pretty conservative :)
 I like your pants 
It doesn't sound particularly nice that you have to define the methods for constructing the enum values yourself - why not implement this via `__callStatic`?
Laziness! :) I was definitely going to, then internet and cats happened. But since you bring that up again, I am definitely, definitely going to implement it. (and also with `__callStatic` you loose auto-completion in most IDE's, so that was also a minor reason) Also note that static methods are completely optional, they are just optional helpers (a few characters less to type that `new Action(Action::VIEW)`))
&gt; Why should we treat type hinting for scalars any different? Because performing an automatic cast to "Exception" is not possible and performing an automatic cast to "array" is not reasonable. Automatically casting "1.25" to 1.25 on the other hand is a reasonable operation. &gt; Especially when, if you want loose type acceptance, you can just leave off the hint and include it in the @parameter attribute? That gives you no type safety at all. With wvenable's scheme on the other hand you are safe against types that just don't make sense (like passing an array to an integer function). Anyway, you are fighting a lost battle here. We will *never* implement strict scalar hinting. If some sort of scalar typehinting will be added, then it will go along the lines of wvenable's suggestions.
Would you recommend contributing to existing open source projects (which ones?) or making your own?
No, for strings (and arrays) we should be using OO.
If there was a core namespace, you shouldn't have to explicitly say "use stdlib", it would be used by default. However, they really should move all the crap out of the main namespace. Obviously keep the big stuff for now like string/array/mysql functions. But just look through the function list and see how much stuff is there that is so rarely used. cairo, cubrid, fbsql, ncurses, svn, trader, and tons of shit I've never even heard of.
Both. Show you can work on your own as well as in a team.
That's pretty damn cool, could see it being useful for learning RegExp in the first place
**Update**: I just implemented them. There even is support for IDE autocompletion with: /** * @method static Action VIEW() * @method static Action EDIT() */ class Action extends Enum { const VIEW = 'view'; const EDIT = 'edit'; }
I dislike SVN, prefer [Mercurial](https://bitbucket.org) or Git.
I've been with Linode for 3 years now and have really enjoyed their offering. Really solid platform and excellent service. They often respond in less than 3 minutes. Further, their guides are amazingâ€”they really helped me learn Linux and web server administration. From what I've read, I do think Linode is a step ahead of Digital Ocean in performance and service offering. However, Digital Ocean is doing an excellent job and is probably the perfect solution for smaller, price sensitive projects.
If I may ask at what company?
I'd would try some frameworks, see what's popular these days and start to get to know them. Yii, laravel, symfony and maybe even Zend ;-) And one of the magic words (well actually two) during job interviews are 'design patterns'. 
SysAdmin/DevOps. If you know server environments like nobodies business, you're invaluable. Combine that with the ability to set up things like Continuous Integration and other developer tools and your value added sky-rockets. VM's and Provisioning are probably the thing I'd try to learn though. You set up the server environment, thats cool. Oh, you did it with {Chef,Puppet,WhateverProvisioning}? That's going to make things easier for sure! You mean you can just clone down some files and type one command and every developer has there own exact replica of the production environment with added tools for debugging....and it works on all three platforms? And it's NOT dark sorcery? (It is, somewhat dark sorcery but you get the appeal.)
No, but gladly willing to work remotely. :)
Learn frameworks! Symfony, code igniter, laravel, cake, etc. More importantly, learn and understand their differences and how they work.
It's available, should be smth like this: $verbalExpression-&gt;startOfLine() -&gt;then('http') -&gt;maybe( (new VerbalExpression())-&gt;find('s') ) -&gt;then('://') -&gt;maybe('www.') -&gt;anythingBut(' ') -&gt;endOfLine(); 
https://www.castmate.fm/login/ OP, get a SSL cert if you are dealing with payments and user/pw.
I never said you should *like* SVN, but if you don't want to learn basic SVN, you risk applying for a job that uses SVN, and therefore won't hire you.
Just a question. The 2nd param of htmentities() is defaulted to 'ENT_COMPAT | ENT_HTML401'. What does the | mean and what does it do?
Well the first thing I did was to read the manual, I just did the mistake of writing lower case instead of upper case.
1. Don't just be a *PHP* Developer. 2. Learn mobile: iOS or Android. Not PhoneGap, not something else, iOS or Android. 3. Learn other systems, such as an NoSQL system like Redis or a messaging system like RabbitMQ. But really, learn mobile development. Which one do you want to learn? It's really up to you.
Stringobjects! I want this so bad! And maybe not only strings. More overloading. __toString() exists, but I miss __toArray() for instance.
Learn Obj-C for iOS development, or Java for Android development. Don't bother with Ruby/Rails. Node.js is worth while, and if you already solid with JavaScript, it will be a fairly easy thing to learn. A weekend project. Both iOS and Android are worth while, and will make you attractive.
This. Definitely. Mobile development goes hand in hand with web development anymore, and being able to hammer out a native android and iOS application to go hand in hand with your web app is a huge benefit. Python is a great language to look into, and I would recommend it over Ruby for sure. In fact, I'd recommend avoiding Ruby like the plague. I know Ruby has it's fans and diehards, but it doesn't scale well and even the Ruby poster child Twitter has been spending the last 5 years moving away from it. Another more contrarian option would be C#. It's beneficial because it's such a well designed and different language from the web focused languages. The main use is for desktop applications, and by going with C# it shows you're willing to use the right tool for the job and not just use the token web project to make everything. It shows diversity, a willingness to use varying technologies for varying reasons, and focuses on a very different line of thinking from web development.
On this note: Build the same end result app in various frameworks, blog about what you learned, liked, didn't like. It shows that you can be flexible, and learn from experience.
Shouldn't the "maybe" return square brackets instead? The example has (s) but shouldn't it be [s]? 
you are confusing Ruby on Rails with Ruby. Which I guess means you haven't looked at either. Good advice.
* Fix the API. * Less silent errors. Anything else would be a "nice to have" for me.
A lot of people use SVN because that WAS the best option when the choice was made. A lot of people use SVN because not all of their developers are command line junkies and SVN quite frankly has better GUI tools. A lot of people won't hire someone who scoffs when they hear a language or tool they don't like, and instead extol the virtues of [insert new up and coming language or tool here]. A good candidate for employment is one that will use whatever tools are available, despite their own personal preference and bias. Learning tools and languages that you don't like is a way of showing employers that you're versatile and willing to use whatever tools get the job done.
Good point, but I have to disagree with one thing: GUI of [tortoiseHg Workbench](http://tortoisehg.bitbucket.org/manual/2.0/workbench.html) for Git/Mercurial is better than any tool I have seen for SVN. 
&gt; Get rid of notices/warnings/errors completely and instead use exceptions I think people asking for this don't understand the point of exceptions or warnings/notices. I completely agree with having real annotations and accessors, though I dislike some of the proposals for implementing them.
&gt; Perl 6 does not currently provide backward compatibility with the majority of legacy Perl 5 code That's [already been done](https://github.com/rakudo-p5/v5), it just hasn't been merged into mainline yet.
I think the move to consistent function naming and parameter orders could be less painful now that we have namespaces. The new functions could go into their own namespace and start gaining usage while the old functions are depreciated. While I'm on the subject, I would like to import entire namespaces. Instead of having: &lt;?php use Vendor\Package\ClassFoo; use Vendor\Package\ClassBar; We could instead have: &lt;?php use Vendor\Package\*; Another possible way to ease the pain of renaming functions and ordering parameters could be using scalars and objects. So instead of creating a new array_key_exists function, we could have: &lt;?php $foo = []; $foo-&gt;keyExists("bar"); 
Good point, but if you have the choice; throw svn in a fire unless you're doing something else than revisioning code binary files for example.
I'm not confusing anything. Another poster had said to look into Ruby + Rails as an option, and as a counterpoint to that I was recommending against Ruby/Ruby on Rails in the context of "becoming more employable." Twitter used to be built on Ruby on Rails for their front end. It's now Scala. They moved both away from Ruby AND Ruby on Rails. There's nothing to confuse. If you want another reason to avoid Ruby, it's only used on 0.4% of websites. http://w3techs.com/technologies/details/pl-ruby/all/all If we're taking about becoming more employable, learning Ruby isn't the way to do it. If you're looking for employment as a PHP developer, learning another web language isn't that beneficial. However, learning a language that is heavily used for LAMP-based servers and to strengthen your portfolio of things you can do. Learning Python over Ruby is a huge benefit, because it allows you to write scripts that can run on the server itself that deal less with the web site, and more with server maintenance as a whole. It's a wonderful combination of web language and desktop scripting language. It's a very versatile language and while less common as a web language, is more common for dozens of other server-side uses. It's a good way to go from web development to desktop development. This is the same reason I recommended C#. I got hired as a PHP developer, and my knowledge of C# and windows desktop development was part of the reason. Not only could I make websites using a web server-side language, but I could write quick stand alone applications to make our office users more productive, and to help administer parts of the website that quite frankly can be written in C# in half the time it'd take me to do the same interfaces in PHP/jQuery. Learning "yet another web programming language" like Ruby, doesn't make you more versatile. It just gives you another tool to do the same exact thing you're already doing and already know how to do. Thus, it doesn't make you more employable as a PHP developer. 
Once again, warnings and notices serve a wildly different purpose than exceptions. What are you going to do.. Wrap every single function call in a try...catch block so you can catch DepreciatedFunctionException and StrictStandardsException exceptions? Warnings and notices are compiler warnings. They're not "exceptional" circumstances, and shouldn't be converted to exceptions.
May I recommend Groovy, Scala or maybe Clojure?
This isn't really possible in a weak typed language. How do you expect PHP to handle this situation: &lt;?php function foo($a, $b) {} function foo($c, $d) {} Strong typed languages can easily support function overloading by examining the parameter *type*. One possible solution for PHP is implementing *guards*. &lt;?php function foo($a) where(is_numeric($a) &amp;&amp; $a &lt; 60) { } function foo($a) where(is_numeric($a) &amp;&amp; $a &gt;= 60) { } function foo($a) where(!is_numeric($a)) { }
Python is a great language to learn to complement PHP. Dynamic-typed frontend + static-typed backend systems are pretty popular and I think PHP/Python combos are extremely powerful and are being used in lots of companies.
The problem with your arguments is that not everybody needs scalability. Actually, very few needs that kind of scalability that Twitter needs. Rails does in fact scale much better than most php frameworks. Also, ruby isn't a web programming language like php. It is an all around programming language. I guess you've never heard of projects like homebrew or chef? I would not recommend C# for the sole reason that you need to run windows, you need to pay attention to licensees that open source languages does not require you to. I'm not saying C# is a bad language, I'm just not very convinced it's a good programming language for the future with major growth in Linux and Mac OS'es. Yes you can of course use Mono solutions, but they are always lagging behind the new features of the framework .NET. But if you run Windows and does not plan to change that, you may have use of C# and .NET. But there is absolutely no need to use any of microsofts stuff if you run Linux.
&gt; No real need. You can already annotate in comments. There are reasonably well known formats for this, and plenty of tools to read them. I'm not really convinced that runtime annotations would be all that useful. The only real reason I would like to see native annotation support is performance. &gt; The fact that PHP makes it difficult to do this could be considered a good thing. Code becomes harder to read, trace, and understand every time you encourage magical behaviours like this. Function overloading isn't all that magical, and like your argument for use of the global keyword, it's a feature supported by many languages. The real problem with function overloading is PHP is lack of types and type casting, which could make it impossible for the runtime to determine which overloaded function to call.
Notices are meant to be ignored if you choose to do so. Killing the script when a notice is thrown defeats the purpose of notices.
&gt; No more use of the &lt;?php tag. I somewhat agree, as the bulk of many frameworks and libraries are straight PHP code and/or classes. But I'm not going to nitpick about something so minor.
I work with the author, feel free to open an issue but I will raise it with them as well
Here's a quick list: - A queue system that lets you do offline processing (store on request, cron to check or something similar) - Notifications of results (just email right now) - Setting thresholds for notifications Since it was based on the PHPIDS system, it also has features in common with it: - Setting exceptions - Setting restrictions ("only look at...") - Uses the same filter definitions I tried to make it so that anyone that's used PHPIDS will feel pretty at home using Expose.
Just buy the best regexp book ever, and learn how to write reg exps Then you can use them in any language without all this verbose absurdity http://www.amazon.co.uk/Mastering-Regular-Expressions-Jeffrey-Paperback/dp/B006DVFVTU/ref=sr_1_2?ie=UTF8&amp;qid=1374678245&amp;sr=8-2&amp;keywords=mastering+regular+expressions
"maybe" makes "(s)?", not "(s)"
Are you developing for yourself, or will someone else be using the final product? If it's for someone else, consider what will be easiest for them to use and maintain. If it's just for yourself, use whatever makes you happy.
If you don't get hired for a development job because you don't know SVN, the hiring manager is a moron. It's a skill that takes a few hours to learn at most. That being said, I recommend understanding as many technologies as you can even if you don't like them.
You'd be surprised how many hiring managers don't know what they're hiring for, or what it *actually* takes.
Yeah but it's not as fun.
I don't know why I got downvoted on my above comment. Your post is clearly what I was looking for. I knew Laravel was using Facade Design Pattern, however I didn't know it was using __callStatic to mimic static behaviour of PHP. It is not the same as directly calling a static method using $this and make PHP generate a warning which you have to silence afterwards. 
This is the #1 thing in my book. It would eliminate thousands of lines of code in my project. Instead, to make sure people can overload every single property, I have to generate getters and setters for each one. It makes objects extendable by default and allows you to hide implementation without refactoring your codebase (and any other codebase using yours). With the rise of Composer, it's vital that we make reusable objects.
Hmm. So, let's say we did the following: $this-&gt;beforeFilter('get_wedding', array('only' =&gt; array('update', 'edit'))); public function get_wedding() { $wedding = Wedding::find(5); } public function update() { $wedding-&gt;delete() // ? } Or, do we add a class scoped variable and appoint wedding value to this? e.g private $wedding; public function get_wedding() { $this-&gt;wedding = Wedding::find(5); } public function update() { $w = $this-&gt;wedding; $w-&gt;delete(); } It's my first time using those before and after filters (I use before filters on routing only) so any examples would be great. 
Yes, you are completely correct, but my point is that it doesn't look good to companies who are going to choose a development language. Twitter dropping Ruby scares other companies from using Ruby. Especially in larger companies, putting your web platform on a language that a well known company is abandoning looks bad to management. As for Ruby not being a web programming language, you are also correct, but it doesn't get used near as heavily from a desktop perspective as Python is. If I had to choose a scripting language to learn for desktop development, it would be Python. Especially in the Linux server world. As for C# requiring Windows, that's one reason why learning it makes you more employable. Most businesses still run Windows. Sure, lots of startups and smaller companies have switched to Ubuntu and Mac OSX, and designers tend to use either of those two OSs, but learning a language that is used by most large businesses is a huge benefit and makes you more employable. On top of that, C# will teach you the concepts of using ASP.net, which is the #2 web programming language. If you know C#.Net, you'll know ASP.Net. I realize C# is unpopular in the PHP/Open Source/Linux/Mac crowds, but the fact of the matter is that knowing it will make you more employable.
Expanding on this, if it's JUST for you (ie a programming blog), write your own. It's a great learning experience, but it's only acceptable if you're the only one who has to deal with the issue that arise. 
I use Pyro all the time. You don't have to use the templating engine. You can use raw PHP in your template files. I know the extensions are ".html", but it's parsed as PHP in Pyro.
True, but converting native types to classes is probably a separate wishlist item all together. And while I really want that too, I think it will require much more work if it should perform well.
Maybe something like this: [The no-framework PHP MVC framework](http://toys.lerdorf.com/archives/38-The-no-framework-PHP-MVC-framework.html)
This was originally started before that PHP port, and this is also PSR-0 and composer ready
One advantage is if, for example, you need to output some other kind of document (PDF, maybe), you can build a PDF formatter and it can take the Form object you've already made. No other changes required. Another advantage is if you want to extend the HTML formatter for say, HTML5's email-type input. Just change &lt;input type="text" class="email"&gt; to &lt;input type="email"&gt; in the formatter, and all your email fields change for free. Of course, if this is all single-use and you know it'll never be used again, feel free to hack up the form in plain HTML. I do so all the time.
I use Concrete5 for many sites. It has a bit of a learning curve if you're new to it, but once you get it, it's really easy to do pretty much anything in. There is a great community and marketplace with plenty of free add-ons to extend/add functionality. 
[This](http://pastebin.com/kSX9fHKA) is the enum class I use in all my projects. It implements [Iterator](http://php.net/manual/en/class.iterator.php), [Countable](http://php.net/manual/en/class.countable.php) and [ArrayAccess](http://php.net/manual/en/class.arrayaccess.php) interfaces so you can use it like this: class Animals extends Enum { const DOG = 'dog'; const CAT = 'cat'; const BIRD = 'bird'; } $animals = new Animals(); echo "There are ".count($animals)." animals.\n"; foreach ($animals as $animal) { echo $animal."\n"; }
There may be dozens of different reasons. Here's a couple reasons off the top of my head: That one line of code replaces a few lines of html. &lt;label for="email"&gt; E-Mail Address &lt;/label&gt; --- The Form class has invalid value logic of some sort. When the submitted form values pass validation, the generated html is this: &lt;label for="email"&gt; E-Mail Address &lt;/label&gt; When one of the form fields fails validation, which may be signaled with a call to Form::invalid("email", "Invalid email address"), the generated html is this: &lt;label for="email" class="invalid"&gt; E-Mail Address &lt;em&gt;Invalid email address&lt;/em&gt; &lt;/label&gt; --- You can easily change the generated html without changing code in your views. Whether you want the generated html to be this: &lt;label for="email"&gt; E-Mail Address &lt;/label&gt; Or this: &lt;label for="pre-defined-id-prefix-email"&gt; E-Mail Address &lt;/label&gt; Or this: &lt;label for="pre-defined-id-prefix-email" class="form-label"&gt; &lt;span&gt;E-Mail Address&lt;/span&gt; &lt;/label&gt; The code in your views is still just this: echo Form::label('email', 'E-Mail Address'); --- The use of a function could be for any of those reasons, or all of them. Either way using the function can make your views look much cleaner. That single function call replaces ugly code like this: &lt;?php if (isset($field_invalids[$field_name])) { $field_classes[$field_name] = "invalid"; } $class = (isset($field_classes[$field_name])) ? 'class="' . $field_classes[$field_name] . '"' : null; $id = (isset($id_prefix)) ? $id_prefix . $id : $id; echo "&lt;label for=\"{$id}\" {$class}&gt;\r\n"; echo htmlspecialchars($field_labels[$field_name]) . "\r\n"; if (isset($field_invalids[$field_name])) { echo "&lt;em&gt;" . htmlspecialchars($field_invalids[$field_name]) . "&lt;/em&gt;"; } echo "&lt;/label&gt;"; ?&gt; Now imagine having 10 form fields on a page, and realizing you made a mistake in your label code. Now you have to change that ugly mess in 10 different places. Ugg.
Personally I find myself using php to build the forms if it's just a standard form with nothing crazy going on. There's been a few forms I've been working on lately which, (for me), are easier to work with if I can see the html.
Yep, that's what I meant.
In order to prevent things from becoming messy you'll need to think about the architecture though. So if you don't want to use an existing one, you'll probably end up writing one yourself. If you want to learn PHP, go to codeacademy.com, they have some good courses.
Drupal - a lot of support, a lot of modules, a lot of community. Developing on it is more of the PAC structure but if you hop into Drupal 8 it operates more like an MVC structure. Its flexible and powerful as writing modules that deal with content, structure, users, or core is very easy once you get a hang of the hook and function model drupal has built in. 
Do you have any suggestions for projects people could develop, for the sake of building a portfolio?
You know you can just use plain old PHP in PyroCMS, right?
Hmmm... I know a lot of people have been super critical of your efforts, and that can suck when you've worked hard on something. I do think that you need to go check a lot of the existing tools. I think there *is* a niche here that isn't covered by existing tools, but at the moment you're trying to cover too much with serverplop, and as a result it does a halfway job of things that could be left to better tools, but doesn't focus on the things that can't be done by other tools. Let me clarify... From out of the box to puppet installed (network configured, virtual mac addresses assigned etc) we use FAI http://fai-project.org - this tool can handle puppet installation instead of serverplop and does a lot more. From there, puppet handles the installation of all the packages to the specified version. The part that doesn't exist is setting up the environments - apache webroots, databases and credentials, staging and dev sites, etc. It seems you may have cracked part of that problem, but you don't necessarily need to include the other parts that other tools already do. Good luck. 
My first reaction was "here we go, some programmer doesn't understand regular expressions and so they have come up with some useless library". I was pleasantly surprised when I actually had a look. Excellent library. Having said that I think everyone should know regular expressions inside and out, if only to use it when finding an replacing in a text editor however library is a good first step in getting to that ultimate goal.
I use PyroCMS and it is fabulous to work with. You could always write with php and html. BTW .. why do you hate templating engines?
Those are very good points, I appreciate your answer. The only thing backing me up from using php to build my forms is the frontend developer. He says it is very confusing to make a quick change or fix when it is build with php.
&gt; What good justification is there for enforcing type conversion simply because it can? Because it makes sense and is perfectly reasonable. And if you enforce strong typing for scalars you're just going to force people to cast. And since casting in PHP is extremely forgiving, you end up losing most of the benefit of the type hinting. 
The work is mostly done for it. Was voted against in Jan. [https://wiki.php.net/rfc/propertygetsetsyntax-v1.2](https://wiki.php.net/rfc/propertygetsetsyntax-v1.2). Shame really. Perhaps a huge push by the PHP community may change their minds. The main reason they gave was some problems with APC opcode caching but that rfc outlines some solutions at the bottom. This single feature would simplify so much. I very much do hope that they see the light. 
Just to add to this - one method a person can use to make a complex regex easier to understand is to break complex patterns down in to individual atoms. As a basic example: &lt;?php $input = "Foo 123 A5F1"; $alpha = "[a-zA-Z]+"; $number = "[0-9]+"; $hex = "[0-9A-Fa-f]+"; $pattern = "/($alpha) ($number) ($hex)/"; preg_match($pattern, $input, $match); While not all patterns need to be done this way, it tends to make it a little easier to see at a glance what the pattern is trying to do. in more complicated regex it can also make it easier to test individual atoms to ensure they're doing what you think they should be doing. This method is especially useful when implementing validations for items in an RFC spec, since an RFC tends to introduce each thing as a series of atoms which then get used in concert to form more complex entities.
Reflection?
I'm not a big fan of the creation syntaxes, but being able to typehint them is really attractive. Definitely very creative.
Maybe you can use this bare bones framework https://github.com/microweber/mvc 
Well, seems like at least a test to see if [register_globals](http://php.net/security.globals) is enabled. If it would be "on" (very bad), it might (haven't tested) cause the global $_SERVER['DOCUMENT_ROOT'] to contain the value of "SHELL_MOJNO_PROBOVATJ". The ["data://"](http://php.net/wrappers.data) part is a bit strange to me, but suggests that they maybe expect the value to be used as a file name (and read with something like file_get_contents). Edit: some googling revealed that it's a [remote code execution attack](http://insecurety.net/?p=742) (they can execute their code if the tainted global variable is used to include files): // $_SERVER['DOCUMENT_ROOT'] is tainted if register_globals is "on" include($_SERVER['DOCUMENT_ROOT'] . '/somefile.php') // executes payload if allow_url_include is "on"
I feel what you mean. However I've built my own framework rather than use these. I'm working on the 4th iteration (which will be the first open source edition). I've always really enjoyed having labels (from the given example) in PHP as it keeps me from having to interrupt the flow of how I'm coding. However I take a different approach by letting my form class handle the work a little easier: $form-&gt;label('Username: ')-&gt;input('username',['type'=&gt;'text','id'=&gt;'username','class'=&gt;['validate','required'] ]); The label only has one input as it only seeds a variable input method to actually build the label (if set). The input field requires you set the name in the first argument and allows you to pass an array of any other attribute to the element in either a string or array. In my example we would get &lt;label for="username"&gt;Username: &lt;/label&gt; &lt;input name="username" type="text" id="username" class="validate required"/&gt; The reason we set our attributes to an array is that it makes it much easier to pass conditional attributes to the HTML such as an error class (passed down from the validation class).
That sounds like an excuse. He can always view the HTML that is output. It depends what needs to change - if the validation is handles server side, then yes, it would be more difficult (for him or her). If it's all done client side, then it shouldn't make a difference.
The status file in the repository says it passes 3.5% of the test suite right now; that doesn't seem "done".
&gt; The best locations to find developer jobs. I currently know of GitHub Jobs[2] , SimplyHired[3] , and Stack Overflow Careers[4] as decent resources. Hahaha, you totally forgot one of the best places: reddit. Head on over to /r/forhire and /r/jobbit. Also be sure to checkout the subreddit specific to your area, such as /r/SFBayJobs or /r/AustinJobs. Also be sure to check out [Meetup](http://meetup.com) groups in your area--a lot of companies in my area go to meetups looking for engineers. Believe me, it's a lot easier to land a job when you're face-to-face with someone. In terms of your qualifications, I'd definitely take some time to learn Linux. [Amazon Web Services](http://aws.amazon.com/) will basically give you tiny little server for free so that you can experiment. You can also fire up a [VirtualBox](https://www.virtualbox.org/) instance of Ubuntu or what have you and experiment on your local machine. Linux is a LOT more portable in the industry than IIS and I think you'll find it's also a lot easier to wrap your head around once you get over the curve.
You're so off the mark with what PSR-0 is.
I'd recommend against not using a framework (at least consider using a "micro framework" like silex), because you'll have to invest some time in learning about security too (sql injections, input validation, output sanitization, xss, csrf, etc.). * https://www.owasp.org/index.php/Top_10_2013-Top_10 * http://www.phptherightway.com/#security
Nicely put. Reading this convinced me to clean up my routes.php and get rid of resource controllers in L4.
I use wordpress frequently at work, I'm primarily a .NET developer so my PHP experience has been limited and most of that has been within wordpress, but as far as I've seen wordpress has been incredibly simple to customize. We generally start with a theme that's close to what we want, make a child theme from it and go from there. So far I've been able to hook filters or actions to pretty much solve any issues that cropped up either from the theme, a plugin, or from wordpress itself. I guess what I'm trying to say is don't knock wordpress before you try it. It can be daunting at first, but it doesn't take long to get a hang of it.
This isn't so much a "i need help figuring this out" request as it is a "please do everything for me" request, and I don't think you are going to get much helpful advise from that style of question. If hiring a professional isn't an option, you might just want to break this project into as many small pieces as you can and work on each one at a time, learning as you go. Good luck.
My only request would be they made a version with static methods so you don't have to keep globalizing the instance pointer in your methods, or passing the pointer around via an argument. I imagine the usability of the object afterwards wouldn't look as elegant
I absolutely disagree with your article. I am using ZF2 and chose to route everything to /controller/action and I'm happy with that. I am not going to manage my 8 controllers with 5 actions each by hand if they follow the same routing logic. My Rest API is the same, routing everything to /controller/{id} relying solely on HTTP methods. No routing needed here... But hey, whatever floats your boat. EDIT : and my routes can be overidden at any time in case I need a special change. No file checking being done here...
Really? You're still doing the tired "lying through cherry-picked statistics" routine, chromatic? The machine-generated `sprintf()` and `pack()` tests alone account for 40% of that test suite. Do the math and try again, with a *valid* metric this time.
PyroCMS templating is really easy to learn. I love that it also automatically detects mobile and will load a completely different template for mobile display if you want. The multi-site manager is awesome. One client has 30+ sites running off one installation on a standard vps. Each site has the option to select from about a dozen different themes with multiple color options. Not to mention that it's being changed over to Laravel, the system is highly customisable and the devs seem to be committed to pushing and using the latest standards for PHP. I'd be hard pressed to recommend any other PHP CMS if being "a nightmare to customise" is one of your concerns. One last thing, from what I've seen, the database is very clean too. I've had no problem getting in there and understanding how the data is structured. 
&gt; SHELL_MOJNO_PROBOVATJ It's just a text "can try shell" in russian. &gt; GET /?_SERVER[DOCUMENT_ROOT]=... Cheking if you have register_globals enabled
You can try Novius OS. It's an open-source CMS based on FuelPHP. FuelPHP is a HMVC framework. some of their creators have been CodeIgniter contributors. You can use any template motor you want, or just PHP for making views. Novius OS is natively multi-sites/multi-languages, builded on the principle that all is application. http://community.novius-os.org/ http://www.fuelphp.com/ 
Mmm, you should learn some design patterns then, like service locator pattern, and dependency injection. These are basically the same for all programming languages. The way I learnt about architecture is basically looking at frameworks and see how they handle it, so as you're not a PHP developer, that might be a problem. However, the creator of Laravel (a very popular PHP framework) released a book '[Laravel: From apprentice to artisan](https://leanpub.com/laravel)' recently and it seems to be a very nice read and should be discussing some general architecture principles. I haven't had a chance to read it so you might want to check with someone else first. Another option is to start with a really stripped-down framework like [Silex](http://silex.sensiolabs.org/) which is actually just a router and a dependency injector. (Sorry if not all those terms are clear) TL;DR look at how other frameworks on how they manage to do things Sorry if not everything is clear, if you have any more questions, just ask :)
I'm actually just looking to get pointed in the right direction where I can get a good starting point. 
I would never rule out a candidate for not having VCS experience. It's easy to learn and easy to teach.
 * Learn Bash shell and basic sysadmin tasks: setup a LAMP environment from scratch, setup an apache virtual server, know how to create users, know how to install linux packages, understand basic security (like why you shouldn't run apache as root). * Learn a framework, preferably one with MVC. It really doesn't matter what it is. Don't worry if it seems overwhelming. * Learn about Design Patterns and Enterprise Patterns. Try using them, and understand when/why to use them and when/why not to use them. Be able to provide specific examples. * Know a version control solution. I personally prefer Git for web-stuff, but it really doesn't matter all that much. * Be able to speak intelligently about problems such as: performance tuning for web applications, web security, e-commerce, web services. * Know your way around SQL and RDBS. No-SQL is the new "cool thing", but it's not nearly applicable for all web applications. You should be able to write basic queries (select, joins, insert, update), you should know about stored procedures, and you should be able to design a basic database and be able to comment on the benefits/drawbacks/assumptions of your design. * Don't have any personality problems. (That's a lot, BTW. If you actually able to know all of these, you're probably a Senior level developer and should have employers breaking down your door).
Looks like you have one of the first steps to writing the program - a plan. Now, follow it! 1) Use a MySQL statement to grab all records within the current day. Just use your timestamp/datetime/whatever time tracking field with a range. Even something as simple as timestamp &lt; currenttime &lt; timestamp. No clue how you're storing the date field, but you should be able to research this and match it up to PHP date() function, php.net can help with this. 2) Read up on your payment processor. They should have the code for this already, with proper success/failure responses. 3) I assume you want it to automatically email everyone when processing is completed? Use the PHP mail() function. Again, php.net has a ton of samples. 4) Storing results should be "easy" as well...in your initial mysql query, you should be grabbing the record id anyway...so just write back to the same record using an UPDATE...WHERE id='$id' Without writing the exact code out (pay someone if you can't lol), this should at least help you think about what to do for your code-writing step.
Try doing a `&lt;select&gt;` field with a default value without using PHP helpers. It's the most boring thing in the entire world.
modx revolution is fine, i always choose it when i have some standard task that needs cms
I think the biggest hurdle is loading the query results into arrays that can then be used in some kind of 'foreach' to build the cURL request. - It also has to take the JSON formatted results and update the DB, send the emails, etc. I've written the code to do these things one at a time, but I'm not exactly sure how to do a whole series at once without potentially causing huge problems. - I don't want the script to charge a user's card multiple times if some variable string gets jacked up and I also need to avoid any type of security issue. Fortunately on the first transaction FirstData provides a TransArmor Token which can be stored and used for future transactions but is useless to anyone that attempted to steal the data. This is the basic code to process each transaction - (Works with a FirstData Class and the GGE$ API): // Purchase Transaction type $firstData = new FirstData(API_LOGIN, API_KEY, true); // Charge $firstData-&gt;setTransactionType(FirstData::TRAN_PURCHASE); $firstData-&gt;setCreditCardType($data['number']) -&gt;setTransArmorToken($data['token']) -&gt;setCreditCardName($data['name']) -&gt;setCreditCardExpiration($data['exp']) -&gt;setAmount($data['amount']) -&gt;setReferenceNumber($orderId); $firstData-&gt;process(); // Check if($firstData-&gt;isError()) { // there was an error } else { // transaction passed } So that part's pretty simple, It's just making that happen for hundreds or thousands of records at once that is a little beyond what I've done before.
What I'm saying is that I explicitely defined my routes as such, no magic here, it's how I chose to do it. If you need to work on my project, look at the config file, it's there in the router section ;) ZF2 makes you define your router, unlike ZF1
Silex is a wonderful microframework, built from Symfony2 (an amazing full-featured) framework. The best place to read is right on their website. http://silex.sensiolabs.org http://silex.sensiolabs.org/documentation
Thanks Gary. I actually use PHP/MySQL quite a bit for various things but I sort of end up learning as I go for some of it. This in particular is not something I've had to do before, but lots of people are doing all the time (recurring billing) - I've pulled apart a huge number of PHP scripts, Joomla Extensions, etc looking for methods by which I can put this together but I haven't really hit on anything yet. I just need it to work properly and be relatively easy to maintain.
Even if a site is only internally accessed doesn't mean there isn't ever going to be a disgruntled employee with access. Also, how secure is the VPN? Do remote users leave their home PC on the VPN all the time, where their kids or others might have access? If legal is really enough of a pain as to prevent you from using a framework, silex may not be the best option.. I'm imagining legal going crazy over each and every composer dependency. You may want to take this as an opportunity to learn some architectural basics, perhaps looking to other frameworks to see how they do things, then start looking for a job with a more sane company if you can, where you can continue to grow as a dev.
This is pretty cool. I encourage anyone wanting to learn regular expressions to buy a copy of [regex buddy](http://www.regexbuddy.com/). I've had my copy of it for years and I still use it regularly because while I'm proficient at writing them now it still makes testing them much easier. Also, I use it as my grep tool to search our code base (it's a lot of code).
If you have explicitly defined a pattern which multiple controllers follow then that's close enough to explicit routing for me. But, I wonder about your example though: `/controller/{id}` Eventually one of these endpoints is going to want a sub-resource, so then you'll have your dynamic routes AND a single lone random route declared yourself? Also, does EVERY single one of your 8 controllers allow GET, PUT, POST, DELETE, etc? If so this is a very rare API :)
If you have it working for 1 transaction you are most of the way there already. Your original post made it sound like you hadn't even started... Why is loading that sql data into an array your biggest hurdle? Using PDO to get your data from mysql should do all that for you: http://php.net/manual/en/book.pdo.php Anyway, if you are concerned about a large result set running you out of memory, you should look to using mysql's LIMIT clause. A very brief example: http://php.about.com/od/mysqlcommands/g/Limit_sql.htm basically just grab a chunk of data from the DB, process it, grab next chunk, repeat until the chunk you grab is smaller than the requested size. PHP also has its own curl library you can use to send out your requests: http://php.net/manual/en/book.curl.php. Then just use json_decode on the result to get whatever data you need from the response, and save that to the DB, again with using PDO. If you are not too worried about how long this takes just grab all that results from the DB, go through each one individually with whatever process you have, save the results, and I think you should be about done. 
I do both, and I can say when I'm on the frontend it's really annoying to have to google how to do something as simple as adding a class to a generated element. Unless you always use that framework, it's a web search every time or a request to the backend guy to add a class used only for CSS. So very lame. And when I'm on the backend, I don't really see a huge amount of benefit from these "try-to-catch-everything" helpers vs e.g. just specifying that id prefix and validation with separate functions/variables. I've also seen monstrosities like 60 lines of javascript passed as one string argument to a "helper" because it seemed like that's how Yii wanted it. I know there was a better way than that, but still, a developer with experience writing html and js came across that helper and thought that was the answer. Another example: is it easier to replace every img tag in an html email with the equivalent helper, and copy all the annoying attributes into the various string arguments, constantly referencing a cheat sheet to figure out what goes where, OR should you just put &lt;?=$img_path?&gt; before the file name in the src attribute? To the people talking about reuse, what is more reusable than html+php? If your company is working on one mega-site then great, reuse your framework-specific html. If you work on more than one thing, you might find it easier to copy your address form from your last project than to copy it, and then replace every element with its helpful helper version. And then change it to the other helpers for your next project. **tl;dr** we all know HTML, and for most things, most HTML helpers are a huge waste of time IMO.
It doesn't come down to any specific language feature; it comes down to identifying what makes PHP cumbersome *and* cannot be reasonably worked around in userland. Take autoloading and scalar type-hints as a pair of often cited examples. Sure, disparate implementations of autoloaders, regardless of what idioms or pseudo-standards they follow, are annoying to work with. Other projects don't always implement them in a manner that matches our expectations. However, it's fairly easy to work around them, create adapters to accommodate interfaces, and move on. On the other hand, scalar type-hinting isn't possible. Just isn't. You can manually box values, but the boilerplate needed to accomplish even the most trivial operations is prohibitive. There might be lots of shitty autoloaders that could benefit from consolidation into core, but at the end of the day, we already have autoloaders. They autoload. We don't have scalar type-hinting. (*among, many, many other things*)
Have you done any search on the API for FirstData GGE4? https://firstdata.zendesk.com/entries/22183523-Helpful-Links-for-Getting-Started-with-GGe4 https://firstdata.zendesk.com/entries/407576-first-data-global-gateway-e4sm-web-service-api-sample-code - This looks like something you should take a look at Searching on FirstData GGE4 api at google also kicks out some information on using it with a few different platforms like Magento and Drupal. 
The underlying problem is that PHP throws notices for what should really be warnings: undefined elements in arrays, for example. These can lead to obscure bugs later on, when further code didn't expect their absence. Dealing with code from junior devs, I see that a lot but it still escapes reviews sometimes. 
Feel free to open an issue or create a pull request and we'll take a look
It doesn't sounds to me like you're going to be able to please anybody here - the legal team want the whole thing to be built entirely in-house to avoid any potential licensing issues, which in of itself seems to me like a lack of understanding (when one department tries to dictate the actions of another it's frankly a nightmare). On the flipside, if you were to even consider attempting this from scratch with little knowledge of PHP you're looking at a good month of research alone - you simply can't learn PHP, OO design patterns, security best practice, DRY, KISS and other related programming principles on top of MVC in a short space of time. You'll end up getting it wrong and redoing big chunks of it anyway - and it you make a hash of the core itself, it could even be an entire rewrite. Not to mention scalability issues and not planning ahead. This, of course, is going to send the accounts department's blood pressure through the roof, because there aren't many companies who'd be happy to write that much time off to research. So, in practical terms you might end up with some sort of middle-ground solution which may or may not work, but as a guy who's been in this situation a good few times, I've found that the best way to tackle is by thinking of it like this: You don't cure a disease by masking it's symptoms. Tackle the actual problem if you can - sit down in a meeting with legal and discuss why you feel a framework is the best solution (pre-proven, extensively tested, scalable, well-documented, secure, standard etc.) and how you can tackle or avoid any licensing issues all together. Throw an hour or two at it, see if you can get past the problem that led you to this one - tackle it at the source. If after all that you're no further forwards, then I suggest you start out with a tutorial [like this one](http://www.webmonkey.com/2010/02/php_tutorial_for_beginners/), and google to find some others (there are scores of them and some will make more sense than others). From here, go on to [learn oop](http://net.tutsplus.com/tutorials/php/oop-in-php/) and get stuck in writing some library code - get a base library set up first. Once you're comfortable you have a decent-ish library, you *may* want to look into MVC, but to be honest I wouldn't push yourself too far too fast. Once you've got an OO library in place, you can build on that and incorporate it into MVC later, but get the basics right first. I appreciate I've not really tackled your question until this last paragraph, and even then I could go into more detail on how to approach it, but you've not really given enough of a clue as to what you need your system to be able to do to be able to offer a less generic guide. Also, I do honestly believe it's worth spending an hour or two with legal if you haven't already trying to work out the issue with frameworks, because better waste two hours and get nowhere than waste a month or two or three or four doing this all yourself only to find that legal were just worrying about a problem that neither requires worrying about nor existed in the first place. Also, as you've said, it's an internal thing... sure it's legal's job to worry about these things, but hey, it's internal, and it's not exactly ridiculously easy to work out which framework you've used anyway (not that they have particularly restrictive licensing). I mean, I don't know all the frameworks well enough myself to work out which a site uses - they all have similar URL structures, and you generally write the code yourself (I know forms are a big giveaway because each form helper will write it's code differently for each framework, but I digress). So you have some pretty decent ammunition with which to fight your corner for using a framework. Saying that, using a framework is no magic bullet in of itself - you still have to have a damned good grasp of the basics and OOPHP and OO design patterns to make use of a framework properly and to be able to extend and mould it to work for you (as they're deliberately designed to be generic). It will, however, save you a lot of the often-difficult-to-grasp code that powers a framework and let you get on with writing your application logic from the off. As a bonus point, because if you're still reading this far you deserve a cookie or a pat on the back, if you do manage to swindle your way into being able to use a framework, pick one which favours convention over configuration - you'll find stuff just works 'out of the box' a lot more. Zend might well be wonderful for industrious applications and Windows servers thanks to LDAP, but good damned luck figuring that out, installing your own ORM such as Doctrine and your own templating engine such as TWIG. So yes, if all that sounds scary to you, then it probably will scare you. Go down the route of something like CakePHP - I use it; I love it - it's simple, easy to learn, quick to get up and running with and tries to get you to do things in a nice, standard way. It tries to idiot-proof a lot of things, which is great even for more experienced programmers, believe me. Some of the best programmers I know are some of the worst at writing code. Sorry to ramble on, but there's a lot more to the question than it might seem, and I wanted to help cover all angles for you. 
They're probing. Looking to see how your server responds.
I don't think companies, especially large ones, get scared of ruby just because it doesn't work well for Twitter nowadays. I work for a large company, which runs java for the most part. But we still have a lot of other apps that run php and ruby. I don't really know if most businesses runs Windows anymore. In fact, most businessnes run linux on the server side and that's what most people are concerned when it applies to companies. Seriously, all new development is done as a website instead of a native application where I work and I'm sure of that it is the same for many others. Then people can use Windows, Linux, Android, Mac or whatever they want on their desktop accessing that service. Of course knowing .NET makes one more employable, because many companies, as you stated, runs .NET and Windows. But I think Java is a way better choice if you want to get employable with a good salary. I'm not attacking C# or .NET, I'm just saying I'm not at all convinced it is the most job-giving language or framework where I live.
Awesome idea to implement these interfaces, I love the "foreach".
rakudo-p5 does *not* currently provide backward compatibility with the majority of legacy Perl 5 code and isn't even aiming at doing so. rakudo-p5 is explicitly aimed (initially) at passing **almost** 100% of the p5 testsuite. It is explicitly not going to deal with XS. The XS exception counts out backward compatibility with the majority of legacy Perl code. XS compatibility will come from a different project, the embedded libperl work (which is also just in progress, not completed). (I've read that they are expected to collaborate, but it's the latter project that has a shot at providing backward compatibility with the majority of legacy code, not rakudo-p5 per se.)
Not a hack. More of a penetration test. Bots will run through a bunch of known exploits to find outdated/unpatched servers -- the low-hanging fruit. Much less common is someone tailoring a hack for your server/code specifically. If you're running a server, you should do some penetration testing or having someone do it for you. Trying to run a server with limited knowledge is a bad idea if said server is hosting something critical to your job/income.
It's the defacto standard. There is a trend to use nginx + php-fpm but Apache works great for most everything.
The majority of Perl 5 code requires XS? Got a source for that?
Cool, thanks. Im a JavaScripter, but pushing myself to php more. 
I could see this being useful when building a regex from a number of variables with unknown values. For example: function findUrls($str, $find_schema, $find_sub, $find_path) { $ve = new VerbalExpression(); $ve-&gt;startOfLine(); if ($find_schema) { $ve-&gt;then('http') -&gt;maybe('s') -&gt;then('://'); } if ($find_sub) { $ve-&gt;maybe('www.'); } if ($find_path) { $ve-&gt;anythingBut(' '); } $ve-&gt;endOfLine(); preg_match($ve-&gt;compile(), $str, $matches); return $matches; } or function findNames($str, array $names) { $ve = new VerbalExpression(); foreach($names as $name) { $ve-&gt;maybe($name); } preg_match($ve-&gt;compile(), $str, $matches); return $matches; } Any situation when building a regex based on unknown values, and you want to avoid the mess of concating strings.
It's like one upping each other on how much you know. Bragging
How is this different from Flux? These two projects seem to have nearly identical APIs. https://github.com/selvinortiz/flux
Isn't that good though? The guy wanted advice, he got advice, someone made that advice better and so on, surely that just benefits you since the quality of the advice is much better than it originally would be.
I understand perfectly well what exceptions are, and my point is that software shouldn't fail silently.
&gt;another commented with the comment "Although this answers the question, more information could be included that would help this user better understand SQL." [...] If you like to wine, for fuck sake GTFO and jerk youself to sleep on how awesome you THINK you are. Jesus christ, man, [calm the fuck down](http://static.fjcdn.com/pictures/Everyone_db2e44_443501.jpg). These are people who take time out of their lives to try and help people like yourself to learn and advance your skills. It's not about one upmanship, it's about trying to help you get a better understanding of the problem and how to solve it. If the answers you get does not answer the question you've asked, it's most likely because you're [asking the wrong question](http://meta.stackoverflow.com/questions/66377/what-is-the-xy-problem), and/or they believe that the answer will better help you in the long run.
What are your requirements?
Fail silently in what way? Warnings and notices are designed to inform you of *potentially* problematic code. Notices in particular are meant to be seen during development, and any problems brought up by the notices should be fixed or purposely ignored before sending your code to production. You're not supposed to catch "strict standards" notices, you're supposed to *fix them*. You're not supposed to catch warnings about output being sent before headers. You're supposed to find the faulty code and *fix it*. Warnings and notices are there to be used during development. That's not what exceptions are designed for. Exceptions handle completely unexpected behavior and failures in your system. For example loosing the connection to a database. The types of errors handled by exceptions can't be fixed during development. Those are "exceptional" errors. I think you are confused over how exceptions, assertions, warnings, and notices should be used, and why each is important to good software development and operation.
Please stop saying I'm confused, I'm not. Trying to access array keys that don't exist isn't a minor problem -- it's a serious error. Trying to append values to an array that hasn't been initialized isn't a minor problem -- it's a serious error. This granularity between different 'levels' of errors supports and encourages sloppy behavior. If someone is trying to dump output after headers are sent, then it's sloppy and it should fail hard.
To get the constants of the class. From the code you posted: $reflection = new ReflectionClass(get_class($this)); $this-&gt;vars = $reflection-&gt;getConstants(); $this-&gt;keys = array_keys($this-&gt;vars);
You are confused. Accessing uninitialized array indexes is a coding error you are supposed to find during development. That's not an exceptional situation. I gather you're not very familiar with compiled languages, and compiler warnings and notices.
Generally my company charges by the hour, but the hours are estimated by us in the initial quote. To the client, it looks like they are getting charged by the site/project, but that's just based upon our estimate. The trick is to make an accurate estimation, this just comes with experience. The rate scales dependent on how much work is involved. For example, a larger project with 100+ hours, would be charged around $50/hr. A smaller project can be up around $60/hr. As a freelancer, you have to charge based around the quality/demand of your product. Good luck 
Keep fighting, we're making progress.
Deeeeyyytoookaaaaaahhhjuuuuuuuuubbbs!
I've been over every page of their 'Knowledge Base' - It's full of incomplete and erroneous information. Besides, GGE4 does not support recurring payments through their API, only through their Hosted Payment Pages, which is not what the client wants to use. The sample code sucks. I've already written better code to process transactions. What I need is a solution that allows me to do a query for accounts that are due to renew on a given day and run through all of the transactions. I'm really curious why you guys think I haven't researched this at all. I have done nothing but research/trial and error for multiple weeks. I have looked into every Joomla subscription extension and all related payment processor scripts. Isn't there a good PHP library out there for e-commerce that will let me customize it a little to accomodate FirstData GGE4? Isn't there a good and simple way to query my DB, run the transactions and parse the results?
Most of the references you'll find in a Google search relate to Linkpoint, which is the older version of FirstData's API and will not work with the account I need to process payments through.
PHP newbie, What would be some ways to prevent this?
I hate it when they can't keep documentation up to snuff. Thats why I like Stripe.. much nicer interface documentation, and easy to use API. If part of what is slowing you down is how to access their API, check out GitHub to see if there are any projects using them. Otherwise, just build a page that does what you want it to do, doesn't render anything to the page, and pull that from a wget based cronjob. If you run php from a commandline you won't have any issues with running into the execution time limit, so you might consider that instead of wget. If you do use wget and pull it as a web page be aware of processing time limits. What I did in that situation was made sure that processes were atomic, i.e. could be rolled back with transaction mode if they didn't complete, and checked time remaining after each atomic process.. then didn't proceed to the next if I didn't think I would have enough time. Then I ran my cron job every few minutes, looking for items to process, then flagging them done as I complete it.. eventually you reach the point where you don't have anything to process left and just exit immediately.
If the html outputted is good and flexible, there shouldn't really be any reason to need to change it with modern css.
Concerning performance. You say &gt;Go and look at the CodeIgniter router and tell me if you think the number of file_exists() and is_dir() checks it performs to maintain that level of guesswork is a good idea. Even if they threw a cache in there, its complicated as f**k and totally unnecessary. With static routes you are saying "take this pattern, and send it to that action" which is super lightweight, compared to: "Is the first segment a directory, or a file? Is the second a directory, or a file, or a method in a file? Madness. Well, the CI router calls is_file() *once* to check if the controller exists before trying to load it, and twice if it doesn't exist, to see if there is a folder. This happens no matter what routes you define. On the other hand if you have hundreds of routes - like reddit does - it will loop through each one and do some regex matching and string replacement that wouldn't be done otherwise. Therefore, explicit routes are not faster. They even have some slight overhead. Laravel is significantly slower in this respect and explicitly defining all your routes might even add hundreds of milliseconds of overhead if you're not careful. However, depending on the case, this may be faster than defining only controllers because [Laravel does that inefficiently.](http://forums.laravel.io/viewtopic.php?id=10675)
My business charges anywhere from $150-$300 per hour. 
Awesome, best answer yet! I wish I could talk these guys into using Stripe, Saasy, JBilling, OpenGateway, Braintree or the handful of others. Unfortunately very few of them support FirstData GGE4. Also the dudes in charge are set in their ways. They are geniusus in other areas, but this is just kinda dumb. GitHub and similar sites have given me some materials to work with, but not anything that works - even with hours of effort in trying to refocus code. I have also gone through hundreds of forum posts and multiple thousands of lines of codes in my hunt for an answer, to no avail. I have to think that someone out there is managing their own recurring payments usng PHP/MySQL (not using Paypal or Authorize.net ARB) - where are they and how do I make friends with them?
register_globals is set as 'off' in the default configuration. So no need to worry. Or in other words, do not mess with your php.ini unless you exactly what a flag does.
See, this makes me ask again.. is the problem with the billing api, or with the recurring part? Recurring isn't hard. Make it once, schedule the recurring with cron. very easy if you can get it solved a single time. If it is the access to their api that is the problem, and there isn't much there as resources in the wild, maybe pester FirstData for a working code sample. Break the problem down to small steps, then code that small step. my recurring thing that i did was a mail server. All I really had to do was track if something had been sent to the mail provider (i.e. gmail) and send it if not. every 5 minutes it checks for new mail from one of my sites and assuming the rate limit for the hour hasn't been exceeded it sends the mail. But really, processing cards isn't that much different. All you do is charge the card instead of send an email. Oh, you mentioned security before. If you are dealing with a database holding credit card information, and you are in the USA, you need to make sure you are up to date on PCI-DSS compliance as well as not storing data you are not supposed to store (like the cvc/cvv2 numbers). As well as encrypting the critical data. One solution a former co-worker ended up doing was having one server to save the stuff that could ONLY encrypt, and one server that could open things to charge stuff that had the decryption key. Kept them separate and worried all the time about someone getting that decryption key. Thats another reason I really like stripe. You get a card token and no worries about losing credit card numbers to a hacker. :) That might be a route to argue for a switch of processor, assuming the company is in a country they support, because security can get expensive when someone breaches it.
Nice. We're getting closer. Doing the query one at a time might be a good place to start. Basically limit the results to the first one then work down through the list, correct? - I don't think this will work forever, but it will get things done until a better solution is found. 
I'm in the US, but PCI Compliance is not an issue because I do not store the card info. I only store the TransArmor Token that I get back from the first transaction. I wrote a bit of code to obfuscate the string containing the actual number for the user's convenience (displays '************1234'), but the first 12 digits are nowhere to be found on my system after they are entered and submitted, except in FirstData's (or the issuing bank's) servers somewhere. **Please send me some links that you think may be helpful.**
I hope you charge a lot more than 60/hour. If not you might want to reconsider unless you're based in a location with terrible work.
It depends on the client and the amount of work. Jobs vary and a lot of our clients are bigger companies that have a lot of regular work. It's just a trade-off for how much work you can regularly get versus how much you'd charge new first class clients. For first class (direct) work we do is usually $75/hr. There are other sources of income as well of course. Maintenance contracts, hosting etc. All adds up to a competitive price (in Australia at least)
I'll go with Reini Urban for now. In his [design decisions on p2 document](http://perl11.org/p2/design-decisions.html), in talking about an approach that *does* include XS support, just not 100% XS support, he writes that p2 "will loose 40% of CPAN code" due to its limited XS support. I'd like to turn this around. You seemed to claim that rakudo-p5 provides backwards compatibility with legacy code. It explicitly doesn't aim to support XS, so were you just ignoring XS?
^ this guy knows
How do you structure Maintenance Contracts and hosting? I charge 10 bucks an hour.. Im in mexico
It does seem a bit bizarre that there are now *three* projects all apparently launched on exactly the same day and all PHP ports of jehna/VerbalExpressions, although Flux doesn't credit this source. Edit: for what it's worth, despite the lack of credit I think Flux has the edge over the other two as it's more flexible - easier to add raw expressions, and you can pass the string format to the different methods so can change bracketing on the fly without the `enableSubPatternCapture()` hoops. This makes support for subexpression more natural, too, not to mention things like lookahead/behind assertions. It also adds expressions in stacks rather than concatenating immediately, so there's the ability to programatically remove elements of the pattern with `removeSegment()` before compiling. There are also more tests (although all three are lacking in this respect). What Flux has against it is the coding style - spaces within brackets everywhere, odd doccomment conventions and generally poorly commented. It should be easier to extend than MarkWilson's, though, which is hampered by unnecessarily private properties and methods, making inheritance a PITA. Please change to protected. Amazingly, the port in the jehna repo is still using PHP 4 conventions ... not to be bothered with, I think. 
Keep your sever up to date! This means apache, PHP, libraries, everything. If you do not have something that makes sure your server is up to date every day you are in trouble.
I suggest you read this : http://static.zend.com/topics/ZF2REST-20130404.pdf ZF2's AbstractRestfulController forces you to implement all of these methods : public function create($data); // POST to collection public function delete($id); // DELETE to resource public function deleteList(); // DELETE to collection public function get($id); // GET to resource public function getList(); // GET to collection public function head($id = null); // HEAD to either public function options(); // OPTIONS to either public function patch($id, $data); // PATCH to resource public function replaceList($data); // PUT to collection public function update($id, $data); // PUT to resource Then every request made to your controller, for instead CityController will be routed according to the HTTP request (GET/POST or PUT/DELETE/PATCH/HEAD/OPTIONS). No need to explicit routing more than /controller[/:id]. All my entities are defined in Doctrine 2 as such : http://yuml.me/9bc4d805.png So all entities are aware of each other if a link exists. I then have an AbstractService implementing basic CRUD operations on them (Doctrine2 EntityManager), and an EntityService extending it for each of them. My RestfulController then chooses which method to implement or not, with the same service for my normal controllers. I forgot to add that by adding an AbstractApiController, which my RestfulController extends, I only need to handle authentification once, on MvcEvents. But when it come to subresources, I work with entity ids and check if $city-&gt;getScenes()-&gt;contains($scene) for instance. I prefer sending my data through headers though, it can get messy with query parameters but that's just my opinion. It's also very easy to create your own HTTP verbs if you have specific needs. All my controllers could have their API done in no time, since it's pretty much always the same logic with CRUD. So to answer your final question, the logic is different with REST, so I separate the controllers. So for my 8 controllers I implemented only 2 so far (corporate needs do not require more), but it was pretty much done in no time. I'm pretty sure I could even abstract the CRUD methods for all my entities.
That's actually only the defaults - you can set the queue and logging mechanisms pretty easily through setters.
yeah, grab a list and do em one at a time. if you can do a single, you can do a batch, and if you can do a batch then scheduling is easy with a crontab. it isnt that complex, my mail processor is like 20 lines all told.
working with a token is much safer. you seem like you have a good grasp of the pieces, you just need to put them in order. maybe a flowchart would help you conceptualize what you need to do a bit better. links to what part of the process? i could point you at the looping part of my mail processor to have an example of the loop type. beyond that, stripe allows for subscriptions so i don't need to worry about scheduled processing .
In my most humble opinion, there is only an advantage in rare cases. If you are making a very simple crud gui, with nothing else front end and where all html elements works the same it will be useful because you can handle the request easier in the back end. But honestly, if you plan to add any form of javascript, does not place your elements in the same way, refactor your code this is certainly not the way to go. Depending on the library doing this, it can be a real hassle to add attributes that's not "normally" there. Like data-attributes. Before you may use this form creator crap fast, you have to learn the syntax for it and it differs for all frameworks. So if you use different frameworks / languages you have to do it different for each project. You can't reuse html between projects that doesn't use the exact same version of the framework or library. Also, you need to refactor all your code if they update the framework.
That's a framework, not a CMS... right?
Or you could write a mod security rule like this: SecAction phase:1,nolog,pass,initcol:ip=%{REMOTE_ADDR},initcol:user=%{REMOTE_ADDR},id:5000134 &lt;Locationmatch "/login.php"&gt; # Setup brute force detection. # React if block flag has been set. SecRule user:bf_block "@gt 0" "deny,status:401,log,id:5000135,msg:'ip address blocked for 5 minutes, more than 10 login attempts in 3 minutes.'" # Setup Tracking. On a successful login, a 302 redirect is performed, a 200 indicates login failed. SecRule RESPONSE_STATUS "^302" "phase:5,t:none,nolog,pass,setvar:ip.bf_counter=0,id:5000136" SecRule RESPONSE_STATUS "^200" "phase:5,chain,t:none,nolog,pass,setvar:ip.bf_counter=+1,deprecatevar:ip.bf_counter=1/180,id:5000137" SecRule ip:bf_counter "@gt 10" "t:none,setvar:user.bf_block=1,expirevar:user.bf_block=300,setvar:ip.bf_counter=0" &lt;/locationmatch&gt; This rule will block access for the offending IP address for 5 minutes upon 10 failed login attempts over a 3 minute duration. Which will redirect you to a 401 page. This prevents not only bruteforce but would limit the impact of the attack on available resources by not reloading the login.php page. After 5 minutes, the block is lifted.
Hi, Please check you website is compatible for following items. Its basic check list for you, will protect your website from most of the hacking attempts. - SQL Injection. - XSS (Cross Site Scripting / js Cross Site Scripting). - jQuery Cross Site Scripting. - Directory Listing. - HTML form without CSRF protection (form posting). - Source code disclosure. - Possible sensitive directories. - Install statcounter analytics or gooogle analytics, will provide you more details for traffic source. - For doss attack you can enable selinux if its linux server. - You can also from request from certain IP address, in firewall. Hope this helps. phptechi.com
&gt; And if you enforce strong typing for scalars you're just going to force people to cast. And since casting in PHP is extremely forgiving, you end up losing most of the benefit of the type hinting. That's actually a very nice argument I didn't hear yet. Seeing it this way, the weaker variant might actually offer *more* in term of type-safety.
correct 
What if I use nginx as my primary server, not Apache?
Then youll have to enable modsecurity for nginx and figure out the configs, i dont see a lot of documentation out there, which is the main reason i dont use nginx. Also, it's no faster than a fine tuned apache + fpm build.
* [Set up REMOTE_ADDR injection](http://stackoverflow.com/questions/5092563/how-to-fake-serverremote-addr-variable) * Hammer the box with forged addresses * Have fail2ban block the gateway, the DNS, the database server, localhost or anything else you please * Brilliant idea, good day, sir
The obvious answer is to supply dynamic content to templates. The common objective is to maintain a separation of concerns by having readable and reusable frontend views and a complex yet extensible backend service layer (or whatever you want to call it). The service layers provide the templates with logic and data. Meaning the same template can be reused multiple times and an almost unlimited number of ways. In your example, before and after events can be dispatched to handle translations or formatting, and even validation. Static html is not reusable, its not dynamic, its often not very readable. Php templates (when done right) are typically within a single page view, very rarely do they scroll to a second or third page view. 
I tried to read the article on my ipad, but the css is messed up and cuts off half the content. Bummer...
i dont really like it, in my eyes it somehow makes the MVC moot, i want to have a designer working the templates who has nearly no knowledge of the language underneath, so its his choice how the form html looks and not the one of the framework i can understand it for very specific problem in smaller projects where TTM is of the essence and you have one person doing php html/css/js all at once (which usually is a bad idea) 
Oops, sorry about that I will try to fix it today in the meantime, here is the raw text. http://hastebin.com/coyutikuxo.txt
Regarding remote address injection, I think it is worth to mention that one shouldn't be able to spoof using just about any IP of his choice. ISPs shouldn't allow to send out packets with source outside of their network. So you shouldn't be able to spoof your IP to be 1.2.3.4, if this IP is not within your ISP's range. It was in the 90's dial-up time when such spoofing maybe was possible, but if some ISP still permits such modifications, I'd be suprised. Also, I'm not sure if HTTP request can be actually spoofed. If one spoofs the source IP address, is it possible to make an HTTP request (because of the failing TCP session)?
Does anyone else think Apache config files are extremely cryptic? I mean look at the snippet above. What kind of self-harming masochist do you have to be to write that shit down? The thing is when you are writing code in most programming languages you get a fair bit of tooling, auto-complete and what not to help you. Plus the language specification means the code will be reasonably readable even if it's badly written. But how do you come up with the snippet above? You have to dig into piles and piles of documentation (if present!) to get something working and even then the whole thing feels a bit fragile. Every time I've had to configure Apache beyond some trivial steps I end up ghosting around on forums and StackOverflow hoping to find something useful. And after I manage to stitch something together it still leaves me with an uneasy feeling because I don't fully understand every part of every line as well as I do with actual code. There's always some residual magic left. 
if you downvote, please explain why.
That answers the question I guess! Apache is the goto for people who don't know what server they need. You'll be fine.
&gt; ISPs shouldn't allow to send out packets with source outside of their network. So you shouldn't be able to spoof your IP to be 1.2.3.4, if this IP is not within your ISP's range. It was in the 90's dial-up time when such spoofing maybe was possible, but if some ISP still permits such modifications, I'd be suprised. Yes, theoretically, no sane ISP should allow out source routed or otherwise spoofed packets. In practice, you should not let your security to rely on anything of the sort. &gt; Also, I'm not sure if HTTP request can be actually spoofed. If one spoofs the source IP address, is it possible to make an HTTP request (because of the failing TCP session)? You only need to deliver the TCP payload. As soon as the request is complete, the web server will begin parsing it and mapping it to a handler. 
Excellent! I am going to take a close look at it.
yeah thats why i asked where he sits, as he said "we" i assumed "he" is a company and for a company it still seemed very low, - but of course there are countries where its totally possible, just not here in germany :)
The "Vagrant" tool should actually be labeled "PuPHPet". Thanks for the list!
You should try awsome forms component in symfony.
This intro was very brief. Will there be an extended version?
Hi latermuse, Yes this was just a brief into HHVM and the core concepts, I'm working on more posts, the next one details how to setup a virtual box for hhvm development, installation etc. My goals is document my process with HHVM to the point of being able to run Magento 
Wonderful. I attempted to do some hacking on HHVM a few years back, but was discouraged by how difficult it was to setup at the time. 
That's really mod_security being cryptic. That said, I've never found Apache config files that cryptic unless you're doing something very esoteric.
The best way to Make currency converter without the hassle of API 
There's also this: https://github.com/mathiasverraes/money
Seems fine to me. No warnings or anything Try using Incognito mode, so all your extensions are disabled.
We're not talking about what you can do now, we're talking about wishlist features. I guess I'm a little confused by this conversation. Autoloading currently works - the technical parts are in the core, the standards are in the community. Great. Scalar type hinting has a few RFCs explaining exactly how it could work, all with minor or no BC breaks. My favorite being the strict weak type hinting, looks great and fits in perfectly with how PHP works. So, it's possible. Then you talk about accessors/mutators. These are not the same as _get/_set at all, and just because we have some vaguely similar weak functionality in the core, doesn't mean we can't hope to add more specific and useful syntax next to it. Are we talking past each other perhaps? Because I don't really see what your point is other than "bad things are good enough, lets just use what we have". 
Good tip for readibility but regular expression already have predefined character types for alpha, number, and more: http://us1.php.net/manual/en/regexp.reference.escape.php They can help in making your patterns more readable. \d - any digit \s - spaces \w - "Word" characters - A "word" character is any letter or digit or the underscore character
I'm aware of that. The example was simplified for the sake of novice users.
How does one deliver a TCP payload without completing a bidirectional handshake?
After reading all the arguments in favor this is still my opinion. Although they can provide some magic in some aspects I still want to leave the view easily maintainable to the frontend developer. 
&gt; Yes, theoretically, no sane ISP should allow out source routed or otherwise spoofed packets. In practice, you should not let your security to rely on anything of the sort. That is right. &gt; You only need to deliver the TCP payload. As soon as the request is complete, the web server will begin parsing it and mapping it to a handler. I don't agree with this. HTTP runs on TCP, and to have an HTTP connection, you must perform TCP handshake. Which is not possible when you don't have an actual control of the IP being spoofed (you would need MiTM etc. for this).
I didn't downvote, but probably because this has little or nothing to do with PHP. Â¯\_(ãƒ„)_/Â¯
... the default is to use the "iptables-multiport" action, which means that only the specified ports would have their traffic dropped. "iptables-allports" is the action that blacklists all traffic from an IP, and it would have to be manually specified in the jail.conf. While forged requests could still be an issue (especially with API access or other known IPs - VIP IPs, if you will), perhaps these are things that can be detected/addressed in the ignoreregex or in the logging code itself. I will endeavour to have a good day, thank you, although I wouldn't say that the idea is brilliant - it's passable and pragmatic, to be used in scenarios where a better architecture can't be put in place. **Edit**: Edited to point out that I am the author of the Throttling post at Whateverthing.
K thanks. I'm a php noob =3
Erm, no you can always define all your methods as unimplemented in the Abstract class that your controller extends ... I guess your controllers are not correctly defined. Besides I think you're missing the way Restful APIs are supposed the work. There's how you like to do stuff and how you should. Rest APIs should return certain codes and should implement a certain amount of functionality...
IMO anyone using Smarty needs to be warned off the Internet 
Ummm, as the author of that `REMOTE_ADDR` post, I don't think you really understood what it was saying. Yes, IP spoofing *is* possible. But it requires you to compromise very low level network systems. And if you can do that, getting around fail2ban is the *least* of the things that you as a security engineer need to worry about. If someone can spoof the localhost/gateway/DNS server/database server's IP, the've either compromised your box itself directly (at which point fail2ban isn't going to help *anyway*), or have compromised your edge router. And if they have compromised your edge router, there isn't much you can do about it anyway either. So in short, if they can spoof an IP worth spoofing as you imply here, they are already MUCH farther along than fail2ban is going to even be able to protect against. So, no, fail2ban is a great *layer* to have in your stack. And if you don't like it because of possible IP injection, I strongly suggest you re-evaluate your priorities...
I don't work as a freelancer. Because very few people are that dumb to pay that ungodly amount of money. And I like it that way :-D
Great, if the Abstract class blackholes them by default that's less of a PITA. &gt; I guess your controllers are not correctly defined. Besides I think you're missing the way Restful APIs are supposed the work. Nah I'm [pretty good](http://philsturgeon.co.uk/blog/2013/07/building-a-decent-api) at them. &gt; There's how you like to do stuff and how you should. Rest APIs should return certain codes and should implement a certain amount of functionality... Mine absolutely do, we're only discussion the creation and the structure, not the effect. Lets get back to the topic: if your routes are explicitly defined, you're doing it right. If they all happen to follow the same pattern and one rule is enough to cover multiple controllers then thats great, until you have to start half and halfing things. That's the extend of the orignal conversation. The rest of it is just the way ZF happen to suggest you do things, but has no impact on the decisions made while producing the API inputs and outputs. The controller and routing logic is different to how I build em, and thats ok. After your last comment it seems less obtrusive than I originally imagined, but we disagree on approaches, and thats ok too. Peace.
If the framework you're using breaks backwards compatibility that badly when it's updated, the framework you're using sucks and you should use a different one. Adding an attribute to an &lt;input&gt; for example, shouldn't be any harder than this, really: $element = $elementFactory-&gt;create(array( 'attributes' =&gt; array( 'class' =&gt; 'input', 'foo' =&gt; 'bar', ), // etc )); (discounting any parse errors introduced, of course. Pseudo-code as well, not meant to represent any particular framework.) Adding an attribute shouldn't be any harder than adding an element in the 'attributes' array. If you have to do the same thing for multiple elements, it may save you time to subclass the element factory class and override the create() method. 
We surely do disagree, but I reiterate what I said, since I had already read your blog post on how to "build a decent API". Shame, if I recall correctly the one on PSRs was quite good. IMHO you seem a little too sure of your knowledge and the arrogance you show in your blog posts doesn't help ;) Might be a good idea to open up your mind a little, mate. But hey I'm not pretending to be an expert so what do I know.
Nice! The benefit of this is the 401 page - you can message directly to the user about what's happened. With fail2ban, things just hang and spin. The drawback is clearly the syntax, the ungodly vomitorious syntax, but that doesn't invalidate the suggestion. Also, sometimes, you really do want certain IPs to just hang and spin. Heh. (I'm the author of the fail2ban post)
Hmmm, I heard hhvm did not currently support magento. Don't remember where I heard that though. Good luck though! 
I set my price the same way. I have a full time job, so if you want me to do free-lance, you are competing with my free time. So it's basically the price you'd have to pay me to give up an hour of my fun.
Hey runamok, It doesn't currently there are bunch of Magento breaking bugs, Daniel Sloof has made great progress, and I'm joining the battle. 
It'll never happen.
We're not actually arguing, you were mistaking me discussing the ZF approach with the CodeIgniter/Fuel/Laravel approach. You initially disagreed with my article and I was pointing out that we are actually agreeing on the routing aspect. I said the rest is different and irrelevant. Not wrong :)
If you have sub directories involved, this doubles up. If you use modular MVC (as the majority of users do) this doubles up. If you use modular MVC with sub-directories this is now doing a lot of checks. Every load. For no reason. It's not going to kill your server, but it doesn't need to happen. How often is your controller moving? CI will perform the file_exists() after a route has been matched, Laravel 4 will match a route to a fully qualified class and an action, so thats definitely faster. Benchmark it. That link to the Laravel post doesn't seem relevant to our conversation.
The sample given: $color = "#f3f3dd"; $PKR = new PKRoundColor(); $roundedColor = $PKR-&gt;getRoundedColor($color); echo $roundedColor; with a bit of syntactic sugar: echo (new PKRoundColor())-&gt;getRoundedColor("#f3f3dd"); Very nice code btw (yes, above works: http://amber.juanleonardosanchez.com/comb.php)
It has something to do with php, it's a very popular templating library for php.
I don't think that giving an error message to attackers is a benefit. If they are blocked, they will manage to guess the reason why. I wouldprefer the fail2ban solution rather than apache. Yes, apache can manage it - but should it? fail2ban seems to more like the right tool for the job. My only concern is that I don't like the low ban-threshold you've posted. As a user who has forgotten which password to use, I can easily try more than 5 passwords within 1 minute (you could ban legitimate users). This is also super slow for a brute force attack. I would raise the number of attempts and lower the findtime. Maybe 30 attempts in 300 seconds.
Thanks for listing "Ode to PHP"!
Juggling the settings is an important point that I did gloss over, unfortunately. I went with settings that would be decent for testing the configuration, but forgot to mention that they should be monitored after the fact to find the right balance (like, 50 tries in 15 minutes - banned for one hour ... or one day ... or forever :) ) I also forgot to mention that all the iptables entries may get removed when the service restarts, so "permanent" bans might be less than permanent.
&gt; If you have sub directories involved, this doubles up. &gt; &gt; If you use modular MVC (as the majority of users do) this doubles up. &gt; &gt; If you use modular MVC with sub-directories this is now doing a lot of checks. Every load. For no reason. But in CI these 1-5 extra calls will happen no matter what routes i define. Defining routes explicitly simply adds extra regex matching and string replacements for every defined route *on top of that*. &gt; CI will perform the file_exists() after a route has been matched, Laravel 4 will match a route to a fully qualified class and an action, so thats definitely faster. Benchmark it. I did benchmark it because i had performance issues with Laravel's router. Checking if a file exists a couple of times takes less than 1ms on my setup, while defining 200 routes in laravel takes over 100ms with XCache. CI routing is way faster, so pointing to it as an example of inefficient implementation is not right. &gt; That link to the Laravel post doesn't seem relevant to our conversation. The point is that you might be correct that explicitly defining routes is faster in Laravel, but simply because controller routing in that framework is inefficient. 
Whoops. OK will take that into consideration
Feel free to suggest new additions weekly. Whilst I have put Sponsored by SourceGuardian (one of my projects) we're not funded in any way. We've consistently sent out every Thursday and hope we can keep it up :) Feel free to share though! All the best Ade
My two cents and please do not hate me... I think this one produces more code and costs more resources than just writing a regex. It doesn't feel like an abstraction like Haml to HTML, sass to css and so on... More code, more chances for bugs. edit: grammar 
I like that one too. Very straightforward and easy to dive in.
Yeah that's a great read!
I used this murach book in a class I took. It was ok. http://www.amazon.com/gp/aw/d/1890774561
I know its far shot and not a every day case, but when minecraft came out,(long time ago in internet time) I wrote myself a c# program that basically allowed me to make... pixel art, from given image. I dont recall names or how much i needed to look, but IIRC c# even had built-in function same as this. this goes to show everything no matter how far it seems, is useful.
&gt; If you want another reason to avoid Ruby, it's only used on 0.4% of websites. That's hardly a reason to avoid Ruby. That source claims that only 5% of the web uses server-side languages other PHP or ASP.NET (and 3% of that is Java). http://w3techs.com/technologies/overview/programming_language/all None of the cool languages have much market share according to that graph. They're still pretty cool languages, worth learning, and employable.
I was in your same situation two years back. I strongly recommend using [NetTuts](http://net.tutsplus.com/). There is a wealth of information particularly for newbies. I often subscribed for the Pro Version too! 
have a portfolio and viewable code on github. this is something i haven't gotten around to doing since i've worked primarily for companies where i could not opensource my code.
I use fail2ban to scan logs for: * faild vbulliten registrations and logins * commenting spam on my custom cms * ssh faild logins * todo: dovecot auth failures &amp; rejected spam mails I block all ports for that IP address for 5 days! My iptables BLOCK list has 500 addresses :D 
Yeah this is me as well. Though I usually price it at around $400-500 or so. Money I'm still willing to work for after office hours.
Not too different for me. Most of my stuff is behind an NDA. 
&gt; Defining 200 routes in either system is going to be fairly slow, but add file system checks to that and guess which is going to be slower. But you're the one advocating for explicit route definition! Without them it ain't gonna be slow.
I don't think this tutorials gives you anything. To start writing PHP extensions, the following things are a must: * Basic extension structure (in this repo) and lifecycle * Functions and arginfo * zend_parse_parameters API * zvals and the corresponding APIs * HTs and the corresponding APIs All these are essential for building any not-absolutely-trivial PHP extensions. From there you can go to more advanced topics like the object and class system. This repo partially covers the *first* of these points. A better version of this is just running `ext/ext_skel` to generate an extension skeleton (including some explanatory comments). Furthermore I should point out that `sudo apt-get install build-essential php5 php5-dev` is a bad idea when writing your own extensions. Instead you should make a git checkout and manually compile PHP. In particular you will want a `--enable-debug --enable-maintainer-zts` build.
You don't have to get rid of your resource controllers. I create resource controllers first, then figure out special cases where exceptions have to be made. // custom user session routes Route::delete('sessions/destroy', 'Admin\SessionsController@destroy'); // user sessions Route::group(array('before' =&gt; 'guest'), function() { Route::resource('sessions', 'Admin\SessionsController', array( 'only' =&gt; array('create', 'store') )); }); I also don't name my routes and use `URL::action()` to point to them in my forms and links. I don't change controller names unless I **really** (never, TBH) have to and URL scheme changes much more frequently.
I believe we are talking past one another. I was essentially pointing out that there are people who are wishing for existing features to be made "better", meanwhile there are non-existent features which (IMO) should have higher implementation priority. To reiterate: We have autoloading, so don't bark about fixing it, it's fine for now; we *don't* have scalar type-hinting, so please get on this bandwagon so it'll happen sooner than later. This can be said of a number of features; I've mentioned scalar type-hinting and accessors/mutators, but the list goes on. This isn't to say I'm against fixing or improving what's in the core now, but I feel that there are some major language-feature pieces missing in the puzzle, and now (*yesterday, but tomorrow will do*) is the time put them in.
I will say though, that of the existing features in core I'd like to see fixed: * Fix reflection, specifically FunctionReflectionAbstract and it's derivatives; it doesn't play intuitively with callable (*boilerplate needed*) * Namespace, rename, and fix parameter ordering on everything; alias to existing, and deprecate as time goes on. We've just celebrated the fourth anniversary of namespaces, so it's about time PHP actually uses them, no? * Fix the damn lexer. There are a few instances where it gets confused and issues a parse error (*namely when doing some inline/literal dereferencing*). This may only fix syntactical edge cases in real life, but the fact that it *doesn't* work now suggests that there are inherent problems. Example: ['foo' =&gt; function ($bar) { var_dump($bar); }]['foo']('bar'); ... to name a few.
&gt; No. There are times when this is actually needed due to how library interactions occur. If you choose to abuse it, that's pretty much your problem. Perhaps this suggests that something needs to be fixed at the library interaction level. I think this speaks of a much greater issue: things being bolted on to keep the whole house from falling down. If libraries fall over each other and need an error suppression operator to talk quietly, I think it's time to refactor those libraries. 
Would be helpful if people noted how many hours they are filling with their rates. I have 2 clients. I charge $25/hr. One pays for 30hrs per week. The other 10hrs per week. Both are on long term rolling contracts. This year I have had 40 hours work every week. I have 3 other clients which I do bits and bobs for. I think I am worth more than $25/hr but I feel I am on to a steady thing at the moment. I am the sole earner in my family. I make enough to live happily enough. I don't want to rock the boat. Before I met my awesome clients I was charging $35/hr and it was really up and down. One month I would have more work than I could do. Then next two would swing the other way. I was probably doing it wrong. I didn't enjoy the uncertainty. Note: Current clients are on $25/hr as this is what I agreed due to the long term nature of the work.
The only problem with using something like fail2ban to handle the throttling is worrying about it keeping up (and the author's solution of a file_put_contents appending isn't helping). With something like mod_security, the evaluation is a part of the request process. When your servers start getting slammed by people sending 10k+ requests a second, which would you rather have? Think about the latency of trying to write out all of those files too - depending on the attack type, that could cause some serious issues with your file I/O...yet another attack vector. It seems a little weird to me to based blocking something like an IP based on a failure in the application logic (bad login) too. The point of throttling is to reduce the requests allowed because of abuse. If it's a number of bad logins, then it should be the application saying "hey wait, you've tried and failed too many times, come back later" not the system blocking them at the IP level.
Could try using the python path as well as specifying the full path for the script you want to execute, something like exec("/usr/bin/python /full/path/to/test.sh");
Just had an .... interesting interview. The guy was trying to use var_dumb. Cracked up our whole team.
yeah .. one might think that at first but as a freelancer you usually are not able to get contracts for 40+ h a week, and you have to pay for quite some stuff (software etc) ... so in the end - for me - the calculation is roughly right, if i take less than 80$ / hour, i get the same in a month as a guy who works full time at macdonalds - of course it would be much different if i could work full time at that hourly rate
What editor is thah ?
Netbeans
Thx
Relevant [dumb variables](http://lists.gnu.org/archive/html/guile-devel/2002-08/msg00163.html) ?
If you write a book on extension writing, I'll buy it. I'd even pre-order it as a kickstarter type thing. There needs to be an up to date, go to resource for extension writing and php internals that assumes intermediate C knowledge and goes through everything. You and ircmaxell would be a great team for the project. I am aware you have started phpinternalsbook.com, but I'd like to see a comprehensive book, it would be one of the best contributions in a long time.
Why would you use python to run a shell script?
Maybe it's just a typo here, but the path separator in Linux is the forward slash, `/`, not the backslash, `\`. Look in the error log file of your webserver, e.g. /var/log/apache/error_log.
This could be an ownership/permission issue with your shell script. I'm guessing your running apache, which is probably attempting to execute the script as the 'apache' or 'httpd' user, who doesn't have permission to the file or folder. Try changing the permissions of the file (if you're really not worried about security, using chmod 777 scriptname.sh). Also, i think Echo and Exec are all lowercase, but I'm not sure if that's just your pseudo code.
What was the question? Just curious. I love solving interview problems.
Hey, thanks for the input. I'm following your work and I'm a big fan. I agree with you that this is not a real tutorial (I shouldn't have put 'Tutorial' in the title). It's more of an example of the most minimalistic php extension that one could write. Also a sort of a way to ease in the extension writing world. edit: grammar
I agree, but the purpose of my post is to retrofit existing applications where you may not be in a position to modify the entire login process or database schema to accommodate that. Just another phase of the constant battle between pragmatism and idealism.
You should insert a record that indicates that it's time to trigger something and have your shell script pull from database with read only account and run when new run request is inserted in the table. That's the proper way to do it and you can do so on remote server as long as your trigger server can access same database. Running scripts 'directly' from web is slow and error prone.
His task was to reverse a string in different ways (array, string functions, recursion). The points is to watch how the people work, so we do it with screensharing. All helpers you usually use while programming (e.g. php.net doc) and your favorite IDE are allowed. Unfortunately about 80% of candidates fail here. Not sure if we should lower our standards or candidates are really that bad. (We're located in Berlin btw.) Next question would be describing a simple resultset from 2 simple tables with inner and left join. &lt;?php $a = 'abcdefg'; // write missing code here echo $a; // output is supposed to be gfedcba (reversed)
Ahh, I see.
I don't suppose you have any recommendations for a good third party server penetration testing service?
To do it recursively you explode, swap first element and the remainder recursively and implode... For str function... can't really say off the top of my which str function, but I'm pretty sure there's a function that'll just do it for you with a single call.
Yeah, obviously without using strrev() ;) And there's possibility to use the string functions within the recursive function.
I may have mis-spoke, but "slow" is a relative term. 200 is more than 100 therefore 200 is slower than 100, but routing X number of things to an exact location is going to be quicker than having it do X number of things AND then do some guesswork. Right?
We like to give our candidates a take home homework to code a daemon-like program that creates a very simple simulation world that just keeps running. We judge them on programming style / speed / and memory usage. It gives them the ability to work w/o the pressure of an interview, and we get to see how they code in a more realistic scenario.
* Sounds terrible, agree. * Agree, and [blogged](http://philsturgeon.co.uk/blog/2013/01/php-6-pissing-in-the-wind). * Agree! `function new()` = nope. `class Default` = BOOM. Thanks...
Is Sara Golemon's book very out of date now? I haven't written extensions recently, so I'm not sure how much the process has changed from 5.2 -&gt; 5.4+
I never intend to change URLs and of course v1.0 wont have anything change, but in 3 months or a year when v2.0 rolls around your client is going to decide they dont like the sound of X and want it to be called Y. Naming routes for me has always been a godsend, and the Rails community have been all about it for a long time.
For Ubuntu I have to $ret = \`bash script.sh\`; Some configurations allow outright execution (\`./script.sh\`) It should also be noted that if your php process runs on another user, it will most likely error. You should give your www (or whatever you called it) user permissions to read and execute that file.
This is what sucks about being stuck in the Netherlands...no awesome conferences like this over here.
It would have been considerate to mention the country. The internet is not the US.
I think using packages is good enough in a lot of cases so long as you at least have the debug symbols installed too (from `php5-dbg`). Not wonderful if you need a debug-enabled Zend Engine, obviously, but it does lower the barrier to entry for basic development. (Edited to add: agreed totally on the rest.)
It's definitely at the point where you have to pick and choose a bit. The basic discussions of things like zvals and reference counting and building an extension are still good, but quite a few specifics are now different.
The thing about the USA is that it's quite large. It would take me over 10 hours to drive there, and I'm on the west coast. A New Yorker is about 2,000 miles away. You could be to Cairo in the time it would take an east-coast american to get to Salt Lake City.
Dutch PHP Conference was pretty good if you ask me! Whereabouts do you live?
#1) I'd keep with using JSON encoded data. Get that information from the server in JSON, and build HTML with that. For example, my login ajax looks something like this $.ajax({ url:'ajax/login.php', type:'POST', data:{ heartbeat:true }, success:function (data) { if (data == "OK") { do login stuff } else if (data == 'FAIL') { do failed auth stuff } } #2) So the trick with this is generally these sites are going to be load balanced, so each request might go to a different server, which splits up the load. This also allows you to refresh small portions of the page without having to refresh the whole page, and lets your page seem to load faster, since you don't have to wait for everything to load all at the same time. Basically you just have several ajax calls in your page, and on each's success, they render html. Now here, you COULD return raw html and just dump it to the page. Or you could return json and have javascript build your html for you, whichever you think is easiest honestly. Off-loading the html generation to the javascript client though does save you a bit of overhead in sending all the html over the network, but I suspect that is generally going to be negligible.
Have a look at the [data-*](http://ejohn.org/blog/html-5-data-attributes/) attribute which is now standard in HTML5. I usually have my ajax calls respond with html, that way I can have the client request something as robust as a php template fully formatted with data; the html is generated at the server and sent back to the client ready to consume. I think it also gets cached. The approach you were asking about is exactly the one I use. We load the base page template, but defer loading of data (aka "lazy load") and those list templates to an ajax call typically in jQuery(document).ready(), or several of them (one for each list, because lists can be refreshed independently of one another). Also, I'm working on a hybrid approach that enables an entire page (including all "ajax" lists/regions) to be rendered in one initial call to the server, but allowing for those lists/regions to also be refreshed independently afterwards. It's a matter of abstracting the proper code blocks and allowing them to be called both synchronously and asynchronously (ajax). I do not adhere to typical MVC conventions though, but that's only because I kind of know exactly what I'm trying to accomplish.
Too bad you couldn't come! Arnhem/Nijmegen, that's perfect! I live in Apeldoorn and there's a PHP user group in Amersfoort which just started. We have our first meeting on Tuesday August 13th, it'd be great if you could come! http://www.meetup.com/PHPAmersfoort/
JSON is more flexible. You can even put an html element/string for a JSON variable. In that case you can have like returnval.output along with like returnval.login_status or whatever. Basically it lets you accomplish what you want with HTML, but also allows for additional information. Personally I don't really see any reason to not use JSON. Even if you are only needing to return HTML, you may want to add additional data at a later date and adding that data will be easier if you are already returning JSON.
Can you drop me a line a couple of days before? Might as well check it out!
Yes, that's true of course, but still. It seems like the conference/PHP community is much more active over there than in the Netherlands (apart from very small regional groups). I mean, there's a conference almost every other week it seems!
I will if I can remember! ;-)
A pretty good method to go by is to use the "accept" http header. You can read this and determine what the request is asking for. This is actually built into jQuery as well. From reading the docs it appears that if you set the dataType when making an ajax request it will add the accept header as well. If you get a request asking for a JSON response, you return JSON. If you get one that asks for HTML you return HTML. This is why using MVC is useful. You always get the same data, but you return it differently depending on what you're asked for. There are some alternatives though. You could append file extensions to your endpoints to determine what kind of data is returned. Asking for /blog/feed might give you html, but asking for /blog/feed.xml or /blog/feed.json would give you xml or json respectively. 
Here's something that others have touched on, but not necessarily said outright. When you charge more, within reason, you automatically become worth more. Obviously you can't price yourself out of the market. If the going rate for a developer of my skill in my area is $95/hr, I probably can't charge $200/hr. However, I probably can charge $145/hr if I'm willing to live with the notion that I have willingly priced myself out of some projects. Personally, I'm fine with that. Charging a higher rate, in general, requires people to respect and value your time. This, in turn, leads to much less scope creep and client shenanigans because it is expensive for them. Basically, I feel like my higher than average hourly rate keeps the problematic clients away. It also means that as long as I'm working as much as I WANT TO WORK, then I can afford to be picky with projects and potential customers, because I'm making more per hour than the going rate in my area. For what it's worth, I live in Dallas, TX, I'm 30, married with no kids, and most years I shoot for making $110k. I can work much less than full time and pull that off pretty easily.
As /u/luminblade said, it is most likely a ownership or permission problem. If you are certain it's not, the only other thing I can think of is the exec () command is disabled in your php.ini configuration. To allow it, open your php.ini file and alter the disable_functions directive to remove exec from that line. Once done, you will need to restart the web server (Apache/Nginx/etc) process. More details available at: http://www.php.net/manual/en/ini.core.php#ini.disable-functions To check what disable_functions is blocking, you can do a simple phpinfo (), or use the shell with something similar to: &gt; php -i | grep disable_functions If all of that doesn't work, try turning on error reporting at the top of your script and note/fix any errors: &gt;error_reporting (E_ALL); &gt; &gt;ini_set ('display_errors', '1');
That is a problem with Linux. To run something serious on a command line, you need proper root (admin) like permissions. The kind of permissions you don't want for Apache. However, since your PHP scripts are run on a webserver, they get run with a same user, making it impossible to run the shell from PHP with permissions of an admin. The only way you can do somewhat easy is to have a chron job that runs with admin permissions and executes files left over by PHP. Thus, making a security hole. This is still better than to run a webserver with admin privileges. 
http://docs.cartalyst.com/sentry-2
If you're doing it interactive it sounds like you should be using javascript and ajax, to then run the php file, which then runs the bash script.
I'm not aware of such service, but if you want to take the rising approach you would use Vagrant for local development, and the (puppet/chef/etc) files used to setup the local virtual machine could be used for the server setup as well.
You might want to look at [zencoder](http://zencoder.com/en/live-transcoding).
https://github.com/darkbls/simple_auth Might be useful for comparison or not
If the URL path ends with .html or they send text/html in the Accept header, return HTML. If the URL path ends with .json or they send application/json in the Accept header, return JSON. Not PHP, but look at Spring's Content Negotiating View Resolver. http://www.javacodegeeks.com/2013/07/spring-mvc-rest-application-with-cnvr-vol-1.html (not suggesting you use Spring, but that you could try something similar in PHP)
Good point; I should have mentioned that.
[Digital Ocean](https://www.digitalocean.com/?refcode=a505d40c33b5) has a VPS for $5/mo. That's a cheap way to replicate any environment you want.
I'm probably biased but Codeigniter was what I learned MVC on. Coming from knowing nothing about MVC (or php for that matter), I was able to set up and start developing in it after only using it for 2 weeks.
Simple..... and robust? Sentry has you for robust. For simple, just Google "simple login script php".
An argument against responding with HTML content: getting carried away and including Javascript content, which introduces debugging problems and potential memory leaks. You can't debug javascript passed in from an ajax call. Sure it will execute with the help of Jquery, but you can't debug it. Here's why: As far as I'm aware, Jquery `evals` any Javascript it finds in the response text after applying the response contents to the DOM via methods like `$(x).html(response)`. Sure you can immediately examine the HTML spawned in DOM in many browsers, but you can not debug the rendered Javascript because each renderance is stored in a separate and brand new memory or framework container object after `eval()` is applied. Keywords: brand new. This behavior also hints at memory leaks. So you want to return HTML - try not to get carried away by including Javascript in that response text.
Uhh Blackhat?
[Opencart](http://docs.opencart.com/display/opencart/Introduction+to+MVC-L) is a nice little MVC framework. It's also practical to learn it.
JSON provides you with more options. Returning HTML, if you were to need any of the returned data, you'd have to reach into the DOM. If it's code cleanliness, or HTML injection you're really keen for, look up Mustache.js. It's a super lightweight, simple templating tool, and provides loops which make dealing with things like updatable list structures a breeze. If you want more power, look to Handlebars.js. 
I had a similar thread going on [r/learnprogramming](www.reddit.com/r/learnprogramming) and I got the script to work when i was root in the terminal, but was still getting errors when running at as anyone else. I ended up just going chmod -R 777 to my webserver documents folder, and that seems to have fixed it. I know it isnt very elegant but as long as it works. 
I checked that and it didnt seem to say anything about exec, and the code worked when I was root. so like you said, it is an ownership/permission problem. Thanks 
Check out explode. Worked awesome for me. http://php.net/manual/en/function.explode.php
I would avoid Codeigniter due to the fact that Ellislab (the people who made CI) [is looking to get rid of it](http://ellislab.com/blog/entry/ellislab-seeking-new-owner-for-codeigniter). Additionally, Codeigniter was never really a very good example of an OO framework. IMO, it's the sort of software you take behind the barn and euthanize. Laravel, Yii, or Slim are decent enough options though.
The fact that they try to call it MVC-L (which really means nothing, it's a completely made up term) because they added localization support is pretty silly.
Because the future of the project is not certain. It makes much more sense to teach them to use something that is guaranteed to be around later.
explode isn't ideal as explained here: http://www.php.net/manual/en/function.str-getcsv.php#101888
They wrote it in PHP-O.
Bypassing "M" and "N" entirely! They must be very progressive. There is no possible way anyone could convince me that using php-o is a good idea.
Yeah I get that, but at the moment the latest release is stable and honestly when I first started out OOP scared me. I had no idea what I was doing and CI was really the best choice when it was time for me to move forward. It probably didn't offer the best look at what PHP5 has to offer, and I probably even set myself back a bit but it was something that was easy to set up and follow with their docs. It allowed me to get a feel for everything and get a pretty good understanding at how MVC worked. OP mentioned that these guys only know their basics, I think starting off with something that's easier for them to understand and slowly moving up the ladder may be better for them. However this is just my opinion, and hopefully starting them off on the right track OO wise is better with a more modern framework, I just hope they don't get confused too easily like I had.
CodeIgniter will probably be the quickest jump into the theory and practical use of MVC. Don't worry about its downfalls -- if you want to learn MVC then this will teach just that.
I had the same issue. Turn on auto_detect_line_endings in php.ini.
Disregarding the fact that teaching people something that could become obsolete is a bad idea, I think if you're going to use MVC as an introduction to OOP you should probably use a framework that actually adheres to proper OO practices. Codeigniter is not really engineered properly.
$csvLine[0] etc, not $data. $data is the original csv array, $csvLine is the current line.
Yeah, I agree with you completely. I just hope this guy is able to help them out considering he doesn't even know much PHP himself.
This is the valid answer.
Although your code is wrong in the loop (as others have pointed out), there's an issue with that function anyway. It is designed to only parse a single line of CSV at a time, so it treats the entire string as a single line and treats unescaped linefeeds as additional separators. Not a big deal if you already know the column width of your CSV since you can use [array_chunk()](http://php.net/array_chunk) to split it in to an array of rows, but if you don't know the width ahead of time you've got a problem. Here is a workaround which uses [stream wrappers](http://php.net/manual/en/wrappers.php.php) to write a variable to memory so it can be accessed as a file resource. This can be used with [fgetcsv()](http://php.net/fgetcsv), and will properly generate each row as its own array: &lt;?php $data = &lt;&lt;&lt;EOT "program_name","merchant_id","code","description","url","start_date","end_date","region","Date_Added","exclusive" "Store1","01","RAWFOOD20","Â£20 off Â£90 spend on Veg","http://www.site.com/ ","2013-07-04 00:00:00","2013-10-31 23:59:59","GB","2013-07-04 01:00:00","No" "Store1","01","RAWFOOD0","Â£10 off Â£60 spend on Milk","http://www.site.com/ ","2013-07-04 00:00:00","2013-10-31 23:59:59","GB","2013-07-04 01:00:00","No"' EOT; $fp = fopen('php://memory', 'rw'); fwrite($fp, $data); rewind($fp); $lines = array(); while (!feof($fp)) { $lines[] = fgetcsv($fp); } var_dump($lines);
i'd suggest using silex because it's based on many components they will likely interact with in their future in frameworks (like symfony 2, drupal 8, ezpublish, and laravel 4) and has an easy learning curve. It should also be very easy for them to run using php's built in web server so they should be able to run it locally quite easily as well.
If you want a local testing environment, check out [Vagrant](http://www.vagrantup.com/). For a remote testing environment, any linux VPS with the same distro as your live server will do. In any case, some knowledge of running a linux server from the command line is required.
If it does what I expect it does, you could for example let users choose the background color of e.g. a profile page, and check whether the color is closer to black or to white. Based on that you can use the opposite color as text color.
I mistakenly make the assumption that people who need to work on my code are competent. It would seem this presumption may be in error?
You do not know anything about my competence. And even if you did, that's a pretty sucky argument.
That's not really PHP related, right?
How about skipping the framework question in total, and introduce them to the basic understandings of design patterns. The things Martin Fowler writes about, proper knowledge of design patterns like decorators, factories etc. are the basics of understanding the true values of OO design. Independent of language, frameworks.. Or if you must make it practical, Fabien Potenciers intro on the principles behind the kernel of symfony2 is a good start on practical web knowlegde. MVC is nice, but it comes from a non web background. Web is centered around requests and responses. Every single HTTP request must get a response. And you can use a model, a controller and even a view to turn a request into a response. 
json is also smaller. less traffic, faster transmission. win win!
Always (99% of time) JSON, never (1%) HTML. Some reasons: 1) client may change over time (desktop, tablet, mobile, embedded device) just returning data allows diff clients to show diff views 2) language may change - data can be embedded diff in diff client skins for diff languages. 3) easier to create unit tests/auto test a JSON interface as you are just verifying correct data is returned with diff calls to ajax interface. For me, all ajax calls in my apps go thru a JS literal object (ns_ajax.js) which uses jQuery for the call but also allows me to log all ajax calls, process errors consistently and trace performance issues. 
Just to add to this, remember the script is run as the user who is running the webserver httpd processes, it has no knowledge of your environment (which path its in, what the system path is etc.) and as written will pause the php script until it completes. So: 1) make sure the script is runnable by the webserver user 2) make sure any files is outputs have permissions to be output to the folder they are being written to. 3) make sure you use absolute path names in the call (even to the shell you want to run the script. Make sure stuff inside the script uses absolute path names. 4) consider using nohup to run script in background without waiting To debug consider putting something simple at top of script and see if you get any output (for example put): #!/bin/bash set &gt; /tmp/test_script exit 
i totally read your name wrong :/
i just dont like the advice you are getting. Here is my advice/answers: 1. Best job sites for techies hands down is dice.com and indeed.com. There are lots of niche sites you can lurk on (like reddit) but they just dont compare. Also get yourself on linkedin and linked to a few recruiters just so you can see what jobs they post on linkedin over the next few months. Beware there are lots of agencies just harvesting resumes. 2. HTML5 and CSS3 are easily learned but will take a while to master. Note for all its buzz HTML5 is not ratified yet - its just that the browser companies have released most of its functionality. Read up on these things but dont take too long to worry about them - you will pick them up on the job. 3. Same with MVCs - Zend is horrible to learn and use, some of the others are easier to pickup. The main thing is you read up on them and you are CAPABLE of using them if need be. For example if/when you get a job that requires XXX framework you can talk about it reasonably competently in the interview then study it heavy for a week or so to be good enough to use it. 4. Re the interview most people in my experience who have ALL the required skills in the job advert are not telling the truth. I want someone who has been developing in *most* of my required technical skillset over the last year or so and is available very soon. I want someone who is enthusiastic, confident, no ego, can work as part of a team, has some initiative, is punctual, well groomed and wants to learn. I don't like job hoppers (those with lots of 6 or 12 month stints at one or more companies). If you are no good technically I can weed that out after you start and during the trial period but I need to get a good feeling about you in the interview. I want someone who asks a few questions about the project, who shows at least a little interest and enthusiasm for what we are trying to do. I never want someone who is strongly opinionated, tells me my technology is the wrong one or is outdated, who refuses to use my tools or complains how we are doing things is old-fashioned or not consistent with what they think. Even if it is the truth!! 5. I would advise you to stick to the LAMP skillset (based on the number of jobs out there), understand JSON/AJAX/jQuery thoroughly, understand SVN/GIT, play a little with Linux and understand some soft skills you may have missed (shell scripts, cron jobs, awk/sed), play more with databases and understand SQL to a good level (DDL/DML). Maybe look into app development and mobile devices as this is the future even for enterprise systems. Understand the basics of object orientated programming and MVC design. Understand what test-driven development means and real-life agile development methods. I would not bother with learning other core languages - the future is either LAMP (with PHP) or .NET or mobile development. I would not bother with Ruby or Python (other than a cursory look). I think Oracle will slowly kill Java. You could swat up on .NET but it is very different to LAMP and you may become just ok-ish at both instead of really good at LAMP systems. Also in general try to think about web applications, enterprise systems on intranets (ie. forget websites). You want to work at the big companies to make the most $$. Last thing, its ok to be humble but be confident. You **are** a LAMP programmer with 5 years experience. Very few people know everything and you will always learn new stuff as you work with new people. Dont be scared to have an opinion (but remember thats all it is). Apply for jobs even if you only have **most** of the skills they request. Just make it clear you can quickly learn any skills you dont know and are motivated to do so.
You should take a look at [Building Your Own Framework on top of the Symfony2 Components](http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1) by Fabien Potencier. Basically takes you from a single file, slowly adding things until you end up with a more proper MVC framework that you assembled yourself. The emphasis of the tutorial itself is not on MVC, but you could certainly take the idea and put more emphasis there. Most of the Symfony components used are really easy to understand as well: HttpFoundation, Routing, HttpKernel. Symfony components, especially HttpKernel and HttpFoundation, are being used in a ton of projects right now so learning them wouldn't be a useless skill.
VPS provider like linode provides you ways to clone a "node" so you can have identical server environment. If you are building your own VPS another solution is to just run a virtualbox (virtualbox.org) yourself on your PC, using the same software and configuration.
for a simple website it shouldn't be a problem. a simple front-controller, use pdo prepared statements in your models and include your views. 
It wasn't an argument, merely a statement about your ignorance. I'll post an actual argument above.
Gotcha, well spotted! Thanks :)
I tried this and struggled to change the input to use the form data. Moreover, the output is very difficult to further manipulate. Thanks for the help though :)
If no one else is going to suggest CakePhp, I am going to. 
Security conference (see website)... php is typically a discussion topic
+1 .. first teach WHY people have come up with MVC which is simply separation of concern at the end of the day. And then show how MVC attempts to solve the problem (and perhaps even some things to watch out for). E.g. making huge controllers, having the model and domain tied together which isn't always desirable, etc...
**Short Answer:** There is no advantage to doing it this way. **Long Answer** You're taking this massively out of context and that's what you need to not do. The code you're talking about probably isn't echo Form::label('email', 'E-Mail Address'); As in, it's probably not just a label floating in the middle of nowhere. It's probably part of a form and inside a template. Which would mean that this would be the label on a field. So actually it would be echo Form::label('email', 'E-Mail Address'); echo Form::text('email'); This way of writing a form input is MUCH shorter than writing out the HTML. But actually this has to do something. So it's probably not just saving you from having to write such a short thing. It's probably actually going to have to support an actual value. And in many forms you have things for editing, for example, you may have the user's previous post and the user's saved data conflicting. So you could actually be saving yourself from writing the following: &lt;input type="text" name="email" id="email" value="&lt;?php echo isset($_POST) ? $_POST : $user-&gt;email ?&gt;"&gt; I note that line doesn't even fit in the live preview... Which says a lot... "Waaaait, that's hardly fair! You're comparing completely different things. The top Laravel example doesn't even have a value set and this one is checking both post and the user info!" Valid. It's not an apples to apples comparison. **Except that it is.** Again, you need to do things in context. No one just makes "a field", they make a form. Laravel allows you to do the following {{ Form::model($user, array('route' =&gt; array('users.update', $user-&gt;id) ) )}} {{ Form::label('email', 'Email Address') }} {{ Form::label('email') }} {{ Form::submit('Save User') }} {{ Form::close() }} (I've switched to Blade syntax, just because I think it's a bit more concise.) By setting the form as a model it will take care of values, filling them from the passed user object, as well as handling priority for things like failed data entry. You can't look at a single element, especially such a simple one, and say that it doesn't have any advantage. The advantages come from being part of a system. 
I decided to use this snippet from the str_getcsv manual: $csvNumColumns = 10; $csvDelim = ","; $csvData = $_POST["csvdata"]; $data = array_chunk(str_getcsv($csvData, $csvDelim), $csvNumColumns); However, there seems to a rolling mismatch which means the output is always one more than the one it should be :S **Edit:** By that I mean: Header 1 - Val1 Header 2 - Val2 Header 3 - Val3 Val1 Header 1 - Val2 Header 2 - Val3 Header 3 - Val1 Val2 etc...
I've written above a detailed response for why this works this way, but my short answer to this specific issue is... too bad. The form is part of a system, and the system has and needs certain technologies. As a front-end developer you need to be wiling to constantly learn new things, and programmatic ways of generating and managing HTML content is certainly one of those. All in all, this is a trivial thing to do. An array can be sent to any element, which takes arbitrary attributes. {{ Form::text('email', $user-&gt;email, array('class'=&gt;'embiggen', 'data-stuff' =&gt; 'whatever')) }} It's hardly rocket surgery. Web development, whether front or back end, is an ongoing process of learning and change. Finding and adopting better approaches is a necessary skill, and should be a passion, not a chore.
This is part of a framework, and the form helper provides huge utility for managing a crud application.
Agree. Considering the students probably have a rudimentary, procedural understanding of php trying to dive straight into an MVC framework (any of the popular ones) could be a bit overwhelming, probably best to have some OO knowledge first. That said, if you're going to teach MVC you could do it without a framework. I'm not saying build a framework just a model, view and controller. They are just objects after all.
Rather than stream the file through PHP, I'd look at proxying the stream at the server level. I'd write my script to do any processing / authentication it needs and then tell the server to switch to the proxy by sending a header. The user will not see the URL of the stream. Take a look at [X-accel](http://wiki.nginx.org/X-accel).
Until HHVM can be easily built in Gentoo, it's going to be dead for me. I mean, seriously, I have tried for 20+ hours over 4 or 5 instances to compile it on Gentoo and it's always a no-good, mostly due to whacky and/or ancient dependencies.
Look for a lib, search packagist for "Carbon" I think it has what you want.
https://github.com/briannesbitt/Carbon
~100-120$/hr I have a full time salary job that gives full benefits for free, so it has to be worth my free time for me to do it. ps: Damn after reading others I should triple that amount lol.
I've quickly knocked something together for you that does pretty much what you asked for: https://gist.github.com/TomNomNom/6095481 A word of warning: people sometimes understand different things when you say 'Next Tuesday'. It can mean either 'The next Tuesday that will happen', or 'The Tuesday that happens next week'. My implementation assumes that latter.
I concur. https://packagist.org/packages/nesbot/carbon
&gt; I guess I just haven't ever really grasped why we need templating engines when, like you said, PHP itself is one. Any thoughts? What you did doesn't autoescape things, for one. Twig escapes by default. That's a big deal when you can necessarily validate that your data is coming from a safe source (which is to say, it's not a hardcoded value). There's also sandboxing. If your template engine is PHP, you can use any of PHP features in a template. That's obviously a bad idea. With a templating engine, you have to explicitly put things into the environment -- functions, variables, control flow structures, etc. The other point that often gets made is that templating engines let designers work more independently without having to "know" php. I'm not sold on that one. &lt;?php foreach ($articles as $article): ?&gt; do stuff &lt;?php endforeach; ?&gt; And {% for article in articles %} do stuff {% endfor %} Look about the same. It's just a matter of what syntax to a designer learns. Granted there is some more syntatic sugar in twig: {% for a in articles %} do stuff {% else %} no articles {% endfor %} And, finally, an anecdotal point: we actually saw improvements in page render time in a few applications just by switching to twig rendering templates (with caching) vs. flat PHP. That's obviously doesn't apply to all templating engines.
I know a few front end people who are puzzled by having to use pure php in the views. But then for some reason you throw twig/handlebars/etc at them and suddenly they are no longer confused. I honestly am on the fence about templating engines though, I mainly use them when I am working with nodejs.
&gt;With just plain old include('template.php') you're passing all variables in current scope. No-one is arguing that you should do that. What we are comparing here is PHP templating a la Savant/Zend View versus templating a la Twig/Smarty/Whatever. These do have scope separation.
Thanks guys, I think that I understand now. As far as I concern Tamplates are being used when there are noPHP people involved in the project, that still do some coding, ad this way we build a bridge between them and our code, tha bridge, that is more understandable for an 'average Joe' than pure PHP. I have upvoted every single comment. Thank you again.
Agree with people saying about Vagrant. Also check out [PuPHPet](https://puphpet.com/). About a month ago it only had setup for local environments, now it also supports Digital Ocean and Rackspace. So I assume they'll be adding more and more VPS providers :)
Because design patterns on their own are pretty dry, and if you don't have a solid frame of reference it just winds up looking like more hassle than it's worth to your students even though it isn't. It's often easier to show someone a way of doing things of thing when you have a framework around which to base why something is useful. Given that most people learn PHP in order to build websites, using something that makes website construction easier as an introduction to patterns just makes sense. This has traditionally been the problem with getting people interested in math. You teach them things like algebra and then move on to something slightly more complex like trig, but with no practical application that matters to them many students are left thinking "when am I ever going to use this?". It's discouraging to that subset of people. To them, learning something like that isn't enough - they need to be able to see how it fits in to some larger picture. If you don't give them that larger picture, the knowledge just gets discarded as useless. On the other hand, if they're given an interesting practical problem where that knowledge suddenly becomes the solution, then they want to know it. The best teachers find ways to make learning seem like it's not actually a chore.
You're welcome. I suggest you write some tests for it to properly make sure it does what you want :)
Few months ago I began learning MVC, and I took this approach: 1) Understanding of how MVC works. How controller/action request is passed through url, how that requests initiates a class and calls a method within the class. Basically, I had to build a very small, query string based MVC app with few controllers and views. Then you incorporate the model to manage data. 2) Once I understood that, I looked at Codeigniter. People might give it some crap, but it's quite easy to pick up, and knowing the above makes the learning process a bit easier. 3) Next I'll be looking and CakePHP and Laravel, will see how that plays out hehe. Hope it helps.
Just an aside: at first i thought you wrote "fapbot", and I thought to myself, "After all these months on Reddit, I'm not surprised at all that a dude named fapbot writes intelligent material about PHP..." But then I realized I'd swapped letters... Freudian slip, most likely. \* Edit: those links were great reads, BTW. Django templating is indeed freaking awesome.
Why would you ENTIRELY switch? Having two web development platforms would be a great help in the future; As you're free whether you'll choose Python or PHP, or both if you want to.
I'm trying not to stretch myself too thin here. I know that I can manage both, but if my class is going to be teaching my PHP, I'd like to focus on that for the time being. I would honestly prefer my course to be in Python if possible, but since it's in PHP I think switching for the duration of the class would enable me to succeed in the class and still grow with my basic skills/knowledge.
Interesting, I'm publishing a follow up of how to setup a HHVM vagrant development box. That could be an alternative in the mean time.
Thanks! I appreciate your answer. You know how the mudslinging goes around languages these days, especially on reddit where no one likes to be wrong. I know that when I first started trying to really learn, I asked which language to pick up and it was kind of a rock/paper/scissors thing with each having it's draw backs and benefits. I don't think PHP would be as prevalent as it is without it being a good and well documented language. Again, thanks for your help!
"With caching" being the operative word there. 
also consider handling it within the server level via ffserver
&gt; The other point that often gets made is that templating engines let designers work more independently without having to "know" php. I'm not sold on that one. At first, i was offended by this idea because it sounded like more work for me (backend dev). But the more i thought about it, i became thrilled that logic can not be DUMPED into templates by frontend devs. I have some seriously talented frontend devs that i work with. Their styling and markup is amazing and device/browser resilient. But when they need some custom logic, they copy/paste and flood the template files with global functions and unscalable conditions. What i need as a backend dev is a consistency of reusable templates and a predictable hierarchy/view inheritance. They should instead be forced to communicate with backend developers to extend or apply new functionality. This gives a moment of reflection by two devs on how to approach a new situation.
You'll have to be more specific. I use Laravel, so I can (if I want) do stuff like.. {{ Form::open(['url' =&gt; URL::route('postcomment')]) }} {{ Form::text('content') }} I usually only use it to open/close forms and for selects, where you really save time.
Are you familiar with Laravel's Form::model()? if you do the following, it will take care of populating the fields, updating them, etc. {{ Form::model($post, array('route' =&gt; array('posts.update', $post-&gt;id) ) )}} {{ Form::text('content') }} It's magical.
Or they're people whose skills and needs have grown beyond doing an include with a bunch of echo statements in it? Dunno, could be either, I suppose.
Yep. Even if you don't use a framework, lots of components from, for example, Symfony, are usable alone, and still useful.
&gt; And, finally, an anecdotal point: we actually saw improvements in page render time in a few applications just by switching to twig rendering templates (with caching) vs. flat PHP. That's obviously doesn't apply to all templating engines. Twig is written in PHP, nothing written in PHP can be faster than PHP itself. If you don't cache, twig will be slower than plain php. If you cache with plain php, plain php will be faster than twig.
Two best things I can think of,t take part in open source projects, conceptualize your own projects and implement it in php.
writing with a framework isn't portable one day that framework isn't going to be maintained and you'll want to use a new one. and you won't be able to.
I would much prefer if the methods didn't alter the original object.
I'm kinda happy I am able to mark off almost everything on that list :-)
and when that day comes I'll spend less time porting it over to another framework than you spent building the same application in the first place.
that is pretty untrue. http://symfony.com/doc/current/book/forms.html there's no way this comes even close to the syntax of the framework you'd move to. you'd have to rewrite your entire application. your views, your controllers, everything.
I *would prefer* a more simplistic form generation API which utilizes HTML as API, akin to: form("&lt;input name=title value=$1 label=Title&gt;", $title, $_POST); form(file("resources/checkboxes2.htm"), $defaults, $input); But obviously doesn't exist, as it would require a semi-parser. And long-winded OO form generation classes are too easy to implement, hence commonplace.
The static methods in Stringy\StaticStringy don't. Only those in Stringy\Stringy modify the object created by Stringy::create(). Do you think it would be better to have each method in Stringy\Stringy return a new Stringy object?
Almost all of those things apply to any web language - and most of them apply to any programming language. It is more a post about how to grow from a programmer to a software engineer.
Yeah, that read like, "bare minimum stuff I need to know to do my job", ha ha
I ended up rewriting it, and decided to split things into 2 classes: Stringy\Stringy and Stringy\StaticStringy. Was hoping for some input though. Another comment in this thread suggested having the methods in Stringy\Stringy return a new object, rather than modify the existing object's property. What do you think? I've never seen a PHP class that used method chaining that didn't modify the original object's properties. But maybe that would make more sense for string manipulation?
I'll be posting the vagrant box later today (really slow upload) so anyone interested can just skip the installation process and jump into a HHVM environment.
For anyone interested here is the follow up article http://coderoncode.com/2013/07/27/first-steps-on-hhvm.html
Absolutely. That's how it works in other languages I'm familiar with. For methods that imply change, like `reverse()`, I'd consider adding `reversed()`, `safeTruncated()` and such. I'd probably also write a `__construct($str, $encoding = null)` for convention, but keep `create()` (which would just `return new self($str, $encoding)`) for instant chaining.
Thanks again for the input. :) I've revised the project, and divided it into Stringy\Stringy and Stringy\StaticStringy in response to the comments in this thread. In regards to the use of UTF-8 - I get what you're saying, but I'd still rather avoid requiring all of Patchwork-UTF8 for a single method: https://github.com/nicolas-grekas/Patchwork-UTF8/blob/9fe2a8601944acffd8f481d26d0f2577b450395c/class/Patchwork/Utf8.php#L39 And about OOP style: do you think it would be better to have methods modify the existing object, or return a new object? Another comment in the thread suggested the latter, which I hadn't thought of. I just feel as though it would be counterintuitive. As for the league, I appreciate the offer! By the looks of the group website though, I don't think this package would qualify, as I don't follow PSR-2 perfectly. (with a quick read, I don't get how the style for closures/anonymous functions were decided within the survey questions/results) Edit: I hadn't realized how extensive Normalizer's coverage was..
Not related to HHVM, but using Vagrant without a provisioner like Puppet, Salt, Ansible, or hell even bash scripts, kind of defeats the whole purpose.
While I do agree, I felt that setting up a vagrant box with a provisioner like chef or puppet, was a little outside the scope of this post. Also the fully setup box will be will be available later today so anyone interested on just having a development environment for hhvm can go and download the box directly. Thanks for the feedback.
Are you referring to Ruby and their use of "!" in function names to distinguish between those that modify self or return a new object? I know python's methods generally return a copy rather than modify the original. I'm still not sure whether or not that'll be counterintuitive for a PHP OO wrapper though, or if almost doubling the number of available methods is a good idea. I'd probably rather stick to one or the other.
It has algorithms, but I'm missing "data structures" in it. A good data structure and algorithm go hand in hand.
Sounds good, although there's a chance that script could time out... You could look into using Gearman to do some parallel processing in this script - basically farm the process out to like 50 (or whatever) workers a time, which should speed the process up significantly and reduce the risk of timeouts...
Great points, thanks. I will definitely check before downloading the photos.
link next to the algorithms takes to the "algorithms and data structures" book although you are right it should say it there 
Just a thought outside you're question... I assume since you plan on updating an existing record, you won't need any sort of historical data? Seems like (without knowing anything about what your intention is) having price data over time for real estate listings would be good info.
Yeah, I'm going to be keeping the data. It really is a poor way of getting the data. Every day, they just release the current listings. Meaning, if something sold yesterday, today it just isn't in the CSV. Unfortunately, that means I don't get the history for what it sold at. To get around it, I'm going to have to make up some sort of code that determines if a record was in today's load file and if not, mark it as inactive but keep it in the table.
are you serious? do you really think you'd be able to take code you write for one specific framework and reuse it? that's not going to be the case at all. different frameworks have different ways of handling everything, you'll have to rewrite your whole application when your framework goes unmaintained.
Ok Frowny McDowner. 
Way to look at things the positive way, haha :P
I'm dealing with similar issues with different type of dataset... ends up being very complicated.
Woops, I missed that. I have the fourth edition of the one by Sedgewick. Great book and definitely recommended it as a first one on algorithms
One way to handle this would be to keep a "last updated timestamp" on each record. Update what is in the CSV file, and those records that did not get updated today (because they have a timestamp older than a day) were not in the CSV. Simples. An "archiving" process would them be able to apply a policy of whatever complexity you like to the records in the database, using the timestamps and current statuses (e.g. no change in 24 hours, mark as "sold pending contract", and in 36 hours take it off the site completely - or whatever rules make most sense).
The first part you mentioned is exactly what I'm going to do. Thanks. Second part wouldn't work. We don't know the reason why a listing isn't in the CSV today. Could be pending, could be expired, could be terminated, etc... That's one of the biggest downsides to the way the state handles this data.
Never thought about returning html as JSON. Sounds like a smart idea. What about making this process a little easier to maintain? All my JS and jQuery scripts stays in a single page as functions and I dislike having a JS file with hundreds of line. I have MVC experience on PHP and I like it, but I never used MVC/P/VM frameworks on javascript. What can you suggest to me to ease those tasks? People says AngularJS is perfect but has a steep learning curve for js beginners. Alternatives like Knockout exists which seems like easier to start with but I don't want to learn something just to prepare myself for Angular if it's alot better than Knockout. By the way, I learn quickest by playing an example, breaking it, reconstructing it. If there is an open source, small sized application exists which utilizes both AngularJS and Laravel, I can easily git clone it and start playing with. :)
Btw, thanks for the reply. I went ahead and modified the class to return new objects rather than modify the original. I didn't feel as though doubling the number of methods was necessary. And after all, most of PHP's string functions return a new string.
Sweet, good stuff. Stringy is going straight into my personal standard library! Cheers.
What I was getting at there, is that you have data, which includes timestamps, and you have some kind of policy - rules you use to determine what to do with those records given their current state. What those rules are, and what data is available, is something you need to determine, but the point is, it can be processed separately from dealing with the created and updated records. You may have additional data you can pull in. For example, for all records that have not been updated in the last 24 hours, you could check a URL to see what the state of those records are on a remote system. The result of that would be thrown onto your own local records and would feed into your policy. In the end, a decision has to be made, and so you need to be able to collect the information you need to make those decisions. If there is really absolutely no way to be sure about what has happened to a property that you are getting no updates on, then you make an assumption. However, that assumption is still a decision your process has made, based on the information that *is* available to it. There is not really much more that you can do.
A benefit to queuing which no one has mentioned yet is that it can let you spread your job out to prevent abuse. Not sure if the images are all on the same server and if automatically getting them all at once is frowned upon. On a couple web servers I run, you'll get throttled if your requests are issued faster than humanly possible.
Well said. It's refreshing to hear someone talk about actual design patterns instead of just the dependency injection framework of the week.
What exactly are your plans for this post? Using HHVM isn't extraordinarily complicated. You just download the binaries and use it as if it were /usr/bin/php (including using the builtin web server).
&gt;Sounds to me you'd prefer to buy tires and logs instead of a car, just in case a car manufacturer stop building their complex products. no, because PHP already is an entire car. using a framework for html output is a wrapper around a form.
Right, the normalizer does a LOT. Even if support is just optional (listed with "suggests") then you will be improving UTF-8 conversion a lot. It's fine to bring something to the league and work on getting it to follow the rules over time, we just expect stuff to follow those rules by the time v1.0 is ready. The group hasn't officially launched yet anyhow. It should return a copy, meaning its not weirdly mutable and can method chain correctly. 
Then: â€” *let's install electric windows on the car* â€” *what for? the car works as it is, that only adds complexity*
Website design needs some rethinking imho, especially the blocky permantly bold fonts
This post is the second of a series, my main goal is to have Magento running on HHVM. Downloading the binaries will get you running with HHVM yes, but the binaries are way behind the current HEAD; HHVM it's still under development and there are several bugs that prevent some of the most popular apps to run on top of it. Facebook plan is to eventually support the top Open source PHP projects on HHVM. What my post covers is how to setup a development environment with hhvm, that means compiling from the source and running it on Vagrant. 
I am so very sorry for the people that are forced to work with you.
everyone at work is generally free to use any framework or code base they like for their projects. nobody chooses to use a framework. some modules yes, but never full out frameworks. I feel sorry for the people at YOUR work who rely on a framework for a language that has built in nearly every function you could possibly need 3 times over. how is it they can't complete their projects in a timely manner using a standard mvc layout and vanilla php?
I'm fairly certain OP didn't post this for design critique. 
http://www.codeproject.com/KB/PHP/ may be something for you. Mine article was published in &lt;2h
Personally, a site that posts submitted content in a matter of hours seems like it is either focused on quantity over quality or just continually rehashing the same beginner material over and over again. Either way, it wouldn't strike me as a serious/professional resource. I'd be happy to take a look at what you've written for PHPMaster.com. It might take a couple weeks from submission time to final publication, but our "bureaucracy" is just review and scheduling constraints. The plus side is that we pay for content, so you can share your expertise and make some pocket change at the same time. Another option is to start your own blog. You'll have complete control over quality and schedule, and over time your readership will grow if you continuously post solid content. Can I ask why the time between submission and publication is important to you?
im very impatient =)
Yes, start a blog...then tell me about it ;) (@phpdeveloper)
my eyes hurts
Heheh... I assumed the @ would get expanded... How naive. =) Thanks so much for the tip! 
Sad [Phalcon](http://phalconphp.com/) DI is not in the bench.
We do it wiki style at [DocForge](http://docforge.com). Your content is immediately published and then reviewed and edited by the community.
I think this is the wrong template file. You might be better off using the wordpress stack overflow site and let them know what the name and source of the theme you're using is. At first glance this looks like a center column content include.
In addition to that, you normally don't want to edit a theme's files, you want to learn how to extend a theme. Otherwise if the theme's author makes an update and you update the theme, your custom coding changes will be overwritten. It's a risk, i've broken the rule before myself, but it's good to know.
I'm not planning on editing the theme. I'm going to add a new template based on the instructions in the Blog Page Template PHP ------------------------------- /* Include the Post-Format-specific template for the content. * If you want to overload this in a child theme then include a file * called content-___.php (where ___ is the Post Format name) and that will be used instead. */
If I installed a plugin that allowed PHP in blog posts, could I have php in a sidebar that calls the php text in the post to the sidebar?
Sorry, we don't allow job postings that are not telecommute positions. Good luck.
I dont think job postings are explicitly banned in this sub but I wouldn't expect this type of post to be popular here. You might have better luck looking in /r/forehire. Also, I'm not sure if you've tried it already or how the situation is in Cincinnati but here in the Minneapolis / St Paul area there are plenty of recruiters that will find contractors for you. That's typically how I found work when I was contracting for a few years. I'm sure there is probably a Robert Half Technology branch around your area. I only bring this up because they cover contracting, contract-to-hire and direct hire roles depending on your needs.
Use INSERT ... ON DUPLICATE KEY UPDATE ... . You can insert in batches this way. If you need to know if a record was inserted/updated just do them one at a time and check the affected row counts. If you want more info, reply, on my phone ATM.
I may be wrong but it's not available as an individual package and can't be installed as simply as the others can it? If I am wrong I'd be happy to add it
Using a queue table is a good idea, though at 6000 rows having to start over is not a big deal. That said, you could insert into the queue table then do a single query to update your main table. This assumes you have some sort of index\unique identifier for each record: INSERT INTO main_table (unique_index, col1, col2, ...) SELECT (unique_index, col1, col2, ...) FROM queue_table ON DUPLICATE KEY UPDATE col1 = VALUES(col1), col2 = VALUES(col2), ... Other people are suggesting gearman which in my opinion seems like overkill and a half as 6000 records is not that much data. The only part of the process that could be any kind of slow is the downloading of images, and [multi curl](http://www.php.net/manual/en/function.curl-multi-init.php) would work just fine for that. Though, if all the images come from the same source it may not matter that much anyway as you will cap out your throughput with them and only the only gain from downloading more than one at a time would be from http overhead. As for downloading the images, just add a column to your table thats a images_downloaded, int(1), default 0. After doing your update you do a SELECT ... FROM main_table WHERE images_downloaded = 0 Iterate the rows and do what needs to be done. Update the images_downloaded column as you get them moved to S3.
Further input (now that im not iPhone typing on a plane): If the "toAscii" method is all you need then copy it, but I feel like there is a LOT more you could use. "Two packages instead of one" is a common reaction, but really, its only going to be slower if there is more code, and there is more code because it is doing more, so its a but if a misnomer to assume more packages MUST = slower. Right? The new OOP interface looks lovely, but im not sure how I feel about having the StaticStringy there as well. Really there is no need, as the `S::create()` method gives all the benefits of static usage would (easy access to a super-global), maintaining the benefits of instance code (the constructor can be mocked, instances can be assigned to properties for further modification and usage, etc). In general having two APIs that do the same thing just leads to trouble and confusion, and people worry about which one of the two might eventually die. I'd say just kill the static API off and go with `S::create()` all the way. Your examples are all about the same length anyway. As for following PSR-2 perfectly, anonymous functions are currently user preference. The CodeSniffer team have taken it upon themselves to make a few liberties with the rules, where there was no definition (or the spec was intentionally vague) the CS team have picked one format and said if you don't follow that you're breaking PSR-2. Thats a bit confusing I know, so following PSR-2 has three solutions: * Learn it, and just apply it as you work. * Blindly follow whatever PHP CS and CS-Fixer tell you to do. * Combine the actual rules of PSR-2 with your personal preference on the rules which are not in the spec, making a custom PSR-2 CS Recipe. The FIG has a list of these inconsistencies and will hopefully be publishing a new standard at some point to get it right, leaving no room for ambiguities so the CS team definitely get it right.
Vagrant for sure. I wrote this [last year](http://net.tutsplus.com/tutorials/php/vagrant-what-why-and-how/) and its mostly still relevant, but the config is a little different.
Symfony fans: Come join us at /r/symfony!
This is an article about using the APIs to get data. Nothing about scraping in it (which would be against the ToS I'm sure). 
It's pretty straightforward, download, compile, enable PHP extension. IMO it's easier than symfony for example. Here is a link to the installation section of the doc http://docs.phalconphp.com/en/latest/reference/install.html#linux-solaris-mac
I don't want to install the entire framework, I'm looking at specific packages
The apis themselves have pretty tight limits... unless you pay them.
Great first site!!! I love it! make me want my toes in the sand now!!!!
One thing I've started doing as a sanity check is a dependency test as part of my deployment. I discovered that I need to upgrade my Linode from LTS to LTS version so its been better for me to have a script that makes sure everything I need is working properly rather than depending on the two environments to be exactly alike. Stuff like this: print "Checking for mysql: "; test(extension_loaded("mysql")); print "Checking for gearman package: " ; test(`dpkg -l gearman-job-server 2&gt;/dev/null`); test exists with a non-zero exit code on failure.
"I'd like a place that has a lot of vistors but lacks the buraucracy of having to wait weeks before its published =)" Good luck.
This project was created to help support another project of mine. That project produces phars by using a simple configuration file, but the comments are stripped as part of the building process (to save space). One of my users reported that this was a problem for them since they used annotations inside the phar. I mulled around various ideas for preserving Doctrine annotations, while also compacting the rest of the source and comments. This project aims to tackle that issue.
The fact that someone felt it necessary to make something *just* for mocking Wordpress objects should be a massive neon warning sign. A better solution to finding specific tools to make Wordpress development bearable is to find a Wordpress replacement that wasn't designed like the year is still 2001. 
&gt; Symfony2, Bootstrap, Propel, JQuery, Twig, Composer Good solid choices. But the design and the name are terrible. Which is hopefully refined now that its open source. The API pages are all 404
I agree, but keep in mind that despite its terrible design, there is money involved in selling WordPress themes, plugins, and services. This framework simply makes the lives of those developers easier.
It is like a scheduler in Windows.
Eh, 10up does OK work. There is nothing fantastic about it, though. We took over a project from them for a client and had to rewrite several portions of the theme and plugins due to various issues in their code including loading JS on all pages instead of where it was needed, and not encapsulating one of their plugins within a class. We weren't impressed.
so people upload the file, and the base64 of the image gets saved somewhere? how/where are you storing it?
is /assets/img/ available through htdocs (.../htdocs/assets/img/) or is it outside of that space?
Have you tested running the string (post-base64_decode) through an image library like GD? For GD, [`imagecreatefromstring()`](http://www.php.net/manual/en/function.imagecreatefromstring.php) or a selective use of other `imagecreatefromX` methods if you wish to switch to allowing a full file upload. This should help to better determine if the data is a valid image, let you reject image types you don't want to support better than relying on the risky "Content-type" header or sometimes inaccurate mime-type checks, further alter the image before saving (adding watermarks or creating a separate thumb image for example), and save it to disk post-processing. Image processing can consume a lot of memory or CPU usage however. But if you're not serving that many hits or if your setup can handle it, you should be OK. Because of the extra consumption of resources on the host however, this may backfire and be a source for abuse, so tread carefully.
Good. Because I have done that and regretted it.
Just trying to learn â€“ why is that code block questionable? 
Whats keeping me from uploading a javascript file instead?
Hi, good criticism is always welcome! :-) Any idea for a better name? I'm not a web designer, so would someone of you help me to improve the actual design? 
Under no circumstances let users name uploaded files, or else you open yourself up to [XSS attacks](https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet), especially if the image source is processed in any way or laid out in HTML. PHP is vulnerable to some image types as attack vectors, eg. [GIFs](http://www.phpclasses.org/blog/post/67-PHP-security-exploit-with-GIF-images.html). [Here](http://security.stackexchange.com/questions/32967/is-it-possible-to-execute-a-php-script-in-an-image-file) are some good Stackoverflow answers to a guy asking about executing arbitrary code within images. In general, [here](https://www.owasp.org/index.php/Unrestricted_File_Upload) is OWASP's guide to securing file uploads.
Set folder permissions where images go without execution rights, set .htaccess not to use PHP interpreter for php tags.
I'd say he's probably referring to the use of `eval`. There's almost always a more graceful way to do things that doesn't open up potential remote code execution holes.
You mean there is no way to keep comments/annotations when compacting to phar?
If you don't mind the cheesiness, there's always the [MVC Song](https://www.youtube.com/watch?v=YYvOGPMLVDo) edit:formatting
I run a site called #! code (http://www.hashbangcode.com/) that publishes articles and tutorials, mainly about PHP. I get the odd article submission every now and then but I'm always looking for more :) The site gets about 500 visitors a day (~3K a week) so it isn't *lots* of visitors, but still pretty healthy.
&gt; cars are static devices, they don't have upgrades or security exploits that would change the way their windows work. you live in 1920 right? &gt; a framework needs to be able to run under the latest php versions to allow you to use new features and fix issues that previous versions had. if you never want to change the site or use only old features, then go ahead, tie yourself to a framework. ever heard of {major}.{minor}.{patch}? You can use your framework until php changes his major number, and even then you probably can still use it. You know even when your framework is made for 5.3 but your server has 5.5 you still can use generators, password hashing etc. Isnt like you are not allowed to use php
&gt; DO NOT rely on mime types sent by the client to tell you what the file contains. To those of you wondering what other options you might have (since I was curious myself), here is a StackOverflow question about it. It suggests using getimagesize(). You are not required to have GD in order to use it. http://www.php.net/manual/en/function.getimagesize.php http://stackoverflow.com/questions/1581136/validate-that-a-file-is-a-picture-in-php
If you are relying on a server-side script to do any form validation before allowing the upload to be successful, please use AJAX on submit and return false to the form if validation fails. This will save from having long upload processes that result in a failure.
sometimes just because a product has bad code, it doesnt make it a bad product, and i am not going to tell my customers that they are not supposed to use wordpress. there still is no real good wordpress replacement from a "blog user" point of view.
It's possible, just poorly handled at the moment. The phar tool I mentioned will either preserve a script as is (including comments and white space), or strip them. My goal is to strip them and re-add the annotated comments in a more compact form.
Yeah you're absolutely right, thanks. Will use the kernel.root_dir parameter
We are talking about security, none of your points address security aspect of it. - The barrier of registration is not a barrier at all. It's like 'let's prevent this security issue by making our URL really long so attacker will give up while typing it' - Nothing is wrong here, you should NOT be using name input at all and use your own uid for naming images as they are stored. - Size enforcement has nothing to do with security. - It's only preferable if you don't know what you are doing, having PHP any where near static content is not only slow but also adds aspect of insecurity. Again this is a security topic. No need to be childish about it.
&gt; Nothing is wrong here, you should NOT be using name input at all and use your own uid for naming images as they are stored. Which is fine sometimes, and not fine other times. I agree with your method, I disagree that it's the only acceptable way to deal with things. &gt;Size enforcement has nothing to do with security. Absolutely it does. Buffer overflows aren't as common as they used to be, but there's still a possibility. &gt;It's only preferable if you don't know what you are doing, having PHP any where near static content is not only slow but also adds aspect of insecurity. Again this is a security topic. You are absolutely 100% completely wrong, and it's clear you don't understand X-Sendfile at all.
Listen guy, I ran an image hosting site that had 150,000 uniques per day what have you done? I dealt with 100's of exploit attempts related to this topic. I don't know about X-Sendfile? What are you talking about? I don't see why would you use it with a basic image host nor will I think you are remotely close to smart if you use it with PHP on anything that get's good amount of traffic. Not to mention it will do nothing to prevent injection in the first place. You are acting like a child. Move along and go learn something instead of being an ignorant know it all.
That all depends, without tests I would not know but PHP is usually slow and a memory hog when it comes to things like this. I used LUA with good results for other things and would probably use it for this too. 
The point of X-Sendfile is to remove PHP from the serving process (but to allow a PHP script to execute) in order to let the webserver handle it. It just tells the webserver to replace the contents of the output with the contents of a file. So, how the webserver deals with the file is really up to the webserver.
it's not wrong. if you use a symphony specific plugin to create your form, it's not going to work under the zend framework or code igniter.
&gt;I don't know about X-Sendfile? What are you talking about? I don't see why would you use it with a basic image host Yeah, it's pretty clear you don't see *why*. Disagreeing with you isn't childish, but freaking out at someone for disagreeing with you? Pot, meet kettle.
No it's called not having any patience when dealing with ignorance, not only are you wrong on the subject I have direct experience with; you go and throw throw shit like 'You don't know X-Sendfile!' at my face. This conversation is over, I hope you learned something from it. 
I've learned that you don't know as much as you think you do. In any case, you did raise a few valid points which I didn't bring up myself, so your tirade of anger wasn't a total loss.
Here is a use case: I'm using MVC framework X, so I'm writing my controllers: class MyController { private $emailService; public function registerAction() { $this-&gt;emailService-&gt;sendMail(...); // render view } public function setEmailService(EmailService $emailService) { $this-&gt;emailService = $emailService; } } I need `$emailService` to be injected when my controller is created. Usually you would let the container create the instance of the controller itself (and inject all the dependencies). But framework X gives me no possibility to create the controller instance myself and use the container to inject "$emailService". So with the new feature, you can do: class MyController { private $emailService; // use constructor or init method to inject dependencies public function __construct() { // get or create container $container-&gt;injectOn($this); } // ... methods public function setEmailService(EmailService $emailService) { $this-&gt;emailService = $emailService; } } (better: you put the code in the base controller class) With that, framework X will create the controller instance, which will call `__construct()` which will call PHP-DI to inject dependencies (call `setEmailService` here). (of course this assumes that you configured the container to know that `setEmailService` needs to be called)
Well, it depends on what format you intend to store the data as. If you're storing it as base64 then yes. If you're storing it as binary image data, then the string length isn't going to give you the file's size. I don't see anything obviously wrong with what nullcandy is telling you to do. If you don't need any sort of PHP logic to serve the file, then X-Sendfile isn't necessary.
upvote for cool project, but I'm not clear on its purpose. This project is a pattern known as [Inversion of Control](http://en.wikipedia.org/wiki/Inversion_of_control). It's commonly known as an IoC container. IoC containers (like [Spring](http://www.springsource.org/) exist to provide dynamic binding and coupling to compiled / static languages. PHP is neither so dynamically typed interpreted languages do not need an IoC container. class Foo { public $bar; public function executeLogic($arg) { return $this-&gt;bar-&gt;execute($arg - 1, $arg); } } So my class Foo has a dependency, $bar. It has no idea how to get $bar, nor does it care. As long as $bar-&gt;execute() does what it thinks it should do, everything is fine, so $foo = new Foo; $foo-&gt;bar = new Bar(); $foo-&gt;executeLogic(12); I have now done dependency injection in the simplest, most performant way possible. It'll make Java devs cry and shit bricks, but why force inflexibility onto a flexible language? Now, if you're using a third party software and want to write a plugin for it, and force some component to use your plugin instead of another plugin, without having to dig through code, then the IoC pattern becomes useful, but an IoC framework is still not necessity. OP's IoC container already uses pure PHP code to do configuration of dependencies. Ok, so why do we need the abstraction? Why not just use pure PHP code to inject dependencies in a easily editable file on the include path and forgo the whole framework thing? // dependencies.php $foo-&gt;bar = new Bar(); $bar-&gt;whatever = new Whatever(); $stuff-&gt;dependency = FactoryPattern::factorMeAnObject('config1','config2'); // etc... So with all this simplicity, why do the benefits of an IoC container outweigh its drawbacks in PHP or any other dynamic language? Note, the pattern isn't my issue, the use of a framework is.
Whaaaaaaaaaaaaaat
No
Not as an alternative, but by a quick Google I've discovered that you can connect to an SQL database through LibreOffice (using JDBC). [My source](https://help.libreoffice.org/Common/JDBC_Connection) - How to do this however I am not sure, I would assume you can edit the database fields live (which would mean you could effectively use Base as an alternative to a phpmyadmin interface for example), but it might just create a localized copy. I am not a Base user however, so all of my thoughts are theoretical, worth having a look though!
&gt; So my class Foo has a dependency, $bar. It has no idea how to get $bar, nor does it care. Type-hinting + IoC + autoloading. Together, the class knows what it wants and the IoC knows exactly how to get it.
Still not 100% clear on this. So calling $container-&gt;injectOn($this) in the __construct() method will run the $container::injectOn() method, which will be something like this: function injectOn($obj ) { $email = new EmailService(); $obj-&gt;setEmailService($email); } ?? Or something else? I don't think I'm understanding it correctly, as the way I've explained isn't a new feature.
From [http://www.libreoffice.org/features/base/](http://www.libreoffice.org/features/base/)... &gt; If you're looking for a database for **single-user situations**, Base comes configured with the full HSQL relational database engine. It's an ideal solution for **uncomplicated needs**, and for people requiring an easy-to-understand, simple-to-use system: the data is stored right inside the Base file, and you also get native support for dBase flat files.
But under every framework that uses that component
Sqlite is good for situations like this.
While implementing a secure file uploading feature in a CMS recently, I found the following two resources absolutely priceless - http://www.mysql-apache-php.com/fileupload-security.htm http://www.net-security.org/dl/articles/php-file-upload.pdf A must-read, IMHO. 
&gt;So you bring 3rd party extensions to this discussion? You must be an idiot because if it doesnt worknwith another minor veesionnof php thats the developers fault. some frameworks do use pecl, which is 3rd party, and pecl does get outdated or deprecated, like the various php caching methods. APC was deprecated by php 5.4, and other maintained extensions just die out. if the framework doesn't replace it with something else, you can't upgrade your php. &gt; Every framework that uses build in php extensions will work 100% til 6.0 comes out. Fact. not if the php extension gets deprecated, like mysql did. any framework using that instead of PDO would be outdated before 6
Being a software engineering manager I have never seen much use from trivial problems. Sure, a person can draw some shapes with GD (assuming they know if off the top of their head) but this does not show you much other than just that. It's more beneficial for me as an employer to forget code samples all together and talk through application design to get a sense of where they stand as an engineer. 
Are you high or do you refuse to read?
Deprecated does no mean it will not work anymore
Well the design questions were in the previous part: http://phpixie.com/blog/questions-for-php-interview/ Imho it may be hard for a developer to talk random application design right of the bat, since a lot of devs are nervousduring an interview and can make mistakes if talking about deeper stuff. What questions precisely would you ask?
I used to use HSQL (which I think is the plumbing for Base) for automated testing years ago. The database would be entirely in memory and would not mess up anything else. You could load the database plus test data for each test. It's not designed for production use however. Don't even try it. 
How long would you say you worked as a developer before this was the case? I doubt one could come in raw and have all of that under their belt already.
D: k
&gt; Size enforcement is absolutely necessary - particularly when the exploit code relies of buffer overflows. What kind of buffer overflows have you seen that require a huge file to exploit? Most of the ones I've encountered are triggered by a few kilobytes of malformed data.
I've used HSQL in embedded products. It's shockingly robust actually.
I usually do something basic and build upon it depending on their answers. Something along the lines of &gt; talk me through building a photo book application that handles multiple users, comments, etc... and give them free reign from there but I try to cover DB design, design patterns, front-end work, etc. If they do a good job with that conceptually I usually then ask something like &gt; ok, lets say a 3rd party wanted to post images and comments, how do you think you would go about this? From here you can go deep and deep down the hole depending on how high level this person is supposed to be.
It's a cool idea but using that constructor example was a bad choice, if all of your constructors have same pattern, extend them to a common class. 
What are you trying to avoid with MySQL?
Not sure why you'd want to use LibreOffice Base ... is it because of the designer since everything is more visual? If so, there are tools like PHPMyAdmin, MySQL Workbench, HeidiSQL (Windows), Sequel Pro (Mac), or Squirrel SQL. Don't use LibreOffice base for a web-based project.
yes, in this case what the `injectOn` method will do look a lot like what you've written.
I 100% agree with you: - dependency injection should mainly be done through constructor injection - a class shouldn't care about the container, or about how its dependencies are injected However there are some situations that justify breaking these best practices, because other best practices were not followed. And I described those situations in the link. Take PHPUnit for example. It doesn't offer a way to control how you instantiate a "TestCase". I can't override its code to make it use my container (well I can't do it properly). So I propose a solution to this problem. I'm not saying this is the canonical way to do dependency injection. I'm saying there are unfortunately too many frameworks that doesn't let you extend the way they create objects, so this feature is a workaround these restrictions. I'm all hear for a better alternative.
if you write code for the symphony framework using the symphony plugin for forms which is symphony specific it will not work on zend or any other framework that isn't symphony because the code is symphony specific
&gt;This function has been DEPRECATED as of PHP 5.3.0 and REMOVED as of PHP 5.4.0. it means it will be removed eventually, which is what happened to many mysqli functions and will happen to mysql as a whole before php 6 so yes, in many cases, deprecated does mean it won't work before php 6, making you wrong again
again? Never was, still deprecated doesnt mean it will not work. &gt; some frameworks do use pecl, which is 3rd party, and pecl does get outdated or deprecated, like the various php caching methods. APC was deprecated by php 5.4, and other maintained extensions just die out. if the framework doesn't replace it with something else, you can't upgrade your php. As I said, 3rd Party apps are an exception. PS: mysql was php 4 so as I said you cant expect compatibility. PSS: What about maintain the framework on your own when support is gone? It would be less work than support your own codebase (and still be able to composer update that shit). PSSS: You just have something about frameworks without any solid reason isnt it?.
&gt;again? Never was, still deprecated doesnt mean it will not work. deprecated means they plan on removing it in many cases, before php 6 &gt;PS: mysql was php 4 so as I said you cant expect compatibility. mysql is in php 5 &gt;PSS: What about maintain the framework on your own when support is gone? It would be less work than support your own codebase (and still be able to composer update that shit). not really. if the entire framework is built around mysql_connect and mysql objects working, you're not going to have an easy time converting it to PDO &gt;PSSS: You just have something about frameworks without any solid reason isnt it?. I just gave you a solid reason. you rely on someone else's code that you don't understand and are bound by their framework and plugins, making a major move difficult, and if they decide to stop supporting it, you're out of luck
Meh, limited potential here; we need real hygienic macro support in the language; not hacks.
The issue is that php still gets invoked and on high load servers (eg greater than 1000 requests a second) that's very unacceptable since its not very efficient. (Its a programming language, it has to be able to do a ton of stuff, not just serve files efficiently) If you look into the design of Varnish for example, it requires less than 20 system calls to serve a file. Even with X-Sendfile you are probably an order or two of magnitude away from that level of performance. As a quick comparison, echoing hello world from php requires (estimate from a quick test) 550 system calls.
If you want a simple single-file easy-to-copy DB, look at SQLite. There are ways to interface with OpenOffice/LibreOffice by running them in headless mode, but you definitely want to avoid that if at all possible. Getting unoconv to work right was enough trouble as-is.
Feel free to contribute to PHP core with this feature, please.
I see your point, but the company I'm currently at somehow hired someone who could barely write code, and needed hand-holding every single step of the way. He got in because he knows the latest terminology and does a lot of reading on web development, so he can talk lots about it. But put him in front of a computer and he'll be hunting and pecking his way around at a snail's pace.
Just what PHP needs, more disparate language features haphazardly bolted on because someone used to working in another language would rather change the language than change how they write their code.
I disagree. With DI, all of your classes need constructors that save some instances to protected properties. Every class that has a dependency does this. Forcing all your classes to inherit a common class wouldn't be very practical.
As for advice on a more OOP method of this. I'd throw out there this lacks Separation of Concern. Kinda depends if you're going for get it done vs organized code. The way I was taught, the biggest key you're not following this is a lot of if else statements. You would want to completely separate the two payment gateway options into their own classes, possibly extending a class/implementing an interface to define the shared method of calling them. You could create a payment gateway factory that passes through to the object what it needs such as test or active mode. Instead of defining the curl function inside of the payment class, the factory could create an instance of curl configured as needed and pass it to the class. This way the factory creates two classes with what they need to connect, and then no matter which gateway, or whether it's test mode or active. You call the same function. You can say $gateway-&gt;setCharge('14.20'); $gateway-&gt;processCharge(); The above would be a good "strategy pattern" for the payment classes. Objects, patterns, and practices is a good book that gives a lot of examples on this stuff that are really easy to follow, but the only thing to beware of is they wrote it before they confirmed some of the OOP keywords for PHP so there are a few words they misuse. I think it's use or implements they swap with another word. O'reilly just put out a OOP book on PHP that i have no idea is good or not but i do enjoy their reading content/quality. I hope I didn't come off stupid in this or make any major mistakes, but I'm sure there are other practices besides the ones I mentioned. The only other thing to keep in mind, is to know when you need OOP vs more procedural programming. If this is going to be a long term project that you will be continuing to developer over time, yes do this with OOP using factories, class inheritance, an appropriate design pattern for each piece as needed, etc. 
I'm not sure, if this is your problem, but [I blogged about this some time ago](http://epilectric.net/blog/2012/04/yii-and-many-to-many-relationships/).
Stating that something should be done a given way doesn't immediately place the onus of doing it on that person.
I'd love to see this support Doctrine, imagine being able to write DQL in PHP. $users = SELECT * FROM users; or with the silly ~ macro marker: $users = ~SELECT * FROM users;
fyi your problem was that you had the group_id and user_id the wrong way round in your relations, - for `Group` it should be `tbl_user_group(group_id,user_id)` and for `User` it should be `tbl_user_group(user_id,group_id)`
That's a form. If the forms are the most complicated and "importable" part of your application, your application is trivial. Business logic, model structures, etc... that's what's hard. And it's probably going to be about the same in any framework. Tewis is right. And it's pretty obvious you haven't used modern frameworks like Laravel and seen how quickly you can develop in them.
and... relevantly... what was the framework you gained your extensive knowledge of modern PHP framework development on? Is it Wordpress? Please, God, tell me it's wordpress.
I fully agree, and that is pretty much the conclusion of the post. I do wonder if something like [sweetjs](http://sweetjs.org/) is feasible for PHP.
It's true. As soon as someone stops active development on a framework the thing just stops working, and gets uninstalled from your server, and you have to go out and get a new framework so it will start working again. It's a nightmare. :(:(:(
Frameworks don't add functions. They add utility. Consistency, structure, reliablity, speed, extensibility. Your ignorance is both sad and hilarious. What's notable is that a huge number of people are deriding and laughing at your statements. And yet, you will maintain staunch in defence in your ignorance. It will never occur to you to reconsider, that maybe smarter and more experienced people than you have found better solutions. That is why we are sorry for the people who have to work with you. Not because you don't know. Not because you disagree. But because you just won't listen, and think your ignorance trumps our knowledge. 
Tags is the relation name but the model is also called tags
Normally I'd agree, but I don't the one should dismiss another's hard work claiming it should be something else. 
Your argument is against shit frameworks. Not frameworks. Any framework that required mysql_ extensions is a POS not worthy of the term or your time, and you've probably had a lot of time to learn that.
Is there a use case for this?
If you need to convert an error number into the more verbose (hopefully) constant name. Or you could be creating an enumerable class to store a value somewhere and then wanting to load that value back in and get the constant name back. I've mentioned to the author about providing some samples in the README.
Me too. I had a basic knowledge of PHP and very little knowledge of what is MVC when I did a project using Django. Codeigniter and its awesome documentation is what really taught me what is MVC, in a very simple way.
We have people like that at our company too. Thankfully, I didn't hire them on my team. I think a lot of it boils down to the interviewer to know if the person is full of BS or not and can actually put what they are talking about into practice. 
I do this with an Abstract class and then two implementations for my payment providers (Stripe, and Authorize). Then I have a factory (a good place for dependency injection) that returns the correct provider based upon the customer. Something like this: $provider = ProviderFactory::getProvider($customer); $provider-&gt;process(); I have a StripeProvider and AuthorizeProvider that both extend AbstractProvider. The AbstractProvider has methods like getApiKey and getSecretKey. Process in that case would be abstract and implemented by the two providers. I'm not sure how much value you'll get out of trying to re-use your charge object. Requests and responses vary too much between providers. I'd just focus on having a standard object you pass in with charge information and a standard response you pass out. Then have the two providers handle those objects. 
Only for class constants? Here's my global constants finder: /** * Given a value, find all constants defined with the same value. * * To search through ALL defined constants, pass FALSE as the 2nd argument; * otherwise, it will only check userland constants. * * @param mixed $val * @param bool $onlyUser * @return array */ function findConstants($val, $onlyUser = true) { $consts = get_defined_constants($onlyUser); if ($onlyUser) { $consts = $consts['user']; } $ret = array(); foreach ($consts as $id =&gt; $cVal) { if ($cVal === $val) { $ret[] = $id; } } return $ret; }
I've witnessed/suffered through this as well. Guy could talk till he was blue in the face on the relative merits of various facets of OOP, but couldn't write a single line of code. It was a painful learning experience for everyone involved.
... and if two constants have the same value, or if the constants have been and'ed or or'ed?
If multiple constants exist in the same class with the same value then it will return both of them. I don't think the default behaviour would be to handle resolving values which have been and-ed or or-ed, but maybe it could be an option to search for them. You should raise it as an issue on github.
Initially I'd say it probably almost doubles the development time. Long term though I find it always pays back as adding / testing new things goes so much faster.
and they still haven't reached that goal yet
&gt;Laravel http://laravel.com/docs/html#opening-a-form &gt;Symphony http://symfony.com/doc/current/book/forms.html the forms aren't even close to the same syntax. if laravel was abandoned, you'd have no easy way of porting something as simple as a form to symphony without an entire rewrite.
If I understand correctly, you want to have a list of all the tags along with each question. In MySQL this could be done with GROUP_CONCAT(). I don't have a complete answer and I don't know jack about Yii, but from some googling I think I can point you in the right direction: Add a GROUP_CONCAT expression field to your grid's criteria: $criteria-&gt;select[] = "GROUP_CONCAT(Tags.text SEPARATOR ', ') AS tags_text"; Since I named the field "tags_text", you need to add that as a property to your Question model so it will see it (`public $tags_text;`) I have no idea how to do the relationship/join part so your query includes question_tag and tags in Yii, so I'll leave that up to you.
It doesn't matter if its TDD or not. Test first, test as you go or test afterwards, you're still writing tests and need time to do it.
I just started on one of my own projects, but instead of writing a project plan, I actually used unit tests as my project plan - for me it is much more fun, and faster. Fx. Im starting on a calendar with events, what do we need for this * Calendar * Users * Events Now create these 3 php unit test files. What can we do with the calendar * Show years * Show X number of monts * Show month * Show week * Show X number of weeks Now for the user, the standard stuff * Create * Edit * Update * Delete And for the events * Add event * Associate events with multiple users * Send email/sms/etc to users * Edit event (adding users, deleting users?) * Delete event (what about users) Now I have my unit tests, and can now create the methods for them in my test files. I can also send them to the client and say "do you need more features than this" - if yes, I can create more unit tests, if no - I can write a full project plan, and a make the price. Now you just have empty unit tests and you cant actually test anything, but you have them
I don't use javascript to form html ideally any site I work on can disable javascript and still function, at most I just hide the element that must require javascript with noscript or provide a workaround from the start
It does matter. For many projects, I find a tdd approach *reduces* the total amount of time spent, rather than increasing it. Also, if you're doing tdd, the idea of adding time for testing doesn't make any sense, because testing is an integral part of development. 
zend, cake, and yii writing normal php code has been much more portable
The testing *is* the development.
&gt;It's true. As soon as someone stops active development on a framework the thing just stops working, and gets uninstalled from your server, and you have to go out and get a new framework so it will start working again. if you want to update php, that is generally the case. APC has had active development slow way down, and anyone relying on it for its data caching methods instead of using memcached can't upgrade to 5.5 for a stable experience. that same can happen with any framework.
&gt;Frameworks don't add functions. They add utility. Consistency, structure, reliablity, speed, extensibility. they also lock you in to that framework if it uses components that apply to that framework only &gt;Your ignorance is both sad and hilarious. What's notable is that a huge number of people are deriding and laughing at your statements. And yet, you will maintain staunch in defence in your ignorance. It will never occur to you to reconsider, that maybe smarter and more experienced people than you have found better solutions. a huge number of people are using a framework for a language that has nearly every built in function available already &gt;That is why we are sorry for the people who have to work with you. Not because you don't know. Not because you disagree. But because you just won't listen, and think your ignorance trumps our knowledge. it is because I disagree. if I agreed that frameworks didn't vendor lock you in, everyone would be on my side. but because I believe a php framework isn't a good idea since a) the language already has an insane amount of built in functions that are already reliable, speedy, and extensible enough b) using a framework can lock you into a certain type of programming style that won't be compatible with future versions of php when the framework is updated the simple fact is that symphony is not going to be maintained one day, and my code is still going to work and yours won't.
Thank you for the descriptive response. I enjoy the quality of O'rielly books, do you remember which book that is? I can't seem to find a recent OOP book for PHP on their website. Edit: It looks like "Learning PHP Design Patterns" might be the one you were talking about?
Saw this linked from php.net. If not for the price tag I would love to go. If only my job would pay for things like this...
complex XML strucutes are either created with nested foreach loops or with recursion ... the elegant way usually is recursion, the more readable way still might be just nesting foreach loops. as mentioned theres also a lot of nested set libraries from doctrine, pear or whatever - they wont help you much around the for blocks though. for/foreach are no performance problem if used right, they only might lead to a resource/memory problem if done wrong. 
Omnipay looks nice but I think by creating my own classes I can keep it simple. There's far to much I would want to strip out if I chose to go with Omnipay.
The clientName is there because of a ridiculous legacy database/table format. I can't really change it. The name has to be inserted into each row (stupid, I know) I'll try the bare INSERT statement and report back. If I change the order, yes, same results... the 0th, 2nd, 4th, 6th, (etc) rows will be entered into the table, the others are ignored. It doesn't matter what data I pass into the array. Yes, mistype, fixed.
gotcha, in that case I would recommend getting the clientName when you set $cid, and just pass in instead of looking it up everytime you want to insert something. And if none of the above works, maybe trying doing the inserts linerally with static data and see if that does anything? $query = "EXEC getInsertSupplyRequest 1, 2, 3;"; $result=odbc_exec($connection, $query); $query = "EXEC getInsertSupplyRequest 4, 5, 6;"; $result=odbc_exec($connection, $query); $query = "EXEC getInsertSupplyRequest 7, 8, 8;"; $result=odbc_exec($connection, $query); Generally when I run into weird errors like that, I try to make it as simple as possible, get it working, then make it more complicated until I find out where it breaks.
I think the only reason I did that line in TSQL rather than PHP is that I'm a lot more comfortable with SQL. I'm rewriting it to just fetch it once and set it on the PHP side.
I think stuff like this comes with experience and time though. I've found that I gravitate towards a TDD for certain elements within my system, but not for everything. When I'm working on something a bit more complicated, I find that the TDD approach makes me really think about how my code will be used at a very early stage, so I end up with very useful interfaces. I've had quite a few "eureka" moments that have occurred through this approach, and ended up making my code much more modular and extensible as a result. Having said that, there are times when I kinda know what I'm doing ahead of time and I just go ahead and write that code first. I'll usually go back and add tests that confirm it all after the event in these cases, because I know those tests can be very useful for refactoring etc later... I personally try to not be too religious about these things, but it's good to have experience of multiple methods so you are armed with the appropriate knowledge for any given situation.
Absolutely, knowing when to TDD is a good skill, it's just no good when developers scream TDD EVERYTHING ALL THE TIME. It's ironic this conversation is even being had, and definitely proves the progress the PHP community is making in its approach to testing. :)
The joke at the beginning... kinda awkward that talk^^
The first example he shows is wrong. He mentions to exit the function as soon as possible, and he was doing it properly the example before the last one where he has done if statement in one line, then he 'refactored' the code even more and used array_filter, but that function will not exit the code and will call the function on each array element even if it's invalid. I was hoping that somebody will shout in the crowd, I would : (
wow, thanks for that link. That talk really resonated with me, especially the points about every decision having trade-offs, and the spike and stabilize approach to testing (which I've advocated for years now, just not as eloquently).
I agree. "Always use TDD" isn't a decision, it's a mantra. It's like saying "always turn right for safety". Maybe, but you'll get where you're going a lot slower. I think a lot of inexperienced people grab onto TDD as a religion because it allows them to avoid making decisions, which means avoiding mistakes, when those mistakes are what make them better.
Well, the problem isn't necessarily with the foreach loops themselves, rather that there's a query executed by the ORM in each iteration. I looked up my query log while doing this and I was running over 1,000 queries using 90-100% of the server CPU. So your last statement is where I'm stuck - what am I doing wrong and what's best practice to fix it?
Thank you for this, I will be looking into this very thoroughly. It also has a bundle for the Laravel 3 framework I'm using, so bonus points there.
I'll take a look. I may end up giving this a try. Thank you!
Yes, that is my feeling too. However, if you take a closer look, most of the payment gateway scripts in there have come from other projects, so it may be possible to lift out just those you need. In my experience, payment gateways always look simple, so everyone tries to write their own. However, they often over-simplify things and will fail in unexpected ways. For example, the SagePay gateway has very strict rules on characters that can be used in different fields and the field lengths, and even the charactersets. But try and find a gateway library that enforces that, and you will be searching far. The result is that it is easy to break the gateway by stepping even slightly outside of what an online shop expects you to enter as your address. I've bought payment gateways for WooCommerce for clients, taken a look at the code, and managed to break the gateway within minutes just by being a customer and knowing where the flaws are. So my recommendation is DO stand on the shoulders of giants, no matter how nice it is to develop it yourself. We can produce a lot more robust code we can all use if we don't have ten gateway implementations that all start from scratch and make the same mistakes, rather than building on code that is out there and taking it a little step further. That's my rant for the day ;-) 
I don't like those code practices. Mainly because his example with &gt; repaint-&gt;(false) He says: If you don't use an IDE (which is ridicules, but I'll flow with it..), you need to open another file with the declaration to find out what the "false" argument is about. He suggests: Change the 'false' arguments to an object that has 1 property which will be a constructor argument, for example: &gt; repaint(new RepaintAnimation(false)); While I agree this looks fancy, this is really bad practice. First he is wasting memory on short-live objects and if I'd need to use repaint several times, I'll probably need to re-use the "RepaintAnimation" class and create MORE objects or could go other way and making those either singleton or global. Also, If I'd like to use it sometimes with animations and sometimes don't - I'd have to create at least 2 objects. He also fail to mention that there is a thing called "Named Arguments" (as a concept), ENUMS (which we can replicate using const or static) and that most of us uses IDE to write our codes. There is no need to create many objects to avoid using regular parameters. Especially in PHP. I also thinks there are other bad practices there but too lazy to write my mind on them. Also - Sorry for the long post :)
i think i'd need to know more about the table structure to answer that. but the basic answer is always: if you're querying the same row from the DB 2 times, then thats wrong.
This is more a symptom of trying to get this across in this format. This would actually be: $animation = new Animation(); $animation-&gt;disable(); $ui-&gt;repaint($animation); This allows you to do things like: $animation = new Animation(); // $animation-&gt;enable(); // Implicit, just for show $animation-&gt;setLengthInSeconds(3); $animation-&gt;setEasing(Animation::EASING_LINEAR); $ui-&gt;render($animation); 
Sure. If you want to pass a configuration as a method parameter (where is makes sense) you should. But his point was that other developers wont realize what the "false" parameter does in his example and his solution was to create a new object for that. 
He's pointing out the code smell. He's not saying to do it in every case; he's showing what to do when you do it. He could have shown a scenario where you wouldn't, but chose not to.
YES!! This is the solution I was looking for! I knew there was something about the eager loading I was missing. Thank you!!
A front end developer should be able to change a few lines of a helper call without breaking anything.
Start by reading this: http://symfony.com/doc/current/book/from_flat_php_to_symfony2.html 
&gt; a huge number of people are using a framework for a language that has nearly every built in function available already Were you dropped on your head as a child, or are you just not following? The number of available functions is **not relevant**. One of the **biggest problems** with PHP is the number of functions available! I'm going to labour this point: do you, or do you not, use jQuery for javascript? That is a **javascript framework** and in all ways analogous to a PHP framework. Why would you use jQuery when Javascript has nearly every function built in already? What if jQuery stops being developed? Your code will not work and mine will. This is **clearly utter bullshit**. Jquery provides a ton of useful functionality, massively simplifying the process of writing javascript, as well as providing utility and improved access to features such as data attributes and dom collections. It doesn't replace Javascript, it enhances it to such a degree that it has become ubiquitous. Not using jQuery for any non-trivial javascript would make you inefficient as a developer, and incompetent at your job. Everything said above (apart from dom collections, etc) can be applied to PHP frameworks as well. Do you, or do you not, use jQuery for javascript? &gt; it is because I disagree. if I agreed that frameworks didn't vendor lock you in, everyone would be on my side. Wot? What are you saying here. I don't get it. &gt; but because I believe a php framework isn't a good idea since a) the language already has an insane amount of built in functions that are already reliable, speedy, and extensible enough b) using a framework can lock you into a certain type of programming style that won't be compatible with future versions of php when the framework is updated the simple fact is that symphony is not going to be maintained one day, and my code is still going to work and yours won't. This is dumb. Like... outright, how-do-you-operate-a-fork dumb. That you can't see that is obvious. Also kind of sad. You seem to have some insane idea that if frameworks don't get updated they turn into dust. Any code you write will continue to run. If you write stuff in a way that's likely to **stop** working some time soon, or that requires features that are deprecated you **fix it**. You have this bizarre combination of factors required to have a valid point - you have to have a codebase that is being actively developed, but never maintained. If, in four years, you find that the PDO connection your framework uses is being discontinued, you just.. change it. Wait... "a certain type of programming style"? Extensible, testable, maintainable code.... yeah, I can see that going out of fashion. The fact is - and this is a fact, not an opinion - technology changes. Platforms change, trends change. Everything you've said applies to PHP itself just as much as anything built on it. If PHP as a language diverges from your framework, your implementation, or your coding, you will have plenty of time and warning to either change slowly with it or refactor into a new platform. Not doing so, not maintaining your code, not being informed of changes to platforms and frameworks and languages makes you incompetent, and there is no one to blame for your negligence but yourself. Note that this applies whether you're using a framework or not. 
Yes, that is the book, It's newer so it should give proper examples. Objects, patterns, and practices though was a good book, so I'm sure you can "acquire" a digital version somewhere.... but give the "learning php design patterns" a shot first would be my guess. If half way through it just isn't clicking, try reading a few of the patterns in "O,P,&amp;P" 
I'm assuming you didn't finish the video, because the whole thing is peppered with his.....humor
The next step would be learning a PHP framework like CodeIgniter. http://ellislab.com/codeigniter/user-guide/ Symfony is posted as a reply here... and imo, it's pretty bloated/confusing for a beginner. CodeIgniter is much easier/simpler. Perfect for learning MVC, a programming design pattern (style to organize code in an application, in an object oriented way). FuelPHP is good too, for a beginner.
Well, you copy your small script into the buffer then paste, paste, paste...
&gt; Were you dropped on your head as a child, or are you just not following? The number of available functions is not relevant. One of the biggest problems with PHP is the number of functions available! and adding more ways of doing things is helpful. &gt;I'm going to labour this point: do you, or do you not, use jQuery for javascript? That is a javascript framework and in all ways analogous to a PHP framework. Why would you use jQuery when Javascript has nearly every function built in already? What if jQuery stops being developed? Your code will not work and mine will. jquery serves as a way to make javascript code cross browser compatible. I don't use jquery for things that can be done inside normal javascript, if that normal javascript won't have any cross browser issues. I don't use jquery 2 specifically because it dropped support for browsers less than ie9. one of the major selling points of jquery is to provide support for browsers that couldn't handle modern javascript methods without tons of exceptions. considering that jquery 1 will one day not support a modern browser, and jquery 2 isn't going to support older browsers, it puts a developer in a tight spot when it comes to future code maintenance. &gt;This is clearly utter bullshit. Jquery provides a ton of useful functionality, massively simplifying the process of writing javascript, as well as providing utility and improved access to features such as data attributes and dom collections. It doesn't replace Javascript, it enhances it to such a degree that it has become ubiquitous. Not using jQuery for any non-trivial javascript would make you inefficient as a developer, and incompetent at your job. again, with the direction jquery is headed, browser support is going to be broken on websites that use it. jquery 2 is already broken for ie6-8, and XP users can't upgrade beyond 8. as a developer, you just have to fallback to jquery 1, but there will be a point where falling back won't work when jquery 2 has a feature but jquery 1 doesn't. jquery is good, but it illustrates that exact point I made before of relying on frameworks to handle your code. it can eventually put you in a tight place. &gt;Everything said above (apart from dom collections, etc) can be applied to PHP frameworks as well. php frameworks aren't about portability. most of the php functions will work on any OS you throw them on without a framework. &gt;Wot? What are you saying here. I don't get it. you claimed that people are yelling at me, but it's not because they disagree with me. it is clearly only because they disagree with me. &gt;This is dumb. Like... outright, how-do-you-operate-a-fork dumb. That you can't see that is obvious. Also kind of sad. You seem to have some insane idea that if frameworks don't get updated they turn into dust. Any code you write will continue to run. If you write stuff in a way that's likely to stop working some time soon, or that requires features that are deprecated you fix it. You have this bizarre combination of factors required to have a valid point - you have to have a codebase that is being actively developed, but never maintained. If, in four years, you find that the PDO connection your framework uses is being discontinued, you just.. change it. if the entire framework is relying on PDO to work, you'd have to rewrite the framework to handle something else. considering you didn't write the framework, so you could potentially have little idea about the complexities of the inner workings, that won't always be an easy task. &gt;The fact is - and this is a fact, not an opinion - technology changes. Platforms change, trends change. Everything you've said applies to PHP itself just as much as anything built on it. If PHP as a language diverges from your framework, your implementation, or your coding, you will have plenty of time and warning to either change slowly with it or refactor into a new platform. APC was going to be integrated into the mainline php. then they quickly decided to instead deprecate it and release php 5.4 that broke support. then they decided instead of that Opcache was going to be in its place on php 5.5, even though it didn't offer key storage functions. that's one example of a feature being blown away by php with little notice, and nobody being around to fix APC as well as it needs to be fixed. &gt;Not doing so, not maintaining your code, not being informed of changes to platforms and frameworks and languages makes you incompetent, and there is no one to blame for your negligence but yourself. Note that this applies whether you're using a framework or not. with your own code you'll actually know what you're doing to change it. if PDO was dropped in php 5.7 and symphony decided to call it quits, you'd be lucky if someone actually fixed it.
Thank you for saying this. I had to stop watching the video after that example. Some people prefer working without an ide, and that's fine, but I will refuse to complicate my code with whole new objects just to set a simple configuration parameter.
I actually envisioned him watching his own video a year later with a downtrodden "I actually said that?" look. It's like he's trying to be like the guys are rubycon. You always get a couple of speakers at rubycon who take shots at PHP (and by extension, people who write software in PHP) because they're attempting to be edgy by pandering to the minimal segment of attendees who make up the vocal language bigots. Newsflash guys - it doesn't make you seem smart, or funny. You just wind up coming off like a tool.
You dont get the point. Singletons themselves can be tested if course. The code that utilizes singletons cannot. This is because a singleton introduces global state. Meaning that during a test the syate if the singleton is an input parameter basically. Testing the singleton class itself has never been a problem. And you cant say you tested a class if you tested a single login method and mocked the rest. How will you test those other methods that jave dependencies on Yii stuff and call ir statocally. I dont believe yiu understand what unit testing is about
&gt;Does your code look like this yes :(
&gt; jquery serves as a way to make javascript code cross browser compatible. I don't use jquery for things that can be done inside normal javascript, if that normal javascript won't have any cross browser issues. And, that's it. End thread. We've reached peak retard.
&gt;And, that's it. End thread. We've reached peak retard. there are definite uses of jquery that handle wrapping all of the different browser functions into one function for you to call.
I agree with that. I think stuff like this evolves over time and experience though. When I first attempted TDD, I did it strictly. Mostly because I wanted to see what would happen if I followed the rules to the letter. I did have some strong success with the technique, but I also found along the way that I was unit testing basic stuff that I knew was going to work and I felt like I was needlessly slowing myself down at times. I think over time you get a feel for how appropriate certain things are for certain situations - the skill is knowing when to use something like TDD and when it's ok to not use that technique.
There are two reasons why we test code: * To ensure that things work correctly and don't break in the future * Testing code enforces good style, because bad code is hard to test The second point is important too. Sure, you can test any shitty, static-ridden code with sufficient effort. But that's not what you want. You want your code to be *inherently* easily testable, because testable code also happens to be maintainable, extensible and easily readable. People saying "Hey, but I *can* test my singletons using method xyz" are just missing the point.
Like moylin said, you need to "completely" separate the two payment providers. We have it setup with at least 3 Payment providers right now. Optimal Payments, AuthorizeNet, IPay. And in the past we changed payment providers more than once. We had E-Xact, beanstream &amp; paygea at one point too. But the classes that process the payments never changed. We basically have an interface that all payment providers class must implement in order to work with the system. Then your payment processing class just choose the right provider and process the payment calling the methods that are common to all payment providers. Its not too complicated... I'd suggest to make sure all payment providers log their API calls requests &amp; returns into an audit table which is read-only. Comes very handy. **Dont log the credit card informations** I'd also suggest to implement a little provider choosing system because not every payment providers accept payments from all countries. So we have a little mechanism which choose the right provider depending on certain client factors. And not every providers will support recurring payments. For example all our recurring payments uses Optimal Payments, because its the only provider flagged for recurring in our system. Thirdly i'd invest time in making a little fraud detection implementation with a third party such as https://www.maxmind.com. But that will only get you so far. We have our own little fraud detection which checks how long the client has been with us, how many payments he made this month, etc... The idea is to firstly make a Pre-Authorization and then run your fraud detection and if it passes all the checks do a Pre-Authorization-Completion. And if the client does not pass the fraud checks the transaction stays at Pre-Authorized and we have the staff call the person and do manual checks. If they pass the human checks the staff does the Pre-Authorization-Completion. I know its not very OOP oriented, but hope it helps :]
You are missing the point. Return early is not about performance. It's about cyclomatic complexity. High-level operations on collections, such as the `array_*` functions are much easier to grasp than loops, and reduce the complexity of the calling function/method. From a complexity standpoint, the `array_filter` is actually *better* than the loop. Side note: If PHP had a native `array_any` function, then the performance argument would go away as well. Not that it would matter in most cases.
Well I got almost 90% test coverage of LoginForm class. And that's quite a good result for me. Yii stuff is tested itself, thus I won't need to get tested Yii internals. Also, unit testing does not replace intergation and functional testing which I will do too. All that Yii dependencies should be tested with functional testing.
That's fine, but at the end of the day I guess performance would be slightly more important. If the task is to create a validator which returns false as soon as one element is invalid then this is the right way. Native functions might be faster in the other case but not this one, if we have 1000 objects to validate and the first one was already incorrect the loop would break and it wouldn't be faster with native functions. I understand he tries to show something different in this example but what he shown wouldn't be ideal for production because it doesn't achieve the task in the best way. Other than that, I do agree that he shown exactly his point.
Keep in mind, this is a third party extension on PECL, not part of PHP core. The documentation is on php.net since PECL extensions usually keep their information there. (The big hint at this is that it uses namespaces, which none of core PHP uses.)
Like most languages, people make third party libs/extensions for PHP and allow others to use them. There are libraries for a wide variety of functionality, including to estimate gender based off a name.
To be fair, that is just the example code... http://www.php.net/manual/en/gender.example.admin.php
I'm the son of a bitch that named you Sue.
Yes, however PHP has one of the richest environments out there. Granted, not all resources are good, but a good developer can sort through them and use the right tool for the right job.
What's your point?
Why? Which gender is assigned to a name can change per region. Like: Anne is a boy's name in the north of the Netherlands. 
...and also one of the most *unmaintained*. It would be very interesting to see the ratio of maintained to unmaintained projects in PHP as compared to other languages.
That saying in isolation that there is an error in someone's name is meaningless and it's an example of typical PHP anti-usability.
I should probably add that my comment should be taken with a grain of salt since it's speculative. It's not a conclusion based on a study of PHP projects. It just seems like every time I go looking for a particular kind of specialized solution (which isn't yet another web framework) I run in to a handful of things which haven't been updated since 2001. In the last few years I've spent a lot of time porting code from other languages because of this.
I suppose having your head so far up your ass is not going to help in this case, but here it goes. That is just an example, it is meant to show some functionality. If your first thought was so negative, i doubt you are any good at your job. That's because your comment was to show how much better you are than the rest of us. PHP antiusability? It all depends howyou use the tool at your disposal. I'd really want to see some of your python code, so we can all learn how pros do it. I asume you use python, hence the head up your ass. Go preach someone else.
Did anyone look at the name dictionary this library uses? it has 48k+ names stored in this crazy text file format. http://svn.php.net/viewvc/pecl/gender/trunk/data/nam_dict.txt.bz2?view=log That being said, I had a use for this a few years back. Wish ~~I would have known about it~~ it would have been around back then.
&gt; "hey guys, do not use Yii, move to Symfony. Yii is bad, and Symfony isn't" Yes.
No you can't but you can connect to the MySQL db you do use via Libre Office Base and do some editing/designing. Check this link http://ask.libreoffice.org/en/question/1822/base-and-mysql-getting-started/ I do not think it's the best idea though, there will probably some issues with the connection driver used. I don't know that for sure but there usually is :)
.. and the lib is buggy and gives the wrong answer for a lot of names.
Jesus. Where the fuck did that come from? How on earth do you know anything about how good I am at my job? You assume I use Python? You mean you've read previous posts on my profile? Actually I work full time as a PHP engineer. Go preach somewhere else? I wasn't preaching, I was jovially pointing out a typical PHP characteristic. A frustration typical of the type that people who work with PHP on a regular basis spend a lot of time with. So what if it was negative. Chatting about frustrations helps us find solutions as a community. We could have had a useful adult discussion about it if you were capable. What value does your fanboy post add? Zero, you sad cunt.
This statement is more for children who play in a sandbox with a toys. My toy is more expensive then yours. Bu-bu-bu!
Both of the frameworks you listed are in some state of abandonment. I would suggest something more modern like Silex or Laravel. Symfony2 assumes you already have a deep understanding of PHP's OO model, and won't hold your hand if you don't.
I was curious about the whole "native function faster than foreach" and all so I made a quick benchmark and I'm finding some awkward result, what do you guyz think. &lt;?php /*FOREACH BENCH*/ $aHash = array_fill(0, 100000, array('data' =&gt; 1)); $t = microtime(true); foreach($aHash as &amp;$hash){ $hash['bidou'] = 'test'; } echo "foreach " . (microtime(true) - $t) . PHP_EOL; unset($aHash, $t); /*END*/ /*ARRAY_WALK BENCH*/ $aHash = array_fill(0, 100000, array('data' =&gt; 1)); $t = microtime(true); array_walk($aHash, function (&amp;$value, $key){ $value['bidou'] = 'test'; }); echo "array_walk " . (microtime(true) - $t) . PHP_EOL; unset($aHash, $t); /*END*/ /* ARRAY MAP BENCH */ $aHash = array_fill(0, 100000, array('data' =&gt; 1)); $t = microtime(true); array_map(function (&amp;$value){ $value['bidou'] = 'test'; }, $aHash); echo "array_map " . (microtime(true) - $t); /*END*/ Here are 4 samples: $ php test.php foreach 0.041761159896851 array_walk 0.053479909896851 array_map 0.080164194107056 $ php test.php foreach 0.042163848876953 array_walk 0.055884122848511 array_map 0.081412076950073 $ php test.php foreach 0.040961980819702 array_walk 0.056441783905029 array_map 0.084516048431396 $ php test.php foreach 0.04052209854126 array_walk 0.055609226226807 array_map 0.082444190979004 Maybe (probably) my methodology is wrong, but I see foreach being faster in each run (and I'm quite surprised by it). 
Cool thanks
what could you use it for? There's so many names like "Casey" and "Taylor" that could be either one, how is this library useful?
Personally I do not like lots of things in Yii. And I do not like its approach in components, mixins, behaviors, static vars. I wouldn't choose Yii for my own personal project. To be honest, I'd choose Laravel or Rails. But... I know people who do really like Yii and Yii works great for them. I don't feel that I can blame them for their choice. Especially If they build a good software.
I've actually gotten a good way through it already and it's helping out a lot. I've got a much better idea of what to do already. Thanks for suggesting it!
Just started doing a similar process to this a week ago! Wish I has seen this then, but it summarizes the things I've figured out since then. Very good summary :)
in what context would you have the ability to ask for a person's first name but not their gender?
What type of PHP developer finds that kind of issue a show stopper? If you had any experience with the language or the environment itself, you would be able to overcome those issue, not even find them as issues. Instead you ... bitch, like the little bitch that you are. You found a fault where there is no fault and proudly claimed your superiority. You want a useful adult conversation? You should have stated how that particular thing could have been improved and offer your own version. That's constructive. What you did wasto show to all of us you are a little bitch. Also, with all due respect, your mother has a cunt.
Yay, more stuff which can be found directly [in the manual](http://www.php.net/manual/en/types.comparisons.php)
Oh dear... http://www.youtube.com/watch?v=edZjdgU0asM
It would be interesting if there was also a library for determining race based off last name.
I never said it was a showstopper or impossible to overcome. I never claimed my superiority. These are all things you invented in your rant. You're nothing but a troll. I glanced at your previous posts. It seems you've spent a large portion of your day slagging off someone who has a differing opinion to yourself about a recent Batman film. Grow the fuck up.
The fuck has Batman to do with your PHP ineptitude?
I may have been trolling in the other thread, cunt, but here i made a legitimate statement: no serious PHP coder will make a lame comment as you did just to show others how superior they are. Cunt.
That's not just PHP, [I was pretty entertained by this bug tracker thread a few days ago when I got a really arcane message from Homebrew](https://github.com/mxcl/homebrew/issues/9953). People clearly don't enjoy being jerked around by smug developers, no matter the language.
No, you were trolling on the other thread and you are trolling on this one. You made no legitimate statement, you just went into a childish and abusive rant because you didn't understand what was being criticized and thought you had to defend your favourite toy like some sort of Nintendo fanboy. Turn your computer off and go masturbate or something. You'll feel better, you bitter little shit. 
Ha! that's pretty funny. You're right, it's not just PHP, but it does seem to happen quite often in PHP. This thread made me chuckle because I was dealing with the exact same thing in a completely separate library at the time. Maybe it's because of the age of a lot of it - the web was new when PHP was introduced and best practices were developing at the same time as the language.
i abuse self righteous assholes like yourself. How the fuck o you claim you are a PHP developer if you can't pass over a simple demo with a if/else/echo? If you're so stupid to understand that tiny thing, how the fuck do you expect to understand more complex things? Good bye, cunt, i hope your mother is well. She has a cunt, right?
I had to implement this a few years ago. The census releases common first names with gender for free, just use that if this library isn't better.
Really, only on /r/php? The rest of reddit is exempt from ignorance?
I tend to agree, this code style is just trying to replicate named parameters, which is something I've heard a lot of PHP developers want, I'm one of them. It's also very inefficient if you did this everywhere. I'm all for making readable and maintable code, but at some point you need to make the pureness/speed cost trade-off or just use another language that supports this stuff.
&gt;&gt;&gt; i abuse self righteous assholes like yourself. Wow, OK. Discussing PHP on a PHP discussion board doesn't make me self righteous. That's what it's for. The clue is in the fucking title. Do you believe PHP and all its associated libraries to be 100% perfect and beyond criticism and even discussion? No, I don't believe even you are that stupid (although I stand to be corrected). &gt;&gt;&gt; How the fuck o you claim you are a PHP developer Because I get paid lots of money to write applications that hundreds of thousands of people use, and have done for a number of years. &gt;&gt;&gt; if you can't pass over a simple demo with a if/else/echo? If you're so stupid to understand that tiny thing, how the fuck do you expect to understand more complex things? I've already said this twice above, but I'll do it again for your ignorant benefit. The point isn't that this is a critical show-stopper, so complex that it's uncomtemplatable. The point is that annoyances like this cause unneccesary work and are quite trivial to avoid, yet still seem to crop up quite often. &gt;&gt;&gt; Good bye, cunt, i hope your mother is well. She has a cunt, right? Why do you keep saying my mother has a cunt? I've got a feeling that doesn't really mean what you think it does. --- Well, cheerio. I look forward to your next witty post, where you completely ignore everything I've written and instead childishly paste in the latest swear word you've heard. Keep digging you prick. 
You clearly have never heard of [CPAN](http://search.cpan.org/search?query=gender&amp;mode=all)
You should write adapters for the payment services. For fallback functionality check chain of responsibilities pattern. And always stick to the single responsibility principle and (almost) everything will be fine.
Why are you talking about Reddit?
Yes, your methodology is wrong, as you've left out function call overhead in your `foreach` benchmark (but included it in the other 2 cases). Here is a modified version that gives you a more accurate comparison: &lt;?php function bidou(&amp;$value) { $value['bidou'] = 'test'; } /*FOREACH BENCH*/ $aHash = array_fill(0, 100000, array('data' =&gt; 1)); $t = microtime(true); foreach($aHash as &amp;$hash){ bidou($hash); } echo "foreach " . (microtime(true) - $t) . PHP_EOL; unset($aHash, $t, $hash); /*END*/ /*ARRAY_WALK BENCH*/ $aHash = array_fill(0, 100000, array('data' =&gt; 1)); $t = microtime(true); array_walk($aHash, 'bidou'); echo "array_walk " . (microtime(true) - $t) . PHP_EOL; unset($aHash, $t); /*END*/ /* ARRAY MAP BENCH */ $aHash = array_fill(0, 100000, array('data' =&gt; 1)); $t = microtime(true); array_map('bidou', $aHash); echo "array_map " . (microtime(true) - $t) . PHP_EOL; /*END*/ With function call overhead included in all test cases, the `array_walk` solution is consistently the fastest, though not by any measurable amount. I think this is an interesting tangent, but it's missing the point of this part of the talk which was cleaning up code smells by using library functions instead of reinventing the wheel and bloating code (which is what `foreach` based solutions sometimes do for developers unfamiliar with standard array functions).
&gt; Do you believe PHP and all its associated libraries to be 100% perfect and beyond criticism and even discussion? Definitely not. PHP has many flaws. So do other languages i worked with. For the last 8 years, however, 75% of my work involves PHP. So i did learn to deal with it's flaws and avoid them. I quickly adapt new versions of it and take full benefit of it's new features. granted, I have an advantage over the rest of developers because the projects we built are used in company, so i am not a freelancer or coder dependent on what hosts somewhere on the internet deploy on their servers. We upgrade our environments frequently so we can take advantage of new technologies as fast as possible. &gt; Because I get paid lots of money to write applications that hundreds of thousands of people use, and have done for a number of years. Fair enough. Since you imply you are not a bottom of the bucket developer, i imply you then have a few years behind you as well. That means you too have a set process of development. I just don't understand why a well established developer would be upset of a minor issue that is not even an issue. It was a quick and dirty "this is how it works" demo. And the guy that made that demo is not to be laughed at. After all, he is smart enough to make such a module. So i take that the ugliness of his demo is not because of lack of experience, but because he implies you will figure out the proper way to implement his code. &gt; The point is that annoyances like this cause unneccesary work and are quite trivial to avoid, yet still seem to crop up quite often. Yes, but this is not production code or anything like that. It is just a quick and dirty demo. &gt; Why do you keep saying my mother has a cunt? I've got a feeling that doesn't really mean what you think it does. I was implying your mother has you. And you are the cunt. We both got out of hand with this one. Ok, so, in retrospect, my reaction to your reaction was a little harsh. I am not like that IRL, or else my wife would have me meet her lawyer :) I am not a troll either, I just sometimes get very passionate about my arguments (see the Batman thread). 
You're correct that we'll never all come to agreement on what constitutes "good code." However, I think we can (mostly) all agree that OOP is easier to understand and extend than procedural code, yes? I mean, that's why we all use it these days. And static calls are nothing but procedural code in disguise, so I think /u/nikic is correct that static-ridden code **is** bad code, and it just so happens to make testing much harder, as well.
Actually, Laravel does not use static methods. Their code is proper OOP from top to bottom. They use a `__callStatic()` facade design pattern to make things *look* static in order to provide syntactic sugar. Incidentally, their code is completely/easily testable because of this. ;-) Also, static code has no encapsulation, because there is no object state to encapsulate. All you have access to is static state, which is actually *global* (or technically, namespaced) state. There is no difference between static methods operating on static properties and procedural functions operating on namespaced variables.
Laraveltuts.com is loooking good! Good luck!
This is surely extremely accurate, because names are so easy to get right.. http://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/
"Good morning Tyrone, we'd just like to let you know that KFC is having a great sale today..."
There is no object state because there is no object. Why would you use static code for a single object, when you could just use a *real* object? Not only would your code be easier to test, but it would also be easier to extend in the future if you end up needing, for example, multiple database connections instead of just one.
From a marketing perspective, you can do a lot with targeting emails based on gender if you sell a wide variety of products. It's not uncommon for someone to give you their name when they sign up, but most don't want to fill out various demographic fields, so the fewer things you ask the better.
We wanted to to know the percentage of customers that were women buying for themselves (women's name and women's products), and the percentage that were buying for their SO (women's name and men's products).
Gender::__constructs are so oppressive.
There is a single object, like singleton. I'd rather called them class methods and not static methods. If you need only one instance of something, and there are lots of cases when you really do, then it's a good idea to use that. If you want several database connection, there is no problem in doing: Db::switchDatabase('database2); and so on. 
Damn, beat me to it.
I'm with ya brother. But you did say anti useability and in still trying to wrap my head around what that means
This should be higher. 
`Gender::FRANCE` That is some shitty separation of concern right there.
Nope. Tests are a tool and shouldn't treated as a part of the software and also should be not developed by the same person who writes the actual project. This avoids pitfalls like altering architecture for working with the tests and most importantly improves test quality because another person than you will see things you don't see.
Adding test to existing or legacy software may be pain and may take actually a gigantic amount of time, depending on the projects general quality and size. It can be so much, that the addition of the tests may be never pay off because the project may be discontinued until your test-coding times has gotten in. It's always better to write tests from the beginning.
That's all well and good, but in most cases the bad code is already there. And it's hard to get time for refactoring because of testing in a lot of companies. So it's very valuable that methods to test singletons exist. The real world ain't that simple, unfortunately. Remember, companies do not exist to write good code, they are mostly there to make money. And most people who pay your wages don't care about good code or bad code, they care about working code. It's hard to make a case. I'm not saying that testing is bad or shouldn't be done, quite the contrary. Every method to introduce testing in a time-efficient way does help. It's better to have some tests, than no tests at all.
I was just typing out a similar answer and scrolled down before hitting save. Just giving a +1 to this and the below addition: In laravel4 (im not sure if it worked like this in laravel3) but you can add additional queries to the eager loads such as: $evaluations = Evaluation::with(array( 'templates' =&gt; function($query) use ($y) { $query-&gt;where('x',$y); }, 'templates.topics', ... ))-&gt;get(); I am pretty sure I have also used orderBy within an eager loaded model but given the way that Eloquent builds the queries and collates the data I am not sure if it works.
I would love some constructive feedback on this, maybe as a desperate way of trying to find something to cling to in the PHP world. Hopefully it will not simply start a flame war, although I guess that may be unavoidable with such a topic. We'll see.
Unit tests add on to development time, but then code documentation does so too - in the end you need both (but not always 100% coverage) otherwise you had better be adding a lot more development time for future code changes ;) when things start doing mysterious un-explainable actions. I also like to combine documentation with unittesting, such as: + This method should always return this for this input because it needs to be used like that over there... + This method should never accept this input because... + This should never happen, and if it does then this, that and there will break... + etc Also when things break because you touch upon a method a few months later that is a dependency of a few other classes (that you forgot about) having a unit test fail and then that test's documentation point out where the bug will be is immensely useful! The first time this saved me a few hours debugging, I was sold. As for how much $$$ to add for unit testing, I do not know, as I have always added tests to one degree or another depending if there was a need (and how complex the system was). If a client wanted 100% coverage for some reason or another, then that could easily double your costs. 
They might've simple scraped baby name lists in different countries. Those are usually split up in boy and girl names.
Ya, I don't think names carry much gender meaning anymore... I've met a girl named Kevin. 
I'm working on a crazy simple class to generate forms in php called Formulatrix https://github.com/simonausten/formulatrix . You just pass the names of the form elements to the class and it takes best guess at what type of form element you want. So you can just do something like form = new FX(legend='Create a User') form -&gt; addFields('name','date_of_birth','gender','home_country') print form -&gt; getForm() It knows about elements with 'date', 'gender','country' etc in them and displays the right form control. It's very simple, but not quite finished yet, if you want to contribute! 
The subject is TDD, and this is what TDD is. [Here is a link for your reference](http://en.wikipedia.org/wiki/Test-driven_development). Whether or not you agree with that methodology is completely up to you.
http://www.phptherightway.com/#security
If they are related it should just be: $author-&gt;books()-&gt;sync(Input::get('book')); I do this in an observer for my Model so that when I save the model, it does this automagically
My suggestion would be to create your Author record first. You can do this via Author Eloquent model. As for your Books though, I would suggest instead using the **insert** command. This lets you insert multiple records into the DB at the same time. Do something like: $author = Author::create(array('author'=&gt;Input::get('author'))); $books = array_map(function($book) use ($author) { return array( 'author' =&gt; $author-&gt;id, 'title' =&gt; $book['title'], 'description' =&gt; $book['description'] ); ), Input::get('book')); $author-&gt;books()-&gt;insert($books); This should let you insert all those books in one query. Edit: Typo
Actually, there's a big problem, because you couldn't keep state for both objects simultaneously.
while your not wrong, lets be honest unless we write the component then its not coming with us to the new framework
many frameworks are using symphony components. 
How would you do this if you arent working off of today date, though? And doesn't this return october if you are on august 31 since theres no september 31
You can use strtotime to handle dates that aren't today: $date = "2013-10-25"; $a_month_later = date('m', strtotime($date . ' +1 month')); To answer your second question, you can try it out. It turns out that "2013-10-31" minus 1 month somehow still equals 10 (October), so it takes a little finagling. You can do something like this: $halloween = "2013-10-31"; $october = date('Y-m', strtotime($date)); $a_month_before_halloween = date('m', strtotime($october.' -1 month')); // 09 $a_month_after_halloween = date('m', strtotime($october.' +1 month')); // 11 
For php &gt; 5.3: try using DateTime's [first day of next month](http://stackoverflow.com/a/3602421/414031)
Only if you hate yourself and any other developers on the project. I've seen Access driven websites before, so I'm sure it's possible.
Right, -1 month literally decreases the month number by 1, so it turns 2013-10-31 into 2013-9-31, which doesnt exist, so it makes it 2013-10-01 So its still pretty much hacky either way? I mean, what i'm doing works, i just dont understand how theres no native function in php that accurately can tell what the next and previous month are lol
using woefully outdated server on php 4.4.7 :(
Fix that.
Yeah, it's kind of lame. Depending on the use case, I might use different methods. For instance, the names of months are highly unlikely to change anytime soon, so I might just have an array of all the month names and determine it that way. If we're in Month 10, then that's October, and 10 - 1 is 9, which maps to September. If I needed something more precise, I'd come up with a custom function to calculate the month more precisely. Pretty rare that I need that, though. Sometimes there aren't built-in functions because recreating the functionality is assumed to be pretty simple. When it comes to dates, though, my question has always been: if it's October 31, how do you define 1 month ago? Is it Oct 1 or Sept 30? Always kinda bothered me. 
 $now = strtotime("2013-10-31"); $lastMonth = strtotime("last day of last month", $now); echo date("Y-m-d", $lastMonth); // Results in: 2013-09-30 Reference: http://derickrethans.nl/obtaining-the-next-month-in-php.html 
if only. i'm just a pleeb working for a company! our main site is hosted legitly on linux with everything legit, this is just a business files site given to us for free on a windows xp server. nothing but problems with it!
i have no pdo or mysqli either haha so its a lot of extra work for me. if/when mysql_ is deprecated then maybe people will realize it needs new hosting
fun quirk, if you are on october 31st and do -1 Months +1 Months you will end up in september
I wrote a very simple wrapper that uses strtotime to compute date math (and comparisons) you might be interested in. https://github.com/shoeman22/Sole-Dates Let's you do simple things like: $months_to_add = 1; $from_date = '2012-09-10'; //interpreted by strtotime, so could also be like TODAY, YESTERDAY, etc) $format = 'm'; //just like you'd pass to date() $october = Date::addMonths($months_to_add, $from_date, $format); You could make history and be the first person other than myself to use it!
That's up to the company, people here will just guess what the definition is but at the end of the day the company is the one that has the definition of what they want out of 'mid level'. Go for an interview, the interview questions will tell you what they are looking for. If it's still not clear; ask.
PHP 4 !!!!!!????? Just quit and run as fast as you can, and don't ever come back.
Yeah I understand that. I'm hoping for someone here who has this current title to explain what responsibilities they have.
It does not work like that. But if that helps you, more power to you man.
Thank you, and I am a girl :D
Network with others.
Can this be done via the [push method](https://twitter.com/laravelphp/status/353328511567675393)?
... or be paid a lot, seeing as working on PHP4 will not improve your marketability there must be some compensation.
Explain that not only is it dangerous to keep it on that server but every piece of work takes 4 times as long to code and you're concerned its going to get hacked. Or, quit.
.....
Agreed. Get known, and become trusted. Trust is that golden substance that'll make your contracts/paychecks grown in size and frequency. Trust is how you'll compete against most of the 3rd world contractors. Get on github, contribute to open source projects, answer questions on stackoverflow, set up a blog and start posting basic how-tos and/or document your code experiments/projects. Comment on other php/web dev blogs, engage in dev conversations on twitter and FB, go to meetups and dev conferences. Weave yourself into the social fabric of the industry...not just on the web, but also in your local community (IRL). 
Here's how I normally do this: $FirstOfThisMonth = date(Y-m-1'); $LastMonth = date('F',strtotime('-1 month',strtotime($FirstOfThisMonth); $NextMonth = date('F',strtotime('+1 month',strtotime($FirstOfThisMonth); 
Whatever you do, just never compete on price with people from third world countries. Three reasons: 1) you'll likely never win 2) if you do get a contract you'll barely make enough to sustain yourself 3) you do *not* want to work for someone local willing to only pay third-world rates, misers are the worst clients. 
Hey, I had to install a server side app on a cracked windows xp. With wamp.
That seems to work well. Here is a PHP one-liner: // Previous month echo date('M Y', strtotime('-1 month', strtotime(date('15 F Y')))); // Next month echo date('M Y', strtotime('+1 month', strtotime(date('15 F Y')))); It works by getting the timestamp for the 15th of the current month and year, and then adds or substracts without having to worry about the 31st of the month issue.
You should just [try parsing it with a regex](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags)
Make sure you have permission before you do any web scraping. You will want to use [curl](http://php.net/manual/en/book.curl.php) to call the page that needs to be scraped. Then you can use a combination of [DomDocument](http://php.net/manual/en/class.domdocument.php) and [DOMXPath ](http://php.net/manual/en/class.domxpath.php) to get the information out of the page. (or any other xml parser that prefer. You could try using regular expressions, but its [generally not recommended](http://stackoverflow.com/questions/1732348/regex-match-open-tags-except-xhtml-self-contained-tags)...) 
Blog.
Snazzy solution.
Any time you're arbitrarily defining a month as 30 days, you're doing it wrong. 30 * 12 = 360, which isn't really a year. In fact, using months as a unit of time when doing date math is something you should actively avoid because it overcomplicates things. For example, if it's the 31st of August, and you decide to add a month, which month are you using as the definition of a month? August 2013 has 31st days, while September has 30 days. This is why pay periods are usually defined as the 15th and the end of the month rather than saying something like the 15th and the 30th. In another example, if it's Jan 30th 2013 and you add a month, where are you at? If you use 31 days as the measure of a month, you wind up completely bypassing February which only has 28 days in 2013. Instead of using months, use quantities which have clearly defined values such as days or weeks. This will make everything much easier for you.
Details of what I am trying to do: We are a customer service based company, we pay another company to allow customers to take surveys to rate their service. That company provided us with a list of links to add to our website. A page of links is really cheesy. Right now I am using iFrames that just look at only the reviews and allows vertical scrolling to go through all of the reviews for whichever location the user has chosen. I just thought scrapping the data would be the better way to do this, I just didn't know how. Thank you for the advice.
This. I would go so far as to say simply "never compete on price" (except some times you'll have to factor it in, especially as you get established. But never, ever undersell yourself.) You have to sell your advantages. Many people prefer to work with someone they can meet, some prefer at least a relatively close time zone. Some prefer not having to deal with cultural variations in communication. There are all kinds of markets out there that are not about the cheapest price, so just forget about the ones that are - you won't win them, and you don't want them. And network. Network, network, network.
Yes because a weird combination of logic and baseless threats always works in the business world.
Oh, is running really old unsupported versions of software not an issue? It's only a baseless threat if you dont do it. If I was being forced to work with PHP 4 on an XP server I'd quit.
Why don't you just write your own survey software? That sounds like the better solution? Then you would have control of the look/feel and could handle the linking of it however you please? It sounds like you are wanting to do the scraping on page load, and that could potentially increase the load times substantially. Could you ask the company for a better format for the links? if they could provide them in xml, json, csv, or whatever you could just do it client side with javascript?
Right now I have a list of locations, when clicked it drops down and shows the reviews along with a link to the webpage that being displayed in the reviews window. I would be fine if I could find a way to only load the reviews based on the location they click. Right now when you hit that page it just loads for 5-10 sec. Everything as far as page content loads up and most people don't notice the reviews aren't loaded because the reviews aren't being displayed unless you click the drop down for that location and the page loads from first to last. I notice because I know how I made it. I am open to the best practice for doing this, but writing my own survey software is not an option at this point. Couple of major reasons are that we have preprinted blank invoices for each location that already have the URL for that location's review page and because in a corporate world change doesn't feel welcome.
This was definitely the kind of reply I was looking for. A lot of this it seems like I already experience in my current job, which I can definitely handle, even if I have more responsibility as a entry-mid level. &gt;Your day will be frustrating and sometimes you will feel that you are either completely incompetent, or spinning your wheels. This happens a lot. But my co-workers on my same level feel like this too. &gt;"I just glanced down and see that you are a girl. " My gf will enjoy that one, and yes, I am bragging that I have a girlfriend across the internet.
They are calling it an "entry-mid" level position. Meaning I'm not a complete noob, but I'm probably not ready to give orders to everyone or make very big decisions for whatever applications they gives us to work on. That's the gist of it, I believe. 
So you're using an outdated version of PHP on an outdated OS that has nothing but problems... I feel like you (or a supervisor/coworker with experience) should bring this up to management. Explain how outdated it is, how much time (and thus payroll) is wasted on the broken thing, and how it's a huge security risk waiting to be exploited. They don't care about DateTime classes, but they DO care about money and security.
mysql_* IS deprecated [Source](http://php.net/manual/en/migration55.deprecated.php)
&gt; PHP developers (not all, but quite a few) are the only developers I ever heard dismissing the use of a debugger as something unnecessary. That says a lot and makes me not want to work with these people. Setting aside the toxic tone for a moment, you may want to read this book: [Masterminds of Programming: Conversations with the Creators of Major Programming Languages](http://shop.oreilly.com/product/9780596515171.do) Including Guido van Rossum, Bjarne Stroustrup, Larry Wall, James Gosling ... I think you would accept that these are serious programmers. Now, does it surprise you to learn that virtually to a man they state in these interviews that they don't use or need interactive debuggers? That should at least give some pause for thought in your tirade. Would you not want to work with these people?
The only example I see is returning a single user. Is there an example of returning a list of users with different exposure? I am thinking more like http://jmsyst.com/libs/serializer/master/cookbook/exclusion_strategies with the ability to group.
I feel ya, Kratzyyy....
What a cool approach. 
If you are a good developer quitting is risk free, good developers are always needed unless you live in deserted area. If you are a shabby developer, beef up your game and demand proper updated software. PHP is free, so upgrading from 4 to 5.3 or 5.4 just costs time. Linux servers with PHP are always legit you know. 
Use the mid of the month and add or subtract 30 days, then look what month it is: &lt;?php $today = strtotime($argv[1]); $mid_of_month = strtotime(strftime("%Y-%m-15",$today)); echo "today: ",strftime("%c",$today),"\n"; echo "mid of month: ",strftime("%c",$mid_of_month),"\n"; echo "last month: ",strftime("%m",$mid_of_month - 30*24*60*60),"\n"; echo "next month: ",strftime("%m",$mid_of_month + 30*24*60*60),"\n"; 
Be careful about scraping for any commercial purposes. Remember that every time you scrape a page, you're downloading the entire document, which could impact their bandwidth. If they don't know what's going on and see that the same page is getting hit thousands of times per day from one IP, they might blacklist you. Another thing to keep in mind is that, when you're using regular expressions (or a regex-based library) to parse, you're dependent on certain elements to keep their ids. If the other company decides to overhaul their UI, it could break your system, and they probably won't think to notify you in advance. If you're scraping for legitimate purposes, it's always better to request an API. 
ah, mid skills / entry pay.
Oh god
Maybe [this](http://code.google.com/p/phpquery/) will be better for him.
Good. Bye. Don't come back.
Wordpress is a really dated choice these days. Wordpress makes for an absolutely horrible framework and I think almost all but a few Wordpress evangelist developers would agree with that. I have had to try and maintain, extend, and scale Wordpress and it is a total nightmare when I consider all of the things that I would like to have as a serious developer. Continuous integration? Hah. Test coverage? That's like a big joke. Even debugging a Wordpress instillation that has had a lot of development and third party plugins installed is a huge nightmare. I think it was really difficult for me to argue that Wordpress didn't make sense though when I make arguments against it and someone says, "well I can install it and there are so many plugins, it saves so much work!". Up until a year ago I had to just shake my head and say yeah... That's true I can't program all that stuff in a couple weeks. I think Wordpress and Drupal, and other extendable CMS systems in the PHP world really got something right, which was that sharing beats hording any day. In those ecosystems there is a culture of sharing your code, even if it isn't terribly good code or extensible code, it's still useful to people, and they appreciate you sharing, and developers share. I feel like the author of this article really is missing a huge point here though, which is that in the python and ruby world people have really had that kind of "share your code" mentality from the beginning. A year ago I decided to stick my head out of the PHP/Wordpress developers horror I was living and look to see if there was some alternative, and there is and I definitely found it in these other language dimensions. As a ruby or python developer I can use other people's packages that they have chosen to share with the community, and the great thing about them is they are made by real developers! What's even better is if I don't like something in the code, or if I make an improvement, I can share that back with the community, and people really do! When I look at what I can do with ruby/rails/gems in a couple weeks, as a real developer it really puts that "Wordpress plus plugins" argument in its place, which for amateur websites made by enthusiasts, and that is fine, but has no place in the professional developers toolbox. So what about PHP? I didn't give up on it. On the contrary I came back and looked around and what did I find? A tool called composer and a site called packagist. To be honest I was really relieved, that people in the PHP world were starting to realize that if you want to make awesome websites these days you have to share. I think packagist has a long way to go but I think it is definitely on the right track. What do I have to say to the Wordpress, Drupal, magneto, (tons of other CMS like systems here) plugin developers? Your plugins are really awesome and useful, PLEASE try and make them platform agnostic as much as possible and share them with your fellow PHP developers on packagist! For those of you PHP developers that struggle with the Wordpress argument, take a look at packagist, take a look at the ruby toolbox, and dream what a PHP world would be like if PHP developers learned to share. P.S. I also highly suggest using something like bootstrap in the frontend. The quality of the themes is just amazing and really speeds things up on the other half of this story.
Yeah, I concur. What classes as entry in one company might well be mid or senior developer level in another. Casing point, where I work now is quite a flat structure - we're all on the same title, but naturally all have different skill sets and abilities. That said, the general 'must have' is a solid grasp of object oriented principles and design patters, generally sharp grasp of the best solution to problems and a knowledge of mvc frameworks (insofar as how they work at least). This is a stark contrast to the place I worked previously, whereby knowing anything of php at all put you towards the top of the chain as they were a design agency so it was more front end than anything. That brings me on to my next point; some places just get stuff done, by which I mean the emphasis is on the result and the time it takes you to get there more than the way the problem is solved. Others are very keen to adhere to strict standards and good programming principles, which I believe is something a company learns as they mature. So in conclusion, it's very difficult to answer the question definitively, but I would suggest that at the mid level you've got to know oop and at least one mvc framework, would consider writing a basic cms as a simple, groundwork task rather than any sort of challenge (I consider cms related things to be commonplace now, whereas when I started that was a project in of itself) and you need to be confident in what you're doing. At the entry level you really just need to know the basics, so syntax, a good number of the core php functions, and a willingness to learn. But these are just things drawn from my experiences, and this will differ massively for you personally. Hopefully there's something to take away from this, though. 
ah lot of good practices have already been mentioned, just adding the relevant man page: http://php.net/manual/en/datetime.formats.relative.php
I typed this quickly, but it works: $seed = strtotime('10/31/2013'); $m = date("m",$seed); $y = date("y",$seed); $last = ($m-1) &gt; 0 ? ($m)-1 : 12; $next = ($m+1) &lt; 13 ? $m+1 : 1; $last_month = date("F",strtotime($last.'/1/'.$y)); $next_month = date("F",strtotime($next.'/1/'.$y)); echo "Last Month :".$last_month."&lt;br /&gt;Next Month: ".$next_month;
I want to punch your CTO in the dick
Yeah, after looking at the docs that's what I noticed about sync. It doesn't seem relevant to me. 
I was wondering before I posted if I was ready for this level and from what you and the other lengthy reply above I think I'll be a sure fit. OOP is as natural to me as the back of my hand. I'm actually a little better with C++ than PHP (even though I have professional experience in PHP)... but I understand enough I believe to be at this level and ready for what they throw at me. :]
yeah, if OP has experience with jquery this could be a good solution.
The arrows in PHP just look confusing. The -&gt; is used anytime you wanna do something with an object instance. Take note this won't actually work because there's no real Object class in PHP unless you make one. $object = new Object(); // Set a property. $object-&gt;property = 100; // Call a method. $object-&gt;method(); PHP just uses -&gt; where other languages like Java would use a period. The =&gt; operator is for arrays and refers to the keys. For example. $person['name'] = 'John'; $person['age'] = 20; The =&gt; operator lets you do shorthand like this instead. $person = array('name' =&gt; 'John', 'age' =&gt; 20); Also is good on a foreach where you need the key and the value. foreach ($person as $key =&gt; $value) { echo $key . ':' . $value; } 
On top of other good suggestions here (networking, blogging, don't work for shit clients), I'd like to suggest finding your niche. That really just means finding the kind of freelancing you like best. Do you like corporations or mom and pop businesses? Do you have a particular industry that you'd like to target (musicians, health care, education)? Things of that nature. Myself, I prefer to work with digital agencies and/or other web professionals. Often this means subcontracting, where the end clients are never my own. This has its ups and downs -- I can't claim the client's project as my own on my website (usually), but I really love working with people in my industry, who understand everything. There's no explaining like I'm five going on when I'm given a brief -- they can use short, technical jargon and so can I. The projects are also bigger than I could get on my own, which makes for some really neat projects for larger name clients. So find something that works for you and keep at it. Don't try competing with others, as becoming confident with yourself is probably the thing holding you back the most right now.
whyyyyy? Maybe you can call something via command line written in another language. python is always an option.
Why illegally use windows when Linux is free?
And it's been soft deprecated for over a year now. Anyone still using ext/mysql is recklessly incompetent.
And it also works on days like the 30th and 31st of january...
I hate when someone asks me something and I google it and the first link has the answer, so whenever someone new enters the team, i send them this link: [What have you tried?](http://mattgemmell.com/2008/12/08/what-have-you-tried/)
&gt; your stupid Why is it that people who call other people stupid always embarrass themselves in the process? Must be a variation on Muphry's Law.
That's Phil Sturgeon you're responding to. He's kind of a notable figure in the php world. You may want to look him up. 
uhhh... okay. I see.... you assume that I am some dude living in my parents basement. Wrong..... I'am old enough to have my own kids living in my basement. And yeah i strongly believe that developers need to show some balls to companies, and stand for their believes and make choices based on that believe. If you don't show a bit of spine, who will?? But then again if you believe in applying a little fixer here and there and not going forward with an application into a modern age. Most of your arguments are bullshit scare tactics mostly used by management, so they don't need to invest in progress. But when the shit hits the fan, you better believe your ass is on the line. All of sudden it's your fault that the application got hacked by a smart ass intern that wanted to get some revenge on his pears, or some other IT dude thought it was a good idea to open a few ports on the firewall so the CEO can access the all important application from his holiday home in Malibu. Popquiz hotshot, no windows here and every single piece of software i use is licensed. Yes I paid for phpstorm, acorn, smartgit, sublime and a few others that I use to make a pretty decent living for my family, did you pay for your software or are you still very comfortable pirating around in your parents basement? 
Because ther eare apps out there that require Windows and will not run on Linux? Because in spite of all said and done there are limitations, and you won't be able to use your hardware to the full with Linux?
Thanks. On a note, C++ also use's the arrow operator. 
When I started work at a company (about ... 9-10 years ago?) PHP5 was almost around the corner, our main servers were running PHP 4.x branch. I was tasked with fixing some things in our office mail client. I've made the changes, confirmed that it works and pushed the code back to the server. Bad idea - turns out it was running PHP 3.x and missed a bunch of stuff. preg_match? Nope. 
Saying that to Phil Sturgeonâ€¦ Thatâ€™s adorable :D
Blogging material ;-) 
In some companies that can be seen as rocking the boat, bringing problems that obviously did not exist as they had never caused a problem before. Still a good reason to get out though. 
What extra work? There have been wrappers for mysql for well over a decade, that keep you well away from the basic mysql functions. I have *never* had to use those functions directly in twelve years of php development. The ADOdb library is where I started. 
A lot of this is true and valid. Unfortunately PHP has supporters in two camps. Those who are aware of its limitations but still find it a convenient way of achieving goals, and those with no awareness either through wilful disinterest or ignorance. The former group look for and/or have found solutions to the (many and significant) flaws in the language and its ecosystem. The latter are highly reactive to criticisms or suggestions for improvements to PHP. You'll see a lot of that here. So let's actually take a look at this article. &gt; PHP has been making me waste countless hours, even days, to do things that should be doable in just a few minutes or a couple of hours. I'm afraid I'm going to have to say "citation needed" on this one. I'd love to see some examples of things that should be fast, but are really hard in PHP. I find it tends to be quite good for simple things. I'm by no means saying PHP has no flaws. But I don't think this is one of them. &gt; "but so lauded by every empowered amateur whoâ€™s yet to learn anything else" This frustrates me. It's basically saying from the outset that if you agree you're wrong. You don't have to "laud" PHP. But the entire passage above this is "php is bad bad bad it's just bad so bad, php is bad". Hardly productive, hardly useful. &gt; This led to tons of non-programmers becoming "web designers" Developers. Not designers. And it's entirely reasonable. PHP is well positioned as a tool for developers to provide a back-to-front end solution. It ties in very well with web development as a skill. Many of us started as web developers who needed our projects to do more, and gained further skills. There's nothing inherently wrong with that. &gt; pseudo-programmers If you program, you're a programmer. This is a "no true scotsman" style of argument where you simply define something to your liking. &gt; Even worst, there are so many PHP "programmers", that it's nearly impossible to convince any of them that what they are doing is bad, because of the overwhelming "evidence" that supports their nonsense and because they defend each other, truly believing they are right. This is, and I'll say it in bold **absolutely true**. There are some terrible practises and attitudes rife in PHP. We should stop ignoring them, and stop coddling the people who have them. &gt; In the past few years there have been quite a few positive changes in the PHP world. Things like FIG and the PSR standards, Composer, Symfony2 and Laravel 4 are a step in the right direction but they're still far from perfect Well... yeah. But they're a pretty damn BIG step in the right direction. Dismissing this seems purely mean spirited. PSR gives a reliable standard to something that has been relatively missing from php - consistency. Composer provides package management that has enabled frameworks to easily share components. Symfony has provided some amazing bits that provide incredible utility in well tested and effective components. And laravel provides a framework base that emphasises both speed of solution and testability. Don't undervalue that. &gt; unfortunately, shit like Wordpress is rooted so deeply and used by so many people, that it's impossible to do anything about it. Yes, this is true. Wordpress, for all its extreme shittiness has its place. It's actually a very good blog platform. if it was used only for that the world would be a better place. But people keep trying to make it do other things. &gt; What this means is that if you are a PHP developer and not part of the problem, you are basically stuck in a world where you will struggle to find any decent reusable software that you can trust, or any decent developers to incorporate in your team. I don't know about developers, but finding good software certainly isn't hard. &gt; Composer just cannot be taken seriously for any professional development or deployment. These flaws are massively overstated. I'm surprised the writer here (you?) has had so many problems. Composer has been great for me. I don't know why it's so slow for you. And for the record.. 2 gig of ram is really a tiny amount. Putting "only" in quotes doesn't make it sufficient. I'm going to have to do some work now, but I wanted to jump straight to the conclusion. Mostly because I have little interest in either the autoloading or the namespace comments. I think both of those arguments are extremely weak. &gt; PHP developers (not all, but quite a few) are the only developers I ever heard dismissing the use of a debugger as something unnecessary. You're partially right and partially wrong here. The fact is, PHP is one of the few languages where using a debugger is rarely necessary. Specifically, because it's uncompiled and runs quickly, most debugging can be done just by echo/print_r the problem area. I run xdebug in netbeans and and debug out quite happily. But I almost never do. Because it's usually just not necessary. Dumping the output straight to the browser is ugly, it's inelegant, but it works. Sort of sums up PHP in some ways, huh? &gt; but you really need to look beyond PHP and I refuse to discuss this with you until you've used something like Python or Ruby for at least a year. Well... no. Sorry, but I can't. I've been doing PHP for years, but I really don't have time to start learning another language. I'm sure python is lovely, and I've heard Ruby is "elegant", I can tell that because ruby people won't shut the fuck up about it. But seriously, what benefit is there to me or to my career to spend a year learning how to solve exactly the same problems in a completely different way? And if this makes me not worth talking to... so be it. The fact is there is a lot of truth to this article. There are a lot of veteran PHP programmers who are self-taught and have appalling practises and standards. They write code the same way they have for 10 years, disparage new techniques, scoff at frameworks, and don't use unit testing or static analysis. As a result, PHP programmers tend to consider as high level or "optional" skills and techniques that should be baseline, unit testing being chief among them. Still, I think this article doesn't contribute much. Where there is massive improvement it snarkily dismisses it. Where there are minor flaws or questionable implementation it rails like they are crushing issues. PHP is still, all too much, a language of cowboys and dabblers. But there are many of us within the language, daily, professional users, who actively seek to improve it.
I'd like to add that in languages like PHP debugging with var_dump (or similar) is a lot more practical than trying to debug C++ with std::cout (because it requires a recompile and often you can't output values just like that). When I'm working in C I'm making heavy use of gdb, but in PHP I usually just don't see the need. Only sometimes use xdebug when looking at very complex logic.
It's all about Orwellian doublespeak man. Instead of discussing problems and losses - we don't even mention them, instead you tell them how much time and money would be saved in the long term by going through the upgrade process. Then not only do you get a more pleasant working environment, you look like someone who cares about their job and the company you work for who is thinking about ways to improve the business.
I don't care who he is, that kind of logic in this field is retarded.
And handles leap years like a champ. 
Hmm, let me add my 5 cents. I have about 7 years of experience in PHP up to and including 5.3, 3 years of Python and 4 years of Java, mainly Spring, and a working knowledge of about 5 other languages. I always was the proponent of "selecting proper tools to get the job done", regardless of my preference to one language over the other. I argued time and again that good code can be done in PHP as such, but one had to be rather careful with the thing, to not mess up badly -- nowdays its somewhat easier with large frameworks like Zend or Symfony, but then again, I feel that those frameworks are designed around the notion of leading the developer by the hand to not screw things, and to kick under the wraps some design flaws with the language. Anyway, here's my recent experience. After about 2 years of hacking away in Python -- not by choice, it was just needed so I learned the language -- I took a job in a project/team lead job in a PHP house, based on interesting projects they were doing. I somewhat disregarded that I am returning to PHP because of what I stated above, language is just a tool, so whatever, right? Well, wrong. Even though I was able to ease into PHP development easily again, I started noticing things (albeit small sometimes), that just bugged me, time and again. I will not try to enumerate those, it was just the general feeling of: "why doing this has to be that weird?" or "oh, PHP cannot do this, hmm, how come?" and later "@#! what the.. is the interpreter that dumb?" and so forth. I started to miss Python, even though I am not a fanboy, not by a long shot. I just wished to do my job with something else. The team uses Symfony 2. Even though I was not familiar with it, it felt kinda like I've seen it before. Annotations? DI container? Oh, but of course, that's Spring! And using that beast feels even weirder. Even though my kudos go to authors of the project, they've done a hell of a job (and with other things like composer is, which, as I understand it, is also a brain child of the original Symfony author), to this day, I cannot understand why we would want to shoehorn a framework that's designed around principles of statically typed language onto a dynamic one. Which brings me back to my feeling that this was done out of need to "cultivate" developers, so to speak. My experience with Symfony notwithstanding, I started to think that PHP is somewhat inferior to other tools in some respects. I don't hold any particular hatred for the thing -- I have my grudges against other languages as well, nothing is perfect -- but I think there are other options nowdays that may be more suitable for web applications, obviously depending on what are you building. Among other things, PHP has a tendency (its a feature) to hide several things from you as a convenience and I personally think that this is not good for a novice developer. Until you try to write a web application in something else, you dont even know how things may work behind the scenes, mainly the request response cycle. Take for example Java servlets. You get a Request object from the servlet container, and you return a Response with contents set on that. Its very thin interface, but its well defined and all is well. However, in PHP, you just print to the buffer and it magically appears on the web page. As we all agreed that this is not good practice, the front controller pattern started to be used widely, so we could get rid of problems imposed upon us by the fact how PHP gets interpreted wherever you put your scripts. Which in turn lead to the widespread usage of .htaccess and mod_rewrite, which has its own problems, so we could suddenly route requests instead of interpreting separate files and so on. And at the end of the day, we ended up in a state, where practically all big frameworks are actually *reversing* those basic PHP properties it was designed with in mind in the first place: templating, no hassle around request/response cycles, access to request variables, automatic sessions... Which is kind of strange. And so it happened to me on several occasions, that even seasoned PHP developers did not even realize, how you can build/deploy your web architecture, because they did not get the full picture from the start and did not know better, because few of said things are unknown in the PHP world. In conclusion, I understand OPs complaint that he felt left out or right out outraged. I would feel the same way few years back. However, I have to admit, that after stints with other technologies, I kinda dont like going back to the PHP world. And as I stated in the beginning, I lived through days of PHP 4 and php 5.3, so its not like I am thinking in outdated complaints against the language. It just happens that after arguably great improvements to it, I still feel there are alternatives which can work better for numerous reasons. Trust me, I was personally surprised that I ended up with this conclusion (I really liked PHP at the time when they redesigned the OO in 5.0 and defended it quite often), but that is my experience.
Yeah I figured if you'd used C++ it wouldn't be all that confusing. That's where it comes from. C++ uses both depending on if you're using an object or a pointer. In languages like PHP the difference is meaningless so some languages kept the period and dropped the arrow and languages like PHP kept the arrow and dropped the period. That's all it is.
Having used code igniter, it'd say it has the easiest learning curve. It's a very nice, easy to learn and quick framework. I would highly suggest Yii framework though. Powerful. Learning curve is a bit steep though. 
"Sometimes you may wish to save not only a model, but also all of its relationships. To do so, you may use the push method:" That's all the docs say. I find the docs for Laravel to be hugely frustrating for this sort of thing. "All of its relationships?" What does that mean? How does it work? How do they need to be set up? A bit of reading shows that this is NOT how it works. Push() is essentially the same as running something like "foreach child, save()"
But is this what you were expecting from "advance the month": $old = strtotime('31 January 2013'); $new = mktime(date('H', $old), date('i', $old), date('s', $old), date('n', $old) + 1, date('j', $old), date('Y', $old)); echo date('d F Y', $new); // = '03 March 2013' ?
That's not what i mean. Tight coupling would be an error, it has technically nothing to do with unit tests in the first place. I very strictly separate test &lt;-&gt; code, in order to have tests who are as "critical" as possible.
Hm.. you got me :-) When I did that, I did it only for the 1st of the month, so for me this couldn't have happened. Thanks!
Never ever ever do validation on client side only. It should be implemented server-side first, then added into the client.
Could someone post a 'best' answer to #1 ? Also, how would I go about #2 ? Should I just sort the list and then try to 'couple' minimum and maximum numbers? Thanks.
Laravel is always the correct answer
Yii is great if you do a few tutorials first. If you know how to use it properly it can save you loads of time and avert lots of common security holes that might otherwise sneak in.
I've just started C++, I'm enjoying it so far, but pointers and the arrow operator is pretty new to me, I only new of it from PHP and from what I understand and understood, its used to access a member variable. I don't really use class's in PHP so I haven't used it outside of arrays.
That depends how well you value your time. I've quit jobs over less.
Let's look at a few reasons why this is the opposite of retarded. 1. Working for a company that has no concern for using outdated insecure versions of code is dangerous. They get hacked, you were in charge of that codebase, you get fired. 2. Working on adding features to that code takes twice as long as adding features to a newer codebase, so you look bad compared to colleagues. 3. An unhappy developer is an unproductive developer. 4. Aint nobody got time for that shit. If you're really suggesting that A) working with PHP 4.4 is fine and B) There is no way to get that code upgraded, then you're living in a dreamworld. Upgrading perfectly functioning code is pointless, but if you're adding new functionality to the code or doing substantial work to it then its time to upgrade.
some links for those who never heard of this: * https://github.com/krakjoe/pthreads * http://pecl.php.net/package/pthreads * http://pthreads.org/
Thanks for writing this krakjoe! I'd especially like to emphasize the awesomeness of point 1: You probably heard many people tell you that PHP does not support multi-threading whereas Ruby and Python do. In a way, the converse is true: PHP has support for *actual* multi-threading, whereas Ruby and Python implement it using a [GIL][gil] (global interpreter lock, which basically means that threads can only improve performance if they are IO-bound). PHP just doesn't natively expose threads to the user and requires an extension like pthreads instead. [gil]: http://en.wikipedia.org/wiki/Global_Interpreter_Lock
It's a complex subject that is poorly reported on; it is the climate change of PHP. The problem is that people coming to research PHP's support for multi-threading come up against blogs and posts written in antiquity, which are mostly wrong even for their time. The people who really know never bothered to write it down, because nobody was listening. I've spotted your attempts on reddit to explain TSRM and very good they are so I didn't go into it here, hopefully our attempts will be enough to properly inform those looking in the future ... thankfully the Zend Engine will not melt while we await the propagation of information ... A persistent problem that still exists ... we say things in passing with a massive impact, it seems implicit to us ... A GIL is a throttle round the throat of your application with such a grip that it is surprising you can execute concurrently at all, and often you cannot. This isn't really multi-threading at all, it always seemed to me to be such a severe restriction that it renders the feature pointless. Operations being implicitly atomic and cor and cow, I kinda just threw that out there. In the real world this means any time you $this-&gt;anything you are reading a copy of the data stored at [anything] which is made under the supervision of a lock that ensures nobody can change [anything] while the copy is made. Anytime you assign $this-&gt;anything the lock I just mentioned is acquired and the data you assign is copied to the pthreads object, the original data that was assigned does not have it's refcount changed and Zend is able to free it if no more references exist. This is what is means by copy on read and copy on write, and implcitly atomic ... just for clarity ...
&gt; PHP just doesn't natively expose threads to the user and requires an extension like pthreads instead. Finally, it makes sense. Thanks guys.
This is a pretty basic question, so I feel obligated to refer you to the basics. Google some PHP/MySQL tutorials to get yourself started. Ignore anyone who tells you to focus on PDO/ORM first. I mean, that's okay, I guess, but it's one of those things that teaches you how to do something without really knowing how it works. I think you should approach learning programming the same way you do with math. You learn long division before you learn short division, and that's because you need to understand the underlying rules before you can take the shortcuts. PDO and ORM are two shortcuts. Anyway, I digress... The above said, here's the answer to your questions: There's a basic misunderstanding of definitions here, so let me explain what a database is. If you've used Excel before, you know that you can have multiple "sheets" in the same spreadsheet. A database is a very advanced form of an Excel spreadsheet. The "sheets" of a database are called tables. What you want to do do is create one database "website" (or something more descriptive), then create different tables to represent different parts of your database. You would have one table that represents customers with fields like customer_id, customer_name, phone_number, and so on. You would have a second table that represents products with fields like product_id, product_name, price, quantity, and so on. An example MySQL query to fetch a list of all customer names might look like this: SELECT customer_name FROM customers; You can even have what we call join tables (customer_products) that contains the fields customer_id and product_id to track which customers purchased which products. That's a little farther down the line and there are some additional concerns to worry about there, so maybe you don't need to do that just yet. Anyway, databases are designed to handle tables easily, so as long as you're connected to that database, you can easily access the other tables. At this point, I can't really tell you any more without going into code, so I suggest you look up some PHP/MySQL tutorials and start with that. Anyway, hope that helps. Good luck!
So, I'm not sure if this is sarcasm or not, but assuming that it is: I think not exposing it natively is quite a sensible choice. Multi-threading is an advanced feature, so one can expect that somebody who wants to use it can run a `pecl install pthreads` command (or download the DLL on Windows). Can't be sure on this, but I suspect that exposing threading without ext could have caused more harm than good (just imagine avg php dev writing threaded code ... ugh).
Can someone give a realistic example of when this might be useful in a PHP app?
I think that the whole point Krakjoe is making is that Pthreads can't be useful in PHP for the listed reasons ;-)
Cool. Totally understand. Wasn't sure if I should have gone the route of separate databases or not. Tables would be a lot easier to manage. Like I said.....been like 4 years. Thanks a lot!
I concur, pthreads would not benefit from integration or bundling in its current form... Threading is complex, for sure ... but I did try to write pthreads for the average user, most of the blurbs advising people that using pthreads is a bad idea cite problems that exist in other languages when multi-threading that simply do not exist in pthreads. Which is kind of encouraging, but even so, I'd prefer PHP to remain simple and for threading to be a feature that you come across when you know about absolutely everything else, which seems to be the main clientele of pthreads at the moment. In the end, you shouldn't need experience with concurrency just in order to do two things at once, and pthreads is written with that in mind ... I think I made a mistake calling it pthreads because people assume its a posix threads implementation for PHP, which it is certainly not, the closest implementation to pthreads is Java's implementation of multi-threading, there are obvious differences that I cannot change from an extension... Which brings me to current form; an implementation at the core of Zend would be superior to pthreads, I realize this is a pipe dream and what you would be left with would not really resemble Zend (for pecl heads) but it would execute PHP ... So, as is usual with humans, I have two concurrent and contrived opinions, on the one hand, KISS and stay in pecl, on the other hand, imagine what could be done if I were plugged right in, I relish at the thought of the technical exercise of writing a truly concurrent Zend, but like pthreads was it would only be an exercise I have no real way of telling if what we got out the other end would be an actual improvement over KISS, assuming I could ever find enough time to bring such an implementation to completion ....
Then you should read the post again ... that's certainly not what I said at all ...
$this refers to the current class so in my example below it would reference the class named "classname" or the current class. private vs public is used to build a wall around variables and functions. public functions and variables can be called from outside of it's current class. Where a private function can be called only from within the current class. The Filesystem in your example is the "type" of $file. In that case it's an entire object that is being passed into the function. Say you had: class classname { protected $file; public function _construct(Filesystem $file) { $this-&gt;file = $file } } class Filesystem { ... } Apologies for spelling mistakes and grammar. It's 3am. Night.
Anytime you want to do more than one thing ... I can't really give a more exact answer than that. I can say this, unless you have rock solid php fu, don't be tempted to make chocolate from cheese. If your current app looks like it might benefit from threading, then don't be tempted to swap chunks of your cheese for chocolate, because it will be horrible. Rather, rewrite the recipe. In other words, your ideas will always benefit more from the possibility of multithreading than your applications will, just knowing it exists allows you to think about things differently ....
Is there any particular reasons to use PHP multithreading rather than splitting it up into its own process via a queue system or something similar?
That's a bit like asking is there any reason to prefer ice over steam; they are both forms of water, it much depends on the activity ... Historically, a queue system or multi processing model is used because of the absence of multi-threading, that's not to say that a queue or mpm doesn't have their legitimate uses even with the addition of multi-threading ... I am not getting into the business of telling you which is best for your application and skill set, try and find out is the only way to go here, think about the things you couldn't do before and can now is about all I can say ...
Don't feel bad, everybody is by default in that group ... everyone thinks there must be a million guys that know PHP inside and out, the truth is there are about 5 people on the face of the earth that can give you an authoritative answer concerning multithreading in PHP, there are about the same that can give you an authoritative answer about anything to do with Zend/PHP ... there's even less still that bother to write down their thoughts or refute any of the nonsense found on the interweb ... Even having read what I have to say, you should probably refrain from providing advice, you can see in this thread that I refrain from providing advice. This isn't a clear cut subject, if a new database engine/server comes out you get all the normal questions, what are the benefits etc, and you can measure reasonably accurately in a generic way which is better, multi-threading just isn't like that. As I mentioned you probably shouldn't be tempted to swap a bit of your multi-processing, or queues or whatever for pthreads what you should do is open your eyes to the possiblity of multi-threading, do some research at the console and when you next have a task at hand you will know for yourself what is the best path to take without me saying anything ...
That's a shame ... installing in *nix can be a headache by virtue of the fact that by default PHP is not usually a thread safe build ... once you have a thread safe build, installation is childs play and there are a shed load of examples included with the distribution and available here: https://github.com/krakjoe/pthreads/tree/master/examples I hope you change your mind, no one should ever be closed to the idea of new possibilities ... no one, ever ...
Well that's true. PHP doesn't have a great history of multithreading therefore PHP programmers by default don't know too much about concurrency and related issues. I wouldn't be so dramatic with saying only 5 people can really answer this or that. Perhaps that applies to internals but the more popular a software is the more people can answer generic questions about it. Anyway.. sorry for the confusion.
Oh yeah I was referring specifically to internals ... lots of people know PHP obviously, but only a tiny tiny amount of people know exactly what they are executing when they are executing PHP, that's a matter of fact, if there were more versed C programmers then we would know who they are .... unless the companies they work for are incredibly selfish and more importantly self destructive, which cannot be many, if any ...
Makes me wonder if this project might benefit from pthreads, http://socketo.me/
I really have no idea about how pthreads works, but if there are changes to Zend that could improve the support, I'm sure that we'd be willing to make them (assuming it doesn't go in the direction of "total rewrite" \^\^). Btw, what happened to that TLS patch? :P
&gt; # PHP proposed idea... &gt; $cmd_data = array( &gt; 'releases' =&gt; '/home/me/releases', &gt; 'webroot' =&gt; '/www/some/website/', &gt; 'git_repo' =&gt; '/home/me/git/my_repo.git' &gt; 'release_name' =&gt; TIMESTAMP &gt; ); &gt; cmds = array( &gt; sprintf('git clone %(git_repo)s %(releases)s/%(release_name)s', $cmd_data), &gt; sprintf('mv %(webroot)s %(webroot)s.old &amp;&amp; ln -s %(releases)s/%(release_name)s %(webroot)s', $cmd_data), &gt; ); That basically works already: $cmd_data = array( '(releases)' =&gt; '/home/me/releases', '(webroot)' =&gt; '/www/some/website/', '(git_repo)' =&gt; '/home/me/git/my_repo.git' '(release_name)' =&gt; TIMESTAMP, ); $cmds = array( strtr('git clone (git_repo)s (releases)s/(release_name)s', $cmd_data), strtr('mv (webroot)s (webroot)s.old &amp;&amp; ln -s (releases)s/(release_name)s (webroot)s', $cmd_data), );
Simple example: Downloading many files. You want them to be downloaded all at the same time, not one after another. This is possible without threads (e.g. curl_multi does this and does it *very* badly), threads just make it more or less trivial. I think the average PHP user has very little use for threads, but people writing daemons and stuff like that can benefit a lot from threading ;)
First: You're fucked. There are no (that I know of) "mid-level" book for pretty much any language. Books for programming languages are usually split between 1. Books for people with no programming knowledge 2. Books focusing on a specific feature of a language 3. Books focusing on a specific part of programming (algorithms, design patterns, OOP, etc.) This annoys me anytime I want to start learning a new language. Your best option is to go with either #2 or #3 and then go back to the manual or back to #1-type books (or the [online manual](http://php.net/manual/en/)) if you are hitting basic language issues. Areas you probably want to research: 1. [Object Oriented Programming](http://www.php.net/manual/en/language.oop5.php) / [Namespaces](http://www.php.net/manual/en/language.namespaces.php) - This is one I'm trying to master now. I started with PHP before OOP was really possible and didn't really pick up on it when it was added except using other people's frameworks. 2. [PDO](http://php.net/manual/en/book.pdo.php) and [SPL](http://php.net/manual/en/book.spl.php) - Learn PDO for database access and learn the SPL so you don't duplicate a lot of functionality. Hell, it would probably be wise to at least skim [the function list](http://www.php.net/manual/en/funcref.php) to get an idea of everything PHP can do. 3. [Automated/Unit Testing](http://phpunit.de/manual/current/en/index.html) - Learn to run automated tests against your code. It is an investment in your code and against future work. 4. Finally, check out the list of topics for the [Zend PHP Certification](http://www.zend.com/services/certification/php-5-certification/) and become familiar with everything on their Exam Information list. Even if you don't go for the certification, it will cover enough of the language that you should be pretty competent. Finally, some actual recommendations: 1. [PHP the Right Way](http://www.phptherightway.com/) 2. [PHP Master: Write Cutting-Edge Code](http://www.sitepoint.com/books/phppro1/) 3. [Learning PHP Design Patterns](http://shop.oreilly.com/product/0636920028062.do) 4. [Pro PHP MVC](http://www.apress.com/9781430241645) 5. [Grumpy Programmer's PHPUnit Cookbook](https://leanpub.com/grumpy-phpunit) 6. [PHP Weekly News](http://www.phpweekly.com/) As a final note, always be reading, learning, and coding.
You're going to want at least three tables: One for the customers, one for the products, and then one junction table to connect the users to the purchased products. If you want to split it up into different orders, you might want one representing that as well. Example: +-----------+ +---------------+ | Customers | | Orders | +-----------+ +---------------+ | id (PK) |-------------------+ | id (PK) |----+ | name | +----------------o&lt;| customer (FK) | | | ... | | date | | +-----------+ | ... | | +---------------+ | | +------------+ +---------------+ | | Products | | OrderProducts | | +------------+ +---------------+ | | id (PK) |------------------+ | order (FK) |&gt;---+ | brand | +----------------o&lt;| product (FK) | | ... | | quantity | +------------+ +---------------+ 
PHP manual comes up in first page when you google for pthreads, shouldn't be that confusing ... the name seems unimportant, but it's worth mentioning that "threads" is an abandoned extension from years ago so that name was taken, you cannot have php in the name of your project either, against license ...
Honestly curious, how exactly does multi curl do it bad? 
No, i really didn't understand how or why it works. 
&gt;I don't understand what "$this" is referring to exactly. $this refers to the current instance of the class. &gt; I'm also unsure as to when to use public vs. protected Public - When you want the property accessible from outside the class. Private - When you only want the property accessible from inside the class. Protected - When you want the property accessible from inside the class and its subclasses. &gt;what is "Filesystem" Filesystem is another class. By specifying the class in the arguments, you specify that you're expecting the argument to be an instance of said class. 
&gt; you cannot have php in the name of your project either, against license As long as it's not a derived work you can: &gt; Products derived from this software may not be called "PHP", nor may "PHP" appear in their name, without prior written permission from group@php.net. You may indicate that your software works in conjunction with PHP by saying "Foo for PHP" instead of calling it "PHP Foo" or "phpfoo" I don't think extensions constitute "derived work". See also [license FAQ](http://www.php.net/license/index.php#faq-lic). But obviously IANAL \^\^
I will give you mine. I have a token, a security code and X consumers. A consumer registers the token if the security code is provided, and returns another reference token once registration is complete. The user is asked for the initial token and the security code. It takes the consumer anywhere between 5 and 120 seconds to respond. I want to: * Confirm to the user that the request is accepted as soon as at least one consumer verified the security code. * Register the token in maximum possible amount of consumers, so that I have as many reference tokens as possible which allows me to perform operations without having to ask the user for the token and the code every time. * If none of the consumers confirmed the security code, let the user know that the token or the code they supplied is invalid If I do not do this with threads, my choices are: * Execute the requests sequentially, forcing the user to wait X*t seconds (where t is average consumer response time), which is bad business * Set up a job queue, fire off job requests for every consumer and wait until at least one succeeds or all fails, which is essentialy same as with threads, but over an artificial pipeline. * Fold up and go home, mission failed.
You know, when your IoC container is this barebones, is it really offering much advantage over just sticking everything into $GLOBALS?
I fully agree. It took me a minute to figure out that pthreads were not referring to POSIX threads. Why overload the name of another very popular and old piece of technology? It's so easy to just pick another name and avoid endless confusion. How about ThreadMod or PTE (PHP Thread Extension) or PST (PHP Safe Threads) or anything but pthreads?
You're most likely seeing personalised search results. The actual first result for "pthreads" is: https://computing.llnl.gov/tutorials/pthreads/
Yeah, first page, not first result ... it jumps out of the page as a php manual address ... I'm quite happy with the name tbh, it would be a headache to change at this point ...
The static scope of a class entry can be considered thread local, in a way. Complex members (objects and resources) are nullified when creating new threads, but simple members (arrays/strings/numbers/mixture of any of the above) are copied, so in the static scope can be class::$config which contains connection info to whatever and class::$connection can be the connection itself, when class::getConnection() is called self::$connection should be created where null, thus providing all threads with a local copy of the same resource using common connection info ...
Hm, it seems a bit roundabout, especially that I was thinking more about some number-crunching use-case, so that the cor/cow locks aren't taken. Anyway, I'm just rambling; thanks for putting the time and effort into it!
Simples ... something like this: &lt;?php class MyQueue extends Stackable { public function run() { } } class MyThread extends Thread { public $queue; public $runs; public function __construct($queue) { $this-&gt;queue = $queue; $this-&gt;runs = 0; } public function run() { while (($item = $this-&gt;queue-&gt;shift())) { var_dump($item); $this-&gt;runs++; } } } /* create a queue */ $queue = new MyQueue(); while (count($queue) &lt; 10000) $queue[] = sprintf("http://google.com/?q=%s", md5(rand())); /* create a bunch of threads to chew the queue */ $threads = array(); while ($i++ &lt; 10) { $threads[$i] = new MyThread($queue); $threads[$i]-&gt;start(); } /* allow all threads to complete execution */ foreach ($threads as $thread) $thread-&gt;join(); /* print some stuff, why not */ foreach ($threads as $id =&gt; $thread) { printf("Thread %lu ran %d times\n", $id, $thread-&gt;runs); $total += $thread-&gt;runs; } printf("Total queued executions: %d\n", $total); ?&gt; This is highly simplified but you get the idea ... note that shift/pop/range are only in git, so get sources from there, they will be included in 0.45 which I'll release soon as I've found time to write up docs for new functions ... Here's another example using Worker/Stackable model where it is easier to return a result (task forms container for it) ... &lt;?php class MyQueue extends Stackable { public function run() { } } class MyWorker extends Worker { public $queue; public $runs; public function __construct($queue) { $this-&gt;queue = $queue; $this-&gt;runs = 0; } public function run() { /* open logs/database whatever here */ } } class MyTask extends Stackable { public function run() { $queued = $this-&gt;worker-&gt;queue-&gt;shift(); $this-&gt;result = strrev( $queued ); $this-&gt;worker-&gt;runs++; } } /* create a queue */ $queue = new MyQueue(); while (count($queue) &lt; 10000) $queue[] = sprintf("http://google.com/?q=%s", md5(rand())); /* create a bunch of workers to execute tasks */ $workers = array(); while ($i++ &lt; 10) { $workers[$i] = new MyWorker($queue); $workers[$i]-&gt;start(); } /* create a bunch of tasks to pop the queue */ foreach ($queue as $i =&gt; $v) { $tasks[$i] = new MyTask(); $workers[ array_rand($workers)]-&gt;stack($tasks[$i]); } /* allow all workers to complete execution */ foreach ($workers as $worker) $worker-&gt;shutdown(); /* print some stuff, why not */ foreach ($tasks as $id =&gt; $task) { printf("Task %d set result: %s\n", $id, $task-&gt;result); } /* just for completeness */ $total = 0; foreach ($workers as $worker) $total += $worker-&gt;runs; printf("Total tasks executed: %d\n", $total); ?&gt;
I'd just like to say that the vast, vast, *vast* majority of PHP applications do **not** need multithreading, so please research before you start adding it into your app. Also, make sure you're profiling your code before and after you add multithreading; sometimes, there isn't a noticeable difference, even though your app falls under one of the use cases for it.
You're right thanks. 
There are some key things I'm trying to figure out that I didn't see in the pthreads docs. One is limiting the number of threads/workers going at once. From your example, it looks like that's accomplished simply by creating $max number of Worker instances: &lt;?php $workers = array (); while ($i++ &lt; $maxThreads) { $workers[$i] = new MyWorker($queue); $workers[$i]-&gt;start(); } So that makes sense to me now. Thank you. I'll have to dig in to the pthreads docs a bit more to figure out Stackable and Worker/Thread instances. Overall, pthreads looks like a very interesting extension. Unfortunately for this project, pthreads is probably out of reach for various policy-driven reasons. What I'll probably have to do is use a wrapper for pcntl, which seems to be less than ideal but still hopefully better than running everything in serial. Thank you very much for your input and work on this extension though. I may write a pthreads version of the aggregation tool to run/experiment with locally just to learn the extension and track its development.
Suggestions on books besides the standard recommendations of the manual and rightway already given. Try O'Reilly Programming PHP (3rd edition only) It's kind of in between beginner to intermediate and IMO a better read than the manual for explanations. For learning OOP, there's a lot of resources, sticking to O'reilly stuff they just put out Learning PHP design patterns which I've read a lil bit of and it seems like a good read for learning it. Lynda.com has an OOP tutorial for PHP which I felt was decent. Once you kinda pick up enough understanding of PHP you'll probably find yourself going back to the manual and reading a lot of it but you'll understand it more. 
Multi_curl is a pain in the ass because it is multi-threaded on the Curl side, but blocking on the PHP side. You have to continuously poll curl asking "Hey do you have some data for me?" If the answer is no, you can do something else/sleep for a bit. If the answer is yes, you grab some data from curl and process it. If "processing" takes a long time, you are potentially blocking a bunch of other requests which could have finished. Once you are done with this request, then you go back to polling, etc etc. It gets complicated/ugly because everything is still batch-based, not truly multi-threaded. If you put in a big batch of requests to curl, you need to wait for all of them to finish before moving to the next batch. You are executing requests in parallel, but still blocking on your slowest request. You can get around this by streaming results in/out of a queue using callbacks, but it quickly turns into a really painful, ugly solution (if you are interested in how this works, check out [Rolling Curl](https://github.com/chuyskywalker/rolling-curl)) This is completely ignoring the terrible, cryptic API that curl exposes - it is a labrynth of obnoxious C calls that have strange side-effects and undocumented gotchas.
Counterpoint to this is that in large organizations, PHP devs might not actually have sufficient privileges to just run pecl, especially on production systems, and having a feature included natively saves the devs from the bureaucratic uglies of convincing the sys admins that the library isn't going to melt their hardware. 
you can sort of accomplish the same thing with message queuing with multiple workers ingesting messages. but that requires multiple processes to be spun up manually. 
With this I could detect when a box is checked? http://i.minus.com/jbxURjMhGhlp65.png (Imgur was down) I print this to paper. hand them to workers. Real Life Workers. They fill them out, pencil/pen in each row and column. I need to know wich ones they marked Rigth now, i got an intern checking them in a Excel sheet... and then graph them. I want to pass it over to php, i belive I scan them, and then how do i detect when a box is checked?
The easy thing is to code for one global config, then test for that on install. Support the variants you want and nothing else.
There is grossly insufficient data to answer this question. &gt;in which hosting is currently less than 5MB. That should be the size it takes up on the drive. Storage space and bandwidth are not the same thing. &gt;When the number of URLs go up, and we're rerouting thousands of users, what can we roughly expect the cost of traffic to be Are we talking monetary cost or the total expected bandwidth consumption? If the former, I have no idea what your hosting provider's rates are. If the latter, you haven't really provided us with the number of redirects you expect to happen. I'd place a single redirect at roughly 600 bytes (request and response). You do the math. 
For a free solution use VirtualBox (https://www.virtualbox.org/wiki/Downloads). Install the same guest OS as your live web server and set it up in an identical way. I also find it handy to set up an ant script to automate the application deployment.
Your last sentence is really what I was looking for, thanks. I know our storage will always be minuscule, but I really wasn't sure how much bandwidth a redirect takes, so saying roughly 600 bytes (or now 1kb as a good over-measure), I can really get an idea of bandwidth costs. Thanks!
Don't forget to account for regular page views as well. 
Well, the only reason I added PDO is because it does abstract a bit of how it works out. I personally think you should know how something works before using an abstracted version of it. Having said that, I'm willing to backtrack on that statement.
I personally do most of my developement directly on the testserver over SSH. Vim is one of the best (if not the best) editors out there, although it has a kinds steep learningcurve.
This. I'll never go back. After investing some time in a chef or puppet script (and in many cases you can find something close to your needs on GitHub), you can create and destroy development environments in one command. It's really badass.
This. Plus ... add in Vagrant (http://www.vagrantup.com) and Veewwe (https://github.com/jedi4ever/veewee) to build a complete solution. You use Veewee to create a 'base box' VM that matches whatever your ISP is likely to provide. Then use Vagrant scripts to do the last mile of configuring your app. Vagrant is like a script API for Virtual Box. You can script just about anything that Virtual Box GUI allows, like add shared folders, configure ports, suspend the VM session, etc. Once you're done you can just add a Vagrantfile to your src folder and then rebuild the VM from scratch every time you need it. 
Or use https://puphpet.com/.
Flat out wrong. Syntax alone is not enough to understand OOP.
Setup virtual machines as others have noted, Virtual box and VMware are both great. In addition to that, you can setup a local and remote config file that contains all of the paths for your xampp setup and then on the remote server. This will help with file operations. The thing with headers is you need to remember you can't print anything before setting the header. This won't always throw an error all the time on xampp, but will on a production linux box. Setting up a LAMP stack in a virtual machine will expand your knowledge of linux administration which will help your PHP development. (you can start configuring and adding modules to PHP as you need/want, tuning apache/nginx, etc) Check out Git for souce code version control. You can setup remote repositories and branch it to your development environment and with a few line bash script, you can automate pushing out updates to as many servers as you have. Just some other points about virtual machines dev environments -- You can setup a local DNS server to map out your local network which is nice. You no longer need to use IP's, you can setup something like http://mydevserver.homenetwork.lan -- this can also be used as a DNS caching server, which will speed up your regular internet browsing. One last thing, you should try developing on a Linux desktop( You can use another virtual machine for this). Start with ubuntu and go from there. There are quite a few IDE's that have a ton of functionality like Netbeans available in linux. Working every day in a linux desktop, you will learn all the tricks and power of it, and why not... it's where your code goes to shine...(onto a linux server). 
Of course it wouldn't break for people older than 43. Negative numbers represent the number of seconds before January 1st 1970. 
Once the recipes / manifests are mature they can just as easily be used to stand up the production server/VM that used to be done completely manually (for example, once your OS is end of lifed).
&gt;Caution &gt;pthreads was, and is, an experiment with pretty good results. Any of its limitations or features may change at any time; that is the nature of experimentation. Hard to justify putting experimental beta code into anything important. Anything not that important I will most likely not take the time to add multithreading. Love that this library exists. Hope someday it becomes stable. 
You only need to keep the files you create in source control, since external libraries already have public repositories. You can easily include their code into your project as a git submodule or by using Composer and adding the "vendor/" directory to .gitignore. Composer is the way to go IMO
Have any good resources explaining how?
I know you said you don't want to add more infrastructure, but something like Resque is genuinely good for this. There's [a PHP port](https://github.com/chrisboulton/php-resque) you can monitor with the regular Resque-web tool, including retrying failed items, and using a premade work queue will save you lots of unnecessary coding. You can also grow your workers across multiple servers later in a really trivially easy way if it comes to that. I'm using it in silex, for which there's a [service provider](https://github.com/GromNaN/SilexResque) which provides a basejob class that injects the application container, and a console command to start a worker, just to make things even easier. 
Thanks, this is good stuff to know. I've used multi curl in the past but for stuff that these things wouldn't really be issues, at least not matter. 
I've made a shopping system recently and also slipped in a ProductPrice table *(id,product,price,tax,date)* so you can have historical pricing on orders, OrderProducts would have a ProductPriceID linking column so you can deal with price increases cleanly. (you could also store your order total against the order and at-the-time pricing statically against OrderProducts) The product list would select the most recent ProductPrice by date for that product and store the currently displayed ID along with the cart (you could also store the active ProductPrice id in the product table)
Awesome, I didn't even think to look for a PHP port of Resque. Thanks!
For managing asynchronous processing of background tasks, take a look at [gearman](http://gearman.org/). I use it with [supervisord](http://supervisord.org/). Here's how I apply it. Supervisord manages the processes, keeping the gearman server and each of the client workers alive. You write your task as a simple PHP function (something like doParseFeed($job)), with a small CLI script that lets gearman know it can use this function to accomplish the task. Then when a feed needs to be processed, you simply pass the raw data as the payload of the job and "fire and forget". Gearman takes care of passing the job off to the client. Finally, to ensure my workers never use too much memory (i.e. they perfectly clean up after each job), I actually exit the worker script (which triggers supervisord to refire the worker and register again). The benefits to this are: 1) There's a gearman setting to how many workers you want to assign. 2) You can leave your workers sleep using 0% cpu until they're needed. After they complete their task they completely clean up their memory by exiting the script entirely. Supervisord then relaunches the script and the workers register again. 3) You can actually distribute workers to multiple nodes for scalability (this was the big requirement for my project since some of the workers can take a while to complete and we can't block the queue).
&gt; I develop using xampp on windows, then upload files to (I think) a linux server using ftp. I could be out of line here, and I'm not going to tackle your actual question (plenty of others have) but something about the way you've put this suggests to me that you're not using version control. Use version control. To put it another way, always don't never not reject version control. Err... I'm not sure if I have the right number of negatives in here, but the point is **use version control**. If you use a hosted SVN solution, for example, you can simply right click to send your files up to the repository and then either manually or automatically deploy from that. You can do the same with Git. Even aside from **much** easier deployment, version control makes your code better, because you don't need to keep duplicates as backups or huge slabs of removed functionality in comments. More importantly, though, version control allows you to easily rollback, remove, fix, and see mistakes you've made. It's possible that you're actually using version control already, in which case, please feel free to ignore me and/or point and laugh at me. But if you're not, for the love of God start doing so immediately.
why not make your life easy and run minecraft as so: java -Xms1G -Xmx1G -jar minecraft_server.jar nogui | tee minecraft.log With that, your output will still show in screen and will be written to whatever file you like (minecraft.log here). screen does not write to stdio, and so will not work through so-called non-interactive execution (i.e. stream-only, no terminal).
This would work great for this post's question, but sadly I need screen so I can do more things than one. It's a dilemma!
I have to say, Git is a wonderful VCS that I would recommend over SVN any day.
+1 for vim. -1 for developing on the server. -1 for no mention of a VCS like Git, Mercurial, or even SVN. Sorry :(
My boss and I have actually run into a lots of bugs in our build process for our current project recently because of differences between linux and mac. It's been frustrating. VM's are a much better solution. 
Yor can work around using screen hardcopy command. Also take a look at tmux. Great alternative to screen!
Thank you for your advice, but neither of those work for what I need.
i dont upload ... instead i use a NFS share // mounted WEBDAV i.e. my z:/ points to beta.localdomain.tld except that our sysadmin keeps the dev servers in line with production ones, he did this manually for years, then used images, now he uses puppet.
-1 for developing on a test (dev) server? Why?
Shame you didn't read the whole post ... it's marked experimental because of what it is, I've tried to explain that decision ... it won't be beta forever ...
Thanks for the tip, will be setting up Vagrant today.
It's a developement server, not a production server. And Revisioning systems are not nessesary when you're the only dev, and remember to backup your code. Something tells me that all these downvotes come from people who think using an IDE is the only real way...
Exactly, i would never make changes to code in production, doing so is a death sin.
That could work if you are the only one who is working on a project. As long as you have more than 1 developer, you can't work on the same dev server.
But then another question shows up: how to manage your VCS? GIT repo on each virtual machine? It may be accidentaly deleted. GitHub? It doesn't allow free private repos. So how do you manage to have reliable VCS system that will be available for every developer anytime with latest changes?
To further elaborate, in this context, an interface does not equal an [object interface](http://php.net/manual/en/language.oop5.interfaces.php), but rather the exposed methods of any type, be it a class or an object interface. If the supplied type is an object interface, the provided instance must be of a class which implements that interface. If the supplied type is a class, the provided instance must be of that class or one of its subclasses. 
Ah yes, I completely forgot about that :) I myself learnt PHP largely through use of the cakePHP framework years and years ago and then thanks to getting a dev position in a company my knowledge accelerated through discussing ideas with other dev's and co-writing code with them. With programming, as with much of life, you never stop learning.
bitbucket is free
best thing I ever did was pick up a cheap netbook (sub $300) and have it sitting next to my router as my own development linux server. super cheap, portable, developing locally on windows is crazy. I have my IDE (netbeans) set to upload files to the local server on save, 'cause it's in the local network it's instant, it's the perfect solution for me.
No, you're right that I don't. Would you suggest git? I would preferably like something that I can start using relatively quickly rather than something that takes ages to master? 
Yes, it's an apache server - what linux distribution would you recommend for Php dev? Or would it not matter? 
Do you use bitbucket? How does your deployment workflow look like then?
I don't use them, I use GitHub and pay for their private repositories, but I figured you might be interested in them as they're like GitHub but without a cost for private repositories (what you mentioned being a problem).
You can quite easily, assuming you all have your own accounts and working environments on that server 
So how does your GitHub deployment workflow look like? :)
I'm not the person that originally recommended version control, but: I commit code to my local version of the repository then I sync with the remote repository (hosted by GitHub) then from the server I do: git fetch upstream/master &amp;&amp; git merge upstream/master and it's deployed. For some projects I have automated deployments so that when new code is committed to the repository and then GitHub triggers an automatic deployment using web hooks and [DeployHQ](http://deployhq.com/). 
There's an example in the source with a number of different use cases: https://github.com/leedavis81/drest/blob/master/examples/application1/Entities/User.php
Well, that's a recent update. Also, why rc1, they officially released 7.0 already.
I'm using [Bitbucket](https://bitbucket.org/) for a year now and I never had a problem with them. And their private repositories are free for up to 5 members/repo.
Git is slightly more complicated, but not much. Benefit being it's much faster and not reliant on a single server. Although it might be easier to learn now because there's so many guides and training tools for Git on the web. I say just start with Git now, it's replacing SVN for most people. I'm currently in the process of switching over.
Match the server as much as possible, distribution, packages, version numbers etc. I personally use Debian.
I don't. I don't use virtual machines, so I'm not sure how that works. Ask the people that do use them. I'm sure some of them use git with vagrant. 
Honestly, SVN is a little simpler, but pretty much everyone uses Git now, and for good reason. Get a free github account, download the github client, and then you can just use that. 
You can still run the command in screen, just read from the log file instead of trying to parse screen with php.
My advice is to do nothing. This is a problem that goes away naturally after a little while. Once you become more experienced with PHP you'll know how to write code that works on your different servers and server configurations. Your examples seem trivial: * File ops? Yup. You have to set the appropriate permissions on the web directory or file before you can write to it. * Sending headers or cookies? Sounds like your local server had output buffering turned on and the remote one didn't. Send headers before sending any other output and this will be never come up as a problem. If you avoid the differences by using a VM you'll lose the chance to learn. Then one day you'll want to run some of your code on a different web host and it won't work.
speed and clean markup
a bit old... 2009 just saying :)
did you really just suggest putting "everything into $GLOBALS"? Let me guess, the idea of scope doesn't exist in the code you're writing. Please don't advocate this - it's a pretty bad practice to just dump everything in there. You'd do better to learn about the proper way to use class visibility (public, private, protected), getters/setters and doing dependency injection via constructor or something. 
I will answer in (what seemed at the beginning) a sensible order, not necessarily the order they came in ... * The reason pthreads is not a Posix Threads implementation is because it is not an implementation of the Posix Standard for Threading, commonly called *pthread* (contained in pthread.h) (okay, that was pretty confusing, stay with me) ... however, Posix Threads are widely available on *nix and derivs, in the early days I intended to support just nix, it then turned out that the redhat win32 project run pthreads without modification, so Windows support was born. It is still not an implementation of Posix Threads but is an implementation of PHP Threads relying on Posix Threads behind the scenes. * Synchronize(): The object monitor is based on Posix Conditions, the spec says you are supposed to acquire the associated mutex before calling wait, logic dictates that a lot of the time the notifier will need to acquire the lock before notifying. So the synchronize block acquires that lock and executes the block (expecting a notify/wait) ... this idea is borrowed from java's implementation of the same logic ... as usual there is a hole in the spec, infact you can wait/signal/broadcast without acquiring the lock, I've not yet in practice found anywhere you should do this and I've been using posix threads a long long time ... * Cond/Mutex: these are a direct interface to the underlying posix library, Mutex are pretty self explanatory and don't think I should explain further, suffice to say, call Mutex::destroy in the same context you called Mutex::create, omitting that will cause leaking memory (fine if it's process wide, and accepted practice, lots of libraries do it, but you have a choice and might be running in a SAPI, so avoiding leaks would be obvious best practice). A condition is less self explanitory, here's a good explanation from the posix standard, which they are a direct interface too: https://computing.llnl.gov/tutorials/pthreads/#ConditionVariables that might seem a bit lazy, but I can't explain it better than the posix standard does, the same exactly applies to everything you can read about them. In reality, Mutex/Cond aren't directed at normal users, they make it into the distribution because they are useful for development of the codebase itself, pthreads is OO and cond/mutex arent really ( they cannot really be without a bunch of overhead that we do not want ), rather than Cond::signal use Object::notify and rather than Mutex::lock aim to use Object::lock ... I hope that's a bit clearer ... * Resources: Difficultly is not the problem, it is support. Just flicking around php-src and bundled exts, they are completely unprepared for this kind of manipulation, there is no way from an external extension to change that ... this is one of the things that a threaded Zend would benefit from ... by pure chance I found a way to make some basic resource types behave themselves in a multi-threaded environment, but it has to remain officially unsupported, there is really not much I can do about it ... nikic, back me up, it makes no sense to even try to share resources, even if it looks cool, right !? * Lock/Unlock: these are indeed user methods, each object has a property table like normal objects do, lock/unlock will acquire the lock on that table, helping you to stop another context from manipulating that object while you are working on the table as a set, even if the other context didn't explicitly call lock on the object. * State of the Manual: again, nikic, back me up, writing documentation for php is harder and much more frustrating than writing code for it ... the manual and last release should be about equivalent most fo the time, build times for docs trail behind upon release by a few days normally. * State of the Project: as mentioned the manual corresponds to the latest release, it's quite normal for master to contain changes not yet documented or released, most of the time the two should be in sync, but it's not a reflection of the state of the code, the last release is stable enough, master contains some cool new stuff and a few bug fixes, finding the time to iron all the creases out, document everything and push out a release is getting harder and harder ... I'm entirely on my own with pthreads :( you'll just have to wait for me to catch up ... * Object Handling: multiple contexts cannot manipulate even basic types, the Zend MM prohibits it, so anything complex and NOT derived from pthreads must be serialized when it is written to an object as a member. Objects that are derived from pthreads are not serialized and are designed with threading in mind, many examples go into manipulating pthreads objects as every supported type, recently added methods in git allow better manipulation as a set, like shift/pop/range etc, they won't be undocumented forever and believe there are examples included in git right now for them if you're interested in testing them out ... * Inheritance: It might seem odd that Worker doesn't descend from Thread, but they are actually a bit different, as you can tell from the exposed methods, so inheritance doesn't seem suitable to me ... for clarity; a Worker is a Thread whose state is persistent until you shut it down, it's run() method is called on Worker::start to setup the context. You place Stackables on the stack of Worker threads and the Worker pops and executes them in the common context until there are no more items on the stack. You can synchronize with a Stackable, but not a Worker the reason is the Worker's object monitor is overridden to provide Worker functionality, additionally, the unit of execution is now the Stackable and not the Worker, so code calling Worker::wait doesn't make much sense ... * Exceptions: handle exceptions as you normally would, they aren't able to bubble (where would they bubble up to, think about it, what if you are passing a worker among threads, or some other pthreads object among contexts that did not create it, where should the exception be thrown then ... an infinite amount of answers exist, so it cannot be really done). The idea of isTerminated is as follows: if a context quits because of an uncuaght exception or fatal error, isTerminated will return true. Saving the exception doesn't make much sense really, it would be tricky to do, being that the context wants to shut down and we don't want to keep it waiting for an unrecoverable errors stack to be read by an unknown context, or not ... So you can detect fatal errors in other contexts, handle exceptions as you normally would with each contexts isolation in mind ... that should be enough ?? I'm grateful you took the time to actually look, have I answered everything ?? It's easy enough for me to put this information out there, formatting it for the manual is not such an easy task, hopefully contributors get involved and embellish the manual with wisdom like every other section of the manual, I guess that'll come in time ... I am pretty much on my own with pthreads, other than a few patches here and there from the elders (people who have used pthreads from the day they noticed it this time last year) and help deploying for windows (because I hate windows, I'm allergic), I have to write, debug, document and develop everything on my own with no input from anyone until it's too late most of the time ... most of the work is now done so there is no point in complaining, sometime in the next few releases I will switch to stable releases as other than bug fix there will be nothing more I want for pthreads and nothing more you should need ... It started a good proof of concept, thanks for recognizing that ... when you get to know it, it becomes a bit more than that, there's not much I could write in java that I couldn't write in PHP, I'm not saying it's a good idea to do so, but the fact that is it's a viable choice is pretty awesome ... it's tiresome to read responses like PHP applications do not need threading ... that's a moot point, until pthreads they couldn't have threading, so clearly, there's not much in existence that could need something that doesn't exist ... this opens up a world of possibilities as far as I see it, allowing you to think about doing things in PHP you couldn't have attempted before ... I hope the people reading start thinking about that, rather than how their current applications can benefit ... I know the current applications are on the mind, but I hand you a rocket ship, reach for the stars, don't rebuild your car with it's parts !!!
This is not directly on-point, but worth sharing IMO: A few months ago I learned that as of recently (~ PHP 5.4, I think), PHP ships with a built-in web-server. You can start it like: php -S localhost:3000 Whereby the "3000" is obviously whatever port you want it to run on. I find this server to be very handy for small projects and such. It gives you nice debugging output (as does Webrick et al) but spares you from having to configure Apache and all that. I periodically use it when I'm doing really simple work.
Use gitlab
I've built a simple LAMP (debian squeeze, php 5.4, mysql, composer, git...) web app Vagrant server setup that allows you to run your project(s) locally in a really simple way: https://github.com/mbman/lampapp-vagrant
Nope, I didn't suggest that. I said that this "DI container" offers little advantage over that.
The point collapses when you think of APC, which has always been pecl, and is the most installed extension that exists ... I don't think you should have to do much convincing, if you do then get new sysadmins and send yours back to the mid-90's from whence they came :D
Provide me a real example of something you want to do and I can show you the best way to do it ... The way statics behave is an accident, a nice accident that can be taken advantage of if you think of it in a particular way ... the matter of fact is that Zend doesn't handle statics the way members are handled so they have to behave differently to true members ... as yet I have not exposed anything I consider as unsafe, which includes manipulating anything without acquiring a lock, I'm not sure that I will ... but, that's not to say that I cannot be encouraged to add some objects in the future if I can be provided with a good reason they should exist and make more complex something already complex ...
At this point why not just start writing in Go? It's basically same thing that Zephir is going to bring to the table, but it can run as a standalone web server ditching apache/nginx completely. If I'm going to static type my code whats the point of having PHP at all?
There are two options: 1. Build your code is such a generic, abstracted fashion that it will work anywhere. 2. Make your dev env be as close to identical to the production env as possible. I use 1. for PyroCMS and 2. for everything else, and I do that with [Vagrant](http://net.tutsplus.com/tutorials/php/vagrant-what-why-and-how/).
Does anyone know how general (non-threaded) performance suffers, if at all, by enabling ZTS? 
A raspberry pi would have been a lot cheaper to run a local server on and I am pretty sure you can get different flavors of linux on it to match your production environment. The one thing to note is that a Pi would not have the same CPU architecture, but that shouldn't be a problem for PHP development
&gt; Remember to backup your code If you use a proper versioning system then you wouldn't have to do this. Vim is fine, but it is not nearly as powerful as a dedicated php ide. 
Having to instantiate a class (which uses magic methods) to store things in a private array, it would be slower than just storing things in the $GLOBALS array. And also that having to write "$container-&gt;whatever()" isn't really "cleaner" than writing "$GLOBALS['whatever']()" This implementation is just trendiness gone mad. "DI is all the rage. Let's write a DI container, but make it so slim that it does nothing but store functions in an array! This is so much better than storing everything in a global array like some kind of n00b!" Everyone agrees that global variables are bad. Then they go on to write a container which is basically just re-implementing global variables. This is a case of understanding that DI is good, but not really knowing why or how to implement it. 
This looks very interested, and I look forward to seeing how it goes. I know we're all very excited about Composer, but having simplistic syntax for extensions is great. I dont expect we'll see a drastic rush of people going back to pecl extensions for general code packages but it certainly wont hurt - and will be especially useful for speeding up internal chunks of code. That said I would be interested to find out the speed differences of A) replacing chunks of my app with Zephir extensions or B) just smashing the whole thing through HHVM.
Ah yes (note, both debug builds): [joe@fiji php-src]$ php-zts Zend/bench.php simple 0.267 simplecall 0.592 simpleucall 0.662 simpleudcall 0.663 mandel 0.750 mandel2 1.132 ackermann(7) 0.593 ary(50000) 0.073 ary2(50000) 0.067 ary3(2000) 0.519 fibo(30) 1.863 hash1(50000) 0.116 hash2(500) 0.126 heapsort(20000) 0.301 matrix(20) 0.263 nestedloop(12) 0.436 sieve(30) 0.293 strcat(200000) 0.038 ------------------------ Total 8.756 [joe@fiji php-src]$ php-nts Zend/bench.php simple 0.198 simplecall 0.374 simpleucall 0.374 simpleudcall 0.373 mandel 0.711 mandel2 1.056 ackermann(7) 0.472 ary(50000) 0.067 ary2(50000) 0.062 ary3(2000) 0.483 fibo(30) 1.393 hash1(50000) 0.100 hash2(500) 0.099 heapsort(20000) 0.275 matrix(20) 0.243 nestedloop(12) 0.351 sieve(30) 0.273 strcat(200000) 0.036 ------------------------ Total 6.940 There is some overhead using thread safe PHP, it's an overhead that it's possible to avoid, and such a patch is in the works but won't become reality until I find the time to work on it, which will be after pthreads is stable ... unless someone else does it first ... it's also an overhead that's it's not difficult to negate if you can thread ... Here's a teaser, this is a heavily patched php that reduces considerably that overhead, which hopefully will one day be the norm: [joe@fiji php-src]$ sapi/cli/php Zend/bench.php simple 0.251 simplecall 0.477 simpleucall 0.523 simpleudcall 0.525 mandel 0.768 mandel2 1.070 ackermann(7) 0.478 ary(50000) 0.069 ary2(50000) 0.064 ary3(2000) 0.516 fibo(30) 1.568 hash1(50000) 0.103 hash2(500) 0.096 heapsort(20000) 0.288 matrix(20) 0.260 nestedloop(12) 0.433 sieve(30) 0.284 strcat(200000) 0.038 ------------------------ Total 7.813 Now, this heavily patched php cannot run pthreads right now ... the poc of that will come after much more work on the patch is done ... but I have run it before now with a modified pthreads and it works just fine ...
This is a bit meaty, but we send this guide to new people here in the office if they need to learn Git: http://www.vogella.com/articles/Git/article.html
This looks very cool. I love the idea of being able to use statically typed variables and creating lower level PHP extensions without having to directly know C.
If you always are working with the same server, get as close as you can to matching. Otherwise, go with either Ubuntu or CentOS (if you are working with RHEL servers a lot). If you are cautious, local dev on OSX can be pretty similar to a generic linux environment - if you don't want to mess with VMs. When you are working for a lot of clients on different servers it isn't always practical to build a custom environment for each project. In that case, assume most are hosted on some form of LAMP, and check phpinfo on the servers before you start, to find out what is available for you to use. 
I have another question, how does pthreads handles fatal error. Say a thread throws fatal error doing some invalid things, does it bring down whole process?
I must say it's amazing that something as unique and interesting as this project would get downvoted in the PHP sub-reddit. Trollers be trollin'. http://fc06.deviantart.net/fs71/i/2011/062/6/d/trolls_be_trollin___by_thatvalvegamer-d3aundh.png
&gt; Having to instantiate a class (which uses magic methods) to store things in a private array, it would be slower than just storing things in the $GLOBALS array. $GLOBAL is extremly slow (incrementing a local variable is 3 times faster than on a global) http://phplens.com/lens/php-book/optimizing-debugging-php.php &gt; $GLOBALS['whatever']() isn't cleaner since $object-&gt;method() is normal OOP syntax which isnt dirty at all. And since $GLOBALS is hard to follow its even dirtier. &gt; Everyone agrees that global variables are bad. Then they go on to write a container which is basically just re-implementing global variables. This is a case of understanding that DI is good, but not really knowing why or how to implement it. The behavior of a IoC and $GLOBAL is a bit different 
which is also wrong
&gt;I must say it's amazing that something as unique and interesting as this project would get downvoted in the PHP sub-reddit. Trollers be trollin'. Are you kidding? The post has 7 points. 
Awesome reply, thank you, that clears up a lot of things. And you're right, it does open a world of possibilities. The fact that you've done all this work on your own is all the more impressive, hopefully this will become much better known over time. Quick follow-up questions, if I may: 1) Am I right in thinking that wherever you've used mutexes in the examples, like [this one](https://github.com/krakjoe/pthreads/blob/master/examples/Mutexes.php#L12), you could use `$this-&gt;lock()` instead? Are they equivalent? 2) Is the following therefore the same as calling `$this-&gt;wait()` within a synchronised block, equivalent to calling pthread_cond_wait(): $this-&gt;lock(); $this-&gt;wait(); $this-&gt;unlock(); 
The fatal error only occurs in one context, from any other context a call to isTerminated will return true ... 
&gt; hing as unique and interesting as this project would get downvoted in the PHP sub-reddit. Trollers be trollin'. Don't be so quick to whinge. This thread is currently #1 on the PHP sub. Also the anti-spam system sometimes adds fake downvotes. Chill Winston. 
Ah, great, it also opens a new opportunity. Thanks again for creating this library.
Ah, got it now, I think - different locks in each case. Thanks again for the detailed replies! 
&gt; And it may be true that PHP has the highest number of unmaintained projects out there, but that's because it eclipses the number of projects that other languages have. Have you even seen CPAN?
I'm going to plug Go whenever and wherever I can, because it truly is _that_ awesome. Web apps are actually quite easy in Go, and there are already full stack frameworks to help out.
&gt; $GLOBAL is extremly slow (incrementing a local variable is 3 times faster than on a global) And I'm not comparing it to incrementing a local variable, I'm comparing it to manipulating an associative array encapsulated within a class and accessed via PHP's magic methods, which is what this IoC container does. You wanna benchmark that against $GLOBAL? I'd be interested to see the results. Also, from the link you pasted: &gt; Incrementing a global variable is 2 times slow than a local var. Incrementing a object property (eg. $this-&gt;prop++) is 3 times slower than a local variable. That says global variables are 2 times slower, not 3 times. But class properties, which this IoC implementation DOES use, are 3 times slower! And that's probably even too low an estimate, because it doesn't just use class properties, it uses magic methods, which in turn add the value to an associative array! But even that's probably all irrelevant as that link you pasted is nine years old. &gt; isn't cleaner since $object-&gt;method() is normal OOP syntax which isnt dirty at all. And since $GLOBALS is hard to follow its even dirtier. * $object-&gt;method() is not how one would use this IoC container. Check out their usage example. * An object is an instance of a class. A coder should be able to look at the class which defines the object and see those methods defined, so he knows what it's capable of. Adding them dynamically, via magic methods, results in a variable with a kind of dictionary of mystery-properties. This is the expected behavior of an associative array, not a class-defined object. So calling this "normal OOP syntax" isn't even really correct. * If you think "$GLOBALS" is hard to follow, I'm not sure how to respond other than I think that's not a normal problem. &gt; The behavior of a IoC and $GLOBAL is a bit different Yes, they are. Or rather, they should be. But this particular IoC implementation does nothing more than encapsulate an associative array within an object which you expect to be always available (one might say "globally" available.) In case it's not clear, I am not saying "IoC is useless, just use $GLOBALS!" I am saying that this here particular IoC implementation, which is linked to by the post on which we're commenting, offers no advantages over global variables since, by bringing nothing extra to the party, that it essentially what it's re-implementing.
Please tell me what advantages this particular IoC container, which does nothing more than encapsulate an associative array, provides.
Have you tried? $dbh-&gt;exec("SET names utf8"); $dbh-&gt;exec("SET CHARACTER_SET utf8"); or $dbh = new PDO("mysql:host=localhost;dbname=world;charset=utf8", 'my_user', 'my_pass'); ??
I keep hearing this, I don't believe it to be true. For example, there's not a good xdebug plugin for vim. I know there are at least two, but from my experience and a buddy's experience it's not 100%. It takes a lot to set up, and even then it does not provide all the functionality you would expect to see in a full-featured debugger. vim's intellisense plugins for PHP are also not top-notch. They can show all methods in all classes, or maybe methods in a specified class, but it won't show methods for nested objects. These two things are huge show stoppers for myself and many other serious developers.
I don't use IDEs for PHP, I use a plain text editor (often Kate or Vim). However, if you want to remember what you did, or what others did, you want to use a version control system of some sort. I highly recommend Git. What I do is this: * Local LAMP stack on my machine (lets me edit and save code, and see changes immediately). * Virtual machine run in the background with KVM (test dev server; I git push to this to test my code still runs on the testing environment). * Hosted server (I don't have SSH access or even sftp access on my crappy free hosting, so I just copy/paste my files to it, but I've made my dev server VM as close to it as possible). I'm the only developer. However, I also have it in Github in case I'm ever not the only developer.
i agree with u, golang is very good language..it is very easy.. basically Go is python in disguised using php syntax
The one I was directed to was with two ## so it would be ##php. Is there a difference? 
read the post again, the first myth dispelled is that PHP is not thread safe ... it ruddy well is, that post was written in 2008 and I have no idea who wrote it, their name should be recognizable if they know what they are talking about .... give up ...
Really? How is go closer to php syntax than python? PHP and Python have classes, Go doesn't. PHP, Python are loosely typed, Go is strongly typed. I'd rather say that Python is Go for PHP programmers =) 
I use a Windows desktop because we use Outlook etc but for PHP I have a dev server and access it from Windows as a share drive using Samba. I use the Windows version of PhpStorm and sit on the command line with Putty. That works pretty good. I agree with those saying try to avoid developing on Windows and deploying to LAMP. At home I simply use Ubuntu Linux. 
Thanks!
Have you ever given Vim a real chance? There are so many things that makes your write code so much faster when using Vim, you can even write your own tools for it, if you are in need of something specific. http://xhtml-css.com/blog/seven-reasons-every-programmer-should-use-vim Oh and xdebug is old and clunky, use vdebug :)
zephir is the name of a troll on /r/Physics maybe its just reflex
What kind of applications would benefit from using threads? I have a php app that reads a large file of json objects, then processes each object. Could I speed processing those objects up with threading?
For example streaming an on-the-fly assembled Zip archive. I was completely satisfied using PHP per process (with FPM it's performant and easy enough to manage), so I don't have an immediate need for any new bells and whistles.
have you tried multi curl?
So, [Cython](http://www.cython.org) for PHP?
I don't know the direct answer to your situation, however there is a good collection of code analyzers on this page: http://phpqatools.org/
I always like new languages, but I don't understand it here. Why not write it in a language close to C that is embeddable. You'll save yourself the hard work of attaching (or building) a GC. Even Rust is embeddable, but still immature and the Dart VM is very promising w/ regards to your optional typing needs. Things like Lua (nicely embeddable), D (maintains the same C ABI), and Nimrod (cross-compiles to C) all seem like better options for a GC'd low-level language than rolling your own.
Are they doing analysis on a binary created by HipHop or the like? Or are they using something like [RIPS](http://rips-scanner.sourceforge.net/) that does static analysis on tokenized source? I'd worry that traditional static analysis on something from HipHop would be about finding compiler bugs and the like and wouldn't reflect real world issues. On the other hand, running HipHop on the codebase might uncover some real issues (along with some possible incompatibilities).
I have no idea. They're a reputable code testing company (not sure if it's appropriate to name the company doing the testing or not)
No tests written in over a year? Stay away. Stay far away.
I only have one real concern: The primary reason extensions are faster than user land code, is extensions can use native C solutions. Native arrays, native string handling, native memory allocation, etc. It's possible for Zephir compiled code to be even *slower* than user land PHP. Zephir is a very promising project. I would like to see inline C code handling so the really nasty loops and algorithms can take advantage of Cisms.
Whilst I am a fan of Phalcon, there needs to be more effort to document PHP internals if you want more community participation, not create an abstraction. In terms of PHP performance, I'm more excited about HHVM if they can get up and stay current with the latest PHP. JRuby is a great platform that allows ruby code to run on the existing jvm, I hope HHVM can do something similar for PHP in terms of speed.
You should abandon CodeIgniter and move on to something a bit more modern. Lord knows the creators have moved on.
As have the people making stuff for it.
Go has structs and structural subtyping. That's similar to classes in my opinion.
Abandoning code igniter is easier said than done at this point. While I don't generally build anything new in PHP these days, I do maintain multiple CI based applications. What would you recommend as a "more modern" framework? Always looking to add new tools to my belt. 
Here is what I would expect: 1. If I ask you to create a PHP program to present a form, save data to a database, extract data from a database to an interactive screen, create a report, create a chart, integrate into excel, create a REST API, output a PDF, interface to a credit card back-end - you will be able to do this. 2. I expect you to understand AJAX and be able to write PHP code (and probably the javascript code) to make a ajax call to a PHP stub, which then initiates and calls a class or set of classes you have defined to do some business logic and database manipulations and return JSON data to the client. 3. I expect you to ask me questions about our coding standards, to maybe want to see similar code we have already developed so you can be consistent with comments, variable, class and method names etc. I expect you to ask me what frameworks we use and be prepared to go away and learn them in your own time. I expect you to ask me about CM and what souce code control system we use and either know it or learn it quickly in your own time. 4. I hired you so I want you to succeed. I am not expecting you to know exactly what we do or be an expert. I want to mold you into what we want for our project. I want you to be enthusiastic and willing to learn, but not too opinionated (I will already know some of the stuff we do is not cutting edge or using the latest whizz-bang framework so dont need you telling me this). I expect you to use google, I expect you to know how to learn new stuff and not have everything in your head. 5. Most of all I just want you to follow my direction and knock out some code for my project, to let me know if you have problems and if not to commit to deadlines and try your best. 
The fact that it's easier to set up and code in the say, python, or ruby, or java? Low entry barrier, quick set up, and smooth learning curve, in a nutshell 
*How can this even be a question?* **PHP is popular by itself.** What got me into PHP is the C/C++ similarity. I could learn the basics quickly as the syntax was close to what I was used to from C++. Take away ALL THE frameworks and WordPress... and I'd still use PHP. **A PHP developer should be able to build from scratch, not live and die by frameworks. Otherwise, he's just a... user ;)** *(I'm gonna get so much hate on this comment here...)* **PS**: *I actually have my own web-site framework and library built over the years so I don't even use other frameworks (except my own). I do use WordPress for blogs and content oriented sites.* **PPS**: *Yes PHP has a lot of issues. But with experience you learn how to get around them. The pros outweigh the cons IMO.*
switched from github to bitbucket over a year ago. the migration was super simple and bitbucket is free
Symfony, Zend, Laravel etc.
This. You don't need to know OOP or the difference between static or dynamic typing. It's not necessarily a good thing, but it makes PHP a lot easier to learn for someone starting from scratch.
&gt; $object-&gt;method() is not how one would use this IoC container. Check out their usage example. first off I copy pasted you there, so... And you can use it like this if you follow the code. &gt; That says global variables are 2 times slower, not 3 times. But class properties, which this IoC implementation DOES use, are 3 times slower! And that's probably even too low an estimate, because it doesn't just use class properties, it uses magic methods, which in turn add the value to an associative array! that was my bad, I just copy pasted the statement of Stackoverflow &gt; An object is an instance of a class. A coder should be able to look at the class which defines the object and see those methods defined, so he knows what it's capable of. Adding them dynamically, via magic methods, results in a variable with a kind of dictionary of mystery-properties. behind theres an associative array, as soon as you see magic methods you know whats up. &gt; This is the expected behavior of an associative array, not a class-defined object. So calling this "normal OOP syntax" isn't even really correct. ?? the object itself isnt dynamic, the array behind it is. And btw syntax has nothing to do with the behavior, so its still normal OOP syntax. &gt; If you think "$GLOBALS" is hard to follow, I'm not sure how to respond other than I think that's not a normal problem. so changing something that can have unexpected results because its used elsewhere and is global isnt hard to follow?
its not global, and thats a BIG advantage
To use the value of a variable to then form another variable we use double dollar signs $$ so for example we could do $who = 'myname'; then echo $$who. This will echo out the value of $myname.
Uhhhhhh...map is a pretty core function in pretty much every language. If you aren't familiar with the concept by heart, it would be a good time investment. 