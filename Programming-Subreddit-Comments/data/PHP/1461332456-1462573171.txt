sounds disgusting.
why `&lt;&lt;` and `&gt;&gt;` as delimiters? single brackets look a lot cleaner.
Thanks for liking it :) But yeah, Apache only I'm afraid
What's your use-case for overloading command handlers? I'm guessing you are trying to passing a Command DTO? Mind explaining?
Two things are really cool about this: 1. it's open source 2. they plan to add linux support. Currently, when you need to talk to MSSQL from PHP7 on Linux you either have to use ODBC which comes with a lot of additional dependencies and you have to deal with the MSSQL ODBC driver being very picky about UnixODBC versions, or alternatively, you use pdo_dblib and link against FreeTDS, but while that generally works, it's also very easy to make it segfault due to various bugs in dblib. Having an officially supported PDO driver from MS that also runs under linux will be very, very welcome.
&gt; Attribute is a specially formatted text enclosed with “«” and “»”. Maybe a little nitpicky, but the single-character double-angle-brackets in this statement don’t match up with the actual use of two separate single-angle-brackets. That is `«` is different from `&lt;&lt;`. Might want to clean that up?
very very cool.
Can you make an example of what a child class would do here? If `update()` is really the only exposed method, then you can likely make this a collaborator/dependency rather than a parent class.
This is a good point. I noticed Phalcon doesnt have a decent user base. I am guessing it's because they can't debug the framework. HHVM is nice. However, benchmarks revealed it's still slower than compiled C extensions (by a lot). I don't know how these will be affected by PHP 7 though 
NO. I'm NOT saying Laravel and/or opinions are bad. I'm saying that putting everything in a single package is LESS GOOD.
I think it's already posted to reddit a thousand times: http://techrights.org/2015/04/12/stabbing-linux-in-the-back/ 
Possibly of interest: &gt; Q. Can I sell my surplus software licenses? Yes, but conditions apply: You can’t resell OEM licenses (because they are tied to a specific machine). Although you can usually sell the whole machine! You can’t resell subscriptions (because they relate to a specific term) You can’t break up bundles It must be uninstalled This is a EU ruling and only applies to licenses purchased within the EU. Similar disputes in the USA are as yet unresolved. http://www.itassetmanagement.net/2014/02/13/yes-you-can/
Source: https://blogs.msdn.microsoft.com/sqlphp/2016/04/12/early-technical-preview-of-microsoft-drivers-4-0-3-for-php-for-sql-server-released/ The new Microsoft is great. I just hope that it will last.
Like this? class ExampleConnection { protected $updater; public function __construct(ConnectionUpdater $updater) { $this-&gt;updater = $updater; } } How would I call the update function from outside? Make the updater property public? I'm sorry if I sound clueless or rude but how is this helping?
Just a side comment: In my opinion, this discussion lacks what it seems nearly all discussions of this type in this sub reddit lack: stark implementation suggestions without any mention of OOAD, specifically the analysis part, which should leave little to no question of how the technical design of your class should be, if followed correctly.
Ah I see, I will try something like this. Thanks for your help!
Yes. Always. You should also have something like `http://mysite.com/api/vx/api?param=value` (or something similar) and a controller route like: `http://mysite.com/controllerAction?param=value`
Assuming you are referecing a index.php file.... which would lead you to write the URL as (www.domain.com/region/summeroner_name/page) RewriteEngine on RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule ^(.*)/(.*)/(.*)$ index.php?region=$1&amp;summeroner_name=$2&amp;page=$3
I really don't like the idea of annotations affecting execution of the app either. I've worked with a Java app that is something akin to this: [An Annotation Nightmare](http://www.beabetterdeveloper.com/2013/12/an-annotation-nightmare.html).
So that validation annotation stuff just magically happens, or do you conveniently not count the addition of parsing libraries, interceptors, and all of those other functions that do the validation in a black box? One tiny validation function that lives under the "main" function, or a whole bunch of messy, opaque infrastructure to make those annotations work? Gee what a hard choice... At any rate, you seem to want to have your cake and eat it too. First you complain that the "main" function shouldn't be concerned with validating its arguments (which I disagree with, btw), then you say that delegating it to another function disconnects the two too much. Even though the disconnect with the annotations is MUCH greater when you actually account for the infrastructure needed to make those annotations actually work...
This was super helpful! &gt;RewriteRule .*/(.)/(.)$ index.php?region=$1&amp;summeroner_name=$2&amp;paage=$3 RewriteRule .*/(.)/(.)$ index.php?region=$1&amp;summoner_name=$2&amp;page=$3
 Solution 1: use PHP as a universal internal rewrite # Redirect /index.php to / (optional, but recommended) RewriteCond %{THE_REQUEST} ^[A-Z]{3,9}\ /.*index\.php RewriteRule ^index.php/?(.*)$ $1 [R=301,L] # Run everything else but real files through index.php RewriteCond %{REQUEST_FILENAME} !-d RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^(.*)$ index.php/$1?%{QUERY_STRING} [L] # read QUERY_STRING from /index.php # apply your logic, include stuff, etc Solution 2: use a single rewrite (warning: GET vars order must be the same as in your example) RewriteRule ^region=([a-z0-9_]+)&amp;summoner=([a-z0-9_]+)&amp;page=([a-z0-9_]+)$ /$1/$2/$3 [NC,L] 
Agree, I think putting version number for Symfony is a bit unfair, this could be closer: [Trends](http://www.google.com/trends/explore?hl=en-US#q=yii2%2C%20%2Fm%2F09cjcl%2C%20laravel%2C%20%2Fm%2F09t3sp%2C%20%2Fm%2F02qgdkj&amp;date=1%2F2015%2012m&amp;cmpt=q&amp;tz=Etc%2FGMT-5)
Symfony2 is used in a lot of frameworks (Laravel, Drupal...).
&gt; What's the purpose of stopPropagation(false)? it would be the equilent of continuePropagation()
Yes. Empty checks for whether a property exists and whether it is false-ish (null, empty strong, 0, false, etc).
[removed]
Anything that has "Nette" as the 2nd most popular PHP framework should just be thrown out immediately - haha. Someone has been messing with those votes.
Really happy that I unsubscribed. 1. despite all the "interactions" in the list, we got something like PSR-6 out in the wild, and bullshit like PSR-8 (seriously?!). Meanwhile, important stuff (Mike van Riel, PSR-5) is just secondary "interactions". 2. 90% of the "interactions" are around bureaucracy 3. yeah, let's solve bureaucracy by adding more bureaucracy (the mail linked here) ("interactions") 4. most of the member projects seem to just jump in for the sake of jumping in and having some visibility. Are we software designers or attention deficient divas? At least, only 12~24 people will have to put up with this. FWIW: I value what FIG produced in the past. Still, I'd choose something designed by MWOP and reviewed by a few eyes that know what they are doing. Something voted "+1" by a load of people that just want to vote because they can, rather than because they care about the produced code, is a problem. It's not about "like" or "dislike", it's about "it is correct" or "it is wrong". Hopefully, the FIG will keep producing something valuable in future, but at the moment this sort of mail really just makes me anger and go back to my private work, where stuff is reviewed and discussed ON THE CODE. &lt;/rant&gt; 
I'd love to see a native extension for Selenium web driver so I dont have to run a local Selenium server.
I found that annoying too. I never search for "Symfony 2 + problem" it's always just "Symfony + problem"
Why not the `@` sign?
Excuse my ignorance, but what role does php-fig play now-a-days? I've been blessed with composer from the start so I never seen php-fig before.
These guys apparently know nothing about Yii2. 
It's still horrible. It's at least half a year late, there's no x64 PDO driver for Linux and it's buggy as all hell. Check out issue 58 on github / azure / msphpsql issues. This may be a step forward, but I've been along for the ride and it has not been fun, and there's no light at the end of the tunnel.
Ah got it. It's the backbone for allowing us to namespace/import without using `require` everywhere. Thanks for the nugget!
And no way to escape it or turn it off? Yuck.
&gt; I can't really think of a way an AD server can be exploited via PHP LDAP https://www.owasp.org/index.php/LDAP_injection
The [shutup operator](http://php.net/manual/en/language.operators.errorcontrol.php).
Really not a fan of regular elections for the core committee. I like that FIG is giving equal representation to all projects, and having regular elections will turn it into popularity contest, especially since all you have to do to get a vote is to have 5 posts on the mailing list within the entire year (actual number from the proposal). 
That's a great idea. mt_rand() is the better approach.
That's exactly what I was getting at. Annotations (in whatever syntax) are to help programmers and their editors, and only *actual code* impacts the runtime. This is approximately what hacklang does, and the [only things](https://docs.hhvm.com/hack/attributes/special) that are not pure syntactic sugar (per this RFC, where I maintain that parsing docblocks is a more sane approach) are typechecker tools that don't affect runtime. Normal @docblock annotations could have worked just as well. The one exception is `&lt;&lt;__Memoize&gt;&gt;` which DOES affect runtime, and that was the wrong decision IMO.
1. Random in "getting TRUE or FALSE randomly" 2. That is even faster. I will add it to the post
Not only does this RFC fail to cover actually reserving any specific annotations, but it strongly suggests that anything can be used. If that's the case, the only typos that the compiler could catch would be things that are straight-up invalid syntax, and then you're back at square one.
That, plus (at least in theory) solid interop between different implementations of a common task. I think the logger handles this quite well, and the HTTP messages reasonably well so.
I would probably pick jQuery. You?
&gt; The net result is that CC members are, unequivocally, elected as "people", not projects. Which means when admitting a project, we can and should vote on them, unequivocally, as "projects", not people. The answer to "projects or people" is "one of each." :-) This is interesting to me. As a person that just writes a ton of code professionally, the way things are currently operated feels a little exclusive: the impression I've had is that you need to basically lead a large open-source project for your input to count. Unfortunately I don't usually get to choose what part of my work is open-sourced; of what is, it's often as smaller libraries than one more cohesive large project. I also like very much the suggestion about requiring implementations to happen before a draft is finalized. There were some IMO fairly large oversights with PSR7 when it actually came to working with it, so if this change is adopted hopefully that won't happen again.
No
As i sad here: https://www.reddit.com/r/PHP/comments/4fyyk1/best_php_frameworks_in_2016/d2di3eb It's because Nette community is very loyal to this framework. So they are trying to propagate it.
Why no? Everybody loves Laravel. All the other things are downvoted. 
LOL. As if Facebook is a "website". 
&lt;facepalm/&gt;
i don't know. i didn't wrote it, personally i think its a huge security flaw
ah low, I find hard to believe that someone find hard to believe that symfony is slow
Microsoft would ask for license fee for every connected user somehow.
Laravel would be way too slow and not optimized and would probably need 10x the number of servers to run their app. TL;DR: No 
Nice generalisation, totally incorrect. The real reason you're being downvoted is because it's an entirely stupid idea to rewrite *any* application of *any* complexity just to adopt a popular framework. Outside of starting my career at digital agencies, I've used PHP in medical applications, financial applications, HR applications... I could go on. Most of the job specs I see for PHP developers are for similar environments too. So I think you're way off saying "*most PHP developers*" work on "*newspapers, 5 page company websites or blogs*". And nice, I've taken the bait.
Where did you hear that Oauth 1.0 is "more robust"?
This is what I am wondering...
I think [oauth-pecl](https://pecl.php.net/package/oauth) supports 1.0
Strongly agree with Jordi Boggiano's post there. Layers upon layers of bureaucracy only serve to slow down and create barriers to any meaningful progress. These proposed changes (other than the "purpose", which I do like) sound like "we have a group and we want the group to do stuff to seem more like a group, so lets spend all our resources managing a group".
How I'm doing it: I use symfony service container. Recently I wanted to add cache capabilities to my Things. My code use $sc-&gt;get('thing') everywhere. In the container definition I changed the "new Thing" by something equivalent to "new CachedThingProxy(new Thing())" . I didn't change any $sc-&gt;get('thing') but there are now all decorated 
Everyone should just switch to go. Or take a lesson on how go implement its standards...
https://github.com/PHPMessageBus/messagebus/commit/8122e51c1f11859c9022ce553740986c505fdb3c
You're mistaking robustness for complexity. Oauth 1.0 is more complex than Oauth 2.0, but that doesn't mean it offers more. The Oauth standard was simplified greatly in 2.0 when communications were secured via the HTTPS protocol rather than through Oauth itself. Oauth 2.0 doesn't offer more or less than 1.0. If you've successfully implemented Oauth 1.0 on other sites, you don't necessarily need to switch. There are no benefits in doing so. By that same token, it is HIGHLY recommended you at least leverage the HTTPS protocol. In addition to simplifying Oauth, sites with trusted SSL certificates are rewarded with better search engine rankings, and probably a slew of other things I'm leaving out. You're not going to find too many actively maintained packages in assisting you with setting up an Oauth 1.0 server. Just bite the bullet and develop using [Oauth 2.0](http://oauth2.thephpleague.com/) with a self-signed cert, and buy a trusted certificate for a year on your production domain. They're super cheap nowadays.
Google will rank the .ca better if people are looking for a canadian business.
Because 99.9% of people aren't writing the next Facebook. And if you are you start small and upgrade the technology as necessary to scale.
You can try porting some packages over to Zephir. I think it would be a pretty interesting exercise. Regarding debugging, there'll be the extra hassle of making code changes in Zephir, building it, updating your server, then checking the results. Maybe having tests could aleviate this. 
This is exactly what I was thinking. How fast Doctrine and Symfony (or any other heavy framework) would be if ported to Zephir. Maybe creating a PHP to Zephir converter would be a worthwhile project. It would alleviate the need of porting code over from PHP to Zephir
how is it that the node, python, golang and other module ecosystems are all able to flourish without some elite group dictating the interactions/interfaces between modules/frameworks?
I could use one right now! Working with ODBC for the first time recently was painful. 
Lol. You win, oh great sir. 
Because Laravel is a web-tier framework for building "websites". Facebook is a large distributed software system of which you can't even begin to understand the complexities.. 
Laravel will bring peace in the Middle East, so I've heard... 
&lt;snark&gt;leftpad&lt;/snark&gt;
Re-reading what I wrote, looks like my idea is very similar to the PHP compiler Facebook came out with. However, it's performance was worse than HHVM. If Zephir compiled to C can do better and we can have a PHP to zephir converter (which seems easier than PHP to c compilation) it might be good. 
Just because you can, doesn't make you creative or smart for doing so. 
FaceBook is large enough that they can't reasonably position their whole system as a single service, and therefore frameworks like Laravel don't even really apply in the normal sense. FaceBook chat should probably be separate to everything else. The long-term storage is probably best handled as a distinct subsystem. (And IIRC that is actually how they have it set up - they use high-density storage with relatively low throughput for data that's not expected to be accessed often.) Plenty of other things should and probably are split off. Each of these subsystems should choose all relevant pieces to suit their needs. Quite often due to extremely high performance demands, existing library support or other factors PHP wouldn't be a reasonable choice - if you're assigned the task of implementing the publicly-facing load balances that routes you to a worker when accessing the main page you have to care a whole awful lot about performance there since you're getting so many requests per second, and therefore languages and technologies that optimize your response speed - even at the cost of some implementation difficulty or the like - may well be worth it. You'd probably take an existing bit of code that does basically what you want in Java, C or similar and tailor it as best you can. These are things you never need to care about as the average web developer, and things that frameworks can do, but do so making a lot of tradeoffs in the name of ease-of-use. Tradeoffs not worth it to a website that's serving millions of people concurrently at all times.
&gt;HHVM is nice. However, benchmarks revealed it's still slower than compiled C extensions (by a lot). Well that's pretty much impossible to beat short of modifying the language so much as to be a proper compiled language with few runtime systems like. That, or just replace HHVM with the JVM and make PHP basically just Java - Java's pretty quick. 
Nope annotations in comments/docblocks are abominations. Comments should never affect the execution of code, what Symfony and Doctrine are doing with Annotations are plainly wrong. The Native support for Annotations will solve this problem perfectly, although I do agree annotations can be easily abused. It is a controversial feature after all, and must be used sparingly. 
I agree with you. It uses a few array functions of illuminate/support but it's better to have these methods included in the package itself
&gt; Well, actually I'm mocking up Laravel parrots. I don't understan why I'm being downvoted http://i.imgur.com/spq0v68.jpg
&gt;If you are dealing with data that requires extended validation certificates you are still required to use one of the traditional vendors. Please stop perpetuating this myth. There is no "data that requires extended validation certificates". EV is a marketing exercise. Any CA pushing the "if you have ecommerce, you have to get EV" argument just wants a sale out of people.
You claimed Symfony2 solves this for PHP templates which is not the case and: - This was made clear in the link I provided. Right below the "escaping with twig" there's the "escaping with php" section which clearly shows the distinction between secure by default and insecure by default - I expect a php developer of "many many years" to understand that echo, concatenation and interpolation cannot be made secure by default. Now if you wanted to argue that it can be mitigated through QA then go ahead and do that, but insisting that the problem doesn't exist or that it was solved already is simply unreasonable. Once again, the problem is not escaping, it's escaping by default. Something some of us expect a "fine templating engine" to do. Like [this one](https://github.com/rails/rails/blob/master/actionview%2Flib%2Faction_view%2Fhelpers%2Foutput_safety_helper.rb#L16) Also disdain and anger are two different things. As far as I'm concerned, your ignorance was clear when you dismissed templating, something most of the community has adopted, as completely unnecessary. A claim like that would make you the genius who figured out what not even Fabien Potencier, author of twig, could. Smart enough to write one of the most popular frameworks, but too dumb to understand that PHP is already a "fine templating engine". amirite I'm not debating this for your culture, but for other developers who would otherwise read your ignorant absolutisms and accept them as things you've learned over a long career. 
There is, it just needed &lt;nowiki/&gt; tags wrapped around it (which I've added).
But [MediaWiki](https://www.mediawiki.org/wiki/MediaWiki) and WordPress should be definitely refactored to Laravel, right?
&gt; which made omitting HTTPS a viable option I have a vague memory of that extra security step in OAuth 1 now being considered broken (because doing your own crpyto is hard), but can't find the link (sorry).
Call me all the names you wish. Its not going to change the fact that the frameworks I use daily include output escaping by default with pure PHP and no "templating engine". You seem to be overlooking the fact that he was the one that wrote the Symfony 1.x output escaping. No "templating engine" needed. Fabpot isnt the messiah you think he is, and in fact has made more than a few questionable decisions when designing Symfony over its years. But in general, hes a good bloke and hes done good work. My "ignorant absolutisms" are nothing of the sort. There is just a way I like to do things, and here you are saying its wrong and your way is the right way. Im happy to say Ive never worked with developers that think that way, and hope I never do, it sounds awful.
&gt; he frameworks I use daily include output escaping by default with pure PHP Source? &gt; Fabpot isnt the messiah you think he is He's fallible. We all are. Not an argument. &gt; My "ignorant absolutisms" are nothing of the sort You literally said that template engine users are adopting a solution where a problem doesn't exist. You didn't say they prefer a different way of solving a problem. You said it doesn't exist. You were welcome to take that back at any point during this exchange. &gt; saying its wrong and your way is the right way Quote me when I said that.
because Python handled it with official PEPs (which are for language changes, coding style, standard interfaces, and the stdlib) from the python folks themselves, and Go started the community off right with stuff like goftmt which is widely accepted in that community. Us php folks have to bolt all this on after the fact. It's my personal opinion that the internals community has abdicated their responsbility to the php community by not caring to even try to create sane interfaces for dealing with HTTP messages and other things, such as common coding standard tooling like gofmt. It's a major reason I've done less PHP recently (I started with PHP right before PHP 4 came out). If it weren't for Composer and FIG, I'd already be gone. EDIT: I'm not necessarily in agreement with the proposal for FIG 3.0, just about FIG in general before this
I've been doing php since before php 4 came out (both for FOSS and non-FOSS), and that's hardly ever been the case until FIG and Composer. EDIT: I'm not necessarily in agreement with the proposal for FIG 3.0, just about FIG in general before this
for anybody interested in background of how that came to be, you should read about the Berne Convention https://en.wikipedia.org/wiki/Berne_Convention
&gt; They're super cheap nowadays. [Let's Encrypt](https://letsencrypt.org). There is no excuse.
Not just wrong, reckless. I sourced my claim with Symfony2's documentation. You base your security on dogma.
Look up the --link-dest option to rsync. Rsync saves you network traffic by deploying only deltas and --link-dest saves disk by hardlinking files from the previous build. 
Pretty sure anyone who posted there works in an enterprise environment, probably paying some chunk of change for licenses. But yeah I hate that everyone does a spiel before they get to the point.
If you're using Symfony you could inject them into your controller/service/.. instead services: app.test_repository: class: AppBundle\Repository\TestRepository factory: ["@doctrine", getRepository] arguments: - AppBundle:Test app.test_controller: class: AppBundle\Controller\TestController arguments: - '@app.test_repository' Which you could use in your controller like this: &lt;?php namespace AppBundle\Controller; use AppBundle\Repository\TestRepository; class TestController { private $repo; public function __construct(TestRepository $repo) { $this-&gt;repo = $repo; } }
EV cert can give you greenbar on adress bar while normal (domain control validation / normal) one just lock icon cmiiw
this could be interesting :)
You probably need to use the [`allow_redirects`](http://docs.guzzlephp.org/en/latest/request-options.html#allow-redirects) option to disable following redirects. Then the response should contain the `Location` header you're looking for.
Short but interesting message. Thanks
Looks interesting, the name could be confused with dingo/api though 
Just because something is not performant and has difficulty scaling, doesn't mean it's not for "professional developers", a professional developer should use the right tool for the right job, and for small/medium web-applications Laravel is not a bad choice.
From a security/crypto standpoint: none. Apart from some metadata in the cert itself, the only real technical difference is that CAs which are allowed to issue EV certs are hardcoded in the browsers. You can't self-sign an EV cert, import it in the browser and make it look like an EV cert - unless you patch the browser. If the additional required identity validation is really worth something is debatable - I think it's most probably not, and CAs also have different validation levels below EV as well, so it's not black &amp; white anyway. From a user experience standpoint: compare reddit.com and e.g. paypal.com. On paypal (which has a EV cert) the browser displays the company name, whereas on reddit, it does not. From a cynical standpoint: EV certs were invented because certs got cheaper and cheaper over the years and certificate authorities needed a way to rip off customers again. I think that's the only plausible reason there are EV certs. 
Actually, it's useful in the first scenario. I just had to make up some extra places where it would be useful. Hence I added the other two. Yeah, **array_rand** is better in that cases. Yes, it was made to be useful for aspiring programmers. I have updated the article
There is output when I set **allow_redirects** to **FALSE** &gt; [pastebin](http://pastebin.com/raw/D1usEveN)
That might be an older guzzle setting?
LOLWAT?
I think same when a parrot suggests Laravel for building web apps (not web sites).
That thread is about writing a new project. &gt; The real reason you're being downvoted is because it's an entirely stupid idea to rewrite any application of any complexity just to adopt a popular framework. 1/10 - would not read again. Poor Trolling.
Take a look at JWT for authenticating your API as well while you're doing your research. There are a ton of great libraries available, it's just as secure, and fairly easier to implement.
No. I never had any need for a gallery. Did you try the plugins? https://github.com/picocms/Pico/wiki/Pico-Plugins 
Like the idea of this. Check out the collection library i made: Source: https://github.com/DusanKasan/Knapsack Docs: https://dusankasan.github.io/Knapsack/ 
Next: Should Google be rewritten in Laravel? *I mean, it's a simple search page. Right?*
In the latest release, illuminate/support dependency has been removed from Crunz.
I'll point this threat when someone suggests Laravel.
any suggestions for a framework to test with this? Slim possibly ?
Slim would be nice. It is very small and not that many files. If you can do Slim3, we can benchmark PHP7 vs Zephir compiled Slim. I was looking at some benchmarks and PHP7 vs HHVM have almost the same performance (HHVM is marginally better). So PHP7 VS compiled Slim will be an interesting benchmark.
Looks good - has many of the hallmarks of why I personally dislike Laravel ... but please for the life of god add docblocks to the controllers :)
I know you're just trolling but there are actual reasons for everyone saying no. First of all its usually a bad idea to rewrite your app. The better question would be "If facebook was started today, would laravel be a bad choice as a PHP framework?" The answer to that is no. Just as Symphony wouldn't be a bad choice either. But when you hit a BILLION users you find performance problems in things no one has before. You are the top 0.000001% of web apps so you have to optimize every little thing in your stack, including your framework. 
Lmfao 
Next up: resize any image in PHP using width="" and height="" ! /s
Will this work for images I upload to my own webserver?! /sarcasm
I don't use Symfony so I can't speak to it. But in my (admittedly limited) experience with Doctrine, I don't think what you are saying is _quite_ right. As best I can tell, the mapping information in the annotation is used by Doctrine to generate real PHP ahead of time (proxies, mappers, migrations etc), and it is that real PHP code which is executed. I don't think in production the annotations are referred to at all. In that respect, these are not really any different to docblocks being used to generate API documentation ahead of time. They are essentially used by another program to build something else. I agree that annotations that impact program flow are bothersome, but I don't _think_ that's the case here.
https://github.com/gabrielrcouto/php-terminal-gameboy-emulator
Stupidest thing I've read this week. Easy.
I'll try to put DocBlockr in my next release. :)
Thanks :)
This threat has only 6% upvotes (I have an upvote!). Also, many others here have said that Laravel is not suitable for big apps. I know that Laravel is successful in building web sites but people find it funny when used in serious apps.
Yes, definitely work, if you have any doubt you may use it on your live server. thanks please give feedback after trying it.
if you will use width and height then image will not look good if your image size in large then normal and this will also reduce the size of image. try it once. thanks
it is different from ERM... you try it and please give feedback for its improvement. thanks
[The real problem there is fashion](https://www.youtube.com/watch?v=xXWGXkHsakg&amp;feature=youtu.be&amp;t=203).
Like what? And why? 
Maybe [Sentinel](https://cartalyst.com/manual/sentinel/2.0) is a solution for you
I'm little bit surprised with such negative feedback, but I have to agree with that in some cases. First of all example usage given in RFC is not so great. Attributes should be metainformation and should not be intended to affect execution of functions - but it doesn't mean that it's something wrong. For example when developing my syntax highlighting library I've got to store meta information (i.e. mime types associated with language) related to class in methods, with only one return statement. Methods that do nothing, for actual class use case. I would really like to write it like &lt;&lt;mime('text/x-php', 'application/x-php')&gt;&gt; it'd be obvious, clean and correct in semantic sense. Another use case is for XML serialization &lt;&lt;XmlTag('tag')&gt;&gt;. And remember it's not possible to do with actual methods (excluding docblock parsing), because on class context you can just add method, but what about properties/methods? 
Bit harsh. Exchange plugin with library and everything makes perfect sense.
http://ulogin.sourceforge.net/ http://ptejada.com/projects/uFlex
Looks nice, except there is very strong coupling. 
Jumped straight to comments, I thought somebody had implemented a trello clone using dingo/api.
[removed]
Okay since you don't know what /s or /sarcasm means here goes: 1) This uses WordPress.com servers, by using this you're eating away their bandwidth and CPU-power. 2) This is hotlinking, a big no-no for most people since the domain where the image is actually hosted can at any time change the picture to whatever they want. 2.1) wp.com can see all the pictures you resize through this service. 2.2) wp.com can track all the people on your website looking at this picture 3) This is not using PHP at ALL. not even one line. 4) There are PLENTY of ways to do this PHP yourself without using a third party such as WordPress (wp.com). So this is a pretty horrible way to resize your photo's.
Are you the author? Couple of issues: * Is the tool used nGork or nGrok? Several typos either way. * I don't like the `php.ini` fix to prevent notices and warnings. The developer should be using `isset()` instead. 
Great, thanks. I think these could use some `isset()` as well, and they seem to have given rise to the notices: $sender = $input['entry'][0]['messaging'][0]['sender']['id']; $message = $input['entry'][0]['messaging'][0]['message']['text']; 
There's plenty of other threads on this. 
Yes I know that you are the creator of Laravel. But I find it ironic that you are replying to an average programmer like me. I don't know about what service you are talking and I have no idea about how powerful are your servers are or how much you have hacked Laravel to build those web apps but no one thinks that Laravel will be suitable for web app like [this](http://symfony.com/blog/one-api-to-rule-all-product-data) one. May be we can see a blog post of a big company using a heavy loaded app. Last time I have checked Laravel didn't even support the delete HTTP method, it required a hack. Laravel has no build in REST API documenter. And some people argue that Laravel saves time for every case. In this case I would need to hack delete method first, then integrate an external REST API documenter (Why I don't use Apigility or Restler PHP in first place!). And probably other lots of hacks because now users have increased and Laravel feels like a turtle. Oh, how to solve this simple problem when it is very simple when not dependent in Laravel, you stuck for hours? And why people find it funny that Facebook, Wikipedia, Google, Wordpress be written with Laravel? Because Laravel is replacement for CodeIgniter. And both CodeIgniter and Laravel are for building simple web sites in short time. Not for heavy traffic complicated enterprise applications.
The only problem with annotations in java is that they may be overused. Pretty the same problem could be with any language feature. For example PHP devs very like to use static variables/methods just because they can. Or arrow-function expressions in javascript, devs like to use them as simple functions since there is no clear distinguish in head what is function and what is functional expression. But annotations are very useful. Just look at python's decorators. This should be declarative way to add some behaviour around stuff. Or add some metaprogramming (for DbC for example).
A few questions... 1. Why are you hardcoding JSON? Just do an array and JSON encode it. It makes your code much more cleaner. And if you're really into hardcoding it, at least use sprintf. Makes your code cleaner... 2. Why are you reassigning variables of the same value to other names? 3. Why such massive arrays...
Just because you have a hammer doesn't mean every problem is a nail.
Your Page Subscription example is wrong - you wrote "$my_token" instead of "$verfiy_token". 
Facebook is not a small/medium web-application.
lol
I would highly suggest using something like Laravel because they have this built right in. other frameworks would have this too. But the base app laravel lets you start with has this.
Just speaking the truth. Event broadcasting, built in asset compilation, built in queues, more thorough dependency injection automated out of the box. Middleware out of the box. Command bus out of the box. 
Ok, so an abstract example. Given an interface: interface FooBarInterface { public function makeFooBar($input); } You may need to split the implementation across multiple classes. Maybe it’s something like a monolog processor — each one does it’s thing and moves on. To simplify the usage, you create a chain implementation so the classes using `FooBarInterface` knows nothing about the details: class ChainFooBar implements FooBarInterface { private $collection = []; public function addFooBar($name, $fooBar) { $this-&gt;collection[$name] = $fooBar; } public function makeFooBar($input) { foreach ($this-&gt;collection as $fooBar) { $fooBar-&gt;makeFooBar($input); } } } So far so good. So now you just need to wire every implementations together using the container. As long as you have a fixed number of implementations you may just use `calls`: foo_bar.chain: class: ChainFooBar calls: - ['addFooBar', [ 'alpha', '@foo_bar.alpha' ] ] - ['addFooBar', [ 'bravo', '@foo_bar.bravo' ] ] But this gets messy and there is no easy way to add more implementations, especially if you’re only making a library / architecture and it’s up to the developer to make the implementations. This is where `nassau.registry` comes into play. Instead of manually connecting the implementations to the chain, you register a tag, so any service can hook itself up: foo_bar.chain: class: ChainFooBar tags: - name: nassau.registry tag: foo_bar method: addFooBar order: indexed class: FooBarInterface foo_bar.alpha: class: FooBarAlpha tags: - name: foo_bar alias: alpha Does this make more sense? &gt; no clear dependencies from looking at services that use this registry with whatever is inside it, That’s right, but as I said it works best in situations where the implementations would be decoupled anyway. Thanks for the feedback, I’ll be working on more extensive description and maybe some examples. In short this could replace 9 out of 10 usages of `ContainerBuilder::findTaggedServiceIds`.
It is a server as well, the [OauthProvider](http://php.net/manual/en/class.oauthprovider.php) gives you that. Not very well document though.
Or a library.
You stated: &gt; has many of the hallmarks of why I personally dislike Laravel Do you expect me to go through your Reddit history? I was just asking what those hallmarks are and why you dislike them. How should I guess from other peoples discussions what you personally dislike about how OP uses Laravel in this project? If you state something like this, why not elaborate at least a little. Otherwise just don't say it because it doesn't contribute at all.
It runs as a pool of processes managed by the PHP-PM daemon. Sure memory leaks are an issue, but the process manager itself kills and spawns new ones. It's far from being for everybody, for sure - but at least the lead developer is dogfooding it: https://twitter.com/MarcJSchmidt/status/723480541572554753
Why would you want to store shopping card id? Store the shopping list in the browser in Web storage, IndexedDB, Web SQL Database.
Sounds more than interesting. Anyone did BM with Laravel 5.2, PHP 7, and PHP-PM? Compared to Laravel pre 5.0, PHP 5, and PHP-FPM the performance improving should be amazing....
&gt; [edit] also, 15x speedup against php-fpm is too good to be true. Is it set up properly, is session handler made nonblocking, is apc/opcache on, etc, etc...? That seems like a realistic speedup. Assuming your services are fairly stateless, you can pretty much skip most of the work done by your autoloader/service-container/etc. Tried it with ZF2 + React's HTTP server 2 years ago and it was speeding up the app almost tenfold, [without any specific optimizations](https://github.com/Ocramius/OcraHopHop). AFAIK, PHP-PM works with any PSR-7 compliant middleware now, which makes it very promising for all coming supporting libs :D
There you go: https://github.com/mattstauffer/Torch
Idea is similar to Plag: https://play.google.com/store/apps/details?id=io.plague . I used it in the past, but it got boring over time.
&gt; I think Laravel is for web sites like newspapers, for 5 page company web site, or for a blog Lol..... How many websites have you *actually* built in your life?
A cart is really just an incomplete order. I prefer not to replicate redundant structures (eg. cart products and order products would be the same). Anyway, IIRC, I check for the user's cart (order) in session. If it doesn't exist, it will also check a cookie (which would survive the user closing their browser and returning to the site later). If neither if those exists, it will create a new cart, register it in the session and create a cookie. The next step is to associate the cart (order) to the user if and when the user logs in. So the initial visit to the site will write a cart to the session and a cookie, but all subsequent requests will just check the session to return the cart. Or a return visit after closing the browser won't find the session, but find the cookie and register it back into the session. Hope this helps. Edit: You also mentioned insecurities around storing data in cookies. You absolutely need to encrypt data stored in cookies and sessions.
but you're not actually using it in production anywhere are you?
&gt; Does the app itself listens to a port and processes multiple requests without exit()ing? yes &gt; What about memory leaks/GC? Package developers were never concerned about memory leaks because of single request-response lifecycle. that is one of the major concerns, yes.
Then why are you here?
Dozens.
Here's my raw symfony3 skeleton (optimized for API's development): https://github.com/intellectsoft-uk/symfony-skeleton It has: - Symfony3 - Doctrine 2.5 - PostgreSQL 9.4 - Nginx - PHP-FPM I would like to improve it if someone has any ideas. Currently I planning to add build and deploy scripts, and add more example of how to use it (like how to use CRON, how to write rabbitmq consumers and so on). Also instead of jms serializer i want to use fractal + symfony serializer. Hope it would be useful to anyone.
As I understand it, in PHP-FPM the process still needs to execute your entire app. In PHP-PM you bootstrap your application (connect to databases load some classes, get everything ready) and then wait for the request to come along. The request gets a head start in that when it's served the application is already bootstrapped.
Which bits? What would you prefer? How is that relevant to this particular thread?
I did I'm not sure how to use it because I didn't compile Pico with the Komposer. I tried following the directions without it but it didn't work. There's no way for my to embed JavaScript in my markdown. It's not being recognized.
I used it in one of our internal systems for about 3-4 month with silex. It was pretty good, I just respawning workers every hour to not worry about memory leaks. Currently I use ayres for my home projects, and it also pretty good.
Has anybody found a best practice yet of linking bot users to users of your app? The bot scope seems not to allow getting the users email address, i am unsure if thars intended and how to deal with it
It's important to set a company code standard and stick to it. We do PSR-2 with some additions for things that PSR-2 doesn't cover, like never nesting blocks more than 3 levels.
Facebook Apps does allow you to get emails so you may get it by using them once they connect with it. Bots are not for this purpose.
of course if it is existing you can't just drop Laravel in. But as /u/gentuer said..you'll probably have to create your own solution.
From their own docs: &gt; Memory leaks, memory leaks and memory leaks. You will also find leaks in your application. :) But no big issue since workers restart automatically. If it dies during a request, that kinda does sound like a big deal. &gt; 15x speedup against php-fpm is too good to be true. It is. It's not a fair comparison. It doesn't even make sense to compare them. They're not the same tool, and you can't run the same code on both of them to do the comparisons with!
Assuming it left a large enough buffer for the last request after the shutdown trigger was hit. Some others were saying it's still problematic.
I can't imagine it getting steam, as you need your users to be in the same location and using the same app at the same time to do this. I can imagine people thinking it's a cool idea, downloading the app, then realizing that there's not really anybody else at that place at the moment that's on, so they close the app and never open it again
[AstroSplash](http://astrosplash.com) has been running as a PHPFastCGI app using the [Zend Expressive adapter](https://github.com/PHPFastCGI/ExpressiveAdapter) that /u/ocramius mentioned since the start of this year without issue. There was a fourfold performance increase with about 20 minutes work - **but** - it is quite a simple app and I designed it knowing that I might want to do that with it.
There are some instructions for getting it running outside of Laravel in the official repo: https://github.com/illuminate/database you usually don't need to pull in a third party package, although there are packages that will make it available as a static proxy/facade.
Thanks for writing that out! 
[removed]
You are absolutely correct. It is taught as **Forest** vs **Single tree** approach in CS classes. If it's possible to have multiple trees instead of one large tree, multiple trees is always preferred for better insert performance.
&gt; Well, no.. They really don't Yes. They do. Delete the doc comments, and let Doctrine/Symfony "recompile" - what happens? 
trying to hard, you are.
Sure. I work in a company were we dispatch technicians for jobs... The cell coverage in certain areas of our territory mean that our techs will not get a stable enough signal to actually complete their job [ which involves proof of work ie multiple high-res photos to be uploaded ]. Sending a 2 MB photo with SSL doesn't work over a shitty cell connection.... I know its an edge case, but it's one that I deal with constantly at work. 0.0000001% :)
I designed a nested set system for a web app that uses wildcard dns for subdomains. Each subdomain or node falls in the nested set somewhere and can be moved. Admins on any given node can also admin any child nodes but no parent or sibling nodes. Rather than use "root" my main branches are divided by "domain". So I can have a rather lengthy tree system for domainA.com and also for domainB.com. Each root node starts with left 1. Adding a node to the far left of domainA.com doesn't even touch domainB.com.
There is still a reason to use SQL such as relational integrity and transactional processing. If you combine it with postgres, you also get built-in recursion ability. 
Downside is you have to now maintain both the function and the comment describing it.
Your article describes a solution to a problem I run in to montly in multiple projects. So I think it's relevant to me as a PHP developer! THNX
Ah, but it seems the subdomains in this case are hardcoded in code. What I mean is that I can easily move Sprites to top level and it will get its own rootId. from the user point of view it will all look like a single category tree (not divided into subtrees)
&gt; It may interest you to know that the parser doesn't consider them to be "just comments". Docblock comments are a special case, with their own token and readable by the reflection API - precisely so that things can read the docblocks and generate other things (like documentation or generated code) ahead of time by parsing them ;) Well it doesnt matter what Symfony's parser consider them to be. From the language PHP's point of view, docblock comments are comments. I can write my own parser that parses inline comments too, so this means my inline comments are not just comments anymore, but also code? And as phpdevster said, Symfony/Doctrine's docblock annotations do affect code, as your application will stop working if you edit or remove the docblock comments. This is what I've been pointing out again and again in the past replies, that comments should not affect code. If you edit or remove comments, your website should not break down, docblock annotations make this impossible. 
And this will completely destroy foreign characters, turning Japanese into "" and German names into half of what they were before. Maybe one shouldn't do that...
&gt; (under the Proactively Secure Long-Term User Authentication heading) You can link to that by adding #title.2.1 to the link. (I wrote that in RST and that's how the RST parser I used creates anchors. I haven't had a chance to convert it to Markdown.) &gt; Is implementing the same type of structure for storing and retrieving shopping cart data overkill? Yes, it's overkill for that use case. The threat model for a persistent authentication cookie includes things like brute force resistance and minimizing the usefulness of timing side-channels. For resurrecting an abandoned shopping cart if the user's browser is closed, there's not much an attacker gains by guessing someone's cart configuration.
&gt; Well it doesnt matter what Symfony's parser consider them to be. From the language PHP's point of view, docblock comments are comments. The PHP Parser treats doc comments differently to comments. They are different tokens. http://php.net/manual/en/tokens.php T_COMMENT and T_DOC_COMMENT are listed. One is exposed through the PHP reflection api http://php.net/manual/en/reflectionclass.getdoccomment.php ... and the other is not. &gt; And as phpdevster said, Symfony/Doctrine's docblock annotations do affect code, as your application will stop working if you edit or remove the docblock comments. As I understand it, only *if* you regenerate the code that depended upon the annotations in the first place. If the entity metadata is cached, proxies are not regenerated and migrations are not re-run, the code will carry on working as normal. 
&gt; I can't imagine it getting steam, as you need your users to be in the same location and using the same app at the same time to do this. No? They can leave a message at any time anywhere, and people will be able to see the message from any place if they happen to be watching. You can try this for yourself. Open it up in two windows, and leave a message in one while zoomed out in the other.
I would have a Factory/DecoratingStrategy class with method like decorate() that would get the base undecorated object and return the decorated one you mostly use. I'm not sure i understand the singleton approach here. 
Depends on region and CV.
Let's say US vs. Canada vs. UK vs. India. 
I agree with you to an extent, but I don't think you know what "strongly coupled" actually is. Your post history brings it up several times, but you never cite any specific examples. Go ahead and explain what "strongly coupled" means, and why these libraries are an example of strong coupling.
Imagine you have several pages who all have their own markup and scripts. Do you prefer to load all css/javacsript on every page? or do you create some system to only load the css/js that you need? My thoughts: It's a lot easier to not have to manage scripts. That combined with minification / gzip compression, it shouldn't be that much of a problem. Also, it'll make the switching between pages quicker because there's less to load (assuming the browser cached the scripts) Of course on the other and, it does make sense to not load stuff the user doesn't actually need for the user experience. 
I guess but id rather is a framework that has either one built in in conventions for having one built in a moment or two instead of building my own insecure thing.
So I assume contracting. It all depends how long your contracts are I guess. In the UK they go by the day. Rates start at £250 a day and go up to £700 (in london). On average for your standard good senior developer (know SOLID etc) about £450 or so is reasonable in say Manchester. I would expect £550 or so in London for the same person.
Currently, the best thing for performance is to minimise the number of HTTP requests. That means combining all CSS into one file, and same with JS. If the total file size is less than 100kb it's a no-brainer to smush it all into one. But if you have some larger files that are only loaded on a few pages, those should be kept separate to avoid loading them when not necessary. It also means you can update that larger file and the "global" one can stay cached. I always aim for max 2 CSS and 2 JS files per page (one global, one for the page/section). **However**, this will not be best practice for much longer because HTTP2 solves the problem of many HTTP requests, so you can put however many CSS/JS files you like. If your server is using HTTP2 I say fuhgeddaboudit.
In the UK shoot for a minimum of £50 an hour, know more than one style of programming, listen, push-back A Reasonable rate for short-run projects is £100+ an hour, but you probably won't book out 40 hours at £100+ without a lot of hours, a great connection pool and some support staff (which means it's not £100 an hour). 
That is indeed correct.
&gt; Businesses are willing to pay for this when you can show them that you'll make them hundreds of thousands in additional profit. I'd argue this is more of a business owner thing to pitch, it's even disingenuous for most consulting contractors... I don't think your average developer gets enough control to influence profit, which is why I stick to revenue IF I have any control over that at all. Using the logic, unless you let me run the company, how can I control enough areas to influence profitability? Building a mission critical business app, you might actually decrease profit, but lower liability likelihood or impact, delivering ROI on a risk-management basis might not always translate immediately, it could be a long-term benefit, or a non-fiscal benefit. &gt; If you're talking about a salaried employee, not a freelancer, it depends a lot on region. An average big city, anywhere from 80k to 140k is probably the average for a "senior" developer. I'd love to see where that job is! I'm from the UK, so perhaps our numbers look lower because the £ is valued at greater than a single dollar; but I'd be interested to see how 100k translates in quality of life, and hours. ($140k USD is just shy of £100k) I think it might be a burn-out shop, or like you said short-term projects (which doesn't mean 100k+ per annum, it's just playing with numbers). I can't imagine it being sustainable for a single business or the worker in a strictly development role, perhaps an architect, or senior management, or a department head could argue for 100k+, but not a boots-on-ground developer (I want to be wrong on this, please post examples as I've yet to see one that translated once you worked out the small-print)...
Sorry, I misunderstood, I thought you were talking about retrieving the objects *being* decorated, as opposed to conveniently applying a series of decorations.
Assuming you want to find out how much you are worth, the easiest way to do this is to go on Linkedin, contact a few recruiters, hand in your CV, and tell them you are interested in PHP jobs. They will call you and you will have the option of discussing your salary range. They don't really have an incentive to stifle you, because their payment depends on yours (they get a percentage of your salary, usually), and if you find out a month later that you have been lowballed hard, and switch jobs, they don't get the money (again, depends on their contract, but they usually get paid after the probation period is over). If you absolutely have no clue how much you are worth, you can just ask them what they think would be a reasonable salary range for your skills.
idk I was recently selling myself for $40/hr USD ...
I'm not naive enough to think that you mean 40 hours/week, so approximately how many hours are you working in a year?
Thanks! Your post should be the first thing visitors read on the original site. &gt; to clean the memory [..] shouldn't it be the developer responsibility? In C, it should. In managed langs we have a GC and trade performance and stop-the-world stalls for automatic memory cleanup.
Mapping distinct trees into a nested set structure is [not a new idea](https://github.com/pear/DB_NestedSet/blob/tags/start/NestedSet.php#L739). The reason why you might not have yet heard of it is that it's just noise for explaining the nested set mapping.
So what this vote is - is to enter it into the FIG for work. Basically "Should we make a PSR for _thing_?" This proposal can be considered the first draft, of which there will be many more.
Depends on who you work for. You'll get the best rates working for clients in the USA, Germany, and UK, based on my experience, even for long term contracts. But I'd say a range of $60 - $120 for a remote senior PHP engineer is realistic.
Try some crowd source sites like https://www.glassdoor.com/Salaries/index.htm where you can plugin where you live and search near by (like a major city if you arent already living in one)
80-120 phr in NZ
In the city you can make something like 200k, out in the tri state area you might only hope to make 3/4 of that due to the cost of living difference.
If you expect most visitors to visit most pages (or otherwise cover most of the CSS/JS) and you have a vaguely sane amount of CSS/JS just concatenate all of it and it shouldn't be a huge issue, and it's easier to manage. If not, just use templating that'll let you add resources to header on a page-by-page basis. 
IIRC the [DoctrineExtensions](https://github.com/Atlantic18/DoctrineExtensions) nested set implementation has supported multiple trees for years.
Well, that is not my 100% accurate calculated effective hourly. As in I didn't actually look at 2015 and add up all my hours. But in general, I do only work 40 hours. I'm also lucky enough to work at a place that pays for any billable time over 40. But we are a time and materials company that does work for clients. They put it in as an incentive. Anyway, I don't know the exact amount of hours but it's probably not much more than 40/week. I know I had a few that went over. But I also had a few under.
really good article
Honestly, using a well known framework is a good idea because it's been tested and it will PROBABLY have less security issues than your code will. That's assuming you follow best practices because a framework won't stop all of your problems. What are you wanting your site to do? If your site is just straight html with no real functionality, do you really need to use php at all?
In the FIG 3.0 proposal we introduce an abandoned state which will provide a way to, in practice, get rid of PSR-8.
It seems like most of these questions are asking things that are *completely irrelevant* one's ability to write good code. In my 12+ years writing PHP I've never needed to know when PDO was added, who founded PHP, or how `0x33` would be interpreted. If I was given this quiz as part of my job application I would immediately look elsewhere, because whoever wrote it is either a manager who hasn't touched code in years or a cowboy coder who prides himself on his *highly advanced* homegrown autoloader and writes 2000-line god classes.
I think the harshness is a byproduct of having to deal with the consequences of PHP's low barrier of entry. Experienced PHP developers have seen *a lot* of awful code. *A lot.* We can be a bit jaded and fail to recognize the difference between a someone who needs to learn and a "professional" who will be writing horrifying exploit-riddled code for the next decade.
Yeah it's almost entirely html. Just a personal website to serve mod downloads for a game. I did this mostly for fun/learning, but also it helps a bit with keeping content updated.
The idea of this proposal is to solve exactly these issues but you cannot fix problems by simply ignoring them. The idea of this proposal is to solve a load of issues that are currently preventing PSRs from being introduced so that people can focus on PSRs content instead of discussing process issues. WGs [Working Groups] are where the PSRs are formed, and no process discussions would ever occur there. Then the PSR gets a stamp of approval from the Core Committee who handle PSRs from a code POV but also have a say in how the FIG is run. Then the member projects can participate as much or as little as they would like in process issues like membership votes (other drama that currently dominates the mailing list should decrease with the new system and secretaries) or joining WGs to work on PSRs (which is ultimately what we care about). "I'd choose something designed by MWOP and reviewed by a few eyes that know what they are doing. Something voted "+1" by a load of people that just want to vote because they can, rather than because they care about the produced code, is a problem. It's not about "like" or "dislike", it's about "it is correct" or "it is wrong"." &lt;- This is exactly why we are shifting to the WG (filled with intelligent people with experience in the problem space and nobody else) voting on a proposal, then a final panel of wider intelligent folks like Matthew for example whose job it is to ensure the WG has accurate representation, has essentially had appropriate intelligent people working on it and the spec is well prepared, not the technical detail. "Hopefully, the FIG will keep producing something valuable in future" this is our common (and the ultimate) goal, and the idea of these changes to to make a step towards making sure this happens.
Unfortunately it seems there's no way to do a seamless integration, just due to the way Illuminate packages are written. However, I found a blog post on someone who uses the phinx migration manager coupled with Eloquent -- the cli is phinx, but it uses Eloquent's query builder. I'm still figuring out some details, mostly working with multiple connections, and you do have to setup a config file for Eloquent and one for Phinx, but overall I think it's the best of both worlds -- the flexibility of phinx and the speed of development from Eloquent. This is a marked improvement from when I always had to lookup the phinx docs separately to match the syntax for their schema builder.
Reading through the comments, it seems your view on software and/or "web apps" is a bit limited; your question is almost unanswerable in it's current form. For example: * Which part of the Facebook ecosystem are you even referring to? Decisions made about a "heavy traffic complicated enterprise application", as you so elegantly put it, **scale FAR beyond what web framework the thing is built on.** There is not a single framework, written in any language, that would even scratch the surface of accommodating the business needs of an application like Facebook out-of-the-box. I mean, I assume you're aware that Facebook developed an entire programming language (Hack) AND execution engine (HHVM) to accommodate their needs? If you are at all familiar with software at this scale, you should know that this is just a silly question. 
In Adelaide, Australia it is roughly $50 per hour salary but you are charged out at at $110-$150 per hour. Contractors should be charging out at the $100 mark per hour. This is for Senior devs of course. (less experienced charge less)
Lol you're a fucking idiot. Please stop making yourself look dumber and dumber. And Taylor just rekt you below. Eat shit. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I don't bother for private methods unless it's non-obvious. Normally I'm the only one he's going to maintain that method and if someone else is trying to call into it, they're doing something wrong. That said, you have to consider future-you too. Is the function name sufficient or not? Are there any funny edge cases? Document those.
The same "PID wrap bug" in OpenSSL (I believe) caused issues in Android and Ruby a few years back. After the Android and Ruby events I removed openssl_random_pseudo_bytes() calls from my projects, as it indeed seemed too dubious source for secure randomness. Same kind of "fork magic protection" in PHP-FPM (or equivalent environments), as used in Ruby, would help to mitigate the problem at least to some degree, but on the other hand, just don't use openssl_random_pseudo_bytes and call it a day.
Trello: The place where ideas go to die. I hope the design, search features, boards, etc. are improved over Trello, because Trello is utterly terrible and annoying to use.
Backwards compatibility break is a big deal with php. But I guess it is ok as long is it is not documented! Lol..
Learn about programming in general to better understand the concepts and don't lock yourself in one language/framework. Check out these screencasts: * https://sites.google.com/site/unclebobconsultingllc/ * https://www.destroyallsoftware.com/screencasts And these books: * http://www.amazon.com/Code-Complete-Practical-Handbook-Construction/dp/0735619670 * http://www.amazon.com/Design-Patterns-Elements-Reusable-Object-Oriented-ebook/dp/B000SEIBB8 That should be a good start. The screencasts and books above are very good at explaining and feel easy to read/listen to. While saying that, you should probably still keep learning Laravel, as you have some experience with it already and use the knowledge gained from the books/screencasts in it. Also branch out from time to time and try creating a small project in a different language if you have time and/or commit to Laravel - you will help the community and learn something. And above all, do what you enjoy. 
&gt; They are the same tree from the point of view of the ORM. You give them a namespace with the rootid, operations are isolated and sets would overlap without the namespace. I probably didn't get your point then. For my understanding you have distinct nested sets. &gt; Mapping to distinct trees wont allow you moving a node from one tree to another Sure, why not? A move operation is nothing else than a remove from one tree and an append to another tree. I surely must miss some point as our understanding diverges a lot.
Thanks for the input, much appreciated. The programming languages and frame works stated in the job description are not necessarily to be interpreted as "AND" but "OR" , repectively "nice to have". And yes, our client is looking for a JUNIOR with up to three years of experience and provides their employees with the opprtunity to improve their skills/build up on their skillset during working hours. 
I wouldn't call this a backwards compatibility issue: As long as you don't use the new thing (traits), then the code is perfectly backwards-compatible. Only when you start using the new features, then you have to play by the new rules. Of course this doesn't mean I don't think this behaviour is strange. If a technical reason forces this, then maybe give us a better error message, or at the very least document this feature.
Thanks for the clarification. I hope you will find the person you are looking for !
This is really a non issue as you should be practicing one class per file.
If you use bad coding practises, you will find no sympathy here
Honestly I'd never come here for critique. Saying that, we get so much shit because of bad developers who abuse the language, so I guess we can stomp on it pretty hard when we see it. P.S I know my previous comment in my history was harsh, but the OP was slagging off php when he wasn't following good standards, otherwise I'd let "ok" code like this be
Note that this also applies to interfaces. If a class uses an interface or trait it will be excluded from early-binding. To fix this we need to a) make class hoisting independent from early-binding and b) reorder class definitions according to the dependency graph (and to allow either of that, early-resolve namespaces). Maybe, if someone finds the time...
You can use any templating engine like Twig or Smarty or anything to create your emails
&gt; Twig yo, hit me up with some links fam.
Sadly never used it, but stumbled upon some time ago: https://github.com/mjmlio/mjml It's node though.
google.com?q=twig+php
Because I could do ThingSingleton::getInstance() and get the correct object back. I guess it's a mix of Factory and Singleton patterns.
I use zurb's system (that you linked), then dump the generated HTML in a template (`.phtml` is sufficient) and edit the placeholders I put in it. Painful, but works and is better than having the entire pipeline doing it at runtime, which may introduce security issues due to missing contextual-aware escaping.
SendGrid works great. They have a front end responsive designer to build your templates for desktop, mobile, and plain text. You can then programmatically insert copy, images or whatever through code into hook points in your templates.
2 small pointer towards your require 1. **$docroot . '/' . $sitepath** is used 6 times =&gt; meaning if something changes you'd have to apply the changes in 6 places. If you make a var *$basePath = $docroot . '/' . $sitepath;* you have less overhead on later changes. 2. concatenating with . is confusing at times, it's fairly clear here but have a look at **sprintf()** 
I guess this is because some PHP apps might be packaged into *.deb packages, like PhpMyAdmin is. If such apps have some external dependencies, it might be useful not to bundle all of them, but depend on other *.deb package like other traditional packages do. This is how traditional packaging works, they try to avoid duplicating packages by bundling everything inside and producing static builds.
Pros to installing via Ubuntu channel: * One library across your system means fewer files/space needed * You can use Chef or puppet or other config managers to install dependencies on servers * You can use system tools to update libraries along with other system packages Pros to using composer: * Package/library versions are set and upgraded per-project * Package updates happen independent from system updates * CI processes can maintain package upgrades during the build process In my opinion, I can't see a reason for using system packages over composer. The pros I listed above are just the ones I've seen touted from system package maintainers, but I don't see the real advantage over composer, and see a lot of disadvantages. That said, something like phpunit or other PHP tools I can see an argument for installing the system package (though it'll probably stay more up to date if you install using `composer global require`).
This is not just a bargain hosting issue. In enterprise, most servers run on RHEL. Unless you install the remi repo or build PHP from source you are stuck with 5.3 or 5.4. 
Any ideas on the safety of using `cat /proc/sys/kernel/random/uuid` - other than being platform dependent of course. That's what we use at my workplace now because it's very fast and we use MongoDB as a temp store for doing large transactions and due to legacy/policy all the IDs are string UUIDs. Previously we were using `mt_rand` generated UUID4.
As a developer, the idea that libraries my code depends on are going to be updated via a nightly `sudo apt-get update` makes my skin crawl. Libraries get bugs, and I wouldn't want that code to change without running tests before it goes live.
Automattic runs the .com, they don't control the .org. The .org is a community project. They have some influence, but WordPress doesn't answer to their whims.
This is a controversial opinion, but: If your operating system promises to support iterations of PHP 5.x long past its expiration date, that's *your operating system's problem*. Expecting any project to continue to support 5.x past EOL is ludicrous. WordPress has every reason to drop 5.2 support, but they don't, because they like to brag about adoption rates.
I believe they are there to act as dependencies for CLI programs and system wide packages. Not for general use.
Exactly one of the problems with that approach, yes. And the fact that not all packages follow semver makes it a bad idea
Roughly €35/hour *before* taxes in NL. Around €4000/month for hiring. The average lifespan of a PHP developer is 6 months per employment. Some stays longer, not usual. 
Have you used php 5.2 lately? It's pretty painful. Not to mention that it hasn't been supported in years and undoubtably has a ton of exploits by now. 
&gt; WordPress has every reason to drop 5.2 support, [...] I wish they would. They could even drop support for 5.3 and 5.4 and very soon 5.5. But I guess that would break 80-90 percent of all WP installations including their own hosted variant.
Thanks! That was really helpful! 
My workplace has the same policy for Ubuntu LTS. Hence why it was such a huge major deal that 16.04 comes with PHP7, otherwise it would have been a giant uphill battle against pretty much the rest of the company to let us use PHP7 on live systems any time in the next 4 years
I saw this some time ago and found it really interesting: https://siipo.la/blog/how-to-use-eloquent-orm-migrations-outside-laravel The main problem with Laravel migrations is that the command depends on the framework, but the schema classes don't. So you can "swap" the migration control to use Phinx and still uses Laravel Schema to make the definitions. It's a bit tricky to understand and setup, but I think it'll work well.
They are only namespaced for query optimization. The nodes are free to move between these namespaces (which happens automatically). Yes, the move operation is the optimized version of remove and add. The intended result though is not achieving namespacing, but faster inserts
Ubuntu will release bug fix upgrades, but we won't get to work with 7.1 or higher until 20.04, so that sucks. Unless we can convince the server admin team to let us stay up to date
OK, Thanks for the help.
You get an Ubuntu version suffix, so for instance on 12.04 LTS the PHP version is reported as 5.3.10-1ubuntu3.21 so you can lookup what security patches were back-ported on that release.
This confused the hell out of me when heartbleed hit. 
Right but any code meant to be shared must be written for the lowest common denominator is what I'm saying. 
haven't dealt with it in a bit, but thanks for the info :)
I agree that it's terrible that we still have to deal with hosting that only supports PHP 5.2/5.3 but the security argument is generally a weak one. These companies (GoDaddy in this example) are most likely backporting security fixes into their supported version of PHP like RedHat does for RHEL. Even large reputable dedicated hosting companies (i.e. Rackspace) don't officially support PHP versions outside those of RHEL, so it's a big problem. I'd love to upgrade PHP on one of our Rackspace servers but then I lose official support for Plesk on that server. Our (newer) server has a Plesk version that supports user-compiled PHP versions but I imagine a lot of IT guys are hamstrung with supporting older servers.
Best practices would dictate that dev/staging environments match production as closely as possible. This is not always realistic down to the last detail (though it certainly can be done) but major version differences are a huge potential issue.
You'll need to be a lot more specific.
Actually, it's not *that* bad. According to their stats, only about 8.3% WordPress installations are on PHP 5.2 at this moment. https://wordpress.org/about/stats/
Is PHP 7 default for ubuntu 16.04? To me (as a sysadmin, not a developer) that seems a bit premature. There's a bunch of important extensions that to my knowledge doesn't have "official" PHP 7-supporting releases yet on PECL, right? igbinary, memcached, and phpredis are some extensions where I've had to build from git forks or branches to be able to play with PHP 7. Am I missing something?
json_decode, json_encode lol
PHP7 is the default, yes. And I'm not sure about igbinary or reddis, but I think memcached supports PHP7 now, and is bundled in? Not at my PC at the moment to check. 
I download a JSON from the DB. I send only the diffs of what I"m changing to the API while I edit the contents. Using JSON Patch Specification.
You probably already know about this, but GitHub has a way to view all open issues / PRs across multiple repositories that I've found very handy to keep as a bookmark. For example: https://github.com/pulls?utf8=%E2%9C%93&amp;q=is%3Aopen+user%3Aauraphp+
I would be happy if they spat out a warning regarding an older PHP version, even though I rarely use WP... It would mean so much to the community and its developers.
thanks for the opinions, you're alright. it's most something like a zend php certification test then an interview test
Thank you very much for this, it's EXACTLY what I need.
RHEL is worse though since they somewhat promote the idea via a handy gui console that someone within your organization should be in charge of what packages you have access to. In my organization this role ended up being designated to a Windows systems administrator. edit - To be fair this same organization also tried to implement some inane internal rules in such as "You are not allowed to agree to any EULA that has not been vetted by the organizations general counsel" and "You are not allowed to use any software that has an open source component (you know because of the whole SCO fiasco)", so this may not be a Red Hat problem... Oh yeah we had 4000 employees.
&gt; undoubtably has a ton of exploits by now. Is that really the case? I haven't looked at many but I've yet to see a specific PHP security flaw that is really exploitable besides very obscure edge cases. I mean, if there was such an issue surely every server &lt; 5.3 would have been compromised already.
Meanwhile the ZF2 manual is still advising (or at least implicitly condoning) the use of ServiceLocatorAwareInterface and AbstractActionController::getServiceLocator all over the place: for [controllers generally](http://framework.zend.com/manual/current/en/modules/zend.mvc.controllers.html#servicelocatoraware), for [console controllers](http://framework.zend.com/manual/current/en/modules/zend.console.controllers.html), for [services generally](http://framework.zend.com/manual/current/en/modules/zend.mvc.services.html) with [examples](http://framework.zend.com/manual/current/en/modules/zend.service-manager.quick-start.html#zend-service-manager-quick-start-examples-service-manager-aware), for [forms](http://framework.zend.com/manual/current/en/modules/zend.form.advanced-use-of-forms.html#the-specific-case-of-initializers)... and that's just a cursory glance. It remains a feature of ZF2 so it needn't have been excised entirely, but I don't see a note about deprecation or best practices in any of those places. It's all well and good to say "well, the RAD people wanted it, but it was a bad idea so we're taking it out," but it's no surprise that users of the framework reasonably relied (or rely!) on its own documentation when they were making decisions.
IMHO Symfony has one of the best docs, no idea how you got such a different experience...
Do you mean the 'callable' type declaration?
5.3 or 5.4 are not all that bad, really.
Agreed, this was exactly why I wrote Couscous in the first place.
If they came out and said PHP 7 only for the next major release (5?) you'd see a lot of improvements in the core as well as the hosting infrastructure. Sadly that will never happen.
I'll just post you an private. 
5.2 is the big move because most of the breaking changes we find in modern php projects happened in between 5.2 and 5.3. ie namespaces, late static binding and closures. 5.3 to 5.4 only has one big breaking change which is traits. But from then on its plain sailing. Most projects built on 5.4 will work on 7.0. Edit: by breaking change I mean a feature that would stop a project built on 5.4 being run on php 5.2 etc 
It's a investment/management/leadership problem not a technology problem.
Play with your headers. I ran into a similar problem recently but would send to hotmail not Gmail. I am not sure why it's happened but adjusting the header fixed it.
I do freelance work so I'm on a lot of different environments, and about 8/10 times they are using a php version from before 5.4. I always notice because I always use `[]` for arrays which was only supported in 5.4...
You should be using a [DI Container](https://github.com/thephpleague/container). 
Some things are good and some things can be improved. A short sampling is: * Prefer to use autoloading rather than requires. * Views shouldn't extend controllers; controllers shouldn't extend core. * Ideally the router would be generic; no knowledge of controllers or views, no hardcoded pages. Consider reading [Create your own PHP Framework](http://symfony.com/doc/current/create_framework/index.html).
I've been working on a little PSR-7 application core called [crux](https://github.com/yuloh/crux). It's just enough code to let you stack middleware and run the app, nothing else. You can use any container interop container with it.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Indeed. It's ironic how certain people go for the "easy" solution, which then end up causing massive frustrations and taking up way more time than it would, having done it right the first time. Of course a Linux shell can be daunting to look at if you come from e.g. a point-and-click OS (like Windows), but once you get the hang of basic commands, it's bliss, really.
You are not alone. There are a lot of PHP programmers on the internet. The best part on internet is that you can find examples of a well written code and the worst part is you can find a bad written code. First of all you should start looking into standards so you will start writing code in the same style as other developers. I suggest you to check PSR2 (http://www.php-fig.org/psr/psr-2/). Looks like you have basic understanding of objective programming, so next you should learn Namespaces (http://php.net/manual/en/language.namespaces.php) After learning namespaces you should start using composer (https://getcomposer.org/). It will solve you include/require mess by introducing autoloading and later on you will be able to use other people libraries that will make your developer life easier. I see that you try to achieve MVC pattern, so learn MVC pattern. Read other people code. Learn Dependency injection. Learn SOLID and DRY. Read other people code. Do not read shitty code. If you have a problem - it was already solved by others. Everyone suggests http://www.phptherightway.com/ , so you should check it too. Learn framework. Start with symfony. It will be hard, but when you will learn it, you will learn a lot of good practices. Be lazy! 
8.2% of all WP installations would magically jump to at least the minimum required version if it was bumped. Hosts are being lazy, not stupid.
No use in using a framework for this if you don't want to. `dirname(dirname(__FILE__))` can be replaced with `__DIR__`. Also, why double `dirname()`? You should set a 40x HTTP response code on errors, this will get logged by Apache/nginx/w/e and could help you in the future. Instead of having separate header and footer files, you could use output buffering to capture the content from pages/ and include it into a another include that has both header and footer. The advantage with this is you open tags in one file and close them in another.
That's not a downside; if you're not documenting your code with comments, you'll find not many people want to work with your code.
Yes, always try to document everything you write. It really helps later on, for yourself and any others that have to support that code later on. Where I work, we have automated checks in-place for things like this, and one of the code quality checks is sufficient documentation for all functions and class methods using PHPDoc syntax. We even go as far as requiring all inputs and outputs of a method to be specified and described. It might seem like a lot of work, but it really helps. Even a month down the road, can you remember your whole codebase and every single function you wrote? If you have to spend 5 minutes for each function everytime you pick the project back up to figure out what's happening, then you're better off spending that initial 5 minutes to just document it in the first place.
I want to check the content of an external .xml file, if that content is different, php does validate() if not, simply does nothing. I need this to check in an interval of 20 seconds. Do you think your solution would be a solid option? 
I think they underestimate the BC breaks of dependency upgrades
And my point is those edge cases don't apply to a bog standard PHP install.
How about a CLI script with an eternal loop and sleep(20)? 
I'd also write a bash script with an endless loop. You can then easily call php from within the loop.
It's a bad idea even for projects that follow strict semver. I've had cases in the past where I've unknowingly relied on a certain broken behaviour in a package which was subsequently fixed in a patch release. No way do I want to update any package even if it's a patch/security release with at least running my automated test suite.
In that case you shouldn't be polling the file for changes but using inotify to let the operating system notify you when the file is changed.
This sounds easy to implement and easy to code, I might try this solution.
If you decide not to go down the queue/worker route, you could have a simple CLI script like the one below to monitor the file: &lt;?php $file = 'text.txt'; $hash = md5_file($file); while (true) { $newHash = md5_file($file); if ($newHash !== $hash) { // FILE HAS BEEN MODIFIED $hash = $newHash; } sleep(1); } It will run indefinitely and monitor the file once per second. Put your code where the comment is. However, be aware that any code you add could be leaky.
You can have long-running PHP. But this idea is to call a PHP script which execute, and then exits. So you constantly are setting up and tearing down, but don't have to worry about the PHP script sticking around for a long time.
Yes.. That is the only true solution. No need to poll like a mad-man, but use the filesystem to notify you on a change. Same way sass knows when you saved a scss file and trigger the compilation. You don't want to run this in a browser, it scream CLI tool :)
It is funny, isn't it?
In which city? I never see job postings that pay so well in my city, especially for PHP devs.
*bash* script not php. And I am talking about running this on the commandline, no (web-) server involved.
Thank you! You remind me how much I love simplicity
Composer is still not signing packages, which you get with debian packages.
&gt;(btw, that's the reason why Laravel could be built on top of SF components. they should have learned a thing or two.) Isn't it the case? 50% of Laravel dependencies are Symfony components. If you mean practicies, having decoupled components that can be used as standalone, it's just not the aim of Laravel.
&gt; (Doesn't Laravel do this with some parts?) You're correct, it can create a compiled php file with all the core classes Laravel lneeds to bootstrap. The intent is to cut down on autoloading and disk access.
Probably batch queuing. Though if you're going for real time and batch you should probably just have an always running processes
While I don't disagree with a VPS being a decent option for a group of people, it's overkill for somebody hosting a blog, not to mention the fact that they'll have to keep a VPS running, including updates. You really want to have your average WP user deal with that? Apart from that, cheap shared hosting doesn't have to mean shitty hosting. We offer PHP7 on our cheapest (EUR1,50) hosting plans.
Dang - I wasn't aware of this and I use crontab all the time. Makes sense now. Thanks for the tip!
I think the second example comes close to what it should be. return $data on success, false on failure is a php thing and not really good practice. If the method can't return the expected result (json data in this case), it should be considered an *exception*. The first example should be avoided at all cost, die() and exit() should not exist in modern code at all.
It says external xml file.
PHP simply is not the right tool for this. It consumes unnecessarily many resources (CPU time and RAM), even when just hanging, and with little or no garbage collection. I **strong advice against** using the poor-mans solution `set_time_limit(0)`, which seems to pollute the web (Reddit, StackOverflow, Google Groups, etc.). Especially when called through a `shell_exec`, where you have absolutely no outside means of interrupting the script, short of restarting the server or identifying the PID and crashing it. Some people use file locks and other persistence tools (e.g. database or cache), but then it is internal logic inside the culprit script determining whether it should run or not. Additionally, the script will simply hang until the sleep timeout has been reached, just to occasionally realize it shouldn't run anymore. Programmers may forget to take into account the execution time of the script itself. Say you want to execute something every 20 seconds, as in your case, but the script itself runs for 2 sec. Then the execution time should be subtracted from the periodic sleep time, being 18 sec. This is easily achieved through a few `microtime(true)` calculations. However, the script will continue to be offset by a few micro- or milliseconds everytime it runs, which is not desirable. Lastly, I'm sure you've already done this, but to others: Please remember to do a file lock (`flock`) so that the same script won't run multiple times at the same time in case of overlapping executions (often caused by (periodic) long execution times).
You need to use [curl_setopt](http://php.net/curl_setopt). It would look something like this for a GET request: $curl = curl_init('https://api.softgarden-cloud.com/api/rest/v2/frontend/jobboards'); curl_setopt($curl, CURLOPT_HTTPHEADER, ['Content-Type: application/json']); curl_setopt($curl, CURLOPT_USERPWD, '{clientId}:'); curl_setopt($curl, CURLOPT_RETURNTRANSFER, true); $return = curl_exec($curl); curl_close($curl); **EDIT:** And if you want to use something easier to use, have a look at [Guzzle](http://docs.guzzlephp.org/en/latest/).
Sadly, no I cannot. They all pretty much miss the mark. 
`minute hour dom month weekday command`
Yep, Flemish.
 /** gets the height */ private function get_height() 
if you need a walkthrough, Jeffrey Way on Laracast has a video on it: https://laracasts.com/lessons/how-to-use-eloquent-outside-of-laravel
I use `data_get`, `value`, and `dd` liberally. In our application code, not a library. Still, if a library chooses to depend on it, I think that's fine, as long as they pick a version and not `*` or `dev-master` which will probably end up breaking the package. I believe it defines all global functions only if they are not otherwise defined. I realize that this isn't perfect because the order it gets loaded might end up clobbering some other package but in general it shouldn't be an issue.
&gt; The "," in echo was unknown for me. Are there more places like this? I guess a pattern which is always good is creating lists of strings and then implode them. &gt; Worrying about , vs dot in most applications that aren't using 10mb fabricated strings is a microoptimization providing to performance gain an only distracting from the real bottle necks. 
Tasks in Crunz run in parallel using symfony/Process library. It also has a locking mechanism (using this is optional) to prevent instances of a certain task from overlapping each other.
not to mention that if say your server loses power while recompiling say a kernel update you are indeed royally fucked. Fuck auto-updates. Don't be lazy and do them yourself.
Consider opening an issue, even just with those. The deprecation was done in the MVC component only, but docs for the other components need to transition to better practices indeed.
thanks.
For the TLDR version of what's going on here: * PHP uses copy-on-write: * When you do something like `$a = $b`, PHP doesn't actually copy the entire value of `$b` into `$a` yet. It just puts a marker on `$a` that points to the value of `$b`. * PHP will only copy the entire value of `$b` into `$a` when you modify `$a` (or `$b`) by doing something like `$a .= "\n"` ...and if you just [copy()](http://php.net/copy) then use [file_put_contents()](http://php.net/file_put_contents) with the FILE_APPEND flag, you can save another 10M of memory by not even storing the original data in the first place (for this particular contrived example using /dev/zero, you could run [dd](https://en.wikipedia.org/wiki/Dd_%28Unix%29)) As others have pointed out - in 99.9% of cases, you'll never encounter memory savings anywhere near this. And if you do, there's probably a better way of doing whatever task you're doing anyway.
I take this article as more of a "Be aware of the costs of what you are doing" in the general sense. If, being aware of this tidbit, you now properly write the code so it doesn't do a needless concat then you've learned something and become a better programmer in general, right? Saying that this specific example is pointless and you should just focus on large bottlenecks is totally missing the point.
Try posting in /r/phphelp.
&gt; The "," in echo was unknown for me. Are there more places like this? Not really, because echo is not a function like the rest of the gang, but a language construct which accepts more than one parameter and will print each one. So comma inside echo is not used for concatenation, but for delimiting the parameters. echo 1,2,(3),4,5,6.2,' PI is: ',pi(); 
The copy-on-write thing is interesting. Would this still apply for arrays? e.g. Does $bar just contain a pointer to $foo[0] until either is modified? $foo = array(array('A','B','C'),array('X','Y','Z')); $bar = $foo[0]; echo $bar[1]; // 'B' 
You can just imagine echo is: function echo(...$strings) { foreach ($strings as $string) { print $string; } }
That isn't part of _this_ RFC.
http://i.imgur.com/JfX8Rig.jpg
&gt; That's a lot of space saved. Perhaps as much as $2 worth of disk space?
I watched that before posting here, and the elephant in the room in his walkthrough is that there's no way to manually run the migrations. IIRC, he just puts code in the global scope and runs it. As I wrote in another comment, you can't hook the migration commands without the framework package, but you can use `phinx` and hook its migration system to Eloquent's query builder, which is nice.
Thank you! I'm having a read of it now.
Thank you! Why should I start with symfony? I was wondering if I should start there or go to Laravel?
Can't you use argument unpacking for that? Like `function foo($a, $b) {}` with `foo(...$arr)`
The ability to 'use' traits has been great for code reuse and has significantly altered the general architecture of modern applications and frameworks that utilize this feature. As such running a php application which uses traits on an older version of php which does not support it would be impossible without re-thinking the architecture. That is the way I see it anyway. Edit: I realise you may not have read my edit on my original post. I'm defining breaking change as a feature that prevents downgrading, not upgrading. I understand this was probably a counter-intuitive way of wording it and I apologize
But but but more classes and more injection makes it harder to reason about code! best to just drop everything in a single class where it's convenient to find things and more "expressive" /s ;)
I get his point, but the example is not really a good one. An extra fwrite could have added more IO overhead that the memory you saved not copying and modifying a variable. Even with an echo example, I doubt the execution time per a million iterations or so would be faster if you concatenate the strings and call only once. Benchmark: - *echo $str . "\n"*: **0.082** sec. (https://3v4l.org/IKrvq/perf#tabs) - *echo $str; echo "\n"*: **0.111** sec. (https://3v4l.org/eoeUZ/perf#tabs)
So, make it as a common gameloop, use microtime() to measure time taken during process and sleep the rest of the time. 
Just deal with recruiters. But yea the type of people in the UK who do Laravel very rarely hire contractors, most of the contractor work I see is asking for Symfony. If you're contracting you can't really choose to just use one framework unless you're really good. But there is at least one Laravel contracting gig in my inbox from a few months ago. Paying £340 a day.
Currently 24/24. Nice. There's usually always one against, so far not.
Wait for it : Zeev haven't voted yet.
Indeed, I missed the edit. Thanks for the clarification.
It's something I'd like to do if I get round to it, but yes, not in this RFC.
it'll be the same problem as with the service locator imo... "I'll refactor this later"
You could do that, but I think that only works in the simplest of cases. An example where that might not work: function drawLine([$x1, $y1], [$x2, $y2]) { // ... } Being able to have the array unpacking in the parameter list itself lets the function body be more concise, and it sometimes means the function signature conveys more information.
This is basically creating a PHP version of Node.JS. The question is - why? Isnt it better to just use Node.js that has their event loop implementation written in C++ and ALL libraries are written in asynchronous nature, starting from build-in fs, http ending on every other community-based library?
Haskell has a more advanced form of this, called pattern matching, which is ubiquitous and really useful. I've long wanted to bring PHP closer to where Haskell is here. In Haskell, I can define a utility function for dealing with tuples like this: add (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) I love how concise and clear that is.
It's a simple addition that brings more consistency to the language and doesn't break anything. Those kinds of things tend to be successful if people think they're useful enough.
I still fondly* remember the fight around introducing `[]` array literals. As expected, the world didn't end when they were added and look, now we even get more `[]`s - and this time even without the controversy :-)
Wouldn't say it's a bad idea, especially if your implementation is better or more useful in some way - but yeah much harder to be noticed in a crowd of a thousand packages than to be noticed in a particular niche 
post at hackernews and medium too. Add to packagist for composer. make sure to have good docs and if possible live demo. 
I'm not sure the extra fwrite adds any more overhead. The same amount of data is being written. So it should be the same amount of IO.
I like the idea of making a blog post introducing/explaining the package.
How is this related to PHP?
Don't be afraid posting a package here - if you're writing good code and solving problems that haven't been solved (or solving them in a different way) you'll have more success. If not, you'll usually get some good feedback! That said, the response can be really random here. I've posted a useless package that was just me pissing around with typed arrays and it did quite well. On another occasion I posted a package that, in my opinion, gave quite a nice interface to an otherwise confusing library and nobody batted an eyelid. Another point is that if you get involved with the reddit community, helping out with comments and posting interesting content that you find - people are more likely to appreciate your personal work when you submit that too.
If you think your package is a good fit, I would try to get it added to [The League of Extraordinary Packages](https://thephpleague.com). I usually check there when I need something before going to packagist.
I'm currently working on adding diagrams, thanks for your feedback. Event Driven Architecture isn't tied to a language, so I've used pseudo code in the snippets. ReactPHP, heavily relies on this architecture: it provides an Event Loop and Promises as components. Out of the box, on a vanilla PHP set up, the Event Loop will use the `select` system call and won't use any Thread Pools, so you might want to: * use the Child Process component (an alternative to Thread Pool) * install PHP extensions like libev (for a better Event Loop) and libeio (for "non-blocking" filesystem support, but [it has its limits](http://blog.libtorrent.org/2012/10/asynchronous-disk-io/)) * install libuv PHP extension and use the [branch from this Pull request](https://github.com/reactphp/event-loop/pull/17) PHP-PM is only a load balancer / process manager on top of ReactPHP, so it's kind of out of the scope of the article, but it got a lot of traction recently and people are asking "how it works". This article is my answer ;) .
&gt; But since we're discussing it. I'm curious about the execution time difference between the two examples. Because if the concatenation example executes faster but uses more memory there is a trade off that needs to be considered. If the other example is faster, then it's a double win. Even if the concatenation example is faster, it will eat up more memory, which reduces the available memory for other concurrent requests to the application to use (in most traditional PHP setups). Fewer people will be able to use the application at a given time. While that is definitely an at-scale problem, it introduces the concept to people who otherwise might not have known how memory can impact the application.
freecode.com can help, too.
Yeah, Reddit can be tough :) I actually posted here a few months back, looking for review/opinions about a package I wrote. Now it has matured a bit and am wondering if I should give it another go. But I'm wondering if I won't get down voted to hell for posting the "same" thread again. Don't wanna lose my imaginary internet points.
Thank you :)
Is this the point where I drop the most useful package in the world into the conversation?! github.com/mdwheele/zalgo &lt;3
That's a good idea. Am not a big fan of moving to their namespace myself, but it would definitely help the code quality and improve visibility.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I get this vibe that maintainers posting their packages here are often more concerned with gaining reputation than solving a problem. 
How exactly does OPCache work? I work with a site that uses modern modrewrite rules for practically everything including the path to the administration panel. Problem: Sometimes when I load the admin panel it'll show the last admin's dashboard, that exposes all the url's and what not on the sidebar. After you click on a link it clears and sends you to the login like it normally should. Question: How exactly does OPCache work? Do I need to separate my admin panel from the main application in order to fix an issue like that?
Thanks! Now I see what is happening.
It's an interesting discussion, one that I don't have an answer for. I'd love to try and benchmark the differences soon and see.
Well actually the way Symfony's principles are, the http request and response are nice interfaces and you're discouraged from modifying global state. It could be done with other code bases, sure, but you'll probably run into more "gotchas" especially with static functions. Doing things like User::getCurrent() in your app? Boom suddenly everyone on your site is the same user, the first one who got set statically. Shutdown functions? Virtually nonexistent so I hope you're not depending on them for anything. 
It's the base exception class whether you're using Laravel or not. Your phrasing suggests it's unique to Laravel.
as /u/ThePsion5 said: `\Exception` is the base exception class of **PHP** itself, not Laravel's. [look](http://php.net/manual/en/class.exception.php)
I've been working on an implementation of [handlebars](https://github.com/wycats/handlebars.js/) for C and PHP. I believe it's finally relatively stable. The goal is to provide consistent, performant rendering of templates both server-side and client-side. The library is implemented in parts: - [handlebars.c](https://github.com/jbboehr/handlebars.c) contains the lexer, parser, and handlebars.js-compatible opcode compiler. As of v0.5.0, it also contains a VM implementing most of the handlebars opcodes, with the notable exception of decorators (and therefore inline partials). - [php-handlebars](https://github.com/jbboehr/php-handlebars) contains the PHP bindings for handlebars.c and runtime utility functions. As of v0.7.0, it can also render handlebars templates standalone. - [handlebars.php](https://github.com/jbboehr/handlebars.php) contains a port of the handlebars.js javascript compiler. The compiler produces PHP code and, with precompiled templates, can run without the extension. The opcodes are compatible with the opcodes produced by handlebars.js, so you could use handlebars.js to parse the template and feed them into the compiler to produce a compiled template, if you really need to avoid native code. - [php-psr](https://github.com/jbboehr/php-psr) provides the accepted [PSR](http://www.php-fig.org/psr/) interfaces. This allows the PHP extension to implement Psr\Log\LoggerAwareInterface. You can also check out [lightncandy](https://github.com/zordius/lightncandy) for an alternative implementation. Contributions and feedback are welcome! Previously, I wrote a [C++ implementation of mustache](https://github.com/jbboehr/libmustache) with PHP bindings: [php-mustache](https://github.com/jbboehr/php-mustache)
I fixed some of them today. Some of them were really really stupid. Others, I can't just fix, and have to chase people ... and also find out who to chase ... I think, they don't actually provide a full report ... just tell you about the silliest ones. Some of us do run static analysis on php-src, but the tools may not be as good as theirs. Maybe, I could wish really hard for a license ... c'mon everyone, wish with me ...
To understand how OpCache works, you need to understand how PHP works. PHP is not an interpreted language. Like many modern languages, PHP source code is transformed into bytecode and executed on top of a virtual machine. OpCache and everything that works like it (APC, xcache, classics like eaccelerator and turck, etc) work by inserting itself between the creation of the bytecode from a source file and the execution. The bytecode is stashed away in [shared memory](https://en.wikipedia.org/wiki/Shared_memory#Support_on_Unix-like_systems) along with information about the file, including the full file path and last modification time. OpCache also inserts itself early on, when PHP goes to open a file to process it. If the file exists in the cache, OpCache returns the bytecode directly and thus saves the effort of recompiling it. In this way, bytecode caching can be a *huge* performance boost. If your environment allows doing so, you can also tell OpCache to not check the last modified time of the target file, which can save a stat(), [an important thing to consider in application performance](http://talks.php.net/show/digg). *Only* bytecode from files on disk is cached. It won't cache the result of an eval, for example. It won't cache output. Or input. Or anything else other than just the bytecode from PHP files on disk. Unless you're doing something really unusual with your source code, like dynamically regenerating it on the fly and writing it to disk, OpCache alone shouldn't result in the behavior you're seeing. That isn't to say that OpCache isn't without historic bugs and unusual behavior, but the thing you just described shouldn't be caused by OpCache at all. Now, speaking of dynamically generating files on the fly, what template system do you use? Perhaps it's being a bit aggressive with what it stores on disk. If it comes in through include/require, it'll go through OpCache first.
Would you consider extracting the collection class to it's own package at some point?
Yup, planning to do, well aware of it : ).
TBH I'd probably go with the saveToCache() approach. Nothing wrong with being explicit in your code, and you never know when a rare edge case will crop up where you don't want to save to the cache...
Save the API responses to memcache (or redis) When it comes to hitting up the API, instead call a helper method which first checks the cache (but can be overridden if needs be). Crappy pseudocode... function get_api_result($data_needed_for_api_hit, $allow_cache_response = true) { if ($allow_cache_response) { if ($result = search_cache()) { return $result } } $result = hit_up_live_api($data_needed_for_api_hit); store_result_in_cache($data_needed_for_api_hit, $result); return $result; }
**TL;DR Version**: We're releasing PHP 7-only versions of most of our projects, and when PHP 5 is EOL'd we'll only be supporting the new branch. Some nuances apply, and random_compat is obviously excluded.
I've been reading your postings for a while now. The content is interesting but the layout is unbearable.
Read the title and thought it was a php7 interpreter written in Go. Disappointed now. :(
Yeah, I see that ... &gt; You have 50 clicks to navigate to the code. After that, the analyzer will offer to fill in a form and send us your contacts and information. If you agree, you will be granted 50 more additional clicks. That's fine if you're using it for some tiny project, probably even quite a good idea ... but makes the trial pretty unusable when the project is the size of php-src ...
I'm just guessing WRT the original complaint, but the first things that struck me were: - There's not enough difference (contrast) between some of the lower-level headings and the content. - There's not enough whitespace around the headings in general. The C.R.A.P. design principles (Contrast, Repetition, Alignment, Proximity) are fairly fundamental, easy to find on Google, and should help you out.
&gt; "product of Satan" :)) btw, thank you for the hard work :)
Just better spacing will make a world of difference.
No. If you use UUID as primary key you don't use auto incrementing values at all in the same table. Use created datetime or similar for ordering. 
I'm a bit biased since I'm from the Yii team. By "others" you mean Laravel's? I don't remember any other good enough ARs. Yii's is a bit more advanced in terms of features, a bit different in terms of API but they're alike. Some people say Laravel's syntax is better, some people say Yii's is better. As for performance, it's good. If we're talking about pure unit testing of user-level ARs, I don't think it's a good idea. AR itself is well-testsed w/ partly unit partly integration fixture-based tests: https://github.com/yiisoft/yii2/tree/master/tests/framework/db. For apps testing there are fixtures framework and Codeception integration. Domain logic should not be put into ARs and that's what should really be tested.
Thanks for all the work you've put in this framework, it really is a very robust framework. I think Yii should get more attention than it actually does as it's a way better tool than many many others out there, but i guess the entry barrier is a bit higher than in another frameworks and that keeps somehow people away.
PHP uses macros a lot, it's true, and they can potentially be an issue when debugging, but they provide an important abstraction of the internals of data structures. Moving to PHP 7 would've been harder without all the macros. And yes, macros sometimes have redundant branches. The compiler deals with that. &gt; Zend framework Uh, no. Zend Framework is a PHP framework. It's not a C virtual machine. That's the Zend Engine. The Zend Engine is at the heart of PHP, no, it *is* PHP. Everything except the streams layer and extensions is implemented there. If anything needs static analysis, it's that. How could you get this wrong? (I'll admit, of course, that the whole Zend branding thing is confusing. That said, the Zend Engine says *Zend Engine* at the top of every file, and Wikipedia's page on PHP tells you what the Zend Engine is.) &gt; Another interesting bug was found in the PCRE library: So, not a PHP bug, then. Should I be relieved they didn't find anything, or dismayed their software couldn't? Because I'm sure there's plenty of serious bugs in PHP that static analysis could catch. I'm possibly being too harsh.
Nah, *their* ok with it.
You better go they're and double check. 
I agree, having a - &gt;toJson and ::fromJson and storing the json in redis (or memcache) is nice and simple and very explicit.
&gt;No. If you use UUID as primary key you don't use auto incrementing values at all in the same table. This is not a hard-and-fast rule. I've worked on in the past and work on currently enterprise applications that use both.
That's much better. I honestly hit the back button and wasn't going to read it until I pasted this in.
&gt; I'd guess that, as they only mention "Zend framework" once, and the "framework" isn't capitalised, that it was just a slip up in writing the article, possibly having heard references to both "Zend Engine" and "Zend Framework" and thinking "framework" was an informal name for the engine. No, they also used the Zend Framework's logo.
&gt; helpful would have been sending the report to internals. Yeah, it was surprising to learn of this first on reddit, rather than, say, the mailing list.
As long as the API itself is backwards compatible, please use minor versions for minimum PHP version increments. Otherwise you're creating a dependency hell, because everything has to be updated.
this is only for personal use anyways I don't plan on releasing it out to the wild.
The API itself will throw syntax errors on PHP 5 projects; so it's not backwards compatible. My goal is to write PHP 7-only software, going forward. The "future" API splits I was alluding to was "if PHP 8 introduces even more new features we want to use".
Thanks for taking the time to answer my questions.
Will you be passing the full report output along to the PHP internals list so that the other issues that we're identified can be resolved? 
&gt; none of which refer to the Zend Engine (as it doesn't have a logo) It does have a logo: https://ajf.me/test.php https://en.wikipedia.org/wiki/Zend_Engine
You're welcome.
PHP might be the wrong tool here because you would have to execute PHP in the terminal and keep it running and wait for the comment, Which PHP is just not designed to do Dont get me wrong, it's certainly possible but just in a clean way
Unfortunately, I think a version drop is a breaking change.
Composer will take care of it and not install newer versions.
I knew as soon as I posted that I was going to be wrong, I'm an idiot, of course it does. The new logo is a lot nicer than the old cogs logo as well. The only time I've looked at the phpinfo() page recently was on April Fools' Day and I didn't scroll below the fold. But all the same, the Zend Engine logo doesn't show up if you just Google "Zend", which I assume is why they picked Zend Framework's ElePHPant for the article.
Related: http://blog.kelunik.com/2016/04/28/typography-redesign.html You might want to increase the line height a bit.
Would the license be perpetual?
Nope. No Yii-specific advices. It's the same no matter which framework is used: prefer aggregation over inheritance, pursue single responsibility per class where possible, couple to interfaces instead of implementations etc.
Thanks. this is a good point.
Yeah whatever language but not PHP. PHP is designed to run once on a server and not continously, you could run a cron or so but that seems a little silly considering python, nodejs, go or whatever could do this task very easily. Use the right tools for the job. 
Whats the php version have to do with the browser version? 
With respect to performance: Are you currently suffering from performance or memory issues? If not, then you're fine. If so then you should profile to find the actual issues rather than assuming removing `create_function` will solve them. Maybe it will. Maybe, though, you will be surprised by something else. With respect to code clarity: This is difficult to assess without seeing the code. I don't find the example too difficult to read but what constitutes readable should be decided by you and your colleagues. If this developer actively refuses and there are multiple people who also have trouble with his code you should try explaining that you and others are having difficulty. If that doesn't go well, discuss the situation with his manager.
I think what he meant to say is "Some things you can't influence."
Sounds like you have bigger problems than your colleague using `create_function`. It's hard to believe in 2016 there's any good reason to be using PHP 5.2.
On which page? Which browser?
post this in /r/programming not in /r/php
Sure if you want! I would it would be very easy in python thanks to the huge community
&gt; Am not a big fan of moving to their namespace myself I've moved two packages over to the League and it wasn't actually that bad! Packagist and Github are really good at allowing your package to live under a different namespace without breaking dependents, so the technical aspect of moving isn't that difficult. On a personal level I can understand not wanting to move away from your personal namespace, but you still retain full attribution and control over your project.
&gt; aggregation over inheritance Shouldn't that be composition over inheritance?
That looks pretty neat. I'm mostly using Slim and this looks like one step further.
"My first professional programming language was this mutant called VBScript, and of course a little bit of JavaScript on the client side, sprinkled with lots of “if this is Netscape do this, else do that” because back then I had no idea how to use JavaScript properly." Euhm, isn't vbscript client-side? 
I can tell you a few issues with the framework: 1) It doesn't adhere to SemVer completely, which means you have to read an UPGRADE guide to prepare your app that runs 2.0.7 to upgrade to 2.0.8. 2) It doesn't have any LTS. 3) It doesn't abide by community standards (PSR1-2, for example). 4) Doesn't have a great community behind it.
&gt; Euhm, isn't vbscript client-side? Both. The vision was to let people learn one language to be able to do both client- and server-side coding. Unfortunately it was an awful language so it made both types of development miserable.
Some white dudes faced reality that was far from any privileges. 
Couldn't agree more. But it's a company decision I cannot revert (Basically, our codebase is 8 years old, and company just don't want to make the effort).
And you haven't seen the best of it. For obvious reason I cannot put the actual code in here, but because of the several layers of evaluation, there's a string (regex) in there that looks like this `/&lt;!\\\\)$param/`
*Definitely* all for this.
Not sure I see the need for this. Nesting functions like that is just slick for the purpose of being slick. There's no harm in using multiple lines for the sake of readability and future-you; this just seems to combine the two approaches.
I'm 45.
Christ, I'm happy you're not on my team. Grab a clue sometime.
Note that Sara's use of anonymous functions there is what hurts readability, if anything. There will, of course, be uses of this operator that make you question its utility, but there are also much nicer uses: $hash = md5(strtolower(trim($email))); // vs. $hash = trim($email) |&gt; strtolower($$) |&gt; md5($$); Here it's hard to argue that the piped variant is less readable. This sort of use case is likely more common than the example in the RFC.
Man, I remember my Trash-80 (TRS-80), the idea of reading and writing to an audio tape is crazy.
Classic ASP could be written in JavaScript as well.
Ermmm piped, flat, linear sequence of functions is 10000x more readable than nested functions, especially when you consider that the source of the chain comes first rather than being nested somewhere in the middle...
What aggressive marketing is employed by other frameworks that makes them popular?
As far as I'm aware, that's the only place that sells them. They're notoriously hard to get a hold of, as most of the variants are only limited runs.
wouldn't that prevent you from piping to functions which take multiple arguments?
Until currying is supported by PHP natively, I'm against this. This is sometimes tried on JS and it just creates a anonymous functions hell (at least in the wild). Btw, lodash is one of the exceptions, and it also uses a replacement character for curried functions. 
Try switching from a PHP environment to a Ruby on Rails environment. Then see how you feel about this comic. 
Not sure I see a need for PHP. Everything PHP does can be done in C!
Here's a concrete example: https://github.com/facebook/fbshipit/commit/8e23de03d8d991d34c46aa0851f31e3768330d33 It makes any particular line harder to read, however: - it makes the function /as a whole/ much easier to read: it's obvious that immediately that it's a load of things chained together - there's no one-of line in the middle easy to miss that changes the meaning of the function - static analysis (eg the Hack typechecker) will spot if you mess up $$ and |&gt;. If you typo `$changeset` as `$changset` in the middle of that twice, it can't know if that was intentional or not (twice so it's not an unused variable)
Is the choice of indentation (function arguments on a new line are indented by a single space) here intentional?
Turned it into a repository ( https://github.com/clinoge/functionalphp ) and started writing docs and tests :-).
The trouble with this design is the the fact PHP functions aren't first class constructs. A Closure is an expression unto itself: function ($x) { ... }; This can be assigned to a variable. But trying to reference a declared function (or method), can't just be specified in a chain because as a name it's not a proper expression: $foo = "bar" |&gt; function ($x) { ... } |&gt; trim |&gt; MyClass::method |&gt; $obj-&gt;instMethod; So at best, you *could* use callable syntax for these and wind up with something like: $foo = "bar" |&gt; function ($x) { ... } |&gt; 'trim' |&gt; ['MyClass', 'method'] |&gt; [$obj, 'instMethod']; But this is ugly for its own reasons. If you want to make functions and methods first-class elements as below, that'd be a separate RFC (which would have serious technical challenges to it due to PHP's existing syntax), but without that the syntax you describe doesn't dovetail well. $x = strtolower; $y = $x("FOO"); Unless you mean specifying them as empty function calls as below, in which case that introduces other (but simpler) technical hurdles, and I don't see it providing much apart from saving two keystrokes. $foo = "bar" |&gt; function ($x) { ... }() |&gt; trim() |&gt; MyClass::method() |&gt; $obj-&gt;instMethod();
Agreed
I would actually enjoy refactoring with this operator in play. I hope it's accepted.
Ah, yeah, I'd have put that one more space in (two spaces relative to the last statement start). I assume /u/fred_emmott was placing it two spaces in from the close paren a few lines down, which was in turn two spaces in from the |&gt; column. But the splitting argumens into their own lines to avoid overrunning 80-columns is a very FB-style-guide thing.
I acquired one at a conference, but that's significantly *more* than $30 (unless work is paying)
The essay seems to be bloated...
Wow I'm surprised you found this :) If you are the real ocramius. Yes, like I said it's a very rough draft. But I think it's the start of something that once I've polished it, could be meaningful. It's really crappy right now though, but I wanted to write out all my thoughts before I forgot them.
I've built a couple of websites in RoR and I have no idea what you're talking about.
They're quite expensive to produce I think, and you need to do a pretty big run of them (to get the cost low enough to sell cheaply) which costs a lot, so I'm not sure if you're find a bargin anywhere, sadly. You might get lucky and land one at a conference sometime like I did. I was at PHPNW in 2012 and got one for adding a feature to [asciigram](https://github.com/chrisdkemper/asciigram) for Rowan Merewood. It sits on my desk at home, I do love it, I hope you manage to get one soon, somehow!
&gt; But as far features go VBScript (.asp) was fairly feature rich for its time. It couldn't do anything! I had to spend half my budget buying .COM objects to give it basic functionality for a big project back in 1998. Finally switched the whole thing over to PHP and got it done in a flash.
Hm. On the one hand I do understand the purpose of this, on the other hand it seems like a lot of the use-cases would be fulfilled by proper scalar objects. To borrow /u/phpdevster's example: return md5($email-&gt;trim()-&gt;strtolower()); Not sure which one I like more - although there are of course a lot of use-cases for the pipe-operator outside of scalars if we can't set custom handlers.
You understand that he was talking to an audience, not you personally, so there's no need to be so defensive on the matter. 
Is your issue active record style, table name as a member variable, nothing new or some mix of them all? ORMs have definitely become the side project that seems like a good idea just for fun until you drink your own kool-aid PHP project.
do they all end in ".io"?
Method chaining fails you when/if you want to use your own functions and can't/don't want to monkey patch built-in classes.
I'm not sure wether it's appropriate to call custom handlers monkey patching. Also, I'm not saying that it's a necessity - rather that most obvious use-cases, e. g. array operations, will be better fulfilled using scalar objects.
D: How do you guys get by without first class functions?! 
You made that presumption way before that. I don't suppose you're one of the 1% here who: - doesn't use and praise ~~PHP on rails~~ Laravel - hasn't ever written or used a PHP ORM ~~cloning~~ resembling ActiveRecord (the project, not the design pattern) - doctrine1, propel, gas, eloquent - hasn't done at least 2 projects in one of the other attempts at PHP on rails (symfony1, cake and the ones that aren't even memorable) 
I only asked if they ended in .io, you're the one drawing massive assumptions haha
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/subredditdrama] [An article about being a software developer over the years gets posted to \/r\/php. But, it includes a line on white privilege.](https://np.reddit.com/r/SubredditDrama/comments/4h4cvt/an_article_about_being_a_software_developer_over/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Whenever you write APIs, SDKs, libraries (and everything else, including your own code really), the access modifiers give you peace of mind if you want to refactor everything. Suppose you have a library that you want to modify some time later. You "know" that nobody will call your private methods directly, so you have a lot of freedom to change them as long as the public methods/properties remain compatible. There tends to be a lot of dead code and refactoring is hell without them. 
Not having to suffer from prejudice is already a chance, but it is easy to take it for granted when you don't have to deal with it. We're not talking about grades in school as much as hiring, CV screening or salary level. Many studies show that the white male gets more interviews for the same CV, or that females earn less that males for the same position. You were talking about facts, these are as hard as it gets. 
White privilege does not mean your life is good because you're white. It means a person of another race in the exact same position would be even worse off.
Have a good day, sir. (nb. I didn't downvote you)
It's backwards to avoid OOP and defensive programming completely. Work within the paradigms of the language to organize your code in a way that is maintainable.
C may not have classes directly but may functions return opaque types which can only be used with a set of functions. `fopen` can be interpreted as the constructor for `FILE` and `fread` a method. The language simply lacks the syntax that allows you to call the method from the object. C++ added classes to make this relationship explicit.
PHP has a really good object model IMO, which is how you get by without first class functions. Ironically, the lack of first class functions and easy closure has helped PHP code in the community follow the same paradigm relatively consistently. Meanwhile JavaScript is fragmented into people who practice FP, and OOP. But since JS's OO constructs are shit, I can't help but cringe whenever I encounter `new` and `this` and `class` in JS :(
Javascript is... different. On one hand I find its prototypical inheritance interesting. On the other, I wish it'd keep a fucking reference to `this` so I don't have to do `var self = this;` every time I want to keep my sanity. Anyways, Python also has a good object model as well and supports first class functions which are fantastic (though technically they're just objects as well). They're great for passing small policies around without all the boilerplate of defining a class. Or for small things like a sort or filter function. filter(lambda x: len(x) &gt; 5, things) x.sort(len) Even yanking methods off instances are supported: push = mylist.append pop = mylist.pop Kinda wish we had support for true anonymous functions but significant whitespace limits that and Guido has repeatedly pushed back on better functional programming support in Python anyways (though I do recall him mentioning that if he could do it over, he'd design it with braces instead). And it stops Python from turning into callback hell like some Javascript I've seen. But on the other hand, type hinting seems to be all the rage in PHP right now, so maybe they're not as important to you guys. But yeah, since PHP doesn't support first class functions, I could see how $$ might be easier to implement in that case. Just wonder how that'd interact when someone does something awful like: $bar = "foo" |&gt; someFunc($$, $$thing)
They do offer discounts during some PHP related events (_[during PHP Australia it was 25% off](https://twitter.com/elePHPant_off/status/720495881045327872)_). Follow them on [Twitter](https://twitter.com/elePHPant_off) or [Facebook](https://www.facebook.com/elePHPant-Official-774704769242207/) to catch such discounts.
Of course the pipe operator would have a lot of nice uses, I'm just saying that using scalar operations is not necessarily the best example, as they would be better fulfilled using scalar objects. But you are right, the pipe operator would be useful.
I bought 5 of them last year. Each was around $30. 
Thank you. That actually helps me a lot. I still think the idea of getting rid of all classes is a bit extreme. But, the point I think you're trying to get to is functions or methods should do what they're supposed to do, and not try to build an AI into it. The intelligence should come before the code. Either from the coder's knowledge on how to use them, or the coders ability to make sure they're testing their data before using them. Thank you again. 
&gt; On the other, I wish it'd keep a fucking reference to `this` so I don't have to do `var self = this;` every time I want to keep my sanity. Not sure how well you're keeping up with JS language developments, but ES6 basically solved this with the new arrow function syntax. `x =&gt; x + this.y` is equivalent to `function(x) { return x + this.y; }.bind(this)` (i.e. `this` is automatically bound inside the arrow function definition).
Yeah, but which should come first? Probably currying. /shrugs/
Sorry man! I never had those problems. I never had to buy any com object. I worked on very elaborate Web Apps too. Do you remember what the company objects did? 
and dont give it a stupid name so people actually find it when looking for something to solve that problem. I'm looking at you BazingaBundle...
I thought it was javascript
Rails is a beautiful framework and ruby is a gorgeous language. Once you wrap your head around: EVERYTHING AND ITS MOTHERS DOG is an **object**. you will be fine :D
One of our general rule is indentation over alignment - so, multiples of 2 spaces. We care how indentented the previous line was, not what it's lining up with. Every approach we've came up with for aligning multi-line function calls with the pipe operator has tradeoffs, and while this one generally fits with FB's internal guidelines, we've not actually settled on something yet. IMO the best purely for visual consistency is to treat it exactly like `-&gt;`, so no space after `|&gt;`, but that is semantically messy.
&gt; playing catch-up This feeling will and must persist. Always. Just "1. Forget The Hype" and "4. Keep on Learning". ;) 
Haha, it doesn't. But you implied they would be the same size. And I inflated both for readability, so it was still a fair comparison. But yeah, the bytes don't matter. I was just showing that they aren't equivalent.
&gt; Readability is what counts. The pipe does improve readability somewhat, but using sequenced assignment is pretty much the same. You won't hear me claim that this is anything by syntactic sugar. And sugar is delicious. Also fattening, but ignore that. And I'm diabetic, but ignore that too. SUGAR
&gt; Just wonder how that'd interact when someone does something awful like: The mixture of variable variables? That's handled in the tokenizer rule to give precedence to the existing feature over the new one. So the `$$thing` is just a normal variable-variable expression and has no relation to the placeholder input token.
HackLang has this, but with a slightly longer arrow: $result = array_map($x ==&gt; $x + $this-&gt;y, $data); It was proposed for PHP last year (using `~&gt;` instead of `==&gt;`, because reasons), but was voted down: https://wiki.php.net/rfc/short_closures
It's been a very long time... but I remember the most frustrating thing was dealing with the file system (local and network shares). There were very basic operations that were impossible to perform server-side with VBScript out-of-the-box.
Conferences, guest posts, trainings. I'm speaking at conferences in ex-USSR and Latvia and there Yii is known and popular. Other team members made to European conferences but not that often. Yii was barely presented in US except, of course, speeches by Larry Ullman. That's one of the reasons it's not well-known there. We definitely should invest more time in all these but time is limited and all the core team members have fulltime jobs (additionally to Yii) and families.
It breaks it in many ways but I can name one way that makes it really bad. It's putting domain logic into ARs. If you're not doing that, it's OK for most cases.
Why did you start building an ORM? There are literally thousands of them. It's "inspired by Laravel", what's wrong with Eloquent?
If you live in germany, i could give you one for free.
I'll take "projects that will be abandoned soon" For $1000
Sure: &lt;?php function pipe($data, ...$callables) { while($func = array_shift($callables)) { $data = $func($data); } return $data; } echo pipe( loadConfig(), 'buildDic', 'getApp', function() use ($app) { return getRouter($app); }, function($_) use ($app) { return getDispatcher($_, $app); }, function($_) use ($request) { return dispatchBusinessLogic($_, $request, new Response()); }, 'renderResponse', 'buildPsr7Response', 'emit' ); As you can see i haven't committed any changes to pipe function ;) With arrow functions its gets even cleaner: echo pipe( loadConfig(), 'buildDic', 'getApp', function($_) =&gt; getRouter($app), function($_) =&gt; getRouter($_, $app), function($_) =&gt; dispatchBusinessLogic($_, $request, new Response()), 'renderResponse', 'buildPsr7Response', 'emit' ); Also where is $app defined? by getApp, predefined? or how? I just noticed that argument passed to getRouter should be result of getApp() (or shouldn't?) but later $app is used and I don't really get it... 
Yeah thats exactly right. I would never use any ORM in a production environment other that Eloquent or Doctrine. This is purely a side project for learning.
Nothing is wrong with Eloquent, I use it all the time. Purely just a side project.
ActiveRecord? Thanks, I'll pass...
But it's weird that only fat arrow functions behave that way, while "classic" function syntax does not. That kind of inconsistency is not good for the language IMO. It means x =&gt; x + this.y and function foo(x) { return x + this.y; } Are not behaviorally equivalent, even though fat arrow syntax is supposed to be shorthand for the original syntax. Also, does that auto-binding of `this` still work when you pass a function into a higher order function, or does it lose its reference to `this` like the classic function syntax does?
100% agree with this, it gives all the benefits of scalar objects (+ way way more) and avoids all the debate, and doesn't fundamentally change the language like turning primitives into objects would. I would still love for everything to be an object, but there's going to be a lot of complex decisions to make to get that to happen, and I don't know that a consensus could even be achieved.
Approximately 5% of latest version installs are on PHP 5.2
There's a lot of risk on the host's side as well. If you have users who have PHP scripts written that are not in WordPress and not 5.2+ compatible, and as a host you upgrade them to say 5.5, then guess who the customers will blame and try (even if they have no merit) to sue
Email to provider sms gateway? That's how I'd do it. 
/me blinks You don't mean [Aura.Payload](https://github.com/auraphp/Aura.Payload/blob/3.x/docs/index.md) by chance?
$3/month doesn't seem too bad for peace of mind knowing you don't have a free hacky solution that might break next month. I'm curious what cheaper alternatives might be out there though.
&gt; it can't know if that was intentional or not Wouldn't that get caught by static code analysis showing that a variable was unused after assignment? &gt; it's obvious that immediately that it's a load of things chained together Although the chaining is obvious, the fact that the functions are just filtering the output of the previous function isn't so obvious, without inspecting each line. If I was going to refactor that code, I'd do it like: public static function applyAll(ShipItChangeset $changeset) { // This is obviously defining a list of filters. $filters = [ 'self::skipIfAlreadyOnGitHub', $fn = function ($cs) { self::stripCommonFiles( $x, $config['stripCommonFiles/exceptions'] ?? ImmVector {}, ), 'self::stripSubjectTags', 'self::stripSubjectTags', 'self::delinkifyDifferentialURLs', 'self::restoreGitHubAuthor', function ($cs) { ShipItUserFilters::rewriteSVNAuthor( $cs, FBToGitHubUserInfo::class, ), 'self::rewriteMentions' 'self::rewriteReviewers', 'self::rewriteAuthor', ]; // This is obviously chaining the output of one function to the input of the next. foreach ($filters as $filter) { $changeset = $filter($changeset); } return $changeset; } Which is more 'obvious' to me but also has the benefit that the return statement for the function isn't twenty-one lines above the end of the function. 
The nested version is obviously horrible. The sequence and point-free versions are about the same, except that (to me) that the point-free version is slightly quicker to write, but would be harder to debug and read due to the lack of intermediate variables. &gt; The variable assignments in the sequenced version is just unnecessary noise. I disagree at least in part because I don't like your variable names. Just calling something 'lowered' doesn't actually describe what it is, and yes if you're using such poor (imo) variable names, then they are just noise. But if you use actually descriptive variable names, then they make the code easier (for me) to understand when I come to debug that code: $trimmedEmail = trim($email); $trimmedLowerCaseEmail = strtolower($trimmedEmail); return md5($trimmedLowerCaseEmail); Can you give an example where being able to leave off the parameters is more persuasive? maybe something where the intermediate values have no semantic meaning at all? If you don't want to use semantically meaningful variables names, you can just use `$v` everywhere..... $v = trim($email); $v = strtolower($v); return md5($v); The difference between that and the proposed RFC seems minimal. Except that using `$v` for variable names would't pass a code-review, whereas using a language feature to similarly skip naming parameters would probably be allowed. 
do you send me the money via paypal or bank transfer? :)
It wouldn't be free, but I'd probably buy a no-contract pay-as-you-go SIM card, and some kind of USB interface. [Here's an article that shows you how to do this with a raspberry pi](http://www.mattiasnorell.com/send-sms-from-a-raspberry-pi/). This would basically end up being just an initial investment of $25 plus whatever you carrier charges for SMS credit. 
I'd be willing to pay the cost to ship it. Should still be under $14 usd
There's not. You can deposit as little money as you like and without auto reload they'll simply shit you down of your balance goes negative. There are no minimums. OP didn't read the pricing page. 
That's for IP notifications, not SMS. SMS is free up to 100 and then .75 per 100 thereafter. 
If you just want something for personal use [voip.ms](http://voip.ms) has free SMS with their numbers which are $0.85 to $1/mo. It's not meant to be used for bulk purposes, but I imagine there wouldn't be any issue with a personal project sending out &lt;200/mo.
Thanks, I might have to switch to a more reputable company like this :) Have you used the *attachments and picture messages* yet?
Yes! yes it is. I have only looked at your personal github profile and couldn't find it. I should have looked at aura. thanks, you saved me a ton of time.
I haven't, but I have done voice calls and made an interactive menu call. So I would imagine the attachments/pictures would be just as easy, just cost a bit more. But their prices are pretty reasonable IMO.
This is perfectly possible. file uploads: http://php.net/manual/en/features.file-upload.php parse CSV: http://php.net/manual/en/function.str-getcsv.php database access: http://php.net/manual/en/book.pdo.php
I don't know if it is because you have two ';'s instead of one (don't know if PHP will error out in that case.. ?) In any case, with SQL queries, if I'm having any issues I usually echo out the $query so I can see what the query actually says, from there I can fix up my code. If you can't see what's wrong, run it in MySQL and see what the output is.
When do you intend on tagging a new release of php-mustache that supports PHP7?
Why do you use an app on your phone to send yourself SMS messages? You can just compose a regular SMS message with your own number as the destination and it will bounce right back to you...
&gt; even though fat arrow syntax is supposed to be shorthand for the original syntax This isn't true though. The arrow syntax isn't meant to replace the original syntax, but is its own thing altogether. Besides the lexical scoping of `this`, arrow functions lack a `.prototype`, and cannot be used as generators. Arrow functions are supposed to be like a more lightweight alternative for regular functions. (At least that's the idea, in practice I'm sure it was also a good excuse to clean up some bad design, like the `arguments` construct.) &gt; Also, does that auto-binding of this still work when you pass a function into a higher order function, or does it lose its reference to this like the classic function syntax does? The `this` gets lexically bound, so which `this` is referred to is determined by where the function is defined.
Var_dump ($con); Echo $query; Var_dump ($result); What do you see?
Oh you're right, excuse me.. I'm a little tipsy. What does your $query output?
it outputs the following: SELECT * FROM users WHERE username = ''
ignore (most) my message below (you should still escape the variables in a SQL string). I just saw this comment, sorry. This means the POST variable 'username' is empty. make sure your request to that script is an actual POST, not just using an url query argument like "?username=something". For that, try $_GET, or $_REQUEST
What are you trying to accomplish by obfuscating the URLs Edit: I ask because what you are trying to do helps answer your question
**Disclaimer** : i don't use mysqli, only the PDO alternative. But in PDO to see database related errors you have to specify it on the connection handle like this : $dbh = new PDO($dsn, $user, $password); $dbh-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_WARNING); Long story short, by default, any errors in SQL thingy will be silent by default in PDO. **For Mysqli :** From there [http://php.net/manual/en/mysqli.error.php](http://php.net/manual/en/mysqli.error.php) and if it works like PDO I would guess you won't see any SQL Query related errors without mysqli_error ( $con ); somewhere after $result = mysqli_query($con,$query); *mysqli_query()* returns false if an error occurs, so I would go like this : $con = mysqli_connect("localhost","root",ltest,database) or die ("error connecting" . mysqli_connect_error()); $username = $_POST['username']; $query = "SELECT * FROM users WHERE username = '". $username."'"; $result = mysqli_query($con,$query); if($result === false){ // DONT ECHO DATABASE ERROR IN PROD EVER echo "Message d'erreur : " . mysqli_error($con) . "\n"; } The other possibility is to look into *mysqli_report()* but for several reasons i would not : * By thread - if your server is sharing threads between request you no longer have any fine control over error reporting. * Sloppy code incoming Anyway, if you do so **don't keep it in prod ever**. User seeing database related error messages is **SCARY**. I would not use that, your call. EDIT: formatting
should i just use pdo? will that fix it? but my sqli seems easier..
I need a bit more context to answer : * What do you need it for ? Short school project and never touch it again or you will commit in PHP dev ? * What do you know about Object Oriented Programming (OOP) in général and the PHP OOP in particular ? * Do you have time to learn right now (in général and for this project) ? * Other programming languages you know ? I'll never advocate against PDO. In fact I even learnt PHP OOP through PDO. But don't learn it just to escape errors the other way. I'll stay around to answer you again. Edit : général - Spot the french
i'm not working on a school project. i'm working on a website where users can submit things about gaming and stuff (posts,blogs) i heard that mysqli was easier but i dunno to be honest. pdo seems better but i hate oop.. 
&gt; I need to zig-zag to trace the flow of data Yes, that's true, and the only reason I like the RFC at all. &gt; one advantage to nested calls is memory efficiency since you're not assigning memory to a new variable on each return That's not really true.... the variable still exists, it just doesn't have a visible assignment. Although in theory it _could_ be optimised to release the memory sooner, in practice the amount of memory used is going to be the same except for the very small number of times the garbage collector runs in the middle of the code. &gt; the pipe operator makes it EASIER, not harder...Just chuck a var_dump anywhere in the....If you do need to var_dump(), just do an assignment when you need it, and remove it when you're done. Debugging using a var_dump is a crappy way of debugging for anything other than trivial bugs. If you are in the middle of stepping through a piece of code with a debugger, and want to be able to view a variable, having to stop the program add the var_dump, and then recreate the condition that caused the error is not a productive way of debugging. &gt; Naming things is hard, which is why point-free programming is a thing. "We choose to ---go to the moon in this decade--- name these variables and do the other things, not because they are easy, but because they are hard." I can see the attraction, I just don't like the trade-off it makes. It makes it easier to write code by avoiding having to name variables, which (in my view) makes it harder to understand what the intermediate variables (whether they are visible or not) mean. Debugging and maintaining code is always harder than writing code. Saving a few seconds per line to avoid naming a variable just doesn't seem like a good trade off over the course of a project. 
Rewrite the URL at the server level. Either with [Apache](http://httpd.apache.org/docs/2.0/misc/rewriteguide.html) or [Nginx](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html). Obfuscating doesn't feel like a good solution - there's no security issue to solve here, it's just a cosmetic change.
So in short: * Personnal project and let us get it done mindset * On your free time * Not much OOP knowledge in PHP or equivalents * No other language than HTML CSS JS is what I guess. Basically if you don't expect doing several other website in the future, I would stick with mysqli. If you expect to learn a lot and do multiple website etc. Go for *OOP* and *PDO*, you'll need it with composer, frameworks and stuff. A lot of *mysqli* (if not all of it) is written in OOP and *mysqli_function* are only convenient aliases. BUT : *PDO* is not easier, it is different. If *PDO* allows to access a *MySQL* database, it was written to allow to switch between database (*MySQL* to *Oracle* for exemple) easily. In my mind *MySQL* is said easier only because *PDO* uses *OOP*, and because it is the "historical one". 
Glad to hear it :-)
I send the message from the PHP script. I use the smsgateway.me api that use the app on my phone to send the message. Unless I use twilio or a similar service how would I be able to send an SMS from PHP?
i don't know if this is progress but now it says SELECT * FROM users where username = 1; that means it did find a user right? but it still won't echo it out here's a screenshot:http://imgur.com/W2rw0zR 
Oh thank god. Seriously, though, look into prepared statements. It's only a hair more complicated, but you quickly find that it feels better than string concatenation, and you don't need to worry about manually escaping all of your values (which isn't a perfect solution for every case anyway)
what i am supposed to use mysqli_real_escape_string every time i write post string? or every string (post or not)] 
Sometimes destructuring in the signature can be useful. That's a different, but related, potential feature to shapes.
Any data received from a user (or that could potentially have been received from a user) needs to be escaped before concatenating into an SQL query string. But if you use prepared statements, it's taken care of implicitly. The following is perfectly safe: $q = $db-&gt;prepare("SELECT * FROM users WHERE username=:username"); $q-&gt;bindValue(':username', $_POST['username'], PDO::PARAM_STR);
"Right" is a sometimes difficult term. The idea of decoupling your core data from where it comes from is a generally good idea, yes. Maybe your Person should be doing some validation but it shouldn't be too big if you are taking this approach. Note in functional languages the data is usually completely "dumb", and the validation is pushed into the type construction of each piece. So it's a valid approach, but not necessarily the "right" or "wrong" one.
/r/lolphp is this way -----&gt;
&gt; Is this somewhere along the right lines? Yes, it sounds like you're on the right track. Don't know if "Manager" is the right term (it's generally advisable to avoid such nebulous, generic names like "Manager"), but overall you're separating responsibility along reasonable lines. &gt; I only ask because the person objects literally are just a bunch of getters and setters, it feels like perhaps they should be doing more? A `Person` object is a perfectly reasonable value object or entity object to have, even if it doesn't do too much. That said, a couple of things: 1. If your app depends on the integrity of `Person` objects being constructed and mutated correctly, then yes you absolutely should do validation in those objects. For example, you shouldn't be able to set a negative age. Those objects should be 100% responsible for ensuring their own correctness. 2. Pure getters/setters indicates to me there *may* be a design problem. You should evaluate whether or not the object is exposing too much data to the rest of the app, or exposing too many ways to mutate itself incorrectly, to the rest of the app, and then better encapsulate that state and behavior as needed.
Can't reproduce that locally, but added a `max-width: 100%` to tables. Is it better now?
after clicking the register button. also is this code correct? if (!empty($_POST['uuername']) &amp;&amp; mb_strlen($_POST['username'] &lt; 15)) { $username = mysqli_real_escape_string($con, $_POST['username']); $query = "SELECT * FROM users WHERE username ='$username'"; $result = mysqli_query($con,$query) or die(mysqli_error($con)); if (mysqli_num_rows($result) &gt; 0) { echo "NAME TAKEN"; } }
Sounds good to me. Validation generally happens within your setters and constructor. 
Obscuring the url in that way doesn't serve to secure the site.
What's your exact Firefox version? Any plugins that might block or change something? `.post main table, .post main img { max-width: 100%; }` should actually prevent that, maybe `td` doesn't count as block element?
Readability is more than sugar, IMHO. Sugar has few redeeming qualities except it's delicious, as you point out. But in this case, when you're maintaining a large complex code base, every little readability advantage adds up. Start multiplying the small savings across, say, 10 developers and you get into maybe hundreds of man-hours every year. In the UK (and elsewhere outside of the US, I imagine), stop lights will blink the middle amber bulb a couple times before switching to green. This is to give drivers a headsup to hit the pedal on cue. Not strictly necessary to perform the base function of controlling traffic, but, I'll bet it shaves a few seconds off millions of commutes, so, probably worth it. 
I was on 45.0.2 but just updated and it appears to be fixed. Huh.
Yes functionality wise it's similar to pushover but it's meant for more advanced developers that want more flexibility over the notifications. I.e. you can have many apps each with any number of notification types, you can manage how each specific type is delivered (sound? vibration?), you can enable or disable notifications groups through the app, etc. Also there's no 7-day time limit you can use it for free for testing and small apps for as long as you like.
Hopefully not another total rewrite.
Agreed, which is probably why it will never happen ;)
While the specifics are indeed a very difficult topic, I don't think more than very few people would want the current stdlib replicated for scalar objects. It's probably one of the points with the most consensus.
Yeah, but you need to get the specifics done and agreed upon before it could go forward. It's easy to agree on "don't replicate what we have" but that's not very useful on its own. 
Well, that was pretty snarky. Thanks for the info, though.
This is pretty cool, I had been thinking about doing exactly this for a while and I'm glad someone else took it on and made it available for all. Thanks rahmatip!
I'm not on my desktop right now, can you please explain the difference between this and using a service like urban airship? 
Because everyone uses the compiled,final product, not its code. A library or framework has a very different scope from a piece of compiled binary that should just be used.
 &gt; But what about addressing the thousands of developers who work on the Linux source code directly? Mostly a very strict review process: the kernel development is divided into layers of mergers, and that reduces the probability of issues arising. A statically compiled language also helps a lot here. PHP's "fails at runtime" architecture (yeah, that's what it actually is) calls for strong contracts and reduced side-effects wherever possible. &gt; And I feel like "as long as it's OOP, we'll approve it" has become kind of a de-facto way of looking at the code. Disagree - there needs to be a decent review process anyway. Many bits of ZF1/ZF2 are still terrible code too. Just because something uses classes and inheritance doesn't mean it's OO either. Heck, most Java code I see being used in real-world apps is procedural classes anyway. I'd probably prefer a functional (not procedural!) codebase over an OO-codebase anyway, as I know that I have fewer spots to debug in first place. 
The fuck are you talking about?
I live in germany and would LOVE to have one of those 2. Would also pay for it.
Thanks for the response, glad I'm heading somewhat in the right direction! I went with the name "Manager" because it is essentially a class that is doing everything (possibly too much) to do with "People". I may look into ways where it is appropriate to break it down into more classes.
Thanks :)
Yes; more details here: https://github.com/dimsav/phpspec-reference/wiki/PhpSpec:-Code-coverage-plugin#clover-format Let me know if you need any help; you can also reach us (I say us because I work at Codacy) through the support channel.
We sell the PHPWomen Purple and Laravel Red ones over at php[architect] : https://www.phparch.com/swag They are $30 including shipping to the US. Yes, they are expensive, but the sales of each of those go to support those two groups respectively. We (php[architect]) make very little from each sale, and it just covers the efforts of our shipping team (aka, Customer Support agent) :)
How can I contribute to this library? I want to participate to add Indonesian national holidays.
Thanks. Great tool btw. It's almost gamified, would be cool to see where my scores stack up against others! Need a high scores board ;)
Thank you for participating. You can contribute easily by creating a Pull Request from your fork. Check out the library on github here: https://github.com/azuyalabs/yasumi. Let me know if you need any assistance :)
Agreed it's definitely interesting. I have to admit I'm confused by his conclusions: the more I use strict types, the less tests I had to write. Of course I still test features, but I no longer have to test for stupid and boring stuff like "assert the result is an object X" or "assert it fails if I give a wrong argument type or empty value", etc. That's also why I love PHP: you can enjoy strict typing when you need/want to, but still go fast whenever you want.
He made one very important caveat - it's true given 100% unit testing and the practice of TDD. The reality is that few projects I see can claim this type of discipline...
The problem is PHP has no compile step, so you can't catch type errors before deployment in any sort of automated way *other* than to have a good test suite. The type argument is a bit stronger in a language where the build will fail if you've made a type error, but that's not possible in PHP. And before anyone suggests adding some sort of type analyzing or compile step to PHP, since a good test suite does everything and more than any type checking step ever could anyways, writing tests seems like a better solution to the problem overall.
Not to slag off OP but just to be completely clear and transparent .... &gt; I always fear what would happen if they shut down someday This app uses a central server to, so still keep an eye on it! In fact, it's probably a fair question to ask OP what the business model is.
I think there are some good improvements in the "direction" of PHP - the new type hints in PHP7 are great, while I do not like strict types. Conversion to a type is usually better than throwing an error, in my opinion, because you will want to make sure a value is an int or string at some point (to avoid unexpected behavior), but you do not want an error every time "5" as string was used instead of 5 as int (which can happen all the time if the data comes from a database). Type hints do the conversion for you and make the code clearer.
Instead of locking the resource, implement optimistic concurrency. Add a "version_number" attribute, which gets loaded to the form as a hidden field. When the form is submitted, save 1+version_number. If the current value of the resource's version_number is not equal to your new one - 1, someone else has updated the resource. Then throw a data conflict error and/or reload the form.
If you are only sending SMS to yourself, you can just email the message to your phone number. You can google for the domain name for your carrier. I have Sprint so i can email &lt;my phone #&gt;@messaging.sprintpcs.com.
Probably because it was not relevant to the point he was making?
I used to do this in some projects. It works, but you'll eventually get blocked if you send too many.
I would guess an updated_at timestamp would work here too?
&gt; You don't need static type checking if you have 100% unit test coverage. Static type checks are tiny unit tests AND documentation AND compiler/tooling annotations. Unit tests are just unit tests.
I can I backtrace a php error? I have some errors that only pops on my live website (error log) I am looking to find a way to log what call made the error more than the error line. Any hints 
[removed]
Still Bing though.
&gt; i fail to see a valid use case for it Short version: you have a well-separated Domain layer, and you need to send one or more Domain objects back to the calling code for presentation, along with a description of what happened in the Domain and other meta-data such as validation messages. ("The calling code" in PHP is typically an MVC controller method or an [ADR](http://pmjones.io/adr) action.) &gt; Are you using your library for any of your other libraries or packages? Not in public applications, but [the default Radar responder](https://github.com/radarphp/Radar.Adr/blob/1.x/src/Responder/Responder.php) responder presumes an _Aura\Payload\PayloadInterface_, and delivers a JSON response based on the Payload status.
I like the theory of it, but I don't like writing tests in comments. It throws away the ability to use syntax highlighting and syntax checkers. It also is not as easy for non-devs (read: QA people) to write tests for code.
I totally understand. You can write the tests in methods, but then they pollute the implementation. I would like to create methods that will be removed from production code.
Test coverage != code coverage, and it's virtually impossible to have 100% *test* coverage on software of any significant complexity. Contrarily, 100% *code* coverage is easy, but offers you no guarantees about the correctness of your software. So, it was an interesting read from a historical POV, but the author lost me with the laughable conclusion.
Exactly. There's a description of this at http://martinfowler.com/eaaCatalog/optimisticOfflineLock.html
The patch is only ~30 lines of code, and a trivial parser change ... it may seem surprising, but it looks pretty well covered to me. Do feel free to test and submit tests/bugs :)
What flow do you feel is missing coverage?
Your company would be best sticking with a stable, supported distro like RHEL or its derivatives, SuSE, Debian, or Ubuntu LTS. Putting anything else into production is just asking for trouble. All these "enterprise" and/or "LTS" releases suffer the same problems though: packages are somewhat version locked for the entire life of the release. Your best bet if using RHEL or similar would be to install PHP as a [software collection](https://www.softwarecollections.org) (SCL/software collections are the recommended way to install non-base packages on RHEL). I strongly recommend using [Remi Collet's](http://rpms.famillecollet.com/) repositories and installing the desired version of PHP from `remi-safe`. Remi is a Red Hat employee on the Fedora Project and the maintainer of the PHP packages. All his stuff is solid, and using SCL installations will not interfere with the system packages. Custom extensions are easily built if you follow SCL guidelines.
Tests tell me if the code I *wrote* is broken. Types can tell me if the code *I am writing* is broken. A "more typed language" enables your IDE to catch errors and make useful suggestions *before* you run your test suite. I won't bother spending the five seconds to fire up my test if PHPStorm shows me a squiggly red under my method argument.
There are a number of ways to send push but the reason i made this (initially just for myself) was because all of the alternatives didnt do the things i needed as a developer. This is designed specifically for developers. You can group notification types and set how each one acts. For example if you're getting 100 users a day it'll group them all under one notification with a count and you can turn off the sound and vibration for that specific group so that it doesnt annoy you but you can leave the sound on for a request alert. And other features like that.
Good luck with the project :-)
&gt; I would like to create methods that will be removed from production code. You have the test comments still in production code. What you really want is probably the so much wanted but closed [composer#1750](https://github.com/composer/composer/issues/1750).
I like that idea of validating the examples in CI so that documentation doesn't get outdated.
&gt; What if there's a bug in the handling of the last class and it jumps to finally instead of the next catch? [better ?](http://git.php.net/?p=php-src.git;a=commit;h=5e10735d07578fcf656e40d0a967a9bc557ad838)
If the errors you are experiencing are exceptions, you can dump the trace into your error log with the getTrace() method. That should give you a lot more information than just the error line. http://php.net/manual/en/exception.gettrace.php 
&gt; But we already have tests covering what happens when undefined classes are fetched, and various aspects of the autoloader, and it's interaction with the vm ... we don't need to repeat those things. That would be a better argument if this was actually a straight up unit test of some compiler function. Nothing prevents the implementation of taking some arbitrarily different path when catching multiple classes. &gt; I don't know what that means, exceptions are not bound to anything. Poor choice of words on my behalf. What I mean is to check that $e is not accidentally set when not matching. edit: formatting
When I said 'lack thereof' I meant I would write a test that confirms that classes are in fact *not* loaded when type checking. I happen to know how type checking works for undefined classes, and I'm not sure if it's documented or not, but it certainly isn't tested here :)
I think it's more that programming is easier in a dynamically-typed language than a statically-typed one. I used to feel this was true during a prototyping phase, but I no longer feel that to be the case. The sooner I can wrap my head around what data looks like and where it's flowing, the better. Obviously that reflects my own experiences and not everyone will agree.
Cool!
My company uses RHEL, and when I need a more recent version of part of my LAMP stack, I use the packages from https://ius.io/ The repos are sponsored by Rackspace, and I've been very happy using them for several years now.
This. Out of all the distros I have actively used (Ubuntu, Debian, CentOS, RHEL) Ubuntu has been the most pain free.
&gt; That would be a better argument if this was actually a straight up unit test of some compiler function. That is *precisely* what it is ... &gt; Nothing prevents the implementation of taking some arbitrarily different path when catching multiple classes. Yes, it does: The patch doesn't introduce new opcodes, it's only syntactic sugar: &lt;?php try { } catch (Exception $ex) { } catch (OtherException $ex) { } ?&gt; and &lt;?php try { } catch (Exception|OtherException $ex) { } ?&gt; Produce identical opcodes: krakjoe@fiji:/usr/src/php-src$ sapi/phpdbg/phpdbg -p* test.php function name: (null) L1-4 {main}() /usr/src/php-src/test.php - 0x7f718586d0c0 + 5 ops L2 #0 JMP J4 L4 #1 CATCH "Exception" $ex 0 L4 #2 JMP J4 L4 #3 CATCH "OtherException" $ex 1 L4 #4 RETURN 1 [Script ended normally] That's *why* it's only a 30 line change in the compiler, not effecting how ZEND_CATCH or any other part of the VM, or the autoloader, or a million other things work ...
Thanks for the reply! I have a pretty narrow deadline for the piece so need to get this rolling ASAP, hence the tutorials.. stuggled finding any post 2014 to be honest without being a finished open source framework. Would it be possible to use the second as a basis for my project and then adapt it to new standards? The bit I'm going to struggle with is just the sub forum's generating posts when users make one and having the comments work accordingly.. Looking at that site briefly it looks hard to find something to help with the post generation from it? 
Fine, although when I switched to PHP7, I started using https://launchpad.net/~ondrej/+archive/ubuntu/php since it is not officially supported. Things have been a little more fiddly since then, but nothing that's a big deal at all. If you stick with PHP5 (or use Ubuntu 16.04 for PHP7) it's probably quite a bit easier. That being said, using the Ondrej PPA is not complex or difficult.
Just started looking in to functional programming and I'm not sure what you mean. Whats wrong with this: function multiply($a) { return function($b) use ($a) { return $b * $a; }; } Which, in my understanding is a curried function, and supported by PHP and can be used as either // PHP 5.3+ $multiply3 = multiply(3); echo $multiply3(5); // 15 or // PHP 7 echo multiply(3)(5); // 15
looks cool, thanks for sharing it
[removed]
This is the best answer. You're always going to be behind in versions if you want to be stable and efficient. Unless you want to have a QA staff that's 3x the budget of your dev staff, that's where you should be.
I don't use PHP anymore but follow it closely, good patch! I remember this was quite a pain when I used it.
Arch is the best.
I don't always use Arch, but when I do it is on production web servers.
Babel ftw! :)
I've found that cantos or Ubuntu is usually very good for a traditional LAMP
I used to be an Eclipse/Aptana user until i tried Sublime. The multicursor, extensions and speed got me. But it sux for OOP and i'm tired of seeing other programmers code with unused variables/uses in their code, things any IDE would warn them about (although they could install PHPMD with Sublime too). I gave it a try for Netbeans again and here are my opinions: * NetBeans is really good at understanding PHP code, and it's not slow. Although the first project i openned on it got stuck. But i tried again and it worked. The problem is that Sublime is much easier to get started: just open a file. Also NetBeans lacks supoort for SASS, Blade and anything that's not in the toolbox, while Sublime is highly extensible. I started using both editors, to use best of both, and now i'm using only Sublime again. I'm short on money for PHPStorm (price in dollars is really high for brazilian currency now) and i might try Padawan when i have time.
I find that web tech is moving so fast that some of the more traditional "stable" distros fall behind on package updates which gets really really annoying. For this reason I use Ubuntu exclusively for webservers. They are always up to date. If I'm in a virtual environment I'll sometimes use debian for the host and ubuntu for the VM's. I find thats a good combo because I have the stable distro on the bare metal and I can always boot up another VM really easily if I'm having any issues with the guest.
Ubuntu and Ondrej's PPA = unbeatable
Can't agree with this enough. Static type checking in a sufficiently powerful language alleviates the need for a lot of unit tests (read: developer time)
Will this be a first stone for multiple return/type hint declarations? Something like User::findOne(1) being able to return an object or null
Even for errors you can register a custom error handler and then call `debug_backtrace`. Sentry might be of intreset, it will capture and report errors with traces etc from your production system https://getsentry.com/ Or you could use something like Whoops to catch the error, and register a custom error handler to email you the stack trace etc.
I'd love to see a similar syntax for allowing passing of multiple types or nullable returns.
What does it matter if you're compiling yourself? Also the application pretty much forces the version of php unless you keep up with good coding and can update it fast when a newer version of php breaks backward compatibility. 
The issue I have with these $$$$$ editors is they have WAY too many features and way too many things that popup being like "did you mean this function?" PHP is not a hard language to grasp, sure the odd needle/haystack, haystack/needle gets ya every now and then, but IMO you should not need some 500$ editor to tell you how to use `array_function_name_here(needle, haystack);` One could argue that there are enterprise systems with lots of classes and lots of functions and abstractions, but realistically you will probably work on a small piece and spend a lot of time with it, I know I did at my company. Sure you venture off into the forest here the big bad legacy wolf lives, but most o the time you stay out on the sunny meadows of new code lane. I have a beef with these 500$ editors because atom and its many packages, or even just a few, I think I use 3 with PHP, do a lot better of job then these 500 features and 89 plugins that make your life a nightmare. Just let me code.
&gt; I really don't like this kind of event handling because you cannot do refactoring easily. Event names are used in string format when you trigger them and are used in method's name as well. It's really hard to maintain. I agree with this posts comment 100%. I always found this approach hard to refactor let alone test.
ok, great!
Dotdeb has been around for ages already and has proven itself in production environments for me for over 15 years now. I just recently upgraded a couple of Magento shops from PHP 5.4 to 5.6 using Dotdeb and all it took was changing the apt source list files and running an apt-get upgrade... My other choice right now would be Ubuntu 16.04 LTS (Xenial) which comes with PHP 7 by default. I just love the ease of use and good default configuration of packages which save time compared to CentOS/RHEL. I run about 30 servers on Ubuntu, 10 on Debian, and 10 on CentOS all on the Rackspace Cloud. At home I've run everything from Arch to Zentyal :)
That's not a serious answer, Mint focusses on the desktop and has no place on a server.
Take a look at BooBoo for one way it's handled: https://github.com/thephpleague/booboo
&gt; Personalization is limited to logged in users, item suggestions, etc. which are subsets of a page frequently loaded via AJAX anyway as you don't want the fraction of a second it takes to personalize a page to delay the page view for the customer since eCommerce conversion rates are tied to speed. Hi, i don't say that it is impossible to solve it that way (basically this kind of simulated ESI is exactly what Magento2 does to hide the poor performance). But you add more complexity to the shop and you limit the possibilities. For instance personalization is (of course) not limited in any way. There is always some history that we can use to optimize the page for the current user, even if she/he is not logged in.
https://getsentry.com/ Just sayin. 
Personally I used to swear by CentOS. However the move from 6 to 7 felt too steep, and 6 has had pretty piss poor support and updates for a lot time now, having to rely on 3rd party repos to use modern versions of PHP. I made the move on my personal servers to Debian a few years ago and have since used Ubuntu as well. Both are very similar in terms of support and updates however Ubuntu seems to be the more popular of the two these days. You can't go far wrong with either.
You're kidding right? This is either a joke or someone trying to get views for an 'out there' article. We've only just seen Drupal 8 after what seemed like 10 years. I hardly doubt ANYONE is going to be thinking about a Drupal 9 for at least another 5 years.
and the search engine developer evolves beyond imagination. waiting for the first implementation that somehow integrates the results with your IDE. so i can stop doing my job i guess
&gt; private $events = array(); I disagree with storing events on the Aggregate roots: What about events from Services? What about events that don't clearly "belong" to any single AR? Given that PHP is single-threaded and you generally don't need multiple "instances" of the same domain, I believe it's quite reasonable to use a static store, provided it is testable. Ex: private function doStuff(){ FooDomain::Record(new StuffDoneEvent()); } &gt; public function postFlush($event) I would not tie the "discovery" of events to the persistence layer. It's even possible to lose events any time Doctrine doesn't think your AR "really changed", such as when event A changes a property and event B changes it back.
Docker setup for symfony3 development. apache, PHP7, mysql, xdebug, support for blackfire.io, elasticsearch, mailcatcher when running symfony with docker, setting up permissions can get quite complicated: see http://stackoverflow.com/questions/34949083/symfony-docker-permission-problems-for-cache-files and http://stackoverflow.com/questions/22714885/how-to-use-setfacl-within-a-docker-container This project aims to avoid those difficulties by settings the UID of www-data inside the container to the hosts users' UID. Works on linux, OSX and windows. 
Some time ago I linked to a blog post with my idea on how to optimize Nested Set, and now it's finally part of the PHPixie ORM. I really tried to take all the complexity away from the user, so I hope you like the resulting interface
Long awaited feature !! +1
Full Page Caching in e-commerce is anything but long, complex and hard to do. And hardly put more problems for the devs to work on. That's a myth. And it benefits greatly to the application. Less charge on the PHP server, less charge on the database, faster load times, and more bucks for the company since the application will use less servers.
Can you link me to a quick &amp; dirty guide on how to send a message to a slack channel from a PHP page? Thanks!
Consider a cache-system as anti-pattern because you need to think about a cascading invalidation system with dependencies is a bad idea. Rule number one for high performance: What's computed is computed and need not be recomputed. In times where we have memcache/redis which can store hundred of million items without issues you definitely can and should cache also simple fractions of your site, even parts which are rendered individually for logged in users. Most people consider cache as a very simple mechanism where you can just store and retrieve something. This is so badly misunderstood that everyone hates caching for more complex stuff. However, it's actually pretty simple: You need to specify and build beforehand a very solid architecture of your caching-system and think about caching dependencies (like a "shop/top-articles" needs to be invalidated when "shop/article/5" changed) and caching invalidation for cache trees (I want to invalidate anything starting with "shop/article"). Of course this makes it a bit more complicated because you need to define a whole system for your caching, but it's also very straightforward once implemented and gives you a extreme performance increasement. If you don't consider caching as a simple key/store memory you could utilize the whole power of caches for every use case - e-commerce is a rather simple one because the dependency graph for cache branches is rather flat. So, I encourage to use more caches, but only if you have thought beforehand about it, because it will end in a nightmare if you start just caching in random cache keys without even thinking about a solid (maybe path based) invalidation and dependency tracking system.
Quite disappointed to have installed and set this up before realising that I can only send 100 notifications a month before I have to start paying :( 100!! Furthermore, is there any way in the app to delete old notifications that I don't care about?
By default you always get a string in PHP if something from the "outside" is fetched - you would need to provide specific instructions to a mysql driver for it to be converted, which can be quite complicated (how do you handle coordinates? the new JSON data type? what about decimal, where you could loose information if you convert it to float?). This would probably introduce more problems than benefits in my opinion.
Why did you post CakePHP 's new legacy version 2.8.4, when in the meantime, they also had released CakePHP 3.2.8? 
3.2.8 was released over a week ago (24 April). CakePHP 2 is still actively supported, and will remain so for quite some time. There are still many applications written with CakePHP 2.x and it is important that they are kept up-to-date.
Why post the release of a patch version at all?
They are cost effective however I would not recommend them for mission critical environments. They are simply too unstable. Just checked there status page and as of right now it reads 'Retrieval of messages information is delayed'.
It's not an anti pattern if you plan properly. In a hypothetical product page that has; 1. Product images, description, price 2. Personalised recommendations 3. Personalised cross-sells 4. User name &amp; cart summary (x items in your cart) etc. Point #1 is pretty much static so can be served from your full page cache. You could keep a TTL of a week or something without any issues + have a manual clear in case you need to flush out a typo or have a well-timed price change. Point #2 and #3 will have one version for anonymous users and personalised versions for logged in users. So maybe include the anonymous version in your full page cache and if the user is logged in, do a separate AJAX request to build personalised content to sub-in client side. This limits the dynamic load to only those people who are logged in, and also allows faster access to most of the page while the dynamic bits are being filled in client side. In dangerously high-load situations, you could easily disable the personalised content and just show the anonymous content to everyone. Point #4 is probably actually useful across multiple pages. Your name &amp; cart info is probably in the header on all site pages. So save you doing the same dynamic AJAX request multiple times; just stick that info in a cookie so it's easily accessible to every page and sub it in with javascript. That info doesn't update particularly often and it's quite easy to know when it has &amp; update the cookie. So you have a full page cache that will render a perfectly functional page and will be displayed to all anonymous users - which will likely be the majority of hits - without even touching your app or DB servers. This frees up your app/DB servers to handle the dynamic, personalised content requests from logged in users. If the servers are getting too hot then they could blackhole these requests knowing that logged in users will gracefully fallback to anonymous content &amp; still be able to read about products, add them to cart &amp; buy them.
They need really someone in their team that is responsible for their GUI appearance. That looks so 2005.
Welcome in PHP lands. While our benevolent rulers value convenience &amp; backwards ~~stupidity~~compatibility more then sanity, please note that sometimes we break backwards compatibility just for the additional sanity hit. Here's your truckload of most common "not a bug, stupid by design" printouts: http://i.imgur.com/T14KplT.jpg
Grammar...: &gt; Stefan is the co-founder of PHPBenelux and speaker **of many PHP conference** around the world. Actually both "speaker **of** conference(s)" and "many conference" are errors. So two in a single sentence!
Regarding cache directory permissions, why not use a docker volume container? I don't see why the host needs to handle that.
Some random defends PHP in comments on some blog post? Ok. (Though it is funny how half the replies are "PHP is turning into Java!")
When a best practice starts with "Always" or "Never" I usually stop reading.
The solution to "not an object" is to give it an object that fails silently? Sure, that sounds just swell. I'll keep doing this: if ($this-&gt;property === null) { throw new SpecificException("You didn't initialize this. Fix your code!"); } Exceptions fail closed, but can be handled gracefully if the developer really wants to not pass the object.
When not using the `-l` or `-d` start argument logs will still be written to stdout . But finding some elegant solution is definitely on the to do list. I thought maybe with the json file option and some webinterface/logviewer-container. or "something with syslog" ...
yeah, that would make things easier. you could even user `/dev/shm` for cache, which really does speed up things... we're using php storm with the symfony plugin which does rely on analyzing the cache files ( for auto-completion of services etc). I also had trouble with permissions between webserver and CLI created files, when using a data-container. but that maybe that could have been fixed.... 
If you're looking at log monitoring, which seems to be the real goal here, write to a normal log file and push said file over to a dedicated service (often using rsyslog or similar). I like PaperTrail, but there are tons of options. Most are easy to set up and have some sort of free plan. As far as writing goes I'd suggest using syslog directly, but file_put_contents will work fine too, you just lose out on standard formatting. Your approach, at least as a fallback, is fine as far as catching the errors go. Moving forward, consider Logger Aware components with PSR3 but that's a convenience not a necessity. 
You are forced to use `null` every time you use a library or function that returns it, some of the times this is our own standard library. Thus "never" is too strong of a word. Also, rather than a "Null Object" that you implement for each kind of object you can use a `Some` or `None` pattern (see `Option`, `Optional` and `Maybe` from many other languages).
While his point is valid in the way he presents it, this has several downsides as well. - An object would take up a lot of memory than a NULL. - type hinting wouldbt work that way (Logger $logger = NULL). - You can configure your IDE to warn you about possible NULL values, and if your function doc @return value mentions that it could return NULL values, you will be pretty aware of that. - isset($var) is a lot easier than checking with instanceof for every return value. 
The limit is only for push notifications, so if the limit is reached, the events are still recorded and you can view them on the apps event list, you just wont receive a push. For now I've gone ahead and given all the current users 3,000 pushes for now. Ask me if you need more. But I will be increasing it over time if there's demand. Best.
&gt; The module's unit tests can still be slow to run Then just split it up a little bit more. We are talking about true unit tests, wihout I/O interaction. In case of PHP it usually takes several seconds to run and it gives you much much more than just typehinting. Anyway, I don't saying that "you should only rely on your test suite". If you have ability to define types - it is good. If not (ruby guys) - just write more tests. And TDD will give you much cleaner code.
The issue is receiving and displaying the pushes and generating the device_ids. This app is meant to eliminate all the work necessary to do that. For a serious developer with multiple apps, handling creds and making apps to receive and manage push notifications for multiple apps can become a nightmare. This also provides searchable db of previous pushes and let's you group notifications and manage how each group is displayed among other features.
I like this approach. Setting optional object dependencies to null, and checking for null each time they are used, always seemed very hacky. 
It should depend on context. If your project critical to performance (most of the project are not) - then yes. If you are developing system for complex domain - then rather use NullObject than null. And the only one absolute rule - there is no absolute rules.
I used this pattern for my expect package. You don't always need logging so if you don't pass one in it defaults to a null logger ([link](https://github.com/yuloh/expect/blob/master/src/Expect.php#L55)). The psr/log package comes with a NullLogger which is great. Other than loggers or event handlers I haven't really felt the need to use this pattern much. I feel like usually the collaborator isn't optional enough to do nothing.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
**tl;dr** here's an example of when using a NullObject could be a good idea
 class YourDataObject extends DataObject and I'm out of there.. Please don't abuse extension like this and please don't make me couple my domain objects to your persistence library. My domain objects should not need to know anything about if and how they are persisted.
If you have to check with instanceof, you completely failed at using a NullObject. If you still need a check, you can go with null as well.
This brings up a pain point I used to find myself doing often until it finally hit me just how dumb it was. Having the constructor do anything but initialize the object. I used to think I was being clever by having database lookups and other things happen the moment the object instantiated. I found that I *generally* had far nicer working code when it is cheap to create an object. Then put in a `run()` or `load()` or some kind of action verb that must be manually specified so the caller knows something expensive is about to happen.
u could write a simple script that tokenizes all code in a unique key-val table, which you could give to the translater(in xliff€ if necessary). after that reverse the script?
MySQL and MariaDB work out the box - while it depends on Facebook's branch of MySQL, that's only for client-side changes required for the async extension - it's still fully compatible with Oracle/Maria/Percona/WebScale servers. Just checking - you've seen: - https://docs.hhvm.com/hhvm/installation/introduction - https://docs.hhvm.com/hhvm/advanced-usage/fastCGI FastCGI should usually be a drop-in replacement for PHP5 configurations. Alternatively, you don't need Apache or Nginx for simple cases: HHVM's built-in webserver (which uses the proxygen HTTP server library) is suitable for production use, and powers facebook.com and docs.hhvm.com: https://docs.hhvm.com/hhvm/basic-usage/proxygen You might also be interested in the documentation site's Dockerfile: https://github.com/hhvm/user-documentation/blob/master/Dockerfile The sources for hhvm/hhvm and hhvm/hhvm-proxygen are here: https://github.com/hhvm/hhvm-docker
&gt; Wouldn't that get caught by static code analysis showing that a variable was unused after assignment? &gt; That's why I said "twice so it's not an unused variable" ;) &gt; If I was going to refactor that code, I'd do it like: Personal preference, both because PHP callables aren't typesafe, and strings-that-are-really-code are something I strongly prefer to avoid. OOC, do some IDEs try to guess that a string is a callable?
Run.
Well either it's overly verbose or terse, but not both :) Idiorm is pretty old school, it's an active record, and it uses a ton of static methods, which doesn't play well with dependency injection. The ORM pattern in this case allows for many efficiencies when saving objects that would be impossible with an active record implementation.
No need, you must handle everything in a universal language, English. Code documentation must perform with basic explanations for the native language but the rest is retained.
Generally I feel like people who are not in support of the null object pattern also do not write unit tests nor think they are useful. And you can't argue with people who don't write unit tests. They'll just drag you down to their level. 
I haven't completely confirmed this as fact, but it looks real. There is allegedly a mitigation for the attack of adding: &lt;policymap&gt; &lt;policy domain="coder" rights="none" pattern="EPHEMERAL" /&gt; &lt;policy domain="coder" rights="none" pattern="URL" /&gt; &lt;policy domain="coder" rights="none" pattern="HTTPS" /&gt; &lt;policy domain="coder" rights="none" pattern="MVG" /&gt; &lt;policy domain="coder" rights="none" pattern="MSL" /&gt; &lt;/policymap&gt; to the policy.xml file that ImageMagick reads (which is usually in the /etc directory somewhere). For the PHP Imagick extenion, following the [security recommendations](https://github.com/mkoppanen/imagick#security) it includes is probably also a good idea. *Edit* From the description of the bug, checking the first 12 bytes of the files match known 'magic bytes' might be the best way of checking the files are actually images. Checking more bytes with finfo might be better under some circumstances. $allowedMimeTypes = [ 'image/gif', 'image/jpeg', 'image/jpg', 'image/png' ]; // Read the first 250 bytes of the file $handle = fopen($filename, "r"); $contents = fread($handle, 250); fclose($handle); //Create a finfo object $finfo = new finfo(FILEINFO_MIME_TYPE); // Actually get the mime type $mimeType = $finfo-&gt;buffer($contents); // echo $mimeType; if (in_array($mimeType, $allowedMimeTypes) === false) { throw new \SecurityException("File '$filename' is not an image file."); } *Edit 2 - proof of concept exploits* https://github.com/ImageTragick/PoCs &gt; It is possible to get content of the files from the server by using ImageMagick's 'label' pseudo protocol: push graphic-context viewbox 0 0 640 480 image over 0,0 0,0 'label:@/etc/passwd' pop graphic-context ................o....k. 
I agree; I have switched to using it for exactly that purpose.
I have tested this exploit, and even modified it to download and run arbitrary files from the internet. Its nasty. The policymap fix does block it.
I don't have a exploit to test with, but does relying on getimagesize() for validating the image prior to sending to ImageMagick prevent this? In the interim, I've written my own function to test for magic bytes prior to processing any user submitted image, since I have no way to know if getimagesize() is enough. function _check_magic_bytes($file) { $tmp = file_get_contents($file, null, null, 0, 2); if ($tmp === false) return false; if (bin2hex($tmp) === 'ffd8') return true; return false; } Only tests for JPG magic bytes, but easily enough to extend via: function _check_magic_bytes($file, $type = 'jpg') { PS -- this is for cases where policy.xml can't be placed or ImageMagick is too old.
oh, sorry then. misunderstood your question.
It's only going to get worse then.
OMG SOMEONE SAID "NEVER" YOU SHOULD NEVER SAY "NEVER"
Zend Queue with database backend and cron script for the worker is pretty light.
Out of curiosity, can you do an ELI5 on how the exploit works?
Thanks for the insight. very useful!
There ya go - http://www.openwall.com/lists/oss-security/2016/05/03/18 Enjoy
I would assume that using identifyImage would return the image dimensions if it's a valid image or it would produce an error if it were something else. I use something similar with GraphicsMagick where I test the image width and height from the identify function to see if they're valid. If nothing's returned then I assume the image is corrupt or something else.
[removed]
no my app is not bound to any 3rd party libraries... Thats what the adapter pattern is for... My domain knows nothing about anything that is not part of my domain vanilla php classes. There is no reason to do a compromise heren Others do it too is a bad argument...
[removed]
Lol. That is probably because you are brain dead from years of Php use.. That, or you didn't take time to really understand how it works. It might be complex, but once you understand it, you will see that it is does a good job. Php programmers take one look at potentially better languages and get turned off because what they see is unfamiliar from the braindead php ways. This ends up with these guys perpetually stuck with this shit language forever... 
Yes, everything is in French language.
French.
The first example doesn't really work for me... When I first read the title I thought "Interesting, I've never used null Objects, I wonder what I'm doing wrong". And when I read the example I realized one of the only places I use a Null object is for loggers where I usually have a null logger that does nothing to prevent exactly what's described in the example. So I'd be curious if you guys have more examples of where a Null object would make sense.
`/etc/ImageMagick/policy.xml` on CentOS 6 and `/etc/ImageMagick-6/policy.xml` on Debian Jessie. I had trouble finding these as they use some capital letters, which no other package does...
Hey, calm down, think of your blood pressure.
Why would you ever for any reason at all choose to write a query with parameters without using prepared statements? To me, that signals a completely flawed design practice. Not to mention, you are constructing a DELETE query based on a parameter passed via GET. You do realise, that someone could just send the admin (who is logged in to system) to a page that contains an image with an url something like "http://www.example.com/page?which=1". As soon as the admin opens the page and the "image" loads, the row with ID of 1 would get deleted, for example. Ideally, you should never pass parameters for state altering requests via url parameters in a GET request. I would seriously advise learning more about prepared statements and CSRF protection. Please don't give birth to yet another PHP system completely riddled with security issues...
I use https://github.com/bernardphp/bernard backed by postgres. Works fine for low-load apps.
www.phptherightway.com
Maybe a silly question , never used docker before because I couldn't get it to run on windows ? I'm getting these Couldn't connect to Docker daemon - you might need to run `docker-machine start default`. Couldn't connect to Docker daemon - you might need to run `docker-machine start default`. An error occurred trying to connect: Post http://127.0.0.1:2375/v1.22/containers/sf_web/exec: dial tcp 127.0.0.1:2375: connectex: No connection could be made because the target machine actively refused it. Couldn't connect to Docker daemon - you might need to run `docker-machine start default`. Guess it doesn't work on windows 10 with virtual box 5.0.18 ? Or more than likely I'm doing something wrong &gt;.&lt;
/u/erxor My condolences. Above suggestion is probably something I would try.
[removed]
The article claims the person implementing it didn't read the documentation. If your implementer isn't reading the specification, all bets are off. Please tell me where it is enforced that two classes implementing the same interface have no other methods where they do differ? It is the problem with trying to make your code robust, there is always a way to break it. A null object is a perfectly valid solution but not for the problem the article starts with.
ZeroMQ is neither a queue, nor simple. RabbitMQ is the best solution at any given day, but, might also be a little to much for OP. PS: Didn't down vote you, just sayin'.
Should I create support to search for Markdown files too?
If you're working with strings or any other primitive type, `null` is perfectly fine. You don't call methods on primitives anyway (at least not currently).
I understand the problem you're pointing out, but "bobby tables" contains characters Ignition considers to be illegal. I've all but admitted there are numerous flaws. I'm sorry for trying to help!
I'm not entirely sure what you mean by 'identifyImage', but let me just clarify few things: * The 'identify' tool from ImageMagick **is** vulnerable. * Neither `getimagesize()` nor `exif_imagetype()` functions are vulnerable (they do not rely on imagick extension only read up to 12 bytes from the image to detect the type). It should be perfectly safe to use something like the following piece of code to ensure that the files are in expected image formats, before passing them to imagick for processing. function isSupportedImage($filename) { $supportedTypes = [ IMAGETYPE_JPEG, IMAGETYPE_GIF, IMAGETYPE_PNG, ]; if (!in_array(exif_imagetype($filename), $supportedTypes, true)) { return false; } return true; }
This is just bad form. Security flaws, poor documentation, and overall bad coding/design practices. Just because you can write your own framework doesn't mean you should. Honestly, why not use one of the more solid frameworks PHP has? I'm all for writing your own for the learning aspect, but for Christ sake do not put something out this out there in the wild. And definitely do not put it out there and suggest other people use it. Especially when it has known security flaws that are undocumented. 
Most light weight solution if you are using unix/linux system and you have no requirements about a persitent queue system: http://php.net/manual/de/function.msg-send.php
We have been using Tracy for a while and it had been really easy to setup and use https://github.com/nette/tracy
I'm not really aware of any other frameworks that fill this particular void. Why are all of you so dicey? I didn't say, "Here is the best thing since sliced bread and you should immediately use it in every single project." The current state of this code is largely functional, and more than secure enough to use on small projects. Why do all of you think I'm trying to present the Space Shuttle when I'm actually showing you a concept-drawing for an airfoil? Christ.
Damn right, son.
&gt; more than secure enough to use on small projects. So you don't even understand, how insecure it is.
I guess not. What's an example of how the administrative vulnerabilities could be exploited by an attacker, and if the attack MUST come from within, what is the likelihood of such an issue being exploited on a small-scale project? Furthermore, the code is there. Why not spend the same effort you're using to degrade me to... 1) Point out the bugs specifically so that me or others can fix them in a spirit other than one intended to degrade. 2) Create a branch and take an hour to fix the exploits in one of the packages and help create something cool. 3) Install it on a server and explore the concept rather than flaws in the draft. 
Or, call me crazy if you want, - public function __construct(Aggregate $aggregate, Logger $logger = null) { + public function __construct(Aggregate $aggregate, Logger $logger) { An optional dependency shouldn't be used with abandon.
Well **this is a validation guide**. You are not required to use the league URI which is merely use as an example to illustrate what to do when creating or modifying an URI: * parse the URI (with your parser of choice, of course having a RFC3986 compliant parser is advised) * validate each component independently (validation rules are scheme specific) * validate that constructing the URI with the given independent components correctly rebuild a valid URI. (validation rules are scheme URI specific) The article tries to highlight that having all URI components valid does not mean that the resulting URI is automatically valid.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I know this doesn't help answer the question but....why would you write code in a non-English language? All documentation for programming languages is in English and all programmers seem to communicate in it. Writing code in some other language just seems crazy.
Your first method is more in-line on how it was done/still done in languages like C and C++ where you would pass an error container to your functions like doSomething(int param1, str &amp;error) {...} In using exceptions to control errors you can easily separate different levels of exception. I don't know if you've checked a few libraries, but they all re-implement `Exception`, `RuntimeException`, `InvalidArgumentException`, etc. It might seem pointless, but it serve a purpose, you can then differentiate between your own exception and those of other libraries. If you throw an exception using your namespace like `MyApp\Exception\Exception` which extends the basic PHP `\Exception` you can then catch your own exception and let others go through: // UserModel.php namespace MyApp\Model; use MyApp\Exception\Exception; class UserModel { public function save($data) { if (empty($data)) { throw new Exception("You did not provide any data"); } // perform save return true; } } // UsersController.php namespace MyApp\Controller; use MyApp\Exception\Exception; class UsersController { public function save() { $userModel = new UserModel; try { $save = $userModel-&gt;save($_POST); echo "Success"; } catch (Exception $e) { // model exception echo "Failure:&lt;br&gt;" echo $e-&gt;getMessage(); } // not catching other exception than your own } }
this is somewhat newer (I contributed). They need to work on their SEO if google didn't lead you to it: http://www.loggly.com/ultimate-guide/category/php/
The other problem here is that the constructor should not be a factory for Logger objects
Exceptions provide a way to bail out of the current method at any point if for any reason the requested action cannot be completed. Say your save() method had 10 different steps, and any one of them could fail for a variety of reasons. If one of the first steps couldn't be completed, then you probably don't want to even try the other steps, so throwing an Exception allows you to exit the method early. In OOP Terms, a method's interface implies a contract - give me this parameter and I will do this thing / return this thing. If the method can't do what it promised to do, then an Exception is a way of letting the caller know, which is cleaner than returning false/null etc. It means you don't have to check the return value of every method, if you didn't get an exception thrown, then you can assume you got the right kind of value back. Exceptions automatically travel up the stack. This is useful because you get to decide where you want the exception to be caught, it might not be the calling method that catches the exception, it might be several layers further up. That said, there is a performance penalty that comes from over use of exceptions, so they should only be used for 'exceptional' behaviour - something that should not normally happen. Sometimes it's entirely appropriate to return a boolean success/failure value.
RabbitMQ - It's fairly simple to setup and well established.
I think "$userAmount-&gt;add" implies that I'm adding to the same object. Once it goes immutable I think that the method should be called "plus" instead. In my mind this is the same line of thought that "setters" in immutable objects are sometimes named like "withFoo($newValue)", because they return a new object with that new property value instead of setting it into the object itself. Keep in mind that I'm not a native English speaker so I might be getting confused with the add/plus semantics. Also I suspect that part of the problem in the first examples comes from the fact that it's returning $this from a setter for a "fluent interface". It wouldn't seem so confusing to me if this was used instead: $userAmount = Money::USD(2); $userAmount-&gt;add($userAmount-&gt;getAmount() * 0.03); $markCard-&gt;withdraw($userAmount); $alexCard-&gt;deposit($userAmount); // It's clear it's 2 + 2*0.03 Nevertheless I do agree that immutable objects prevent unexpected behavior that are hard to debug. I'm just not sure those are the best examples.
There are lots of video courses on Youtube and on the various code school sites that will teach you php from scratch. Some are free, others are paid, though most of these have free previews or the first few lessons free. Front End Masters (training) https://frontendmasters.com/ Egghead.io (training) https://egghead.io/ Udemy (training) https://www.udemy.com -Courses are charged individually Code School (training) https://www.codeschool.com -Cheesy songs, good live exercises Scotch.io (training) https://scotch.io/ -javascript, node, laravel, wordpress Skillinifinity (training) http://blog.skillinfinity.com/ -wide range of non-computer topics ShawAcademy http://www.shawacademy.com/ -wide range of non-computer topics 
There's a difference between perfect code and secure code. No matter what state your code is in, you should always try to be as secure as possible, which could easily be done in your case.
The point of that example is that it's not supposed to be depositing the markup in Alex's account, but because it's mutable it is, and it's easy to miss.
Did you skip the last sentence of the post you replied to? &gt; Nevertheless I do agree that immutable objects prevent unexpected behavior that are hard to debug. I'm just not sure those are the best examples. He or she agrees with the idea behind the use of immutable objects, but thinks the blog used a silly example. I absolutely agree with them. The code in the money example was very strange. I can't imagine why a class method called "add" would ever return a copy of the object it gets called in. That's just strange. I would expect that method to return void or perhaps a boolean indicating the success of the operation. With that in mind, the code would be re-factored in the way /u/mikedelfino re-factored it, and suddenly the bug becomes incredibly obvious and easy to spot. Why am I depositing the same amount I'm widthdrawing? Duh, because you're literally using the same variable for both operations. The idea behind the blog post is still sound, but the money example did a poor job of illustrating that. It only illustrated that confusing code is, well, confusing. But that has nothing to do with the fact that the objects were mutable. That code could be made incredibly readable with mutable objects if it weren't designed so strangely.
If you're commenting code extensively then there's a chance that you're (a) explaining the obvious or (b) writing bad code that is not self explanatory. If (a) then you should look at your code, and if you can see what it does by reading it, don't comment. For example: // increase counter $counter++; If (b) then it's a bigger issue and you should learn more about fundamentals of programming. Namely identifying what you're trying to achieve and coming up with the simplest algorithm that achieves it. A good book that teaches it is Code Complete. Generally the only comments you need are docblocks — comments that document what a module, class, method, or property is for. If you're commenting on the program logic code then your logic is probably overcomplicated. _Probably_, because there are cases when logic is complex and it can't be simplified, but these are usually rare cases. EDIT for completeness: if you insist to keep a different set of comments, you could keep them in a separate branch that you don't push to your public repo. EDIT 2: if your private comments are about how you came up with a solution, it would be great to blog about it. That way you can refer to it yourself, as well as serving the community by, potentially, providing a solution to other people who may be facing the same problem.
It's more along the lines of explaining why I did something a certain way as it pertains to possible future enhancements. For example, if it's a commercial WordPress plugin it would be nice to make a note like: "Note to self: I chose this pattern so that it will be easier to add feature Y when feature X is complete". Basically, it would be helpful to flesh out my ideas and remember key points that wouldn't likely be relevant to anyone else - or at least not yet. Another example would be working with a clone of someone else's poorly documented project. There could be personal comments to myself e.g. "This section does Y with X even though it's a poorly written jumble of WTF". Sure I could maintain a separate branch in both cases - it would be cool to be able to have personal annotations built in to the IDE though. Kind of like how Dash.app lets you make annotations in the margin about your docs. 
I'm looking for an integrated solution in PHPStorm. Of course I could maintain separate files for docs :-) PHPStorm bookmarks come close to being what I want. There's an indicator of the comment (bookmark) in the margin which you can hover over and read. Only problem is that these can only be very short. https://dl.dropboxusercontent.com/u/17065165/Screenshot_f81ae.png 
Ah. yeah those are stored in the .idea directory iirc.
In my opinion, the ease of use is already better than Doctrine (if you disagree tell me why), and performance in write-heavy use cases is better. If this is the only issue that makes this library "bad" for you then I accept pull requests :) I don't have time right now to do it myself. My guess is that it would take perhaps 40 hours to get to a workable solution.
pre commit hook that strips your comment before push?
Why can't you share these comments publicly? &gt;Basically, it would be helpful to flesh out my ideas and remember key points that wouldn't likely be relevant to anyone else - or at least not yet. The way it sounds, you'd be better off letting people read them and potentially letting them help you in the future. Ideas become greater with an extra pair of eyes.
I see what he was going for now. I don't think the add returning an instance of the class is unreasonable overall though, it's the way DateTime works, and if you're going to have a mutable and immutable version of a class like there is with DateTime, it's required in the mutable version to keep them interchangeable.
My personal projects have used RabbitMQ and at my former workplace, we used RabbitMQ to broker messages between applications and services. 
&gt; but a good portion of the comments won't be useful to anyone else. Wrong. Having comments is better than having no comments.
I *do* see your point here. Just the weird part is that the callers in the first example need to have if () statements applied to check for null *before* calling getShippingCost. If it's just one place calling it, not that bad. If it's 10-100, the null object interface might be better. And it might only be 1 place calling it now, but 1 year from now, maybe 10 places are calling it. It's a matter of adding 1 additional test branch required for the getShippingCost function, versus potentially many for the callers (again depends on the application's structure and use cases). If you have a bunch of code that is generally like this: if (thing is not null) { doOneThing(thing); } And when this same pattern is repeated a lot (5 times, 10 times, and more), that signifies a need for the null object pattern. We want "thing" to be available to call on without checking for null every single call. Yes, the doOneThing() function will need an additional if () logic check. But, probably better than 10+ if statements littered around the code. Also in your 2nd example I might be inclined to say at the top of the function: if ($shippingAddress-&gt;isEmpty()) { return 0; } Since the shipping cost for a non-address (digital goods) would just be zero. 
"editing a php CLI script stored on a remote server" - why do you need to regularly edit and debug code remotely?
I think you should re-read the post. I clearly said "I love documenting my code extensively".
I thought of this and so far it's one of the more tenable solutions I've come across. Good idea.
You can't tell me it wouldn't be occasionally useful to have private comments. I mean, literally every professional does this - it's akin to making margin notes in a scientific paper, notebook or textbook. Yes, of course 98% of all commenting would be public but there are cases where notes to yourself are useful. Especially as you get older. Or you are branching into unfamiliar technologies. And what about this use case: &gt; Another example would be working with a clone of someone else's poorly documented project. There could be personal comments to myself e.g. "This section does Y with X even though it's a poorly written jumble of WTF". I'm dealing with that right now… and in this particular case it wouldn't be appropriate for me to add a whole bunch of comments but I do occasionally commit some code. We're talking a single function comprised of 3000 lines of spaghetti code here. I'd love to sprinkle comments around for myself explaining what the hell is going on because there are none. 
I use a lot of shell scripts. This is saved as a .sh script and I simply run this in SubLime (command+B on Mac) ssh root@yourserver.com -t "cd /srv/users/serverpilot/apps/asknicely/app;php ./yourfiletorun.php" The output is shown in SubLime or in your terminal (I assumed your are on Mac/Linux) It doesn't debug your code. But I don't know if you need to if it's working correctly with your local install. I have massive amount of code and there is no need for me pretty much ever to debug on the server. 
I agree nearly 100%. It's just that there are specific cases where notes to yourself are useful. Especially as you get older. Or you are branching into unfamiliar technologies. Or trying to make sense of someone else's code base. 
I was checking the guzzle implementation and wow. https://github.com/guzzle/psr7/blob/master/src/MessageTrait.php#L108 its using a known bug to achieve the requested functionality. the `headers` property is private
*So i just wrote a huge text wall and after that i finally came up with a good example, fuck me. Here is the new answer:* If you learn a new language and feel the need to comment specific functions or operations you probably don't want to do this directly in the code because you will also need them elsewhere. Better write it down on a notepad and put it on your screen or above your keyboard. Also most IDEs will explain to you what this specific php function (i know there are a lot of them :D ) does if you hover it. If you need to note why you used this function and not the other one that does nearly the same, make it a php comment and commit it to the repo, someone else may need to rewrite this section at some time and could stumble about the exact same thing you messed around with. ------------------------------------------------------------ **Also here is my original text wall, have fun:** I think i finally got what you mean. For example you are getting into a new project and the lead developer introduces you to some stuff. He goes with you through the script hierarchy (in which order which scripts are executed) and explains the most important one. Because you like to forget stuff (doesn't have to do anything with getting older :D ) you write it down on some notepads but there are special things in the code you would also like to take notes for but this would of course not work out with notepads, because you would never find the right one in time. So yes, such a feature would be nice but i still say that if there are parts of the code that are not easily to understand (also if only for a newcomer), just comment them and push it to the repo. It will maybe look stupid to some people that can read what this specific block is doing without problems but there will also be people like you (or me or another developer) that don't see it immediately and therefore the comment is great. If you publish something under open source it is most of the time your own code and nobody will judge you for some comments you did in there. Most times people will just be happy someone already created a project like that and they don't need to do it themselves.
Try using scratches: https://www.jetbrains.com/help/phpstorm/2016.1/scratches.html
The QA person in me says you should just rewrite the comments and push them to the main repo but i know that this is not always possible timewise. Also it's probably a huge fuck-you to the original developer if you push a commit named "Fixed docs" or "Better docs". But other developers may have the same problems as you so consider that if you have some free minutes. Other than that having your own docs integrated in the IDE sounds actually good for this use-case. If you for some reason really can't edit the original comments and you are using git, you could also consider creating a new branch, fix the comments in there and then cherry-pick every change you did after this (probably less work and more reliable than writing a pre-commit hook)
Thank you for genuinely trying to understand what I'm trying to say - Which to summarize is that: if post-it notes and comments in a notebook are a good practice... Then why are "digital comments" that only I can see somehow bad? They are basically digital post-it notes that I can "attach" to specific points in the code. With the added benefit that I don't have to switch contexts (pick up my notebook) to read or write them. That's all I'm getting at. I don't understand why anyone would suggest otherwise - except that maybe I didn't phrase my question well enough :-) 
Will definitely try this and see if the added complexity is worth it. I'm a little worried about making a mistake and pushing a comment like "// This code is a jumbled clusterf*ck because &lt;lead dev&gt; is an idiot" ;-) I guess I'll just have to watch what I say, just in case. 
To much chinese chars, disgusting. 
for future reference, you can try what I did to find it quickly #because they said to look in /etc cd /etc find . -name policy.xml revealed it's location in a split second
What are you even talking about? I have an i5 2320 and 8 gb of ram and PhpStorm is sluggish as HELL on my pc, even with a clean and fresh install of windows its unbearable to use.
This is really interesting. I like this approach when it comes to programming
I'd recommend quiver, the programmers notebook. It's not project-specific, but it's one of the best programming-related note taking apps I've seen. 
well psr5 was a huge fiasco and from the way I see this, PSR7 will be very difficult to implement in a real life environment specially when dealing with things like rest apis.
This is over a year old and reposting it is FUD.
Here's maybe a stupid question. Imagine I have an API call to update some user details. The call is a post request with a user id and an array with new values. My preferred way of writing this would be (pseudo code, ignore the lack of validation): //Get user if (!$user = $userManager-&gt;getUser($userId)){ return $app-&gt;json("User not found", 404); } //Set new values $user-&gt;firstName = $postBody['firstName']; // etc. //Save new values if (!$userManager-&gt;updateUser($user)){ return $app-&gt;json("Error saving", 500); } //Return OK return $app-&gt;json("ok"); Here, my `userManager` just returns the object, or false on failure. I rarely get cases where I think an exception would be better. As the same code with exceptions would just be more bulky and not really offer any real advantage. Am I wrong here?
Good call - I'll have to try this. Thanks!
PSR-7 has been out for a while now and quite heavily used. I would be interested to hear if anybody reading this thread has had difficulties? Personally, I've used it in a variety of projects without issue. The only issue I've encountered is people who are used to mutable objects being confused by the API (which is actually quite a significant issue).
as you said the author never mentions performance as an issue against inmutability, there are other issues specially about usage.
PHP interprets "XeY" (where X and Y are numeric digit[s]) as a number in scientific notation. Thus in PHP: "01e4" == "001e4" == "1e4" The answer is to use '===' and '!==' and make sure you have the types right.
Key argument: &gt; Should the Union Types RFC pass, we will be able to use null in union type declarations. It would be strange and inconsistent for function foo(): User | null to be valid but function foo(): null not to be, and it would be redundant to have both null and void with identical (or almost identical) semantics. Personally, I liked the void return type, but thought that it should cause an error if people attempted to read it into a variable. After all, why would you ever check the result of a void function?
I'm familiar with beanstalkd, but not supervisord. How would one run a PHP worker with it?
Ah good times, I remember being very surprised too when I realized that: http://stackoverflow.com/questions/3884493/why-protected-and-private-attributes-are-accessible-by-same-class-rather-than-by But that's actually logical and done this way across many languages.
Yes but that definitely makes "the best comment" not relevant though.
Btw do you mean PSR-6 (cache) rather than PSR-5 (phpdoc)?
It's only a short version that linked, while detailed explanation is not available anymore
Offtopic tip: use ` &amp;&amp; ` to separate consecutive commands instead of `;`. This way, if one of the command fails (with non-zero exit code), it won't execute later commands. 
Wouldn't [nullable types](https://wiki.php.net/rfc/nullable_types) be a more elegant solution to that? Then you would never need "user | null", but would just write "?user". Personally I think that a returntype of "void" is semantically different than a returntype of "null". Like the difference between an empty set, and a set containing only the empty set. There is a semantic difference between a function always returning null (which could be useful when using functions as interchangeable values), and a function where it is semantically invalid to look at the returned value. So I don't think "void" should be removed.
You shouldn't SQS in your application layer. SQS is an AWS service to help you program the AWS infrastructure. 
isn't tha tunnel vision? you take a minimal part of an argument and then extrapolate it to the entire argument
Private methods and properties are not just visible to the one object instance, but the *class*. Java and C# both allow this.
I'm just saying that you quoted this as the best comment, but this particular comment is actually not relevant.
The first example has a not equals operator though? It seems to me that the question is why is the second one considered equivalent and not the first.
Yes, you are right. I mistook the question myself. My apologies. 
You're welcome. Here's more: 1. If file that you going to run doesn't depend on current working directory, you can run it as `php /srv/users/serverpilot/apps/asknicely/app/yourfiletorun.php` 2. If specify interpreter in the file header and allow execution via `chmod +x filename.php` you will be able to execute it directly, like `./yourfiletorun.php`. Header format is `#!/path/to/binary`, see [this example](http://pastebin.com/s1FYMyne). Your location of php binary can be different though, use `which php` to find it.
In fact, he is getting downvoted for taking this code too literally. While your link is not equal to the question asked (there is "e", not "a" in the the second statement). Heck, what a confusing question. I mistook it at first myself. 
But if you'll write `return;` there will be actually `null` there if you try to print it. The same is about property defined without default value - it will have `null` value. With that in mind for consistency I'd rather avoid introducing `void`, but after using Hack a bit `?user` seems pretty natural.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
an URI is composed of a hostname component not a domain name. According to RFC3986 hostname are a subset of domain names and hostname labels can not contain underscore. So it is not a problem or an issue
But unless I want to keep the old response (and why would I?), then isn't it just treating immutibility as mutable anyway? How is `$response = $response-&gt;withHeader($header)` any better than `$response-&gt;setHeader($header)`?
Though i always managed to get a PHP environment up and running on my Mac with brew, i'd now recommend something more portable and flexible with virtualization. Homestead https://laravel.com/docs/5.2/homestead offers a good vagrant environment geared towards laravel development. Or you might try out the much hyped docker which has gained a lot of attention lately. https://www.docker.com/ - i'll give it a shot right now.
Void Return Type already had a vote. If people wanted null instead, they would have voted against that RFC.
This has some information on how to set up https on Zend Server for windows. I had a couple of issues and thought I'd share how I got through them. Cheers
SQS is `simple queue service`. It's not there to program the AWS infrastructure. https://aws.amazon.com/sqs/
Hmm, what kind of sluggish is it? Typing latency? I'm runing laptop with 2nd gen i3 (2328m) + 8gb ram and it runs well even with a lot of apps in background and quite big projects with highly cancerous code and ZF 1. 
&gt; After all, why would you ever check the result of a void function? This is actually somewhat common. Take a look at this proof-of-concept for an [`Option` class](https://3v4l.org/WCkeh) with the `Match` method in particular. This function does not care what you return from either `callable`, if anything. It just passes it back for the caller to decide.
Unit testing anything that has a global dependency is a struggle, ideally the controller would be re-worked to not access the $_POST data So if, for example, you have: // router.php $response = $controller-&gt;index() // controller.php function index() { $userId = $_POST['id']; } You could look at re-factoring by // router.php $response = $controller-&gt;index($_POST) // controller.php function index($post) { $userId = $post['id']; } Now you can test the index() method with any crafted array you want.
[removed]
The problem I have with this is the notion of type. I don't think of `null` as a type. In my mind, it's a value. You wouldn't specify that a method returns a value of 3 or "Howdy". You'd say `int` or `string`. `void` is a type, like any other type except that you can neither derive nor assign a value to it. It's valuable for the purposes of generating an error if someone does try to use it as a value. To the point that Thue brought up, allowing for nullable types would be a better fit. The notion that a variable of some type can be assigned a value of `null` makes a lot more sense to me. As to the question of how to specify `null` as a return type, I would say we don't. The only reason to do this is to support union return types, which I still believe is a bad idea. If `null` is one of a set of possible return values, then don't try to promise anything. Just document it. It is a dynamically typed language after all.
That makes sense. Where the issue lies is in the model //Controller.php public function create($_POST){ $model = new Model(); $model-&gt;createSomething($_POST); } //Model.php public function createSomething($data){ print_r($data); } The function in the model always fails because technically there's no post data coming from the unit test. I tried forging it, but that doesn't work either.
Overview of best practices in various areas (http://www.phptherightway.com/) Debugging strategies (https://www.phproundtable.com/episode/debugging-is-more-than-var-dump)
Honestly, PhpStorm is what you're looking for. You may just have to try a few installs and read up on a few of the ways to optimize. But PhpStorm is the best tool I've ever used for PHP. Have you considered dual-booting Ubuntu?
This is really the same issue. Your controller should ideally not be accessing global state and instead should have that state passed in. If that change is too large right now [PHPUnit does have methods for handling global state](https://phpunit.de/manual/current/en/fixtures.html#fixtures.global-state).
&gt; that does not mean that you should be relying on that accidental behaviour. Just for clarification here: this behavior in PHP is not accidental. It's purposeful and has been there for years.
It depends on how your framework is set up. Ideally there is a specific place which is responsible for bootstrapping the request by collecting the various globals and passing them into whatever is running the rest of your request as a dependency. This data would pass down to other parts that need it (such as your controllers) as a constructor or method parameter.
That's just my copy/paste list of every school I've looked at. I've been mostly working on Javascript, so some may be more JS oriented.
Why not Python 2.7?
I think the bigest problem is that you can not easily implement an immutable response object into an application which was designed for a mutable response (because you have to return the changed object). This is probably also the reason why the adoption rate is so low. Another thing is they say its immutable but actually only the headers are immutable the body is not. While I would love to have an standard HTTP request/response I think the current design is flawed. AFAIK no other language has an immutable HTTP request/response. I would like to see an open discussion to reconsider the design decisions.
Well that seems like a mistake on the voters' part. The RFC clearly made the case for void and against null, so they knew what they were voting for. If people really wanted a "null return type" why did no one make an RFC made at the time? Honestly this whole thing is a mess, types are being added in such a hodgepodge way. Instead of separate RFCs for void type, nullable types, union types etc, people need to sit down and look at the full picture and figure out what's the best situation overall.
thanks. 
I actually *did* have one in the works and I asked the RFC author a multiple times to not go forward. She did not listen, or at least decided to do it anyway. I did not have enough time when it was going on to contest it.
Maybe. But isn't it prudent to check if one already exists first? That's what I'm doing.
What i noticed so far is that, you said you used it in production, but yet "Yep. There's tons of vulnerabilities. ". I Think this two things can't go one with each other. Correct me if i'm wrong.
Not really using a framework per se. It's just a simple router. I'm at a loss here. No clue how to get POST data into my models from controller tests in phpunit. Looked around the web and most just say throw data in $_POST...
Homestead is also branded with Laravel, and the documentation for Valet has a "Valet or Homestead" section. Seems like the documentation is pretty clear about Valet's use case, so I'm not sure what the problem is.
The docs say it’ll use homebrew’s php70 package. It’ll just be using `php -S` as oppose to an actual webserver.
Is it better than Vagrant/Docker? No. Is it better than PHP builtin server? probably. If being incomplete is a reason not to use it, then PHP should have never had a builtin webserver too
I've got a 128gb ssh and a slow Mac. Vagrant isn't for me.
&gt; Personally I think that a returntype of "void" is semantically different than a returntype of "null". That was certainly the argument of the RFC that saw it added. My take is that "void" is a special case where neither union nor nullable types are particularly relevant. For all *practical* purposes, `func(): null` and `func(): void` are the same, even if you want to argue about the semantics between the two. But in the context of union types, `func(): User|null` would mean "I will return a User or nothing" where `func(): User|void` is logically invalid. `void` (historically) means that under no circumstances will the function return something - so `type|void` is saying "I'll give you `type` or nothing, ever", which just doesn't make sense. It implies a sense of permanence: `null` is a lack of value *this once*, where `void` is a lack of value period.
I think I understand what you are saying but you don't seem to understand what I am saying. I'm saying that the Match method does not care whether it is a maybe/option type. It doesn't care if anything is returned at all. If we had void semantics that people seem to be asking for I now need two methods `Match` and `MatchNull` *or* I have to wrap the callable. Neither of those are improvements to our current semantics. The end result is more code and no power gained.
Staging server FTW.
Wasted time FTL! Do you also want to fix the bug on your staging environment? Or faff around trying to fix it locally without knowing if the fix has worked until you deploy again?
What would you expect there to be assigned to a variable if you capture the "return" type of a `void` function? `null` means the lack of a value, you can't be "null-er". IMO the best way to think about it - or what I would propose if I was writing an RFC - is that `void` is invalid in union types (e.g. `function foo(): User|void` is a compile-time error). Null could be valid, and nullable types (`?user` or `user?`) are basically a macro. Is that redundant? Maybe. It's not what I'd design as part of a comprehensive type system, but I'm in the "something is better than nothing" camp. Having a follow-up vote before 7.1 is feature-locked that cleans up the debris from the half-dozen or so type system RFCs would go a long way. General wisdom seems to say that smaller, more scoped changes are likely to get through, and overall comprehension suffers as a result. It's quite unfortunate, really.
That is one major drawback to using a VM, indeed. The resource consumption can be kept quite small though, including the disk usage. I only have a 250GB MacBook Pro, though it's only a couple of years old, and has a modern i7 and plenty of RAM, so resources aren't an issue. Perhaps you could give Docker Machine a shot. You do still run a VM, but you could make it a very-low resource usage one. The Docker Machine VM uses an absolutely tiny image, and the entire OS is kept in-memory when it's up. Then you can spin up a ton of containers without using that many more resources.
It's for quickly looking at projects. Taylor made it because he was tired of configuring his VM. Don't knock his projects when there's thousands of much less interesting projects out there. It's not like he's asking you for money.
No problem, OP's comment is a _little_ cryptic. The problem is that [`.dev` is now a proper TLD](https://www.iana.org/domains/root/db/dev.html), so it shouldn't be used for local development hosts. More info here: https://iyware.com/dont-use-dev-for-development/
My home machine: i5-2500k 16GB RAM (Though at one point I had 8GB and it ran fine as well) Work laptop: i7-4800MQ 8GB RAM Never had an issue with performance and I'm the type of person who has way too many processes running at once.
http://xip.io is nice for local domains; myproject.127.0.0.1.xip.io if you use your lan ip you can usually access your local sites from any device in the same lan, depends on the router
Side note: I don't think it is strongly enforced here, but /r/PHP is not actually a support sub. /r/PHPhelp is better for that. 
I don't really see how it's poorly implemented other than not being Docker. What is it doing un-sensibly? If you need an exact mirror of production than by all means `brew install virtualbox vagrant python &amp;&amp; sudo pip install ansible &amp;&amp; vagrant box add ubuntu/trusty64 &amp;&amp; sudo /etc/hosts &amp;&amp; vagrant up`. I spend enough time fighting that massive stack of tools at work; I would rather have something that just works at home.
The main reason for why this is a poorly implemented solution to an already solved problem is in the comment you're replying to: &gt; you're more likely to not find bugs in development that may exist in production There are also other numerous advantages to using a Vagrant / Docker (or other similar alternatives) environment; for example, if you are wanting to test multi-machine, distributed projects then it's way easier to do that (though I'm not saying that's the problem Valet is trying to solve - just, why purposefully start with a tool that is mediocre when there are better alternatives, that are still easy to set up and get running with when your project could grow easily and the other tools would have supported that growth). In response to: &gt; I spend enough time fighting that massive stack of tools at work; I would rather have something that just works at home. You only need to spend the time once to make your development environment work per-project, and can maybe even just copy and paste it the next time. When I've used Vagrant before I've set up a standardish PHP environment that I'll maybe have to change a couple of variables in to get up and running with a new project. This environment's configuration management can then also be used in production with a few flags to control settings to make it more productiony. With Docker, it's far, far easier. I make a `docker-compose.yml` (it's super simple really), that's insanely simple, then type `docker-compose up` and I'm up and running. Next time I go into the project, I just `cd` into the directory, and `docker-compose up`, and I have a fully running server in a few seconds. There's less configuration, that's managed in the images, they start way faster, and they use less resources - it's great.
Quite a large ssh session you've got there :)
Hahah wow chill, I said more or less it isn't for me, there are (in my opinion) better alternatives out there.
It was a hypothetical bug; I've seen it happen many times in the past thanks to inconsistent environments. You can avoid wasting time trying to fix bugs caused by inconsistent environments by simply having consistent environments to begin with. It can even be something a bit silly like using a feature of a newer version of PHP that you're using locally, and not having that language feature be available in a production box. Or perhaps it's a bug caused by platform differences, some of them are quite subtle after all. I've never used Homestead, perhaps you could tell me some more about how it works; can you choose a PHP version to run? Which web server you use? Which database server? etc.
Poor clients.
Lol. 
So... why?
I'd like to see something like this for classes. Something that would all you to write a DateTimeExtensions class and register it so that all DateTime instances have the extra functionality. Similar to C# Extensions. EDIT: Clarification
There is some very active development work ongoing to ease that pain :) - it's in private beta currently, I've only tried the Mac solution (they're working on Mac and Windows at the same time, with the same ideas in mind).
wow, laravel author just discovered dnsmasq? oh, I see, It just needed a new name starting by laravel blabla funny
damn that zonda.
Probably, my point was not very clear because of last sentence. I'm all for nullable types without any doubts, they are very natural to me (I had some Hack experience when implementing support for compressed Phar in HHVM, which should land in master soon). But I'm strictly against `void`, since IMO `null` already sufficient in PHP context. So I'm wholeheartedly support this RFC.
Thank you, that's very detailed!
This is great, I've been using ngrok for quite some time. It's very well-equipped for webhook testing and mobile app backend development.
See the documentation.
Totally legit. I like `void` for its naming consistency with other languages, but I see how many would find it out of place in PHP. I'm pretty indifferent tbh.
OP's question is pretty vague...
You're basically famous now. Mind sending me an autograph?
The problem is that Valet is relying on the built in PHP installation as OC said. For a team working on the same project and hosting it this could cause a lot of problems as each dev could have different PHP versions, modules, and configurations. Even with homestead it can still become inconsistent. I agree using Docker as a solution to keep environments consistent and have a registry repository of the images for PHP, OS, DB, etc. I can't rate Docker highly enough personally. 
I don't think the intention here is that it _replaces_ the workflow for established projects, or serious projects. It's about dropping the barrier of entry when you just have an idea and want to hack on it. I'd imagine that if you figure the idea has legs, you'd at that point go ahead and migrate your dev over to a virtual machine that mirrors production...but if the idea doesn't have legs you've not wasted precious time setting everything up, editing hosts files, etc etc etc. wonder if /u/utotwel or /u/adamwathan have any plans to _automate_ that rollup... all the necessary information is there so it could perform all the necessary homestead modifications etc.
I was using a wrapper script to run the PHP worker as a service, and then auto-restarting it using Monit. It wasn't that reliable so I had to monitor the age of the log files as well to ensure it was working properly. Not the best solution, so I'll be switching to this. Thanks again.
When you say "support" what exactly do you mean?
If people use it wrong, that is their fault. I would find value in using this to share a quick prototype with colleagues or friends. If people mistakenly use this as a full fledged dev env, it's not any different than failing to use Laravel itself correctly.
That's not a problem, it's a different use case. What's the point of complaining that a tool doesn't do what you want it to do, when there are plenty of other tools out there that fit your needs? Are you saying that something like this should not ever exist in the world?
The truth of the matter is that all of the skill exists here and I would be surprised if he/she got an descent answer there. I mostly see really beginner questions there and not horrible but.. mediocre answers there. If you guys (/r/PHP) would also frequent there it would be nice.
Extract whatever unit of code that uses the $_POST values into its own method, and pass the $_POST values into that method as parameters. Then unit test that new method, passing in whatever values you want instead of pulling from $_POST. Alternatively, just do `$_POST['whatever'] = 'whatever';` in your unit test's setup method, or wherever makes sense, to fill in the expected values. You're better off going the first way though. I wouldn't worry too much about testing your controllers at this point. Edit to say, ultimately you're trying to unit test something which isn't a unit. Controllers do too many things and interact with the outside world too much to be easily unit testable. You're better off unit testing the small, discrete units of works that the controller activates, with isolated dependencies. Look into integration/acceptance/functional testing to cover controlllers, IMO.
Yeh i think it's cool.. especially if you're trying to validate an idea - 1. hack some code, 2. share it with your friends and get feedback... 3. decide if it's worth going on with. I think once you start going on with it, and you start having concerns about production and dev envs being close to one and other, it'd be good to have a command which shipped your valet up to homestead - that way you entirely bypass the need to configure the thing. The whole workflow becomes "hack on valet, share with friends, upscale to homestead in one command, keep working". A lot of the "cool" things in valet would work in homestead as well i'd imagine - automatic serving of entire dev folder to magically mapped domains, sharing via ngrok.... so the upscaling would simply be adding new capabilities and aligning with production servers... 
lalala
My comment still applies. In the ideal case you'd change how your code works so that data like `$_POST` is collected when the request starts and is given to some object or function that handles the rest of the request. All other parts of your program which need that data takes it as a dependency. If that can't be done, PHPUnit can handle global data as explained in the link I provided. Without seeing code it is impossible to help you more than that.
Same here, having only 4GB RAM doesn't help.
Nah
Damn right, there's often heaps of negativity instead of simple appreciation. I don't understand that attitude at all. Seems some developers have their panties in a permanent twist. Maybe if they spent less time endlessly configuring their setups they could spare a moment or two to build a *better* open source system. Oh wait, then they would be on the receiving end of negative feedback...
Yes, like /u/Rican7 said, with a small addendum: `.dev` should not be used in a private network at all, not just for development. So for local development, you should pick other tld, which doesn't exists in public registry. When Amazon withdrew their application back in 2014 for .dev in favor of Google, I knew they will get it, so I gradually migrated my development environment to `.local` ; I don't like it as much as .dev, but meh. As a rule of thumb: if you see that a domain resolves to 127.0.53.53, it means that there is a collision between a fully qualified domain name and a similar domain used locally (_via DNS server hosted inside your private network, or your hosts file_) and you should pick another domain. $ cat /etc/hosts | grep reddit reddit.dev 127.0.0.1 $ ping reddit.dev PING reddit.dev (127.0.53.53) 56(84) bytes of data. $ dig +short reddit.dev 127.0.53.53 This doesn't imply that reddit.dev is actually registered, but it gives me a heads up that a TLD which until recently it was used only in private networks, now exists in public internet and I should migrate my private network to another TLD.
agree with this 100%. It's incredibly useful if you have an idea pop into your head and just want to cut some code to see if the idea has legs. Or if you're building something super simple and you don't want the headache. It _would_ be good if there was a way to take a "valet" project and automatically roll it up to vagrant though. I can see a case where a small project or a simple hack becomes something a little more "real" and needs all the toys... it doesn't solve the problem of needing to go a bit bigger. 
So `127.0.53.53` is a sort of a "warning"? I'm guessing it still works, but it's a way of the system to tell you there's something wrong?
No? I was just highlighting what OC said which contained some crucial points. Someone replied who didn't see the problem so I reiterated with the use case in question. So I can only assume you read my comment out of context. Or just didn't agree with OC in the first place. Of course some will find this useful in other use cases. As someone mentioned they can't run vagrant because their computer wasn't capable. But I still stand by my opinion. 
I see your point. The trouble is that often the questions asked in either sub are so broad that it's a time-consuming business to answer, often requiring several rounds of interaction. I prefer Stack Overflow for this reason, as much as I'd like to help here - training readers out of overly broad questions is a good thing. 
Use PHPDOC with *@return string|null* for a function/method which returns a string or null value. 
Well if we're talking slap dash then sure. But in my use case scenario, you'll only going to be glazing over what should be an environment that will enforce consistency across the team and/or production. Vagrant (Homestead) is okay, and I'm using it currently at my new job. Didn't stop me already making my own docker environment. It's just more lightweight, consistent, and modular. 
Doctrine?
If you are interested, [This](https://www.fullstackpython.com/) is a good resource for anyone starting in Python or trying to rehabilitate from Php..
Be aware that PostgreSQL’s inheritance is not inheritance as thought in object oriented world. Children rows will appear in parent tables but you will not be able to create foreign keys pointing on parent tables. Postgres inheritance is more like a structural trait, updating the parent table automatically updates all tables using it. This being said, although Pomm is not an ORM (it does not handle relations between entities hence makes harder to implement nested loops), it supports PostgreSQL multiple inheritance system, there is an example here http://www.pomm-project.org/news/pomm-nextgen-is-in-the-pipe.html 
&gt; should not just get rid of for some half-valid technical reasons... You summed up the Php core development perfectly....
Ok i want to keep this conversation going i'm bored anyway. Whats point of moving from Wordpress to custom solution. I know Wordpress, i will go with wordpress. Whyyyy would i even spend time to learn this THING. Wordpress is customizable and there is no tons of vulnerabilities. There is no advantage in thing u made. Got it?
It's a matter of trade off. There's always differences between prod and dev environments, you can't eliminate them all, and for the most part you don't need to... They're practically same *enough* for development purposes, the likeliness of you hitting some problems on prod that you never saw on dev environment is also minimalized with staging phase. What I've found during my experience is that using VMs is far from necessary when you have a small number of projects (with a small variation on dependencies; let's say they all depend on Postgres, Rabbit, Redis, and I feel ok keeping these services at my work machine). VMs have their problems that you didn't mention: they eat memory, they're slow on CPU, memory and disk usage (all three need to be virtualized, advanced CPU instruction sets don't really help with memory and disk), there's an eternal pain in the ass with synchronizing your code (that you write in the host machine) with VM (netfs is *awesome*, yes... no). And all this pain just so you can tell everyone that you use the same kernel and package versions as your production server? BTW your VM can't mirror you production server if it runs OS without virtualization. Docker on the other hand is a nice tool for managing services, for restricting their access to the OS and for running multiple instances of whatever which you wouldn't normally run outside of container in the numbers greater than one. If I had time and *need* for this, I would surely use Docker. But I think you negate your main point of running the same environment as in production, with Docker, because now you will probably have your own flavor of OS that you like (let's say your ops like Ubuntu-server on their prod servers and you like Arch-based distros on your machine) - so now you have different kernels, different log-processor, different service management utilities (init.d vs systemd) - that's all if you run your containers in your host machine and not in the VM of course, but the problems of running VM I outlined above. So basically that's why I prefer running everything in my host machine (I will probably start using Docker earlier or later, when I'll be willing/have time to build images for our projects). I also prefer this way because then I get to set up everything manually which gives me much better perspective on how things run in our project. I don't advocate for not using VMs, if you like it or are willing to deal with their quirks then sure use them. But saying that your environment has to mirror production server as close as possible is a big fallacy that I've heard too many times. It's up to developer to decide how close they want to be, because it's always a trade off between being close and having comfortable working conditions. PS just so you know, this discussion (and me personally) has nothing to do with Laravel or any associated products.
It is achieved using something called dependency injection. Have a look here and pick your favourite: https://github.com/ziadoz/awesome-php#dependency-injection. Personally I really like the third one on the list, container. It is a somewhat advanced subject however, so don't feel bad if it looks confusing at first. You'll find much better explanations online, but here is a crash course: your `public/index.php` will bootstrap your application, usually` Application.php`, which extends the container. In that Application's constructor you register your providers, like so for example: `$this-&gt;addServiceProvider(RoutingProvider::class);` For your specific use-case and if you chose to use container as I said above, you'd create a "delegate" provider, which would let you instantiate request objects that are injected in your controller's action. So your controller's signature would look like something like this: `public function doSomething(SomethingRequest $request)`, and instead of accessing the global $_POST variable, you would get the data out of the request object, like so for example: `$data = $request-&gt;request-&gt;all();` Not only does this provide you with separation of concern and better architecture in general, it also happens to come with a nice side effect: in your tests you can easily mock a `$request` object and inject whatever you want.
This seems like just another useless wrapper for existing technology. Why do Laravel's developers always need to rebrand other people's tools (homestead for vagrant, tinker for psysh etc.)?
Hmm... &gt; even 5ms average response time on a crappy 14$ (2gb ram and 1 slow cpu core) virtual server. This links to the following tweet: https://twitter.com/MarcJSchmidt/status/720919519770910720 The 5ms response time in that tweet is the front-end, i.e. the time it takes to render the DOM after TTFB. The actual response time is everything before TTFB (i.e. the backend number on that screenshot) which shows 73ms. That's still damn respectable, but it's much higher than the possibly misleading 5ms quoted. **edit**: as has been pointed out to me, this might mean that front-end is the public site and back-end is the admin section. If so, then carry on, this is huge performance increase.
I think you might be reading too much into this screenshot. I trust the author of the library/blog to know a little bit what he's doing. Also 5ms is a very credible number considering everything that has been written about PHP-PM, ReactPHP &amp; co. It's highly possible that "frontend" means the public website and "backend" means the backend application. That would explain the numbers too.
Xampp ecosystem bloats your machine with runtimes which is generally discouraged. One of your clients may rely on Redis, other one may rely on Hazelcast, another one may rely on Memcached. You may get a great deal for developing a Wordpress plugin that has to work on PHP 5.2 but your side project has to be blazing fast and you would rely on PHP 7.0. With vagrant you can create two boxes, spin up the one you want to work and that's it. With Xampp, good luck. You need to rely on whatever Xampp bundle brings to you. You won't be able to configure and install another database application or rely on HVVM since Xammp doesn't work that way. You end up downloading a setup.exe and if your project requires something else, you need to install and configure them by hand. You will enter project's website, try to find the download button, click on it, click on setup.exe and restart your computer because Windows tells you to do so. In the end, you will be tightly coupled to your computer which isn't a good thing. Xampp runs on Windows environment so you need to know about the drawbacks. Ideally you want to mimic your production environment so issues caused by the OS differences can be caught during development and not when they reach production. As you grow better, you may work on bigger projects where you work alongside collaborators. You can't tell them to install Xammp, then Redis, then Supervisord and loads of different tools. What if one of the tools in your stack doesn't work on Windows that is crucial for development? Not to mention, installations almost never works properly on Windows environment. I had to change Skype's port each time I had to launch Xammp because both of them worked on port 80. It is one of the most obvious cases. What if your collaborator can't install a specific tool on Windows just because he has a messed up Windows registry and spend hours trying to solve it with zero Google results about the error message? Should he format his computer and re-install Windows? Oh, wait. Before he formats his computer he has to backup his wedding photos into USB. With vagrant I can easily destroy and provision my box in minutes. While it reinstalls my vagrant box, I can switch back to Skyrim and play it until it's done. Using vagrant or provision tools isn't hard or takes time to learn. Xammp is a good bundle, but how is that any better than https://puphpet.com/? You can tick whatever you want and that's it. It is thousand times more flexible than relying on whatever Xampp has in the bundle, plus open source. You should always familiarize yourself with unix environments and CLI. I regret not doing it sooner. A web developer without CLI skills will never be great regardless of his skills. A web developer has to know how Nginx/PHP7/FPM works together, has to be able to configure at least a basic VPS via terminal. Can I switch back to Xampp? Yes. Would it boot faster than Homestead for me? Yes. Do I want to go through installing Xampp/Redis/Grunt/Gulp/NPM/Ruby/Gem/Python/Git/NodeJS/Composer/Beanstalkd/Supervisord/Sass all by hand? Never. As long as your app has no other dependencies other than a webserver/a RDBMS/PHP and if you're certain your app will never require additional dependencies, then you can rely on Xampp as long as you're aware of the drawbacks.
I was with you for two or three days, you didn't feel the smallest ripple in the Force? Our guys in india run XAMPP. Our stack is interesting due to being hosted with Pantheon. So, I am experimenting with Kalabox. For me, the differences are too much to feel good about.
I use xampp for small stuff. it's fine.
frontend=actual website backend=administration (with heavy acl checking, system stats retrieving etc., that's why its 85ms for the live-dashboard) It has nothing to do with client parsing, TTFB etc.. Just the number of seconds representing the time PHP needs from start (request incoming) to delivery (response sent). 
Use whatever makes you feel comfortable with. Period.
This is super informative, thanks. All I can say is that (regrettably) the work that currently comes my way has no other dependencies than those you list at the end. I have not used PuPHPet before though, I will look into that.
I'm using xampp on Windows for years now and I've created huge sites with it. We are using internal database servers for mysql/redis/memcached/elastic any way so I don't have any issues with that. For very specific environments I sometimes have to use vagrant but that's always been much slower for me than xampp so when I can use xampp I do it :)
Let me list some: - "It worked on my machine" - LAMP runs on case-sensitive filesystem - LAMP requires file permissions to read/write/execute files - you're probably running different versions of PHP and MySql in dev vs prod - doesn't scale with team size - how do you synchronize some hacks to the xampp setup for 20 devs? - doesn't scale with multiple projects on the same machine - what happens when one of your projects requires PHP7, but the others can't run on it? 
I have set the Error_logs to on within the ini file but not error logs are being generated 
I have been using xampp and wamp for years in windows and will continue to do so for the forseeable future. They start up easy and quick, and they have everything I need for a dev environment. More than a few times I have needed to add a php extension or upgrade a database version, and it isn't any harder than doing it in a linux environment. Every new project needs a new vhost or two and that takes maybe 2 or 3 minutes to add. It *is* bloated, has a ton of extensions and settings I don't use, but it doesn't really matter on a dev environment. I get why people say that dev should match production, so that you don't get errors about missing or incorrectly configured files, but I have yet to have that happen. Our production server is lean, stable, and geared for supporting several thousand simultaneous users, using caching and sessions stored in cache on remote machines. We have spent hours and hours tweaking and settings, customizing memory usage, creating processes to monitor settings and services. I could mimic this with VMs on my machine, but what do I gain? I know the modules installed on my PHP and Apache setup on the server, and when I release a new feature to our testing server (which mimics the beta and production servers) I know immediately if modules are missing or incorrectly configured. The only sure case for using Vagrant is if you are freelancing or working with multiple companies who want a lot of specific modules and configuration that you will not use in future projects. Would you really want to install both memcache and redis on your computer and tie them in, or mysql and couchdb, mongo, cassandra, mariadb, etc, etc... You would have a ton of these programs and services running that are never being used, so create a VM that uses them instead and close it when done. So in summary, use xampp, but learn the php.ini and learn the httpd.conf. learn how to add new extensions both in windows and Linux evironments. If you can do that, there is no need to go through all this vagrant stuff for personal projects.
Before learning PHP to do something practical, it would be better to get a handle to how to solve simple problems. The simpler the problem the better. Maybe draw a string to reverse. Maybe have a list of all english words, and then search and print all the words that end in "ing". Maybe draw a triangle. There are very good tutorials, videos, and that stuff, but the real learning will start the moment you create a new file with extension .php and you write print_r($_POST); in it and see what happens, and you treat PHP like a magical toolbox with many fun tools in it, and you try each tool to see how they behave. 
&gt; This may work fine for very small projects Which is exactly what the original poster wanted. &gt; It's difficult to maintain, hugely limits your software options No you are wrong. It installs php just like you would from the website, you are free to install any plugins/extensions you want. &gt; makes switching between different setups practically impossible without uninstalling &amp; installing software on the go and makes sharing exact copies of complex server setups I'm sorry but what? I don't recreate my entire infrastructure locally when I am working on a project. &gt; . And on top of that, you have differences between Windows and Linux which can absolutely break code which behaves "correctly" on Windows and will not work as expected on Linux (and vise versa). Sorry, I haven't see anything that mimics this aside from DIRECTORY_SEPERATOR. Please do explain what works on windows and not linux that is not file-system related.
I just run a 7ft tall rack of servers in my basement :|
To be fair, Vagrant bloats my machine with VMs. I use it because I have to; if you don't build critical things across a mishmash of environments, I'd be leaving it well alone. 
Don't take this offensive but, I'm trying to find a reason to care if he does or not and really struggling to find one :)
What kind of systems are you deploying to? That's my primary reason for using vagrant, I can match my production environment so everything they experience, I can replicate. I also like being able to spin up new instance with different database servers and php versions to test new features. One of the greatest things about using vms is that they're self contained, if you completely fuck everything up just destroy it and spin up a shiny new instance in less than 5 minutes. It's also great for if you use multiple computers (home &amp; office, mac or windows) as you do one config file, commit it to source control then can run it from anywhere and you have the exact same environment. I was using xampp, then wamp for years, the companies I used to work for used those and it was fine. It's only after wanting to learn about new technologies that I came to realise all the benefits there are to having VM's over a solution like wamp.
Or, alternatively, Ace claims to be able to import Sublime tmlanguage files; does anyone know where to find a tmlanguage file which includes PHP 7 tokens?
&gt;"it works on my machine" I've had this problem with vagrant setups also.... &gt;doesn't scale; how to synchronize hacks Don't use hacks &gt;multiple php versions I run different versions on different vhosts with cgi 
&gt; I'm sorry but what? I don't recreate my entire infrastructure locally when I am working on a project. Because you're working on very simple projects, architecture-wise.
This use case is a perfect counter example to you wanting private comments. A comment that explains what a jumbled mess of code does is useful to everyone. I think the aspect you're focusing on to justify the comment being private is the little immature bit at the end "WTF". The simple answer is don't be unprofessional/immature in your comments. In this case WTF provides no extra context or value is just the author complaining.
so I have a data sets that I display on google map. I want to put in something like 100 main st, nowhere, ma and see if you have access to the services from those data sets. Great example is like a cell phone coverage map.
Then I can only assume you didn't understand my comment. I'll explain. Valet is a tool for setting up a native (non-virtualized) development environment. The documentation makes that clear, yet OC calls it "poorly implemented" because it isn't virtualized. So the argument is either that such a tool should never exist (which I find silly and not worth responding to), or that Valet was misrepresenting itself. Hence my reply, pointing out that Valet's documentation seems pretty clear to me. That is what I meant when I said "I'm not sure what the problem is".
Is [Cloud9](https://c9.io/) what you're looking for? 
This is amazing for people like me who use a Mac and hate vagrant
if installing apache with cgi is hacking, call me a hacker, by all means. rsync does not solve any performance issues. professionals have a decent build server that does the corrects tests and don't need identical development environments to catch small quirks in version differences.
I can't comment on Xampp as I've never used it. Vagrant combined with ansible helps me keep my machine clean though. I keep an ansible playbook for each project that automates everything. Then I destroy them once I'm done working and recreate them as needed.
we're comparing local setup vs VM based setups.
I’m not using `sudo` for several technical, personal, and psychological reasons. A lot of systems use it and if it’s well configured it’s okay – But not for me, that’s all :)
&gt; Is DQL abstract from the DB? Yes. You can extend it by [playing with it's AST](http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/cookbook/dql-custom-walkers.html) or using [custom functions](http://www.doctrine-project.org/2010/03/29/doctrine2-custom-dql-udfs.html). I use doctrine with postgres for about a year and I never had an experience to modify DQL. In cases where I need posgresql specific stuff I can just use native queries.
I use xampp aswell... and as you, have wondered if im missing something big when i always found Xampp better suiting and simple to use.
You're removal of 5.6 support made me upgrade an old local box to 7. Then I had to convert a ton of old code to work without mysql drivers! That's how much I love phpfmt. Thank you for creating and maintaining it. 
I used to be a big xampp user. It always worked great. Eventually some issues came up with deploying my work. My dev environment was nothing like my production environment. I switched to a Ubuntu based vagrant box where I can mimic the production environment almost completely. I've had fewer issues since. 
me and my coworkers are using xampp all the time.. I tried to work with vagrant for few months, it was cool in the beginning but then I updated to windows 10 (from 8) and virtualbox stopped working.. came back to xampp. I need something that just works without too much linux hacking.
"Satisfying the interface" doesn't make you compliant. If you were to use an implementation that mutated internal state, that wouldn't violate the interface, but it would definitely violate PSR-7 and make that implementation non-compliant.
Except that they don't, and most of the article was based on bad assumptions and misunderstanding (like the entire "Big Responses" section, where the author incorrectly assumes that it's not possible to stream responses without buffering them in memory).
Don't use PHP on IIS. That's a bad configuration.
I use XAMPP mostly because i tried, many times, install VirtualBox and didn't work. So i just unzip my xampp folder and it's fine for everything PHP related.
I used XAMPP for years. I recently made the switch to: https://mallinson.ca/osx-web-development/ Im much happier. It seems much more real, XAMPP always felt "emulated" in a sense. Ive successfully used Laravel within my setup from above too.
I still use XAMPP when developing websites on Windows and want to be lazy about it. The only major catch is if your targeting a linux server for prod, make sure to turn off case-insensitivity When it comes down to it, it's an arms race when it comes to the concept of developing on as close to the production environment as humanly possible. because we've all faces the problems that happens when theres even a single inconsistency. Have you been burned by a prod environment that doesn't use a particular PHP extension but youve been using it happily on dev? I have. I've also been bitten once twice shy about the case sensitivity thing. So when it comes to doing proper development, you want to turn your dev into the prod machine with just a few tweaks to get your debug style information. If your target machine is IIS, XAMPP is excellent at mirroring the prod, but youd typically want to setup IIS on your machine and see how it's going to run on that. Same with Linux prod. People will do everything possible to make linux as accessible as possible on whatever machine your running at that time, because a grand majority of servers out there are running some flavour of linux. And whether it be LAMP stack or LEMP stack, etc, you just want to make sure that when you push to prod from dev, you want it to be as smooth as possible, without any grabmegotchas being discovered on the live version of your site Docker, Vagrant, VirtualBox, VMWare, Parallels, Otto, etc, etc, etc, etc, etc are all designed to let you do this and as "easy" as "possible", regardless of what operating system you use to develop on. XAMPP is just a quick opinionated way to getting your windows or osx system usable to render some php pages or and perl scripts, without infecting your machine with any of that stuff, and in a way that's in a little sandbox you can eliminate at any point. And trust me, I've tried to go full native, installing apache2, php56, and mariadb on windows and it's a bad time if you download the "wrong" version of something, despite it looking right. The memory issues I faced with PHP alone, drove me completely insane; and back to XAMPP once I spent an entire day removing all traces of the native binaries and libraries off my machine. 
Yep! I can't understand the need for Vagrant when developing with PHP for WordPress. I use WAMP though, with options for PHP 5.6 or PHP 7. I mostly do WordPress themes and one of the stupidest arguments I hear is that "you should use Vagrant when developing WordPress themes and plugins so that your local environment is the same as your production environment". Considering WordPress sites mostly run on shared hosting, this makes no sense. With that said, I do use Vagrant, but only for Rails development. Rails and Windows don't mix well, especially when building gems such as *nokogiri* and *mysql2*. 
i'm on mac os x and installed apache, mysql and php70 with homebrew. because i work on a lot of different projects i use [virtualhost.sh](https://github.com/virtualhost/virtualhost.sh) to manage them. every project has its own folder in ~/sites/ and has its own git repo. example usage: $ virtuahost.sh site.dev # generates new virtualhost site.dev which points to ~/sites/site.dev with [brew-php-switcher](https://github.com/philcook/brew-php-switcher) it is also possible to switch between different php versions really fast.
I setup a docker container that emulates my production server (centos, php, nginx, xdebug) and syncs to a folder on my host machine. Setup is only a few clicks using kitematic, no bloat, and I get to develop on the same environment I deploy on. 
I installed stand alone software in Windows and hack a script as my server runner. My build consists of Nginx, MariaDB, PHP 5.5/6 &amp; 7.0, and Acrylic DNS Proxy for my SAPI. Here's my server runner script, https://gist.github.com/rmrhz/b7b46df13c91410365d8
Symfony1 to 2 was a complete BC break. Whole different project, but it's not really a demerit for the folks behind it. Symfony1 was made on the pre-5.3 era. It meant no anonymous/lambda functions, which meant no dependency injection. It meant no namespaces. The language simply lacked a lot of things that make it great today. When the 6.0 branch failed, all new features were backported to 5.3. It was released in 2009, and it opened a new world of possibilities. Sensio took the opportunity to completely rewrite Symfony, with all the newly-possible best practices in mind. Zend did the same to Zend Framework. This is just not the case for Laravel, though. Laravel4 was out waaaaay after 5.3, but they broke a lot of things upgrading to Laravel5 because they realized they had made many design mistakes.
My experience with ORMs in php has lead me to the believe that they're developed by people who mostly know mysql. Mysql is mostly used as a dumb storage engine and therefore the ORM encourages this use of the db. Using such an ORM for pg prevents the use of most of the advanced features of pg and, at least to some extend, defeats the purpose of using it. IMO, when using a database like pg you are substantially better off writing the sql yourself. It may, of course, not be an option you can choose.
Redis.
Yep, my vagrant environment spins up a half dozen machines. Using the exact same setup as production. 
Virtual machines have only been usable for about 6 years or so - people who started web development before that did not have the option. i used to use XAMPP, but now I like VMs better since they can usually more closely match the production server, like others have said. If you are working for alot of different clients, side projects etc it may not make sense to provision a virtual machine specifically for each client - thats alot of set up.
I used to use the built in Apache/PHP in Mac OS to maximize battery life, but I work on too many different projects with too many different configurations/weird system dependencies (i.e. one project requires FreeTDS for MSSQL connectivity, for instance, and another might require redis). Now, I mostly use Docker + Docker Machine with the Xhyve plugin to model my environments. If https://github.com/oldpatricka/vagrant-xhyve had been around when I was using Vagrant, I'd have probably used that quite a bit. One thing to note is that those sorts of things are really nice in terms of making sure an entire development team is on the same page as far as their environment goes so that you're not running into weird compatibility issues from that one guy that likes to run PHP HEAD and use all the new features on the day they're committed or something.
nope I am too
I had been developing for 7-8 years before I ever switched to Vagrant (as it wasn't something I knew a lot about) or felt comfortable messing with until someone sat down and taught me the secret wonderful life of Vagrant. I'd never go back, but I'd imagine it's the same for many - it SEEMS pretty technical and scary until you understand the basics of it.