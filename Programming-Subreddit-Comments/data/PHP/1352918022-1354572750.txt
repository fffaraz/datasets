- Advanced git knowledge is different knowing how to work with git as a basic level. There are also other systems besides git that are big, such as mercurial. Know some scm, and know the differences between it and the rest. - Yes there is, but I find that devs who spend enough time to become comfortable submitting patches/feature sets to OS projects become entrenched with the project. I'm not necessarily saying don't do it, but be aware that it becomes very easy to just stick with the project and not explore since you've contributed something to it. - That generation of js frameworks (backbone, angular etc.) are closer to backend development, but they are not backend development. Understanding how they work is good, being able to build complicated applications using them is not necessary. Again, this is for a senior php developer, not a front-end dev. As for the database point, I re-read it and meant to take it off because it made no sense and I just forgot :( 
Means that any bugs reported with these OS's won't be accepted (serious security vulnerabilities possibly exempted), and that possibly any code that supports these OS's could be removed. Just think about it: XP/Win2k3 is the PHP runtime equivalent of supporting IE6. Those OS's are a decade old and several major versions away from the current OS's on the market, and for the most part they are no longer supported even by MS. For the same reason it's ridiculous for web devs to support IE6, it's ridiculous for PHP to support XP/Win2k3.
I really like the RFC system (though it has its issues), and so glad to see them referenced in the changelog. Thanks for your work on PHP btw!
Set up your script as a cron job. Since it'll run as a CLI script, it will have no time limit. Once the script has completed tarballing your files, update whatever page your client wants to download the files from with a link to the tarball archive. How you accomplish that is up to you. You might have a temporary name for the .tar at first and then rename it according to a specific format which makes it pop up, or you could have a database or any number of things. 
The majority of your post is misguided and mischaracterized ranting. The first sentence would have been sufficiently informative, but now I have to wonder how badly you've mangled the answer.
http://en.wikipedia.org/wiki/Cron Your code will execute as a HTTP request, which you shouldn't do. You should run your script via CLI, like I said in my original post. So... php /path/to/script.php
First off, that's a rather rude reply for someone trying to _help_ you. Secondly, it's beyond poor form to issue a criticism while ignoring any actual argument at hand. Lastly, I have reason to believe that you're simply a trolling dickhead, and so I won't bother to respond further. edit: actually, the [-7] by your name from RES tells me all that I need to know. Troll elsewhere.
I'm not sure this question belongs in this sub. I'll let the votes decide. You don't provide nearly enough information. "Sign up, have a profile page, searchable by category" isn't really an in-depth spec to base a quote off of. Hell, this could be done with a vanilla Wordpress install in 10 minutes, and cost you $100, or it could be done all custom and to your exact specifications and cost you $15,000. It all depends on what you want, how fast you want it, and the quality you need. If it were me I wouldn't be able to provide a ballpark range until I had a good feel for what you were asking for. edit: On second thought, this def. does not belong in /r/php. Maybe you should try /r/freelance for pricing questions.
&gt; Secondly, it's beyond poor form to issue a criticism while ignoring any actual argument at hand. There isn't an argument. There was an unwarranted opinion which was littered with very poor associations in an attempt to push a personal agenda of some sort (there's no other reasonable explanation for going on about it).
Wow, you do understand the definition of experience don't you?
I had hoped they would wait until they had sorted out the [properties](https://wiki.php.net/rfc/propertygetsetsyntax-as-implemented) feature. It just doesn't feel like enough of an upgrade to justify the release without it.
First I heard of this, but dang that's pretty sexy. At this point is it pretty much guarunteed to not make it into 5.5?
To be honest, the one I'm most excited about personally is the one that's probably the least technically complex: the password hashing API. It doesn't really offer anything that 5.3 and 5.4 couldn't do, but lots of people have struggled with crypt()'s (admittedly rather arcane) API, and it makes using good hashing practices a snap.
Whatever you do, get some of the money up front, some for beta, some for final release and some for support. And they don't get any code until they pay. And make sure the specs are CLEAR. They must pay the remaining balance on delivery of a product meeting the specs. They WILL change their mind about lots of stuff when they see the final product. Changes cost extra. Been screwed too many times.
"It's like twitter. Except we charge people to use it."
Clear specs, change control, project management, project reports, sign offs, etc. Client must be involved heavily. No hands off bullshit. Sounds expensive.
Charge them 150 an hour, that will include any design, any testing, any BA work, that will be required. Phase work is huge. Definitely take on this project in phases. It's not smart to take it on all at once. Even if they want it done in three months, tell them, "We are going to phase it out into phases of one month a piece." This way you can take down any major bugs and issues that will arise, and I guarantee 100% that you will come to a point where that will happen. Regardless, good luck. Don't sell yourself short. If you think you're worth 20, charge 30. If you think you're worth 100, charge 150. Also, if you think you can do it in 10 hours, say 15. If you think you can do it in 100, say 150. Always say 1.5 times your original estimate because it gives you more padding, and, if you finish early, you look like a badass.
I agree. I had a client back out mid project, good thing we settled on payment stages. I strongly encourage this, as well as a contract. 
Does a contract need to have a lawyer to it or does it simply have to be a form with stated terms and signed by both parties? Is this the same everywhere in the world?
Charge them [a tax](http://www.webmonkey.com/2012/06/retailer-taxes-customers-still-using-internet-explorer-7/).
Just wanted to point out that the [-7] from RES means that he's individually downvoted Jack9 on seven occasions, not that any one single comment got seven downvotes from random redditors. He's using it to say that, in his opinion, Jack9 has historically made comments that were bad enough for kenman to downvote.
Bullshit. Requiring Javascript is a nobrainer.
Why? It (and most of them) seem to just make the code more unreadable to me.
Why, oh, why aren't you asking this on the PhpBB forums instead?
And people say my black and white (stark) minimalist UIs are difficult to read!! What a horrible color scheme!
Agree, but sometimes the FTP is one external service that I need to work with. Anyway is pretty straight forward to use ftp over ssl with PHP ftp_ssl_connect and little modifications. The library will be upgraded soon.
yup
yep it's exactly that simple, but I've done enough hobby coding for today considering I have a six-week-old daughter ;)
To maintain *some* consistency.
is this faster than get_headers?
Well.. not really trying to get a cheat sheet out of you guys. Just want to know generally what I should learn. I am not trying to BS or scam anyone on the interview. I know my skills and limits and would happily tell the interviewer that.
Ok thanks for that.
http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9.4
Untested (no HP printer) so I'm trusting that your end works! I added a couple "or die()" statements just in case a connection to the printer didn't work that the user would know. http://pastebin.com/C6zmwrC3 &lt;?php $msg = "Your first line "; // first line (20 chars max) $msg .= " "; // second line, comment this out if your display is one line only if(isset($_GET['firstLine'])) { $firstLine = $_GET['firstLine']; $len = strlen($firstLine); if($len &gt; 20) { $firstLine = substr($firstLine, 0, 19); } else { str_pad($firstLine, 20); } $msg = $firstLine; if(isset($_GET['secondLine'])) { $secondLine = $_GET['secondLine']; $len = strlen($secondLine); if($len &gt; 20) { $secondLine = substr($secondLine, 0, 19); } $msg .= $secondLine; } $msg = preg_replace("/[^A-Za-z0-9?![:space:]]/","",$msg); // strip any ASCII commands (eg newlines because they will break the command and print a page) use this if accepting user input. $msg = substr($msg,0,40); // (optional) truncate message to 40 characters (2 lines) $printerIP = '127.0.0.1'; // IPV4 (a.b.c.d) obviously change to your printer IP $socket = socket_create(AF_INET,SOCK_STREAM,SOL_TCP); socket_connect($socket,$printerIP,9100) or die("Could not connect to printer."); $data = chr(27) . "%-12345X@PJL JOB" . chr(13) . chr(10) . "@PJL RDYMSG DISPLAY=\"$msg\"" . chr(13) . chr(10) . "@PJL EOJ" . chr(13) . chr(10) . chr(27) . "%-12345X"; socket_write($socket, $data) or die("Could not write to printer. Check connections."); echo "&lt;strong&gt;Printer status set to:&lt;br&gt;" . $firstLine . "&lt;br&gt;" . $secondLine . "&lt;/strong&gt;&lt;br&gt;"; } ?&gt; &lt;!doctype html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Set HP Printer LCD Status&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form method="GET"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;label for="firstLine"&gt;First line (20 chars max):&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="firstLie" name="firstLine" size="20"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label for="secondLine"&gt;Second line (20 chars max):&lt;/label&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="text" id="secondLie" name="secondLine" size="20"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="submit" value="Submit"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; Edit: Edited to use EmptyTon's less resource intensive (cheaper) code.
That's awesome, I'll try it out when I can monitor the paper situation, in case something... goes wrong
I've had a quick look for the source, but can't find it. Will this always be faster than doing a header lookup, and if so, why? 
we'll def be doing a contract. it will actually be per phase, too, not even the entire project as a whole (with phases broken down in it). so, once we finish this first phase—they want something in january to start pitching to investors—they and we will be free to move on if need be, no one locked in to anything. it'd take far too much time (given the short turnaround, holidays, etc.) at this point to spec out the entire project in a way that would be helpful for a full on contract, so we're just going phase by phase. if/when they get investment we can take the time to figure out a roadmap for the remainder of the project and know that they'll have the $$ to be good for it as well. thanks for your thoughts. clarity on specs is a good reminder.
thankfully this client has been the most involved and most financially ready/capable we've ever experienced, so overall i feel good about the relationship. a rarity indeed :)
i was leaning towards the hourly with projections for the phases and this helped push me over the edge to be certain about it. thanks!
whoops.
I believe both perform HEAD requests, but the cURL version is probably using lib_curl (highly optimized) rather than whatever is implemented into PHP (which probably has more HTTP code/overhead to traverse/exec for a request).
I don't get what the size of your dataset has to do with javascript. It's not like your will transmit all your data to the page. About client side, Backbone never really spoke to me but I'm currently using AngularJs and liking it. It's not mature but very promising.
This is actually a good question; it can't really be backwards compat since its being added for PHP5.5 which obviously has namespaces :P Maybe ircmaxell will chime in ...
Dont need the two " either. echo $simpleNumber; 
sweet, thanks!
Pretty sure you'd want to sanitize input... somehow. The last thing we need is a rash of Printer Spool Injection DOS attacks.
1. This is not a class because it does not need to be a class. 2. If you have your own personal code with the same name as these functions, then they're either going to be doing the same sort of thing (so delete them) or they are in your control, so rename them. I really don't see why it's a big deal. Making this as: Foo\Password::hash() just for the sake of it would be ridiculous. Those are my views, but ircmaxell explains things nicely over here: http://www.reddit.com/r/PHP/comments/zrprk/the_new_secure_password_hashing_api_in_php_55/c677yu2 He answers things again over here: http://www.reddit.com/r/PHP/comments/zrprk/the_new_secure_password_hashing_api_in_php_55/c67r6un
If you have to use PHP, then you pretty much HAVE to use curl_multi to make those requests asynchronously, otherwise it will take exponentially* longer to process all the URLs. #EDIT *OK not actually exponentially but $total &gt; average($requestTimeOut) + $delayBetweenRequests) * $numberOfPagesTotal vs $total &lt; max($requestTimeOut) * ($totalNumberOfPages/$maxConnections)
I asked ircmaxell (One of the authors) this same question when he first introduced the new hashing API. You can read the full discussion [here](http://www.reddit.com/r/PHP/comments/zrprk/the_new_secure_password_hashing_api_in_php_55/c67owc2). Here's the summary of his answer: &gt; No other core function or class is namespaced. So I don't want this most vital API to be the one to break that barrier (and the confusion it will cause).
If you can, send a HEAD not GET request with CURL so you'll save on bandwidth.
If your app runs in a web browser, users will use the back button. I suppose you could have the app/test appear as a new window where the location and nav bars are hidden, but who likes pop-up windows?
In the above example cURL clearly uses GET.
Thanks!! That gets me on the right path.. Guess i didn't realize i could do it that way, and i had not come across a solution like that in my searches.
If for any reason the users' browser window closes and they lose their answers, I don't think they'd be too happy. lampdev's database suggestion is the way to go.
Indeed. Expression Engine is what you need. Built by the makers of CI - very clean and flexible. It's not free, but worth the few dollars you'll spend
As much as I love ExpressionEngine I suggest you take a look at [PyroCMS](https://www.pyrocms.com/) before you pull the trigger on EE.
Definitely. [PyroCMS](http://pyrocms.com) with the PyroStreams module is what you are looking for.
Just to add to your point: Moving these functions into a static class or into a namespace provides absolutely no benefits beyond a simple global function. It does not make them more testable, it does not make conflicts any less likely (in fact, if you were to simply put them in a class called 'Password' you'd probably *create* a lot of conflicts). Besides *feeling* more organized, it provides absolutely nothing of benefit. As mentioned many times throughout, though, it makes it more complicated and less approachable for exactly the kind of people that need these methods the most.
I'm trying this out right now, but str_pad doesn't seem to be padding it out to 20 characters (or at all), so it all goes on one line. So I'm using Macintosh_HD's code for the time being: while (strlen($firstLine) &lt; 20) { $firstLine .= " "; }
&gt;2) isn't confined to be just cms for basic content (e.g. wordpress, etc.) Your preconceptions about mature projects are showing ;-)
`str_pad` doesn't modify the string in place, it returns a new padded string. My bad. Something like this is what it needs $firstLine = str_pad ($firstLine, 20);
don't build your output inside your code. grep your data first and output it in the end using shorttags, &lt;?php foreach(...): ?&gt;, and so on
Write UnitTests, once you start writing them you will start to gravitate towards better practices. Nothing worse than trying to test a mess of code. 
Have you considered [SilverStripe](http://silverstripe.org)?
Nope. Never heard of it. Will check it out tho, thanks. 
I know this will come off wrong in the /r/php subreddit but... Try a different language. It'll give you a fresh perspective on how people do things outside of your comfort zone and your normal routines.
I don't think the type of DB matters as much as how you are designing it. Obviously I don't know all the specifics so you may have your reasons but consider: 1) Ensure your database is well indexed. If you are only selecting on website_id and you have an index for it then the query should never be more than a few hundred ms. 2) How long do you need to keep this data? Will you need the 2 million entries from 6 months ago? 3) If you do need old data, can you summarize old data and move it to another table? 4) Do you really need to do the SELECT every minute? MySQL would have no problem handling this task.
The easiest next step is to take a simple php framework, say, codeigniter, and implement your solution with that. You will learn tons! The user guide and community is good, and by the time you are done you'll have a better grasp of OOP and MVC. THEN you can think about other languages, although, I'd first stick with PHP and try other frameworks. I'd suggesting trying Kohana next. By the time you can implement your program in codeigniter and kohana, you'll understand the usefulness, and soon will be much faster and more efficient in either of those than you are now. You need to build on what you've got. You are clearly a competent programmer, and you don't need to go miles outside your comfort zone at first, just a little ways. 
If you are using one script to ping them all I'm not sure how you'll go doing 50 sites in a minute. This would be where your scalability would be worst (I would think). If you have one cron for every site it would work, but then you need an entry for each site so you have to maintain a cron file more often. 
I'm hoping this was sarcastic
Pretty neat. I can't get it to work on my HP Officejet 6600 though.
Just an FYI - faster writes means slower reads, and vice-versa. If you want your table reads to be fast, you usually want to use indexes. But, indexes slow down your table writes. My advice would be to store historical data (e.g. a daily snapshot) in a separate read-only table that you can index for fast reporting, and keep the table you're writing to free of indexes. 
This is absolutely ridiculous advice. Relational databases have been around and handling datasets far larger than this for a couple decades before NoSQL was even coined. An intelligent schema and indexing will make his use case absolutely trivial, and he'll be able to efficiently query his data unlike with a hadoop or MR approach.
I think maybe your confusing short tags with alternate syntax for control structures
I second that. No DB does a good job from the start until you know how to handle it. Bad design in your data can make any fast DB slow.
Woha, I've got only bad things from using this. Particular if you are going big !
For 50 records a minute, probably. In a recent build where we had thousands of records a second with as many concurrent connections, mongo worked better than most enterprise-y solutions we had access to without much hassle. Granted, some don't scale horizontally very well without taking out a third loan on the house. We found mongo to be easier to manage than a MySQL NDB, but YMMV. We were doing NoSQL on the MySQL cluster, so maybe that doesn't count. Doing ETL activities on it wasn't a chore either. In any case, the OP asked for suggestions and that's what I gave. Food for thought.
Yes but it's hardly simple to create any sort of advance functionality. I don't know about Wordpress but if it's anything like Drupals "hook" system I don't want to touch it with a 10 foot poll. A CMS should be concerned with managing data. Nothing else.
&gt;The 'rules' of MVC tend to state that all database queries belong in the model. Does this mean my line querying the invoice's jobs belongs in the model? Or am I doing things the right way? I would have used a [data mapper](http://martinfowler.com/eaaCatalog/dataMapper.html). &gt;Under what circumstances would this be used, rather than simply Job::my_static_function() ? Would functions specific to the job-&gt;invoice relationship go in this namespace? I think the wikipedia description answers this sufficiently: &gt;"In general, a namespace is a container for a set of identifiers (names), and allows the disambiguation of homonym identifiers residing in different namespaces.[1][2] Namespaces usually group names based on their functionality." Imagine you have a class "Client" which handles HTTP communication. Now imagine that you have another class "Client" which instead handles FTP communication. To differentiate and group the functionality, you'd place the HTTP client in /vendor/HTTP namespace, and the FTP client in the /vendor/FTP namespace. 
it's released when the RM posts it on reddit ;P
If this is for your own site, you are better off signing up for Google Webmaster Tools and Google will give you a full list of 404 errors on your site, plus the URL pointing to that dead link.
Perl doesn't quite have the same library popularity in the web domain though. So it's completely misleading to advertise is as a simple shoe-in. IMO just forget about fcgi altogether, and use Ruby or Python, if you want something different.
You need a better understanding of what PHP does, compared to what Javascript does. PHP has no "access" to any tags at all. Only what the end result of the post back to it is. Your problem is 100% javascript related. That said, post your js function and maybe we can spot the bug.
Even selection of view can be done outside controller, because in web applications the execution starts with clean slate. It is quite common to design app in such a way that controllers and views have 1:1 relations. You can use routing mechanism to both determine the name of controller **and** the view. Then you just pass the view in the constructor of controller. This would also keep the `render()`'ish methods out of the controller. 
My steps to improve my code: * learn a framework (I think many here told you already some) - this basically teaches MVC and nice database abstraction and encapsulation of code (into modules). * look into jQuery - I'm more a coder-type and designing isn't my strength.. to make a gallery look nice just take an already working library like prettyPhoto which does the rendering for you and you only need to provide the data to it
Properties would have been very nice, sure. But you don't think generators are a massive add. Given how common the passing from M or V must be for so many PHP installs? I think this is huge for PHP.
You should not use Laravel to learn OOP and more advanced pattern. It's quite bad at it. For example, every time you see a static call, it is either procedural code (in case of static methods) or global state (when you have static variables). And in Laravel there are statics all over the place. Also, the documentation is extremely vague (up till now i thought that Yii had the worst docs ... turns out i was wrong). ... aaanyway .. about the questions: 1. In MVC most of the storage manipulation (except for loading of resources, like classes and templates) should be part of the model layer. It also should be separated from the domain and (if you have) application logic. So basically, SQL statements should be used/generated in the layer, that contains the storage logic. Preferably in form of custom made data mappers. None of it should end up in the presentation layer (that's the part, which contains views, controllers and templates). 2. Namespaces let you group classes with same functionality. But more important what they let you do: - autoloading: it is common to (either partially or as whole) map namespaces to folders in which classes exists. For example `\Foo\Bar` class would be in some `/some_path/foo/bar.php` location. - naming: namespaces let you have two classes with same name, if they are in different namespaces. You might have classes `\Framework\Core\Engine` and `\Application\CarParts\Engine` .. both ar perfectly valid class names, but they do two completely different things. Namespaces make naming them a bit easier.
I agree it has it's strengths but I think if you're doing some lot of custom work you creating more difficulty for yourself than need be.
That would depend on the scope and context of this vague, arbitrary "custom work." Something that is custom inherently means a focus on certain priorities. Any given project will have tradeoffs about what you build custom and what existing solutions you make use of. It is the project, not the technology, that is the deciding factor here. If you think something like Rails or CI is just better by default for all "custom" projects, you're going to be "creating more difficulty" in other places. Tradeoffs! I'm a full-stack application developer who picks the best tech for each individual job. That ranges from WordPress/Drupal to CodeIgniter/Django/ASP.NET MVC to from-scratch client side JS applications. I've mostly learned the relative strengths of each by too many experiences of getting 80% into a project and going "Dear *god*, I wish I had used [other tool with different focus] for this job!" That has meant regretting Drupal/WP, and also regretting MVC programming frameworks.
The community has grown considerably in the last year and our forums are slowly getting better. We're working on paid support contracts so companies can feel more assured about getting quick help.
It's an issue you have to plan for for all systems; SilverStripe is sturdier than most. It also allows you to cache content at multiple layers. Are you referring to version 2 or 3? And what site did you roll this out on?
Was there any need for this comment ?
I wish more had videos, but this isn't bad at all. edit: I can english good
I'm not too much into Laravel, neither am I a big expert of more advanced design patterns in general - but I thought I'd chime in as I've found myself in similar scenarios. In my CI projects I usually abstract non-trivial model retrieval functionality inside of a library so that the controller simply knows that a bunch of models will be sent back to it from said library, and it'll simply pass them to the view. So basically inside a controller i'd do something like (pseudocode) $invoices = invoiceLibrary-&gt;get_all() and then load the view passing the array of $invoices to it... hope it helps? 
You don't need to loop. The server on the other end is what is wrong.
file_get_contents() is really not that great at this sort of thing as it's a memory hog. Better to use cURL. Even better put an object oriented wrapper around it. Try [Guzzle](http://guzzlephp.org/). You don't even need an autoloader you can just require the phar file. Guzzle will automatically return your json parsed to you. If you want to grow your application Guzzle will already be there to help you do that. And no, you don't need that loop.
I agree. Using a framework for something like this is silly. However, I agree with some /u/balrok when he says to learn a framework. Clearly the user is stuck in a bit of a rut and learning how frameworks could solve this issue with proper separation would be a good exercise. Not just for this project, but for future ones as well.
Supposedly they were all audio recorded as well. 
You might want to look at something other than **file_get_contents** as it tends to memory heavy and has a lack of options. Either cURL or another HTTP client, personally I'm a big fan of [Artax](https://github.com/rdlowrey/Artax).
I thought Matthew Weier O`Phinney's Video was really good. Don't know why the slides link just points to zendcon.com.
Definitely lightweight, but not completely barebones: http://www.elefantcms.com/ I'm the lead developer of the project. Even if you don't choose it, I'd love to hear your impressions :)
A better question would be, what makes you think it's asynchronous? Without some curl trickery, I don't think anything in PHP is asynchronous so all methods should be blocking.
That will be a good way for me to approach such questions in the future. But for today, it's not that I thought it was asynchronous - it was that I just honestly didn't know. I gained quite a bit of perspective as a result of this investigation ... &gt;I don't think anything in PHP is asynchronous so all methods should be blocking Another useful fact I learned today! 
nope, I mean both of them
Apostrophe is probably my favorite CMS. It's years ahead of Drupal and WordPress. Symfony v1 is still an excellent framework, imo. 
Google spreadsheets used to have a special built in function that was like `=GoogleLookup(A1,'zipcode')` it was kind of amazing because you could throw all the addresses into a column, drag the calculation cell down, and watch them all get magically filled in. Not really a PHP thing but it still *would* have been the easiest way I can think if to do it if you only needed to do it once. Unfortunately last time I tried to use it there was just a notice saying it's removed.
vote: your filesystem + text store all your content in plain text files, your templates in plain text files, either use a micro-framework or router to route requests to them. That's as barebones as it gets, and there are probably 6000 CMS' that do exactly that on github, often using markdown/markdown-extra to abstract away writing any HTML to publish content. It's a good way to keep a blog, as the system can shed most of its weight (and be more secure) by having no administrative interface or database. If you want to keep it barebones but still introduce more complicated features like commenting or analytics you could always outsource it to stuff like disqus and google analytics. fwiw I've made my own cms that does exactly that, and uses a CSV file to manage meta-data on each post/page. Every time I want to make a post I just write the text, and then add the title, date and location of the file to use (which can be remote, e.g. on dropbox) as a line in the CSV file. I use a separate file to hold meta data because even with 1000 lines, it'd probably be less than 100KB and would still parse lightning-fast. It's worked well for me so far but I'd say it's not a finished product, I still need to add some functionality, namely I want to add a small administrative interface that detects any file not listed in the CSV index that's in the post directory, and allows me to append it to the file right from the site. I have it loading showdown.js and highlight.js to make my posts and code snippets all pretty.
Rather than looking for the CMS that does this, just learn how to configure nginx. It's really easy. Just put this in the config file in the server block: location / { root /path/to/your/files; index index.php; if (!-e $request_filename) { rewrite ^/(.*)$ /index.php/$1 last; } }
All of SQL databases can easily handle millions of entries in a single table. This should have no impact on how you choose the DB system. Though, i would note, that MySQL is the *"i don't know anything about this"* choice. 
I'll probably be down-voted in to oblivion for mentioning this, but MySQL or SQL in general is not always the right tool for the job -- although every day it seems like it's able to do more and more. However, once you start pushing a system outside of its comfort zone and you see the cracks firsthand it's hard to say "fuck it use MySQL" in every scenario. Mongo, hadoop, bigtable, voldemort et al are not without their faults either. However, it's just ludicrous to not even try alternatives when you're concerned about problem x or feature y despite not having a 20 year track record or uses some fancy dan technology that attempts to address those specific concerns. There may be stories of mongo having issues with data disappearing. Nothing of the sort was going on with our project. We might have not even noticed a small amount of data loss, though. When getting sub-second updates from each machine in an assembly line essentially machine-gunning cigarettes out the end of it, there's an acceptable amount of loss. In the end, I just don't want the OP to come away from this thinking z technology is a free lunch. Do your homework and find what fits for your application's needs.
More details about the project would help a bit more but if lightweight is what you're looking for, try Perch. http://grabaperch.com/ 
That's a rather broad question. I assume you've read the documentation on the Zend website, so you're familiar with all the features. Do you have any specific questions? What are your trying to accomplish that Zend Server would help you with? 
Yes, I think so. And you're right, 'if' is to be avoided. I'm an apache guy so I just fly by night with nginx
Zend Server CE is their free option. The Zend GUI tools are demos, but you never have to register or pay to use PHP or Apache. The installation just works and it includes PHP 5.3+. A coworker of mine had troubles with WAMP and Web.Developer because he also had Ruby installed. Apparently there's some problem with the PATH variable and the curl dlls. This problem doesn't show up with Zend. It also includes more features than a base install of PHP and Apache. Regarding speed, it's running a modified Apache 2.2. The Zend PHP interpreter is fairly fast, but people have claimed that Apache is slower than other webservers.
The server or the framework?
More people than you think are suggesting frameworks actually based on experience.. Not via some "herd mentality". like myself (although i have not done so in this thread).
not that i disagree about the above but, if you do have all the above in place, i would recommend looking at something like Redis with Rediska http://redis.io/ http://rediska.geometria-lab.net/ 
This is a very broad question. [Reading up on how to use PDO](http://www.php.net/manual/en/book.pdo.php) would be a good start.
[Get Simple](http://get-simple.info/).
I think using php sucks, use node js instead which then allows you to use socket io for real time communication and lots of other features like npm that make life easier. Php is a legacy language and it's main purpose was to be used as a templating language to pre render html pages. Now that front end frameworks are developed enough, creating dynamic web apps that use a rest full api to deal with their data is much easier. 
Nginx is free and open, and PHP-FPM is free and open, and sensible. And they run pretty fast, and are manageable. I don't like using closed solutions when I have others like the above available. Nevermind the fact I haven't come across any benchmarks showing the proprietary solution to be faster.
Your example doesn't use short tags and short tags are generally considered terrible practice. Only thursday I downloaded the sagepay inteegration kit, dropped it on work development server and had to spend 2 hours going through and changing all the short tags. A lot of servers have dropped support for short tags
I've used previously but have always come across conflicts with other software being used and can't really see any benifits of just using the default LAMP stack provided with the distribution. 
Don't feed the troll. 
[Chyrp](http://chyrp.net)
No, nginx rewriting is as simple as apache's mod_rewrite, you just have to learn something new. *shock* If you want to learn new technologies, make sure you actually go ahead *and learn how to use them*, yeah?
Like everyone else is saying, learn how to use PDO. It will be a little confusing at first if you're new to OOP (you said emerge into web development, don't know if that means programming too), but it's an awesome way to access your database once you get the hang of it.
We use Zend Server at work but it is because the sources are encrypted. It is actually pretty good. You can switch between the different versions of php, etc.
Sadly that means programming as well. I know HTML and CSS really well and can create a nice static site but I don't have any programming experience and really can't quite find where I should start.
Well sir, you are in luck. I spent the last hour writing a super basic tutorial on PDO for database access. There is a lot more you can do with PDO than what I've mentioned, but it should be enough to get you started. http://dunphtastic.blogspot.com/2012/11/basic-usage-of-pdo-for-database-access.html
i agree
I'm header off to work but I will definately give it a more thorough look over. I just gave it a quick glance since I'm in a hurry! Since you were kind enough to write it I'll give you my thoughts and a "review" of sorts if you'd like.
Not entirely sure what you're asking either, but I think you're saying the data isn't getting posted to the next page. Sounds like either your JavaScript is crashing something or the value attribute on your option tags isn't set (or is getting altered by the JS). Check the JS console in Chrome or Firebug in Firefox to debug the script.
Drupal has http://drupal.org/project/oracle, although I haven't personally had to use it.
Rewriting the whole damn thing sounds like a neat idea, but it hasn't worked very well for Perl. 
I'm an ex-Apache guy too, hence the phrasing as a question. Still not confident in my nginx chops. So I guess my suggestion should come with an addendum: "May or may not explode horribly."
First off, you should never assume that a new line is an HTML linebreak. If you used `&lt;br/&gt;` instead of `\n` in an interview I was conducting, I would probably pass on you. It seems like a small nit-picky thing, but for some people, it's a big deal. Also, you shouldn't repeat yourself. Instead of `echo`ing "&lt;br/&gt;" after every case, you can just echo it at the end of the iteration. It seems strange and inefficient to use `foreach` instead of `for` when working with a range of numbers. Here's my solution: for ($i = 1; $i &lt;= 100; ++$i) { $out = ""; if (!($i % 3)) $out .= "Fizz"; if (!($i % 5)) $out .= "Buzz"; if (!$out) $out .= $i; echo $out . "\n"; } 
I suggested using a framework. I agree that it would be overkill for this project, so I'll elaborate. &gt;I always write shitty looking code or inconsistent out dated stuff. How can I break my old ways and make this fresh? It sounds like OP is looking for more than just a way to clean up this one project. I think they are looking for a new *perspective*, and it seems like learning to use a framework (I suggested Code Igniter) could provide that.
Yep, exactly what I meant :)
~~Not a fan of the default wordpress theme. I wish i didnt have to be *that* guy.~~
I do a lot of WordPress development, and contributed to Twenty Eleven, so I kind of like to think that, I helped build that. :)
Because different is fun $iter = new MultipleIterator; $iter-&gt;attachIterator(new InfiniteIterator(new ArrayIterator(array(null,null,'Fizz')))); $iter-&gt;attachIterator(new InfiniteIterator(new ArrayIterator(array(null,null,null,null,'Buzz')))); $iter-&gt;attachIterator(new ArrayIterator(range(1,100))); foreach ($iter as $row) { echo implode('', array_slice($row, 0, 2)) ?: $row[2], "\n"; } 
What advantages does this system have over https://github.com/sebastianbergmann/php-timer other than Lap?
Yeah, that is very true, unfortunately. They push their hosted solution. The creators are a smallish company in Pennsylvania, and it seems like they're doing well enough to justify their actions.
Laps/Named Laps, its lighter (someone prove me wrong please? Would love metrics / comparisons) and returns an array of data instead of a formatted string. 
Totally fair, and like you said, largely comes down to personal preference. I suppose my counterargument would be that it's a pretty low code overhead, and instantiation would allow multiple timer objects to be running in the same script. But utilizing the laps would probably take care of that need.
If for some reason you are already using Azure for .NET and you want to bring in a PHP application then you aren't forced to maintain a separate web stack. The benefit seems pretty clear cut to me. Now you can ask the legitimate question about why a developer would be using Azure in the first place if they intend on supporting PHP applications, but that would be silly because developers typically don't question their decision to go with Microsoft after paying the licensing fee(s).
exec('scp... ') ;
No composer.json. Are there still people downloading libraries manually ?
Nginx + PHP-FPM + Python + Ruby...run per project languages on the same box...not to mention the speed of Nginx...1% memory usage with 500 users hitting a website on one box...never thought I would see the day. Why are you leaning towards Zend Server for your company? That might provide us with a bit of insight into your line of thinking.
I think since PHP 5.4 (or 5.3?) you can do (new Object())-&gt;Method();
why use continue when you could use elseif? - btw this code looks horrible: you try to be dry and put "\n" at the end but then use continue and don't use the \n
Would you still have to store the object in a variable? IE: $var = (new Object())-&gt;Method(); or just do the same code above for every method you use? I've not seen that way of writing out code - would like to learn about it. Thanks!
I felt that PyroCMS was being misrepresented, so I responded.
Not Composer friendly then :) Perhaps the next version
I'm not versed in XDebug or others...I really ought to learn...but I think the class aims for a more involved functionality than the trace? Ie: In-function performance vs per function performance...can XDebug for example, time each step of a for loop? 
&gt; * @return true Always returns true &gt; public final static function Unpause(){} Huh? 
Using static everywhere in this way is just an old and outdated way of fudging namespaces. Think about using namespaces. 
I haven't implemented Pause() or Unpause() yet :( and yeah, doesn't return...yet. It's more of a reminder I guess. 
For docblock reminders use @todo.
Thank you! Will update accordingly :) I just put a general todo block in the README
I dunno, that's pretty easy to read and laid out really nice. It's elegant. 
ugh, needs more than IF.
My favorite part is that the code uses nested ternaries (which is an immediate code smell, and should be against your team's coding standard IMHO), presumably for saving space, and then explicitly sets $this-&gt;needs_redirect in every branch. Here's my take on improving it: private function needsRedirect() { if ($this-&gt;uri != $this-&gt;real_uri) { return false; } else if (eregi("(cName|pName|mName)", $this-&gt;uri)) { return ($this&gt;attributes['SEO_REWRITE_TYPE'] != 'cName'); } else { return (ereg("(".implode('|', $pattern).")", $this-&gt;uri)); } } $this-&gt;needs_redirect = $this-&gt;needsRedirect();
Or some parentheses, at the very least. Good grief!
I hope to god you're not the poor bastard who has to maintain this type of coding style.
As I wrote above, they serve different purposes. Xdebug is meant to find the bottlenecks in some real code, without modifying it. I have a hard time finding a real-life use case for a benchmarking library like yours or S. Bergmann's. Maybe once the bottleneck is identified, to analyze the code with a finer granularity. Though simple `microtime()` calls would be enough in most cases.
Ternaries should be one-liners IMO. And they should be parenthesized for compartmentalization. Also, wtf is up with $this&gt;attributes['SEO_REWRITE_TYPE'] != 'cName' ? $this-&gt;need_redirect = true : $this-&gt;need_redirect = false Um. Er. $this-&gt;need_redirect=($this&gt;attributes['SEO_REWRITE_TYPE'] == 'cName' ? false : true) There is so much more wrongness here than needing ifs.
This is a great site and all PHP devs should read this.. 
Thankfully it's nothing to do with my team or any team I've worked with. It's part of an SEO class for oscommerce in a friends' site which I just fixed a horrible bug in. It was redirecting any url to a 404 which had 'pID' in the uri. I'm assuming pID is product id or something like that. My friend had added a guitar amp product called the "Line 6 s**pid**er". The terrible code was doing a case insensitive search and turning up a false positive. This is the first time I've ever seen oscommerce. After reading the code and working with it; I will never complain about Magento ever again.
P.S. Here is the entire class in all it's glory. I'm going bald just looking at it. http://pastebin.com/hmSCmVFL 
Really dude? $this-&gt;need_redirect = ($this-&gt;attributes["SEO_REWRITE_TYPE"] != "cName");
I only had to work on this for about 45 minutes the other day and I was raging by the end of it.
Read the full, beautiful code here. ;) http://pastebin.com/hmSCmVFL
The parenthesis are for legibility. If you write code like the above, you'll want to shoot yourself in the face a year later when you have to read it again to make an edit to it.
Ah cleared :) Idk, I know I used benchmark libraries when I first started programming with performance in mind, but never got around to using XDebug. 
$this&gt;attributes That's a typo right?
Please elaborate. 
Ought to be consistent with the quotes too. Since there are no variables in them, simpler to use single quotes. Having said that, personally I would probably write the final clause like this for readability: $reg = implode('|', $pattern); return preg_match("#($reg)#", $this-&gt;uri);
Looks to do the same thing http://placekitten.com/ does.
Another question is how critical the data integrity actually is. If a the data is wrong on a few hits a day is this acceptable? I was reading about the Youtube hit counters and they say 'what does it matter if the counter isn't 100% accurate' which I totally agree with. If the OP is hitting each site 1440 times a day I suspect a few lost entries won't be critical, but if scaling up increases the error rate then it would need looking at. 
I find printf/sprintf to be much more useful and readable these days instead of escaping characters or concatenating multiple strings. eg, printf('&lt;a href="%s"&gt;%s&lt;/a&gt;' , 'test.html' , "It's a link!" ); Obviously I don't actually use this for html, it's just an easy example of mixed quotes.
Appreciate the feedback. Your point is covered in the rewrite rules to lock down the width/heights to sane/required combinations if required to avoid this - but in your defence it's probably something I should stress a little more in the README.md.
Somewhat, so much as the URL for width/height parameters - but thummer is about working images on your server/website/webapp, rather than just random kittens (not that I have anything against kittens!).
$these-&gt;attributes fixed those for ya 
Woops guilty as charged. Apologies, I tend to assume all of the logic is in the code rather than the server configs. But yes stressing that point is a good idea, I agree! And maybe even switching your defaults to that might be even better. Right now somebody just carelessly dropping your lib into their project (the web designers in our marketing department are notorious for this) is going to potentially leave them vulnerable.
http://i195.photobucket.com/albums/z287/maomaolx1983/200707240817348103458201.jpg
I know you're trolling and I don't usually respond to such weak and snide attempts, but you're confused. My suggestion actually improves legibility while yours is just a pathetic attempt at provoking me.
&gt; even with CodeIgniter being a bit of a hinderance Please elaborate. I have used several CMSes before and CI is by far the best. I have found that many CMSes want you to do things their way and any other way the CMS will just tell you are doing it wrong.
For some reason the government seems to be really pro-Drupal. It's kind of like someone just installed a Drupal instance somewhere and showed their boss and their boss was like "you can edit pages without installing extra software!?"
I tried to make my own framework (before I knew about Codeigniter) - I failed miserably. I had some co-workers who didn't use a framework at all and I think because of people like my co-workers is what gives PHP a bad name. PHP code scattered all over the page, credentials to a database plastered in the middle of the page....it was bad.
Cute, it tries to pass itself off as a helpful script. From glancing it over my best guess it is essentially allowing a remote attacker to execute code on your server. Some of that code does absolutely nothing -- it's probably just filler or a smokescreen. But much of it seems to be involved in shenanigans. It decodes stuff contained in the "hash" docblock comments. It looks for code signatures in the cookies. Hmm, the script also looks for a conf_global.php file which it searches for up to 5 levels from the doc root, and if it finds it it includes it. Not sure what's in there, but you may want to check for it on your server. Looks like it's probably exploiting a vulnerability in your forum software. IPB is Invision Power Board I assume? I'd suggest shutting down your forum immediately and if there's any sensitive information hosted on the server, you should assume its been compromised. Users should be made aware of this immediately, and warned of what information the attackers may have accessed. If your users have the same passwords on the forums as they do on other websites with sensitive or personal info (eg banking websites) they should immediately lock down those accounts and change their passwords. Send examples of the malicious code, as many as you can, to the forum software developers. Provide them with any information they may need to track down the vulnerability. ^Edit: ^Adding ^to ^it ^as ^I ^discover ^any ^new ^insights. 
lol
I mostly do python/django these days, so I'm not up on the current best practices in the PHP world, but I've been using the [django rest framework](http://django-rest-framework.org/) extentively recently, and it does an extremely nice jobs of abstracting out a lot of boiler plate as well as separating concerns in a nice MVC way that works especially well for web services. Not sure how familiar you are with the python world, but you might check out how they do things and try and port the concepts over to PHP especially considering a lot of concepts from django should cary over to CI (last time I checked). 
One of the really nice things about phpThumb was being able to generate a secrete key hash for the URL so that only my own scripts could create working thumb URLs. For example $url = 'site.com/thummer/' . md5(SECRET.$w.$h.$file) . "/$wx$h/$file"; Then in thummber.php, you can check that the md5 matches by recombining these values. Clearly, not NSA approved hacker-proof, but generally gonna be damn well good enough.
Here's the short example of the rationale behind parenthesis on one-line conditions. $customerCreditBalance = $ExcelWorkbook-&gt;getTable("MyTable_Customers")-&gt;getColumn(1)-&gt;getCell(1) || "N/A"; if ($customerCreditBalance != 0) { // Send promotion to spend remaining balance! } -- $customerCreditBalance = ( $ExcelWorkbook-&gt;getTable("MyTable_Customers")-&gt;getColumn(1)-&gt;getCell(1) || "N/A" ); if ($customerCreditBalance != 0) { // Send promotion to spend remaining balance! } If you lack screen real-estate you're going to have to scroll right to see the bug in this program. Even with the screen real-estate you're forcing yourself to scan the whole line before discovering it's a conditional. However with parenthesis here you'd automatically know there's more going on than just the normal method calls. I too write in Python, and share your feelings on unnecessary brackets and parenthesis. But for a language as crazy verbose as PHP it's best to either avoid inline-conditionals where possible or make sure they're clearly denoted.
could simply make this more "NSA and hacker-proof" by just replacing md5 with hash_hmac... using SECRET as the key. Just as easy and a lot safer. rule of "thumb" if you want to pass in a secret to a hash function for signing or whatever. use a MAC like HMAC. just hashing doesn't cut it.
Everything I'd want to override is private or a constant. wtf...
This can solve the issue for a moment but not the bad design.
The only comment in this thread was a positive towards pyro?
That was my first thought - quite a nice way to keep it in the system... pass off as a "friendly" - a quick Google for key strings gave a few results - most were Invision boards in a broken state, basically the script had been inserted/hacked-in wrong and was emitting the PHP source and that got spidered. In any case - patch things up to latest and remove the offending code - it can't be good!
I'd be interested to see your caching strategy for this. Have you filed a bug report?
Evidently awareness needs to be made given the sheer amount of shit code out there.
Most of PHP's "mvc frameworks" assume that views are dumb template and refer to collection of active record instance as "models". Both of those factors force the business logic and presentation logic in the controller. This is not MVC. Not even vaguely.
Let me ask you this... How do you deal with a CMS'd website (like concrete 5) where the production site has files &amp; folders that the client may have uploaded files to. If you have the vhost running pointing at a symlinked folder, and change that symlink, those files are "gone". So now you're in a situation where those files need to be outside of the webroot, or your deployment has to manage migration of those files... or your site relies on a CDN for those files. Now, multiply that by 400 sites... You just created a more failsafe, but majorly complex and ultimately unmanageable system... 
We use a system that manages hundreds of sites (including prod, qa, dev and developer sandboxes) that involves a bunch of custom bash scripts, a unique method of setting up our server hierarchy, and svn. It took a while to develop and still gets tweaked on occasion, but it lets us manage stuff with a minimum of hassle and it ends up allowing us to see almost instantly when sites haven't been deployed to standard. It also aids in troubleshooting performance issues. We work primarily with Drupal sites and rely heavily on Drush.
Hah as much as I'd like to jump on the hate-train, OSC serves one of my clients just fine. Granted, she doesn't see shit for traffic, maybe a few grand annually in sales, but it's held up ok. Also, the original dev did us a favor and worked the frontend into a somewhat-clean template thing... not pretty or clever, but at least I'm not editing 10-deep tables. Still... tep_abc_def_ghi_afafafa fuck. Thank god (or FSM) for xdebug &amp; "step into...".
I smash my head into the desk whenever I see someone misuse the word "literally".
I'll just add this to the list http://www.wolfcms.org/
The PHP manual has pretty good explanation for this: http://php.net/manual/en/security.globals.php But here is an enlightening part about the register_globals: "This page will explain how one can write insecure code with this directive but keep in mind that the directive itself isn't insecure but rather it's the misuse of it." register_globals basically creates variables "on the fly" with values sent through query strings or post requests. Ex: www.site.com/index.php?name=Foo, with register_globals=On PHP will create a variable called name with the string "Foo" stored on it. The first example is very clear about why this is dangerous: // define $authorized = true only if user is authenticated if (authenticated_user()) { $authorized = true; } // Because we didn't first initialize $authorized as false, this might be // defined through register_globals, like from GET auth.php?authorized=1 // So, anyone can be seen as authenticated! if ($authorized) { include "/highly/sensitive/data.php"; } ?&gt; 
And *this* is when you ask why IPB is still running md5 + salted hashes: md5(md5($salt) . md5($password)) Whoever got in, if they dumped your database, could probably yank half your user's passwords (half of them are gonna be crap) by running John the Ripper on them.
I second this one, and promote this plugin to go with it: http://get-simple.info/extend/plugin/simple-input-tabs/523/
You can reproduce some of the convenience of register_globals in a much more secure fashion. For instance, this will work for $_GET: &lt;?php // Array of get parameters that should become global variables $get_vars = array('var1', 'var2', 'var3'); foreach($get_vars as $get_var) { // If parameter was defined in $_GET, turn it into a variable if (isset($_GET[$get_var])) { $$get_var = $_GET[$get_var]; } } echo "$var1 $var2 $var3"; ?&gt; By explicitly declaring which variable names you are using, you remove the security risk of arbitrary variable declaration.
Why would you start playing with settings while having absolutely no understanding of what they do, or how they impact your code?
/?this_variable=someValue will be $this_variable with the value of 'someValue' in your code. 
true.. but redis / nosql would be an optimal solution for a project like this
Also, I think this is relevant. Where do you store your password salts? Separately next to the password hashes? I saw strategies that embed the salt in the password hash itself. Is it a bad idea to store the salt separately from the password hash? (for ex. in a database there are 2 columns, password_hash and password_salt)? 
I really do appreciate the input. I'm basically firing back at you the questions that came up from my exploration of jenkins and these deployment methods. I'm going to definitely explore these methods and talk it over with my team. We do have different tiers of projects and this definitely seems like an excellent way to manage the larger tier projects. You definitely are correct that small web outfits don't do automation for that reason, and I guess I was just looking for a magic bullet. Thanks again, you've definitely given me something to chew on.
Take a chill pill, bro. 
Fair enough. Keep up the good work, man! :)
if you put in phpunit and selenium tests between step 4 and 5, that's the way we are going to go. as the project is not yet live, i can't give you a detailed review yet, but in a pre-release enviroment its already working. upvoted. 
[SaltStack](http://saltstack.org/). Fast, based on ZeroMQ, able to push configuration / content updates to hundreds of servers, and all done with a smattering of YAML - no massive java stack (or xml) to configure.
Dear god. So this means if someone got a hold of a source file, they could potentially fuck up some shit if you had this enabled?
In some cases they wouldn't even have to get hold of the source code.
Yup or rather than brute force they could make educated guesses based on the parameters that are getting passed around. Fortunately it's not a problem any more. Also, be careful with `extract()`, the same issue could occur, though it's less of a problem than `register_globals`.
This is a great system for automated deployment: http://puppetlabs.com/
`register_globals` by itself isn't the main culprit. It was the common (and moreso implicit) combination of running all code in global scope and never initializing variables, paired with muddled execution paths through included scripts.
http://alanp.ca/blog/tag/hack/ Check this out, very similar if not the same hack. Been around for a while now! 
It's pathetically easy to avoid even back when it was nearly always on. Just having error_reporting(E_ALL) would make sure you found all uninitialized variables and wrapping includes in a function would make sure you were never running code in the global namespace. 
Capistrano is great for this and will let you ignore user-generated content, among other things. The Railsless deploy gem empties the Rails-specific methods, making it perfect for PHP sites. https://github.com/leehambley/railsless-deploy Fabric is similar, but written in Python and a little more generic: http://docs.fabfile.org/en/1.5/
Why not use Slim PHP instead of CakePHP? Slim really allowed me to do the RESTFUL stuff and then gets out of the way. If your looking to do RESTFUL with backbone Slim really is a good choice. 
Well, you could choose to be the source of good programming advices, instead of just bashing them.
Capistrano and use Chef to handle updates and such
luckily we've moved off magento to our own ecom cms and salesforce. all extensible with either php or python. my precious'. as for crm and edi, we still are using acctivate, which is just as extensible with good tsql and crystal reports. i will never go back to magento. ever.
I'm not sure why this would be downvoted. If you are creating a PHP class or package and want as much adoption as possible you should absolutely be putting it on Composer and Packagist. PSR-0 is not a requirement for Composer at all, it just so happens that the vast majority of people use it as it makes a whole bunch of sense. You can jam any PHP format you want in there - for example the Amazon AWS SDK just uses class map to get all of its files autoloaded. That said, this should definitely go at least PSR-0, ideally PSR-1. It's not just a temporary trend, its the future.
I would keep to the traditional braces in class files. 
I wouldn't necessarily call you a "jackass", but aside from the obvious answer of "why bother", this alternative syntax only seems to exist for a select collection of control structures. According to the [PHP docs](http://php.net/manual/en/control-structures.alternative-syntax.php), "end" syntax exists for if, while, for, foreach, and switch. Absent from this list are declarations such as class, function, and other similar constructs. So you're pretty much stuck using braces in some places, which will give you a file with an inconsistant mix of brace structures and end structures. Yuck! That said, template files are exactly where this kind of syntax makes sense and personally I prefer it in those cases. Braces are really hard to keep straight across &lt;?php ?&gt; boundaries and quite frankly it makes the template look ugly and harder to follow. It's even worse if the template author doubles down on braces and in an effort to clean the template up starts making gratuitous use of: &lt;?php if ($bool) { echo "&lt;div&gt;A very long stretch of normal HTML with a single $var in the middle&lt;/div&gt;"; } ?&gt; So yeah, there's a time and place for them, in templates. But not in normal .php source files.
Just like freezedriedpop I'd say only use these in view /template files. Brackets get ridiculous very quickly inside a presentation file and usually end up with people thinking "sod this, lets use a template parser" which is overkill. This endif endforeach syntax makes statements much easier to follow in view files when mixed in with HTML, but if you use them in your PHP classes you will be hated by your colleagues forever.
I can only see one attack vector for not expiring the token: user requests a password reset, doesn't act on it, and X amount of time later, his email account is compromised. The attacker finds the password reset email, clicks for the hell of it, and now owns the user's account on your site. It's a stretch, but one to mitigate against if your users consider their accounts valuable.
How about having the reset link expire on next successful login? 
The main reason being: Convention. There's tons of ways to get the job done. The main reason to stick to convention is worrying about the guy that comes in after you, and how he'll feel about your code.
This is effectively what the "one time use" implies.
Just because _you_ do not like Twig, that doesn't mean it's bad. 
No its not bad, maybe not that good, but definitely not bad. It does what its meant to do. Maybe with a little more complexity but it does its job and can be useful if used in the right scenario.
For me the point of the article isn't "this is the only right way" but more like.. "I am a bad programmer" and "This made me less bad". So I've read those static methods in "class-containers" more like a first solution for his problem and not like a best-praxis. Also it would be nice if you could elaborate where he's getting more pain than before - when I look at his before-code everything he mentioned in his article seems reasonable - although I would argue if twig really helps.. but at least it won't get worse with it.
It allows you to use the autoloader to automatically include the right files, which is damn handy. 
I was kind of excited when I got to your testing part ... but it looks like you're not testing properly. It appears as if you're actually rewriting the logic *into* your tests, instead of letting your test run the code it's testing and then asserting on the results.
Oh. I misunderstood. Yes, it should expire on successful login as well, imo.
``` mysql_query( sprintf("SELECT * FROM `users` WHERE `id` = %u LIMIT %u", $user_id, $limit), $mysql_instance); ``` Edit: Since I got downvoted to hell, I'll explain why I put this. In the article there is this line of code: ``` query('SELECT * FROM users WHERE id=? LIMIT ?', $userId, $limit) ``` I was providing an example on how to implement this without a custom function and I didn't explain this initially. In production, I would always recommend using PDO now. Regardless, this code isn't AS bad as everyone seems to think. It is properly escaped despite all the comments about SQL Injection. (%u typecasts to unsigned integer). It also has no example of how I defined $user_id or $limit. TL;DR: Insecure code, don't use this. Merely provided it as an example query with passing parameters after a query.
When the request is from the local server.
We actually thought a bit about that too; It would definitely be a bit more complex to do, but quite nice to have. Then you can also run the daemon _on_ ec2 itself, so servers can easily find each other :)
BTW, you should cross post this to /r/aws! 
One word: No. Two words: Use PDO.
It is unless you're using windows notepad to code. I don't think a lot of html editors go through php strings... Plus it'd normally be inline. &lt;?php foreach($ar as $var): ?&gt; &lt;h1&gt;&lt;?=$var-&gt;title ?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?=$var-&gt;desc ?&gt;&lt;/p&gt; &lt;?php endforeach ?&gt; Also, the braces are fine until you get even slightly more complicated if and foreach blocks. I've been on projects where it's very hard to parse through the braces, or you see things that would be redundant such as. &lt;?php } // end of if ?&gt; &lt;?php } // end of foreach ?&gt; And I feel that it's mostly that way because the if and endif actually match the formatting of the HTML it's embedded in, and you're not introducting a whole new formatting structure like you will by using braces in the middle of html code. Almost every designer is pleased when they're separated from php code that uses braces vs code that uses the block style. 
Besides, password resets shouldn't be much of a database hit at all unless you're getting them spammed by bots (in which case, block that).
There are lots of things wrong in this story, but for me, it shows what happens when you don't have a solid education in software engineering. the sadness is not about PHP but about methodical software development
Yes, however your script also has to be reliant on global variables. If you are using an object-oriented framework, then all your methods do not access globals by default; they have to use 'global' to make those variables accessible. So if you don't use globals, it's a non-issue. However a lot of OO frameworks often *do* use globals to pass data between objects, methods, and utility functions. For corner cases where it allows the code to 'just work' by magic, and to hide away the boiler plate. So even if you don't use globals in your code, it may be possible to seep data into global variables, at the framework level. This is partly why global variables should never be used, and every global variable and top level variable should **always** be initialized before use (it's also more performant).
Autoloading is a very common feature? What's the point of this comment? 
Except all those things add a lot of value, while twig doesn't.
Nothing wrong with foreach, I use it all the time. However for core bits of code, that is run on every page, I'll go with a for-loop, as it's more efficient. I also do this for any templates which generate a tonne of items. Otherwise for-each all the way!
I'd be slow to publish this post showing my prior lack of knowledge if I was head of a big retail website like he says.
Fair point, but my example was concise. [Here's a better example from Wordpress' codebase](https://github.com/WordPress/WordPress/blob/master/wp-content/themes/twentyeleven/single.php).
Or stored procedures.. or bindings... or.. I give up.
uh, no. You run the method, and then assert the expectation. Basically, you're saying "given these inputs and conditions, the given method should set this state", and then you test the state to see if it's what you expect. Your test should not care about the actual mechanics of what your method does, only its results. For example, lets say I'm testing a method called "add_two_numbers" in my class Useless. I'll use PHPUnit since I'm familiar with it: &lt;?php // Our useless class that we need to test methods in class Useless { public function add_two_numbers($n1, $n2) { return $n1 + $n2; } } // Our useless test which tests methods in class Useless class UselessTest extends PHPUnit_Framework_TestCase { public function testAddTwoNumbers() { $useless = new Useless; $result = $useless-&gt;add_two_numbers(5, -3); $this-&gt;assertEquals($result, 2); } } Given the same two inputs, if the result is ever not 2, the test fails. This then indicates that something in the method add_two_numbers() changed.
It's important to note, which you imply in your last sentence, that tests are not just for testing when you first write the add_two_numbers() method and then throwing them away. Any time your code changes, you run *all* your tests. Just thought that was worth saying since this submission is about some of the simpler parts of development.
"OOP is bad. It adds needless complexity and doesn't add a whole lot of value." Wrong. "MVC is bad. It adds needless complexity and doesn't add a whole lot of value." Totally wrong. "Tests are bad. They add needless complexity and don't add a whole lot of value. etc" So wrong I could fucking explode. If you're serious - your code must be god damn awful. **Edit: I just re-read the post you were responding to and now realise you were being sarcastic. Too trigger happy there eh? Ok, I'll let you off :-)
I don't think he positions himself as an expert.
Email systems aren't always quick, remember the 10 minute clock start counting from the time you generate it but users might not get the email until 15 minutes later, especially not if you ever have a high volume of email going out such as a newsletter and a user requests a reset token while that's going on. Timing out is great, but 10 minutes is too brutal for a system which you ultimately have no control over.
The author says he'd written a lot of code in C++ by the time he started with PHP.
I was glad to see your comment as the top comment. At the DBix section I kept thinking, "Why didn't you use PDO at the very least?" Seems like the author was thrown into a situation and tried to make the best of it.
Regardless of the language static methods have their place, if you know when and why they should be used. One example would be a common transformation of some input that does not depend on or require any other state. 
yes , static methods and variables are a good tool for solving specific problems in procedural programming. But you shouldn't then use heading "OOP and asking for stuff" and call it OOP. Just because you use classes does no make it OOP. ... and his interpretation of MVC is just a joke. Since when did we start to refer to MVC as "My Very Code" ?
Surely this is a joke.
I really don't think this has anything to do with "true OOP" vs using objects in procedural code. Consider all the built in php functions. Let's take some string utilities for a second and pretend php didn't provide a trim(), rtrim() or ltrim(). Everytime you wanted to call them you'd have to instantiate a StringUtils object along the lines of $stringUtils=new StringUtils(); $trimedText=$stringUtils-&gt;trim($text); vs $trimmedText=StringUtils::trim($text); There is overhead to calling the implicit constructor/destructor every time you "new" something. Beyond that, it acts as a namespacing mechanism and lends it self well to the PHPUnit framework. Don't worry, you can still do all your type hinting dependency injection. I just feel it's wrong to say static is a four letter word. 
If you need "utility function", then create a file with a namespace and include it. Since PHP 5.3 there is no point in faking namespaces with all-static classes. And most of the code in the examples was not using "utility functions". Instead it was mostly used for factory method and singleton antipatterns. As of the overhead, it is extremely small and compensate after 3rd method call on an object. And PHPUnit has NO problems with native namespaces.
I've clicked the reset link just to confirm that my username was the correct one. I am one of those people that goes "Oh I remember!". As long as the timeout occurs quickly and the reset password email occurs quickly, their shouldn't be an issue. ...I get impatient waiting for the password reset email. https://www.owasp.org/index.php/Forgot_Password_Cheat_Sheet
They're quick if you use something like Postmark or SendGrid.
So? Perfectly consistant with C. #include &lt;stdio.h&gt; int main() { int i, iv; float f, fv; float x; for (i = 0; i &lt;= 100; i += 5) { iv = i; } printf("iv: %d\n", iv); for (f = 0; f &lt;= 1; f += 0.05) { fv = f; } printf("fv: %f\n", fv); x = 0; x += 0.05;x += 0.05;x += 0.05;x += 0.05;x += 0.05; x += 0.05;x += 0.05;x += 0.05;x += 0.05;x += 0.05; x += 0.05;x += 0.05;x += 0.05;x += 0.05;x += 0.05; x += 0.05;x += 0.05;x += 0.05;x += 0.05;x += 0.05; printf("x: %f\n", x); if (x == 1) { printf("x == 1\n"); } else { printf("x != 1\n"); } if (x == 1.0) { printf("x == 1.0\n"); } else { printf("x != 1.0\n"); } if (x == ((float)1)) { printf("x == (float)1\n"); } else { printf("x != (float)1\n"); } return 0; } output: iv: 100 fv: 0.950000 x: 1.000000 x != 1 x != 1.0 x != (float)1 runtime: Apple clang version 4.1 (tags/Apple/clang-421.11.66) (based on LLVM 3.1svn) Target: x86_64-apple-darwin12.2.1 Thread model: posix 
You really need to look at the [OWASP cheatsheets](https://www.owasp.org/index.php/Forgot_Password_Cheat_Sheet)
IEEE 754 ftw! Edit: OP, all languages that use the accepted standard for floating point arithmetic will produce similar errors. Floating point can't be used to exactly represent .05. The best it can do is a little bit over .05. If you modify your code to print out a few more digits you get: iv: 100 .05: 0.05000000074505805969 fv: 0.9500003.20 x: 1.00000011920928955078 x != 1 x != 1.0 x != (float)1 
it's not just PHP. you'll entounter this in every programming language. the problem is how floats are represented internally. the conditionals fail because $x isn't 1. it's actually more like 1.000000000000000222044604925. the lesson is, never test floats for equality
If you do not consider all-static classes to be fake namespace, then I have no argument, that will convince you. An if you care about metrics and optimization ,then you wouldn't be using PHP to begin with. One should be using right tool for the right job. There is nothing I can say to convince you, that classes are not the right tool for isolating utility function.
I thought that too, but he did mention that he started out on PHP4. That might not have been an option.
Congrats on starting up all the other devs in a pissing contest. Good question, but it's about readability in template files, nothing more.
no tabs? why no tabs? spaces? something?
or &lt;?php foreach($ar as $var): ?&gt; &lt;h1&gt;&lt;?php echo $var-&gt;title;?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $var-&gt;desc;?&gt;&lt;/p&gt; &lt;?php endforeach; ?&gt;
A lot of web developers start learning how to program with PHP. They don't know MVC or OOP beforehand. So, yes. And this article provides a small, easy step in the right direction.
I do get that just seemed like that was glossed over when you deceived his comments. 
I read so many posts saying how incorrect he is. Will someone explain the correct way to use OOP and MVC in PHP?
Personally I do like to make any PHP logic explicit in HTML, as otherwise it can be difficult to spot. I personally don't believe that things like if statements and for loops should be made to look more like HTML, because it doesn't act like HTML, at all. To put it another way, I'd prefer it to be too explicit, than too difficult to spot.
There is a very early experiment in it, that achieves that via /etc/hosts. It's mentioned here in the readme: https://github.com/fruux/ec2dns#update-etchosts-with-your-ec2-instances Hooking it into the dns resolver is definitely way nicer, but might also add some impracticalities/complexities for certain setups. We hope to look into that in the future.
drupal is a good all around cms but it will take time to learn. Or just design your own database and gui.
A framework, *any* full-stack framework (so, not Zend ~~Framework~~), would have saved this guy three months of pain.
The sending system is yes, you still don't know about the receiving system. There are people out there still using terrible system and sometimes my test mails to hotmail are still slow. The only system I test that is never really slow is gmail.
Some of the problem is that most of those persons will hear some site has some extra capabilities and they will want to try those as well, so a very simplistic solution will cause some conflict for them. Not related: *title* and *author* ;)
So they'll completely disregard the fact that he explicitly points out that he thinks he is probably currently mediocre at best?
there is no OOP in the article, TDD paragraph is pitiful and his interpretation of MVC is a joke. 
I think this guy is heading in the right direction even if the code is not perfect yet. Most importantly he wants to learn a better way to write code, so I hope he doesn't stop now and continues to learn modern PHP development. I know plenty of devs who just double-down and insist there's nothing wrong with old PHP4-style code when asked why they don't use OOP. That being said I don't like some comments in the article, e.g. that composer would be overkill for his project. This sounds like something someone would say if they'd never used composer. If you haven't used something don't go round telling people it's hard or complicated. Composer is extremely simple and I would suggest pretty much everyone just learn it and use it in all their projects. Either way there is a line in one of the popular programming books (maybe pragmatic programmer or something) that says "don't let best be the enemy of better". I think this applies to some of the comment here. 
Functional primarily is what we do not, I am aware of php unit however.
? false : true is the worst kind of inverted logic you can have...
Variables $user_id and $limit are not being escaped at the query level. It is not immediately clear whether these variables contain user input and if they have already been escaped by a function such as mysql_real_escape_string elsewhere. You could call this function again but repeated escaping will add multiple backslashes and bugger your data. In such an ambiguous situation it's easy for a developer to make a mistake and leave variables unescaped. As a note, the above approach is error-prone, dangerous and unmaintainable in a modern PHP application of any scale. People wanting to move away from such an approach should look into using a database abstraction layer such as PDO ([introductory tutorial here](http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/)). 
I'm familiar with it. However, it does not provide an appropriate answer to this question. I'm looking for a logical reason why a token expires, not a guide on best practices. My link is a better guide for that, imho.
At this point it really feels safer to convert the rating system to integer percents.
Aw thats cute, but your example looks like horse shit.
The reason that this is happening is because you are relying on the equality operator to execute the final iteration of your loop, and floats added to floats are rarely going to be equal to what you expect. Essentially, at the end of execution, $i is going to a be a value that is close to 1, but $final_value never gets assigned to it because the test ($i &lt;= 1) will fail. You could still do this loop, but you need to not rely on the equality operator. For example, this will work: // Now using floats between 0 and 1 inclusive. for($i = 0; $i &lt; 1.04; $i += 0.05) $final_value = $i; print "2: "; var_dump($final_value); But, I think the idea of using integers representing percents is better.
an example of horse shit is still horse shit. 
And the point your trying to make is....?
we dont agree on what makes code more readable. which is fine since we dont work together. but ive never seen someone defend the lack of indentation.. especially in examples (code meant to be read).
sorry man, im just an asshole today. 
You could always put some logic into the code that if the password link is tried again after 10 minutes that it bump the expiration to 20 minutes. That would curb that problem. Also, having a good support procedure or some phone number for users to call in an emergency is always helpful.
Thank you! You guys have been very helpful and I wasn't even seeking for help!
It typecasts it to unsigned integers. This isn't how I would produce production code either. I merely presented it as an example on how to pass variables into a string without a custom written function.
Yes, after reading the responses in this post I decided to change the rating system to integer percents. Thanks.
It was to show an example of how to accomplish it similar to what the article says. It is much safer than meets the eye though, as it typecasts the values. Besides, I didn't how how I set the variables. /me thinks about register_globals
You should! I'd read it.
Ah, sorry, I did not realize that you typecasted the values, but I still prefer doing it the PDO way.
"Variables $user_id and $limit are not being escaped at the query level." sprintf with %u typecasts the variables into an unsigned integer. mysql_real_escape_string shouldn't be required for a variable that is an unsigned integer for a query expecting the placeholders being integers. I do agree that this is not the way to do queries, with modern features that exist like PDO, but it does show an example usage for running queries using a string and passing in variables after it.
I would recommend calc2(). Passing variables to functions can get confusing when your classes grow.
I wouldn't recommend any approach over the other, as it entirely depends upon the context in which they are used.
If the function is part of a public interface and relies exclusively on internal members, have them tracked internally; don't pass them in. That means that if you have to change something later, it's less error prone, and that users of the class won't have to know how the class works. If the function is expected to work with that data or other data in other circumstances, then it probably shouldn't be a member of the class at all; even so, the class should still call the function on its own, internally. If the function is expected to sometimes work with internal and sometimes with external data, you're looking at either a very complicated situation, or much more likely, poor design. In either case, use more meaningful names. If you can't tell the results of the function without looking inside, you're creating long term maintenance problems for yourself.
And, of course, this leads to a nicer implementation since you can use polymorphism. Essentially, Rectangle can extend/implement Shape (which will handle all of the setting and getting of data), leaving each child to only care about the getArea() function. Lovely.
&gt;Nicoon's answer is nice. The one I deleted, or my response to lostmyfont?
Any reason you cannot simply integrate YouTube into your site? They have an API, you know.
I just read this whole back-and-forth, and I'm pretty sure if you would have just said "because I haven't figured out how to indent code on /r/PHP" from the beginning everyone would have been happy. As-is, I'd tend to side with cheeeeeese here. Code you're putting forth as an example should be well-formatted, since it is explicitly an example for others. The readability here isn't terribly disrupted, but that's not really why we're criticizing the lack of whitespace. If you didn't know _how_ to add whitespace in Markdown or /r/PHP, that's totally understandable, and you should have just opened with that instead of getting defensive and doubling down on the whole no-whitespace-is-fine thing.
&gt;Let me ask you... could someone who knows what they're doing with the YouTube API make things work how we want without ever having to visit YouTube? Yes. That's what the [API](https://developers.google.com/youtube/v3/) is for. It addresses your concerns with managing your private videos. 
I'll admit the example was extremely generic and pointless, but you understood what I was saying enough to answer my question. Thanks
The one you deleted, though now I don't remember what it said.
Test anything that is loosely-coupled with unit tests, then test the site itself with Selenium/WebDriver. We have our own PHPUnit WebDriver extension (didn't get on with PHPUnit_ Selenium2TestCase, but this may have improved since we last looked). edit: worth mentioning, if you have things that are very tightly coupled, you should also ideally be refactoring them, but that may not be realistic depending on your dev workload, and before you do that you need a comprehensive test suite to catch any regressions, so you're really in a "catch-22" situation (and this is why testing from the get go is less work in the long run).
The only reason I would make the class function static is if it's a Factory Class.
This is nice. The only thing I would add is that I would remove the setter methods and only set values in the constructor. That way, your object becomes immutable :) . And, to be honest, I'm not sure how it makes sense to think of a triangle changing its dimensions; better to simply create a new triangle object in this case.
I'll just leave this here: https://github.com/kriswallsmith/assetic :)
There are advantages and disadvantages to static methods. Another use would be for the singleton pattern. I tend to stay away from them but as in the example simple math operations don't really require a whole math class to be instantiated just to call a once off function that should never change.
Sounds like you only read the first 25% of the question.
&gt; as far as testing goes. What are you saying
Add it to composer.
Like I said the example class is over simplified. The actual classes I'm working with are more complex. As for custom math functions, though, and to thread jack my own post, should they just be defined as a bunch of functions in a math.php kind of file, loading them to the global namespace? In this case, would I need to require_once the file everywhere I need it or is there a way I could namespace it for use with an auto loader somehow?
Trying not to nitpick because I know this is a quickly done example, but if you follow the convention of Clean Code then having public mutator methods that directly expose the backing fields is poor design, i.e. you might as well just use public fields instead. 
Looks good. I've been looking for something less cumbersome than Assetic to integrate with my new simple cms, [Bolt](http://bolt.cm "Shameless namedropping"). 
Dude. Bound parameters.
I updated the post to suggest that this snippet should be inside the include that connects to the database.
If by "ingenious" you mean "idiotic", then sure. Sanitation and validation is context-dependent, so this is absolutely the wrong way of doing things. Secondly, if you want to be sure to be absolutely immune from SQL injections, then use parameter binding in a prepared statement. 
Can't say I've come accross many live servers running 5.4
The class is an API. The **only** important thing is that it exposes methods that take arguments and return something (returning nothing is just return null). In your example, doMath1() should be a black box to any other code that uses that method. They simply do not give a fuck what is happening inside. That said, the actual answer to your question is: do as little as you need to. Start by simply returning $this-&gt;a + $this-&gt;b, but if you need to calculate that elsewhere, then abstract it and call the method (although this is so simple it would not be worth it, just speaking in general).
Posts like these are _exactly_ why PHP gets a bad rep.
Hey Bopp, Ya, definitely. I use it in every project at work. It will definitely fit snug into your CMS and not give you any hassles. If you do have any suggestions or have any issues, please let me know.
&gt;I'm not sure how this library takes place of any client-side optimisations. The entire point of minifying and combining scripts is to reduce loading times on the client-side. The minification is to reduce the total number of bytes and the combination of files is to reduce the overhead brought upon by opening new connections. &gt;it doesn't even matter. It does matter, any developer working with performance optimisation can attest to that. Especially so when you are working with mobile devices and the like. &gt;The whole point of this library is to make it dead easy to take advantage of the awesome power of LESS. A [build script](http://en.wikipedia.org/wiki/Build_automation) is tons better than having the server-side involved in client-side affairs. 
Ok, so I assume you just started to learn programming. You may think you're brilliant, but wait until you've learned a bit more, grasshopper. This is an absolutely TERRIBLE idea. Using MySQLi bound parameters is how you become immune from all SQL injection attacks. Very simple. Your code is very likely to break various things and cause incorrect values to appear all over the place.
I've never* created a script for Composer before so I'm trying to figure it out. At the moment, I do have this up: https://packagist.org/packages/meenie/munee But when you install it in composer, it will put the files in webroot/vendor/meenie/munee instead of just /webroot/munee. I'm trying to figure out how to change that. I suppose you could just update your .htaccess file to point to the new location though... Thoughts?
This is a tool i use alot and hold very dear. http://gskinner.com/RegExr/
&gt;And by this you mean a proper build process Yes, as I said in my response to meenie. &gt;They're not client side optimizations They're not optimisations performed by the client-side, no, but they're optimisations *for* the client-side, which is the point I was making. I'm sorry you interpreted it differently. &gt;but they can only be optimized on server side I don't think it should be optimised by the server, but by the developer. &gt;a build process is the best way to solve this, even better than using a library for it This is what I'm saying. I don't think this even belongs in the back-end, since the back-end shouldn't be concerned with the front-end. You know, separation of concerns and all that. The developer would have greater control and it also wouldn't be tied to a specific platform. 
I can't speak for how others would want to use it, but for how i'd like to use it, that wouldn't be a problem. How i think i'd use it in my app, is that i'll create a small file like app/minify.php or somesuch. That file would contain the specific settings for my app, and include and call the relevant code from vendor/meenie/munee. Also, I don't know if that's possible yet, but i'd like to be able to 'pass' my own config. That way i'd be able to use Munee from composer, without having to modify any files. One of the benefits of composer is that you can easily update libraries, which means that any local modifications would be overwritten when your do a 'composer.phar update'. 
My favorite too.
I use this for regex especially working with php http://www.gethifi.com/tools/regex
Yeah I agree. The issue with "...$object-&gt;method()..." is not really PHP version (in)compatibility. Much more important, for me at least, is readability. Surrounding with braces makes the method call much more visually obvious/easier to scan.
Did you sign in or register an account on Zend.com when you downloaded the bundle? If so, then Zend usually will follow up with a call for new users a few days later. Even still, you didn't make a mistake. If it was Zend, it was a sales call. Very likely they wanted to see if you liked Zend Framework, and then they would pitch their training and certification programs. It's not a big deal to not want to talk, and honestly they can be pretty aggressive if you do. They will do the same if you download a trial of any of their commercial products, asking about training and licensing. The calls regarding Zend Server tend to be especially aggressive. 
I have only once entered my company e-mail address when downloading Zend, more than a year ago. Could explain this all. I'm glad I didn't miss anything.
&gt;It is You're missing my point. Unfortunately, I don't think I can be clearer about it than I've already been. &gt;but that doesn't change the fact that your arguments against this library were based on incorrect assumptions and were just plain wrong. I've made more than one argument, and the fact that you're objecting to one of them do not invalidate the rest. Anyway, I don't see much value in continuing this exchange, seeing as meenie and I have already met an understanding. 
&gt;So, Zend ~~Framework~~ just called me on my phone... FTFY.
Keep up the good work. Looked through your code, looks clean, easy to read. Keep programming, keep learning. The most important trait of a programmer is the will to learn, to go forward, to never be stuck in the past; and you have it.
I've had my fair share of commercial Magento websites. Let me tell you, if you never plan on making a single code change, Magento can work wonders. However, once your customer requests a new feature for their Magento-powered website... Have fun. Have fun opening tons upon tons of files, only to see that the file is including another function in some obcsurely-loaded file. It is beatifully written, in terms of standards, design patterns, etc. However, it is not something that can just be picked up and hacked away. When you charge a flat-rate per hour, you really don't want to eat away at your profits just sifting through files or docs just to do a simple change. Also: this Magento experience is from 2 years ago. Back then, there wasn't any "free" support or docs. And much less support forums. I don't know about know, and quite franky, I'm never looking back. TL:DR: All web scripts have their ups and downs. Think OScommerce is bad? Let's talk VirtueMart.
And what's interesting about that point ('limiting untrusted sources') is that you could sandbox those few times in your app by using smarty/twig/whatever to render those, and not base your entire application's rendering process on the same technology. Use raw PHP for 99% of the time when it makes the most sense, have the 3 views that deal with untrusted sources use markdown/bbcode/twig/whatever templating code. Somehow this compromise never seems to come up with people who advocate these templating projects. That said, I like the idea of 'escape by default' in a view layer, and also do like DSL concepts. I've just not seen it done very well in PHP projects in the past 15 years or so (including my own). 
re: the DB stuff, I would encourage the OP (yappie2?) to have a look at redbean (http://redbeanphp.com/)
that was fast...
"Protect your server" - Looks like someone didn't know about the `/e` modifier. Or maybe he did know, but forgot about the NUL-truncation :)
I learn about new features like /e everyday... If any intrepid testers want to me PM me, I'd love to chat about closing this all of this thing's vulnerabilities :).
This is a real powertool!
You're a jerk.
At the moment no there is not but definitely something I will look into. To fix this issue now, you could store the cached files in git, and then move them across to the live site when you want to deploy.
At the moment, I haven't exposed any settings because there's really nothing you can change. But I am guessing on one thing and that is setting the WEBROOT constant. If you have the dispatcher call in a file that is one folder down from webroot, then everything will work fine. If for some reason you find you need to change something in my code, let me know and I will look at exposing it into a setting.
Now that you've got this, use it for a small project and you'll see what it's good at and what its shortcomings are - maybe even build a "documentation" website for it. After that, investigate other frameworks and see what they do to solve similar problems. Re-inventing the wheel is a great way to learn the ins and outs of things, so you're definitely on the right track. 
Hi, Yeah, its very restrictive sticking to one type of routing method. Do you have any suggestions for any other types of routing?
Thanks, I am looking into it now :)
this is pretty amazing !!
Teresko, thanks for a great reply! I will take all your suggestions onboard for version 2 :) I guess I thought it was doing MVC-ing as I tried to separate views from logic.
That's just another magic_quotes approach.
Well, it's common convention by most frameworks to allow for user-defined patterns where you have segments which resolve into parameters. For instance: /path/to/{something} Where {something} is the segment whose value will be extracted. Now, user-defined patterns certainly allow us to do a lot, but suppose that we have a case where the implementation provided by the framework is insufficient for what we want to do. It would be rather bad to be pushed into a corner because the framework wouldn't allow us to do what we want to do. So what option do we have? Well, we could define an interface and let our route classes implement that. If we do have a case where our existing classes do not cover all our bases, then we wouldn't have the unfortunate circumstance of having a developer feeling trapped because of the limitations of the framework, as the developer is free to provide his/her own implementation of the routing mechanism. So, what would such an interface look like? Maybe something like this: interface IRoute { public function match(IRequest $request); } We are then free to provide our own implementations, e.g. class RegexRoute implements IRoute { ... } Or: class SegmentRoute implements IRoute { ... } etc. Then we could simply match against the routes by doing the following: $match = $route-&gt;match($request); You could even match against multiple routes at once by creating a route stack, e.g. class RouteStack implements IRoute { protected $stack; public function __construct() { $this-&gt;stack = array(); } public function addRoute(IRoute $route) { $this-&gt;stack[] = $route; } public function addRoutes(array $routes) { foreach ($routes as $route) { $this-&gt;addRoute($route); } } public function getRoutes() { return $this-&gt;stack; } public function match(IRequest $request) { foreach ($this-&gt;getRoutes() as $route) { if (($match = $route-&gt;match($request)) !== null) { return $match; } } return null; } }
And most IDEs help writing it almost automatically...
How about support for any of the preg_match* flags?
&gt;I didn't read the code because MVC frameworks hurt my brain Too magical for you? :) Need an explanation of how they work internally?
&gt; suppression of errors (it should be E_ALL) Yes, but also be aware you should be logging them instead of displaying them to the user.
Well done on the effort! Just curious, what's the reason behind the dual database connection?
That's why there is a `display_error` option in `php.ini`/`ini_set()`.
Actually MVC is about two types of separation: - detaching presentation from business logic - splitting apart interface creation and user's input In a fully implemented view, it is actually an instance, that is responsible for UI logic. It create a response for user (and in web apps, the user is actually the web browser), that can either contain HTML, JSON, XML or even just an HTTP location header. The view acquires (the "how" is main distinction between Model2, MVP and MVVM) data from model layer, and based on that information, it can assemble HTML document from multiple templates. .. as for version 2, you should start by expanding your understanding of OOP at first. You should have encountered some issues already wile making the first version. I would recommend you to go throught the lectures, that were listed in [this post](http://www.reddit.com/r/PHP/comments/z94id/ok_ive_got_codeigniter_pretty_figured_out_what/c62t4wl). And, after you are done with the V2.0, read the *"Patterns of Enterprise Application Architecture"* by Martin Fowler. 
Implementing a timeout is very easy if you are generating your own reset tokens - just build a timestamp into the token.
&gt; For instance, is it better to write class methods to accept parameters if the parameters are properties of the class? In general, yes. It makes things more composable. calc3($a,$b) { calc1($a+5),$b+5); } That same thing with calc2 would be. calc3() { $this-&gt;a = $this-&gt;a+5; $this-&gt;b = $this-&gt;b+5; calc2(); } It's a *lot* harder to generalize code that's modifying global state, and make no mistake, class properties are 'global state' for internal functions. The risk is only that you destroy the state of the local object, so it isn't as wide ranging as a true global, but the problems are analogous.
His system will work, as soon as the user comes back it automatically logs them in. If there are 15 current sessions, it'll just have to stop them there (not killing the session, but not validating it). If they don't have a session they can resume, than either create one if &lt; 15
It is just a "shorthand" syntax for if/foreach/etc structures. No real benefit. Some people like to use it when combining PHP and HTML in the same file.
Thanks for the reply. Used when combining PHP and HTML, hm. Thanks for the info!
The theory is that it makes it easier to determine which end bracket corresponds to which block. If you have a mix of If statements and loops, it's easier than trying to match up curly brackets.
Thanks that was an interesting read.
Yeah I can imagine it would help. I have done //endif or //endforeach before lol. Didn't know I could do it a lot easier though. Thanks for the reply!
It actually follows typecasting rules. If it typecasts to an invalid type (i.e. a string to a number), it just sets it to a 0. $expected = '15'; $unexpected = "anything' OR 'x'='x"; $template = "SELECT * FROM `table` WHERE `id` = %u;"; $queries = array( sprintf($template, $expected), sprintf($template, $unexpected), ); print_r($queries); Like with this, it will dump out this: Array ( [0] =&gt; SELECT * FROM `table` WHERE `id` = 15; [1] =&gt; SELECT * FROM `table` WHERE `id` = 0; ) Evaluates just fine, though I would definitely say a check first for integrity would be helpful (like only run the query if $id &gt; 0, or if it passes is_numeric(), etc..)
You might want to check out redis, not sure if that is a possibility, but you could setup a key value store and set it on a TTL. http://redis.io/commands/expire hope this helps.
I see what you mean. You could still implement the same system rather just check for 15 concurrent logins and your activity check before log in. You're still going to need to know if somebody logs in twice with the same username I think. Six in one, half dozen in the other. Good luck. 
Or..................... &lt;? foreach($foo as $f):?&gt; &lt;?= $f ?&gt;&lt;!-- will echo the var --&gt; &lt;? endforeach; ?&gt; 
Alright. The first step in an MVC framework is the front controller. The front controller is a file (e.g. index.php) which intercepts all requests being made to your website. Usually, this is done by a .htaccess file if you're in an apache or apache-compatible environment, which tells your website to route all traffic through that file. Next is the routing component which is responsible for assigning URLs to specific controllers (classes) and actions (usually methods). A route is essentially a pattern which is matched against the URL from which you can extract specific portions of data into so-called "parameters". For instance, you might have an identifier in the URL for a blog post which maps to a specific entry in your database. Once a matching route is found, it is handed over to the dispatcher, which is a component which is responsible for instantiating and invoking the controller. Now, the implementation of this might differ from framework to framework. Sometimes the action is called directly from the dispatcher, and sometimes that responsibility is handed over to the controller itself, e.g. by passing that information along to a dispatch method. Now, this is only the first half of the story, but it tends to be the part which most people are confused about at first. Any questions so far?
I kinda have a config file for dev variables and one for prod variables. Each are in a separate file. When it comes to deployments you want to be able to switch out a file with whatever deployment scripting program you're using e.g. Fabric rather than edit a file, change the value to prod/dev etc then upload that. Make it easy to switch out. Something like config.php is the file that's loaded. Then you have a config_prod.php, then when you deploy using automated scripting you rename the config.php to config_dev and the config_prod to config and automatically it's in production mode with production settings.
Good on you for writing your own and learning how they work under the hood. The real key is having a demo or real app which uses the framework, then you realise shortcomings and architectural weaknesses from the framework. Then you can improve on it to make it easier to use and fix the problems.
I can't believe it's 2012 and I'm still seeing this stuff. We need to form a PHP police agency that finds and eliminates/amends all of these outdated tutorials. 
$ grep -rl 'mysql_' ./ If anything comes up, I refuse to touch the code.
The front controller is not a router. The router is the router. A front controller is merely a centralised entry point for all requests, and that's all the pattern is concerned with. A front controller without a router would still be a front controller. Now, you can invoke a router from the front controller or even merge it with a router, but the front controller pattern itself is not a router. 
Yes. I think it is more readable for views/templates. Consider this: &lt;div&gt; &lt;?php if($error): ?&gt; &lt;span class="error"&gt;There was an error!&lt;/span&gt; &lt;?php else: ?&gt; &lt;span class="success"&gt;Huge success!&lt;/span&gt; &lt;?php endif ?&gt; &lt;/div&gt; Against this: &lt;div&gt; &lt;?php if($error) { ?&gt; &lt;span class="error"&gt;There was an error!&lt;/span&gt; &lt;?php } else { ?&gt; &lt;span class="success"&gt;Huge success!&lt;/span&gt; &lt;?php } ?&gt; &lt;/div&gt; It becomes even more useful with foreach loops, etc. But **never** use it inside your models/controllers ;-).
It has a name... it's called the ternary operator...
You can enable PHP short tags if you want but if you're writing code that's intended be deployed on other servers it's usually considered good practice to use the full `&lt;?php ... ?&gt;` syntax.
Thanks, I'll check it out!
I get that it follows typecasting rules. As a new programmer on the project I would expect it to error if I put an id of 'a' in, that's all I meant by expected behavior. Once it' pulls up user 0 I'd know exactly what's going on.
Totally agree. This is my first project to be added to composer and it was very easy. 
&gt; You can enable PHP short tags if you want but if you're writing code that's intended be deployed on other servers Only if you can't control the php.ini file. Most places would run their own server these days even if it's small apps so I'm not sure how valid that excuse is. I write code that is pushed to 30 different clients and use short tags with no problems. 
Just use a decent hashing algorithm and store the hash in your database.
If you're doing the same thing that this Alex Laird guy is doing then your websites are ridiculously easy to hack. 
I don't think he meant echoing the HTML. I think he meant doing it like this: &lt;div&gt; &lt;?php if ($error): ?&gt; &lt;span class="error"&gt;There was an error! Balls!&lt;/span&gt; &lt;?php else: ?&gt; &lt;span class="success"&gt;Great success!&lt;/span&gt; &lt;?php endif ?&gt; &lt;/div&gt;
oh of course. ops
Please forget everything that tutorial taught you. it's horrible. (see nicoon's comments). Also the overuse of static methods for function namespaces is pretty bad.
There are plenty of people who use shared hosting, or for whatever reason can't control this. The fact is -- whether or not it works in your very particular anecdotal case -- it's generally considered best practice to use the full syntax, as misterstevenson suggested. So at best you're simply giving bad advice.
php 5.5 is coming out with a password hashing library that's extremely easy to use. And there is a compat lib so you can start using it now. https://github.com/ircmaxell/password_compat
NO, you do NOT just start using a decent hashing algorithm. You need to use something very specific for password hashing. Right now the best way to do that is crypt() with bcrypt. PHPass and the future 5.5 library make this easy: https://github.com/ircmaxell/password_compat
&gt;Right now the best way to do that is crypt() with bcrypt. Implying this isn't using a decent hashing algorithm? Jesus christ, how do you people even operate.
That isn't ternary...
Why shouldn't you use it in models and controllers?
Because braces are highly deseriable in models/controllers. It's used in output because it acts essentially like HTML tags, allowing you to keep the generic flow of the document. In pure PHP files though, it's kind of weird.
Best way I've found is to place the upload at a temporary location.. and then run validations and such on it. That way you can simulate the behavior with files that aren't actually uploads. 
I didn't know that about emulation. That's awesome.
We've now entered the era of pointless comment of pointless "era of PHP Testing" article. :) 
Yeah I just read another post, basically the argument is to keep to convention, which I can agree with. Thanks!
Great series, thanks
care to elaborate, rather than just calling for an imaginary person? 
why is that?
It's not a MySQL database, it's MSSQL unfortunately which is why i have to COUNT(*) because there is quite literally no way of getting a row count from fetch data otherwise. Otherwise, would have to process the data and only then can i get a rowcount, which is useless when i require a count before hand.
What exactly is wrong with just md5ing the pass?
In my opinion, setters and getters should do nothing more than set and get. This is personal preference, but I would move validation into its own method eg public function isValid() { return ($this-&gt;weight &gt; 0 &amp;&amp; $this-&gt;volume &gt; 0); } if (!$obj-&gt;isValid()) { throw new Exception("Object is invalid"); } 
I've only read the documentation but it looks really interesting. Going to read the code and try it later! Are you the author? Thanks for sharing
That is very valid. Thanks for sharing :)
If you extended the phpunit class you'd have access to methods directly instead of having to use fqn.
I just glossed over the documentation, but I didn't see any "down" functionality. Suppose you write an "add column" schema update. Do you also need to write the opposing "drop column" schema update?
Isn't is the case that hashes don't provide strong enough security though?
There's basically no security. For example, install Firefox Web Developer Toolbar, click 'Add Cookie'; set the key to project-name-userID and the value to any userId you like, and you're logged in as that user
See my comment to fistman.
I disagree - I believe that methods should **always** throw exceptions whenever they are passed an invalid parameter or encounter a bad/unrecoverable state. Other parts of your code may use these objects, not knowing they have bad data because no exception was previously thrown. You're not going to call `$obj-&gt;isValid()` all the time, are you? I think `isValid()` is really only useful for validating the object as a whole though; for example, an ecommerce site should ensure that an order has a billing and shipping address before placing the order.
some.. like md5 are too easy to crack. not the ones mentioned here.
If anyone wants to do anything like this on a publicly facing machine, then for the love of god only allow functions from a whitelist to be run. Otherwise someone could do something like this: index.php/system/rm%20-rf%20~
&gt; Come deploy time, however, this is a terrible way to go. For a new table, it's not a big deal, but what if users already exists? Modifying it more than once is going to take a very long time. I wrote a system that does this in an extremely large US corporation. It has been in use since 2005. It works on Oracle, db2, mysql, etc. It's really database agnostic. Since it also does the software deployments, it knows what is installed on each server, and which servers contain databases. There are other considerations (such as regions that get region specific sql), but the end result is you never push the same SQL statement because you know the starting point and the target release. If you already pushed release C, pushing it a second time wouldn't matter because there are no new dbscripts to run when going from C to C. 
This is bad and you should feel bad
I was expecting someone to be yelling at singleton classes. Was disappointed.
I'm not no, just thought it looked pretty cool. I'm more of a cli fan for working with migrations, but a solid gui could make it more accessible, and perhaps push new people to use better methods too.
People seem to forget what exceptions are actually for, and I strongly disagree with your interpretation. Exceptions should be used in exceptional circumstances. Not every time you want to reject something. If passing a bad parameter is fatal to your code, then an exception is warranted. However if it is not fatal to your code there are other ways the object can communicate that. 
Actually, the best way to handle validation is through a [chain of responsibility pattern](http://en.wikipedia.org/wiki/Chain-of-responsibility_pattern). The way most php programmers tend to hard code validations, particularly on classes meant to be extended and reused is silly.
**Please read the entire thing or skip to the bolded part.** I wouldn't recommend using this in production code. I mean the comments describe exactly what it does, but it could have problems because the $_POST (and I believe $_GET) array can have arrays within themselves ( such as when you set name="options[]" ) If you were to do this code specifically for making all of the $_POST array "mysqli safe", I would recommend an array_walk like so (only PHP 5.3+, requires create_function: array_walk($_POST, function(&amp;$value, $key) use ($mysqli){ $value = $mysqli-&gt;real_escape_string($value); }); ---- **I do not recommend this for any purpose because of the following reasons:** * Not every $_POST/$_GET/$_REQUEST value will need to be given to a database. Why waste extra resources calling an unneeded function? * The $_POST/... arrays are not only used in a mysqli database of an application. Having this code run automatically before you actually have access to the raw $_POST/... arrays will seriously limit yourself and could have potential problems (ie. parsing data). It is much wiser to use bind_param's for inserting data into a database *as needed*.
Why not refactor your code to not rely on such things in the first place? 
I suppose it's a good way to get a legacy class under test so that you can refactor safely. Obviously it's better than nothing, but I agree with you that I'd much rather refactor away from singletons than depend on fragile trappings.
Yeah, stuck at a similar approach myself. Company has lots of NNN.sql files and it works fine enough for dev machines, but come stage/prod, it's "grab all sql, merge by hand" kind of deal. It's not killer work, just annoying that there isn't a really good tool for it yet.
Oh ok, well that's good to know then. I am really inexperienced with these things, so it's good to know that there are secure hashing systems out there. I have heard of bcrypt, but never used it or known much about it. Thanks!
Well sorry about that, was only going off what I've heard, and by your answer, then maybe the simple hashes are what I was talking about.
Yeah the cookie was obviously stupid, the password bit being bad is what confused me though. Where do you store the salts? In the function? In the database? Honestly I would love a straight forward answer as to why $hash = md5($password); is insecure. I've been using this for a while now, I do occasionally salt them but the salt just gets stored in the database, it doesn't feel fantasically secure, I just heard it is good practice
That's a pretty clever idea.
Then why have getters and setters in the first place? That makes them absolutely useless, Java-esque boilerplate crap.
You can add a word to all your functions instead of creating whitelist. function whateverAction(){} Now if the link is index.php/system/whatever you do $p[1] .= 'Action'; And then check function_exists();
I believe what he's trying to get at is that a getter or setter might fire a validation process, but it shouldn't be responsible for actually validating data. In this fashion, validators or transformations are able to observe changes in attributes (and take appropriate actions) without actually becoming entangled in the process of setting variables.
It's going to be very circumstance dependent, but to call upon an example I'd point to the ActiveRecord pattern. While it has a set of validations (defined by the model set up by the programmer) those validations are not acted upon until you attempt to commit the data. Even after committing, it will either save, or it won't. Errors are tracked by the object and it becomes the programmer's responsibility to check for those failures. Why do this? Because faulty data is expected. In addition, it allows you to run a sequence of validations without interrupting the chain. This way you can track every validation failure instead of having to stop at each one to handle it. My point is that exceptions are for the unexpected; they're not for the things you know happen commonly.
&gt;care to elaborate The article posted by stonedoubt claimed to be a "Secure PHP login", but upon inspection it was shown to be the exact opposite. The only secure part of the code was that it protected against SQL injection via the use of prepared statements and it regenerated the session id to prevent session fixation (though, I doubt the author knew that regenerating the ID would have that added security feature, as the comment said he did that to "make it harder to track"). Now, the script had two glaringly bad code parts, which I posted above. The first being storing the password using sha1, which is just plain insecure and easily cracked. The second, and most critical security hole being that you can simply create a cookie and you'll have access to that person's account. This is no way to build a secure login script. &gt;rather than just calling for an imaginary person? I wasn't calling for an imaginary person, I was invoking an idiomatic expression. You know, the thing where an expression have a figurative meaning which is separate from the literal meaning of the words?
The practise of salting passwords is so that two identical passwords of two different users do not carry the same hash. That way, the attacker won't know that the same password works for both accounts, but need to crack both hashes in order to know that. MD5 is vulnerable, as it is subject to several fatal flaws which has rendered it cryptologically broken which is why the US-CERT now considers it "unsuitable for further use". SHA1 too has been found insecure. What's more, these are general hashing algorithms, which are unsuitable for handling passwords. Vulnerabilities aside, they're incredibly easy to crack even with a brute force approach (e.g. by using a tool such as John The Ripper) since their algorithms are so fast. Salting the passwords won't save them. What you should be using is password-specific hashing algorithms, which are cryptologically slow, able to scale with the increasing computational power, and have salts built-in. Hashing algorithms such as bcrypt. 
Well, it should've been.
...For?
My point exactly.
Thanks, the similarity confused me, my apologies :)
Good shout, my apologies!
This is like controlling fire by hiding it under pile of papers.
Absolutely correct. There is too much hype in web-dev today. HTML + Microsoft Frontpage will get the job done faster and with fewer distractions.
whoosh.
That's very astute of you.
I see we're both Magento developers, so you and I are aware of how messy large applications can become. :) To elaborate on my earlier point, I would say that the state of an object doesn't always matter. Maybe it doesn't matter if an object is partially composed while other things are happening. Maybe an object is being passed around to many areas, and it simply will not be a complete object until it's ready to be committed. I guess I view your point as being strict, when it's not always necessary to be strict.
I see where you're coming from, and I agree. For example, it doesn't make sense for a Product model to validate whether another product has the same sku. The database layer would be the one responsible for checking that on save and throwing an exception. I tried to come up with examples where it would be necessary, but for strict getting/setting I couldn't think of any :P So I suppose I take back my original point.
Well, you got me thinking, and I questioned myself after reading your reply. I would be very interested in seeing a codebase that effectively implements more strict validation. I just added you to my social networks btw, since we're both Magento devs. I'm studying for my cert.
[monolog](https://github.com/Seldaek/monolog) is pretty nice
&gt; because you only ever want one of them. So *only create one of them*. Using constructor hiding to enforce a Singleton (capital S) indeed simply creates a global state that's just wrapped up, and indeed harder to test, because you de-localize all side effects of code that interacts with it. If you need to write a blog test about specifically how to test it sucessfully, it's already hard to test.
You already have a public getter and setter, why would I use the magic functions `__get()`, `__set()`? Also `$_bar` should be private.
because you might have originally used a public property, but now you need a getter and setter and you don't want to change all your code. there are other benefits such as being able to easily configure a class based on an array - you don't have to check for setters. regarding your second point, you have absolutely no idea of how Foo is going to be used and whether child classes might need access to that $_bar property. private by default is really arrogant - there are often circumstances where you need access to that property from child classes.You should only use private if there are no acceptable circumstances for child classes to access the property directly (this is very rare). In this case you might want to change the default value to something else, in which case the child class would need access to $_bar. So you are wrong wrong wrong wrong wrong and this private by default attitude needs to die, I frequently encounter it and have to beg upstream to make a particular property protected instead.
You already have a getter and setter for `$bar` with `getBar` and `setBar`, why fuck would you even bother adding `__get()` and `__set()`? Also, your getter and setter shouldn't be modifying the value like in: public function getBar() { if ($this-&gt;_bar === null) $this-&gt;_bar = "Hello World"; return $this-&gt;_bar; } should be: public function getBar() { return $this-&gt;_bar; } &gt; regarding your second point, you have absolutely no idea of how Foo is going to be used and whether child classes might need access to that $_bar property. Which is exactly why they should not have direct access to the variable, I don't know what they're going to do with it. They can access it through `getBar()` and `setBar()` provided they were even created properly in the first place. &gt; private by default is really arrogant - there are often circumstances where you need access to that property from child classes. It's not arrogant, it's encapsulation and proper programming. 
Obviously the code I posted was to illustrate usage, it's not real world. In the real world the __get() etc would live in a base class that Foo extends. Having this kind of structure allows you to write code that can consume different types of object and not have to know that they need to call $obj-&gt;setFoo($value) instead of $obj-&gt;foo = $value etc. Since you don't allow your getters and setters to actually do anything: 1. Why use them? Why not use a public property? 2. How do you initialize default values. e.g. instead of returning a string, getBar() needs to return an instance of Bar. How do you provide a default value for that? And it is arrogant. It is assuming you know better than the developers who actually have to use your code. I presume you make all your classes and methods final too? 
Ahh, a big word proves everything. Encapsulation is worth nothing if all it encapsulates is an assignment and a variable access. If you say that "setters and getters should do nothing more than set and get" then there is absolutely no point in writing them. If you allow logic in them, *then* they're a good idea because what is a simple assignment today might contain something more complex later.
**KEEP YOUR MOTHER FUCKING HANDS OFF MY PRIVATE MEMBERS. ENCAPSULATION IS THERE FOR A REASON**
Easy man :) By creating public members on a class, you basically define a contract that your objects should adhere to in the future. Encapsulation is there to help you ensure this. But if you don't use getters and setters for anything other than getting and setting the value of a private field, and *never will*, as jesse_dev said, then there's absolutely no point in writing them. A public field would mean the same thing. I agree that encapsulation is important and that's why I always use getters and setters. But not allowing logic there is just insane. It defeats the very purpose of the whole thing.
Getters and setters should do exactly what they are intended for, GET the value and SET the value, nowhere in there is there necessarily an ALTER the value unless you create a specific method to do so. I didn't start in Java but I most definitely see the reasoning in why it does what it does and why it's better. Symfony 1.2/1.4 I have used more than Zend. **EDIT** Honestly, I would agree to disagree at this point because I personally am not backing down but if whatever you do works for you then have at it. I don't necessarily agree but whatever, yo.
I don't see why you couldn't do this... class Room { private $x; private $y; public function getX() { return $this-&gt;x; } public function setX( $value ) { $this-&gt;x = $value; return $this; } public function getY() { return $this-&gt;y; } public function setY( $value ) { $this-&gt;y = $value; return $this; } private function verifyValues() { if( $this-&gt;getX() &lt; 0 ) { throw new OutOfRangeException( "Width cannot be negative." ); } if( $this-&gt;getY() &lt; 0 ) { throw new OutOfRangeException( "Height cannot be negative." ); } } public function getArea() { $this-&gt;verifyValues(); return $this-&gt;getX() * $this-&gt;getY(); } } I'm a bit inebriated myself but I think that looks right.
To maintain the purity of my getter and setter. I don't really care that the value gets set to a value less than zero until I am about to use those values in a calculation. Otherwise, the validation should be done before setting the value in the first place. So... $room = new Room(); $value_x = 1; $value_y = 10; if( $value_x &lt; 0 ) { throw new OutOfRangeException( "X must be greater than or equal to zero." } else { $room-&gt;setX( $value_x ); } if( $value_y &lt; 0 ) { throw new OutOfRangeException( "Y must be greater than or equal to zero." } else { $room-&gt;setY( $value_y ); } 
Excellent! Many thanks for the resources. I started trying with composer (see op github) on Wednesday, but got pulled into making an android app for a client. Will update thread when its fully composer friendly 
 "SELECT id FROM table WHERE entry='" . $_GET['entry'] . "'"; http://site.com/page.php?entry=' OR 1=1; DROP DATABASE; Always, always, always clean your SQL. Better yet, use PDO: http://php.net/manual/en/book.pdo.php
so even if i'm using a dropdown/radio/checklist and I'm using POST method I should still escape/strip/trim for that piece of data?
"prepared statements"? Isn't that what mysqli_real_escape_string() is?
$_GET and $_POST can always be faked. &lt;form action='http://yoursite.com/yourpage.php' method='post'&gt; &lt;input type='text' name='theirvalue' value='whateveriwant' /&gt; &lt;/form&gt; Just pointing the form at your site and hitting go would send the POST to your site. You have 0 control over the POST variable coming in. If you don't scrub it, someone can take advantage of it.
No, but I'd also recommend using them over just escaping strings. [PHP manual on mysqli_stmt::prepare](http://php.net/manual/en/mysqli-stmt.prepare.php)
Probably not a great book to use as a resource... Basically, how to build an insecure app 101. Nor should you even be thinking about using `mysql_*` functions...
No, you have to protect SQL statements from SQL injection.
informative very very
Well I guess you didn't mean MonoDB: "A collection of information about parasitic monogenean worms." -- http://www.monodb.org/
Nope, it supports many different logging handlers, for example we use it for Database + graylog2 + some file based + firephp logging and you can configure where to log depending on the severity of the item. (we log to different locations depending on where the application is deployed) https://github.com/Seldaek/monolog/tree/master/src/Monolog/Handler for a list of handlers. It also features processors which process the log item before it's saved, adding extra information. For a full list see below https://github.com/Seldaek/monolog/tree/master/src/Monolog/Processor We created our own processors to store user information and other things.
After learning about monolog in this thread, I'm trying to mix it together with FirePHP now. Right now I'm not using monolog for anything a fwrite wouldn't solve, but I'm not quite done toying yet ... It puts the error in the logfile or else it gets the hose.
First, thanks for taking time to answer, it's helpful for me. I like the recursive function idea, and I have to admit that I probably couldn't come up with this on my own, I'm a learning guy. About the HTTP solution, I'll keep it in mind, but you're right, I should change my stuff like you're code ! Thanks EDIT: I update the blog post, to point out your solution
Actually there's nothing bad in references. And I think it's definetly better than recursive functions.
If the domain is hidden in the URL, how are users meant to switch between them?
Nice thanks for your answer and your time. the method mailAction was on the tutorial when I tried it but it's not supposed to be here :p Well, so should I create a new project using the first link you gave mand rename my bundle at the same time? The entity repositories I created are here because I think I'll need those entity :3 then I believe I will say that Playlist are composed of a name and a table of songs. I have one question, we did an analyze with Merise method but it's not Object-oriented, so should we do it again with UML? Thanks again !
Do you assume from the name "Catfish" that the fish is a cat?
I have been using Monolog in a few projects, you should absolutely look into it. If you just have one server and want it for local debugging it's brilliant, as it can send out to FirePHP, Chrome Debugger, Email, whatever. Anyone in your team can tweak a local config file to setup how they get it. Higher level, we usually let PHP just dump into syslog or whatever, then use [Logstash](http://logstash.net/) to collate the logs and post them all off to [Graylog2](http://graylog2.com/) for nice overview and statistics. Logstash sits on each different server, then Graylog2 on a single server so we have one collection of logs. Monolog CAN send things straight off to Graylog2 using Gelf but that can slow down the application as it's posting directly each time, or you can use AMQP which is a little quicker but its still a blocking operation. 
Have a look at REST. You could use urls like that: POST /playlist/ - for adding playlist PUT/PATCH /playlist/{id}/ - for editing DELETE /playlist/{id}/ - for removing GET /playlist/{id}/ - for viewing
I will probably get downvoted for this, but I'll post it anyway. If you want to go evil, you can use eval : function toyaml($data) { $result = array(); foreach($data as $k =&gt; $v) { $str = sprintf('$result["%s"] = "%s";', str_replace('_', '"]["', $k), $v); eval($str); } return $result; } The idea is to turn mysql_username into mysql"]["username then to plug it inside $result[""], and finally to concatenate = "$v" to the whole thing before evaling it.
thanks i'll try
Only that PUT and DELETE have spotty support among browsers, so you're better off simply using the traditional GET and POST verbs for anything which isn't an API.
Symfony reads _method key on post requests as a fallback.
You might want to expand a bit more on that. --- Edit: I managed to gather the information on my own. Apparently you're supposed to put a hidden input field called "_method" in a form, whose value symfony interprets as the request method.
Oh sorry If you submit post request and body looks somewhat like that key=val&amp;...&amp;_method=DELETE Symfony will assume this is DELETE request. So you can just add to your form &lt;input type="hidden" name="_method" value="DELETE" /&gt; 
http://knpuniversity.com offers some very well done screencasts. They cost money but are absolutely worth it!
MAMP Pro is better. Easier interface and more user friendly. Edit: Editors: BBEdit. Coda 2. Extras: Kaleidoscope. GitBox. CodeKit.
Thanks :)
Coda 2 on mac Notepad++ on windows You do have to pay for coda though so you might not want that. It's worth it though. 
If you want a fullblown IDE you can try PHPStorm but remember that an IDE is not always necessary. I am currently using gedit on Ubuntu and the terminal for git.
I always put a limit when there should be only one returned result. The reason is because the query needs to only look for one. If you had a million users, it would find that one and just keep searching until it hit the end of the database.
They really should grey out the reference pages with deprecated features. Kind of like when you view Android Developer's Reference pages with an insufficient API level. 
If the DataMapper approach in this article looks nice, check out Doctrine2 (not Doctrine1 which is/was ActiveRecord). While I haven't had a chance to fully implement D2 anywhere because I went with a distributed storage system, my next mysql site will definitely use it.
In upcoming PHP, `&lt;?=` is not considered a shortcode anymore. It's merely an alternate (and preferred) way of writing `&lt;?php echo`. But then again, not a lot of people use 5.5 in production!
In my current MVC I use a heavily modified version of this router: https://github.com/dannyvankooten/PHP-Router It supports building fully static routes, fully dynamic routes or anywhere in between routes, matching URLs with routes and I re-factored the URL generation algorithms. Once the URL has been matched, instead of automatically dispatching the action, it returns the control back to your application, along with an object representing the current route and context. I could send you a copy if you want.
The front-controller is really the mastermind. It receives the request, then calls the router. The router either returns a match: &gt; `/read-article/18/my-recipes` matches `/read-article/[id]/[slug]` which is associated with controller `blog` action `read` or barfs: &gt; `/potato` doesn't match anything. Sorry From there, the front-controller gets control back, interprets the router's response and either calls the action (what we call dispatching) or generate/calls an error message. This is the way front-controller/router/dispatchers are usually implemented, but there are many others. Two that I've built and used are the "no router" method, where the front-controller is a big switch statement, and you specify which page to load with a query string parameter, i.e `index.php?page=home`. The other I've done is the dump front-controller and highly intelligent dispatcher, i.e. the front-controller calls the dispatcher for every request and the dispatcher calls the router then dispatches the request.
If the end user can influence the $_SESSION[USERID] variable, then that's an SQL injection vulnerability. I.e. code that can be used to attack your server.
I've sadly used it back in the PHP4 days. It lasted a day before I grew tired of it.
What resource are you learning from? And why are you using a table for only one record of data?
Here's how to do that: First, add a column in your table called "last_action", it will contains the last time a user request a page to your server. In all pages, actualise the last_action field of the current_user with the current timestamp UNIX (time() to get that). "UPDATE userdata SET last_action = " . time() . " WHERE id = " . $user_id . ";" You can't directly know if a user is still in your website, or not. We suppose that a user is connected when his last_action is 3 minutes ago maximum. Then: "SELECT * FROM userdata WHEN last_action + 3000 &gt; " . time() . ";" To get all the connected users.
Well when zend picks up this as standard, so will i. I do sorta like it ... sorta.
Agreed.
And I, along with the rest of the academic community disagree with you. The Single Responsibility Principle is a basic principle of object-oriented programming and design, and one of five such principles which is jointly referred to as SOLID. If you disagree with that, well... Let me just say I'm glad I don't write software together with you. 
I'm curious, why are you going into super defensive mode? Are you really more interested in protecting your own "image" to yourself than actually learning something which almost everyone consider to be the better way to go about things?
I'm just not particularly interested in people's coding styles that they read in a book somewhere and now they're out on a crusade to tell everyone else how they should work. I didn't find anything in this article technologically interesting, and in fact found it to be rather devoid of any substance whatsoever. Basically I look at it like the difference between a news story and an op-ed. If we're arguing about what class the code goes in, that's time not spent on thinking about how we can make it faster or more awesome. 
We use an identifier as PK with email as UNIQUE. We needed some form of persistent identifier for user profiles anyway.
&gt; I'm not sure I'm writing faster or more awesome code. I'm not sure what that even means. If by "faster" you mean in terms of putting a project together, then yes, SOLID helps as it encourages code reuse. If you want to focus on your actual business logic, then I'd recommend you pick up a framework which are already built around SOLID principles and where a lot of the problems are already solved for you. If by "faster" you mean in terms of code execution, if the component isn't causing a problem, then [you're optimising code needlessly for no real gain](http://www.codinghorror.com/blog/2009/01/the-sad-tragedy-of-micro-optimization-theater.html). As for "more awesome", the term is meaningless. Now, like I said to thelerk, SOLID has its strengths in being more manageable, especially when working with other people. It also invites for code-reuse and you're able to swap out a data source without disturbing your business logic.
Thanks for your reply. I guess I've just been a little anxious this morning wondering what all this work I've been doing really amounts to. By the way, did you see my other comment about User class instantiation in UserMapper::loadUser? It doesn't seem right to me.
Instantiation within classes is a big no-no when it comes to dependencies. In this case, UserMapper is essentially acting as a factory, and since it's implementing an interface, you can easily replace the implementation for something else. Now, if you're not happy with this level of abstraction, you could take it a step further by passing along an object factory to the mapper. This might be the preferable option from a SOLID standpoint, as you'd have a greater separation between the object creation and the data source. 
Yeah, my reply was assuming $_SESSION['whatever'] == a sanitized piece of data
You can re-use the same document root as many times as you like. There's no need to have separate htdocs folders.
Here's what I've done in the past, without even comparing to what you're doing. * Use the same document root for every virtual host. * Parse the server name variable in index.php, from right to left, and define the base Url. If you parse from right to left, it's much more reliable. This gives the option of having both `somewebsite.hosted.com` , as well as `www.somewebsite.com`. * In your database tables, most tables will have a column for the website ID, or the company ID, or whatever is most significant. This means pretty much every table will have this column; content, users, etc. Obviously you could refactor this to be a foreign key also, which would eventually reference a parent ID or a grandparent ID. 
Oh god. I've made a terrible mistake.
&gt; If we're arguing about what class the code goes in, that's time not spent on thinking about how we can make it faster or more awesome. Uhhh, no, that's *exactly* how you go about making it more awesome. It is now better code, that's easier to extend, modify and maintain. That is *distinctly* more awesome. If all you are ever interested in is learning what the next new fad technology is that you can glue into your projects, I hope to *never ever* have to maintain your code.
Here's a rant on my personal favourite PHP framework, CakePHP: 80% of the time, I see it get poo-poo'ed whenever mentioned around these parts. But one thing that gives me validation in choosing it, is that it has implemented this pattern ever since at least version 1.2 (4 years ago!). Cake Models are simply that - models for working with data. They follow an active-recordish pattern, but the key thing is that they aren't directly responsible for storage and retrieval of data, just the business logic in using it. They use a DataSource (basically a CRUD data-mapper) to implement that functionality. This allows you to use the same Cake Models, but implement them over an SQL DataSource, or XML storage, or say the twitter API. I've seen countless "new and hot" frameworks since that implement a direct ActiveRecord pattern directly in their model/ORM, that is practically only designed for SQL - *exactly* what this article recommends moving away from. Cake has been doing it "right" since at least 2008. I still have no idea why some people wave it off in a single "CakePHP is crap" to this day.
Is it considered "okay" to have a mapper deal with 2 tables. Like what if my user data was stored across 2 tables. Can the mapper handle the loading and saving of both, or should that be 2 mappers and then the second table data gets passed onto the original user object. I've always used active records (though without any extra functions like the gravatar one). I guess I am having trouble imagining how to set this up if I have a regular user, and then a moderator with more functionality that extends user and requires more tables being read from. With active records I can just extend the original user record and be done. 
I'm worried about PHP's underlying architecture, though. At its heart, it's built on the Request-Response model that HTTP represents. But the web is moving away from that at a rapid pace, and I can't see PHP doing much to adapt to it. I wrote a more fleshed out response as a direct reply, [here](http://www.reddit.com/r/PHP/comments/13pn3v/is_php_still_a_good_choice/c779sx7)
(You missed the sarcasm...)
Thank you, I will check that out.
I am sorry, but if you don't know what those things are, they are the absolute building blocks of any website. You *must* learn the basics first, before you ask a question like this.
didnt read the post nope
dreamweaver works great for text editing and ftp stuff. that's pretty much all i need in development. if DW added netbeans' "find usages", code completion, and support for subversion, id say its the best IDE fucking ever.. but without those netbeans features, its really just the best text editor ever. do not use design mode unless youre creating inline styled html for emails -- oh and it crashes when you open [really] big files, so that sucks.
In my case we couldn't turn off stat'ing for all cases that PHP so that wasn't an option. I wouldn't go that route unless you have a fully controlled and unchanging PHP environment.
Ok, sorry for posting some inaccurate information. The problem occurs when the sample data includes a key that is later redefined as an array. Maybe it was my bad for generating poor test data. $myArray = array( 'mysql' =&gt; 'enabled', 'mysql_host' =&gt; 'localhost', 'mysql_db' =&gt; 'mydatabase', 'mysql_password' =&gt; 'mypass', 'foo' =&gt; 'bar', 'some_very_long_path' =&gt; 'some data' ); This fails, whereas if you remove the top key/value pair ('mysql' =&gt; 'enabled'), it doesn't fail. Of course this makes sense, I can't define the mysql key with a value, then try to redefine it as an array later on. 
Sorry I deleted my old comments and posted a new one that explains why I was going crazy. I generated the test data myself originally, just to try what I thought was a common configuration scenario. I.e. defining a key with a value when really it should just be free to point to another array.
I feel your pain! Don't do it please!
Right you are. I've updated the code accordingly.
The default apc.max-file-size value is 1Mb, the Guzzle phar is 870k. I tested it, and the file does get cached with that configuration. Edit: ok, this is weird, apc shows the memory size for guzzle.phar to only being 8368 bytes. I also found this comment on php.net: http://www.php.net/manual/en/book.apc.php#99775
I don't understand your opening statement. &gt; This is quite a dilemma for us: as all the PSR* packages and composer get traction, more and more libraries and bundles come PHARed. From what I've seen, composer is driving people away from PHAR files. Silex itself no longer recommends you use their PHAR and, instead, recommends composer. Other than one small PHAR in Doctrine, none of my projects that are managed with composer have any PHAR files. Looking at Guzzle's GitHub page, they say "The recommended way to install Guzzle is through Composer." which would, again, seem to indicate that they're urging people away from their own PHAR. So yeah, PHAR's might have a huge performance hit but just don't use them. If you find a library that only releases in PHAR, you should probably point out that Silex moved away and urge them to do the same. It seems like it would be harder for them to do this anyway since you can point composer at any public GitHub with the right composer.json file.
&gt; I am needing to create a quick website and I don't have time to learn how to hand code the user interface. Would using a drag and drop type of application like Dreamweaver the best option? Was planning on doing it in PHP. If you don't have time or don't want to learn how to code it download wordpress: http://wordpress.org/ Unzip it, upload it to the FTP server, run the installation page through the browser and follow the steps. There, you have an effortless, fast website, that you can manage without having a clue of how to write a single line of code.
Thank you for clearing this up for me, I was absolutely confused regarding PHARs. Somewhere along the way I assumed with the further spread of PHAR (post PHP5.4) will yield greater adoption and packages will come bundled as PHARs. So, I can safely say "screw PHAR" and forget about this. One question though: can a package maintainer decide to dstribute the PHAR only version of the library through composer?
I believe that's possible, yes.
It's very similar to the style of routing used in some JS frameworks, such as can be seen with [Backbone's router implementation](http://backbonejs.org/#Router). 
This is a novel idea and it was distilled down into some pretty simple steps. But TBH I'm far too lazy to do all that when MAMP is just a download away. If I really need an environment that I completely control I would rather install Apache, PHP, and MySQL (two of which are already installed in OSX). Also web developers deal with so many languages in their day to day I feel like adding another is not a good idea. Leave Ruby code to Ruby projects and PHP code to PHP projects. That said it is a neat idea and the fact that everything was made to play nicely is pretty amazing.
OK, so, as the original author of PHAR, I think I should weigh in on this: First, APC doesn't support PHAR files; this right here is the biggest performance bottleneck you're going to see (by a guesstimate of a factor of 3). Second, PHARs may or may not be compressed, and support **three** different storage mechanisms. 1. TAR-based archives (this is the one I originally wrote), this is a standard TAR archive. **With or without *whole archive* compression**. 2. ZIP-based archives, this is a standard ZIP file. **With or without *single file* compression**. 3. PHAR-based archives, this is a custom file format that is much much faster than either of the previous two (and that's why it was created). **With or without *single file* or *whole archive* compression**. The main benefit of the TAR/ZIP formats is you can create and open/edit them without any special tools. In fact, I created the first PHAR with the `tar` command, without writing any code at all. You can see a great comparison of the three formats [in the PHP manual](http://us1.php.net/manual/en/phar.fileformat.comparison.php). In the case of Guzzle, there is no compression being used, and it's using the PHAR format. Unfortunately, I'd put the majority of the slowdown on lack of APC support. PHARs are pretty cool, and work really well for things like Composer, or when you just want to grab a library to test during development; but for production deployment, you should probably be extracting the contents and running them off the disk for real (until (if) APC catches up).
Man, it's awful
I'm truly sorry, I commented purely on looks and just assumed it would be able to handle basic shit however I have taken your comments into consideration and as such spent more than 10 seconds looking at the code and not just the buzz. I should have known something was up when I saw that they encourage you to add this code to every page in your website: &lt;a href="http://www.webasyst.com/" style="text-decoration:none!important; font-size:0px; line-height:1em;float: none!important;overflow: hidden!important; letter-spacing:-4px; border:none; cursor:pointer;" title="Powered by Webasyst" alt="Powered by Webasyst"&gt; &lt;img src="http://www.webasyst.com/wa-content/img/dots/red.png" style="border:none;"&gt; &lt;img src="http://www.webasyst.com/wa-content/img/dots/blue.png" style="border:none;"&gt; &lt;img src="http://www.webasyst.com/wa-content/img/dots/yellow.png" style="border:none;"&gt; &lt;img src="http://www.webasyst.com/wa-content/img/dots/pink.png" style="border:none;"&gt; &lt;img src="http://www.webasyst.com/wa-content/img/dots/green.png" style="border:none;"&gt; &lt;img src="http://www.webasyst.com/wa-content/img/dots/cyan.png" style="border:none;"&gt; &lt;/a&gt; Furthermore &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"&gt; Should have been a substantial clue that I was approaching arbitrary decision territory. In hindsight I'm glad I turned back when I did. 
Thanks for the detailed explanation. I had a similar experience with Silex that I could only chalk up to it being in a PHAR. Now I wonder if Silex has docs on extracting it for better performance.
Sublime Text 2 plugins taking a pain to get working? Well that's a first. You sure you didn't forget to install the absolutely excellent http://wbond.net/sublime_packages/package_control ? If so, you're genuinely the first person I've ever heard of having trouble with it. Try it if you haven't!
It's a ruby server serving up static files generated by PHP. No different than Nginx serving up static files generated by PHP.
Vim with [neocomplcache](https://github.com/Shougo/neocomplcache) and [vdebug](https://github.com/joonty/vdebug) plugins. http://www.koch.ro/blog/index.php?/archives/63-VIM-an-a-PHP-IDE.html http://joncairns.com/2012/05/using-vim-as-a-php-ide/
I don't think you're doing it right. 
I used SciTE and EclipsePDT for several years while I was learning, then I tried Netbeans, PHPStorm, and a couple others. I finally choose Geany and used it for 2 years before I switched to Sublime text 2. Linux: Geany has code-completion based on what documents you have open. I have even used it when writing letters as it knows what words you have already used. Geany has nice themes and is very lightweight. Windows: SciTE is very light and fast. No custom code completion though.
Hah. It's quite different. Ruby makes a shit webserver for anything but testing. Same with PHP. Same with Python. Same with nodejs. Use a proper httpd such as nginx, apache, or lighttpd.
Not exactly. Explicitly required stuff gets opcode cached by APC, so it is pretty fast.
curious if this principle can be applied to other platforms that use session ids (eg ASP.NET) and how long they might take to crack ?
Now explain the implications of this discovery.
The point of this is they can accurately generate session tokens of existing users. This is basically a way for them to execute https://www.owasp.org/index.php/Session_hijacking_attack and basic session hijacking prevention techniques will put a stop to this. These are about session fixation (a similar attack) but the prevention mechanisms apply here too: http://en.wikipedia.org/wiki/Session_fixation Bascially if you make your sessions be multi-factor, this attack won't work. An easy one would be to store the user's IP address in the session. For all requests, verify that their IP address matches what was used to generate the session originally. Obviously this would fail for users whose IP changes frequently (such as those behind proxies) but it's a good 90/10 fix. Each time an IP address changes, make those users re-enter their password to re-validate the session token.
This doesn't solve the problem; it takes longer to break in. The best solution is for your application to prevent against session hijacking and fixation. There are a number of ways to do this, best done in combination: * Regenerate session IDs on each request. * Destroy the session on any suspicious activity (IP change, User-Agent change) * Disallow session IDs coming form GET/POST requests (also prevents accidental session hijacking) * Set reasonable session timeouts
Try PHPEd (NuSPhere) or CodeLobster
why show errors to people who can't do anything about them? silly, silly, silly. Capture the errors and have them sent to the inbox of every developer on the team. Give the user a nice friendly message, but don't shit on them just to "encourage" you to do better. 
You really need to read up on separation of concerns. Mixing business logic with HTML is bad enough, but you're throwing SQL into the mix as well, making for a delicate application that will fall over at the slightest push.
I use a mt_rand call at the beginning of a file that is called on every page, there is a 1 in 3 chance the session id will be regeneated. While it does lose some of its protection from regenerating on every page it still makes it incredibly difficult to fixate.
Thanks, haven't been to the site in a while so that is good to know :)
True, you could be using memcached. That doesn't negate all the sites that use the default PHP sessions settings, though. Not many shared hosts let you have access to a memcached instance. And the developers who are at risk here *are* using the language properly. It's the language (and by that I mean the devs behind the language) that are to blame for this.
Doh! I should've thought of that, thanks, this should do the trick.
Apart from accessing someone else's session ID, session fixation is in no way a similar attack. Session fixation works by setting the session ID by specifying it in an URL, and sending it as a link for someone else to login on. This thing works by targeting the underlying random number generator, from which the session manager receives a seed to generate an ID from. Though, as you say, both attacks are easy to counter.
We looked at different platforms, but PHP turned out to be the most retarded.
I have already posted it, but let me write it again: &gt;Yes, this research is relevant, but the tool kit fails to be useful in practice as it requires some local info from the remote target machine such as pid and the output of php_combined_lcg(). This new research allows to bruteforce the PHPSESSID completely remotely with the help of new techniques namely Adversarial Time Sync and Request Twins. Also Samy's research did not consider the fact that the attacker is able to spawn fresh processes which set new php_combined_lcg's seeds using multiple Keep-Alive requests.
&gt;I would use some kind of private key that is securely stored and that will be used on each random token generation. Also reseed the generators AFTER a random number is obtained. It will guarantee that no further keep-alive requests will share the same state. BTW there is a secure function by George Argyros that utilizes /dev/urandom https://github.com/GeorgeArgyros/Secure-random-bytes-in-PHP Highly recommended! Also use session.entropy_file and session.entropy_length as had been already suggested.
soo, relatively speaking, how retarded were the other platforms :) ?
Check out this article concerning Python: http://blog.ptsecurity.com/2012/10/random-number-security-in-python.html Most platforms just use external crypto providers by default, PHP has started to do it only in 5.4 and only for PHPSESSID generation (seeding is still insecure).
Maybe there are changes you can make in your scripts, so that they do the exact same thing, but in a better way ? Import and export tasks don't necessarily need lots of memory. A common mistake in that kind of script, is to load a whole set of data in memory (in an array) before dumping it into a file on disk. The correct way to do that would be to dump records line by line (fetch &gt; format &gt; write &gt; repeat). That was you would have at most 1 record at a time in memory, and a very small memory footprint. If you want to go further, there are even better ways to do it. Disk writes are "slow", and buffering a certain amount of lines before writing them to disk can increase your script's performance a lot. And then it's just a matter of adjusting the size of your buffer (number of lines to process before you dump them into your file). The same thing goes for imports : loading a huge file into memory is not a great idea. Writing it line by line on the other hand, will do wonders. And even better, using your DB native import module (MySQL has mysql-import, and I'm sure every other DBs has their own) will usually be even better/faster.
This was my favorite before moving to osx 4 years ago, and I think I've tried every one of them.
Yes, being in control of all the code would be ideal, and your suggestions are all great. However, there is a lot of third-party code operating within the main loop. This is code I cannot change, and really have no intention of rewriting using better techniques. Each "fetch" eats up 5M of memory that is not released, for whatever reasons. I'm not so worried about the time it takes to run, just the memory resources it eats up. I guess where I am coming from, is accepting that the core code is no efficient, was never written to scale well, but is complex, has many hooks to other modules, and works correctly. It will be impractical to rewrite it, especially as would then become something that *I* will need to support. So my thoughts are to divide the problem into smaller chunks that do fit into the resources available, so then I just need to concentrate on the wrapper. And hopefully it would be done in a generic way that can be applied to other projects too. Writing the output to a file, that can be appended to until it is complete, and then offered to the end user, is likely to be a part of the solution (or uploaded once, and consumed in chunks until it is finished). Doing all this in the background using a queuing system also looks like a necessary approach. Some imports can run for half an hour or more. It is not efficient code, but there are too many dependancies and hooks into that code from other modules to start messing around with it.
I wouldn't kick in the delays as quick as your example. Do that and you'll drive all your users to the next guy who doesn't take such precautions. Make it 10 failed logins before you start and you'll solve the same problem with little extra cost.
Honestly, who would fail to enter their credentials ten times in a row? Three times I'm okay with, then all you have to do is wait a few seconds to try again, just like here on reddit. Frankly, between the loading time of the page, typing in the credentials again, and hitting send, 5 seconds isn't that noticeable for the average user. Especially considering that they'll be going more slow to type in their credentials after the third time they've failed to enter the correct credentials. Now, if you don't want to deal with the page load and the error message, you could just make it sleep for the remaining time of the waiting period before attempting to sign you in (the other way around wouldn't work, since you could just spawn another parallel request and ignore the waiting time) assuming it is not too long. If it is too long, you simply fall back to the error message which asks them to try again in x seconds. 
Linking session to IP should help. In the top of your code: session_start(); if ($_SESSION['ip'] != $_SERVER['REMOTE_ADDR']) { session_unset(); } In code where user autorize: $_SESSION['ip'] = $_SERVER['REMOTE_ADDR'];
Think this belongs here - in case it helps anyone (don't know what the original poster said as he/she deleted the post). Session information is stored locally on the server that is below web access. Similar to cookies stored on your local PC, sessions are on the server itself. What that means is that if you are on a shared server, that opens another way for someone to obtain user information. Also saw someone mention salts below your comment - salts are only as powerful as the encryption that you use. If you have a weak encryption, the salt isn't going to do much to help your cause. And encryption should ideally be one way only, if you can reverse the encryption - it means that there is some information that you need back but also adds another layer of vulnerability. Apologies for hijacking your comment thread.
OK. We can use cookie. start_session(); if ($_SESSION['confirm'] != $_COOKIE['confirm'] || !!$_SESSION['confirm']) { session_unset(); $rand = rand(1, 9999999); //for example. instead rand() you can use any random function //including even letters and other symbols set_cookie('confirm', $rand); $_SESSION['confirm'] = $rand; } 
If he hasn't access to user browser and cookies, he can't know true variant of value.
Not sure it's an option, but if you're looking for something at the server level, [Fail2Ban](http://www.fail2ban.org) is perfectly-suited for this. I use it for quite a few things, one of which is to block brute-force login attempts on a Wordpress site. In essence, Fail2Ban is a log-file scanner - you tell it what logs to watch (ex: Apache access log), what to watch for (ex: 3 failed POST attempts to wp-login.php), and what action to take (ex: banning their IP via iptables for X minutes). It's pretty simple to get started, yet quite powerful once you start considering all the possibilities. TL;DR: got a VPS? [Fail2Ban](http://www.fail2ban.org) is pretty cool.
I believe I was. It's not the sole thing relied upon. It's part of a combination. Though for that reason, I use the complete list delivered by X-Forwarded-For (not just the remote IP record). Any minor change in that or the UA will cause the hash to fail. It's a larger number of guesses that the attacker must make. Even better would be using a good LB with the ability to strip it and write its own with just the connecting address.
I think if you can't see what I'm trying to show you, you're a fucking idiot that should find a new hobby.
I use [Komodo edit](http://www.activestate.com/komodo-edit). Much lighter than Netbeans.
CAPTCHAs work by storing a key in a session, from which an image is then generated and displayed to the user. The user then enters the key in the image into a textfield and submits it, and when that happens, it is matched against the key in the session. If they match, it's a valid request. Now, CAPTCHAs aren't all that great. For starters, it's not very accessible. Secondly, CAPTCHAs are regularly broken, by, for example OCR technologies and other vulnerabilities. This means that the CAPTCHA must undergo continuous updates and change in order to beat the advances in these approaches. Point of the matter is that it is a losing battle. Now, if you want a proper solution for this problem, go ahead and read my answer which I posted earlier. 
If somebody intercept confirm cookie he intercept sessionid too.
I made a mistake. session_unset WILL NOT close the session, only unset all session variables. Now I'm thinking something way to create new session.
This almost seems impossible. Wouldn't this just lead to a wealth of wrapper classes? If my project extends the functionality of a library component (Zend\Validate\ValidateInterface?), I'm automatically coupled. The only way to truly decouple while still actually USING a framework is to isolate code WITH framework dependencies and then inject it into some kind of wrapper without dependencies. You're still stuck doing a LOT of work if you change frameworks, you might save time on controllers and service-layer models, but you're still deep in the weeds. Any interactions with framework components (which is why we use them, isn't it?) couples you to the framework. 
Confirm cookie solves problem of sessionid bruteforcing.
I will be interested to know what information you're looking for. It's basically for beginners.
I tend to agree. I recently migrated a fairly large app from ZF1-&gt;2, so I've felt some of the pain the author is trying to avoid. But his solution is really to create a kind of metaframework. As you pointed out, sometimes you want/need tight coupling in order to leverage the framework. Validator, Form, Routing and associated helpers, etc, were the biggest parts of my migration. Loose coupling is for course good, but at a certain point, it becomes masturbatory. After all, how many times are you really going to migrate an app from one framework to another? I was pretty happy with my migration, because I pretty much stuck to Fat-Model/Thin-Controller stuff. Most of my logic was abstracted away behind a nice set of service classes (or was otherwise build around Doctrine2, which was invariant). So most of my pain points were towards the front-end. Form handling, routing/view-related stuff, etc -- things that weren't easily wrappable anyway.
Yeah I am really having a hard time with this blog post. I just don't see how it would be possible, without making your life a living hell, to follow this type of ideology for even the simplest of web applications. You would need to wrap all interaction between your code and the framework, and then what happens when you switch frameworks? Oh, nbd, you just need to rewrite all of your wrappers. Well now, wasn't that worth it? And then what happens when PHP becomes obsolete? My point is that obsolescence, deprecation and backwards compatibility breaks are all necessary evils. Going to these extremes to supposedly "protect" you (hint: it won't) from those changes is just a waste of time. Choosing a framework is *exactly* like choosing a language. You should accept that you're stuck with it unless you plan to rewrite everything.
Hey! Just added a bunch of things: composer.json, namespace, usage tests and reformatted the file tree (src, tests, etc). Also, I added it to Packagist (https://packagist.org/packages/jsanc623/phpbenchtime)
That is partially a solution, but if the attacker knows the 'username' that they're trying to go for, they can easily manipulate their cookie to have that username, and then kick off the PHP session hijacking, What's being mentioned here alludes to some better solutions: http://www.reddit.com/r/PHP/comments/13w4qp/brute_force_php_session_ids_in_under_8_mins_using/c77ser8
CodeLobster seems nice, it runs fast on my machine. I will give it a try for a few days and see. Thanks.
Does this have an instantiated interface too, or is it just static? If so, why is it just static? Also, using VFS should be a bit nicer than actually smashing the file system whenever you run your unit tests. http://tech.vg.no/2011/03/09/mocking-the-file-system-using-phpunit-and-vfsstream/
That makes so much more sense that it belongs in ExplainLikeImFive...I'll switch the class over to non-static methods tomorrow when I get to the office. But again, thank you so very much for explaining it like this and taking the time out to explain the pitfalls of using static in namespace. 
What sort of class is it?
No problem! I used to use static everywhere as well but it wasn't until someone took the time to explain it to me that I understood it. So when you get the chance, and I'm sure you will one day, you can help the next guy! 
If you have not heard of it, vim is the guru of editors. If you want advanced features, you can configure it that way and if you want a bare bones clean editor, well you can configure it that way too. Good color scheme - solarized / twilight Code Completion - OmiComplete Debugging - vdebug seems cool. I have been using debugger.vim Syntax errors - syntastic (it points out the errors when you save a file. not as you type) &gt;All i can say is - ***It is the god of editors, you just have to have faith in it :D***
i suppose you will still have the unique id for the users, which is shown in different places. Also how would you show the usernames in the website(if it is forum, it should have *Posted by username*) 
"A MySQL connection is required before using mysql_real_escape_string()" try using it together in your mysql query =)
Why are these newcomers so blind to the security warnings and deprecation notices which are all over the page of the documentation? This is NOT how you're supposed to do things. Try this way: $pdo = new PDO($dsn); $sanitizedString = filter_input(INPUT_POST, 'text', FILTER_SANITIZE_STRING); $pdo-&gt;prepare("INSERT INTO myTable (columnName) VALUES (?)"); $pdo-&gt;execute(array( $sanitizedString )); And look up each part in the documentation and read each section thoroughly so you understand what it does and so that you're up to speed on the status for the features. 
This too. filter_input() is the method you want. No need to try and roll your own sanitize method.
 ini_set('display_errors', true); error_reporting(E_ALL); for development.
ive been using a principle like this for years. creating wrappers for plugins makes comeplete sense, and allows you to do things like pass things to error classes, timer objects, and more without interfering with framework responsibility. I even write wrappers for plugins or extensions like phpmailer, or magpierss, when a new version comes along its very very easy to replace. This works very very well on a large codebase if its in an application that evolves, i dont know about the practicalities of following this route if you are building one off web sites.
if you switch frameworks you build new wrappers, thats the idea. seperate your business logic from plugin extensions. Choosing a framework is exactly like choosing a language. I find this wrong, a framework is written in a language. you should learn and understand that before you even use a framework, and in many cases learning the actual language will negate the need to use a framework. Frameworks are for speed and weight. And business logic is independent of many of the things that a framework provides. I see this practice as only beneficial on large projects. And many times using this practice, youll realise how you can do alot of things without your framework and then use the framework for what is was designed for, to enhance your site, not control it.
Masuka?
Right.. Thanks for the tip. I'll update it accordingly
Yeah, I had that thought as well. But for what he's suggesting it could work.
Thanks it worked. I promise i'll learn :)
It works as a static class because I wanted it to be as concise as possible, following the MicroPHP way. But classes are necessary to work with autoloading and PSR-0, otherwise the core could really just be a function or two. Since loggers shouldn't affect your application's logic, injecting one any time it's needed just adds unnecessary boilerplate to avoid hard-coding `Analog::log('me')` vs `$this-&gt;logger-&gt;log('me')` when neither actually impedes the testability of your own class. And I figure once the FIG group finalize their LoggerInterface standard, it'll be easy to write a wrapper that complies with it too :)
Yeah, I'm vote with this guy. You want me to put an abstraction layer on top of a framework? No thanks.... Frameworks are designed to keep me from having to worry about that. If you are gonna switch frameworks, some major re-engineering is gonna have to happen.
I'll tell yah. I use NetBeans. It uses hogs of memory and CPU, but it does everything I need. It has fast searching, excellent git and svn support, and is customizable. I wish I found something that could match its git and svn support (specifically diffs) without using so many resources but it doesn't exist for free.
And yes, there were always workarounds - but now it's out of the box. I only care about this because I build a distributed application, which means the more people on PHP 5.4 the sooner I can start using it for those applications.
So I should spend countless hours writing a framework abstraction wrapper but not my own framework. Got it.
If you write a lot of PHP phpStorm is well worth $100 IMHO.
3 downvotes? Express your opinions with words, I'm curious to know what is bad about hosting companies keeping up to date with PHP version releases instead of lagging behind for 3 or 4 years as they have in the past.
Depends on the situation. The explode approach would work, but I think str_replace or Tickthokk's preg_replace would be simpler (i.e. one line). Also, this might not be appropriate but you might be able to strip off the http: and just use a protocol-less urls.
This works perfectly. You could also use parse_url() and check/edit the scheme, and re-assemble.
KDevelop, since it is (as usual in KDE programs) very lightweight but nevertheless highly configurable. Get it at http://kdevelop.org
strstr and explode don't replace substrings. Performance doesn't really depend on the size of the script, but rather the details of what you need to replace. If you just need to replace 1 string, str_replace() will be faster than regular expressions. If you're replacing multiple parts, a single regular expression will be better (multiple calls to str_replace() vs. single call to preg_replace()) 
Would you mind giving us more context? I find this to be pretty vague. Why would you turn the string into an array? And what do you mean "scaleable"? As in "easily changeable" or something of the sorts? str_replace('http://', 'https://', $url); // http://example.com =&gt; https://example.com Why will the above not suffice? Does "http://" appear multiple times in $url (that would be an odd url), and you just want to replace the first one? preg_replace("/^http:\/\//", "https://", $url); // http://example.com =&gt; https://example.com Don't want to use regular expressions? Well there's plenty of other ways to manipulate it then. if (substr($url, 3, 1) !== 's') { $url = 'https://'.substr($url, 7); // http://example.com =&gt; https://example.com } Or even.. if ($url[4] !== 's') { $url[4] = 's'; // http://example.com =&gt; https://example.com } Although that just looks ugly and confusing to me. And that's just to name the ones that crossed my mind here and now, although I doubt any of this is new to you.
I would avoid using explode() and strtr() because it can be error prone (though you may not see it for this particular application) I would recommend using parse_url($url, PHP_URL_SCHEME) instead of explode() and strtr() for the added benefits of parse_url attempting its best and the command being more compact. Of course, you will still need to rebuild the URL from this, so it is not the most compact solution. (This follows along Mechanical_Turk's post) The most compact solution would be the one provided by Tickthokk. This is a single line to replace http: with https: only if it's at the beginning of the string. You lose your added benefit of parse_url trying to figure it out. The gotchas will be if there is whitespace on the beginning of the URL that starts with http:, or if it is returned in HTTP: $url = preg_replace('/^http\:/i', 'https:', trim($url));
Probably worth the free 30 day trial, will check it out
sorry. to be more clear, I've only been using PHP for a few days and am trying to take a url from an XML returned by constant contact's API (which is a http url), replace the http in it with https and put it in a variable so I can call the API again with the new URL. Constant Contact's example php code uses two methods (I don't know why). In one class, they use explode() to split the http url into an array, grabs the second element in the array and concatenates it onto https. In another class, they use str_replace like so &gt; $campaignId = str_replace('http://', 'https://', $campaign); with $campaign being a returned http url. 
Aaaaaaaaaaaand its not static anymore + added legacy code
Legacy code is now in src/ folder! 
Lookin' good!
Thank you!
A suggestion, from experience: if it's remotely feasible, the best way to learn to handle OOP in PHP is to learn a truly object oriented language. PHP was not originally designed to be object oriented, so the implementation is a little sloppy, and it's easy to develop bad habits. If you learn through Java or C# or Python, you'll understand how it's supposed to work, plus you'll acquire another useful skill in the process.
hi5.com 's last programmer
As mentioned, it's a great idea to apply other OOP language practices to PHP. Having recently applied Objective-C style OOP to a number of PHP projects, I have discovered that some things are not quite as simple. So far the easiest way I've found to deal with autoloading and class access is with [the autoloading function](http://php.net/manual/en/language.oop5.autoload.php). Usually I create a header type file inside a library folder and specify all of the class filenames within it. Including this file in the website header loads each class. Here's an example. function __autoload($class_name) { /* classes */ $classes = array( 'class1', 'class2', 'class3', ); foreach ($classes as $class) { $file = sprintf('class-%s.php', $class); include_once($file); } } This in effect loads all files of the format "class-*className*.php"
Um, this pretty much defeats the purpose of an autoloader, which is that you load what you need when you need it. That might as well just go into your main controller. A better way to do it is to have one class per file, with predictable file names. For PSR-0 autoloading, \Abc_Def\Abc_Def is autoloaded from Abc_Def/Abc/Def.php, for example.
Are you fucking serious? This has absolutely zero relevance for the r/PHP community, it is simply advertising, which does not belong here. I couldn't care less if your hosting provider of choice has upgraded to PHP 5.4, it's not a big deal. Keeping software up-to-date is a basic thing for any half-decent hosting provider, and it's certainly not newsworthy.
Some background on why you may want to use Message Queues: http://www.eaipatterns.com/docs/IEEE_Software_Design_2PC.pdf
PHP 5.5 will have proper password hashing function out of the box. Meanwhile, for 5.3.7+ you can use the same thing implemented as php library: https://packagist.org/packages/ircmaxell/password-compat https://github.com/ircmaxell/password_compat
Thanks, I will look into it. I played around with some of those languages (nothing too serious though) and I already noticed PHP does certain things differently OOP-wise.
Try doing a simple web based quiz or calculator - basically just a form that accepts input, runs it through a function / table, and generates a results page. You can knock something out in a day or two. Try to find a "calculator" that nobody has build before (brainstorm a list of ideas and look them up on Google). There is a good chance you will rank in the search results and get some traffic, which makes this really impressive to an employer...
This is probably one of those times when you're just going to have to test it out and see what happens. You could likely have an answer in 5m and a few lines of code.
This would not be a particularly impressive project IMO, unless you do something really novel and/or use to implement all kinds of design patterns to the point that it's over-engineered, at which point I think you'd be making a bad case for yourself.
Plus, if you contribute to the point that you're added as an official team member (contributor, maintainer, etc.) for that project, it'd look really good to employers when they Google your name.
Similar here. I had been working with PHP for a few years and OOP just didn't make sense to me. Took a couple Java courses and all of a sudden it made sense. Haven't touched Java since but use what I learned from it daily.
What's your deal, dude? The man asked a question about personal projects. I answered in good faith. I stand behind my answer. I'm a dev and a hiring manager, so I think I'm more than qualified to render an opinion on this. The biggest risk in small portfolio projects is you work on stuff that never ships and is never looked at. Start simple, build something that people actually look at and enhance. There a lot which you can ADD to a simple calculator app - in terms of additional features that require data persistance, sessions, etc. Thanks for the nice welcome to r/PHP...
Maybe just setup something like WAMP locally? 
As someone who co-organizes the Memphis PHP User group. If there isn't one in your area, find someone and start one! Meetup.com can be the best way to find potential members. Also reach out to other tech user groups that may be in your city.
Can't do that, I'm not working on a private project at home, this is an issue I have at work.
Don't apologise, you're right. Somebody doing that level of work should not be looking for professional dev roles.
I know. But it's an outdated construct that makes code harder to read and maintain, which is why most standards now specify that it is not something that you should be doing ever. They're differentiated at their point of definition by being marked private/protected -- They don't need to be differentiated when being called, and someone maintaining your code shouldn't have to check the visibility of a method when inside the class in order to call it.
They're differentiated at their point of definition by being marked private/protected -- They don't need to be differentiated when being called, and someone maintaining your code shouldn't have to check the visibility of a method when inside the class in order to call it. It's an outdated construct that most coding standards now specifically specify against doing. It makes code harder to read, harder to write, and harder to maintain.
Matter of opinion.Personally, I think it makes it easier to read. Personally, I would only do it with private methods, ones which you wouldn't need to call from another class.
How so? If I md5'd "(@jkj234)(*#%" as a password for example, how would you even go about figuring that out? The likelihood of that being stored in a database is literally slim-to-none.
Yes, but opinions like these matter on open source projects, when other people will likely be working with, updating, and/or maintaining your code, which is why the community agrees on standards. This one in particular had a consensus reached a long time ago.
Granted other languages have better implementation, but as long as a language is capable of the core OOP features, any language is suitable for learning. Sure, you might get to the "hey, objects can do everything and be anything" point faster with something like Java or Ruby, but these languages don't help you get better at knowing when to refactor something into a class, etc.
Check out [phpMyAdmin](http://www.phpmyadmin.net/).
I'm a professional php coder. Does that make my code professional? Probably not.
Apparently there isn't one in San Francisco, I'm sure the [sf php meetup](http://sfphp.org/) will be surprised to find that out, and just after their 10 year anniversary.
By all technicalities, it does.
Aaaaaand you missed the entire point of my post. Anything that you can "knock out in a day or two" is most likely not going to be impressive, and that is exactly the suggestion that you gave above. You even provide evidence that's contrary to your suggestion: &gt; I've enhanced it a fair amount over time Yes, you can make _any_ project a good portfolio project if you put enough time into it -- it has nothing to do with "a simple web based quiz or calculator". But my point stands that any sort of generic weekend project isn't going to be raising any eyebrows on its own unless you demonstrate some advanced concepts, which of course fall outside your suggestion of "simple" (and if it does, then your interviewers have low standards).
I'm a dev and also hire people. If someone showed me a calculator and that was their crowning achievement I wouldn't hire them.
Where are you from Denmark, Finland or Sweden? (guess that its Oslo that are malwared)
[PSR-1 and PSR-2](http://phpmaster.com/psr-1-and-psr-2-to-be-approved-as-standards/) I highly doubt you'll find a dev adhering to these standards completely as standardization within the PHP community is still, or so it seems, in its early days.
I was pleasantly surprised the Benelux php meeting was at 100 meters from my home... Then got seriously disappointed by the prices... 200 euro for watching 1 tutorial? Come on...
phpStorm has a "power saver option" that makes it much more responsive.
Same question as /u/ocdrupal, there are some groups in Mexico and they are not listed.
&gt;Oops misread the question! You're still doing it: &gt;Apart from frameworks and the like 
Wow I'm a fool. Regardless- the above frameworks utilize the most common sign patterns and are great examples of -professional- code.
tl;dr OP is over complicating his life
1. This has nothing to do with PHP and therefore does not belong in this subreddit. See FAQ ---&gt; 2. This is called the XY problem.
I don't think that issue is specific to StackOverflow. A lot of Q&amp;A forums have that issue, and it depends on a couple of things. First, on forums like StackOverflow, those looking for karma will simply solve the problem hoping to get the most points. Second, the first couple of answers tend to determine the path of the discussion. If the first responses address the symptom and not the problem, it can really sway the discussion away from the true solution. Lesson: Don't be afraid to address this problem, whether in the answers or the or the original question. We're on these forums to give and get help, and while any is appreciated, useful lessons that make us learn are always the best. 
I think that's the framework I'm going to go with. I've just been over the 'getting started' tutorial though and it seems pretty complicated. I didn't really understand the unit testing at all.
http://www.meetup.com/phillyphp/#calendar Apparently they have monthly meetups.
http://php.ug/m/contact Edit: I just used the form to recommend a group, and it was added super-quick. 
I have added some more info and a TLDR.
phptherightway.com
You think namespaces add an unnecessary level of complexity/obscurity and that it is dumb, but you're completely fine with it if it's Java and C++? Double standard much?
"it just feels right" is an emotional argument, not a technical one. Can you give us a *technical* reason why you think namespaces in PHP add unnecessary complexity yet they are OK in Java and C++?
&gt;no because they've always been in it. And? How does the length of time a feature has been implemented change whether it is a good or a bad feature? Again, double standard much? &gt; there wasn't anything wrong with php or php frameworks before namespaces were added. Except, you know.. Naming conflicts. &gt;look at symfony. overcomplicated piece of trash and every project that french bastard does has composer and twig and all that shit its just awful Seeing that this was about namespaces, I assume this is still what we're talking about, otherwise you're not making much sense. Now, if symfony is overcomplicated trash because of its use of namespaces, then by the same logic, so must Java and C++ be. But apparently you don't think that. Seeing as you won't take your own arguments to their logical conclusion, I must conclude that you're arguing from emotion rather than reason. 
Just tested it using: $opts = array( 'http' =&gt; array( 'user_agent' =&gt; 'PHP libxml agent', ), ); $context = stream_context_create($opts); libxml_set_streams_context($context); $doc = new DOMDocument(); $doc-&gt;load('http://domain.com/xml.xml'); $doc-&gt;load('http://domain.com/xml.xml'); Both calls used a user agent string of "PHP libxml agent".
Were I you, I'd probably ask them for a code sample or two. I've dodged more than one bullet when considering moving in on a project this way. You would *maybe* be surprised at how poorly coded a lot of "professional business" stuff is. Granted, not everyone will show it to you until you're employed... but turning down a job because you don't want to work with their crap code is better than spending most of your time trying to work with it. Can't hurt in your interview process either. I used to always go into interviews with the mindset that I was interviewing them to be my employer rather than being interviewed myself. Not with an attitude or anything... just the mindset that I was deciding if they were good enough for me to dedicate myself to. At the very least, showing that kind of proactive interest in how they do things already could make you stand out as a more attractive candidate. Its also a plus if you can show or tell them examples of how your skills and style would effect/improve their existing code. **Edit:** a few more thoughts
[Quoting](http://chat.stackoverflow.com/transcript/11?m=6398271#6398271): "Oh geez. A language isn't OOP or not. PHP gives you everything you need to write OOP code. Whether you do or not is up to you."
Oh my. That's fucking retarded. Here's a list of more productive things to do with that book than reading it: * Burn it * Paperweight * Prop up a crappy table * Learn origami * Hold a paper airplane competition * Make a paper mache reddit alien, post pics for tons of karma Now you're going to tell me it's an e-book, right?
I think I'll do that. I can tell from the Zend tutorial that I'm way out of my depth already.
Going from your name you may be interested in this - http://www.drupical.com/ Similar concept but for Drupal events.
New programming language every year looks like somebody read pragmatic programmer book :-)
Whoa, whoa whoa. Understandable point of view, but that's currently the only way annotations can be used in PHP. Do you also feel the same about the spread of comment-based annotations in Symfony and Doctrine? By the way, I'm not disagreeing-- it is a mis-use of comments. But I love annotations and I can't wait until we get a language-level implementation.
The Symfony framework, and SensioLabs' other products, has a lot of really, really beautifully written code. I'm definitely a fan of Fabien Potencier. https://github.com/symfony/symfony
As a hirer, the absolute best thing for me to see is an active github account. Meaning: contributions to open source, and perhaps sharing a bunch of tools you found useful.
I'm curious, can you show an example of one of these small but impressive applications? or can you talk about *why* they're impressive (enough to get hiring considerations)? Does the quality of the project show programming ability, or is it the fact that you took an idea from formation to completion and then expanded on it in a logical and efficient way? The confusion from other users here seems to be because just making a calculator *is* trivial, so the reasoning cannot be the coding skills required, so explaining why it is considered valuable to hiring managers would be super helpful. Also the position it was valuable for would be good information too (eg: developer, development manager, front end developer, systems administrator) 
Only Java at the same level. I know PHP has its problems but some of the hate for it is ridiculous. Anyway, this topic has been debated ad infinitum, let's not go there!
I think PHP gets a bad rep because of its popularity. Because it is so popular, there are so many pieces of bad advice out there. Add to that the fact that PHP pretty much lets you get away with murder when coding, people start to bash on it.
This. Plus, it's roots were never to be what it's becoming today.
it has gotten a lot better over the year from what I have seen. I started with 5.2.x so I haven't been around too long. A lot of the bad stuff I hear about PHP was from 4 so I don't share the same bias as older developers
Annotations have their place in the modern codebase, for example in PHPUnit tests or Doctrine entities. What your book is telling you doesn't make sense, however, so don't do it. Annotations aren't meant to replace existing functionality that works perfectly well.
Just teach yourself Drupal module development and get hired in no time!
Yet is there anything that HAS to use annotations? 
This. As a developer who participates in hiring decisions, I want to see how you code, know that you can read others' code and modify it successfully. Anyone who shows me open source contributions scores major points with me (bonus points if you used Git) Teamwork and ability to learn is way more important to me than what you know or have done.
I would avoid Cake, I think it has fallen behind the others in terms of capability and usage. Zend is a safe bet, especially for larger projects, and tons of sites use it. Symfony2 is the future though, IMO.
Well, I could see this being good for a junior position or internship, but not much else.
because fuck caching.
Relevant is the current RFC for Annotations in PHP: https://wiki.php.net/rfc/annotations
It's gotten better, closures and namespaces were a big step -- but when compared to more modern OO languages like Java, Ruby, or Python, it's still got a *long* way to go. This isn't to say that any of those languages are perfect (and I'll happily go on a nice long rant about the shit that's broken in Ruby if you'd like), but PHP really does set itself apart in being difficult. Here's a short list of the problems that cause me issues that I have to spend a lot of time fighting on a regular basis: - Objects can not respond to typecasting to anything other than string. - Objects cannot respond to *any* operators. - The scalar type of my primitives is changed in memory with no warning - Closures will always use the namespace they were defined in, not where they were called - No ability to overload functions that are already defined - No ability to modify or extend classes that are already defined - There is no way to gain the abilities of most built-in types in PHP. Even if I implement ArrayAccess and Iterator, is_array will return false, and every array function will throw an error. And here's a short list of things that just irk me: - Functions do not typecast consistently. sprintf("%s", 1) will typecast to string and insert 1. sprintf("%d", "1") will not typecast to int, and will not throw any sort of error or warning, it just silently inserts 0 and continues - Nothing throws exceptions *ever*. Sometimes I want to actually **handle** an exceptional case, which I can't do with errors. - htmlentities/html_entity_decode. Pick a system and stick with it! - A function can do up to 10 different things depending on ini settings, and even compile flags - Often times having access to a core function requires recompiling my *entire* development environment. - E_ALL has changed its meaning 3 times since I've used PHP. At no point has it meant "All errors" - null &lt; -1 &amp;&amp; null == 0 //true - I can not recover from an E_RECOVERABLE_ERROR - The SPL classes do absolutely nothing related to being a class, but instead cause an error to be thrown if you try and reassign the variable to any type... Wat? - Accessing the value of an undefined variable throws an error, but there's no way to declare them without a value. - Unless it's a global variable in which case I have to declare it, but if I forget the code just assumes I want a new local. - Why on earth is the compiler incapable of handling string concatenation in a smarter way than looking for {$? If I decide that $foo should be uppercased in "...{$foo}..." now I have to change it to "...".strtoupper($foo)."..." - The documentation frequently says something "won't work" in a certain scenario, without defining what "won't work" actually means. - So many functions do irrational things because "that's how c does it" except for when the c way makes too much sense. e.g. strpos returns -1 if the item isn't found in every other language, because it could return 0 if it did, and 0 == null == false. For whatever reason PHP decides to make it return a value infinitely more likely to cause silent bugs. - Modules cannot be included individually, must exist on everything running on the system. - mysqli_real_escape_string -- just kidding about that fake one. - We need 18 sort functions even though every other language under the sun has managed to get by with 1. At the end of the day PHP makes my life harder, not easier. It constantly refuses to tell me when something is wrong, instead silently performing the *incorrect* action. It is inconsistent, slow, and is impossible to code effectively without constantly referencing the docs. It's only benefit is that it is installed just about everywhere, which quickly becomes irrelevant for just about any application since you cannot isolate the elements relevant to your code within your code itself. As other languages continue to become more and more ubiquitous, I think that PHP's decline can really only continue. I'm just hoping for the day when I don't have to work with it any longer.
Thats a terrible counterpoint. Do you HAVE to use variables? The answer is no you can use registers, or a stack. 
I think it they are good if used properly. Symfony2 makes heavy use of comment annotations, and it works out really well. I find PHP sometimes to be rather lacking in terms of built-in constructs and syntactic sugars. Annotations like these kind of fill in some holes for the language. It makes things easier that would otherwise require much more code, usually in less ideal locations. However, I would reserve this as advanced usage. I would consider it irresponsible for a beginners book to advocate this. But if it's an advanced book, then go for it. Learn a cool new pattern.
I think that PHP more-or-less copied Java's object model. That's why Java is a good language to use to learn object oriented PHP. PHP isn't a good language to learn OOP because so much of the popular PHP code is still written in the style of PHP4, and the easiest way to do something will usually not be OOP.
In my experience, most 'professional' code is just spaghetti code slapped together to 'just work' and it's not always the best code.
rabidferret, what an appropriate name for that rant. Haha. Seriously though I can't argue with a lot of your points although some of them are nit picky and exaggerated. I agree that it could be better, as could any other language. The only pure language is assembly and I don't see any of us picking that up anytime soon! In regards to PHP declining though, I just don't see it happening. Bigger companies may be moving away from it but most of the web will still use it. PHP is too easy to do and that's why its popular. I mean you can write php code in the middle of your html script so its so forgiving for beginners. And you have to give it some credit on being robust. It runs facebook. 
the code standard where I work requires a DocBlock on all methods and properties. The reason for this is not just the system will parse through it, but it will be an apt description of what everything does for others who will work on your code. I also know of some places where the code is parsed for the DocBlock for one reason or another. I'm not really in favor of this. Now the big thing I would suggest so that you don't get laughed at by others, PLEASE read more on what a DocBlock is and where/when to use them. 
It is complicated and all, but the Zend folks are working on new and better documentation for it. Concerning Unit Tests, I would understand unit tests first before trying to figure out the tests of any framework.
Assembly isn't a language. Erubis. Facebook has had to fork their own version of PHP, and has made several very public attempts to remove PHP from their system (difficult due to the size of the code base). If you don't see the decline, I'd advise looking at the metrics that we do have (language use stats on github, stack overflow question counts, etc)
Making a big deal about code standards in something that should be a tutorial makes me thing it's phpthewrongway.
You assume the publishers of said book actually gave a shit about the quality of it's content.
I've been writing PHP since version 3, so I feel I might have some insight here. PHP is no longer my go-to language for everything, but I still use it here and there for smaller things because I know it so well now that it's very easy for me to prototype ideas quickly in it. PHP is looked down on because PHP is badly designed. I mean, it's capable, and it has definitely evolved, but it doesn't matter how much makeup you put on a monkey. It's still a monkey. This isn't to say that good code is impossible with PHP, it's just so easy to get incredibly lazy and write exceptionally bad code. Good code in PHP requires a lot of discipline. A lot of people here will disagree with my assertion, but in a lot of cases that will be because they're simply not familiar with other languages and therefor have no basis for comparison. Often the elegance other languages provide comes at the cost of learning some new ways of doing things. Many PHP programmers are resistant to change because they can already hack something together the easy way - even though the easy way often means you have an endless stream of problems with bugs and maintainability. Things I see in the community regularly: * people that either don't know about, or won't use PDO and/or MySQLi, even though the older mysql library has been deprecated. * people that either don't know about, or don't know how to properly use PHP's closures for a more functional style approach to problems. * people who still think ftping to their live server is the right way to deploy things * people who either don't know how to use, or can't be bothered to use version control * people who can't be bothered to write tests or documentation I could definitely write an exhaustive list, but the bottom line is PHP attracts bad programmers in droves because PHP makes it easy to write bad code. Experienced programmers often won't stick with PHP because once you've had a taste of any number of other well designed languages it's *hard to go back*.
It's sub-optimal, but it's the best way to really add these annotations. Besides the "ick" factor of comments affecting the running of the program, no other method of storing that same information really has any advantages in terms of discoverability, readability, ease-of-use, compatibility, etc, etc. Many other methods have disadvantages. Once we get some sort of annotation feature in PHP, there will be no excuse to use this (besides backwards compatibility for the next decade, I guess), but until then I would certainly call it acceptable.
This is not common, but knowing it can he done may help you in the future.
I'm definitely not trying to say that you are, and I'm not trying to say that every PHP programmer is bad. I think it's commendable that you are willing to dive in to the language despite the strong opposition from other camps. I'm ok with people having issues with PHP, but it burns me when they make their arguments from an ignorant stance. We use [Capistrano](https://github.com/capistrano/capistrano) and [Git](http://git-scm.com/) here, and they have served us fairly well. We've also found that [Redmine](http://www.redmine.org/) works pretty well as a bug/feature tracking system. Capistrano (and subsequently its recepies) are written in ruby, so if you have knowledge of ruby it's a big plus. Another common misconception is that it's only for rails. While it's true it was designed with rails in mind, it can be used to deploy pretty much anything you want, including php. If you decide to go with git, I would also highly recommend [git-flow](https://github.com/nvie/gitflow) as a means to simplify the git process. It takes a lot of work out of manually maintaining all your branches. Lastly, dive in to [phpunit](https://github.com/sebastianbergmann/phpunit/). Testing PHP is a little more annoying than other languages, but it's not impossible. It will unquestionably save you more time over time.
I've seen professional PHP code. It was horrifying. Not everyone who's getting paid to code is doing it right. The most "professional" code you'll find is code that's done in a consistent style, reuses components wherever possible, self-documents through clear and consistent naming, and is modularized to allow its parts to be reused elsewhere and/or replaced easily.
&gt; The point was that at its core it is PHP and isn't all bad. Every point I've made has been about the core PHP library. Care to give me one specific example of something that it does better than a sane language?
this is obviously going nowhere. I'm sorry I insulted your infinite knowledge
Actually, I'm perfectly happy to have a discussion. I've tried to respond to each of your points individually with an organized response. Unfortunately, you've simply responded with general vague statements, and gotten offended whenever I counter with any sort of point. I'd love to see you give me some reasoning behind the argument that you're trying to make. I'm sorry I insulted your perfect language. 
I write object oriented code in PHP, and I think I'm less critical of the language than a lot of developers seem to be. Where you quoted me, I was actually suggesting that PHP is a bad way to learn OOP -- not that PHP itself is bad -- because it doesn't impose any kind of structure or prevent you from creating awkward combinations of object oriented and procedural code, which a new developer might assume is normal. Most of what's wrong with PHP has more to do with amateur developers than the language itself, especially because it's so many people's first language. Learning on a stricter language, like Java, will provide a better sense of structure, whereas PHP doesn't care if you write ugly or indecipherable code, as long as it meets some loose guidelines.
you win
(Chrome 24) Zoom scroll is disabled? Not even navigation arrows?
I would create a relatively simple project - something with basic CRUD functionality + AJAX interface, in several different frameworks. I think [Laravel](http://laravel.com/) looks really good but haven't tried it yet...
Pick a large project, like a basic CMS. Learn a few basic concepts and write your large project. Learn intermediate concepts and write your project again. Continue to learn and re-design your CMS using new concepts you learn. Example: 1st version: learn basic conditionals (loops, if then, switch, etc) with basic input output (POST, GET form handling, echo, etc), file reading and writing, basic database connections with mysql... 2nd version: learn about creating classes and objects, validating input with regex, various ways to create a basic MVC style architecture, using mysql routines and array manipulation etc. 3rd version: look into mvc frameworks that exist (codeigniter, cakephp, zend, etc). work to create ajax style sites with a php backend + jquery frontend. learn connecting to other databases (postgresql, mongodb, mssql) and parsing other data formats (CSV, XML, JSON). look into extensions like cURL, Sockets, FTP, Sending real email vs simple mailto() etc to expand your arsenal. Benchmark various ways of doing things and try to understand why certain ways may be faster than others (when should you use PHP pointers and when not to? is array_walk faster for certain cases?) After that it's just keeping up with new functionality added. I say to go this route because so many functions exist in php that it would take forever to learn everything in one go. Of course some do it, but I find it keeps your interest better if you can dive right in and start creating some cool stuff. Learning how to do all the stuff that the fancy functions do using the basic concepts will make it so those things are second nature and you can rely on them if that fancy function like array_replace_recursive() doesn't work exactly the way you want it. As you re-write and dig deeper into individual parts of your projects code you'll learn there are often one liners to accomplish lots of code quickly, but trying to learn them all at the beginning before writing any code is crazy in my opinion (if you don't believe me, visit http://us.php.net/quickref.php ... it's a list of all php functions). Most of them I find by accident or reading other peoples code.
I am new to php and am teaching myself. how do I learn what not to do? and what to do instead thank you sir
What book is it anyway?
Neither of those are working.
They're really dredging the bottom of the river for characters to use for new PHP features these days. I see we are very close to needing APL keyboards.
Ah, k. What about less intuitive aspects to PHP. A lot of these posts make it seem like there are non-intuitive aspects to PHP that make it inherently "worse" than other languages. Any guide for those? As far as security and performance goes I will def try my best and should be able to pull it off okay, I think.
I was pretty skeptical about it myself at first, but it's grown on me. Yes, it's not a tutorial per se, but it's a harsh bootstrap into the realities of PHP, and most helpful to avoid the mistakes of the past and the failures of the language itself. 
Pro PHP MVC.
I'm confused, what do you mean by 'disposable'? I hope you're not routinely stripping comments out of PHP :S
PHP sucks, but still [Powers The Internet](http://w3techs.com/technologies/overview/programming_language/all). Guess it sucks to be other web languages. They had [redistributable](http://getcomposer.org/) [packages](https://packagist.org/) way before PHP too. Poor guys just can't catch a break.
WHY do you want to do all this?
Why do people insist that "people use it" is a decent argument for the quality of a language? And I'm a big fan of composer, it's a shame there aren't more decent packages on there (actually there could be for all I know, about 60% of the packages I find on packigist have no documentation or real description of any kind)
Attach the session id to an IP address and use tokens for every request. Don't think that can be exploited.
And just to consider: python has a rather different OOP methodology than Java and C#.
jenkenstein, If you'd prefer something less commandline-y than capistrano (correct me if i'm wrong skeptical, I only skimmed the docs), or if non-technical people will need the ability to deploy, take a look at [Jenkins](http://jenkins-ci.org/) too. It looks like [this](https://builds.apache.org/), and can handle both complex and simple projects. [Heres a template](http://jenkins-php.org/) to set it up for PHP, along with a load of optional code-standards checkers. 
&gt; PHP sucks, but its easy Please give me some examples of how PHP is so much easier than say Ruby or Python. &gt; and thats obviously more important to produce useful stuff (wikipedia, facebook, etc) than being good. Are you kidding me? The only reason that PHP is good for Facebook is because they *built their own implementation*! And even then, it's no secret that they've been trying to get rid of PHP for some time now. The fact that Facebook has to **pay** people to change the sheets when PHP wets the bed is not something to help its cause, especially when you're trying to make the point that it's *easy*.
Chainsaws suck when used as parachutes.
http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
The main problem is that PHP allows for a great depth of bad programming to be done. And thus, a lot of people program badly in PHP. I should know, I was one of them. Learn OOP &amp; frameworks, they are a start in preventing a lot of bad practices.
Any language allows for a great depth of bad programming to be done; this isn't restricted to PHP. I would argue that the "bad programming practice" that is most frequently associated with PHP is from the documentation in the manuals--constant use of mysql_query("blah") or die() is a terrible practice, but until the mysql_xxx() commands were officially sunset, they were on the record as an example of how to do it. Don't get me wrong, there are a lot of things I dislike about PHP, but it's not as though PHP is a magical magnet of bad programmers. Bad programmers are bad programmers no matter what their language; all one has to do is look at the wealth of "enterprise" code written in Java that's full of Impls and data transfer layers because "that's how it's done in enterprise" to see that the language doesn't make the programmer bad.
Well Git or not, any Configuration management knowledge is very welcome. I don't know if I was lucky or not, but when I got hired, they later told me it was because I was the only one that applied that had taken an advanced class in CM. Funny thing was that during the class I was thinking who the hell looks for this knowledge. 
That's because it's a wrapper around the C function. If you come from C/C++, it's very handy to not have to get used to yet ANOTHER API for the same thing. Just do what you've always done.
use IDE with autocompletion GAHD!
As PHP Developers we should compile a list of PHP reference material and rate each one - hopefully those wanting to pay for these resources would have better insight into their quality. Pro PHP MVC was published October 31, 2012, so it's not like it is outdated or anything.
You do realize this whole process is about being able to predict the values of functions such as rand(), right? This "solution" exposes a random number to the attacker, making obtaining the seed trivial.
I hadn't seen this before, bookmarking! Thanks for the resource.
Yes, definitely. there's always [this list from Stack Overflow](http://stackoverflow.com/questions/194812/list-of-freely-available-programming-books), but it's not very extensive for PHP books and these books are free. I'd like to have a more recent list for all the popular PHP books with ratings by fellow redditors, so we know whether a certain book is worth the money or not.
See also [a FAQ](http://www.php.net/manual/en/faq.using.php#faq.using.parameterorder) about this.
All of which are affected by the same vulnerability... Did you even read the issue?
The solution for a programming language's syntax being inconsistent isn't "Use an IDE", the solution should be to fix the syntax.
Since PHP is open-source, nothing's stopping you from doing this yourself. Considering how much you pay for PHP, beggars can't be choosers.
&gt; especially in the way it mixes HTML and PHP (by simply opening/closing &lt;?php and ?&gt; tags). This has become one of the worst things about php. It made sense when php was little more than a templating language, but at this stage not using proper templates is a great example of how one of of php's biggest problems is the vast number of poor programmers using it. &gt; The API is a merging of other languages', particularly C's, so people coming from those languages don't have to re-learn everything. I'm sorry if this makes things 'inconsistent' This is not in any sense where the inconsistencies come from. The underlying C functions being exposed ARE consistent, it's php that mucks around with things. &gt; In short, people wanting to use PHP for things it is not designed for will have problems. Here you're exactly right. PHP was designed for extremely simple home pages, everything else are afterthoughts bolted on over the years. The result is a workable language with a lot of strange quirks and odd behaviors that designed languages don't generally suffer from.
Exactly what my reply would have been. While using something like notepad is ridiculous for coding, requiring an IDE in order to remedy a mish-mashed language is equally ridiculous.
&gt; JavaScript has a ton of issues with it too, but for some reason people complain less about JS It does but the most common complaints are because it's a very difficult to understand language, some of the decisions they made when designing the language seem extremely questionable at first but when you get into it properly it has some pretty cool tricks up its sleeve.
But those who don't like links aren't going to click that.
I wrote a massive answer to this one on Quora a while ago. http://www.quora.com/Do-a-large-majority-of-people-hate-PHP-solely-because-other-people-do-so
Idiots who keep complaining about parameter order and function naming. We get it, get over it. Get some work done and shut up.
For the love of fuck can we please shut up with "PHP sucks because of ordering/naming/crap code/etc" -- stop using it then. Quit bitching and get back to work. Everyone complains about the weather but no one does anything about it.
&gt; This has become one of the worst things about php. Lots of people would disagree with you here, including myself. Sure, you should use MVC or templates for bigger projects. But there's a gigantic need for simple, one-page utilities as well (especially for internal tools). Other languages would force you to use an MVC or templating system to build even the simplest of utilities, but PHP helps you get these types of things up and running quickly and easily with minimal overhead. Not every project is large. You have to do what's right for the project.
It seems to me that PHP became popular because it's so easy to use, not that it's a good programming language.
I am not against the idea but the problem with the "fix the syntax" approach is that it will break an awful lot of applications and websites especially applications more than a few years old with little to no current development. Then again the company I work for still runs an ancient version of php on one of their servers because the application running on it is so huge and old that nobody knows how its internals work and as its still working with TB of data with no problems nobody spares the time to redevelop it. I guess people would just end up being stuck with one version of PHP until their legacy application got replaced or updated.
I didn't mean literally notepad. If your vim isn't helping you in this regard, it's not much better, though.
I got a lot of wonderful responses from both sides of the fence and I'm glad to see that there's as much conflict concerning whether or not PHP is a good language in the community as there is in my own mind. ~~I agree that the inconsistencies can be confusing - string functions that work in similar ways, but have $needle and $haystack mixed up in the argument order cause me to pretty much always reference the PHP Manual as a precaution. That said, it's something that I've come to live with and has not affected my perception of the language on the whole.~~ (Duely solved by Phil Sturgeon in Point #1 of [his answer to a question found here](http://www.quora.com/Do-a-large-majority-of-people-hate-PHP-solely-because-other-people-do-so).) I still personally love PHP and while I admit it has a long way to go as far as consistency and optimization, it does seem like those who develop it are diligently working on making it better. It also helps me better understand why Frameworks are necessary for large PHP projects with multiple contributors - it brings some consistency and sanity to otherwise unwieldy PHP. I would like to address a couple of things specifically: *Concerning the use of an autocompleting IDE:* Something I've liked so far about PHP is that it *doesn't* generally require an IDE. I began programming on plain old Notepad back in High School, switched to Wordpad at some point, and then discovered Notepad++. Personally, I'm comfortable with just code highlighting and bracket matching, and haven't found the necessity for autocompletion. It may not be the most efficient way to do it, but by developing in this way I have become extremely proficient with the behavior of PHP, and I value this expertise. &gt; I smell a troll... that, or the OP is extremely lazy. Who uses a language for 10 years and yet has no opinion about its utility? I wanted to see an actual discussion about the topic with people on both sides, not just read an article titled "PHP sucks balls" and then an article titled "PHP is awesome." If posting a question concerning a potentially controversial topic on a discussion board in the hopes of finding valuable conversation is trolling, well I guess you caught me. I didn't state my own opinion on PHP because I didn't want posts to be "agreeing" or "disagreeing" with me as the OP - I just wanted to hear peoples' opinions. Not to mention, I said I have been working with PHP at a hobbyist capacity. I had a PHP development job for 8 months, the first 6 of which I had never even written a function before. Every bit of PHP knowledge I have gained has been from practical use, trial and error, only learning new things as necessary. It's for that reason I only recently began working with object-oriented PHP - I have found the need to consolidate code in my various projects and have found that Classes would be the best way to do so. *Concerning other languages*, some things I hear about Python make me not even want to begin with it. Specifically, I hate the thought of using indentation instead of curly braces, and the recent version change which broke half of the old Python scripts (changing from "" to ("")) scares the teetotal crap out of me. I like knowing that an application I wrote ten years ago, if I wrote it well by the standards of that time, will still work now, and in another ten years. I've worked with Perl a little bit, but frankly nearly everything I've ever needed to do in it I can also do in PHP, so I haven't found much of a need for it. While PHP might not always be the best language for a certain task, it's a lot quicker for me to write an application in the language I know than to go learn a whole new language for a single task. I'm also working toward learning C and ASM because I would like to get into embedded programming some day soon, but I don't think comparing PHP to C is fair. The purpose of PHP (and Perl, Python, any other interpreted language) is to abstract above and away from C to make it more easily for 'brogrammers' (as so hilarious referenced by another user) to hammer out working applications. That brings me to PHP's ability to execute nonsensical or otherwise very stupidly designed code. Personally, I *do not* appreciate that - I design 100% Valid XHTML 1.0 Strict web sites, and take my PHP discipline just as seriously, even if quicker/dirtier ways work. And I do hate opening a previous developers code to find it absolutely horrible and chaotic - but while I don't like it, I don't blame the language - I blame the specific developers who lack discipline in their coding. I'd like to thank everyone for their opinions on this topic. I know I can find articles ranting or raving about PHP, but I appreciate seeing an actual discussion about it. EDIT: Grammar.
&gt; It stems from people trying to use it for things it was not designed for. For example, PHP now has GTK bindings. Who in their right mind would use PHP to develop a desktop application?! I understand where you're coming from but respectfully have to disagree - I'm extremely excited to see increasing implementations of PHP for creating 3D graphics, desktop applications, or anything that languages like Python or Java can do. PHP may not have started with such tasks in mind, but there's nothing stopping it from moving into those fields, and it would be a boon to me because I would get to develop more diverse applications without needing to learn new languages from scratch.
You're absolutely right. PHP is king when it comes to hammering out a quick and dirty internal tool.
&gt; So it is shit That's your opinion; I haven't stated mine. &gt; but it's free so stfu? _Those that can, do. Those that can't, complain._
http://fabien.potencier.org/article/64/php-is-much-better-than-you-think
&gt; the recent version change which broke half of the old Python scripts (changing from "" to ("")) scares the teetotal crap out of me wat I guess you're referring to `print` which has become a function (instead of a statement). This is generally for the better, and the "fix" is simple enough that it can be done with conversion scripts like 2to3.
It's not my opinion either, since you didn't refute the complaint I assumed you agreed with it. 'You can fix it yourself' it's not a reasonable response, you shouldn't have to, attitudes like yours are the reason these problems still exist. People are so unwilling to admit there is a problem, they start doing what is essentially 'victim shaming'. This is an issue at the core of the PHP community, inability to handle genuine critique.
 /#(\d+)/ &gt;I'm not great with regex so I'm looking for some help. Doesn't sound like you even tried, to be honest. This is one of the most basic things you can do with regular expressions. 
I didn't honestly but I do appreciate your help.
I've tried learning regex before and I just can't wrap my head around it so I do find that it's easiest and quickest to ask a colleague. 
Maybe people don't complain that much about Javascript because you don't have the choice, it's the only widely supported language for developping in a browsers. PHP is a choice, you are not forced to use it.
It is not a wrapper around the C function because PHP strings know their own length. http://lxr.php.net/xref/PHP_5_4/Zend/zend_builtin_functions.c#478
I heard that vim is a pretty bad editor, only people with slow pcs use it.
As far as I'm aware (I'm no expert) they are nonexistent - however I have read something about using PHP to fork a file to another process, and apparently by doing this you can achieve some manner of PHP multitasking by running the same file as multiple processes.
The way I understand it, PHP is designed to be a 'glue' between several other technologies. A web server (often Apache), and a database (often MySQL). The database stores information to be retrieved, PHP turns it into a nicely formatted page, and the web server spits out the page to a user. Other languages, such as Java, Python, and Ruby, have various web frameworks built in that language that entirely replace at least the web server. These large frameworks do a lot more than simply let you program a web page, and they have their place... But for modularity and the idea of one program doing one small thing, which is part of UNIX design, PHP rules. PHP takes in data from the user and puts it into the database, and it takes info from the database and makes an HTML page out of it. That's all it does, that's all it should do. And it makes it as easy as possible to do this, and with some good practices does it efficiently, easily, and securely. I guess this shows either my incompetence or my stubborn willingness to work with a broken system and not complain, but I really don't mind an 'inconsistent' design. Even in languages like Java and Python, I have to look at the references and documentation to remember how to use a function. Same is with PHP, this is just normal for me. "Oh but it's easier to remember if all the functions are named and operate in the same way!" Yeah, so what? Won't help me, I'll still be nose-deep in documentation. To me it sounds like a bunch of OCD people obsessing over how all water bottles should be exactly 8 inches tall, so that they can always know it'll fit in their specific coat pocket. They're all different sizes! I have to check each one against my coat pocket to see if it'll fit! In the case of multiple languages, you also have multiple coats. So you would probably need to make sure it fits anyway, even if all the bottles had the same height. "All jackets should have equally sized pockets!" Yeah, I'm sure you'd LOVE for every programming language to have EXACTLY the same APIs. I'm sorry, that will never happen.
To compilers and interpreters, comments are absolutely disposable. That is, until we write annotation libraries that force these tools to look at comments and turn them into a Frankenstein monster of custom syntaxes that do who knows what. Putting critical functional metadata into comments is like throwing a bunch of regional slang words into an otherwise regular language that everyone can understand and benefit from. You may have never heard these words, and no formal textbook on the language can cover every dialect's idiosyncrasies, but if you don't know their meaning then you're at risk of dangerously misunderstanding what the sentence is actually communicating. I think comments as a programming concept were created for a reason, to allow unstructured and unfettered communication between programmers, safe from misinterpretation by the computer. When we start blurring the lines, and libraries with those blurred lines become more prevalent, we're at risk of losing the benefits we get from separating our structured syntax from our unstructured notations.
&gt; This is an issue at the core of the PHP community It's an issue at the core of every single open source project. Ever. You will always get its fantard users bashing you if you complain about a poor feature and get the "fix it yourself" line because they're too blinded by their fanboyism to see any faults. It's not just limited to php.
If you really want to "just do what you've always done," why not just use C/C++?
It's not a bad editor. It has the steepest huge learning curve of any editor by far, so it gets a reputation for being an elitist, "true hacker" editor, but it's really quite powerful. I use Sublime Text 2, though. Vim is too much of a hassle to learn; I'd rather be coding.
You can probably get away with saying that here... Don't try it in /r/programming. &gt; assuming he's not being sarcastic.
I can't imagine a large desktop application without proper multitasking, or even a video game. 
Google it. It was Mr. Stroustrup. http://en.wikiquote.org/wiki/Bjarne_Stroustrup http://www.stroustrup.com/bs_faq.html#really-say-that
There are lots of reasons you'd want to do this. I'll outline one: Perhaps you have a very niche problem to solve. There are many tools in other languages that solve it *pretty well*, but this particular problem is part of your business' value proposition and squeezing out an additional 3-5% of confidence or accuracy is worthwhile to you. This is especially important when you're an enterprise platform like we are. The rules are a little different than in the consumer space. Great, so now I've justified building it from scratch, but why do it in PHP? Technical debt, for one. Adding Python to our system would give devops one more thing to maintain. Black boxing is another; we built it, we understand it. Integration is yet another; by keeping everything in the same family we're able to do really cool stuff without "hacking" it all together. As a result, our systems are very tight and have incredible uptime. There are fewer gaps and fewer points of failure. &gt; Time is money Sure it is. But *somebody* needs to do the innovation. If everybody exclusively used 3rd party libraries, there'd be no more new libraries! And like I said, the rules are different when you build products for enterprise. You absolutely need to outperform competitors. &gt; and it doesn't sound like you're allocating your resources very efficiently. Who are you to judge, with no information about our business, our architecture, our team, and our skillset? In reality, doing it this way was an excellent business decision because we have a system that does exactly what we need, has excellent performance, and requires next to no maintenance. It pays off in the long run. &gt; and using Python or a different language We don't use Python anywhere.
After learning vim, the editing part of programming becomes completly intuitive. Transforming code/text is a task that I often do, so learning a good way to do that really pays off.
No problem. To answer your question, I've actually laid out "why PHP" in response to another commenter [here](http://www.reddit.com/r/PHP/comments/143y7w/php_sucks/c79tssg)
Preach it! Especially when you have enterprise clients and a 99.99% availability SLA.
Thanks, I appreciate it. Tricky question, isn't it? But most people on the blog and HN have just been saying "do what you love and build good things and you're fine" ;)
Multitasking or multithreading? Anyway, multithreading is a relatively recent development in the history of desktop applications, and many humongous ones have worked just fine long before multithreading was a possibility.
Is it broken, or are there really no PHP user groups in New York? http://d.pr/i/5ZDO
&gt; Who are you to judge, with no information about our business, our architecture, our team, and our skillset? I'm not judging. I'm was just curious because my assumption, based as I said on my extremely limited knowledge in this area, would have been that it was a poorly chosen tool. But clearly you thought it through and explained it well. No need to be defensive, I wasn't criticizing.
Fair enough. I did get a little defensive; I'm the CTO, and it sounded like you were accusing me of ineffectively using our resources! (Gasp!) There's pretty much just one big golden rule I follow: do what's right for your product and your team. In many cases, pulling in Python to do the job would be the right thing to do. In our case, however, it's not. :)
Do we really need one of these "PHP Sucks?!?!" posts every week? There's already lots of material to read on the subject. Use the "search reddit" field.
Another complaint I hear about JavaScript is that it is relatively slow, and some of the language design choices and interfaces slow it down even more. Personally, I do like the syntax (and what has been done with it, like in JQuery), but it is important to do things the way they should be done (and use helper functions), and not take some of the syntax shortcuts the language offers.
What? What do you think a leaky water bottle would leak? The contents are irrelevant. The point is that it's simple but easily screwed up without an in depth knowledge of it's functioning, much of which makes little sense.
Concrete examples of PHP's best/worst WTFs: http://www.phpwtf.org
This is exactly what the world doesn't need. A way for people who know nothing to court fire by installing things they don't understand and have no ability to maintain.
Cheers buddy.
Living up to your name. But i think the benefits outweigh whatever issues you are intimating.
I don't think I'm, or the majority of /r/php for that matter, is in your target market but if I may offer some advice. - Edit this post and link to your site. - Give a few examples and walk through tutorials. Create a couple of short 1-5 minute demo videos for your use cases. - You may have more luck hosting the apps. Even if free, you'll be expected to support it running on N platforms. The number of unique environments can be unwieldy. - You may want to post this to /r/smallbusiness.
Why not use GTK bindings? Who in their right mind wouldn't use it simply because it was released in the 90's as a web scripting engine? It's now 2012, and a general purpose language. 
I love PHP, and it is a go-to language for me. To be fair, I don't usually write large enterprise level applications, though I've worked on them and have built pretty large PHP frameworks. There are too many things about PHP I like over not just languages in its class but all modern languages in general. For example, I have done wonderfully flexible things with PHP's magic methods (who needs to write getters and setters for every property? [or frankly at all?]) as well as its anonymous functions, functions stored in variables, and my favorite, string variables as function names. The sheer power released by these aspects of PHP make developing some pretty robust and seemingly complex tools and apps a lot easier. Sometimes I whip up a PHP script on the command line (using -r) before saving it to a file. It's a powerful yet very non-obfuscated language (compare to Perl's weird $[ $# special variables and it's painful $@# type symbols, or Python's cryptic [::]:] syntaces) and at the same time allows for rapid development (compare to Java and C#'s insistence on repetitive functions and infinitely-nested classes .... AOP would probably not exist but for the frustration of dealing with those damnably OCD languages). Given all that, it is functionally just as powerful as any of the others, yes even Java and C#. Its module library rivals Java's core classes and is comparable to Perl's; its OO ability is as good as any of them. No one can possibly tell me that coding in Java or C# or even Perl is easier than coding in PHP. If they do, they've never really tried to do anything with it besides build a web forum, and while that continues to be the main sort of work done by PHP, it is far more useful than that. That being said, I've dealt with some pretty esoteric PHP situations, filed a couple of bugs against it, including one that IMO invalidated 5.2, and contributed plenty of weird function behavior descriptions to the comments sections of the php.net site (which, I will also note, few other languages have anything that is at once as efficiently documented while socially open and contributory as www.php.net, which alone IMO is an argument for its use). So in terms of complex applications, I think it's fair to say that I've done and/or seen more with PHP than most. Most people don't even know about PHP CLI, and that's a shame. Given all that, it is still my go-to tool language and has been for some time.
It would be nice to have a PHP ext that wraps some larger linear algebra library. PECL's lapack extension is rather weak. Do you have any custom PHP extension code for your linear algebra needs?
Believe you're prematurely optimizing or prematurely scaling might be more accurate. How are the events getting into the database? User submitted? Let it get a decent size before you worry with this part.
I fell asleep reading PHP in Action, and I decided to take a break from reading to experiment with recursion. I am solving for the first brute force solution to the n-queens problem. At around n=16, the server starts to throw the following: &gt;Fatal error: Allowed memory size of 134217728 bytes exhausted &gt;(tried to allocate 71 bytes) Obviously, the first thing that I would think to do to crank out more queens is to start using C, but as I am trying to learn more about coding well in PHP, that is obviously not an option. Is there anything that anyone would recommend to improve either the code itself or the algorithm? [Source Code](https://github.com/jankenstein/php/blob/master/recursion/nqueens.php)
For what purpose?
I don't know how to reduce the memory footprint but you might want to give an Evolutionary Algorithm a try...
I'm not sure I agree that just because its not in a text book its a bad idea (you get that just by using other people's classes), but I definitely see where you're coming from with the comments-arent-code viewpoint. Its unfortunate you can't do complex things as cleanly (discoverable, terse) without annotations. Have you found a nicer way?
The really great thing about PHP (and MySQL, to a certain extent) is the documentation. The comments also add a lot of value. On the other hand, Javascript doesn't really have any central documentation unless you're using JQuery or similar. The Mozilla site is pretty good but it's not in the same league as PHP's.
&gt; the training of a large neural network takes hours or days. True, but I was talking about training an existing large network on a single new data point. &gt; They're red-black trees. Sorry, I had forgotten the term. My point really was to mention the difference between direct memory access vs some kind of lookup structure. Listen dude. I get it. You're a smart guy. You don't think PHP should be used for neural networks. But I'm sitting here telling you that what we have works very well for us and that we love it. I also never once said that you *should* make one in PHP, but that you *can* if it makes sense to you. And it makes sense to us. Why are you so hostile towards the idea that somebody, somewhere, has done this?
No, the *table* would get massive. You can shard tables that are appropriate, though. Splitting up databases isn't going to help you for server load; if they're still on the same server, that's just redundant. Using more *servers* is an option for out-scaling.
&gt; True, but I was talking about training an existing large network on a single new data point. This is not how neural networks work. This is like saying "yes but I was talking about designing just the left front wheel of the car." . &gt; Sorry, I had forgotten the term. `:|` Red-black trees and hash tables are not even slightly related. . &gt; But I'm sitting here telling you that what we have works very well for us And, I'm warning the person you told that to that someone who's only ever tried it one way, and doesn't know their basic datastructures, might be someone who should be listened to ***alongside other more experienced opinions***. . &gt; Why are you so hostile Please stop turning hiding from your attempt to argue with something I said to not-you into me being hostile towards you, thanks. If you give bad advice in public, and someone says to the person you were advising "this language is a bad choice," that is not a case of the third party being hostile towards you. If you would like to be less melodramatic, great; otherwise, I'm not really interested in this conversation that you started with me. There was nothing hostile in what I said to you. At all. That kind of dig is disappointing to say the least.
We use about six different databases where I work. The segregation ocurrs for security, instant-access replication v delayed access, and to account for environmental differences (qa v production, etc).
&gt;The number of connections permitted is controlled by the max_connections system variable. **The default value is 151** to improve performance when MySQL is used with the Apache Web server. (Previously, the default was 100.) If you need to support more connections, you should set a larger value for this variable. &gt;[...] &gt;The maximum number of connections MySQL can support depends on the quality of the thread library on a given platform, the amount of RAM available, how much RAM is used for each connection, the workload from each connection, and the desired response time. **Linux or Solaris should be able to support at 500 to 1000 simultaneous connections routinely and as many as 10,000 connections if you have many gigabytes of RAM available** and the workload from each is low or the response time target undemanding. Windows is limited to (open tables × 2 + open connections) &lt; 2048 due to the Posix compatibility layer used on that platform. http://dev.mysql.com/doc/refman/5.6/en/too-many-connections.html
Even then you should be using multiple database servers, not necessarily multiple databases.
memcached
The first thing you always want to consider regarding caching is whether or not you actually need it. (Insert a thousand blog posts about premature optimization here.) How long does the query take to run? What are the performance requirements of that particular page? If you decide that you do actually want to cache that information, you have a couple good options: * [Memcache](http://php.net/manual/en/book.memcache.php) * Create another MySQL table and cache the results of the slower query in that table * [Serialize](http://us1.php.net/manual/en/function.serialize.php) the results and store them on the disk.
i think you make a lot of good points that help to weed out the mediocre programmers that are so common. i have to remember this next time we hire at my firm.
Do you only want to cache the output from the database, or can you go one step further and cache the generated HTML?
Just use a simple cache table for something small like this: run the initial query, serialize and store the data. If you need regular updates, either a cron to update the cache table or a trigger when something is edited that re-caches the data. memcache is fantastic, but seems like overkill for a small cache like the one you are describing.
I don't think there is a big difference in this case. It depends on whatever would load faster.
Caching the generated HTML would probably load faster because you're doing less. In this case, you could save the generated HTML to a file and read the generated HTML from that file when you want to display it. You could also use memcached/APC/xcache to cache this HTML, though that adds a dependency to the solution and I'm not sure if any of those is available to you.
I think '; DROP TABLE news; --
["Little Bobby Tables, we call him."](http://xkcd.com/327/)
First off, chrisguitarguy brings up a very good point - that setup is perfect for a SQL injection attack. As long as your MySQL indexes are correct (primary key on id, normal index on locale), this query should be super fast and shouldn't need caching. But try putting "$timeStart = microtime(true);" before the query, then after it put "echo number_format(microtime(true) - $timeStart, 4) . 's';" - this should give you an idea of how long it takes to run.
If you don't care about the 'freshness' of the results, just dump the record set into memcached. Set the TTL to 30 minutes, once the record expires, just read from the db again and cache it again.
Read the huge, red, highlighted warning on the page for the function you're using? http://php.net/manual/en/function.mysql-fetch-array.php
You should check your config and make sure the path in http://php.net/manual/en/session.configuration.php#ini.session.save-path exists and the directory is writable by your webserver.
If news really doesn't change very often, your query will already be in MySQL's query cache. This makes me doubt that you've done any benchmarking. 
didnt know it existed, sorry
the issue seems to be it is writable when I access the URL only always with index.php in the end or always without it
What makes you say that?
http://bobby-tables.com/
No problem. The other answers in this thread are on the right track anyways.
I've seen apache blow up many times and serving white pages until restarted.
There are many possibilities: A quick and dirty way is to use static variables or global variables, thus http://developer.teradata.com/blog/neilotoole/2009/06/a-simple-php-global-static-caching-mechanism There are various opcode caches that will speed up the execution of php script, APC being a popular choice. Many web sites save generated HTML to a file on disk and then use .htaccess to automatically bypass PHP (and mysql) entirely. It can be tricky to set up, but the performance is stunning. Something like Varnish https://www.varnish-cache.org/.
If you're new to PHP just start with [PDO](http://php.net/manual/en/book.pdo.php) and skip mysql_*. It will save you headache in the long run - and the short. You can still write queries with possible SQL injection, but it gives you the tools so you can easily avoid it, e.g. [execute()](http://php.net/manual/en/pdostatement.execute.php). If you're feeling more studious, just jump right to [Propel](http://propelorm.org/). 
Pretty surprised their is not one in downtown Salt Lake City. Would have to travel the next county over to get to one. Insane. Anyone in Salt Lake City want to start one?
Doctrine Common has a nicely done implementation of a [caching library in PHP](https://github.com/doctrine/common/tree/master/lib/Doctrine/Common/Cache) that supports multiple drivers. [examples docs](http://docs.doctrine-project.org/en/2.0.x/reference/caching.html).
I got it up to 40+ using a column hash, but the diagonals are giving me a hard time because of the random number generation I used in each placeQueens call. The random number isn't random enough so it never chooses 0 and I can't fill one position, which causes an infinite loop. I'm thinking about using the random number as a starting point and incrementing up to N, then rolling over to 0 through random-1, but I'm still not sure how to implement this for the diagonal check. You might notice I used $index[0], which is an array that contains the current index. This reduces the memory footprint as well because I can pass this by reference and update $index[0] as you do with $index++. for($i=1; $i &lt; count($board); $i++){ if(isCollision($index[0]+$i, $rand+$i, $board, $filledPositions) || isCollision($index[0]+$i, $rand-$i, $board, $filledPositions) || isCollision($index[0]-$i, $rand+$i, $board, $filledPositions) || isCollision($index[0]-$i, $rand-$i, $board, $filledPositions) ){ placeQueens($board, $index, $filledPositions, $indexIteration); $index[0] = $index[0]+1; return; } }
Cool you found an edge case to bitch about a language you are clearly already biased against, thanks for posting.
I think the real question here is: Why on Earth are you passing 1,000 POST variables to a page? This isn’t a fault of the language rather the developers.
There are clearly three problems here: 1. The developer is trying to pass 1000 POST variables, which by itself already says that something is wrong, very wrong with the application. 2. The developer seems to be running severs that do not have error logging enabled, thus he wasn't able to solve this problem by a quick, one-minute glance at the log. 3. The developer is not using the official PHP distribution, rather he is using a package provided by his operating system. There is little wrong with that by itself, but you should expect that security fixes are backported.
I issued a pull request for a fix that gets this up to n &gt;= 50 on 128M of memory. The higher n is the greater the chance of running out of memory, but it does well with 40, and is 50/50 with 50. I could squeeze out more, but I feel like this is good enough since Wikipedia says "These brute-force algorithms are computationally manageable for n = 8, but would be intractable for problems of n ≥ 20, as 20! = 2.433 * 1018". [Code](https://github.com/ajbogh/php/commit/c691055b71b207491b6e5b1484cedc460fad0588)
Great move forward. Personally if it was totally blown away I wouldn't loose any sleep. It's just breeding more bad code being developed going forward - if people STILL have apps that need this extension, at the very least they can use an older/current version (at time of writing) of PHP.
Personally, I think the best option would be to just ninja-alias mysql_ with mysqli_; in a procedural sense, it makes no difference (AFAIK). It would have the obvious benefit of being a completely invisible upgrade to 1000s of users. That way, the concern of all existing tutorials/codebases not working will be non-existent. *"When you do things right, people won't be sure you've done anything at all."*
Don't run the query if you don't need to. Which means, cache/store the result and only run the query if you think it makes a difference to the result. Also your script is short, so storing techniques like memcache or APC can help but not as affective as they can. They help if you have long processes which processing a lot of data. Store the result of your script into a html file and server this file to the browser. Regenerate if you have an update to your data. Then think about your database/table design. It can help to improve the query time.
The original MySQL extension is faster than both PDO and MySQLi. So if a huge website needs this extra speed, they might lose that option sometime soon. I hope the extension is just removed from the default list of extensions, and not entirely removed.
It really depends what are you doing with the code. Full OO style in a very flexible PHP projekt is nice. Following coding standarts will keep the code clean. Some small scripts do not need OO, but as good as a flexible OO project. The main part about telling if a code is professional is the legibility. Code you don't understand or is a bad form of spaghetti-code will not get the professional stamp. 
If the performance of mysql_ is an identified bottleneck in your web app or website, then you will have much bigger fish to fry.
Good, we just need to wait 10 years for people to adopt 5.5.
I searched for it on Google and stackoverflow says it's enough, but it's better to use prepared statements (which I know, but don't have the resources to rewrite the codebase): http://stackoverflow.com/questions/4171115/is-mysql-real-escape-string-enough-to-anti-sql-injection 
It probably is enough I guess, I've just had it nailed into me by ... by internet people, for so long, that you must use PDO/prepared statements. You might consider going further than the default chars that mysql_real_escape_string strips though, for example, stripping out ASCII control characters, etc. ... just in case. 
&gt;For mysqli you can literally replace every instance of mysql_ with mysqli_. mysqli_ functions changed the parameter order. Where mysql_ usually expects an optional link identifier as the last param, mysqli_ makes it mandatory and the first param. So it's not going to be quite as simple as a global search/replace.
Thanks for taking a look. I use the latest version of ZF1 (1.12), which you can find at their website. You may have to update the configuration file as well to match your local settings.
No worries... can't update to 5.5 anyway because I have clients running scripts that were encoded with an older version of Zend Guard that is not supported in 5.3+. Unfortunately, the software developers no longer support their software so there is no hope of getting an update and the software is integral to the sites that my clients are running. *sigh* I have used mysqli for a number of years now for software that I write.
Deprecating it doesn't break it, just issues an E_DEPRECATED notice which can be ignored. The next step will be to remove it completely.
&gt; For mysqli you can literally replace every instance of mysql_ with mysqli_. Tell me more about this mysterious mysqli_result() function.
Interesting who voted on the No side. Wondering why Rasmus and ircmaxell decided to vote no.
That post (from sam @ numbsafari) doesn't provide any information on why mysql_real_escape_string might not protect someone. In reality, the only problem is if you make a huge error and mix up your encodings. Otherwise it's 100% fine as far as anyone knows.
Rejoice? Not if you have a bunch of code out there that uses the "mysql" extension, and it will be a GIANT pain in the ass to change it.
If you have legacy applications then it's highly doubtful you are upgrading to the newest versions of PHP as soon as they are released. Everything dies at some point, and by giving you advanced warning you have plenty of time to plan the upgrade task in your own time. But really, its slow as shit and full of security holes so you should be happy to have the excuse to remove it.
Not true. There are a lot of subtle differences in what the functions do and how you use them, and you really need to study the mysqli extension before you run wild with it. To be honest, I think the mysqli API is crap from a usability point of view. I used to do everything using the mysql functions directly, but I find that the only way I can keep my sanity when working with mysqli is by putting a wrapper around it. Yes, I know there's PDO (which comes with plenty of trade-offs of its own and isn't nearly as powerful as the native API), but I'm trying to compare apples to apples here. mysqli *could* have been designed to be completely compatible with the mysql extension, or it *could* have been designed to be as simple and logical as possible, but they decided to try a little of both and got neither, and then apparently said "fuck it" and piled on a lot of extra garbage that doesn't fit with either approach. As an aside (since this is related to prepared statements, which the mysql extension didn't natively support in the first place), could someone please explain to me why the mysqli API is so radically different depending on whether your query is a prepared statement? I mean, pretty much *everything* about how you interact with results changes, for no apparent reason. For example, why can't I simply fetch an array or object from a result set if I'm using prepared statements? Why do I have to use the variable binding paradigm instead, or use some weird elaborate workaround involving reference magic? Why couldn't they simply be identical APIs, or a single agnostic API that sorts out the differences behind the scenes? This stuff drives me nuts.
It's not a simple matter. For example, some people think it should be moved to PECL instead of spewing E_DEPRECATED errors.
A code base I work on using MySQL. I looked at changing over to PDO or mysqli it's really just not that simple. 
The viability of PHP as a programming platform includes more than its execution performance, for instance there is a very large and oft-ignored codebase from the days of yore, and similarly a very large and oft-ignored collection of developers whom have no interest in moving beyond `mysql_*`.
I do agree the methods and basic workings behind the "auto-magic" should be learned. Although I don't agree they should be necessarily learned prior to using a framework. I still believe it rests on the individual to dive deeper into a framework and see how each segment of the "auto-magic" is created and how the data flows behind the scenes.
@ is error suppression.
I feel like there's a double layer of misunderstanding here. ##First misunderstanding. * You said "I'm really glad that they opted for deprecation in 5.5 instead of doing nothing", implying that you do NOT think that they are "doing nothing." * jtreminio replies "I disagree with your notion that they're doing nothing." implies that he thinks you're doing nothing. My interpretation: jtreminio approves of the deprecation warning, because he disapproves of what he sees as the alternative: removing it outright. As evidence of this interpretation, he says "You can't simply go from fully-functioning to completely broken with no in-between.", implying he wants an in-between. He sees deprecation as this in-between. ##Second misunderstanding. You think jtreminio sees deprecation as "completly broken".
IIRC Rasmus is pretty keen on using as minimal code as possible, while still keeping code readable. 
But OP obviously hasn't, and I'm sure he's not alone. I understand what you're saying, I get sick of it too, but we aren't the intended audience.
"Deprecated" just means it will generate warnings, which you can turn off (see the "suppressing deprecation warnings") bit on that page. And anyway, in most cases you can switch to mysqli by just changing the function names to mysqli instead of mysql in most cases.
Switching to mysqli should be simple. In all of my code I just had to rename the functions and everything worked fine. I think there are some differences in some functions, but they're minor and weren't anything that effected my code.
I noticed that PDO was faster than mysql_.
http://dev.maxmind.com/geoip/geolite is decent and free. You can also look at the Accept-Language headers present in every single browser request. e.g: en-US, en-GB, nl-NL
&gt;I've started building a website that should have different content depending on the country the user is coming from Please don't do this. Respect the browser's settings, not the IPs country of origin. There might be people travelling, or people having just settled which might not read the local language. There might also be people who prefer to read in language X (e.g. English) over their native tongue. So, please, respect the Accept-Language header.
it's more comparing that... screwdriver that's bit has worn down that you can hardly use it anymore, with an old wooden handle that gives you splinters when you use it, vs a new screwdriver with tons of ergonomic features that make it a joy to use.
PHP Community has been trying to keep people from using mysql extension for probably 8+ years and you still haven't moved off of it. This is just a chance for the message to be voiced even louder. 
Due to the nature of the website, I really need to display content based on the ip of the user. Don't worry though, there will be a country-selector available - I will not ignore what you are saying! :-)
Code will still work in 5.5 it's after you have to worry about. Even then it will live in pecl.
Thank you for the reply! Now I just have to see how I could go about making queries in that table...
It's an on-disk file with an API to access it. It can also be used in a built-in fashion with nginx and Apache, so that all you need to do is reference a $_SERVER variable without any additional function calls needed.
mysql is one of those hollow plastic hammers children play with.
I took a different approach - perhaps a little bit more complicated than what you suggested but it does the trick. I edited the original posting. Thanks for the tip though!
Rasmus is right. His only short coming is that he has not been enough of a dictator with PHP. PHP's success is because of his language design skills. Period. And then, as with many successful open source projects (Firefox, maybe?) it attracts a bunch of destructive grammar nazis who degrade the concept of the project and then leave it to die. If you want all the features of Java JUST USE JAVA. Please leave PHP alone. The MySQL extension needed maintenance - not replacement by primadonnas piggybacking on the success of others.
I hadn't heard it can be up to 3x slower. I have heard that it's slower for a one-time query, but much more secure if there's unfiltered input. I'd be interested in how much slower it really is.
I learned how to use "mysql_*" about that long ago. Since then, I have used a standard template that I wrote for all of my db work. It worked, so I didn't see a need to mess with it. I am simply not looking forward to going through all my code to find what I need to change.
Some (maybe most?) shared hosting sites have multiple PHP versions they allow their customers to choose from. Shared hosts rarely force an upgrade, anyway, for that exact reason, so it would be silly to cater to them. They wouldn't be the ones to utilize PHP 5.5.
At Bluehost my account is defaulted to the lowest possible PHP version (5.2) and I have the ability to go up to 5.4
See https://bugs.php.net/bug.php?id=54638
&gt;If you want to cater for the rest of that 1% then allow each table row to be updated independently of each other. And click 200 submit buttons? No thanks.
[This](http://erlycoder.com/69/php-mysql-prepared-sql-statement-vs-sql-statement) was the original article that made me realize prepared statements might be slower. So I did some testing on my website doing timed tests and found that prepared queries using either PDO or mysqli were significantly slower. They're also just not as easy to use, and escaping is secure if you do it correctly. If you're using prepared statements in your existing code, or if you prefer using them, that's fine. Really the performance penalty isn't huge. But escaping parameters and using direct queries are also a good option, so it shouldn't be discouraged.
Nice to see the discussion, just thought it was an interesting point - big fan of Rasmus and his work. But would have thought that moving PHP forward in this way would be a positive for all. But I'm guessing it's all down to breaking a tonne of old/deprecated apps/code and annoying possibly a very large user base. What I think should happen as a plan (somewhat outlined in the RFC Wiki anyway): * Compat. lib/function set (written in pure PHP) to alias all "mysql" global functions (since there is zero OO in this API) back to "mysqli" versions. I'm pretty sure this would work as a "drop in fix" with a require_once() when "mysql" finally gets nuked. * Do the work now to move out "mysql" extn. to PECL. This would probably be the best win for all - as a "mysql.so" you can add/remove as required - and shared hosts could enable/disable per user very easily.
Huh, interesting. Thanks for that! It looks like you can set `PDO::ATTR_EMULATE_PREPARES` to 0 to use native prepared statements.