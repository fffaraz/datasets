The presence of StdClass itself is questionable, since they are 99% the same thing as an associative array. Unless you have some weird library that expects StdClass objects, you won't ever use them.
Technical reasons aside, conceptually it makes little sense. `$obj` is not an "object" but an "instance of `stdClass`". The only justification for special-casing something like `{}` to mean `new stdClass` I can think of is for anonymous objects, and anonymous objects are a mistake in nearly every imaginable context because they lose static analysis benefits.
Going to vote tomorrow, or later today if we're lucky, is the [Anonymous Classes RFC](https://wiki.php.net/rfc/anonymous_classes) It's overkill compared to short object syntax, but the same result: $obj = new class { public $foo = 'bar'; }; It would be nice to get some syntactic sugar on that for sure.
Thanks, this is what the article should have been from the start! I understand the president obviously wants to spread your company's name. My gripe is that it was a topic targeted at programmers, but answered none of the questions that programmers have. This is a programming forum after all.
Javascript inspired? $obj = { foo: 'bar', __construct: function() { echo "wut?\n"; }, }; Or more strictly PHP? $obj = { public $foo = 'bar'; public function __construct() { echo "wut?\n"; } };
Hello, Disclosure bis: I am also working at eZ and I am the author of this article. (I also want to add I am not the president :-)). Apologies if this article was posted may be in the wrong forum, which is a one focusing on development. We probably overlooked that. We won't do it again and will encourage our engineers to share more on the technical side! Beside that, the article is not promotional, and is more looking at the non-technical reasons which are also very important to a product manager. This was intentional, I know we too often focus too much on the technical side. And it is clearly not about Symfony, but more about why moving from in-house to a framework shared with a wider community. I hope this clarifies a bit more too. Cheers
Why would you want one? The point of OOP is to allow separation of concerns and shielding of internal state. What's the point of monkeying around with the internals of an object like this?
Amen!
This is basically a plea to ensure it does pass.
no problem. Glad you you like it :)
helpful still not 'short', just a shortcut
Hi! I'm an ~~helpful~~ annoying bot! I'm here to tell you that 'grammer' is actually spelled 'grammar'. ----- If something bothers you, send me a message
My expectation is a runtime error, as I mentioned before. The currently described behavior is nonsensical. There is never a scenario where you want typehints *themselves* to cause permanent changes to variables outside of the function.
Please. Zeev.
The biggest advantage of generic objects is that you can do true pass-by-reference/operate on them by reference, but with arrays you have to use the crude, error-prone reference operator.
Or just upvotes from the Symfony camp
For the life of me, I can't figure out why the alternatives are more readable. The *Current* code is very similar to other languages and IMHO makes the jumping between Java/C#/Delphi a lot easier for developers. The suggested alternatives seem too terse and the last reads "JSON for everything" to me.
I'm not arguing that everyone should switch. But you can't ignore that for apps beyond a certain # of servers, that one big benefit of using HHVM is going to be less #of servers. If you're autoscaling, having to spin up fewer instance is going to make a big difference.
Why would you want weak types? Can someone explain me?
Not if you use the 2nd argument, `json_decode($json, true)`, now you have an array.
Yes, that's what I would expect. I don't think coercion makes sense with by-ref at all.
Thanks! Thats a good point to make.
Very well done. Respectful and logical. I hope internals really listens to this one.
&gt; Contending that the 3rd group will be happy because we can choose between 2 other modes that we don't like is ridiculous. The entire "group" thing is an abstraction. The reality is there are 100 different views if you ask 50 different people. I bundled them into groups, because it's useful to abstract it. Yes, not everyone will get what they want. In fact, that's an absolution. But the majority of the middle group is given *something* that they can work with. They aren't left completely out in the cold. And that was my point, which I still think stands. Yes, not every individual gets exactly what they want. But there are people who think the strict mode of the dual system is too weak for allowing int to resolve float hints. And there are people who think that "apple" passed to int causing an error is too much. We can't please everyone. But we can please the bulk of every group. Which was my original point. &gt; And that's not even taking into account that there is a not-insignificant group of folks across all groups who dislike the multi-mode RFC exactly because it has multiple modes. Well, then vote against it! Seriously! I even said the proposal isn't perfect. But realize that no single-mode proposal is ever going to win (again opinion, but one supported via discussions and vote tendencies). But this **exact** thing is happening in other languages. [JavaScript](https://developers.google.com/v8/experiments) is doing the same thing for the same reasons (though they are going a bit further). 
&gt; still not 'short' $obj = (object) [];
I always declare a class as a class if I know properties beforehand. If you are building an object to encode it it to json, it's pretty much a DTO already. By defining that structure as a strict SomeSpecificResponseDTO you get much more readable and understandable code instead of relying on "objects" that are pretty much maps
/u/ircmaxell's RFC is failing by one vote right now (65-33). :(
Solution for group 1: function($int, $string); Solution for group 2: function(int $int, string $string); Solution for group 3: declare(strict_types=1); function(int $int, string $string);
Thanks! I appreciate the feedback. I'll update the code to use the more standard `{table} () VALUES ()`: https://github.com/erusev/base/issues/3
Ah, I see, thanks.
Objects are not passed truly by reference either. Object identifiers are passed by value. This is evident if you try to assign a new instance to an object passed as a function argument; the external variable still references the original instance. You still need to use &amp; if you want to truly pass an object by reference.
Yes that's the one. Internals thread here: http://www.serverphorums.com/read.php?7,1155073
If you can't even take the time to get some karma, why your opinion should matter? No karma means you don't contribute to the PHP (internal) ecosystem. Trolls and vote manipulation are **real** problems that karma helps a little. Also the bias from reddit users being only a fraction of the real userbase (who I doubt it 90% touch anything besides the PHP documentation). So even if it's a single vote, it can still be manipulated. Maybe what you want is a revamp of the karma system? I wouldn't mind if people that contribute a lot to PHP's userland get a vote. Or maybe I do, because contributing to userland doesn't mean they have enough knowledge of a C code base or programming language design. Wait, but neither does karma. [WE'RE DOOMED.](https://www.youtube.com/watch?v=aXU8w336oGs)
Regardless of the outcome of this, I'd like to tip my hat to /u/ircmaxwell for both stellar technical work and being both able and willing to navigate the political minefield of PHP internals with well-spoken arguments. Anthony, I hope to have a chance to work with you at some point.
&gt; Zeev's RFC isn't necessarily taking away votes from ircmaxell's If you look at the actual votes, almost all of them alternate yes/no between the two RFCs. Surely there are more tactical voters than Zeev, who would prefer ircmaxell's RFC to nothing.
My company uses ZF 1.13. When I joined it was a regular, vanilla ZF project, but since then I transformed and shaped it to be a bit more modern. I added composer support, namespace support, a container, restructured the directories to mimic what you'd see in SF2, removed all references to Zend_View and replaced it with Twig. After all these changes and more it's actually not quite so bad to use!
If you're too lazy to write any tests, why should we do it for you?
I think any object short syntax would need to just be a wrapper on stdObject. No constructors, and if you want a method then its a property. $obj = { foo =&gt; 1 }; // or $obj = { 'foo' =&gt; 1 }; // Equivalent of $obj = (object) ['foo' =&gt; 1]; The whole making an array then converting it to an object is depressingly common and really should be considered a hack more than anything. I stuck to `=&gt;` there to avoid controversy. Having `:` would be a nice, but just something else for people to scream about. Theres an old RFC for [JSON-style syntax](https://wiki.php.net/rfc/objectarrayliterals) but it didn't get far.
Which java frameworks you used?
&gt; the main direction php's heading in is to make class definitions important because they say what your object is, so you can validate its type, type hint, extend, That is how PHP has been for a decade. &gt; Why wouldn't I say ['foo' =&gt; 'bar'] instead? That's an array, not an object. :)
&gt;That's an array, not an object. :) That's his point, he's asking about the benefits of making an anonymous object instead of an array
I perfectly understand your reaction, Terroragon. I might not have phrased it this way, but it's your right to say it. Since you're interested in the how, I can enlighten you, as I think our details are pretty cool. We were the proud owners of an up to [13 years old code base](http://github.com/ezsystems/ezpublish-legacy). Stable, proven, with a *very* flexible content model, but hard to maintain, reaching limits in performances, badly tested, and based on PHP 3. We were asked to make it much better, _but_ keep backward compatibility. We did it the old fashion way: with an architect and layers. We ended up with a Repository encapsulating our former database, with its clear API, and a swappable persistence layer. The whole thing can be seen at http://github.com/ezsystems/ezpublish-kernel/blob/master/eZ/Publish (API and SPI folders). To make this Repository actually do CMS stuff, we chose Symfony2, for the reasons explained above, and because it matched our requirements: - proven and _flexible_ service container (we have a s*load of services, compiler passes, extension points...) - clear HTTP framework - known, proven, flexible template engine But we didn't stop at data compatibility via a new API. We needed something better, as we wanted to push the Repository out without writing the whole application around it. We also wanted to bring existing customers along. We ended up encapsulating the existing legacy application into the Symfony one, by means of callbacks, closures, inner kernel... the Router, Security layer, Configuration components were all flexible enough so that we were able to plug legacy code in enough places to make the integration smooth enough for partners. I mean, we are even able to inject Symfony services into the legacy backoffice code to bring new features into the old app without writing extra code. We are gradually swapping Legacy out, as planned: the legacy integration was externalized to an optional bundle, and it all went smoothly with some PSR-4, git subtree split. We were concerned at first that the Full Stack would restrain us, limiting us to what was considered. Turns out it's the contrary, and we are pleasantly surprised about that. We have a couple presentations around, such as ([this one](http://fr.slideshare.net/lolautruche/symfony-and-ez-publish-lets-have-a-trip-together)), and a [core dev team blog](http://share.ez.no/blogs/core-development-team/) where more technical details are published.
This is very much a work in progress, but it already works quite well for spotting simple mistakes like undefined variables, nonexistant classes and functions, and properties/methods on `$this`. I hope that in the long term, I can more or less match what JShint does for Javascript. Contributions would be more than welcome.
The strict types proposal doesn't break anything; its an optional thing which you can turn on or leave off - entirely at the option of the programmer. This means its backwards compatible while bringing to PHP some of the best features of strongly typed languages. Hack is a great option for these types of features that haven't landed in PHP yet, but its less accessible for many people.
Check that `$count-&gt;execute()` is returning `true`. If not, there may be something wrong with your SQL statement. If it returns false, `$count-&gt;errorInfo()` can tell you what is wrong. My suspicion is that the date format you're using is incorrect, and should be `Y-m-d` instead of `Ymd`.
&gt;Why wouldn't I say ['foo' =&gt; 'bar'] instead? To rephrase this question of his: &gt;Why wouldn't I just use an associative array instead of using an anonymous object? Do you get it now?
You probably did not real my full comment because I said that the title on Reddit is not the real title of the article. And the introduction made it even clearer that this wasn't about Symfony. The article wasn't extremely technical but I still found it interesting, and judging by the upvotes many people did to.
Oh, yeah. Arrays are unfortunately the answer to everything in PHP because there often isn't a better solution. List? Array. Dictionary? Array. Named params? Array. Enum? Array. Ahh well :)
Please continue to post here and don't let *somebody on the internet* bully you. The upvotes for the post show clearly that the majority of this subreddit found the article very interesting (like I did) and you'll always get haters. Sure maybe there are this to improve in the wording, but I don't get the "You wrote about X but I wanted to read about Y so I'm mad".
But why *would* anyone want to use an anonymous object rather than an array? 
Yeah Steve seems really cool and I thought there was a great connection between you guys, there was no awkwardness or anything like that, great stuff! I'm sorry I obviously missed the blog with the details and such. I've been reading through and its really interesting to thanks! 
How are you finding working with the php-parser? I have a static analysis tool that's been a work in progress for a bit too, but it's more security-focused looking for different bad practice patterns: [psecio/parse](https://github.com/psecio/parse). It has stalled out a bit recently with a job switch that I've made but two other devs have made some impressive contributions to the project in the meantime.
It's pretty good. My main roadblock has been working with advanced nested statements of mixed object property/method and array operations like this: $obj-&gt;prop-&gt;method()-&gt;prop[0]-&gt;method()-&gt;prop; Obviously an exaggarated example, but trying to work out these types of expressions has been the biggest issue with the php-parser library so far (though I doubt any library could make it easy).
You wouldn't want to in PHP because you can't. If you could then you probably wouldn't want to. I don't want to try walking through a wall because I can't, but if I _could_ then I would totally walk through some walls.
That is not a realistic argument. Many people use PHP because that code will run on 99% of the web hosts out there out of the box. If most people could use any other language and needed strict types, they'd go use Java or Go or something else. The use-case for hack seems to be "We like PHP and we have a big legacy PHP app but want to add some newness to it and use strict types and dont want to retrain all our devs and rewrite the whole thing." It's definitely not something you can just flippantly suggest as a replacement, or a reason to naysay on valid new features.
&gt; but often times they're overkill or just unnecessary When? What are you doing that having a full stack available, even if mostly unused, is detrimental to the point it's worth building the smaller stack from scratch?
You managed to use PDO at the start, and checked that it was executed there correctly, why stop? What happens when little bobby tables makes an account?
Yup, +1, let's just make this happen.. Logically, coercive should never have gotten up. Andrea's proposal was so close to passing that blind Freddy could see that with a handful of relatively minor tweaks it would pass comfortably. Zeev bent the rules then, stating it was never about 2/3's but instead about "consensus" (what's 2/3 if not consensus...) and that somehow his status as an original architect should count for more. This instantly muddied the waters - i mean of *course* people would prefer a single mode if it was possible. Anthony was far too nice I think at that point, suggesting he'd be ok with a competing RFC delaying the vote end on his ... I don't want to accuse Zeev of being sneaky or anything... no wait I actually do. Zeev waited until the latest possible moment to release his RFC to give himself the maximum amount of time to white ant a decent proposal. And then Zeev comes out and says he'll support Anthony's if coercive fails.. So it mustn't be THAT BAD. instead of writing a competing item why not work with Anthony to sort improve dual mode? Argh the whole thing makes me angry. I can see a world where we go another major revision with no scalar typehints because a couple of bad apples... 
Amusing, but these signatures do not describe the behavior, and it's the behavior which makes all the difference. [The weak mode of the dual-mode RFC](https://wiki.php.net/rfc/scalar_type_hints#behaviour_of_weak_type_checks) is not the "Solution for group 2" - there are **significant** differences.
Java and Go are both strong, static, and compiled languages, so that's not exactly a realistic argument, either. If I wanted a strong, static, compiled language I wouldn't be considering PHP *or* Hack. :p
I usually use Heredoc when I type raw SQL statements
The reason I mentioned C is because there is also a downside to going for pure speed. PHP vs C is an extremely good example. C is orders of magnitude faster, but we don't use it - we use the slow one! All you are saying is that a framework is slower than raw PHP. You are forgetting how much utility a framework brings. So I'll repeat the question, this time why don't you try to answer it instead of linking off to some irrelevant benchmark. What are you doing that you **need** to save a few milliseconds at a cost of having to build everything from scratch?
Off to a great start, can't wait to build mocks with that!
I haven't read his book, but one year and a half ago or so some friends working on a PHP site with +100K concurrent users - so we can assume they know what they're talking about at least regarding on scaling - bought it and the consensus was that it was already obsolete. Opinions? 
You are falsely assuming a framework will add 300ms. Symfony2 will add ~10ms. This is perfectly acceptable, especially when you should be protecting your web servers with a caching layer. Is this high traffic enough for you? http://labs.octivi.com/handling-1-billion-requests-a-week-with-symfony2/ All I'm hearing is "don't use a framework, you will save money on servers". How much are you saving? What is the cost of developing from scratch? What is the cost of maintaining custom code? What is the cost of getting new hires up to speed on a custom platform? There is no substance to your claim, and you should stop making it.
+1 on those books. Also: * [Building Microservices](http://shop.oreilly.com/product/0636920033158.do) -&gt; a fast introduction to Microservices, talks a lot about how to split concerns - touching a lot of DDD concepts - on a big app * [Enterprise Integration Patterns](http://www.amazon.com/Enterprise-Integration-Patterns-Designing-Deploying/dp/0321200683) -&gt; not all of it, but if you move to an event-based app it helps a lot * [Domain-Driven Design in PHP](https://leanpub.com/ddd-in-php) -&gt; still only half the book in Leanpub, but really promising 
You're cherry picking data to fit your claim and refuse to admit that frameworks are not a one size fits all solution. You're acting as if everyone is using it for the same purpose. You are pathetic.
I've given you plenty of examples, benchmarks and articles, yet you still do the equivalent of plugging your ears and go "lalala I can't hear you!" Twitter ditched Rails, Reddit is written in Python without a framework, Wikipedia uses PHP without a framework, but there are also tons of big sites that do use frameworks. It entirely depends on the functionality of the site. You keep on saying "well, give me some examples of...." I have already given plenty of examples and provided benchmarks, but to you there's literally no evidence to prove that short of writing the code yourself to see which runs faster for a given application. Frameworks are great for tons of uses, but they're not necessary for many. If you're working on a relatively static site, there's no need to use a framework. It may not run slower, but it's extra work for no reason at all. If you have a massive site with really high volume, depending on what you're doing a "generic" framework could be very detrimental. Look no further than Facebook as an example. I use CakePHP and Django quite frequently, but I also know when they're unnecessary. You don't need a jackhammer in a situation when a ball peen hammer is easier to use and will work just fine.
A shortcut to detect if a given object is the instance of an anonymous class would be nice. You can do that with reflection but I would prefer something like ```is_anonymous_class($obj)```. This is required as you can not serialize instances of anonymous classes but you may want to know that before and avoid a fatal on serialization. Otherwise I like having anonymous classes.
I started to refute you, but this sums it up really. &gt; I use CakePHP You shouldn't. That's likely why you think frameworks are slow/cumbersome/hard work. &gt;You don't need a jackhammer in a situation when a ball peen hammer is easier to use and will work just fine. This isn't fact based though if you look at a modern framework like Symfony2. To quote that case study handling a billion req/m: "when you won’t use some of the most time/memory consuming tools like ORM you can achieve similar performance to the microframeworks like Silex (yep, we tested it :-) )." There is no point to going raw, or micro. Modern frameworks are performant enough, particularly when you realize that caching is what makes things fast in the majority of cases.
In the list of 13 I supplied: - 1 is this post, which aims to start drama without presenting any evidence of wrongdoing - 1 is blogspam - 8 are newbie posts: either they're asking for support **even though says in the sidebar this is not a support subreddit**, they're asking for validation of really stupid ideas, or they're showing off really poorly done and poorly conceived starter projects - 2 are upvoted with high upvote-to-downvote ratios, despite my feelings on their quality - 1 is an advertisement for a niche PHP conference So out of that list, there is one post that arguably (and I stress the word "arguably") doesn't fit your criteria for a post sitting anywhere near zero *and* is actually sitting anywhere near zero. What is this grand brigade attempting to do? Prevent Iowans from learning about conferences in their area? The horror!
Aren't you the one harping about "frameworks don't determine speed!"? How sad you don't realize the irony.
You should learn how to chill out.
You should learn to admit when you're wrong.
It's not obvious, please explain.
Last thing needed in this sub is shitstirring like this thread...
&gt;I've taken the liberty of upvoting all of your quality insults posts too, do you feel better now? Not with that attitude. I prefer the stubborn, fact-overlooking one.
Fact: you're an idiot, and I'm an idiot for wasting my time here. Lol cakephp. Good luck with stuff, you sound like you need it quite a bit.
Haha, sorry, I am still learning PDO and it's been ~10 years since I've done anything php. I got it working, here is what it looks like in case you were interested: $today = date("Ymd"); $query = " UPDATE admins SET lastact = $today WHERE username = :username "; // The parameter values $query_params = array( ':username' =&gt; $_POST['username'] ); try { // Execute the query against the database $stmt = $db-&gt;prepare($query); $result = $stmt-&gt;execute($query_params); } catch(PDOException $ex) { die("Failed to run query: " . $ex-&gt;getMessage()); } 
If you need help figuring out the difference between a stack and a framework let me know. Good luck passing CS 101!
check the /new section. all submittions get insta-downvoted just a few minutes after submittion.
I can't tell if you're trying to make a locally-hosted phishing site or whether you're trying to automate your own login to facebook. Either way, I think you may be barking up the wrong tree.
 public function formatSql($sql) { return preg_replace('/ +/', ' ', $sql); } $sql = $this-&gt;formatSql("SELECT * FROM Table INNER JOIN OtherTable USING (MyID) WHERE Name = 'scott';"); Of course in the best case you just call formatSql() in your database handler before query execution
Or even better: $myLazyValueObj = { id: 1, firstName: 'Donald', lastName: 'Duck' fullName: function() { return $this-&gt;firstName . ' '. $this-&gt;lastName; } } 
this
or you just don't like Go, and don't want to spend time relearning java from 12 years ago
I think this is a good idea. At least it might provide a semi-concrete talking point in internals as to whether a feature is something that is wanted in the community. There's plenty of examples of people referencing community support and the opposing party refuting it as here-say. I'm sure if the community was overwhelming in support of an RFC (even without voting rights) it would have an impact on the 'democratic' process...
What's interesting Phil is none of the reasons you state here are glowing endorsements for the use of PHP. Typically I'm an advocate for PHP but the whole STH debate has eroded my confidence that it will continue to grow with the developers that use it and that other competitors won't eventually see PHP go the way of Perl.
Not just bug, serious security hole.
Here you go: https://github.com/camspiers/closureaccess
\*cough\* ^(`register_globals`) \*cough\*
I wouldn't need 3, and 2 should be easy. But I'm mostly concerned about 1: &gt; Find the reflectionfunction of the function/method being called With the php-parser lib when you visit a `MethodCall`, you have an instance of the variable. In [your code you check the variable name for `this`](https://github.com/anlutro/phint/blob/master/classes/Visitors/MethodCallVisitor.php#L19) so you know which class the method belong to because of the current context. But here in `MethodCall` you have only the variable name and the method name, not the ReflectionFunction or the class name. So it's extremely hard to find the class name because I have to track back where the variable was created/assigned and guess what class it was… And what if there was multiple assignments, or if it was a parameter, or… So many possibilities…
If you're using anonymous classes in a situation where you need to serialize, you're using anonymous classes incorrectly. Your colleagues should not have to worry about your anonymous classes. Anonymous functions have the same problem.
Because they are resistant to change. This is the way they have been doing it for x years and "fuck you I'm not changing my ways". Thats the mentality we are dealing with.
You could also use an array: $sql = []; $sql[] = "SELECT *"; $sql[] = "FROM Table"; $sql[] = "INNER JOIN OtherTable USING (MyID)"; return implode(" ", $sql);
IIRC with heredoc don't you need to unindent the delimiter completely which messes up the indentation? e.g. class Something { function doSomething() { return &lt;&lt;&lt;SQL SELECT * FROM whateever SQL; } } 
awesome... and the arrayof rfc pls...
I think my future plans (specifically traversing nested property/method calls) require there to be an autoloader present regardless, so I might as well stick with it. I'm not really targetting the legacy code audience anyway.
To be clear, the problem here is not that serialization is non-sensical but that it is *impossible* (work-arounds notwithstanding). On the contrary, it would extremely useful -- it's just very difficult to do in a sound way; even Java doesn't know how to serialize lambdas. I'm leaning towards being in favour of PHP simply giving up instead of creating a solution that has a dozen weird edge-cases.
[RFC author here] Well… yeah… It just works since 2005… But I'm sure, without the OS X Mail.app I wouldn't use it anymore...
No, honestly, it's a difference in philosophy. In my functions, I want to be sure what types I'm dealing with, so my functions always begin with a bunch of "$foo = (int) $foo; $bar = (string) $bar;" crap. I'd love to streamline that boilerplate by putting weak type hints in the function definition. But meanwhile, I don't want to *reject* a numeric string for not being an int, or an int for not being string, because then all you're doing is kicking the boilerplate down the road by forcing the caller to do the manual casts. As always, it's the caller's responsibility to call the function using appropriate arguments. That's true whether we're talking about strong or weak type hints. The benefit of weak type hints is that you save the work of having to do manual casts by automating it in a sensible way.
A stack is the term for all of the tools/products being used: The operating system, server software, programming language, frameworks (both front and backend), database, etc... LAMP (linux, apache, mysql, php) is a very common stack. A full stack developer is somebody who interacts with every aspect of the stack instead of just one or two aspects, like a DBA or a front end designer. In laymans terms a framework is a library of code that generally has some kind of structure/pattern/style (such as MVC) to which you write your code around. Frameworks usually contain pre-written code used by many people such as user authorization, caching, templating and data retrieval. 
That's the best point I've seen so far. It's very similar to the javascript behaviour there too, which is why `Object.create()` and other Object functions have become so popular over in js-land. Of course, you still can manage assign-by-reference on an array. Using your example: &lt;?php $a = []; $a['prop'] = 'foo'; $b = &amp;$a; $b['prop'] = 'bar'; echo 'Array was changed: ' . $a['prop'] . "\n";
I think the scalar types proposals should be dropped for now, and brought back up in a year or two 
Have you considered [using hphp]( http://www.slideshare.net/mobile/nickgsuperstar/static-analysis-for-php)?
now/heredoc isn't going to introduce gaping security concerns. Just an easily fixable compile time error. 
I think the big problem here (and im sorry, this isnt very delicate)... The php community generally isn't smart enough to have an educated vote. I'm including myself in this. It's like asking a 14 year old to vote in the Presidential Elections... He or she can, but would it really be a good vote?
The developer is asking us to test it when he hasn't written any tests himself. I don't know what else to call it.
One day. I'm still recovering from the last attempt.
Naive? Collaborative? Hopeful? All are more fitting than lazy, and less rude. Edit: Furthermore, just using a little common sense, I don't believe he is asking you to write him a test suite, it sounds more like he is looking for some adopters to give his framework a try. But feel free to dismiss him as lazy anyway, that's your prerogative.
Is the JS farming the computation out to a C module? Most benchmarks I have seen put JS even slower than PHP for calculating fibonacci sequences. Do you have a link?
That's not the same thing that the OP was asking for at all.
sigh.
I see, its good to know, thanks for your explanation and best luck to it! 
Sure. It's just a situation where a few votes may change the whole outcome again.
The point of an interface is to enforce contracts between objects. If you allow multiple arguments when the contract ensures only one what's the point of the interface then? An interface shouldn't state "this object is okay as long as it contains the specified contract's method(s) and the required arguments per method." It should state "this object is valid only if the method implementations are exactly the same."
I can't decide if [PHP RFC Watch](http://php-rfc-watch.beberlei.de/) is a good thing or a bad thing... It's great that there's now a place where we can keep an eye on it without having to constantly go `echo php -r '68/(68+35);'`, but on the other hand, the impulse to check on it every 20 minutes or so is getting harder to control.
&gt; The point of an interface is to enforce contracts between objects. You can still call the method by ignoring optional parameters and the contract is perfectly respected. So the implementation respect the contract of the interface 100%. &gt; If you allow multiple arguments when the contract ensures only one what's the point of the interface then? An implementation doesn't exist just to implement an interface… Think about it, a class can implement multiple interfaces. Also, a class can be used without caring at all about the interface. For example in Symfony framework in some classes you care about Symfony's container implementation. But in other places (e.g. application code) you care about the interface because you want to be decoupled from Symfony. &gt; this object is valid only if the method implementations are **exactly the same**. **No that's not the point of an interface.** Have a read for example at [Covariance and contravariance](http://en.wikipedia.org/wiki/Covariance_and_contravariance) for example. The point of an interface is to specify something that implementations must **implement**, i.e. offer/expose. They don't have to be strictly identical. For example, the implementation can: - provide more public methods than what's defined in the interface - type-hint against more general types in argument types - support more optional arguments The point is that I should be able to use an implementation like its interface. I don't care if there are more public methods, optional arguments, etc. As long as **they behave according to the interface**.
You must be joking, right? Tell me you're trolling me? No-one can be this stupid?
&gt; the problem here is not that serialization is non-sensical but that it is impossible I don't believe that. For an anonymous class it is easier than for closures (because there is no ```use ($..)```, but I am convinced it is perfectly possible. Even if there is a weird edge-case that will not work, then so be it and throw an exception. But to say closures and anonymous classes are not serializable per se is just giving up on the topic without really trying. And there are userland implementations for serializing closures that handle most cases, why do I need an external userland lib for such a fundamental thing?
Why do you say cakephp is dead?
the rfc nees more than 2/3 of the votes to pass.
"Do you have a link?" &lt;-- No, i did the benchmark myself (with the fibonacci (Recursive one) ).. built identical *programs* in python, php, and js. python took 27 seconds, php-master @ 19 seconds, node @ 1 second for fib (37) in my machine..
Don't mislead people, that's not true. &gt; For these reasons, a feature affecting the language itself (new syntax for example) will be considered as 'accepted' if it wins a 2/3 of the votes. Other RFCs require 50% + 1 votes to get 'accepted'. 50%+1 is logical to get actual majority, but 2/3 (not over 2/3) majority is required for language-affecting RFCs.
and I think you are missing MY point, that your concern is NOT a valid reason in THIS case. Not to mention, it wasn't even MY blanket-statement.
ohhhh, like private classes inside a class?
He did, but it's unclear if (well, *when*, given the current vote count) he'll choose to withdraw. Zeev's RFC currently has 38 no votes to 20 yes. Anthony &amp; Andrea's RFC currently has 36 no votes to 68 yes. At this rate, neither will pass and *everyone* loses.
It's not bad, it's just unprecedented.
a.) not sure how much quicker a convenience method would be. b.) Is your production bottleneck really going to be caused bu a reflection method?
&gt; b.) Is your production bottleneck really going to be caused bu a reflection method? Whether or not this is the case (and reflection is slow in *any* language), needing reflection in production is always a hack. It's sometimes a useful, very rarely even a necessary, hack, but it's always a hack.
1. Devour all of the advice on http://www.phptherightway.com/ 2. Learn and understand the most common vulnerabilities on https://www.owasp.org/index.php/PHP_Top_5 All the best!
Get on phptherightway.com - it's an awesome source for new (and experienced) developers. I'd also advise getting yourself familiar with Vagrant, you'll want to use that, especially if you're a Windows user. Avoid wordpress if possible in the future. It's a pile of shit and few experienced PHP developers will take you seriously if you're not able to understand why it gets such a bad rep in the PHP developer community. I'd personally get myself stuck into a personal project to help improve my experience. Say for example, a simple CMS system that uses composer based packages, an is at least 80% covered by unit tests. 
This is not constructive discussion.
This would easily be solved with method overloading, but right now in PHP you're only limited to one single signature per method name. You should probably be advocating that, not the way interfaces work.
You can do the following: switch(true) { case ($foo === 12): //do something break; case ($foo === '12'): //do something else break; }
That is ridiculous!
So 71-37 right now (failing). But Zeev promised to switch his vote if Zeev's RFC fails, which it looks sure to do. That would make the vote 72-36, which is exactly 2/3 majority.
Perhaps, but if you take guywithalamename statement at face value, 25% of the no voters (and 4.2% of the yes) should not have been allowed to vote merely because it was their first time voting. That is...silly... *Edit: apparently /user/&lt;username&gt; isn't the right way...
Sure. I'm not saying they shouldn't be allowed to vote. I didn't [in my mail on list](http://news.php.net/php.internals/84828). I was just pointing out the irregularity that 75% of those voters who never voted before voted against.
Indeed. It is highly irregular. My disagreement was with guywithalamename's statement that they shouldn't be allowed to vote is all :)
Seriously, though, can anyone explain the "no" camp's position here, because I'm honestly not getting it. I'm not looking for a straw man misrepresentation, I really want to understand. This RFC (and its predecessors) seems like an excellent and much-needed feature. And while I live squarely in the "strict-or-die" camp I don't see any problem with other people getting what they want if I get what I want. 
&gt; This is pure political mayhem in the making Absolutely, it's virtually PHP internals "House of Cards" 
&gt; slowly improving current casting glithces I'm not sure if I'd like such a move. Breaking the language once is something that should be done with great care (even if it might be the the right thing to do here). But touching the same areas multiple times over the course of multiple years forcing the same code to be revisted multiple times is something to be avoided imo. On the RFC: Implicitly converting the marker for the absence of a value to a typed value is a showstopper for me
I notice you're using `$params['end']` to bind, but `$params['timestamp']` in the printed string. 
Thank you! Why is it always the stupidest thing every time I ask for help?
1 ppl just changed his vote from no to yes. If it stays like this, the RFC will pass.
The dual-mode RFC is actually passing right now with exactly 2/3 of the votes. And that is without Zeev's promised change of vote to yes, if (when) the other RFCs fail.
It happens.
2 more persons voted yes. It is 74/36 ATM
php,mysql,jquery : http://www.infotuts.com/cascaded-dropdown-jquery-ajax-php/ (has a popup modal, sorry) You should post 'help' questions over in /r/phphelp 
Adding optional params in the implementation doesn't change the behavior defined by the interface, just like adding methods do. Again, *as long as you implement the interface*. The keyword is `implements`, not `is`. &gt; Adding additional **optional parameters** has absolutely nothing to do with the interface or its implementation at all. Hey I did it again ;) Again, *as long as the class implements the behavior defined in the interface*. So in short it should work with the signature defined in the interface, that's all that matters. Every thing else extra is OK if it doesn't affect the behavior defined in the interface.
try this one: http://news.php.net/php.internals/84561
At least one of them don't have any karmas listed on their profile page. I won't come out and say it's suspect, but still... come on, that's kinda suspect.
try the census.gov site. about best I can offer. It might only do county.
Edit: What I was saying didn't help the situation.
He is making the internal list even more toxic than usual, about the STH. I hate him for that. We need STH, or a lot of ppl will go to hhvm/hack. I'll be one of them.
From a less experienced eye, this looks fantastic.
&gt; Additional parameters do affect the behavior defined in the interface. How? The second method *can* be called with one parameter, without ever knowing that the second parameter exists. That second parameter doesn't affect the interface, of the contract defined by the interface at all. It is *compliant* with the contract as it can be called like defined in the contract.
Look what he just did : https://wiki.php.net/notrfc/scalar_type_hints
Urgh. Please don't spread the internals drama here. 1) This is not the place for it 2) Without appropriate backstory, this is meaningless to most people, and most people are not going to run through the past few months of strict types / type coercion discussion (and even fewer who would want to even try to summarise it) Suffice to say, a number of internals members are totally against this kind of move and do not support this kind of "not an rfc vote, but let's pretend it is" move. The votes displayed also cannot possibly accurately reflect what people will actually vote if/when the associated Basic Scalar Types RFC does actually go to vote, because it's author has stated it's a "backup plan" that would only be considered for voting if BOTH the Type Hint / Coercion RFCs that are currently officially being voted on do not pass. --- In my opinion this is a dick move by Zeev, who is basically hijacking someone elses RFC for his own means, even after the author of the RFC explicitly told him in no uncertain terms that he did not want Zeev to touch his RFC in any manner.
&gt; I wonder if he will actually change his vote to "Yes" on Anthony Ferrara's RFC as he said he would multiple times. I would love to be proven wrong on this and I will gladly eat my words if proven otherwise, but **no**, given his past behaviour, I think it's highly likely that he will simply weasel word his way out of that "promise".
A couple of hours I saw FUD passing by that the RFC would turn PHP into Java which is in line with a remark Zeev also made on the internals list a couple of week/days ago. I find it really insulting that they are trying to pass any criticism or pointing the obvious in that regards as "offensive" and playing the "do you know who that person is ?" card... again. It is really becoming tiresome. &gt; Do you know who Kristian is and how instrumental he was in the proliferation &gt; of PHP? How can you bring yourself to say he has no clue? It's fine that &gt; you disagree with him, but saying he has no clue is offensive &gt; Let's also not pretend there hasn't been countless calls by the RFC &gt; supporters to vote Yes, including ones that pretend there's no problem here &gt; and it's good for everyone. If Kristian's position is FUD, so is that. And that post symbols everything that I find wrong with his attitude and his tactics. I personally don't care if it is the fracking pope or somebody who solved world hunger. I should be about facts, not ego`s, no fear mongering, no FUD ... just facts. 
This STH mess has to end ASAP. Anthony's move is welcomed, Zeev is clearly out of control. I hope the RFC will pass.
Get your python out of my php! But seriously, I like it.
He will use this unofficial poll to break the rules so the language is going where he wants it to go. His move only proves that he doesn't care about other opinions. It seems I'm not the only one to understand it that way, since he is getting "no" from most voters (2 yes/10 no), and one of the "yes" is his. I think he shot himself in the feet with this poll.
&gt; He will use this unofficial poll to break the rules Then wait until he actually breaks the rules, and complain about that. Holding an unofficial poll about a technical issue should always be allowed. This subreddit is beginning to resemble an echo chamber a bit too much.
Now that Anthony has changed the date, Zeev can't vote yes on it, because his poll hasn't come to the end yet, and he's sure that it'll pass. He needs to wait for that to finish before he can switch his vote, otherwise he's not "giving the community what it really wants." I'm not saying this is right, but this would be my guess as to what his reasoning will be. My second guess would be that STH will be 1 or 2 votes short, including Zeev, so changing his vote wouldn't matter any way (despite the fact that Zeev changing his vote would likely have a ripple effect).
Hasn't he already broke the rules by launching the CTH RFC the way he did ? If I remember well, he made major changes to his patch, and launched the votes right after. It's against the rules, since he should have waited several days before starting the votes for his RFC. It is actually one of the recent complains about Zeev.
Yes, that is a valid complaint. But I don't see how that is relevant to Zeev's right to run a straw poll.
His RFC is guaranteed to fail at this point. Zeev can use that reasoning if he wants to, but it would just be a way to go back on his word. A single vote switching from "no" to "yes" is actually a pretty big deal, because of the 2/3 clause. Any "no" vote needs 2 "yes" votes to counter. It ends up being the equivalent to 3 new "yes" votes.
Making it a poll that people "vote" on gives the wrong impression regardless of whether he's in the right. It should've just been a thread on the mailing list asking for comments, instead of asking for a simple "yes/no", without any surrounding context.
It is extremely clearly marked as not an official vote. I really don't see how anybody could get any other impression. Asking for comment on a mailing list is not an effective way to know the actual quantity of people supporting an idea - the "loudest" people might be overrepresented. Especially when we are talking about ~100 voters, a mailing list is simple to an effective place for a straw poll. The concept of basic type hints seems fairly clear, though there might be details, but the straw poll was about the concept in the abstract. And there were discussion on the mailing list. I don't think there is a critical lack of "surrounding context".
Ah I think we start to understand each other. - I've never said you *can* (or should) use the optional param when type-hinting against the interface: obviously I agree with you, nobody should do that as it breaks the point of the interface. So when using the interface, stick to the interface. - in some places it makes sense to not care about the interface at all, and that's where the optional param makes sense (just like the extra methods). Think for example of a "helper" or "builder" or whatever class that *is tightly coupled to the implementation* for valid reasons (not everything is meant to be decoupled). That's in those cases, when using the concretion (and not the interface at all), that using the extra param is OK &gt; The fact that you can call a method without an optional parameter doesn't mean you're going to get what you want out of that method by doing so. You are assuming too much. The role of the interface is to define a contract, an *interface*. The definition of "interface" is a way for 2 systems to communicate, so here we are defining a way for X to call Y. No assumptions should be made on **how** the implementation work. So the important thing is that the implementation with the extra parameter *should behave exactly like defined in the contract when called without the extra param.*
It is slightly confusing when compared to Javascript: ``` $a = ["foo" =&gt; "bar"]; "foo" in $a; // false ````
We don't need to wait. We can express concerns about the direction an approach is taking. It's better to address those concerns now, than to wait for the situation to become even more polarized.
Lol now he's launched an "unofficial" poll to see how people would vote if the basic STH was brought to a vote... but it's not official so it's ok. And he has the nerve to get all uppity when people call it like it is - blatant manipulation to get his own way. People don't agree with his assessment about dynamic/coercive type hinting (practically on any level - that it is in any way "sane", that it is what people want, that it is how people expect STH to work, that it wouldn't have an impact future optimisations), he's routinely shown to have barely a rudimentary understanding of the topics he's talking about...and still he throws his toys out of his pram and stoops to blatant manipulation.. and when called on it pouts in the corner like a child. We get it Zeev, you don't like strict STH. Or dual mode STH. Now it's time for you to get that the majority doesn't agree with you.... 
But you are assuming bad faith. That is poisonous for cooperation, and bad form.
Also, the misuse may be likely for you, but not for everyone. And its hardly severe. Its a quick fix.
&gt;Isn't it fair enough to hold a quick unofficial poll to gauge support? In an isolated incident, absolutely. This would be encouraged. You have to look at the whole story though. When Andrea had her vote open, Zeev literally yelled at her saying her v0.1 proposal had "consensus". He went **really** far with the abuse, going on to insult her publicly (to which he still hasn't apologized). He harped on the consensus point over and over. He said that "v0.1 would easily pass". After she left, I picked up her proposal and made 2 tiny tweaks. I got a mail from Francois (Zeev cc'd) basically asking me to stand down. He said that him and Zeev would work on a proposal themselves. I said I'm not stopping with this proposal as it was so close to consensus. I then continued to explain why the v0.1 proposal wouldn't work (basically [this post](http://news.php.net/php.internals/84689)). I was ignored. So we want ahead with parallel proposals. There was concern about how voting would work since mine went up first. After much back and forth on-list, I offered a good-faith alternative: I would keep my vote open until Zeev closes voting his competing proposal (which we hadn't seen by that point). Then he posted his proposal. Several people raised serious concerns. Me included. He said "he just needed to tweak" it. A patch was posted. We showed it broke **a lot** of code. His response? "We need to tweak it, don't judge it!". He said "Don't test with the patch, we're still tweaking the code". Then a week went by. A week with no announcements, nothing. Then, all of a sudden, a vote was opened. I tried to diff the page but got nothing (due to errors on the wiki). I then called him out on list. His response? [Nothing changed](http://news.php.net/php.internals/84550) (which wasn't the full truth, rules did change). Let me quote part of it: &gt; While I only put in the final changes today, they're identical to what I said was going to be done on the discussion thread a week+ ago, there was no further feedback or discussion on these changes. The patch (minus these two minor changes) has been available for over a week. We pointed out that pushing to vote shortly after changes is not cool. He argued there was nothing wrong with it. No votes poured in. He continued to argue. We pointed out the issues with the proposal. He argued. Ok Whatever. Then Bob (/u/bwoebi) went ahead and opened a RFC as a "fallback" in case mine failed. It was basically was Andrea's v0.1 proposal, with a pretty significant tweak (behavior of `null`, but we only found this out later). Zeev's RFC was failing hard at this point (70% against). He immediately jumped on the proposal suggesting it go to vote immediately. We pointed out that the rules said it required 2 weeks of discussion. He said "we discussed it already". He pressured hard to get it to vote, even saying he'd fork the proposal and push it to vote himself. We pointed out that the rule **he wrote** said he couldn't do that. His response? "Why are we being so lawfirm"? And that his interpretation is different (even though we showed him quotes of his prior interpretation). So what does he do next? He pushes hard for a vote for the basic proposal (Bob's). *Several* people say he's out of line, including [Bob himself](http://news.php.net/php.internals/84857). He back-channel campaigns *hard*, asking people to support him (and worse). Then what? [He opens a straw poll](http://news.php.net/php.internals/84912). By itself, the straw poll would be fine. It would have been great a month ago when I took over Andrea's proposal. Or even 3 weeks ago when people raised concerns with his proposal. But no, he waited until half way through voting of *his* proposal. This isn't something that has been railed through. This is something we've been working on for **years**. He came out of nowhere, said "he knew better". He put up a proposal, and it failed **hard** (or more specifically, currently is failing hard at 63% against). Rather than doing the honorable thing and admitting failure, he's trying whatever he can to get *something else* in. Which is not cool. 
/u/robdura 
No I mean, I understand the weirdness with having to explicitly unset $v after using it in the foreach loop, but what I failed to understand was how the last code snippet demonstrated this weakness. Unless that wasn't its purpose ?
why can't we reset the internals and simply have an expert nucleous handling the pull requests and the community voting on the rfc's?
Ideally I would want it to be : $x !in $someIterable But I'm not sure how hard it would be to implement, so the current proposal is good enough. Also, I wonder how it would behave with associative arrays ? I'm guessing that since we already have array_keys and array_values, we could write code like this : if('foo' in array_values(['a' =&gt; 'foo', 'b' =&gt; 'bar']))
"Program to an interface, not an implementation"... Is it relevant in dynamically typed language like PHP? If so, why? 
If you use very specific database functionality then an orm is not for you. Simply as that, if you have a good design in your code you should easily be able to use raw sql when its needed an orm for the rest. 
any suggestions on how to make a non-strict version of the comparison? in &lt;- not strict inn &lt;-- strict BTW, the above example is kind of rediculous
It's relevant, for exactly the same reasons as other languages. It allows you to swap the implementation you're currently using out for another one, either due to business reasons to change, or to allow using a mock object for testing.
`not in` feels like it should exist. 
 in &lt;--strict inish &lt;--not strict There we go.
reading the internals mailing list is like listening to my 5 year old and 10 year old sons in the back seat of the car on a long trip "he touched me. No I didn't. You touched me. Nah uh. stop looking at me. you're looking at me. Dad he won't stop looking at me. Hey don't stick your tongue out at me. He touched me again. You touched me first" In a recent post I suggested we have a community poll to gather interest in different RFC's, not for voting members, just for regular every day users. It seemed like the people who replied suggested "if people want to vote they should contribute" but if you read these mailing lists for a half hour, who in the their right mind would be compelled to work with the internals group? Seriously, I love PHP, I always have, I've used it nearly exclusively for 16 year! But I'll be damned if I'm going to be one of the people that sticks my hand into a running garbage disposal. Down vote me if you will, but it's pure madness.
This isn't just one guy. It's a fair number of internals folks who do not like the direction the others are taking the language in. Zeev is just the vocal one.
You're going places. I don't know where, exactly, but places!
The expected output would have been: ax bx cx but the unintuitive reality had 'bx' repeated twice.
Maybe the STH issue needs to be a wake up call for the community that we need to lobby internals more on the features we want in the language.
Or maybe we should just fork the language and let zeev and his old timer buddies stagnate as they wish...
Great write up. I learned a lot as a non-voting pleb. PS, "Opinion" is spelled as "Opinon" on your page. 
I'd really *love* to be able to do this if( 3 &lt; $SomeVariable &lt;= 12 ){ //do something } instead of if( 3 &lt; $SomeVariable &amp;&amp; $SomeVariable &lt;= 12 ){ //do something } 
PHP internals needs to grow up and understand that there is a certain point at which any possible productivity benefit offered by a community member can be matched or shadowed by that member's overall negative impact on the community, and create a way to kick people out. And then it needs to recognize that Zeev reached that point a long time ago and that the rest of internals needs for him to not be able to contribute to PHP anymore. This is basic project management, but the PHP internals is so overly democratic it's practically communistic.
+1 That is one thing I really miss from Python. 
I don't think there is any overlap, but it's been a while since I used either one, so they may have added features since I last used them. phpcs checks for code style issues (indentation, linebreaks, braces...). phpmd checks for code complexity issues (function body length, number of methods...). Phint does neither - I don't know if there is a word for what it does, but it tells you about undefined variables, methods, properties and so on. It doesn't care about the style or complexity of your code, it just tries to parse it and look for objective mistakes.
The reason for using strict typing is to prevent inconsistencies like this: http://3v4l.org/pcE8I
Anthony, First, let me say that your extensive use of back channels is not cool at all. I'm perpetually blamed for using back channels, but I don't have dozens of reddit posts or tweets dealing with internals@, trying to shape public opinion. That would be you. Secondly, I did not 'yell' at her. No use of caps or anything. No swear words. No insulting words like 'Sneaky', 'Abuse' or 'Political' - just 3 of the words you chose to use against me and others in the last month. For those who want to know what 'yelling' looks like according to Anthony, [here's the thread](http://www.serverphorums.com/read.php?7,1128464,page=3). When Andrea left, I also spoke with her to ensure it wasn't me who pushed her to leave. She did say the interaction with me played a part in it - but a minor one. Which doesn't stop Anthony from continuing his quest to portray me as a malicious person, bullying and shutting people up. A lot of people tell me I had my chance to put the Basic RFC for discussion and vote, but missed it. That's true. Why did I do that? Because I was actually aiming for consensus, and didn't want to leave the proponents of strict typing without a good solution. Coercive is a lot closer to Strict than Basic (weak). Unfortunately (from my POV) - this was voted against by many people and has slim chances to pass. In terms of my recent push to open a parallel vote on the Basic RFC: * First and foremost, I did not 'force' anybody to do anything. I stated my opinions, in a very respectful way with no swear words or offending words. * The Basic STH vote was being blocked from going to a vote without the mandatory minimum discussion period, despite it being identical to a proposal that was discussed in detail a few months ago. Yes, I consider this a technicality and not an issue of substance. But - when numerous people made their position that that was the case, including Bob - who brought up the Basic STH back on the table, I respectfully accepted their position, even though I disagreed with it. * The Basic STH vote was now being blocked from going into that very same discussion period (that would allow us to vote in way that's clearly in according with the Voting RFC rules), because the deadline for RFCs was March 15. That deadline is coming from Milestone 1 in the [PHP 7 Timeline RFC](https://wiki.php.net/rfc/php7timeline) - which incidentally I wrote - and passed in a true consensus. It calls for "Lining up any remaining RFCs that target PHP 7.0." by March 15, which is very much open for interpretation. Yes, there was a discussion on internals on interpreting it about a month ago, a discussion I unfortunately didn't follow. In that discussion, two interpretations were discussed - either all RFCs finish voting by Mar 15, or all RFCs start voting by Mar 15. The version that 'All RFCs are put on the table and begin being discussed' wasn't brought up. When I skimmed through the discussion, I said we should go for the more lax interpretation, which out of the options presented was 'voting must start by Mar 15', because resolving the Scalar Type Hints saga was a lot more important than a a couple of weeks. Unfortunately, I didn't go back to look at the actual RFC text; If I did, I'd see that a very valid interpretation (and most likely the intent) was that RFCs are, well, simply lined up - not voted on. Now, I realize that strictly speaking, people who want to block the Basic STH RFC have technical grounds to do it. Do they have moral grounds? I'm not so sure. With a bit of good will, such as a statement from Anthony saying it's more important to resolve this once and for all than sticking to technicalities, I'm pretty sure we could have resolved this peacefully. But that wasn't in the cards - I was portrayed as a villain for even asking the other camp to be flexible, and prefer substance over ultra-strict process. Also note that the lax interpretation about the meaning of 'Lining up' did not come from me, but Bob Weinand. Which of course, did not stop people on the list from attacking me as if I came up with it. Speaking of good will. I committed - publicly, and more than once - to switch my vote in favor of the Dual Mode STH - in case the viable alternatives (Coercive &amp; Basic) fail. Not because I think it's good - obviously I think it's quite bad. I did it because I think the community wants SOME form of scalar type hints, it almost doesn't matter which - a position voiced by dozens of people in the last couple of months. I proposed that we put the Basic STH up for a vote, and if we see - as Anthony said numerous times - that it stands no chance at passing - not only will I retract it, but I'll move to support the Dual Mode STH with both my vote and influence, trying to convince as many people to do the same. Here's what [Anthony made of it](https://www.mail-archive.com/internals@lists.php.net/msg77214.html). What about the straw poll? Yet again, portrayed like each and every action I ever do with zero benefit of doubt and absolute confidence in malice and bad intentions. At least one person that cannot be blamed to be a blind follower of mine thinks there's [nothing wrong with it](https://twitter.com/SaraMG/status/577225234375417856). Contrary to the claim, I didn't "wait for the last moment". I worked on Coercive. Basic wasn't on the table until Bob put it there on Friday. This is what's on the table now. And last, the overnight shortening of the vote, from ending on the 25th to ending today (the 16th). So yes, I'm this really bad guy for **talking** and **discussing** possible options, without actually doing anything (other than an unofficial straw poll, that is). Anthony, on the other hand, feels that he can just change the voting period on his RFC, and give everyone just over 23 hours, instead of the published 10 days. And make that decision and action during the weekend, no less. No discussion, no consultation, just unilateral action. I'm sad that we don't get the chance to vote on both Dual and Basic in parallel, seeing for the first time what the community really thinks about both options as they relate to each other - AND allowing me and others to support Dual STH if we see there's not enough support for Basic (which again, I committed to). Instead, we're being forced to get the dictation of Dual, and only if it fails - actually see where Basic stands - which runs the risk of not having anything for 7. Under these far from ideal circumstances, I'm hoping Dual STH fails, and hoping Basic becomes a fallback option that will go through successfully. 
Can someone explain to me the development of PHP (itself) to me? Heres where I am at so far: For Bugs there is a Bugtracker, but who assigns these Bugs to people? Who fixes them? How are they both chosen? For new Features and changes there is the RFC system. I read that you need Karma to do stuff there (Vote / Propose), but how do you get Karma? Or in other words: Whats the process from moving to a new Major Version (Bugfixes &amp; Features), what people are involved and how did they get to be involved? Thanks for any summaries =) 
Both your proposed RFC's have no chance of passing as the current vote and straw poll show. The vast majority of people (including the community members that can't vote) are behind the dual mode RFC. You promised to vote yes on Anthony's RFC if your RFC fails. Be a man of your word and withdraw the clearly failing RFC(s) and switch your vote. It is the only chance to get STH in as we all can see. Right now a lot of people are seeing you as the villain. It would be really easy to become the hero. But you would have to put the opinion of the majority above your own, which is hard to do I understand. But please do it for the sake of PHP.
&gt; he's routinely shown to have barely a rudimentary understanding of the topics he's talking about. Give one instance, please.
I don't want to pay for a subscription. Do you know any other sites?
For me it only complains if you do return something but the return statement may not be reached. In my version you can use void and it will equally complain if you do return something. But you can't have `@return string|void` 
As I want to create is like moment js. Not like Carbon. Wanna add new features like endOfDayFromNow and etc...
&gt; Anthony could have been the hero if instead of climbing higher and higher on the tree Well he is the hero.. and you are the *villain* here..
So I have all my classes commented for PHPdoc like a good boy. But now I hear that comments slow down execution time of scripts, what do I do? Im using a custom framework I inherited.
Perhaps, but they DO seem to be in the minority here..even if the vote is close it's still vastly more than a simple majority agreeing with this direction. And Zeev has given no technical reasons against Anthony's... falling back on the emotional argument that it is somehow contrary to PHP's "vision" and is thus "damaging". His approach has been to attack, play political games and be incredibly sneaky. Of course he denies it, but the internals mails are there for everyone to read as he weasels his way in and out of things, all the while attempting to paint anyone who wants to move PHP in a direction other than that which he can reconcile as being the enemy. Contrast that to the 'attacks' on his RFC which have been by and large poking massive technical holes in the RFC. It simply doesn't stack up on technical grounds and it is highly likely that it would be a poor solution. So yes, Zeev is vocal, and loves to stand on his right to an opinion, but that opinion seems less and less informed by the day and he's fighting against what many consider to be positive change in the language.
Yes. This is a very good point of view. I have generally a big problem with naming.. But I fully understand my code. I just want to learn it the "right" way. (Updated the description)
Check out the [OOP bootcamp](https://laracasts.com/series/object-oriented-bootcamp-in-php) series, [Simple rules for simpler code](https://laracasts.com/series/simple-rules-for-simpler-code/) and after you feel a bit more comfortable, have a look at his videos on design patterns. If you ask yourself how he works so quickly with his editors, check out his videos on sublime text and PhpStorm.
Olivier, The unofficial poll failed to be an unofficial poll for two reasons: * Anthony decided to unilaterally change the end date on his vote to today, instead of 9 days from today. With only ~15 votes in the first 12-13 hours, mostly from the diehards who won't change their mind anyway, it was meaningless - and there was no chance for it to be meaningful in the compressed timeline Anthony imposed. * Secondly - it was being portrayed as illegitimate, which I find ridiculous [not only me](https://twitter.com/SaraMG/status/577225234375417856) - but did influence some people. The Basic STH received no fair (or otherwise) chance at a real vote and the only way to vote on it and see what the community truly thinks about it is by having Dual Mode fail. That's very unfortunate, but it's a direct result of the blocking tactics &amp; date pulling that took place. For that reason, I'm not going to change my vote and very much hope Dual fails at this time. If that happens, I believe Bob plans to bring the Basic RFC as a fallback. If that passes - great. If not, then I'll be supporting Dual whenever it becomes available for a vote again. In a nutshell, yes - I'll switch my vote to Dual and encourage everyone to do the same, but only after Basic gets a chance, not before.
Thank you, glype works nice!
tobiasgies: &gt; @zeevs Did I miss something? You made an informal poll about basic and were met with a HUGE amount of NOs, (c) Zeev: &gt; @tobiasgies At ~15 votes, virtually all from diehards, it didn't manage to actually provide a reasonable poll. @bitfalls @Ocramius Ah, so the dual mode people who have ~2/3 majority are the diehards, while Zeev who can't make an RFC with more than ~1/3 support is supposedly the reasonable person working for consensus here?
&gt; If that happens, I believe Bob plans to bring the Basic RFC as a fallback. If that passes - great. If not, then I'll be supporting Dual whenever it becomes available for a vote again. After you made a commitment to switch your vote if Coercive failed (which seem to be a foregone conclusion). Something else has come along which allows you to block the strict type hinting boogieman, so you are altering your commitment. What's to stop you altering it again? At the very best you have acted dishonourably.
&gt; And really, I sometimes think you guys (those who share the original vision of PHP) should just quit, and leave PHP to the 'community' Oh God, I think just had an orgasm.
Basic RFC did not exist when the commitment was made. It is better to not make conflictive promises at all.
Not-strict seems to me abjectly stupid, but I wouldn't ruin the process to get my own way. 
That does seem to be what is happening in Zeev's head. Even the actual vote counts doesn't seem to have any effects.
Zeev wrote elsewhere: &gt; Rest assured that if I see that they both seem to be failing as we near the &gt; end of the voting time, I'll retract the Coercive STH RFC - and I'll &gt; actually vote in favor of the dual mode RFC, Are you going to keep your promise, or are you planning to break it? And no, saying that you would keep you promise if some other condition is met is not keeping it. 
I think both the string and array functions in PHP need to be made a much better api. But you don't get to a better API by making incremental changes. Hacking bits here and there is how we got to the current situation. You need to think the whole thing through and figure out how all the pieces should fit together nicely. 
&gt; Posted by Brian on Mar 12, 2015 $mysql = mysql_connect($db_host, $db_user, $db_pass); Showing people deprecated stuff as an example is really not a best practice.
Its kinda unfortunate, I hope for the best and with the demand for scalar type hinting, one solution should be implemented for PHP 7. 
I'm sorry, I can't hear you over the whoosh of goal posts.
Most of these scalar types should only be reserved once we have a context sensitive lexer (I think thats right?) to prevent it from breaking namespaces amongst other things; otherwise that is a HUGE breaking change.
Well the best way to resolve this problem is to make PHP case-sensitive, but it will require significant change to Zend engine and is very unlikely. I personally dont mind true scalar types or mixed types are reserved for class names, but I dont understand the need for resource and object. These aint even scalars, and are heavily used as namespace or class names in many projects. It's not like Tony Marston's please do not break our language nonsense, its actually a reasonable debate. 
The words of a recently created troll account are nothing but noise.
[Laruence just posted](https://www.mail-archive.com/internals@lists.php.net/msg77315.html): &gt; I have a question, which is not explained in the RFC: lib.php &lt;?php declare(strict_types = 1); function add(int $a, int $b) { } ?&gt; &gt; assuming lib.php is a thrid part library which I want to use it in my project. &gt; but I use whole weak types in my project.. &gt; thus I simply call add by: &lt;?php add($_GET['a'], $_GET['b']); //recoverable error since all input in _GET _POST is string by default ?&gt; &gt; that means, I need to add a lots of (int) while I try to call a function in a library which is not written by myself. &gt; is that right? Misunderstanding how strict types works (he only gets the checks if the strict declaration is in the calling file). Laruence then goes on to claim on the mailing list that this (A main point of the RFC!) was not mentioned in the RFC text. He then goes on to say that his reason for opposing the RFC that he clearly does not understand is that "declare(strict_types = 1);" "is ugly". Hhhhnnnnn... And he voted against that RFC 13 days ago. It seems that a lot of people don't understand this point. I wonder how many of the "no" votes are based on that?
in my opinion, it's no different than casting in other languages. Look at javascript for example, it's not even strict, but to make sure things are correct: var fooA = '7.5', fooB = 10, dollarAmount = 0; dollarAmount = parseFloat(parseFloat(fooA, 10) + parseFloat(fooB, 10), 10).toFixed(2); Sure, you don't have to write it that way, but if you're working towards clean predictable code that passes all lint checks, that's how you'd do such a simple thing. my point being that casting is something we do all over in other common languages, it shouldn't be seen as a draw back in PHP. Personally, I think it's just irresponsible and lazy to not do it. I cast in PHP even now without strict typing.
In my opinion, you are hurting PHP and the community at this point. So much time and effort has been spent on what is ultimately a minor difference. Everyone wants scalar type hinting, and it's clear that only a minority actually want it the way are fighting tooth and nail for. Please, just change your vote as you originally said you would and move on to more important matters.
Just some things that stand out for me: - You have unused use statements in the header of your file: you import \DateTimeZone, \DateInterval and \DatePeriod, but you don't use them anywhere in your class - The date format is fixed to d-m-y. It would be great if you could pass this as a parameter like this: public function firstDayOfthisMonth($format = 'm-d-y') - A lot of your methods have a parameter that is never used: $value=''. These parameters could easily be removed. Personally, I don't think I would use your package. For me it's more convenient to type the following code instead of adding an extra dependency to my app: $date = new \DateTime('first day of this month'); $date-&gt;format('d-m-Y'); Besides all of the above, your package has unit tests, contains docblocks, has a proper README file and you encourage people to contribute to your package, so points for you! 
Is `Response` in a different namespace? You might have to `use` it or fully qualify it.
Nope, this does not allow keywords to be used as class, interface or namespace names, only for methods and constants. The fact is that resource is a common namespace name, and object is a common class name. 
This is what I was thinking. In Java kinda like language having a function like function setData(MyInterface myinterface){} and then passing some class that implements MyInterface inside the function is understandable. As in, the implementation of the class that implements MyInterface is changeable without effecting the flow as long as it conform to the interface. But, when I program in PHP, as we don't need to define the object type in the function argument, I was thinking why do I need an interface in the first place. I can change the implementation inside the concrete object and the code will still work right. I know I am missing something in my understanding about interfaces. Any help is much appreciated.
&gt; Give him rope enough to hang himself, without giving him any opportunity to blame a failure on you. He's already hung himself. Multiple times. He'll always find someone to blame, because that's in his personality. He can't look inwards and find any flaw in what he's doing (he never could), so he will always blame it on someone else. What I did by moving up my ending date was say enough is enough and try not to drag the community through this for another several weeks.
Why does it extend datetime when all of the methods are called static and each one instantiates a new datetime object? Why are none of the methods declared static? What benefit does this wrapper bring?
You should be using type-hinting in PHP is really all it comes down to, if your method expects an object then you should be letting people know what type of object it expects. Once you're doing that it has exactly the same purpose as Java.
Hey /u/utotwel, congratulations for getting this out the door. Looks amazing!
I'm inclined to agree, resource and object are ridiculous.
This is kinda OT but can I just say thank you for adding id's to the h3's so I can link them to my friends and colleagues...
&gt; He's already hung himself. Multiple times. He'll always find someone to blame, because that's in his personality. He can't look inwards and find any flaw in what he's doing (he never could), so he will always blame it on someone else. Yes, I agree. And such lack of social skills is poisonous to collaborative projects, and PHP would be better off without him. But this is a spectator sport, where the spectators decide who wins. The point is to remove any doubt of that from the minds of other voters, who might not all have been following this closely enough to realize how many times he has already hung himself. Having him hang himself again would have been the right thing to do tactically. &gt; What I did by moving up my ending date was say enough is enough and try not to drag the community through this for another several weeks. I understand emotionally why you did this, but I think it was a tactical mistake. IMO your chances would have been better by taking the very high road and just letting it run its original course. In the big picture, "another several weeks" of dragging would be a very small price to pay compared with the increased chance of this not passing.
I don't currently have immediate plans for it. But will add it to my list of things to research. Thanks!
What I don't understand that the NO votes have nothing to loose when the strict RFC gets passed. That is something I can't get my head around and that from a technical POV. I was raised with the believe that you also need to see others POV before judging, but in this discussion I simply can't. A lot of us already have some experience with a dual mode in a web related language. Granted it isn't the same but I use "use strict" a lot in JS and that doesn't really result in a cognitive load and you can do more f*ck ups then what this RFC would ever introduce. Also which developer don't know how to handle basic types, that they need to be saved by the NO camp? I don't know how each educational institute operates and that in every country, but it is safe to assume that most of us have been educated in a language that have basic type handling. Developers are pretty smart. And if you have problems with strict types - which is again purely optional - you are in the wrong profession anyway. Sometimes after reading the PHP internals list I have the feeling that some are really convinced that we are all idiots and we don't know any beter. I never seen so much disdain for the users of a product as some on the internal list portray imho. 
For voting/rfc privileges as you said, you need karma. And if you need Karma, you have to contribute to the source or the php documentation by editing, improving, bug fixes and eventially write and introduce yourself to the internals and request for participation.
But how man ?
And he's calling everyone else to get behind it too, even though he thinks "it’s pretty bad": http://news.php.net/php.internals/85059.
He has correctly decided that some STH are better than none, and that we can iterate on the details in later versions. This is a good thing for all.
&gt; I understand emotionally why you did this, but I think it was a tactical mistake. IMO your chances would have been better by taking the very high road and just letting it run its original course. Yes, but I'm not really interested in tactics. I'm interested in this being over with. I literally have an ulcer from this. My health has been affected negatively. My stress levels have been higher than they have been in years. I just want it over, to whatever end.
This is great news. I just hope it's not too late. I really thought that he wouldn't change his vote but I'm very happy to be shown wrong.
Just noticed zeev changed his vote ... the plot thickens.
People can change their votes, so it is certainly possible for Coercive to pass. However, clearly that won't happen.
Looks like he's closed his now.
With Zeev's vote swap, it looks like we're sitting at ~~66.8%~~ in favor. Edit: Looks like we're up to ~~68.67%~~ in favor. Looks promising, just like the original STH proposal. Edit @3:14 PM EDT: The vote is at ~69.03%. Just a couple votes away from 70%. Well into the passing range.
You want some mustard with those words? :-) http://news.php.net/php.internals/85059
Zeev's decision is wise and good. A lot of people are currently listening to him and are voting yes, which is an even better thing. The RFC is currently standing at 68% (101/47). At this rate, the RFC will pass. I hope Kristian hasn't some last minute "no" votes in his sleeves.
I think thats a general Jekyll thing, but... you're welcome :)
I would suggest doing some user testing - it may make sense if you already know what the product does but for example it's not at all obvious to me if it deploys to my current servers, or only to the servers that Envoyer runs. Also, is it limited to PHP, or if I have an application that is half PHP, half some other tech, can it deploy both parts of the project? Just in general, not having the documentation available without signing up is weird. 
LOL my bad! I didn't realise Xinchen = Laurence. The other one I was referring to was Yasuo in that thread.
Hey Taylor. This looks like a really nice service. Say for instance I have some phpspec tests that I want to run on the servers before the deployment is set as the active release (cause while Travis is nice, I do like to run the tests on the actual servers to double-check). If I add the test in as a hook, will Envoyer mark the hook as completed with errors and halt the deployment if the test fails? Or should I perhaps approach it differently?
Yes, as long as phpspec exits with a non-zero status code if your tests fail, Envoyer will cancel the deployment. What I would do is put "set -e" at the top of your hook to make Bash bail on any non-zero exit code.
Yeah, I need you to outside and spit 3 times. https://www.youtube.com/watch?v=N1tyiWP9MSk
I can see that, Phabricator is its own standalone now, so Hack going that way seems very plausible. Also agreed, if people wanted to fork PHP to try and clean it up then Hack should really be what they look to work with since it already has a head start.
This is one of those things that's so inconsequential and unlikely to be an issue that it's hardly worth thinking about.
I think it's important to make it clear to potential viewers/readers that you yourself are learning as you go. Don't present your findings as absolute truth (which is true for almost anything, at any experience level, but especially true for someone starting out) and encourage users to give you feedback / corrections. The corrections are for your benefit as much as anyone else. Besides the nature of open source software is many contributors improving the quality of code - the same is true of information - many people contributing to its quality. Embrace information from others, don't treat it as a competition or take offense. Some people are, and will act like, dicks. They might be dicks, but they might also be correct and make good points. Unfortunately, you have be willing to put with good points presented by dicks.
I assume you are looking at the constructor. I've never had that issue myself. Mine always show up fine.
`returns_void()` does not have a return value and that comparison is non-sensical. The fact that PHP (and Ruby; and Python?) *always* returns `null` by default is an implementation detail you as a developer are not allowed to do anything with (e.g., you can't test a method's return value for `null` to determine if it was "void"). It's an unfortunate limitation of the language but that's all it is. [Edit] I just saw that `void` didn't actually make it in.
I agree. The people who use this service are going to want to know more than what it does. They want to know how it does it. The site doesn't tell you anything about how it works, and I'm not going to watch videos to find out.
Framework maintainers can release a new version with PHP 7-only support, then Ctrl+H the name of their class moving forward. They can move to PHP7. It's just not seamless (which a major language version change doesn't necessarily need to be, anyway).
Thanks! We all have our own opinions on how things should be done, but ad hominem attacks and namecalling makes us _all_ look like unprofessional idiots. 
Question: If I say "just don't use X" where X is a library/framework whose maintainers have an established record of hostility to security researchers, does that (by moderators' judgment) qualify as a form of personal attack?
I don't understand how userland classes called String, int and such are a good practice. If you are wise enough, you won't call a class, namespace, method or trait as something that is already reserved in another language. For compatibility sake. We had a "goto()" method that redirected users to a URL, it caused fatal errors once the function appeared in PHP. This taught us to be careful and not use reserved keywords from another languages, cause it could be implemented anytime in PHP. This is even truer with words such as bool, string, int, float or anything like that. They are basics, and it was a matter of time before PHP would implement them.
It does not. In my own opinion, you would even be justified to say that the contributions by the maintainers are of poor quality. Where the line would be crossed is if you began attacking the maintainers' character ("The maintainers are assholes"). We're not here to stifle dissent/criticism. We only want to make sure that a minimal level of professional decorum is kept. If it would be acceptable to say in a non-hostile office space, then it's probably okay to say here.
Of course not. That classifies squarely as a technical argument and is very much welcomed to the discussion. Saying "just don't use X because author Y is a jerkface" would not.
I'm not sure if you understood my point... function foo() { } function bar() { return; } function baz() { return null; } ...are for this purpose the same, and should be accepted as a valid `void` return type to avoid confusion.
I don't remember for C# and C++, but isn't there already a String package in Java ? http://docs.oracle.com/javase/7/docs/api/java/lang/String.html . How could you create a String class if this already exists in the API ? EDIT : OK, I just understood it. My bad, didn't think about it enough. I'm very tired. You create a custom package, add it to it, and use it. It prevents String for being used like in Java. It's too bad that you can't create a String/int/such classes in a custom namespace, but this can be changed in a future RFC. I guess. Thanks to Context Sensitive Lexer
Nah, I am not a big fan of false equivalence. Zeev is the main problem here.
Somewhat ironically, the fact that we may be getting scalar type hints is going to make getting bigints into the language transparently far more difficult. Consider this code, and what would occur if we had the automatic promotion of ints to bigints that was suggested: function foo(int $x) : int { return $x * 10; } function bar(int $x) { if (intval($x) != $x) { echo "Wat."; } } bar(foo(PHP_INT_MAX)); The code above has an issue in that the type safety has failed us.....somewhere. But it's not obvious where the error should occur, in the sense of should it error on the return from foo, the passing the param to bar, or checking the value of an int is the same as itself cast to int. I'm reasonably sure that correct behaviour could only be achieved by having explicit (aka not transparent) promotion to bigints, and by triggering an overflow exception for any maths operation that accidentally has a result which is not storable within the int type. 
I'm struggling a little bit to see if this gives me what I want, or provides any real value for me personally. But I'll definitely take more of a look at the videos when it isn't 4am. 
yeah, and with the current way RFC is going, they both will become reserved keywords. Of course, I will run and maintain a custom build of PHP 7 when it comes out with scalar objects/classes and some other fancy things, so I can just manually remove them from reserved keywords. Still, its very unpleasant and may create maintenance nightmare. Oh yeah, CakePHP has root object class just like I do, I wonder what their opinion is on Object being reserved keyword. 
So, what triggered this post?
The middle example uses @font-face, I've tried setting the text "פעמיים נקודתיים‎" (Paamayim Nekudotayim) instead of PHP and put the direction:rtl in the parent block, no problem so far, as long as the font you're using has the glyphs for the language. 
Think of it like code reviews: As a reviewer, focus on the code and ignore who the author is. It's OK to consider the author's past actions when deciding what to scrutinize (history of XSS? Better focus on that!), but don't try to find fault or be excessively pedantic because you don't like someone. Try to praise the person but blame the code. It's human nature to tend to ignore someone's suggestions based on their past actions, but at least make a conscious effort to keep that out of your comments. As the author, remember that the reviewers may rip your code apart, but that doesn't mean their opinion of you has changed. They just want the best for the codebase. This is always something I've told new employees: it doesn't matter that I've been here longer; if you see a bug where `git blame` puts my name on it, raise concern about the code. We all make mistakes, I won't get offended. Even if these things aren't strictly true, operating as if they are will make the commentary a lot less stressful and let you focus on what's most important (the code)
You act like MySQL itself never has security problems. What if an attacker with a MySQL 0day appears? https://gist.github.com/evandrix/4196054 Hardware separation is critical for stopping sophisticated attacks. (Virtualization isn't even sufficient; we can't expect developers who cannot build a secure operating system to be able to, in turn, build a secure virtualization environment.)
For the most part I agree with you. If it's a subordinate or a coworker, sure. But, there are many cases where bad behaviour is so public that it's more effective to make the criticism/condemnation public too. To speak in concrete terms, many believed that Zeev was somewhat-openly acting in bad faith. That needed to be address publicly and head-on, to resolve it early and fully.
But what if they are indeed assholes? lol
To be fair, its just a new vote freeze. Feature freeze will happen after the current votes are finished/implemented.
I honestly cannot believe you ventured into reddit. This place is not like the internals mailing list. The people here don't care about what your involvement was in FI or in 4.0. The people here care about the language they use on a daily basis and what will make their jobs and their lives better. The people here have to deal with enough politics bullshit from orgs like Wordpress, or Drupal, or Joomla. And you know what, in almost all cases the community has forced changes in attitude and direction out of those orgs. This is the place where you actually get to talk with the thousands of people that have to live with bullshit like T_PAAMAYIM_NEKUDOTAYIM, or "100 apples". Not in some pissing contest in a mailing list, or a debate line-item in an RFC, but with clients and employers who are trying to accomplish something. Your proposal did not, in large part, help us accomplish more things. And your maneuvering and behavior during this process. It has gotten bad enough that there are large numbers of developers here who are ready to completely abandon PHP7 in favor of Hacklang as soon as there is IDE support. The only thing you have actually accomplished is convincing me that PHP-FIG should control php-src, which is frankly frightening since that group has no particular expertise with language design. This is not a safe place for bullshit. We deal with bullshit from our clients, we deal with bullshit from out hosts, we deal with bullshit from plugin devs and package maintainers. And we have been *ruthless* over the last few years in stamping out that bullshit through things like the PHP-FIG, the League of Extraordinary Packages, Composer/Packagist, and the standardization around several packages and behaviors that originated out of Symfony which are now the building blocks for many other applications like Drupal. We have no patience or time to deal with bullshit from the mob that seems to be controlling the language itself. Get your shit together and stop wasting our time and productivity Zeev. This is no longer the little project that you simply get to be part of. PHP has enormous impact on that world. There is no longer room for it be your own little fiefdom when you want it to. The rest of us have too many other things to do.
For a while even the `[]` array notation was deemed too much of an intrusion. Lots of long-time PHP developers have lost their appreciation for just how awful some parts of the language can be, especially the `array_` functions. Sometimes I wish everyone was required to spend 6 months away from PHP before voting on RFCs. We would definitely see a focus on ridding the language of crap like `array_` functions and my personal nemeses `__get()` and `__set()`. Strict type-checking has also probably helped doom the `in`operator.
This is a pretty solid first effort to be honest. Keep going. Date/Time packages are perhaps a bit ambitious for a first project just because there's so much technicality to keep track of, but you should definitely feel encouraged to keep working an improving. 
Except the dual mode proposal does not make it possible to write library code that will ONLY work in strict mode.
That's actually the experience I had that I was referring to when I asked this question.
So then... we have two camps. Those who understand and vote yes, and those who don't understand and vote no.
I think we can all say that was the least dramatic RFC ever. Thanks to Anthony and Andrea for getting this done.
FINALLY the drama is over! Also 156 votes in total, that's the record by quite some margin ;)
Thats good news, the drama is over and thumbs up to Anthony Ferrara. Now I think this means scalar types are reserved already, theres no need for the other two reserved keyword RFCs anymore, right? 
What does all this mean? ELI5 please!
Thank you everyone for your support.
Why does one have to have "evasions" when one can simply continue voting no with the reasoning that one disagrees with the proposal? And why does one have to use the word one so often to refer to oneself? Inquiring minds want to know.
Yeah, I was going to order some [PHPopCorn](https://www.kickstarter.com/projects/940438815/phpopcorn) and watch the voting but this RFC didn't seem dramatic enough. Maybe next time.
Mr. Lerdorf didn't let me down.
One of the reserved words RFCs target the four names reserved in this RFC: int, float, string and bool It also targets: true, false &amp; null The second reserved words RFC targets: resource, object, scalar, mixed, numeric So, one has no relation, the other now has very limited impact, and will likely pass with flying colours
Thank **you** for all the hard work, and your tact and diligence in navigating the minefield that is called 'internals'. And a big thanks to Andrea as well, of course! 
The second one is terribly bad and will break lots of apps(resource is a common namespace, and object is a widely used class name), it has more than just limited impacts. Also there's no reason to reserve resource and object since these aint even scalars. Why are PHP internals voting for it? That RFC also does not give any explanation for reserving more types, the description seems to be a mere copy from the first RFC. Anyway, the first RFC is already accepted as scalar type hinting is passed, and second RFC is ridiculous and needs to fail. 
Let me know when you're ready, I'll get that through as well. :-P
Fucking finally
&gt; This RFC will allow you to declare the variable type and require the variable to maintain its scalar type. I dont see such an RFC available. And if it does exist, it will be a very bad idea since its essentially converting PHP into a static typed language, but PHP has and always will be a dynamic typed language. 
*S*calar *T*ype *Hints*. [Zeev](http://en.wikipedia.org/wiki/Zeev_Suraski) [Context](http://www.reddit.com/r/PHP/comments/2z5xql/scalar_type_declarations_voting_date_change/) 
Now off you go and fix climate change
You kind of need strong typing in order to have function overloading. /** * @param int $a * @param int $b * @param int $c */ function foo($a, $b, $c) { printf('Number Args : %s %s %s', $a, $b, $c); } /** * @param string $a * @param string $b * @param string $c */ function foo($a, $b, $c) { printf('String Args : %s %s %s', $a, $b, $c); } // Which function is called? foo("12", 6, "0");
This is great, thanks! I was hoping this would pass. Will surly remove some code from unit tests.
With PHP 7, you'll be able to do this: function do_something(int $wholeNumber, float $fraction, string label) { ... } Values passed into those functions will automatically be converted to the correct type. There's also an optional strict mode that can be enabled. In strict mode, if this function is called with values that can't be converted without losing data (for example, converting the float 1.1 to the integer 1), it will result in an error.
There are actually a few different proposals related to annotations that are complementary, not mutually exclusive. Hopefully this means that the debate will be mostly bikeshedding instead of coming down to critical issues like STH.
[Let's celebrate!](https://www.youtube.com/watch?v=l593_96Xp3s)
Scalar type hints, rather.
Very much available, and very much passed for PHP 7. However, there are essentially 3 modes - strict, coercive and weak. You can still write code without the type hints, you can use libraries that have type hints but leave out the declare(strict=true) from the top of your script, pass whatever in, and let PHP coerce the type for you, or you can go fully strict, which does have some benefits.
That may've been slightly tongue in cheek. It really is great news though :-)
Well, that's not really that much of a problem since it looks like the Context Sensitive Lexer will also pass.
&gt; If this function is called with values that can't be converted without losing data (for example, converting the float 1.1 to the integer 1), it will result in an error. Nope, 1.1 will be silently rounded to the integer 1 in weak mode. https://wiki.php.net/rfc/scalar_type_hints_v5#behaviour_of_weak_type_checks While it doesn't seem very sane to not error out there, it is how PHP has always worked. So it has to be that way unless you want to add a separate coercion table for type hints than for other users in PHP. Or want to add a major BC break by changing coercion globally. To see that no error is thrown in e.g. PHP 5.6, try str_repeat("a", 1.1)
No, the context sensitive lexer doesn't cover it. The RFC seeks to forbid the names as class names to allow them to be used as non-class typehints at some point.
Oh interesting. Didn't know that. 
/s
One could continue disagreeing with no problem. One thinks the reasons for the disagreement were flawed but that is irrelevant. What one should not do is put forth another RFC to vote without the proper period being waited purely to undermine an existing vote. And I do not know why one does this. 
So... About Palestine...
It passed.... I now owe you a beer every time I see you. Shit.
Who has been saying this? They are a crazy person. 
Even if this were true - and I doubt it is - it would be trivial amounts. 
Possibly not. In the past, it's been noted that function/method overloading and/or multiple dispatch would be a huge performance burden *globally* due to the nature of function calls. I vaguely recall something about having to *always* do type checks on *every* function call to find the correct function, instead of the new behavior of doing type checks once the function has been located. It's unclear if this has changed, and I personally wouldn't get your hopes up.
Can you point out a few specific problems with the array functions?
yyyyeeeeesssss im such a nerd that i care about this but yesssss
With PHP 5.3, one can write function compute1(array $param1, object $param2, MyClass $param3) { } Each time this function would be called, the types would be checked, and a fatal error would stop execution in case one type were wrong. Yet there was no way to declare that a parameter's type was "integer" or any scalar type. This is what this RFC adds. It also add a way to declare return types. function compute2(string $param1, bool $param2, int $param3) : int { } But, contrary to the previous behavior, these types won't be checked unless the function *call* is in a file beginning with the line directive(strict_types=1); // first code line of the file On the other side, the return type will always be checked, even if the function call is not strictly typed. So if some weakly-typed code calls `compute1` and `compute2` defined above, PHP will check the types of `compute1` parameters and `compute2`'s return value, but not `compute2`'s parameters. Also be careful that there are no union types, so one cannot declare that a parameter can be null, and no returning `bool|int`. And be extra cautious when casting: `(int) $dbvalue` will convert most non numeric values to 0, including "" and NULL, which may not be suited.
Am I being a bit slow .... But this feels like it should be part of Forge and not a separate product. To a degree I feel like my forge subscription has been diluted. Yes forge creates The servers but it also deploys. This feels like this should be the pro version eg. Forge Pro Or have I got it all wrong. Happy to be educated if that's the case. Ps. Still looks awesome Taylor 
To expand, I would expect (given the way that the rest of PHP works) that intval will return a bigint if the value is too large for an int, and that the "int" type in PHP userland will actually be a composite type of BIGINT | INT for all comparisons, including === checks.
The gmp extension is still there, but consider the difference between: // with gmp $sum = gmp_pow('2', 256); echo gmp_strval($sum); // with bigint doing the heavy lifting echo 2 ** 256; While the GMP extension would be the proper way to go if bigint never sees the light of a release, I think the syntactic benefits of it being in the language are huge. It might seem like a minor thing, but it lowers the barrier of effort required to deal with big numbers in a significant way, and makes doing math with databases which have huge column sizes (&gt;=64bit int columns, which will do different things depending on php version and platform atm if you need to do math with them) way, way easier, with better readability.
I'd have to re-read the mailing list for bigint, but I do believe that is what it would do. If not, that is probably what it should do, so we don't have to know necessarily if we're dealing with a "bigint" or not, and just do a bounds check `($x &gt; 0 &amp;&amp; $x &lt; 2 ** 32) `for example
I thought about this but it actually doesn't make sense for a few reasons. First, it would definitely be a paid upgrade to Forge, bringing it to a Forge "Premium" level of $30 a month. But, there are some who want zero downtime deployment who do not need Forge's other features. So, it made sense to break it out into a separate $10 a month app that people can use separately from Forge.
&gt; But, contrary to the previous behavior, these types won't be checked unless the function call is in a file beginning with the line This is **incredibly** untrue. In weak mode the types will be automatically converted to the appropriate types if they are not already of the right type, in strict mode no such automatic conversion occurs. They will **always** be checked if given to the function and the function can always assume that its parameters are of the declared type.
I can see a horde of Laravel fans taking over, but there it goes, my chip for Slim Framework. 
Ah that's right, I remember now. I'll correct my post.
At least within phpmd rules, [it's a bad practice](http://phpmd.org/rules/design.html#exitexpression) on the grounds that it's untestable. I use exit expressions myself, but Scrutinizer, Code Climate and Codacy penalize my scripts for its usage. I guess phint would allow to deactivate certain rules.
uh... I couldn't find how to try it. 
As above, please can you provide some examples of where these are used in any projects? I completely agree with you, I just want to annecdata to backup the argument that this is a bad idea on internals.
Do you really think the RFC to tighten up the RFC process will be less contentious?
I don't even understand why is repeating bx. If $v scope was leaking into the second foreach then it should be stuck at "cx". I'm baffled.
What was wrong with the actual RFC process? I mean, there were a few spats over timing (as expected, so close to the deadline) of competing RFCs, but I thought that part of the whole thing went really well.
Thanks, I will improve it.
There seemed to be contention on when it was acceptable to open an RFC for voting (with regards to the basic STH), but maybe that was just zeev being zeev. It also seems wise to me to have some guidelines set down for what happens when you have competing RFCs, since the current vote system just lead to tactical voting rather than considering each proposal on its own merits.
Gandalf's good if you want something to not pass.
Yeah... I completely missed your point. I agree with you, however, I think that some semblance of backward compatibility is required so that we don't wind up with a Python 2/3 fiasco. Outside of that, I'm frustrated that the language is losing out on great features other languages are adopting. Some would argue with me to use those languages instead, to which I say, no - I love writing PHP, I just wish some of PHP's contributors would love it as much as people like me.
If you say so, I'm sure it worth it. We need yet another way to do regex.
You're welcome to do a search on any major OSS PHP project if you don't believe me. Here are a few to get you started: [ZF](https://github.com/zendframework/zf2/search?utf8=%E2%9C%93&amp;q=strpos), [Symfony](https://github.com/symfony/symfony/search?utf8=%E2%9C%93&amp;q=strpos), [PHPUnit](https://github.com/sebastianbergmann/phpunit/search?utf8=%E2%9C%93&amp;q=strpos), [Slim](https://github.com/slimphp/Slim/search?utf8=%E2%9C%93&amp;q=strpos), [Guzzle](https://github.com/guzzle/guzzle/search?utf8=%E2%9C%93&amp;q=strpos). You can also [refer to the PHP manual](http://php.net/strstr), which instructs users to use `strpos()` when checking if a substring is in a string: &gt; If you only want to determine if a particular needle occurs within haystack, use the faster and less memory intensive function strpos() instead.
&gt; You're welcome to do a search on any major OSS PHP project if you don't believe me. Way to miss the point. This is about unnecessary drift toward Perl's insane "50 ways to do it, each subtly different"
CakePHP does this. 
You avoid the Python 2/3 fiasco by minimising the amount of BC breaks at once, not by not having them. There would be, for example, very little wrong with a major version bump every 6 months that introduced 1 or 2 BC breaks. The problem is if you do a big bang major upgrade once every i dunno.. lets say 10 years... and introduce dozens or even hundreds of BC breaks. BC break frequently, in small amounts... 
Well annotation is not as much a demanded feature as compared to scalar type hinting. I for myself dont care if it exists or not. Also annotation can be done in wrong way, the only good practice is to have first class annotation like Java, C# and Python's. If annotation is defined in docblocks, I will be against it, since docblocks are comments and annotation in comments is abomination(comments should never directly affect code, you should be able to delete and replace comments/docblocks without breaking your app). I can give examples on whats good and what is not: First class annotation(good): https://wiki.php.net/rfc/annotations Docblock/Comment annotation(bad): https://wiki.php.net/rfc/annotations-in-docblock In a word, annotation's implementation can be very tricky, if done in wrong way they can be a hindrance than a benefit. Read this article and you will understand the issue with docblock annotation: https://r.je/php-annotations-are-an-abomination.html
That's a really odd semantical nitpick there. There is no other feature freeze deadline, this was it. Call it whatever you like.
Class named object is not a poor design, it's the way root class is named in some frameworks. I do this myself too, and as I mentioned CakePHP has been doing this for both version 2 and 3. Object is the root class for many object oriented languages, ranging from static typed Java, C#, Scala to dynamically typed Python and ruby. In PHP, classes do not derive from a root class, but in userland we can achieve and enforce this. It's not a bad thing, its a reasonable convention. 
I didn't miss anything. I was just correcting your demonstrably false assertion: &gt; The first of which is spurious (insofar as that is a RARE case for production code)
compared to a lot of other changes like register_globals, something like that can mostly be fixed with search and replace, so a 5to7 converter could be made.
I know. I'm not surprised it anyway.
Good point - though at least with `in_array` I have the option of passing `true` as the third argument to force strict comparison. If the hypothetical `in` operator were to be consistent with that, you'd need a second operator that would serve as either the weak or strict comparison alternative.
Annotations, Scalar type methods, Generics, Arrayof, Expression trees, ... Let's make it happen. 
I'm still surprised Phalcon came second in 2014. Didn't realise how popular it was!
Any support for GitLab or self hosted git repos? Limiting to 2 hosted providers is a bit of a weird one, especially for a paid service
Please help me i need job 
So it's even OK to denounce Laravel now, or is that framework still exempt?
Register_globals has security issue and proved to be objectively bad, using names such as resource and object does not have this problem. Theres a good reason why resource and object are used as namespace and class names, and why should we refactor the code when we are following proper design and coding structure? I do refactor all the time, but when I do its for a reason. I dont see the validity of refactoring this time, it seems that this evil RFC wishes to reserve some keywords for the sake of reserving them, which is ridiculous. The funny thing is that, even now the PHP internals who started this or voted yes for the RFC still refuse to come here and give an explanation, I think they cannot explain it. 
Actually, if you read this blog post from Ilia Alshanetsky (http://ilia.ws/archives/205-Type-hinting-for-PHP-5.3.html) there is reference at the end dating back to 2006.
Type hinting a resource (e.g. a file handle) is useful. Unfortunately it doesn't guarantee that it's the correct type of resource (though maybe that doesn't matter in some cases?). Object makes no sense to me. What's the point of type hinting for any object when it could have any methods?
I agree that nothing of substance should change after an RFC is introduced for review, but you (and others before you) have been alluding to some kind of conspiracy, without providing any evidence to that effect. For all we know, he fixed some typos and/or clarified some wording, and you guys are being *wholly unreasonable*. So forgive me if I leave my pitchfork in the closet on this one.
&gt; People blew it way out of proportion, took it personally, developed dillusional conspiracy theories, and that is what caused the drama, not these events. Sorry, that's ridiculous. zeev's conduct is what caused people to 'blow it out of proportion' etc. Therefore, that caused the drama. I could just as well say "people taking it personally is not what caused the drama, the stuff people said in reply to that caused it". The whole fucking lot is the drama. &gt; As I said before, we can fix the processes, but it's not going to fix the major problem. If the things I listed above were tightened up so there is no ambiguity, zeev would not have been able to even suggest doing those things and there would have been much less drama. You said in another comment: &gt; I think most of the drama revolved around some kind of perceived sleight from competing RFCs being introduced so close to one another, during each other's voting periods, etc. I don't think that's true at all. The drama in zeev's RFC came from him asking Andrea/Anthony to delay theirs until he'd finished writing his (which ended up rushed). No one had any problem with competing RFCs being voted on. That's exactly why Anthony originally set the voting to end when the competing RFC ended, so they could be voted on in parallel.
&gt; Today was the feature freeze for PHP 7. That means no new votes can be started for a feature that is aimed at PHP 7.0, and would instead have to go into PHP 7.1.
PoC||GTFO! ;)
Now that I'm at work, let's do the trivial diligence. The reference to the manual, referencing strpos is not compelling. Of course it points to the memory efficient way of doing things. The 'in' operator gives a narrow functionality that also benefits. Ostensibly, the manual will be changed to say "use strpos or `in`", which does not affect commonality of use. Tautological cases for using `in` are spurious. If the language was to be changed based on usage, then the rfcs should be presented and approved by the largest projects (for some value of project usage measure). This is not a direct benefit to the average user or to the purpose of the language. Facebook made their own to this end. The projects you listed are a mix, but strpos is relatively rare. These numbers are all skewed by the nontrivial amounts of whitespace and comments. The importance of these non-functional lines is a separate discussion. Feel free to do the reduction and repost. strpos uses per lines guzzle 0.15% 14/9202 guzzle/src/ phpunit 0.12% 31/25143 phpunit/src/ zf2 .07% 197/296365 zf2/library You can do the rest of the math at your convenience.
It's subtle. After the first loop, $v points to the third element of $a. Then, in the second loop, the three operations do: Loop 1: (Element 3) assigned from (Element 1), so array is now: [ 'ax', 'bx', 'ax' ] Loop 2: (Element 3) assigned from (Element 2), so array is now: [ 'ax', 'bx', 'bx' ] Loop 3: (Element 3) assigned from (Element 3), so array is now: [ 'ax', 'bx', 'bx' ] So given an array of (n) elements, the nth element will always get set to the (n-1)th element, because the nth element get hosed by every element before it, until it just gets assigned to itself.
Thanks! I hope it ends up being useful for you.
Conspiracy is too strong of a word. Is just bad behavior by some people, intentional or not. I don't think that additional clearly stated rules and guidelines will end up being unreasonable in practice. 
Though he only works once (or maybe twice).
&gt; zeev's conduct is what caused people to 'blow it out of proportion' No, How /u/ircmaxell projected zeev's conducts is what caused people to blow it out of proportion. It is the same trick politicians do to turn public opinion in their favor. If you want an example of 'developed delusional conspiracy therory' see [this message](http://www.reddit.com/r/PHP/comments/2z2g2c/scalar_type_hints_rfc_reaches_more_than_100_votes/cpfjty6). [Here](http://www.reddit.com/r/PHP/comments/2z54ep/last_minute_twist_basic_sth_rfc_by_zeev/cpgf26l) is one person saying that Zeev " has no idea how static analysis works". And these are the kind of people that support /u/ircmaxell and hate on zeev. And you can see that the guys I was replying hasn't not yet replied to my request to justify his claim of "he's (Zeev) routinely shown to have barely a rudimentary understanding of the topics he's talking about.".. So all this points towards a huge amount of ill will has been formed against Zeev, thanks to the suggestive posts of /u/ircmaxell....
should use startInForeground or startForeground over start(true) &amp; start(false). the booleans make no sense. This is just an API suggestion as you see you comment // start in background or // start in foreground. If you change the name of the method those comments will no longer be necessary. Other than that this is pretty good work.
When is it not bad practice to make an object's variables public?
The RFC text says: &gt; "This breaks any and all cases where these new reserved words are used in class, interface or trait names. It does not break any usages as function or method names or as class constants."
Agreed. PR in right now https://github.com/peridot-php/webdriver-manager/pull/6 - as soon as travis gives the ok I'll tag a 1.1 release. Thank you for the feedback :)
I totally agree. Any explanation for the high number of "no" votes?
Bahahaha... you win 10 innernet points sir.
Quoting Sara's mail: &gt; To be clear, this RFC is about declaring these names as reserved, not about actually /using/ them. There's no language in the RFC about actually throwing errors or other code-breaking behavior. Therefore, even should all of them pass, it does *NOT* mean that your code using these names suddenly stops working on PHP7. It means that you have been warned that using the names of intrinsics is a bad idea, and that the language reserves the /right/ to make doing so an error at some point in the future. So that seems pretty contradictory. /u/SaraMG could you clarify?
The three-way voting method between "dual", "coercive", and "nothing" was stupid. For example, you had Zeev voting "no" to the "dual" proposal, even though he preferred it to nothing. Debian uses the [Condorcet method](https://en.wikipedia.org/wiki/Condorcet_method) for such votes, and it would have been perfect for this PHP vote. (Debian's custom use of Condorcet has [one unnecessary sillyness](https://lists.debian.org/debian-vote/2014/02/msg00038.html), which PHP should of course not copy)
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Condorcet method**](https://en.wikipedia.org/wiki/Condorcet%20method): [](#sfw) --- &gt;A __Condorcet method__ is any [election method](https://en.wikipedia.org/wiki/Voting_system) that elects the candidate that would win by majority rule in all pairings against the other candidates, whenever one of the candidates has that property. A candidate with that property is called a *Condorcet winner* (named for the 18th-century French [mathematician](https://en.wikipedia.org/wiki/Mathematician) and [philosopher](https://en.wikipedia.org/wiki/Philosopher) Marie Jean Antoine Nicolas Caritat, the [Marquis de Condorcet](https://en.wikipedia.org/wiki/Marquis_de_Condorcet), who championed such outcomes). A Condorcet winner doesn't always exist because majority preferences can be like [rock-paper-scissors](https://en.wikipedia.org/wiki/Rock-paper-scissors): for each candidate, there can be another that is preferred by some majority (this is known as [Condorcet paradox](https://en.wikipedia.org/wiki/Condorcet_paradox)). &gt;==== &gt;[**Image**](https://i.imgur.com/uD1TYqZ.png) [^(i)](https://commons.wikimedia.org/wiki/File:Preferential_ballot.svg) - *Example Condorcet method voting ballot* --- ^Interesting: [^Schulze ^method](https://en.wikipedia.org/wiki/Schulze_method) ^| [^Voting ^paradox](https://en.wikipedia.org/wiki/Voting_paradox) ^| [^Dodgson's ^method](https://en.wikipedia.org/wiki/Dodgson%27s_method) ^| [^Minimax ^Condorcet](https://en.wikipedia.org/wiki/Minimax_Condorcet) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpht0fy) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpht0fy)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
He is talking about it messing up his views. When using PHP with HTML, you need the closing tags...
I will most definitely be signing up for a trial but I agree the page doesn't explain some things well enough. A link to a features list with details or some docs would be very helpful. - How does the 'Health Check' work? Does it just check for a HTTP 200 or can you set it to search for specific content? - What does 'customized deployments' mean exactly? - I see a tab for deployment hooks. Are there pre-deployment hooks? Can I require functional tests to run and abort the deployment if they fail? - There's also a 'Heartbeats' tab in the screenshot. Are those just the health checks, or is this something different? 
Yeah, and I had to explain that to them, because your article's title was misleading. I'm not attacking you dude. Just saying the term you chose wasn't the best.
I'm trying to think of when I would care how the rendered html formatted...
Templating is not always about HTML you know.
This is true. But for the majority of projects where you need a basic search - then elastic search is complete overkill. MySQL full text will probably meet the requirements of 90% of projects.
Use two newlines instead of one; no need for spaces. It is extremely common amongst PHP devs (especially beginners) to include the closing tag at the end of files, even though it isn't necessary. PHP strips the first line feed character ("\n") after the closing tag due to the Unix convention of *terminating* every line with a line feed, as opposed to *separating* the lines with said character. Removing the line feed fixes an issue where the terminating newline after the last PHP closing tag at the end of the file would be interpreted as template data or whatever you want to call it, causing data to be sent to the client and making everyone's lives miserable. In hindsight, it would probably have been a better idea to simply check if the last character in the file was a line feed character and then remove that. Fixing it isn't worth the effort, IMHO; the benefits don't outweigh the headaches that would ensue, and using PHP's templating is a bit of a joke anyway--there are better tools out there.
whoa, very subtle indeed.
The term was fine, the understanding of the term was wrong. :)
Not for 7.0, and I'm personally pretty happy about that. 
I see, but thats kinda confusing. My major problem with this is that theres no explanation for why each keyword will be reserved. Unlike Levi Morrison's RFC which was very clear that these are scalar types, this RFC is very obscure. I can get that Numeric and Scalar will be used in scalar type hinting too at some future point, but I dont understand for resource and object since these aint scalars. If there's a good reason to reserve them, I will not complain. 
Hinting resources would however prevent extensions to move away from them. Afaik that has been discussed more than once and some userland extensions already moved to objects. (Also the "core" gmp extension was already rewritten from resources to objects in 5.6 (without bc breaks afaik). The resource typehint would either need to allow objects to be passed or would break migrations that could be done without breaks otherwise. It's not really usefull in both scenarios.
I think I quit PHP.
He's goingish places
Wouldn't it help in this case to force language spec patches to be part of the rfc before voting starts and lock them (to any changes) while voting and have the actual RFC open for minor **fixes** (unclear wording, typo). The RFC should just serve as documentation and reasoning for the spec patch that is actually voted on.
I.. actually haven't considered that. Looks like I didn't give this too much thinking.
Thanks! I don't have any experience with Phabricator, but it looks pretty slick. You could easily put a different interface on top of the manager - whether that is a different CLI or a point and click interface.
"Bad behavior" is laughable. This is nothing but perceived sleights and classic dogpiling. Dozens of folks are badmouthing Zeev because 1) they disagree with him, and 2) it's become the "cool" thing to do. Not one of them has given a single shred of hard evidence to prove anything they claim beyond "he actively lobbied against a proposal he didn't like" - which, coincidentally *happens all the time, by virtually everyone.* You don't see me badmouthing Anthony's questionably-motivated (to put it politely) attempts at undermining first-time voters' legitimacy, simply because most of them voted "no." Folks on all sides of this were doing silly things, and letting passion override judgment.
If edit diffs were made public, that would probably solve most of the drama.
I've seen other weak-typed languages deal with function overloading using *guards*, which lets you attach an expression (any expression) to the function, which must evaluate to true in order for the function to be called. function foo($a) when (is_string($a)) { } function foo($a) when (is_int($a)) { } function bar($a) when ($a &lt; 50) { } function bar($a) when ($a &gt;= 50) { } It's not much different than putting an expression inside the function, which then dispatches the function call to a more appropriate handler, but I think the syntax is a little cleaner.
Well if we could deprecate old style constructors I dont see why we couldnt do away with this
So you want the huge expense of a look-ahead on every single file everywhere that has a closing line baked into the entire language that serves about 40% of the entire web to billions of people *per day*... so that you can get your "pretty" HTML without using one extra space?
&gt; This is nothing but perceived sleights and classic dogpiling. My entire problem with Zeev is that he seems impervious to facts. Not drama or sleights. The moment he argued that accepting number-like strings as valid input for int typed arguments would NOT affect static analysis, I effectively wrote him off as not knowing WTF he's talking about. I don't want him anywhere near this language because he's *portrayed himself* as being incompetent for the sake of confusing voters who don't know any better. Which means either that he honestly *doesn't* understand what he's doing, or that he truly cares about his own ideas more than *anything*. More than usage, more than how it impacts the language that 40% of the web uses, more than decades of research and work done in language design. How can I possibly trust someone that is *either* of those things with being a steward of the language?
That's gonna be easy peasy with such a clean api you provided. I've been looking for a nice way to launch selenium from our build system at work to run tests automagically when pushing to the vcs. Maybe this will do fine!
They are public as it's a wiki, but the wiki software is broken and won't render diffs in certain circumstances. That needs to be fixed. That said, text diffs are sometimes harder to parse than typing up a summary of the changes.
Why do you care how the HTML is formatted after rendering? For most use cases, I feed generated HTML through a minimizer that strips out whitespace, line feeds and other data that is meaningless and adds bytes to the final result. None of your users care, why do you?
I really doubt hosting providers will accept to update their PHP every 6 months. Maybe that doesn't matter to you, but they're the one who can make or break PHP. They do not update for various reasons: it works, cost, and BC. That's why 5.0 took so long to be adopted and needed active propaganda, and then 5.3 took also a while. Right now default PHP (they offer offer up to 5.5 sometimes but never default) hosting offering is split 5.3/5.4. And actual usage of 5.4 is even lower than the offering. At this point I think what matters is the type of BC we're talking about here. PHP can't fix structural issues anymore, that would be how you pull a Python 3 or Perl 6. But if some functions disappear or change behavior, it's not too bad I agree. Worst case scenario you have to write a userland implementation and bingo.
&gt; Full text searching ~~in Symfony2~~ with Doctrine I fixed that for you.
Deprecating a feature takes time and has many stages. First it throws notices if you keep using it during the deprecation period, then it is removed. What you suggest is black and white, it's not deprecating it is removing directly. You can't deprecate it because the compiler does not know your original intention (to remove the whitespace or not).
That is ridiculous, running a regex to... avoid concatenation in your script? seriously? $sql = 'SELECT * '. 'FROM Table '. 'INNER JOIN OtherTable USING (MyID) '. 'WHERE Name = \'scott\'';
what regex? are you serious ? PHP tokenizer perfectly knows whether it is at the end of file or not
Because its unexpected behavior. 
Can we get this working with codeception?
Which one? 
Isn't OAuth2 specifically designed for this purpose? Now I agree, OAuth2 has it's problems but wouldn't it be better to invest some time in learning how to use OAuth2 instead of trying to roll your own? 
Here you go: http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html#ConstructingTheAuthenticationHeader
How many clients? I'm assuming a relatively small number, as you've given them their own key-pairs, in which case why not let your webserver's SSL library do all the work? It can authenticate a client cert way more securely than you or I ever will, and then pass you their DN in an environment variable so you know who they are.
&gt; Not one of them has given a single shred of hard evidence to prove anything they claim I linked you to one thread in another comment. Just look at the stuff on internals ([easy-to-browse version here](http://www.serverphorums.com/list.php?7)) or the many threads on /r/PHP from the past few weeks. &gt; This is nothing but perceived sleights and classic dogpiling. Dozens of folks are badmouthing Zeev because 1) they disagree with him, and 2) it's become the "cool" thing to do. Where's your "hard evidence" for this?
Yes, `Authorization`. That's the one he's already using. Which is, by the way, not specific for API's.
That wouldn't be much fair though.
&gt;hash('sha256', $key-&gt;privateKey.$timestamp); It looks like you're concatenating a secret value with a public value to create an authenticator. SHA256 is not secure for this purpose. Look into HMAC functions.
Maybe not ELI5 but the "Use case" section gives an example: https://wiki.php.net/rfc/generator-return-expressions#use-casecoroutine_return_values
Phalcon is amazing. Last time I tried it I didn't go ahead because I didn't felt like migrating from Twig/Doctrine, but I wonder if I can use Phalcon's micro APP as a drop in replacement for Slim routing.
Because then you would get people rushing votes while other competing RFCs were still being developed and refined, in order to beat them to the punch. And in an attempt to not be left out, you'd see these competing RFCs thrown prematurely into the mix and not receive a fair chance (which is what would have happened with Basic STH, and to a much lesser extent, Coercive STH). Not only that, but any attempt you made at resetting the vote if someone expressed intent to introduce a competing proposal would obviously open the system up to abuse, by opposers just continually putting up artificial competing proposals in order to delay the vote indefinitely.
pst.... /u/scaturr..... 
`yield` is a generator, `yield from` is generator delegation. The given examples are...eh, trivial? I can't speak for the PHP implementation, but in Python, `yield from` handles getting values from the subgenerator, sending values into a sub generator and handling errors from the subgenerator. In addition, a `yield from` assignment handles grabbing the return value of the subgenerator. `yield from` is also a handy way of "replacing" nested loops. In `itertools`, there's a method called chain that looks like: def chain(*iters): for it in iters: for v in it: yield v With `yield from` you can just... def chain(*iters): for it in iters: yield from it It's also very handy for building event loops. I won't go into details, because I'm still trying to understand them, but take a peek at Python 3.4's [asyncio](https://docs.python.org/3/library/asyncio.html) module.
My company is still using 32-bit OSes. It's actually very common still. SAs generally don't like to change things up just because shinies.
a variable doesn't have to be typed... It can be dynamic. Just like .net has right now.
that would be awesome.
Yes, the PHP RFCs are implementing exactly this behavior. I'm not sure if Python generator return values are accessible outside of delegation contexts, though. The PHP proposal here also allows application code to call `$generator-&gt;getReturn()` to retrieve the returned value from any generator function which has iterated to completion regardless of whether or not it was a "subgenerator."
&gt; The documentation once you are logged in Why is it hidden?
First, note that this RFC is really just a stepping stone for the `yield from &lt;expr&gt;` syntax proposed in the [Generator Delegation RFC](https://wiki.php.net/rfc/generator-delegation). Think about what has to happen to multitask processing tasks: we dispatch some unit of work in the form of a function call and that function returns immediately *even though the task hasn't completed yet*. This is how we can continue doing other things while the original async operation is happening. So how do we know when that other work has completed? Traditionally we use callbacks and you might do something like: function myAsyncThing($foo) { asyncThingFoo($foo, $onComplete = function($error = null, $result = null) { if (empty($error)) { asyncThingBar($result, $onComplete = function($error = null, $result = null) { // handle the next result here ... // and the nesting continues further and further to the right }); } else { // handle error here } }); } Now this is fine, but it quickly leads to a situation where your entire application happens inside callbacks and becomes very difficult to reason about. Before you know it your application is moving horizontally much faster than it's moving vertically. It's tough to write code this way and even tougher to read this kind of code. Not to mention error handling is notoriously difficult because if something goes wrong your stack trace is far-removed from the code where the actual problem occurred. This is what people often refer to as *"callback hell."* So it's no stretch to say it would be much easier if we could write asynchronous code that looks and feels similar to how we write normal synchronous code, right? This is where generators come in; remember that generators are nothing more than suspendable functions. This means that we can manipulate generators to wait for asynchronous operations to complete and subsequently resume where we left off when they finish. So let's do away with the callback from the above example and instead assume the `asyncThingFoo()` and `asyncThingBar()` functions return a "placeholder" object for the eventual value which has yet to be resolved. This placeholder is generally referred to as a `Promise` and it exposes methods like `Promise::then(callable $onSuccess)` so a holder of the promise can be notified when the operation completes. We can now rewrite our above function as a generator like so: function myAsyncThing($foo) { $bar = yield asyncThingFoo($foo); $baz = yield asyncThingBar($bar); return $baz; } In the new generator function we simply yield promises any time we have an operation we want to wait for and this completely eliminates callbacks. Beyond the above we only need about 40 lines of "framework" code to create functions that will automatically resolve generators yielding promise objects. Frequently this sort of thing happens inside of a non-blocking event loop and the asynchronous operations use that event loop to resolve their promised results. Generator delegation with the proposed `yield from` syntax just makes it much easier to write code using generators in this way because we can break up various parts of an operation into multiple generator functions instead of having one monolithic generator. So, in summary: generators and the two generator-related RFCs I've proposed here for PHP7 allow us to make asynchronous multitasking in PHP *much* more pleasant. Folks shouldn't need to understand how non-blocking IO or event loops or anything else work under the hood to see the benefit in the above example. `*` *edited to fix code derps*
To Python, exceptions are unexceptional. We take a "Easier to ask for forgiveness than permission" mindset rather than a "Look before you leap" other languages prefer. It does screwy sometimes -- see above -- but for the most part, I find that at a developer level, I know which things are gonna trigger what exceptions and how to handle them. Like 99% of the time, I simply don't even think of StopIteration, the looping mechanisms do that for me. But every once in a while, I'll need to do something with StopIteration.
Why not use simple HTTP authentication (if you use HTTPS)? You don't have to implement anything, the clients can use simple HTTP tools, even if the tools can not add extra header fields. Keep it simple.
Drupal == Downvote on r/php
Looks reasonable to me. Thanks for including a code snippet. 
&gt; SHA256 is not secure for this purpose. Not saying that you're wrong, but can you provide a source or explanation for this. 
Since I, hopeseekr, never actually attacked anyone and was *always* viciously attacked by Nicoon, HopeSeekrSucks, PointsOutBadCode, etc., can I maybe get my account reinstated, now that you've finally taken a stance against the provocateurs? I mean, it has been 3 1/4 years...
Seriously, literally 100% of PointsOutBadCode is attacks against me, primarily on /r/php, yet the admins responded in 2012 by revoking *my* write access, which I actually thanked them for. It *was* a valid response, as it prevented me from defending myself, constantly, which I felt was a workable compromise.
Among the numerous possibilities ranging from difference of philosophies to what depth of 'reasoning about the code' is being discussed, "Zeev does not know how static analysis work" is the last one that you should assume.. How many of other possibilities have you considered? Or did you choose the easy path and assume one that put you a bit superior and among the trend followers?
You're where I was two years ago on Zeev. :) 
Isn't it about SHA-1? SHA-256 and SHA-512 is SHA-2, so no any security issues. no?
Need to also use a constant time comparison function instead of == or you will be vulnerable to a timing attack. That's ignoring the other issues such as not using an hmac etc.
lets hope hhvm and the new compiler promised by /u/ircmaxel will make the internal pull their ass out of their mouth. yes i wrote it right
I think the advantage of having a `mixed` typehint is that you can distinguish the case "Not typehinted (yet)" and "I looked at this, it returns different types".
we only had to wait 7 years. thanks obama
still at the end of the day you have two ways to make the same thing. except that now you have a higher learning curve.
I have nothing to do with the RFC, just providing the patch ;)
You're misreading the issue. The construction of the SHA hash in general is based on blocks. You can know the has of a previous block without knowing the content, and then you can be determine the hash of that unknown content with known data appended. Use of any block hash in this way from MD4 to MD5 to SHA1 to SHA512 is a problem.
I was hoping that this bundle is something for feature toggle/switches, but it isn't.
The README only mentions enabling/disabling controller methods, is there anything to toggle the features in views for example? Or anywhere else in the application? (e.g. commands)
Ah yeah. I hate that. Comments are comments. 
Not rewriting URLs : Another commonly ignored and easy to fix issue. URLs like myapp.com/index.php?p=34&amp;g=24 are just not acceptable in this day and age. Due to it being incredibly difficult to write a good URL rewriting guide that would cover every server and framework out there, almost every framework has a guide on how to set up clean URLs (Laravel, Phalcon, Symfony, Zend) and any that don’t just aren’t worth using – they obviously don’t care about modern practices.
Long-term feature toggles are a little bit insidious anyway.
Agreed, it looks like its main purpose is to prohibit specific controller-actions based on annotations and the bundle config.
it only detects configuration for the moment, but feature enabling/disabling is coming in next version. Anyway it'll not be in the views, but in a service. And by the way you can access global twig variables to check the enabled/disabled features in the views.
Two things that annoy me: - Ordering of parameters is inconsistent. - Some functions return the resulting array, and in some the array is passed by reference.
Thank you, that does make a bit more sense. I guess since I've never written anything like that (mostly simple sites or straightforward/top-down execution) I was lost at the part where the program would continue without the yielded value I wanted. So then would the return within the generator act like a temporary value until the value I wanted was yielded? Edit: typo
This is how Python handles it. &gt;&gt;&gt; x in some_iter &gt;&gt;&gt; x not in some_iter Same thing with identity (not equality): &gt;&gt;&gt; x is y &gt;&gt;&gt; x is not y Alternatively, `not` could be moved outside as well, i.e. `not x in some_iter`
I don't like PHP anymore ...
i am very excited in what optimizations can be done by the compiler for segments of code that use strict typing. 
No doubt. Especially as it's use grows in popularity. At the very least lets make this a ini setting that can be modified at runtime.
Nice writeup. I found this very useful. Thanks!
The main problem discussed in internals about this specific implementation ( (int) &amp; int ) notes that large strict typing libraries will be really difficult to use for anybody who does not have the documentation available (if there's any) or for the eventual PHP 4/5 rookie user.
This may seem simpler at first glance, but in practice it would be a nightmare. Libraries might use a mix of strict and weak type declarations, and users would have to pay close attention to whether coercion is allowed *every time they call a function.*
I feel like that's not much of a problem. I mean, every other strong typed language seems to march forward without this complaint. Plus, at this point, everyone should be using some type of IDE with autocomplete that tells you which types a function takes. Even Vim has autocomplete plugins.
PHP was a weakly typed language until this year. There is (most probably) a high amount of PHP users that will keep programming in weak mode around the World, they will not understand the new error messages at all, and will probably keep using Dreamweaver.
This is one thing I really miss in PHP from languages like Java and C#. If I'm developing a package, it would make complying with semver much easier if I can specify visibility at the class level. Some classes are purely intended for internal usage and I feel `private` is more expressive than using the `final` keyword.
Yup. Because people who haven't even bothered to try the patch, and barely even read the RFC are saying that it's bad. And I don't mean you. I'm talking people who voted on it. People on list who are right now discussing it. Who fail to even read the proposal (since the exact points they are making are spelled out literally).
I GLANCED AT IT BRIEFLY AND -1 BECAUSE I DONT UNDERSTAND THE THINGS IT SAYS
Yeah, pretty much. We do have `!=` (there's also `&lt;&gt;` but it's tongue in cheek for Python 3) but that's the only place I can think of that uses the exclamation mark, but really I find myself typing `not x == y` more often than not, feels more "Pythonic" to me. In PHP you'd do: if !$x {...} Python: if not x: ...
Oh hey Phil! I'm actually in the process of reading your book, I don't think I've gotten to the authentication section yet though. Thanks for the links!
Agreed. AFAWK should be replaced too, toward the end of the article.
Note, this is **not** package private. It's namespace private. This is a HUGE difference. Because you can trivially do the following: In `/Foo/Bar.php`: namespace Foo; private class Bar { } Then in `/Something/Elser.php`: namespace Foo { class Baz extends Bar {} } namespace Something { class Elser { public function blah() { $baz = new Baz; // just accessed a private class!!!! } } } This is because namespaces are literally nothing more than copy/paste (They are class name prefixes). This means that you can define a namespace anywhere. Which means that there's no such thing as a "package". Meaning the visibility limitations are trivially bypassed. This is unlike JavaScripts AMD-style packages, where private is literally private (well, more specifically closure scoped). And unlike Python or Go packages, which are first-class packages with true visibility. I think I'd much rather see a first-class package system in PHP before I see private implementations...
That's what I'm starting to feel more and more. Thanks for the feedback.
To clarify, SHA256 is secure for this purpose, but you would need to use the HMAC functions. (So not sha256 on its own) This is the way I use it: hash_hmac("sha1", $youruniquestring, $clientSecret, false); You might be tempted to use the raw output, but it is kind of flawed in PHP as far as I can remember because you have the posibility of generating a C style \0 (end of string) character. This might have been fixed.
Ha! I hope you like it. There's a bit in there about "probably don't roll your own" and about how OAuth 2 is a solid solution despite the odd complaints from detractors.
You are not forced to use scalar typing in your functions/classes. And if you need to use an external library with scalar types, you are not required to cast the variables in normal (weak typing) mode, unless you manually add the declare() directive at the top of the current script.
So what you're saying is that depending on Java as a career path is like depending on the lottery for income?
Agreed with this. Full text searching in SQL is not all that scalable. It works up to a point, but once you start dealing with millions of records, it crawls - even if you have the DB loaded into memory.
&gt; I think I'd much rather see a first-class package system in PHP before I see private implementations... This would be great ideally, but I think that ship has sailed with the introduction of compiler-assisted-copy-paste namespaces. Proper package semantics would require a specific filesystem layout (just like in Go, Java etc.) and that could clash with existing namespaces. The only way to make it work would be to limit namespaces and autoloading to a single standard like PSR-4. That way, existing namespaces could transparently become *packages*. With that, we could even introduce wildcard imports, i.e: use Foo\Bar\*; 
Okay, but you're not disagreeing with me. I'm debating the `declare(strict_types=1)` syntax vs. explicitly casting when I call a function, eg `foo((int)$i);`. Both syntaxes leave the decisions up to the caller, but I think the latter is cleaner than littering all my scripts with a `declare` statement.
&gt; and users would have to pay close attention to whether coercion is allowed every time they call a function. There's a simple solution for that: don't allow coercion! And then, as if by magic, you don't have to think about anything when calling a function. A PHP function with type hints acts the same was as every other language with strong typing.
I think it's mostly the quality of this article, who the fuck does not know you need to read logs?
&gt; SSL certificate that gets pre-installed on the mobile devices that will be used to access the application You mean the application can't be accessed without the certificate being previously installed? Are these individual certificates (e.g. each client has its own client-side certificate)?
Actually, the goal in PHP nowadays is to avoid things like that in the configuration. If you're on shared hosting you usually can't change php.ini and by the time you'd be able to call ini_set(), it's already too late.
So you would litter all your function declarations with additional characters, but you won't add a line to the beginning of the file? Besides, mixing weak and strong type hints in one file seems like a really bad idea...
What's the point in type hinting when you can put a weak type through to it anyway? Surely if you're declaring strict for the function, then that should also (automatically ideally) be done for any programs that call it? Doing this: function add(int $a, int $b): int { return $a + $b; } and letting you do this: add(1.5, 2.5)); Completely defeats the point of the type hints!
In strict mode, the engine will throw an exception: &lt;?php declare(strict_types=1); //strict function declarations.. $my_int = add(1.5, 2.5); //Exception
no, is about knowing your market and lying a little on the interviews. before specializing in java you need to find what they use at your country, which certifications are required, whats the most popular software, etc.
I see, and that makes sense. I believe the syntax you mentioned has been suggested and rejected earlier, but perhaps in time those sentiments might change.
I have full control over my hosting environment for all my projects, so it wouldn't bother me personally, but we're the exception to the rule in the greater world of PHP usage. Also, my bad about ini_set(), I momentarily forgot that type hints are checked at runtime, not parse time.
Hoping that the current user has access to the directory of the library that caused the problem globally (FTP permissions? Shared hosting Include path?).
It isn't. In fact, it even goes as far as to contradict itself. On one hand, it says something to the effect of "don't reach for the stars, because you'll wind up broke trying to get there", then it goes on to say "use what you know". These are both sentiments I can agree with. On the other, it then tells you explicitly not to use PHP because it will "hold you back" which is patently false. If PHP were holding people back, 3/4 of the web wouldn't be running it for projects.
Cool, thanks! Tomorrow takes the 20% of a project that is spent with a text editor, and surrounds it with process-based options that cover (some) of the other 80%! E.g. Cloudflare built in, auto minimisation of LESS/Javascript, automatic generation of migrations. Another pretty cool feature is built in hosting via your own isolated container. There is also a lessening of friction between an idea and that idea being implemented, by prompting the user and guiding them where suitable.
PHP has some flaws that people like to bring up but I don't feel that comment *really* touches on them. His suggestion of "skipping" PHP, the language that powers the majority of the web, is bad advice. He may not like PHP, but there *are* good reasons to use it. He clearly comes from a background of working with stricter languages. Languages that can stop mistakes before you even make them but at the cost of certain flexibility and simplicity. People who are very comfortable with stricter languages tend to find PHP too forgiving in comparison to what they're used to. They like the stricter rules and structure and see the, by comparison, free-for-all nature of PHP as a bad bad thing where mistakes are easier to make. But if you don't hate PHP, you find working with it easy and fun, then PHP *is* awesome and great to use. You don't need everyone to like the tools you use if you get the job done.
It seems that his main point of contention is this: &gt; PHP lets you be active a lot, and it hides a lot of different types of errors in not so great ways that can hide serious problems And he's partially correct. It's true that PHP will *let* you hide serious problems **if you tell it to**. That doesn't mean that you should. As long as you keep your error reporting on the highest setting and don't use the error control operator (the @) then this isn't much of a problem. However, PHP does have strange quirks that will let you do wonky things. For example: "10 a long piece of text here." + 2 === 12; In most programming languages this would be an error. If that irks you a whole bunch, use a different language. Otherwise, who cares? :P
This is pretty impressive. Automatic migrations, full project export, container statistics (maybe add bandwidth / connections?), runs on MariaDB and HHVM, has JS/CSS preprocessor support. Does it support automatic scaling via Google Compute Engine? Congrats on entering beta, looks pretty damn nice.
Its one shared certificate, but the IT department will be pre-installing the certificate on the mobile devices that will access the web app so that the non-technical operators never have to do that themselves. Thus the end-user training will be "Never accept a new certificate if you see this" *&lt;image of certificate confirmation bubble in iOS and Android&gt;*.
I would agree, except that PHP has no mechanism to safely cast between types. It's one of the biggest problems with strict typehints in general. Existing explicit casts use unsafe rules (with data loss), and can never fail. Now that strict typehints are a thing, this will need to be addressed pretty quickly.
I think you're confused. Look again at what I wrote in my comments. &gt; I can explicitly cast to int when I call the function if I want casting, eg `foo((int)$i);`. and... &gt; I'm debating the `declare(strict_types=1)` syntax vs. explicitly casting when I call a function, eg `foo((int)$i);` For clarity: foo((int)$i); For even more clarity: function foo(int $i) { .... } $i = "42"; foo((int)$i); That's not putting the casting in the function declaration. That's calling a function, which puts the decision making on the caller, as you said. So I'm not even sure what you're disagreeing with. And to make things even *more* clear, when I say, "the declare strict syntax" I'm speficially speaking of the expression `declare(strict_types=1)`, not function declarations.
[This thread](https://news.ycombinator.com/item?id=9216294) from hackernews contains some info regarding this. 
Most other programming languages will tell you how to be a good programmer, but PHP won't do that. PHP is one of the most 'freeform' languages I have used, probably comparable only to Javascript. Your code hasn't to be elegant to work, and even your 70 years old neighbor can learn some basic PHP in a day. Being a freeform language is both good and bad. Good, because this is one of the reasons why PHP is such a big language. Everyone has at least once put php code on the top of their index.php file and echo'd some values in between HTML tags. I've even read books that suggested that this was the best way to do it. But this is just the start. From there on you learn about OOP, you learn about the SOLID principles and other things. You become a better developer and this will make your code much better. Bad, because the community has the shape of a pyramid. The bottom of that pyramid are those who know PHP but don't know "how" to be good developers/programmers. They never heard of Laravel, Composer and unit testing. The top are very good developers like Fabien Potencier and Taylor Otwell (and many others btw, these are just 2 names I can think of right now) who make the PHP community better. So to answer your question. PHP is not a bad language (IMO), but it lets you code free and if you don't take the time to learn how to become a beter developer, your code will be bad. For example, take a look at this source code from Facebook that leaked in 2007: https://gist.github.com/nikcub/3833406 If you know that that isn't the way code should look like in 2015 (and even in 2007 that code wasn't very good), you are already a better coder than those who made Facebook a multibillion dollar company. So go ahead and use PHP for your next project. You'll be fine.
So if someone tries to connect to the web server he just needs to accept the new certificate and he's good to go? Then I think this could be improved. I suggest you configure the web server to **require** clients with valid certificates already. That is: IT department must pre-install signed certificates on the mobile devices. So someone from another device on the same network will not be able to access the web app, because he doesn't have a valid certificate installed. I've never done this myself, but you could [start here](https://httpd.apache.org/docs/current/ssl/ssl_howto.html#allclients). I suppose you could even work on a infrastructure where individual client certificates could be revoked in case a device gets stolen. Then of course on top of it you can also push other tiers of security, like that shared password you mentioned before.
Original poster makes claim "I don't think it's even fair to say Facebook uses PHP. They use HPHPc" then posts URL to wikipedia Original poster doesn't bother to read the content of the Wikipedia article they posted " in early 2013 Facebook deprecated HPHPc" PHP has flaws, many, but it is moving forward. The ability to take the valid criticism alongside the FUD is the hardest part of being a contemporary PHP developer.
I mentioned this in another comment, but I'm fine with using the `declare` switch. I just think it should be used to turn on weak typing with strong typing being the default, eg `declare(coerce_types=1)`.
When he says "holding you back", he likely means in terms of being able to design and build *robust*, tested, stable, well-architected software, as well as being able to grow as a developer - he doesn't mean in terms of what you can and can't accomplish in PHP. If that's what he means, that would be true if we're talking PHP 4. Hell, I'll even throw him a bone and say that's true of anything prior to PHP 5.3. But that's actually *NOT* true anymore. It hasn't been for *many years*. Arguably, PHP has surpassed languages like Python and Ruby in terms of writing disciplined, well-structured, object-oriented code, and is at least on par with them in terms of frameworks and process. PHP has many excellent frameworks on par with Django and Rails. PHP has a package manager now. PHP has FIG standards now. PHP will actually help you *grow* as a developer, not hold you back. 
The key is to have a few different schemes along the lines of password limiting. You could start with each IP having only a few attempts with each attempt adding an ever growing delay. Also if there are simply too many attempts in a period of time from many IPs then you could kick in some captchas. They could be easy for the first one and harder for the next. (click on the cute kitten for the first). The reality is that while a numeric only password wildly reduces the attack surface area a 4 digit pin is fine for banks because of the lock out. Also while this is security by obscurity if you don't mention the numeric only in the password screen then the average attacker will happily keep plugging away with alpha numeric passwords. So while your situation is not ideal it isn't a total disaster. Where you just have to be careful is that if a hacker is wailing away that they can't shut out a legitimate user. 
&gt; Arguably, PHP has surpassed languages like Python and Ruby in terms of writing disciplined, well-structured, object-oriented code This is simple NOT TRUE. PHP is a Joke if you compare it to Python (2 or 3). Watch [this](https://www.youtube.com/watch?v=NfngrdLv9ZQ) and give it some thought. Please. On top of that. "writing disciplined, well-structured, object-oriented code" is not an end in itself. You are required to be extra disciplined when working with php because the language is a mess. You are required to write TONS of unit tests, because only god know in how many myriad ways your application will break because of a small change you made and that too 10 days into deployment... 
&gt; if you get serious about learning programming and learning to be good at programming, one of the things you will end up learning in this process is that PHP was holding you back Okay so that is a claim that in order to be "serious" and "good" at programming I should not use PHP because PHP is somehow "holding me back." Okay, I'm willing to accept that, let's see what evidence or reasoning he uses to support this rather bold statement. &gt; A lot of programmers never care about whether or not they can prove their results are correct. I'm not exactly sure what this means. "Prove my results are correct", hmm. Is he talking about mathematically proofing my software? No one has done that for 40 years. How about validating my results against some validation rules? A lot of people do that, especially in PHP. I don't know what to make of this statement. &gt; They don't care if they aren't getting more productive over time, but are spending time fixing the same, old bugs they've always had. To them, activity and productivity are the same thing. I'm not exactly sure what he's getting at here. He doesn't define what the "same, old" bugs are. He states that PHP developers view activity and productivity as the same. Essentially, in his view, PHP requires that I fix the "same, old" bugs repeatedly and therefore, while I may be active, I am not productive. This is implies that I am unable to learn from my mistakes or draw on my experience to avoid making those mistakes in the future. Perhaps he makes those mistakes repeatedly, but is it PHP's fault that PHP isn't a strict language? Or is it his fault for treating PHP like a strict language and blaming PHP for not meeting his unreasonable expectations? &gt; PHP lets you be active a lot, and it hides a lot of different types of errors in not so great ways that can hide serious problems He doesn't cite a single error or "serious problem." Perhaps he is referring to error suppression or how some developers don't report notices while developing. If that is the case then he is criticizing PHP for being *too* flexible. Sure it may be bad practice but it isn't required and certainly no great tragedy. Alternatively he may be referring to type coercion and dynamic typing. In that case it only demonstrates he doesn't understand what dynamic typing is. But I guess I can understand that since PHP is the only dynamically typed language in the whole universe. Oh wait, no it's not! (Yet somehow PHP is the only language that receives criticism for it). &gt; Personally, I prefer a language that helps you find your problems, rather than sweep them under a rug. What problems? He hasn't actually defined a single problem, only presumed a problem and forwarded conjecture and unsubstantiated opinion. This is just another example of a hothead portraying his personal preferences as objective fact. There is no perfect programming language because there is no objective standard. He makes a lot of claims without providing any evidence and expects us to accept his word on the basis of credibility (and his username is moron4hire). Let's just say I'm not convinced. I prefer PHP and consider myself both "serious" and "good." edit: reading comprehension
&gt; Will the users have those passwords? Is it personal devices or company devices Users will have them, but they are company devices. &gt; The standard prevention against brute force attacks is limiting log-in attempts. Adding something as small as a 10s cooldown per IP between attempts drastically increases the time involved to brute force and if possible a 60s cool down pretty much prevents it, if you have something actively alerting you if failed attempts reach a certain threshold. I think in this case, the threat vector is going to be someone nearby with a laptop and Backtrack et. al. Given this they'll be able to both impersonate any MAC address, and any IP address, with relative ease. So while it would certainly help to prevent an ex-employee from connecting nearby with a laptop or tablet, it won't stop a determined attacker with the right tools. Literally the only defense in this case is the fact that the extremely low entropy of a 5 digit password is protected by a ~2 second attempt to log in per try. If they were to gain access to the database file somehow, it would be trivial to crack the password, but we're safe from SQL injection so I doubt we'll be leaking the database. They would have to compromise the server itself to get at it, but then we have bigger problems anyway...
&gt; This is simple NOT TRUE. PHP is a Joke if you compare it to Python Is it not true that Python (2) provides no method visibility? That all methods are free game for any client code to consume? Also, is it not true that Ruby has no way of explicitly requiring an implementation of an interface, that duck typing is the equivalent of PHP's non-interfaced duck typing? Because if so, then why have I seen people give PHP shit for the very thing Ruby gets praise for? Also, is it not true that Ruby lets client code arbitrarily override the visibility of service code methods?
The pythonic way is to mark the private members with an _ prefix. The reasoning is that even if your methods are private, it does not actually protect you from anything. One can always edit the source. The important thing is letting others know that you (the author of the class) intend so and so methods for private use only, which can be done by following a convention such as using an _ prefix. And if they still need to access something, they can do that without going and editing the actual file. Editing the source file as you ll have to do in php is sub-optimal because when you change a private method to public so that you can access it, you are erasing the info put in by the original author, that this method is private, and might confuse/mislead other who come after you. 
do people use Yii? I tried out Yii 2 when I was starting my current position in December - we were deciding which framework to rebuild and then continue a suite of apps with. I found Yii so unnatural, clunky, and awkward to write compared to Laravel or [non-PHP] Rails. Also, I've never met a single person in real life who uses Yii or Yii 2, and when I was googling for help during my trial with it, Stackoverflow/Reddit seemed completely void.
I don't disagree. I had that discussion too in school … and we were told to discard it as indeterminate. I see your point, but just putting there "The answer is 1." is not correct. It's not the answer, it's usual consensus. (0! = 1 is definition and 0^0 isn't defined in that sense.) But that's also why I put the "wrong" in italics.
Wait so you can turn off the checking in your calling code if you want? Edit: forget me. I was confused, it works like I thought.
The contrary also applies too on what was or wasnt said. Just because its easy doesnt mean its right. Its easier to get a stick of dynamite to take down a wall, doesnt mean its the best option.
Maybe "hiding the error" refers to functions that return false instead of throwing an exception. Most of my calls to php functions look like this : If ( false === ( $var = php_function() ) ) throw new exception ("");
No idea what you mean.
https://github.com/thephpleague/shunt is an option. I'm not sure about the quality, but that group (thephpleague) have a decent history of building quality packages. I think that would do what you're requesting. There was another SSH package as well written by (I think) one of the Bitcoin vendors that got shutdown, but I'd advise against using that as I believe it had some horrible flaws.
http://phpseclib.sourceforge.net/ PHPSecLib is a pure PHP implementation of SSH, RSA, SFTP, etc.
Damn. It seems PECL has the DLL built for 5.5, but not 5.6. 
&gt; You are required to be extra disciplined when working with php because the language is a mess. You are required to write TONS of unit tests, because only god know in how many myriad ways your application will break because of a small change you made and that too 10 days into deployment... No, you're not required to do this because "the language is a mess". You're *highly encouraged* to do this because any change to a system can have side effects regardless of the code base size and you want to be able to quickly identify errors in the code base. It doesn't matter if you're programming in Java, Scala, .NET, Perl, Python, etc etc etc or if you're 10 days or 10 years into a deployment; if you change a method to return an array when previously it was returning a string you're going to have a bad time. If you're altering a data class that is used in the messaging/database/caching systems, you need to make sure you didn't change a parameter that someone needs somewhere along the line. You write *tons* of unit tests because you want to cover every single possible logical path that your system can take, and you're willing to admit that manual testing is tedious, boring, time consuming, and prone to missing errors. I think you might misunderstand the point of unit tests.
&gt; You want to change a route without touching the file that contains the routing logic? There is no reason for that file to contain any other logic. Right? &gt; Not sure how. SRP says an entity should have only one reason to change. You are changing the routing file because you want to change the routes. How does that violate SRP? A route is comprised of a URI, and a handler. That usage of decorators couples the URI to the handler in the same class. I can't change *only* the URI without touching the class that contains the handler call. In Laravel (or really, any PHP router), that's the equivalent of attaching a callback function to a route URI, rather than referencing a class@method. Route::get('/my/uri', function() { // logic is coupled to my URI defintion - badness. } is the same as @get('/my/uri') def myHandlerFunction // logic here vs Route::get('/my/uri', 'HandlerClass@handlerMethod'); // Much better. I need not touch anything in the place where my `Handlerclass@method`code lives if I merely want to change my URI to `/my/different/uri`. SRP means more than one reason to change. The URI schema is a reason to change, as is the logic that responds to that schema. Changing the schema, and changing the logic that runs in response to that schema, should be different things entirely, and thus should be separate - not live next to each other in the same class or file. &gt; When I first looked at python I thought 'No namespaces, no Autoloading. WTF? So braindead !duh'. Oh boy, was I mistaken! On the otherhand, the fact that I have to explicitly import MD5 just to use it, while PHP makes it available to me globally, is silly. PHP's library API is global. With Python, I have to know where things live in order to import them in order to use them. That's fine for 3rd party packages, but I shouldn't have to import fundamental parts of my language's library just to use them... But anyway, the point isn't to bash Python, it's simply to point out that Python isn't right while PHP is wrong. Python is DIFFERENT, and I have no reason to use another language that provides no *tangible* advantage over PHP, when I am super-proficient in PHP already.
mm..I think you misunderstood me. I am not missing the value of automated tests. But, when you are coding in a better language, there are **less** things to go wrong, **less** tests to write, **less** mocking to do, **less** dependency injection you have to handle..That is a lot of less! Right? I am not sure I can convey the feeling. But when I code something better languages, the end result feel less 'flakey'. To have the same feeling in PHP, I used to have to write a whole lot of tests. 
On the other hand... a lot more than 3/4 of the web isn't trying to do anything particularly interesting technology-wise.
That's just not true. Take Go for example. It is a very strict language (overly so IMO) with a very sane standard library which is extremely opinionated about how it needs to work. And yet it still has a ton of tools like formatting, unit testing, code coverage, IDE integration tools, linters, vetting, and even race detection built into the language. These aren't things to "make a bad language good", these are things which every language should use.
From my experience, when I was working with php, I had to write a lot more automated tests to feel complete, to feel that things are not broken. But when working with python, you don't feel the need to write as much tests. Because when developing itself, you are seeing less broken stuff, less inconsistencies, less weird behaviors. So the result feels much more solid, **without having to write tons of tests**. 
I'm always astounded why this response is not brought up more often. Its 100% true and accurate. This is exactly how I plan to use STH. Sure bugs and such may go un-noticed a little easier .. but thats the state we are already in with PHP.. so it's not really a strong argument. ((this is the main argument I see against the weak camp))
I don't buy that at all. I've did python work for a good while, and it was the same amount of work writing python tests and debugging as it was in php. Saying something "feels" more solid is worthless, take a look at some systems which went from PHP to python, generally the overwhelming consensus is that it's just different.
It's the right answer for the following reasons: * OP's asking indicates they care about doing it correctly ("Is this a secure way to handle authentication for API calls?"). Unless you are a security researcher, following existing best practices is the right choice. If you are a security researcher, then your goal is to improve the best practices. OP is clearly not a security researcher, and there's absolutely nothing wrong with that. I'm not either. * OAuth2 is one of a handful of approaches that are designed to solve the problem the OP inquired about: * It's one of the easiest to implement (both client and server side). * There are countless libraries to get it up and running quickly, easily, and securely. * It's a well understood standard by most developers programming against APIs * Its shortcomings are understood as well * Literally everyone who's not a security expert that tries to implement their own thing does one of two things: 1. Creates an insecure system (this happens the vast, vast majority of the time) 2. Unintentionally recreates an existing standard Seeing that #1 is not acceptable, the correct, secure approach is to follow an existing standard, preferably implemented by an [existing library](https://packagist.org/packages/bshaffer/oauth2-server-php) (disclaimer: I have not tested or reviewed that code; it was highly rated on packagist) I can spot several flaws in OPs proposed approach (which have been discussed elsewhere in the thread) that back up my claims about accidentally creating security flaws (#1), but going through all of them and and fixing them eventually ends up recreating OAuth2 (#2). **This does not reflect poorly on OP - this is why we do code reviews, and I commend OP for requesting one.** Seriously people, please don't fuck around with security. Save your cleverness for other stuff, where problems don't lose people's personally identifying or financial information, or break in nearly-invisible ways. This is the same thing I tell people when they take my development security classes, and anyone else that asks for advice. I work on codebases that handle billions of dollars, so I take this stuff seriously. I don't fault anyone for wanting to learn about security, but please save your experimentation for side projects and use established, trusted systems in production with real user data.
Do training wheels hold you back from being a great bicycle rider?
He's arguing that it's annoying to have to throw his own exception instead of php doing it for him. My code assumes php throws an exception from php_function() so it needs to be handled. That would be more annoying than checking the return value for false, in my opinion. 
&gt; If PHP were holding people back, 3/4 of the web wouldn't be running it for projects. There's this silly little company in California called "FaceSpace" or something like that who's using PHP. Granted, they're heavily involved in steering the future of the language, but I've heard kids talking about their product so they must be doing something worthwhile with it.
I find myself curious as to which language you are using and how it differs from PHP. I'll concede that in some cases DI and mocks can present pain points when doing unit tests. However, it is not a result of PHP being a bad language that mandates I write lots of unit tests. I'm not testing PHP as a programming language with my unit tests, I'm making sure that "for these various inputs, I obtain the correct predicted output." It has nothing to do with the language. Whether I was writing tests in Java, Ruby or PHP I'd like to know "if I submit an invalid parameter, an exception is thrown. If I submit a valid parameter, it is processed appropriately." &gt; ***less*** things to go wrong What do you mean by "less things"? Few programming languages prevent you from changing your code to return a different datatype than before unless it includes scalar type definitions. Few languages will prevent you from altering a class structure which may have unintended side effects. No language will prevent a 3rd party data submission from containing bad data. One of the few ways I can think of that === "less to go wrong" would perhaps be static variables and the aforementioned scalar types (which is upcoming in PHP 7). What other things do you consider should be included? &gt; ***less*** tests to write If I have 5 different possible outcomes of a method, I should have 5 different unit tests so all my logic paths are covered. The language I'm using does not affect that. I have yet to write a unit test that was mandated due to a PHP bug that only cropped up when "N" input was submitted. &gt; ***less*** mocking to do If I want fewer mocks to make up, I use fewer classes in my software or avoid connecting to 3rd party services that are outside of my control. Again, if it has an affect on my logic path, I want to have it under test. How does your programming language allow you to use fewer mocks? Automagic mocking of classes? That could be a rather nifty addendum to PHPUnit or Mockery, but you still run into roadblocks with private/protected parameters/methods. &gt; ***less*** dependency injection DI can either be a good thing or a bad thing depending on how you're implementing it. If your software is architected poorly and you have a tightly coupled system, then hell yeah you're going to have a problem with DI. If I'm putting something under test and I find that I have to mock up a bunch of objects in order to DI them into a class, I'm going to assume that my code is poorly structured and should be refactored. I'm not sure how PHP itself contributes to a problem that is primarily due to architecture issues. How does your preferred language mitigate DI issues?
Fair enough. You can't modify the contents of native functions, of course, but that's a better approach for user functions.
Compile from source. Probably will be rather more involved than on *nix where I can compile SSH2 extension with a simple "phpize &amp;&amp; ./configure &amp;&amp; make" - but should be possible. Also this will most likely need OpenSSH libs as well - fun times :)
I've never felt held back by the language in the 15 years that I've been using it. If you feel held back by a language, you're obviously not wanting to look for a solution, rather the easy way out. I've lost track of the things I've been able to do with PHP in the industry that I'm in. Sending print jobs direct to the printer (no Ctrl+P browser interface requiring user interaction). Printing to a receipt printer (sure that's simple but most don't know how simple it is), which in turn will kick a cash till, and the list goes on. The other developer who uses Delphi is constantly asking me what I use in PHP to get around certain road blocks he is having. Most of the time it ends up with him having to write some week or two long workaround to implement htmlentities or something stupid like that because his XML component keeps freaking out. I sigh... I sigh a lot, and I'm using the "less professional non-compiled' language. At least I can do my job properly, and at speed, and he is using a WYSIWYG based IDE. I'm not saying that PHP is #1, but I've been around a lot of languages over my 25 years of programming, and PHP has allowed me to do more on a default install, faster than others. But to each their own, if you like trading up sanity for the sake of feeling satisfied that the end result is a compiled binary that took you 5x the time to write it, go for it.
This is really a "Magento" post - not "PHP" related at all. Clickbait. My one recommendation for MAGE would be double every educated estimation of expected CPU/memory usage needs - MAGE Is an absolute pig-dog and will need it. 
You have a weird history dude... You went from not hating PHP, and writing some cool stuff (Vodka, Cliche), to deleting your old account (/u/i_make_snow_flakes), and creating this account, and turning in to a massive troll. What the hell happened?
I went from using strict languages to PHP, and it sucked. Hard. Shit was weird. And then I got used to it. And now I kind of prefer it.
I'm assuming the session cookie will be encrypted using a different key. As a possible response back to the client I would maybe show them this as an argument for why a 5 digit only numeric passphrase would be bad. https://www.grc.com/haystack.htm
&gt; ~~His suggestion of "skipping" PHP, the language that powers the majority of the web, is bad advice.~~ # &gt;So I think if one is interested in building a career in programming, they better skip php. And yet I make $115k/year as a PHP developer + my own side projects. edit: I quoted the wrong part.
I had one that did a 40GB XML database dump into MySQL through PHP at the top of every hour. C# wouldn't even parse it because it wasn't what C# expected the XML to look like. PHP handled it perfectly.
I'm new to PHP, but I keep hearing this same thing over and over again. If PHP is such a crappy language that I shoudn't use it, then what should I use instead of it? Everyone appears to be bashing PHP without leaving any alternative languages to use. I'm really confused about this.
I feel like that person comes from a background in something like .NET where he can take a Web Forms application and just drag/drop 90% of the functionality you would want onto the page and go from there. Its really fast, but its also not as great as it would sound. There are a lot of overhead with a lot of those objects, and the graphical view doesn't necessarily generate good code. And while its quick to just create a connection object to the database, create a datable object to said connection object for a table and just connect that table to a gridview to display, but its easy to fall into that trap of "oh the update panel lets me do ajax without thinking about it" and "the girdview displays a paging grid" and the repeater displays large amounts of data easily! And its great on paper, even while developing, but you find out right quick once it goes live that it doesn't scale well for shit. That your ajax calls are transmitting way more data than they need to be and the whole site feels slow and clunky. By custom coding all your ajax calls, using plugins like datatables for your tabular data, etc you can get a much better experience, but at that point you're really just using the language as a framework and whether its in PHP or .NET or Java it matters less and less because at the end of the day, a lot of the code you're writing is in javascript.
There is allready an issue on github: https://github.com/justinrainbow/json-schema/issues/128
Quirks like this are in most programming languages. You should watch https://www.destroyallsoftware.com/talks/wat, or check famous stackoverflow threads such as http://stackoverflow.com/questions/11695110/why-is-this-program-valid-i-was-trying-to-create-a-syntax-error As for the above example, you can see PHP is doing type juggling and trying to convert the string into an integer since you are using addition operator with an integer on right, so PHP tries to convert the first parameter into an integer. http://php.net/manual/en/language.types.type-juggling.php "10 a long piece of text here." then becomes (integer) 10. Why? Because that is the rule on how strings are converted to integers in PHP. If you read: http://php.net/manual/en/language.types.string.php#language.types.string.conversion you'll notice interpreter checks if the first letter is a valid number. If so, it goes to the second letter. (recursively) In this case, `10` is valid, but the ` ` coming afterwards is not valid, so PHP takes `10` from that. You could also pass something like `1e5`, which is scientific shortcut for `10000`, and PHP will convert it just fine long as it is in the boundaries. (Boundaries are 32bit signed for 32bit platforms and 64bit signed for 64bit platforms excluding windows, with no unsigned support) Since final output becomes an integer and also equals 12, the strict comparison passes. (integer) 10 + (integer) 2 === (integer) 12 --&gt; true What is weird about it? It is like blaming math for not supporting the addition of apples and oranges.
I agree with you, but I think it depends what you're trying to make. I don't think the argument, "X amount of the web uses it so it must be good!" is a valid one -- the majority of sites aren't trying to really do anything outside of display basic content. (guess what I'm trying to say is the majority of web sites are not web apps, and just because many people use it does not make it the best choice for every web app). 
I'm really only a web dev (have dabbled with some strict-ish languages, namely Java and C#) but most of my experience is with PHP and JavaScript. I've always wondered if it's easier to go from a strict language -&gt; less strict language, or is it easier for dev's to go less strict -&gt; strict? 
hehe Jordi will fix it before php7 is up 
No, training wheels will *enhance* your ability to be a great bicycle rider. A little guy named **Lance Armstrong** based his bike riding on the use of training wheels, you're going to tell him he's not a good bike rider? Pfft. There's nothing you can do on a bike without training wheels that you can't do on a bike with them, and over the past few years they've been getting more and more sophisticated: shocks, struts, more give for tight turns. People are just basing their wrong opinions on version 4 training wheels, I bet they haven't even seen the new ones. They're just jealous because they see people in the street with training wheels who never even went to bike school. Dolla dolla bills, training wheels 4 lyfe.
This was a massive, poorly designed database (all data in one table, no relations or indexes) that consisted of an entire nationwide organization's memberlist. ...with plaintext passwords.
Haha, I feel like I need a tutorial or something on how to use / get the most out of PHPStorm. I can tell it's packed with a lot of power, I just have no idea how to use it / when to use various tools! 
javascript does that for things like indexOf.... idk about php though
Yeah I am definitely guilty of that. For me I always just feel kinda clunky/slow in IDE's, and like there's so many buttons and toolbars and side panels and whatnot it's hard for me to just focus on what I'm doing. Of course, this is a result of not really knowing what all the tools do. I tend to just use git from the terminal personally :-) 
Well, my time is mostly spent in the code window, sometimes in the project window looking for a file to open, rarely in the navigator window when I forget what shit I actually have in some old file I haven't looked at in months, then the todo window, and then code inspection once I've hit a plateau and think I've fixed a tonne of bugs (and then discover from the inspection another tonne I never knew about). The rest of the time is staring at reddi... uh, code, pressing CTRL+B or middle-click to go to some class/method/function, Shift+F6 to rename something and have it applied everywhere, and Alt+F7 to find all usages of some function/method or whatever, and sometimes there is the occasional CTRL+q to pop-up the PHPDoc info on a class method I'm about to use. It's all a few key combos in roughly the same area, and a few prominent windows in the IDE that get my attention. Apart from git at the start / end of the day or few days, or a CTRL+F or CTRL+Shift+F to search the file / project for some particular text then that's about all I use. The rest of the time is just dealing with code and responding to notices about stuff I've miss-typed or whatever other warning Storm wants to give me. There is plenty of other bells and whistles, but who the fuck knows what they do.
Yeah, probably. I was playing devil's advocate to answer OP's question.
Fair enough. I switched to Mac for that reason, though it's not feasible for everyone. Srsly though, fire up a vagrant box for that stuff
PHP, like any language, can be written poorly. PHP is easy to learn so when people see poorly written PHP they tend to blame the language; not the developer. What separates someone who knows PHP from someone who has mastered PHP, in my opinion, boils down to object design patterns, knowing common mistakes, and balancing database query power and PHP processing power. PHP is a great language. It's easy to get your hands dirty. Prototypes are quick. Support is always there. Next time you hear someone bash PHP, ask what version they used last. It has grown a lot. Chances are they are on a bandwagon.
OS X runs photoshop really well. 
I ll give you one example where PHP has bit me hard, and how I begin to hate the language (after 9 years working with it). Consider the following snippet... $c = array(); // You store some data using some string keys foreach (array('ab', 'cd', '10', 'gh', '24') as $key) { $c[$key] = 1; } // You pass the array $c to some place else and there you do something like foreach ($c as $k =&gt; $v) { if ($k === '10') { echo "found"; exit; } } If [you try the above program](http://3v4l.org/XTuNL), you will see that it **will not** print 'found'. The key is never '10' because it has been silently converted to a integer key. No errors, No exceptions, No Nothing. In my case, the key was a randomly generated hex string. And once in a while it generated a string with only numerals. And it didn't throw up with an error or exception... Tell me, how can you work with such a language that does this (even after 20 years into it's creation), and have any sort of peace of mind, without having to write test cases for every possibility that you can imagine? 
well.. he seems to have a point in this case.. Tried to submit a bug report, but it seems people have submitted this bug to tracker befor.. and their response is "Thank you for taking the time to write to us, but this is not a bug. Please double-check the documentation available at http://www.php.net/manual/ and the instructions on how to report a bug at http://bugs.php.net/how-to-report.php" This is sooo depressing!!!
*twitch* 
The most popular alternatives are Node.js (framework in Javascript), Ruby on Rails (framework in Ruby), and Django (framework in Python). Ruby and Python are fantastic, very clean, and well-designed languages. Most startups these days will be using one of these languages, not PHP. Popularity of Node is growing at astonishing rates right now. PHP is best for quick (and often dirty) scripts in my mind, but with some effort you can do anything in any language. So, learn PHP if you want. Just be aware that PHP started out as a quick hack, then it evolved by basically throwing a bunch of hacks on top of that...its creator Rasmus Lerdorf has said these things: &gt; I'm not a real programmer. I throw together things until it works then I move on. The real programmers will say "Yeah it works but you're leaking memory everywhere. Perhaps we should fix that." I'll just restart Apache every 10 requests. and &gt; There are people who actually like programming. I don't understand why they like programming. Of course the open source community has improved it quite a bit, but its core rests on this philosophy; a hackjob.
Not "something went wrong" It's that the string did not contain the needle you were searching for. This is not exceptional behavior, so an exception being thrown here would be very weird.
So, you'd say speed of development doesn't matter, it's only raw execution speed that matters? I don't even know what you're trying to argue. You said it shouldn't be used for anything serious, yet there are some major players using it. What does "&lt;-- for everything in python" even mean?
That's a small change. Maybe write a PR for it?
Rasmus doesn't take himself too seriously, and neither should you.
Aside for when VirtualBox won't work with your setup for a reason and Google is full of unresolved issues from 3+ years ago :(
Nope: http://3v4l.org/GiQPR
Well then... I kind of feel like I saw into the future at some point. Almost like reverse déjà vu. Thanks.
This is PHP compensating for the fact it was born as a web language. All web input is strings. Developers wanted the "right" thing to happen when they wrote something like: $lineTotal = $_POST['price'] * $_POST['quantity'] So now we have the mess that is PHP's loose type juggling, even when it makes no sense with what a lot of people are doing with it (e.g. writing business logic and dealing with typed data out of a database).
Did you try phing? You can create your own task in PHP :) https://www.phing.info/ ANT/phing are prowerful for repetitive tasks. You can set configuration files hierarchy and use the result in your targets and/or executing direct shell commands passthruing the output or not. In my projects, usually composer executes phing targets :)
New major version. New major features. New reserved keywords. The [context sensitive lexer](https://wiki.php.net/rfc/context_sensitive_lexer) goes some way towards mitigating this, but they had to drop class names for technical reasons. Some people are going to have to update their code for this and other changes. While there are backwards-compaitbility breaking changes, in my opinion the PHP developers have done an excellent job at advancing the language while keeping the BC-breaking changes minimal and generally easy to identify.
probably the same 3/4.
Hello, @JordanLeDoux , @bwoevy, @pee-ayche-pee, because the function f(x,y) = x^y isn't defined on the point (0,0). That's not "indeterminate" as has been said in this thread, is simply and clearly undefined*. If you compute the limit of x^0 (x-&gt;0) then you have 1, but if you compute the limit 0^y (y-&gt;0) then you have 0. Returning 1 doesn't ensure "continuity" has has been said, that's only true if you restringe the function to one variable (in this case fixing the exponent to 0). And no, it can have more than one value, it simply hasn't any value. This list tells better reasons to justify returning 1 than the keepping the "continuity" ( https://www.math.hmc.edu/funfacts/ffiles/10005.3-5.shtml ), the interesting point is that this page made by mathematicians use the "undefined" word. I have a degree on mathematics too, but I'm not a researcher, so I prefer to rely on explanations made by greater mathematicians. In any case, my preference is to maintain correctness over "convenience". The alledged cases are corner cases, and usually there are better solutions than rely on false mathematical properties to do what you want. I think it's preferable to throw an exception in order to allow earlier bugs discovering, hiding problems is like kicking a ball forward, sometime the bug will be rediscovered, but probably with worse consequences. * About the distinction between indeterminate and undefined: indeterminate is a good term for equation solutions. There are equations with infinite solutions, so we could use this term. Meanwhile, when we have something like 0^0 , almost all the answers we can obtain come from limits. Limits must be computed as a whole, not part by part (at least if you haven't demostrated properties that allow you to do so, in these cases we haven't these properties), and aren't equivalent to the mentioned exponent operation, we have completely different mathematical objects, se we cannot establish an equivalence.
&gt;If you know that that isn't the way code should look like in 2015 (and even in 2007 that code wasn't very good), you are already a better coder than those who made Facebook a multibillion dollar company. the takeaway from this is not "you should know better than to code like that", but rather that business model trumps tech stack any day of the week.
Use Java.
I've read this, perhaps more interesting than the previous link I've posted : http://math.stackexchange.com/questions/11150/zero-to-the-zero-power-is-00-1 , because in Set Theory and Discrete Mathematics is true that 1 is the unique possible value for 0^0. I think this should be voted :s , but I don't know who are the users of my library. Don't take my position as if the library won't change in the future, it's an opinion that will be hold in the codebase until people (preferably users of the library, or contributors) vote against it. If you want this can be discussed in the (yet empty) mail list, or in the gitter chat.
Yii is in fact a superb framework, I honestly believe you just need to spend a little bit more time with it. I haven't used it extensively (as in, have a full blown project running under it), but throughout my experiments, it truly feels like a very strong solution.
&gt; "Why are there dollar signs all over the place?" "How else would you make that sweet cash?"
Nice article :) You might want to play with Jenkins, because you can also easily configure thresholds over there and get some nice graphs to indicate if quality is getting better or worse. Next to the many more advantages. http://www.sitepoint.com/series/php-quality-assurance-with-jenkins/ But in overall, looks handy for small projects to quickly measure your quality :)
That doesn't solve the BC break.
I browsed the internals list a little bit over the past weeks, and I think this was the most disappointing thing about the entire vote (more than zeev's conduct).
Checker is indeed a PHP component. see [the repo](https://github.com/lwiesel/FeatureChecker). The service throws an exception which is catched by a listener, which redirect to a controller that renders a exception view. One could find it overkill, but it's made to be fully customizable.
Nice.
Magento is bastard child of evil.
Dude, I put that out there as a *possible* solution, and then dismissed the idea in the very next sentence.
I think having a shallow understanding of concepts comes from not learning your shit more than anything.
&gt; which is unsafe and cannot fail What? A bool may not fail, but literally every other type would fail if you pass an incompatible type, and the bool example is as equally worthless as the current plan for bools in STH, which also lets just about any value pass for a boolean. The type of explicit casting in my example is already a common pattern used by large frameworks and libraries to catch type errors, and more importantly *it lets PHP handle the testing and throwing of errors.* It's supposed to be unsafe. I don't think you understand the point of the explicit cast. In just a few characters it does the exact same thing that took you 3 lines of code to accomplish. The cast will test for compatible types, and trigger an error when the types of incompatible. &gt; The same could be said for strict typehints: The example you gave doesn't rely on PHP to catch the error. You have to test and throw the errors yourself, which we already do, and it sucks, and it's the reason we want STH. You shouldn't be recreating the error handling that's already built into the parser and runtime. Really though, you just missed the point. The current RFC which allows coercion is no easier or more elegant than methods we've been using to accomplish the same thing. Compared to the RFC I currently only have to type one extra character to coerce values and trigger type errors on my own. So, STH which coerces types doesn't really add any value to the language. Strong STH does, because in 4 characters (bool) you accomplished the same thing as typing 3 lines of code.
That is an amazing performance gain. Well done!
From the chatter it looks like they enabled GCC global register variables. It also only looks like this will be applied for gcc versions 4.8.0 and up.
Never trust a benchmark you didn't [fake](http://blog.ajf.me/2014-10-23-on-benchmarks) yourself
&gt; but they had to drop class names for technical reasons. They didn't have to drop it for "technical reason", it was a straight up need for the typing change function foo(string $bar) {} If a class named `string` exists, it's unclear what you're typing that parameter.
&gt; Explicit casting absolutely does fail and trigger an error when given an incompatible type. That's just not the case with booleans. This is incorrect. Explicit casting never fails, regardless of the type of the cast, or the type/value of the expression being casted. &gt; I know because I'm sitting here running examples. Please share. Maybe we can get down to the root of your misunderstanding.
I think what we should have is benchmarks linking to appropriate travis builds. Then anyone can setup a travis to build your benchmark on both environment s and see the clear distinction.
My point here is that the tests performed will have no reflection at all on real-world performance of your applications / website. [bench.php](https://github.com/php/php-src/blob/master/Zend/bench.php) isn't a particularly good benchmark - it's only 400 lines long and tests a handful of common, rather basic algorithms - many of which you'd never actually implement in real world PHP code because there are better alternatives. Even the Wordpress (or any other "frontpage") test is pretty poor - it'll be on a fresh install with no data of any real value in the database - the vast majority of code is simply skipped because there are no posts / comments / categories / etc to display in any form. Don't get me wrong, there's nothing bad about the PHP core developers striving to improve performance, but I'd personally rather see more work to improve the language from my point of view as a PHP coder - For example, despite the improvements Exceptions in the Engine have made, Out of Memory errors will still be uncatchable fatal errors that log only the file and line where they occurred with no other (opportunity to display/capture any) contextual information - often making them extremely difficult to track down as they end up being thrown by some horribly generic part of the framework such as the database driver that's used from a million places.
A big pattern this doesn't solve is the case where any existing library *writes* to a stream. For instance, `XMLWriter` can directly write to `php://output` on the fly. PSR-7 streams don't allow this, so the XML response must be entirely buffered. This is one of the major drawbacks of this model for streams.
He means that if you keep telling people, "use what is available and don't even *think* about rolling your own," you'll just end up with OpenSSL. I can see both points, but OP wasn't on a quest to build a better security context, he just wants *A* security context.
&gt; It's always sad to see the sorry state of the beautiful English language these days. Once upon a time, people used the right words, they knew "literally" didn't mean "figuratively", and that "they" isn't valid as a gender-neutral pronoun. Nope. Nothing in that sentence is correct.
Yeah I guessed that but in this context it was clear that nobody was saying "DONT YOU DARE EVEN TRYING TO LEARN" and just saying "It would be better to use an existing solution for this well solved problem." I would absolutely rather somebody implemented OpenSSL than tried rolling their own, even though today is OpenSSL bug day. Implementing SSL has been fine for years, then every now and then theres some bug and you update and its fine. Rolling your own security, cryptography, authentication, etc is normally just a path to destruction. When it comes to anything else, [try reinventing the wheel](http://blog.ircmaxell.com/2012/08/reinvent-wheel.html). :)
That's a bit extreme. You can't tell if you're making progress without measuring, and you can't measure without some sort of benchmark. It's important to understand what's being benchmarked and realize it doesn't predict the performance of any other application, but still a necessary tool.
Can't wait to see this in action. I love me some strict typing.
I'm sitting on a train now with my lil Kindle Fire, so I can't run any examples right now, and typing out code will be a pain, but try it yourself. Try casting an array or object to a string, e.g. `$foo = (string)$obj;`. It's going to trigger an error because you can't convert an object to a string (unless you defined __to String). I feel like that is such common knowledge that there must be a miscommunication between us. Maybe you don't consider such errors a "failure", but I do. My unit tests will stop as soon as the error is triggered.
I would assume we might see an update as we get closer to Symfony 3.0
This gist has been turned into a proper repository. https://github.com/phly/psr7examples
If you look at the CallbackStream implementation provided in the gist, you could wrap your XMLWriter calls inside the callback. I wrote up that example specifically to address how you might wrap output-generating code; it doesn't matter what code is doing the emitting, as long as it is wrapped in the callback.
That still buffers the entire XML string.
To be fair… that code is full of potential issues. and some errors… a) Don't just require "z" in the call to zpp (aka `zend_parse_parameters`) … when you pass in a wrong type, everything will blow up. Better add some type checks there (`Z_TYPE_P(...) == IS_*`) b) "z" only gives you a zval, eventually copied (copy on write), to pass something by ref prepend a "/" to the "z". c) Not sure why you also want to require the length? It can be fetched via Z_STRLEN_P(pubkey) (… or maybe I just misunderstood something!?) d) What's that efree(newpubkey) there? The type of pubkey is still IS_STRING... And you just free its string. That'll horribly fail when the value of that zval is accessed or destroyed later. You probably want to free and set type to IS_NULL. (for example) e) Just looked up the definition of secp256k1_ec_pubkey_decompress(): https://dev.visucore.com/bitcoin/doxygen/secp256k1_8h.html#aca74957d5f786c32fdaaddaf2becbe1e … It tells us that the passed string must be able to hold 65 bytes. (See https://github.com/bitcoin/secp256k1/blob/792bcdb015b0272928d4dd602557faa685dcd5a1/src/eckey_impl.h#L48 … random access of bytes 33-64 without realloc or similar) But your string only is 34 bytes (including NUL byte). So: copy your string into a new buffer of 66 bytes and use ZVAL_STRINGL() on the new buffer. (and don't forget to free the string then) Also… USE_ZEND_ALLOC=0 environment variable with valgrind --tool=memcheck --leak-check=full wouldn't be a bad idea in your code, generally ;-) P.s.: Just noticed: secp256k1_ec_privkey_import() is passing a zval * to zpp and not a zval ** (should be &amp;seckey)
Use IIS. Granted, it's sub-optimal as the environment for PHP, but you can install it via a wizard and it is the best solution for your platform. Your concern centres around URL rewriting for Wordpress, and there is guidance for configuring that in IIS, for use with Wordpress. If you really do have performance to spare and don't want to confront that technicality, you could install a lightweight Linux server in a VM.. it's own set of complications..
Perhaps [Reactphp?](http://reactphp.org/)
If the connections/writes to oracle are the bottleneck, consider pushing the stuff to be logged into Redis with [predis](https://github.com/nrk/predis). Set up a worker to chug through the logged queries, moving them from redis into oracle at it's own pace.
Exactly. Use a queueing system, that's how you solve it. Redis is very well suited for it, e.g. php-resque is built on it. Not the best php software code quality wise but gets the job done once you get the hang of it. You can use rubys resqueweb to introspect the queues, also very convenient.
Log to memcache server then have a background task to periodically flush. Flush every second.. or flush every 60 seconds. Etc. 
yes it will make the app more responsive. by forking the process you don't wait for the blocking I/O. having the same processing running in a worker has not much benefit. The only downside to forking it's hared to manage for complex tasks. But if they need it for an oracle call its way more optimal than setting up a redis server just for that
Right, I see the print statement. But that behavior doesn't appear to be documented anywhere? *edit*: yea, this seems rather bad. In your implementation you just call echo as a side-effect of calling `getContents()` on the stream. This means that if I want to get the actual contents of the stream (for postprocessing or otherwise), I now need to keep in mind that I may need to do output buffering around `getContents()`? Seems a bit crazy, and while yea it's technically 'possible' to do this in PSR-7, but then it's also technically possible to put echo statements in any other function. It doesn't mean you should =) If calling a method has the potential side-effect of also producing output, it should be part of the method documentation. A more reasonable approach would have been to add a separate `output()` method to the stream, exactly for that purpose, and have `getContents()` wrap that with output buffering.
Definitely an essential place to start. An easy way to get eased into writing integration tests would be via [Codeception](http://codeception.com/). You can also switch from Selenium controlling an actual browser to instead use [PhantomJS](http://phantomjs.org/) which will make your tests run slightly less slow.
It *was* the purpose of the example, but no, I didn't document it in the code. I'll make that more clear, if you'd like. Knowing that: would this example work for you? It definitely means changes to how you might code, but I could also see it being useful for legacy code that you want to refactor to use request/response objects, or to fix code where headers are not being emitted until after the output buffer has flushed, etc. It also means you can delay execution of output-generating code until your application is fully ready to return the response. I perceive all of these as gains.
When I tackle stuff like this I usually try to pick out some of the worst offenders and focus on that depending on just how bad it is. Duplicated code, frequently called static methods, etc. I usually harness it into a testing suite from there and get to work hacking away at it little at a time. 
Overall it looks like a neat project. It's cool to see someone building a specification library for PHP. I looked over the code, and it's very legible, as well. The only real issue I noticed with the library is the use of multiple instances of the same specification, as noted on [github's issue tracker](https://github.com/K-Phoen/rulerz/issues/3), but there seem to be workarounds readily available. I look forward to playing with this library more.
Selenium can run Phantom as well. Also, these are not integration tests--they're (acceptance|functional|end-to-end) &lt;pick your favorite term&gt; tests. Integration tests are tests between units, not browser-level tests.
Doubt you're going to get decent answers with the attitude you have shown the first poster here. The built in web server is certainly not built for performance - I'm pretty sure it's parallel connection count is set very low too - making it useless if you want performance or serve multiple clients at once. Also to deamonize it will be a pain - you could try nssm I guess (since you are using Windows). IIS is going to be the best choice for a Windows server - it's the only web server that's actually tuned for Windows and designed ground up for it. Apache could be a second option, Nginx never makes ANY claims of windows performance - at all (it's even stated in the documents). Both these web servers were built with a *nix first mentality - Windows is really an afterthought. 
&gt; None of these are good ideas in modern applications, UNLESS you have reasonable performance concerns and/or resource consumption issues. That's just ridiculous. Efficiently generating data and sending it to a socket without buffering doesn't make the application less modern. You can't just come up with something brand new, and invalidate the use-cases that don't mesh well with your conceptual perfect 'modern' architecture. My point is: if at any point it becomes a requirement for Zend framework to be able to handle large responses efficiently, which is not that crazy to think, then you immediately also have to carry the same burden. I doubt you'd solve it by dropping a echo/print statements in `getContents()` though, because that will surely mess other things up.
Which is fine for any up to date distro.
And you can use [anorgan/qutee](https://github.com/anorgan/QuTee) via composer and decide between redis, beanstalk or mysql
Nice! Just mentioned my [QuTee](https://github.com/anorgan/QuTee) in another post :)
I recommend the book "Modernizing Legacy Applications in PHP" by Paul M. Jones. https://leanpub.com/mlaphp It provides a path to take for modernizing legacy applications and I think you could at the very least get some great ideas on how to approach the problem. Additionally, using Codeception, Behat or Selenium and building up a suite of integration tests (acceptance testing) is a great way to test the functionality before and then be able to re-run after each individual refactor to ensure you don't break any site features while making the refactorings.
you can't refactor if you do not have tests. Period.If anybody says otherwise he is lying. So write tests first. 
Or [icicle](http://icicle.io)
- add system/integration tests on what you want to refactor - refactor a small part, always keep control (avoid the kind where you start somewhere and end up refactoring everything) - while refactoring that small part, cover it with unit tests - repeat Start with the easy picks at first as they allow to clear up the more messy parts. Also if you want to move away from static calls to dependency injection, check out this PHP-DI / Zend Framework 1 integration: http://php-di.org/doc/frameworks/zf1.html Don't be afraid to use the "service locator" pattern at first and then switch to full dependency injection later. When everything is static you often *have to* make your container static and get from it statically (e.g. `StaticContainer::get('Foo\Bar')`). Don't shoot for perfection from day 1.
As others have mentioned you need tests. If you can't write tests at all because the way the code is put together then the first step is to untangle things. This can be hard. If your code is working I'd probably just leave it alone until you need to touch the code for some other reason (adding a new feature, usually). I recommend this excellent book for learning about specific ways to refactor, as well as when they are commonly used: http://www.amazon.com/Refactoring-Improving-Design-Existing-Code/dp/0201485672
Nice work. A small unasked-for code review: - Classes and methods should have docblocks explaining their purpose and usage - `QueueService` can end up in an unusable state. `Adapter` and `Logger` are required dependencies, but the class can be instantiated without them. - `AdapterInterface` shouldn't define the signature of the constructor - There should be an interface for jobs - State (in `Job`) should not be a boolean. I'm sure there are at least 4 basic job states (waiting, running, finished, failed) - Moreover as soon as you use the word "status/state", consider using a state machine - I think `Job` should be split into a `Job` (payload/definition, state) and a `Job Dispatcher`, a class that performs work according to the information in `Job`. Right now `Job` has one responsibility too many - There should be a way to unblock/retry stalled jobs Good luck.
thank you, and sorry for posting in the wrong place!
If your name is Matthew Burgess, this is going to freak me right out. Also, I agree. Especially about "they". It's as close to a gender neutral pronoun as we have 
Believe me, I am no prescriptivist! That was supposed to be ironic, which I hoped would be obvious given [I made all the "mistakes" I decry](https://en.wikipedia.org/wiki/Muphry%27s_law). But then, [Poe's Law](https://en.wikipedia.org/wiki/Poe%27s_law) applies, I suppose. The usage of "literally" in common speech isn't a misuse of the word. It's not even a new definition. Rather, it's an extension of what's been done to basically any adverb meaning "really" (see: objectively, actually, totally, definitely, truly, really, etc.). It's exaggeration. "They" is a perfectly valid gender-neutral pronoun, indeed. In fact, I use it (very much deliberately) all the time - as a person who cares about gender issues, I try my best to be respectful and not assume people's gender too much.
If users are accessing your site over regular HTTP instead of HTTPS, someone sitting in between the user and your server could manipulate the cookie data (and any data, really) that's sent over the wire, in either direction. They could also eavesdrop and do all sorts of other nastiness. The only real solution is HTTPS, with a properly-issued certificate (not self-signed). Also, any user is free to manipulate the cookies on their own system, and malware can also manipulate those cookies, create/delete cookies, change their httponly flag, whatever. In fact, you should assume that it's possible for users to send you *anything* in *any* kind of input (query strings, form submissions, cookies, HTTP headers, etc.), and they can always selectively ignore JavaScript or do their own scripting. That's why it's important to validate all user input and to understand how to properly escape data wherever you put it.
I think we caused the author to edit the page. From the bottom of the page: &gt; Edit 2015-03-20: Just in case someone missed the sarcasm: No, I am not a prescriptivist, I very much like "they", and using "literally" is not wrong. 
Agree with everything you say apart from the "self signed" section. A self signed cert is just as secure encryption wise to one purchased from a provider. I makes do difference in this context. 
One is a micro/syntetic benchmark the other is a macro/"real life". Both are useful and anybody thinking that they should correlate 1:1 has no experience with perf tuning.
Does it work and performing to a good-enough standard? Other than for your own sanity, why do you think it needs to be refactored? What currently relies on this and is it business/monetary critical? Depending on the above it may not be cost effective to even attempt the refactor, least not at mass. Nothing stopping you improving code quality going forward, but baby steps will be key. Plus until you know the project inside out, I would never recommend a refactor as you'll almost bound to miss something you wasn't aware of until it's too late. 
Can we please, collectively, just stop with these non content posts? Every month someone on the internet feels like they need to write up something on the "best framework for 20**", it's like developers now expect a framework to be the solution for all their problems, or they need the reassurance that they are using "the best" tool. A framework is just code, does it fit the requirements for your project? Will the tools help you? Do you even need a framework? 
Use PHP Core Functions and Classes, Create a Configuration File, Always Sanitize Data That Will Go into Your Database, Leave Error Reporting Turned On in Development Stage, Don’t Over-Comment Your Code, Code Snippets Handy, Use a MySQL Administration Tool (Like phpMyAdmin), Use a PHP Framework.
Developing development developers!
This looks neat. My main question is, how are non-string payloads serialized, if at all? Do I have to do this myself?
I'm very slowly cobbling together an API myself, and ignoring the myriad ways to over-think the messaging semantics of it, I've decided to go with Digest Auth + SSL. How bad an idea is that? The intent is to have a front-end module consume the services of a back-end API module..
Hm. Seems like you compare directories and I compare whatever is adapted to the system (GIT so far). And you only check for SemVer 2.0 ;) But you have more assertions than me :D That is something I am up to this weekend. Cheers! 
Either really poor English or they're keyword stuffing their content for SEO purposes.
Plus unit tests.
thanks a lot for the help / feedback! /u/changetip $10 a) will do b) hmm, I actually managed to get it to work without the "/" now... can't really figure out waht the "/" really does ... c) we were following the function signatures of the libsecp256k1, but you're right, there's no need for it (and it's anoying / unnesecary for users too) d) an atempt to fix stuff, removed it e) yea, I guess that was causing the segfaults, fixed it with a `strncpy` now, thanks! 
/r/PHPHelp is a decent place for this
For those of you who don't have your PSRs memorized, PSR-7 is the HTTP one.
&gt;There are 39 current voting members, which means there must be 13 votes to pass quorum Why is the quorum only 13? How could the FIG defend anything if only 7 out of 39 parties involved agree...
The quorum is for the vote to be even considered, the PSR still needs 20 positive votes to pass. These are 2 distinctive parameters.
Digest is fairly terrible for frontend services. It broadcasts the actual password in hashed MD5, which is done with a nonce but hardly uncrackable. Digest is also a bit of an arse, as you either have to rely on browser based sessions to keep you "logged in" or keep the password around locally to send the Authentication headers over and over for each request. All of that leads to the password being a tad too available. Using authentication tokens though.... thats fine. Those tokens change every hour or so and if somebody gets hold of one the chance of that token being the same for multiple sites is non-existent compared to the chances their password is reused.
Which PSRs and which drama? Do you mean the RFC drama? Oh PHP. We recorded on the 12th of March and we did discuss PSR-7 and Josh's plan to use it for Slim 3. PSR-7 only went to vote today. 
PHP does roughly the same. If it needs 50%+1 and only 10 people vote then 5 people decided to add something to a language that 150 people have voting rights on. The fact is that controversial stuff in the FIG get a lot more votes than things that are less important, so its rare that something that needs "defending" will only have 7 supporters.
No, it needs half of the votes being cast.
Yes, I'm talking hypothetically of course, I don't think this vote will stop at 7 :) I didn't know PHP itself also had 150 voters, I don't think I've ever seen an RFC with more than 50 votes. not that I follow that many RFCs :)
First? What are you resources. You can tell an inexperienced developer if they do not first ask: what is the budget. See all the suggestions for unit tests... nice! What if your budget is 1 man hour. You going to install the test unit code and then oops, ran out of budget but hey at least you tried? Lots of dev's when confronted with legacy code go "rewrite!". That is nice, if you got the resources for it. Often you don't. Find out how much time you can spend on it and most important, how much time you can spend on it BEFORE you are expected to implement new features. If you start a rewrite that takes 3 months and they expect new features next month, you got a problem. Once you know your constraints, you can come up with a viable plan of attack. 
PHP actually has nearly 1800 voting members ;) But 95% of the accounts are inactive.
Inactive as in barred/suspended or no longer interested ? I would give an arm and a leg for a voting right ;)
Oops, sorry yes I meant RFCs. Was hoping for a funny rant :D
Thanks :-) b) Imagine `function foo(&amp;$by_ref) { $by_ref[] = [2]; } $a = [1]; $b = $a; foo($a);`. Before the call to `foo($a);`, $a and $b reference the same zval with refcount 2. Now, in a by-ref fcall, $a is separated from $b (value is copied, from $b, $a now references an other zval) and $a is made a reference. Now, in case where you don't prepend "/" modifier, $a won't be a reference and point to the same zval than $b does, so every modification to $a will now also change $b, even if $b isn't a direct reference to $a. c) Not only this, but when you put in wrong lengths, you may get segfaults... Also… did you ignore my P.s. part? ;-) // But secp256k1_ec_privkey_import already looks much better … only string typecheck missing. P.s.: you forgot to free the old string upon success...
So how is Guzzle going to implement this? I presume that if we just look at Requests and Responses, Guzzle would change its Request and Response classes and interfaces a bit, have its own mutable Request and Response interface extend PSR-7's immutable Request and Response interfaces, and then if people using Guzzle want to adhere to interoperability, they should use PSR-7's interfaces rather than Guzzle's.
[Slim v3](http://www.slimframework.com/2015/02/11/whats-up-with-version-3.html) will be PSR-7 compatible.
Account creation is not automated, it's done by a person. When that person creates your account, he or she may select one or more areas of "karma" to grant to you, including voting on RFCs.
Good little bit code
Haha. Even better!
Well, how do magnets work?
What did you switch from, and what are your thoughts so far? I've been using Laravel, but am considering using Symfony 2 / Silex for new projects as they come up and would like to hear thoughts on this. I've been reading the symfony book. It seems both frameworks are pretty similar, with Symfony offering more options for doing things in different ways and being more flexible yet a little more verbose.
You can get voting rights without losing any limbs, just get commit access. You can get this by contributing to php or php.net.
That's the problem. I can't commitm because I don't know C and php.net does not seem to have improvable issues.
Well it sounds like the voting system still works as it should then :).
""" The second argument has / after it, whcih means that the argument is separated from the original value. This is useful if you want to modify the value inside the function without affecting the calling scope. Calls SEPARATE_ZVAL_IF_NOT_REF """ so z/ actually dereferences the zval in C from the actual zval in PHP, which is not what we need :( pseudo code; https://gist.github.com/rubensayshi/be74404020e666247e07
+1, it's a really [great book](http://www.sitepoint.com/modernizing-legacy-applications-php-review/), made exactly for this purpose. ZF1 is an awful enough framework to resemble the chaos and inflexibility of procedural apps, so if you just skip the MVC section of the book, you'll feel like it really hits the spot.
bugs.php.net - for a start, let me specify whether to fulltext search in the title only. If it already can do it, they did a great job of hiding it away from the UI.
Unit tests are probably not possible if he's got static methods and spaghetti code. Selenium tests will let him refactor to the point where he can create unit tests.
There are two hard things in computer science: - Cache invalidation - Naming things - Off-by-one errors 
turns out adding ZEND_ARG_INFO(1) fixed it, and here I thought that was just metadata for reflection 
We were previously using codeigniter, and I'd had some experience with Laravel. I personally prefer Laravel but its really subjective. My only serious complaint thus far with Symfony is it won't autoresolve type hints unless you've defined what you're hinting as a service already. But that's pretty minor.
Unfortunately not. The named params RFC fell by the wayside, and while an RFC for [skipping params](https://wiki.php.net/rfc/skipparams) has found its way in, I think most of us are happy it didn't pass, because it's only a poor bandaid for the solution. However, as of 5.6 we also have [variadic functions](http://php.net/manual/en/migration56.new-features.php) via the splat operator - rather than using func_get_args(), maybe that could be of some use to you? *Edit: Changed context to reflect skipparams has already been voted on.*
I’ve actually implemented PSR7 as part of the Http core in a framework I built. You can see how I implemented it here: https://github.com/spiral-php/spiral/tree/master/framework/Components/Http
I had the same question a while back and /u/nikic was kind enough to [answer](https://www.reddit.com/r/PHP/comments/2vgl77/the_scalar_type_hints_rfc_is_currently_passing/cohy56w)
Yes, but I believe most of the interfaces are based on Guzzle.
Oh, didn't know about it. Thank you.
&gt; however I'm still trying to find a model where basic research and infrastructure work can provide revenue which is related to the amount of value it's bringing to companies. I remember when HippyVM was announced I was really wary to the fact that it wasn't open source, and that some parts of the software would not be free (as in "free beer", you have to pay for it). It felt really out of place in our world. Now I feel a bit sad for you and the project. We take so many open source things for granted yet people still have to eat. We are kind of a schizophrenic specie us developers: we crave for a model that doesn't provide us money easily :/ Thanks for sharing your experience.
Do you have a link? Sorry if it's a "noob" question I couldn't find any mention of it on the website and I've never watched any of these in real time before :) *Edit*: nevermind you tweeted [the link](https://plus.google.com/events/cqqb28tcp3o1kgue50tk4ljn0h4) ;)
Currently, do like this : // ... function query($sql, array $options) { $options += [ 'userMaster' =&gt; false, 'async' =&gt; false, 'autoHydrate' =&gt; false, 'entity' =&gt; null, 'merge' =&gt; null ]; // .... } query($sql, ['async' =&gt; true]);
A friendly reminder since the voting thread is being linked: **do not vote or participate in that thread please**. This is a voting thread (so only meant for +1/-1) and only [FIG voting member projects](http://www.php-fig.org/) can cast a vote.
I hate when people don't take naming things seriously. 
Nice. This is the first time I see a meaningful use for the += associative array. For some reason I always expect the right side to overwrite the left.
so I need to free everything that is not a zval? 
It's an `E_FATAL` because you didn't declare an exception block which could catch it. This is a new concept, but it's how [Engine Exceptions](https://wiki.php.net/rfc/engine_exceptions_for_php7) was implemented. declare(strict_types=1); function foo(int $a) {} foo(10.5); // FATAL ERROR try { foo(10.5); } catch (TypeException $e) { // caught type exception } where `TypeException extends EngineException` where `EngineException extends BaseException` and `Exception extends BaseException` (basically, a new root exception type that was added above exception to not break BC).
Exception won't be the base PHP exception anymore in PHP 7: https://wiki.php.net/rfc/engine_exceptions_for_php7 The class hierarchy might change before the final release.
Thanks! Could you point other DBALs that use the same approach? I'd love to have a look at them.
thats weird.
You might be thinking of `strcmp()`, or `version_compare()`, which both return 0 if both args are equal, -1 if the left is less than the right, and +1 if the left is greater than the right. Coincidentally, PHP7 has added the `T_SPACESHIP` operator, `&amp;lt;=&gt;` which is a generic way to do these types of comparisons :)
You sound very new to the dev world. You will very likely spend the next several weeks neck deep in tutorials if you are serious about it. Personally, I prefer to develop locally and push to a server when done. That being said, I'm not bad in a linux environment so this is pretty painless for me now. If you are serious, you will have to dive into linux sooner or later, so you might as well follow what I'm about to advise. If you primarily use windows, google "wamp hello world" If you primarily use mac, google "mamp hello world" If you primarily use linux google "lamp hello world" Respectively these mean, "* apache mysql php." Figure out how to get a server running locally with apache, so that you can do "localhost" in a browser and get that welcome screen. Then get it to say something. Then plop in a vanilla wp instance. It's a series of steps, and best to start with "hello world". Good luck
Honestly, this sounds like a question from someone who has never properly used a framework. If you can bang out all the components and features of even a micro-framework in less time than it takes you to understand the framework, you are either the world's best programmer by far or an extremely slow learner. More likely, though, you're not using the features of the framework, which means that no, you are not writing good code. You also say "I know what I need to do", which sounds like you've never really worked as a part of a team. One of the most important advantages of a framework is maintainability. It allows others who work on your code to more quickly understand it. You can write an extremely efficient and stable app, but if no one else understands it without access to you, then the project grinds to a halt the second you quit, and it's not good code.
The point of frameworks is to provide convenient and fast solutions to common problems. Taking something like Laravel as an example, problems like handling authentication and login, database access, caching and routing. These are non-trivial problems, trivialised by using a framework. &gt; I can bang out a scalable, OOP, data layer abstracted server in a tenth of the time it would take me to stumble through, say Yii. 1. I suspect you're wrong. But even if you're not 2. Maybe. The first time. The second time you'll only take twice as long. The third time, half as long. And so on. If you're using it routinely this time is an **investment** and the notion that you shouldn't learn new shit because the same shit you've been doing is good enough is... the opposite of what you should have as a professional. You say your code would be "probably better", but it's pretty obvious when you say this that you don't work as part of a team. Because when you work as part of a team having a consistent pattern for how things work, having things documented, having common problems searchable on stack-overflow... these matter vastly more than your personal interpretation of "best practise". Being able to search the "poorly written" docs for how to handle cache invalidation, or why this is being received as an object instead of a collection is... unspeakably important. This reads as a screed against learning, rather than a reasonable criticism of modern frameworks. You refer to "overhead... in learning", to "stumbling through, say Yii", to "stumbling through poorly written doc pages", etc. Normally I'd make an impassioned plea for the importance of frameworks, but your attitude makes me instead say... Yep, you're totally right. Don't learn any frameworks or develop your skills in any way. Enjoy the future of your career.
Frameworks are the wet dreams of sociological thinking - and so promising reusable, relational code and sometimes valuable components - developers and that sucks for the people of freedom. They work themselves into the problems and come with solutions that blind many people. For example solving OOP diamond problem with DI Containers. For my opinion this works, but sucks at the long run. Frameworks might lead to better teamwork. It is great for the Jimmy's whom like to jerk each other. 
fame and maybe money
Sounds like a good idea. I were confused.
+1 I always end up playing with the URLs. Even just a link, not a breadcrumb, would be an improvement.
I tend to find when I go for what's seemingly the simple approach, the technical debt just racks up. Just slightly weary of OAuth I guess, but deep down I know it's the right tool for the job.
When programming you face the same problems again and again. - authentication - authorization - data access - validation - caching - routing - I18N Ultimately when you're not using a Framework you still need to solve all these problems. What you'd end up with are components / modules / (name it whatever you want) that you write in such a fashion that you're hopefully able to use them in following projects as well. Because those problems will be ever emerging. If you don't build them re-usable, then you're just wasting time. It doesn't matter how awesome a programmer you are, doing the same stuff again and again is a waste of time. And that's where Frameworks come into play. They do solve the problems. They have unified modules/components/yaddaYADDA that are re-usable. So you don't even have to write the first implementation yourself. The thing that you refer to as overhead likely comes from full fledged MVC Frameworks. The thing here is: in big applications this overhead is almost non-existent. Execution time isn't caused by the frameworks overhead but rather by the complexity of operations run in the background. Therefore - in most(!) cases - you can simply neglect the overhead of additional classes. For small applications you can just use simple components without the full MVC power. This is basically what brought SlimFramework to life. The same thing that's now emphasizing the development of ZF2.5+ / ZF3. Re-Focusing on Components rather than the full MVC Stack. 
I'm probably being dumb here but what's wrong with func_get_args
if you have a function like function foo($bar="first", $baz="second") and you only want to specify the value for baz you would need to do this: foo("first", "whatever") which would duplicate the default vale for $bar but with named argument support you could have some syntax like: foo($baz="whatever") and avoid duplicating the default value for $bar. func_get_args wouldn't really help much because IIRC it would just give you a numerically indexed array of args. You could have some complicated rules like "if only one argument is passed then $args[0] will be the $baz value otherwise it will be the $bar value" but that would be a horrible API to use. Especially for functions with more than two arguments (triadic etc.)
You might be able to bang out a scalable, OOP, data layer abstracted server, but can someone else pick up your code and instantly know what and where shit is and how it works?
The article assumes that the user agrees that framework X is the best framework for everyone - oops! Ahem... the OP appears to have deleted their user account...
OAuth is insanely simple when you implement an existing tool, and very flexible. If you find you need another flow than just user/password you have that right out of the box. :)
The lack of error handling would make it unusable for me. And the current structure looks both inefficient and locks you to a specific output of pdfinfo.
New user, just enough there to get people riled up, but no real substance. Doesn't reference any of the thousands of online articles answering this.... Intentional or not.... troll.
The parsing implementation is inefficient: the output is traversed once for every attribute, 14 times in total, however it would be enough to traverse it once. The output is stored in memory, however it's not used anywhere after the object is constructed. The loadOutput() method is public, however it doesn't do anything useful, it just runs the same routine that has been already run in constructor.
eli 5 psr7
I might have to use pdfinfo for a project in the upcoming weeks, great to know I won't have to make it from scratch !
Oh wow this is really interesting. I started looking at C (those are C snippets right?) before but then got scared by pointers and strings so I left it alone. But every once in a while I get curious and click on a pull request for the php source and dont really understand whats going on there. This got me one step closer to understanding whats actually going on under the hood =)
`php -l` checks for syntax errors. An undeclared variable isn't a syntax error, it's just a hazard at runtime. If you run `php test.php`, what happens?
You sound fairly arrogant. If you can build a better framework in less time it takes you to learn to use one fully, you're probably a very special breed of human. Your question suggests you're either trolling, or a junior who's questioning every experienced guy's opinion because he's "written C, Java, PHP"... Were those assignments? Have you ever worked on a real project with a team? Probably not. Also, if you're legit, when you talk about writing a better framework, I suppose you mean it with full test coverage in mind? Do you know how long writing good tests takes? Have you seen how many bugs/security holes are found in the early life of frameworks (written by the very best devs/teams) by the thousands of users who start using them? How do you find those in your code if you're the only one using it? Young devs are confident in their code because it's less generic and tailored to what they need, but if you had to bet big on a security audit by competent people, I think that confidence would vanish pretty fast...
Great read. Would love more of these. 
So you better stay tuned for the next part about objects management in the Zend Engine ;) Thank you for your nice comments everyone, it confirms that if I write something interesting for at least one person, my goal is reached !
yeah but no one really uses it. They would need to integrate it directly into github for it to get any uptake.
What exactly does this do? 
If you want to read more about phps internal implementation you might want to look into the following (in no particular order): * [Ircmaxell's: PHP's Source Code For PHP Developers](http://blog.ircmaxell.com/2012/03/phps-source-code-for-php-developers.html) and most of the other blog entries are worth reading, too. * [The php internals book](http://www.phpinternalsbook.com/) * [Nikic's blog](http://nikic.github.io/) 
Hi there! I'm trying to use this right now! Documentation could be a little better for php configuration though. Otherwise nice product!
Despite linking other entries below; Keep on going, it's always an interesting topic to read about ;)
Basically the library can keep files between two filesystems in sync.
Haha that's right it's a Mailchimp popup to subscribe to the newsletter, it was not meant to be annoying, only because it's a new "feature", this will stay for one week ( and anyway it will only show up once per visitor ) ! Sorry if it bothered you :)
I have so many sites that have recommendations but I feel confused and at a lost of where to start. Do you have any recommended websites/tutorials to start at whether it is free or paid? Also I greatly appreciate your help! Do you have a contact e-mail I can contact you on or should I message you via reddit?
As initially said, use valgrind to check what leaks. And otherwise… check what's refcounted, what might be contained otherwhere etc. That's for a big part also just experience with the codebase.
Definitely need more like this, I love this post. Thanks.
You've obviously never heard of PHP 6. 
Thanks for the feedback. I make the loadOutput private now. Do you have any suggestions for improving the parsing implementations? I should use more complicated regular expressions or ...?
/u/htfo and /u/mnapoli: done :)
Awesome: that's so much better. Thanks!
Ah - I misread it. But you still don't need this, as you can (and should) be doing this with the uncaught exception handler: function exception_handler($exception) { echo "Uncaught exception: " , $exception-&gt;getMessage(), "\n"; var_dump($e-&gt;getTrace()); } set_exception_handler('exception_handler'); Which avoids having to have a special rule for a new error that cannot be continued from. 
Obsessive Compulsive Disorder. If I can see the output and everything is not tabbed and lined up properly, it will be.
Nice! I really like that it's a pluggable library with a clean API. Very well-designed.
One of the best explanations on how variables work
So basically you're a hosting provider for a very specific vertical stack and you provide full support at all stack levels? Does this business model scale, or is it only targeted at the individual? What if a customer wants Postgres instead, or an additional service installed, or Laravel? Does the full support drop there?
And how would it help?
Just note that a lot of the details have changed in PHP7. This is a great overview of 5.x. The concept is the same, but things got a lot more complicated in 7 (justifiably so). 
Sure, this article was designed for the current stable PHP implementation. About changes, phpng is a fork of the current Zend Engine with some type additions and VM improvements ( at least for zval and zval management ). Things are not really much more complicated, but more complete or optimized - about zval, it's not a huge structure change, it's more of an usage change by avoiding too much dynamic allocation ( VM space vs heap space ) and optimizing data access; The biggest change on zval is about references and I agree that the new zend_reference type probably needs to be introduced ( it's basically the same concept than the current reference system, reimplemented ). If you have a look at the (restricted) documentation https://wiki.php.net/phpng-int , you'll be able to see that the world of zval as we know it is not about to change a lot :)
&gt; Sure, this article was designed for the current stable PHP implementation. Absolutely. And it does a great job at that. I was just pointing out that it was demonstrating the stable version. And that the details (but not the concept) are changing in 7.
Does this work from a master server to multiple slaves?
When you have E_NOTICE enabled, it should point out undeclared variables. But it's not really an error, it's just null.
Looks similar to [Aura.Dispatcher](https://github.com/auraphp/Aura.Dispatcher)!
It fixes the issue you have with no newline being generated after the tag? I mean, you could put a space after the closing tag, but why not use code?
Vagrant + Samba instead of shared folders. This is a most performant setup that i had on Windows host. PHP Is very slow on windows when working with file system (only in dev environment when Symfony always revalidate cache). Run with XHProf and see.
I have a Linux VPS with Fedora on it. I feel that LAMP is a native environment and WAMP is kind of a hack. There seems to be many ways that people use to get WAMP working but LAMP just works, and, I keep my Windows box free of extraneous bullshit. Even a VM eats up local resources so why bother? A VPS is like $10 a month. The server is remote and I use Netbeans to upload my files on save so I can test. The VPS can easily handle a virtual domain for every dev and you can have a main site you sync the commits to for overall testing. When a new dev comes in or a dev gets a new machine he doesn't have to setup a whole server from scratch and make the site work. It already works. He can just install Netbeans (or whatever IDE that'll sync by sftp) and go. 
Linux Mint 15 with Mate (soon to be 17.1) in a VirtualBox VM. Rather than use Vagrant, I configured SMB, PHP, Apache, MySQL, SSL, git, etc. myself (and documented the crap out of it) so that I wouldn't be dependent on someone's development setup. I would have preferred Centos or Fedora, but I find that Mint with Mate works better with VirtualBox than anything else I've tried. Have also got an ESXi server running Debian (among others) for my production backups. 
Ubuntu laptop for development (I actually prefer debian, but I prefer to stick closely to what our production environment uses). Ubuntu server for staging &amp; production environments, with the exception of a few centos servers that we have not replaced yet(soon, yesss soooonnnn).
I loved the article, and went ahead and read every other entry in the blog. Really interesting stuff which remind me I have to refresh my knowledge of the Gang of Four's Design Patterns to refactor an ongoing project. It's appaling how one tends to forget such stuff and falls into anti-patterns over and over again.
Yeah. I've had nothing but problems using vagrant with windows. It always takes forever to boot, there can be weird issues with the filesystem paths, and it's hard to get a windows shell to work as well as it does on Mac OS or linux. I've found it much better for my sanity to just dual boot into Ubuntu and then either develop locally or use vagrant there. 
Yes, not directly at the moment, but soon. My other tool [Seabreeze](https://github.com/FlameCore/Seabreeze) supports it already.
It has no real advantage over rsync tbh. But it's pure PHP and it supports all Flysystem adapters.
I use IIS for local development on Windows- it's reliable, quick, and the PHP manager is a really nice feature. If there's a specific *nix server configuration spin up a virtual box, but this tends to be slower. 
Why do your company not provide the right tools? Is that company wide? E.g. no phones, only cans + string? No desks, only blocks of polystyrene?
Is there an 'easy' way to make this compatible with other cyrpto currencies? *cough* dogecoin *cough*
&gt; If someone could come along and give me the hardware quality of a Macbook Pro, Windows-style window management, and native Debian w/apt-get for the shell, I would be soooooooooo happy. You can install Ubuntu on a Mac pretty easily.
We're a large ecommerce company with hundreds of employees spread across the world. It's not out of the ordinary for a company of this size to standardize on a single platform for all employees.
This is the first in what may become a series on /r/PHP. After the STH RFC drama, I figure it might be beneficial to start some discussion about RFCs which are "under discussion", instead of waiting for them to be in voting phase (when the greater PHP community tends to descend on controversial RFCs). Please let me know if you have any concerns with the format, or if there's something you think would add value to this process.
I actually figured this out about 10 minutes after posting in the thread. Thanks so much, jawsdb is super cool!
Try to set realpath_cache_size = 256k in your *php.ini*. Symfony is quite heavy on filesystem, especially when in development environment.
I much prefer the Windows UX so I'm using a local (physical) server that has Ubuntu installed on it. Samba for the network locations and Putty to stay connected to the server terminal. Basically, I get all the goodies of the Windows interface but also all the stability of the Linux system.
I've recently switched to an hosted XenServer (2xXeon + 32Gb) box with three VMs. One running Win8.1 with PHPStorm, another is a Debian Wheezy with a dotdeb environment running in Docker and the last is an OpenVPN gateway. I can easily switch clients and access my env from everywhere (work, home, on the go with a 4G phone). My primary client is a Macbook Pro connected to the box through VPN with tools like Sequel. The main advantage of this solution is that a full Magento env with xdebug is a running as fast as possible.
Debian Sid running Apache locally with a custom compiled mod_php. I already use Linux as a primary OS so I see no need for a different environment.
I use EasyPHP on Windows 7. EasyPHP has addon for virtual domains and it is very easy to change your PHP version. Also, why should I use virtual machine on Windows? PHP is platform independent. I like IDEs but they are very heavy, thus I use Notepad++. The MySQL is located in a Linux PC on the network. Also we use Git, Bitbucket, dploy.io, and HipChat. I prefer to use Navicat. We have different production servers; Linux, Windows, Apache 2.0, Apache 2.4, PHP 5.6, PHP 5.3. So the code needs to run in all of these envirements. It was much messy, I've fixed some of the issues (there were no version control for example) but it is hard when you have an employer who is not aware how to run properly a software company.
Thanks!
It's not that easy bro.
CakePHP never looked, felt or performed better. Thank you so much for the hard work devs!
Why the F can't we have a Linux based laptop with rock solid hardware? I use a dell xps, ubuntu for everything except photoshop. But I was getting 56k speeds on the Intel 6235 and disconnects; after months of battling went and bought an ac7260. Figured it has to work because it's the card from the xps ubuntu edition. Awesome wifi now, but the Bluetooth goes to sleep every half hour and won't wake up without using the physical toggle on the keyboard. The Nvidia Optimus power management doesn't work on ubuntu, so instead of six hours battery I get two and a half. There's always something that doesn't work quite right and I waste hours fiddling. Getting tired of this and ready to buy a mac but that has its limitations too. 
That's got to be the smallest definition of "universe" that I've ever seen, or do you concatenate a UUID on the end of the string this library generates?
You can change it in all scenarios.
Following that thread, seems that there's no software available (apart from PhpStorm) checking for uninitialized variables.
Rumour has it, all the League packages are [at some point, or already in the process of] ditching 5.3 for not-dead minimum versions...
Check what subreddit you are replying to.
http://gooseberrycreative.com/cmder/ Made my life easier for a while; gives you unix style command line on windows. Note it is an emulator, and thus slow as fuck. I ultimately switched to a mac based environment. 
For windows style window management on OS X check out Flexiglass. Can't go without it.
&gt; you register multiple "controllers" in the same dispatcher instance Yes, that's true -- the "controllers" (or invokable action objects, whatever) are registered, generally as callables themselves so that they can be factories. (Hope that made sense.) &gt; Aura.Dispatcher doesn't allow dependency injection in parameters Also true, although I admit I don't get the idea behind "injection into parameters." Anything that needs to be injected, IMO, probably ought to be injected as part of the object creation, whether by constructor or by setter methods. &gt; but you need to have dependencies :/ Which is a problem for library-level stuff in Aura. But not for Bundles, Kernels, etc. Regardless, it's nice to see someone else thinking along similar lines.
I develop on a Macbook Air or Pro. When working on libraries and tests, I run the code using [Homebrew](http://brew.sh/) PHP. Anything web related runs inside of a Vagrant VM with Ubuntu, so that the environment is similar to production. In the near future I plan to start running [Docker](https://www.docker.com/) images inside of my VM to more completely emulate production. Personally, I would never do web development on Windows, unless my production environment was also Windows... and that would be crazy. YMMV.
pfff will https://github.com/facebook/pfff/wiki/Scheck#features
&amp;gt;I honestly believe any web developer should work on unix machines. I understand, but it seemed like your answer was very broad. I would always recommend a Unix-based machine over windows for PHP dev, but not to every developer. This thread is talking town on Windows for development it seems, but it has its place. To each their own.
I already have for league/oauth2-server. As have Flysystem, oauth2-client, Fractal, route, container, CLImate, and probably most of the others.
&gt; although I admit I don't get the idea behind "injection into parameters." Anything that needs to be injected, IMO, probably ought to be injected as part of the object creation, whether by constructor or by setter methods. I agree with you when doing the "traditional" approach to controllers (i.e. classes). But you can also define controllers (or e.g. [commands](https://github.com/mnapoli/silly)) as closures. In that case you don't have an object, or a constructor. I think the "controller = callable" approach is really great in the sense that it's scalable. You can start with a quick controller in a closure, then later on move it to a controller class.
With the default token length and just using digits for the token I believe there are almost 100 million combinations.
People keep duplicating node abstractions in userland PHP but fail to realize that event emitters and stream implementations are prohibitively slow due to fcall overhead. This is fine in client environments but it just won't give you the performance you hope for in server environments. Are they nice abstractions? Sure. But you'll be disappointed if you, for example, implement a real http server and compare benchmarks against a compiled solution with ten or twenty thousand concurrent client connections.
Never used CakePHP, nor been to their website before, however their API docs look fantastic
We use whatever OS on the workstation that the developer is more comfortable with. Personally I use windows on my workstation, then I have a bare meta server that is identical to our primary web server (software wise) running CentOS with samba for file access. I also have a couple servers running vSphere Hypervisor for spinning up VMs to test things like server software changes. (Like trying out HHVM for instance) Everyone else works remotely from the dev server that is local to me. So we use Git and SSH. It works out really well for us
Omnipay will be in the next major. As well as a jump to guzzle 5. 
i always enjoy these names. not sure what i can use it for but i like it
&gt; PHP 5.4.16 or greater. * clap Seriously. Well done, and thank you for looking forward.
Never have tried it, but always heard good things about it. Kudos to the team.
Great minds think alike? I'm one of the core devs, and here are a few things that stand out: - CakePHP does not yet have an official queueing library. Honestly, I've been working on this as there isn't a good generic one (laravel's is decent but not built on good backend. For instance, I don't personally think redis is a good queuing backend). This may be a sticking point for developers, but I don't think it's a huge issue. I hope that we get a decent, framework agnostic one soon, and will push CakePHP towards it once it appears. - We don't have a dependency injection container. We don't personally think this is a great idea for us to implement, and it's easy enough for developers to use Pimple or something else. - CakePHP has a *much* larger testing suite. Some might say that's because we have more code - we probably do? - or because we have more features - cool I guess - but that's something we've always taken seriously and continue to do so. I hope Laravel continues improving on this front. - I prefer our error/exception handling code. Having just written an app CakePHP and reimplemented the same in Laravel (on a lark), it was just much easier to change certain types of output in CakePHP's version. Note, this also means it's easier to write more boilerplate code, so something to be aware of. - We're using PHP as our templating language. I mean, it's a good templating language. It's also easy to swap out with something like Blade or Twig (both of which I'm aware of implementations). It's similar to [league/plates](http://platesphp.com/) for those who hate frameworks. - Routing layer is pretty similar to the rails routing layer, and though they superficially look similar, I don't think it's fair to compare ours to Laravel's. - Our event system handles quite a bit more functionality. If you've used [thephpleague/event](http://event.thephpleague.com/), you'll feel right at home. - The ORM is implemented completely differently. We use more of a datamapper pattern whereas Eloquent is more ActiveRecord-like. We looked at the advantages and disadvantages of other solutions - switching to Doctrine, implementing ActiveRecord, adding a `Session` class - and found our solution to be the best one for us. YMMV and all that jazz. Also, our ORM is wayyyy better - seriously, try adding json support to Eloquent vs Cake's ORM - but I might be biased. - Our Collections and Hash classes are fucking ace. Drop those into your apps (cakephp/utility is the packagist dep) and start using them outside of CakePHP. None of the above is to say that CakePHP is better or worse than Laravel (though I think it's better). Use what works, don't rewrite your apps in a different framework just because it's new, and evaluate your options before diving in. I encourage everyone to look at CakePHP and let us know how the new version can be improved. Better frameworks/libraries == better developers :) --- ^(I'm still hungover from being out with /u/philsturgeon so I apologize if I say anything correct)
You are not the first one to tell me that ;)
This was a really great post! Thank you for taking the time to elaborate. I'll have to give the new version a spin! 
Very interested in taking the datamapper ORM for a testdrive.
I like the natural scroll direction when using just the track pad, but I don't feel like undoing two decades of mouse wheel scrolling habit, so I'd like for mouse to be normal, and track pad to be natural.
Since Dogecoin uses Scrypt instead of SHA-256, there may be some core changes. A whole fork may be in order in fact.
Yep! https://groups.google.com/forum/#!topic/thephpleague/yVKgoY3YFq4 Luckily pretty much all of them have a major version out which is still PHP 5.3, so as long as project leads are cool making patch fixes for older versions for another few months we shouldn't have an issue. 
You mean apart from the issue of 5.3 being dead and dangerous?
It's great that there are other options, but Windows just works, usually without much hassle. And there are great code editors that happen to run under Windows, and it runs web browsers just fine, so people should be able to use it if they choose. 
I've been desperate to try a data mapper that's not Doctrine. Is it possible to use separately?
Desktop: Mac mini (Yosemite) with Twin Cinemas, PHPStorm. Vagrant: Centos/Ubuntu Vagrant w/PHP5.6 +xdebug, HHVM, Mariadb 10 &amp; Redis 
&gt; **we** shouldn't have an issue. 
That's no reason not to develop the abstractions. By the time fcall overhead is reduced, we will have some mature libraries and the mental models to use them wisely. Besides, arguing the performance in the context of 10,000-20,000 concurrent connections is facetious. Node couldn't handle that without significant configuration and optimisation. The average PHP shared host battles with 30 concurrent connections. There's so much space in between that anybody attempting to get higher-than-normal PHP concurrency will reap the benefits of carefully constructed applications atop reactive libraries such as these.
Our development server is Debian, configured to (approximately) match two separate Debian production web and mysql servers. All of our production-use packages are kept at same versions. We have a subversion repository on dev, with separate checkouts for each developer under his home dir. The production apache server contains its own checkout. Each working copy contains all of our websites, accessible to us as http://&lt;dev name&gt;.&lt;etc&gt;. For production, it's just "www". Once a developer completes a project, it's committed. That dev then shells into staging and executes a script that tells production to pull changes. That's our shared environment. My own work computer is Ubuntu, with my working directory loaded as an NFS mount from my home office. Sublime editor. Multiple testing browsers on diff machines and mobile devices. The other devs use variants of Mac, Windows, and CentOS.
Honestly, I don't see much value in this beyond the point where you have a connection. It's all fine and good to treat dependencies the way the article describes, but when the dependency is a database server without well-designed and fully documented code contracts, with which you communicate via a domain specific language interface, you're going to have a hard time testing certain constructs without the cooperation of the real deal. 
Glad to see Cake back in the framework game, so to speak. I've never used the Data Mapper pattern before though since I'm more of an ActiveRecord kind of person, especially with small stuff. Aside from that small learning bump, will definitely be checking it out.
If you've been using a mouse for 20 years, the scroll behavior of the scroll wheel is ingrained in you. I'm NOT changing my scrolling habits to satisfy a poor decision from Apple. Meanwhile, I find the "natural" scroll direction of the trackpad to be intuitive in that context, so I want to use that. 
Work: OS X, PHPStorm. No webserver as what we're building does implement a webserver in PHP (not the built-in before people flame) Home: Ubuntu, PHPStorm. I would use OS X if I could at home, but my Macbook Pro is significantly less powerful than my PC (it's 4 years old after all). Road: Aforementioned MBP. OS X, PHPStorm Pretty consistent environment all around. We're super cognacent of case-sensitivity when working in OS X, and haven't ran into problems as a result.
Pretty much covers me too. Homestead for my vagrant, as I do a fair bit of Laravel stuff. That said most of my projects lately are EmberJS, rather than PHP.
Fair enough. Took me about a day to get used to. I rather like it.
If you're mocking a data source, why not have your mock simply return a wide variety of data in the same format as what the original data source would have provided? I am not following the need to build a mock for the entire mysql interface. 
Windows 8.1, Atom (soon back to ST3...), msysGit, Hyper-V running local FreeBSD VM and pushing to Hyper-V FreeBSD/httpd production VM. why? because it's easy, fast and maintainable without having to learn anything else.
I second this approach. Per the docs it has a number of advantages over libssh2 too: http://phpseclib.sourceforge.net/ssh/compare.html An independent assessment would be nice but whatever. Also, fwiw, the 2.0 branch on github is namespace'd. The docs don't seem to mention that but I've used it and it works great.
I'm doing the same but after a recent upgrade i'm having a problem (vmware tools related) with accessing shared folders.
I'm in the exact same situation. I could insist on following IT policies to the letter and getting nothing done, we're several people with that kind of problems but they don't care - we're still in the minority. If it were up to them we'd be doing our development in Word, and for the advanced stuff we'd be using Excel :(
Fair enough. I've just been working in this area long enough to know that asynchronous programming won't be a big deal in PHP until it is at least somewhat standardized. Obviously it won't be mine, but discovering a standard way is part of my goal.
The docs are pretty much what got me to try, and then stick with them for a long time. Not PHPing much anymore, but still looks good.
&gt; He said any developer. ಠ_ಠ You need to use the... &gt; con·text /ˈkäntekst/ noun The circumstances that form the setting for an event, statement, or idea, and in terms of which it can be fully understood and assessed. Either the subreddit or the *actual post* on their own ought to be enough for you to realize he's **not** referring to .Net development. 
cake has no english forum? only google groups? 
We had forums in the past - as well as a slew of other solutions - but in the end they proved a bit more difficult to moderate than we'd like. For now, I recommend the following support solutions: - IRC (I idle there frequently as savant). This is my preferred method, as you can generally get an answer much quicker than a forum or otherwise. - Google Groups (Quite a few core devs answer questions there). Pretty good alternative if you like forums. Not so great for organization, but we'd probably just have 1 subforum anyhow :) - Stackoverflow (We had ask.cakephp.org which was a silly adventure) - Reddit (I try to answer questions when they pop up)
Started out in my early days in Windows, but these days I rock an Ubuntu laptop decked out with lots of command-line goodies, though I actually write all my code in Sublime Text. I use Xdebug for debugging PHP, which integrates very nicely with Sublime. When it matters, I run the code inside a Docker virtual container (lighter than Vagrant) that either matches the server setup or is the container to be run on the server directly. Also VirtualBox for Windows &amp; other strange things. Apache/nginx are run inside Docker containers, 'cause my system can't be bothered with such things, since it is also my school+gaming+everyday+showoff laptop. I mostly use Ubuntu because it just works for all these things without .conf wizardry and I'm comfortable with it.
It's a performance optimization. Laravel code using Facades will have a *lot* of calls going through there and `call_user_func_array` is very slow. In PHP 5.6 you would replace that method with `$instance-&gt;method(...$args)`, which is much faster than `call_user_func_array` (or the switch).
My guess would be that it was implemented like that for performance reasons. See http://paul-m-jones.com/archives/182 for some call_user_func_array benchmarks
I'm probably the main contributor the new ORM and the developer that lead most of its architectural decisions. Back in the days (I think that was end of 2012) we were starting to think about cake 3, by the time I was happily using Doctrine for a few projects in combination with CakePHP. I actually suggested to the core team to use Doctrine instead of using our own framework, as I already had experience in doing a bridge between the 2 libraries. After some consideration by the whole team we came to the conclusion that using Doctrine was not possible for us at the time, here are some of the reasons: * At the moment some parts of Doctrine where licensed under LGPL, whereas our license is MIT * Doctrine documentation was exceptionally scarce, we imagined that we had to document the missing parts and try to coordinate with a team that we had little contact with. At the end it seemed like we would had to duplicate their docs effort so we could offer guidance in how to use the ORM and how to use CakePHP with it. * Out of my experience doing the CakePHP bridge for Doctrine, I came up to dislike their use of private methods and final classes, which made me copy paste large parts of theirs software just to add a couple lines. * We care a lot about the overall experience when using the framework, everything should feel it was intended to work together, making Doctrine fit into the Cake mentality was kind of difficult. Also, having 2 different places to report bugs for our users would have been less than ideal. There were not real good ORM alternatives at the time, so even though we knew how huge of a task that would be, we decided on rolling our own. I found it both fun and challenging and I'm really happy that I took the chance. The new ORM is one that I could actually like: It is flexible enough to stay out of the way, yet it helps you a lot in every single task.
Os X, homebrew, xdebug, composer, phing and NetBeans. Vagrant and PHPCI for real integration test.
OS X on my home and work computers. Using Vagrant at work but MAMP at home (not had a chance to move over yet). Also just started the process of switching from Sublime to PHPStorm and plan to make use of XDebug in the near future.
404 assets may slow your website in dev env, because the router then profiler will try to match the route.
Thanks :)
Thanks! That was a good read too!
Just so you know guys. Modern Linux kernels are very good at managing threads and will automatically jump to a different process as soon as the current one starts waiting on IO. The whole async problem was there about 3 years ago, it's not there anymore, at all. Just make sure you have enough threads running and you'll get exact same performance. The only downside to threads is more memory consumption. But who cares about additional gigabyte of ram anyway?
&gt; It loads a database from a SQL file (fixture) in the static ‘setUpBeforeClass()’ function. This may not be so ‘correct’ or ‘clean’ (from a unit testing point of view) So what you have there is an integration test, not a unit test. That isn't neccisarly a bad thing; there are plusses and minuses to both. At least your doing some form of automatic testing, which is a great start. &gt; but it is much faster to write and easier to maintain. Yup, that's certinally one of the arguments ppl make when using mocks - pain in the ass :-)
I know the reasons why they use private and final classes and I definitely respect that, but knowing the reasons does not make the work any easier :) We definitely did not want to create a frankenstein of copy pasted code that would constantly break with each change in doctrine. As for the docs I agree it is a shame. We put tons of effort in our documentation so we know how painful it is to produce it and keep it up to date. But as I explained earlier, we would have been in the worst of the cases, where we needed to duplicate their docs and to explain the differences we would have introduced.
Ha funny I discussed that benchmark yesterday [here](https://github.com/myclabs/DeepCopy/pull/12#issuecomment-84482483). Since the benchmark was dating from 2005 (PHP *5.1*) I tried to reproduce it on PHP 5.6: Method Iterations Average Time Ops/second ----------------------------- ------------ ----------------- --------------- $obj-&gt;foo(); [100,000 ] [0.0000022220159] [450,041.79270] call_user_func([$obj, 'foo']) [100,000 ] [0.0000035184002] [284,220.08451] So in short, using the `switch` method in Laravel makes sense because it's a framework and facades are going to be called a lot everwhere. But for any other non-critical piece of code, `call_user_func` is not slow. Especially consider the cognitive overload for understanding the code.
&gt; and `call_user_func_array` is very slow While I don't doubt at all the fact, that's some strong words to use considering the performance difference will not not affect the majority of PHP developers. I'm fearing another "single quote vs double quotes" myth again.
Hi, do we have a *proper* pecl extension implementing collections and datastructures in php? things like lists,dict,set, (add other data-structures here) I am aware of spl lib.. would like to know anything else... (similar to hack collections)
I don't like to push developers in any particular direction about their setups, but I do show the benefits of using a proper IDE and the correct debugging and analysis tools. Doesn't stop me taking the piss about devs using Windows :) A while ago I was faced with similar problems with virtual machines and so I setup a project called Vlad (https://github.com/hashbangcode/vlad). This is a Vagrant project that uses Ansible to setup a virutal machine with a standard LAMP stack. More software can be added on top as well, and it's also possible to plug in custom Ansible roles. It is geared towards Drupal developers, but the tools and scripts we install don't force you to use Drupal. The 'dev' branch now contains support for Windows host machines and we are looking for developers to help with testing. I'm sure the community would love to get some feedback on this :)
This is great news and I hope that everyone takes the time to give Cake 3 a whirl even with a simple test app just to see that so much change has happened. This isn't the CakePHP you remember, this is an entirely new beast with a whole host of new things. Give it a try today, you'll not regret it and hopefully, the code will change your perceptions of CakePHP for you!
Thanks for your reply... &gt; I'm just saying I don't personally like the interface or the backends it provides. The redis bit is me picking on redis, not laravel's queue layer. Regardless of how I feel, it's a feature laravel has and cakephp does not, and that was the point of that comment. Fair enough - it wasn't entirely clear. Read a little bit like "don't like Laravel queues because they require you to use redis". &gt; We have and use dependency injection already. The core team just doesn't see much point to a DI container. If your app requires it, you can implement it pretty easily - here is a plugin[1] from a core developer that uses Ray.DI[2] . Personally, the only time I ever missed a DI Container was when I was writing Android applications. If you need it, nothing is there to stop you. One thing I really like about using frameworks built with a DI container is that the details about *how* the framework assembles an object are abstracted away from me. This is especially useful when you have complex framework components with complex dependency trees. Being able to just instruct the framework that I don't want to use component A, because I've written component B, and swapping that out with a single line of configuration without damaging other parts of the framework in strange ways is liberating. That said if you don't actually have complex dependency trees it might be a non issue. &gt; Yeah, it's changed quite a bit. Thank god for that :) 
I certainly can't be the *ONLY* developer subscribed to /r/PHP that maintains both PHP and .NET... 
Why rely on an emulator? If you want Unix commands in Windows just compile from source and add them to your path...
Something you just install is much easier than compiling and adding to patb
Thanks! I appreciate taking the time to respond. I'll examine the approach and I'll consider it for the library.
I have worked on Windows for almost 10 years. In the beginning it was xampp, later on (PHP 5.4+) i used the internal Server so goodbye xampp. However the more CLI tools began to emerge over the past years the more unhappy I got. Not I'm using OSX for barely 9 months and I truthfully couldn't be happier. Vagrant, Composer, PHPStorm, MysqlWorkbench/SequelPro and occasionally FileZilla that's all I need. Ultimately I barely leave PHPStorm ever. Recently I've added phpbrew to my stack locally for some fast tests on different php versions.
Why is Joomla so disliked here (from what I've read in the past)? What is wrong with it, and what is right with it? I find myself in a situation where I have to get familiar with it and right now I'm stepping through code trying to get some understanding of how it works and so far it isn't pleasant but that could just be my own shortcomings.
Like others said we need a bit more info. What do you try to list? DB Version and queries? Symfony is definitelly not your bottleneck on this one.
Interesting discussion. Thanks.
Cmder is only Terminal emulator, and it's not slow at all. It doesn't include any Unix commands by itself, but people usually install it with MSYS which is a set of Unix utils compiled for Windows.
Okay fair enough, I'm not qualified to really know. But I do think Ubuntu's real objective is mainstream acceptance and to do that they're going to need an equivalent to the Samsung Galaxy S that made Android mainstream.
They're not that bad. Take the base Macbook Pro (non-retina). It's the last user-upgradable Macbook. Buy the base model, then when you get it pop in 16GB of RAM and an SSD, and you've got a beast of a laptop for a very competitive price - especially when you consider the build quality.
I think their objective has shifted somewhat over the years. In particular I think the desktop has been a means to an end rather than the objective *per se*. The (dare I say) unbelievably friendly and usable desktop Ubuntu introduced has allowed them to be a household name in business. They now seem to make money primarily in the server space while desktops are probably more of a loss leader, the phone may play a similar role for their push into IoT and openstack.
If you voluntarily read Leaseweb articles you're a masochist.
I think it might lead to nicer stack traces as well.
Yup once your used to it it's just as intuitive. The 20 years prior has nothing to do with it if it only takes a couple days to unlearn.
I would use the [Symfony Process](http://symfony.com/doc/current/components/process.html) component to handle running the command.
Ubuntu, Phpstorm, nginx, hhvm, composer, node, that's about it, I think
Yeah, the only difficulty I have is I'm forced to use Windows a few times a week. I need to find a way to invert it there as well.
Web === open .Net !== open Web developer should use Linux. If it doesn't run on Linux, it shouldn't be used for Web Development. Let's be religious about this. 
easy to do if you are a one man team, but if you want to ensure everybody has the same "utilities" it begins to be a PITA. So basically, while compiling everything you need is very close to the metal (extra nerd points for that!!) it sounds like a maintenance nightmare to me.
Hey there, I just tried it out, but I can't seem to connect to the host. I tried using all the credentials stated in the Connection Info screen in MySQL Workbench, but it can't connect. Afterwards I tried pinging the host, but also in vain. Is there something I'm overlooking?
Mocking code you don't own is a bad idea. The same query may produce different results on different schemas, DBMS versions and different versions of DB driver and so on, while mocking assumes the result is always the same. Instead, you need to define some data abstraction (e.g. a repository) and mock it when testing data consumers. And the repository itself should be tested in a functional way (i.e. by means of using real DB connection). It's not my own idea, of course, there was a better explanation of this by @everzet.
+10 innernet pointz for thoroughness. 
Save for the fact that it needs to live in the include_path like PEAR what about it made it messy / a bitch to implement? Looks like the 2.0 branch (which I didn't even know about) works with PSR4 autoloaders.
The omnipay-stripe package has a section in the README that covers Stripe usage via the Stripe token. https://github.com/thephpleague/omnipay-stripe#stripejs
He said any web developer. I work in both - PHP on Mac for freelance and .NET on Windows for my full time. 
You can swap underlying classes pretty much anywhere using the `className`options key when configuring that dependency. Different strokes I guess. I've never had the desire for a DI Container. Yes, it's a nice feature, and can be useful in certain cases, but the way CakePHP handles it - configured adapters behind what are basically factory classes - seems to work well enough. I think what we're quibbling over is where that configuration goes, and what it looks like, not the end result. We might revisit this in the future, but at the moment our current strategy works well enough for the apps we've built^[1] , so there isn't a pressing need to redo this. Though if it works for you, use it :) --- ^([1] This includes applications in other frameworks and languages. Of note, I currently work on and deploy Golang/Lua/Node/PHP/Python/Ruby and a slew of frameworks in each language. These are all non-trivial applications and thus I've tried to use my experience there in building out a better base framework. The same goes for the other devs - one of our two lead developers works in Flask and a homegrown PHP framework at Freshbooks, with CakePHP being his labor of love.)
Flaky? http://php.net/manual/en/types.comparisons.php the main reason for this type juggling is that all input in PHP (such as from GET and POST) starts as a string.
.NET is open source though...
To reiterate what everyone else is saying, this looks really great! Thanks to the entire team for all the hard work and congratulations on the release.
I switched to using Linux as my main OS and I run Windows 7 in a VM for when I need to use Photoshop or Microsoft Office (very rare nowadays). I also have a few other Windows specific programs that I need that work fine. It's been great and getting out of my Windows comfort zone has forced me to learn more about Linux and now I feel like I can be proficient working on a Linux, Windows or OSX desktop.
I switched to running Linux as my primary OS, with a Windows 7 VM guest on Virtualbox that I use to run all the Windows stuff, like Photoshop, when I need to. It works really great, and having the Unix/Linux command line as a native tool is very convenient. However, I did this mainly so I could get really comfortable with Linux, not because of any Windows issues. Having said that, regarding the browser issues, for web development I think it's imperative to have access to native Windows 7 and 8 systems running the latest IE and the other browsers in order to be able to do proper testing. I've found that having Windows 7 and 8 setup in a VM does not always accurately render websites the same as it does on a native install when doing browser specific testing. I had the same experience as you with Windows though. Never had any issues with web development. I even had a portable development folder on Windows setup that contained Sublime Text, an FTP client, and an SSH client, which I could drop onto any Windows computer and start development work right away without any installation needed. I'm not sure I could do that easily on another OS.
Thanks!! (This was the answer i was waiting for)
Interesting that you are able to recall and dig it back :) .
Nice work. On a semi-related note; since you're familiar with the DateTime code. Are there plans for PHP's DateTime objects to support microseconds?
All input in PHP does *not* start as a string.
You can add the `category` or `chapter` in there. It's still not full fledged hierarchical content, but things like 'about/people' and 'training/foo' is doable. See here: https://github.com/bolt/bolt/blob/master/app/config/routing.yml.dist#L112 
To clarify: with Curl, I mean the Curl PHP extension, not the program itself.
&gt; I don't know friend. Seems a little unbelievable to me... :) I only posit the feasibility because I've done it to the tune of 80,000 responses per second with 10,000 simultaneous clients in a real http/1.1 + websocket server implemented entirely in userland PHP (7) on [standard server hardware](http://ark.intel.com/products/52214/Intel-Core-i7-2600K-Processor-8M-Cache-up-to-3_80-GHz). If you use current 5.6 master the same server can handle ~50,000 responses per second with 10,000 clients. You can doubt it if you want to. I don't care.
I can't tell if this is sarcasm?
Ideally, any method that simply needs to extract the value of a DateTime or very temporarily use a DateTime's value would just use the interface. The problem with accepting the interface is that it allows the mutable instance to be passed, which would mean it could change out from under you (or you could accidentally change it yourself). Also, the whole point of this addition was to allow for easier interfacing between new **and** old code. Older code (pre-5.5) doesn't have the ability to use the `DateTimeInterface` or the `DateTimeImmutable` types, as they didn't exist yet. If you're writing a new application and want to take advantage of the new immutable instance, you're going to find that its a complete PITA to use them with any external libraries that support pre-5.5 PHP as you'll have to convert the instances all over the place. That was the drive of this addition. :) So, yea, ideally you'd use the interface or more clearly denote the requirement of an immutable instance to the caller via a type-hint, but that's just not always possible.
You aren't, but even so it isn't a free-pass to "comment without reading the article".
Hey there, send me a pm that contains the email address you use on heroku and I'll help you troubleshoot :)
All input from file operations start as string. All input in $_SERVER variables start as string. All input in $_GET variables start as string. All input in $_POST variables start as string. All input from socket functions start as string. So mainly yes, they do start as strings. Some casts happen before your program even gets a chance at the data though. Like in $_SESSION variable, where it is also stored as a file, and read into memory initially as a string, but where type is preserved because the cast happens during the process start. (I believe this is because sessions store serialized strings, although I'm not positive.)
I don't think there are any "plans" for DateTime improvements (or at least, none that I know of). It would be a good idea to add support for microseconds, however. The most annoying thing about `DateTime` and micro-seconds, is that they're actually kind of ["half-supported"](http://php.net/manual/en/function.date.php) right now: [Example...](http://i.imgur.com/6HBeXoJ.png)
DateTime "supports" microseconds at the moment. There are bits and pieces lacking, however. What in particular would you like to see added/changed?
That's a bit over the top. Yes, everything is transmitted as a series of bytes. So that means it's a string, right? No. It means it requires interpretation. When you receive data over a socket, you decode the data. That means, according to a protocol, you interpret the results. Often that requires unpacking data into more appropriate types. Just because it's stored as a blob of bytes doesn't mean it's a string. A great example of this is JSON. It's a "string", but it has intrinsic meaning. And you can decode it to that meaning. Your "all input in $_... start as string" is incredibly short sighted. It's saying that "because PHP doesn't know how to deal with it, it must be a string". No. Your application knows how to deal with it. So it decodes it. And if there's an encoding error, that's precisely what it is. Just because it was bytes at one point doesn't mean it's a string (even if PHP uses IS_STRING, it just means it hasn't been interpreted yet). Under the hood, everything is just a byte. So why don't we say "all variables are just bytes"? Because that would be a *derp* comment. Just like calling "all input is strings" is a *derp* comment.
Because it's [broken](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/) and makes people either [sad](http://phpsadness.com/) or [hysterical](/r/lolphp).
More like disgust in my case.
I'd argue they're recognised in the sense that people will generally recognise what they are, but I'm not so sure they really have much benefit in practice in terms of getting a job. Certifications are awfully low on the list of things I care about when I'm hiring, personally.
That decoding just doesn't fall to the application in all languages. That's the distinction I was making.
Aha! You have hit the problem that explains why (some) people are so excited about javascript on the server, and more specifically being able to run the same exact code ("isomorphic apps" is the term du jour for this). But alas, that is a huge undertaking and the ecosystem is so in flux that it's not feasible to give up on your existing codebase. SO... you can either come up with processes that make it less horrible to maintain this double code base (as @samandiriel mentions in his answer), or you can actually keep all your logic on the server, in PHP, and have the front-end make ajax calls for every calculation. This is going to be slow and error-prone if you're firing off ajax requests many times per second... but if there's only going to be occasional requests then it might be a viable option. Or you could mix-and-match the two... super basic calculations (like "total up the line items and add sales tax to get a grand total of the order") can have duplicate logic between client (js) and server (php), whereas more complex calculations (like "combine various pieces of data about this order to formulate the proper discount from a matrix of possibilities") can be done entirely in php on the server and called via ajax from the frontend. Good luck!
The point of accepting DateTimeInterface in PHP7 which supports both DateTimeInterface and DateTimeImmutable would be less extra typing to convert to the type you require (and possibly the potential for small optimizations and future proof code if another DateTimeClass extending DateTimeInterface is introduced). If you pass a DateTime to createFromInterface you get a new clone, same as would happen with immutable passed in. I hope this would make it easier to accept DateTimeInterface instead of the specific class you want to use. //example entity class SomeEntity { public function setSomedatetime(DateTimeInterface $datetime) { if (!($datetime instanceof DateTimeImmutable)) { $datetime = DateTimeImmutable::createFromFormat(DateTime::ISO8601, $datetime-&gt;format(DateTime::ISO8601), $datetime-&gt;getTimezone()); } $this-&gt;somedatetime = $datetime; } } //example methods... not sure which is faster or better datetime format class DateTimeImmutable { public static function createFromInterface(DateTimeInterface $datetime) { if ($datetime instanceof DateTimeImmutable) { return $datetime; } return DateTimeImmutable::createFromFormat(DateTime::ISO8601, $datetime-&gt;format(DateTime::ISO8601), $datetime-&gt;getTimezone()); } } class DateTime { public static function createFromInterface(DateTimeInterface $datetime) { return DateTime::createFromFormat(DateTime::ISO8601, $datetime-&gt;format(DateTime::ISO8601), $datetime-&gt;getTimezone()); } } //example new code class SomeEntity { public function setSomedatetime(DateTimeInterface $datetime) { $this-&gt;somedatetime = DateTimeImmutable::createFromInterface($datetime); } } 
This. And also just the complexity involved if the result of one call depends on updated results of another, and one request happens to take longer than the other even though it was fired off first... it's not too hard to keep things running smoothly if there are only a few basic calls being made for straightforward situations. But when things get complicated they get REALLY complicated (especially because it's hard to reproduce errors that are caused by combinations of state changes that your users might not even be aware of and hence you have no way of knowing what exactly went wrong)
Maybe you could fork and extend this project, PHP-to-Javascript: https://github.com/Danack/PHP-to-Javascript Then, create a library of calculation functions/classes similar to how you would approach solving problems in LESS, SASS, CoffeeScript... to be compiled, deployed and reused by the front-end?
Yeah, I was thinking of something along these lines. /u/samanderiel had a good suggestion about the pseudo-code. It might be worthwhile to have the 'master' formula in .php and have the JavaScript slave from it. I suppose the devil is in the details on this. Depends on how difficult the formula is.
It is hard to transfer code back and forth between php and javascript, but it's easy to transfer data. Given that, it's not terribly difficult to set up a single source of validation rules that drive both your php and javascript model validation. You of course need the code to consume the rules in both languages, but after that is in place, you can make model and validation changes in one place.
Can the new ORM be used stand alone without the rest of the framework?
Not all input (`$_SERVER['REQUEST_TIME']` is not a string), but a lot of it, yes, and in a strongly typed language that just means you need to parse/interpret those strings into more appropriate types and structures (as @ircmaxell was saying). The original PHP designers instead tried to make it so the developer didn't have to think about types too much and could just throw around strings and pretend that they're integers or bools etc based on how it was being used (hence the "is this string numeric?" checks in the implementation of `==`). I don't think that was a good decision, but it's how we got here.
People here suggest using NodeJS and that's not a bad idea. Especially if you consider the fact that you don't necessarily have to rewrite your whole application in JS. You could just create a "microservice" that you can call directly from PHP. This service would never be exposed to the web. This microservice could expose a HTTP API (REST or whatever), or you could communicate with it using a message queue like RabbitMQ, Redis, …
Have you considered keeping all the logic in PHP and just making AJAX calls from JavaScript to have the PHP perform the logic and give you the output?
I tried Aura.Html for a small project, while it is well thought out in itself I found it very difficult to create more advanced helpers. More precisely I found it nearly impossible to call an existing helper from a custom one, or to extend one of the core ones. 
Yes, you do have to duplicate everything, but you can make it a bit easier for yourself. On the client you need friendly error messages, so the error code needs to be more complicated, and you need to detect and say exactly the problem. On the server though you can be harsh - if anyone sends bad data that's their fault for bypassing the client code, so you can use simple code that is just pass fail, with no diagnostics, just "error". I strongly recommend making good comments in both saying things like: "If you change this, also change it here ...", and linking them together. Also make some tests - you don't even need anything automated (although that's nice). You can simply have a large comment with a list of tests to run and expected results. Ideally you have two test cases for every error condition (one pass, one fail).
Link to Godwin's law for those that dont know: http://en.wikipedia.org/wiki/Godwin%27s_law 
The language [Haxe](http://haxe.org/) can be compiled to both PHP and Javascript. ;) [OCaml](http://ocaml.org/) can also be compiled to Javascript using [`js_of_ocaml`](http://ocsigen.org/js_of_ocaml/) (that's what Facebook used to build their browser IDE for Hacklang), but there's no (reasonable) web-framework for this language. Yet.
That isn't a cool change. Breaking changes in a minor release? This is why I recently chose not to use Laravel on a new commercial project. This isn't the first time breaking changes have been made without any communication or within the versioning guidelines. Laravel seems to be good for personal projects, but I find it hard to regard it as an enterprise framework when things like this happen.
Pretty sure that was a joke. At least I hope it was.
Oh wow, I don't even feel sorry for laravel users, it's not the first time something gets broken in minor releases of this framework because the author suddenly concludes that A CHANGE NEEDS TO BE DONE and f*k you all. I will never ever use it for any serious or commercial project, that's fo'sho.
+1 for Symfony, ill stoke the fire for you over here in this camp (y) and we'll share horror stories of other frameworks! 
This is great! Cake was the first MVC PHP Framework I ever used and only one year ago for my final year project. It was very confusing in the beginning to get up and running on but I loved the end result, not my horrible UI but the code I used. I've not used it since but I want to give this a spin and make a few demo apps to get a feel for it. 
Once you get over the initial learning curve, emberjs is remarkably productive, often automatically filling in the gaps for simple things without the need to write anything other than some basic handlebars templates. And if you do need to build things, it's API is very expressive and well thought out. Ember data (a first party addon) gives probably the best ajax support I've seen in a javascript framework, and ember-cli takes care of the structuring of files, concatonation, build pipeline, frontend dependencies, testing framework and the like. It suffers in some artificial benchmarks on outright performance at the moment, but [that's changing](https://is-ember-fast-yet.firebaseapp.com/)... And if that's not enough, there's a thriving [addon ecosystem](http://www.emberaddons.com/). It's not all rainbows and unicorns though... The learning curve is quite steep and to leverage a lot of it's productivity gains you really must buy into it's conventions. The community is also a bit of a hipster circlejerk, although is broadly helpful at least.
Actually I started the project with ember and I did another project with it some time ago. But I still don't feel really "at home" :) Maybe I just don't understand parts of it, but I often struggle on half the way. E.g. I couldn't manage to teach Ember Data to create the models from nested fixture objects. Or: I have a set of data that I can create statically and then pipe to the view, but I'm to stupid to do this with a promise to simulate AJAX loading of this data.
It's funny but when I tell people I refuse to use laravel they're all, "OMG why, it's so amazing!" Then shit like this happens and people only dump on them. You don't push breaking changes **ever**. Not just in major or minor releases, but **never**. It defeats the entire software development cycle. This is why version control has a branch and tag features.
Well, laravel isn't a community project, so live with it. I love the way that symfony is adding new features, but jesus, YAML files?!
what's wrong with yaml files? I generally config my services with xml though.
No one's even mentioned that in the conversation. This is probably the biggest crime...
I'm definitely trolling here, because I'm biased towards CakePHP. Have you guys considered a framework that offers better stability over time while still having a rich feature set for building applications?
There's a difference between just "not being a community project" and openly disregarding the community or being hostile to dissenting opinions.
Laravel brought some innovation to the PHP scene. A lot of people were introduced to IOC/DI through Laravel, and the usage of reflection for auto-dependency injection (which I consider highly valuable for prototyping) as well as the static proxy stuff ("facades") is highly valuable. After Laravel 4's release it could've easily grown into a stable project - because of its explosive growth in popularity, I thought it was going to go in that direction - if it had brought in more maintainers and made decisions based on consensus and not just the whim of the single project maintainer.
I said the same on the [internals list](http://news.php.net/php.internals/84342) when the op brought the subject up there but it was just ignored. Now if someone passes you a DateTimeInterface object and you want an immutable, you have to check if it is mutable, then use the method or if it is immutable, then clone. That is just bad, sorry.
Laravel has taught me one thing for sure. Never run "composer update"
:D
Hi, Thanks for sharing !!!! 
&gt; We're not changing it. If it's not working, you've set the permissions wrong. How is anyone supposed to know they needed to set permissions on the vendor directory? It's not in the docs at all.
apparently he cant stop him moving files around: https://github.com/laravel/framework/commit/92a2300e87b1971cf71f4aea1f6e65e0a519a046 if someone suggests using laravel for a new project, i'm always sending him this: https://gist.github.com/anonymous/8565929 side note: i'm a symfony2-fanboy.
Wow, another one? I love laravel, and have a few L4 apps in production and a couple under development, but yet ANOTHER breaking change and an unpredictable release schedule really makes me reconsider what I'll be using for my next project. I wonder if anyone would consider forking laravel as a community project, and keeping it a bit more stable? Or maybe I should just make the switch to Symfony and be done with it.
That sounds like it could get hugely complicated fast - you're basically talking about a custom compiler and language, which can be very tricky to do well without shooting yourself in the foot, and makes bug hunting a huge headache as you have to worry about both the engine and the ruleset being consumed by it. It's very possible, depending on the complexity required, that your solution would be even more of a headache than the current situation.
Laravel is a great framework for a lot of needs. For us, where I work, we need a little bit more stability, so we chose Symfony about a year and a half ago. I have no regrets. It may be slightly more complex than Laravel, but I have updated to the latest version within a few days of its release with no issues since then. When 3.0 comes out this Fall, I will be ready to upgrade to that right away as well.
I have issues with some of that advice. None of it seems to address the actual question of "how to make maintaining code parity easier", and some of it is questionable IMO. &gt;On the client you need friendly error messages, so the error code needs to be more complicated, and you need to detect and say exactly the problem. On the server though you can be harsh - if anyone sends bad data that's their fault for bypassing the client code, so you can use simple code that is just pass fail, with no diagnostics, just "error". Friendly error messages on the browser and basic pass/fail on the server is not going to help with maintaining parity between codebases. &gt; I strongly recommend making good comments in both saying things like: "If you change this, also change it here ...", and linking them together. Making one's change management process contingent on code comments is frankly awful advice, and in this context unhelpful because *any* change in one ruleset implementation requires a change in the other ruleset implementation by definition. &gt; Also make some tests - you don't even need anything automated (although that's nice). You can simply have a large comment with a list of tests to run and expected results. Ideally you have two test cases for every error condition (one pass, one fail). This is poor use of a programmer's valuable time, and only workable for simpler use cases anyway (if some process takes n steps with only two options for each step you get n! test cases to run through - this becomes unworkable very, very quickly!). Plus you get then get human error creeping in - both in running thru the processes manually, and in recording/interpreting results. For something as complicated as the OP says he is working with, this is not a good idea.
I always call my composer dir 'local' and my bower components dir 'local'. I need both package managers because composer fast fails if the 3rd party project doesn't have a composer.json file - bower doesn't seem to care.
Sorry to interrupt the pitch-fork laden circle-jerk, but this has been fixed in 5.0.19 to prefer vendor only if it is writable. Was never intended to be a breaking change.
-Sorry for the problems you had when upgrading-