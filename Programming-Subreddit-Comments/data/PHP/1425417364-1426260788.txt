A worthy effort and would love to see this - but I suspect it will never pass. The idea of correcting the errors of the past via namespaces sounds like a better long term solution to me. 
LOL. I would go so far as to say I have *decent* html skills and joomla can still fuck off and die
Ditto, for my oh so beloved [strpbrk()](http://php.net/strpbrk).
Scalar objects is a pretty bad idea. You can write extension which will extend parser (hey, we have AST now) and this will be just syntax sugar. $str = 'My String'-&gt;replace('foo', 'bar')-&gt;toLowerCase(); will be interpreted as $str = strtolower(str_replace('foo', 'bar', 'My String')); But i don't think that this will be popular extension. You probably should change language for this kind of stuff.
Exactly ! Not so long ago I was in this situation, and I felt overwhelmed by all that complicated stuff : Composer, Git, Vagrant, Gulp (and them doctrine, twig....) It was all supposed to make my life easier but seemed very intimidating and overly complex... As a result, it took me waaaay too long to finally decide to use those tools.
If you spend this much time thinking about what the ORM is doing behind the scenes, you may as well just go back to writing raw SQL again.
amusing where? all I see is a complete asshole picking on someone doing things differently
I'm very curious: what sort of use-case is there for strpbrk()?
Well yeah but that's not possible, so would you rather leave the functions eternally misnamed?
Yeah, i don't see this passing. Its a pretty big potential BC break, and it would be much better to see it move to OOP.
In a word, yes
Or any other CF system for that matter. Reinventing your own doesn't help anybody unless you bring something new and have the community to build the expanded array of modules.
https://philsturgeon.uk/blog/2013/01/php-6-pissing-in-the-wind/ Whoooo!
Imitation is the greatest form of flattery, or something. Maybe get your own username? Also I would love scalar objects. [Blogged about as much here](https://philsturgeon.uk/blog/2013/01/php-6-pissing-in-the-wind/).
If they don't fit in memory, they sure won't fit in redis in memory.
Make your own informed opinion if it's useful or not, with such a question you will only get ~defensive and ~biased responses. Try it in a small project where you think of the database as an object persistence device, which is closer to the default use-case for ORM: Object relational mapping, not the other way around; switch to the following mindset "What can a database do for my objects", instead of "What can this ORM do to my database". Also by your example you said you write many nested subqueries either for performance reason, or based on the way you structured data in your db. Haven't used Eloquent but with other ORMs I've used you can still perform that query like you'd do with the "raw" mysql functions and use and object "hydrator" to map that result back to an ORM object without relying on the ORM to build the query.
My guess is it is a replacement for preg_replace("/\^\(.\*)(" . implode('.\*', str_split($chars)) . ".*)$/", '$2', $string);
But then you would have to cast things all the time first.
 "testing 123".length(); "foobar".pos("foo"); String::length("testing 123"); String\length("testing 123"); are possible solutions
step 1) write an standard step 2) write libraries following the standard step 3) announce deprecation of previous libraries step 4) announce a version were the deprecated libraries won't be functional step 5) profit
boxing/unboxing each scalar value into object is a bad idea. Syntax sugar is just a syntax sugar, i have nothing agains it.
and deprecating it with an announcement of a version that won't support it anymore
I really got fooled here :)
&gt; is the reason why its so hard to have a civil discussion with some people nowadays only sith deal in absolutes. Nope, the reason is that some people have some fixed ideas and shouted about it in every RFC discussion (and event in pull requests). If you want every stuff in language to be an object - you need different language (or just write extension). If you want syntax sugar (something like i described) - you always can write an extension. But i don't think that such hight-level stuff should be in PHP... At least for now. 
No one wants to parse XML. I'd say JSON, specifically because I can easily turn a JSON object into a PHP Object and store it.
Both this rfc and scalar objects can co-exist nicely.
It's a major version bump, why are we still giving a shit about BC? backwards incompatibilities are to be expected.
What do you mean by this?
I'm definitely using this instead of homsestead from now on. I've got an apache homestead monstrosity I hack together differently every time I need to fire it up, but I bet I'll enjoy this better.
You don't fool me. I know the other one is the *real* Phil Sturgeon.
Not sure why you got downvoted. It's an important point. Getting bogged immediately into performance optimisation discussions misses the point and focus of an ORM.
Let the client specify the format they expect using the Accept header -- that's what it's for. If they say `Accept: application/json`, respond with JSON. `Accept: application/xml`, respond with XML. If your API methods internally deal with associative arrays, it should be straightforward to pass that output through a rendering stage to generate the appropriate format. Of course, you should also deal with incoming data in different formats, according to the Content-Type header.
i like your rfc, i was not complaining about it, just feeling sad that something that is such an obvious bug will live in php 7. like the ?: operator
Joomla as a platform is not bad but without proper management / leadership it's nothing but a piece of code. Joomla is nothing without extension developers! People don't use Joomla because it is easy, people use it because they find the extensions that fits to their project. As a developer, most of my project is not base on what CMS i need to use. It is base on my customers needs and I will study if the software is available and how difficult it is to implement. The choice of CMS will only come last once I found what software i need, and this is the situation for almost developers. If i need a community site, i know I have a good one in Joomla either Jomsocial or ES. For eCommerce i used VM previously but now WooCommerce. For a good forum, i know i hve a stable Kunena. Well if Jomsocial is available in Wordpress, we probably use wordpress.
miles for 9 years?
Well think of it's user first. Who care for the framework if not everyone can dare to use it since it either break or not possible to update? I have few 1.0 and 1.5 sites and they are all forgotten, too much work. 
&gt; It is base on my customers needs and I will study if the software is available and how difficult it is to implement I've found that in the amount of time I've spent... 1. Searching for a plugin/extension 2. Reading through whatever documentation I could to see how it works 3. Installing it and playing around with configuration 4. Finding out it only does about 80% of what I need (or less - often times less) 5. Diving into the source code to see how hard it's going to be to get that last 20% 6. Ultimately removing the extension and trying a different one because almost all plugins/extensions for all CMSs (Wordpress, Drupal, and Joomla) are poorly written ...I could simply write a plugin/extension from scratch that does *EXACTLY* what the customer needs, without the bloat and abstraction of 200 different settings/configurations that the customer *DOESN'T* need. And then I realize that if I need to write my own plugins/extensions, why am I even using a CMS at all at this point? Why would I want to do it in a sub-standard platform like Wordpress/Drupal/Joomla with a sub-standard DBAL, no proper PSR-4 autoloading support, no dependency injection container, no proper migration support, horrible-to-non-existent routing mechanism, sub-standard events/hooks system, and many other deficiencies - when I could write the same functionality in an *actual* framework like Laravel or Symfony, and do it faster, cleaner, and with tests? At that point, what is the CMS *actually* doing for me? Auth? A WYSIWYG editor and content CRUDDING? Tagging and taxonomy? All of that can be done in a day or less. Literally, 8 hours or less. Much less if I created a zero-assumption skeleton app with all of that in it and put it on Github for re-use later on. The basic problem a CMS solves for you: authentication and content entry, is so trivial to implement in a framework, that all of the baggage and assumptions that go along with a CMS are simply NOT worth it 90% of the time. The only time a CMS is worth it, is when your client doesn't want *specific* things, and they are happy to accept the limitations of the CMS and extensions you find. That is, they're happy with that "80%", and you never have to spend much time building new functionality - you simply spend time configuring what the CMS and extensions can do.
you are going to need a big spoon to stir that pot
Thanks!
His mom edited his post and removed the URL. Classic.
Good to know actually. I will do that next time!
Tastes best when taken with a bottle of PHPkoolaid...
&gt; what type of response return type is expected by developers What kind of developers? Masochistic .NET developers might want XML. Open source developers that know life is short want JSON. Front-end developers also want JSON, for obvious reasons.
Try using UNIX sockets.
While this is true, I think a great solution would be the addition of new collection types, like how Hack handled it.
 $string = "cdn.mobiopush.com/mobio.js?mobio_sitekey=e667bf06f6f57ca1bc68b9418173631b"; preg_match('/^(?&lt;url&gt;.*mobio_sitekey=(?&lt;key&gt;\S{32}).*)/', $string, $output); echo 'key = '.$output['key']; echo "\n"; echo 'url = '. $output['url']; when you run that you get: key = e667bf06f6f57ca1bc68b9418173631b url = cdn.mobiopush.com/mobio.js?mobio_sitekey=e667bf06f6f57ca1bc68b9418173631b 
Not necessarily. Scalar object overloading has already been proven to work, so this isn't really a concern. In any case, that would definitely be an error, as you're attempting to access a prop/method on a non-object (if not a string).
I would recommend using parse_url in combination with parse_str. The below implementation allows you to have a better idea what went wrong in the edge cases when the url does not contain the key. function getKey($string) { $parts = parse_url($string); if($parts === false) { return new \RuntimeException("Seriously malformed url"); } if(empty($parts['query'])) { return new \RuntimeException("Url does not have any parameters"); } parse_str($parts['query'], $params); if(!isset($params['mobio_sitekey'])) { throw new \RuntimeException("url is missing key variable"); } return $params['mobio_sitekey']; } $string = "cdn.mobiopush.com/mobio.js?mobio_sitekey=e667bf06f6f57ca1bc68b9418173631b"; echo getKey($string); 
I was about to comment on the OPs post, what a terrible terrible solution in this blog (no offense to the OP). This regular expression of yours is a far superior solution. Alternatively, if you don't want a regex, you can do it much simpler than how it was done in the blog: $string = "cdn.mobiopush.com/mobio.js?mobio_sitekey=e667bf06f6f57ca1bc68b9418173631b"; $url = substr($string, 0, strpos($string, '?')); $key = substr(strstr($string, '?mobio_sitekey='), 15); echo 'Your site url is: ' . $url; echo '\n'; echo 'Your site key is: ' . $key; 
parse_url is awesome
I have yet to see someone give a compelling reason for storing application state on the client. Citing lack of server resources is ludicrous as all the data is simply going to be shipped back over, decrypted, and unpacked into memory *on every request*. Session ID's exist for a reason.
Thanks for an efficient sol @jagibers :)
Well… rather objects are treated differently from arrays. Before PHP 5, regardless if array, object or scalar, they all were by-value and always copied. It was changed because people really nearly always passed their objects by reference. As opposed to normal arrays (or how often do you pass your arrays by ref?) Generally, a scalar method API is something we could consider, but please don't make the primitives objects. Seriously, what would be the advantage _there_? Except a hell of a BC break?
Interesting definition of a compiler you have there (insert boilerplate about how languages aren't interepreted or compiled, implementations are). The fact is that PHP runs opcodes in a VM and you can't run even "compiled" PHP without the PHP executable. That makes it effectively an interpreter.
Thanks for your reply. I am interested in PHP developers 
Thank you very much for your reply . I agree that this is a great solution . 
Arrays shouldn't be an objects. We should have some sort of typed arrays, but not Array-objects. Strings - maybe, but i only like the idea to have UString class.
I meant amazing * feedback 
I visit it to try to point out the factual flaws in most submissions. 
As horrifying as this is, it is not at all unique, a truly disheartening number of massive content publishers have WP in their stack.
It's unintuitive, but I'm afraid expected. The main process is the environment processing the request (in your case an apache worker, tut tut btw), and it's the processing of a request that sets the working directory and other super global stuff. You might say, why not copy the SAPI globals from the parent context; This presents the problem that not every SAPI uses the structures in the same way, so there is no globally acceptable way to do it. It's probably obvious, but the thing to do is basically this: &lt;?php class Child extends Thread { public function __construct(array $config) { $this-&gt;config = $config; } private function manifest() { foreach ($this-&gt;config as $key =&gt; $value) { switch ($key) { case "cwd": chdir($value); break; /* ... */ } } } public function run() { $this-&gt;manifest(); printf("Child running in %s\n", getcwd()); /* ... */ } protected $config; } $thread = new Child([ "cwd" =&gt; getcwd() ]); printf("Parent started in %s\n", getcwd()); $thread-&gt;start(); $thread-&gt;join(); ?&gt;
PHP isn't just OO language, it is multi-paradigm, this is i think a main reason for not doing such things. Also in order to arrays and strings became an actual objects you should do tons of changes in runtime to make it usable. If you wan't so - do it as PHP extension. Nobody won't stop you. But i don't think that this kind of things ever be in PHP out-of-box.
This is not a support subreddit for newbies, go to /r/phphelp instead if you want an answer. 
Ok thanks!
Seems like some very fair arguments. The immutability of a response object seems crazy.
When choosing a package to use, most people would include it via composer. If you release a new version, it might be better to keep the namespace the same. This way, a developer can branch their code, update composer to your packages new version, and run their tests. Otherwise they would be messing around updating all instances of your namespace to projectv2 or what ever. I personally would not use a version number but keep the namespace the same. However, if you want to enable users to run the projects side by side, you could do something similar to Guzzle, which uses Guzzle then GuzzleHttp for the newer version.
Maybe I didn't make myself all that clear. I do agree with you. I believe PHP syntax is the way to go with templating, like using Plates. I meant to say that I would prefer not to learn a custom templating syntax but do agree with using a decent templating system.
Upvote. I don't mind a good parody account, but it has to be obvious. On the other hand, trolling and impersonation are dickish and should be disallowed and burned at the stake. 
It's already covered as far as I can tell. A parody account for a community member falls foul of all three of the following guidelines, surely? &gt; * Please be professional. This is a technical subreddit, so the level of decorum is higher. &gt; &gt; * Jokes are fine, but they should be relevant and in good taste. &gt; &gt; * Trolling and abusive language are not permitted. We're easy-going, but such things are not conducive to good discussion.
My initial post may not have been very clear. I am not aversed to php templating systems, I just do not like custom syntax when PHP syntax is more than good enough. taking your example: &lt;?php foreach ($whatever as $w =&gt; $v) { ?&gt; This is &lt;?php echo htmlspecialchars($w)?&gt;. &lt;?php } ?&gt; Using a template engine such as php leagues Plates, and the alternative block syntax, you can have this: &lt;?php foreach ($whatever as $w =&gt; $v): ?&gt; This is &lt;?=$this-&gt;e($w)?&gt;. &lt;?php endforeach; ?&gt; While slightly more verbose, still does exactly what your blade example does, with the additional benefit of it being pure PHP, and supported by ide syntax highlighting without any extra effort. For the sake of saving a few keystrokes, I wont put time into learning blade when the same thing but more powerful can be achieved in native php syntax.
I agree, but (controversially) I feel the issue is with the moderation team rather than the content of the existing community guidelines.
No. Tag the release properly and Composer will take care of including the right version for its users.
i want to disagree here ... it really depends on WHAT KIND of data you are returning, imagine you returning geo location data or business reports, and you need only a small part of the data, then XPATH is always faster to get data then running through a lot of json objects but for all small returns json is certainly better i personally build my apis with selectable return type which is usually xml/csv/json, for all those apis which mainly have reporting functionality. the others are json only
I've had no problem testing Traits with PHPUnit - it may very well be using hacks under the covers, but it abstracts them away.
Why? What reason would there be to use two versions of one library at once? Has anyone ever done that with success?
1. It's horrible 2. What I meant was, it's made to be easy for people to use if they don't know what autoloading is, see edit. 3. [Behold!](https://github.com/googleads/googleads-php-lib/tree/master/src/Google/Api/Ads/Dfp) 5 versions of the same library living side by side, and yes if you pull this in from Composer you get all 5 and the autoloader has a bad time. Don't worry though, this library recently *deprecated* PHP 5.2 support, so it should be up to 2012 standards by about 2019. 4. I can tell by the pixels. Maybe 'probably' is a strong word, but to my knowledge a fair chunk of these sort of API consuming libs are auto generated to some extent.
There is nothing hacky about it. It just writes a lot of boring code for you, so you save time. 
More to the point, how will forcing Response/Request immutability be a benefit? How will forcing people into the Middleware solution be a better solution to our problems? I'm in your boat - not on top of it enough to answer - but these are things I'd have to be convinced of.
+1 for blocking impersonation but also: &gt; he could have used a username like 'philsturgeonirony' or even 'philsucks' or something like that. Shouldn't be allowed either. Either this is a meant to be a place for decent discussion about technical issues or it can be a place where deliberate and personal trolling is allowed. I don't think it can be both.
yeah i could do that, BUT as we are all time to market driven: we have no gain when offering those kind of filters, so we rather shift the workload to the receiving side. 
euhm, don't we just need a mod with common sense?
But how long is that going to take to implement? Why not fix this inconsistency *now*, while we can? Even if scalar objects were implemented tomorrow, the native functions aren't going anywhere any time soon. So let's make them easier to work with instead of stalling until some mystical "perfect solution" surfaces.
There's no need for additional rules. This is already covered by [reddiquette](http://www.reddit.com/wiki/reddiquette)
Wow, what a fascinating blog. I loved reading that so much interesting content on one page and definitely not just an advert for the authors library with no real details of what it does. But where could I find more stuff from the author? Do they have a news letter or a maybe a book I could read? I searched all over the page and couldn't find anything!!1! /s Seriously though, please don't link to sites that have almost zero content, but instead are huge adverts for someone's book. 
I like the idea
Not sure if sarcasm or not.
Here in Germany most of software companies user PHP &amp; MySQL. We for example work in the HR business and all companies in this business use PHP!
Can somebody please explain the benefits of having these 2 object immutable? I have to join the crowd here and say I can only see problems with it...
Hi, thanks for the response. I did expect the reason to be the one you explained but I thought it should inherit the working directory from the parent. :-)
I knew someone would seize the opportunity ...
I also have no problem with testing private methods (using reflections) or static methods but i think that i shouldn't do it. This is why i like PhpSpec - it just don't let you write code that need this kind of hacks for testing.
Thanks, I'll check that out!
&gt;how will forcing Response/Request immutability be a benefit? Because it forces us to accept a new message. If we only pass by reference the request or response could change completely and we may never know. take the following example where we give a request to some listeners and they do whatever it is they want to do with the request. $this-&gt;request = new SimpleRequest(....); $this-&gt;requestListeners-&gt;handleRequest($this-&gt;request); .... $this-&gt;send($this-&gt;request); //$this-&gt;request = instance of SimpleRequest all good? well no. Because our ApiSecurityListener has spotted that we are not authenticated and being a good listener it has returned an ApiAuthenticationRequest in order to authenticate our client. Being a good listener it built a new request instead of modifying the existing one. but we have now lost it. We dont know it ever existed and you are going to pull your hair out looking for why you keep getting an authentication error. $this-&gt;request = new SimpleRequest(....); $this-&gt;request = $this-&gt;requestListeners-&gt;handleRequest($this-&gt;request); .... $this-&gt;send($this-&gt;request); // $this-&gt;request is now an instance of ApiAuthenticationRequest If I give you a request to look at, and you tell me you will give me one back, Then I shouldnt be upset if you decide I need a better one. I gave, you returned, I listened. We are both happy.
It already is a new major version. But then I get class name conflicts if I have both installed. If I change the top level namespace of the new version like e.g. Symfony has the Symfony2 namespace I can avoid that
Yeah, I'm not knowledgeable enough of this stuff to form an opinion. Why is immutability being pushed in the first place? What theory is it based on?
&gt; why use the same object? Because with a mutable API, the first method is much, much more intuitive. Everyone loves method chaining and it's used everywhere extensively. With a PSR-7 HTTP implementation, users would silently incur massive costs just by using method chaining. That's scary.
If everyone follows the standard I think it makes writing generic components that hook up to &lt;insertPSR-7HTTPImplementationHere&gt; without much problem. That's the kind of stuff FIG is interested in, interoperability. 
Phil sturgeon and Taylor Otwell got into it last night and erupted on Twitter. Chris Hartjes was involved for a bit. 
I liked philsucks more, but it was already taken. Btw,sorry for the shitty joke nothing against phil, and all against impersonation. 
Looks nice! However: looking for the 'object' in this and I'm not sure I see it. Looks like it's another DBAL to me, not an ORM.
Thanks. Calling it a DBAL might indeed make more sense.
Excellent, minimal DBAL design. Beautifully implemented. Kudos on using beating SensioLabs Insight!
&gt;Because with a mutable API, the first method is much, much more intuitive. It is also much more prone to causing bugs in software as I [point out above](http://www.reddit.com/r/PHP/comments/2xw1ky/issues_with_psr7/cp415u9). You cant force somebody to listen for a different response, if you cant force them to listen. That is what immutability forces. &gt;Everyone loves method chaining and it's used everywhere extensively. Not everybody loves it, there are people grumbaling about the issues method chaining can cause. I agree that some parts of immutability can be a pain in the ass, but I can see the reasons it was done in this particular case. Much like why we now have DateTimeImmutable, that was only an object that holds a string and look at the cluster of headaches mutability caused there. &gt;With a PSR-7 HTTP implementation, users would silently incur massive costs just by using method chaining. That's scary. No it is not, scary is passing an object around like its some sort of global, allowing any dirty little listener to do what they like to it and then not checking that they actually gave us the same object back.
am I the only one who think these.. function_arg ← func_get_arg function_args ← func_get_args should just be ... argument ← func_get_arg arguments ← func_get_args the rationale is that "arguments" are not part of the function definition per-se as they are part of the invocation at runtime 
&gt; Why is immutability being pushed in the first place? What theory is it based on? https://github.com/php-fig/fig-standards/blob/master/proposed/http-message-meta.md#why-value-objects HTTP is stateless. If all of a request's attributes are the same, it's the same request. If all of a response's attributes are the same, it's the same response. Requests and responses don't have an identity beyond the sum of their parts. If one of those parts change, it's no longer the same message. Value objects are the correct way to represent them. The streams being mutable is unfortunate, but I understand the [why of it](https://github.com/php-fig/fig-standards/blob/master/proposed/http-message-meta.md#why-are-streams-mutable).
Yeah... mods, don't be dumb-asses here - this kind of behavior should warrant a ban under the existing rules (as pointed out by /u/williamgbuckley). Why would you tolerate that kind of crap? It's wrong that you should have to ask the readers to step up and support your point; **instead, us readers should be asking the mods: "WTF?"** 
&gt; Much like why we now have DateTimeImmutable We can have DateTimeImmutable because no matter what happens it's a *tiny* value object, so cloning costs are minimal. An HTTP request, on the other hand, can be arbitrarily large depending on the payload. &gt; No it is not, scary is passing an object around like its some sort of global That is *also* scary, but you didn't reply to my point. Having an immutable API where every method chain is a cloning operation is *horrible* for performance (both CPU and memory wise) with arbitrarily large request payloads. *That*, in my opinion, should trump all other considerations anyone might have.
I guess I'm not sure the term 'DBAL' is any more obscure than 'ORM', but as far as I know 'DBAL' and various expanded variants ('DB Abstraction Layer' or sometimes 'DB Abstraction Library' etc) seem to be pretty commonly accepted for packages like this. I guess I don't really know of any other names in common use. 
wouldn't this rfc affect the language?
Not in the sense that the engine changes or that what is possible in userland changes. The code that needs to be changed is in an extensions, [mostly in the intl extension](http://lxr.php.net/xref/PHP_TRUNK/ext/intl/) which are not part of the language, they're part of the standard libraries that PHP ships with.
&gt; Let's say you have a Request instance with a 50MB payload. You now have to clone that payload every time you call a method on that instance. That, to me, is insane. I agree, unless that payload is represented as a stream. Streams (the body) are shared between instances. It's one of the complaints in the post -- and its a valid one. Not sure how it would deal with large request bodies are just url encoded (eg. normal values). I would caution that PSR-7 is just a set of interfaces at this point. No real implementations have risen to the top as well optimized and good. It may be that we'll get those optimized things later and the cloning of large requests becomes a non-issue as work arounds are found.
I believe this is the link that should have been provided. http://booboo.thephpleague.com/ 
&gt; cloning of large requests becomes a non-issue as work arounds are found. Sure, but that's not really a solution is it? If we have to fight the PSR and introduce implementation specific workarounds, then what's the point?
o_O What if the file has not extension?
Right now it's a lot closer to deliberate trolling. Mention anything about a framework or CMS that someone finds inferior, they'll post a snarky off-topic comment and get up voted to hell, mean while people on topic that maybe use the platform everyday get ridiculed and down voted. PHP'ers have such an inferiority complex when people from other languages insult them, but have no problem trashing what the deem inferior. This too me is a much bigger problem on r/PHP right now and is the reason this community is completely toxic. 
The point of a templating system isn't different syntax, it's to take advantage of features and plug into your controllers easier for presentation. There's a reason why templating systems are so pervasive and people tend (for lack of a better phrase) look down on PHP mixed with code alone. That said, the custom syntax is barely custom, as I pointed out above. The only thing that changes is that instead of opening your foreach / if / whatever with &lt;?php you use an @ in normal code. Instead of using an echo, you use double brackets for a standard echo or triple brackets for a sanitized echo. It also makes composing your pages and reusing things much easier, which is one of the big goals of a template system. It took me maybe 15 minutes to figure out the ins and outs of blades and make extensive use of it... there's almost nothing to remember. Regarding your example, it's important to note that PHP short tags are deprecated and should not be used, so using &lt;?= is not proper syntax. I'm also not sure how your example is "more powerful" - in fact, that's not true at all. You can even use pure PHP in Blade templates if you want. Not to mention if you're using an established templating language (like Blade) syntax highlighting is available for just about any editor. I won't debate this too much because ultimately you need to use what you like best. I would suggest at least giving it a go before you completely dismiss it as too much to learn or not powerful...
Would that actually be a real issue though? COW should mean no extra memory needs to be allocated or copied to clone that 50MB request (assuming that none of the modifications you're planning to do involve modifying the actual request body).
Behat 3 is definitely the latest stable version - I'm not sure why Everzet has the docs pointing to 2.5 but please don't read anything into that.
&gt; you have a Request instance with a 50MB payload. You now have to clone that payload every time you call a method on that instance. That, to me, is insane. Why do you think that would be an issue? PHP uses copy-on-write for zvals - you wouldn't actually duplicate the 50MB of the request body, unless you were modifying that bit. If you're just modifying the other bits of the Request, e.g. the headers, or just duplicating the request body into a new Request object, it wouldn't be allocating 50MB of memory. 
I agree with that approach. The person did no harm other than having a name similar to philsturgeon's. That's not a bannable offense and phil needs to simply get over it. Now if the person actively starts impersonating him, then it becomes bannable, not before. I understand phil's frustration with it, but it's more important to be fair to everyone.
I think you're mistaken about Phil being overly sensitive, he's not the one complaining - WE ARE. [His only comment on the matter](https://www.reddit.com/r/PHP/comments/2xtept/thoughts_on_php_rfc_consistent_function_names/cp3g3qa): &gt; Imitation is the greatest form of flattery, or something. Maybe get your own username? &gt; Also I would love scalar objects. [Blogged about as much here](https://philsturgeon.uk/blog/2013/01/php-6-pissing-in-the-wind/). 
First of all, let me tell you thanks for this great package! Obviously I need to read the docs with more attention. Your first answer is the simplest and does exactly what I need. 
This is where RES's tagging feature comes in useful - if it doesn't have the BAMF tag, it ain't Phil...
Yea, one of the biggest issues I have with PSR-7 is the fact that it uses mutable streams with immutable value objects. I understand a lot of the strengths with immutability, but the mutable streams directly contradict them. Its a strange inconsistency and defeats a lot of the purposes, IMO. I understand the potential complexities of implementation with regards to streams and mutability, but as it stands it just seems somewhat broken in this form. :/ Regardless, I really can't wait for PSR-7 to become a standard... I just don't know if I can really respect some of its decisions at this time, unfortunately.
Strangely enough, /u/phpilsturgeon posted for four days in non-PHP reddits before he started trolling.
Glad I could help, and you're quite welcome!
There are many mistakes in the code. - Missing vendor namespace - Missing class, method and property comments (how do I use this? What's this argument for?) - Missing method visibility - Strange property order (class properties after the constructor) - Strange name choices (Base, getFkEnding) But moreover this is NOT ORM! The library returns an array, not an object (a model at that, not just any object), so this is not an Object-Relational Mapper, but an array-relational mapper, something PDO already does on its own in PDOStatement::fetchAll(). I can't see any use for this. It's badly written and has no purpose other than wrapping SQL in a few methods.
Thanks for the feedback! I'll take ur suggestions into account.
&gt;You just duplicated a huge payload when an in-place operation would be much faster. It would never be an in-place operation. If the body is the large part, and you're modifying it, then there will still be a large allocation, no matter whether the object containing the body is mutable or immutable. The only time it would be a problem is where references to both the initial request and modified request are active at once, and so the memory can't be reclaimed. &gt; my opinion is certainly in the minority here :) yep, IMMUTABLE ALL THE THINGS!!1! 
"Troll. Trolling does not contribute to the conversation." This user is obviously attempting to get users to think his comments are Phil's comments based on a casual inspection. Can you not see that? Just because Phil didn't handle this like you think he should doesn't make him wrong.
Looks neat.. One question: &gt; Relationship methods require that table names are singular - e.g. user instead of users. Why's that?
Thanks. &gt; Why's that? Because, by default, these methods expect that FK names are based on the names of the related tables. For example, `$Base-&gt;find('user')-&gt;has('post')` would expect a `post.user_id` FK. Does this make sense? I'd be happy to elaborate if it doesn't.
That's good to know, thanks!
I don't think he was saying it was a suitable solution. Only that it helps if you have it.
&gt; u Well, unit testing and regression testing are not equal. Actually, there are two types of RT. First one is needed to validate the build that hadn’t undergone changes for a long period of time. While the second type is to check whether the build had not damaged the other part of the application (exactly what did you talk about snowflake :) There was a good article on Ubertesters' blog, which distinguishes this types of regression testing: http://blog.ubertesters.com/regression-testing-everything-wanted-know/ 
Twitter has a very clear policy on this, that protects real users, parody accounts, and people with similar names. It is a solved problem and I'm pretty sure Twitter won't sue if you copy the wording right from their TOS.
Pretty happy with my new flare! But yeah, this is a policy that should be enforced. A moderator asking them to change their name is not so hard.
I see how it makes sense semantically, but not yet why it's a hard restriction. For example, if I have tables `posts` and `users`, and my foreign key is `users_id`. Wouldn't that work? Also, if this restriction is in place, how would you deal with words where singular and plural are the same? (like "sheep" or "fish") or where the singular is never used? ("trousers", "scissors")
&gt; I see how it makes sense semantically, but not yet why it's a hard restriction. For example, if I have tables posts and users, and my foreign key is users_id. Wouldn't that work? That's correct. I should probably change the text to make it more clear. &gt; Also, if this restriction is in place, how would you deal with words where singular and plural are the same? (like "sheep" or "fish") or where the singular is never used? ("trousers", "scissors") This wouldn't be a problem as long as the table name and the FK match. For the rest of the cases, the relationship methods provide a second parameter that takes a custom FK name. You can see an example about it in the README.
Unless you're in the .../.compact URL on mobile; then the flair says "The Real Phil Sturgeon".
Because its one of those features that require a huge undertaking with little to no gain. I'd rather the internals focus on more important issues or features.
&gt; this site was meant for sharing and building knowledge primarily but NOT REPUTATION If you simply drool or roll over on a technical debate over someone's username, reddit is not for you.
Somebody correct me if I'm wrong, but AFAIK, the people most responsible for the interface expect individual implementations to be mutable if they so choose (I can't find the source of that on the FIG google group right now though). I understand the train of thought in going with immutability as the default, but mutability seems to be a must for so many architectures. Although the interface itself doesn't reflect that, there's no reason why implementations can't be. Vanilla middlewares can still work on the assumptions that they are receiving a vanilla implementation.
You say that like it's a bad thing.
This is not true at all. The customer is an entity, because it has an identity. That identity does not change, regardless of what data you change on it. Using your same example, if you were to legally change your name in real life, do you become a new person? Did that change your identity? No, of course not. You're still you; you just have a different name now.
You wouldn't. And this, and the other problems could easily be solved with request/response builder factories that spat out immutable instances. But I've been told "now is not the time to go making major changes to the API." So, whatever.
Hi, You may want to look at graph databases for this kind of use cases. There are two blog posts on sitepoint for discovering Neo4j with PHP: http://www.sitepoint.com/discover-graph-databases-neo4j-php/ http://www.sitepoint.com/adding-social-network-features-php-app-neo4j/ It is using neoclient. NeoClient is a php driver for Neo4j and is using the symfony dependency injection component so integration in symfony is a piece of cake. You can ping me on twitter @ikwattro if you need some help for Symfony integration.
Well, don't take it too literal, then. $string-&gt;Length(); Whatever. Changed the original to match PHP syntax. Regardless of whether you define a string, int, boolean or custom object you'll either get the length if the method is defined or you'll get an exception. Yay dynamic typing.
Thank you. I'll have a look at it.
Yes, though really it's far more powerful than just things like "setting headers". By providing a common interface for requests and responses, it allows you to wrap or alter either one to add behavior - authorization, caching, validation, etc - without caring much about how each framework handles them. You probably got downvotes because your previous comment could be interpreted as an attack on the FIG, which wouldn't make sense because a framework-independent HTTP request/response interface is a great example of what the FIG can and should do.
Downvotes, because how dare you even try to be similar to the Almighty One And Only King Phil, and how dare you advertise your obviously shitty project!!! 
Exactly. League of Extraordinary PHPsirs only, please.
&gt; Symfony has the Symfony2 namespace Actually Symfony2 uses Symfony as vendor name. &gt; But then I get class name conflicts if I have both installed. Composer can help you with that. Look at "conflict" setting from composer.json "conflict": { "vendor/orm": "&lt;1.0" }, ### From docs: &gt; Lists packages that conflict with this version of this package. They will not be allowed to be installed together with your package.
I have used smarty before and have dabbled in blade a bit. Its just not for me. As for &lt;?= not being proper syntax, &lt;? is short open tag, &lt;?= is short echo tag which is permanently available as of php 5.4.
But I actually want them to be able to be installed together.
You are correct, that's *why* the example behaves the way it does. What I'm trying to say is that it's a bad/error-prone system. 1. The fundmental semantics of `=` are inconsistent, based on a hard-to-predict edge-case, creating *mutable copies* of a unique builtin type. 2. Keeping track of "arrays" vs "objects" is even *harder* due to the introduction of array-like objects, act like arrays only in certain ways(e.g. appending items) and not others (assignment.) So right now, programmers already have to keep track of whether it's an object, an array, or (in the middle) an array-like object. This gets *even worse* if you allow stuff like: $a-&gt;count(); // New method on all arrays, like what gearvOsh was talking about $a[] = "Appended value"; $a-&gt;count(); Can you tell whether `$a` is an array or an array-like object now? Plus it will break all existing code where someone already wrote: class MyCollection implements ArrayAccess { public function count(){ ... } ; // Now directly conflicts with "new array API" }
Can the real phillsturgeon please stand up?
Mmm I think it's because in this day and age everybody knows you start projects with Laravel. Even if you're not in PHP. If you're developing in C#, why are you not porting Laravel? Because who needs a framework with long term support? Everything is so dynamic anyway. Photons, energy and stuff. Relevant: Anybody know how I get to run my Laravel in this Arduino? Do I just hit it with the hammer? 
&gt;How about models? Your controller has access to a $customer? Why not have $customer-&gt;withName('Changed Name')? This way, if some other piece of the app got the hold of the $customer object it can mess it as much as it wants without disturbing the instance that our precious controller operates on. No, because a customer is not a value object. A customer is an Entity (Domain Entity, not Model Entity) it has an Identity, I actually really dislike the use of a Customer class, so I am going to refer to it as a Person (customer is a role, not an object). Now in the real world, If I change my name, I am still the same person. class Person{ public $id = 1; public $name = Bound_testicle; } class Person{ public $id = 1; public $name = Bound_testicle_improved; } See how I am still the same person, I have a different name, But I am the same person. Infact almost everything about me can change, my hair colour, my name, my weight, my gender, my height. all these values that make up me can change, but I am still me and you cant make me twice. Now lets look at a value object A Person has a name class PersonName{ public $firstname = 'Bob'; public $lastname = 'Smith'; } A name has no Identity so It is a value object, Its identity comes from the sum of its parts. So if we change the Bob Smith object to John Smith, it is no longer a Bob Smith because its Identity has changed. Now It is a John Smith. Now I see you thinking but what if I put a numeric $id field in the person name (like for a database) is it still a value object? well yes it is still a value object but now you need to be carefull of changing the name because you are going to change a lot of Bobs to John and they might not all be okay with that, so it is best if instead of changing a name, you create a new one.. just like our request. Now onto your question of sessions, is a session an Entity or a Value Object? A session represents one Person, they have an Identity assigned to them in the form of a PHPSESSIONID. The session much like A person can consist of many value objects but ultimatley it is an Entity so only one should exist.
Behat 3 works. Here is a simple [example test suite](https://github.com/mikedfunk/behattest) I put together to demonstrate it.
The Cheats Sheets is really useful http://cheats.jesse-obrien.ca/
I own a "specialized" Social Network / Dating Site since 10+ years with ~ 200k Members. Going now in the 4th "rewrite" completly in Symfony. I would say i'm "advanced" but doing a community in sf2 is quite a big task. It's not as easy as put a few bundles together. I'm +1 on doing that in symfony (doing it myself so), but i would rather recommend to you using like @heybige commented www.humhub.org (even when it's based on yii as it seems) or something like phpfox ( http://moxi9.com/phpfox ). Then you can rather concentrate on getting users and everything up an running. When you reach a certain size (at all), you could reconsider doing a switch. If you have any questions / need help, just hit me up :)
It is the Vietnam of Computer Science! http://blog.codinghorror.com/object-relational-mapping-is-the-vietnam-of-computer-science/
nope, was on mobile. should I leave it?
This is good reference http://www.sitepoint.com/best-php-ide-2014-survey-results/
first, i don't think sublime is IDE, it just another text editor. i personally use PHPStorm, it has a built in mysql browser, GIT Client, FTP Manager, live checking editing, PSR Formated. and more.. 
Oh yeah, it's a basic editor. Was simply stating what I am using currently, since I am looking to try out some new things. 
I like me some PhpStorm. I have written in vim, and other editors. I've also written in weird things like Dreamweaver, IDE's like Netbeans and Eclipse. (Never tried ST2/3.) But overall, I like PhpStorm best. Yes, it's written in Java, but I don't find that slows me down these days. It's extremely configurable, both visually and how it behaves. Its code sense is very smart. I feel, honestly, like it was made for me. I bought a license within a few days of trying it, and that is unusual for me.
go open source: netbeans 
Is that to get reddit karma above the point in which spam filters slow you down?
I downloaded the trial, set up my local testing, and have been messing around with it for about 15 minutes now. Goodbye Sublime is all I have to say. 
I use Emacs with [Projectile](https://github.com/bbatsov/projectile), [The Silver Searcher](https://github.com/ggreer/the_silver_searcher), and most definitely [Magit](https://github.com/magit/magit).
You are not alone. I've spent a year with PHPStorm but I keep going back to notepad++ even with its non-existent object autocomplete. Don't get me wrong, IntelliJ is glorious and the git integration is nice, the interface looks nice I dig the breadcrumbs, integrated xdebug support, etc. But I think the whole IDE is overwhelming for me. I have spent about 5 years coding in pure notepad and wordpad (it handled unix style newlines, notepad didn't) as a kid. (Side note: When I didn't have access to a computer I wrote code on paper and later typed them on the computer ;_; Not PHP, it was an AI in another language. It'd be crazy to write html without live preview :/). I moved on various text editor eventually, settled on vim for a while, moved to notepad++ and stuck with it ever since. In the past 3 years I've questioned myself and tried over 30 IDE/editors. In the end I shuffled between Aptana/PHPStorm/Komodo. PHPStorm is better imho. Komodo is full of potential and feels lighter, can be used for casual script editing, but the interface is full of glitches. I'd probably use Sublime if it had color autocomplete (in css) and better autocomplete and sidebar sftp.
&gt; Who cares. About 108 people, less anyone who cares enough to downvote it. &gt;This is seriously the most upvoted thread? It seriously is. When you order the subreddit by popularity, this one's at the top. The numbers don't joke. The links to do this for yourself are top of page if your incredulity persists. &gt;If you have a problem with the quality of the posts, well... ... ... don't go to open forums. You. must be new to the internet. Welcome! 
&gt; Please upvote if you feel that we need a rule against such impersonations. There may be no rule against impersonation. But there is a rule against saying that.
Not an answer, but have you considered using pcntl (forking) instead of using threads? I had to do parallel processing and found that forking is very easy to code and has no issues. Forking will work as long as you're on some *nix platform. 
While I do agree, the issue with that is then it starts to get complex, fragile, and you're reverting back to using SQL and still paying that startlingly large overhead. I received a lot of advice from other teams to avoid using an ORM on our project, and given my experience, the additional overhead, and the complexity of yet another system just isn't worth it when compared to a good design pattern and PDO. Of course with the footnote that the team I'm on was very comfortable with SQL.
If the app changes a header on a request received from a client isn't the request sent by the client the same. I understand the difference between Entities and Value Objects, I just don't buy the argument that a request must be a Value Object.
Ofcourse he is trolling because he is questioning a claim made by a php big shot, which 'does not contribute to the discussion'..hence TROLL! TROLL! TROLL!!!.... And my question was 'Why would he do that' if he is doing what you claim him to be doing...?'
The only thing more disappointing then the popularity of this thread, is the fact you are getting downvoted.
Up to you. Might be offensive to some
Hah, [that](https://github.com/phly/conduit#middleware) looks almost identical to ExpressJS. One problem I found with that architecture is that it doesn't easily allow for before *and* after middleware. e.g., a very common middleware logs an incoming request and times how long it takes. For that to happen the middleware needs to be invoked both before and after the request, and somehow maintain state between the two. How would phly handle that? [morgan](https://github.com/expressjs/morgan/blob/dafb4cd0682f95ab069c7a266303709054a1f40d/index.js#L108-L110) cheats and stores some state information on the request object, which you wouldn't even be able to do with PSR-7 because of the immutability. Seems like the PHP world is just now catching up with Node.js, but Node.js already moving on to a possibly better architecture. [Koa](http://koajs.com/), which is a new JS framework meant to supersede Express, depends on ECMAScript 6/harmony's generator functions. With them, that logger example can be re-written to something as simple as: app.use(function *(next){ var start = new Date; yield next; var ms = new Date - start; console.log('%s %s - %s', this.method, this.url, ms); }); The support for generators in JS, however, is currently quite poor. PHP, however, has had generators since 5.5, so I don't see why we can't just skip right on ahead and learn from Node.js instead of making all the same mistakes. N.B. one area I think Koa messed up is with the `this` object, which is a hybrid of both `request` *and* `response` *and* has special methods which simply delegate to their counterparts which means there are two ways to do one thing. That's a poor design decision IMO. --- Actually, now that I think about this more, that's a shortcoming of Phly, not PSR-7. If we actually read the PSR-7 interface, `getBody` is defined like this: /** * Gets the body of the message. * * @return StreamableInterface Returns the body as a stream. */ public function getBody(); Notice that it returns a `StreamableInterface`. So... I'm not really sure what the author's qualms are with the spec. Streaming does not appear to be a problem to me. The `StreamableInterface` has a method write, /** * Write data to the stream. * * @param string $string The string that is to be written. * @return int|bool Returns the number of bytes written to the stream on * success or FALSE on failure. */ public function write($string); Which implementers could use to pipe directly to `php://output`. So what's the issue? --- Okay, adding headers to response is still a minor issue. But all we have to do is take the best ideas from all 3 worlds: (1) we use generators as suggested by Koa, (2) we keep the immutable request/response from PSR-7, (3) we copy the middleware architecture from ExpressJS/Phly: function ($req, $res, $next) use ($monolog) { $time = microtime(true); yield $next($req, $res-&gt;withHeader('X-TimedResponse','JustAnExample')); $ms = microtime(true) - $start; $mogolog-&gt;addDebug("took $ms ms"); } You just have to pass along your new request and response objects to the next middleware. No references or mutable objects needed. Boom! That looks pretty beautiful to me actually. 
yes. there is a constant for that. echo PHP_OS;
When you publish code for various people to reuse, it helps to put in some library checking. if (!function_exists('curl_init')) { // throw exception -- need cURL } And a non-cURL approach as a backup is simply file_get_contents, which works on urls for most systems these days.
We've had this issue with Guzzle in the real world. Having a lagacy application use v3, then a new component being pulled in that needed v4. This was OK with Guzzle due to the namespace changing. If it's a package that people are likely to need 2 different versions of then at the moment a different namespace is your only option with PHP / Composer. It's not ideal though. Node's npm makes each dependency local, so you end up with many different (usually semantically similar) versions of a package installed. This gives more flexibility but at the cost of a lot more packages to manage, download, etc.
Similarly, echo PHP_VERSION; And yes, phpinfo() has that and a lot of other stuff. ---- Edit: find all PHP_* constants: &lt;pre&gt; &lt;?php var_export(array_filter(get_defined_constants(), function($a) {return substr($a, 0, 4) == 'PHP_';}, ARRAY_FILTER_USE_KEY)); ?&gt;
It's all clear to me now. And I am mostly of the same mind, except that I find it not so much disappointing as typical.
filter_var is to validate the url structure or format. But to verify that whether a link is broken or not we need to use either cURL or need to make a get_headers call.
Nice !!! 
I did it like this using [php_uname](http://php.net/manual/de/function.php-uname.php): $serverInfo = array( 'vendor' =&gt; php_uname('s'), 'version' =&gt; php_uname('r'), 'machine' =&gt; php_uname('m'), 'info' =&gt; php_uname('v'), ); 
One thingh though. Apache. Again... When people will learn that you need to give a choise - nginx, apache or both. Some people do not use apache at all, like never. It's strange, at times very resource intensive and - plain and simple - confusing.
If it's not obvious straight away, it's not very clever at all. Unless you're trying to say "You need to be a genius and have a PHD to make a page."
I had a nightmarish experience with curl url validation and sites that returned 404 while being displayed correctly on browsers. If the site admin is incompetent there's little you can do unfortunately. Also parse_url usually fails if you get a relative url or something exotic. Albeit thank you for your contribution! :-) 
I hope there is no one here who still uses notepad++ in 2015... Tell your coworkers to move to a new editor or IDE. Also, set CS up as a git hook, then it doesn't matter what editor is being used.
Why don't you write a real app of some kind and show that as an example?
Just as annoying is the sites that return a "page does not exist" page along with a 200 response.
If you don't grasp the concept of an identity (not a literal "id" datum, but the concept it represents), then it isn't going to make sense. You said you understood what entities and value objects were, though, so I assumed you did. Pick up a copy of Domain Driven Design by Eric Evans.
&gt; is this PhpNuke thing related to DotNetNuke? No. PHPNuke was the first CMS from PHP world. Official site is at https://www.phpnuke.org and source [on Bitbucket](https://bitbucket.org/phpnuke/phpnuke/src)
To be honest I actually thought that a fairy having some flowers is the most down-to-earth example of a oneToMany relationship. Perhaps I'll change it to Categories and Posts instead so it's more real-life like. I have considered using __call() but in that case it would be weird that doing $repository-&gt;query twice returns a different query instance every time. And yes, you can pass a closure to: $query-&gt;where(function($q){ $q-&gt;... }) As for using this over Eloquent: * Explicit separation into Queries, Entities and Repositories. I really hate when those are mixed, since it breaks separation of concerns entirely. In Eloquent after you fetch an object from database and pass it around, that object can still be used to generate queries, create more objects etc. In PHPixie an Entity is just an entity, and you are 100% sure it won't be querying database * Say you want to like all Posts by a certain author to some certain Tags. In Eloquent you'd have to do it step by step (get posts, get tags, link together) resulting in multiple queries. PHPixie ORM will do it all in one query ( there is an example of that in the quickstart btw ) * Support for Mongo. If you use it. * [~100% unit tested](http://phpixie.com/coverage/orm/ORM/index.html) plus with additional functional tests covering about 76% . Last time I checked Eloquent was only about 50% tested. * Your own custom model classes will be super easy to test and mock, since they are done with composition and don't realy on the underlying framework classes. You will never need to fixtures to test your logic. * Additional candy like Placeholders, nested containers, transactions and more that I will describe in next examples.
If you aren't worried about your bandwidth or execution time overhead, you could do a cURL HEAD request. $ch = curl_init(); curl_setopt ($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt ($ch, CURLOPT_URL, $url); curl_setopt ($ch, CURLOPT_CONNECTTIMEOUT, 20); curl_setopt ($ch, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT']); // Only calling the head curl_setopt($ch, CURLOPT_HEADER, true); // header will be at output curl_setopt($ch, CURLOPT_NOBODY, true); // HTTP request is 'HEAD' $content = curl_exec ($ch); curl_close ($ch);
One way is to do some processing of the data before handing it off to the chart. You can prune the data to only include items on or after this start time. Then check if there is a data set for that start time, and if there isn't add an empty result set for that time. 
I might be misinterpreting your suggestion, but the example already does make a HEAD request?
It's a pointer you dummy
 foreach ($db-&gt;Person("#x.@author#book and #book.@books=?", $bookshop) as $n) { echo "&lt;li&gt;",$n-&gt;firstName," ",$n-&gt;lastName,"&lt;/li&gt;"; } that is some funky query syntax
Points, points, points... LOL
RedBean is awesome. It's not a graph database, though ;-)
I use [Doctrine DBAL](http://www.doctrine-project.org/projects/dbal.html) which is a thin-ish layer over PDO. It's a *huge* timesaver and help -- convenience methods like `insert`, `update`, `fetchAssoc`, etc.
&gt; I hope there is no one here who still uses notepad++ in 2015... What would you suggest as a valid editor alternative?
Free: Netbeans. Paid: PhpStorm.
&gt; ~100% unit tested plus with additional functional tests covering about 76% . Last time I checked Eloquent was only about 50% tested. 100% test coverage should not be a goal. You need to test just enough in order to not be afraid to change things without breaking something. 
Sure about that? This works: $url = "http://maps.google.com/maps/api/geocode/xml?address=400+Broad+Street+Seattle+WA+98109&amp;sensor=false"; $content = file_get_contents($url); $xml = new SimpleXMLElement($content); $lat = (float) $xml-&gt;result-&gt;geometry-&gt;location-&gt;lat; $lng = (float) $xml-&gt;result-&gt;geometry-&gt;location-&gt;lng;
It's very common to create *thin* wrappers over libraries/core tools either at a framework level or at a custom application level. From my experience it just allows for a lot more flexibility/customization to be done. A lot of time you use this to abstract away issues between the "driver" portion (eg you could create a generic cache library that works with multiple cache systems (memcache,redis,etc) generically). I know PDO does some of this for you, but you can also do things like figure out how to get insert id(s) back in a consistent manor, generic inserts that work across different dbs, fetchById type deals, etc. Some of these helper methods may be useful for your particular app, especially if you use the same tool you created in other projects. Basically create the thin wrapper, which has nearly 0 performance penalties and as you need the functionality just add it there which is a million times easier then retrofitting it to something that uses PDO directly when you already have tons of calls down the road.
Something must be seriously wrong with this project if the home-page has a top download list and articles on games
Up to an extent, True. Actually, It depends on you and your application requirement that what is required http status code to consider a link valid. Like, say my application need very strict handling then I will only consider 200. For someone, anything else then 4xx and 5xx. But yeah, generally we can say that anything except 4xx and 5xx is valid. 
I've been developing php applications for 15 years. These psrs are getting pretty fucking annoying. That's all I'm going to say about it. I know it's not helpful, but this shit is getting kind of ridiculous.
What is a graph database?
What rules did they change that killed your comapny?
I really like the Aura SQL. Its a PDO wrapper that is really nice and give some abilities base PDO doesn't have.
For writing PHP I wouldn't recommand a text editor, as others already said the best IDE i s probably PHPStorm, or netbeans if you can't pay for phpstorm. For editing text, my absolute favorite is EmEditor. It's the only text editor I found that manages to open 4 GB files instantly and without trouble on my modest computer.
When I tried to make a pdo-wrapper some people said, that the PDO class didn't need to be wrapped, as it was simple 'as is' but I went away and made [a tiny wrapper](https://github.com/samayo/Leaper) and has been using it since then. Its just a wrapper and nothing else, so yeah ... nothing special, but it gets the job done anyway :/
Hmm, really lame that they got rid of the Amazon RDS addon. Do you have pricing tiers or is this in like a free beta stage right now?
Phpstorm can be free get the phpstorm EAP version. It's free
Why not IDEA? https://www.jetbrains.com/idea/features/php_editor.html
I do it for adding on features like off-site backups (with encryption) and restorations as well as easily exploring the schemas or settings.
My feels. They hurt. Change your name buddy.
Okay.jpg
Messaged the mods with examples of other throways used to promote that site, hopefully it'll be enough.
I'd still be curious to see some benchmarks compared to Neo4j and others...
I can only see it being painfully slow under any kind of real world usage.
What's your setup for running Visual Studio the most efficiently? It's a resource hog. 
I burn code onto CDR's and post them to my data centre. Express Delivery is used for urgent bug fixes or tight project deadlines.
It's free, except when there's more than a month between releases (IIRC it happened a couple of times in the last year or so). Still a good tip though =)
I just smash it on Heroku these days to save all the f**king around, but eventually I'm sure we'll be back to Chef or Capistrano.
Chef + teamcity
It's actually the second web based graph database created with that name, graphenedb.com
troll level 1000.
Only skimmed it, but it would highly recommend changing your folder structure to represent your domain instead of your framework. So instead of: - Entities - Repositories - ValueObjects You would structure it like: - Order/Order.php - Order/OrderLine.php - Order/OrderRepository.php - Order/OrderLineRepository.php That way things that belong together are in the same folder. This also makes it a lot easier to refactor parts of your application out into their own package and has other benefits too.
ssh/phing/git from within the vagrant machine. VPN tunnel required prior SSH connect. The "deploy" process does a few things: - run tests - lint sources - ensure git working copy is clean - clears app specific caches (models, etc.) - reset opcache - notify the team a deployment was performed (hipchat)
If you have a problem - then you don't have an abstraction.
So what of old PHPixie without 100% test coverage? would you suggest that isn't used for sensitive production code? 100% code coverage isn't really a feature. It's *typically* a side effect of TDD, and it really is for the maintainers of a package. There are other ways to test. For example, you could have built your ORM using PHPSpec... and you'd have no coverage information if you did. Are you saying you'd never use something built using PHPSpec for sensitive production code? What about behat? codeception? 100% code coverage is a side effect of a particular style of coding. And it's beneficial *largely* for the maintainers of a package.
This was literally posted 2 days ago: http://www.reddit.com/r/PHP/comments/2xtept/thoughts_on_php_rfc_consistent_function_names/
We use DeployHQ linked into our BitBucket at work
It might be because it does some optimizations that are specific to MySQL..?
If you can find time to watch it, I can highly recommend [this talk](https://www.youtube.com/watch?v=WpkDN78P884). Uncle Bob can explain it much better than I could. The gist is that if someone looks at your folder structure he should be able to tell that it is an e-commerce app instead of "mvc", "command-bus" or whatever else is in fashion at the moment. Also your approach leads to a lot of folder skipping that slows down development from my experience (I went with your suggestion for a green field project a year ago and I really regret it these days. It's hard to find related things.)
Nope, no way. 1. Installation by "unzipping" 2. Missing or partial comments 3. Crazy unreadable query syntax - Crazy custom syntax for definitions - Bad code practices like - manual requires, - methods not sorted by visibility, - multiple classes in one file, - freaking \Exceptions everywhere, - magic strings ("sub_ok", "ob_ok"...ok?), - cryptic names like "l, v, tr, tltr, ltr, ok", - arguments passed by reference, - conditional branches without braces, - fucking unreadable spaghetti code I mean [just look at this shit.](https://github.com/xzoert/graphene/blob/master/src/Prop.php#L378) if( $this-&gt;dir==1 ) $tl=$this-&gt;storage-&gt;getTriples(null,$this-&gt;pred,$v,$this-&gt;type); else $tl=$this-&gt;storage-&gt;getTriples($v,$this-&gt;pred,null,$this-&gt;type); No - fucking - way.
What do you mean by "folder skipping"? I'll definitely watch the talk. thanks!
Robo http://robo.li can be used for deployment. It has tasks for SSH, Git, Rsync, and Docker and much more for writing deploy scripts easy to use and maintain
Thanks, I must have missed it!
He means if you are dealing with a Person you need to jump from the Entity folder to the Events folder to the Handler folder to the Service Folder.
Here is my effort: https://github.com/terah/fluent-pdo-model It's still being heavily developed and needs more tests/examples. I'd appreciate any feedback.
**Warning:** Don't copy and paste that code! It uses weak conparison instead of strict. You should always use ===. 
I &lt;3 Heroku and I'm not afraid to say it.
Does this approach allow you to run Composer install on deployment? Or even other commands, like database migrations?
or GIT
See my comment below. You could fall back on get_headers if cURL is missing.
lol
Sounds pretty slick, thanks for sharing. I'm actually doing a talk on deployments at Midwest PHP in a little over a week, so it's helpful to learn how people are actually doing this in the "real world".
*Never underestimate the bandwidth of a station wagon full of tapes hurtling down the highway.* –Andrew Tanenbaum, 1981
Quite insensitive 
I thought that was an extremely good talk, thanks for sharing that.
I haven't used their service so I can't speak to the quality of their instances. However, from what is publicly available I can point out some differences that developers may find important. ClearDB is a multi-tenant solution. Applications share hardware with other applications which has the potential of leading to competition for resources. JawsDB will provide each customer with root access to their own instance. All permissions are yours and each instance will have access to 1 dedicated cpu and 1 GB of RAM **at the very minimum**. Higher tiered plans will offer much more. ClearDB's highest offered plan for Heroku is 10 GB with 40 connections. Meanwhile Heroku's own postgres plans extend up to a full terabyte and 500 connections with many options in between. JawsDB hopes to provide more comparable options for applications that are growing or want the room to grow. Our lowest plans will support at least 60 connections and we will support storage capacity much more comparable to Heroku's own postgres addon. Lastly, ClearDB provisions their Heroku instances on the Microsoft Azure cloud platform whereas JawsDB will use the same cloud platform as Heroku, Amazon Web Services. The servers we provision will be located in the same AWS geographical region as your Heroku instance which will improve latency between the two services.
JawsDB sounds like a great service, i'll check it out
I use [deployer.org](http://deployer.org/) ([Github project](https://github.com/deployphp/deployer)). It's a PHP based deployment too very much like capifony/capistrano. Being written in PHP means the deployment config files are php based. It can be packaged up as a phar file allowing you to deploy from anywhere with a php interpreter (and required extensions). I gave a 5 minute talk about it to the Thailand PHP User Group. Video [here](https://www.youtube.com/watch?v=XbbtSsgUI_k) and slides [here](https://docs.google.com/presentation/d/14TlHO8JgVq0OIiHLgOcjceoLSQvmRoEnNYz2U2qIw8Q/edit?usp=sharing). **edit** *disclaimer*: i have contributed to the project
Hah, a very apt statement!
I tried it out, i really like the Dashboard.
It doesn't. It's an example to illustrate the point of thinking in components. 
Use beyond compare to sync my local folder to my vps
[Rocketeer]( http://rocketeer.autopergamene.eu/#/docs/rocketeer/README)
Thanks :) thats exactly why i post. I love talking about this stuff and learning from others. 
Ansible. We started with a handmade bash script that connected via ssh and did the deeds.. but it got out of hand. Bash is pretty hard to debug and understand. Then I started porting it to rocketeer, but I quickly realized that it wouldn't have worked out. So I did some research, and it was a battle between Ansible and Salt. Ansible won because of its simplicity. 
Server is Windows, can't switch to Linux.
I'm not sure that kind of structure is possible with Doctrine ORM. Seems they all have to within the same namespace.
ah, right. that comment *did not* make it through moderation and *isn't* second in the list. next, i'll be told it broke rules in the note contribution guide. you win again, internet.
I use PHPStorm deploy function, it's probably dirty but it does the job :D
I use gulp (running tests, prepare build) and Ansible (server provisioning and deployment) but want to use Docker instead.
Serious question, why is there is no good documentation tool in existence right now? When it comes to Laravel docs, I have fantastically scannable, example-based documentation, but then the API stuff is in a totally separate and horrendously unusable system. Meanwhile, if I want to know how code behaves, I have to go to github to see the actual code. Why isn't there a tool that just combines everything together? 1. Lets you create a documentation story like Laravel's primary docs 2. Lets you provide additional / extended examples (more like Symfony's Cookbook docs) 3. Lets you browse the public API with a simple argument/return signature, nicely compact and in one line 4. Lets you toggle it to see the actual code, right there in-line with the documentation story I have yet to see a good documentation tool that lets package owners provide documentation in this way?
k.
Since there's no further information about it there - the only commits in over a year on the 2.0.3 version is to change a weak comparison to a strong one: return $persistCode == $this-&gt;persist_code;
It is incorrect. It's only usable in the Ukraine. The 2 letter country code for the UK is GB! =P
Yes. Fork the repo, edit the code, write a new Command class and register it with the CLI framework.
Yay for ansible, such a great orchestration tool !
[Every time you use a weak comparison operator, God kills an elephant.](http://www.reddit.com/r/programmingcirclejerk/comments/2v0hoa/artisan_php_framework_achieves_webscale_security/coe53zm)
Composer documentation has a section about [Writing Custom Commands](https://getcomposer.org/doc/articles/scripts.md#writing-custom-commands).
git pull from dev to staging (when tests are green) then rsync that up to production (excluding a few config files, and data) 
Thanks, I will try this out.
Fantastisch. Euh... Waarom post je dit?
True. And this bothers me greatly because TLDs.
Mercurial still has hooks - http://hgbook.red-bean.com/read/handling-repository-events-with-hooks.html
My employer uses shared hosts for all our PHP apps, so I'm stuck with FTP. I'm also the only person who knows how to use git or anything similar. My boss simply edits files live on the FTP and refuses to learn anything new. Not even trolling :/
I was unaware that phpspec had coverage now. It wasn't on the official roadmap when last I looked. &gt; Code coverage from behat ia rather useless, since you are asserting only the end results of a page, for code coverage to make sense you have to have a lot of assertions like you do in unit tests. That's one use for behat, but you can assert loads of things with behat without ever actually having a "page". It's an integration test. You can throw it at just about anything you like. Your step definitions can create objects and verify those objects etc.. not hard to do. &gt; That is why I stressed that it is Unit test coverage. It means that each part has been isolated and meticilosly tested. A unit test is isolated, sure, but it isn't necessarily meticulous. You can write very low rent unit tests if you want to. &gt; What 100% code coverage tells you is that the develop took time to inspecr every class and that you should not expect some stupid bugs.Take it as a seal of quality Sorry. But bullshit. Total utter fucking bullshit. All 100% code coverage tells you is that 100% of the lines were executed during the execution of the test suite. That's it. It tells you nothing about how isolated those tests were for a start - you can touch as many collaborators as you want and you can execute every code path without asserting *anything*. The ONLY thing 100% code coverage tells you is that all the lines were executed by the suite. Period. As a veteran project manager, I can tell you from the bitter lessons of experience that if you create a policy of 100% code coverage on a project, you'll get it...but your defect rate will remain the same. That is to say if the only goal is 100% coverage it is simultaneously easy to achieve and utterly useless. Seal of quality? Hardly. That's *not* what unit testing is for. If you think that's what unit testing is for you need to go back and take a look at the literature again. Saving you from 'stupid bugs' is a nice side effect, but unit testing is a design and refactoring tool. That is to say if you have decent coverage with *quality* tests that correctly exercise your application you can refactor with confidence. It also drives a decoupled approach to design if done correctly... but *neither* of these concerns are concerns of the consumers of your code.. The unit tests exist for the people developing and maintaining the code. Potentially extending the code. Sure, it's a bit of a red flag if there are *no tests* on a library you are using, but to claim that you would never use something that wasn't 100% covered by tests, especially in light of the fact that "100% code coverage" is a new revelation for your projects smacks of putting yourself on a pedestal.
While the official ISO 3166-2 code for the United Kingdom is GB, the ISO 3166-2 country code UK is exceptionally reserved and implied meaning of United Kingdom at the request of the United Kingdom.
thanks, TIL.
I actually moved from Netbeans to Sublime after Netbeans broke spectacularly.
just type 'I hate PHP' and hit enter :D
Ouch :(
What's more annoying is that we've only just been able to start registering .uk domains. Previously it was .co.uk only.
you can configure where certain namespaces get their mapping. I actually go over that in the [second post](http://programmingarehard.com/2015/03/05/structing-my-application-contd.html).
Why are they not using `password_verify()` here?
To be fair, it got substantially better when upvoting was first made available, though comments like the OP risk making things worse now. Perhaps PHP.net maintainers should consider downright deleting punny/joke/extremely low quality comments altogether.
Because it is not a password, but a randomly generated string. The persist code is not the password, it is more a token to stay logged in. 
Use `hash_equals()` then! https://github.com/resonantcore/php-future EDIT: Wait, persist token? https://resonantcore.net/blog/2015/02/remember-me-safely-secure-long-term-authentication-strategies
1. A lot. Before you can list encrypted extensions in JED, then they change that. Many developers disappear due to this. 2. You cannot sell an encrypted extensions in your website if you have another extensions listed in JED. In short, they own your business as well. It's none of your business if I am selling products not inline with Joomla rules, it's not even listed. When they changed this, i lost 50% of my business right away. People does not need to buy 2 licenses any more since they can use it unlimited.
I'm not sure how big a concern the immutability will be in practice. You can make a mutable response class that implements the interface and takes on mutability as well.
This is asking the wrong question. The issue isn't with CSRF tokens, but rather with your rewrite rules. Post those instead. 
One way of doing CSRF is, like you said, to create a randomly hashed session token, and serve it and insert it into the current page's POST forms. When those forms are submitted, it includes the CSRF token unique to that user (should be recent enough) in the POST. The server should compare the user-provided CSRF in the POST with the one stored in the SESSION. Thus, if you are having issues reading the CSRF from a POST, then you must not be able to read any other variable from the POST. Fix that first, then worry about the CSRF.
Where I submit it from is in /thread/x/comment/y/ if it helps at all ErrorDocument 404 http://localhost/x/index.php RewriteEngine On RewriteRule ^thread/([-_A-Za-z0-9]+)/comment/([a-z0-9]+)/?$ index.php?thread_view=$1&amp;comment=$2 RewriteRule ^thread/([-_A-Za-z0-9]+)/comment/([a-z0-9]+)/?$ index.php?comment=$2&amp;thread_view=$1 RewriteRule ^profile/([A-Za-z0-9]+)/?$ index.php?profile=$1 RewriteRule ^thread/([-_A-Za-z0-9]+)/?$ index.php?thread_view=$1 RewriteRule ^profile_nuise/([-_A-Za-z0-9]+)/?$ index.php?query=$1 RewriteRule ^profile_nuise/([-_A-Za-z0-9]+)/notifs/?$ index.php?query=$1&amp;notifs=all RewriteRule ^profile_nuise/([-_A-Za-z0-9]+)/find/([A-Za-z_-]+)/?$ index.php?query=$1&amp;find=$2 RewriteRule ^profile_nuise/([-_A-Za-z0-9]+)/find/([A-Za-z_-]+)/?$ index.php?find=$2&amp;query=$1 RewriteRule ^profile_nuise/([-_A-Za-z0-9]+)/find/([A-Za-z_-]+)/submit index.php?find=$2&amp;query=$1&amp;direct=$2_submit RewriteRule ^sg/([-_A-Za-z0-9]+)/?$ index.php?snowglobe=$1 
php easter eggs -brought to you by javascript
I don't understand if you are able to post normal form fields why you can't correctly post a hidden form field with a token in it? The only important criteria for the token is that it can not be guessable by someone, it isn't mandatory that you base it on the session id or even store a copy of it in a session variable (doing those things just make it easier not to fuck up). As a simple example: hash_hmac('sha256', $_SERVER['REMOTE_ADDR'], date("Y-m-d G")."1-of global salt!") Creates a new nonce token for every ip and every hour, you don't need to store the value server side since you can just calculate it for the current hour and last hour to verify it. There are plenty of things you can add to it like script name, logged in user id, server name, salt it with the names of all your form variables, take it to the minute level and expire it every 20 minutes. Sure I would still rather involve session variables or session id but for preventing CSRF this will work.
I think he is saying that his session is not persisting between browser calls when he is doing URL rewrites. This sounds like an improperly configured session problem not a CSRF problem. 
Why are you redirecting POST requests?
The United Kingdom (UK) != Great Britan (GB). Great Britan is a part of the UK, which encompasses more than just GB.
I'm not? The redirection was caused by ErrorDocument line, not any PHP code I had.
Normally you only change that on escalation or demotion of privileges but even so the values in your session should persist giving you a secure method to store server side values.
If a php script generates javascript it still counts as php right?
I think i've come around to your way of thinking. I'm going to whip up another post this weekend. Thanks for the suggestion!
You have two redundant rewrite rules: &gt; RewriteRule ^thread/([-_A-Za-z0-9]+)/comment/([a-z0-9]+)/?$ index.php?thread_view=$1&amp;comment=$2 &gt; RewriteRule ^thread/([-_A-Za-z0-9]+)/comment/([a-z0-9]+)/?$ index.php?comment=$2&amp;thread_view=$1 So any request to `/thread/x/comment/y/` will be rewritten using the first rule from the top, from which might result your problem.
My micro-framework [Bullet](http://bulletphp.com) does this, and people love it: https://github.com/vlucas/bulletphp/blob/master/src/Bullet/Request.php#L118
What simple comments? Every comment I ever see is some bat shit insane example/application of how to make the function do the things it can't do, rather than a simple example of what it CAN do and how to use it...
Nice, I'm building something like this atm, will give it try :)
If you offer them the first method, I have a felling that they will end up with: $sess1 = new Session(); $sess2 = new FrontendSession(); And after 10 minutes (_or 40 lines after ; just finished a code review with something similar_) they will forget which is which. So I will go with second approach.
Stick to Language constructs, and don't reinvent the wheel. http://php.net/manual/en/class.iterator.php What is more readable? $collection-&gt;each(function($item) { // code }); or foreach ($collection as $item) { // code } or while (list(, $item) = each($collection)) { //code } Seriously, don't reinvent the wheel, or you will hate yourself in 3-6 months.
phantomjs, wkhtmltoimage and shell exec. If you want do this in clear PHP - you have to write HTML&amp;CSS&amp;Javascript engine inside this language. Do you have a lot of time to do this? i don't think so :)
thank you for pointing this out! going to fix it right now :)
glad to hear that
Thanks I'll take a look at aura/accept
This is awesome.
It's not like the two languages compete. PHP is back end, Javascript front end. They don't even touch each other without at least some HTML in the middle. Just wanted to point that out, since the tone of that was kind of "a point for Javascript!" It's the front end of the website, of course you're gonna use Javascript to navigate.
add a line to your hosts file that points yourdomain.tld to 127.0.0.1 more than likely you are getting shit on by the router/firewall the server is sitting behind because you are trying to route a connection externally that should be routed internally.
Neat! Even works with [twig macros](http://twigfiddle.com/cfhzlm) (although I haven't tested across multiple templates). I'd suggest finding a way to expose the Twig documentation on-site, and making sure the images (such as the blue one on the help page) are a bit more conservative in their file size.
I'm sorry, but that's not what the term say.
Very true if speed is a concern. I would even use [rolling-curl](https://github.com/joshfraser/rolling-curl) in a case where you need to validate a large quantity of URLs.
Not PHP but I use [CasperJS](http://casperjs.org/).
Well. In a way, [they do compete](https://nodejs.org/), just not in this instance.
Or better, http://www.vimperator.org/vimperator And for real power: http://5digits.org/pentadactyl/
That's a very interesting selection of packages, thanks! 
You are once again missing the entire point (and shifting points entirely away from your bullshit assertions about unit test coverage to architecture..nice work). The architecture is largely a concern of those who maintain the project.... developer experience is how those who consume the library interact with it. Back it away from DX for a moment, and talk about UX. Lets talk about wordpress. Now, we can all agree that wordpress is very poorly architected. It's *UX* is astonishingly good. Those who *use* it do not care how badly architected it is. The same goes for DX in something like eloquent. Those who use it (generally) find that it stays out of their way, is very comprehensible and easy to learn and come to grips with. And at the point where you run up against it's hard limitations you have Doctrine to jump to. Rails suffers the same sorts of architectural issues in the Ruby world. It is developer experience that makes it popular. Nobody cares about your very junior/immature views on architecture and testing.. what they care about is how easy it is to use your stuff.
All kids want do be in the "I am a [Phil Sturgeon](https://www.reddit.com/user/philsturgeon) impostor" club or what?
What did you need to do that rocketeer couldnt do? Just curious
That's exactly what I did wrong. Thanks!
You never heard of Node? It's pretty old.
You've suddenly written a PHP-&gt;Javascript transpiler, in PHP.
I would disagree with most of the people here saying not to reinvent the wheel. You're not doing that. You're trying out different wheels to see if there are better wheels. Absolutely do that. It's a good thing to do. IMO the first one is a bad example. It's not a good collection because it's not even really a collection. You have to have a "thing" to have a collection of it, and your example is just an array. The idiomatic and obvious (and fast) way to loop over a php array is `foreach`. But this is just an example. A more common example might be something like the list of a customer's products, and in that case, the Object Calisthenics rule number four applies: [First Class Collections](http://williamdurand.fr/2013/06/03/object-calisthenics/#4-first-class-collections). This means that you would have an Order object, that contains a CustomerProductsCollection which contains **nothing but** that collection. This lets you do things that strictly belong to the collection, like sorting, iterating, filtering, calculating, searching and accessing, entirely and exclusively on the collection object itself. This is a good thing to do, and something that PHP programmers don't do enough of... PHP is so good with arrays that we just use that for everything. The second part, your promises. Meh. Either way that makes you happy. I don't see a problem with either approach. Both are completely readable. Again, and like everything else, there's nothing wrong with any approach overall. Just try sticking to the one that is appropriate at any given time. And don't be afraid to use the basic language constructs. They're excellent for what they're for.
I've been wondering about ORMs as well, I'm using postgres 9.4 and specifically the jsonb and ltree types in several places. How would an ORM normally deal with things such as the custom operators for these types? I've also made a range of stored procedures to deal with computations that need access to several tables. I decided they might as well take place in the database and be done within a single query/db access, rather than in the application layer resulting in several separate queries. Do ORMs deal well with stored procedures? Essentially, in this case, I've opted to write most queries in raw SQL, I keep all queries in a sort of repository where I can call each query by its name.
Everything now being namespaced is quite a big change I'm still battling with.
No, it's not. Look, if you want one of those debates where people crap all over PHP, /r/webdev is over there.
&gt;one of those debates where people crap all over PHP wat. Talk about jumping the gun. I did in no way suggest that, not sure how you interpreted it like that.
The principle of least surprise applies here. Lots of languages have a .each construct but foreach in PHP is much more idiomatic, as evidenced by the guy who thinks &gt; foreach ($collection as $item) is more readable than &gt; $collection-&gt;each(function ($item) You should always consider the external API that your libraries are going to provide. Many experienced library authors recommend planning that out before you even start implementation. In your second example, I'd consider something like: &gt; if ($input-&gt;validates()) { &gt; ... &gt; } else { &gt; ... &gt; } to be reasonable effort that doesn't break expectations, followed by something like: &gt; if ($validator-&gt;accepts($input)) It looks like you really like closures, but they are kinda second-class citizens in PHP.
This is something i really need to work into my workflow Right now i have a local copy of my sites That i edit then manually upload via sftp to my dev server to test, then if im happy i move it to productiom. Would like it to automatically upload changes to dev when i save in atom and then when im satisfied i can do a git push at which it uploads it to production. Just not sure what all i need to do to make this happen
How do you update to new versions on the production?
No, I love doing things in a more functional way.
Check out https://github.com/rcousens/packer-php7-dev/blob/master/doc/02-debug-php-extension.md if you want some idea of the kind of tutorial content I plan to keep on producing. Documenting what I learn as I go, hoping to become an active contributor to the Go-PHP7 movement (http://gophp7.org/gophp7-ext/) and ultimately start developing/supporting extensions. This repository basically documents my journey so far, from learning to compile PHP from source, to how to configure a development, debugging and runtime environment around it, and then using Vagrant to make it available to everyone else with a simple, single 'vagrant up' command. This isn't necessarily meant to compete with a similar box put out by Rasmus, but I had bizarre issues with that box and wanted to understand the process underlying its creation. Also, I'm much more at home on RHEL derivatives. So I set out to make my own although it's not quite as feature rich in that it supports PHP7 only! The Salt state files in the 'salt' directory are equivalent to documentation describing the process of compiling PHP7 and installing it for testing and/or running a website. 
I understand your point, but I honestly would never hire a developer that would tell me in an interview that he'd selected poorly architected solution just because the method calls are more convenient. A smart dev would just extend the classes to add the shortcuts he likes
The conversation drifted somewhat from my initial posts a while ago. At that point I was trying to be genuinely helpful. We then moved onto your preposterous notion that you wouldn't use anything that didn't have 100% code coverage (which is actually saying nobody should use your current PHPixie), a reality that even Fowler considers to be a smell, and that somehow DX does not matter - and that your new found view of clean architecture somehow is a feature. I honestly don't have the time to review the entirety of your package. The small part of the API surface i've seen doesn't fill me with an immediate desire to use it, and your examples and the way in which you speak about the package raise red flags around unnecessary indirection for my particular current use cases (indirection that if I felt I needed I would move to something that is a little more tested and has a better reputation than your code currently does - I'm sorry if that makes me a dick, but reputation does count a bit for busy people.. rightly or wrongly). As for what makes a better API - the public API and how you use it makes a better API (note, this has nothing to do with how it's architected). That you have to use getter for the query builder on every query you want to make makes **me personally wonder** whether you've considered the developer experience at all. It makes me wonder what other friction the API imparts in the name of architectural purity. So it's not for me. Sorry. But your *attitude* towards other peoples' work, and the *implication* that your stuff is somehow better than other peoples' work is what I am taking great issue with.
Not all code reviews are internal and not always you (_as a reviewer_) have the power to decide what gets changed and when. When you review a piece of code, you make recommendations, which may or may not be followed by the company who contracted you and you might never know what percent from your recommendations have been applied.
Well if you dob't have the time to review the API isnt it a bit preposterous to make assumptions regarding its DX ? If I didnt consider my work to be better than existing solutions why would I spend a year of my life on it ? A crossdatabase ORM is not a weekend project you know
I think the biggest thing I'm learning from this thread is that almost everyone has a slightly different process for deployment. I inherited a job where the previous developer would ftp directly to the production server without revision control. I figured anything would be better so I got to writing a bash script for deployments. 1. Check out from revision control 2. Zip and scp to live server 3. Unzip remotely to a uniquely named directory 4. Point my active symlink to the new deployment and point a rollback symlink to the previous active deployment I've also set up a configuration file that allows me to specify multiple targets. Targets can even includes a production flag which will force you to stage the deployment and enter a random verification string before you can deploy to that target. It's still in the works, but I'll be posting it on github once it's ready. I haven't looked into Capistrano or any other existing deployment tools. Maybe if our deployment needs get more complex I'll check them out. 
Doctrine2 does have DX issues vs Eloquent. It is objectively easier to use Eloquent. But at the point where I could no longer use eloquent because I had run up against it's ceiling the trade might be a good one to make. For most of my projects right now it is not a trade worth making. But I feel I would get a lot more for that trade by moving to Doctrine then I would by moving to yours.. Doctrine is a solid proven ORM again with thousands of users. I can employ developers tomorrow who have experience with Doctrine. The same cannot be said of your work. As for not bashing it. Lol. "I'm not bashing it BUT ITS ARCHITECTURE SUCKS". Nice one. Seriously though this conversation is really going nowhere. I'm going to drop out.
Doctrine2 is a whole different paradigm and has vastly different goals to mine. For one things its not even an activerecord. There are a lot of usecases where doctrines persistance layer would absolutely burn through your ram
Error: Question too general, please try again later. :)
Still using mysql_* functions? Not sanitizing data? Waking up in the morning? Trying to shoehorn everything into MVC? Asking vague questions about a large group of people's foibles?
Not turning on all error reporting while developing.
Why is that a bad thing, I assume your relating to what is now known as "dev ops"? I don't know much about Linux, I know enough to get by and have had absolutely no problem with it.
Especially if your parents are PHP developers
&gt; I happen to be lead dev in two projects when setting up local dev with some new guys that wanted enormous $ per h for their time was really pain This sentence makes no sense whatsoever. As for what I assume is your point, these guys were paid to know a lot about Linux. If someone wants to use it as their desktop system, what's wrong with that? It's not like Linux is limited to the elite who know a lot about it. Also, I don't know about you but I didn't know a lot about Linux when I was a newborn babe. Neither, I'm assuming, did any Linux expert. This sort of knowledge has to come from somewhere.
Distributing response headers and output throughout their application, which PHP makes so easy to do. This means that it's really easy to do something like: echo "Here is the result:"; //generates a 200 OK response header, as it's the first line of output. $items = $db-&gt;getData(); //Whoops - the DB is actually unavailable, we need to give the user an error response Because the 200 OK response header has already been sent, it's not possible to send the appropriate error header. Also the body has 'some' of the OK response in it, but then that gets mixed up with whatever error message will be shown. Instead of doing this, all headers and output should be put into a response object which just contains strings of the headers to set, and the body of the response. And it's only if the request actually completes without any error that that response is sent, otherwise an error response can be sent.
Thank you for the advice.
This is probably a thing I will never understand. How can you develop while hiding the errors.
Among the advanced developers, the biggest mistake by far is trying to twist PHP to do what it was not meant/designed to do, e.g., concurrent programming or multi-threaded programming (even with the pthreads extension). You can see this problem easily when a PHP developer decides to "defer" a call using another HTTP connection. 
i giggled. you're a good troll. thanks.
I hear good things about that book.
Trusting the referer header for any sort of authentication or privilege is a massive, MASSIVE fail. Also, just use prepared statements.
IMO the biggest problem is that PHP *lets* you hide the errors. There should be one mode: strict. End of story. No way to change it.
So funny (unfunny) story. 2 weeks into my current job, I was in charge of a server migration for our web app from 1 web and 1 db server to 3 new web and 1 new db server. Tricky, but not hard. I get the 3 web servers configured behind the load balancer. Wait a couple days. Migrate the db. Wait a couple days. Everything's rocking and running better than ever! Fast forward a couple days and EVERYTHING stops. People can't login, run the app, and http requests are stupid slow. Wtf?! Turns out the previous developer simply turned off error logging, and all 3 web server's HDs filled up because I hadn't setup log rotation yet. 60gig error log files in a matter of 6 days. In hindsight, I took it as a learning experience of never trust something because it LOOKS like it's working, and always check the error logs. Edit: Oh! I forgot to mention that the old servers all had plesk installed on them. That was fun to deal with. 
Whaaaat? It's fun being in devops! Everybody gets to blame you when stuff doesn't work... 
&gt; the solution is just "use parameterized queries"? The solution to 99% of SQL insecurities. I would guess that one example might be affiliate networks: The referrer determines who gets a commission, so you must store the referrer until checkout. (I'm guessing you store [affiliate,product_id] pair indefinitely? I don't know the terms of service on those agreements.)
notices are annoying and: if ($good_stuff) do_awesome_function(); looks sooo much nicer than: if (isset($good_stuff) &amp;&amp; $good_stuff == true) do_awesome_function(); actually I agree completely with your statement but I still prefer the look of the first statement.
The OReilly book "Programming PHP" is pretty awesome and Rasmus had a hand in writing it 
I may be a little jelly. I work with a smaller company trying to break out into a medium establishment. I end up having to do a fair share of backend and frontend work. That combined with trying to maintain a windows **and** Linux server environment can get pretty taxing on your mental status.
I think you only see that pattern when using _POST bools? In that case I have a *post* class for validating _POST input, and always do $do_good_stuff = post::bool("good_stuff"); if ($do_good_stuff) do_awesome_function(); Slightly more verbose, but makes for clean code.
mines are java devs and my younger brother is a ROR. I am the phpurple sheep of the family
&gt;&gt;Trying to shoehorn everything into MVC? &gt;Explain Sometimes all you need is two functions in a cgi script. (edit: quote marks)
Some days I agree with you, and some weeks are more trying than others. Ultimately the problem is growing pains with the company. Since I've been there (2 years) we've gone from 150k (paying) users to 400k, our uptime has gone from about 97% to 99.9% (almost got that extra % if it wasn't for some faulty hardware...), and the codebase has gotten much cleaner and 1200% faster in some cases. They took my advice and hired on two devs to handle the load which has helped tremendously. What's awesome is one guy is a better backend developer than me and the other is a *much* better frontend developer than me. The backend guy has some decent sysadmin fundamentals too, so we have a really good feng shui of skills. Basically what I'm trying to say is that some weeks are frustrating (like this past week), but the root of the problem is not the job itself, but the tough situation of having to keep up with the pace of growth.
* Using the mysql_* functions. / Not using parameterized statements. * Not taking the time to understand SQL injection or XSS attacks. (Commonly repeated as "sanitize your data" with inadequate or incorrect context on what that means.) * Trying to validate email addresses before sending an email to it. edit: A much bigger one: They assume nobody is going to try to hack their application, or that it's not worth hacking. Software always needs to be developed from the perspective that people are going to try and break in because they will.
Sure, either they don't know any better or are forced to by circumstances beyond their control.
Interesting scenario, I have never been in that situation, the largest project I've been on grew from around 4 million users to around 5 million, it currently stands at around 6-7 million. Though the active userbase is much much lower, we were still running tech way behind, before I got made redundant we were about to introduce knockout.js, the framework behind the scenes was still php 5.2 possibly 5.3. What exactly are your problems with pace of growth? Have you thought about hooking up with some people on LinkedIn or another network and learn about the growth and how to go about it. I would highly recommend [bufferoverflow](https://overflow.bufferapp.com/?utm_source=reddit&amp;utm_medium=Social&amp;utm_campaign=reddit-is-awesome) they had extreme growth and they have blogs on how they dealt with the growth, it is fascinating, maybe even help you along the way! :) 
&gt; `E_ALL | E_STRICT` Ftfy
Never use `die()`.
Looks like you found out what grinds his gears
How is yii2?
amazing, the best framework i have ever seen. i get surprised on how little code you need to make a functional site. everything is reusable, everything is extendable, i truly think its the best framework in php
I get this, its like people forget PHP is also procedural.
Why are you here?
Especially not reading non-PHP books: *SICP*, *Code Complete*, *Design Patterns*, *Refactoring*, *Patterns of Enterprise Application Architecture*, *Clean Code*, *Working Effectively with Legacy Code*... Honestly I think the best book for a brand new PHP developer is probably Sandy Metz' *Practical Object-Oriented Design in Ruby*.
Now I'm sad I'm not related to any other developers :( I didn't know that was a thing that I wanted until now.
You know me 5 years ago? *weep* I'm not the best dev out there, but I'm better than I was, god dammit!
a log without rotation is the disk version of a memory leak, its not a question of if but when it will cause an outage. 
YES. There are so many gotchas with ==, like 'not zero' == 0 resolves to true
Not knowing what they are coding. An example from a current project, the developers had to get all category ID's from a table with a parent-child structure for a given parent category. Including at times the top category. They had chosen to write a query with multiple joins for each nested level and then they did a foreach and checked whether each of the joined ID's existed in the answer array and if not added it end up with a unique list of ID's. This is a 1 grain of rice on a chessboard deal. 5 levels so first category has to be checked 5 times against an array of 1 element. But 10.000 category has to be checked 5x10000 if it is new. That is a LOT of checks. Very simple very fast ones but a LOT of them and that takes time. With 30k categories 3.5 seconds. And they use the found categories to construct a query (IN()) with a select * and then request a row count for the count and then do ALL of it again to do the final query... The code "works" it is perfectly legit. But it is also clear that the person who wrote it, doesn't get what he wrote. Doesn't get what is happening. Doing the same work twice is not just lazy, it shows you don't get what you are doing. I have seen lots of mistake but the worst is just that, people trying to code who are just not getting it. I seen really poor code before by people who really just can't code and that is okay because their ineptitude usually stops them from messing it up to bad. But this code in question is used in production and the company needs to grow and it can't because they company that produced it just can't hack it anymore. There is a level where just using a subset of PHP and general server tech is okay and that is one of PHP's strengths but a LOT of actual developers stumble when they have to move past it and produce sites that can scale, can be updated and extended without each time hacking together a new approach (this code has 5 different entry points for the same frontend as each time they cobbled in a new "routing" page for the next feature. To recap? Stagnation, developers who don't grow their skills and after years in the trade still write procedural code like it was 1999.
Better to first check if the file exists and can be read, then you know what is happening. No suppression needed.
&gt; Biggest mistake PHP coders make? Using PHP. \#SomeoneHadToDoIt \#DownVoteApocalypseIncoming
This is all bad.
That's subject to a race condition though -- fopen may still fail.
So this APEX thing has no session management at all? I guess you could write a file using PHP that APEX could read and correlate it to a user ID and then pass that as they get parameter. Kind of make up your own session management thingy. If the user ID/session id in the get parameter can't be random and unique this doesn't really buy you anything.
Not branching out and trying different frameworks or languages. I've seen so many devs who get comfortable with WordPress but can't make the time to learn one of the MVC frameworks.
PHP had bad developers writing *its* code, then. :)
Can't you use the database as a shared session backend? That is PHP stores a random hash along with the authenticated user id on the database, then redirects back to APEX with the random hash as a request parameter or cookie. APEX then queries the database using this random hash as key and setups the user as authenticated accordingly. The random hash should be valid to be used just once.
Sure, I've seen large test suites that can take up to 10 minutes to run with a few thousand tests.
It's a troll account pretending to be philsturgen
&gt; WordPress There's your problem right there. 
Oh it's weird, I thought people were born knowing how to use Linux.
Dashbrew is a Vagrant build that aims at providing a powerful PHP development environment that can be used as a replacement for local development stacks such as MAMP, XAMPP, and others. It provides an easy way to manage, organize and develop PHP projects and comes with a unique dashboard that allows managing various environment aspects. It also comes preinstalled with all software and tools needed to start developing right out of the box. Dashbrew makes use of phpbrew — the PHP version management utility — to allow developing both web and command-line projects on different PHP versions and configurations on the same development environment. Make sure to check it out at https://github.com/mdkholy/dashbrew
Abusing the shit out of ORM and function calls is probably the worst I've seen. I'm actually working on some right now that manages to run up apache to about 3-5% per process. Didn't take long in cachegrind to find the source though. Not running HHVM right now but I don't really think I want to drop in an attempt to speed it up since, overall, that won't make the code any less shit.
No worries. 
 if (!empty($good_stuff)) do_awesome_function(); Same result as the first one, no messages.
&gt;&gt; die() &gt; For ajax requests it's perfectly fine. No it isn't. If you have an ajax request that is missing a parameter you should be issuing an HTTP error header (a 400 code) *at the very least*. Terminating the request with a 200 OK when everything was not ok is amateur hour.
Thanks for the feedback and thoughts. Since PHP is compiled from master, it's unreliable to assume it will work correctly for the php-based composer installer. The curl method is relatively foolproof and is installed by kickstarter way before the provisioner runs. Also, the reason the packer files are in the same repository is because both Vagrant and Packer are equally capable of running the salt provisioner. Packer does it initially when creating the box which significantly reduces the set up time while Vagrant does it on launch to keep everything up to date. I don't see any point in making them separate and using something like submodules etc. The additional overhead in complexity for me is not worth the 10kb of files in the packer directory. I specifically chose to only support CentOS 7 as I had a lot of the Salt state files previously for this OS. I am curious about extending support to debian at least, and will have a look at it at some point in the future. The SaltStack PHP files aren't particularly relevant because none of this is based on packages. Mine compiles PHP from source! For a debian based box check out https://github.com/rlerdorf/php7dev/blob/master/README.md 
It handles sessions via a session ID passed in the URL. A user is assigned a session ID even if they are not logged in, which is fine, but I can't find a way to change that session ID. A thought I had was to pass the APEX session ID to PHP, authenticate using PHP and store a value in the DB saying "UserID 123 with session ID ABC is authenticated for X minutes", but for some reason this sounds horribly insecure to me.
TIL that facebook is forced by circumstances to use PHP ... common !!
True, I'll have a look again at your formula. I guess I just liked the literal translation of the set up tasks the composer website itself recommends for a global install. I honestly didn't know about the flags to the installer, which is pretty cool, so thanks for showing me that! Also, I don't know what a PPA is really. From memory the equivalent of a user run package repository? The whole point of the box is to test and develop extensions in C under PHP7 master branch at all times. Also, distro's way overcomplicate the way they structure the php distribution for purposes of flexibility/security which isn't necessary here. 
I have to disagree, working as a *backend developer* you develop the backend of sites. Sure if I were to say I'm a *full stack developer* then sys ops would be included in that.
It's certainly seems horribly insecure. But then again, are you trying to make it more secure or easier to use? Since you don't have to worry about cookies or any modern security limitations you could have PHP handle the authentication to APEX server side then redirect the user to their specific URL. If needed you could also have PHP periodically check the APEX session to see if it's still valid and log the user out or send them a new URL, whatever makes sense.
 $var = isset($_POST['input']) ?$_POST['input'] : die(); I can't really quickly skim over that and understand what its doing. I have to slow down for a second to figure it out (my eyes don't immediately register a ? and : in the middle of a line, while they can easily pick up new lines). The equivalent in long form might not be as short, but its easier to read (4 lines of code, I dropped the die since it shouldn't be there in the first place): $var = false; if(isset($_POST['input'])) { $var = $_POST['input']; } Now what I'd expect an experienced developer to come up with would look more like this: $this-&gt;request-&gt;getPostParam('input') Then getPostParam is long form, but only written once: function getPostParam($input) { if(isset($_POST['input'])) { return $_POST['input']; } return false; } 
&gt;What kind of retards render any html inside of a ajax get/post page lol. The kind that are replacing one block of HTML with another. It isn't an uncommon practice. Your ignorance is showing.
If it were not optional, and display_errors was always On... imagine how fast those errors would be fixed!
I can see, now, how relying on the arguments could be unreliable. Not that they would but what if Composer changes how those arguments work?
&gt;Not uncommon, but just bad practice. No, encapsulating the HTML inside a JSON response isn't necessarily a bad practice, particularly if there's other metadata you need to ship with the payload. If anything I would call it situational.
Nobody said anything about displaying the errors. The app just shouldn't run when there are any.
You're right -- Regardless, there are many more reasons not to use die, some of which are in the comments on that link.
PHP isn't precompiled, you can't check for errors unless you execute the code and in most cases execution will stop when an error occurs.
That's why god made ob_start() and ob_get_clean().
lol..you are right. starting in programming with PHP is a very grave mistake one can make at this point. It completely ruins your brain and make it impervious to better languages/practices... &gt;..DownVoteApocalypseIncoming The naivety of the people here who thinks down votes can compensate for their ignorance is amusing...
&gt; They assume nobody is going to try to hack their application To add to this - web applications inside company networks. Some think that their internal network applications are magically shielded somehow from the evils of the outside world, so they get disgustingly lazy with security best practices. They are wrong.
Not displaying errors when there are errors being thrown is security through obscurity. PHP shouldn't concern itself with information disclosure - if you have errors in your application, it's your responsibility to correct them, no PHP's responsibility to help you hide them.
This has been a problem for as long as PHP has been alive it seems. This makes me think there should be a PHP language enhancement request or at least a RFC. If the interpreter detects a closing tag in a script file followed by nothing but whitespace then that closing tag is ignored.
OP still uses 5.3
No, these aren't, no. It's something I can point to when people say, "Well, `hash_equals()` isn't available before PHP 5.6 so I'll just keep using `===` on HMAC validation," after I tell them to do things correctly. http://www.cs.berkeley.edu/~daw/teaching/cs261-f12/misc/if.html
Force user to login via php then authenticate them in apex
usually everytime my boss ask me to take care of a project i look the code 5 minutes, then i pretend to look at it for an hour before i tell him that we need to erase that shit and make it again
Intermingling your PHP code and HTML. It's rare these days, but I know some coders out there are probably still doing it. PHP originally was designed to work that way, but it quickly becomes a nightmare to maintain. Most people eventually realize they need to use templates (or at least template-like PHP scripts that only use PHP to output values if not a real template library). But it wasn't that long ago that most PHP coders were writing PHP scripts that were intertwined with HTML, sometimes outputting the HTML with echo statements.
for them thats easier than learn Active Queries. i will quit the day they tell me i should work that way, so far it looks like when i start a proyect the other devs have to force themselves to follow my guidelines (specially because i use dinamic databases changing the prefix in testing and production exactly to avoid them using sql queries)
How old are those projects? I mean, I've seen programs 10+ years old and I somewhat accept stupid stuff that is old. Just because it's old. And I'm not old enough to know, how things were written back then. But as far as I know Yii was released 2007-8.
one of them asked me on friday about an exception and i had to explain him the try/catch structures
Not spending enough time working on the design and writing it down in a spec. So many developers jump right in and write code which will need to be refactored almost immediately. You can save a huge amount of time and expense by spending the time at the start figuring out what you want to do and how you're going to do it.
they started as such. i think the problem is that the mentality is 'as long as it works....' so many cases 'work' crashing 'randomly' or with a few 'minor' problems. Most of the time they simply ignore safety on code (specially sql injection). since the paying costumer never sees the code once the payment is received they forgot about it. Right now they are also offering support and media marketing so we need to take care of old shit... mostly i have to take care of it
Thanks for recommending the Metz book, I just got it and it's awesome, exactly what I've been looking for.
Maybe you should suggest to your bosses about implementing some form of code-review. There's a great video about ableton live devs, and how they changed their view on code "ownership" and code-reviews so on[ here](https://www.youtube.com/watch?v=tILlZRLhBJE). Incase you are interested. Other than that, a web developer that still ignores sql injection, should be a student, not an active employee. Or atleast his code should not go without oversight. In my opinion.. I mean, thats the basics yet again.
I have been using Yii 1 for years and love it. I have yet to take the plunge to Yii 2, but when the next big project rolls around, I will probably move to it.
I think m4r3x is saying that some people want a lot of money for little knowledge. I do not think he was bashing people that are trying to learn it or new employees that are trying to start on the ground floor.
I was about to complain about how hashEquals uses mb_strlen (in 8-bit mode) when a simple strlen would suffice, but then I learned that mbstring.func_overload exists. What jerk thought mbstring.func_overload would be a good idea?
`var token = '&lt;?php echo $feed-&gt;getToken(); ?&gt;';` This is making me all squirmish inside. It would have been better to store the token in a hidden HTML input and get its value through JS.
Mvc
You are just making things worse 
Heya, I thought I'd try giving this a go, and I've followed all the installation instructions I had to jump through some hoops to get it working on my system. (windows 8.1) On the first vagrant up my browser gives me a connection refused error. I could ssh into the box no problem, and found that apache wasn't running, so I started it. My apache error log was filled with: &gt;[Sun Mar 08 06:33:36.082384 2015] [proxy:error] [pid 2079:tid 140059101566720] (111)Connection refused: AH00957: FCGI: attempt to connect to 127.0.0.1:9001 (*) failed I had to force start php5-fpm using: (It didn't seem to want to start otherwise) &gt;sudo php5-fpm -y /etc/php5/fpm/php-fpm.conf My hosts file was also unchanged, so to actually get to dashbrew I had to use the vm's IP address: http://192.168.10.10/dashbrew/ Maybe I've missed a key step in the installation? 
brand new account, meant for trolling /r/php.... I asked for a shadowban of this dude already...
I recommend you use a framework for medium-to-large sized PHP projects. There are many reasons, but here are two big ones: 1. No need to reinvent the wheel. You can plug in other people's code to get things done quickly. 2. High quality. You're using code which has already been tested by many people. I recommend Laravel. The easiest way to learn it is via Laracasts.com. Good luck.
Or just don't add closing tags to your files?
People trolling /r/php probably just are insecure about their programming proficiency and are looking for some way to compensate. It is fast and solid on a lot of fronts, and gets the job done. I work in a few languages for work, but PHP is my goto for web based pet projects. Room for improvement, but I have faith it can get there. 
So if I understand all that correctly `strlen` and similar functions cannot be relied upon if we want to use it on non utf8 strings because it could be configured to actually use the `mb_` counterpart?
No, his parents merch in Runescape.
Classic /r/php response to php criticism. **Four replies and none addressing the point of my post**. Lots of troll calling and calling for shadow ban for expressing my opinion...And lots of upvotes for all the guys attacking the PHP criticizer, even when they says something dumb like &gt;'We aren't in the age of functional programming in PHP anymore, just so you know.' People are not even trying to correct the guy, but instead up votes him. Because as long as he is attacking a 'PHP hater', it is ok. Right? 
You just have to talk about it terms they will understand, i.e. money. By getting it right at the beginning, your costs will be much lower. Less bug fixing, less support tickets, less refactoring, less developer burnout. The team will be able to focus on new features rather than spending so much time supporting the existing product. Everyone wins - management, developers, customers. 
Don't be afraid to check out some books that aren't specifically about PHP. You can learn good design patterns and principles and apply them in PHP.
Hey, I toyed with Dashbrew a bit last week, here are my thoughts: - you have only Apache, Nginx can't be added? - one of the fancy command line prettyfiers extremly slowed the command line in shell, I don't know if it was OhMyZSH or some other one, I deleted the files in home directory. This only occurred when the command prompt had to show the git branch the folder was in. The response time after preforming a command was 5-10 seconds. - I couldn't change the write/read rights on my synced folders. My application temp and log folder needed chmod -R 0777, but that was inpossible, i tried both with root and vagrant user. How to do this? - how would I install additional software, so it can be easily available when I build the machine each time? Other than that this looks very promising.
generally the problem is that a developer is free to write whatever comes to his/her mind. and this is a start of disaster, because you should first think what you are writing, then write. frameworks such as Symfony2 help a little bit, because it has some rules you must abide. just like before a surgery you must have a plan, you should have a plan before writing even a simplest function/method/class.
This is particularly bad in the way that most WordPress plugins are constructed. I always see 1000+ plus lines in one file that consists of a singleton coupled with filthy HTML. Vomit.
&gt;PHP doesn't need modules... You are telling me that 'PHP doesn't need modules' because it has classes. Right? You see, there is no issue in a language being different. But to pretend that the problem other languages solve with modules, is not relevant in php, is the issue. So php does not have a solution to organize large code bases, and using classes (And **one class per file** according to standards, what a joke! I know how auto loaders work btw..) to do that is just a workaround/hack, just like other multitudes of workarounds/hack in PHP....
&gt; a language that supports modules You can perfectly build modules in PHP. That's actually what everybody do… &gt; and namespace it manually. PHP has namespaces.
Of course is brought by JavaScript: PHP Doesn't interact with the HTML DOM once is generated. Even if it involved some PHP it would need to be done with AJAX, which is still JavaScript. Falsely witty remark is false.
come on, let us have an 'intelligent discussion'.. How do you justify using a language for medium/large projects, whose only solution to the problem of code organization is classes?
lxc are very accessible now, i dont think ill ever go back to vagrant or virtualbox.. but good job i guess 
It's good that it lets you hide the errors, it just should stop whenever an error occurs. In my personal projects I always convert errors to exceptions, and I just feel that should be the default.
&gt; My point is, this looks smelly as hell. Local instanciation, awful variable naming, and if that method really spans over 40 lines, you probably have a lot more issues to tackle than just remembering which session is which. It looks like you did not see much legacy code from the enterprise segment. :) A 40 lines long method is small in that context. From time to time, you will see what we call "Megamoth" (_MEGA MOnolithic meTHod_) which can have 800 - 900+ LOC.
&gt; Can you show me what a module looks like in PHP? https://packagist.org &gt; In other words, included files inherit the scope of parent file, instead of having it's own scope/namespace automatically... What? Each file has its own namespace and doesn't inherit the one of the "parent file". Have you ever tried to build a PHP with modern tools? (Composer, autoloading, modern framework, etc.)
Believe me, i have seen such :) But the context here is - i believe - rather the upper segment of software quality, not the bottom (and below) ;)
Man, are you trying to piss me off at the expense of looking like an Idiot? if that is so, it is working...
-1 to mid-large applications for beginners.
Think of it like building a house. Unless you are building a very specific house there is a massive amount that will be the same in most houses. If a community of people have already got together and come up with a number of really good starting points why build that all yourself. 
There are two aspects of my argument. One, the conceptually weird one, which is the practice of using classes to organize code, is easy (I think) to follow, which is why I didn't go into details explaining it. The second is, What are the downsides of doing so, despite people building lots of stuff in PHP? This is hard to explain and grasp. For one, it totally teaches the wrong idea regarding OOP to the beginners (hint: this is very, very damaging and difficult to undo). The other is requirement of hacks like 'one class per file rule' which is just a limitation to work around the bad design. A certain part of the application may be best expressed by a combination of functions and some classes, say 5 classes and 30 functions. In PHP you have to 35 separate classes in 35 separate files **and you have to namespace them correctly and wire them up with DI containers**. Can where this is going? If you were using a language with proper module support, that could have been one file, one module. And you still can have all the code separation you want (before someone tell that we are past the days of one file php deployments). Can you see how using PHP can result in much more overhead for large projects? Thoughts? Edit: I would like the people of /r/php to think twice before accusing someone of being a troll. Respond to my post. Not to my comment history. Please.
That is not the 'module' we are talking about. I have written about it in a bit more detail [here](http://www.reddit.com/r/PHP/comments/2yb7zz/what_books_would_you_recommend_for_building/cp821d1).. It is funny that people are upvoting you instead of correcting you..Is this sub full of noobs?
I interpret him/her as saying they hired someone for a big wad of cash and they expected them to be more knowledgeable about Linux than they turned out to be. I understand the frustration there, but I don't think the conclusion should be that every PHP developer should be a guru or gtfo, which is what they were saying (I think).
Right, so, what you *probably* want here is an HMAC. An HMAC is a very simple shared-key signature - you have a key (random piece of data) in your PHP login script and in your APEX endpoint that the PHP script sends the user to on successful login, and the PHP script can sign the user ID and the current time using this key, then the APEX endpoint can verify that the PHP script sent it (and not a user, because the user doesn't know the key). So in PHP (&gt; 5.1.2), you do: $key = base64_decode("Z2VuZXJhdGUgdGhpcyByYW5kb21seQ=="); $userId = "bob"; $timestamp = strval(time()); $hmac = base64_encode(hash_hmac("md5", $userId."-".$timestamp, $key, true)); redirect("http://yourapexserver/loggedin?user=$userId&amp;&amp;timestamp=$timestamp&amp;hmac=$hmac"); And on your APEX server, at the loggedin endpoint's PL/SQL script, to check the HMAC, assuming that the user query parameter is stored in `l_user`, the timestamp parameter in `l_timestamp` and the hmac in `l_hmac`: l_key := UTL_ENCODE.base64_decode('Z2VuZXJhdGUgdGhpcyByYW5kb21seQ=='); l_computed_hmac := DBMS_CRYPTO.mac(UTL_I18N.string_to_raw(l_user || '-' || l_timestamp, 'US7ASCII'), DBMS_CRYPTO.hmac_md5, l_key); IF UTL_ENCODE.base64_decode(l_hmac) = l_computed_hmac THEN -- The HMAC's the same, so we know l_user and l_timestamp came from the PHP script, because it's the only other system that could create the HMAC with this key l_current_timestamp := (sysdate - to_date('01-01-1970 00:00:00', 'DD-MM-YYYY HH24:MI:SS')) *24 * 60 * 60; -- I think this is right? IF to_number(l_timestamp)+10 &lt; l_current_timestamp THEN -- And now we know this HMAC was generated within the last 10 seconds, so authentication is successful - do whatever you need to do to mark authentication as successful here! END END `l_key` *must* be the same as `$key`. There may be issues with the syntax/types in the PL/SQL, I've never coded in PL/SQL before.
For medium to large sized applications, I'd recommend Symfony 2. Laravel's older, more mature brother that is pretty much solely designed for medium to large sized applications.
"Head First Design Patterns"'s cover doesn't inspire the programmer in me. but of course they say never judge a book by the cover.. but really .. what were they thinking..
Sure. Zuckerberg didn't know any better and at this point they've got a lot of legacy debt, so that's exactly what it is. Not to mention moving to HHVM/Hack, as well as all the other languages they write at Facebook.
I see. I misunderstood the post title.
I get what you're trying to do here, but imho if you want more adoption for this stuff it needs to be something that can be easily swapped out when the PHP version is upgraded. For example, why not make the functions in the global namespace and have function_exists checks to see if they're there, if they are use those. Using something like this (while I'm happy to see it) means they're locked in to using this library and not taking advantage of updates that may come with bugfixes in the pure PHP implementations of the functions in future PHP iterations.
Honestly, you're just better off not using the referrer at all. It's a header that comes directly from the user's client and *literally* could be any value...from something normal like "http://google.com/search?q=test" out to "my voice is my passport. verify me." It's just a string value and the user has complete control over it.
All legit browsers do use the referer though. Seems like a valid way to weed out some of the bots/scrapers.
I have so much to say, but I've rewritten this post like 10 times now, My brain just stopped working.
https://github.com/resonantcore/php-future/pull/1 I doubt they pull this in and I feel dirty even having forked this repo. I plan to delete my fork as soon as this is rejected.
Correct, they do but since it can be completely controlled by the user, it should be considered tainted. Like any other tainted data it should be filtered and validated before use and not blindly put into something like the SQL example he gives (nor output directly without escaping). You can still use it, but do so knowing the risks involved. Even a bot or scraper can send a legit looking header...HTTP is all just plain text. Performing evaluations against the data (like "does not contain the string 'Firefox'") aren't as bad as using it as data, but there are still issues there. Chances are, whatever you're trying to do with it can be achieved in a another, more reliable way.
You'll need to learn some Ruby first, but I recommend Sandy Metz' *Practical Object-Oriented Design in Ruby*.
One of the best, clearer, understandable and actually enjoyable book on Object Oriented design I have read is called Practical Object-Oriented Design in Ruby. I haven't written a single line of Ruby code in my life
&gt; ... it should be considered tainted ... Of course, that's what I said in my original comment. But your comment was about not using it *at all*. &gt; Performing evaluations against the data (like "does not contain the string 'Firefox'") aren't as bad as using it as data, but there are still issues there. Chances are, whatever you're trying to do with it can be achieved in a another, more reliable way. We're talking about the referer header, not the user agent string.
This sounds like the best solution, /u/solar-ice elaborated a bit more in another comment and I'm going to try this route.
This sounds like an idea solution and something I can implement given the limitations of APEX. I'm going to try this Monday, thank you!
When you get to a project larger than a small business or personal website it's less about the language and more about imposing a structure that makes sense backed by a data model that's thought out and performant. I recommend these books: http://www.amazon.com/High-Performance-MySQL-Optimization-Replication/dp/1449314287/ref=sr_1_1?ie=UTF8&amp;qid=1425831227&amp;sr=8-1&amp;keywords=high+performance+mysql http://www.amazon.com/gp/product/0321127420/ref=oh_aui_detailpage_o05_s00?ie=UTF8&amp;psc=1
Duh... Dreamweaver's "Synchronize" tool! ^(/s Fabric+Git, actually...)
I'll just echo /u/lordofworms thoughts, and say that I too have used Cake 2.x and Laravel 4.1, 4.2, and 5.0, and while I haven't had any experience with Cake 3, and I'm sure it's a perfectly capable framework, I would still recommend Laravel over Cake anyway (definitely over Cake 2...) Laravel's documentation is super fast to skim through and logically structured. It's not complete at the most "advanced / edge case" level, but if you want to become 80% proficient with Laravel in say, a day, you can do that by reading through the docs. And then there's Laracasts.com, which offers a [free course](https://laracasts.com/series/laravel-5-fundamentals) on getting up to speed on Laravel 5, and if you want, you can pay $10/month for access to more advanced less on Laravel or programmin/architecture/testing.
Agreed. This is also my go-to argument for arguing a custom build in a framework, vs using a canned CMS like Wordpress, Drupal, or Joomla. Good frameworks like Laravel, Symfony, and other mordern ones, don't constraint you. They don't impose layers upon layers of assumptions. They don't even impose their own proprietary architecture and utilities on you (but do make them available, and they're always superior to the equivalents in CMSs not just in terms of convention, but raw capability).
Most people here in reddit will tell you good things about Laravel. But I'm going to make a case for CakePHP 3, since I think it has some interesting advantages: Cake 3 is a modern and very flexible framework that also lives up to "conventions over configurations" mantra. It has a extremely powerful ORM that implements the Datamapper pattern instead of ActiveRecord, which is what Laravel uses. There are plenty things that make Cake 3 shine when compared to others. * Building forms, both simple and complex ones (involving data from multiple tables) is made very easily. The framework integrates very well from building the form and saving it without any extra major work. * Working with data is a pleasure, it stays simple for the the day to day stuff but also offers a wide array of options to filter data in an advanced way. Things like filtering by multiple pivot tables and other associations is a matter of a couple lines of code. * Authentication is built-in and is very extensible and pluggable. * Every part of the framework can be extended in some way. Which helps in building your application in aspects. For example the behaviors system is great for adding functionality to your tables. * Testing when database data needs to be used is a breeze. The fixtures system is easy to master and use in any project. * It has a large super friendly community, actually one of the most friendly communities that I know. * Documentation is extensive and clear, it has examples for both beginners and advanced users and features tutorials for learning the basics. It does not require looking at a bunch of lengthy videos or require any payment. * CakePHP is committed to long term support and service. It is very careful with backwards incompatible changes and supports older versions for a very long time. This is a big difference with laravel, which almost do a rewrite of the full code every year with no offer for support or security patches in older versions most of the time.
You would be surprised. There are so many companies that don't even use any form of version control. They use the code from client 5 as the basis for the project they are doing for client 6 and so on. The most recent version of the software they're selling always lives on the webserver of the latest client.
This is why i like the command bus architecture. You build up a command with data from a client, put into a command object, and send it to the command bus to be handled. Your handler could like something like this. &lt;?php class CreateProjectCommandHandler { private $projects; public function __construct(ProjectRepository $projects) { $this-&gt;projects = $projects; } public function handle(CreateProjectCommand $command) { $expirationDate = $command-&gt;getExpirationDate(); $this-&gt;guardValidExpiration($expirationDate); $project = new Project($command-&gt;getName(), $expirationDate); $this-&gt;projects-&gt;add($project); } private function guardValidExpiration(\DateTime $datetime) { // check expiration, throw exception if invalid } } You might also consider putting that validation check inside the project class &lt;?php class Project { private $name; private $expirationDate; public function __construct($name, \DateTime $expirationDate) { $this-&gt;name($name); $this-&gt;setExpirationDate($expirationDate); } private function name($name) { if (!is_string($name)) { throw new \InvalidArgumentException("Project name must be a string."); } $this-&gt;name = $name; } private function setExpirationDate(\DateTime $date) { if (invalid expiration date) { throw new \InvalidArgumentException("Invalid project expiration date."); } $this-&gt;expirationDate = $date; } } This way your entities can never get into an invalid state
I don't know how your tests are, or if you are testing, but if you are then for purposes of testing you should be mocking database calls regardless.
&gt;Go read the damn comment already. They're referring to conventions that support their preferred autoloader behavior. You can have any kind of custom autoloader you want. You can have more than one autoloader that fires in sequence if you really want. If you can't be bothered to learn how the language works, it's not possible to discuss it. &gt;Are you even reading the stuff I write...? I sure am, the ignorance is astonishing. &gt;Which was not at all the point of my argument... If you'd bother to learn the language you'd see why your "point" doesn't have a lot of merit. We've taken this about as far as it can go. It's a complete waste of time to argue with someone who doesn't understand the language they're trying to argue about.
So just convert them to Exceptions and you can achieve that.
I feel like you're overcomplicating things. This is stupid easy with the ActiveRecord pattern. Each instance of Project should know whether its expiration date is valid and how to save itself to the database. Your service can then ask Project (or ProjectCollection or ProjectRepository, if necessary) for the set of valid or invalid Project instances. How badly do you really need Repository and Service to be separate classes? The best design is as simple as possible and no simpler.
The nice thing with the hooks is that you *do* have a choice to not run phpunit as a pre-commit - it is simply a choice from a suite of options. 
What about PHP versions which have LTS from the distro maintainers such as Ubuntu? Are you suggesting that PHP developers should never use LTS distros?
&gt; What does that mean to you? You might tell that is just the recommendation. But that is the whole point. We are talking about inefficiency of practices encouraged by PHP. So this is just a problem of performances? You are saying PHP is bad for everybody because this convention is slow regardless of the website size and traffic? I'm saying bullshit, premature optimization. And regardless, PHP has an opcode cache which stores in memory every file so it doesn't matter how many files you have.
You have a very specific vision of a module and you don't want to admit there might be other (efficient) ways of organizing code. PHP people use PSR-0,1,2,4 and you blame those standards because they are not the one you are used to. No actually you blame the language…
He really didn't know much, from everything I saw and heard. I got the impression he learned most of what he knew on the job.
What are we talking about? That's of course what I'm doing. OP was making the point that there shouldn't be a way around it. Every PHP error will throw an exception. In the dev environment you will display the exception and in production you handle it otherwise.
I thought templates were included in all frameworks? Yeah, I use Blade now, but I used Smarty for years and it's quite good also and isn't tied to any particular framework.
Got any good books on the topic of analysing and writing specs?
strangely enough I had one this morning. Using symfony and doctrine.. doctrine was throwing an error that one of the base classes wasnt built. I needed to run doctrine-build-model. when I would run my script it would instantly die. added the shutdown handler and it caught the fatal. So I would assume trying to use a class that doesnt exist results in a fatal.. and I guess doctrine was catching it internally ? I cant be sure.. but it wasnt being spit out with the E_ALL. 
Services (or commands + handlers, if you want to go that route) should be completely self contained. The service's clients should only have to make a single method call to tell the service to do something. The rest should be up to the service. So, option B in your example. If your service expires projects, then that probably means something along the lines of checking the date and updating something in the database. The clients of the service shouldn't have to worry about that second part. Just **tell** the service to do its thing and done. Why? Because you -- more specifically, your service's clients -- shouldn't care that a service does its job now or later or how it accomplishes its work. Maybe expiring a project takes to long for a web request, so one implementation of `ProjectExpirationService` sticks something in the queue to do later. The queue consumer picks it up and uses another expiration service implementation to do its work. Option A in your example above doesn't let you do that. There's a coupling between the *specific implementation* of the service and whether or not a `save` call is needed later. That's extra cognitive overhead for whoever is working on the system as well as some additional complexity. On a small scale, no big deal. Multiply that times 5, 10 or 100 service objects and you're probably going to have a bad time. &gt; I feel #A is much better for testing since I can test the service with just PHP objects, leaving the database alone. Not really. What's much better for testing is only having to mock a single dependency (the service) instead of two (sevice + repository). Then you can test your service by mocking the repository and probably run some integration tests with a real database backend on the repository. It's a chain: make sure each part works with fake objects until your objects start touching the outside world. When that happens add in some integration tests and finish things up with an end to end test or two that hits the entire stack (and probably only follows "happy" paths). TL;DR: Just [tell your objects to do stuff](https://pragprog.com/articles/tell-dont-ask) and provide them the dependencies they need to get it done.
Most of those points Laravel has as well (simple forms/form data binding, working with data is sublime, built in extensible auth, framework very easy to extend, testing is a breeze (one thing I hated about cake 2.x was that running "vanila" phpunit over it was nigh on impossible..not sure that this has changed), very large helpful and friendly community, great documentation (at least better than cake 2.x, haven't looked at 3.x)... One thing Laravel doesn't have is LTS which is an issue for some. Not to take any of the shine off Cake 3, but most of these features are far from unique (fairly sure most frameworks provide these in one respect or another).
Ok so why is it that once a question is answered people see fit to delete their original post.. that's damned annoying...
This is an old question that has plagued object-oriented programming since its incarnation. Various concepts will provide different answers. For CRUD systems, all database storage is handled by a single object designed for that purpose. Any other object that requires database storage must invoke the database object. For Domain-driven systems we feel that we wind up repeating ourselves, hitting the sore leg of O.O.: rather than abstracting and reusing, we wind up coding the same functions (in this case database storage) for various objects. Or so it seems. Because yes, each repository object might sport its own "save" method, but does that really prevent you from having that save method invoking a single central abstracted database handler? Must we stay so true to a chosen programming concept that we forego the basic tennets of O.O.? Dadamssg provided the command bus architecture. It's an abstraction that lives aside the domain-based objects. It's a handler that abstracts rather than specifies. It's a thorn in the eye of the domain-driven developer. So your choice becomes: do I choose the path less traveled, or do I choose pragmatically?
That was... surprisingly relevant
I can only imagine the reason why Derick voted against this is because of the amount of work it'll require for Xdebug.
the Technical debt isn't Drupal, it's Invision Power Board, which handles the user registration. (since that one is already existing) (not to mention, IPB isn't using modern PHP(5.3+), and must be bought to allow you to use it.) Even then, Drupal 8 allows you to respond to the user registration event, and do whatever the fuck you want.
Agreed
This is excellent news. 
I get your point at least. If someone was able to submit to an open source project with this... but nah, that'll never happen. https://freedom-to-tinker.com/blog/felten/the-linux-backdoor-attempt-of-2003/
My question should have been more specific...how much RAM have you found it takes to run smoothly?
&gt; I do think that data binding when using multiple different related tables is much better in Cake 3 that in laravel at least. All the logic for hydrating the right properties, fetching from database merging and syncing belongsToMany is done automatically, whereas in laravel you need to do most of that stuff on your own. Fair enough &gt; I also find the approach to testing when using databases much better in Cake. In laravel apparently you need to fake a cli command ( Artisan::call('migrate') ) on each test run, which I find flabbergasting. What happens when you have tens of migrations often rolling back one another as it is normal during development iterations? As a caveat, I'll once again admit I've not used Cake 3, so my experience really is with Cake 2 testing which imo was incredibly difficult to use. In Laravel you are not "faking" the CLI command here, you're actually running it (well, you're executing the same thing that php artisan migrate would). As for flabbergasting.. I don't find it so.. For a start you don't *have* to do it that way, you can if you wish. You could easily use some fixture approach if you preferred. The advantage of remigrating is of course that the DB state is identical at the start of every test (and I would argue that this is correct, tests should not be dependent on resulting db state from previously executed tests). Migrations are also fast.. faster still if you set up your test environment to execute your tests against an in memory SQLite DB (time to execute them is negligible even for hundreds of migrations in this configuration). But if you'd prefer you can just migrate once at the start of the test suite and, then selectively seed tables with fixture data, wrapped in db transactions that rollback on tearDown. You also find it isn't a huge problem because the number of tests that actually touch the database should be minimal and I've found actually isolating your tests from the database to be far easier in Laravel than it ever was in cake. So, the combination of migrations being fast (especially against an in memory db), and being able to minimise the number of tests that actually hit the database mean that running the migration isn't really a massive problem. As someone who extensively used Cake testing, Laravel's testing story is imo superior (because it is vanilla, great IoC container, doesn't peg you into one particular testing approach or technology etc)
This thread has been linked to from another place on reddit. - [/r/programmingcirclejerk] [User makes a PHP library filled with secure hash string comparisons, among other things for older PHP versions. Turns out it's only for versions that haven't reached their EOL yet.](http://np.reddit.com/r/programmingcirclejerk/comments/2ydtuw/user_makes_a_php_library_filled_with_secure_hash/) [](#footer)*^If ^you ^follow ^any ^of ^the ^above ^links, ^respect ^the ^rules ^of ^reddit ^and ^don't ^vote. ^\([Info](/r/TotesMessenger/wiki/) ^/ ^[Contact](/message/compose/?to=\/r\/TotesMessenger))* [](#bot)
How can sql injection still be an issue with prepared statements? 
If true it kinda sucks. I appreciate the work that goes into a project xdebug but IMO the rational thing to do is not to vote against a good idea because of the work it would entail, but instead request help or donations publicly, an approach that does often work for high profile and instrumental projects like xdebug.
Creating a complete ecommerce platform is a very complex task to set yourself. Your best bet, if you are interested in ecommerce is to look at one of the existing platforms out there, and instead try to develop plugins for it. This will help grow your knowledge of how an ecommerce platform works, and in time, you will get more comfortable with what is unusual, or inefficient with the platform you have chosen to look into, and then you can start work on your own. Or better yet, contribute to the one that exists. Creating a fully-featured ecommerce platform will take years of work. Source: I work on an ecommerce platform, Miribase.
Read the entire thread, and I have to say it was extremely entertaining to watch you shit the bed over and over and get torn apart by PHP programmers of all things. How does that happen? 10/10, would watch you fail again.
flase...
I forget to `use` namespaces. All the damn time. Especially for global classes (I'm looking at you, `Exception` and `DateTime`!).
Forget to add "Location:" when using header()
I run with 32 GB on my computer
Give a try at PhpStorm and that will never happen again. It adds warning and in 2 clicks it generates the missing import (Alt+click on the warning + click "Import class").
Or he could have just not liked the proposal and/or patch.
he's been coding php too long
Redis? Can you turn them into one big JSON string and store/pull them with a single lookup?
http://consciouslifenews.com/paid-internet-shill-shadowy-groups-manipulate-internet-opinion-debate/ Some have a financial incentive. This stalking of certain people who created stuff the U.S. military prefer they not create have been stalked since the [Total Information Awareness program](http://en.wikipedia.org/wiki/Total_Information_Awareness) was put into effect in February 2003. HopeSeekr started to be harassed when he maintained the xMule project (one of the first cross-platform p2p clients, specifically for non-Windows) in 2003. In 2005, he added military-grade encrypted chat, coupled with the ability to choose "safe" IP hosts to connect to (how the ED2K protocol works, in general). At that point, apparently Falun Gong and several other oppressed groups took it up, usually inside a VM (to further avoid government-installed snoop/spyware). Finally, in a beta only available via the website, released on Sep 11 2006, there was the compile-time ability to turn every xmule client into its own ed2k server, as well, permitting adhoc one-to-one and many-to-many secure chat and secure file transfer. Apparently, this is what it is *still* used for, tho it's doubtful it's still compilable in 2015. But yeah, those three actions really put him on the radar. Been stalked by trolls ever since. (OH, he also hosted www.loosechange911.com and traveled promoting it between 2004-2007 and was heavily involved in the 9/11 truther movement. That alone put him on the Yellow List in the early 2000s. Being searched every time at the airport is fun!)
I noticed you spelt project with a Y twice. Any reason?
yes in spanish its proyecto
It's an unauthenticated remote shell, with a convenient blog plugin.
` () if $something === true; { ` Because I type the brackets and forget to press left. 
Derick is fully against BC breaks.
Ah, fair enough =).
This is a tremendous result for stability in long running processes \o/
&gt; Alt+click on the warning or alt + enter if you are lazy to reach for the mouse, like I am.
I always mix up the $needle and $haystack parameter positions across functions. Drives me up a wall.
Sadly, the hybrid thing is here to stay. Most warnings/notices will never be converted to exceptions as it could never get the 2/3 majority.
This is a wildly inaccurate guess, based on nothing at all.
I'd use the inbuilt Grid Widget. You can modify it, but the best bet is to start with getting a list of the records you want, in the order you want. After that, you can manually replace some of the columns with your own class types. Whats your php level? Are you familiar with OOP &amp; MVC? Also, I'd recommend using RBAC to do your admin check if you're not already.
Hi. I am just average I guess. I am using MVC. And I refuse to use GridView widget since it's in table display, I am currently using admin-lte panel. In this [link](http://almsaeedstudio.com/preview), I am using the "Latest Members" panel. I changed mine to "Latest Staff Members"
 if($this == $that) { instead of if ($this == $that) { It's a tiny thing (missing the space) but it's annoying.
I have not tried these myself, but I am about to as I have heard good things regarding [Thenewboston](https://www.thenewboston.com/videos.php?cat=11)
Try the listview widget. That might get closer to what you are trying to achieve. You can override the itemView property with your own layout to get it exact to your specifications.
I do this too. The crappy inconsistency on the ordering of them doesn't help matters. I don't trust myself to get it right anymore so always check the manual.
He he..exactly. But I guess I ll leave these guys to revel in their ignorance for the time being...
I can only imagine the reason why Gwynne voted against this is because... *squirrel*!
At work we use thin machines and the slight lag between a keyboard shortcut and it executing means that I've now got into the habit of saving 5 times before reloading, and defaulting to running "git commit -v". Just to be safe.
How so?
Yeah, this is a great example of why I find PHPStorm invaluable. I have hundreds and hundreds of use statements in my app and I didn't type any of them. Anyone who works in modern OOP PHP is crazy to just use a text editor IMO.
My company has a Lynda.com account and I've gone through the standard "beginner's guide to php" course (before realising there's a course that seems more suited to me called "web developer's guide to php" and most of the Object-Oriented PHP course. It's been a great resource but I've also used random google searches, stackoverflow, the php manual itself, trial and error..I don't think there's really a 'correct' way to learn. I do wonder if I should be using Treehouse instead though - teamtreehouse.com check out both and see what seems right for you.
I started with treehouse.com (10% of my learning time, but the videos and teachers in there, for me atleast, were simply amazing) and 90% of my learning time is coding a project i planned out - doing what I want in order I want (f.e. i dont understand arrays completely, but this function stuff is really interesting, lets learn this today), and a lot of google search, stackoverflow etc. Also good place to be is ##php in irc.freenode.net
True, that's how I do it today. My wishful thinking was more of a language design concern :)
Yep. How should the settings table look like? Is Redis a better alternative?
Does anyone know of any larger open-source PHP projects using the Respository pattern well? So far I've only seen the Repository pattern with small examples where they make a lot of sense, but when you start using searching, pagination and joining, I have a feeling they would get out of hand. I also saw an interesting alternative to the Repository pattern where you'd basically be making a separate class per type of Select query you'd make ( http://stackoverflow.com/a/16238079/1381550 ), which sounded fantastic, although this Stackoverflow answer was the only place I've heard about it. So I would like to know how the more popularly known Repository pattern should look like in a larger project.
&gt; Trying to validate email addresses before sending an email to it. One check I'd suggest doing is to make sure that the input contains at least something before the @, an @ itself, and at least one character afterwards. There's no point trying to invoke an email to something that isn't an email address. You can also gain a tiny bit of pre-validation by making your email inputs of the type email; in good browsers they'll let you know when you try submit an email input with no @ in it.
I have a phpStorm question: Is there a way to have phpStorm's code hint system automatically prepend "$this-&gt;" to properties and methods when within class? Or is there another way to look up class vars and methods? // disclaimer: [I already asked](http://www.reddit.com/r/phpstorm/comments/2yefsy/automatically_add_this_to_properties_or_variables/) on /r/phpStorm but it seems there isn't much going on in that subreddit.
Time to look for a new job!
Use an IDE (I recommend PHPStorm) and when you type the function name it brings up the parameter order, no need to check the manual!
Ha! I use something similar - the "th" is for $this. I have "t" for true as I use it more often. And I agree about live templates, they make life easier.
&gt; if ($this === $that) FTFY
Hallelujah. The un-catch-able PHP Fatal error for many common mistakes (i.e. calling a method on a null variable) is the one thing about PHP that I considered truly horrible about PHP.
The vlucas one, at least the last time I looked, uses a static call for the main entry point, whereas the josegonzalez one uses an object instance. (I prefer instances over statics whenever possible.)
How can we force everyone to upgrade their PHP to a supported version short of releasing a PHP 5.3.x and lower 0day and/or putting a gun to peoples' heads?
Running r-sync and waiting for Gulp to compile your JS/LESS isn't much more fun ;)
Now I know what pedantic means, thanks!
get_file.... wait... file_get.... or is it?
Yeah, well that's true. But I use $this-&gt; much more often than true so there's that.
Yeah, I'm not a fan of old versions. They're adverse to building secure websites. :P
what. the. fck.
You're right - vlucas does use a static method. Although that doesn't bother too much considering the config values will all end up in the global environment anyway. Calling the dotenv parser is simply a means to an end in that respect.
wooooooooooooooooooooooooooooow
With vlucas, the static entry point is only for convenience though, right? Is there anything to stop you from just: $env = new Dotenv; $env-&gt;load(__DIR__); Not to say there aren't good reasons to prefer josegonzalez's version, just that I don't see how this would be a problem. 
If you give someone hyphens, pretty soon they'll be asking for “smart” quotation marks everywhere.
Well, it's the only runtime for Hack, so if you want to use Hack, it's 100% useful because it's the only place you can use it. :D There's nothing about HHVM which necessitates that your site be huge. What scares a lot of smaller users off it is the unknowns. PHP has 20 years worth of community and infrastructure built up around how to get a server up and running, how to deal with the unexpected, how to tune once you're up, etc... Meanwhile, HHVM is similar enough to PHP that a lot of those resources translate, but not all of them, and usually not 1:1, so you tend to be slightly more "out in the wilds" at this stage. So that's a minus, but if you're the type to share your experiences, it's also a great opportunity to BECOME that expert resource for the next person. :)
I am astonished anyone other than me has thought that.
And each time I do that I sing ["Won't you take me to, fun-ci-town"](https://www.youtube.com/watch?v=OTVO6tznEmk) 
Trying to re-invent the wheel
As the author of the less used (josegonzalez/dotenv) version, here is why I wrote it: I was looking for a library to include in [friendsofcake/app-template](https://github.com/friendsofcake/app-template) to do env var parsing (because env vars are cool). I'm familiar with the "pattern" in other languages (python/ruby), so thought it wouldn't be hard to do in PHP. I was using the vlucas package originally, but that package uses a static call vs an instance, which is something that irks me for whatever reason. I couldn't figure out how to test it, so I decided against using it and looked for others. In the end, I couldn't find anything, so I wrote my own. I borrowed the regex (with modifications) from the dokku project I contribute to (original PR [here](https://github.com/progrium/dokku/pull/244)). I also took a few bits from the vlucas project where it made sense. One thing I departed from was not running code by default. I don't think it makes sense to have environment side-effects without calling a method/configuring something explicitely. As such, even the static method currently only parses the env, and doesn't actually modify the env/define anything without being configured to do so. I realize my project will be much less used than the vlucas one, and I don't expect Laravel to switch (I seriously doubt Taylor would use anything from a Cake Core dev). That said, I like my method just fine, and it seems to work well in projects I have. There are one or two features I'd like to implement (like filters that can modify the env var output), but for now it seems to work well. If you're using the vlucas package, keep doing so, it probably works for your use case and there is no sense switching if what you have is already working.
This reads like buyer's remorse justification. No actual substantial argument here, just "it's better, really, trust me!". The only real valid reasoning here is async calls, and we have PThreads for that until we get true async anyways.
&gt; that package uses a static call vs an instance, which is something that irks me for whatever reason I for one appreciate and applaud your avoidance of statics, and hope you continue to do so. :-)
I'm looking to break up some of my larger classes into many smaller classes to better adhere to the single responsibility principle, but I always get stuck on the best way to go about it. Take this `View` class and it's children for example (do note that it's Hack): https://github.com/titon/framework/blob/master/src/Titon/View/AbstractView.hh It currently manages data to pass to the view, manages helpers, manages lookup paths, manages template locating, manages locales, template rendering, caching, and more. What's the best way to break this up? Create `VariableBag`, `PathBag`, `LocaleBag`, `HelperManager`, classes, etc? Pass them in through the constructor? Or hard code them internally since they'll rarely ever change or need to be replaced? What about calling methods: `$view-&gt;getPathBag()-&gt;addPath()` or `$view-&gt;addPath()` which pipes to the bag internally? I can never decide on an approach that doesn't over complicate or over abstract everything. Any input would be appreciated!
HHVM is really neat. Digging it a lot 
Doesn't hack have great async functions? And what about Igor's react
Never stick to a regular naming convention
Thanks for the thorough explanation! That's very insightful. I'm actually using your version after all - I like that it doesn't insist on clouding the environment unless specifically asked to. I also like having the ability to add a prefix to my keys, thus avoiding clashes with anything else in my environment.
You are breaking the rules of this subreddit. If you find something interesting and wish to share it, do so in a subreddit appropriate for that content. Due to you breaking the rules, the post has been removed from the feed. Discussions about architectural patterns used by the community, which you complain about, is absolutely relevant to this subreddit. A pull request adjusting a license text for a front-end library is not. I'd advice you to adjust your behaviour in accordance to proper rediquette rather than acting all snippy towards people informing you that your content doesn't belong. It makes you look like an angsty teenager.
Show me how to safely generate random bytes on PHP &lt; 5.3 on Windows without ext/mcrypt :P
I really don't understand how that's beneficial. Once I can execute PHP code in your application's context, your elimination of one of countless possible ways to hide a backdoor has literally no effect on the situation. It's utterly pointless.
Wow. I can't believe you're serious. By that logic we should start submitting posts about toilet paper, because all PHP programmers go to the bathroom. 
I think you missed the point of that blog post. "you must run supported versions. And you must run a version with all known security issues fixed." Ubuntu 12.04's PHP 5.3.10 is supported and has no security issues. Stable versions are generally more secure. When PHP introduces new features it add the possibility that there are security holes in the underlining code.
As I said, "relevance to PHP" is a very vast subject and I think I am allowed to have an opinion on the matter. Still I find it "relevant enough" to not get removed from the feed, especially while it's upvoted. 
Can you retrieve all members? Can you sort them by date? Can you then limit the results to the top x results? You won't find explicit answers to all your query needs online, sometimes, you have to make them yourself.
Depends on a lot. If you can see purpose to its benefits now then go for it. If you are unsure hold off. But it also depends on if you know you can refactor later or not
Okay yes, you're right, I did miss the point there. I'll extend support to PHP 5.3 if the OS backports security fixes. I just want to pressure people into running secure versions :P
take a look at [react php](http://reactphp.org/)
Does anyone else think the "Context switching" or "everything in one language" plus-side of node is a bit of a cop-out in terms of naming advantages? Most people who do enough PHP (or RoR, py/django, etc) often have enough JS experience to not be bogged down by suddenly switching between languages. The point that is often missed is the fact that, even though its same language, you're still doing a significant amount of context switching. The syntax is largely irrelevant when (on the server-side) you're *still* dealing with stateless request/response cycles, data serving, API providing, etc while on the client side, you're doing real-time, UI-driven events, data fetching (polling/websockets), setting up states, tearing down states, etc. There are frameworks that help blur this line, but there is still way more context switching than just simply unifying syntax can help. The "everything in one language" piece is kind of a novelty feature rather than a practical one. I've used node from 2009 when it was still not really working on all platforms and I like it personally; I've contributed packages to the NPM registry and many projects surrounding it; basically I'm not trying to bash node here. So here are my suggestions: Why not focus on the new things it brings to the table? The author mentions asynchronous a little bit, but it's far more important than just the paragraph or two he mentions on it. It's a totally different style of programming that makes node particularly suited for evented I/O (and also introduces a steeper than expected learning curve for front-end JS enthusiasts). We can also mention how using events and callbacks help separate business logic from event triggering. A prime example of this is how PHP is based around single, long procedures while node forces the use of declarative, configuration-based approaches (in PHP, we have large frameworks to help us attain this, with node they are only lightweight layers). 
Know of any writeups listing the differences or teething issues you might experience spinning a project up on HHVM?
The only code snippet he included was to demonstrate that his JS and PHP source code looked almost identical, and none of his other points were actually supported. If he wants to demonstrate Node's superiority, why not provide concrete examples and real use-cases?
Well I too like playing around in both languages. When I first got into Node I found many similarities. It just felt as if I was writing my backend code with like my frontend without the DOM and with a database. But Node stil feels more like a toy rather that a viable alernative to PHP (with Composer duh...)
Unfortunately, it's not an entry point. All methods are static. Calling new on it is valid, but misleading in the end: you can end up thinking you are creating two different instances when in fact they're using the same static members.
There is almost no good reason to use a 32-bit OS over a 64-bit operating system unless (for some reason) your server doesn't support a 64-bit OS.
Running a 64-bit OS has a lot more advantages than simply addressing more RAM. For example, it lets you use 64-bit packages which will generally run better than their 32-bit counterparts. They are also not vulnerable to some issues that a 32-bit OS is and make use of some better security practices. There's a reason why Ubuntu no longer produces 32-bit server software anymore.
Honestly, I'd start any new project on Hack so that you can take advantage of its features right off the bat. Async is a pretty fundamental design decision to make early in a project, for example. It's not all about peppering in bits of syntactic sugar.
Fair point. Sadly, we'll probably never see a 32bit HHVM. Or happily, depending on your point of view. :D
I use it for all my small web projects nowadays: - the typechecker combined with strict scalar types saves me a huge amount of debugging time, even on tiny projects - I'm an XHP fanboy - Async can have a big impact, even on tiny projects - eg waiting for both curl and mysql data at the same time, without having to restructure your code to have a coordinator. This works much better if your project is designed with async in mind from the start - ideally so that you have one single $awaitable-&gt;getWaitHandle()-&gt;join() at the top level of your code. This means that you'll want a lot of your internal APIs to be async. - Even when I don't need asynchronous mysql, I like the queryf API (http://docs.hhvm.com/manual/en/hack.async.mysql.asyncmysqlconnection.queryf.php) - as an added bonus, the typechecker understands format strings, and makes sure you have the right number of arguments, and they're of the correct types. Disclaimer: I work on HHVM, and have recently been focusing on making these features available and easy to use.
they finally ditched the static calls in phpdotenv v2.
phpdotenv v2 branch no longer uses the static calls to instantiate: https://github.com/vlucas/phpdotenv/tree/v2 
Since it wasnt stated... Does the database exist in MySQL?
yes all names ar correct I changed them in to dummies just to post it online 
doubled checked them on my phpadmin so there is no mistakes in names.
LOL, I love nokia, and HHVM :D
So you would recommend that a VPS with only 1G of RAM would still be better off with 64bit? Personally, I would love to run everything on 64bit, but some of my sites just dont need the extra memory, and I dont need the extra cost. I have two project servers I just started, and if I am wrong in my thinking, now is the time to switch. so please convince me :)
You aren't passing the correct parameters, `mysqli_select_db()` expects two, with the first one being the actual database connection. Check out the "Procedural style" example [here](http://php.net/manual/en/mysqli.select-db.php).
If you attempting to generate 'true' random bytes using PHP; you have much bigger things to worry about. 
You're wrong on your thinking, and after reading that I think (and this is not meant to offend!) you're confused about the differences between a 32-bit and 64-bit OS. You don't NEED 4GB of RAM to run a 64-bit OS, you can use however much RAM you want - be it 64MB or 512GB. The problem with a 32-bit OS is that it won't ADDRESS more than 4GB of RAM, so if you want to use 8GB of RAM you can't use a 32-bit OS there because it will only be able to use 4GB. A 64-bit OS has no problems running with 64MB of RAM though. As for how to convince you, I build infrastructure for a living. We have over 1000 VMs running inside this infrastructure. Some have 512MB of RAM, some have 8GB of RAM, some have 128GB of RAM. We have never and will never run a 32-bit OS because there is literally no reason to with the hardware available today.
It's 2015. 
I use the "references" and "in_reply_to" from the result of imap_fetch_overview to lookup what I've already seen and do my own threading.
 &lt;?php $password = "password"; $link = mysqli_connect("localhost", "user", $password) or die("&lt;p&gt; Error connecing to database : " . mysqli_error() . "&lt;/p&gt;"); echo "&lt;p&gt;Connected to your Mysql database!&lt;/p&gt;"; mysqli_select_db($link, "mydatabase") or die("&lt;p&gt;Error selecting the database your-database- name: " . mysqli_error() . "&lt;/p&gt;"); echo "&lt;p&gt;Succesfully connected with your database-name! &lt;/p&gt;"; ?&gt; still the same
For the username example, yes, after database has stripped spaces it would violate the unique constraint and prevent the insert. But there might be other places where its not practical to define a unique index (email address for example - if you also keep historic user accounts and allow people to sign up again). 
 if ($a = $b) instead of if ($a == $b)
well i do like the idea of being able to "cast" the environment variables to types. So it's worth examining other options!
True random? lol http://sockpuppet.org/blog/2014/02/25/safely-generate-random-numbers/
Thank you! First hand experience means the most. No offence taken, though I am fully aware of that - I also know that 64bit OS's tend to USE more memory as well as allow for more to be addressed. I guess this has become trivial since I last looked into it deeply. I was under the impression that with just 1G the OS and system processes would fill that up quite quickly leaving very few resources to do whatever job I actually need them to do. Time to start from scratch, while I still can :)
Yeah, you'll be fine. There can be some wonky issues when you drop below 512MB, but those issues can just as easily happen on 32-bit. Most of your stuff can likely be ported over, and I don't know if I'd necessarily drop everything and convert to HHVM. I just wouldn't use 32-bit stuff anymore!
https://github.com/resonantcore/php-future/commit/c8101c00c6efbd8003939edad0d77fd7c20b37f9 I've updated the readme with a clearer statement of which versions we support. Thanks to /u/stephen-hill for pointing out my previous oversight.
I only have experience with a couple of stand-alone libraries, nothing with their Platform system. From my observations, though, Cartalyst has yet to firmly establish release schedules, versioning, and maintainability. I'm not sure if they ever actually "completed" Platform 1, and now they're busy with 2. I'm also a little put off with a development group that [needs help making their packages agnostic](https://github.com/cartalyst/sentinel/issues/45) ([screen grab if you aren't a subscriber](http://i.imgur.com/Njs8vfC.png)), when they already claim that it is. They have development talent, but it isn't applied efficiently (IMO). They're growing and learning, just like Laravel and other devs/frameworks did when they were young. I'm certain they'll stabilize more over time, but not enough to my liking at the moment. *I should note that I do not have much direct experience in recent months because of my initial perceptions. They may very well have stabilized more since. Hopefully someone with more recent, direct experience can add their views as well, as mine are undoubtedly skewed a bit.*
Are you designing this just for GMail? If you are, I'm sure it would be a lot easier to just use [the GMail API](https://developers.google.com/gmail/api/)
I kinda agree, most composer components are either very framework specific or huge monolithic packages. There's very little reuse between projects. Maybe we should start making more specific packages that do small tasks well than reinventing the wheel for every project.
I've never done that since I've never used "admin" as my username ;) ^^^I've ^^^definitely ^^^done ^^^\($username ^^^== ^^^"chiisana") ^^^though ^^^:(
Thank you for these suggestions!
that repo got deleted? wtf... and they use their own private packagist and require people to use it? https://cartalyst.com/manual/sentinel/2.0#preparation no thanks
LOL you don't even know what object composition is. Bed. Shit. Hard.
Composition is a different concept which is not directly related to the topic under discussion. so "Don't know what you mean by composition" =/= "I don't know what composition is" :) LOL.
I dont see a problem with your abstract view, I think if you follow through with this you will be needlessly overcomplicating things. The single responsibility principal is great, but remember the KISS principal is eaqually as great. Are you ever going to have to pull out or reuse the pathBag, variableBag etc? most likely not. The only thing you "could" refactor out is the locateTemplate function, a clue to this is that it is really easy to come up with a name for this that makes sence as apposed to PathBag. We could call it the TemplateLocator and its job would be to locate templates! That leaves your AbstractView as nothing more than a coordinator of view resources and I think that would classify as a single responsibility.
As you requests, I posted it to /r/python: http://www.reddit.com/r/Python/comments/2yguem/worlds_most_pedantic_pullrequest/ It's getting upvotes there and nobody is complaining. I guess that only proves what a massively unfirendly person you are
&gt; It's getting upvotes there and nobody is complaining 4 comments, 4 points, 22 votes and 59% upvotes. They are downvoting you more compared to /r/PHP, so that's a good thing. &gt; I guess that only proves what a massive dickhead you are You still don't get it do you? I'm not doing anything. *You* are violating the rules of this subreddit, which is why the mods have removed your post. I am consistently amazed at the poor quality of your comments and posts on this subreddit. Try to grow up.
The saying comes to mind "A mechanic doesn't blame their tools"
And again, I do not believe this post violates any subreddit rule. Rules allow posts indirectly related to PHP and pull requests are as related as taljs about architecture
Yeah I'll have to do it - I'll pick up a license later this week :) Really interested in learning to use XDebug so it'll be a good excuse!
Yup its fixed, check this out http://www.secforce.com/blog/2008/10/wordpress-sql-column-truncation-vulnerability/
how do you query database in react ?
Already fixed that =)
&gt; I can't think of any auth system that would grant privileges based only on username I can't think of any *respectable* auth system that would grant privileges based only on username 
I worked at a job where coding standards made us do else if's without a space like: } elseif ($condition == true) { JS requires a space between else and if or it is a syntax error. Thankfully my IDE catches this.
My old boss required us to invert the condition to help prevent these. It's called a yoda conditional. If you are comparing a value instead of variables it would be a syntax error. Doesn't produce error: if ($var = true) { Produces error: if (true = $var) {
gggggggnnnnARHGLUARGGLKUARGHGHGHGH!!!!! If I ever have to work with you, I will kill you. I spend hours on that shit. This is better, but then again because of X reason, maybe this... back and forth for HOURS. I wish I could just not care... Call your entity Quiz, your table quizzes. Easy Peasy, same accross the entire project. Now some fucking idiot calls his entity Media. NO! JUST FUCKING NO! Media is plural, singlural is medium. Holy crap I will lose my shit over such things. I just can't deal with it. I WANT TO KILL PEOPLE. Someone please send help.
Personally, I'd recommend using a proxy service such as [Nilas (formerly known as Inbox)](https://nilas.com/). It pulls in emails for SMTP accounts and exposes info (such as threads) via a nice REST API. Dealing with IMAP directly is not so fun.
Shitcode is the only vulnerability here. This and the referrer header article were both crap.
I'm writing a large intranet app at the moment. Part of the job is to migrate millions of rows from gzipped files into a database with the usual validations and manipulations. PHP5.6 was doing it in ~12 hours, HHVM is doing it in 3.5 hours. HHVM has a few memory leaks when doing these sorts of long running tasks tho. Another thing to watch out for is that there are a few PHP extensions that haven't been ported so I find I have to keep my code PHP compat so I can switch between hhvm and php when needed.
What the hell
Is this supposed to be an example of about 20 bad practises all in one script? Also, the bio at the bottom states this person has 18 years experience in security, highly doubtful! 
Reduce, reuse, recycle!
I don't know about you but I love seeing a simple 100 line app tacked onto an entire MVC framework.
I can't think of a respectable system that would have a backend actually online rather than offline.
You always can use: filter_var('bob@example.com', FILTER_VALIDATE_EMAIL)
I don't know what you are doing with php. Again, it could be a simple hello world and with no db/nosql layer. I know when I ran php, against my own code. It pretty much died. Damn, I also got confused with my earlier posting. It's not 2000 req/s. It's actually 918 since 55,103 / 60(sec) = 918 req/s. But, I think we are comparing apples vs oranges here. Yours = Localhost. 8 threads, 128 connections, 10 second test. Mine = Simulated real world traffic from Internet IP to my Internet IP. (hhvm) 32 threads, 2000 connections, 60 second test. Not exactly the same is it? Sure, I can run from localhost with my benchmark. I bet it's ALOT faster.
PhpStorm + PHP Advanced Autocomplete plugin = autocompleted date calls with common formats fully completed. It's cut down the number of times I have to visit that page dramatically.
&gt; apt-get install hhvm and then change 1 line on your nginx file Is it really that simple? Might have to give that a go, I have a fairly popular site that could benefit.
&gt; .+tab =&gt; "-&gt;" Why a 2 character "shortcut" to insert two characters?
This is not my experience.
Thanks for the input! My thoughts are currently pointing this way as well, so this makes a lot of sense. Very much appreciated.
I use both Node.js and PHP... aswell as dNode https://github.com/bergie/dnode-php
Not having a unique constraint on username isn't "obviously insecure"?
Oh, so things like openid and facebook login are bad?
Yes, that is bad design. My point is, at a glance, you would not know this code to be vulnerable to such an attack. It relies upon a separate vector to be enabled.
Coming from the Java/C++ world, I viewed PHP as a toy language until I learned it. It's matured a lot since then though so not exactly a valid comparison but I would say calling javascript and the node platform a toy language is a little ignorant considering how much flack php gets.
Which is fine, but [as you can see here](https://fightingforalostcause.net/content/misc/2006/compare-email-regex.php) the underlying regex that filter_var uses gets quite a few of the [test cases](http://3v4l.org/jietO) wrong. (Though that exact example might be a bug since it's inconsistently wrong!) When you take an email, it's atypical that you want to send email to it. So use your smtp server to do the validation for you. After all, if the smtp server can't send mail to it, it doesn't matter if it's a valid email address format or not.
Saying that "64-bit packages which will generally run better than their 32-bit counterparts" is entirely false, the only benefit is being able to address over 4gb of RAM, and actually even 32-bit Linux can access more than that if it has PAE. 64 bit apps use almost twice as much memory as 32 bit ones because memory pointers are twice as long. So using it on 1GB VPS will just burn through your RAM faster 
It's absolutely true if the package was written to take advantage of a 64-bit architecture, and as I mentioned there are way more benefits than simply addressing over 4GB of RAM (search 32-bit vs. 64-bit if you really think that - there are countless articles and papers on this). Additionally (and as I mentioned), yes they can consume more memory, but it's not as significant as you're making it out to be, though in fairness this does depend on what you're running. If they're getting to that point your VM was probably under-provisioned even on the 32-bit OS given the memory limits of the 32-bit OS.
It is not perfect and it wasn't meant to be ! The scripts works and does the job for me Thank you for your input If you have the time you can make it better you are most welcome :)
Anyone know of a mirror for the video? Unfortunately it's buffering every 3 seconds (unwatchable) on me currently.
Try directly through here: https://christf24.wistia.com/projects/5faksr3y23 Hope this helps. If not, please try again soon because it may be your internet
Spoiler: You wind up not using PHP for the important things where speed and load matters.
One of the main issues with Platform 1 &gt; 2 is we we're still learning. While our packages I feel we're pretty solid the versioning process from 1 to 2 was a huge mess. Platform 1 wasn't semantically versioned. I made the decision to refactor a majority of our packages to be agnostic at that point, semantically version them. This put Platform 2 in a release cycle that lasted almost a year. Pretty sad I admit. But I think it was the right call. Since we officially released Platform 2 in late January for Laravel 4.2. We we're able to update all 55 of our packages to Laravel 5, and platform itself in roughly 3 weeks. Platform 3 was released Yesterday morning. All to say, we've learned alot and I really appreciate your comment "They're growing and learning". I think that is so important as thats what we all do here every day. This is what I learned about writing agnost packages. https://medium.com/cartalyst-development/agnostic-php-packages-b5fb80a22cdd
 pubic
i did a lot of if ($this = $that) ...
I use Vim and thats the way i like it.
what does it do? 
Noooooo!
Yeah its about time, PHP4 constructors lead to many hard to debug glitches in PHP softwares and should have been removed a while ago. Oh I can see the sad face on Tony Marston, the author of 'Please do not break our language'. It must be a miserable day for him. XD
No, it's your host. 
omg i have to update a software i wrote 10 years ago!
Yeah, I don't get that (I caught your sarcasm, don't worry). If you're still maintaining something you initially wrote 10 years ago, that's all fine and dandy, but it should be evaluated/updated on a regular interval. It's not legacy if it's still being used. Keep that shit up to date.
interesting. does codeception includes a graphic module itself or is it run from console?
i think thats where my confusión came from on the first place. since i heard "you don't need to be aprogrammer to use codeception" i imagined a tester using a graphic panel. thanks for the response
Shoot. They must be having issues in certain areas. I'm getting in touch with Wistia. Thanks for letting me know!
They need to hurry and remove Mysql_* features, that'll teach the people who haven't updated a life lesson, don't code with error_reporting(0)
mysql_* is [already gone in PHP 7](https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7#extmysql) along with [a whole bunch of other stuff](https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts) (+ [alternative PHP tags](https://wiki.php.net/rfc/remove_alternative_php_tags))
But could he/she debug them when things go wrong. Which, with it being codeception, is quite likely to happen.
Thanks mate, I didn't know. Thanks for the reference too :)
Is there a transcript for this anywhere?
Yeeeeees?
To be fair, when the RFC was first created, the title was accurate in the now instead of in the later. It's a win in either case.
The title says that they are removed, and the RFC being accepted right now one could imagine that they are actually removed for PHP 7 (whereas they are not). I don't blame the RFC though, which is indeed quite clear in the content, but some people won't read it and will draw conclusions too fast ;)
Reading his writings on the constructor thing.. It's hilarious, especially as he seems to suggest that the fact only a small group of "saboteurs" are enough to push a change through... If something was truly malicious/bad, then there'd be enough awareness raised in the mailing lists/reddit/etc to have other contributors vote against it. 
&gt; Christopher Jones stated these extensions to be supported by Oracle. Oracle plans to maintains them further in the core. I hope that's true. We use an oracle database unfortunately, so I hope oci8 sticks around. Or my company realizes how bad Oracle is and lets us use Postgres in place of it.
Sorry it is not yet available, but it's being worked on :). I will let you know when it's up
According to PHP8, would this still work (below)? Is this the ideal syntax? Am I missing something? class A { public function __construct(){} } class B extends A { public function __construct(){parent::__construct();} }
Who came up with this unintuitive logic in the first place?
published apps?
Yeah, it really does depend on the app. But if its minimal, I'm sure an API beats IMAP ;)
I was a fan of the simplicity of the remember() method back in Laravel 4 and wanted to bring it back. This initial version just brings back the core query caching functionality, however I intend to expand upon this to allow it to also cache the loaded relations (for example, when using with()).
What are the rules regulating that type of majority is required? Some I see are simple majority and others require 2/3 to pass.
Sorry, we only allow telecommuting job postings here on /r/PHP, as well as a noteworthy position.
Men are anxious to improve their circumstances, but are unwilling to improve themselves; they therefore remain bound.
\Agree
I've never heard of this plugin, sounds nifty.
&gt;now PHP has some awkward bullshit called __construct() PHP has had that for at least a few years. Don't complain that the language is broken when you don't know the language properly.
Oh, I wasn't aware it was removed from Laravel 5 (I'm still on 4.2 for my projects big enough to require remember()). Do we know why it was removed ?
It's been bullshit for at least a few years.
my boss is using that plugin and indeed its awesome, the only issue with that is that i don't know how to make versionings of it.
What guy?
Oldie, but goodie: http://www.tonymarston.net/php-mysql/breaking-bc-is-evil.html Can't forget about this guy too! http://www.tonymarston.net/php-mysql/please-do-not-break-our-language.html
Ah, afair he was against removing it befor having it offocially marked as deprecated and this rfc was turned to do exactly that (and btw this was the reason why I voted no for the original idea to remove it in 7.0).
Other languages also DONT use the class name as the constructor....
The point is that you generate :COMPUTED_HMAC based on :TS, and then ensure that :TS is a certain short time ago - 10 seconds, in this case. You **don't** generate :COMPUTED_HMAC based on :COMPUTED_TS. That way, your clock times can drift by 2-3 seconds without much trouble (probably), and you can also cope with slow connections.
Which is why we can use PHP instead of C in the firstplace, and also why switching to HHVM for that performance boost is a stupid idea unless you really have exhausted all your other options.
Or just use !false. \^^
How can you fire open source contributer?
hey, thanks for posting this. I'm editing this publication on Medium (although I didn't write the article). I wanted to let you know that I'll be posting 1 article / week on a programming topic (not necessarily JS- or PHP-related), you can subscribe to the blog here: https://medium.com/unexpected-token Next two articles will be: - How to make Meteor webapps communicate together - Predictably debuggable: node.js domains This is an initiative coming from eFounders, a startup studio hiring extraordinary CTOs to build startups (9, we've built VC-backed companies so far). If you wanna know more, you can visit our website http://efounders.co/ or ask me here. Cheers
This code is exactly what you should write, yes.
you can't stop merging emails
It seems like it was huge break of the separation of concerns principle. Remember() implied that there HAD to be some sort of a caching system used, and while I think it is indeed useful the current Cache::remember seems like a much better idea IMO
9 times out of 10, these "how we scaled to a zillion views" articles always boil down to "we added a cache layer and some load balancing".
It is not. Old constructors are getting removed, like promised in the title. Only not in the immediate future, like some frisky people wishfully think. *Edit: Great work, by the way! Many thanks!*
Exactly as /u/lordofworms said. What you said probably explains why it was removed from the core framework, but sometimes I just want to get shit done, knock some stuff out and throwing remember() on to a couple of queries just makes it a little easier to get a performant product out the door. It's not for everyone, but if you're upgrading a L4 app that uses the caching or just a fan of simple query caching then this is a simple solution.
Personally, I don't see the problem with allowing use of the class name as the constructor. If you're naming a method the same as your class name, you're probably not using a good name. But the __ prefixing differentiates methods that PHP sees as a hook for specific actions, which is a much cleaner way of handling it. If you're using class name as the constructor, then what are you using for the destructor? Then apply that a bunch of times over for the full list of [magic methods](http://php.net/manual/en/language.oop5.magic.php).
HHVM is also good if you are looking to control costs by needing fewer machines.
whatAboutThePeopleWho_use_both_camel_and_snake_caseTogether? 
Can't you just extend the base model and add it if you need it? It's not like it's much work. You don't even need to inject a cache manager since Cache:: calls are static anyway
In terms of potentially altering code so that it matches a standard (PSR-1 &amp; PSR-2), I'd prefer https://github.com/FriendsOfPHP/PHP-CS-Fixer to the new PHPCS functionality. That's just because I've used Fabpot's PHP-CS-Fixer, but not the PHPCS 'fixing' functionality. In any event, you've probably got the code under source control, so you can easily see what has changed before it's committed anyway.
You're right - it's replacing E_STRICT with E_DEPRECATED. Same point either way, though. The fact that few people would even see the E_STRICT it would throw before, and use that information to clean up their code, means they also won't see the E_DEPRECATED, and undoubtedly there will be many teams that don't start changing their PHP4 constructors until they're completely removed years from now.
I've actually implemented a custom DB based session handler in the past, unfortunately the way the sessions are handled in APEX this is not possible, as APEX sessions are only accessible by the APEX application and not other DB users/schemas.
That's precisely correct - an HMAC is a Message Authentication Code (i.e. it authenticates that a message came from a certain source), not the message itself.
xxs. End
That's @PHP_CEO talk.
My point is that this really isn't covering any new ground that hasn't already been written about and solved many times over. The headline above is a bit disengenious because this really has little to do with "scaling PHP" and more to do with how they implemented Redis, Nginx, et al.
Great stuff!
The only values that should coerce to a bool in a type hint are `1` and `0` from an int, float, or a string. Anything else is just looking for trouble. 
What happens if I pass an argument by reference? function foo(string &amp;$a) { ... } $a = new SomeClassWithToString(); foo($a); var_dump(gettype($a)); // ?
X-posting from the mailing list as this RFC would be really quite bad imo. Voting no due to: i) Having conversion rules be difference in userland to internal functions. You list 'Single Mode' as a benefit of this RFC, but it's only single mode if you gloss over this difference. This is a massive cognitive load, and will be one of those issues that catches users out again and again. Why on earth should a boolean be convertible to int for some functions but not others? What will happen when someone writes code that extends an internal class and overrides one of the functions, is that the person who is using that extended class will have to alter their code to use the extended class in a different way to how they would use the built in class directly. For everyone who didn't pick this up in the RFC, it's hidden in the large chunk of text: "Unlike user-land scalar type hints, internal functions will accept nulls as valid scalars." ii) The subtle BC breaks. false -&gt; int # No more conversion from bool true -&gt; string # No more conversion from bool btw You appear to have only tested this code against barebones frameworks. These are often written far more cleanly than actual applications so I don't think the report of 'very limited' BC breaks is accurate. iii) Having conversion work, except when they don't. People who want weak type hints want weak type hints - they don't want code that breaks unexpectedly. function foo(int $bar){...} foo(36/$value); // works when $value = 1, 2, 3, 4 breaks when $value = 5 This is neither weak nor strict type - this is a horrible hybrid that would only catch people out. But finally, the fact that a significant part of the RFC is talking about how the behaviour will need to be cleaned up in a future RFC, but at the same time that some of the problems will be left for five years show that this isn't a sensible RFC to vote for, even for the people who just want weak types.
Not read them yet but upvoting because you made the effort to write them at least! 
It's not US, but can't say enough good things about the Dutch PHP Conference. http://www.phpconference.nl/
if you mean deployed within the company VPN, than yes.
A good IDE like phpstorm or intellij will give you static linter type code analysis. You can pick and chose from a list of things you deem verboden and issue warnings if you try to commit. You can also do "analyze code" for your project and get a compiled list of dirty laundry to go through. That's not exactly a script though, if you're looking for something like a precommit hook to flat out reject such commits.
It's possible to build a site engine in JS that uses rest calls to a server running PHP which returns small amounts of data in a Json format instead of a typical PHP site engine though... Just saying
Well, node is still server-side, it's just Javascript instead of PHP. Angular is purely front-end, and so for most apps, will need data fed to it from the backend (via either JS/Node, Python, Ruby, or PHP). The need for backend and a server will never go away (in fact, it will become increasingly important). The question then becomes, will JS (via Node) eventually replace PHP as the server-side language of choice? Maybe - but I wouldn't bet on that. You'll likely see Go challenge PHP more than anything. That said of course, websites written PURELY in PHP (with PHP templates and things) with some jQuery sprinkled in won't cut it anymore. If you want to be a full stack developer, you need to know PHP with strong JS skills (preferably in a framework like Angular or Backbone or Ember). Also, for pure JS solutions, look at Sails (built on Node and Express) with an ORM and all kinds of goodies.
This is a complete clusterfuck IMO. Not just the RFC itself but the conduct of Zeev et al on internals (at least from what I've seen). &gt; However, given that unlike the introduction of STH - which is a new, previously unused feature that will (for the most part) not affect existing code - changes to what internal functions would be willing to accept could have substantial compatibility implications. What about existing userland code that wants to update to type hints? Now you have to prepare for massive BC breaks, edge cases (int-&gt;bool but no float-&gt;bool?) and inconsistency with internal functions.
JS has many great features but is still a new language with high use with new/small projects and low use within huge projects and enterprises. Ruby took more than 10 years to still be used by huge projects and enterprises (and many of them, later, switched to Java) and i think JS will have the same use. PHP has good tools and, now, patters to be used by huge projects but, for what i think, the future aims for everything running inside a JVM.
&gt; It doesn't bring up unit tests (which Symfony was shown to have many failures). This is a catch-22 really. From what you said before the vast majority of the test failures were due to testing edge cases, passing incorrect types etc. So surely those tests *should* fail? (Or rather, the function call inside the test should fail, and the test expect that.) In other words, CTH doesn't mean Symfony's code is suddenly all broken. Of course that doesn't excuse the fact it creates days/weeks of work...
&gt; Per the voting RFC[7] a minimum of 1 week of discussion is required from when the proposal is announced for vote and when voting is opened. I brought this up and asked voting to be postponed a little[8] . I was immediately told no[9] by Zeev. Derick then brought up the voting RFC[10] . And Zeev again said no[11] . Sounds like Zeev just wants this to fail. Why doesn't he just pull the vote?
this is great thanks
No I mean like. A tool built from an amalgamation of libraries. As an example you can look at pithos: https://github.com/pithos/pithos/wiki/Installing-from-Source to install from source it requires: python3-setuptools python3-dbus python3-pylast python3-gi python3-gi-cairo gir1.2-gstreamer-1.0 gir1.2-gst-plugins-base-1.0 gstreamer1.0-plugins-good gstreamer1.0-plugins-bad gir1.2-appindicator3-0.1 gir1.2-notify-0.7 gir1.2-keybinder-3.0 gnome-icon-theme-symbolic All libs serve one isolated function and were not written with pithos in mind. Then pithos is released back to the community.
I haven't really been following too closely, but here is some baseless speculation. ircmaxell's scalar type hint RFC, which Zeev opposes, says: &gt; This vote is opened on February 26th, 2015 and will close the later of March 13, 2015 or the date that voting closes on a competing RFC. So if Zeev withdraws his RFC, then scalar type hints looks set to pass on Friday. If Zeev's RFC is not withdrawn, then I guess there is a better chance that the scalar type hint RFC will fail.
wait.... what? switching to hhvm is a stupid idea? Why is that exactly? Switching to HHVM after you have solved all the issues, give you a much further boost AND then allows you to reduce the number of boxes you need, reducing costs.
I've written two posts here about ReactPHP in the same sort of vein, although less organized. :) I fully support this.
&gt; iii) Having conversion work, except when they don't. People who want weak type hints want weak type hints - they don't want code that breaks unexpectedly. Glad to see some voting members catching this and pointing that out! That was my immediate reaction, that it should either work 0% or 100% of the time, not depend on which selection of a certain scalar type was passed in. I can see a very real-world scenario too if you have some math functionality that may yield a float with no decimals or float with decimals. Or even worse, may yield an int or float depending on your input.
Or at least Zeev would be unable to put his RFC up for vote if he waited 7 days after his latest change to his RFC.
&gt; The general interpretation of that date is that voting has to have started by the 15th. Right, since Zeev made the change yesterday, it means it the vote could not be started until March 17th. Unless someone wants to make the claim that *a* vote has to be started before the 15th, even if that vote is later withdrawn.
Well, I'm mostly curious to hear if it scales well. Javascript and by extend NodeJS has been designed for this type of work, and a NodeJS application will typically only work well if there's a minimum number of CPU cycles being spent in between waiting for IO. PHP is not. This is not something I see as a flaw of ReactPHP itself, but rather the underlying PHP engine. The entire engine designed to _just_ spew out a HTTP response quickly in a single thread. I've been experimenting a bit with PHP's libevent and stream_select for real-time log processing and that worked fairly well. I imagine that ReactPHP would probably have made that a bit easier to do as well... but I'm curious if anyone built any high-load application servers with these. I haven't heard much success stories other than simple one-offs yet, so that causes me to quickly classify it as rather experimental.
Worse, he made changes over the 26 hours before opening the vote. I can't tell what since the wiki won't let me diff.
* Performance is almost never going to be impacted by your framework, at least not enough to matter once you add in caching. * The first several times you use a framework, you *will* write your code in such a way that it is a jumbled mess. You will also tie it into your framework of choice so much that will *need* to rewrite your codebase from scratch because it won't be easily portable. You will eventually get better, though. * I wouldn't recommend Kohana anymore. Go with something newer. If you're new to frameworks, try Laravel. Eventually you can move on to something else like Symfony2 if you want. * If you're good enough to go through the framework's code to figure out if it has any security issues, then you're already smart enough to be using a framework. Make sure to use a framework that is in active development. That's why I don't recommend something like Kohana - it's dead and if there's any security holes (there are), it's completely up to you to fix them.
&gt; Is it worth to sacrifice performance and flexibility over a rigid framework with the risk of "getting stuck in a quicksand" and rewrite your project because you don't feel comfortable with it? Very few modern PHP frameworks are "rigid". Also, very few modern frameworks sacrifice performance. Sure, a framework will have more to bootstrap than a functional PHP site, but it doesn't mean that it's the end of the world. Remember, there's more to performance than just the code. &gt; Is it worth learning a framework or a simple plugin that is in alpha or discountined like Kohana framework? Yes and no. You shouldn't learn something that you don't intend on using, but learning how things *used* to be done and how they are done now (if you don't have that personal experience) can help you gain valuable knowledge. Seeing how problems can be solved in different ways will broaden your experience as a developer. I would always learn a new tool that I intend to use on a regular basis before learning something that is just for kicks. &gt; How do you handle security issues if they're hidden somewhere in the framework core? I'm talking about Codeigniter which had some serious security flaws in the past Having a proper support system around the framework is a key to success and stability. Modern frameworks such as Symfony and Laravel have a lot of users and regular maintainers. This question isn't really for you as a developer, but is more a question of how maintained is the framework or library you're using? That said, you should try to never blindly use third-party software. Always vet the project in some way - look through the code yourself, get opinions from other people who've used it (take those with a grain of salt sometimes), etc. Your questions overall give me the impression that you either don't understand frameworks, or you're afraid to use them. These are the *wrong* questions to ask if that's the case.
Awesome thanks! Just start with the first post and go on from there. The first few introduce a couple of core things before moving on to other things like using sockets and child processes (coming soon).
There is nothing in the PHP engine that inherently makes this sort of development difficult. PHP can be used just as event based as Node, just as functional as Haskel, and just as OOP based as Java. You just shouldn't do all of those at once. PHP is a language that is limited by the developer more than almost any other language, because one of its driving ideals is that you the developer are always assumed to know better than it the program. That's why some things that are just straight errors in many other languages are handled as "best guess" in PHP. If you do something stupid, PHP assumes that you're so smart that you knew exactly what drawbacks being stupid like that has, and that it was actually part of your intended design. People have perceptions around PHP that are heavily influenced by the work they do in them. Most people do most PHP work in software like Magento, Wordpress, Joomla, etc. and these pieces of software were mostly influenced by software written long ago in either Java or PERL. Because of this, most PHP developers can only think about PHP in a Java or PERL type paradigm. They feel that that's just how PHP behaves. But it isn't. That's just how some of the most mature free software in the language is written. PHP isn't any worse at non-blocking IO or event loops than Node, that just isn't how most PHP developers think. If you have spent your entire career building Java-like apps in PHP, you're likely to use ReactPHP incorrectly, because you can't help yourself. Because PHP doesn't **stop** you from doing that. PHP assumes that the developer is always more correct than the interpreter. This is one of its greatest strengths and one of its greatest weaknesses, depending on what you are trying to do in PHP. As for your main point in this reply, we're still in some testing phases, but if you'd like I can capture and distribute some "at scale" performance for ReactPHP once we complete our testing in a few months.
I've used CodeIgniter for 8 years and never had a single compromise of any website. There's more to creating a secure site than the choice of the framework. If you look at a platform like WordPress, which has a huge user base and tons of resources available online, the real security weakness is actually introduced BY that community in the form of poorly-written plugins and designers that quickly (and cheaply) build sites for clients and then walk away. It's the on-going proper management of a website that keeps it secure, not just which platform or framework it's built using. If you build a website using the most secure framework available and then walk away from it for 3 years, there's a very good chance it will have become vulnerable to some exploit in that time.
Of course PHP can support other programming paradigms than just a java-esk way of doing things, but it doesn't mean that it's particularly well suited for this on a high scale. If scale is not a concern, then you are of course correct. PHP itself is a rather slow language compared some of the other examples you name. If more time is spent in an average PHP function, it means that on average more events are waiting to be handled. This is detrimental to performance in a node application, and it will be in a ReactPHP-like application as well, except that it will be worse *because* it's PHP. A single slow function will block every other thread. If you're building a webserver or FastCGI server with ReactPHP, you will feel this pain.
Yeah I've seen them pass by, keep it! Love to see more of those, especially since you do a completely different style then I'm doing. We need more of this out there
&gt;I'm still learning a lot about security. I have an online form that I currently have being submitted, creating a pdf, and that pdf is being emailed to the company and the user. Is it mailed manually or automatically? What is the consequence of forged data? &gt;creating a pdf This could potentially put a lot of strain on the server. &gt;Does anyone have any references I could see to learn more about this? http://en.wikipedia.org/wiki/Cross-site_request_forgery
Once it is submitted I use PHPMailer to send the email. There is some personal information on the form. There haven't been any reports on the server. The company said they want a pdf so I'm not sure of a way around that.
It's a member application form. It has things like address, email, phone number etc. The PDF is just used for the company to be able to review the information submitted. As far as the consequence of a forged request, I guess that's what I'm trying to figure out. I am not storing any information using cookies or even a database. So wouldn't a forged request just send the company a member application? 
We've gone and fully moved towards using it in the project that my company is building. There's been a lot of work, but the speed and memory usage is amazing. 
CodeSniffer is probably the one most people will turn to. Not sure if it can correct errors - but I certainly can report on pretty much anything you define. 
And both of them are happening soon! Phil is coming on next week. Feel free to send me questions you'd like to have asked :)
I'm guessing he is referring to details being submitted to the server over HTTP, rather than HTTPS - leaving the form open to "man in the middle" attacks. Depending on the sensitivity of information sent - you might want to look at adding HTTPS to this section of the website. You could also argue mail between server and company mail server (assuming not on same server) could also be open to man in the middle attacks - could look at encrypted email and/or SSL/TLS over SMTP. Other concerns raised here in other comments really are about performance (PDF generation) and rate limiting (thundering of requests) - not really security issues at all. From what you have said on the surface - sounds good to me otherwise. 
This. There is like almost no information about Ratchet or ReactPHP out there. 
&gt;So wouldn't a forged request just send the company a member application? Yes, but how do they use that application? Surely the company should have a process for handling forged applications, and if not, they should get one. It should be part of their risk management plan. Also, I'd like to circle back to the to the creation of PDFs and how it might put a strain on the server. The reason I mentioned this is because it can be done intentionally to bring down the server (See [Denial-of-service attack](http://en.wikipedia.org/wiki/Denial-of-service_attack)). 
Ok fair enough, guess I was misinformed. I do hope your RFC passes, right now it's a little borderline.
1. Depends on the project you are making. Is RAD (development speed) more important than performance? Startups often make v1 of their app in Laravel/Rails/Django then when their full stack framework gets a bit slow and the feature requests/pivots slow down enough they can rewrite it in something compiled, or at least something more lightweight. Or just throw another server at it. 2. Depends on the framework. Using discontinued software sounds like a really bad idea in general, but NodeJS have been doing it a while. 3. Keep up to date. If your framework is installed via Composer this is almost done for free. [VersionEye](https://www.versioneye.com/) makes updates even more obvious, smashing them right into your inbox.
Make sure that, the form is Protected by Cross Site Request Forgery. https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF) 
Crap. With barely a day left to go on ircmaxell's RFC, too. I wish the bit about waiting until the end of a competing RFC's voting phase was never put in there. Magnanimity is not a virtue when dealing with individuals who will stop at nothing to get their way. In hindsight, and perhaps for next time something this tricky comes up again, a two layer voting process might be the way to go. Maybe have each RFC vote for admission into a final "select from competing accepted RFCs (if necessary)" vote or something.
&gt; Besides which, the estimated length of effort is being ridiculously exaggerated every time it comes up, for greater effect - and that's disingenuous, at best. Mainly because the information we have is from well tested applications that were coded using good practices. We don't have any information about the billions of lines of code out there that are untested and made using whatever horrible practice the developer chose that day.
CI is working on being more actively maintained now. It's still just CI though which is fast and fairly easy but eventually I missed some of the more advanced features like working migrations, ORM and a standard way of applying authentication like Laravel provides. If you aren't going to do much work then definitely stick with something simple, if you are writing, adding and maintaining apps with multiple components and dev/production servers I think the time spent learning a more advanced framework pays out in the end. I constantly forget to add tables to my production server over the period of writing the modifications and new features. Performance for most of us will never be an issue that can't be resolved by db design and then some form of caching. The programming rule is to not spend time trying to optimize until after you find there is a time problem. Profile the time spent and then only spend extra time optimizing that one area. Security in a widely use framework is most likely going to be better than anything you write yourself. Other people also have a vested interest in finding those security issues while you might be off adding features.
Well, last paragraph wasn't meant to be taken too serious hence the quote. But yes, the other stuff is.
https://www.glype.com ?
I apologize for the unintentional mishap. Do you know a good forum to find solid PHP talent. I will have a couple of telecommuting jobs available soon. 
Your company is making a framework built on react too?
Yes. :) I designed most of the architecture for it.
&gt; If you want to be a full stack developer This sortof discounts all of the existing stuff out there that will need maintenance. It's quite a jump to throw away something that works fine as it is in favor of a new SPA just because it's the trendy thing to do. Pretty sure there will be room for the traditional non JS-heavy full stack developer for several more years to come, though I agree it's where the future is headed.
&gt; calling functions with many parameters is a lot slower than calling with fewer parameters What about calling a function with an associative array of values for the function to use instead of using individual functional parameters? That's how I normally see it done.
Other languages make whitespace meaningful, should we do that? Other languages use the same operator for concatenation and addition, should we do that? "Other languages" is not a valid argument, this isn't another language, it's PHP.
Yes.
I don't think lack of information justifies scare tactics. "We don't know" is honest and conveys the potential risk just fine.
TIL LTS=1 year.
&gt;while others like Symfony ... get up to 200ms. You mean cold though, right? And probably with debug on? This is a request to a Symfony app running on my desktop (which is due for replacement) - 12ms: Concurrency Level: 1 Time taken for tests: 0.012 seconds Complete requests: 1 Failed requests: 0 Total transferred: 281 bytes HTML transferred: 4 bytes Requests per second: 84.62 [#/sec] (mean) Time per request: 11.817 [ms] (mean) Time per request: 11.817 [ms] (mean, across all concurrent requests) Transfer rate: 23.22 [Kbytes/sec] received
&gt;Is it worth to sacrifice performance and flexibility This is horseshit. The sacrifice you make is in learning curve, but I've yet to meet **anyone** who has made this sacrifice and not been delighted with the outcome. &gt;Is it worth learning [something] in alpha If you think it will help you solve a problem &gt;Is it worth learning [something] discountined like Kohana framework If you inherit some code and have to. &gt;How do you handle security issues if they're hidden somewhere in the framework core One of the advantages of using a third party framework is you get to outsource this. Just use a respectable third party.
&gt;"Other languages" don't make whitespace meaningful. Then you proceed to mention one. &gt;Languages that are compiled, like C++, can afford to use "+" for concatenation. And yet scripting languages that use + for concat still exist, as you mentioned! Way to ignore the point (that your premise is wrong) too!
No you can run into that in any scenario where something may or may not be set. There's nothing special about the _POST superglobal in this regard. Imagine a function that takes an array of options and you need to act on certain ones. You're right that verbose code isn't necessarily worse code, but he really should be using `!empty` for this pattern. It's just as readable as his first line with the functionality of his second.
Nice job not reading. Do you work for the PHP foundation or something?
Yeah one wonders how deliberate waiting for that thing was... give the longest possible time to hurt Anthony's RFC. Still, I'm quietly chuckling at the amount of no votes Zeev's fail proposal is getting. So much for driving consensus :) 
It's called branding. Nothing wrong with coming up with a brand to release packages under. So what if it's a "self-elected elite"? Fascist? &lt;sarcasm&gt;Yeah, it's SOOOOO fascist to create quality packages and distribute them for free.&lt;/sarcasm&gt;
&gt; 1) Is it worth to sacrifice performance and flexibility over a rigid framework with the risk of "getting stuck in a quicksand" and rewrite your project because you don't feel comfortable with it? Woah, lets just jump straight into a very loaded question. Worth sacrificing performance? yes - most of your problems for most applications you are going to write, the bottleneck is still going to be the database, so there is in general not a *huge* loss. The tradeoff in terms of productivity is immense. People cost a lot more money than just throwing hardware at the problem. A lot more. As for lack of flexibility... a lot of developers who have that "flexibility" write big balls of unmaintainable mud.. You wont get stuck in quicksand if you are careful and architect your solution properly (one major mistake would be allowing the framework to completely dictate the architecture to you). The benefits are many - but perhaps the largest one is that a framework buys you a lot of the boilerplate that you'd otherwise have to write. &gt; 2) Is it worth learning a framework or a simple plugin that is in alpha or discountined like Kohana framework? Probably not. There are a number of great frameworks which are currently maintained and modern development platforms. &gt; 3) How do you handle security issues if they're hidden somewhere in the framework core? I'm talking about Codeigniter which had some serious security flaws in the past A lot of this comes down to framework selection. A well maintained framework, you can submit your security concern to the maintainers and typically it'll get fixed quickly. 
You fundamentally misunderstand what I just pointed out. It's not about blocking or not blocking on IO. Of course you should do this, but this is completely irrelevant to my point. My point is that the time spent *not* doing IO, i.e. in PHP functions will be higher.
Omnipay is in their own namespace. Just part of the league organization on github.
that would make it not a DBAL lol
Version 2.x comes with a tool, phpcbf, to fix errors.
1) It's unlikely that your choice of framework is going to cost you any significant performance. Adding hardware is cheap compared to developer hours. A main stream framework is always going to be a better choice than baking your own. Further more, your application and your framework should be two separate things. E.g. you don't write applications in Symfony but in PHP. You then expose your application to Symfony through the use of a bundle. Symfony should just be the HTTP layer, not your business logic layer. 2) Doesn't sound like a good idea. Sometimes something that is alpha now can be very popular later on. If you happen to be an early adaptor, great. using a dead framework like Kohana, hmmm, not such a good idea. 3) Well, I guess there are two sides to this. a) it might be difficult for you to fix security issues in a framework (I assume that's what you get at) which leads to b) if you roll your own framework there might be security issues you don't even know about. At least a popular open source framework has many eye balls and often loads of smart people involved. It's a good thing to stand on the shoulders of giants. 
If you can't upgrade even after being given one whole year, then you're honestly doing something wrong.
Has anyone used reactphp for parallel processing of scripts / programs? If so, can you share?
When their "long term" releases [have bugs](http://www.reddit.com/r/PHP/comments/2ypcpo/hhvm_360_lts_released/cpbq2os), then yes, I am weary of upgrading. Also, I'm not sure if you know what it's like in the real world. My company has to physically fly out to some our clients to perform an upgrade because of their policies and procedures. Some of our clients are still on Windows XP and IE7. Upgrading is not always trivial. Not to mention all the testing *we* have to do to make sure its compatible with *our* software. I've been bitten by HHVM a couple times already. That said... I don't mean to take away from the work FB is doing. I think this is great, but it's going to be awhile yet before I trust it.
Every piece of software has bugs. Long Term Support means that we will backport fixes for a longer period of time.
Yes, that too.
When you say "read user 1", does that mean it reads a record from table "user" with primary key "1", or does it read the first record from the "user" table? If the former, how does it find the what the primary key is? Secondly, are the underlying classes immutable or not? i.e., does the fluent interface return new instances or modify the current one? --- Okay, nevermind. I looked at the source. It assumes the PK is called "id". And the classes are not immutable. And the field and table names are either [not escaped](https://github.com/erusev/base/blob/f4d02a2eaf614fd61ad749dbd3d039ae23663001/src/Collection.php#L46) or [improperly](https://github.com/erusev/base/blob/master/src/Collection.php#L412) escaped.
2) If we're talking about annoying (but not security-related) things that might come through a comment form, here are some of the things that you can block: - Excessive whitespace (e.g. pressing Enter 100 times and adding a lame joke at the end). Look for lots of empty paragraphs. The exact pattern will depend on your WYSIWYG editor's configuration. - Weird, confusing, and possibly misleading Unicode characters, such as ʇxǝʇ uʍop ǝpısdn. If your website only caters to English users, ban any character that doesn't belong in [Basic Latin](https://en.wikipedia.org/wiki/Basic_Latin_%28Unicode_block%29). This can be easily done with a regex. - Be careful with multimedia content, such as `&lt;object&gt;`, `&lt;audio&gt;`, `&lt;video&gt;`, etc. HTMLPurifier may or may not allow some subset of them depending on the configuration. If you allow too much, it can get annoying for your users. 
Dang, that imploded. I apologize to whoever felt offended by this. My wording was clearly off. Some of the things written on their page doesn't appeal to me but reading it again, it doesn't warrant usage of "elite" and "facist". Thanks to reddit lesson hopefully learned. 
The main problem is that we only support non-LTS versions for ~ 6 weeks, so people tend to move off them quickly. Bugs found in later versions may not even exist on the newer one. That said, that might not be an unsolveable problem; I'll think some more about it :)
Paul M Jones (of Aura), although that's likely just because he seems hell bent on trying to wind up Phil Sturgeon.
If I understand correctly, your main struggle is to define a schema for your DB. If that is the case, you could try to use a document oriented database, instead of relational database. In such case, you will eliminate the schema from equation and each object (_car, bicycle, plane, etc_) will represent a single document in your db and because there is no schema, you can add and/or eliminate new types of objects on the fly. However, this is just an idea and you should document yourself for pros and cons of using a nosql db instead of relational db, because not everything is good in nosql land.
wordpress has such a database which basically has an key/value table for exra properties for posts this works really well for sites that have a limited audience and are not build to scale too much, if you forsee your site becoming really big (we are talking about beyond 10 mio customers) then its better if you either code a good update mechaism wich can alter the table scheme of an sql database OR you use a document-related scheme like MongoDB / CouchDB etc 
When I first started using reactphp two years ago there wasn't any mysql component to work with. So instead I've started using elasticsearch and redis instead for anything running within the Ratchet websocket process. In more recent times I've been pooling `child-process` processes to do anything blocking in them. (Such as database connections and CPU heavy actions.) Another step I'm taking is running certain things as gearman workers for these type of things. Remote filesystem access can be done use the pool I've mentioned above but for local I'm working on [react/filesystem](https://github.com/reactphp/filesystem) to get async filesystem IO in the reactphp loop. The results are really promising but need to finish all the features you want in it first before it will be ready. (Currently working on duplex streams.) Getting current packages/libraries to play nice with react or any async system in php in general is going to be interesting. Supporting promises like [Guzzle](http://guzzle.readthedocs.org/en/latest/quickstart.html#using-responses) does is one way to go but mostly they're written in a blocking fashion. I'll go into it in later blog posts how to do these things :). P.S. ReactPHP is much more then something that can replace FPM, so anything is possible from small bits of react in your current stack till running the webfacing app on it in a single process. Also check this out: https://github.com/marcj/php-pm 
Because it's not a drop in replacement. You don't just switch, you must put many, many hours into it, and if your projects are not extremely well supported by automated tests, then you can expect to put many^many^many hours in. What are your expected cost reductions for all of this expense?
I think a better option would have been to have a verifiable badge people would be allowed to apply to their package that would certify it as "the league certified."
Thanks. I would love to attend that, I just don't think my boss will finance that.
Add Fluent to that list
"Entities" table, list of entities with Two columns: entityID, name 1, bike 2, car Then have an "Attributes table", list of attributes. Four columns: attID, entityID, name, value 1, 2, "colour", "blue" 2, 2, "horsepower", "300" 3, 1, "colour", "red" Then have a query that selects all attributes for your entity. Hope that helps 
This is [the information you are looking for](https://github.com/thephpleague/thephpleague.github.io/wiki)
I see the part of 'much slower' would be the problem of how to format the eventual value-field, since that can have anything from a single digit to the contents of a book in it if I am not mistaken. I take it thats the big con of using EAV or am I missing an obvious solution to that problem?
Quality as in a basic minimum, which if you actually read that link you would see is just following PSR-2 &amp; PSR-4, writing unit tests and documentation, using continuous integration and semver.
is a document oriented database not an option? eg mongodb?
There is a lot more to what defines our packages from a quality perspective. The items in that checklist are more a reference of how we package our packages, not necessarily how we write them. I agree, maybe that list needs to be tweaked or the wording changed on the left. We all work together to hold each other accountable to writing good code. This involves things like using good design patterns (and avoiding bad ones), reducing code duplication, minimizing coupling between classes, naming things properly, aiming for clear understandable APIs, allowing for package extending, and the list goes on.
Thanks for your negatively. Looks like a [trend](http://www.reddit.com/user/aztek99).
Having worked in all three solutions... ultimately, Document Stores are likely better long term. The querying aspect of MongoDB can be puzzling at first, but worth it. EAV can be difficult to troubleshoot and navigate, and if you only have one table for each, you can run the risk of table locking and it just becomes a hassle. I have actually done the "ugly solution" Adam mentioned above because I didn't know any better... and let me tell you it is def ugly. So.. my vote is for Document Store.. again, like Adam said, it allows you to move the logic of the application to your PHP code and not worry about FK constraints or other things.
How is it presumptuous? It's just a play off of The League Of Extraordinary Gentlemen...
Zeev just wrote he would vote yes to ircmaxell's RFC if it looked like both RFCs were failing. Everyone seem to think that some kind of type hint RFC should pass. I would guess/hope that voters won't ultimately let ircmaxell's RFC fail.
I did raise my eyebrows at this line in Zeev's RFC &gt; It absolutely requires a 2/3 majority, with the hope of reaching as close as possible to consensus. It reads to me like he honestly though that he could get close to 100% support for his RFC. Given the zillion revisions, refinements, and failures of Andrea's type hint RFCs to gain consensus, it seems to me hubris that Zeev thought he could waltz in and gain complete consensus with a half-baked RFC (half-baked e.g. because he changed the coercion rules just before putting it up for a vote).
You can find the not-so-secret discussions on the mailing list: https://groups.google.com/forum/m/#!forum/thephpleague
Yes, that is the security issue I am worried about. So ideally I need to just set up a DB and do away with the email? The information is sensitive. I said above it holds personal information. I thought it would be less likely an attacker would bother with getting into 'sales@company.com' than to be able to access a db. I guess I'm wrong on that which is fine, I just wanted to be sure. Thanks for the help. 
I'm just glad it's tanking so badly. If it was close, or even if it passed but by less than Anthony's, I wouldn't put it past him to push for his to be adopted as the "best fit" because he's "an original architect". As it stands now his vote is going to go down so badly that perhaps he'll forget about pushing for his stupid idea once and for all. 
FFS, I'm feminist/"SJW" as all get out, but it's not being called "The League of Extraordinary Packages made by Gentlemen". That it's a riff on the title of a comic set in 1898 doesn't make it sexist.
Damn phil! Give it some REST!
It's not scare tactics. It's truth. This will break applications. And it will break them in a way that requires a human to figure out why (you can't reasonably build a tool to do it, short of placing casts before every function call). Which means that to upgrade, you need to test. A lot. Because it's not just one or two places. It's every place. It's every code path. It's every source of input that can cause problems. We don't know the scale (tens of errors or hundreds of thousands). But we do know, for a fact, that these errors will occur. Zeev himself doesn't disagree. The fact that there's no way to tell is precisely what makes it scary. It's not "scare tactics" if it's true.
I'm going to Lonestar PHP, my first PHP conference. Should be fun!
Maybe you shouldn't use bleeding edge software if upgrading is such a pain in your environment?
If I could vote, i'd put a -1 on the CTH RFC. It looks like Zeev wants to screw the STH RFC, or acts like a spoiled kid who'll do anything it takes to go against what he doesn't like. But it seems his tactic has failed, STH keeps getting +1s, and his -1s. Happy dev is happy, I want strict types, and I'll get them :D.
I have to say, overall, Phil Sturgeon seems like a pretty cool guy. If you've never heard of "The League of Extraordinary Gentlemen" the name might seem pompous. But really, he (and the people who contribute to the League) have the aptitude to back up the ego that some people think they have, so it's a moot point. My experience with the league: Sent pull requests to the league's oauth2 server, they were reviewed and implemented quickly and discussed reasonably. 10/10 would audit again
Read the different bits of documentation on the individual components [repositories](https://github.com/reactphp/), read the source code and gain experience with using them.
I'm trying to understand the main mechanism which enables async methods and promises here. With React, it sounds like the processing is being handed off to an external system (Gearman) and the results are gathered after it's done ..??
Agreed, looking into what from these posts can be put back into the docs of the difference reactphp projects in one way or the other. Could even look into proposing more docs on the reactphp.org website. But that aside I love to see more people blog about it!
Why wouldn't we want this to be a run-time error? Silently destroying the original value seems like the worst possible way to handle the situation.
Thanks for the info! I visited some repo, and for some reason the readme wasn't displaying. I was like "who build something like this with no documentation?" haha, It's all showing now, maybe a mobile issue. Thanks again!
Cheers, have fun learning. If have questions ping me here, on Twitter or join the freenode #reactphp IRC channel. 
I understand, I posted it here since this has great influence on how I will eventually program the PHP-code behind it. The 'not a support reddit' I figured that was about getting help to get PHP to work in the first case... My bad.
PHP itself currently would do that if your foo function was: function foo(&amp;$a) { $a = (string)$a; } In either of these RFCs you're basically doing the same.
In your example, you're explicitly telling PHP to overwrite `$a`. It's completely different behavior, even if the end result is the same.
It's not FUD, it's reality. It's also not *weeks* of refactoring, but *months* for a codebase of any reasonable size. What too many people gloss over is what happens to internal function calls when typehinting is enabled. With CTFA and STH in strict mode, all calls to PHP builtins now honor the typehints found in *all* of the existing internal functions. With STH strict mode, you opt your own code into running in strict. It's a choice that you, as a developer, make. When doing so, you'll be forced to make sure the types are correct, coming in and going out, calling user-defined and internal functions. You can take care to perform testing on your code in small, segmented chunks. In CTFA, there is no opt-in. You get typehints on internal functions by default, whether you want them or not, whether you are prepared for them or not, over all of the code, whether written by you or not. Ever think about all those horrible third party libraries you rely on? If CTFA were to pass and STH were to fail, the first thing I'd end up doing to my codebase is to hide every single last one of the notices it raises, because we would never at any point be able to effectively address them. It took us four years to clean our massive codebase up to 5.3 standards... so long that 5.6 was out before we were done. I simply can't imagine ever getting away with another cleanup of that scale in the near term. Hell, we still have to run with an error filter that excludes missing array key notices. CTFA is the wrong solution right now. STH with the default weak mode and optional strict mode is a more safe and sane way forward for PHP7.
One of the advantages JS has had was superior asynchronous services. This is improving with both PHP7 and Hack (and ReactPHP). I think in many ways this is going to make php more node-like in some of its responsiveness capabilities.
If with early return vs elseif shouldn't have any impact on your CRAP, npath or cyclomatic complexity (etc). With that being said, readability is king - and elseif wins in this case as you're making explicit to the next developer that one of two things will be executed. With sequential if statements the next person must read the body of the first statement and ensure all paths within it return in order to reach the same conclusion. If I saw this during code review I'd also flag this as a concern, including the above rationale as my justification.
Some constructive criticism: **Dealbreakers:** 1. No composer support 2. No PSR-0/PSR-4 autoloading or namespacing 3. No tests 4. No attempt to sanitize input used in `exec` 5. No license file - even if I wanted to use this at work, it would be illegal **Other Significant Issues:** 1. Weird, inconsistent formatting of variable names 2. Incorrect usage of docblocks, for example `@param resolution format example 1200x900` 3. No validation or checking if the required extensions/libraries exist before using them 4. No usage of Value Objects when it would seem pretty obvious for several methods 5. Why bother with a constructor if you hardcode the path to ffmpeg anyway? 
See: [Object Callisthenics](http://williamdurand.fr/2013/06/03/object-calisthenics/#2-don-t-use-the-else-keyword). Readability almost always improves greatly when you can remove indentation.
Once you are past the learning curve, I would say that frameworks take some of the drudgery out of development. You can have good authentication, CRUD, ORM built into it from day one. In addition you can leverage work from other developers who find flaws or provide framework patches. Finally some frameworks offer scaffolding which makes jumping right into writing prototype code more fun, especially for proof-of-concept ideas. 
Thanks for the name... By googling guard clauses I have come across http://sourcemaking.com/refactoring.
Thanks for the link 
It doesn't seem egotistical in the slightest it's a tounge in cheek reference to a piece of pop culture. Some people just seem to take things way to seriously.
Just as a clarification this is something I have picked up after seeing this being advocated for as being the better practice and also due to encountering it in multiple libraries. Is it generally frowned upon due to the lack of transparency in communicating to the next developer? My belief is that returning early would be analogous to exiting the function by throwing exceptions. 
Using the full If, If Else, Else set usually ends up with a big noodley mess of code pretty quickly, and is usually much more fragile as well. The pattern above allows for a much greater level of readability and is slightly more robust as it means you're keeping all required actions within a single code block instead of potentially spreading it out or repeating yourself across the rest of the If statement. If Else, specifically, can almost always be replaced with a switch statement as well, which is again, much more readable and more robust. I don't know that using If/Else If/Else is really worth being *reprimanded* over, unless you're on an open source project with a strict style guide, but the above pattern would definitely be the preferable choice the majority of the time. 
I'm not certain that I understand the question you're asking - my apologies if this is response is slightly tangential... For the simplest case of a single conditional I prefer to use a variable with a default value which is overridden in the body of the if and returned as the final statement. I'm a fan of multiple returns for the slightly more complex of 2-3 branches nested no more than, one level deep. In these cases the reader can easily see the and understand the function body at a glance - and brevity aids rapid comprehension. I would, however, still make each branch an elseif rather than 2-3 standalone if statements (for the reasons I posted originally). For more complex cases I'd argue that multiple returns lead to code that is more difficult to reason around - guard clauses are preferable to deep nesting, but where possible I prefer decomposing the method into several smaller ones adhering to the preceeding requirements.
&gt; I'm sorry, but that's not an estimate - it's a joke. I have a couple hundred thousand SLOC of ten year old legacy *crap* to deal with here. The application runs almost every aspect of our business and manages how our 75 employees do their jobs every day. Changes are slow and careful because not being slow and careful breaks things. There have been numerous times where we've fixed things to silence an E_NOTICE only to have to pull out the fix because it butterfly-effected something somewhere else entirely different and unexpected. If CTFA passes, we're effectively never going to be able to move to a version of PHP that makes internal function calls perform strict type checking. CTFA proposes this for the next major release after X years, and it *still* won't be anywhere near enough wallclock time for us to even consider *another* comprehensive audit of the codebase. I don't know what kind of codebase you're dealing with here, but you should probably stop making assumptions about what *others* are dealing with. It's going to take *us* years, and we're dealing with some pretty crap code. Now imagine what mediawiki, what phpbb, what all the existing PHP scripts out there are going to have to deal with....
&gt; Some people just seem to take things way to seriously. Bingo, you've just found 90% of the cause of Internet drama.
&gt; It took me over an hour to get PHPUnit fixed from its own test suite. "Over an hour" doesn't really tell us much out of context. How many instances did you fix in that time frame? Were you intimately familiar with the internals of PHPUnit as most dev teams will be with their own apps? The RFC says only "several" issues were found in PHPUnit, so I'm sensing some extenuating circumstances were in play here to make the LoE so high. &gt; Yes, we are erring on the side of alarmism. Because the other side is pretending there's no issue at all. And that's nuts IMHO. Both extremes are equally nuts. The only reasonable approach is not to resort to extremes at all.
Why no one uses ZF2? Or let me ask in this way; why it is not popular? Is something wrong with ZF2?
What you're describing is a pretty standard legacy app scenario. You aren't special in that regard. What you don't seem to have a very good grasp on is the actual potential issues at hand, and how that translates into prevalence within your app. You do not have "months" (I'm going to pretend I didn't just see you upgrade this to "years") worth of fixing the BC breaks this RFC would cause. Did you grok the RFC details? You do realize that the things that would be rejected afterwards are things that would *already* be breaking your app, right? And you still think you have a legitimate 320+ hours of solid fixing of cases where you're passing arrays into string functions and obviously broken things of that nature? Legacy is one thing. What you're talking about is a *completely non-functional* app. &gt; you should probably stop making assumptions about what others are dealing with Did you really just play the "everyone's different" card after making this previous claim that started the discussion? &gt; It's also not weeks of refactoring, but months for a codebase of any reasonable size.
Thank you!
No, an assignment instruction is explicit. The value being overwritten within the engine due to having no other reasonable way to handle the combination of a by-ref pass and weak typehint is *implicit*, not explicit. It's the same difference as an explicit cast vs. an implicit cast: $foo = '1'; $bar = (int)$foo; // explicit cast $bar = $foo + 1; // implicit cast Using `$foo` in an integer context is not an explicit cast. You are not telling PHP to cast it. PHP casts it for you without being told to do so, which makes it implicit.
&gt; My belief is that returning early would be analogous to exiting the function by throwing exceptions. Pretty much. There's no point funneling all the possible scenarios to the very end and then having an else-throw-exception clause. 
Great video, I'm really interested in PHP, scaling and caching so this was a really interesting video for me. It also gives me hope that I could amount to something pretty decent without going to college :)! Edit: Please can you make a video about your site, the tech it uses, any difficulties you have had with it. I'm really interested !
Yep, let's think positively, I also hope people will ultimately make it happen.
Okay cool, thanks for explaining that. A couple more questions, if I may. Do all the devs run a local development server (on their own computers) in addition to the development/deployment system? As in, do you push to the Capistrano server to trigger a deployment?
Joking aside, thanks to /u/ircmaxell for the in depth blog post. Love reading detailed articles like this and learning about PHP internals.
&gt; that doesn't stop them being slower in the first place, right? Sure, but the issue is that statement makes as much sense as "that doesn't stop them being yellower". It is meaningless to say your framework is faster without context. &gt;It doesn't have as many features, but it's quicker - and therein lies the tradeoff I was talking about. C is quicker. Why don't we use it? You're throwing out an entire framework to save a couple of milliseconds. It's not a trade-off, it's stupid. And claiming Symfony has a 200ms overhead is extremely irresponsible for someone with your reputation. 
&gt; The problem here isn't with bcrypt itself. It's with the combination of bcrypt and other crypto in an unsafe manner. I disagree with that. `php_crypt` is passed the password length. The error occurs because `php_crypt_blowfish_rn` and possibly other places doesn't use the provided length and instead they try to figure it out on their own -- but they do so incorrectly. &gt; The underlying problem is that combining cryptographic operators that weren't designed to be combined can be disasterous. In this case, I think the underlying problem is that "password" is no longer precisely defined. Are we defining a password to be only printable characters, and anything else is invalid input? Or are we defining a password to be any character except null? Or can a password be literally any string? Unless some documentation explicitly says otherwise, I think developers' expectation is that password_hash should be able to take literally any string. EDIT: But still, upvote for spotting the problem and describing it well. :-)
Enjoyable and scary as always from Anthony Ferrara. Thanks to the user who posted it
Well, I don't. I'm not using HHVM for this reason. I tried it, and it didn't work for me. I *like* the idea of HHVM, and I would *like* the to use it, but I can't because it has too many bugs right now. It's not reliable. That's why I'm bummed about this.
If anyone wants to use encrypt(password_hash()) like /u/ircmaxell suggested, here's an example that *will* work and is much safer than rolling your own, but definitely don't use my code as I am not a professional cryptographer: https://gist.github.com/sarciszewski/443f094dac3d0b4de84a
Dude you can just ask us. 
It'll be under League\ soon.
Who are we to tell other people how to write code? Not into that idea at all. Luckily others are working on it, having metrics of success to give scores and help people work out if the package is good or not.
I didn't say that. I said instead of branding the packages under the league namespace you could have set the same exact standards you put forward as your standards and then gave a badge to all those packages that did meet that standard. I guess I would have to wonder... if you found many many packages that met the standard.... would your packages really be that extraordinary?
Why? In a lot of cases you don't really need it and it only adds complexity. He said he *rarely* uses it, not *never* uses it.
hah, we would all be so lucky if that happened :)
&gt; You rarely use else? This scares me a little. You can reconstruct almost any logical path to use as few `elses` and `else ifs` as possible, returning or throwing exceptions early, and making your code much flatter and more readable in the process. If you're writing shit like this... if ($user-&gt;isAdmin()) { if ($this-&gt;closed) { $displayed = "Closed (not for you)"; } else if ($this-&gt;inEvidence) { $displayed = "Open and in evidence"; } else { $displayed = ""; } } else { if ($this-&gt;closed) { $displayed = "Closed"; } else { $displayed = ""; } } ... you're doing it wrong.
&gt; With that being said, readability is king - and elseif wins in this case Disagreed with you here. That may be true for *you*, but not for me. Two consecutive `if` guard clauses is MUCH more readable to me than `if, elseif, else` UNLESS it resulted in a lot of unnecessary duplicate code. It sounds like this guy's boss has a problem separating logic from personal coding style, which would immediately prompt me to start looking for another job. Nothing is worse than a manager who reprimands you for not being an extension of his brain...
That's why password_needs_rehash() and other similar implementations are important. If a user succeeds in logging in after an update to the algorithm has been pushed, you can rehash their entered password and store it using the updated algorithm.
&gt; I rarely ever use else How would you write that snippet (which I would never write anyway)?
&gt; I think developers' expectation is that password_hash should be able to take literally any string. I think if we looked at this through the lens of the principle of least astonishment, we'd find that the expectation is for `password_hash` input to come from a typical keyboard, and thus it should handle those characters fine, but not characters that a user would not typically input from their keyboard. I don't even know how I'd enter a null byte from my keyboard. I wouldn't even go so far as to enter some alt+numpad combination to get an ascii character. Thus I wouldn't even expect `password_hash()` to work on characters like ♦»Æ, let alone literally anything.
There actually is pretty much a master switch: hhvm.force_hh = true; The main effect is that it allows you to use hack syntax - lambdas, await, etc - in PHP files (though the typechecker still won't look at them), but it also raises hard failures in a few situations where if it thinks you are very likely to have a subtle bug, eg using array_fill_keys with doubles (bad because http://3v4l.org/gvfc9)
This is something I think so few people really understand. Two things kill companies whose primary products are digital: 1. Brittleness - kill off the company faster because users get fed up with bugs 2. Rigidity - kills off the company slower because they cannot adapt to changes in market, or to competition. The solution to both of those problems is tests. Even if you have atrociously designed code, tests give you the confidence to modify it - you can at least brute force your way through brittle, shitty code to implement a new feature if you have the tests to back it up. But if you don't have tests, and your code is a nightmare, you become reluctant to change it, and the instant that happens, you have a rigid system. Or if you do charge ahead without tests and start hacking apart brittle code, bugs. Bugs everywhere.
Agreed. Also, suspicious number of upvotes relative to comments considering this article has no real substance.
Well, this is not a weakness in the algorithm, but a bug in the implementation. Totally different things..
FTA: &gt; Base64 encode the raw output of a pre-hash ... If you are using raw output, encode it first, and you're safe. Then I must ask, is there an advantage of doing something like this then? $password = 'weak'; $key = '...' // some key derived from a crypto library $prehash = base64_encode(hash_hmac('sha256', $password, $key, true)); $hash = password_hash($prehash, PASSWORD_DEFAULT); And if there is an advantage, and you know it's safe, why *not* do it? Is the prehash algorithm above *always* guaranteed to safely add entropy to the input of password_hash?
I'm assuming the KEY constant is supposed to be a stand-in for an actual, raw binary blob, right? It appears to be hex already, so your `bin2hex()` calls are taking the codepoints of each hex character and "rehexing" them. In other words: Your key literal Its binary representation Final output | | | 4ff556f7... --&gt; 34 66 66 35 35 36 66 37 ... --&gt; 22424223232442...
&gt; Thus I wouldn't even expect password_hash() to work on characters like ♦»Æ, let alone literally anything. It's one thing to not expect it to work on NUL bytes. I think it should, but I'm not astonished that it doesn't given the purpose of the function—to hash passwords. But I would be completely astonished if it arbitrarily rejected anything non-ASCII.
&gt; I didn't say that. I said instead of branding the packages under the league namespace you could have set the same exact standards you put forward as your standards and then gave a badge to all those packages that did meet that standard. We are not trying to run around the internet saying who we think is good or bad. That is a misunderstanding of the groups intentions. As I said, who are we (a group of friends and I) to tell other people how to write code. &gt; I guess I would have to wonder... if you found many many packages that met the standard.... would your packages really be that extraordinary? We aim for being extraordinary. That just means we try really hard to do well. Nowhere are we saying we're all epic and shit.
Seems to be a biproduct, but never the intention. Unless you were already being a twat.
Yes. It's nuts. It's like this group is pissing on everyones cornflakes for simply existing. https://philsturgeon.uk/php/2014/10/16/what-is-the-league-of-extraordinary-packages/
You need to make sure you make a distinction between people **using** a technology and people **writing about** the technology. ZF doesn't have a lot of excitement and hype with people writing about it, blogging, evangelising, etc, but there are still quite a lot of people quietly using it to build things.
What a huge mistake. You can hire philsturgeon to do the same thing but code will run [10x faster](https://www.reddit.com/r/PHP/comments/2yp8ok/some_questions_to_php_framework_users/cpck5m1). 
It is based on PDO, so it supports all of the drivers that PDO supports: http://php.net/manual/en/pdo.drivers.php.
Thanks for the feedback! &gt; And the field and table names are either not escaped or improperly escaped. This is a valid point. I'll see what I can do about it. &gt; And the classes are not immutable. Could u elaborate on this, please?
Thanks! It doesn't, but it's a good suggestion. I'll think about it.
You are seriously suggesting a reduction in password space based on the keyboard in front of you right now.
Oh whoops, that's what I get for writing code right before bedtime. Edit: fixed in rev 4
What do u mean? I don't understand.
Jeez people calm down! &gt; and arbitrarily chose Who tells you it's arbitrary! It's fine if the author doesn't explain in this very article why they chose Symfony. The title shown on Reddit might have confused you but let me remind you the very first paragraph: &gt; Why would a successful organization **toss out an excellent open source web development platform** that had an avid developer community? That’s the story I’m here to tell. Hey, the story is about why they ditched their good enough custom framework for an existing one. So fine, Laravel, Cake, whatever… Don't go to your pitchfork just because they mentioned Symfony and you just happen to not like it…
That a darn fine collection of articles I also just found a few days ago over at /r/coding... 
I'd disagree with switch is more robust, since switch uses loose comparisons, for example this would trigger both echoes: switch ('12') { case 12: echo '"12" is 12'; break; } switch ('12') { case true: echo '"12" is truthy'; break; } This should at least be kept in mind.
You can use the command as a DTO and set data on it. http://programmingarehard.com/2015/03/04/structing-my-application.html Search for "controller" on the page.
Wow, that is a brilliant write-up. Thank you for the link
get the testings on to the git repository, save them, commit them and execute them elsewhere. Or edit the files in text to make tweaks
The parent commentor suggested the "League of Extraordinary Packages" was exclusionary because the League of Extraordinary Gentlemen was exclusionary.
Not sure if it's just a typo, but it's json_encode(). You've got a space in there.
Thanks man -- I tried that (that being JSON.parse(data.FailReason)), but it's showing up as undefined.. I'm starting to think because I don't see any brackets around it [] .. maybe it's still a string? I wonder how come it has no brackets .. EDIT: JS is calling PHP file calling a REST server ... so maybe it's ALREADY json encoded .. let me just try without force object because i didn't try your suggestion earlier with this) EDIT 2: You were 100% right -- it was 2 mistakes! Your fix and the guy below. Cheers~
Nice!! I think this is the answer, i'll get back
Probably because we're on reddit. It's an endless pit where time disappears. :)
Uh, no, more like advertising for op's company.
&gt;Don't go to your pitchfork just because they mentioned Symfony I could have not been any clearer that I though OP was advertising for his company, and the only reason why the mods even allowed it is because it had something programming related in the title. This has nothing to do with my preference of programming tools or any bias. The reason being, for an article about switching an entire code base, nothing technical was mentioned in the slightest; nothing about PHP, programming, symfony or any other framework. Just "ez does this" and "ez does that" and "our customers love ez!" &gt; It's fine if the author doesn't explain in this very article why they chose Symfony. What is the point of writing the article? That's literally the title. "Why we switched to symfony." All they did was talk about their company and what open source is, which is why I suggested it was written by the marketing department and not an actual programmer. I love learning from fellow programmers by hearing **real** reasons as to why they chose to do something a certain way, not marketing fluff without actual content.
Sure. The first error looks like this: &gt; Fatal error: Uncaught exception 'Exception' with message 'ERROR: syntax error at or near "`" LINE 1: INSERT INTO `customer` SET `name` = $1, `address` = $2, `age... ^: INSERT INTO `customer` SET `name` = ?, `address` = ?, `age` = ?' in /home/projects/basetest/vendor/erusev/base/src/Base.php:197 Reddit is stripping out the backtick character in the reply. View the comment source to see it. Postgres does not like it, so I changed it and then the following happens: &gt; PHP Fatal error: Uncaught exception 'Exception' with message 'ERROR: syntax error at or near "SET" LINE 1: INSERT INTO customer SET name = $1, address = $2, age = $3 ^: INSERT INTO customer SET name = ?, address = ?, age = ?' in /home/projects/basetest/vendor/erusev/base/src/Base.php:197 That insert statement is totally invalid on postgres. It should look like &gt; INSERT INTO customer (name, address, age) VALUES (?, ?, ?) Remember, PDO itself is not a DBAL at all. All PDO gives you is a familiar API that you only have to learn once. You still have to craft SQL that will work on all databases you intend to support. So I suggest you install these other databases and try out your code on them :)
Disclosure: I'm working at eZ Engineering and was highly involved in the technical discussions we had at the time. The author is not technically. At least not in current position as he is Product Owner at eZ, so he know the business decisions that were made very well but was not involved in the technical parts. So no conspiracy here, the article is just not meant to be a technical one, some of the pieces that are technical where edits I made to avoid misunderstandings. On the technical side it was a clear win: - Symfony 2.0 just came out, and moved way beyond other frameworks in terms of quality, expandability and potential. - It's approach to HTTP as the native way to cache has benefited us greatly and continues to do as we extended it further something that is now been moved to the independant FOSHTTPCahe lib. *The clear HTTP (request/response) approach is something Zend just announced for future Zend Framework 3 btw* - Zend was working on v2 but it was clear it was far from as big step as Symfony2 made - Symfony had a lot of traction in the PHP ecosystems, something it continues to do and will continue to do with Drupal8 out - The Symfony ecosystem is great and very vibrant, the Zend Framework ecosystem has never really seemed to be close on this - CakePHP was more or less dead, Yii a niche micro framework and Laravel's coding style and use of singletons all over was not good signs when it comes the first point I made, besides it adds another level of abstractions that we would have to build on top of - Our main alternatives where using Zeta Components and writing something new, both would involve a lot of effort, and not provided any of the collaboration opportunities we have gained by using Symfony For me personally the only real argument against Symfony (and other large PHP frameworks) was performance, uncached. But we are a CMS, so it was ok as our sweet spot is when content can be cached (varying on user rights and other parameters, and reliably banned on changes to the content of course) and the cache speed is good (roughly 500req/sec per server with PHP, or as much as you want with Varnish). However PHP 7.0 / HHVM / Symfony 3.0 have the potential to change that noticeably.
Right, if anything I find myself using $arr = (array) $someObject; More than anything else.