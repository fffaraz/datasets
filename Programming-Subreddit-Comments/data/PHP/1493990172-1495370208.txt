It is my understanding that many people underestimated the power of SQL Views. Views are amazing at concatenating contents from other tables, and keeps the interface from SQL to PHP (and vice versa) strict and manageable. Something that is usually preferred over having two implementations in SQL and PHP, respectively, doing the same thing, which - in time - may diverge and break things. Views also work nicely with many ORMs, including Doctrine. You have a `User` table with a `firstName` and `lastName` columns, and you need to search across both of them for the entire name? Create a view that trims both columns and concatenates them, as such: CREATE VIEW `UserView` AS SELECT `user`.`id` AS `id`,CONCAT(TRIM(`user`.`firstName`),' ',TRIM(`user`.`lastName`)) AS `nameDerived` from `User` `user`; Voilá. You can now simply join in the view instead of making big, crazy SQL queries with subselects and what not. And you can use their columns in `WHERE`, `ORDER BY`, `GROUP BY`, etc.. As Such: SELECT * FROM User u JOIN UserView uv ON (u.id = uv.id) WHERE uv.nameDerived LIKE "%John Doe%"; (Of course apply input sanitazion of "John Doe", etc. when using PHP variables to avoid SQL injection. Basically, use PDO.)
It was about that time when I noticed that this well known framework creator was about 500 feet tall and from the paleolithic area.
I spend more time than I like working with/creating Crystal Reports reports with a SQLServer back-end - views are a must in this situation. Also I'm a fan of [CTE's](https://technet.microsoft.com/en-us/library/ms190766\(v=sql.105\).aspx) in T-SQL.
Haven't really used stored procedures or triggers with PHP + MySQL, but I have used views for a certain degree. I like to keep things with PHP hooks. That said, one should always use proper schema constraints. Foreign keys, unique keys, indexes, etc. Offload the calculation, sort, and filter parts to the database (aggregation functions, joins, sorts, Geo calculations, etc). 
Had a very poorly organized database and needed very annoying joins, subqueries, full outer joins, etc to answer common questions. No matter how many indexes I threw at the table most queries were too slow. Turned the slowest parts into views and now everything is fast.
I suspect we may be getting a bit off topic. Configuring form types as services was, to me, a much cleaner way to customize form types than always having to remember which options are needed for which types. Keep in mind that the way options were handled actually changed several times during the S2 development cycle. And I was not the only one using services. I keep an eye on stackoverflow and quite a few developers were unpleasantly surprised by S3. 
I also had form types as services, that didn't break
TL;DR: Corma is allegedly faster than Doctrine mostly because Corma uses an upsert to insert / update multiple rows at a time when saving so [there is an artificial test as a proof](https://github.com/thewunder/corma-benchmark).
&gt; I'm always afraid that it obscures the transparency of my applications. This. While using views, SPs, and triggers might be helpful in a *very well documented* application, most of the time that app isn't well documented and those db functions become frustrating "features" to track down. Anecdotally, this happens to me on about a quarterly basis depending on where I am focused at work. I end up pouring through code only to have the light bulb go off a couple hours later along with an audible "fuuuuuuccccckkkkk". 
&gt; Some programmers don't even know that views are often faster than queries because the database can pre-compile the underlying statement and skip to execution and that views update automatically and atomically when data in the underlying tables change. Most databases cache common query plans anyway, though. 
Because it's so much easier to add to your deployment processes a database versioning and migration tool that will deploy a 'create or replace view' command when you decide that you also need the middle initial in the nameDerived, than it is to deploy code with an updated query. *cough*
I try to keep data definition stuff, including unique indexes and foreign key constraints, in the database. Show me a database that doesn't enforce constraints and I'll show you data that would fail those constraints were they put into place. I prefer to keep logic in application code. That said, my projects tend to have a 1:1 correspondence between application and database, so I can do this fairly easily. - I like the idea of views, but haven't yet had any reason to use them. The primary use for these appears to be in presenting a restricted or simplified interface to the database for other clients that connect directly to the database. I'm thinking, for example, of giving someone direct read access to the database for reporting purposes. They give you more granular control than simply granting permissions to individual tables. As an example, you want to let the reporting user see the users table, but want to filter out sensitive information. Deny access to the users table, create a view to it that includes only the approved fields and maybe adds a couple of filters, and grant read-only access to that view. - I avoid stored procedures simply because I find that the logic in them is harder to write, harder to debug, and more fragile than application code. Where they shine for me, though, is when I have operations that are heavily intensive on I/O but simple on logic. It speeds things up considerably when you don't have to send the data back and forth between the database and application. - I also try to avoid triggers. They have all of the downsides of stored procedures with the added bonus of easily turning into a mess of chained updates triggering off of one another. Think of events triggering more events and potentially running full circle into an infinite loop. A careful developer will avoid this, but triggers force you to be extra careful with your data integrity at stake if you mess it up. The main use for triggers, in my mind, is if you have multiple users for a single database and you're attempting to refactor the database. Database refactorings that aren't simple additions or deletions will have some intermediate state, where both the old and the new are sitting in the database side by side. Triggers are the perfect way to keep those two locations in sync while the client applications move from using the old to the new.
Because you cannot use that in a `WHERE` statement, as per the example above. `ORDER BY` is fine. You'll have to wrap the entire thing in another `SELECT`, which in turn may hurt performance.
I will only write a stored procedure or trigger if it maintains an absolute rule in the data domain (not a business rule). It acts as a great failsafe when you or another team member forgets or accidentally breaks the rule of... always write a new audit record for every login (for example). When this fails, you'll find out pretty quick in testing. I've saved myself a number of times by doing this. Still not very common that I use them, but foreign keys and knowledge about whether to delete on cascade is a must. I had a development partner who didn't maintain foreign keys and also made the mistake of not using a large enough key. When the keys ran out, no problem. Mysql just rolled over and re-used previously deleted keys. Well, that's all and good unless your code didn't clean up and delete all the old relational data. So new entries got their own data as well as the decade old data that never got cleaned up. Nightmare material for someone inheriting that kind of data. Please learn and maintain relations if you don't already!
Only for (nigh-)identical queries. The relation between primary keys are actually cached as an index when using a view.
Nice. Thanks man!
What about if the time the server makes the hash ends up being at 00:59.9 seconds and the server receives it at 01:00.1 seconds? Anything like that will break this scheme. Seems too unreliable. Anything less than 100% success seems like bad design to me. +1 for the rest though.
MySQL doesn't pre-compile views (unless that's changed very recently).
No, because that's what I would've used options for.
Stored procedures are useful if your company has a separate data department. It allows the database designers to have an "API" that the developers can then use.
I use them in MS SQLServer and I believe Postgres supports them - I think I read at some point that MySQL or a variant is planning to support them.
Its all about how much you NEED it. If its a simple application or have few users it may not be worth the time or complexity to fix some simple for loop. Rememeber, every query you make its processing and connection time on your application server. I was refactoring a code that was run by a data integration process. The process made several queries to the database, some calculation and made some updates again. One calculation lasted for a couple of seconds. Now, we needed this calculation to be made 50,000+ times, several times a day. This process lasted HOURS almost a day so this was not viable. First we rewrite it to use just a couple of queries to the database and the time was cut in half (connection and transfer time is a real issue). Then we wrote a couple of triggers and put some calculations on store procedures and hour process now last a couple of minutes. Databases are made for storing, looking, sorting and updating data and will do it quickly and seamlessly. If you need to update and process huge quantities of data your database will do the job. 
I really wish PHP had an equivalent to `Name\Space\Example::class` but for functions. Typing a whole namespaced function into a string is no fun. If it was more convenient, it could open up some doors to functional programming in PHP.
A computed/virtual column would be better for this specific situation. They're indexable too in MariaDB.
&gt; The way I see it, [stored-]procedures etc. need to be called out as a **separate** runtime system, with a separate language, on a separate server, maintained by a separate (if overlapping) team. &gt; Either you **fully** acknowledge that (e.g. hire a DBA) or else you do your utmost to keep [the database] as a (relatively) dumb storage/query engine. What you want to avoid is: * A big pile of spaghetti where half of it is implemented as application code and half of it is implemented in triggers/functions/sprocs * Neither half can be tested or developed alone * Nobody on the team is actually a database expert to debug it when something strange happens
&gt; PHP Weekly Discussion (May) I'm just wondering how many posts is it gonna take, before someone notices the titles say "PHP **Weekly** Discussion (**Month**)". OP? :-)
I recommend using Wordpress or drupal. Those are the most used and popular php cms systems. Both have tons of themes and plugins and articles/tutorials to write your own. 
Since MSSQL and Postgres both claim heritage to Ingres, I'm never too surprised when they share features not found in MySQL :) 
It depends on what are you doing. Are you showing content to users like in a blog or magazine? Is customer registration / login necessary? I would start with wordpress so you can learn PHP. Later when you are better you can try laravel.
&gt; I would start with wordpress so you can learn PHP. More like `I would start with wordpress so you can learn awfull and outdated PHP.` The only valid reason to get wordpress IMHO is to get shit done fast when you are exactly in the core user spot, eg. a blog. The fact you can bend Wordpress backward to do something else than blog isn't enough to justify it. As easy as it is to get a wordpress site out, the real pain is in the maintenance anyway. And security (you basically paint a target on your back as soon as wordpress is installed somewhere). At least go with drupal, a more universal CMS (not thought only for blog, and not completely outdated). Symfony/Laravel/Yii2 should have some CMS bundles too. If you want to learn, by all means, learn proper stuff, for everyone's well being, yours first.
Just an FYI I'm a php developer as well, so would prefer to stay away from slapping a bunch of packages together. I've installed Silverstripe and it's not to bad, I think you can skin the UI as well so that'd be a good option.
Yes, definitely a good point. Use the db for what it's good at, and what it's meant to do. Avoid business logic tho. 
Alright. Sure. I'll believe that. I was thinking bigger, like an image OCR or other huge-assed file parser. Code on, bro.
May want to look into [Fractal](http://fractal.thephpleague.com/).
I'm sorry you missed it. If you want to know everything about Symfony, you just need to follow https://symfony.com/blog, https://twitter.com/symfony and https://twitter.com/symfony_en
&gt; The `HAVING` clause is applied nearly last, just before items are sent to the client, with no optimization. . &gt; Do not use `HAVING` for items that should be in the `WHERE` clause. https://dev.mysql.com/doc/refman/5.7/en/select.html
Can you do the same benchmark with Ting please ?
I am not the OP, so asking me would be rather in vain. But I can tell you that it is not how the things done in the open source. If you need a benchmark for whatever, take his sources and add ting. 
That's what I hoped.
Except that behaviour isn't consistent across different databases. 
If you have a web app *and* mobile apps that work through a separate API, you might end up with duplicated business logic. You can either standardise on a single API or move some of that logic to the database. There isn't a one size fits all answer.
I just want to say I think you did a great job handling the criticism from the devs, and I applaud your efforts and perseverance with teaching yourself to code. I hope you continue learning to code. If you decide you dont like development, I think you should try project mgmt, because of your good people skills. Cheers
Wow, thank you! That was such a nice thing to say. I really appreciate it! I actually work full time as a designer/developer and it's a career path I love and will continue on for now (who knows what the future will bring?) I definitely would not let the vitriol of a few people bring me down in the slightest. 
I don't see a problem here. There is someone trusting the user input, then an user who inputs anything he want to. It's not a bug, it's a feature. 
Write your own lightweight base for re-use in other projects.
Can you `print_r($_SESSION)` and make sure it's populated? And also what is the ..id notation? It should probably be just $_SESSION['id'] 
Can you drop your code into a JSBin or gist so we can see it?
If you want to write tests for it OO would help, but it sounds like a simple enough script. If anything, the "process it" part could be OO if it's complicated enough. The rest is too simple to bother making OO and/or with unit tests. &lt;?php $file = file_get_contents($download); process($file); // &lt; magic file_put_contents($backup, $file); That doesn't look like it needs tests or OO to me. It's the "process" part that does
Personally I think you should do it properly, with unit tests and OO etc. If it's important enough to back up, then it's important to know it's resilient and working, right?
You can build an api in Symfony and expose endpoints urls to Jquery app with FOSJsRoutingBundle
This question is nonsensical. Code structure has no relevance to purpose, only maintenance. If I have a file that I cannot view, but can execute with behaviors, if it's done in an "OO" or "procedural" way is unknown.
The way I see it (As someone that's probably still considered an amateur programmer), stored procedures/triggers/etc are useful for databases that can be accessed by various software, some of which may be using different programming languages. I.e., you have a program that runs off python that accesses the databases, then a website written in PHP that also accesses the databases. As long as everything's clearly documented everywhere it needs to be, using stored procedures where possible in database calls seems to work out well in my experience.
Perfect, thanks!
I'm starting to agree, since it's quite critical code so it really requires the test. Thank you.
They certainly can, but it's much harder to isolate components, when you ignore the facilities the language provides for abstraction, encapsulation, polymorphism and unit configuration (which require objects and/or functional closures). Writing "procedural code" implies leaning mostly on naked data coming in and going out of PHP 4-style named functions.
Well it is a question about maintenance as well. I wasn't sure if perhaps an OO approach would maybe be counter-productive for a step-by-step process.
I'll add the video to my watch later, so I'm replying to the TLDW but this class would be `downloadFile()`, `processFile()` and `backupFile()` which I thought was pretty pointless since the instructions inside those methods would be executed that procedural fashion just once.
It's a matter of coding style. Both styles can be tested, and can be made equally resilient. Personally, I prefer to were in OOP, but that doesn't mean FP is bad either. 
You said abstraction and polymorphism are "huge barriers" to writing clean and testable code in OO. This means you're saying they prevent you from writing clean and testable code. If you think this means they *help* in writing clean and testable code, I'm not the one that has to work on their language skills.
Support your statement about polymorphism, whatever you think it means, with **one** example.
This is a forum where we support our opinions with facts, logic, examples. Something that's been very tangibly missing from all your replies, so far. I can use your credentials next time I need to go to the toilet.
&gt; procedural vs OO 90% of developers thinks that their procedural code is OO just because it uses classes :(
depends what it does..if it is more than a few lines it makes sense to organise it..and it is always good to practise OOP everywhere..will take like 10 mins more for such a task
Hi there. Evaluate whether you have made the correct architectural after you have something working. Don't be afraid to refactor if you think you've made a mistake. R.e. The test-ability of OOP vs procedural (most likely actually functional). Your code should be equally testable whether your data structures are bound to functionality or not. The "Unit" in "Unit testing" is abstract on purpose.
For authentication, I think using [JSON Web Tokens](https://jwt.io/introduction/) would be a better approach, for security and reliability.
Procedural. Think of the person that will eventually take your job when you leave. You have no idea of their skill level, but procedural code is (probably) going to be easier for them to understand. Because it's all "just there".
paradigms aside, try writing unit tests for what you'd *imagine* your code should be. then implement the functionality. don't get too caught up in thought experiments. it's a cron job, not the page rank algorithm. this approach works for me. if i feel i'm fussing too much over getting the "perfect" model for a given problem domain, i switch over to writing tests. the strengths and weaknesses of any approach (verbosity, over-abstraction, unnecessary methods, temporal coupling, etc) quickly reveal themselves.
You want me to look at *my* tone? Let's see. I've never spoken to this person *in my life*, and their *very first communication* to me begins with the following: &gt; This is the most non-sensical thing I've read in this thread. And then they say a bunch of things, which would make even a junior programmer laugh. Which also got upvoted at the time for some reason, which means a bunch of newbies will go over this and come out with the conviction that "abstraction and polymorphism are a huge barrier to writing clean, testable code". I'm asking "can you support this", they don't, and they get weird, telling me things like: &gt; You might want to touch up on your reading comprehension skills there bud. And the problem is... *my tone*. Of course. We've gathered here with the hope of learning from each other, not confusing each other, that's where my focus lies.
This isn't a support subreddit. Please use /r/phphelp
Structural is easier to strat with, but its better to be aware of proper (even if only structural) separation of concerns. If you've written object oriented or functional code before than it should not be a problem (works both ways: if it becomes a problem then you'll learn some OOP/FP solving it).
In case you weren't aware of it, in the coming days we're going to introduce an official JavaScript-based tool to manage assets in your Symfony apps. I haven't tested specifically with Vue, but it should help you "integrating" it with Symfony (it's not really an integration, because both will still be separated ... but it will help you "linking" them somehow so your Symfony app can use the Vue app).
I'm the other guy who has. It's basically him and me in here.
Wow, as a member of the class writing plebs, I didn't expect to meet you all in here guys. I'm honored.
Fyi /u/the_need_to_post/ gives some good advice. I'd take it and leave it.
Compared with OP's plan to just run it in a single file without functions, any well known paradigm is proper. OO being proper doesn't stop other paradigms being valid. My personal view is that OO is a good choice.
Well, I did mean 'proper' compared with OP's stated alternative - OO is not especially modern as a paradigm, having been around since the 1960s, although I take your point with respect to PHP.
&gt; OO is not especially modern as a paradigm, having been around since the 1960s I can appreciate that sentiment. It's been a long time since OOP first became popular as a paradigm but that's why I said __more modern__. The actions based development approach has been around since ENIAC--around 1943. 
I was facing similar problem lately.. We had a cronjob script no one understood and it always made some problems.. Then I rewritten this crap using OO. Now it makes all sense and the code is maintainable. It really depents, for smaller crons I would go procedural, for more complex I would use OO.
Functions are not the telltale sign of OO. You can still write a simple base class for job related core functionality and then break major aspects of the task into different functions. Think of the functions like objects. You can also still pay attention to minimizing global state and side effects. Procedural doesn't equal one massive function that masks complexity and hurts ease of management and OO doesn't have to equal object relationships that unecessarily hides simplicity.
Yeah, that seems like the only solution. Guess I have a Sunday project to work on.
Here's the macro for it, if you're interested: https://gist.github.com/assertchris/d58afd9fd312f9c52bae9a19bdf94da8
No thanks, it's annoying enough dealing with that with js. I'll just wait.
I prefer a kitchen sink solution. I went with SlimPHP for a front-end website that was just connecting to a web service and still wish I would've used a full fledged framework. When we redo that site I am ditching Slim for Cake. I rather the framework do the boilerplate stuff for me so I can focus on the actual product. #neveragain
Obligatory: https://paragonie.com/blog/2017/03/jwt-json-web-tokens-is-bad-standard-that-everyone-should-avoid
Pretty much never. I used to be big on constraint checks and have used certain database features like views when things were too difficult to implement in legacy garbage code, but in general I like that functionality in code. It's easier for developers to understand and find when in code.
The shoulders, dude. You forgot the shoulders.
I was born without them...
We noticed, just don't have time to ask why the change. Same goes for why the library thread is missing. 
Thanks a lot ! that's one way to fix it and make it look good as well :) 
My coding style tries to hide as litte as possible of important logic as possible. SQL usually expresses pretty deep knowledge about your business but even with simple queries you have to read "between the lines". Stored procedures and triggers makes reasoning about SQL much harder. Performance is also a factor. If I test a query and it is sub second, I don't want hidden code to change that. Wild uses of triggers and stored procedures can put any queries performance at risk. We often consider triggers at work, but most of the time we find solutions that are more transparent. percona-online-schema-change is a great tool that makes really good use of triggers.
&gt; Most people don't use most of the features of any given technology they utilize. Except JS script kiddies. They even use features no browser supports.
Approaching OWASP isn't a good idea. https://twitter.com/tqbf/status/851467779073028096
If you're not experienced enough to answer this question then you're not experienced enough to do this from scratch. Hopefully someone will be able to provide you with pre-existing options. The first thing you need to do is examine the existing code base and functionality. Become aware of its complexities and make a better guess as to whether you should be changing it in the first place.
5.5 was EOL last year. The jump should have been earlier. 
Despite any other advice, I want to give you mine: don't try to do that alone.
To be honest - It does matter. The solution will sill take time to maintain. Maybe even some features will be added. At one point it will be just too trashy, slow, complex and takes too much time to maintain it. If the business should be expanded - the software should too. But I agree that op maybe won't be able to pull it of by scratch himself.
&gt; What I'm getting out of this is that `mysqli` is not an acceptable method for 2017, and PDO is the right way to do it. No. Both drivers (PDO/mysql and mysqli) are fine and supported. However, there is a popular view that the mysqli API is a bit fiddly (e.g. in specifying types of bound parameters using a string of 'i' and 's' characters). Thus, PDO is sometimes preferred because it is a bit easier to work with. Nevertheless it is not wrong to teach someone to write using mysqli. &gt; The PHP docs on MySQLi list MySQLi as "the preferred option" for new MySQL projects. I've never seen that before, and indeed it does! I guess that must be some core dev's opinion, but (from my reading around) that does not reflect the view of the wider user community.
I agree that the OP is kind to want to help, but I am not sure about your advice either: * mysqli has an object-oriented API * mysqli has a somewhat awkward API for specifying types of bound variables, but that's not enough declare it "not a good approach to teaching people proper practices". You are presenting opinion as fact here. * PDO does indeed have the awesome feature of preventing SQL injection (i.e. bound parameters) but so does mysqli. When you mentioned "mysqli", were you perhaps thinking of the deprecated "mysql" driver? 
Morning Colonel! How are you own "affectionated rants" going today? `:-)` 
&gt; Whenever variables are involved in a query, you should use a prepared statement. I would modify that a little bit, how about: **Whenever variables are involved in a query, you should use a prepared statement where possible**. Consider this statement: $sql = "SELECT * FROM users WHERE location = :location ORDER BY $sortColumn"; That adds a bound parameter for location, which is safe, but - oops! - what is the `$sortColumn` doing there? Well, unfortunately it turns out there are several areas in a query in which you cannot bind variables. Select column output lists, table names and order by statements all apply here. This is a common problem in paginated views, where you might expect to click on column names to sort by that column. The solution here is to whitelist (if it is in the list then sort by it, if not then ignore). 
No I meant mysqli because PDO doesn't allow you to use raw queries and helps with keeping your code secure and clean. Although mysqi does allow oop no one ever uses it as OOP, but usually proceedural. Secondly, PDO allows you to not only connect with just MySQL, but several other databases as well, which is good if you ever get into a company that has different databases in their ecosystem. Another great benefit that PDO has over Mysqli is the ability to name your parameters in your prepared statement to help with readability for other devs working on your code. So, yes my opinion is good enough to recommend not using it. Some people like the pain of getting burned by the fire, but my opinion is don't put your hand in it. You can do what your want but I'll still always recommend what I think it's best and most beneficial for people to learn. PDO is simply the better choice in helping a new dev develop better industry standard habits. 
I agree with other comments here, you're handling criticism with the patience of a saint. If only devs were normally this bulletproof! I have a [tutorial for PHP and SQLite](http://ilovephp.jondh.me.uk/), which may be helpful for you in two specific areas: (1) separation of logic and output, and (2) cross-site scripting vulnerabilities. It uses bound parameters too, but it seems you've got some great advice on that already. 
This is not a support subreddit. Please use /r/phphelp
I use PDO as well, and I agree with you that it is to be preferred. But you were wrong on several counts, and it really is important to get this right. The OP is new enough that you (we?) can misrepresent opinions as facts, or make factually wrong statements, and they will be repeated down the line in a tutorial somewhere. Not attacking you, by the way - just trying to help `:-)` 
PDO can connect to 12 different types of DBs, so you never write raw queries, but use it more as an ORM, that way if you change DBs you simply change the connector and not the code. Much cleaner
And I'm sorry I'm Rageing out on this post, I've had a very shitty time with literally EVERY fucking post I do in ANY type of social media. I have no idea why I try to help people when all I get is constant uninvited criticism and opposition with everything. So I'm just super fucking tired of it. It's nothing personal. I don't do this to other people, so why the fuck do they do it to me? FML. 
[removed]
&gt; Well it sure felt like a typical Reddit response dipped in passive aggressiveness. It was not intended to be any such thing. Please be willing to hear criticism here, maybe like a code review? `:-)` &gt; I'm having trouble seeing why I should tell her to use mysqli, when in the real world, which you and I know she would have to switch to PDO anyway. Nuance is important. I don't agree that the OP "would have to switch to PDO anyway". That is an opinion, not a fact. MySQLi works fine. Maybe I can illustrate it thus: 1. "It is wrong to use MySQLi and PDO is the modern approach" 2. "PDO and MySQLi are both ways in which you can connect to MySQL safely, but I prefer PDO [reasons here]" One is opinion presented as fact (which could mislead beginners, who may repeat wrong information) and the other is opinion presented as opinion. Both have the effect you intend, which is that you want the OP to use PDO. Does that make more sense? 
Those stats show one thing: the world using Packagist/Composer and the rest of the PHP world are two absolutely different worlds :-)
&gt; the amount of development resources and skills you need is greater than what is required while developing simple server rendered html forms. I can see that it takes a bit more skill, as of course it requires someone knowing about React, but I'm curious that you find HTML forms easier to implement. I'm finding that there's actually fewer lines of code written per form, when using React + a PHP api, compared to just doing it all in PHP, and it's also cognitively simpler to think about. Are you using a cunning PHP form library that makes your life really simple, or what am I missing? 
&gt; Coding standards be damned. It's a business not an OS project. Depends if the project is likely to be static and unchanging, or evolving over time. Maintenance and feature development costs can rise pretty quickly with poor coding standards
I agree with your colleagues. If you don't plan to have multiple implementations, having an interface is over engineering. - Devs need to keep interface and implementation in sync. Each time they need to change or add some functionality, they need to touch multiple places. - To see the implementation, devs have to jump to implementation via interface first - It creates lot of files which are basically useless and devs need to keep the knowledge about them in their mental map. It adds up. - Removing interface later is harder, not easier as other commenter said. Generaly there is built in tool in IDEs to extract part of the class into an interface, but not the reverse. And you are saying that you are even using ISP, which means you don't create one, but multiple interfaces for each implementation? Yep, definitely over engineering. SOLID is made to solve specific problems. If you don't see having them, don't try to stuff it everywhere. In your case it's a canon for a birds. You are breaking more important principles here, such as DRY, YAGNI, KISS.
If you expect more implementations in the future - yes. If not - no. However, of course, you can't always *guess correctly* what you might need tomorrow. This is why it's best to start with a class `Foo` and then when you need more implementations, split class `Foo` into interface `Foo` and implementation `FooImpl` (use a better name if you can). Notice I didn't use an interface suffix `FooInterface`. This way I don't have to refactor all code that has type-hints for `Foo`, instead it will **just work** after the refactoring without breaks. This is why interfaces should not be treated as "special" in naming. They often start as classes.
It’s always a judgement call, but keep in mind, that there is almost always multiple implementations: * Because you value composition over inheritance. So your `FooImpl` will only do Foo. If you need to cache it, you add `CachingFoo`, and if you need logging you add `LoggingFoo`, and then `AuthorizedFoo` and `BarFoo`… * Most importantly, **tests** will require new implementations — call them Stubs, Mocks, Test Doubles or whatever. I personally don’t see adding an interface as an over engineering and I wouldn’t point it out at a code review. 
Actually I do believe that an interface is never a bad thing..will not harm and can only help..if nothing else, it helps you plan out your class and makes your code more maintainable..specially if the class is used as a dependency..because you should always depend on abstraction and never on an implementation
You have mentioned Fernet also before and I must say I like it. However Fernet spec pretty much seems to be abandoned. Maintainers keep radio silence and last commit is three years ago. Any change of Paragonie taking it over?
What exactly are you asking here?
Those stats also show that how fast an improved version of a technology can effect the whole business, according to the 2016.1 stats PHP 7.0 =&gt; 1.17% in 2015
&gt; If I really do need to change it to an interface later, I have no remorse in just renaming the new interface with the class name (without the I prefix nor the Interface suffix) and rename the class something like MyObjectImpl, I know it violates standards, but it remains a valid thing to do: no refactor needed at all! I used to do this and probably still will. But if you're building a library you expect somebody to use implement or extend, this is a BC break and should be done with greater regard. class MyParser Extends YourLibraryParser // Might become something like this after you swap implementation for interface. class MyParser Extends YourLibrary\Parser\Html 
A higher probability would be, we propose a better standard and it becomes de facto.
Thanks for the feedback! How do I use it? Basically every time I need a collection of *services* implementing a contract: * Strategy pattern, where I choose different implementations based on some conditions. For example, an API client with different implementations: default (production), read only (all write calls are stubbed), mocked (for integration tests), etc. * Listeners / processors / formatters / etc. For example, I have an Excel importer, and each records needs to be „processed” after importing. The processor list and it’s order is controlled by the lib. * *Handlers* of various kinds. For example, I have a registration flow of type „foo”. I have a `RegistrationHandlerInterface` to manage it, with `ChainedRegistrationHandler` as an entry point. If any of the collected handlers `supports($type)` I use them, the `DefaultRegistrationHandler` otherwise. Basically, I can’t think of any use case of Symfony Container tagging that couldn’t be easily solved by my lib. I use it to reduce the boilerplate of the same `CompilerPasses` over and over again.
The question shouldn't be whether you need additional implementations now, but whether you can be sure that you won't need them in the future. Personally, I like APIs, because they allow to separate data from design. I can use he same function to fetch data and just put it out in different ways, depending on how I need them. For example, I like to use html-output as a parameter for my APIs, so that I can develop easier, but instantly switch to JSON output on client-calls. I also think that having one single point of entry helps streamlining the entire process and helps with cleaner code that is easier to maintain. I'm one of those guys who totally forgets everything about a project when not working on it for 2 or 3 months. A clean approach has saved me quite some time getting back into it. 
I care more about performance and functionality of a library I use with a well documented API than the underlying "code quality", or readability. 
Also the PHP versions not being similarly coloured according to major version.
No worries. One reasonable criticism of it is that it does not contain variable scope inside the logic or templates that use it. However, that was a trade-off for complexity - I have deliberately not used a framework to avoid magic on beginners, and it has grown too large as it is `:-)`. 
not to mention phpstorm will go completely mad, static analysis tools are rendered useless, generated code (for these short closures) is relatively bad for performance...
There's always the possibility for criticism of all things. Any learning resource that keeps it simple, avoids frameworks, and makes an effort to balance simplicity with security is doing it right in my book.
Great, thanks! 
tl/dr?
Less cores but faster cores is better for PHP. Kinda duh info. PHP does not multithread (easily) and this app wasn't not programmed for any async operations.
That's... not really true, though. Most web servers are multi-threaded, or use multiple worker processes. Each of those has their own PHP running. The really stupid thing is if you're benching cores and considering hardware upgrade like OP does, then PHP shouldn't even be on the table. A single-threaded Java application would easily be around 10-20 times faster than a multi-threaded PHP application, if data processing is involved...
[removed]
we are in the process of upgrading ... but meanwhile I have to deal with that ... that's the difference between theory and real world deployment and business requirements = it takes time aka technical debt :)
More servers vs more cores. CPU is not the only bottleneck on a given server, especially on apps with a lot of I/O.
lucky for him not everyone needs to use different databases, I guess.
PHP doesn't have to be multithreaded because the web server is.
YAGNI. It's trivial to extract an interface once you need a second implementation; PHPStorm and presumably other tools can do it for you. 
Sounds like a very specialized system when users are prepared to wait that long for a response. It's not always worthwhile to fix the code, or they might need to fix the performance in a short time frame while they figure out a more permanent solution. We have [a platform](https://smoothcomp.com) that we developed for club competitions with up to 1000 participants and mostly parents spectating. It was recently used for a tournament the size of a world championship. You can bet they triggered some unexpected bottlenecks! We threw more cores at the problem and optimized some obvious bottlenecks but now the championship is over and we are targetting bigger refactorings. Getting good web site performance is a full-stack task.
/u/eklect, I was told three times in the course of this thread, "I shouldn't be writing tutorials". Some of my questions were responded to with snark and vitriol. I even had my gender thrown in my face as a low jab and to dismiss any possibility of credibility, which was later edited out. (Unfortunately, I don't have the benefit of anonymity, as I would very much rather nobody know that unnecessary personal detail.) The same has happened on many StackOverflow questions I've made. However, it's a very small price to pay - a few negative comments on reddit - compared to the hundreds of emails and comments I've received from people about how I've helped them, how they finally felt like some aspect of development they struggled with was possible and accessible and simple. At some point, you have to decide if you'll be brought up by helping people, or brought down by those who would view you with contempt, and if it's worth it. I provide free, ad-less resources for beginners and I still get hate online, so I understand the "constant uninvited criticism and opposition" you feel. It's very easy, under the guise of anonymity on reddit, to discount and dismiss others. The easiest way to feel better about oneself is to bring someone else down. Particularly in the development and programming community, (but also everywhere) people are quick to judge and attack. The amount there is to know in this field is never-ending, and one person can't possibly know everything. I guarantee not a single person sprung from the womb knowing shit about coding, and people tend to forget that and view ignorance as stupidity. The key is to not take anything personally and glean what useful information you can. That being said, I appreciated your post, and that you were actively aiming to help me and give some useful advice and suggestions, which I'm looking into so I can improve my code. I also do not think /u/halfercode was trying to personally attack you and oppose you, but getting challenges can be difficult to deal with. Any sort of critique is very hard to not take personally. I try to respond positively and ask more questions. If they want to help, sometimes I'll end up learning a lot. If they just want to be a jerk, it's easy to figure it out and ignore them. If you want to be helpful online, the net positive will greatly surpass the negative. 
No I've seen the examples on their website 
&gt;That's... not really true, though. I said "PHP can't utilise more than a single core in process execution", the web server obviously can, but PHP without extensions such has pthreads cannot. &gt; A single-threaded Java application would easily be around 10-20 times faster than a multi-threaded PHP application, if data processing is involved... I seldomly see web applications being ported over to Java in this case. Heck, before you even ask if PHP is the right language, it may be worth considering that the PHP might need to be upgraded, are they using PHP 5.2 in this case? Are they making use of an opcache? &gt; Traffic was relatively low for this server and &gt; Upon further investigation, I found that although the volume of traffic was not enough to activate all 18 cores concurrently Indicate that moving to Java would not have satiated the problem. 
Because he's spamming it to all of the programming subs.
true but it's still a dependency you never know when it will break and when it break it can be nasty. I totally like the idea and I find it cool. For personal projects probably yes, for other projects probably no.
It gravity a force for good? A force is a force. You can use it well, or poorly. For good, or bad. But you can't stop the force. You can only harness it. That's true for technology and progress in general.
I'm well aware that war has driven innovation, but I think in 2017 we should know better than to continue developing better and better systems so we can kill more and more people. "...rather than just bashing the 3 main industries that are currently driving innovation" I'm not sure I understood this bit. What you are trying to say is that, because those fields drive innovation, is ok we continue to developing them without questioning? My point with the article was to spread the idea that instead of blindly developing everything we are told to, we should stop and think about what we are doing.
The context for this is a web server, not a console application. In this context, there's no indication that the ability to fork exists. Can you tell me exactly what it is in this web application was CPU intensive? For all we know, it could be a badly written for/while loop. 
Definitely. I'm pretty sure I can't stop progress in whatever way it goes. I'm only trying to spark the discussion. Because sometimes, it may be progress, but is it worth it?
Yeah, I added the disclaimer so that people would know that I'm not coming from a place of not bashing software just for the sake of doing it. Of course, most of the software is totally inoffensive and actually useful in our lives. The corner cases are the ones that worry me. 
&gt; The context for this is a web server, not a console application. In this context, there's no indication that the ability to fork exists. I've discussed different approaches for if you run on the web, or in CLI. In CLI, you can fork, start multiple new processes (via the Process API) or use pthreads. You mentioned Pthreads, I mentioned the rest. None of these are suitable for a web thread, including Pthreads, which you mentioned. &gt; Can you tell me exactly what it is in this web application was CPU intensive? For all we know, it could be a badly written for/while loop. How the hell can I know, I don't have their source code. But if: 1. There's a performance issue. 2. It's not due to heavy traffic, but it's for every single request, taken in isolation. ... then obviously something heavy is happening in that request. And it's CPU bound, because OP is comparing more CPU cores vs. faster CPU cores, none of which would have any effect if the problem was I/O bound (say, disk access or network I/O).
Well, I have said "No" in the past. It didn't change the world, but it changed "My world" ;)
Same here, I just think you could have done a better job of explaining those things. Overall agree with you though :)
Notes taken, next time I will try to have things clearer. Thanks :) 
So basically the tl;dr is common sense? :).
That's only true for extremely large values of common sense. ¯\\\_(ツ)\_/¯
PHP is single threaded, it's pointless to have multiple cores. Hence the movement to micro services. Horizontal scaling is currently the best way to scale out a massive web program... Until the next best thing comes along.
&gt; Somewhat short answer: if you want it testable then use POPOs Plain Old PHP Objects. I so wish that my current client understood this: I suck at politics. :-(
your macro uses variables by ref, if an RFC ever passes variables will probably be passed by value. Also, if Babel for JS is a mess at least it has the concept of stage-0 to stage-3, i.e. proposals that are likely to be approved or not, while your syntax is made up. But it's fun, so good job!
webserver -&gt; create job/queue client (frontend) -&gt; check job status -&gt; if done -&gt; return result They need some job / queue servers. 
This post wil give better response on r/libraries?? Buts its a php software
Did something similar a while back: https://github.com/assertchris/functional-core/blob/master/examples/structures.php, but it uses eval to produce a validation class and factory function. May be interesting to you...
Yup, seems to be the general rule. While I can appreciate learning more about the specifics from blog posts like this, I doubt many developers *need* to understand at this detail. If there's a solid request load, throw another app server in the load balancer, barring any code/database optimizations.
Bad idea to split the class Foo into interface. If someone extends class Foo it gonna break his code.
Dude, seriously?! 
The entire premise of this scenario is you need a single implementation (extending it would be a second implementation). Of course, if you're distributing this to other teams or third parties who aren't aware of your intent, just declare the class as `final`, problem solved.
Hi all, I've collected some websites and blogs from this subreddit about PHP development. It's been a while since I worked with PHP so I hope I made the right calls with the list. Let me know if you have suggestions! Cheers
Your thread is worded like it will be a tutorial, but it simply links to download software. Beyond the fact it's written in PHP (which we just now found out), it appears to have no other relation to the subreddit. What's the goal in posting it here? Did you make it? Are you looking for critiques? You should post a link to the repo instead, if so.
sorry for this, but its a custom php code, every body can make customisation on that, its not a tool its my Custom scripts, My goal is to increase traffic from reddit. i am looking to promote my scripts, R you a developer?
&gt; successful upwork freelancer Oxymoron.
I mean Github exists and a little big a searching can find what you are looking for. Never-the-less [Illuminate/Database/Query/Builder.php](https://raw.githubusercontent.com/illuminate/database/master/Query/Builder.php) should be a large enough file for you with plenty of variety.
Looks very bias to magento
What is the point to this tool? &gt; With ComposerCI, you'll never have to worry about keeping your dependencies updated anymore. Doesn't any build process take this into account anyway? i know my deployment pipeline on Gitlab ensures packages are updated on each build
Didn't read the article yet, but I will answer your second question. You do NOT have to buy your domain from the same service you plan to host your site with.
&gt; Laracasts and the odd YouTube video Those are some strange books you're reading.
I'd consider dropping some of these sources... combing through articles, there are quite a few with poor editing or providing little to no actual substance, for example: https://blog.wyrihaximus.net/2016/12/php-api-clients-command-bus/
No love for [SitePoint](https://www.sitepoint.com/php)? If not for the channel as a whole, every tag and author also has an RSS feed attached, for nitpicking, just append `/feed` to any URL ([tag combination](https://www.sitepoint.com/tag/oddball+php/), category, author, whole channel, whatever).
Looks like the Composer equivalent of https://greenkeeper.io/ to me.
moooooooods
Since you like books so much ^/s , apparently, I recommend checking out the video presentations on infoq.com. Ignore the "agile management" stuff and focus on technology, plenty of good lessons there. Including in the older presentations (use the search bar). That's not really PHP specific, but then being a good developer isn't PHP specific either.
What is the business model? Why is it free?
I don't actually use a ArrayCache unless nothing else is provided in my actual applications I . I know it doesn't cache anything across requests, but it is still better than a VoidCache is it not? Agreed, but starting fresh (ish) here we don't have to worry as much about backward compatibility, and we have a greatly reduced list of supported databases. This is never going to be Doctrine, same space, but different priorities. Thanks for the feedback!
Agree, it will never be so cool as static typing analysis. Yeah, it's not intended to be exactly like Hack's Shape, so I enabled this optional field on, so you only check for keys the consumer relies, maybe putting this as: the Shape is what the client expects, not what the implementation has to strictly have. And typed list is made by proper [typed collections](https://docs.hhvm.com/hack/collections/introduction) in Hack.
&gt; I know it doesn't cache anything across requests, but it is still better than a VoidCache is it not? You are not caching annotations, which means that there's probably a lot of reflection and autoloading going on at boot time. &gt; Agreed, but starting fresh (ish) here we don't have to worry as much about backward compatibility, and we have a greatly reduced list of supported databases. This is never going to be Doctrine, same space, but different priorities. Good luck with it - glad to see some research going on :-)
I think, you'll need something more intricate than smoking, to come up with the idea like that.
I don't think OP is too attached to the name. The real value is in the "data mapper" which doesn't necessarily transform SQL data to objects. Just data to data.
I don't know how Gitlab handles the process, but ComposerCI updates dependencies OUTSIDE your version range. For example, you may have "cool/dependency": "ˆ1.2", and if cool/dependency v1.3 is released, you wouldn't update, even when running composer update.
Exactly
We simply open a pull request that you can merge (or not)
When you get the pull request, you can run your unit tests, or check everything works localy. But, if you recieved a pull request, your local dependencies must be also outdated
This is a good read - also has a book if you prefer that route: http://www.phptherightway.com
I'd be curious to look at examples before opining; I've not worked with Expressive and it'd be interesting to see what others are doing.
Ah, now I understand!
&gt; It's usually the latter, because I can't think of a situation where fetching arrays would cause more queries, if code is structured well. Multiple services acting on the same data - TDG and AR tend to cause more writes in these scenarios. If two services act on the same input/output data during an interaction, the lack of a UnitOfWork already causes the multiple fetches in most scenarios. A typical scenario is just authentication/authorization and then getting the current user (same information) information into your dataset/auditing as well. &gt; Think about it: you use distinct read/write models when interacting with SQL directly (queries/command and result sets). &gt; This dependence of Doctrine (and Hibernate/JPA) on mutable object as hybrid read/write models is why it'll never quite work right with relational data (or pipelines of data in general), which requires ad-hoc read models, ad-hoc write models and easy to duplicate and transform data. Yes yes, [we know](https://martinfowler.com/bliki/OrmHate.html) &gt; Think about it: you use distinct read/write models when interacting with SQL directly (queries/command and result sets). The data structure is still the same/symmetrical, which is why we keep representing it as a mirrored in-memory copy in "traditional" OLTP apps. Being a strong advocate of CQRS/ES, I can tell you that the split model is not just at interaction level, but also at data representation level. You don't get many benefits (other than lots and lots of CRUD - figuratively and not) if the read and write side still work with the same dataset. &gt; You also use read/write models when interacting with a web API (queries/commands and JSON/XML/whatever result sets). I stopped pushing state over APIs: it's a stupid idea in most scenarios, and I replaced it with imperative commands (yes, RPC, basically). &gt; The only odd one out sits straight in the middle of this beautiful data pipeline of commands/queries/results and it's Doctrine, constantly managing everything in frozen-in-stone-definition mutable entity classes. Doctrine is generally added to this kind of setup just as an anti-corruption layer: having statically typed properties, as well as type-checks during hydration operations, simplifies things massively when it comes to data validity. The cost is huge, as the ORM is basically useless, but if performance is not critical this is acceptable and actually simplifies things.
I don't care about the person/company so much as a more professional presentation with some more pages of information. But I definitely agree that as it stands, I would not surrender GitHub permissions to this service.
Thanks, I will check it out. 
Typo: &gt; lastest version That should be "latest version" I think `:-)`. 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [zendframework/zend-expressive-skeleton/.../**Action** (master → ecac3e4)](https://github.com/zendframework/zend-expressive-skeleton/tree/ecac3e40718dcc6b0478cc758022acd6ccb72da1/src/App/src/Action) * [zendframework/zend-expressive-skeleton/.../**ConfigProvider.modular.php** (master → ecac3e4)](https://github.com/zendframework/zend-expressive-skeleton/blob/ecac3e40718dcc6b0478cc758022acd6ccb72da1/src/ExpressiveInstaller/Resources/src/ConfigProvider.modular.php) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhbzggp.)^.
I think it doesn't work anyway. If you click on it, it goes to an invitation page asking for an email, so that interested people can be notified when it actually works `:-)`. 
Firstly, the sign in with GitHub button doesn't ask for permissions, but allows you to enter your email to get beta access. I am still working on the about page... until then, you can check my GitHub profile (https://github.com/m1guelpf) or drop me a mail if you want to know more about me.
&gt; So basically, again, this is mutually exclusive to the Doctrine model, where you mutate state, and then "persist" it Yeah, I only use the ORM for read operations, when dealing with CQRS/ES apps. Mostly due to performance (L2 cache) and type safety (it's entities, not blobs/arrays). &gt; wish we had typed arrays (like Hack's Shapes), that's what we really need. "record types" is what I'd like to have - see http://learnyouahaskell.com/making-our-own-types-and-typeclasses
&gt; There is a "static reflection driver" in doctrine that uses this approach to generate entities. You can probably eval() entity code on the fly (keep everything as public properties) and skip the actual classes. I'm guessing in that case it would be more performant to just generate the entity classes. Since that needs to happen only once in a while instead of on every subsequent request. By the way, when I wrote: &gt; Did anyone by chance already make what I'm describing here? That could save me some trouble. I meant, did anyone already make such a graphical entity / form builder? &gt; Warning: remember that YAML support was removed from doctrine develop (3.x), and YAML support will be completely dropped from core in the next major release, unless somebody externalizes and maintains it. I strongly advise to move to XML or annotation mappings. Oh no! Why? I find YAML to look so clean and easy to read. XML contains a lot of noise imo. Although if I'm generating it instead of writing it myself then it doesn't matter much of course.
Talking about the D2 setup in your bench 😋
Ah ok gotcha... totally unfair numbers then!
I don't think you can make a case for "performance" when 1/3 of the web is WordPress, which after a few plugins takes 4-5 seconds to render serve a simple response. If people cared about performance they would have done something about it. As for high traffic sites, you can use HTTP cache like Varnish to keep your site both dynamic, and as fast (or faster) than a static site would be. I'm just giving you honest feedback, there's not much of a reason for going 100% static in 2017. You can't even provide basic things like user login and form processing on static sites, let alone sorting/filtering complicated data sets in a way that's still visible to Google, and so on. Modern sites are not just content, they are also applications. And that requires running logic on the server.
AWS was covered in the tutorial. I used AWS Elastic Beanstalk
Thanks for pointing topic feeds out. I had it initially in but it tended to produce lots of articles about Wordpress optimisation.
I used to. It was really convenient for getting a full-stack environment set up on my Mac, and the Z-Ray features were interesting. Had been looking to recommend it for our self-hosted customers’ non-Linux production servers as well, especially on Windows. But quickly abandoned that idea when we received the pricing: several thousand dollars per year, even for the small business edition, which is orders of magnitude more expensive than the actual software we are selling. Total non-starter. I think Zend is really only interested in the Enterprise (money-to-burn) market for Zend Server, and with the support options available at that level, it might make some sense.
I like some of the other components from Agile Toolkit, but I'm not sure you're on the right path here. Everything I saw in the video, defining HTML UI, defining DOM event handlers, this is done in PHP, for some reason. But it should be done in JavaScript. Because then I have the freedom to define my own custom logic, instead of doing what feels like going through very, very, very tight PHP funnel, where I get to use whatever actions you have defined in your PHP API, most of which are very simple, and not very useful in real-world applications. This is also where the need to have JS expressions comes from. You insist on us generating JavaScript through PHP, and when PHP falls short, we need to supply JS expressions as *strings* in PHP, so we can define custom logic. I can instead go and write all this in a modern TypeScript IDE (plenty of those), with autocomplete, error checking, refactoring and so on, and so on. Writing JavaScript in strings is not something that feels like a step forward from this experience. I.e. what's the benefit of this: $button-&gt;on('click', new \atk4\ui\jsExpressions('alert([])', [123])); Over this: button.on('click', () =&gt; alert(123)); Not to mention that the old-school approach of setting up a layout and mutating it with handlers doesn't stand a chance against modern functional UI paradigms like React.JS. The world is moving in the direction of strictly isolating HTML UI, from browser app state, from server API and server app state. There are huge advantages in this separation, while Agile UI seems to be trying to merge them together into a single concept. This more closely replicate ASP.NET WebForms, an approach to web apps that was used in the 1990s and people didn't particularly like it back then, either.
Is this going to be done with github integrations like the new greenkeeper?
Well I hope what you do finds audience, but the niche you describe seems very sparse. Who is willing to learn a highly specific PHP approach to defining UI and can't handle a few lines of *basic* JavaScript, where it fits best? Here's a take at the same thing you demonstrate above, with all the benefits of binding and so on, but with proper separation, and layout defined in JS, where we don't need `jsExpression` and so on: // PHP $models-&gt;set('chart', $m); // JS var chart = frame.add(new atk4.chart.BarChart()); chart.setModel(models.get('chart'), ['name', 'sales', 'purchases','profit']); chart.withCurrency('$'); 
I would suggest that interfaces provide an "easier to parse" way to construct a mental model of how a system is composed. For this reason, if the class is of any importance to the composition of the system, I would define an interface for it.
But then you exclude the [Ballmer Peak](https://xkcd.com/323/).
Chart groups data by a client and calculates sales, purchases, profit. That's just an example, there can be more stuff happening.
It's hard to have high-performance static sites today without [AMP](https://www.ampproject.org/) support. Put that in as the default feature (and as a requirement for all user-submitted official-to-be themes), and then you've got something.
&gt; I don't think you can make a case for "performance" when 1/3 of the web is WordPress, which after a few plugins takes 4-5 seconds to render serve a simple response. If people cared about performance they would have done something about it. I disagree and think people simply don't know how much better things can be. They wouldn't tolerate such slowness if everything else was fast.
&gt; Chart groups data by a client and calculates sales, purchases, profit. That's just an example, there can be more stuff happening. So which part of this requires you define the chart itself on the server? The PHP model can provide the necessary data sub-set, it can do transformations on it, and some more trivial calculations can be done on the client-side in JS. The binding requires that the chart knows which model to look-up on the server, and that's all the binding they need for all this to function properly.
FTR, I'll vote yes on (nearly) any incarnation of short lambdas at this point. I want implicit by-ref capture, but faaaaahk me, I'll take it any way I can get it. Seriously couldn't care less if it's with/without `fn` prefix.
Data access control and aggregation. I think we have exhausted the topic. Can you do stuff in JS? yes. Do you still need server component? yes. Practically all the frameworks come with some CRUD generators, form builders and various admin systems. They are quite clunky and do half the job. I think that PHP is well suited for "integrating" components together and binding some events. I want to give it a try if you don't mind.
&gt; Data access control and aggregation. I think we have exhausted the topic. Can you do stuff in JS? yes. Do you still need server component? yes. I don't think we've exhausted the topic. The topic is you don't have to define JavaScript driven UI in PHP. The only thing you need to strictly define on the server is the models. Data access control and aggregation is done by the models. They're on the server. ChartJS and its wrapper only call the model on the server, that is its role. Anything else makes the relationship between them unnatural and suddenly you find yourself writing JavaScript in PHP strings. &gt; I think that PHP is well suited for "integrating" components together and binding some events. I want to give it a try if you don't mind. I certainly don't mind, but I don't think you're very open to your ideas being challenged, you simply reject the feedback. I'm telling you, you will lose most people with this approach. Of course, it's your right to pursue it regardless...
We use symfony forms. I don't know how good is it as a standalone component, but with full framework it's possible to define it in backend and then on frontend you can render whole form via single `{{ form(form) }}` in twig template. Validations are also super easy with it and binding to ORM model as well.
Imho, as an individual, you need to know the market and need to find your niche. Only successful freelancers I've come across tried to work locally, offering service and writing their own product they reused with each new customer. The only real way you can save money as a single developer is by reusing code. So figuring out a niche that you can work for, where a lot of smaller companies are in need of developers, but just can't afford spending the kind of money big corporations charge. You'll probably spend a lot more time explaining basic computer-stuff to your customers than any large company would, but in the end you gain loyal customers who'll call you and only you if they need something done. I think, as a small, individual developer, you need to invest a lot more into customer-relations and do a lot more non-developer-stuff to help them, than you would in any large corporation. But on the other hand, you can start business-relations that will remain with you until you retire.
&gt; Besides for incredibly cheap hosting that doesn't require a database, or any kind of security/maintenance associated costs that inevitably come from a huge open source platform that routinely has thousands of people poking at it with their own metaphorical black, and white hats. You can get a VPS for $5/month these days. On which you can host hundreds of your client sites. So, please, don't talk about "cheap hosting without a database". It's ridiculous.
I don't mind if you challenge my ideas: - some server-side code is needed for data access, so you'll be running PHP anyway. - since you write PHP, why not drop a line that adds and executes a component object. - the component object looks after HTML, JavaScript, CSS and connects it with the data through callbacks. - those components can use any JS library and wrappers they want. - to facilitate interaction between components which may be using different JS frameworks I define events/actions in PHP. A resulting system is easy to install and integrate, does not need any assets, requires basic training and is ideal for quickly creating admin UI and some basic web apps. I can't see how I can implement your suggestion without compromising some of the goals.
hah yeah you got me, totally confused :-)
Well, if you have specific questions/problems, I can give specific solutions. :-)
it actually plays very nice also as separated component. +1 for symfony forms. That thing is so powerful sometimes I cannot even believe it.
Hey, I'm working on a PHP UI framework and it has a Form component. I can't say it's 100% ready, but take a look at the demo: - Simple example: http://ui.agiletoolkit.org/demos/form.php [[source](https://github.com/atk4/ui/blob/develop/demos/form.php)] - Complex example: http://ui.agiletoolkit.org/demos/form3.php [[source](https://github.com/atk4/ui/blob/develop/demos/form3.php)] The idea is to define data structure, then pass it into Form component which will render the form selecting appropriate fields, handle submission and display of validation errors. Form can also be part of another component such as [CRUD](http://ui.agiletoolkit.org/demos/crud.php). The UI can be integrated into a full-stack framework or work stand-alone in a single PHP file. You don't need to install or create any additional files. Curious to see if this would help you.
How cool is that. I will give it a shot :)
I haven't allowed a form submit itself for years. I always do it via AJAX, so I don't reload the page, I show the errors via JavaScript (as they come back from the JSON API on the server side). This also means the form doesn't have to explicitly "remain filled" as I never reload, so it remains filled naturally. As for pre-filling it based on dropdown of configurations... also seems like a nice job for JavaScript.
I'm going by your examples. If nothing else is needed in your code, then nothing else is needed in my code.
On load, check your db if the values exist. If so, load them. So you have a lot of &lt;input value=" '&lt;?php if $var ? echo $var : "" &gt;'"/&gt; kinda stuff. Then jquery on click submit that make sure everythings filled out and valid. If not, css that bad boy bright red. If everythings good, use jquery to grab every inputs .val() and dump it to an array. Pass the array via ajax to a php file with the necessary sql. Bing bada boom. 
React. You can get pretty far with PHP, some kind of static templating language, and jQuery.Validate, but if your form is very dynamic with lots of inputs showing and hiding and changing and repeating based on various conditions, eventually you wind up with spaghetti code. I find that React manages dynamic content extremely well. That said, if you don't already know React, it'll take you quite some time before you're able to write a form.
 &gt; Oh no! Why? https://github.com/doctrine/doctrine2/pull/5932 Yaml may be pleasing to the eye, but having to answer multiple issues/questions a week because somebody messed up indentation is terrible. From my PoV, we could introduce json-schema validated json mappings as a replacement, but it is a lot of effort to document/sync. XML+XSD works so well that validation issues pop to the eye in any modern IDE, and you can tab through fields when writing these mappings.
Create an API and use a front end framework 
Here's the fallback: &lt;noscript&gt;Your browser has disabled JavaScript. Please enable it and refresh.&lt;/noscript&gt; No browser comes with JS off. No browser allows one to accidentally switch it off either. Modern browsers also haven't had a serious security issue with JS for years. There's no reason to disable JS. No reason to think about no-JS users, aside from telling them to get their head out of their behind.
Again, using JS for validation is a good start, but you should *always* validate on the backend too. Never trust the user.
There are still offices in this world where JS is disabled from on high due to "security". [Statcounter puts the figure at around 3.6%](https://statcounter.com/demo/system/?granularity=quarterly&amp;fromHour=00&amp;fromDay=01&amp;fromMonth=2013-12&amp;fromWeek=2013-50&amp;fromQuarter=2016-01&amp;fromYear=2013&amp;toHour=00&amp;toDay=01&amp;toMonth=2013-12&amp;toWeek=2013-50&amp;toQuarter=2016-02&amp;toYear=2013&amp;fromHourB=00&amp;fromDayB=01&amp;fromMonthB=2013-12&amp;fromWeekB=2013-50&amp;fromQuarterB=2013-04&amp;fromYearB=2013&amp;toHourB=00&amp;toDayB=01&amp;toMonthB=2013-12&amp;toWeekB=2013-50&amp;toQuarterB=2013-04&amp;toYearB=2013&amp;isComparison=0&amp;dateselector-relative=) - sure, small, but not zero. Even more concerning: assistive technology for disabled users is often lagging in the JS department. **These days it's fine to assume JS, but you should always have a fallback, especially for HTML basics like form submission.**
Well that was uncalled for.
In hindsight it looks like a personal attack but it was meant purely as on observational comment. As in it's confusing how someone can be so thoughtful and intelligent on the programming subreddit but here they just spout garbage. A conundrum. 
Thank you very much for your help.
I admire your tenacity
I don't know about Rails.. But You could read the "Why Stitcher" list here: http://stitcher.pageon.be/
After reading the docs for about 5 minutes, it seems to me that AMP is a set of rules and guidelines to create optimal HTML, CSS en JS. There's also the mention of Google AMP Cache which can cache rendered HTML. Is that correct?
You're kind of a dick when you want to be.
We ask for the repo scope to be able to make pull requests.
Doesn't that sound like what ApiPlatformBundle does though?
Marginally. AMP is a set of alternative HTML elements to use in place of real ones, and a spec to follow on which standard ones are allowed, all sped up by Google's AMP library included in the page. It places hard limits on the amount of animation, interaction, dynamics, and heavy elements one can include in a given page. While, yes, this is very opinionated of Google, it's also quite effective when done well - Google's search results point out AMP sites with a little lightning bolt, and also preload them because they're guaranteed to be fast. This leads to non-trivial perceived performance bonuses, on top of real performance boosts, particularly noticeable on mobile.
Unique entity is handled better by catching the unique constraint exception when trying to flush, you'll need to do that either way. You can then manually add the form error. The whole idea is that your domain objects (entities) remain in a valid state, can't do that with forms putting all kind of junk in there.
&gt; I’ve started working on this project because of the need I saw for performance on the web If performance is your concern then PHP is not the language to go with. Take a look at https://kore.io/ it will kill anything you produce in PHP for performance. I don't understand this project, trying to force a square peg into a round hole. Even if you're stuck with PHP but your website now needs performance upgrades it's much cheaper to do it with hardware rather than developer time, caching, load balancing etc
You don't need to remove anything, Just need more variety.
Remember that you can subscribe to the GitHub issue for the GitHub Integration (https://github.com/composerci/roadmap/issues/1) to get notified about updates of this feature
See http://www.soliantconsulting.com/blog/2017/03/formidable-different-approach-forms and eventually https://github.com/xtreamwayz/html-form-validator
&gt; Twig extension does it, not controller. But you said this: &gt; with full framework it's possible to define it in backend and then on frontend you can render whole form via single {{ form(form) }} It sounds like you're building the form (HTML view components) in your application logic not in the view layer?
Form doesn't need to be 1:1 with your entity, where do you have this from? You can have unmapped fields inside form if you need that, no need to create virtual properties in entity. Worrying that you might flush entity in invalid state by accident, while managing to pass DB constraints is not worth it, because risk that you will make a mistake while blindly creating 1:1 map between your form/entity/popo AND then calling appropriate setters and getters is a lot higher. If you do this, since you are producing 10x more code, you WILL make a mistake and you will set wrong values to wrong properties. hostnet/form-handler-bundle how does that make form handling easier? It only extracts form handling code from controller into separate class. This only creates more work by having to create separate class and produce extra code. Not saying it's not good to separate this thing from controller, but it does NOT make work easier (maybe in long term if you have complicated logic, but you should do that when you actually get to this point, YAGNI).
Actually, the language its made in doesn't matter at all. The build process is completely separate from the actual website.. It sounds like you didn't really bother to read into the subject, and just wanted to post a completely irrelevant link..
&gt; Fun fact: your all js app will break on 50% of mobiles Hah, indeed... what a fun, made up, unsourced "fact".
Thanks! What I didn't really understood from the portfolio page, is how pages are compiled? Is this done clientside with the JS library? I've read about the Google AMP Cache, does this server holds the compiled data? 
&gt; FYI you can submit comments and stuff on Reddit without JavaScript; it's just the reply button that doesn't work. ...
None of the existing tools for UI building can do it 100%. You end up thinking about filling-in IDs yourself, connecting fields to the domain model, loading values in the drop-downs or adding routes for your auto-complete field. It fully backfires when you start hacking field markup. But if all of those cases are handled correctly, then as a developer you can stay top-level, have the necessary functionality without going into details. I don't think it's impossible and it motivates me to continue my work. On the flip side, you can now use 3rd party field implementation with pretty cool functionality. I have a one-liner for "file upload" and another one for handling "amount+currency" combos. Date field is automatically enriched with date-picker and system takes care of normalisation, formats and validation as the data is saved into SQL, NoSQL or is sent to API.
Never heard of Spress, but I am interested in static site generation. Is this a popular tool?
Thank you, Derick. :-)
Seems like you're allergic to code, maybe you shouldn't be working as developer.
You are building fields in backend conceptionally (because hey, backend needs to know what kind of data it should expect), but visually it's built in view layer.
I became developer so I don't have to do monotonous tasks. That's what are computers good at. Haven't you heard about DRY? That's my most important principle while programming. You need to work smarter, not harder
I respect Zend, I use Zend Studio for development, and the odd Zend Framework component here and there. But regarding Zend Server, I don't think they've been able to differentiate it well from stock PHP. It's hard, of course, PHP is open-source and so on. I suppose the audience for Zend Server is the same corporate clients that would opt for the Enterprise Oracle MySQL server, over their "Community Edition" or MariaDB.
Hmm, okay, I kinda get that rationale. And at the same time I wonder if that could've been easily helped by creating a Github wiki page with all the common ways people get their YAML configuration wrong. If you also copy-paste the exact error messages that people get into that when making those mistakes then there's also a high chance of people finding that wiki page when they google the error that they're getting. And if they're still asking those same old questions everywhere that will make people refer them to the wiki page which will make Google put the wiki page higher in their search results. Boom, problem solved. ;-)
&gt; Actually, the language its made in doesn't matter at all Complete and utter bullshit &gt; just wanted to post a completely irrelevant link Nope you want website performance then KORE is about as fast as it gets for frameworks, sure I could post a link to the assembly language and build a full HTTP stack from scratch and it could be faster but realistically in a commercial environment KORE is the way to go if your main goal is performance
Oh, I'm not suggesting that *everything* has to have a fallback, and I'm totally recommending "progressive enhancement" to give amazing bells and whistles to those who can use them, but OP is asking about **web form functionality**. That's just basic HTML, and should always have a bare-bones fallback (particularly if you're using a framework... write once, use everywhere). I get your point, but in all seriousness I use the command line versions of Gimp/Imagemagick and Inkscape all the time in my web apps ;)
Your attitude is why we can't have nice things. Yeah, I get it, many developers love to show their skills by writing tons of overengineered code, but your number one priority is solving problems, not writing code for the sake of it. The less code, while solving the same problem, the better. Yes, you should plan ahead and avoid technical debt that accumulates by going the quick&amp;dirty route. But doing the opposite and planning everything ahead is just stupid, because 1. it won't go to plan anyway and 2. it eats time you need to develop actual features. YAGNI.
There is a misleading typo in the article: &gt; ~1.1.2 means get the largest 1.1.x with version at least 1.0.2 1.0.2?
I don't get why people use Xdebug. You're not a real PHP programmer if you have to rely on a debugger, go back to Java or Python or something. Never use Xdebug and never will. Not sure why Derick wastes his time with that crap.
I did read that already, that's precisely what made me think it was PHP-flavored [Jekyll](https://jekyllrb.com/docs/home/). Or [Middleman](https://middlemanapp.com/).
Cheers! 
&gt; Seems like you're allergic to lumber processing, maybe you shouldn't be working as a cabinet maker.
I'm not familiar with the internals, sorry. I only implemented it once by following the instructions to the letter and it worked fine, but it was too much work in subsequent projects. If there was a tool which automated it like what we're talking about here, though... :) [This might help](https://www.sitepoint.com/an-introduction-to-googles-accelerated-mobile-pages-amp/).
A thousand upvotes to you for including a profiling tool in the workflow. There's a few approaches to application performance: * Hope it'll all work out. * Run a profiler.
&gt; Modern browsers also haven't had a serious security issue with JS for years. Is this sarcasm? * https://www.cvedetails.com/vulnerability-list/vendor_id-452/product_id-3264/cvssscoremin-7/cvssscoremax-7.99/Mozilla-Firefox.html * https://bugs.chromium.org/p/project-zero/issues/detail?id=1130 * https://bugs.chromium.org/p/project-zero/issues/detail?id=1011 * https://bugs.chromium.org/p/project-zero/issues/detail?id=1024 Ever heard of [BeEF](http://beefproject.com/)?
fully agree with gadelat, it's really not practical at all, and the most beneficial gain from using DTOs is keeping entities in a valid state, but now you say "ignore the fact that they should always be valid". and as gadelat said, they dont need to be 1:1, I am also dealing with a large entities and nested form collections, and really never had to deal with headaches concerning the mapping. Yes you need to make changes, the same changes you would need to make when using a DTO. 
Let's totally set aside the fact that every exploit used a `&lt;script&gt;` tag. History has shown some [really interesting JS engine exploits](https://googleprojectzero.blogspot.com/2014/07/pwn4fun-spring-2014-safari-part-i_24.html) in the very recent past. I wouldn't write out the possibility of that happening again today. Disabling JavaScript (or whitelisting it to only domains that are trusted) reduces your risk profile by a nontrivial percent, similar to how disabling ads reduces the risk of malware delivered by ad networks. You could make the case of, "Well, I'm entitled to my users' trust," which is fine and totally fair, but not the same argument you made which was a broad stroke about browser security.
&gt; Could I use a multi-dimensional array? Of course. &gt; How many layers can you safely have in a multi-dimensional array. About several trillion, depending on your available RAM :-) &gt; What's a good resource on learning proper structure for a multi-dimensional array of this magnitude? Go by instinct and refactor when the need arises. &gt; Would this be better managed using OOP in PHP? I've yet to have a need to deviate from Procedural, but I really want to learn OOP in PHP if this case would be best for it. You can benefit from using OOP to produce the array, probably. Should the array itself be objects is another issue. If you'll be serializing this data to JSON or XML or something similar, it's probably not worth it to pack it in objects, and unpack it later for serialization. But it really depends how you plan to use the data. &gt; What's a good resource for learning OOP for PHP? PHP's OOP is the same (in broad strokes) as Java, C#, TypeScript, Dart. The principles are generic. You'll find good articles here: http://www.phptherightway.com/
Hi. I just watched a bug go through the edge bug tracker that let you bypass CORS and make arbitrary requests to the outside world because *the Fetch spec basically allows this* and is fundamentally flawed in that regard. It did so before a CVE was ever issued. I doubt a CVE will be issued. The vulnerabilities listed are each implemented through the browser's Javascript engine. It is because of JS those vulns are there and in the wild. 
Empty entity seems like a valid state for me, so I’ll pass on this whole DTO mumbo-jumbo. If by „valid state” you mean filled and ready to save to database, you can’t do that either way. Think about unique constraints — you can’t be sure about the validity until you try to flush into the database. Well, maybe just YMMV, but most of my entities doesn’t have any complicated state — it’s mostly just content, and I accept nulls in a new entity as a valid state for them, for simplicity’s sake. Maybe it will blow up in my face some day, but for the last 5 years it hasn’t.
Pretty sure this is trollage but really, you should take the time to [get to know the tool](https://www.sitepoint.com/getting-know-love-xdebug/).
Firstly, I don’t think we understand the term „domain object” the same way. Secondly, there are a few differences between arrays and objects besides being able to enclose some logic in them, and I’m sure you know them all. I think your argument misdirects the point. But, if we’re talking black or white, yes — my entities have more to do with arrays than with classes implementing my business logic. I think it’s a valid architecture, one in which your argument does not apply, so I don’t think you can advocate is as the only valid solution. In other words, I can and I will bind my ORM to forms, without any problems you describe.
You can say that we use the exclusive features everyday since it is a package deal. The panel is exclusive and within it, the GUI over collection of features is pretty much indispensable. You do not need to use the gui if you know which .ini to edit or sqlite db to manage, but it is all there. I find that you will find usage for almost all items: * dashboard for events, statistics, notices * reporting on triggers, limit breaches * adding vhosts or apps * session clusterin(requires mysql), but that is not my favorite * z-ray is a Symfony developer toolbar copy-cat( no offense ), but if you copy something you might as well use a good source * code tracing web based within GUI( imagine finding hot code paths ) * Good debuggers like Zend Dbg or XDebug to choose from * Multi-channel job queue, job scheduling(cron like, but simpler) * Various caching rules and methods, url based, PHP API, cache management withing GUI, * user authentication ca be ldap bound, etc * PHP api for most of the features, WEB api for almost all of the features We use it all in smaller or larger fashion since its all included. Imagine a tool that represent a year's worth of developer hours to make LAMP easy and almost feature-full for majority of websites.
Without knowing your details it's hard to say what you actually need, but with that disclaimer out of the way... I don't think you'll be served well by trying to solve large data problems with PHP. This is where getting to know your database server would likely serve you well. I would strongly consider moving your data on over to PostgreSQL or some other pay to play DB like Oracle with strong programming support. You can do a lot of heavy lifting at the database server level, then produce results for your middle-ware language to present. Like gaidengt stated, you need to do some serious prototyping to see where your bottlenecks are. If you're spending a lot of time transferring the data to PHP before you even get to working with it, move that work to the DB server. If the time to get to PHP is trivial, then do your work there.
Everyone in this thread keeps referring to the price and it offers nothing much over apache/ngnix etc the real value is in the support and not so much the product itself (although the product does come with some nice extra features). &gt; Live support functionality to troubleshoot user problems in real-time This is worth its weight in gold when you have an angry customer on the phone line who is losing £millions in online sales every hour there is a problem. So in answer to your question, if you have a product (or a customer) which is making millions a day then is £7k a year really a 'huge' fee. The question is, how many hours a year can you afford to lose in down time? If its more than £7k then I wouldn't bother using it. It's the same with RHEL, why pay thousands of pounds a year when you can get (almost) the same product for free and host/run it your self? The value is in the support and knowledge. I don't want to be troubleshooting server problems in the small hours of the morning.
https://cdn.meme.am/instances/500x/65997988/futurama-fry-not-sure-if-satire-or-poes-law.jpg
Thanks, makes sense. Do you use it both in production and development? What does your deployment workflow look like? Any particulars?
Take a look at [Laravel](https://laravel.com/). It's a bit like PHP on Rails. Watch the introduction videos on https://laracasts.com/ to get started. If you like RoR active record, you'll understand Laravel's [Eloquent](https://laravel.com/docs/5.4/eloquent), symfony's [Doctrine](http://symfony.com/doc/current/doctrine.html) and Yii [active record](http://www.yiiframework.com/doc/guide/1.1/en/database.ar) very fast by reading the docs. Take a look at composer. Its a bit like bundle. So instead of ```bundle install```, you run ```composer require```. The info on PHP on the web is often wrong and outdated. Want to do it the right way? Take a look at http://www.phptherightway.com/ Just want to know about the PHP syntax? Take a look at https://learnxinyminutes.com/docs/php/
There is one advice I'd like to give you. Don't get stuck on a single language. Even if you are a professional, seeing or implementing solutions in other languages help you in your craft, even if all you do is creating template after template. That being said, yes have a look into php. Look how different problems are approached in those languages and ask yourself why. However, the decision whether you should write in x is entirely up to you. If you are good / interesting enough for employers to notice you, good. If not, improve (which is always good). If however the demand is not there at all, looking into other directions (even temporarily) can help you set foot into a company. Once you are in, suggesting changes becomes so much easier (there is still high conflict potential if you are one of your kind regarding experience).
Don't do it man. Here be dragons. Just keep at it and try to land a Ruby job.
Take a look at [CakePHP](https://cakephp.org), it's the original "inspired by RoR" framework for PHP, and has a big, helpful and friendly community built around it. We are still inspired by RoR where it makes sense :)
You're right. I was just doing a straight data-dump from mySQL and then trying to calculate everything in PHP, which is not the proper way to handle such large amounts of data. I'm in the middle of a company merger (and thus systems merger), and I got this intranet project dumped on me that was basically a quick and dirty proof of concept that was forced into production before any optimization was allowed to be done. I think my best option is going to be to use a mix of proper (and clean) Queries, mixed with some AJAX and Jquery to setup the front end where it doesn't pull all 4 years of data, but instead pulls for 1 year. To see another year, the user will click the button I'll create and then the AJAX/JQuery will populate a div with the data for that year. Basically, have the data still easily accessible, but not have it pulled and calculated all at once. To give you a better idea of what the end goal is... We have 6 ladies that log different transactions in everyday. These transactions show how much vendor X sells the item for, and how much vendor Y sells it for. The way they want the data displayed is as such... User A logged X number of transactions for (Year) - (Month), it would have costs $J from vendor X, but we saved $K by purchasing from vendor Y. So basically, a table that shows the total costs and savings for each individual user, for each month, for each year. 2017 | | | | ---|---|----|----| User | Month | Costs | Savings| Dunder_Chief1 | Jan | $1999 | $575| 
Hope you enjoyed the piggyback ride :)
Lol what. 
In what situation would using Varnish be a bad idea? I have an admin tool and I am wondering if Varnish could be a better caching system than Reddis. I guess Varnish doesn't handle dynamic data very well and it's more for fixed data like html, css and javascript files and images while Reddis is more for data.
It would be a bad idea if you don't have lots of cacheable content, naturally. Say if your entire site depends on a user being logged in, obviously Varnish wouldn't cache content from user A and serve it to user B. There are actually ways around this, but you can research various approaches on this problem (hint: it's only for huge scale, as it's annoying to deal with). Best use case for Varnish is caching static content (images, CSS, JS, etc.), and content-heavy sites with cacheable pages, like news sites, documentation sites, popular blogs, etc.
As the author of https://github.com/php/pecl-php-operator I would like to state for the record that operator overloading in PHP is a terrible idea*. * In 99.999999% of cases.
Cool, thanks 👍
Multi step forms with vuex and vue-router has been very handy as well.
still sounds like 1 sql statement to me, maybe with subqueries, dont know your database layout but doesnt sound to me like it needs any php
It is. Worse than I thought. I'm pretty happy with my build process now, but it took quite awhile to perfect it. It is pretty sweet though. I mean, it's not entirely React's fault. It just gets you thinking about how you can optimize and compress and hot-reload and code-split all your assets, which is something you can benefit from with or without React.
Is anyone using hack outside of facebook? Ideally you'd think a lot of people would have gravitated towards Hack, but it seems like that's not the case. Why is that?
Idk. For me the client should not dictate how I get the job done for him. He is the one with the business specification or/and the idea and i realize it for them. Even legacy systems can be almost treated the same way. I get it if a technology gets dictated somehow. Just so they can use the buzzwords in their marketings. But how I integrate or use them, that's my job.
Also might be worth looking into `WITH ROLLUP`
My personal principle is, don't use a framework that you're not prepared to fork and maintain yourself, should the s*** hit the fan. Frameworks, especially PHP frameworks, have a very short half-life. So extension frameworks... the value prop is not there, especially as there are countless other ways to speed up your application, should you need that.
I stand corrected. Thank you for the heads-up! Doctrine is on my todo list of ORMs. So i'm not familiar with all the nuts an crannies for that one. Just gave it as an option for OP (a RoR programmer that might like AR / ORM). Edit: tnx for pointing out it's a data mapper, instead of an active record
I hear Laracasts is amazing. 🚬
PHP has it's pros and cons. Some of the pros are it's easy to get started and it has a good community. Some cons are that it is full of black magic and you'll have to sacrifice a first-born child to Cthulhu to figure out how legacy software works, sometimes. Another pro is that it's highly adopted, sometimes by enterprises with excellent first-born-children-for-human-sacrifice budgets. 
The source really is just a big mess (no offense).. you have multiple if elses combined with switches all over the place.. going as far as 4 levels deep.. https://github.com/catfan/Medoo/blob/62b1f34df2c3aad5f841e22e215d44ba856bb8ef/src/Medoo.php#L465 But the worst part is that there seem to be literally zero tests? https://github.com/catfan/Medoo Anything that claims to have a stable API (v1.*) with no tests is pretty much a no go for me..
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [catfan/Medoo/.../**Medoo.php#L465** (master → 62b1f34)](https://github.com/catfan/Medoo/blob/62b1f34df2c3aad5f841e22e215d44ba856bb8ef/src/Medoo.php#L465) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhej5wq.)^.
I'd like to add that you can also use PHPStorm to control your tests even when PHPUnit is running inside a docker container. It's a little more complicated, but here's a [a demo project with instructions.](https://github.com/DHager/docker-php-library-demo)
Can confirm. I went from Ruby/Rails to PHP/Laravel. Its a decent stack. The docs are really good which sets it apart from other frameworks. 
I just ran the example from your link and it worked straight up. putenv("webdriver.chrome.driver=/path/to/chromedriver"); $driver = ChromeDriver::start(); The ChromeDriver class is from the `facebook/webdriver` package. (It's `Facebook\WebDriver\Chrome\ChromeDriver`)
First, thanks for not immediately downvoting and insulting. Seems dumb to say, but I feared even posting this would get me shunned and banned (not literally). I would say I have some very basic OOP in my class files. I forgot about the term 'procedural PHP'. Perhaps this is how I would classify my apps. Being a solo dev with no dev friends, you tend to miss out on formal names to things. &gt; As far as literal directory paths I don't think that's as much a programming style as it is an implementation detail. Ok, this makes sense. I thought this would have a style name. Hard to explain to people. I suppose "literal directory path" is sufficient. Thanks for the reply, sir.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Don't know if there's a pattern which suits this particular style, but there are a lot more than only mvc. Patterns mostly trying to respect principles like dry, soc, GRASP (is somewhat itself kind of a pattern) and other. I think you should give phptherightway and Design Patterns for Humans a read. (There are a lot more good resources tho)
Page controller?
I've been meaning to read php the right way. Thanks
Hmm, essentially take what the code does and literally put words to it. There's a page and there are controllers. I like it :-)
Thanks. Glad to know there are many similarities. [phptherightway.com](http://www.phptherightway.com/) seems to be the resource I've been looking for. 
I feel like the term "spaghetti" is used to define completely unmanageable and unmaintainable code. I don't feel like what I create is like that. I have two very business critical apps that are entirely maintainable and very easy to read and follow. One app is similar to a CRM, with different portals depending on the user type (think staff vs customer). Registration, approvals, etc. When I think spaghetti code, I don't think manageable CRM. Eh, it's all talk unless I had open source code to prove it, which I don't. Regardless, thanks for your opinion, sir. Edit: typo
Thanks for the advice. Definitely don't want to limit myself. I think after all the struggle to learn I've been becoming attached to what feels comfortable for me right now.
I'd agree with 'spaghetti'. Sorry but why would this style have a formal name? It's not something anyone would want to repeat so why formally name and describe it? It's the kind of architecture someone with no knowledge of software architecture would come up with. It's like using globals everywhere and then asking what design pattern that is, it's not it's just bad practice and a mess.
No need to be sorry. You have a different opinion than me; that's alright. When I think of spaghetti code, I think of code that can't be followed. It would take a dev a long time back tracing why a particular piece of code is doing something. It would also be a hassle to change anything. I don't have any of those issues with my apps. I go to a page and can see the function just the same as with the Laravel example I posted about. Comparing that app with how I develop mine, if I wanted to change the way the assets, for example, are counted, I'd have to traverse back to two or three different functions in separate areas in the Laravel app. Where as mine, I'd only need to go to one place. With IDEs like PHPStorm, traversing to find the origin functions is easy enough, though. I'm not going to convince you, that much is obvious. I just think clean code that's entirely manageable and maintainable shouldn't be lumped in with 'spaghetti code' just because it doesn't conform to what you (generalizing) may be used to. Which is interesting when you think about it. If we define spaghetti code to be anything we personally don't understand, then everything is spaghetti code to someone.
This article is a bit old. Version 2.5 is no longer a release candidate, but the main version of LimeSurvey. The latest version is [2.65](https://www.limesurvey.org/stable-release).
This is unrelated to MVC. It's a [page controller](https://martinfowler.com/eaaCatalog/pageController.html). Compare that to a [front controller](https://martinfowler.com/eaaCatalog/frontController.html) which is what most people use these days.
This has no name, as it's not a pattern. A pattern is a solution to common problems, and you're not trying to solve any problem with this software architecture. I agree this should not be called spaghetti code, as soon as it is structured and anyone (with an understanding of your framework) can tell where the code is defined, what is it doing, and how. But from what you've told us, it's just a mix between procedural and OOP PHP, nothing more. To get an intermediate example between MVC and no-pattern code, you could have a look on [Atomik Framework](https://github.com/maximebf/atomik) (no longer maintained), which has been created as a lightweight framework following a pattern that we could call "Action-View" (no models). The purpose of this pattern is to separate presentation layer from application logic, while staying simple and extensible (anyone could write plugins to improve Atomik).
I can't be sure, I know PHP 7 is being adopted like crazy because it's a so huge performance boost, that every damn hosting out there is moving because they can cram almost double the amount of clients on the same hardware :) 7.1 can't say for sure, it is being adopted rather fast and major distributions these days keep up with PHP quite well. Also, 7.1 has nullable type hints and return types, and in my limited experience, if you start using type hinting, doing it without the nullable stuff is pain, so I expect people moving into 7.1 quite swiftly. And the release cycle of PHP is well defined, a new minor version every year and 3 years lifecycle, so we are upcoming to 7.2 this November-December and 7.0 will be going into security maintenance mode and will be not supported in 1.5 years.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'm currently using Bitbucket, pushing from dev and pulling on production. Probably a bad idea but it works for now aside from that I'm just using sublime for all my coding
You can set up your own Git Repository on your server, and deploy using Git, without ever touching GitHub or Bitbucket. Here's a guide for how to do that: https://www.digitalocean.com/community/tutorials/how-to-set-up-automatic-deployment-with-git-with-a-vps This ALSO gives you the AMAZING benefit of using Version Control through Git, which is quite frankly awesome. Feel free to ask any and all questions :) Also, for IDE, I can wholeheartedly recommend PHPStorm!
Currently I use something called [deployer.org](https://deployer.org/) - deploying changes from one of my repo's via ssh on my server is as simple as: `dep deploy prod --tag=2.3.11` Which essentially goes through a list of settings, grabs the git repo changes from my private repo based on tag, updates and runs composer (if needed) and then done. I have it setup where it takes my site into maintenance mode and back off when completed. Deployer has things called `task`'s which are basically php closure which you setup to do things in the order that they come. Also comes w/ cool features like symlinking folders or files. Which is useful if you want to seamlessly deploy without any settings being lost. (note: those config file's are in .gitignore, but the application still looks there for them and this is a super convenient way of handling that, some people prefer using `env` variables, and that's cool w/ db and what not - whatever works for you) set('shared_dirs', [ 'src/Logs' ]); set('shared_files', [ 'src/Config/app.yml', 'src/Config/sitemap.yml', ]); They are also working on an automated system which is wrapped around the application, but it's in beta atm. Laravel's creator made something similar called [Forge](https://forge.laravel.com/features), but I have no experience with it. I'm personally working on something similar to deployer in /r/crystal_programming, but it does something a little different to solve a specific issue I have w/ a work project that I don't want to get into details yet until I have a public working version available. PS: Use [bitbucket.org](https://bitbucket.org) for free private repositories if you don't want your code public
So do you have all your code on your local machine?
Thanks. Glad to know the release cycle and adoption is quite regular. That's a good point.
Difficult to test ** That's subjective. I found it difficult to test the Snipe-IT app until I understood it. I can't claim its terribly written because I didn't know how to test it at some point. Mixed responsibility in files ** I won't argue there. Poor reusability ** A unique page where a query is run only on that one particular page necessitates a function call for said query? I'm a big proponent of actually writing out SQL, not just depend on a simplified ORM. If I need a very unique query just once for a very specific use case, I don't see how not having a function call for it is detrimental. Boilerplate ** Every view page I saw in the Laravel app I looked through had the same, or very similar, top. I don't see how that's different. Your last bit is subjective. PHP has evolved tremendously. What was once best practice (mysql_*) is, today, deprecated. MVC was evolved from non-mvc. Different frameworks exist. There are plenty of people who don't code in conventional frameworks, as I've been learning. We have entirely different languages that do the same thing. I stand by what I wrote. Lumping clean, readable code with unmanageable code and calling it spaghetti just because you (generalizing) do it different is disingenuous. I'd argue that I code more toward 'pure PHP'. If we want to call vanilla PHP messy, then we'd be arguing entirely different things.
Oh. So /u/thinsoldier was correct. I seem to have been describing page controller. Thanks for the link!
common sense is not always good sense. But in this case it is.
Over time, I've definitely separated more layers than when I first learned to develop. I'm studying more apps developed using some frameworks so that I can better understand and perhaps borrow some aspects. I just find it much easier develop with a page controller style, as has been pointed out in this thread. Thanks
I think the answers so far have glossed over some of the more important details. 1. Github is just Git hosting platform. Git is a distributed version control system. This means each user has a versioned copy (for the sake of simplicity I'll ignore branching) of the code and their copy can diverge from all other instances or converge via a merge. Changes can be committed to your local copy and you can revert to any previous commit. You can use git in this way without any other copies of the code existing just to allow changes to be reverted if they did not work as expected. However at this point if you lose your local copy of the code your entire history is also gone. So ideally you would have another copy of the code hosted somewhere reliable as a backup. This is where github comes in. Pushing to github is effectively just synchronizing your local code's history with another copy of the repo stored on github's servers. It can end there without discussing anything to do with deployments. 2. Deploying from a Git host (e.g. Github or Bitbucket) So at this point you have your code version controlled locally and are pushing changes periodically to the git host but how do they actually get deployed to a web server? Well the answer is a bit complicated because there are endless options but lets just take the most basic approach. So we already know that we can have multiple instances of our git repo. One local and one on github, but there is nothing stopping us from cloning a third copy of the repo to the web server and pulling changes from github whenever we want to synchronize this live copy of the code with the most recent changes pushed from the local copy to the hosted copy. This approach or some variation is relatively common for simple deployments but you need to be a bit careful to not expose the .git directory. 3. Real time editing of live code In general you will not have the real time editing workflow as you use currently if you switch to a deployment-via-git approach. Instead you would be working on a local copy of the code. Committing the changes. Pushing the changes then SSHing into the web server and pulling them. This means you would probably want to be able to run the code locally before committing anything. 4. Version control is always relevant You could use git with your current workflow. Ok so it's not ideal but the first step forward would be to start version controlling your local code even if you continue to push changes via FTP. Version control is a no-brainer at this point even if you use a different tool to actually deploy code. 
These are actually a couple of questions that you seem to have interpreted to be the same thing. A quick run through: - How people develop and test their code: Most people develop and test on either their local machine or a remote server so the code is not accessible to the public until ready and tested. 'Live' editing like you do is something that is considered most evil in professional environments. - How/where the code is stored: The norm is to use a version control system (VCS) of wich Git is the most popular. With a VCS you can track all your code's changes and history. Git can be pushed to a remote server (not required, but hey, computers break, data gets lost). Github is a popular free host to do this, but it's for open source projects, that's why it's visible for everyone. Bitbucket provides free private repositories. - How people deploy their code for use by the end user: Only working, correct, tested code is pushed to the production server (the one where you're working directly on right now). This is usually done using VCS to make sure you're pushing the right state. There's a ton of ways to do this. In short: separate these steps and please read into Git. 
Just wanted to point out that BitBucket is similar to GitGub and allows private repositories for free.
Thank you for all of your hard work, Derick!
For my first year working as a developer I wasn't aware of point 2, but a few months in was introduced to mercurial by a work colleague. I continued to use FTP for about ten months still, before realizing the better alternative, but hg had already improved my workflow considerably, and it saved me many times that I needed to roll back changes &amp; once got me through the death of my HDD. Version control is always relevant.
[Big ball of mud](https://en.wikipedia.org/wiki/Big_ball_of_mud).
Is this desperate for ticket sales? It's posted here every few days. :/
If we'll be talking about testing, if you *really* insist on correct architecture, none of your testable business logic would be in MVC, which is your UI layer (and UI should be tested via /headless/ browser tools and manual QA). How do you test your *views*, really? What about your view-producing *controllers*? Truth is nothing is lost, because nothing is unit testable there, aside from very basic regressions tests via tools like Selenium (which you can still use with OP's sites).
Nope not desperate, just sharing the event :) We are trying to share with as many people as possible, had some people find us last year just after CakeFest had finished, saying they had missed it and hadn't seen it - so trying to post everywhere this time round!
Wow, that's actually a real thing. That's great.
Well, as you said, unit testing views and controllers is typically a pointless endeavor. If so, separation doesn't really aid in testing what you wouldn't test. There's a much bigger sin than combining controllers+views here, and a big majority of people using frameworks, and claiming to be doing "MVC" and "OOP" commit it on a daily basis: fusing domain+UI. I.e. if someone validates input in their controllers, if they interact with the database in their controllers, i.e. business logic concerns, then this robs them of the opportunity to test their most testable (and most test-worthy) code: their UI-independent domain / business logic. I.e. `(domain+controller) + view` is much worse IMHO than `domain + (controller+view)`. And yet the former is exceedingly common, still. Of course in the general case one shouldn't fuse controllers and views, either, if they want to be flexible in choosing views parametrically and so on. But I'd call this a contextual and subjective choice at best.
Off topic: I hate sites using sticky headers/footers so much.
And thenyou have 2 fields, say an Email and a Username and both have unique constraints. Your code tells you that a unique constraint failed. I don't think you can easily find out which that is to display to the user.
wonder how many clicks you have to do to find something worth reading... who knows really.. 
I prefer an extra dependency which I know works, than to write it from scratch, also; adding it as a dev dependency won't install it in production; so there's no performance cost. Although I doubt the composer autoloader really adds a lot of loading time.
I could only find this commit made in 7.0.19 concerning MySQL. Don't really know what it does though.. https://github.com/php/php-src/commit/35a28fac51e4b210f8f3f51b754786908a977462
I'm in the middle of migrating the admin area of my largest project to MVC using no framework and 1 very old library that does too many things (front controller and routing and templating and validation and request/response objects) because it's the only _good enough_ thing that will work with the php version on this old server. As archaic and rudimentary as this approach is compared to what I _should_ be doing, I strongly prefer this half-assed mvc approach over page controllers. The #1 reason against page controllers in my experience is you may have some .php file lying around somewhere that nobody has touched in 8 years and nobody knows what is in it and if some search engine spider were to somehow visit that file someday it could wreak havoc. I recently found an ancient "import.php" lying around in my photos folder that someone must have accidentally ftp uploaded to the wrong folder way back in 2007. If the url for that file was visited AND a table named "listings_bk" existed in the database (which is actually the case sometimes when I'm making modifications to the listings table) then all db tables would have been truncated. With a front controller *all* activity has to pass through index.php and has to be defined by a route. In a framework like laravel a simple terminal command can give you a list of all entry points to your application which makes it easier in my opinion to catch problems like what I just described. A file like my import.php would never have been uploaded to the web accessible directory and the only way it could be triggered is if I defined a route for it.
This is not a support subreddit. Use /r/phphelp
No.
Come on, [you already posted this article 2 weeks ago](https://www.reddit.com/user/SarasaNews), but from the different site. The article itself is good but it turns out you're just a spam bot. Therefore stay away from this sub. 
Thanks will look into it
Thank you for your answer 
Very helpful 
Not to pile on but I don't understand the "light-weight" claim at all. This actually seems harder to use due to all the table/column abstraction and the huge file is not a selling point to me. I prefer something like Doctrine DBAL which is well documented and handles abstraction of different engines very well and supports more than just PDO - and you write queries instead of messing with a query builder.
I'll echo what others are saying about it being a page controller instead of a front-controller. From there, it looks as if you're doing some separation of concerns, given the `$theme` object. It's hard to say without more code, to be honest. I have seem objects just like `$theme` in other projects that turns into a bloated [god object](https://en.wikipedia.org/wiki/God_object) but cannot say from this example. So, there's at least some OO going on. I'm betting that with how clean the limited example is and that you're using Composer to pull in what are probably modern libraries, you're most likely doing a bunch of OO stuff already. Specifics aside, this is common PHP style from the old days, if cleaner than many of the messes from that era. It's basically all that the language was really capable of. Aside from being an instance of the page controller pattern, there doesn't appear to really have been much codified about this style. Each project seems to have had its own interpretation. Many of the off-the-shelf OSS PHP projects, like MantisBT, still work in this style. It is difficult, but not impossible, to migrate from this to a front controller. I'd argue that front-controllers are preferable for projects of any size, as you gain more control over your URL structure, can hide more code outside of your Web server's directory, and are able to centralize what quickly becomes repetitive bootstrap code. I tried to do such a migration some years back on a seriously legacy project. If I were to do it today, I'd try to start swapping in Symfony components and then try to inch the application structure to match what Symfony uses when you're using it as a framework.
I think their is their only metric for 'lightness' from their homepage: &gt; Lightweight 32KB around with only one file.
Sounds like you're doing a search... the Google search bar *pretends* to be a drop-down with its predictive suggestions, but it isn't. Drop-down combo-boxes are designed for a user to scroll through and select an option. I can't imagine they'd do that for 10k+ options. Hell, twenty is probably too many for that UI element.
/r/theydidntdothemath
**Here's a sneak peek of [/r/theydidntdothemath](https://np.reddit.com/r/theydidntdothemath) using the [top posts](https://np.reddit.com/r/theydidntdothemath/top/?sort=top&amp;t=year) of the year!** \#1: [Close enough](http://i.imgur.com/tojPc7S.gif) | [14 comments](https://np.reddit.com/r/theydidntdothemath/comments/5jczal/close_enough/) \#2: [50% of Women](https://i.imgjar.co/jar/SYtXsJXTlk64wiTmKA0gzQ.jpg) | [10 comments](https://np.reddit.com/r/theydidntdothemath/comments/5yirhd/50_of_women/) \#3: [Walsmart maths](http://imgur.com/o8NfCCW) | [9 comments](https://np.reddit.com/r/theydidntdothemath/comments/5a4rjl/walsmart_maths/) ---- ^^I'm ^^a ^^bot, ^^beep ^^boop ^^| ^^Downvote ^^to ^^remove ^^| [^^Contact ^^me](https://www.reddit.com/message/compose/?to=sneakpeekbot) ^^| [^^Info](https://np.reddit.com/r/sneakpeekbot/) ^^| [^^Opt-out](https://np.reddit.com/r/sneakpeekbot/comments/5lveo6/blacklist/)
Thanks. I'll have a look at the structure of MantisBT for comparison's sake. *I do stay away from god objects :-)*
Do yourself a favour and start reading up on frameworks and software design, it'll help a lot.
I'm glad to hear you run non-prophet projects. ;)
A `composer update` or `install` will always use the version constraints set in the composer.json file. I think this tool is to upgrade beyond that, and see if your code is broken with new version. Besides, shouldn't we just commit the `composer.lock` file and make composer build the exact same version in CI server? Even projects with 100% test coverage could have bugs with a different dependency version.
Did something similiar recently with ext-imap and it was a no-brainer - and I'm no phpro. Give it a shot atleast!
With that attitude you'll be fine. This is a really good 'book' which explains a lot of the stuff people are repeating in this thread, but with some solid examples using components from the Symfony framework. I'd recommend giving it a read: http://symfony.com/doc/current/create_framework/introduction.html
Your version is off for RedHat 7 since by default it should be 5.4.16 so you already have it installed from somewhere besides the default repositories. I use Remi Collet's repo https://rpms.remirepo.net/ for backports of older versions of PHP on my Fedora 25 workstation. His stuff is also available to install newer versions of CentOS. He is the guy who maintains the PHP rpms for RedHat, you get the fresh versions there first. Here is a presentation his work. https://blog.remirepo.net/public/Docs/PHPRPM.pdf For a more offical way you can can use RedHat software collections, they have most versions of 5 and 7 available: https://developers.redhat.com/products/softwarecollections/overview/ https://www.softwarecollections.org/en/scls/rhscl/rh-php56/ I have no idea how the software collections work since I'm not a sysadmin. Good luck! 
Going to give that a read. Thank you for the guidance.
Keep disagreements civil please `:-)`. 
Please only post significant updates. This and the last post have been removed, as we're not cool with a constant stream of promotional posts.
Adam's course is great and totally worth the money. The progression of building the app is really great and adam is a great teacher.
Do yourself a favor and don't learn from the laravel community. There may be some people that seem like great teachers, that will teach you all the best stuff, and it will maybe help you make some more money on short term, but you'll learn so many bad practices that will make you even worse engineer in future. 
My experience has been different. I've learned a lot from Laracasts, it especially propelled me after learning PHP but not understanding frameworks. I find Jeffrey Way to be the single most important person in my journey from "whats a HTML?" to "gainfully employed and kicking ass at developing." Do you have any alternatives to recommend?
I don't know about past, but today's "kicking ass in developing" has became like pop music... the worse ones are the most popular and coolest stars. You just have to do fancy and shiny stuff. The people will like you no matter how bad your work is.
We're looking at different stack overflow posts I guess. Or you're just talking out your ass. The latter is more likely, since any Laravel specific posts are likely to be by people who are particularly inexperienced.
You speak in pretty rough generalisations, it's hard to argue with that rhetoric. I went from having 0 skills to being employed in just four months of self-study, and a decidedly accomplished developer in the three years since. Maybe if you saw my code, you'd slap me in the face. Who can say, nor do I care... I'm just still trying to improve, hence this post. I'd say thanks for the replies, but you didn't actually respond with any resources to help, so...
I'm trying to associate "you'll learn so many bad practices that will make you even worse engineer in future" with facts. Apparently you're not.
https://twitter.com/adamwathan/status/839930049453244416
I have no idea what you're trying to communicate or how it relates to your criticisms of Laravel.
When someone asks a simple question it's low hanging fruit. Even idiots can pick low hanging fruit. You'll find that with any language or framework, but since this framework is popular you're going to find many beginner questions from people that have absolutely no experience and just happen to find this one first. You should at least attempt to look at the bigger picture so you don't make myself look like an idiot by making wild assumptions that you can't back up at all
I would suggest looking at real tests from open source projects. Here are some unit tests for a popular library for Date Time stuff, Carbon: https://github.com/briannesbitt/Carbon/tree/master/tests Here are some tests for a framework, Slim: https://github.com/slimphp/Slim/tree/3.x/tests Here are some tests for an status-page application, Cachet: https://github.com/CachetHQ/Cachet/tree/2.4/tests 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [briannesbitt/Carbon/.../**tests** (master → 926aee5)](https://github.com/briannesbitt/Carbon/tree/926aee5ab38c2868816aa760f862a85ad01cb61a/tests) * [slimphp/Slim/.../**tests** (3.x → d282722)](https://github.com/slimphp/Slim/tree/d28272231017ae737abeee4b99673cbf29ee4e69/tests) * [CachetHQ/Cachet/.../**tests** (2.4 → 501768e)](https://github.com/CachetHQ/Cachet/tree/501768e8df6718ddf64b30497e0c4b0fc3ad71cf/tests) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhg7al4.)^.
If you don't want to do cron, look at phpfastcache.
I even lump OO PHP (that's non-MVC) as Procedural PHP.
Cant be that bad since its 90% upvoted hey! Its not really promotional - we are just sharing our conference with the PHP community - the same as any other framework does on this subreddit. Bit unfair that you have removed it? 
I'd say it kinda depends on how long your image-creation takes. If it's done within milliseconds, I'd check for a "most recent creation" date and if it's older than X seconds, fetch a new one, otherwise load a buffered one. If the image-creation itself takes a couple seconds, I wouldn't load it onto users, but rather do it scheduled server-side. The question is also, whether you want to just show the most current image at any given time or back-up previous images to offer a history to your users. It kinda is important to figure out if you want to store the data or just throw it away before you can decide on how to implement it. For projects like way-back-machine you need different approaches than for "is my server online"-systems. 
Well said.
If you offer Cthulhu your sanity, it is reported that he will take it instead of your first-born. You gotta choose which one is more important to you. 
Thank you, this really explained a lot for me! I am quite excited to get into using Git in some way shape or form. How does it work then, with databases? Lets say I update / modify the code, or switch around some columns or rename a column (or something) in the database, and modify the code to reflect that. Wouldnt using Git only update the code, and not the databases?
Tl;dr: cloudways spam, install symfony3, install elastica bundle
Thanks, having issues posting to reddit.
I would personally say so. Mainly because you need to set up plain Git no matter what. Using Github/Bitbucket doesn't actually do deployment for you. It's simply a repository for your code.
Hi David. How is the support for custom Composer repositories with private hosted code? For open source packages, there is a service called VersionEye that you might be interested in.
It's not about the echo. Maybe PHP 7.1 has a slightly higher base memory footprint. https://3v4l.org/5p7kN/perf#output
Hi John, thanks for the response. Relating private hosted code, I don't really know how "composer outdated" would work. Two days ago I run the program on a site of mine, with a private vcs, and the thing didn't work well, though it's now clear to me where the error came from (I've an open issue for that). The behaviour of this package, so, is just to output the results of "composer outdated", having in mind that you're running the command from your browser (probably www-data user), so issues may arise.
What is the point of this _summary_? Also : _5. Visual Basic_ what.
The article reads like it has been through the Google Translate wash more than a few times. &gt; In this time one Language Used in Nowadays from Some old programs languages. I have no idea what this sentence could even try trying to convey.
Interesting, adding a return after the echo drops the percentage increase to 55%. Still this is a huge increase in memory usage between a point release, do you know what is causing the increase in base memory footprint between v7.0 and v7.1? EDIT: why the downvotes?
&gt; \5. Visual Basic https://media.giphy.com/media/l3q2K5jinAlChoCLS/giphy.gif
I'm very excited about this release. We have a company policy to only use PHP versions whose numbers sum up to 13.
Looks like the jump happened in 7.1.2 read the changelog here: http://www.php.net/ChangeLog-7.php#7.1.2
7.1.2 is mostly bug fixes, do you know which bug fix has caused the huge increase in memory usage? 
&gt; The source really is just a big mess (no offense).. you have multiple if elses combined with switches all over the place.. going as far as 4 levels deep.. This tends to happen when writing high-performance parsers/generators to be honest. Notice that code is intended to parse out expressions from an input array and turn them into SQL (or something). I'm not casting a positive or negative judgment over the entire component (I haven't looked into it enough), but I'm just saying, don't be quick to reject complex conditional code when it comes to parsing/generating and it has to be fast. [Symfony's Yaml parser](https://github.com/symfony/yaml/blob/master/Parser.php#L158) looks just as bad (if not worse).
r/titlegore
Yii is a good framework and this article is a shitty blogspam
Hey i just got an email about it going live, congrats. I had some trouble figuring out how to add my repo, a picker with my current repo's on github would be super handy, Also the sync button could give some feedback that its working
Interesting! One more question then, so i have to pull the entire codebase at once? If i just wanted to update a singular folder or sub domain for instance, could I do that with git/github? 
This is not soo new The actual first OS project to do that was probably CakePHP. The CakePHP DebugKit plugin contains this for a while now in a tab called "Packages": https://github.com/cakephp/debug_kit#built-in-panels
55% is huge. No matters how many MB. 
I am not yet learned the idea behind the unit of work, but at least I can recommend you two things to consider. 1. Make it DataMapper-based. Simply because of the Single responsibility principle. A PuddingRecipe class that has a LoadFromDatabase method is a Frankenstein. So it is logical to have a PuddingRecipeMapper class that can bake you a PuddingRecipe instance. 2. You will need a factory to seed the single database connection into ORM classes. Here is a good implementation, http://stackoverflow.com/a/11369679/285587
Have you considered Redis? It's got some bells and whistles (ie. Data Structures) that the others don't have.
For new projects we use [redis](https://redis.io/) instead of Memcached. It is slightly slower than Memcached for some data, but it makes up for it with much better configurability and a slew of [data type options](https://redis.io/topics/data-types). Even if you're just using it as an out-of-the-box string store like Memcached, the fact that it is newer and now more popular makes it a better support experience for us. No matter what back you decide on, don't reinvent the wheel. Use one of the many good caching libraries like [Stash](http://www.stashphp.com/) of [phpFastCache](http://www.phpfastcache.com/). We use the [Doctrine caching component](https://github.com/doctrine/cache) because we're already using Doctrine. You might also want to check if SQLite is causing trouble. SQLite works OK for concurrent reads, but it's terrible for concurrent writes. If you're modifying the database at all, it's probably going to block. MariaDB or PostgreSQL will be much, much faster in those circumstances.
The problem with APC/u is it's not distributed, the second you have to load balance you have to rip it out and replace it with something else like memcache/reddis. It's also states in the read me that APC shouldn't be used for session data as it's susceptible to cache-slam issues.
As long as not another Active Record kind of ORM because they're already too much. We needs more Data Mapper ORM, using plain PHP object as entities.
Maybe you can build one ORM that doesn't imitate ActiveRecord (Eloquent) or Hibernate (Doctrine). They all have the same flaw - they mix read and write models, in an extremely unnatural way and they don't even realize it. Let me demonstrate, imagine if SQL worked this way: $result = $pdo-&gt;query("SELECT * FROM users WHERE id = 1 LIMIT 1")-&gt;fetch(); $result['firstName'] = 'John'; $pdo-&gt;flush(); // Save the new user name. That's how Doctrine works. You fetch results, you modify them in-place, and call a magical "flush()" method to *update the result set for that query you just issued*. This is silly for many reasons: of flexibility, of performance, of maintenance, of expectations. But it's not just SQL. Imagine if REST APIs worked like this: $response = $guzzle-&gt;request('GET', 'https://www.example.com/user/1'); $response-&gt;getBody()-&gt;setField('firstName', 'John'); $guzzle-&gt;flush(); // Save the new user name. I know those examples look ridiculous. That's the point. Because... **everywhere in your code, throughout your entire pipeline, you work with explicit queries, and explicit commands.** ORMs wedge right in the middle of it all, and they want to be Different™. This is the cause for untold number of performance issues and incidental complexity. ORMs can be good, they can be amazing, if they embrace explicit queries, and explicit commands. There's no need to repeat old mistakes. So if you want to make another ORM, don't imitate what ORMs do, just see what we already do everywhere else in our apps. 
Nope, 7.0.6.
http://imgur.com/gallery/FmYjcHV
Maybe it's not OP calls on what database to use. Can't see how your question is helpful.
The guys at Composer contacted me, and ComposerCI is going to be renamed to DependenCI!
Technically it violates SRP. Developers can abuse this by putting all the business logic in their models. But IMO, that's a problem with not understanding how to properly use AR. I'm sure I'll get downvoted to hell, but there is a way to use AR successfully for small to medium sized applications. I can't speak for large enterprise apps as I've never built something that large yet.
? lmao. do you not write unit test? I do.
I suggest you figure out a particular workflow or design style, and make a *specialist*, opinionated ORM. Trying to make it too general or extensible and you'll never finish :p
I didn't take offense, I need all the information I can gather! Thank you so much for taking the time to explain it to me! I'll definitely watch those videos. I'm excited to start using it! 
I'd suggest you read up on the [object-relational impedance mismatch](https://en.wikipedia.org/wiki/Object-relational_impedance_mismatch). This is the major problem with ORMs, the thing that's going to break your brain the most, and how you decide to solve it will probably dictate how you build your ORM. Yegor's complaint in the article boils down to this. The mismatch means that you can never effectively solve the problem 100% in either direction. Most ORMs (in my experience anyway) solve it by making relational data fit into objects; his solution, SQL-speaking objects, solves it the other way, by adapting the object around the demands of the database. The first approach is good for basic CRUD apps. The second is good for databases with complex relationships. Both have their own set of issues and challenges. Good luck with it!
I know I've basically already asked this question, but you said a group of files, could a group be a subdomain for instance? As a lot of subdomains on my servers are separate websites, complete by themselves. If I could make separate groups, then it would be nice to split them up but subdomain at least. I have a feeling your going to tell me no, and I'm sorry to pester you like this. One again I am really grateful for your help. 
Does 3v4l possibly only have opcache/VLD/xdebug/whatever loaded for the latest version?
Well, you can always write your own implementation of PSR-7, but for people using other libraries implementing it, I think it's a good practice to abstract the use of it. This one relies on Guzzle, but it could be easily replaced by any other. That's the point ;)
It's a 55% increase for the smallest possible case. If it's 55% for everything, sure, but the interesting part is how the behavior is under real life loads. Would you assume that a 55% increase was bad if the memory usage remained static for 7.1.x, but increased gradually for 7.0? A single datapoint is mostly useless. 
Thank you and thanks for pointing this out, I've heard of this issue before but never gave it much thought till you showed me this article
Your arguments make sense. I've worked largely with AR sonits ine of the main inspirations but not the only one. I understand where it falls apart and where it doesn't. It's an inspiration but not a direction, if that makes sense.
Absolutely. Personally I love AR. Maybe it's because I learned Laravel at the beginning of my professional career and advanced me very far or because it's just nice. But I definitely understand where Data Mapper can be better. Depends on project needs and requirements. 
&gt; Having objects not dependant on the DB gives you much more power and freedom..at the end you have a manager responsible to take whatever object and map it to the underlying db. I haven't really ever understood this argument. Here is why: 1. **I was using Sqlite and now I need MySQL!**: AR implementations should allow you to choose different database drivers. A model should never rely on strictly a MySQL or a Sqlite implementation. This depends on how the DBAL is implemented. At the end of the day, I should be able to switch from Sqlite to MySQL without having to change a single line in any of my models. 2. **My application has grown and now my model has been split into two tables!**: That means your model is no longer properly representing itself. Personally, I feel that a model should be a 1-to-1 mapping of the table it is stored in. Data Mapper allows more flexibility here, but that can result in many models that have nothing to do with the actual database they represent. Is that flexibility or poor implementation? I think it is poor implementation. AR does not let you do this. 3. **Logic is duplicated everywhere!**: This sounds like a problem with how you _used_ AR. If AR is meant to be a 1-to-1 mapping of the DB, then why is there any business logic in there? There shouldn't be. This is where Repository Pattern comes into play as well as the business logic layer which pokes some serious holes in MVC but...that's an entirely different discussion.
Building an ORM has some really great benefits if you get to put it into production somewhere and are ready for crazy issues to come up. I would recommend finding an ORM you like the API of and trying to create a simple version of it. Maybe just the CRUD portion of it first and then give it a test and get some activity on it. The one downside is that when something goes wrong, it's pretty painful.
This is a win win. Great cause and also thanks to Digital Ocean for teaming up on this!
Done. What a great cause. Major respect to DO for doing this. They just won my business.
Contrary to what some people have said, SQLite is a decent and performant DB engine for *typical* workloads. It's primary drawback isn't that it's slow in general (it's quite fast!), but that it can't scale to handle a lot of concurrent writes. The typical website is read-heavy and fairly low traffic, and should be fine on SQLite. If you're not running a typical website then we'd need to know more about what you are doing. How many DB writes are you doing per minute, at peak times? Because it's quite likely your problem isn't SQLite, but poor query design, missing indexes, N+1 queries, etc., and slapping a cache on top is just a band aid. On the other hand, if you're scaling beyond what SQLite can handle, then again, slapping a cache on top is just a band aid, because what you really need to do is upgrade to Postgres (or MySQL, MariaDB, etc.). (Also consider that using cacheing to reduce *writes*, rather than *reads* is a very hard problem. What are you planning on doing with the cache, exactly?) As far as what cache to go for, you seem to be focusing on speed, but that's largely irrelevant unless you have a very unique workload. Any cache will be fast enough; the key question is whether it needs to be shared between servers. SQLite won't work for that, so *if* you're wedded to SQLite, you might as well use APCu, although this is quite likely to be doubling down on some deeper architectural issues. On the other hand if you are legitimately trying to scale to meet large loads, then you will need multiple servers. This means you'll need to ditch SQLite, and that APCu will not be suitable. Instead, I'd recommend Redis. (Memcached would also work, but Redis has some advantages of Memcached.) In short, if you have a *small* load (especially one which is read-heavy) and no need to scale beyond a single server, SQLite and some marginally sane DB design should be more than enough; you shouldn't need APCu at all. If you do you either have a very odd workload, OR your design is wrong. On the other hand if you have a *large* load (especially a write-heavy one), and do (or will) need to scale beyond a single server, you need to switch DB backends, and if that's still not enough, look at adding Redis or Memcached.
I would say so far doctrine proved itself to be ideal for me..I have 1:1 object: tables these do nothing just have the properties representing columns and getters/setters ..of course the wiring is done by annotations. Working with these objects is really great, the creation of tables and db is turned around because you model your entities first and how you want to use them and create the db structure out of them. Of course you have repositories and the entire model layer which is responsible for putting the data in shape..but generally you don't care about the db..and you write DQL never sql.. The best showcase of the Data mapper approach was for me when I needed to process an excel..loading 5000 thousand rows with formulas into db..the AR approach run out of memory..while with the data mapper I was able to flush changes after every 100 rows and it took 3 minutes but completed the task
Here are some things I might do: - Create unit tests - Move duplicated code into functions/methods - Restructure the code into a few class/interface files
What are the more active/popular psr-11 DI Containers out there with autowiring/auto resolving included?
The Yaml parser is indeed complicated but it does have unit tests, has more than one file and methods do have a comments explaining what is intended.
I'd afraid you'll have to be more specific if you believe there's a vulnerability in the little example I gave. In the context of storing any user provided data and then outputting it onto a page, it's common knowledge to distrust and sanitize the provided input. Also, even if a developer didn't do that beforehand, json_encode escapes the output.
If you are on Windows, just install Microsoft Web Platform Installer. One click install of php and mysql as services and will automatically integrate IIS if you want to use that as a Web Server. Most of my local tests just use the php web server. 
Use vagrant+virtualbox+nginx with an Ubuntu box, lets you switch projects easily, replicates likely live servers you'll encounter in future. Free. Can turn it off and not have any junk running in background. Can easily transport it to other computers. Just set it up to forward port Also, use git to save your learning project. Useful skill to have. Might take longer to set up but every time I've tried to use a preconfigured thing I've always had to waste time trying to tinker with one thing or another. Perhaps overkill, but its good to get the ecosystem right. 
Just to play devil's advocate, you don't *have* to load an object to update with Doctrine. Often, you might have a use for that object. But if you don't, there's no need to go hydrating it. A few options off the top of my head: * update with DQL, e.g. *UPDATE Acme\User u SET u.name=? WHERE u.id=?* * Use a [reference proxy](http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/reference/advanced-configuration.html#reference-proxies) instead of loading, e.g. *$user=$em-&gt;getReference('Acme\User', $userId)* 
Definitely overkill for someone who plans to start learning.
PHP is much more complete on its own right than people realize. Not only it has a built-in web server as others note here (which is 100% good for development and simple intranet needs), but it also comes with SQLite, which may be "light" but has a powerful query engine, and is ideal for all your database needs, right up until you start getting those coveted millions of hits per hour on your site (at which point you can migrate to bigger databases).
It depends a lot on what you want to do. I understand why people suggest the slim and simple "Just install PHP and use it's dev tools". It's a great way to learn the language itself without having to deal with an actual server and database. But if you want to learn by creating a web with PHP or the learning resources assume a full stack installation xampp or a virutal machine provide a "similar to production" environment that is also great. If you have experience with another platform any option should be rather painless. Beginners may feel more overwhelmed.
That's exactly what I thought when I first used vagrant, but boy was I wrong. Trust me, even the smallest of issue/problem that you encounter with them become a headache. As someone who's just about to start learning, I don't think that's encouraging.
Not really related to PHP is it?
Brilliant, many thanks!
for simple pages, you can go to [phpfiddle.org](http://phpfiddle.org/) and use their online-editor to write and test code. but for more complex projects, having some sort of server available is definitely required. If you don't want to bother with setting up a local server, there are tons of free-webspace providers out there, offering limited space, but also often php and mysql. Might not be the best or fastest, but for learning purposes, they'll suffice. there are tons of ways to get access to server-functionality. XAMPP is just one of those, thats comparably easy to work and that is available for all OSs. You NEED a web-server of some sort. you CAN use xampp. 
Encoding json to a JavaScript variable like that is a security vulnerability. You should use a proper AJAX request. Edit: here's some info: https://forums.phpfreaks.com/topic/294115-json-encode-is-not-a-security-feature-or-how-to-pass-php-values-to-javascript/
Keep going! 
Nice work, that's looks to be super useful! Any reason why this is on Gitlab and not GitHub?
Where did you get stuck on the JS implementation? I'd love to see ruby and js ports and I could lend a hand.
&gt; I think your guzzle analogy is a bit flawed. guzzle is more of a database connection object. Indeed, hence why I use the same analogy for both Guzzle and a Database Connection object. :-) &gt; One could imagine a GuzzleEntityManager which uses a GuzzleConnection object to execute queries and updates. In fact you could probably implement the DoctrineEntityManagerInterface and, within reason, replace your sql database with a REST like database. Indeed you could, because that's precisely what Doctrine did. It took a database connection and slapped that abstraction on top. The ability to do it is not under question, Doctrine is already an empirical proof that you can do it. The question is if if you should, if it's the most flexible, simple and performant approach. And is it an approach you apply in any other layer of your application (again, RDBMS and REST being two such layers). And my thesis/demonstration above is "no" on all accounts. Just by the nature of what's going on, you need to *at least* issue a SELECT query on all entities you plan to UPDATE, which, of course doesn't happen in SQL or REST... you can update directly. And the SELECT should fetch not just the fields you plan to edit, but typically the entire entity. The method is full of illogical operations and inefficiencies under the hood. &gt; The entity manager maintains a cache of objects queried (aka unit of work). All a flush really does is to determine which of the cached objects have changed then executes the update. Not really all that magical. You seem to think I'm using "magical" as in "I don't understand how it works". I understand very well how it works, I just don't like how it works, and the resulting infamous "impedance mismatch" it introduces in the API exposed to users. Also we need to make a key distinction here: *the Entity Manager and the Unit of Work pattern are two distinct things*. You can have "unit of work" without this. In SQL we call it a "transaction" ;-) you use it every day. And it works for mappers in exactly the same way: $mapper-&gt;begin(); $mapper-&gt;update(...); $mapper-&gt;update(...); $mapper-&gt;update(...); $mapper-&gt;update(...); $mapper-&gt;commit(); No entities, or Entity Manager required... &gt; Having said that, I have pretty much moved away from the Doctrine ORM. I have Finder objects which only do queries and Updaters which only update. Yeah I think the fact you've moved away from Doctrine, and to a command/query model precisely like the one I'm describing, is a testament to the fact we agree on all the major points :-) So it's strange we have to be at odds about the minor things ;-)
I'm usually use Zend Hydrator, but your's looks simpler, thanks :D
You can start with this one http://sandbox.onlinephpfunctions.com/
What about PHP makes it unsuitable for testing?
 &lt;?php error_reporting(E_ALL); ini_set('display_errors', 1); 
No. PHP has it’s own built in web server that you can invoke at the command prompt. Modern PHP frameworks such as [Opulence](https://www.opulencephp.com/docs#php-built-in-web-server-config), [Symfony](http://symfony.com/doc/current/setup/built_in_web_server.html), [Cake](https://book.cakephp.org/3.0/en/installation.html#development-server), [Laravel](https://laravel.com/docs/5.4/installation#installing-laravel), [WordPress](http://wp-cli.org/commands/server/), and many more support this.
Do you get any results with just `SELECT userID FROM users;`? If no, check for typo (`UserId`, `userId`, ...) If yes, squint harder. 
&gt; EDIT: I should of mentioned, I'm currently building this as a side by side view in the same window. As in, my view on the left, hers on the right. The button to select user is certainly an option I didn't think of. Ideally, I would love the side by side view but if that can't be accomplished, that's definitely the way I'll go. Thanks.
As an aside, I once had SQLite performance issues and was able to speed everything up, a lot, by using transactions: https://www.sqlite.org/lang_transaction.html.
If you are hosting the web app you can set the session cookies explicitly to the subdomain that is being used(it might as well be the default session cookie behavior). Then you can set 2 subdomains in your hosts file forwarding to your web server for e.g. bf.domain.local and gf.domain.local... Then you can open 1 tab with the bf.domain and the session cookie will be only applied to this domain. I am using this currently at work where logging in one subdomain must not transfer to the other. Hope that helps. Cheers
Trying to avoid the use of 2 different tabs but if all else fails, I've try this. Thanks for the help. Appreciate the advice.
You definitely should not ever be doing a query with a `where` condition on the passwords. That implies that you're storing passwords in plain text. You should be hashing your passwords. Use http://php.net/manual/en/function.password-hash.php and http://php.net/manual/en/function.password-verify.php to handle passwords. Query your database by username, return all the columns (or at least the ID, username, password) and verify the passwords then. Please don't be just another bad developer who completely ignores security. It's incredibly important. There's just so many things wrong with your question, it's clear you haven't read up on best practice guides beforehand. You're also vulnerable to SQL injection with the query you posted. Use prepared statements (or an ORM to remove the need to write your queries yourself).
Still, what you are doing is a simplified and restricted version of http://docs.php-http.org/en/latest/ at a level where you wouldn't require or need such restrictions in the first place. Furthermore, its code is now tightly coupled to a Symfony package. It would be interesting to see this bundle use HTTPlug with the Guzzle Adapter for it as default configuration. Then, it becomes something that adds value. Currently it only introduces a layer of code and a dependency on that.
There's no canonical definition. It's the term used in the guts of Hibernate that went into many ORMs such as Doctrine. Hydration itself is definitely violating OOP but, in exchange, you're not exposing properties that should not be exposed.
You are missing the point about PSR compliance. You have transformed compliant entities into non compliant entities and therefore made your code into specialistic code that is incompatible with all code that does follow compliance.
Tye repo selector screen is on the roadmap, and the sync button has a success message now.
Cool !, i already found a few updates to my repo's
Thanks for the quick reply :) I will try to give it a read. Just to be sure these are the books you suggested: - [Pattern-Oriented Software Architecture, A System of Patterns](https://www.amazon.co.uk/Pattern-Oriented-Software-Architecture-System-Patterns-x/dp/0471958697) - [Component Based Development for enterprise level applications](https://www.amazon.com/Component-Based-Development-Enterprise-Systems-Perspective/dp/0521649994) 
I'll try that!
Start with gang of four if you've never read a pattern book as that's the pattern bible. Then there is vol 1-4 of pattern architecture books. You'll know if patterns are for you if you get a eureka moment after reading 20-30 pages of Gang of Four. For CBD, I recommend it because it will solidify the different tiers of an application and make you realize that a component can actually be implemented in 4-5 different technologies and languages and os's although I don't recommend it Have fun 
I would always recommend repositories. You pass data from business layer and the repositories storing data in matter of database design. At this point you could use AR, data mapper or plain sql. 
I've never used any open source code from Gitlab before, so I'm not able to fairly contrast the two, hence my question.
&gt; You can have "unit of work" without this. In SQL we call it a "transaction" ;-) you use it every day. Incidentally, your example here is almost exactly how [Atlas ORM](https://github.com/atlasphp/Atlas.Orm) works. Cf. &lt;https://github.com/atlasphp/Atlas.Orm/blob/1.x/docs/writing.md#unit-of-work&gt;
I wouldn't go that route. Instead maybe let the client make the api call via AJAX and save the response.
if they had cloudflare they probs block tor unless you enter chapta which is another hole to patch probably somehow legitimately purchase another IP? some VPS/hosting services allow you to buy extra IP i dont know about your host or how to make curl use your alt IP
Does this account for vendor directory updates? If not, you could be in for a bad time at some point in the future. I'm assuming you were being facetious with "hundreds of thousands" of tests, especially since you mention using a fairly new application structure (pds/skeleton)?
When using this tool you should run a complete build before you merge code in (i.e. as part of your CI system or manually) to account for any side-effects or dependency changes. This tool was designed to speed up development when doing TDD with a high quantity of tests. And yes, I was being serious - this project literally had hundreds of thousands of unit tests (it's a fairly major web app for a very big company).
This actually is something that interests me too. I would like to see some good suggestions !
Came here to post something similar. Glad someone beat me to the punch.
You can get a digital ocean server for $5/month. Perhaps just spread the load out over different IPs? 
I wouldn't go the TOR route either, but I see other options here (sorted by complexity, from my point of view): - make the requests client side (as /u/Pig743 suggested) - buy other (cheap) VPS servers and make it somehow scalable (depending on the number of requests you need to handle). You don't need much performance, so you could go really low cost - buy a VPN subscription that allows you to have multiple devices connected. Then spin up VPS with multiple Docker containers, make each one connect to a different VPN IP and route the requests through that containers
&gt; It'll be a massacre. THAT'S THE SPIRIT! ;-)
Create bitcoin wallet, find a place that will sell you bitcoins, once you receive funds, make a transfer.
This is beyond helpful, your saving me months of discouragement, no one was able to give me helpful feedback quite like this, thank you :) 
This is a stab to the heart to OP I am sure but every line is a valid point and well thought out. To sum up all these points the CV tells me the candidate has a very small experience pool, plugged in a few modules, may have built a JS slider and there greatest noted achievements are that they done a couple of custom themes for WP. They lack a critical understanding of Ruby, have given me no actual examples of PHP development and seem to have found some technologies and shotgunned them across the CV. If the candidate showed me awe and wonder, with a drive to learn I'd consider a chat to see if they could become a junior dev with a push in the right direction: Not yet experienced enough to be considered. Where is your Laravel work? As a software engineer who primarily works with PHP and has trained a fair few people that is what stuck out to me, there was your chance to prove yourself and you gave me nothing to keep my interest. The same goes for nearly everything you mentioned, except from wordpress theme development. What you need is help in writing a detailed but pin pointed CV. List the work you have done for each technology here in this thread and im sure we could help a little. If you are genuinely pationate Im happy to help in the small ways I can.
I was looking for recommendations on where to purchase bitcoins, there's so many of them it is hard to trust one.
I've used btc-e.com a few years ago, all went well.
Resume should be one page, tailored to the job listing. I've thrown out resumes that exceeded one page. If it's greater than one page, it should be your CV -- and you generally don't submit those when applying. Do you have a Github portfolio? That will go much farther than Heroku apps. Everything else has already been stated.
When you write bullet points for a job, don't tell me what you did. I really don't care. What I care about is the IMPACT of what you did. "Created responsive mobile site." Great, who cares. "Created responsive mobile site increasing traffic by 40% and mobile sales revenue by 20%." YEAAAAAH BOY
not a stab, its helpful, im not that sensitive, this is helpful. I understand now, im working on making adjustments to my resume right now, i didn't know how many opportunities i was missing out on. 
Lack of js knowledge is easy to solve. Learn some Javascript. It's possible the api won't allow you to call it from a browser due to cors restrictions tho. In that case client side is not an option. Then you could do a hybrid solution. As long as their browser is open, use it. If it's not schedule it server side, and make sure your server is only doing 3 requests per second. Scale up with more servers as needed (a DO droplet costs 5 dollars per month). Or increase the delay between updates (to 20 minutes or so). 
Such a great tool. I use it for non php projects as well. 
It looks like you guys launch a new feature every other week, well done! Can't comment much on frameworks, probably the ones everyone talks about all the time. Imho, MariaDB/MySQL and memcached are a must. Elasticsearch would also be nice, I guess.
I'm using this for a new small project i started last week, it works fine. Admittedly the source code isn't as beautiful as it could have been, but it works, so i don't mind. 
Me too. I have plans to add yaml support for task, for non-php devs :_)
Thanks for the feedback, if you were going to start a new project, you would probably use a datastore, but manage the connection/clients yourself? 
It's just super expensive. I can't convince my CTO to purchase Bamboo when we have access to Jenkins Pipelines and Blue Ocean for free. Thanks for the answer, though.
Yes :)
Interesting feedback, if you don't mind, I'll pass it onto the Bamboo PMs. Could you convince your CTO to move source control into the cloud?
Please pass on my feedback. I would love to use Bamboo. We are already using Jira, Confluence and Bitbucket. Due to German data protection laws we self-host all internal software systems. It's easier for our security and legal teams, I guess.
Out of curiosity why was the dot notation removed?
Having composer baked into your default php image would be good. But personally I'd like a way to run the pipeline without making a new commit. When I was getting my head around it this drove me crazy!! Currently were not using pipelines, but I want is to I just don't have time spare ATM to figure out what's going on. If we could upload our own docker-compose files that would make life much simpler.
It sounds like a discrepancy between their rules of documentation and the implementation as to what "user" refers to... API user vs service user. I'm guessing either their API or documentation needs to be updated to reflect the other... Either way, no quick fix for you but you could try seeing if you can push them harder for a resolution. Other than that, yeah, buying extra IPs to access from or using client requests. Cloudflare constantly throws Captchas in the way when using Tor.
YAY! Umm... now I haff to rethink recipes :)
This seems very ambitious, As you would need to load and initialise the database for every hit on your site, which is very inefficient. SQLite is better optimised for static servers where the database is loaded once and kept loaded while requests are handled. I agree, SQLite is a good database driver, I use it for my bot's because they will need to load it once and will run for months on end. 
I have been using Capistrano v2.x for years now and it is time to switch to either Capistrano v3 or Deployer. Deployer seems nice since there is no Ruby dependency. Any thought from people who made the switch? Does it work as expected?
SQLite is not loading the whole database in memory every time! In fact it is using very little memory with file-based databases (with in-memory DB you have a 15% overhead compared to the size of the data though), and opening a database is extremely fast and negligible. My tests showed that opening a 100+ MB database takes the same time as opening a 50 KB database. In fact my tests showed that opening a SQLite pointer was about 4 times faster than connecting to a mysql server on localhost :)
Feels like 4.0 just released.
I don't mean to be anti-progress; but it is frustrating to see packages like this PHP 7 only. Do you (and lots of other package maintainers) really need to bother restricting it so you can add a bool return type to one single function? I realise it wouldn't be hard to copy and paste this one file package, but I've struck something similar for one of your other packages which was basically a one class adaptor. With that said, thanks for the great packages - I owe you a few postcards! =)
Tried it on a Google cloud project and it was really slow. Test it heavily. There seems to be some flakey combos of libraries and or PHP versions or something. I could not find a combo that performed acceptably. The data on it says it's very fast when it works so well worth trying out.
I understand English may not be your first language, but; &gt; Compatible with PHP 5.0 or highter. It should read "[...] PHP 5.0 or **higher**" ---- Also, in your README file, section [example usage](https://github.com/Rawnly/PHPTokenLogin#example-usage) there is a syntax error in the `header()` statement. You're also missing the good-practice `die;` after the `header('Location...`. ---- As this is a library, is there any reason you're not promoting the use of [composer](https://getcomposer.org/) to handle the dependency? ---- There is no PHPDOC on class functions to explain the function, parameters, and returns. ---- You could split out the database queries in `sendToken()` to a separate method as `sendToken()` should be only in charge of sending the token to the user as its name suggests. Please don't `die("Mail not sent. $Mail-&gt;ErrorInfo");` - use the `Exception` API! Every other error does... ---- It doesn't seem you're using prepared statements [at line 171](https://github.com/Rawnly/PHPTokenLogin/blob/master/class.phptokenlogin.php#L171) - though the input is being system-manipulated so this could be a anal point, but not dismissable as it's 2017. ---- You seem to have left in your MySQL details [at line 214](https://github.com/Rawnly/PHPTokenLogin/blob/master/class.phptokenlogin.php#L214)... and why isn't it using `$db = $this-&gt;Database-&gt;connect();`? 
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [Rawnly/PHPTokenLogin/.../**class.phptokenlogin.php#L171** (master → e8e27ba)](https://github.com/Rawnly/PHPTokenLogin/blob/e8e27ba63e0513412284fc4335bddddba3da17e0/class.phptokenlogin.php#L171) * [Rawnly/PHPTokenLogin/.../**class.phptokenlogin.php#L214** (master → e8e27ba)](https://github.com/Rawnly/PHPTokenLogin/blob/e8e27ba63e0513412284fc4335bddddba3da17e0/class.phptokenlogin.php#L214) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhkt6mo.)^.
First, thank you so much for pipelines. We're really loving it. Super simple to get going with the yml configuration, and works much more fluidly than the Gitlab CI we use at work. We primarily use the Laravel framework, and being able to test against MySQL, Postgres and Redis would be really nice. We haven't attempted it yet, but from what I've seen, we can just define an extra service in bitbucket-pipelines.yml to run a MySQL/Postgres/Redis container side-by-side?
Better =)
What is it?
Thank you!
Thanks, I'm new in PHP and this is my first project, I understand that's not ready to be released, but I just posted it to get an opinion. So thanks again i'll follow your suggestions.
Using prepared statements are far from a must, while protecting your application against SQL-injections certainly is, to which it is an option. But can we try not to forget that prepared statements being resilient to SQL-injections is a side effect, not the purpose?
&gt; what frameworks would you use Laravel or Symfony depending on the project &gt; what datastores would you need to test against MariaDB and Reddis
Laravel, Silex, Symfony MariaDB, Postgres
Although technically you are right, in practice your ideas are a decade outdated and proven to be wrong. Try this one: [The Hitchhiker's Guide to SQL Injection prevention. Why manual formatting is bad?](https://phpdelusions.net/sql_injection#manual) 
Looks like there is a thing that could be called "a critique driven development". You're posting a "cool link" to tease devs and to get the feedback from them; and then proceed to fix your code. There was another similar case a week ago, with a mysql connection tutorial.
Configuration is more straightforward. I definitely like Deployer better. 
How does it compare against Zend\Hydrator or Ocramius\GeneratedHydrator?
exactly
Its helpful.Thanks
... and preparing your statements is preferred. which renders your performance rather pointless.
No
No you dont specifically need it. 
i have php storm, i think i should include that.
So for full disclosure we run our own Gitlab server and thus also run our own Gitlab task runners... so this probably isn't reflective of their hosted version. But I have faced a lot of issues that go away once you restart the runners, usually related to caching. They also take longer to execute than BB pipelines that are doing the same thing, in my experience. Also, BB pipelines seem to be just as integrated as GL CI. I just prefer it, but maybe it's personal preference.
&gt; ridiculous microservices culture As with all these things though, there are some nuggets of good ideas and, in the right context, it's a good solution. 
+1 to this series, goes through a nice TDD approach and uses both unit and feature tests. As someone new to writing PHP tests, it's been an invaluable reference. 
Hows that CV coming?
Frameworks: Symfony, Silex. Data stores: MariaDB, ElasticSearch!!, maybe Redis.
Respect to Digital Ocean team!
Ideally you would throw an exception..catch it and react on the exception type..at least for a user access..but otherwise nothing wrong with it, you just need to consider what the condition is about.. Like the user is accessing something he shouldn't be able..this breaks the standard flow and therefore it should be an exception
You should communicate somehow if the action... happened. In the most primitive way you can return a boolean (true = success, false = failure). But a better approach would be throwing an exception, returning an error object, or taking an "out" $errors parameter by reference, that you fill with errors.
Thank you very much! I'll provide to implement all this things. Thnaks again for the help!
As a fellow lazy typist, I did [something similar](https://GitHub.com/mahngiel/composer-package-completion). Will give your script a try and see how they compare. I did have complaints from zsh users (yes, _bash_ completion), but never investigated.
You want to rewrite your git history as well. https://github.com/Rawnly/PHPTokenLogin/commit/daef363e1e3a1c32d729fdeff74f3dff7934cf76#diff-ef8ce900e50143022caed7aee9bc5142L214
&gt; [...] The class that handles the token should not be the class that handles mailing It's not. The class that handles the mailing process is phpmailer. 
im going to share in one sec hang tight :)
I would rather have a fluent system for these things. Something like this for example: $name = String::make('Jeff Bridges'); $name-&gt;reverse()-&gt;toUpperCase(); // Resulting in 'SEGDIRB FFEJ' This way we can chain string manipulation commands.
You may like http://anahkiasen.github.io/underscore-php/
how does this look https://drive.google.com/file/d/0B1pSkcjKOCQ8LXNsUW5NbUdMWEE/view?usp=sharing
Before implementing too much, I'd benchmark what kind of overhead may be added for code in tight inner loops.
Sure, but does have ability to be extended and actually could be a good starting point for you as it seems to be abandoned project. I swear i've come across something similar in the past but can't find it atm :/
So I tested it out and it works freaking great. I used magic __call method for the Str object to check if the equivalent Str::$funcName static method exists and returns a string value. It's then called to modify the Str object's internal string reference and the Str object is returned. If you call a method that returns something other than a string, it returns that value not wrapped in an Str object (obviously) and can't be chained off of. Example: $string = new Str('John Smith'); $reverseHash= $string-&gt;getReverse()-&gt;getHash(); // Works! $hashedArray = $string-&gt;toArray()-&gt;getHash(); // Errors, because toArray returns an array and thus get hash can't be called (unless at some point I implement a hashing method into the Arr object, but that's beyond the scope of this demonstration.) The idea is for all methods that change the type of an object to an incompatible one will have the prefix 'to', most methods that return a modified object of the same type use the prefix 'get', and I've yet to come up with a prefix for methods that modify existing object reference.
What's your preference for functions vs static methods? I know it lets you nail down functions needed via use calls, but any other reasons?
You can convert to an object that implements `\ArrayAccess` and use `spl_object_hash($this);` as the hash?
Thanks for the kind words. That's exactly correct, you define the datatores you need in your Bitbucket-pipelines.yml and we make sure they're present before we run your pipeline step. Can I ask why you're not using services in your pipelines already? You seem to be pretty well versed in what they do/how to use them. 
Thanks for the feedback, what kind of tasks would you do in your pipeline that you typically want to detach from code commits? We do have custom pipelines, https://confluence.atlassian.com/bitbucket/run-pipelines-manually-861242583.html which might be of interest for you :) I forgot to mention that we've talked about supporting docker compose, as our yaml is pretty similar. Last discussion I think we got to "compose does a few too many things we can't easily support". There's an issue on Bitbucket you could follow/vote on if you're interested :)
anything else to make it look good, being that i have little physical job experience ? should i describe personal projects of my own ? Thanks for taking the time to help me get this right, it means alot :) 
Also, possibly of interest: https://github.com/nikic/scalar_objects
If you have worthwhile projects of your own then go for it. It shows passion, or at the very minimum and willingness to do the work. 
Ya, but the error on the $hashArray is more that there is no Arr::getHash() method defined yet, so when toArray returns the Arr object it errors. It was just an example. When I get around to defining the Arr methods I'll probably use spl_object_hash to implement the Arr::hash() method.
That looks very cool, but they use a PHP function register_primitive_type_handler which is from an extension you have to compile php with.
That is not true. There a big work refactoring all parts (with BC) and plenty of new features, like ssh command and on func.
You could probably give this a shot: https://github.com/mattes/rotating-proxy It is kind of similar to what you want - sets up HAproxy to "load balance" to *n* other Tor instances. For example, the command `docker run -d -p 5566:5566 -p 4444:4444 --env tors=25 mattes/rotating-proxy` would spawn 25 internal Tor instances available at a single address, `127.0.0.1:5566`.
We're currently using PhalconPHP (v2 and v3/php5 and php7, respectively), I'm not entirely sure if it's even remotely supported by Pipelines (we haven't researched it a lot I have to admit, yet). If it's not, I'd love support for it as well :)
It really **really** depends. You sometimes need to throw exceptions, other times an early return is perfect. But be mindful with getter functions, `return;` is basically `return null;`, make sure callers are aware they can get back a `null`.
Can it run/test inside a docker container? If so, it can run on pipelines. 
I'd prefer camel-case; as, it leaves underscored (or snake_case) for table names. And with javascript there's a lot of camel-case. With the two working closely, more camel-case in php makes sense. That's really nice work by the way! Changing things like str_replace to Str::replace just makes good, clean, semantic sense. 
Much love for ideals like this, millions of seconds saved increase the time I can spend on reddit
Much love for number 3 and 1
Blinkered much?
Sad that it does not support mercurial.
Yes change it. No it doesn't take long. Do it today.
Didn't heard of ansible before. So I went to their website. Oh cool a "quick start video"! "Enter your email address to view this video." Oh fuck off, no thank you. This tells me all I need to know about the kind of shit I can expect from them. I can fucking view their promotional video before agreeing to receive more promotional shit from them...
IMO, even if you're not using a fully featured MVC framework, it's generally cleaner to keep all your database logic in 1 file. You could add file called 'db.php' which holds this code (and all your other database statements): require "../config.php"; require "../common.php"; function add_user($new_user){ try { $connection = new PDO($dsn, $username, $password, $options); $sql = sprintf( "INSERT INTO %s (%s) values (%s)", "users", implode(", ", array_keys($new_user)), ":" . implode(", :", array_keys($new_user)) ); $statement = $connection-&gt;prepare($sql); $statement-&gt;execute($new_user); } catch(PDOException $error) { echo $sql . "&lt;br&gt;" . $error-&gt;getMessage(); } } and then in your create.php, you could write require "../db.php"; if (isset($_POST['submit'])) { $new_user = array( "firstname" =&gt; $_POST['firstname'], "lastname" =&gt; $_POST['lastname'], "email" =&gt; $_POST['email'], "age" =&gt; $_POST['age'], "location" =&gt; $_POST['location'] ); add_user($new_user); }
What's the benefit of using this over, say, writing a basic shell script to rsync your new codebase over to your old one?
I have followed one article about bitbucket pipelines here https://www.cloudways.com/blog/using-bitbucket-pipelines-php/ but I would also try it with any lightweight framework like Slim and Silex
What if we would tag something 5.6 and decide to add a new feature next week or month. We wouldn't be allowed to use 7 features since that's we already published it for 5.6. Sure, we could up it to 7 and composer would take care of the requirements, but if a bug pops up a month later we suddenly have to backport our bugfixes to an older branch. Overhead al over the place. A library is rarely *finished* when it's released. I'll agree with you that there isn't much in here now that warrants PHP 7 and up, but it's simply not worth support versions that are on their way out and have it bite us in a few months (especially when we, the authors, don't need it at all)
The [sub]title is rather confusing. The connection itself is covered in but one paragraph. The other content contains a lot of mistakes and design flaws, which is expected, as the author does not have any practical experience, nor tested their code under any real life conditions - the code written here is their very first experience. Practically, it's very good for a personal exercise, but by no means should be recommended as a tutorial for other novices. I'd say it was an interesting experiment. I myself was eager to see it is possible for a smart but completely inexperienced beginner to create a usable tutorial. Well, the miracle didn't happen. I think that it's *the experience* which is the key. A layman, even asking eagerly for a feedback, just *cannot sort it out properly*. And so they could dismiss a good suggestion and succumb to a bad one. Or simply misinterpret a suggestion. Or there are questions that they just don't know how to ask. Take, for example, the other tutorial from the same author, [How to Use JSON Data with PHP or JavaScript](https://www.taniarascia.com/how-to-use-json-data-with-php-or-javascript/), which basically retells you the corresponding manual chapters and nothing else. For a person without any experience it's enough. but for someone who worked with JSON in practice it is evident that *handling JSON errors* is very important a topic that should be covered in such a tutorial. The same goes for the current tutorial. The author is just retelling what they've been told, but do not really understand many parts. No offense meant, but that's an example of what we are calling "a cargo cult programming": some code is written because the author has been told to do so, but without a real understanding nor without any real world experience to prove the decisions made. 
Sql injection vulnerability. Edit: Form post forgery vulnerability.
I was using the OP's code for reference. I would write it like this: function add_user($client_id, $email, $password, $status, $hash){ $db = new PDO("sqlite:".__DIR__ ."/../data/db.sqlite"); $stmt = $db-&gt;prepare("INSERT INTO users VALUES (null, :client_id, :password, :email, :status, :hash)"); $stmt-&gt;bindParam(':client_id', $client_id); $stmt-&gt;bindParam(':email', $email); $stmt-&gt;bindParam(':password', $password); $stmt-&gt;bindParam(':status', $status); $stmt-&gt;bindParam(':hash', $hash); $stmt-&gt;execute(); return $db-&gt;lastInsertId(); //user id just created $db = null; } Which is secure.
I think you're seriously over-estimating the sort of "packages" that my comment was aimed towards! =)
I like ansible too, great tool. I took a few ideas from it (for Deployer v5) by the way. But i like simplicity of Deployer tool. Some times i can find myself in deep debugging of ansible and i switch to deployer. Also i have plans for adding provision support for future releases of Deployer.
&gt; The content contains a lot of mistakes and design flaws, which is expected, as the author does not have any practical experience This was my thought as well, the problem with a lot of these 'tutorial' sites is that the authors have very little if any commercial experience in a high volume setting. The problem is this article is aimed at beginners, beginners will read this stuff and think its *normal/correct way to do it* then shit code is copy and pasted everywhere, vulnerabilities and all. If you are a beginner and wondering where to get started I would recommend reading the documentation and this write up (linked below). Both have been well reviewed over a long period of time. http://php.net/manual/en/book.pdo.php https://phpdelusions.net/pdo 
&gt; it's generally cleaner to keep all your database logic in 1 file Lol! No. It certainly isn't. Database logic as you are calling it should be separated out into individual classes each related to one specific part of your application logic domain. 
I think this comment would be better if you could also spell out the mistakes and design flaws. That way the author and others stumbling on this post can learn from it.
Hmm. So what's in $hash? Is that the random salt from the password hash function? If so, I'd recommend naming them something like $password_hash and $password_salt. Either way, I'm not trying to be a dick, just trying to help.
You're 100% correct, but the OP is not using a MVC or OOP structure for this tutorial. In any modern PHP project, each part of the application should have it's own model that holds the database logic, but I was trying to simplify it to 1 pseudo-model and 1 controller to fit this specific example.
After working a lot with Slim and Silex in the past, I was left with some annoyances, mainly the way they both handled middlewares. I tried to solve those annoyances with Starch. It's no where near finished (needs to do caching etc), but I'd love to hear the thoughts of others.
Aha! That is one of them, thanks! /me add's that to google keep
mysqli doesn't have the nice OO interface that PDO has, but keep in mind they have separate objectives: PDO is about providing a clean and consistent interface to several different SQL backends, whereas mysqli is about providing as much of the functionality available from MySQL as possible. This means, for example, that the SQL executed by PDO is sometimes not the same as the SQL you thought you wrote (for example MySQL doesn't actually support named parameters in prepared statements). The majority of the time PDO will be a decent solution with a cleaner interface (and thus implementation), but you should weigh up the objectives of both libraries before assuming that mysqli is bad and wasting time rewriting. Julien Pauli has [an in depth blog post](http://jpauli.github.io/2014/07/21/php-and-mysql-communication-mysqlnd.html) about connecting to MySQL from PDO and mysqli and some of the key differences. I just wanted to throw this out there because I often see people telling beginners not to use mysqli without a clear explanation of what its purpose is and when it might be useful.
I also use ansible for provisioning servers and services, but for deployment I need a more suitable tool. Did you try Deployer?
Please don't, keep it simple :)
I thought not writting tutorial when you are a beginer was a given. Seems not. Even more when good ressources already exists, it's a useless and harmfull. And database interaction has been covered. OP, be sure to understand (like, really understand) most of the problem before putting a tutorial about it on the web. Otherwise you are doing more harm than good. You obviously can't talk about everything when writting a tutorial, but you have to know what and why you are avoiding some subject. You are either naive (to believe you can create a tutorial as a begineer, which is fine in my book, at least how I mean it) or have to much ego/self-esteem.
This is what I was hoping for. 
Come on, Mysqli has nothing to do with SQL, and, therefore, with non-SQL standard features of MySQL as well. Mysqli supports some mysql-specific features, of which only one I can consider of any importance for the average PHP user - mysqli_info() function that can give you the number of rows both found and updated. All other features such as async queries are too specific to be mentioned in a basic tutorial - whoever is supposed to need them, is not a subject for such a tutorial. 
There is a problem which I tried to explain in the above comment: even with explanations given, the result is not guaranteed. For example, some flaws has been mentioned in [this review](https://codereview.stackexchange.com/a/163026/101565). Alas, the OP paid no attention to them. After all, we cannot write the whole tutorial for them, telling the author which questions to ask and then answering them as well. To me, there is an ethical problem too. When the author has some clue - did, say 80% of the job and then asks for the review - it's fair. When the author literally knows nothing and all their job is to milk other people for the information - it's another deal, IMO.
Fully agree, on all counts. It's just hard for a noob to get an objective view of why mysqli even exists. Googling PDO vs mysqli for example yields nothing.
&gt; I thought not writting tutorial when you are a beginer was a given. Seems not. That's what I tried to explain to them in the other topic, but failed completely. It seems they just don't care for the rule if it stands on their way. They have a goal, and they are going to achieve it, no matter what someone says. So you can tell it's "to much ego/self-esteem" as it is. Given such a steamroller attitude, there is no way to make them consider any argument they don't like. So they just confirmed that. 
no worries mate, when i get bored of answering you i'll just delete my reddit account ;) (joke) yeah, its quite common to have one group of files (aka a git repository) per subdomain, in fact, i cant really think of a better way to do it to be honest. that style is what i use for my freelance stuff. so ive got a client with a marketing website and a seperate blog, their blog is hosted under blog.foobar.com and their marketing website is www.foobar.com. they are two seperate groups of files so they are two git repos (short for repositories). my linux webserver directory looks like this: /var /www /vhosts /www.foobar.com /blog.foobar.com /www.example.com /www.1337.com /lulz.1337.com and each of the sites is its own git repository
**Update**: Ah, you're sly. You called the key from the routes array in the code that dispatches the routes, interesting. Can you elaborate on this [line](https://github.com/starchphp/starch/blob/37ca3da7a78c8a7e59c736ab6487bbeb7ad2a1eb/src/Router/Router.php#L49) ` $r-&gt;addRoute($route-&gt;getMethods(), $route-&gt;getPath(), $index);` On paper, it should be adding the methods, path and handler, but it's adding the route index? Which is an integer if I'm not mistaken? public function map(array $methods, string $path, $handler) : Route { return $this-&gt;routes[] = new Route($methods, $path, $handler); } Shouldn't you be calling `$route-&gt;getHandler()`, or am I missing some voodoo code while reading this source? As I'm working on something myself and seeing how other people are incorporating FastRoute.
It might include data provider rows. Phpunit reports each different data row as a test... So 1 test method that uses a data provider with 20 scenarios will report as 20 tests.
I actually stole this somewhat from Slim :p I wanted to tie my original Route object to my request, so when fast-route does it's thing, it's simply returning the index of the `routes` array. I get the route back from the array, add the arguments and set it as a request attribute. The request gets returned and then sent through the middleware stack. The last middleware of the stack is my own RouterMiddleware, which gets the route from the request, then gets the route handler through there and calls it using the invoker (which in this case is just the php-di container).
Ah, neat! I wasn't aware of those! The example in the docs, like all examples, is a bit unlike the real world would actually work. Could you show me how this actually comes in handy?
Looks like a great resource! I'll peruse through it and see what I can improve for my own learning purposes. Unfortunately I can't help out anyone else's site anymore than you can, but I did click on it from both mobile and desktop. And now it's at the top of this thread, so it'll get even more clicks. We did it, reddit!
From this experience, it only took about an hour for me to simply rewrite everything I had from mysqli to PDO. It doesn't change any other flaws that might have been present, but there's no more effort involved for simply connecting.
&gt; Now, I really can't see a case why someone would choose HHVM any more. If your code sits in the really rare combination that a) it runs fine under HHVM and b) it can be run in repo authoritative mode, then HHVM can give you much better performance than PHP 7.1. However, those conditions are restrictive enough that not many people meet item 2.
It's possible to have race conditions in APC. If you hit a cached item at the same time/very close to the set TTL it can provoke a chain reaction between apc_store/fetch. This eats up all your memory and can cause timeouts. See this post here for a detailed example on how that works: http://notmysock.org/blog/php/user-cache-timebomb.html
Or just use DI. Singletons/Facades/whatever the name of the month is; give way too much freedom to new and lazy developers who will just call services from all the wrong places and create hidden dependencies in other classes etc.
that makes zero sense, composer does nothing at runtime except for autoloading.
you chose your class examples wisely, `Str` and `Arr` are not reserved keywords. What are you going to do with `Int`, `Bool` and `Float`?
Ups! I did't know that PSR-15 has two approaches to middleware that use HTTP Messages. Double Pass: fn(request, response, next): response Single Pass (Lambda): fn(request, next): response And the Single Pass approach has about 3 "sub approaches". function (RequestInterface $request, array $options): ResponseInterface function handle(Request $request, $type, $catch): Response function handle(Request $request, callable $next): Response Now I'm a little bit confused and disappointed. Is this still a "standard" or just a mix of "approaches"? Source: https://github.com/php-fig/fig-standards/blob/master/proposed/http-middleware/middleware-meta.md#4-approaches
I tried to turn your GitHub links into [permanent links](https://help.github.com/articles/getting-permanent-links-to-files/) ([press **"y"**](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) to do this yourself): * [php-fig/fig-standards/.../**middleware-meta.md#4-approaches** (master → 0745733)](https://github.com/php-fig/fig-standards/blob/07457338de38459a4784fc627bdb780a3dacfb22/proposed/http-middleware/middleware-meta.md#4-approaches) ---- ^(Shoot me a PM if you think I'm doing something wrong.)^( To delete this, click) [^here](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dhml9sc.)^.
This example in the docs shows how it's reported properly: https://phpunit.de/manual/current/en/phpunit-book.html#writing-tests-for-phpunit.data-providers "testAdd" is one test, and the data provider has 4 rows. The run says "Tests: 4" and 4 assertions. Edit: Oh, how it comes in handy? Data providers themselves or the fact that it reports each row as a test?
Yea, take a look at OP's submission history. They just mass submit links to slightly relevant subreddits.
Without any aggressivity or anything like that, I'd like to understand : &gt; I've written dozens of articles and I'm acutely aware of the type of negative reception I can potentially get on this sub, so I can't claim to be naive. Ignorant of some of the finer details, for sure! There is definitly a lot of negativity/aggressivity on this sub/on the internet. But except this aggressivity, there is one main theme. Why do you write a tutorial when you (almost openly) admitted you are not qualified enough... (or did I missread it) It's kind of intelectual honesty to me not to write about something (implicitly claiming I know what I do, like a tutorial; wouldn't have any problem if you wrote an opinion piece after 2months of use) until I am confident enough I don't miss anything big. I use some frameworks/libraries every day since several years, source dived a lot (I love it), almost never second guess what I do anymore on those, and I still am a bit conflicted about writting something on it. Even more when there is some quality content already existing. I might in the future do a laravel (validation or eloquent deep review with internal walkthrough) piece. But it would take a few weeks of writting, and maybe one month of proof reading. I don't get the connection between `I am a newbie/junior dev(/medium dev?)` and `I have the qualification to write a decent tutorial on some subject`. And reformulation of official doc is not enough, and even harmfull (docs are updated) to me. I might have to much expectations about the writter, but I feel like you don't have enough at all.
Data providers are very helpful to prevent duplicating similar tests over and over again. One prime example is when you have unit tests for string manipulation functions. For example you might have a utility class that deals with international currency formatting, and let's say it also returns 0.00 when the input amount is less than zero. Keeping with the principle that you should keep the number of assertions in one unit test low (one is best, but a few as OK too) you don't want to have to create a new test method for each unique case, and you also want it to be easy to test a lot of different scenarios easily. The dataProvider lets you simply provide the input variables and your expected output in the same "group" of data which is then passed to the unit test method, and usually the test becomes one line: $this-&gt;assertSame($expected, Currency::formatThing($input)); 
&gt; Unfortunately I can't help out anyone else's site anymore than you can, but I did click on it from both mobile and desktop. And now it's at the top of this thread, so it'll get even more clicks. We did it, reddit! Is that really how it works, I wonder...
You think we'll ever see bodiless classes in php? Eg.: `class SomeRandomExceptionName extends \Exception;` `interface SomeAliasInterface extends SomeInterface;`
Dumb question, but am I reading correctly that the suggestion is to have a class per action with a single invoke or execute method instead of one class containing many actions? Aside from the dependency injections benefits, are there any other reasons to approach a MVC web application from this angle?
&gt; or taking an "out" $errors parameter by reference, that you fill with errors. How frequently do you see this? I was working on an internal validation class and experimented with a `&amp;$errors` parameter for validation errors, but I eventually ditched it in lieu of a `ValidationResult` class with `hasErrors()` and `getErrors()` methods. I'm still not 100% sure if I made the right choice on that, but I *really* wanted to avoid using exceptions as DTOs because I'm validating large quantities of imported data and didn't want additional overhead.
Float can just be Flt, Bool can be Boo (stupid, but sticks with convention fairly well), Int is the only one that really gives problems. Any suggestions?
Composer itself does not add much overhead as it just handles autoloading, but in my experience if you're using composer packages vs building your own stuff you're not going for the tightest loops and most optimized code.
ok i see thank you syanticraven :)
you surely could if you choose packages that cared about this. A package like this would have to be very much optimized imo.
&gt; is it really so bad to just have a few more service instances around than you might strictly need in every method? Depends on what those services are. Some may not matter but some may be quite expensive to instantiate if you're going to use them in a fraction of the request that your controller actually serves. In some cases proxies make this a moot point. This would let you inject a proxy in place of the expensive service so it is only truly instantiated once you start working with the service.
Very good point!
The way I was playing with it atm you could do: Str::extend('reverse', function($string) { return strev($string); }); and it will create a static Str method with that name, all static Str methods are also invokable via fluent style and edit the object your calling on (verse calling static and getting a string back) thanks to the magic __call() method on the Str object instances. So you could do: $name = new Str('Joe Bob'); $name-&gt;reverse(); Str::extend('toLowercase', function($string) { strtolower($string); }); $name-&gt;toLowercase(); echo $name; // Outputs bob eoj 
I created an issue, very interesting as I was just abuot to do the exact same thing as you. Only issue is what I described in my new issue. ~~Also make sure you contact the guys over at php.com to use 'php' in your name. I think you need written permission or something.~~ ignore the last bit, that's your github name, not the repo name.
I'd argue this is a more intuitive structure than the Rails-inspired fat controller many of us are familiar with. Just because it's not what everyone does by default does not make it worse. The resource use improvement is nice but largely secondary to the improved testability and maintainability of this approach. 
Oh, I agree that there is further opportunity for refactoring. In this case, I might split it into two actions: one that is routed to on GET and another that is routed to on anything else. But one step at a time, Tanks, one step at a time. :-)
I'm obviously trying to use words/components that will be intuitive to everyone reading this, I'm not spelling out a fully-fledged architecture in a comment. Replace "$db" with "$domainService" and the problem stays exactly the same. Furthermore, caching may be a part of the domain, but it may be a part of the application, as well. Or both. And to extend this to the domain, it'll have the same problem: what happens if a domain command/query only needs the $db (or whatever other dependency) "sometimes"?
I don't know if that works for everything, but the Symfony Cache Component has this "PhpFilesAdapter" that saves data as a PHP file that it then calls opcache_compile_file on. Doesn't that basically allow you to do the same thing that APCu does?
That's certainly easiest, but there's a reason many people shy away from that in favor of DI despite the initial setup and cognitive overhead (I could also be misinterpreting what you're describing).
If you're building small projects, don't care about maintenance or testing, or have little need for flexibility, sure. But the idea of SOLID design has been around for 15+ years (well, probably longer, but that's when it got the name), and the D in SOLID stands for dependency inversion. It's possible to over-engineer anything. That doesn't invalidate the engineering principles that were used or make them a "fad".
&gt; You create a bunch of useless files. Maybe at first it feels that way, but (and not to tease!) after a while you won't create controllers at all; you'll move toward having only one Action handler for the entire user interface. Everything ends up going to Responders and Domain-level code, along with the occasional input-marshaller for complex input structures. Single-action controllers are just one step along that path. But that's a separate topic. :-)
dependency inversion is not the same thing as dependency injection. this is degenerating into a bikeshed argument and you're now firing broadsides without justifying your statements. surely you recognize that there are plenty of ways to develop maintainable and testable code and there is very little about dependency injection that necessarily means code that uses it is testable or that code that doesn't use it isn't testable. I was hoping for a better conversation. I think we're done here. 
&gt; I was hoping for a better conversation. I think we're done here. Likewise; agreed. I hope that you don't think I'm attacking you or your code because that was not my intention - there's a lot of context-specific requirements that need to be considered for any technical decision and that's nearly impossible to get across in a reddit comment.
Bruh, sorry this happened but you probably should have left whenever people started bitching about wyte mails. 
Any particular reason you want to implement this in PHP?
PrestaShop is a legacy mess piece of crap :) WooCommerce works only for very small installs (and it is WordPress) - performance is a big issue. OpenCart - heard horror stories only. Magento - a lot of legacy and no will to move on. Basically, from the list above - none are excellent systems :) I'd recommend Sylius, but it's not yet 1.0 (although it's close) and it's targeted at custom development - Symfony skills are a requirement and expect to develop some functionality that is standard for other systems yourself - not hard for a Symfony dev, but system is highly modular and there is a definite learning curve there.
This. Well put.
So no static analysis... 
&gt; True, but not everyone uses opcache. I think that peoples who do not uses opcache will not use some third-party overlay over standard library.
&gt; I came up with the idea This already implemented in underscore.php and this prevents static analysis. &gt; You can also just overwrite methods at any time by calling This is calling "monkey-patching" and you will have a lot of problems with that if your solution will spread. Imagine that module A overrides behaviour of function `foo` and module B using it. You are creating hidden coupling of your code and this could lead to very huge problems.
All the best, dont be put down by any rejections. Just take any feedback you can get an evaluate from there. Any projects you have done yourself that you can show off is worth putting them down, or just linking your github if its clean and got what you want to show off
Hard to recommend either at this point for the majority of cases when Shopify is right there. Your client only cares about the end result, not how you did it.
What is the solution if you don't mind telling? I haven't seen you or author talking about this anywhere so would like to know if not too much to ask? Link to comment/article would be enough. 
&gt; This already implemented in underscore.php and this prevents static analysis. I did not mean I literally invented the idea... &gt; This is calling "monkey-patching" and you will have a lot of problems Fair enough, I see the issue with that.
The agency I work at does a lot of Magento 2 development for fairly large ecommerce sites. I personally don't build the Magento sites but I've reviewed the code and built some modules to integrate with the platform and it's a fairly nice platform. Having dabbled in Woo, Shopify, and Magento, I can say Magento is definitely the most robust and capable platform out there, albeit a bit bloated. (Disclaimer: Advice from a non-Magento developer).
Hi, I have worked with Magento for 4 years, Magento 2 only since recently. Learning curve is big but well worth it. Sometimes I have had to do something in WordPress and the code looks like shit in comparison :) Magento is a well designed OOP system which is full of design patterns and nice APIs. It's not perfect but I think is the best choice. 
So I broke it all down to functions like you suggested and just load them all via composers file autoload, the only issue I'm really having anymore are cosmetic ones (Can't use Array and a few other keywords in namespaces so I just did Cfp\XString, Cfp\XArray, Cfp\XInteger, etc) and secondly in 5.6+ apparently you have to use: use function to import functions which looks a bit dirty, but meh. I also added an XClass type for each namespace (XString, XInteger, etc) which using __call checks if functions exist in their namespace and does all the neat chaining of calls. The new system looks sorta like this: use Cfp\XString\XString; use function Cfp\XString\reverse as rev; $name = 'John Doe'; $name = rev($name); $name = new XString($name); $name-&gt;lowercase(); // This type of call always uses the non aliased name of the function. echo $name = 'eod nhoj'; Opinions?
We're in a similar situation, as a financial firm we just can't have source code or VCS in the cloud. Data protection laws and compliance here are quite strict 
That's a very nice factoring, and indeed a great idea to decorate the cache, rather than make it an explicit concern in repository users. But it doesn't solve the particular issue of a dependency being instantiated when not used, because let's follow the trail: - CachedArticleRepositoryDecorator is always injected in MyAction. - ArticleRepository is always injected in CachedArticleRepositoryDecorator. - If we keep following the trail, most likely DatabaseConnection is always injected in ArticleRepository. So this means the database is always instantiated, even if you hit the cache. Still, I like the code, thanks for providing the example.
The solution is to make dependency creation lazy, which I typically do by having a group of related controllers define an interface that contains all dependencies they collectively use (no other dependencies needed elsewhere in the app), like this: interface ControllerContext { function getFooService(): FooService; function getBarService(): BarService; function getTwig(): Twig; } class SomeController { function __construct(ControllerContext $ctx) { .. } } Now at the controller instantiation place, you can implement this interface by injecting the container into the interface implementation and creating and returning the necessary dependencies *on-demand* avoiding wasteful instantiation of complex dependencies. And at the controller you store the context directly, and you invoke it only when you need a specific dependency. This is not the same as injecting the container *directly*, and it's not a "Service Locator" for several reasons: - It's perfectly type safe, where most DI containers have "stringly typed" fetch methods like `$container-&gt;get('twig')`. - The controllers will only have access to *their own dependencies*, and not *all dependencies of the app*, which is very important for maintaining a clean application architecture. - The controllers never see the container, so they are not dependent on any container, they only depend on the *interface that the controllers define* to describe their own dependencies (it's much like constructor declaration, but allows lazy instantiation). This pattern is known as "Encapsulated Context", and maybe DI containers may support automatic implementation of contexts one day, but so far I've not seen one. But it's easy to implement manually, say via an anonymous class.
&gt; ... To accept that you're working with PHP, and prioritize clear business logic and understandable code over trivial performance changes? :p So you feel that coupling yourself to a highly specific, and highly *implicit* container behavior, namely the generation and injection of proxies, is "clear business logic" and "understandable code"? Congratulations... now you have code which doesn't do what it appears to be doing (i.e. it appears to eagerly inject dependencies, but it's invisibly providing proxies, and instantiating dependencies lazily). Let's imagine a scenario where in a service object you use a DB connection and you issue a query: $whatever = $this-&gt;db-&gt;query('SELECT * FROM whatever WHERE whatever')-&gt;fetch(); Now imagine *this particular code* throws an Exception with this message: SQLException: Access denied for user 'USER'@'HOSTNAME' That's rather puzzling, isn't it? There's no way this error should be happening at *this* place in the code. But it did, because "clear business logic" and "understandable code". ^/s No, when you create dependencies lazily, you *have to make it explicit, so the caller knows what the hell is going on*. Otherwise, you have magical code working in magical, unclear ways. &gt; IMO using proxies with DI is a great way to achieve that goal. Yes, it'll take a few more cycles to spin up infrequently-needed collaborating objects, but in exchange you've got clear and understandable code that runs decently well. Aside from the example above which debunks the "clear understandable code" claim, proxies don't work with final classes, classes with final methods, classes with no separate interface, and may exhibit incorrect behavior in edge cases, compared to using the object directly. Say objects with public properties, and objects that take and return data by reference are clear candidates for the Proxy misbehaving (it's been some time since I explored the implementation of LazyProxy, but most PHP proxies explode or misbehave in such scenarios). And there are other use cases that Proxies break. Let's say you ask for a dependency by a commonly available interface, and you can use that, but you also can check for extra optional features in your code, when they are available: function __construct(SportsCar $car) { if ($car instanceof CarWithNitro) { $car-&gt;activateNitro(); } $car-&gt;drive(); } I'm being cheeky with the example code, but checking an object for additional optional interfaces is an actual use case for actual real-world code, and... guess what, cars with nitro will never have their nitro activated if you get the car by a proxy, because your code no longer has access to other interfaces the object supports. Oops. But enjoy using proxies... I'll just opt for simpler and more explicit solutions. 
I respectfully disagree with the underlying assumption of this article. It seems to be based on the idea that controllers, or any class, that does more than one thing is necessarily a bad thing, and that breaking everything up into separate classes is a good thing. It's ok for a controller to perform multiple actions where some methods have dependencies that other methods don't. We can all agree that there is a point where too many unrelated tasks are being handled by one class. But too often I see developers who go too far to the other extreme and take a simple task that could be clearly and eloquently implemented in 2-3 classes with maybe half a dozen methods each, and instead end up with 15 classes where each one barely has one or two methods. We should recognize that there is a cost to adding complexity each time you decide to divide a task up into multiple classes or methods. Sometimes making that division of responsibility makes sense and is worth the tradeoff, but often it's not. Don't just entirely forget that adding classes means adding complexity, and each time you do that consider whether it's making your code easier or harder to understand and maintain.
This is why costly work in constructors should be avoided. PDO is bad example because it makes the connection when you create the object. Also when dependency graph is deep, (specific) factories might be of use. But there is no escape from control flow divergence - you can only choose they layer you put it and where you decide it. And how much layers you have is purely up to you. 
Look, we've had this conversation about a hundred times, and every time I list the **major differences** between both patterns, and every single time, it doesn't stick, so I've kind of given up on that front. I suppose your mind is unable to see the difference between those two approaches. So let's see what people say, and I mean anyone who isn't *you*. Find a single link from an even slightly reputable source, that says Encapsulated Context = Service Locator. Frankly, I feel you're just trolling me, or you would try to at least put some substance in your response.
Yeah, I had already read the docs :P I'm curious how the providers themselves are used in a real world scenario, the docs provided an example fairly similar to "here's how to test a calculator".
[Sort of](https://www.reddit.com/r/PHP/comments/6bhbb7/action_injection_as_a_code_smell/dhngn9t/). A single interface that declares all the "factory methods" that a particular object (or a narrow set of related objects) require. Some might object to calling this a factory, as it doesn't necessarily return a new object every time (although it could). Hence why it's best to go by the example and judge if you see this as a factory or not. /cc /u/adrianmiu
It was hard to have a counter-argument to the *original argument* of your comment which was "it is a Service Locator". Now that you've *edited it*... my argument is that this is a very incomplete definition of a "Service Locator", and any factory, or object returning an object that's injected in an object would fall under that poor definition of a "Service Locator". If you want to call half the objects in any given codebase a "Service Locator" who am I to stop you... But you still remain the only person in the world to claim so. This doesn't make my argument "personal", I'm just saying there's literally nobody else defining it this way, and I fail to see how this is *my problem*. The way I see it, when you play so fast and loose with terminology, you're the one on the losing side when trying to determine what architectural effects a certain pattern will have on your code. I'm very well aware of the differences in effects between a class Service Locator, and an Encapsulated Context. You don't seem to be aware of them.
Sorry for interrupting the conversation of you two but while i think your solution has some features of factory method and service locator - it does not matter which one of them it is or is not because in the end it is still a "**creational pattern**". -- Sorry @pmjones, but I'm not recognized credible source haha. // chill
It becomes especially clear that this is adding complexity when you consider what will happen when these Action classes have code in common. Do related actions now need to share a trait? Or do you introduce inheritance where related Action classes extends a common superclass? These solutions are not objectionable per se but it does add complexity.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
&gt; A very large application with over a thousand classes has about a dozen contexts in total. A `Blog` controller might require access to `PostsRepo` and `CommentsRepo`, along with other more general one (cache, logger etc) so you still need a lot of granularity. &gt; Controllers, in particular are such a set of objects. So I'll have one Context for, say, all my "admin panel" controllers, another Context for my "public site" controllers. But not for every controller. There's no practical need for this, as they share the same dependencies, as they are a cohesive unit of code together. I would rather have a `TwigSupplier.php` file next to my `Twig.php` file, instead of `PublicControllerContext.php` not next to `PostsController.php` file 
I did a little experiment, I tried to forget the meme "singletons are bad" and sat down and sincerely tried to buy into the author's case for singletons and see if I'm too dogmatic in my views. But I kept cringing at almost every code example and instantly recognizing the headaches ahead if I go with the author's proposed approaches. It seems the key issue is "what if we have a class that has dependencies, but we don't want to set those dependencies every time". First, I don't quite buy the particular example because I have a very similar class, and in my case it's entirely stateless and static: Json::decode(string $json, \Closure $filter = null); Json::encode(mixed $data, \Closure $filter = null); The approach of supporting an optional filter closure to do type resolution, deserialization to classes etc. is an obvious and very flexible approach, and allows your deserialized objects to also be injected with *their own* dependencies: $result = Json::decode($json, function ($data) use ($db, $cache) { if ($data['type'] === Repository::class) { return new Repository($db, $cache, $data); } else { return $data; } }); If you have a "default type resolver", obviously that type resolver won't have the chance to interact with your particular application and inject the deserialized objects with something contextual they need from your app. But I digress. If you want to have a class with optional and default dependencies, it's actually very easy without singletons: class JsonSerializer { public function __construct(TypeResolver $typeResolver = null) { $this-&gt;typeResolver = $typeResolver ?? new DefaultTypeResolver(); } } $jsonSerializer = new JsonSerializer(); See what I did? I just made the parameter optional, and I set up a default inside. It's quite simple, and that's also a valid approach sometimes. But I understand: sometimes it's not just that you don't want to supply dependencies, you also don't want to instantiate the class. It's too much hassle! You might be tempted to have a handy `JsonSerializer::getDefaultInstance()` there. And still allow instantiation for further configuration. But is this default going to be suitable for *all projects to ever use your JsonSerializer?* Are you even in a position to judge that while you're writing a reusable library? My experience so far is... no. So wouldn't it be far more prudent to replace the "singleton" coupled to the original class with a factory method that is specific to your application? I.e. instead of `Library\JsonSerializer::getDefaultInstance()`, you can put that method in your project internal code and reuse it this way `SpecificApplication\Utils::getJsonSerializer()`. Now we don't burden JsonSerializer with the weight of having to provide the perfect default for everyone, and we still can have static access to some default configuration to a dependency. I would still suggest this is only useful for a small set of dependencies, because most times you end up regretting static access. But if you'll be regretting it, it's best to regret it within the scope of your application, where code is easier to refactor as a single unit, and not regret it in your library, where any change represents a major B.C. break. But where things really go off the rails with the author is when he sneaks in this innocent method into the game: class JsonSerializer { private static $serializer; /** * @internal This method is not part of the client API */ public static function setSerializer(JsonSerializer $serializer): void { self::$serializer = $serializer; } } Notice it says "this method is not part of the client API". Yet the article doesn't say *who* and *how* should be calling this method. And with access so easy, it will 100% be abused, and now we've introduced volatile mutable shared state in the application... where several well-intentioned components will be randomly overwriting this default instance, depending on race conditions and other unexpected factors, with possibly unpredictable side effects. This is not fun. It gets even worse in the next example: class JsonSerializer { private static $serviceLocator; public static function setServiceLocator(ServiceLocator $serviceLocator): void { self::$serviceLocator = $serviceLocator; } public static function serialize($object): string { return self::$serviceLocator-&gt;get('json_serializer')-&gt;serialize($object); } ... } On top of all other issues I mentioned, we just coupled our clean, isolated, innocent JsonSerializer with a framework dependency. To use this JsonSerializer, now you need also to use Framework Brand X, which provides this ServiceLocator class/interface. And spend a moment to think about something... What is the connection between these static methods, and the rest of the class that actually implements the serializer? Do they have to be together? Do they really depend on each other? No. It's an absolutely obvious case of mixing two *completely distinct concerns* for no reason. The JSON serializer that the ServiceLocator returns might not even be *an instance of this class*, because nothing ever checks that it is, and nothing requires it. I'm afraid a case for Singletons and Facades hasn't been made here... If anything, this code should scream to you "run away".
&gt; A Blog controller might require access to PostsRepo and CommentsRepo, along with other more general one (cache, logger etc) so you still need a lot of granularity. I'm unsure what's the problem. If it needs these, put them in the BlogContext, and now it has them. &gt; I would rather have a TwigSupplier.php file next to my Twig.php file, instead of PublicControllerContext.php not next to PostsController.php file OK, but I think just stated like this, you're not making a great, or even good case about the distinction. The Context pattern is not just about dependencies, by the way, so it's not as if the existence of factories make it pointless. It's also an example of the Delegate pattern, where a wide range of behavior decisions can be "outsourced" to the context, without the need for writing dedicated "dependencies" for the purpose. Good use of this pattern can result in some strikingly flexible and reusable code modules, where by just implementing one interface you're saving yourself days of work doing the good old "copy, paste and tweak" routine that many people do with their controllers and templates, from one project to the next...
I'm on mobile, so these will be just keywords: testability (mockability), maintainability, extendability, searchability, debugability, plus reducing cognitive overhead during most of those things.
can someone link me to use examples with composer?
I personally am not adverse to those two extra curly braces, so I don't really see the benefit.
Never heard of this pattern before, looks really interesting, thank you.
Well, Sylius is actually 5 years old, but they chose to go for a release only this year. It has some issues, but due to being superbly designed with bundles properly the Symfony way, it's very easy to override parts of it. Customizing it is easy 
Hi, I am the PM for Bamboo. Thanks for the feedback! Security and compliance are a concern for most of our target enterprises users due to the regulatory environment they operate in, so we are focusing heavily on that area. Feel free to DM me if there is any way we can help you with Bamboo.
That's amazing. What terminal app is that preview GIF rendered in? That's not iTerm, is it?
That's [Hyper](https://hyper.is/). However, I'd rather suggest you to use iTerm. Hyper just looks fancy, but it's not so powerful as iTerm.
Yes. And Magento is really bad. Job offers with "magento" in them go right to the trash bin. 
Reddit is the way to get instant help from other PHP developers + is Google friendly. Private Slack teams are not + messages are deleted after some quota is reached. Gonna skip that one, good luck though.
Yes to everything here. As someone who has dealt with Magento...its garbage. As someone dealing with PCI Level 4 Compliance, its long. Some of it is over my head, mainly KEK and PEK stuff. Problem is, many small to medium e-commerce shops are not PCI compliant and have never really given it a thought. Sure, they know a few things, but the SAQ is 12 sections with each section having anywhere from 10-50 sub-sections. #brutal
You should at least mention beanstalk, which is used as much as rabbitmq
The sole purpose of `ControllerContext` is to provide dependencies, hence it’s a service locator. The differences you mentioned do not matter in determining whether this is a locator or not, because: * The pattern doesn’t specify what kind of methods does a locator have (typehinted or generic) * How many dependencies does it manage („all dependencies” or „some dependencies”) And the argument about controller not seeing the container is misleading: it sees the service locator.
Problem with Shopify is that to roll out a decent functional shop you need to play over a 100$ a month for modules. And ever 200-300$ a month is quite common. It's cheap only for a very basic shop. Take the amount you will pay in a year for that shop and I can roll out a Sylius install for the same money with more functionality and ability to further tailor it to your needs (and it's code is actually very good - take a look). It's not that black and white with Shopify as people tend to think. Maybe it's because the usual rate for development in West Europe, Scandinavia, USA and Canada is actually like 2.5-3 times bigger than here in East Europe where I live (and I don't sell my skills cheap either - 35 EUR/hour is not cheap at all, but comparing to UK, Norway, USA and so on - this is 2 to 3 times cheaper than most agencies) and this is why I can roll out a custom shop with no problems, especially if design is not complicated. And supporting it further is no problem as Symfony devs are not too hard to find and there is nothing specific about the platform that requires special knowledge to work with it.
I've deleted the repo before someone other comment it, I understood it wasn't ready to be public, I'll try to work on it, I understood my errors and I'm fixing them, from various sql injections to a better file organization. Thanks to all of you for help / critics (constructive or not) you helped me in any case. Peace✌🏻
start writing tests and you will soon start to despise hidden dependencies 
My bad, I've misunderstood the article and it's purpose.
So you expect people who come seeking help to go through your quiz to get answers for their queries? Good luck. But that right there is gonna deter most from joining.
Font should be this one, right? https://github.com/abertsch/Menlo-for-Powerline
mind that paraunit does not use threads, but just plain processes with `symfony/process`.
Your IDE should be warning enough (marked as yellow^^).
&gt; Can I remove the brackets for this guard clause? Strictly speaking, yes you can remove the brackets. However, it's generally considered best to always include the brackets for readability and reduce the chance of error should you need to modify the code later. There have been several rather infamous bugs caused by editing code without brackets.
Phpbrew allows you to easily switch PHP versions.
I'm curious about an expected budget to run on a custom symfony shop. PCI compliance alone is a few hours + constant monitoring and attestations. Running a few servers (web + database) with data replication and backups also takes a few hours every month and also costs money.
I like to use method injection for request state (route parameters, the request) and the constructor for stateless services. Everywhere else in the application you tend to use a similar pattern. The object gets it's dependencies when constructed and gets what it operates on as method args. I don't think controllers should be any different. The 'after' example in the linked article moves the request to the constructor. I think that is worse, because now you need to construct a new controller to handle each request (i.e. sub requests in Symfony or async PHP). It reminds me of [this article](https://igor.io/2013/03/31/stateless-services.html). That seems like a worse code smell. Now your controller is a stateful service when it doesn't have to be. I agree that injecting services into the methods is not great. I've done it before and it was just confusing. Just because it's the one place in your app where you _can_ use method injection doesn't mean you should :D
But you can buy it at very low price!
I think you would do a beginner a disservice by showing them unnecessary features that they are likely to abuse unintentionally. Instead, explain to them why that code should not be in the view to begin with. A strong understanding of the fundamentals is the key to progressing in software development.
You really overestimate how much hardware it needs :) A decent VPS with SSD's and a few cores easily runs a shop without any trouble. And PCI DSS compliance is required only for those who process credit cards on their own - why would you even consider that for a type of shops we are discussing here? You are never going to do card processing yourself - you just integrate providers that do card processing - PayPap, Stripe, FirstData, whatever local area providers and banks you have- and that's it. They do the processing, you just use their API's to process payments - you never-ever-ever deal with credit card data! If you are dealing with credit card data (or whatever cards for that matter) - you are not a basic shop at all. Hell, your budget is probably bigger than my whole life's earnings for those 50 years i'm gonna be working. IF we don't take into account the design - that can cost 15-20k euro or be a 20-30 EUR template, I can slap a default Sylius shop with PayPal and some configuration in an evening (3-4 hours). For 1-2k EUR I can do quite a few custom things or apply a design to it (if you provide HTML&amp;CSS ready). Server will cost you like any regular VPS - a 10-20 EUR/month SSD VPS will work just fine - put it on Digital Ocean. IF you have a big catalog - you want some Elastic backing - that requires some more memory - need a bit beefier VPS - cost will maybe go to about 20-30 EUR/month. For 44 EUR/month + VAT I can place it on a monstrously powerful VPS with high clock speeds (3.5 GHz, quad-core last-get v4 xeon), super-fast disk IO, plenty of RAM and fast network connection. You don't really need to do much with a shop to maintain it - backup your database daily, backup your files - all that is pure automation, and basically the only thing that costs money is the server itself (you need to host it somewhere) and additional development if required. If you want your server maintained - that's not really my job description - i'm a developer, not a systems administrator. But to be candid - there is not much to do - plan your OS updates every so often, schedule downtime when needed, put platform updates every so often and that's it - a monkey can do that these days - it's not like 10 years ago to maintain a Linux server you had to be a bearded experienced dude with 10 years of experience behind your back to do it. Any decent experienced web developer can do that with his left foot. You will have the basic tools to edit your pages, have a blog if you need one, create promotions, put banners up and all that. This is what a basic shop means. If you need a full-time developer to do stuff with a shop (or at least you have constant work to be done every month) - this is not a basic shop anymore. That's different.
How *would* you solve that problem? If you constructed a `Parent` instead you'd get back a `Parent`. You could typehint `foo` against `Child` I guess, but then if you added in another class, `class Grandchild extends Child`, then the typehint would be wrong. I guess the only thing you could typehint against would be `self`.
Depends. If you're servicing an established company with deep pockets, by all means, go custom and give them the ability to grow. I said that in _most cases_ (considering all cases of ecommerce on the Internet .. mom &amp; pop type shops), Shopify is way more than enough. 
&gt; then when your finally big enough In _most cases_ that will never happen. 
hmm am I right in thinking that you _shouldn't_ be able to fix that, 'cos instances of foo() in child classes should have the same signature as ones in their parent. $anything-&gt;foo() should return a class of Parent (or a class which implements/extends Parent), which we know has a method foo which returns a class of Parent which we know etc etc
It doesn't... that's kind of my point. The original "action injection" doesn't solve the problem, it just makes it less severe. And OP spends the entire article talking about alternate solutions, only to arrive at a factory that's 100% identical to "action injection". And so I wanted to talk about how we can address the problem of conditionally user/unused dependencies in a complete, comprehensive way.
Why not `public function foo(): self`?
It is much easier to write tests for code that is decoupled into separate classes. You don't have to mock dependencies that you are not using for a specific action.
Because it doesn't work yet. https://3v4l.org/JJbKE Apparently PHP expands self to the class name, and as PHP doesn't support variance yet, gives the error message: Fatal error: Declaration of B::foo(): B must be compatible with A::foo(): A Adding variance to method declarations is going to be hard to do, and may require class autoloading. That's something I'd be fine with but other people apparently object.
If PHP supported the way the static type works in phpdoc, would that work to resolve your issue? I've run into the same problem as you several times and had to resort to setting phpdoc comments for my IDE to typehint correctly. /** * @return static */ So if PHP instead supported static return type this seems it would solve the issue (using your code): class Parent { public function foo() : static { return $this; } } class Child extends Parent { } $x = new Child; $y = $x-&gt;foo(); Of course this return type would only be valid within class definitions. edit: forgot to mention that this is based off PHP's [Late Static Binding](http://php.net/manual/en/language.oop5.late-static-bindings.php), so it's not entirely unexpected that support for this would be unreasonable.
I assume `public function foo(): static` does the same?
&gt; The sole purpose of ControllerContext is to provide dependencies, hence it’s a service locator. This definition, as I said above, fits over half the objects in any given codebase, and isn't what people generally understand as a "Service Locator". Heck, your constructor argument lists falls under the definition of a "Service Locator" with a definition so vague and wide. But unlike you I won't just say an (incorrect) claim, I'll source it. For brevity, in the rest of this comment I'm using these abbreviations: - DI: Dependency Injection - EC: Encapsulated Context - SL: Service Locator First, your two statements: &gt; The pattern doesn’t specify what kind of methods does a locator have (typehinted or generic) In that particular claim I wasn't contrasting SL with EC, I was contrasting: 1. Injecting a typical PHP container: `$container-&gt;get("string")` 2. Requiring an implementation of a type-safe interface: `$context-&gt;getDep(): Type` If we wouldn't reduce all this to bickering about names, it's quite obvious you'd rather have a type-safe, autocompleted dependency source, rather than something that takes strings and returns whatever. Or are you going to argue about this, as well? &gt; How many dependencies does it manage („all dependencies” or „some dependencies”) Ok, let's go to our sources. Let's start easy with [Wikipedia](https://en.wikipedia.org/wiki/Service_locator_pattern): &gt; This pattern uses a **central registry** known as the "service locator" This goes directly against your claim. EC is neither "central", nor is it a "registry", which implies not just getting dependencies, but also setting dependencies from all around the application, which is further confirmed by: &gt; Applications can optimize themselves at run-time by **selectively adding and removing items** from the service locator. The EC is an *interface* that only provides methods for reading what an object needs to operate. There's absolutely nothing about "adding and removing items" from it. And let's see some of the cited disadvantages: &gt; The registry **must be unique**, which can make it a bottleneck for concurrent applications. &gt; The registry **hides the class' dependencies**, causing run-time errors instead of compile-time errors when dependencies are missing. &gt; The registry makes the code more difficult to maintain (opposed to using Dependency injection), because it becomes **unclear when you would be introducing a breaking change**. &gt; The registry makes code harder to test, since all tests need to interact with the **same global service locator** class to set the fake dependencies of a class under test. However, this is easily overcome by injecting application classes with a **single service locator interface**. All of these talk about the same thing: the assumption is that the SL *is global to the application* or significant parts of it, and therefore all the effects above from unclear relationships between dependency providers, and dependency users. None of this is in effect with EC, which is an interface that's strictly defined for one, or a narrow set of related objects. And it being an interface is not *optional*, as with the SL. It's *100% required*. ----- Now let's move to someone more authoritative, Martin Fowler, in his [Inversion of Control Containers and the Dependency Injection pattern](https://martinfowler.com/articles/injection.html): &gt; In this article I dig into how this pattern works, under the more specific name of "Dependency Injection", and contrast it with the Service Locator alternative. Sounds good, right? &gt; The basic idea behind a service locator is to have an object that knows how to get hold of **all of the services** that an application might need. &gt; The key difference is that with **a Service Locator every user of a service has a dependency to the locator**. The locator can hide dependencies to other implementations, but you do need to see the locator. With EC that's not the case, because I said about a hundred times, EC is not a global dependency itself. The *same service can be provided in multiple different ways, either directly or through different EC interfaces*. And EC is not a "canonical locator" for anything it provides. It's merely *a bridge, an adapter* for the real provider of the services. &gt; Using dependency injection can help make it easier to see what the component dependencies are. With dependency injector you can just look at the injection mechanism, such as the constructor, and see the dependencies. With the service locator you have to search the source code for calls to the locator. Once again EC is on the side of DI rather than SL here. Because every EC interface is utilized by a single, or a small set of related objects, you don't have to "search through the source for calls to the locator", you can merely see the interface EC defines and conclude the objects it services, which are *strictly defined*, need all of the listed dependencies (albeit not on every request, of course). That's a very strong distinction between EC and SL, because SL does indeed tend to "hide dependencies", while EC is as explicit as a list of constructor arguments. &gt; Since with an injector you don't have a dependency from a component to the injector, the component cannot obtain further services from the injector once it's been configured. &gt; So the primary issue is for people who are writing code that expects to be used in applications outside of the control of the writer. In these cases even a minimal assumption about a Service Locator is a problem. Once again EC behaves like plain DI here: you can't get "further services" than are strictly defined in the interface. You can't make even "minimal assumption" about any other functionality in the EC instance you're given, apart from the interface you have defined for your component. So, I've been quite comprehensive, I believe... You and /u/pmjones/ can keep calling it a Service Locator if you want, this doesn't matter to me. What matters is that Encapsulated Context shouldn't be conflated with the negatives typically ascribed to Service Locators, like "container coupling", "dependency hiding", "dependency spaghetti", "shared mutable container state" and so on, because none of these are even remotely relevant to what Encapsulated Context is. 
That's what I meant https://3v4l.org/imR21
I am able to type hint the return type via PHPDoc with this: /** * @return $this */ PHPStorm completely understands that, and will provide auto completion support for the child class. What I can't do is properly type hint in code that the return type should be the child class extending the parent, however many levels deep are involved. 
you can't already use stdClass?
I think this fits better under /r/laravel, but it looks like a promising tool for dev/staging environments
Does the async execution in the server process execute in a child thread / process ? I know from experience when combining with Doctrine for example, your consumer will blow up after a period of time as the memory leaks. I created something similar.. I call it an RPC and I have two scripts running. A parent consumer that only listens to Rabbit which then signals another script to execute the main processing of the message in a child. The consumer holds until it receives a response to the message before it ACKs (or NACKs). It's super resilient. The child processes can blow up, doesn't take the parent or the consumer with it. 
`stdClass` is not the same as `object`. `object` encompasses ALL objects in PHP, while `stdClass` is a concrete implementation of of an `object`.
Here's where the problem arises. If I were to set up methods in the parent class that I want to allow to chain then I can't type hint the return. For example, I'll fill in a bit more of my example. class Parent { protected $value; /** * @return $this */ public function foo($x) { $this-&gt;value = $x; return $this; } } class Child extends Parent { public function bar() { // Do something important with $value } } $x = new Child; $x-&gt;foo('snafu')-&gt;bar(); Without being able to type hint that you're going to get back the same object you were working with, this can't be defined in code. My solution today is to note the return type via the PHPDoc as $this, and at least the IDE understands what is coming back from foo(). More importantly, I want to state that what is coming back isn't just an object of some type, but the very same object that I started with at this point in the chain. For example, every setter method used in the hierarchy of the class structure should be able to do that. Otherwise, you simply can't have hint-able setters anywhere but at the lowest child class. None of this is a show stopper for continuing to code. I just think it would be nice to hint this very common thing so as to fully utilize all the new hinting abilities of PHP 7.
&gt; This definition, as I said above, fits over half the objects in any given codebase Not my codebase, since I tend to obey the law of diameter. :P &gt; If we wouldn't reduce all this to bickering about names, it's quite obvious you'd rather have a type-safe, autocompleted dependency source, rather than something that takes strings and returns whatever. I would like to have typehinted methods. In some of my project container / service locator had them, and that didn’t change the fact that I was using the Service Locator Pattern. &gt; This goes directly against your claim. EC is neither "central", nor is it a "registry", which implies not just getting dependencies, but also setting dependencies from all around the application Good to know — you just need to split your container into two, and you are no longer using the SL Pattern. &gt; You and /u/pmjones/ can keep calling it a Service Locator if you want Thanks! Do you grant this privilege to us exclusively, or do other devs can do this as well without asking? BTW, your context would be a little more flexible if service ids would be injected instead of hardcoded (I’m not saying it doesn’t, I don’t have your code at hand, maybe it does). I mean: class FooContext { private $container, depId; public function ($container, $depId) { $this-&gt;container = $container; $this-&gt;depId = $depId; } public function getDep() { return $this-&gt;container-&gt;get($this-&gt;depId); } } 
&gt; Not my codebase, since I tend to obey the law of diameter. :P I prefer the law of radius, myself... It's [Demeter](https://en.wikipedia.org/wiki/Law_of_Demeter), BTW ;-) And it has nothing to do with our situation, because the EC interface is part of the same code unit as the class using it in its constructor. The Law of Demeter speaks of *units*, not *classes* or *objects*. And as people who do unit testing often forget, those aren't the same thing. &gt; Good to know — you just need to split your container into two, and you are no longer using the SL Pattern. Architecture is often about shades of gray, not about black and white. Splitting it is one step. Injecting it is another step. Typing it is another step. Depending strictly on an interface, not implementation, is yet another. And before you know it, you've walked the entire path from horrible ungodly mess to a flexible, elegant architecture. &gt; BTW, your context would be a little more flexible if service ids would be injected instead of hardcoded (I’m not saying it doesn’t, I don’t have your code at hand, maybe it does). This is the Encapsulated Context: interface FooContext { public function getDep(): Dep; } It's just an interface. It has no properties, it has no constructor, it has no method implementations. Whether things are "hardcoded" or not is entirely up to the discretion of those who want to create an instance of `Foo` and have to implement the `FooContext` interface. The idea is that Encapsulated Context doesn't suggest it's implemented one way or another. Which is good, because it also means it's not coupled to a specific container, like your class is. Don't get me wrong, your class is a *perfectly good implementation* of that interface, but the important part is this implementation shouldn't be shipped together with `Foo`, only the `FooContext` **interface** should be shipped with `Foo`, allowing implementations to vary based on your ad-hoc needs. I use Encapsulated Context to configure components which are entirely independent of a given application, or framework. This means I can implement the same EC interface from *different applications*, in *different frameworks*, using *different containers*, or even *without containers*. This makes components using EC for injection truly independent and reusable. Just as much as constructor injection results in components that are independent and reusable. Except we have a lot more flexibility, like lazy instantiation, behavior delegation and so on.
I don't like this, because it encourages using objects as simple data containers without contracts, and coding against objects of variable contracts - neither of which is a good practice when it comes to software design.
Right, I was suggesting that an additional return type of "static" based on PHP's Late Static Binding would meet the functionality that you require, but this would require a change to the language. If you haven't tried using the "static" return type comment, I would take a look as it also allows for proper child hinting on static class functions. Here is an example that is supported by PhpStorm using the static return type in phpdoc comments class test_parent { /** * PhpStorm always shows the return of the function as being the parent, but * the returned value is properly hinted. * * @return static */ public static function foo() { return new static(); } } class test_child extends test_parent { function bar() { return 'blarg'; } } /** * CTRL+hover on the ::foo() function and the variable and you'll see what I'm * talking about above. * * Do this for all the calls and variables. */ $x = test_parent::foo(); $y = test_child::foo(); $y-&gt;bar(); 
Sure, maybe. I guess it would depend on how your test environment works and how and when the mocks are created. Personally, I prefer to do as little mocking as possible (unless there are real world consequences, like hitting an API or sending an email) so that the test tests the real behavior on every level as much as possible. But that may be a different subject.
Changing a constant at runtime is sort of a trick question. The black magic fuckery known as runkit makes this doable.
With PCI DSS 3.0+, even if you do not directly process/transport the credit card your website still needs to be in compliance. If you use something like an offsite gateway (redirecting to PayPal) that is less of a problem. If you use Stripe you need to serve that checkout form over SSL and a few other things with iframes/xss. Server maintenance alone would be more than 30$/month. You would want to test your backups every so often, os updates sometimes have to be quickly installed, software packages might have CVEs, etc. It's interesting to say 300$/month for any SaaS e-commerce software is too expensive but "1-2k EUR" to develop a solution + ~60EUR/month for hosting / maintenance is deemed okay. You end up with a very similar price point but with less features.
&gt; However it is not currently possible to declare that a function either needs to be passed an object as a parameter I'm fairly sure you can actually do that, unless I'm misunderstanding... class Foo {} class Bar { public function DoThings(Foo $foo){ } } &gt; or to declare that a function must return an object. That'd be nice though.
I had this exact same problem yesterday! I had a abstract class parent, with a method returning parent, and a child class extending parent, that should return itself. This should be allowed since the child extends parent, it should be allowed to return it, since all users off the return type can atleast expect parent to be returned, but maybe something *more*, but never anything different! 
Just FYI, I am a developer just starting in on a senior dev position. PHP and frameworks built on top (Laravel/Symphony/ect...) is just some of the tools I have picked up along the way. After a while, it all just mixes together. Personally, the best people are in local meetups. That and the compensation/benefits needs to be there. If you pay with peanuts.... At least that is how I was picked up for my last two positions. And some of the better programmers that I have worked with.
&gt; This is the Encapsulated Context: You misspelled "Service Locator" (or perhaps "Container" ;-)
What can I say - we live in a different areas and realities. Most small shops will happily live on a 5$ Digital Ocean droplet, following the rule - if it works - don't touch it. Most hosting providers have backup solutions out of the box, and I always drop in a database backup cronjob. You just clamp everything down with a firewall except SSH, 80 and 443 ports and maybe in half a year they will ask you to run an upgrade on the server that most of the time takes like 10-15 minutes. That's how the realities of the smaller shops work. And either it stays small and is just a side business for the person, or they grow and eventually start ordering custom development that goes way outside the PaaS/SaaS scope just due to how business works, with what vendors it interacts and general accounting/shipping/warehousing integrations. And to be very candid here - a lot of western style accounting/warehousing software is shitty and extremely expensive to a point of 10x-20x compared to what is available from local vendors in my region + it rarely is adapted to the realities of the region and customization skyrockets the costs even more. So, in the end, integration with something like Shopify for a seriously growing business is not just hard - most of the time it's impossible. Bigger shops, at least those that I tend to get, have a different set of stuff - they need custom shipping integrations (local), they need numerous payment integrations (bank links, local payment processors - for many PayPal and Stripe is actually secondary or even "because a few clients asked a lot" + getting out money from PayPal, Stripe and the other lot in my region sucks to a point that its just not viable at all - to get my funds out of PAtreon - I lose ~7-8% just on transfer fees. 2% transaction processing fee here is considered "high", if you want to pay paypal or stripe - get ready that those fees will be included on top in the order) with some being being quite custom, just general order processing adaptation to the business rules, some completely custom stuff like as an example for a current project "reserve goods to check them out at the store before buying". And no, with the amount of traffic this project has you cannot do it via "notes" field for the order. I'm not even starting on warehousing, accounting and store register integration with the web side of the store. This is not something that can be really done with Shopify - they just don't have all the modules you need, nor it can at all most of the time, because each custom client has his own custom set of requirements. As for PCI DSS - SSL everywhere, I would not put up even a blog without a Let's Encrypt SSL certificate these days, and for shops most of the payment providers basically require you to have a proper certificate or they will decline your request to use them. And of course most are using offsite gateways, and because 3D-secure in Europe these days is mandatory (I always have to authorize my payments through 3D-secure at least initially, most of the time with each purchase) - you always end up going offsite regardless to login into your bank. We get very little direct card processing by businesses in our region - everyone is using some gateway, and we have a lot of those (we have a FinTech hub in our country - tons of companies and startups in that area). That's the realities of my region. You mileage is going to be different :)
&gt; Don't just entirely forget that adding classes means adding complexity, and each time you do that consider whether it's making your code easier or harder to understand and maintain. Oh, I completely agree that there are tradeoffs that come with the single-action controller approach. However, in this case, I think it might be more appropriate to say that it *reveals* the pre-existing complexity of the system, rather than that it *increases* the complexity.
Your level of discourse in this thread is that of a 10 year old who just hit puberty. You're better than this. 
Could explain the use of such fusion for someone who used Slim but never used ReactPHP? Thank you.
I suspect we can all agree that compensation is messy topic and is one of the variables (albeit a large one but it causes one to rabbit hole quickly - my goal in posting was to pick brains about avenues/vehicles to search). So that I am not specifically dodging: we have full insurance/401k package(s) and I have fished with sub six figure and high six figure salaries (USD) depending on what type of candidate we are talking to. I tend to fall into the group who thinks the skills and candidates set the salaries, not the position we are hiring for. That works really well for us (we are a small business) it doesn't work for large corporate.
completely valid, I would definitely consider that everyone of our developers fits the bill of completely front-to-back so maybe I am incorrect in my thinking others exist... one thing is for sure I am learning a lot from this post so thanks to anyone/everyone for commenting
You two are going back and forth like it's only a one-or-the-other scenario. It depends what your target clientele is. My agency has a large focus on Magento e-commerce solutions. **All** of our clients are too large and have too complex business requirements for Shopify or any SaaS we're aware of. SaaS, Magento, and other solutions in this thread are all potentially valid choices for someone seeking an online retail position. Understand your clients' needs and choose wisely for them, and everyone can be successful.
If every single PHP-based solution on the market is terrible, why do you think yours would be any different? Since I don't really know you or your skill level, I can only say _good luck_. E-commerce is **hard**. The business requirements vary greatly, and customers will expect all the usual bells and whistles (_what do you mean it's going to cost me more money to add coupon codes?!_). It is extremely easy to underestimate the work involved, and we all know how good it feels to miss deadlines and see our hourly rates get smaller and smaller. Magento, while it has its faults, provides one of the best feature sets and extensibility you will find for a free e-commerce solution.
i did that a while ago, just for fun, and i think there are a few more people who did similar things.. https://devedge.wordpress.com/2015/08/09/king23castle23reactphpslim-framework-3-0-for-the-fun-of-it/ 
That's the point of this RFC, yes. Take a look at the examples in the URL, there are some generic use cases.
I suppose it can't be any worse than it can be now... I often forget php isn't a strictly typed language, you have to force it to be.
agreed &amp; fair points
No real benefit, just seems odd having empty classes in certain areas. Dangling brackets.
I think you mixed up the links for Slim and React in the credits.
You are not the first person I've heard say this. In fact I was speaking to another company and they moved to js\node simply because of a problem finding talent. Given that I can say our two other php devs were entirely home-grown via training, pair coding, and brutal PR reviews. &gt; hire two full-stack PHP-based programmers who know js/mysql/AWS/&amp;more The AWS component may steer ~some~ people away since its very vague (AWS is a huge platform). I would probably just adjust it to say experiencing hosting an app on any cloud platform (Linode, Digital Ocean, AWS). This is, of course, unless you need something specifically done with an area of AWS that may be more ops-y. Other than that, your requirements make complete sense. Perhaps drilling into JS will filter out some people who may not be fit (adding in some words like "Familiar With Build Tools, Task Runners" or something).
Yes absolutely, deployments must restart the process for sure, however outside of that requirement, the process should not need restarting due to memory leaks, locks, etc. 
It kind of seems like you're throwing out a lot of buzzwords because you don't really know what skills are needed for the job, or because the job itself is not well-defined. As a dev looking for work it's one of my bigger frustrations that I constantly run into. I can't be confident about my ability to do the job if I don't know what you want me to do, or if it seems like you're looking for someone to do several people's jobs as one. What do you actually want done? I can't tell from &gt; full-stack PHP-based programmers who know js/mysql/AWS/&amp;more because those are tools, not a job. Full-stack can also mean a lot of things, and what I may infer from the tool names may not be what you're actually looking for. 
The variance issues on typehints definitely needs to get handled in some way eventually, though I think an explicit `this` return type - different from `self` - would also go a long way. Returning `$this` implies (though doesn't *technically* guarantee) that you've modified the existing object; `self` may return a new instance of the same type of object like with PSR-7's `withSomething()` methods.
How does he expect your code you write to go up there? Framework is just tested (errors/security) code. 
I bet your boss is gonna feel real smart when someone gets RCE on your servers because you overlooked one of PHP's nearly infinite security issues in building this api from scratch. Debian packages don't protect you from that. In all seriousness though, does your company print its own money? Sure you COULD write your own framework from scratch, just for this API, but why would you? You then own the upfront costs (which will be higher for the framework than for the code you're writing, it sounds like) and you also own the maintenance forever, which will continue to cost your company money as long as this API is in service. I work at a SaaS company, and we try to adhere to the philosophy of "build what your customers are paying you for" in making decisions like this (buy vs build, in-house vs external tools). If it's not the service your customers are paying you to provide (hint, your customers are not paying you to parse web requests, they're paying you to DO something with those web requests), then you should be using someone else's code for it in almost every case.
Agreed, "official Debian package" is an absurd metric. Ludicrous. Makes no sense. They are not kept up to date by any means, especially for fast moving web technologies. For the frameworks I use that do have official Debian packages, I dread hearing someone say they actually used that for installation. I constantly have to tell them to uninstall and use the official installation instructions. So, that's one chink in the armor.
gj, i have no idea why anyone would do this in production though :D
Fun Fact, you can still use Slim 2 without composer.
Not surprised. Though with Magento I had to purchase plugins for basic things as well like configurable products. So same shit, different shit shopping cart product.
To be honest, if your shop really can run on a $5 VPS you can be much better off running on Shopify. When you do start getting a bit of traffic, there's absolutely NO way you can get away with even a $20 VPS. If you are small, why not scale down your requirements? You don't need to have 3 shipping providers and 4 payment gateways if your sales volume is maybe 5 paid orders a day. And you definitely won't need any sort of inventory management, POS integration and the likes. What's to say, I know we're all developers here, but as a small store you should be concentrating on growing the business, rather than fucking around with your code and server. 
&gt; mixing html and php without remorse Can you please give me an example of this? I'm getting back into PHP and don't want to become one of the candidates you're referencing.
Without every significant op being async, there is no benefit.
And I was like you a few months ago too. Started to pepper in some vue here and there in projects. I loved the data binding of angular and was using that for small pieces on sites but hated how huge angular was. Then discovered vue and immediately replaced that angular code with vue. Still feel like a noob too but I'm currently building a community app with a fully decoupled front end running vue/vue-router/vuex and liking it a lot. 
Is the job actually interesting? I've been a full stack dev for nearly a decade and while I'm open to looking at new positions, I'm a bit picky. People with a broad range of experience are: 1. Likely to already have a position. 2. Likely to want something that gives them room to grow. 3. Probably looking for something more than just the same thing they're doing now at a different place. A great number of positions I find, for example, want to specify too much of the technical solutions in the job description. This is a big turn off for me, because if I was going to leave my current senior dev position, I'd be looking to have a lot more influence and input over the architecture. If you tell me you're looking for a senior dev to work on a number of client projects written in Wordpress and Laravel, I'm pretty much going to laugh and move on.
&gt; How should I encourage him to let me use a micro framework? You: "If I could use battle proven framework X, I would approximatly need y% of time, because I don't have to implement a,b and c myself. Also consider, every line of code I have to write less, means a line of code less where I could fuck up". Boss: "Ok"
Exactly this, I often browse Job offers for fun (Pretty happy with the Company I work for) and to me the worst offers are the ones where a too broad skillbase is required. To me it often reads like "we don't really know what we are looking for". Sometimes the required skills even don't make any sense (once I read an offer for a jr. dev position with atleast 5years exp and once it was a backend position requiring heavy skills with Photoshop and AfterEffects...). @op: try to figure out exactly what you need (where are your most needs) and ask for the other skills while interviewing. Anyway, most devs are happy to learn "new skills" which are needed in their Company.
We should not discourage language features and constructs because of potential misuse by user land. User land will always find a way to apply bad practices, no matter how small the feature set of a language. I see a lot of potential for this implementation, although I do agree with the better part of the voters that supporting object variance is probably best left out, as it makes contacts confusing and symbols create unpredictable behavior. If variance were applied, I'd rather see covariance all the way.
&gt; Without being able to type hint that you're going to get back the same object you were working with, this can't be defined in code. Ok. Let's try to view this problem without knowledge of how your `Parent` is implemented. Basicly type hints are just describes which type you will get but not how. Imagine that instead of returning `$this` we will have something like that: public function bar(): self { return new self(); } This will basically force code to always return `Parent` independently of how your code has been called. The knowledge that you may return something different from `Parent` will be available only at runtime (dynamic context). And the main point of type hints is to provide information about types in static context. Also if you had implementation with type hint `self` which returned `$this` and you will "substitute" it with new implementation which will return new instance of self, your code will be broken. We have LSP been violated. &gt; Otherwise, you simply can't have hint-able setters anywhere but at the lowest child class. I have few solutions for you: 1. Do not use inheritance. At all. (yes, in real life you will but try to think how to do things without it). 2. Do not use return type hints for method chaining, IDE is understands when you returning `$this`. It doesn't have any value in your scenario.
Offer a high compensation and have a good product with a good company culture and work/life balance. I listen to those jobs. I don't even bother with a job if they don't post compensation in their ad.
I find that some job adverts ask for a lot more than is strictly necessary. A lot of the times, the core requirement may be enough to get someone with solid background, and then they can learn the extra bits. I'm struggling to even get a reply from agencies for Junior PHP posts, I have a long history of IT consultancy work in development and support. Had a career break due to stress and went off and did an Art degree. I don't have any commercial PHP, but work quite a lot with it at home. Agencies seem to see this as a bad thing and I can't understand why?! I hate the idea of applying for something which I can't do, so any job which asks for too much will put me off. I've worked with some people who've got in on saying how good they are and ended up not living up to it, so I don't want to be that person. I thought applying for junior roles would be a good start point - I'm not even that worried about the money - after all as a student I learned how to live within my means.
"Yeah, I wrote all that code you see in ./vendor ... yes boss... it's just a few thousand lines - I knocked it out last night ... "
Look at these, they might fit: - https://bolt.cm/ - https://asgardcms.com/ - https://octobercms.com/ 
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phpadvisories] [SQL Injection Vulnerability in Joomla! 3.7 • r\/PHP](https://np.reddit.com/r/phpAdvisories/comments/6buo77/sql_injection_vulnerability_in_joomla_37_rphp/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
Joomla sites are so infested they became sentient. Joomla sites needs no webmaster, some one else will administer it for you. Joomla sites have very good SEO, specially in "v1agra c1alis p3nis size" Traffic count with Joomla is high, all the bots breaking all the vulnerabilities count for somethin'. 
With your current design you won't get any benefits. In fact, your current approach will actually make it worse than using Nginx + PHP-FPM. The reason for that is that your [request processing blocks](https://github.com/NigelGreenway/reactive-slim/blob/701667b3c2b2538d2fe2eab9a0db3d09d4a36f4b/src/Server.php#L93). During that time, ReactPHP won't be able to accept new connections, leaving them in a hanging state. While the connection isn't established, no client will send any data, so all clients have to wait for the previous request dispatching to finish before even getting their connection accepted. There's a similar project called [PHP-PM](https://github.com/php-pm/php-pm). IIRC, PHP-PM dispatches requests to workers when they're idle only, but I didn't have a closer look. The benefits of non-blocking I/O will only pay out in case every significant operation is non-blocking as /u/assertchris already mentioned.
Senior Developer here. I'm actually a freelancer at the moment but I normally post on the Hacker News Who Wants to be Hired / Freelancer / Seeking Freelancer thread once a month. If you look through the people that post there you'll see a lot of good talent. Incidentally there's a site that amalgamates all the postings too http://hnhiring.me/ which you can filter by job type and skills.
React is dead.
Thank you. I'll add those to my reading list.
&gt;&amp;more
OK so you clearly *don't* have any ability to improve search rankings, since you don't know that site speed is a minor factor in ranking. Links still play a much bigger part. 
But it seems like this can *only* be misused. I didn't see an example where 'object' actually made sense and couldn't be replaced by a class. 
Oh alright, awesome! Thanks.
Oh they passed the two milestone already? Good for them.
With that logic we should not have the `array` type hint because specific classes could be used instead… I always see this argument with core features like this, but many frameworks or libraries need to do low level stuff, and receiving "*an object*" is sometimes a perfectly valid use cases… Then the party gets ruined because some people will say that developers "should not do that" without thinking that libraries/frameworks they use every day could get a bit better with it.
Random example: https://github.com/symfony/symfony/blob/5129c4cf7e294b1a5ea30d6fec6e89b75396dcd2/src/Symfony/Component/Serializer/Normalizer/NormalizerInterface.php#L24 Another: https://github.com/symfony/symfony/blob/5129c4cf7e294b1a5ea30d6fec6e89b75396dcd2/src/Symfony/Component/Validator/Validator/ValidatorInterface.php#L49
It might be semantics but does his restriction against frameworks also extend to 3rd party php libraries? 95% of most modern frameworks just wire together libraries. Of course for a low volume website you could take this as a learning opportunity and actually write your own app from the ground up.
&gt; &gt; it is a Service Locator &gt; How is that any different from Symfony DI where the container gets injected? it's not. Correct! When you inject a container into another object, so that other object can retrieve its own dependencies from the container, you are using the container as a Service Locator.
IO ops are exactly the significant ops /u/assertchris is talking about. But request / response IO are just some of the IO ops in request processing. There's probably a database, other file IO, etc.
Wading through the jokes and cynicism; yes. These types of positions exist and are actually pretty common. Even better, certs and degrees aren't nearly as important as practical/tangible evidence of knowledge. I love seeing an applying developer post their Github/public repos on a resume (as long as it's not barren or 3 years to the most recent commit... ugh). If you've got a functional and actively maintained web application along with some publicly visible code, I don't see any reason not to consider you a candidate. This may differ for others, but those of us enveloped in this field understand that formal education is not at all required in order to be a good developer.
Thanks :)!
What specifically is it that you're having trouble with? The concept? The syntax? 
I use laravel and love it, it's quick to make stuff with it. 
https://laracasts.com/ has a lot of resources. It's biased towards Laravel, but it also has some courses on design patterns (https://laracasts.com/series/design-patterns-in-php) or SOLID principles (https://laracasts.com/series/solid-principles-in-php). 
[removed]
Well, just don't mix business logic with html. Example that i've seen too much (Warning! explicit, insecure and ugly code): &lt;form method="post" action=""&gt; &lt;?php if ($_POST['blabla']) { $insecure_data = $_POST['blabla']; } $list = $db-&gt;query('SELECT ..... '); /* ... insert other ugly and insecure business logic.... ... */ ?&gt; &lt;label&gt;foobar&lt;/label&gt; &lt;input type="text" value="&lt;?php echo $insecure_date; ?&gt;"&gt; &lt;ul class="nav navbar-nav"&gt; &lt;?php foreach($list as $item) : ?&gt; &lt;li class="nav-item"&gt; &lt;a class="nav-link" href="#"&gt;&lt;?php str_replace('@', 'at', ucfirst($item))); ?&gt;&lt;/a&gt; &lt;/li&gt; &lt;?php endforeach; ?&gt; &lt;/ul&gt; &lt;/form&gt; Use a framework or at least respect the basics of mvc and you should be alright. And finally, for god sake, sanitize and validate all user input before anything else and avoid using php super global.
A quick google and I found [this tutorial](https://www.tutorialspoint.com/php/php_loop_types.htm) that does a fairly good job of explaining loops to the new reader.
man, thank you so much for making this. You explained things really nice and simple. I shared it with my colleagues at the office and everybody loved it.
There is lots of love in r/php for Laravel, and they seem to have a decently sized community. I know of a few people that use it and love it, so it might be for you? I'm pretty biased, but I'd probably choose CakePHP: - Our [bake](http://github.com/cakephp/bake) tooling for code generation is second to none. - I'm absolutely in love with the [debug_kit](https://github.com/cakephp/debug_kit) toolbar, which lets me inspect various parts of a given request to figure out whats going on in my application. - The new ORM in CakePHP3 is pretty similar to sql alchemy from Python, so if you know any SQL, it should feel pretty straightforward to use. - We're pretty good about handling BC breakage, and have taken pains to backport features from 3.x to 2.x to ease that transition. - If you need api or admin generation, the [Crud](https://github.com/friendsofcake/crud) and [CrudView](https://github.com/friendsofcake/crud-view) projects are pretty pro. Again, I'm super biased (I'm one of the core devs) but I highly recommend trying a few frameworks out and seeing which approach you like best. If it's not CakePHP3, then thats fine, so long as you feel productive and write great code :)
So assuming I extend `Str` with a method called `rot13` that ROT13 muddles the string and returns `$this` it would not be chainable? I can't see why not? Or what do you mean "automatically"? class MyStr extends Str { public function rot13() { $this-&gt;string = str_rot13($this-&gt;string); return $this; } } $str = new MyStr('hello world'); $str-&gt;reverse()-&gt;rot13(); echo $str; // echoes 'qyebj byyru' This would even pass type checks if something is expecting a `Str` as a parameter or a return value. If you happen to need a baseline `Str` instance you can do $str = new MyStr('foobar'); $str-&gt;rot13(); $str = new Str($str); $str-&gt;reverse(); Please do say if I'm missing something here. Are you talking about inter-library extendability or something similar? :)
I've had good experience with Yii2. It's pretty simple to learn and at my previous job, we even modified it to suit our needs. It also has a lot of handy features like migrations, active record, etc. The community is pretty helpful too. Take a look at a couple MVC frameworks before starting. A little bit of research will help a lot as far as picking a framework that has all the features you need to implement your site.
Yes you could do that (you could actually just call reverse on the MyStr instance), In truth I've completely abandoned the Str static/instance class for this project though. I've moved everything to functions in their respective namespaces: Cfp\XString\reverse for example for reverse and there's a Cfp\XString\XString object that can reference it's own namespace when calling methods on and inflect functions from it's namespace to be used for chaining. So you could do $name = new \Cfp\XString\XString('john doe'); $name-&gt;reverse() and that will call \Cfp\XString\reverse on $name and return it's object to be chained some more. To add a function/method now you just define your function in the respective namespace. [edit] The way the new XString knows if it should return a chainable object ($this) or a raw result (which is generally a type other than the objects internal value should be) is via an internal check each class has. Each class that inherits from XObject has a protected method called _setValue which is called in the constructor and when the results of a method are returned to modify the objects internal value. _setValue returns true or false based on if value is proper type to be set in the objects value and if it was set. If true $this is returned, if false the raw result value from the function are returned without modifying the internal objects value reference.
&gt; With that logic we should not have the array type hint because specific classes could be used instead… Arrays can unfortunately be used in two very different ways in PHP, which makes this a more nuanced problem than that of generic objects. &gt; many frameworks or libraries need to do low level stuff, and receiving "an object" is sometimes a perfectly valid use cases The fact that a practice is in use does not make it a good practice. It's only a "valid" use case in the sense that people sometimes want to use it in this way, not in the sense that it's the best way to solve the problem. &gt; libraries/frameworks they use every day could get a bit better with it. They would be even better if they structured the code such that methods are not accepting arbitrary objects.
&gt; The knowledge that you may return something different from Parent will be available only at runtime (dynamic context). And the main point of type hints is to provide information about types in static context. Agreed, to a point. It probably is a bad idea to try to specify that the very same object is coming out. That doesn't mean we couldn't have something that at least specifies that the object *type* should be that of the actual instance. If we had a return type of *this*, then you could still perform a static analysis. The parent class is promising to return that actual instantiated object type rather than a type of *self*. &gt; Do not use inheritance. At all. (yes, in real life you will but try to think how to do things without it). That doesn't sound like much of a solution. In real life, inheritance is a valuable tool when used correctly. It shouldn't be thrown away because the language doesn't adequately provide a way to specify that the return can be the instantiated object type. &gt; Do not use return type hints for method chaining, IDE is understands when you returning $this. It doesn't have any value in your scenario. That's what I'm doing today, and it works. I was just voicing my wish that I could specify that a method clearly supports chaining, even if established at a parent level class. 
I strongly believe that in these crazy days you either do backend work or frontend. JavaScript world these days is so fluid and moving at crazy speeds, that a single developer while doing work is unable to keep up unless it's his full time job. And yes, you leave HTML &amp; CSS template development to a specialist too - depending on the size of you business you may not need a permanent position - just find a reliable contractor and you will be amazed (although we enrolled him on permanent basis after a few months because he opened up us to take on more work). Backend is a more stable environment, but there is a lot to do too. With the amount of stuff you need to know and have solid high-level knowledge and experience - you really need to focus on one or the other. In a hectic environment of a full-stack development people can't really focus on an area and innovate or build up the tools that make their work easier. Let's take my personal example - I'm one of those people that sticks to Windows, so I make use of Vagrant and stuff. But I had a problem - I had problem adapting any tools that suited my needs for automation and take care of the idiosyncrasies of Windows, VirtualBox, vagrant and general project setup problems. One day I decided enough is enough, so I found this wonderful provisioner called VaProBash, spent a few days tinkering with it on and off, then forked it, fixed issues and added quite a few things to it and to this day I maintain my fork, recently pushed a sizeable update that made my life even easier. I recon it saved my weeks of time not having to deal with things like re-creating my VMs, moving between machines on a whim and so on. Same goes for many other things - automation is king. But when you jump from one are to another all the time - you just don't have time for that - your context is always switching. I'm not even talking about the context switching - that stuff eats time like crazy. My context switch time is ~30 minutes until I can start working properly. Imagine the time losses. Doing both backend and frontend just leads to mediocre results and lot's of wasted time and lost profit. I have a first-hand experience with that and I can tell you with certainty - if you play this right, the overhead is gonna go down and you will be able to pay people very good salaries and attract proper talent in the future. Stars small, learn things, work out what proportion of what specialists you need for your turnover and reap the benefits.
/u/NigelGreenway talked about 20 + 1, where 1 is a traffic manager (probably just another Nginx instance). It doesn't make any difference whether this proxies directly to PHP-FPM or an Nginx instance in another container and then PHP-FPM. It's even one Nginx level less that can fail.
I haven't had any issues with the docs but I've only worked with Laravel for 2 years now. Its possible they have improved. For example, when I went ahead and added the `$schedule-&gt;quarterly()` method to cron (Kernel.php) They asked me to update the documentation as well, so other users can use the method. 
Guess I'll be setting up a GitHub account next then!
Hyper has a lot of other disadvantages. I can't remember all of them, but it doesn't have profiles, can't send control codes in input, has much less settings and is slowly than iTerm, — these are the most annoying. For common tasks it OK, but if you use terminal like a pro, then Hyper is not for you.
About a year to a year and a half ago I needed to choose a framework for my future in-house web apps for my company. Prior to this I'd worked with pretty bare-bones PHP, wrote one of our apps like that and reworked a few security competition apps in the same way. There hasn't been a day that I've regretted choosing Symfony. There's no framework that I've seen that makes me want to switch to it or lament that Symfony doesn't have some of it's features. Off the top of my head the main advantages for me have been * It consists of many decoupled [components](http://symfony.com/components) AKA libraires. You can pick and choose * It has a reliable and predictable release cycle * The PHPStorm Symfony plugin is amazing * The documentation is awesome, the cookbook is nice as well(though the PDF is a bit clunky) * There's not much magic. Or, to put it another way: There's no magic that bugs me/is too difficult to reason with, or it's all way above my head and I'm to dumb to be bothered by it ;) * Really really easy to make your own 'bundles' similar to plug-ins but the difference is [explained here](http://symfony.com/doc/current/bundles.html). I have a few bundles that I require on most of my work projects(e.g. A user bundle that handles LDAP authentication in our network, provides the model for users/roles etc) * Has a ton of existing bundles available for all sorts of things. I use it for personal hobby projects as well. Most recently I wanted to learn more about the console component and wrote a command to retrieve chat history from Twitch.tv through their rechat API. It was pretty quick to spin up which is a big plus for me.
 // Use a local instance of class Foo: $foo = new Foo(); $foo-&gt;bar(); // Use the globally available singleton object (requires no instantiation): Foo-&gt;baz(); I can't be the only one who always gets confused when a class can be used both as an instance, and as a singleton / statically. Every time I've ever mixed these two fundamentally different things in the same class, it's led to confusing code. A class should always be *EITHER* an instance, or a static/singleton. I've really never encountered a situation where the API of your domain or service layer is improved by this hybrid approach.
My solution to this in the past has been to pass an array into the object, but I agree, it really feels like just kicking the can down the road. Why not just pass an array into the function and validate inside the function? It feels cleaner to separate it out into a config object, but I always have this niggling feeling that all I'm really doing is moving logic around without any real benefit.
It's not always the case. From your point of you as a developer of the class, you know the internal. It's easy for you to validate an array. From a user who is using your class (this can be you later in time), having a typed structure gives you many benefits. It gives you mental model as well as IDE support and more. They don't have to open your class and find out the internal. 
Perhaps this generic solution can be of help? http://stackoverflow.com/questions/23078604/symfony-doctrine-using-setters-and-getters-dynamically
Yeah, I suppose if you come at it from a usability perspective instead of a purely code perspective, it makes more sense.
Yeah, that structure probably makes somewhat more sense in this hypothetical scenario.
What other scenarios do you have that does not make sense to use structure? Like phpdevster mentioned, you might be doing too much with your class or you are thinking just from your point of view. I can't think of a use case that is complex, but works better with just variables or arrays.
First, be sure to check out existing email solutions: SwiftMailer and PHPMailer come to mind. If you end up doing this on your own: &gt; You could pass in a PHP object with predefined properties That's what I'd suggest -- perhaps an `EmailMessage` class with the needed elements. &gt; how is that object formatted - does it have getters and setters I can imagine one that would have a constructor with the minimum necessary to build a valid object (from, to, subject, body) then getters/setters for those and everything else as well. (The setters might validate their data as they get invoked.) Regarding immutability in PHP: it's very difficult to do with anything other than scalars and nulls. Cf. &lt;http://paul-m-jones.com/archives/6400&gt;. If you go that route, be careful. Finally, your sending method can receive that `EmailMessage` and then either use the getters to build the parameters for sending via `mail()` (or whatever), or you can put a method on the `EmailMessage` that returns exactly what a sending method might need. 
I'm currently using Mandrill, I'm using their class directly as we utilize a lot of their specific functions (such as allowing IF/ELSE statements inside email templates, and passing variables in on a per-email address basis) and it was difficult to really abstract that out through a third party. The question was more in general though, I was just trying to think of an understandable example. Thanks for the feedback though, I think probably some of the issues in our current implementations tie around relying too much on Eloquent models whereas we should maybe abstract things out further (e.g. we have an EmailMessage already, but we also have a TriggeredEmail and a MassEmail, which are represented in the DB - we should probably have a way to abstract those all into a non-Eloquent EmailMessage which can be used generically.)
Something like this maybe class EmailOwner { public function __construct($email, $name) {} } class EmailMessage { public function __construct($subject, $body, $headers) {} } class EmailSender { public function send(EmailOwner $from, EmailOwner $to, EmailMessage $message) {} }
&gt; some of the issues in our current implementations tie around relying too much on Eloquent models whereas we should maybe abstract things out further /me nods Active Record is great for simple domain logic, but as you expand toward more (or more complex) domain behaviors, it can be hard to get away from. (That's why I wrote [Atlas](https://github.com/atlasphp/Atlas.Orm) -- as an alternative to Active Record that gives a better refactoring path.) Regardless, good luck!
I feel like my entity should just be the properties and a list of setters and getters, or at least that's what I've learnt. Do you have any resource to back this up? 
I've always set up my entities so that required properties were constructor arguments. The theory being an entity should never exist in an invalid state.
What makes you feel this way? If you have data that is required for an object to be valid then you should provide that data in a constructor. That doesn't mean you can't also have setters if needed.
Learn phpspec and some of these design considerations will emerge. Using arrays is a bad idea, your function should establish the contract with its signature; an array means nothing and makes tests painful. Further, favor splitting responsibilities and method signatures. Optional parameters that change logic are the root of many bugs. 
No, you're doing it completely wrong. Use the constructor. &gt; I feel like my entity should just be the properties and a list of setters and getters, or at least that's what I've learnt. Totally wrong, where did you learn that? The entire point of entities is that they can can be domain objects with domain logic. Where are you putting all the logic that belongs on the `User`?
Setters are there for mutable objects. I prefer immutability as much as possible. Also, some single property setters can bring your entity into an invalid state, where you would have to call 2 setters or infer a value of another property, based on what's set.
Do you recommend passing all the data in an array, or separate fields for each? 
Every documentation for doctrine2 shows setters and fetters? 
Documentation shows you how doctrine works, not how to implement proper design patterns. Documentation is usually dumbed down to be as easy to understand as possible.
I actually am not the author of this repo :/ But he will probably accept a PR :D
That's pretty much what I would've done, though I would ensure the password would've been ~~encoded~~ hashed, not plaintext.
Guess you don't need the set functions inside the entity, so just $this-&gt;email = $email; etc.
A common refactoring for long parameter lists is 'parameter object'. See here: https://refactoring.com/catalog/introduceParameterObject.html How you go about constructing this parameter object is up to you, you may want to read up on 'creational patterns', such as factory or builder. Another thing you could do in this example, which may also help you with future coding is to look at an existing library and see how that does it. For your email example you could take a look at SwiftMailer: https://github.com/swiftmailer/swiftmailer http://swiftmailer.org/docs/sending.html
The reason I wanna use a framework is because I've never written an API in PHP. It's not that I'm afraid of writing it myself, rather I'm afraid of leaving security holes in the API. The deadline of the project is next week, that's why I wanna use a framework.
&gt; the benefits of being able to reason about that argument via its class definition What are you even saying? What, exactly, is the benefit of "reasoning about a class definition"? The real benefits are: validation, assuming the class actually implements any, and bundling logic with state.
For a small online business, I would suggest to take a micro-framework. Keep as much loosely coupled to the framework, so you can switch if you need too. Use design-patterns that allow you to uncouple stuff, or couple to something else with less effort. (Did I mention I like the KISS-principle?) Good luck
I wanna use a micro framework, because the only thing I'm going to use the Framework for is accepting requests and creating the response. The logic between the request and response is written completely by me.
At no point does the article define "lightweight". Seems like the term is just used as an arbitrary descriptor. The article is clickbait and can be ignored.
Laravel is not very "lightweight". Slim is lightweight and also very popular for building RESTful API's.
&gt; The biggest thing that hurts Laravel, however, is the fact that it lacks a lot of community support that is enjoyed by other solutions. While third party implementations are great, they still pale in comparison to Ruby gems, Python PIPs, and Node.js NPM’s. What this ultimately means is that Laravel is powerful, but limited by its relatively shallow community support in comparison to its competitor support systems. I don't think the author spent much time researching for this article... 
You can get a PSR-7 request if you install a couple of libraries, and the framework will convert responses. https://laravel.com/docs/5.4/requests#psr7-requests
Looks like he wrote it years ago but only published today.
Strings are subtypes of arrays, BUT when dealing with utf8 specifically they don't work like most think they do. In ascii "Tom" is array with ['t','o','m']. But unicode allows multiple codepoints per letter and with languages like arabic you can't just split characters as the next character is determined by the previous characters, so if you reverse the letters for example it completely changes the letters or makes an impossible string.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Where in the world is Laravel lightweight..this just killed the article..if Laravel is there, where is Zend or Symfony. I would expect in this list Expressive, Lumen, Silex, Slim Phalcon
First, make sure you're using PDO. Then you can use `PDOStatement::fetchObject`
You have to construct some data to pass into `foo()`. Option 1: foo(array $data); Option 2: foo(FooConfig $data); Which of those is going to be easier to reason about when it comes time to construct that data? The answer is `FooConfig`, because you can just look at the `FooConfig` constructor and/or class properties to know what is and isn't valid. The generic array means you have to dive into `foo()` itself to understand what array keys are being referenced, how they're being used, and what values they should have. The former takes you 10 seconds. The latter will you take you much longer. Hence, a class definition is easier to reason about.
This does not at all answer the question OP has.
you said "lightweight" and then had Laravel as first.. hahaah what the heck? 
I can see how the example would be confusing with the abbreviated code. ```EmailBuilder``` would be a separate mutable class from ```Email```. It's basically using a mutable class to build an immutable one.
If only OP could put that in a function and reuse it. But I guess they'd type it a thousand times. ^/s Kidding aside, your advice is fine, although I'm not a fan of `::fetchObject`. It breaks the object encapsulation, like PHP serialization does, but it doesn't implement the standard hooks PHP serialization support to put this under control (i.e. `Serializable`, `__sleep`, `__wakeup` etc.). So when using `fetchObject` it's short and performant, but for any complex objects, especially ones whose data schema will evolve over time, it's like driving with your eyes closed, and hoping the road is straight.
Putting DB queries in your model classes is usually considered a violation of the single responsibility principle. A better approach is to have two classes: a lightweight model class that is not coupled to you database, e.g. Car, and a service class responsible for executing queries and building objects e.g. CarRepository. Then you can get stuff from the database like this: $carRepo = new CarRepository($pdo); $car = $carRepo-&gt;find($id); You can then add new methods to your service when you need new queries ie. $fordCars = $carRepo-&gt;findAllByMake('Ford'); There are ORMs that will do all this for you. Take a look at Doctrine2
What is useless in the list according to you ? 
Just to add, putting the query in your model class is essentially what active record orms do via inheritance and there is an argument that these are quicker and easier to set up but I prefer the OO purist approach
&gt; Putting DB queries in your model classes is usually considered a violation of the single responsibility principle. The active record folks will be so disappointed to hear this. Be careful. This is a very Laravel friendly site. Can you guess the default pattern for Laravel database access?
I agree with this in principal and it is the method I've taken more often. However, you can describe the array parameters in your docblock as well, which can be helpful in IDEs.
Well, I'm doing a lot more than that. I'll have a lot of query options bound to an ElasticSearch database, as well as supporting mutations, etc, through it. Just wondering if there's anything anyone wishes they had known before starting - might be that there is not.
Mutations are just a list of commands, so it's relatively straightforward. The variables, functions, directives and so on are folded by the GraphQL parser so you don't have to deal with that. One thing I'd personally recommend is to skip the "middle man" and pass queries and mutations directly as JSON, because GraphQL as its own language is really not that necessary. GraphQL has the right idea for the structure and semantics of the final query/commands (the JSON format). But the "text" being sent? It's basically 90% there being JSON itself. It doesn't provide value IMHO.
My thought is that the value is that it's a documented standard. This is going to be available as a public API as well. We also need to support passing multiple filtering options into the queries (e.g. give me all customers in Los Angeles, and their addresses, and payments, but only payments where the date is after 2017-01-01, etc) which is pretty nicely laid out in the GraphQL standard.
Interesting read. I wish the author gave more details about the 45k emails they have to send at times.
If I understand correctly Composer install , installs all dependants based on your composer.lock Composer update, installs and updates all dependants based on your composer.json and creates the composer.lock Install times often vary in DNS... write speeds... and the number of sub dependancies 
Take a look at yarn pkg though. It's a drop-in replacement for npm which does exactly the same thing + extra, yet it's done in like 10% of the time. Edit: xdebug is disabled btw.
I do use vagrant, but I run all non-env specific tasks on the host machine. So things like `composer install`, `yarn` or `webpack` is all run on the host machine.
My question isn't about the download size. The downloading itself is reasonable in terms of speed. There is a ~30+ second delay before anything even starts downloading. Why is that delay there? That's my actual question.
At the end of the day, there could be a few dozen different variables that affect the speed. From network and DNS latency to GitHub throttling your API calls. Personally, I've never seen 30+ second pauses like you've described. Maybe Composer has some built-in tools for profiling its calls? I've never checked, but if I wanted to know which part of Composer was going slow, that's one of the first things I'd check. Edit: [Yup, `--profile` is a thing.](https://getcomposer.org/doc/03-cli.md#global-options)
&gt; Yet it takes way longer than it has to. How long does it have to take?
Maybe you should stop asking for AWS. I know AWS, but lets be clear, anyone who had work with google cloud or azure will know how to use AWS in a week or two. (This isn't true if you're looking for architecture engineers)
- What packages is there? - `packageA: ^1.0` - `packageB: ^2.0` - What package can I install? - versions `1.0.0`, `1.0.1`, `2.0.0` are available for `packageA`; only `1.0.0` and `1.0.1` match `^1.0`, pick `1.0.0` - `packageA: 1.0.1` has deps on `package1: ^1.0` and `package2: ^1.0`, etc. - ... - there's only `package1: 2.0.0` found for `package1: ^2.0`, but `packageA: 1.0.1` required `package1: 1.0.1`, so need to find a version suitable for both... operation either successful (continue the deps resolution) or not (you get a conflict) It may not be _exactly_ what Composer is doing, but that's the idea, and that's what we mean by resolving the deps: going through the packages to get a tree of fixed versions you can then install. My point above about JavaScript was to say that JavaScript can actually skip this step as you can avoid having this kind of conflicts. However if you ask yarn to flatten the tree which is basically what Composer does, you'll see that it is much much slower.
Above
Composer isn't going to solve your Phalcon problem. Phalcon is a framework that gets its speed from having the framework actually compiled into a PHP extension. You cannot install PHP extensions with composer. They need to be compiled, or installed via a package manager. Other frameworks are just code, which can be installed with composer. Or, if you can't get composer on the server, you just use composer locally, and commit the vendor directory so you don't need to run composer on the server. Choose another framework. Symfony, Laravel, whatever... recognize that Phalcon isn't the best tool for the job in your case.
It tends to be the convention you find around projects. I don't think it's explicitly mentioned in the PSRs. It's traits, then everything else for me, as well.
Haha that's a good one!
This. Use statements are always the first thing in a class body. Why? Because they are related to class extension/composing.
First thing after the class opening brace. You wanna see everything that the class is, extends, implements immediately. Don't bury it somewhere below.
Inside this [class](https://github.com/EnMarche/en-marche.fr/blob/e6d33b8069934b8bb126c7411806b202ce194e86/src/AppBundle/Repository/ProposalRepository.php), there is after method declarations something like &gt; function findOneBySlug(string $slug): ?Proposal ": ?Proposal" I haven't seen before those? To me it looks like something like ternary operation, but I may be very wrong. Hard to google something like that and haven't seen before in php documentation. 
":" indicates the return type (new to PHP7). &gt;function findOneBySlug(string $slug): Proposal Means that the method will return a Proposal. "?" indicates that it's nullable (new to PHP7.1) so &gt;function findOneBySlug(string $slug): ?Proposal Means the method can return either null or a Proposal.
Ah. Good to know. Thx. 
Thx
I understand it can be a bit strange when it appears to be sitting there doing nothing. However if you use `--verbose` it's interesting to see how busy it actually is during that period.
What is the case to solve here? I've never seen "use" like that inside a class.. Teach me!!!
that's not exactly a PHP problem. how about asking their support?
The reason I have added that function is, PHP is returning some garbage(some spaces or newlines) WITH whatever desired echo I am returning. So, I am cleaning up with this function. Is there anyway to stop that garbage value itself? Or is there any alternative for this function?
Did you hear of git and .gitignore? Pretty much does what you do with a script. https://git-scm.com/docs/gitignore
I am doing the same, but automated, using Ant in a build / deploy target. For example: https://github.com/odan/prisma/blob/master/build.xml#L162 https://github.com/odan/plasma/blob/master/build.xml#L190 
Pretty much the same for people who `git export`. Not the same at all for people who download a zip and upload to a server, which is most of my user base.
Interesting, though this is sort of what I wanted to avoid, ie manually maintain a list of files to delete
Honestly, none
[removed]
After Google Reader died, I get 99% of my PHP news from popular PHP devs on Twitter.
In practice, you do this only once. In your script you have to maintain the files you want to keep. In both cases you have to maintain your script anyway.
For discussions, I just come here. Finding anything php related outside of this subreddit always ends in someone talking shit about the language even though they haven't touched the language since 4.0.
Or you can use https://github.com/tavy315/composer-cleanup-plugin
Again, this sounds like a godaddy problem. Seems they are rewriting your source files. 
If you have lot of dependencies, the tests and documentation can increase the size and number of files in your app significantly. For [selfoss](https://selfoss.aditu.de/), I think it was more than tenfold. This does not matter for commercial operations but it is quite important for open-source web apps, which are often hosted on shared hosts with petty storage quota, and where slow FTP is the only option to deploy the app.
I don't visit a lot of discussions.... infact this is pretty much the first one i visited in a long time... In order to be updated i usually hang around in stack overflow and try to answer as many as possible.. For those that i don't know the solution of i stick around till someone else answers that... Usually after some time you don't need to go around a lot of discussions.. php.net has awesome documentation for everything unless you plan on contributing to php core in which case just use there IRC channel... Hope this helps you out :D
Many are missing out on the "why" of this, and for that I can help out. When PHP projects get fairly large, you end up with a lot of dependencies, and those cascade into even more dependencies. If you're being smart and creating tarball copies of your releases, you deploy these by some form of `wget | tar x`. This, now, is where the test/docs/etc reduction becomes important -- it turns out that removing all those little, totally unused files can have a major impact on your extract time, which in turn means your deploys can speed up quite a bit. In practice, I've seen a real codebase shrink from 140,000 files to _half_ that size through cleanup techniques like this. That's a lot of savings in build time, a small savings in build size, and a big savings in inodes usage.
Medium, laracasts
Are you taking remote devs? I'm currently looking.
nope sorry.
I made a list: https://twitter.com/Ocramius/lists/knowledge-roi
my guess is that second example is better. it's cleaner and closer to others "use" outside the class
Most general, language agnostic programming subreddits (like r/programming) usually just thrive on interesting articles, guru-tales and occasional drama. It's fine, but you aren't going to get the news you like, no matter your language.
&gt; is intended for files that you do not wish to track in version control Which is why its literally the perfect solution. You get to keep all the tests and documents locally, and push a clean commit to production. A scorched earth approach--removing everything other than things you think you may need--never works out well... Ever.
If you keep the tests locally, how do you track their changes or share them with other developers?
Depends on how you wanna do that. Personally, I don't know why you wouldn't use git. Just add the tests directory to your main repository's `.gitignore` and then track the tests directory independently. Then just share the test repo?
Unfortunately, `git archive` is already used for exporting source archive, where tests are desired. Unless git supports different archive targets (like `export-ignore=production`) it will not be of much use.
The scenarios are pretty marginal but major libraries like Symfony still decide to keep them. See [Symfony discussion](https://github.com/symfony/symfony/issues/17749#issuecomment-192172162).
You now have multiple repositories for a single project. Each time you change some part you have to commit in at least three different repos (code, docs, tests) and then all your colleagues have to pull in all the repos on their computer. While OP’s solution is far from ideal, at least the related changes happen in the same repository.
Jetbrains has some nice news letters, the PHP one is here https://blog.jetbrains.com/phpstorm/2017/05/php-annotated-monthly-may-2017/
&gt; You now have multiple repositories for a single project. No, you have a single repository for a single project and you're tracking your tests independently in a portable manner--which was your requirement. I personally wouldn't track the tests at all. Why would you __need__ to? &gt; Each time you change some part you have to commit in at least three different repos Or just write a script which intelligently commits to both repositories? Why are you trying to make this sound __way__ harder than it actually is? &gt; While OP’s solution is far from ideal OP's solution is __literally__ trash and If I ever saw __any__ of my developers using it in a _production_ environment I would probably _seriously_ reprimand them and depending on the situation, I would probably even consider letting them go; &gt; rm -rf "$1" I mean Jesus Christ... To actually use that on a production server? Unconscionable.
I visited sitepoint a lot..but the changes to their site made it almost not usable..I also have an RSS with like 500 subscriptions..that is a pretty good source
&gt; No, you have a single repository for a single project and you're tracking your tests independently in a portable manner--which was your requirement. I understand tests as being a part of the project. &gt; I personally wouldn't track the tests at all. Why would you need to? Solving conflicts without version control is too much hassle. &gt; Or just write a script which intelligently commits to both repositories? Why are you trying to make this sound way harder than it actually is? Which is extra work in comparison to having a single repository. &gt; OP's solution is literally trash and If I ever saw any of my developers using it in a production environment I would probably seriously reprimand them and depending on the situation, I would probably even consider letting them go; It is not meant to be run in the production environment. The post title literally says “before sending to prod”. &gt; rm -rf "$1" I agree that deleting files can be dangerous and that is why we avoid it in [our build script](https://www.reddit.com/r/PHP/comments/6c9n8g/clean_up_script_before_sending_to_prod_remove/dht3g3h/), but in this case it quoted correctly.
All of these arguments are entirely superficial. &gt; It is not meant to be run in the production environment. ...read the treat title... &gt; Clean up script before sending to __prod__ (remove /\*\*/tests, /\*\*/docs, etc) You don't "clean" up a development environment for a __production__ server by using `rm -rf`. That's total fucking lunacy. There's almost no way to roll back a fuck up via `rm -rf`. &gt; I understand tests as being a part of the project. Also, tests are very important and _are_ part of a project, but that doesn't mean they need to be tracked _with_ the project. Unless you're releasing software for public consumption tests should be local...
&gt; ...read the treat title... Have you? &gt; Clean up script **before** sending to prod … &gt; You don't "clean" up a development environment for a production server by using rm -rf. That's total fucking lunacy. There's almost no way to roll back a fuck up via rm -rf. Of course you do not remove the files in your development directory or on production server. On the other hand, it is a fairly reasonable solution on a fresh clone or on a CI/CD runner. &gt; Also, tests are very important and are part of a project, but that doesn't mean they need to be tracked with the project. Unless you're releasing software for public consumption tests should be local... Well I prefer the simplicity of tracking all parts of a single project in the same VCS repository. I do not understand how tracking them with the project would make them not local.
There is package for that, you might like: composer-cleaner - https://github.com/dg/composer-cleaner
Thanks!
I probably just forgot, but also, he mostly tweets about Amiga stuff these days. There are loads of people that aren't in the list that I could just add, if notified.
I frequent pornhub. Very informative.
&gt; Clean up script before sending to prod Yes, and if you "accidentally" remove project critical files by being an idiot then __OOPS__ you're fucked unless you were tracking that folder/file. Just because you're not running the script _on a production server_ doesn't mean it's totally fine to run. I sincerely question the state of mind of _anyone_ who runs this script. Seriously. There's nothing worse than losing tens or hundreds of hours of development time because you were stupid for 5 seconds once. Having the script move all the unwanted files to `/tmp` would be an __infinitely better solution__. Because at least then you have until the next reboot to recover the files if you found out you _did_ make an error. The very fact that this has to be discussed with someone who claims to be a developer is just...imbecilic.
As a periodical, [php[architect]](https://www.phparch.com/) puts out good content. Offers print and digital subscriptions. Not beginner-level, but pretty varied.
wow - that would have been my nearly last guess who the culprit is. but cheers to another mystery solved!
Work? What's that?
http://www.phptherightway.com/ has been a very useful overview on a lot of things for me lately.
https://externals.io
[SwiftMailer](http://swiftmailer.org/)
Yeah, I am planning to experiment with that library once I get started!
laracasts.com
Thank you!
javashit is the worst language. But if you mean the real revolution you are missing out on preprocessors, Family class templates, Transactional memory, User defined operators, OOP designed Standard library, Lockable variables and the list goes on.
it's not a PHP / developer publishing site. its a best practices documentation site.
If you didn't have anything to contribute, why post anything at all.
https://web.archive.org ... Haha just kidding we like to have fun here
Docker containers make a lot more sense when you think about them as [*roles* within an architecture](https://valdhaus.co/writings/docker-misconceptions/) rather than single processes. It's not like they had the entire kitchen sink installed in their prod container: just nginx + FPM. "This runs my webapp," is a fine way to do things. Even when I'm using separate containers, I'm usually running an nginx + fpm container on the same host and within the same task definition (to use AWS terms). Certain things, like logging and build times, get easier in multiple containers though.
GET and POST are two different actions - if you pack two (or more) actions into one controller, by internally testing the properties of the Request object, your controller is doing the router's job. The request should be fully resolved before the controller is dispatched - in most cases, that means the controller should never even see the request.
He asked what I read, not what do I recommend. No wonder this subreddit is so dead
nice! I need to do some calculations in the next few weeks, and you've just saved me a job! Thanks!
This is probably something I can use. Awesome. (I just really wish you'd capitalize class names tho...)
I don't know why you're telling *me* this. I'm merely using the code given in the article. Plus... you're not correct. The router is part of an application's "front controller", i.e. it's already a part of the controller. A part that selects a more specialized controller. How much more specialized, and how many levels of specializations a given request goes through is entirely dependent on the specific app. I.e. a router may call a controller that is itself a router, that calls another controller that is itself a router and so on. That's perfectly fine. So while you keep saying "should", there's no "should", here. A router just selects a route, then forwards the HTTP message there. That's all it does. How and why doesn't matter. Like an Internet router, which is where the name comes from. Your browser's request to read this very comment right now has gone through a graph of routes about a dozen levels deep before reaching Reddit's server. To say that at the application there should be just one router and it has to absolutely take the HTTP method into account is completely arbitrary. Something being a common convention doesn't turn the convention into a best practice, or let alone a rule. And what does "fully resolved" mean, anyway? What if the URL contains data coming from a database? Like an article id, or a comment id under it? Must "the router" do anything that it takes, including doing direct database queries in order to "fully resolve" before a controller is called? Not at all. 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I can highly recommend this free series by laracasts: https://laracasts.com/series/php-for-beginners
Thanks I will have a look at it and see how I get on. I need to find out what things I need to start as well cause starting from scratch.
https://www.youtube.com/user/phpacademy/playlists has good series for beginners https://laracasts.com/series Also a good resource for beginners http://www.phptherightway.com/ A good read to know how to use php correctly and avoid security complications 