If you want to build quality applications, and not use 20 years to do it, why would you build everything yourself, especially when there's tested and reviewed components out there? Personally, I have no desire to program tools, but have every intention of using the tools that's proven to be good. I get to use my skills the best as an application developer and the people behind the tools get to use theirs.
That may be true, but that nevertheless I can not find a single legit argument why to use spaces for indentation. Let's use PSR2: that is because one or two more projects uses spaces than tabs. No rational argument behind. Things I hear is "diffs work better with spaces", "when we use spaces, the code is the same for all involved developers", etc. That is all bullshit and the second argument is one of my favorites: if you use tabs, each developer can choose his own indention size but the code is the same for everyone. Spaces limit you to the one agreed upon indention size. But all rational arguments are lost with spaces-fanboys. 
Laravel will win anytime for a few reasons: 1. It tries as hard as it can to be easily enough to be picked up by any new newcomer. Laracasts and making the code more easy to work with (_even if sometimes that means to break some rules and patterns_) are helping to achieve this. 2. Because it is mostly used by small shops and beginners, it will result in a myriad of google searches, forum posts with questions which will boost metrics for that framework ; metrics which sometimes are used in a comparison. 3. Also #2 will push the framework's name in everyone eyes, making more people interested to see what is all the fuss about. Many of those people will be beginners or hobbyists which will find that framework good for their needs and stick to it. &amp;nbsp; As a side note, including frameworks from different categories in the same comparison is not really fair. &amp;nbsp; Developers from the enterprise don't (_and never will_) use Laravel or _fairy tales_ to get their job done, because of their expertise which will find the flaws in those frameworks and requirements of the enterprise sector, which will make them in a _no-no solution_. - They will use a framework that fits in that sector and at this point in time there are only two of them in PHP world: Zend and Symfony. - They will get their training via [official](http://framework.zend.com/learn/training-and-certification/) [ways](http://training.sensiolabs.com/en/training/courses), not from google searches, forum posts or watching videos on youtube. So surveys which include those metrics will create a disadvantage for those frameworks. - They don't have much free time and sure enough they will prefer to spend it in other ways, instead of searching the net for surveys and vote for the framework they work with. So in many of these surveys, frameworks used in the enterprise environment are somehow disadvantaged. You can see this even from this survey, because there are a few people over 35 years old who voted. &amp;nbsp; My conclusion from a while back is that you can't make such a survey which could reflect the reality very good. At the very best you can get near decent results.
I'd Say it's an optimisation issue. If your hardware is more expensive than your developer, do optimisation. If your hardware is cheap and programmer-hours expensive, just buy more servers. 
Still better than not speaking up at all.
16 and you have a deal
This is an excellent response. While generalized benchmarks like this are good, they are not the end-all-be-all indicator of a framework's overall performance. But, it can be used as one of hopefully many watermarks for deciding to use a framework. The biggest thing that the stakeholder deciding which framework to use needs to do is to first analyze the current website traffic patterns. If you don't know what your demand is, then no benchmark in the world will help you. Sure, you could shoot for millions of requests per second, but if you only get 100 requests per minute, why waste the time and effort? As /u/mr_tyler_durden said, developers are expensive.
Namespace aliases are useful for humans reading xml and because it results in a serialization that needs less bytes. But a lot of people fall in a trap to rely on a specific alias, when it should have no influence over the canonical element name. But back to your point: it was simply too hard to do prefixes well and not break some of the other design goals, and in practice I found it not really that frustrating. Granted though, it's definitely a little frustrating.
I can appreciate you wanting to share some knowledge, but please, as you are still extremely early on in learning how to program, don't try to share your current knowledge and pass it off as an example to be used by others. This is exactly what damages the PHP community, and the language shall not be taken as seriously as it deserves to be if tutorials made by novices are still being presented as examples. In a modern application you'd use a routing component, or at the very least - something easily expandable, and configurable. Also `?id=4578&amp;do=edit` – ~~Parameter string~~ Query string.
Thanks for the feedback. I do have plans to write tests. hah I know that my entities aren't entities, I just couldn't think of a good name for the directory at the time. Value objects are exactly what that are (as their content defines them) I'll look into the decoupling of the data and the value object. I didn't use guzzle (although I thought about it) because I didn't want it to have any dependencies. I completely agree that it would enhance the library though. The cache age generation will be moved, I plan on putting a cache adapter into it in the future. I just didn't want to yet because I'd like it to adhere to PSR-6.... if it ever gets finalized :| As far as the chaining calls, I kind of modeled it after the structure of the return data from the Forecast.io api. in the json you'd use the same path.
Fair enough :P
Like what?
And that's what they call "a good problem to have"! There are very few applications that have to run at such scale.
Nothing Microsoft about it. https://github.com/php-fig/fig-standards/blob/master/index.md
It is PSR-7. It says that in a lot of places, including the top of this page.
i just find it odd that psr-7 will be released before 5 or 6
I'm using it right now for simple local UI testing things. The built-in web server makes my life so much easier.
I actually don't get your question. Do you want to allow to select one answer per question or to select multiple answers per question? If you just want one selected answer out of four for each question, you just have to use different names for the radio buttons of each group, e.g. Question 1 here &lt;input type=radio name=q1 value="a1"&gt; Answer1 &lt;input type=radio name=q1 value="a2"&gt; Answer2 &lt;input type=radio name=q1 value="a3"&gt; Answer3 &lt;input type=radio name=q1 value="a4"&gt; Answer4 Question 2 here &lt;input type=radio name=q2 value="a1"&gt; Answer1 &lt;input type=radio name=q2 value="a2"&gt; Answer2 &lt;input type=radio name=q2 value="a3"&gt; Answer3 &lt;input type=radio name=q2 value="a4"&gt; Answer4 If you want to allow the selection of multiple answers of one question, that is not possible with radio buttons.
I use it for development all the time.
Hey thanks for the conversation starter. However, you don't know the link to self all the time. In the REST dissertation, Fielding says that REST systems should only need to know one single point of entry. So yes, you need to know that you can start at say, /api, but you could end up at /api/orders/42/items/37. You would start with /api and follow the links to get there, which are your affordances based on the application state, by following RELs. It's the same idea as knowing that if I went to Wikipedia, Clicked English, then clicked Help. The alternative is memorizing that Help is located at http://en.wikipedia.org/wiki/Help:Contents
Also, more importantly, Hyperdrive doesn't say you NEED links. It says you need an awesome Star Wars quote in your API. What's more important? You be the judge.
I think you should first use code from professional, then try to implement it yourself, when you are not satisfied with existing one. When you omit "use code from professional" step you are actually (I think) will learn much slower, because your own mistakes are very slow and costly feedback. Also this is unprofessional behavior for me, when you charge money for your learning instead of using proper tools and make work as best as you can with your current skill.
Each *set* of radio buttons should have the same "name" attribute - its purpose is to group the buttons. So any radio button with a different name will be part of a different group. You probably want to do something like $i = 0; while($row = $result-&gt;fetch_object()){ echo $row-&gt;question, '&lt;br&gt;'; echo '&lt;input type="radio" name="q'.$i.'" value="a" id="q1a"&gt;&lt;label for="q1a"&gt;' . $row-&gt;ans1 . '&lt;/label&gt;&lt;br/&gt;'; // rest of the input for this group here $i++; }
&gt;&gt; I think it would be reasonable to have something a bit more reasonable, like $forecast-&gt;current()-&gt;temperature(); &gt; That would still be breaking law of demeter. I don't think LoD is very popular around [here](https://www.reddit.com/r/PHP/comments/30fuwg/anyone_here_using_readbeanphp/cptetaf).
yep
Seems like you're still not understanding how the HTML works. Each radio button in a *group* needs the same *name* attribute. Each group should have different name attributes from each other. The row-&gt;id is your question ID. Each time round the loop is one question, one group of radio buttons. So the first time it will output `name="q1"` for the 5 options, the second time `name="q2"` for the 5 options on Q2 and so on.
Coworkers use it during development for manual testing. 
Nope, never used it. It's pretty trivial to run a local "real" server at least on linux.
Anyone using Laravel's `php artisan serve` for dev does.
highfive
Right, often small conversations happen on GitHub but bigger things need to be discussed on the mailing list. Typo in the PR? Point it out on the PR. Syntax issue on the PR? Point it out on the PR. Spotted a bug on the website? Make an issue on the website. Think a method should be renamed or some classes should be split in two? Get on the mailing list, a lot more people than those who happen to subscribe to the repo will care about this. This is not some confusing rule, its fairly simple. If somebody says "take that to the mailing list" they aren't shouting at you, they're saying "this is a topic than the mailing list should know about." How that is a problem in anyones eyes is utterly beyond me. :)
Think of it this way. So I'm building an application to text me when it's going to be hot. Since I'm lazy I want to use pre-made code. I find your code and decide to use it. Since I have a habit of randomly breaking random code I test my code 100% to make sure I don't break anything. So say I create a class to tell me if it's raining. I have a function called is hot. To test that method I would have to create a mock of your Overcast class, a mock of your forecast class, a mock of your daily class, a mock of your temperate class. That's a lot of mocks for something so simple. My code is now dependant on all those things working as they should. Now if we apply law of demeter. You code stays the same, the way you deal with it, all those value objects representing data in a programmatically way remains. However when I want to use it and test it I'm mocking a lot less. I'm not only mocking your overcast class and forecast class. Now lets also have a think about it this way. How often when I am getting the forecast am I actually interesting in getting the temperate for that forecast. If I want another day or time I'll fetch that or I'll ask for that via your object. 
Why use PHP over C? In all seriousness, carbon is full of lovely. I do still typehint on ‘DateTime‘ tho for for function arguments. Also, there's not enough love in the community for Period yet. Fingers crossed Carbon and Period merge into the best thing ever. Edit: I would live with Period returning Carbon objects by default and keeping the packages separate.
&gt; Think a method should be renamed or some classes should be split in two? Get on the mailing list, a lot more people than those who happen to subscribe to the repo will care about this. here is the problem with that. how do i know if this is not being discussed already? how do i know if there is not a patch already proposed? if someone thinks the same how can they find my proposal from two months ago without reading two months of emails? how can i know how many differents proposal to refactor that method are there? &gt; This is not some confusing rule its is not intuitive. there is a difference and as developers we must understand it. intuitive design always is preferred by anyone no matter how 'not confusing' the alternative is. &gt; How that is a problem in anyones eyes is utterly beyond me i had problems understanding that some users don't want to load the info of their shipment on a new page and preferred a pop up but they did. personal preferences are never an argument and you know it
`Random comment of the day`: Shouldn't you commonly typehint for `DateTimeInterface` as `DateTimeImmutable` works fine most of the time (Atleast in cases where you can guarantee 5.5+)?
I'm not sure if I'm following your example. You go from /api to /api/something, and GET /api/something. In order to GET it, you know its link. Why is it a scenario where you forget the link to the thing, but remember the thing which has its link, so you can get the link back? REST suggests we use one entry point for APIs but it's incorrect to interpret this as forbidding machine bookmarking. And if you would insist that machine bookmarking is forbidden, then providing "self" links doesn't get you off the hook, because using the "self" link later also qualifies as bookmarking. Except you're "bookmarking" the whole resource state in order to read the "self" link later. It's kind of like "I did not murder this person, he just fell on my knife 18 times" workaround to what you suggest REST recommends. To know if something makes sense, it helps to forget what paper X says, forget the philosophical and semantical interpretation of a design and look at it from a practical perspective. I'm not saying semantics don't matter, but let's take a step back and see what we're doing. A recommendation like REST is only as good as its practical benefits. If our APIs are performing strange magical rituals that make no engineering sense, only so we match a recommendation from the gods in the sky, it's a sign we have to rethink the recommendation.
to be fair it kind of is. python can run one pretty easily too (and that's installed on pretty much every linux system out there) Still, i think the internal PHP one has it's uses.
You have to consider inertia. Of course you won't use it because you already have a working dev setup for a version of PHP without an internal server. I also didn't use it at all. Then one day I got a new computer and while setting up my dev environment I went "hmm", and I started using PHP's internal server. I still do. So that's how it goes.
How do you connect to database with it?
That's really impressive.
what?
I've used for my online course on Basic PHP. It eliminates the need of explaining web servers and how to install them in detail.
Again, I don't want to continue this thread because it confirms by original premise that devs can not agree on spaces or tabs. 
You're making a mountain out of a mole hill. &gt; how do i know if this is not being discussed already? Somebody will tell you. &gt; how do i know if there is not a patch already proposed? Somebody will tell you. &gt; if someone thinks the same how can they find my proposal from two months ago without reading two months of emails? A few people on GitHub pay attention to both, and they will tell you. There is also an awesome search feature, which searches the one mailing list instead of making you search across multiple repositories in an organization, and across multiple forks of those repositories. &gt; intuitive design always is preferred by anyone no matter how 'not confusing' the alternative is. Lol we aren't designing a website, people just direct you to the centralized source of conversation when you accidentally post in a place which wont get noticed. What is the problem?
I use it quite often when I am prototyping a new REST service or experimenting with a new framework. Easier than spinning up a vm.
&gt; In addition to performance, there should be substantial memory savings, as optimization of internal data structures is one of the primary ways in which performance improvements have been achieved. I've seen a lot of benchmark stats about speed but it would be great to see some numbers to back this up. Still very exciting!
If you can't figure this out just from reading the documentation, you should not be trying to write software at all.
This is really interesting (although a bit over my head!) - could you add some examples with these systems and php please?
You will probably still need javascript to handle changing the form elements when the dropdown changes.
Nope what is it?
best article title ever
&gt; Since I'm lazy &gt; To test that method I thought you said you were lazy :p I get what you're saying though, some convenience methods could be added, while retaining the current structure
What is Period? Link?
Vagrant is your friend here, you can use resources / load config for a project only when you're working on it, and you can develop in a (semi) isolated environment.
FYI, UVS still doesn't permit calling Closure properties like methods: http://3v4l.org/LXMJZ but it does allow you to wrap it in an expression: `($foo-&gt;bar)();`
[Lots of reasons](http://carbon.nesbot.com/docs/) $start = new Carbon('2011-03-05 13:45:00'); $end = new Carbon('2012-06-05 21:17:00'); if ($start-&gt;gt($end)) { echo 'start is after end'; } $start-&gt;addHours(6); $end-&gt;subDays(2); $daysBetween = $start-&gt;diffInDays($end); if ($end-&gt;isWeekend()){ echo 'Sleep Late!'; } $now = new Carbon(); if ($now-&gt;between($start, $end)) { echo 'yep, it's between the dates'; } Carbon lets you manipulate, compare, format, etc dates and times MUCH easier than the built in php functions do.
We do ... in a VM. Many people dev on their main box and use samba or NFS shares with a VM that closely resembles production. Doesn't negate the usefulness of the built in server to test little things when you need it.
Haha, you were left hanging!
nice! best orm by far
Mostly it is whatever my host gives me.
That's where it's awesome, there's a very simple option to do URL rewriting (i.e. redirect all requests to a single file). Saves me from remembering how to do it in Apache/Nginx/… It's used by e.g. Symfony `app/console server:run`.
The thing is when you checkout ~ a github project per week, and there is no vagrantfile, and you will only spend a few hours on this, you don't want to configure and create a VM every time. A single command does all that for you. I do see the value of Vagrant in big projects though! But for simple projects, the CLI server is much much easier (and faster to set up).
I disagree. The majority of third-party software packages can be hard to wrap your head around without reviewing use-cases and digging into them; software developer or not. Not a very supportive thing to tell someone.
You are quite right, updated and clarified the nested `::` example also. Thanks!
If it wasn't for doctrine php would be dying by now, for better or worse. 
&gt; simply search for active issues Yeah, simply search through conversations on multiple repos spread over various different users repositories and forks, instead of one centralised location. I think you're really confident that you have a good point here, but in reality the way you think it should work is a pain in the ass and it did not work at all. If you comment on GitHub and we think it would be better on list, somebody will just tell you to take it there. 
I will probably use PHP 7 by default, and use Hack if there's a feature I need.
The best way to run a development environment. They're all virtual machines, you can spin up a Linux box with LAMP with a half dozen lines of code, spin it down then spin up an nginx machine with another half dozen lines of code. No more tweaking environments per project. Screwing with configs to run LAMP and a PHP server side by side or whatever. Done with a machine, trash it. Replace it in seconds. 
Does PHP have Repo Auth Mode? If not, benches won't be the same :) I'm currently with HHVM. I will be moving my code base to hacklang. I don't ever plan switching to PHP 7.
https://www.youtube.com/watch?v=vgk-lA12FBk
It's powerful, because it's a subset of SQL. One day, who knows, they might provide all of SQL. Imagine one day having full SQL in PHP. I'm getting pumped up just thinking about it.
For all intents and purposes, that's what the SQLite driver does.
Not that I am aware of
Sarcasm detected? Jokes apart, we are indeed moving more in the direction of abstracting mappers and getting rid of forcing the user onto SQL. Assuming that there will be a Doctrine 3.x somewhen, I really want it to be DB agnostic, as in compatible with nosql/sql/graph/tree databases interchangeably.
Very sorry for the long wait, but pretty much all the team members were affected by multiple job position changes, and to be honest, the Second Level Cache *really* wasn't ready for a release 6 months ago. I'm actually happy that it took longer and that we went this slow and careful with it: - the test suite coverage increased by a lot - we had the chance to refactor some major headaches - a lot of quirks and issues that required internal BC breaks were fixed - many new ideas were collected, many were rejected - by looking at usage of 2.4.x, we had time to think about what makes the ORM a good tool, and what we'd like to keep when we move forward - by looking at usage of 2.4.x, we had time to think about what the ORM should *not* be We also observed a very small amount of reported major bugs, which means that the tool is actually very stable. The fact that 2.4.x was this stable also reduced the need for pushing 2.5.x: yes, that part was just laziness :-) 
A `Value Object` is an object that is not identified by its memory address nor an identifier assigned to it, but that is identified by all of its values (usually internal state). A value object is (usually) an abstraction around one or fields that are bound together by some semantic meaning, and that respect a set of rules (that you decide), for example: * `new MoneyAmount(123.45, 'USD')` (the number *must* be coupled with a currency) * `new Address(123, 'example road', 'BS34', 'Bristol', 'UK');` (many values representing an "address" when put together) * `new EmailAddress('foo@example.org')` (just a wrapper around a string, but it guarantees validity of the value) Before Doctrine ORM 2.5, creating something like a `MoneyAmount` inside an entity would have required you to continuously wrap and unwrap the fields as following: class BankAccount { private $balanceAmount; private $balanceCurrency; public function getBalance() { return new MoneyAmount($this-&gt;balanceAmount, $this-&gt;balanceCurrency); } public function setBalance(MoneyAmount $balance) { $this-&gt;balanceAmount = $balance-&gt;amount; $this-&gt;balanceCurrency = $balance-&gt;currency; } } Now you can simply have it like following: class BankAccount { private $balance; public function getBalance() { return $this-&gt;balance; } public function setBalance(MoneyAmount $balance) { $this-&gt;balance = $balance; } } It's not much, but since the ORM now "understands" the concept of `MoneyAmount`, we can now apply many more ORM-specific operations to embedded value objects. You can look at http://docs.doctrine-project.org/projects/doctrine-orm/en/latest/tutorials/embeddables.html for the doctrine-specific stuff.
But then you have to manage vhosts on that box. Compare that to `php -S 0.0.0.0:8000`.
Eh, it was just an option and there are many provisioner options that can handle the vhosts for you.
&gt; In python you can create subclasses on the fly We could do that as well, it just isn't efficient to do so at runtime, and the files really are just a cache, nothing else (in python it would probably just be a cache at engine level) So far, I didn't find PHP's capabilities limiting. Actually, I even went further and implemented https://github.com/Ocramius/ProxyManager/ around these concepts, just to see how far we can go with it. For what concerns the code, we would love to have some AOT compiling for some of the parts of the ORM, since there are bits of the codebase that are truly horrifying, such as [the ArrayHydrator](https://github.com/doctrine/doctrine2/blob/6b94dc61c600df52cd394219bb169d28e00de2cf/lib/Doctrine/ORM/Internal/Hydration/ArrayHydrator.php#L93-L265), and that could be coded in a clean way if we didn't concern ourselves with all the performance-oriented quirks. 
Some Ruby folks are working on ROM (Ruby Object Mapper). It's the closest match to Doctrine in Ruby that i know of. Last time i checked it didn't really support RDBMs that well, but that was over a year ago. http://rom-rb.org/
I tried it once and it did not work for me. Real pain in the butt. I am curious, are running mysql that comes with xamp, mamp.. or do you download mysql separately? 
I have not found something simpler than running `php -S 0.0.0.0:8000`. The only way I can save time over this is if it's a project I'm working on every day (so it saves me one command per day), in which case I will set up a permanent setup.
I presume that right now, there is an onChange even on the select and it then displays one block and hides another. Well it does do that, I just checked. If you must do this with PHP and HTML and no javascript, you need to put the dropdown/select in its own form and add a submit button. In PHP you then process this form and return a completely new page displaying the selected form. So create a single PHP file that contains the HTML needed for the first form with the select and the submit button (you can't use onChange because that is javascript) then have an IF/ELSE statement check for the presense and value of the submitted select value and return the right HTML. Normally you would templates for the HTML but since the assignment seems to ask for a single (self-referential) file, so be it. Basically take the source code of the assignment and before the element with #helprequest add &lt;?php if(isset(_$POST['formchoice']) &amp;&amp; $_POST['formchoice'] == 'helprequest')): ?&gt; between the two blocks &lt;?php elseif: ?&gt; and at the end &lt;?php end; ?&gt; (Might want to check this one, been a LOONG time since I coded like this. This is NOT a best practice and you should feel bad while doing this but it does seem to be what the assignment is asking you to do. Not using javascript at all is a good exercise, you can't always rely on javascript being enabled and for such a basic thing as handling a form submission, you shouldn't rely on it always being there.
Converting back and forth between mutable and immutable collections is O(1) and has been for a while -- it only actually issues a copy under the hood if you mutate a mutable collection when there are immutable "copies" hanging around. So basically don't worry about it :) Lots of the array functions take collections just fine, though of course they will still produce arrays out the other end. While many of the functionality is available as member functions on the collections themselves (map, filter, etc), yeah, this is something we need to work on.
Because I still need to add a web server config to serve it. And sometimes I just need something quick.
The flippant answer is: "Custom scalar types". It's a language/pattern thing as opposed to a persistence/database one. 
how is that different from any other project? every fork has their own issues thats true, every fork has their own discussions thats true. and there is still a centralized location to have the conversations about the overall project. &gt; If you get it wrong then somebody will let you know. as i said thats a waste of time for everyone involved in making those corrections
Is that a reasonable goal without making the performance cost of the abstraction too high? 
Does one still need to make xml files to map the underlying database table?
I actually believe the only logical conclusion is Doctrine will have its own DoctrineDB backend and everything else will be considered Poor Man's Doctrine setup. I respect the work you guys do, but in the end I feel Doctrine's paradigm is an ill fit on a RDBMS, always was, and always will be. With a dedicated backend you'll be free to explore the limits of the Doctrine paradigm without being limited by interop limitations. Plus, hey, all the hot startups these days make databases. Why not join in?
What if you wanted to share templates between various systems without rewriting them? Mustache has a lot more implementations in other languages than Twig/Jinga2.
I don't think you need to apologize. The community should thank all of you for your hard work and a good piece of software. Even if you don't use Doctrine as is, you can use it as a learning resource because I find its code and design beautiful. &amp;nbsp; Thank you and my respect to all of you.
belated reciprocal high-five
If you work constantly with JSON, I understand the appeal of having a library which grabs directly JSON, and validates it. That said, there are two distinct responsibilities mixed here: 1. parsing JSON to a generic (for the language) data structure, like arrays and... 2. validating said generic data structure. I also work extensively with JSON but I always parse to arrays first, then validate separately from that. This produces two key benefits: 1. You can run the same JSON data through several independent validators in a pipeline, without parsing JSON anew in every one (performance, flexibility). 2. I can reuse the same validators for other data sources, like form fields in $_POST, query params in $_GET, input encoded in other formats coming from transports like raw TCP sockets etc (reuse, flexibility). Other notes: - The grammatically correct version of your "haveSomething" methods is "hasSomething". I.e. not "haveSize" but "hasSize". - You have noted that other libraries require that: "key ordering should be the same both for your API and for expected JSON". I've never encountered that, it'd be a very basic mistake. Most libraries don't have this problem. JSON keys, of course, have no meaningful key order in objects.
Slightly offtopic but, what does DC and DDC stand for in the [bugtracker](http://www.doctrine-project.org/jira/secure/Dashboard.jspa)?
ELI5 Repo Auth Mode please :)
Although if your only concern is sharing templates with JS, Twig has a JS implementation too https://github.com/justjohn/twig.js/
&gt; hhvm stores serialized HipHop Bytecode and metadata in on-disk repositories, or &gt; "repos" for short. Repos are implemented using SQLite &gt; &gt; Repo.Authoritative: false(*) or true &gt; If true, use Repo as authoritative source for unit bytecode, do &gt; not consult filesystem to check for existence of file or parse it. &gt; Otherwise, fall back to parsing file from filesystem if unit &gt; is not found in Repo. https://github.com/facebook/hhvm/blob/master/hphp/doc/repo Sound kinda like `apc.stat = 0` to me. Also interesting: http://hhvm.com/blog/6323/the-journey-of-a-thousand-bytecodes
I know, I use it with one of our products. But sometimes other options are a better fit. Mustache has a lot of implementations in other langs and has been battle tested for some time. Personal pref is still twig, but options are good!
We've been using HHVM in production for a year in an environment that definitely needs to scale. I'm well aware of the advantages of HHVM over PHP 7. That said, the benchmarks I've seen for PHP 7 are extremely enticing, enough that I want to switch away because I'm personally in the other camp where I think Zend Team &gt; FB Team. Not sure what you mean by PHP-FPM worker nonsense. Prior to HHVM, we never had any issues there.
Fantastic news, I've been looking forward to Embeddables in a stable version for a long time. Congratulations to all the team for their hard work.
Your radio buttons should use the same name attribute, say name="fieldName" then your selection will be at $_POST['fieldName'] and you can compare it without the loop. Also never assume input is present, because it may not be (and this causes warnings and notices): if (isset($_POST['fieldName']) &amp;&amp; $_POST['fieldName'] === $correctAnswer) { ... } Notice triple equals. It's a strict check, it's preferred when you compare two strings (that you know are strings) as PHP doesn't try it's usual casting tricks this way. Also note it's preferred to separate your business logic ("is $foo the correct answer?") from your input reading (checking $_POST and reading from it). Try to split those in two functions, where the latter accepts form values from the function arguments, and not $_POST directly.
Okay, I see. This is my database setup: http://imgur.com/Aqwhiuw. This is my PHP to get the data. while($row = $result-&gt;fetch_object()){ echo $row-&gt;question, '&lt;br&gt;&lt;br&gt;'; echo '&lt;input type="radio" name="q'.$row-&gt;id.'" value="1" id="q1"&gt;&lt;label for="q1a"&gt;' . $row-&gt;ans1 . '&lt;/label&gt;&lt;br/&gt;'; echo '&lt;input type="radio" name="q'.$row-&gt;id.'" value="2" id="q1"&gt;&lt;label for="q1a"&gt;' . $row-&gt;ans2 . '&lt;/label&gt;&lt;br/&gt;'; echo '&lt;input type="radio" name="q'.$row-&gt;id.'" value="3" id="q1"&gt;&lt;label for="q1a"&gt;' . $row-&gt;ans3 . '&lt;/label&gt;&lt;br/&gt;'; echo '&lt;input type="radio" name="q'.$row-&gt;id.'" value="4" id="q1"&gt;&lt;label for="q1a"&gt;' . $row-&gt;ans4 . '&lt;/label&gt;&lt;br/&gt;'; echo '&lt;input type="radio" name="q'.$row-&gt;id.'" value="5" id="q1S"&gt;&lt;label for="q1a"&gt;' . $row-&gt;correct_ans . '&lt;/label&gt;&lt;br/&gt;&lt;br/&gt;'; } Which gives this output: http://imgur.com/4WYiRyS. I'm using a loop to get all the data and then grouping the radio buttons with the ID from the database. I think this will make the OP a bit more clear, I'm trying to grade the what the user submits. Do you think your if statement would achieve this? 
Coming from Java, I almost always use a for each loop when dealing with array structures. Avoided it here as the data is stored in an object. while($row = $result-&gt;fetch_object()){ However, using a for loop as you have suggested does make sense and is easier to read. So I think your for loop should be made a function and then the function is ran when the user clicks the submit button at the end of the page? There is more info here, that I left it out of the OP (if it is relevant): http://www.reddit.com/r/PHP/comments/31aoz7/am_i_solving_this_problem_the_correct_way/cpzudcg 
Finally no workarounds for using Embeddables! My thanks to Doctrine team for this awesome tool :)
Wow, that is a lot of information. I appreciate it. I just checked this line here: if (isset($_POST['q'.$i] &amp;&amp; $_POST['q'.$i] == $correctanswer) { It appears that there should be ) after the first closing ]? &gt;In your example you only used the $correctanswer variable once, so it might make sense to just use the $row-&gt;correct_ans in place of it instead I thought it would have been easier to read if I stored the correct answer in a variable, rather than use it directly as $row-&gt;correct_ans. Although, if it's better practice to use the $correct_ans directly, then I will. I see you have used the same idea here (with $post_key): if (isset($_POST[$post_key] &amp;&amp; $_POST[$post_key] == $row-&gt;correct_ans) { Is this because you used it more than once? Your final loop is very clear and easy to read. Triple = also checks for capitalization, correct? It is just a stricter comparison really. I appreciate the example. Now, I need to run this loop once the submit button is clicked and then echo the result, which according to this, requires AJAX: http://stackoverflow.com/questions/20738329/how-to-call-a-php-function-on-the-click-of-a-button 
DC =&gt; Doctrine 1 DDC =&gt; Doctrine 2 See http://www.doctrine-project.org/jira/secure/BrowseProjects.jspa (also, that is not the complete list of our projects)
I am not yet sure about that, but we're experimenting and exploring, and we do performance profiling as well.
The second level cache is not in place to cache the "abstraction", but to prevent I/O towards the DB in first place, regardless of how the DB deals with it. Relational databases are *slow* at dealing with multiple sequential ID-based `SELECT` queries such as `SELECT * FROM foo WHERE id = :id`: that's what NoSQL is good at, and that's what caches are good at. The ORM is a tool that causes a lot of these "single hit" queries (depending on how much you optimize your code to use fetch-join DQL queries), and enabling the Second-level Cache mitigates this problem massively. In addition to that, the cache saves information in a much more ORM-friendly format, which is also a nice-to-have.
 &gt; I feel Doctrine's paradigm is an ill fit on a RDBMS Sir, this is nothing new, see: - http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch - http://martinfowler.com/bliki/OrmHate.html - http://www.reddit.com/r/programming/comments/2cnw8x/what_orms_have_taught_me_just_learn_sql/cjheyec We know exactly that an ORM is not a silver bullet solution. &gt; Plus, hey, all the hot startups these days make databases. Why not join in? We are not a startup, we try to actually be useful to the community instead of hunting VC funding and then leaving :-P
The reason there are many sequential highly granular calls like you mention is *because* of the ORM abstraction. When you utilize SQL directly, the interaction is much more transactional in nature. You write fewer queries, that fetch more data at once (and exactly the data you need for an entire API call, for ex.). So, yes, you are caching the abstraction, because you're trying to solve a problem that the abstraction caused. P.S.: Another reason your cache is faster than SQL is in part because the ACID constraints are mostly gone. For those who care (I guess not many do, sadly).
Yea, you're correct, I missed a closing paren (fixed it in the OC), something that happens often and the main reason I use an IDE (so it catches those stupid typos) heh. Since your original variable has the idea of "correct answer" in it already, there's no reason to create an additional holder variable for it, at least not in my opinion. If your object state variable would have been more confusing: $row-&gt;val, then creating a more semantic holder variable would make sense. Double equal and triple equal both check for capitalization, however, if a match succeeds based on type with double equal, it doesn't go any further. It's kind of confusing but: $val1 = "new mexico" $val2 = "New Mexico" if ($val1 == $val2) { echo "Correct"; } else { echo "Fail"; } Would output "Fail" since types match, a strict value comparison is done. As for your button, ajax is not required. This is how it was done back in the old days before ajax and widespread use of frameworks: &lt;?php if (count($_POST) &gt; 0) { //handle posted content //output message to user of either success or failure } else { ?&gt; &lt;form method="post"&gt; &lt;input... &lt;input type="submit" id="submit" value="Submit"/&gt; &lt;/form&gt; &lt;?php } ?&gt; As you can see, the conditional acts as a page display separator. Depending on whether the user clicked submit or not will decide what version of the page they see. 
Mainly because it: - reduces sql security issues - increases developer productivity - makes it possible to code domain concepts directly on the entities
That's... not what I really asked :) I know they are Doctrine 1 and 2 respectively, but I assumed DC and DDC were acronyms, which doesn't seem to be the case.
&gt; You write fewer queries, that fetch more data at once (and exactly the data you need for an entire API call, for ex.). That is something that *can be* true only if you're the only person following the project for all of its life. If you start adding developers and domain knowledge, it gets really hard to understand what you meant by looking at an SQL query, and ultimately, you start coding different queries in different services just to abstract away this knowledge. What you end up with is the same as before: loads of queries and you're not applying transactional boundaries nor in-memory caching effectively anyway. So yes, SQL all the way if it's a small project and you know what you want by directly looking at the DB, but for me, the DB is just a tool: knowledge of the domain is more relevant, and that's what should come first in the code. And yep, that's a personal preference too :-) &gt; So, yes, you are caching the abstraction, because you're trying to solve a problem that the abstraction caused. Not really: if you create a method `InvoiceRepository#addLineItemsToInvoice($id, $lineItems)` and then apply this code to what the client tells you to do, then you land into the same issues that we have, and that without the need for an ORM (O(n) or O(n*m) code, to keep it simple). This is not persistence abstraction, this is simply how the domain works, and the domain works differently from your database, and so do your customers. In the real world, a secretary does not do "joins" unless he/she is an MS Excel nut: they iterate over data and apply operations. We code like that first, in order to make concepts as clear as possible for us and for the domain experts, and later on we apply optimizations such as low-level queries for heavy operations. &gt; P.S.: Another reason your cache is faster than SQL is in part because the ACID constraints are mostly gone. For those who care (I guess not many do, sadly). True, but for read operations, this is mostly enough. Caching is one of the two "hard" things in software development, and we didn't take it so lightly. The second level cache fits read-only structures and can also fit more complex data affected by concurrent access by applying locking, so we still try to be transactional (or simply evict the cache if we fail). 
I wrote it below in a separate comment, but I think that I found a BC break. Single Table Inheritance does not allow me access the mother entity (or I am doing it completely wrong way). My setup has 1 table with 4 entities, using single table inheritance. They are 'Images', 'Texts', 'Urls', 'Titles' for user supplied contents. I put them all in a single table, and set up a mother entity 'CreativeContents' that is inherited by 4 entities. I need to query against the mother entity as well as the 4 child entities. UP to ver 2.4, I did not have any problem with that. In this setup under 2.5, doctrine dies with this exception Entity 'Creative\Entity\CreativeContents' has to be part of the discriminator map of 'Creative\Entity\CreativeContents' to be properly mapped in the inheritance hierarchy. Alternatively you can make 'Creative\Entity\CreativeContents' an abstract class to avoid this exception from occurring. CreativeContents itself cannot be mapped inside CreativeContents discriminator map (or can it?) And I cannot make the entity abstract as it should be accessible too. 
Sounds to me like you've never developed for performance 
I did: far too many times. If you develop for performance, then you don't develop domain-oriented, or you use something like CQRS and accept that things can not always be synchronous.
Can you rephrase your original question then?
This was actually a sleeper bug: you are not allowed to have non-abstract types in an inheritance and not having them in the discriminator map. In previous versions of the ORM, this still worked due to some lucky coincidences. Correcting that logic actually made the exception explicit. The problem is very simple: if something may exist, and the ORM knows about it, then the ORM must be able to deal with it, otherwise you are just waiting for a late runtime crash. See also https://github.com/doctrine/doctrine2/blob/master/UPGRADE.md#minor-bc-break-discriminator-map-must-now-include-all-non-transient-classes
Moved to http://www.reddit.com/r/PHP/comments/318g7s/doctrine_orm_25_released_second_level_cache/cpzvpb6
My company is building our app in Phalcon (2.0), I have to say I'm rather impressed. With 2.0 they introduced the Zephir language which provides insight on how the c extension operates, that helps lift the veil of complexity. I'm not too crazy about their IoC container, (it makes use of magic getters/setters), but you can use the container in creative ways to inject your dependencies. I will say one thing for certain, it is fast... very fast.
That looks really awesome, thanks for the explanation!
Autarky is a microframework meant for users that want to pick their own components. It includes a router, a dependency injection container and a file-based config data managment tool as well as an optional twig templating layer. Anything beyond that, like authentication, database ORMs, queueing libraries, you name it, is left to the user. It's heavily inspired by python's Flask. If you want to experiment with this, I recommend using composer's create-project command - the skeleton project is well commented. composer create-project -s dev autarky/skeleton --prefer-dist ./myproject Documentation for the framework is available [here](http://autarky.lutro.me/).
This is exciting! Congrats to all of the hard-working developers that put their time into this release. I'm sure that organizing such a release for such a large code-base with so many users must have been quite the challenge. Respect. As for the ORM itself, I have to say I love it. Now, no piece of software is perfect (especially when it attempts to solve so many problems for so many different use-cases) and I don't think that Doctrine is the be-all-end-all, but I have to say that Doctrine is really quite an impressive piece of software. Really the main thing for me is that Doctrine made ORM's feel less dirty to me again. The way Doctrine promotes (and even sometimes requires) so many design patterns and structuring with separations of concerns is an absolute delight after spending years with ActiveRecord, haha. I can finally test my domain-level code again without attempting to mock singleton structures or having to apply "fixture" seeds to my database. Yea, there are definitely things that still bother me a bit about Doctrine, like its superfluous use of proxy objects (the very "magic" that I wanted to avoid in an ORM) or promotion of annotation use (don't get me started on annotations...) for mapping, but I understand how some of these things may seem somewhat "necessary" to get a stronger majority of devs at different experience levels up to speed on how to use the ORM itself. And hey, at least some of the grossness, like annotations, can be avoided (I use PHP-native mappings by using the `ClassMetadataBuilder` directly). And yea, while writing manual queries all of the time would be "nice" in some ways so that an ORM wasn't necessary, its just not the most practical strategy for large projects. At the end of the day, I'd much rather have a team be productive by using an ORM that promotes a stronger architecture and design than having to use something like ActiveRecord. :P Anyway, thanks again to the devs that worked so hard to make this release happen. And for free, no less. :)
Facebook has unsolicitedly given me a four-digit check for just posting a security bug in HHVM via secure channels. Their core devs are courteous, give me their Skype and email addresses, and encourage cooperation. On bugs.php.net, I found a backward-incompatible, unnoticed break in PHP 5.6 that caused a hard segfault if you did something like: new DateTimeZone('CST5CDT'); which was completely valid for years. It languished for 6 months in the bug report, despite there being a Pull Request. I had to fork clients' PHP instances to include the PR, or keep them stuck on 5.5. In the end, Rasmus ended up saying how difficult it was to fix and then they covertly fixed it about 3 months ago (after about a year), deleted all of my comments and never even put it in the ChangeLog... My corporation has completely migrated all of our sites and all but one of our long-term clients to HHVM. I was able to do `sudo /etc/init.d/php-fpm stop` back in March, and that was a great day indeed! We should let Facebook be our new stewards.
The benchmarks says that lighncandy implementation is 4~6 times faster than mustache.php: https://github.com/zordius/lightncandy#features
Sidenote, `++$variable` is marginally faster than `$variable++` in PHP. Same effect, one less opcode.
Thank you for so quick a reply. I set the mother entity as an abstract class and refactored the rest of code after all. But at least you have cleared up a point for me, and hopefully I understand the concept a little better now. 
Holy shit.
&gt; its superfluous use of proxy objects Note: they are the only currently existing way in PHP to implement lazy-loading associations ;-) If they are not proxies, they're still AOP-autogenerated code anyway.
It does seem like you're defending Doctrine as a more scalable paradigm for large monolithic apps, and that might be fair. But have you thought maybe the problem is large monolithic apps? With micro services that problem doesn't exist. Every micro service owns its own tables and no one else has access to them. You say "it works with small projects" but SOA is about making a big project composed of such "small projects". Also, I don't understand your InvoiceRepository example. The domain should expose less granular API calls that match the domain. I.e. API modeled after use cases, not SQL joins, sure, but also not some abstract OOP domain model. I doubt the secretary wants to know the intricacies of Doctrine's paradigm either. Regarding caching - "*mostly* enough" and "we *try* to be transactional" caching can be applied already to results returned from Doctrine without Doctrine's involvement. I.e. this layer you added might as well be completely outside Doctrine. But you made it a part of doctrine, I have to say, it does appear a bit as a PR move. Now that you have this cache, you can tell naysayers "ah yes it's slow in benchmarks but you didn't enable the cache", side-lining concerns about un-cacheable operations and data-integrity, because rarely a benchmark checks any of those. 
You're probably right but a prefixed ++ has a specific use and unless you're prepared to use it like that it can cause issues, especially when other team members are reading your code. I tend to prefer semantic code over a very marginal speed improvement. I only use a prefixed incriminator when it's specific quirkiness is called for: $count1 = 0; $count2 = 0; $postIncrementVal = ++$count1; $preIncrementVal = $count2++; echo "$preIncrementVal|$postIncrementVal"; //Output: 0|1 
In theory, you should be able to code your entire domain logic without even having the ORM plugged into your system. Imagine coding all your associations and interactions only in-memory: that's pretty much the aim. Lazy-loading only gives you that perception, and is as useful as dangerous, obviously ;-)
Haha, yea. I think it'd be incredibly useful/beneficial to have some sort of blog post or example in the documentation that might show what that'd look like. Its kind of like the whole Laravel "static" backlash: so many people were complaining how it uses static calls everywhere and /u/utotwel kept mentioning that you could use Laravel completely without that (using proper/traditional DI instead), but the documentation really only showed the static way of doing things, so it kind of accidentally promoted the "improper" usage and hid the more powerful/maintainable usage. haha
He's asking for if there's an reason for the DC / DDC tags. Is there a meaning? Is DDC an acronym for example, or is it a random keyboard mashing?
 &gt; Its kind of like the whole Laravel "static" backlash I'm not sure how that is relevant here: proxies are just an internal mechanism, and the ORM asks you to configure their path and namespace just because otherwise it would generate them over and over again. The ORM itself is already suggesting a code-first approach as a best practice, where the ORM actually becomes part of the workflow only after your entities are set in place. Some known quirks that may actually be a problem when designing your domain models: - identifiers are required - collection-valued associations require `doctrine/collections` - scalar values are compared by reference (a problem with custom types) - embeddables (one of the new 2.5 features) are not nullable These are actual limitations when designing "without the ORM" in mind: so yes, there is still some coupling :-\
This is like talking to cheese.
Thank you for discussing these points with me, I've found your PoV informative and honest :) (never mind I always sound critical).
Anonymous is a good step 1, but then you're often left with the "Oh, pretty much everyone who applied is a white dude, what do I do now..." issue. Conferences have been shut down after drama over this. Totally anonymous, they did everything they thought correctly, then... yup its all white dudes. Twitter balks they're sexists and racists and the whole thing is fucked. Even if its not about them avoiding getting shouted at, we can hardly say (as discussed in other threads) that 90%+ white dudes is a great situation to be in. It's not representative of the tech community by any means, and just leaving it all up to "see who applies" is not always the solution. Sometimes "minority" groups (non-white-dudes) need a bit of encouragement to sign up. There is quite a big gap between banning guys and trying a bit more actively to find quality speakers who represent more than just one specific group of people.
Yeah, if you abuse them (incrementing on assignment) you run into that. for ($i = 0; $i &lt; $max; ++$i) versus for ($i = 0; $i &lt; $max; $i++) Is what I was alluding to.
Historically, I relied upon python -m SimpleHTTPServer to quickly serve things over HTTP ... The internal web server **changed my life**.
This was dumb and you should feel bad.
I did not do the frog jump. Will test it and see the result I get. Tx
First time I ever felt like creating an account on Reddit to leave a comment, and I almost regret this decision. I feel like the reason why we have a limited number of women in tech is clear in threads like this - we come here and see a bunch of guys commenting on how unfair it is to give any kind of extra help to get more women into tech / a conference, deciding whether action X is good or not, with little or no participation at all from women. Feels like a chicken / egg problem, but whenever someone tries to change the ratio like Chris is doing, this is the kind of reaction we see. Of course we fly away! Who would want to get into a hostile environment dominated by people who can't relate to you? I know for a fact that many women out there are capable of presenting highly technical talks but they won't just submit to random conferences because they feel intimidated by the fact that more than 90% of the audience tends to be men. Honestly, guys, it's much harder for a women to present a (technical) talk for the first time. You have no idea.
Constructing form field ids on the fly feels like bad practice to me. Personally I would have constructed it like so. $form_fields = ['q1', 'q2', 'q3', 'q4', 'q5']; $right_answers = 0; foreach ($form_fields as $form_field) { if ($_POST[$form_field] == $row-&gt;correct_ans) { ++$right_answers; } } This makes it easier to maintain down the road if the form fields need to be renamed, or should the code need to be repurposed.
So basically: PHP (with its imperfections) is perfect for hacking stuff together quickly and figure out your business model, and after that, when you don't have to iterate that fast, go compiled for the future of your business.
Another important thing to ask yourself is: do you use different libraries instead of one big framework. I wouldn't recommend using the plain old PHP for new projects. Despite the wide standard library, it doesn't come for example with a router or better templating that seems to be must have feature nowadays. It's possible to reinvent these but why bother because there are many better libraries already.
Nope! Do what you want. I would suggest that you don't try to everything yourself, and composer packages will help you out a lot there. Routing, DI, Dispatching, Image Manipulation, HTTP interactions, etc are all solved problems and there are other things you can be doing. Screw people who shout USE A FRAMEWORK at you without context. Sometimes it helps, sometimes it doesn't.
Interesting. I've been using [phly_mustache](https://github.com/phly/phly_mustache) combined with a simple, custom View class with Slim 2 for quite some time now. I'd be interested in how much faster LightnCandy is vs. what features it supports. I know that phly_mustache has some extra features added, like template inheritance (which I use extensively).
&gt; but it's very likely that all women who came to you because they have something to say about PHP already came to you. This particular pool of female speakers is exhausted. So, as a result this means now you're unintentionally (or intentionally) looking for women to talk because they want to help you fill a women quota. This assumes that everyone knows about all conferences, and all interested women are actively submitting already, which is... well patently false.
On 5.6.7, definitely upgrading to 7 when it's stable. Will compare Nginx + 7 to Nginx + HHVM when the time is right and make a decision.
Done
To add the mix, there's an article [Do Not Learn Frameworks - Learn the Architecture](http://kukuruku.co/hub/programming/do-not-learn-frameworks-learn-the-architecture) that just hit both [reddit](http://www.reddit.com/r/javascript/comments/31ah12/do_not_learn_frameworks_learn_the_architecture/) and [HackerNews](https://news.ycombinator.com/item?id=9314149) that covers things in pretty decent depth (well comments do anyhow). It really boils to down to variations of what /u/BringTheTanks says... "I don't know enough to begin/build it..." vs "I can't do it all myself, with reasonable results..." Add a dash or two of "It's not a perfect fit..." and "I hope they don't drop or change the framework..." and you've pretty much got it. For the most part, you've probably got a good feel for whether you're in need of a framework, and it may change from project to project (and from year to year); however, I think it's mostly a case of "You're wrong for varying definitions of wrong, but also right for varying definitions of right..." I'd also ran across something (that I can't find now) on Martin Fowler's Twitter (years ago) where he advocates owning your core business tools (including code/processes/etc.) It allows you to distinguish yourself, and though often requiring more effort, it puts you "in control of your own destiny"... Fowler's concept of a [HarvestedFramework](http://martinfowler.com/bliki/HarvestedFramework.html) is one I've always liked (and sounds like it might be one you're already using). Regardless, I'd avoid attaching "bad person" to framework use, since it really seems to mean incompetent, cowboy, or some other negative quality applied to programmers, which can still be a hard question to answer. EDIT: Reworded final sentence to avoid giving obvious incompetent/cowbody coders a free pass. There are obvious tells for the worst of the worst...
I had to double check the date of this article when I saw those references o.O
It's dramatically more than that with HHVM -- see http://www.reddit.com/r/PHP/comments/318lwz/what_are_your_future_php_plans_hhvm_php_7_other/cq06qc7
Build for yourself. Some people spend decades working on their own boat. And then they die and their kids rip it apart without it ever having seen the water. For those kind of projects, do whatever you want. But I looked at your history and you were looking for corporate jobs? Good luck going to a shipyard applying to be a boat builder but insisting you get to do everything from scratch. Is it for a hobby? Then do it all from scratch. You want a job? Then learn a simple lesson, you do not waste time on code where you cannot differentiate yourself. If you know how to make perfect tires, you build tires but you do not make wheel nuts. If you can build the best car engine in the world, you build car engines but you don't bother with spark plugs you take them from the shelve. DB connector, logging, routing, autoloader etc etc are all thing that you can spend countless hours writing yourself and nobody will notice any difference when they use your application. Take the stuff that is generic of a shelve and focus your efforts on the part of your application where you can make a difference. I seen projects from "scratch" be absolute non-maintenable crap to many times to any longer believe there are exception to the rule that people who still don't use a framework and/or libraries through composer can ever produce anything that can scale up beyond a hobby project. It is not just the lack of a foundation a framework gives but the constant attempt to write components that are not part of their core competency (not that every had any) where there are proven alternatives. One guy had written his own disk based queue system... needed a very expensive raid setup and once the fastest disks available had been bought, there was no further way to scale it up. Tens of thousand euro's in hardware spend, I replaced it with Amazon SQS for fraction of the cost, solving all performance problems along the way. Used standard libraries. Other project tried something with semaphores to establish locks. I used redis, was instantly reliable and allowed the application to be scaled up by using more servers (semaphores are local). Am I that brilliant? No. I simply stood on very tall shoulders and used other peoples work. And the funny thing is, no matter how tall you are, you always see further if you stand on someones shoulders. And hey, maybe you are the exception. Your life, your decisions. 
Yeah, I disagree, but definitely see where you're coming from. Hack support for shapes and arrays isn't going away -- we need them to support legacy code -- so feel free to keep using them. One of the things I like about Hack: you can use exactly as much of the language as makes sense for you, your team, and your application :)
Everything browsing a website does not have a human built into it. There are web crawlers, parsers, etc.
Absolutely, we saw it this morning and thought it'd be cool if we had something like that for Packagist so we hacked it together in the afternoon
Frameworks, as in whether you use them and/or which one you use is not particularly important to the success of a project. The truth is following programming standards, having good project management and having a solid technical design are more important to the success of most systems (both small and large) as is following the KISS principle and making sure code is well commented and requirements/test plans are documented. Take a look at different frameworks for your own education and to see how the latest batch of programmers are being pushed into thinking, but dont force yourself to use them if you dont need to. Often you might use just one package from a framework as a component of your system to stop yourself from re-inventing the wheel (session management for example). 
Great, thanks!
Or, become adept at good coding practice and develop solid engineering discipline, stick with PHP, and have the best of both worlds.
For thinking posting this was a good idea.
You don't need to be using a framework, but you should be using Composer packages. If you're actually writing all the code yourself, yes, you're doing it wrong.
&gt; Also: document your architecture, and keep the code as consistent as possible. This even goes for if you do use a framework. This. So much this. And no, comments and tests are not documentation. They are a part of it, but you need so much more.
I'll add it to the docs - and maybe set up a post-create-project hook to copy the example file for you. I put a lot of effort into adding comments to all the files in the skeleton projects, which makes me prone to forget that not everyone will read those immediately. Thanks for the feedback!
Sweet, thanks for the recommendation!
&gt; What is then the least monolithic framework? Silex lets you use the Symfony components without mandating many of them, or prescribing a structure for your code.
Yeah just go ahead and build your projects from scratch, it's not like anyone else will ever have to maintain them right, right?!
Thanks for the reply. As for the corporate jobs thing, I was in the process of looking for a coop through my university and every company that was there for developers was looking for C++ and/or Java as well as a scripting language (usually Python). It was more of a frustration with that than anything else, I wanted to know if PHP was used in corporate environments. Up to this point, most of my code has been for personal projects. And since I started coding, once I developed my base class structure (database, session, remember me, etc.) to the point where I was comfortable with how it was written and it's security, it's followed me from project to project. As others here have said, that's almost a personal framework. Others also mentioned things like image manipulation and other things where writing from scratch is just not worth it, for those types of things, I use libraries. Brilliant quote by the way: &gt;Am I that brilliant? No. I simply stood on very tall shoulders and used other peoples work. And the funny thing is, no matter how tall you are, you always see further if you stand on someones shoulders. Thanks again!
But don't use EasyPHP in production. After few hours in heavy traffic it stops responding. For production you can use http://windows.php.net/ and http://www.apachelounge.com/ if you have Windows, but I don't recommend using Windows on production. Apache and MySQL is not for Windows. We had some problems like; * MySQL's performance decreases. * If you connect even with only one IE then Apache starts to [lag](https://stijndewitt.wordpress.com/2014/01/10/apache-hangs-ie11/) until you restart the Apache. * Updating MySQL is not as easy as on UNIX based systems. * It looks like updating PHP and Apache is easy on UNIX based systems. * Unnecessary RAM use in Windows, like UI. * Windows does not support SSH. Hard to install SSH. * Windows is expensive. Some points above might be unreal but these were my experiences.
Have you tried running Vagrant on an notebook with 1GB RAM?
I only had problem with [Time](http://php.net/manual/en/function.strftime.php). For the MySQL database were case sensitivity matters we have a local Ubuntu machine. Other than these I don't see any compatibly issue.
I'm just looking for an Enum implementation. My requirements are: - single instance - type hinting - code completion - traversable - Enum value can be used as a key I took a look at many implementations and yours seem to target the requirements the best. We'll try using it very soon and if something comes up, contribute back. Thanks a lot!
I've just started using Phalcon. I like it for a few reasons: * Uses modern OOP conventions * Loosely coupled * Being loosely coupled also means no changes are generally required in my code when upgrading Phalcon version - even the jump to Phalcon 2, which is programmed in a different language (Zephir to C, instead of straight C) won't break compatibility with projects * Default project layout generator can create a multi-site project easily * Phalcon devtools can automatically scaffold models, controllers, and some CRUD pages based on your database * Phalcon devtools automatically creates migration files from your dev database schema * No framework code in my projects' code base * Low memory usage * The performance stuff is a bonus I don't know much about HHVM and PHP 7, but once Phalcon supports them and they become more mainstream, I'll look into them for some extra performance boost. But the fact that my framework is in C to begin with means I'm already part of the way there in terms of performance.
Yes. You are making it harder on yourself and probably more expensive for your clients. However... you are free to do what you want.
I have wampserver for my Windows box - several versions installed in parallel actually, which allows me to switch between 5.3, 5.4, and 5.5 as needed. I just create vhost files as needed and point the httpd.conf file for each install to its respective vhost folder and I can do local dev almost sorta kinda like I do on Linux or Mac. Still haven't found a way to just use Apache 2.4 for all installs though.
You don't NEED to use one but without something similar to one, you'll be inefficient as a developer. The need for one naturally occurs as you start working on new website after new website and find yourself duplicating the same "boilerplate" code constantly (i.e. helper functions for doing better string manipulations, parsing query string values, etc). When it comes to database access, you probaby write the same CRUD code over and over too. All this is extremely boring, wastes everyones time, and takes your focus off writing the business logic of your application. Not only that but it also means a lot of your sites will be architected slightly differently so switching between projects can also eat up time getting re-acquainted with the code and how the plumbing works. I ended up rolling my own MVC-ish framework over time for my PHP projects but when I first started out I'd just have a folder called "_library" that I could copy into each site which contained a bunch of PHP class files named things like string.php, url.php, etc. They each contained a bunch of static methods to have available to get me developing faster and also to normalize the terribly inconsistent PHP methods into something I can use without constantly referencing php.net. So basically, no, it's definitely not necessary; however, if you want to take being a developer seriously and hope to make it a career, you should start using something or at least explore a bunch to see what they can offer. As a developer, it's your job to be as creative and efficient as possible to solve problems. Employers would not want someone to spend days writing pieces of code for a new project that another developer can "write better" by downloading a matured package to use in the project. And on top of that, now other developers can re-use that decided package in other projects to save time re-learning how certain plumbing between projects work and it's already fully documented for everyone at the project's website. 
This is very true. Get your hands dirty and go out there and just learn and experience everything you can! In fact, it really just depends on the project and your personal goals. If you need something quick and dirty, drop in a few composer packages, whip something up and you're golden. If you need something more advanced and in depth, maybe use a framework you've never tried before (if you have time to learn and fix mistakes). Also for smaller projects, do it all yourself and use it as a learning experience; read up on how others do it and take a shot at it yourself. In no way does this sort of individualism make you a bad person! Just document your work, be consistent and clear as possible so that the next person to look at your code after doesn't want to hunt you down and murder you. 
The only time it doesn't help is when you don't already know frameworks and there is a learning curve. But this is a fallacy as it assumes you will never do anything that should make use of a framework.
&gt; I think it matters less whether it's an off-the-shelf or something built in-house. Do you honestly think the in-house system will be as well documented as a large open source community project? Or well maintained? Or extended? Not to mention that you can count on at least some new starts already being familiar with an OTS solution, and zero knowing your in-house one.
Implementing a PHP framework has been a curiosity of mine for quite some time. It has always come down to either expanding and improving the code I have already written or spending the time to find the best framework for what is needed and learning how to use it. However, I have found Web design frameworks to be very useful. 
My knee-jerk reaction is that the big nested blocks could be their own DSL with PHP embedded as-needed... Obviously that won't be great for universal syntax-highlighting, though.
After years of being a framework devotee I've gone full circle and now just glue a hand full of composer packages together. I would much rather use packages in my code than force my code inside a framework.
I recently wanted to switch to a new framework, did my research and kept wanting to use Phalcon. I ended up going elsewhere only because of the HHVM incompatiblity. Yes, the performance was already there and resource usage is minimal (it really is a great framework!), but something inside me kept saying I'll regret going to Phalcon just because of the incompatibility. I'd love to know how well it handles PHP 7. I'd gladly make the switch if they work well together.
300k page views a day is only like 4 req/s. You could probably serve the site on a potato. More seriously, either is going to be a good choice. Performance is probably not that important-- you should look at support, community, ease of debugging and development, etc. FWIW, Symfony 2 is the way to go.
I agree, if you aren't using a framework you put yourself at a severed disadvantage over those who do. As a client, I'd trust the code of a well known, open source project over JoeSchmoes custom password hasher.
In truth, any framework will do when you're running it on a potato.
Honestly that isn't that much for Phalcon to really shine I would say use whatever you guys are comfortable with and are easy to debug with, on that note Ive never used phalcon in production (ive tried it in pet apps), but I love how Laravel 5 works and how its easy to debug specially since I come from wordpress and CodeIgniter sites.
I have to be with you on this ive used Laravel in production and I have to say coming from Code Igniter and actually loving it Laravel was a good and refreshed way of getting back to MVC.
I wouldn't ever say that the choices you make for developing things makes you a "bad person". I think that a failure to chose the right tools for the job makes you a *bad developer* and potentially a *bad employee*. Now, what are the right tools for the job? That's a much harder question. Sometimes it certainly **will** be a hand rolled script totally built from scratch, other times it will be a collection of components stitched together in your own architecture.. there certainly *is* a place for frameworks in the debate as well... The key I think is to be mindful of "Not invented here syndrome" and be mindful you are not writing everything from scratch for the sake of doing so. But really it comes down to making the best choices for the problem at hand given the information you have available to you at the time.
Definitely not! Learning by doing is the only way to get somewhere. Don't use a CMS or Framework if you don't want to, theres no wrong in that. PHP as a language is more of a framework itself, comparing to other languages, so you might not need anything more. That said, i would still urge you to use composer (and git) and selecting the most critical parts of your site/app to utilize some already built and tested tools, these include database querying and authentication. Security is hard, and no one gets it right the first time.
Can you tell us more details about the hardware you were using to serve 1 billion requests per day?
We're not currently using HHVM as NewRelic doesn't have their own extension for it. There is a community built one for HHVM but afaik it doesn't support all the features. I haven't yet had the opportunity to try it. But I have tried HHVM with our current code and from using PHP microtome calls (As I can't use NewRelic) it improves performance significantly on some pages. 
I'm using Jenkins for automated builds and release. I do set up multiple jobs which do checkouts, automated unit tests, deploy to a staging environment, running some acceptance tests with behat and finally, if every build step passes, do the deployment to the live environment. These jobs are merged in a build pipeline. And that's all there is. 
The question you have to ask yourself is: do I want to solve a problem that someone else has already solved, or do I want to try to solve it myself anyways? It's like, you could build your own toaster from spare parts, or you could go buy a toaster from the store. Sometimes you want to build your own toaster just because. Or maybe you think you're slick and you can build a better toaster. But if you're running a commercial kitchen, you don't have time to sit there and build all your own toasters, you just want to buy your pre-made toasters and just start toasting. And then if you hire other chefs in your kitchen, they have to know how to use the toasters. If you built all your own custom toasters with a different design, then all your chefs have to learn how to use your toasters because they only know how to use regular toasters.
Depends on the site. Is it a typical web app? How fast do you want it to work, like how many miliseconds for the first byte acceptable to you? Does it do heavy queries or calculations? Can you cache majority of the page? What is your server specs look like? Do you have an international audience or local? If you have a local audience, you'll get majority of hits during daytime/evenings and peak hits will be high, where international visitors will give you a balanced hit ratio during peak/minimum. The information you gave is really limited, but I wrote a reply on a Laravel vs Phalcon topic two days ago. Tried to explain why Phalcon isn't really fast like an eli5: http://www.reddit.com/r/PHP/comments/313nc8/frameworks_how_are_requests_per_second_important/cpyhhua In your case, sounds like Laravel will be a better choice, but beware, Laravel `currently` has a big con you didn't mention. Laravel doesn't follow semver. Taylor Otwell recently broke BC in a minor commit few days ago once again. (https://github.com/laravel/framework/commit/cfa7fcb) He did it plently of times in the past too. There is no LTS, so you're pretty much forced to upgrade to Laravel 6 when it releases. Sounds like your application will be in development for over a year? If so, Symfony could be another valid choice, but Laravel is also suitable as long as you plan to keep it fresh.
This is pretty awesome. Thanks for putting this together, I'm excited to give it a go. 
i use [codeship](https://codeship.com) to run tests and deploy my apps. it has a free plan for 100 builds p. m. in a normal month, i use 30-40 builds. it works for very small projects with not a lot of activity.
Download php, (add it to path if needed); run 'php &lt;filename&gt;' on command line.
Could you give some non-abstract examples?
A n00b question, how can I set up jenkins for a very simple static site or say wordpress? I tried searching but could not find any simple tutorial or article. ^^sorryifitwasastupidquestion
Yeah fair enough. Which framework did you go with in the end?
If he's never used a framework at all, I would recommend playing about with one or two just to get a feel for them though. I learned loads when I first started with Cakephp back in 2009 ish. Then I moved onto Zend, then Symfony, and nowadays I'm more like you in that I pretty much "do what I want" - sometimes if the need calls for it I'll use a full stack framework. Other times I just pull in symfony components and Zend components or whatever just to do whatever I need. I think it takes an initial exposure to these things to be able to build up a sufficient frame of reference, however, so for that reason I'd recommend the OP have a go at using a full stack framework in a project, just as a learning experience more than anything.
One major benefit of generics is that it can be used to enforce type safety for collection types. Lets say you have a collection class that can store different types of objects, but the objects stored in each collection must be of the same type. A good example is a collection of integers, strings or file objects. Without Generics, you have to create one collection class per collection types, such as IntCollection, StringCollection, FileCollection, etc with methods such as checkType($obj) to enforce type safety. With Generics, all you need is something like Collection&lt;T&gt;, in which T is substituted by int, string or File at runtime. This way, you ensure type safety and write less code. Its a win-win situation. 
This is the reason i wrote this library (i used something similar to what you suggest). To reduce amount of code in my test scenarios and make them readable and easy to maintain. I just don't like the idea to write some kind of `ListFormat` only for my test cases. 
Uh. I don't know. I kind of like behat and it's gherkin implementation. Can be adapted to support dsl and therefore tests can cover multiple domains with similar functionality but different structure. I use behat along with phpunit, though. Unit tests for code level and behat for acceptance tests with a real browser executing js and whatnot. I personally don't see behavior driven tests for code level. 
only good post in this thread!
No need for the internal server, this script can be run right from the command line. `php championgg.php` the CLI out put is: root@debian:/# php championgg.php Creating item sets for all champions... Saved set for Aatrox in Top role to: 1428141608_ItemSets/Aatrox/Recommended/5_6_Top.json Saved set for Aatrox in Jungle role to: 1428141608_ItemSets/Aatrox/Recommended/5_6_Jungle.json Saved set for Ahri in Middle role to: 1428141608_ItemSets/Ahri/Recommended/5_6_Middle.json Saved set for Akali in Middle role to: 1428141608_ItemSets/Akali/Recommended/5_6_Middle.json Saved set for Akali in Top role to: 1428141608_ItemSets/Akali/Recommended/5_6_Top.json Saved set for Alistar in Support role to: 1428141608_ItemSets/Alistar/Recommended/5_6_Duo_support.json Saved set for Amumu in Jungle role to: 1428141608_ItemSets/Amumu/Recommended/5_6_Jungle.json Saved set for Anivia in Middle role to: 1428141608_ItemSets/Anivia/Recommended/5_6_Middle.json Saved set for Annie in Middle role to: 1428141608_ItemSets/Annie/Recommended/5_6_Middle.json Saved set for Annie in Support role to: 1428141608_ItemSets/Annie/Recommended/5_6_Duo_support.json Saved set for Ashe in ADC role to: 1428141608_ItemSets/Ashe/Recommended/5_6_Duo_carry.json Saved set for Azir in Middle role to: 1428141608_ItemSets/Azir/Recommended/5_6_Middle.json Saved set for Azir in Top role to: 1428141608_ItemSets/Azir/Recommended/5_6_Top.json Saved set for Bard in Support role to: 1428141608_ItemSets/Bard/Recommended/5_6_Duo_support.json Saved set for Blitzcrank in Support role to: 1428141608_ItemSets/Blitzcrank/Recommended/5_6_Duo_support.json 
Thanks guys. REALLY appreciate the help. I am going to try it out.
From how I see it, you might not be a bad person or bad programmer, you just like to work more than you have to. Frameworks are great in allowing you to refactor your work, include previously made functions into new projects and setting up project-environments faster. You can do everything a framework does by hand. The only question you have to answer for yourself is, why would you want to do it by hand, if you can automate it?
I downloaded php windows. Then I open php, and I type 'php championgg.php.' nothing happens. :)
nobody who asks this question will know what you mean by path. and possibly command line.
I think that doctrine is bad. Really, really bad. Why? Because all it does is trying to hide that there is an SQL database in the backend. But in fact, there is and there are so much complications because of that. Instead of DB rows, you have plain php objects that pretend to being simple entity classes, but it will never work. One of our developers treated a list of doctrine objects as "mysql would never extists" and was lazy loading a collection of 50 paginated entries which resulted a 120 query on single page reload. You CANNOT treat them like a "just objects" and "let doctrine do backend stuff" it does just not work. The answer why is simple. SQL databases are not a things that contain OBJECTS. SQL databases are things that ANSWER QUESTIONS. Doctrine just simple questions for you. About alternatives? I would propose Eloquent ORM, which is easy to use, has various relations and useful things, but it does not hide a DB for you, it just make you use SQL database easier. Thanks.
Well, I don't have any link to a tutorial for you. You have to Google that yourself or just dive in. But be aware that Jenkins is a fully blown system running on Java. https://jenkins-ci.org/
If you were writing every query by hand, you could almost certainly make more efficient queries most of the time. For example in Doctrine, sometimes it decides to run a separate queries where you could have used a JOIN. Unfortunately the power they give you sometimes comes at a cost. However, at least in Symfony, Doctrine makes very good use of caching. All of the metadata is cached to PHP classes, so it doesn't have to compute that at runtime. You can also enable a variety of query caching options.
Are you getting related objects from relationships like described here? http://propelorm.org/documentation/04-relationships.html#minimizing-queries This is one of the most common mistakes people make when they first try using an ORM. 
I tend to use ORM's as good starting points for functionality. As the project matures they begin to fall off except for very simple operations. I absolutely don't trust ORMs to write efficient joins or handle complex data transformations. That's the kind of thing that leads to the biggest degradations in performance, in my experience.
Did you save the file from github as championgg.php and make sure you navigate to the same foldet the script is on when running the command.
If the ORM you are using is generating N+1 queries, you are either using it incorrectly, or it's crap. Obviously that's not going the scale.
You either use an ORM that is already available, or you will have to write the object mapping code yourself. If you think your code is going to be better (perform better, easier to maintain, better documented), than the already available ones, then go ahead and do that. As for my personal experiences, Doctrine2 is a fucking godsend to the PHP world, and it makes my job so much easier. No, it's not slow. If it's slow, you misconfigured it, or using it incorrectly.
Care to point to some ORMs that generate proper join queries without having to drop down to a query builder API, or some SQL-flavoured syntax (DQL)? The promise of ORMs is working with database data via objects that abstract away the details of SQL. If I have to, essentially, write SQL, to get the ORM to generate sane queries, then what is the ORM doing for me? If I have to keep "peaking behind the curtain" to get the abstraction to do what I want, then it's not a very good abstraction. Maybe I've never worked with a good ORM before, but that's my experience with them.
Execution time is cheap. Programmer time is expensive. If you're optimizing for execution time rather than long-term development cost, you're optimizing the wrong thing. (There are exceptions, of course). 
The way of specifying what is loaded eagerly, and what is loaded lazily, doesn't have anything to do with a separate SQL dialect. Doctrine2 choose to do this via their own language (DQL). Case in point, SQLAlchemy doesn't use any kind of DSL (and afaik, it's even more powerful that Doctrine2). I'm using an ORM because it provides me features I want (efficient flushing, identity map, mapping the data rows to objects, handling relations, and so on), and not because I want it to hide SQL from me. I couldn't care less if I have to write SQL/DQL/whatever. If that's what it takes for me to leverage these features, and the ORM to be efficient, so be it. The pros far outweigh the need of writing DQL for me. Anyway, this is what I replied to: &gt; If it's a "SELECT * FROM table LIMIT 10" sort of query, sure. But as soon as you need to join one or more table, the performance picture gets pretty awful. Google "ORM N+1 problem" for more in depth details. This is very far from the truth. N+1 is a problem if you use an ORM incorrectly, not something "as soon as join one or more tables".
Yeah, I made $200,000 in 2014 doing nothing but replacing Doctrine findBy()s with createNativeQuery()s. And creating a bunch of unit tests to make sure it all worked afterwards. No joke.
&gt; For my use cases, with dozens of queries per page, 200 ms per pageload is the target, and I usually come in under that. See, for our use case at work, that just wouldn't be feasible. We try really hard at keeping response times below 50ms which, when you are using PHP, sadly requires a ton of hardware. Abstractions like ORMs or frameworks are great when you need to get a working product *fast*, but it will always come at a performance cost. Whether that cost is signficant depends on your use case. Personally, if you are aiming for &lt;50ms response times, I'd strongly recommend staying away from ORMs and most other abstraction libraries. Or, if your situation is more flexible, maybe try some other languages that don't have the whole "build up/tear down the environment on every request" thing. Every tool has its uses :)
When it gets that slow, your boss has to hire me at 2 or 3 times your rate to undo your mess. Then the next project they manage, whenever they hear Doctrine or even ORM, they scream, "NOOOOOO!!!!"
I have carved a professional niche in deploying wampserver on production environments, although i much prefer Z-Wamp, since it can run with just an extraction and runs fine from USB sticks (which *has* been a requirement at more than one place!) http://zwamp.sf.net/ A list of sites currently running Z-Wamp: * A top 10 United States bank [runs on a thumb drive for their employee intranet backend... don't ask me why, it was a requirement!] * www.railchannel.com 
One hour long, no synopsis and comments are disabled :-/
Actually I am a bit curious as how caching is done in ORM frameworks such as Doctrine, especially when it comes to shared hosting environment in which caching extensions such as Memcached aint available. Can anyone elaborate? 
sexsearch, xxxmatch, and other 37 in the list... =) Now pornhub does use to, but their strategy is quite different on tackling the problem as their primary focus is read, not write. =)
My general advice is that you should have 5 nodes of Riak and keep 3 copies in the cluster. Also ensure to write to at least 2 nodes before consider it written (read DynamoDB paper from Amazon). As our information is quite dynamic, we do have Varnish on certain places and rely on ESI in specific parts of application, but it does not handle all requests... I'd consider ~60% of all of them.
TIL using the find() function in pretty much any ORM is "using it incorrectly" 
Daaaaaamn, that is nice, thanks for answering!
To answer your question in a word: No. To expand: All the benchmarks I've seen show maybe 3-5% overhead, if your memory usage and timings are more than doubling something is **very, very wrong.** That shouldn't be happening even if you don't enable caches. What is it that's wrong? No idea, without looking at your situation.
&gt; Or, if your situation is more flexible, maybe try some other languages that don't have the whole "build up/tear down the environment on every request" thing. And in any dynamic language (and many compile ones) you probably want to use FastCGI for your SAPI. If you are using Apache don't use the PHP module -- use FastCGI instead. I might also add that using FastCGI will allow you to switch to other web servers more easily (I recommend trying out nginx).
I would use something other than phalcon, and just make sure you're caching whenever possible, as well as using a good opcode cache and a finely-tuned web server. Also, make sure your php-fpm is optimized as well
Could be the N+1 problem. Most ORMs handle that problem rather elegantly, but require you to explicitly do something about it. To be more specific, if you have a row (1) in a table that has many child rows (N) in another table, you could accidentally issue N+1 queries to the database. This is usually done by iterating over the relation. e.g. `foreach ($post-&gt;comments as comment)` However, there's usually some command you can run before doing that iteration that would issue a single select for all of the related model objects so you're left with only two queries: one for the parent object and one for the children. From a SQL perspective, this is probably the fastest way. It's true that you could use a join to get it down to a single query, but then you have a mess on your hands trying to disentangle the parent and child records, not to mention that you've greatly increased the amount of data the SQL server must send back and the amount of work the PHP code has to do upon receiving that. Best to simply issue two select statements asking for exactly what you want. And that's exactly what an ORM is going to do for you, if used correctly. Bonus: If you're using foreign key constraints, you already have an index on the column in the child table that you're selecting against.
Here are a few cases in which I have missed having generics or template parameterization in PHP: - `Iterator`. I often just have to go through an iterator or read the documentation to see what it can hold. Having a generic type such as `Iterator&lt;Foo&gt;` would let me know that the iterator will always return Foo objects without having to look up anything else. - `Optional`. The `Optional` is a structure that holds a value or it doesn't -- kind of like having a `Foo` or `null` except generally considered to be better (I won't debate the merits of it here, it's just something I've missed) - In algorithms. It is common to have `map`, `filter` and `reduce` operations for things that have multiple values. Having type-safe algorithm signatures would be nice. Below is an example for a type-aware filter algorithm. It uses the concept of a type signature in the callable which we don't have either. It also uses generators, scalar types and return types: function filter&lt;T&gt;(Iterator&lt;T&gt; $values, callable $predicate(T): bool): Iterator&lt;T&gt; { foreach ($values as $value) { if ($predicate($value)) { yield $value; } } } You might be wondering… why is that any better? For me there are three big reasons: 1. You don't need to check for error conditions. If the iterator returns an incorrect value the engine will catch it for me. If the predicate has the wrong signature the engine will take care of it for me. The engine does the type checking work, which is really nice. 2. You can more easily check the code for errors *without running the code*. This is generally known as static analysis. Having generics makes it easier to check to perform static analysis (and in some cases it makes it possible where it it is impossible without it). 3. You can look at a type signature and understand more about what is expected of you as the user. I know that the Iterator values and the predicate parameter type need to match. I know that the predicate needs to return a boolean. Essentially, generics help me to write more understandable and more correct code. It does require a higher learning curve for both the writers and the users, but once the learning is acquired it's significantly better when the type information is valuable. 
I've used both. Phalcon is great if you are intermediate-advanced. Laravel is great if you are fresh to PHP / intermediate. That being said, we've had several juniors and interns new to PHP pick phalcon up incredibly quickly. I personally find it faster to develop in Phalcon because its more of a glue framework. It doesn't include anything extra. You pull in composer packages of just about any functionality you need and you are up and running in minutes. Laravel on the other hand includes the kitchen sink. It also has its own packagist just for got laravel packages (packalyst) which can make integrations easier if you don't have a lot of that under your belt. Summed up. Laravel holds your hand. Phalcon prepares you and forces you to learn application development
Awesome, now I can watch the sessions which clashed!
We use phalcon and heavy ORM in the majority of our appllications. App response time in the range of 40-70MS. We cache metadata and as many relationships as possible. That being said, in our API's we try to use SQL where prudent. 
[This](http://www.reddit.com/r/PHP/comments/31e96e/i_cant_wait_for_generics_in_php_and_no_not_just/cq0uavl) is a better answer...
There are file-backed cache providers you can use if you really don't have any other option. Those are still a lot better than nothing. You can also see if your proviser has APC or XCache support, which work just about as well as memcache if you're working in a single-head environment.
&gt; the mysql library itself will be faster then PDO Do you have benchmarks for that?
The app I'm speaking of is actually pretty fast for the amount of work it does, and the hardware footprint- it's a BI tool that runs aggregate queries via Doctrine DBAL against a data warehouse that is dynamically generated before ETL runs from metadata, using the DBAL SchemaTool. It could be faster if we were to do in-memory OLAP, but our customers are satisfied, so the dev expense isn't justified yet. There are a lot of ways we could throw money at it to improve performance beyond the 200ms mark, but with only one full time developer writing a fully functional BI tool, I'd say that's pretty decent.
You should have some option to turn on query logging in the ORM, or as a last resort, turn on query logging at the DB level. Compare what queries are being run in each setup. It may be that the ORM is generating a lot of slower queries (or it's assuming indexes exist where none do). Or there may be a lot of overhead. Or... it may just be that the overhead is ... ~30ms, regardless of how many queries, and that it's a fixed overhead for the ORM setup phase? Lastly, some ORMs have the option to let you have expressive query building, but skip giving you back objects, returning plain arrays instead. That's going to be much faster, and if you're not *doing* anything with the data - if you won't be making any changes - the data is basically read-only and you should go with the plain-array option when possible. 
As strictly a development environment, is there no love for EasyPHP here? It seems like the only comments about EasyPHP are being downvoted. I find it incredibly simple and lightweight, and it works into my development process very well. I use EasyPHP to develop locally on windows, then I use my linux test server to make sure everything works cross-platform, and it feels like the best of both worlds to me. Am I missing something? Is there something negative about EasyPHP that I should know?
I work for Code Climate, so if you have any questions on that, just let me know. As random314 points out, we have an awesome support team. We also have a dedicated team of Devs working on new features all the time. We currently support PHP, Ruby, JavaScript, and coming soon, Python. We integrate with all flavors of Git, and we provide SAAS and on-site versions of our software. We also integrate with lots of productivity solutions like Slack, Jira, Hipchat, and more. We integrate right into your PR workflow to let you know if the changes to your code are introducing issues with security, clarity, complexity, style, or bug risks. Each check that we notify you about isn't just an error message. It also includes a "readup" that tells you why we flagged the issue, what risks it produces for you, suggestions for how to refactor it, and suggested articles and presentations so you can learn more about the issue and improve your coding skills. Our goal is to not only improve your code, but to help you improve your skills as well. 
Why did you just make a claim that it's faster if you're not going to or can't back it up with statistics yourself? The major selling point of a library or framework is that it saves upfront time and aggregates best practices. Yeah, I could write my own test but how am I going to be sure that I'm testing the right things in the right ways that mimics a real-world scenario?
Yes, in theory. I believe laravel loads a lot of packages that are not necessarily used on a page. To speed up having to locate all that code, it even caches it into a single boot file. It is that kind of thing that writing your own package glue instead of a full framework can avoid. Laravel makes development rapid, and maintainable, but at a performance cost. These things just need to be weighed up.
They're not the only criteria. Do you think that the in house framework is going to change in new and incompatible ways for reasons that don't affect you? Do you think the external framework is going to be focussed on just the things that you need? Is it going to be easy to just change out a single component of the external framework? How much does it matter that it takes someone an extra 2 weeks of a five year career to come up to speed?
All of the packages being loaded into the container by Laravel are listed in a single array, you should be commenting out packages that are entirely unused before deploying the application and utilising deferred loading where possible to avoid requiring infrequently used packages on every request.
Good tip. Edit: just been through a project and commented out the service providers that are not used at all. Speed seems zippy enough now. Also set my own providers to `$defer = true`where I know they won't be used on every single page. Thanks again - never come across `defer` before.
I call it the _More_ PHP Paradox. It is the phenomenon in PHP ecosystem which aims to solve every problem throwing more code - not very different from what happen in Node.JS/io.JS world. The real issue is that in other slim languages, like C - you cannot escape the need to add more code to solve your problems because there is no code available first off. In PHP, otoh, you have almost everything available in the main binary - network access, check; curl, check; native DB drivers, check; CLI args parser, check ad eternum. However you still see projects like Guzzle (network access and curl); several ORMs (Doctrine, Propel etc); Symfony's Console component etc. So when you are coding in PHP, you might find yourself coding in several semi-DSLs - Guzzle expose its internals in one way; Symfony's Console expects to hold the application; Doctrine annotations on T_DOC_COMMENTs... All of this happen, and will continue to happen because in PHP way of doing things, the right approach to solve problems is not to fix the language (which is almost impossible by contract and by politics) but to extend the language throwing more code into the problem at hand. You wanted a better PDO, what you got was Doctrine with all its internal dependencies plus Symfony's Console (https://github.com/doctrine/doctrine2/blob/master/composer.json). This is the main aspect of what I call the "More PHP Paradox". 
Also, you can drop out of ORM mode and just use a raw db connection any time you want. Even if you simply start off this way and use ORM for basic CRUD you will be loads better off.
PHPmyAdmin - do you know what this is? This is database browser only. 
What does that mean? 
1. Sure when you get started perhaps, our in house framework had it's routing, dbal/orm, session handler, forms, security etc built about fifteen years ago and it's broken BC on our schedule, not someone else's. Symfony is a good point and a great framework, not many people have symfonys record though. 2. Its more I can do this and not have to care about supporting this, that and the other use cases and have to worry about PHP 5.3 compatibility. YAGNI applies when building for yourself, when building for others it's different. 3. Plenty of frameworks aren't easily customisable (symfony gets this right), if upstream change their abstraction then you have to redo it, you get to find all the bugs where the theory of how to replace a component doesn't match reality. 4. Maybe. We never ever do that and perhaps that is partly the reason why. We forecast demand well, employ staff on permanent contracts and treat them well and have good long term relationships with customers.
&gt;They are partly why the foundation didn’t make Wikipedia pages available in a version adapted for mobile devices until 2008, and why the site didn’t get a user-friendly editing interface until 2013. I'm not sure how the UI is PHP's fault.
I don't think structure is quite as self-evident as we'd like to think. Having a big file that basically says what all the methods and classes do is a waste of time, 'cos the code/tests/comments should explain this but sometimes you need to document the Why and provide a bit of a "users guide" as well.
ELI5: PHPMyAdmin does for databases, what you try to accomplish for Blog-Entries. If you want to read/write from and to the Database, PHPMyadmin lets you manage, you will very likely have to use MySQL or whatever other SQL your Database requires. Most likely MySQL though. A simple google-search with the terms "php mysql" should give you all the information needed to do so. But if your teacher wasn't even able to give you enough information for you to know that you have to use mysql, I probably don't want to go to that school. Hope it's not that expensive. 
&gt;Having a big file that basically says what all the methods and classes do is a waste of time I agree. And if that's what your tests look like then your tests are a waste of time too. I have no tests that look like this. My tests are based around behaviour, not classes and methods. And I don't have one big file that tests everything. I have individual test files based around classes, but the tests themselves are all based on behaviour, not the structure of the class or methods contained within. This is where people are going wrong.
On one project my test suites (using Doctrine) took up to 30 minutes. Without Doctrine, 8 minutes. If you care about performance, have the foresight to do the testing to find out what impact the ORM has.
You don't strictly have to switch language if "build up/tear down the environment on every request" is your bottle neck. Tools like Gearman or any other message queue system doubling as job queue for that matter, can help drastically by abstracting away your request, and allow you to run back-end processes for long period of time. Yes, then the 'PHP is not supposed to be a long running process and memory management becomes a huge issue' things comes into play, but it is cheaper to kill the back-end workers and spin up new ones as opposed to dealing with the build up/tear down.
I think you need to understand the tools and language you are using. 
They're a student -- what do you think they're trying to do?
Basic steps (also, **use PDO**): * Connect to database (http://php.net/manual/en/pdo.connections.php) * Query database (http://php.net/manual/en/pdo.prepared-statements.php) * Take result and display it how you like (usually the result is an array, if you are looking at multiple rows you can loop over them easily with a for loop :))
It doesn't have to do eager loading that way. I don't believe the active record implementation in rails does that (not sure) but it isn't that hard to do "the right thing" in an ORM if it is written properly.
&gt; Like I said, if performance really is an issue for a query then just grab a raw connection. Which I was adding to by saying a simple timed run of your test harness should be enough to tell you what your ORM is costing you. &gt; The reason your tests run slow is most likely debugging and profiling that doesn't run in production. This is not the case since it's all the build test anyway. You seem too worked up to read my post, which wasn't directed at you in the way you have addressed.
The first part is very true, hovever: &gt; throwing more PHP code in a project does not make it better Wait what is *better*? ;) Performance, maybe not, but the rest certainly is impacted. My point is: not everything is about performances in every project.
A quick question, what if you need to use an static method of a class? should you add a public method to an object of that class and then pass the object to the constructor? that's the way it works? 
Could you explain more? I'm a sysadmin by trade and know enough of PHP and SQL to write some internal applications. If i block access to my webserver with firewalls and/or HTaccess, why would i still need to worry as much about security? The only scenario i can see is that one of the machines on my network becomes compromised, then giving a malicious person access to my box(which also is secured, *nix style). Is that what you were referring to? 
A previous version of php-analyzer can be found at https://github.com/scrutinizer-ci/php-analyzer Not sure if it reflects the current state of things though.
If we're talking about Eloquent, that's exactly what it does... http://laravel.com/docs/4.2/eloquent#eager-loading &gt; foreach (Book::with('author')-&gt;get() as $book) { echo $book-&gt;author-&gt;name; } &gt; &gt; &gt; In the loop above, only two queries will be executed: &gt; &gt; select * from books &gt; select * from authors where id in (1, 2, 3, 4, 5, ...)
Couldn't agree more. And if coverage and code style are your thing, scrutinizer can do those too. Just expensive for private projects
basic and very simple
Laravel powers a site with 15,000,000 uniques a day. Heck, even the main Laravel website gets 50,000 hits per day on a little 2GB server and does fine.
We do presently, but you missed the bit where I said we'll be implementing a lot of personalization which will mean certain parts of caching will have to be removed. 
Probablemente reddit no sea el lugar para dejar scans de libros con derechos de autor en español.
Try [PHPStorm](http://www.jetbrains.com/phpstorm/features/) instead.
I run a Phalcon network of arb sites that handle ~30 million visits a day. Phalcon has been fast and rock solid from day one. Our decision was made mostly on the overhead of other frameworks. Laravel and Symfony are pretty cool (I prefer Laravel since it's easier to configure), but both frameworks add around 15-20ms of overhead just to get to our code. We aim to deliver fully, non-cached dynamic pages in under 30ms, so both were out of the question. Phalcon on the other hand routes, loads the DI and the config for around 20 services in under 2ms. The memory overhead and CPU usage is also pretty low, and this has enabled us to save on hardware big time. There are only 6 small-sized VPS running the whole web side, comfortably handling over 2000 req/s at peak usage. The same app in Laravel would have required twice the capacity. HHVM is quite interesting, but it doesn't play well with some of the C extensions we need to run the system (LevelDB, ZeroMQ and phpredis), so we can't use that yet. The only problem is that the community is not as big and vibrant as Laravel's, and there aren't so many out-of-the-box packages to use. There's also no easy way to fix issues directly with Phalcon, but we are yet to find a bug. Let me know if you have any doubts, I'll be happy to help. 
I'm curious what types of tests would take 30 minutes. How many tests are there? It must have taken a long time to write the same tests with raw queries *and* Doctrine.
I suggest checking out https://github.com/danielstjules/pho
I think you underplay "expressiveness". Comprehensibility is important both in terms of writing something in the first place and maintaining it in the long run. In terms of outright cost these 2 elements are *in the vast majority of cases* going to outstrip any cost in mitigating performance by throwing more server hardware at the problem.
What kind of performance difference are we talking about? Because in my experience the trade off in performance has been more than acceptable in light of the savings in terms of development effort. In cases where it DOES become a problem you have the option at that point of dropping down to a query builder to write the exact hand rolled bit of perfect SQL, but in most cases the 'overhead' of using the ORM isn't worth it.. You may be optimising the wrong thing...(that is to say you're probably going to get far more milage out of optimising your database).
This paradox can be solved by something like Phalcon though : Instead of adding more PHP you add more C, which is supposedly a lot faster. But I thinks for most CRUD apps or websites it's not really worth the trouble : Your bottleneck will almost always be DB access, and for websites you'll end up caching everything anyway.
I really would like to understand where this dichotomy of expressiveness vs cost/weigh comes from. It is possible, and desirable to have fast and expressive code - even expressive first, fast second. My problem is the bloat. And it is very easy to get things bloated - bloat vs speed/weigh is the true dichotomy here. You wanted a better $argv, what you got was a whole Symfony Console application. Really? So you are coming from a false starting point. There is no such dichotomy between expressiveness and cost. There are many ways of achieving high expressiveness - and lots among them without code bloat. 
Yes, I know this was posted a year ago, but after seeing the rust/c post I think it's relevant to remind everybody about the existence of the awesome zephir.
I select classes that I think are relatively stable EDIT: I always develop in php and then transfer as verbatim as possible to zephir. You can't debug/step through the extension, so as long as I deem that a necessity I'll keep it in php. But for deployment it would be worth it especially for computationally heavy functionality like looping through data of various kinds, which I do a lot. It's not a big deal to recompile - on linux the compilation process takes care of everything, copies the extension to the php-lib folder in the end so you only have to restart your server. Off the top of my head I think the full compile command is just zephir build inside your source folder when you're done editing. I use phpstorm for the zephir dev, it doesn't fully support it but it's usable. An extension lives in its own namespace, so just make sure your namespace doesn't conflict with other namespaces. You just call your classes like any other class (it is, of course, already loaded, so no autoloading needed): use MyExtensionNamespace\MyClass; and $myclass = new MyClass(); I find everything these guys do to be surprisingly simple to use, the phalcon framework, the zephir language.
you can use vagrant image for php 7 built by Rasmus https://github.com/rlerdorf/php7dev
Yup... snapshots based on master is available in the php windows site..
Do you really need the whole bloat? That's my point. 
The point is not the cost of developer. Developers are more productive using predictable and highly expressive tools. For sure all that is a give in PHP ecosystem. The cost of hardware being cheaper than developer is not an universal truth. In US, yes; Europe maybe; but there plenty of places where buying hardware (or renting it) is not a choice. But again, hardware is not the problem here. There is no dichotomy between Expressiveness and Cost. You can have something highly expressive (yet incomprehensible) and that's cost a lot to maintain (either by scarcity of man power driving hiring costs upwards or because it is a restricted domain of knowledge), as much something very expressive and cheap to maintain (abundance of resources in all means) But again, this is not the point. The point is bloat. The guy asking the question just realized that introducing an ORM in his stack double the runtime cost of everything. So, is it possible to have Expressiveness and Good performance yes? How? Avoid bloat piece of software... That's the core of The More PHP Paradox: in making things only more expressive, package creators are just spreading runtime cost everywhere. When it is marginal, OK. But you have a two-fold increase in the runtime, for sure it is something to pay attention to. 
Is there an easy way to clean the whole cache directories when compiling? Zephir complains when you rename/remove methods and classes, since they are still present in the header files. Running the basic clean-up commands do not help (at least, in Windows).
I believe zephir clean Actually, just type zephir at the command line, and it will give you its options EDIT: Just saw you're on windows. I don't know about windows I always try to avoid any development on windows because it's always a hassle. One place I work where it's all windows I do my development in a linux vm.
You know, the documentation is great. But Zephir may already have served its time. In particular since HHVM took inspiration from it. You can write mixed-native extensions by [mashing PHP, Hack and C++](https://github.com/facebook/hhvm/wiki/Extension-API) more easily. And unlike Zephir, there aren't any arbitrary / cargo-cult constraints; for example doesn't impose namespace wrapping for *everything*.
Well, that's what happens when you develop using a beta of any software. Zephir is supposed to give support to both OSes, however, the main OS of the developers is indeed Linux.
Your unit tests shouldn't use a real database. Use a in-memory db with predefined data sets. Or just redefine your test logic. Test behavior rather then data sets. 
I definitely see this in other languages as well, but you are right in asserting it is common in PHP. Even with PDO, the DB API needs a serious overhaul. I'm not even sure ORM is the way to go. I prefer the managed context API such as those implemented by Apple's Core Data or Microsoft's Entity Framework, but that's just me. Phalcon was an attempt to circumvent the More PHP Paradox, and to a large degree it works. But I think the creation of such plugins and libraries highlights the elephant in the room (pun intended): that PHP still has an identity crisis. Not nearly as bad as before, but it's still there.
Well, I work on very high throughput, realtime applications where the difference between 50ms and 100ms can add up quite easily and degrade end user experience.
&gt; Your unit tests shouldn't use a real database. I totally disagree. You only use alternate technologies when it's not cost-effective to have a mirror of production. Once you have full coverage of unit tests, you do integration tests that include workflow (when you have the time and confidence).
The average reaction time for people is about 250ms, so I use that as a benchmark. [source](http://www.humanbenchmark.com/tests/reactiontime/statistics) Given, that's just if it's a simple page load and not some API call that needs to be in realtime (i.e; /r/thebutton)
Well having my unit tests run 8 to 30 minutes isn't really cost-effective. Unit tests should be small and fast. You achieve this goals with less test dependencies. A complete mirror of a production database is a big dependency. Only circumstances where I can see any benefit of testing against a real database beside the fact, that one of my test dependencies is my database is, if I have very complex queries but at this point: If your queries are really shiny, complex and fantastical: You ain't gonna use an ORM anyway or you shouldn't. This SO thread shares some good points of testing database driven software: http://stackoverflow.com/questions/145131/whats-the-best-strategy-for-unit-testing-database-driven-applications
Indeed there are situations where you can just get arrays and return it as JSON. Model instantiation does come with some overhead, but that's just the nature of ORMs. Like you said, it really depends on what you're doing, how critical the performance is, how maintainable you want your codebase, how rapidly you want development to be. It's not wrong to use an ORM, it's not wrong to use raw queries. It really just depends on the scenario. However I'm not arguing that. The point I was making is that ORMs can be used without the N+1 problem of having to run more queries than a hand-written solution.
It's not bloat. It's more than what you need right now, but it doesn't matter, because it what it takes away from performance is so small, that it can only be seen if you measure it. It's a well written, and battle tested library, that is going to be a hundred times more robust and better than you can ever write. It also comes with docs, so any time you have someone else working on it, it's just a matter of looking up things there. Is it more that what you need right now? Yes Does it affect performance when you measure it? Yes Does it affect performance by so much that it matters? No.
He's wrong. More code can equal better performance easily. See my reply above.
More code that render better execution paths, maybe. That's what PHP internals have been doing for PHPNg. But the orthogonality is the key here - when you have the option to choose which extra code you're adding then you are totally right. It does not happen in practice in PHP ecosystem - virtually all good packages have deep dependency trees. So even if they are well-crafted ensuring you have the power to choose, the odds are that the dependencies are not that well-thought.
I tried PHPStorm about 6 months ago, solely for the refactoring features. I wan't able (or figure out) how to perform basic class and package refactoring, i.e. a) rename a class so that all it's references throughout the code base are updated automatically b) move a class into a different namespace and that it's references are updated automatically. I was at least expecting these two types of refactoring to work, but it didn't. When we talk about refactoring in PHPStorm, what features are we actually talking about? PS: I've used the refactoring features in Eclipse/Java for many years, there it seems to "just" work. Maybe my expectations aren't realistic? 
Those a good point, it's interesting to read. I will also add this, it doesn't invalidate what you said: another reason I tend to use interfaces and classes instead of functions is that it allows to use dependency injection and mocks in tests. PHP provides very few API implemented with interfaces and classes, so I end up importing a library that is just an OO wrapper around low level functions (instead of rewriting one every time). Take for example Symfony's Filesystem: I sometimes import it (and use only 10% of its features) for the only reason that I am then able to mock the filesystem and test my classes. Yes I could sometimes mock built-in functions with weird hacks, but using a library (or a class I wrote) is much easier, and when performances are not critical there is usually no issue.
Ok. And then something totally unexpected came up, I don't know what to make of it or if it's appropriate to hijack our discussion with it here but I will at least mention it to you. [This reddit thread](http://www.reddit.com/r/programming/comments/31igos/open_source_lawyer_on_the_implicit_patent_grant/) pointing to a comment on [this HN thread](https://news.ycombinator.com/item?id=9111849) basically says that FB's bsd lincense is booby trapped - [this comment](https://news.ycombinator.com/item?id=9112177) in particular.
why does php-fpm need to be reloaded? never had this issue with dploy.io - but I am wanting to switch to save $5 a month. :) I tried running that command that the setup told me to to allow reload without password. I also tried this http://stackoverflow.com/questions/19998526/ubuntu-php5-fpm-throws-unknown-instance-on-reload/29353181#29353181 What gives? O.o Any way to disable the need to reload?
 $email = &lt;&lt;&lt;EOT value: Somevalue date: date value source: source name EOT; preg_match('/value:(.*)\ndate:(.*)\nsource:(.*)\n/i', $email, $result); Your results would be in $result.. and would look something like this Array ( [0] =&gt; value: Somevalue date: date value source: source name [1] =&gt; Somevalue [2] =&gt; date value [3] =&gt; source name ) I use this [regex tool](http://regex.larsolavtorvik.com/) whenever I need to quickly workout some regex 
On PHP 5.5+ the OpCache needs to be refreshed. A symlink change won't trigger that refresh so had to be done manually.
What am I missing? You agreed to submit a pull request then eight months later decide to post here instead?
Looked through a few of these (episode 9 to 12). Unfortunately, it doesn't touch on the two refactoring issues I had.
If every email comes in in the same way, consider writing some sort of monitoring service that listens to the inbox and parses the email without human intervention. Having to copy-and-paste the contents of an email into a script is exactly the sort of busywork that you should try and automate away with software.
But one that every developer (at least, the ones I have met) never can master. 
It's pretty normal when dealing with infosec issues to give a grace period for the project to address the issue and then post it publicly. 
Practice. 
Precisely. Normally I'd post a link to the ticket on full disclosure after N months of it remaining open.
Can't you just right click on the namespace or class name choose Refactor -&gt; Rename. This searches through all code - just tried using the preview and it seems to do exactly what you described.
Wikimedia's lawyers didn't seem to find any such issue. I can't imagine they would have deployed HHVM throughout wikipedia without taking a look at the license considerations. If it does end up being a problem, then i'm sure the facebook folks would end up changing it though.
I just noticed this "Restart FPM After Deployments" has that always been there?
For those two in particular, it might just be because it's somewhat counter intuitive compared to the what you're used to or expecting, I know it was for me at least. You can't refactor a class or namespace by refactoring the file in the project tree, you have to go into the file and refactor the class name or namespace itself, and then let the consequences of that refactor act on the file name and location, and then all of the references to it. It doesn't change things when you act on a file because it's not strictly required that anything matches for PHP, and if you want to have file names that don't match the class name and 3 different namespaces in the same folder, it's not going to stop you, it'll just tell you that that's the case if you don't turn off the inspections. Overall though, your expectations probably do have to be adjusted a bit because you just can't statically analyze PHP like you can Java, but if you're willing to invest some time in writing out doc blocks with @param, @return, @var, and @property annotations with the correct types, it'll be able to do a *lot* more with your code. I keep basically all of the inspections on and I've gotten into the habit of just fixing everything I can, a lot of which end up being solved with doc blocks, and the refactoring tools work very well for me.
It's not like the issue is closed. You agreed twice to submit a pull request. I'd bet the issue just fell through the cracks while they were waiting for you. I don't understand why you would post here without following up on it first.
how do we handle images uploaded to public folder? They get wiped on each deployment.
&gt; Not true - not everywhere. Show me where they are not? &gt; Any place whose currency is devaluated against dollar plus tax. Not so unusual actually. Find me a country where you can hire quality developers for less than $1 USD/hr (a very generous cost of an EC2 instance - they can be had for much cheaper) and I'll eat my hat. &gt; That's the heart of the More PHP Paradox: if PHP did not have batteries included I would not care. For starters, let's not call it a "paradox". It would be a paradox if more made it faster. Nobody is arguing that. It stands to reason that more abstraction, all else being equal, slows things down. We all accept that. There is nothing paradoxical about what you are proposing. Now, to batteries included - and correct me if I'm wrong here. You seem to be arguing that because PHP includes some higher level abstractions out of the box (PDO in this instance) there is no value in building ever more abstractions ontop of this (aura.sql, doctrine dbal etc. Further, you seem to be arguing that using an ORM is unnecessary because PDO exists, even though PDO and ORMs have very different concerns? Further to that, you seem to be arguing that the only benefit additional abstractions (aura.sql, doctrine dbal) or an entirely different class of concerns (doctrine2, propel, eloquent, cake orm, etc) are unnecessary and we should simply defer to PDO for all cases where we would otherwise reach for these tools? Because if that is your argument, you are arguing in favour of Not Invented Here. Because at some point you will hit the ceiling that PDO's abstraction provides you and you will end up building your own abstractions to wrap PDO, or your own ORM to map data to business concepts - and this way madness lies. &gt; Let's get the correlations right. There is a strong correlation of lack of expressiveness and cost, ie, the more incomprehensible that code is, more likely it is going to cost keep it. A code with a high level of expressiveness does not make a code necessarily cheaper to maintain, because expressiveness is not the single factor affecting cost. Lack of expressiveness makes things costlier, expressiveness does not necessarily make them cheaper overall. all else being equal, comprehensible code (let's stop calling it "expressive", let's call it "comprehensible") will cost less then code which is not comprehensible. Comprehensibility is of course a multifaceted thing, and included in that is developer experience (how easy the API is understood), documentation and a myriad of other factors. But generally speaking code which is difficult to comprehend will cost more to maintain than code which is not difficult to comprehend. Even if the code which is difficult to comprehend is several orders of magnitude faster at runtime on the same hardware. &gt; Bloat cost is easily proven in indirect costs: increased combination of dependencies ... diminishes the pool of available skilled workers to work on your project. Sorry but this sounds like the way you are hiring is you are opening up your composer.json and writing the job description to state that you need experience with all of the libraries currently in use on the project. If you are doing that, please stop. You are not only making it harder on yourself by diminishing the pool of developers you are ignoring talent which has not been exposed to your choices. I recently hired an entire offshore team in a country which has a very small pool of Laravel devs. I didn't even mention Laravel in the job descriptions. I sought broad problem solving skills, demonstrated knowledge of OO concepts, exposure to certain design patterns etc. None of my candidates had touched Laravel but inside of a week they were being productive. At *worst* you should mention your core technology decisions...rattling off every single requirement in your composer.json is ... stupid. A quality developer may not even *know* PHP... a quality developer will be able to quickly learn the *language* even, to say nothing of abstractions you are chosing to use. &gt; Perfect, so you wouldn't be burned by dragging around extra code that does nothing for you - neither making it costlier nor interfering anyhow with your runtime. It really depends on the application - I know cases where 10ms difference trickles down into a 150ms latency (mobile networks). Yeah and 150ms is nothing. If you are attempting to fix this in PHP, you are likely optimising the wrong thing. &gt; If the runtime cost was not significant, the OP wouldn't have posted right? Not necessarily. The OP doesn't make it clear what his reasons for posting are, only that using Propel doubled his time to service a request. He mentions nothing about WHY they've decided to go down the ORM road, or what efforts if any have been made to mitigate the performance degradation. Or even whether the slow down is significant.. it reads to me like a simple "hey is it right that an ORM would double the amount of time it takes to run this thing?"
When developing and deploying projects, what tools do you use for smooth transfer? I develope on virtualbox using CentOs and when everthing is ok, I push my finished project to bitbucket, then acces it on my production vps via putty and pull the relevant project from Bitbucket, but there is always some problem with dev/prod related errors. Like forgetting to change something from dev code, then I get errors in production which means I have to alter the code via vim and make changes quickly. The database issue is even worse in that, if I have to create more columns for a project in local, then on production I have to do this manually. Because if I do mysqldump on local then send this sql file to my vps, I would have to drop production database for this project, which is a problem because there may be new data there. Its just a hustle, and it feels like there is a piece missing in the puzzle
Another solution: use PHP's built-in [php_ini_string()](http://php.net/manual/en/function.parse-ini-string.php) function. If you are able to make a tiny change to your email's syntax to match .ini syntax, this one function will do all the parsing for you. Unlike the regex, variables can be in any order and additional or missing variables are handled too. $data = php_ini_string($_POST['mytextarea']);
It's less "the right tool for the job" and more a factor of the following: 1. Is dev speed more of a priority than performance speed. 2. How experienced is the team building this, or is it a solo venture. 3. Who will be looking after the project when initial build is complete. 4. What is the expected lifespan of this project. All of these factors can lead you to the correct choice about language and tooling for the project, but the inexperienced developer will just shout "use a framework!" for everything because it's all they know.
&gt; but there is always some problem with dev/prod related errors. Loke forgetting to change something from dev code, then I get errors in production which means I have to alter the code via vim and make changes quickly One possible fix for this is to pull changes into a new directory on your production machine, for instance `/var/app/2015-04-05`, and then switch your httpd configuration to use that as the root web directory. If something goes wrong with the code in production then you change the root web directory back to the previous directory. This essentially allows you to "roll back" your upgrades. You can also test the code in `/var/app/2015-04-05` before making the switch.
I'm talking about two machines, how does environment variable help with anything?
&gt; After a while, you're going to really be running yourself ragged by constantly reinventing the wheel by "doing it yourself" when you could be doing something better, This depends solely on the development team. I have worked for multiple companies where their own framework was excellent and solve their problems for their team in a considerably better fashion than trying to jam an existing framework into the situation. Frameworks are great, I helped build a shitload of them, but they're also not always the answer and going it alone needs to have less of a stigma attached, especially these days compared to 4 or 5 years ago.
You read all of that and you're still saying that CodeIgniter "supports" PHP 5.2, by actively recommending users install PHP 5.4? I'll say this until I'm blue in the face: &gt; Arbitrarily breaking PHP 5.2 support "for the good of the community" is nonsense. They recommend PHP 5.4. CodeIgniter happens to work on PHP 5.2. That's absolutely fine. And expecting CI 4 to take 3-5 years based purely on that being how long CI 3 took is a weird guess. The project was abandoned by the main team for a few years there and only had one guy working on it for ages. Now there are a team of people expecting it to be another 3-5 years is silly.
I'd recommend using something like [dotenv](https://github.com/josegonzalez/php-dotenv) instead of shell scripts.
Alternatively to something like environment variables, you can just detect your environment from the host value in $_SERVER and select a different configuration that way. The default is always production and then setup as many alternative configurations as you want. I don't change any code or configuration from dev to test to production. 
Yea, there are many many (better) ways to achieve that, I was just trying to demonstrate the easiest way to get started without an external tool. 
It's absolutely necessary in a multi stage environment. It's how it's done in the big leagues. Once you get that setup you can look at a service like CodeShip to automatically run tests and deploy your code to your server on every git push. On my projects I have it setup so when I save a file it gets copied or uploaded to the dev box. When I push commits codeship automatically checks out the new code, runs the tests, then deploys the new code to my staging server so the client can see the changes. Everything works 100% automatic and I don't have to touch anything once it's setup correctly.
No it doesn't. I either moves or renames it but it doesn't update any references to it, which is what I would expect.
BTW, the "Doctrine Developers Mailing List" link on the Doctrine-ORM community page seems to be broken. Google Groups just says: 'There is no group named “doctrine-dev” '
Extremely common. That's how we do it, but by tag name from Git instead of (semi-)arbitrary date since we may release multiple times a day. You can also do a symlink from the docroot instead of a real folder and just modify that. Either way.
Just wandering, is there a guide/tutorial for these things?
If you don't commit your config file you lose the ability to track, and, if necessary rollback changes to it's structure. It's a way to maintain a separate copy of your config's data and it's structure. Structure is in source control because it's the same everywhere while the server-specific data is stored locally and not in source control. It's also for security. If someone gets your codebase they'll have your config but not your passwords. With only two systems it's not a huge deal but when you've got to roll the same code out to a dozen systems all with slightly different environments (and certainly different hostnames/ip's) it makes it much simpler to just dump the code everywhere and setup the environment variables via a chef or puppet or grunt or whatever during creation. 
An introduction to PHP's Filter API that I've banged out. For small projects not using a framework, and for writing custom framework, this API can save the developer some time over reinventing the wheel.
Does php has the concept of numeric strings[for keys in arrays] yet ??
Wat? why.
Would you rather prefer paying an experienced developer for the accurate static introspection? Yeah: that's what I thought, indeed.
Urgh, those links need to be updated indeed :-/
I'm not sure I understand the question. You can definitely use a a string like "42" as an array-key. If you're concerned with some of the weird PHP magic that plagues the core array type, that might be an argument to use "real" maps or other array-like-objects instead.
I hadn't run across either of those plugins before, thanks for those!
I'd submit a pull-request for [them](https://github.com/doctrine/doctrine-website-sphinx/blob/3220a2942fa90afe2806edf65b7ddc17273c46d8/site/community.rst), except I'm not sure what changes would need to occur. If I have a small feature I think I could add, where's the best place to go to get comments/buy-in?
Sometimes, i'd rather not pay for it at all. I mean, PHPStorms does a decent job.....
"You can definitely use a a string like "42" as an array-key." &lt;-- php typecasts string 42 to integer 42.
It was intentionally vague, in hopes that it would be found humorous (by omitting context). Apparently I had to make it as obvious as possible (removing the humour)
Why would I do this? Same thing can be done through own loop.
Since it is there, why would you not? It's simple, it's easy to read. And it allows to easily re-use the same data for multiple tests. Plus it's a standard behaviour in PHPUnit, so following it makes it easier for new developers in a team to understand your code.
Uhm... yes? I'm still not clear on exactly what your use-case is, and I think my previous statement is still accurate. Instead of using just numeric-strings, are you *also* using integers, and want to keep `42` and `"42"` separate? Or are you trying to get something where calling `array_keys()` will always give you a list of strings? You may want to look into [`SplObjectStorage`](http://php.net/manual/en/class.splobjectstorage.php), which as I alluded to earlier, is more like a "real map". 
Not sure where this hostility is coming from. For commercial usage the price itself (149 a month) is payable, even though that the idea of you needing 10 repos making you enterprise is laughable. Any project that has a modular architecture has to pay the max fee (well, or be open source). However if you have some security requirements, such as the quite reasonable "on premise solutions only" it gets rather expensive (ask the guys for a number, the one we got was extremely high). Now for personal usage, I don't see myself paying 149 euros a month. As for that "pay experienced developer for review instead" - that's something I have to do in business life anyways, to mitigate risk, no matter what automated tool runs over the code, you will need more than one person who knows and is able to maintain the code, if not you are building on sand. 
Well, the magical typecasting that PHP does here is pretty much the same that it does all over... so what do you do when you say if ($key == "42") ? Do you go for the key with the int 42 or the string "42"? And saying "you should always use ===" isn't really an answer.
&gt; You are to old... I'm 2 years older than Nick. &gt; People like you destroy PHP language People like you destroy reputation of PHP language... And really, what do you suggest? I just don't like the idea of boxing scalars into objects just to use cool OO-like syntax. I don't mind of syntax sugar, but i don't think that this is something that should be done in PHP in near feature. There is a lot of other problems that need to be solved. Things that were suggested can be implemented as php extension (if extensions can modify AST) and then, this implementation can be proposed as RFC. 
Here is a site explaining the reasoning: http://12factor.net/config (some of the things outlined on that site are great though as always your mileage may vary and I'm not convinced by 3 or 4 of them)
Extension? No. This must be a standard. Look on Cpp and Java - what do you think, why Java is more popular than Cpp? Java is easy, has good syntax, everything is boxed in objects. If you using string you know, all functions to string object is inside this object. You don't need know all functions to string , because IDE give you a help with hint to this object. See: - Java - JavaScript - Python - Ruby In this languages, string is a object, and everyone recommend this languages (except JS :) ) Today, you must learn N functions names in PHP. Today we want OO language, not procedural. Procedural is deprecated. Don't make a chaos in PHP.
The article was unreadable on mobile, couldn't close the overlay ad :(
The best advice I can give you is: Document the shit out of everything. Ideas, implementation details, even trivial things. Over time you will learn to appreciate this habit. You will avoid scope creep, premature optimization and everything else that distracts you from your big picture and keep you focused on core objectives of your project.
Also a basic tutorial available [here](http://www.sitepoint.com/getting-started-php-extension-development-via-zephir/).
Exactly this. Large problems are just a series of small problems. The more you break a large problem down in to its component parts the easier it is to concentrate on a small problem that contributes to the larger picture. People are only overwhelmed by a large problem when they can't figure out how to reduce it to its component pieces. To this end, a ticketing system is invaluable for assisting in this breakdown, and making sure you focus on the right priorities in the right order.
From my personal experience there are two things which will help you to create better projects: First of all, experience is one of the biggest factors that helps you to create better projects. Everybody first few systems will be far from optimal. That is just because there are things that you wouldn't think about, unless you experienced them. Second of all Software Engineering books can help you enormously. They give a collection about known problems, and how to deal with them. Mostly they are accompanied with a reasoning/proof why that solution is the way to go, which helps you enormously in understanding in how to deal with such problems. My personal favorite is Code Complete, which deals both with designing systems at a large, and at programming the small parts, while giving a good explanation about why you should or shouldn't do it. What helps to do is to do a thorough planning/documentation beforehand. (Or for this particular project afterwards). It helps future you with understanding the code, and forces you to look into a good design before the coding. 
thanks, really greate tips. But one question, if I have multiple sites in one vps, how can I for example do `export APP_DSN="mysql://devuser:devpass@localhost/schema` since this means now, APP_DSN environment will be the samw for all my projects across my vps? Or do I just just give every project separate shell scripts with varying settings
You might want to learn about [S.O.L.I.D.](http://en.wikipedia.org/wiki/SOLID_%28object-oriented_design%29) Which is a mnemonic acronym for the following 5 principles: - [Single responsibility principle](http://en.wikipedia.org/wiki/Single_responsibility_principle) - [Open/closed principle](http://en.wikipedia.org/wiki/Open/closed_principle) - [Liskov substitution principle](http://en.wikipedia.org/wiki/Liskov_substitution_principle) - [Interface segregation principle](http://en.wikipedia.org/wiki/Interface_segregation_principle) - [Dependency inversion principle](http://en.wikipedia.org/wiki/Dependency_inversion_principle) You also want to be familiar with the following: - [Don't Repeat Yourself](http://en.wikipedia.org/wiki/Don%27t_repeat_yourself) while allowing for the [Rule of three](http://en.wikipedia.org/wiki/Rule_of_three_(computer_programming\)) - [Keep It Simple, Stupid](http://en.wikipedia.org/wiki/KISS_principle) - [You Aren't Gonna Need It](http://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) Now, take a look at [PSR-1](http://www.php-fig.org/psr/psr-1/) and take a specific note of item 2.3. Code in a single file either does something (executes code), or defines something (such as classes, methods, or functions), but does not both at the same time. Files that Do Something are allowed to include or require files that Define Something, but files that Define Something are not allowed to include or require files that Do Something. And the most important of them all: Document everything.
&gt; Procedural is deprecated. OOP is just about inversion of control, but how many times PHP developers ignores this principle. Most of the people in PHP community writes their OO code in procedural style. Deal with it. &gt; Today, you must learn N functions names in PHP. Tomorrow you must learn M method names. I agree that something should be done for more consistency in function names, i just don't sure that you understand my idea that "not everything should be an objects". &gt; Extension? No Why no? Yeh, then no one will use it, i know. Ok, write an detailed RFC. I bless you. And then implement one. Things that you want receive can be implemented even without any performance footprint if scalars will be fake-objects (like in javascript, where scalars just act like an objects and used without need of boxing values into object wrapper).
Is there any progress on adding the ability to pass by reference in zephir?
I learned by doing what you did. I wrote a decent sized project, and did it poorly. Then I spent countless nights worrying about what would happen when I had to go over it again or when another developer would have to. So I spent a weekend or two to rewrite the core and slowly migrating the system piece by piece. Then I looked upon my new work and thought to myself "What a pile of shit". And after many countless nights, and 3 months of thinking, I did it all again. This time I did it in such a manner that when (not if) the system needed to be rewritten again it would be easy to pull something out and do quick changes without affecting much else. I still don't think I did it right, but I never felt a need to rework it again. And I took that with me for the rest of my career. I took that mindset and made use of it. One or two times I redid old code. I still wonder what other devs think coming in to my old projects. But I feel more secure in myself now. And that's how I learned. I kept making messy code until I realized I might always do that. And the main thing is making it easier to unfuck code in the future
Since most IDE's do that for you already, we do not currently include that. We are always open to new feature requests, though. Just drop us a note at: http://www.codeclimate.com/help, and let us know what you would like to see added.
All of our code from 6 months ago is "shit", that's how you know you're improving. There's no escaping that feeling but at least you're constantly learning. My advice to improve organization/planning would be to look into Test Driven Development. I used to just write and refactor and sometimes change the scope of the feature to fit my code. Test driven development, however, starts from the scope of the feature and changes are made to the code to fit the scope of the feature. It's never too late to start, if you intend to maintain this project i think this is the right way forward. Good luck!
what i would do to learn is to do the idea.. scrap it.. do it again.. scrap it and repeat until I'm satisfied.. it isn't practical for doing something with time constraint but it does give me a pretty good picture of what I need to do and how.
I can't speak for anyone else, but I know I was in your shoes once. One thing that you may or may not have done, sounds very simple, because it is, but if you don't get it, you'll stay stuck in this situation until you do. No matter how advanced or newbish you are, it's a great way to structure your code. I've seen PHP professionals screw this up, and end up building unmaintainable messes of code. I've also seen people who are very bad at PHP do it right and allow for well-structured projects, even though they are sucky PHP programmers. Here it is: *Separate your data retrieval (model) and your data display (views) from anything else.* In other words, no matter how simply or complicatedly you're setting up your project to be, you always want your data retrieval to be its own code, and the part that displays the data to also be its own code. You're left with everything else, which is basically routing, authentication, more stuff like that and of course acting as the glue between the display and the data retrieval. It's okay if the code that displays the data knows what sort of data to expect, so if you need to add a column to a report you need to alter stuff in two files. The point is that if you do this right, you'll know which two files you'll need to alter in order to add the column, right off the top of your head. You'll also have three distinct, well-defined parts of your application instead of one, leaving you with a smaller still-unstructured piece: smaller pieces are easier to grok than larger ones. It's this sort of thing that adds structure to your project. This is also the entire point of the item in the PSR that /u/alexanderpas mentions. He also mentions SOLID, which can get a little abstract, but it's the S that can really get you started. This leads me to another concrete tip: If you find yourself building a class that does two or more things, rethink your design. Also build a [PSR-4](http://www.php-fig.org/psr/psr-4/) compliant autoloader and use namespaces to structure your classes. If you start doing these things, you'll find that you'll start grouping classes and functions by functionality (or whatever makes sense), and you'll start thinking about the different directories with the class files in them, as belonging to different parts of your application. And then you'll not only be on the right track, but miles ahead of other people with your amount of experience.
While this series may not be what you're after, here's an awesome one by Igor on [Stack Machines](https://igor.io/2013/08/28/stack-machines-fundamentals.html)
You should not be designing projects with the idea that you're going to need to rewrite the entire thing again. It is seldom cost or time effective to rewrite an entire project from scratch multiple times, and you'll have an impossible time convincing any management type that it's worth either. You writing messy and/or bad code is a symptom of another problem. Probably a lack of pre-planning or discipline. You should be addressing the root problem, and not the other problems it creates.
Since you mention access.log, I'm assuming you're looking to read through the Apache or Nginx logs to check user requests. You might want to look into http://goaccess.io/ - it provides an easy way to scrub through access.log files pretty easily.
I wasn't aware of that. [here](https://github.com/phalcon/zephir/issues/609) is an explanation why it's not easy and a discussion about how to do it. tl;dr: 1. PHP handles reference with some pointer trickery which cannot be repeated outside of php-core. 2. Phalcon was originally designed with javascript in mind which dosen't have by-reference. 3. Phalcon recognizes that by-reference is important but it's not easy to implement. 
A unit test is any test of a discrete component. This can include or exclude a DB/datastore. The terminology is a bit fuzzy because we don't have a lot of evidence as to what constitutes a discrete component.
There's general rule that you shouldn't use loops in your test suites, but why use data providers? It creates cleaner tests and has more comprehensive errors. The following test is simple, but easily illustrates these points. &lt;?php class ExampleTest extends PHPUnit_Framework_TestCase { public function testA() { foreach ($this-&gt;exampleProvider() as $input) { list($expected, $actual) = $input; $this-&gt;assertEquals($expected, $actual); } } /** * @param string $expected The expected value of the test * @param string $actaul The actual value of the test * @dataProvider exampleProvider */ public function testB($expected, $actual) { $this-&gt;assertEquals($expected, $actual); } public function exampleProvider() { return [ ['bar', 'bar'], ['fizz', 'buzz'] ]; } } TestB is far simpler to read the parameters are specified and easily understood. Yes, somebody new to phpunit would have to google "dataProvider". The error messages for these two identical tests are completely different: $php vendor/bin/phpunit exampleTest.php PHPUnit 4.3.5 by Sebastian Bergmann. Configuration read from /phpunit.xml F.F Time: 38 ms, Memory: 4.75Mb There were 2 failures: 1) ExampleTest::testA Failed asserting that two strings are equal. --- Expected +++ Actual @@ @@ -'fizz' +'buzz' /exampleTest.php:9 2) ExampleTest::testB with data set #1 ('fizz', 'buzz') Failed asserting that two strings are equal. --- Expected +++ Actual @@ @@ -'fizz' +'buzz' The important difference here is **ExampleTest::testB with data set #1 ('fizz', 'buzz')**. phpunit tells you the specific offset in the dataprovider that failed as well as the values supplied by that offset. In our contrived example it is easy to see which data set the error came from, but this is not always the case. By using data provider, your testcase became more readable and the error messages became more informative.
Its 100% feasible! [This book](https://leanpub.com/cleanphp) has been very helpful in achieving EXACTLY what you're trying to do. In order to really create a frameworkless application you need to have a good understanding of SOLID design principles. (see http://en.wikipedia.org/wiki/SOLID_(object-oriented_design) ) This has been a recent topic that I have been tackling myself. Through some tutorials I have set up a "SOLID" application shell which attempts to address your question: [My SOLID app](https://github.com/Iconate/solid) Yes it uses vendor libraries but thats because it's impractical to write these certain components yourself (ie I am not going to write my own request handler)- instead they are introduced via Adapters and Dependency Injection so that "should" I ever need to replace or write my own component it can be swapped out rather easily rather than being so closely coupled. Hope this points you in the right direction- I am becoming quite the advocate of frameworkless applications 
&gt;Tomorrow you must learn M method names. No, because i only need type in my IDE "$simpleString-&gt;" and IDE give me a hints with methods. &gt; Ok, write an detailed RFC. I don't need. Nikita Poppov and Joe Watkins already write this (PHP contributors) https://github.com/nikic/scalar_objects/blob/master/doc/string_api.md and https://github.com/krakjoe/ustring &gt; OOP is just about inversion of control, but how many times PHP developers ignores this principle. Most of the people in PHP community writes their OO code in procedural style. Deal with it. Because PHP was created 20 years ago, and first object was implemented in PHP 3. Since that time PHP makes small steps to make self full OO language. So, PHP should make today big step to the future of the programming, and we should forget about bad practices with procedural programming. 
Do you mean [this](http://marcofiset.com/)?
Pretty sure he does. I've been following it too. Was just about to post that. 
For JS, nothing comes close to bitHound (https://www.bithound.io). Use it for personal and work projects. Since they this single focus - the tool can dig deeper - i.e. call back errors, tech debt tracking, file insights, check for dependencies... The interface alone is worth checking out - attention to detail in the UX and code makes it a great tool.
I have been using [Rocketeer](http://rocketeer.autopergamene.eu/) for a while and I love it. After committing changes and if tests pass I can deploy using one command. You can also configure it to do migrations for you. $ rocketeer deploy
Glad there are companies such as Facebook and Etsy pushing development PHP forward. 
Yes! Thank you!
Am I missing something here? If you read the posts below, many people were complaining about CodeIgniter still supporting PHP 5.2. Its not just for the sake of breaking PHP 5.2, theres a reason why supporting PHP 5.2 is bad, even for the development itself as you aint utilizing the new features introduced in PHP 5.3, 5.4 and aint keeping the codebase up to the industry standard. Its the first time that I heard I was the only one complaining about CodeIgniter's PHP 5.2 support, I thought its not difficult to scroll down and read other people's comments carefully? 
You are missing something. :) 1. Anthony complained before CI changed its documentation. 2. On the podcast Ed Finkler and others agreed that documentation was an acceptable solution. 3. You're confusing me saying "you're the only person advocating randomly breaking PHP 5.2 support so it literally wont work" with "You're the only person that thinks CI supporting 5.2 is a bad idea". 4. I'm also saying that most people here do not realize that CI changed its documentation. Re-read what I said: &gt; At no point during the conversations that happened via Town Hall or any of our blogs was anybody advocating randomly breaking CodeIgniter for PHP 5.2, other than you, here, now. By that I am saying: You are the only person I've spotted that thinks arbitrarily stopping CI from executing at all if PHP version 5.2 is detected would be a good idea. I think that would be f**king awful, and those who are against PHP 5.2 being "supported" are mostly doing so without the knowledge of the document change. Don't get me wrong, when I discovered PHP 5.2 was not in their built matrix I did push for them to flat out say that [PHP 5.3.3 was required](https://github.com/bcit-ci/CodeIgniter/pull/3450), but fixing their documentation in this way _is_ an acceptable solution. Support is "these are good versions to use." "It just so happens to run on X" is fine.
To be fair, it is literally pasting one line of code into your application, which is the same installation process used by every other PHP application in the world which isn't using Composer. require './vendor/autoload.php'; The CI developers are also incredibly aware of Composer. Trust me.
**Yes!** I wish more devs used `filter_var()` on email addresses when they need/want to validate them.
You probably don't need that many tutorials for a framework you built yourself. Every application has an architecture, and that architecture is the framework. You can install one or make a simple bit of glue between components if you're a tad more experienced. Neither solution is always right or wrong, so yes, something like Proton is a f**king wonderful idea. Alex knows what he needed and how it should fit together, so he did that. Related: http://www.reddit.com/r/PHP/comments/31botn/i_dont_use_a_framework_am_i_a_bad_person/
Using framework is not strictly mandatory but it's recommended because if your project doesn't have a sound structure, the code will eventually spiral out of control. Especially if you are just starting to learn. I'd recommend a micro framework like [Slim](http://www.slimframework.com) or [Silex](http://silex.sensiolabs.org) since they both have good routers and useful helpers but most of the time they get out of the way of your own code.
&gt; the main responsibility is "developing php programs to be used with command line." what does that even mean? They want you to use the [CLI SAPI](http://php.net/manual/en/features.commandline.php). Think writing shell scripts, but using PHP instead of Bash/ZSH. Common applications are things like [message queues](http://en.wikipedia.org/wiki/Message_queue), task runners, migration scripts, etc. If you've used Composer, that's a command line PHP program. You may have to work with libraries that facilitate command-line usage like [Symfony's Console component](http://symfony.com/doc/current/components/console/introduction.html), but that might be a bit much for a junior-level position at the start.
Oh I agree 100% if you're a tad bit experienced building your own out of components may be the answer. Especially if you're fighting some framework rough edges with your use case. But he says that his co-workers are not very savy, so for them documentation and tutorials like Laracasts is key.
The majority of the difficulty I've encountered in migrating to HHVM stems from the lack of documentation (or outdated documentation), and this covers a few areas that don't seem to be widely known, so thanks for posting this!
Didn't actually see that end bit until now. Thanks for pointing that out. Those are both fine micro-frameworks for something small and quick.
I am not a full time developer by any means, but i tend to take on a project every few months to stay sharp on syntax and best practice. I have always been more of a procedural coder. I recently finished my first project without using mysql_ functions. Is replacing mysql_query("qry") with mysqli_query($link, "Qry") enough? I'd love to learn PDO and OOP, but i just don't have the time to devote to learning it that i should spend on it. TL;DR: Am i really gaining anything by using mysqli without prepared statements and OOP instead of mysql_? 
1. Trusting your users/visitors, never do that.... Build it as securely as possible from the beginning. 2. Forgetting the semicolon in the end; 3. Including php files before starting the session and in one of the included files having a space " " in the end of ?&gt; or before &lt;?php == session already started error and sometimes hard to find. 4. Not optimising the code. Reducing load-time by removing stupid "while" and "for" loops is easy but lazy developers just calls it a day and then wounder why the site is slow and has a low google rank (google loves fasts sites) 5. being lazy and use $_POST $_GET $_REQUEST and not protect against SQL injections. 
Many languages do not require frameworks, they just make life easier, in general.
Sorry, I was confused about the question
I've learned to code better since then, to plan ahead and to do things as best as possible from the outset, but I still try to keep in mind the idea that no matter how good I may think I'm doing, I could always be wrong. I simply try to keep my code loosely coupled so that if I need to take something out, redo it, extend it or even slot it in to another project, its not that hard to do
I webscaled hard
What is the effort for though? If they have a proposition that would put it ahead of Laravel, that would make sense. But all they are doing is giving CI devs an excuse to stay stuck in the past longer than they've already gotten away with. Seems like one of those dog chasing a car situations.
[Yes](https://wiki.php.net/rfc#php_70)
By the time those are "ready" PHP7 will probably be out, and have very similar performance.
OK, I'll put in a PR and hope it's not too proof-of-concept-y.
I would recommend using some form of frameworks. I've been working on a web application for a company which has had two previous developers which was built from scratch. As good as it is, we now need to move it over to a framework the code is starting to get out of control... now this isn't going to be a fun job.
&gt; If they have a proposition that would put it ahead of Laravel You're looking at this like it's a competition, and it is really really _really_ not. We all know that [CodeIgniter needs a rewrite](https://philsturgeon.uk/blog/2012/12/5-things-codeigniter-cannot-do-without-a-rewrite/) to be considered competitive with other frameworks, but it's not really in anyones interest to do that. If you want a modern framework you can use a modern framework. But for the hundreds of thousands of applications out there written on CodeIgniter (serious there are fucking loads of them) people are pretty happy to not be running on a completely abandoned framework. Like I said, [Smarty is still going](https://github.com/smarty-php/smarty) and it has been a decade since that stopped being cool. People need to not be mad that a framework they personally don't use is being actively maintained. :)
Sans the opportunity to use Hack, which is the real difference maker IMO.
http://archive.jnrbsn.com/2010/06/mysqli-vs-pdo-benchmarks A tiny difference but a difference so if speed is your concern, every split second saved is a split second saved. Not I am NOT advocating doing this, you gain so much with PDO and higher level abstraction BUT when you do need raw speed, you need to get down to the bones.
There, formatting fixed. Yeah, I was wrong with octal numbers, what actually happens is [the keys get lost completely](http://3v4l.org/BA909). ಠ_ಠ
Oh yes, array_merge will renumber integer keys. Essentially it does a dict merge for string keys and a vect merge for integer keys, which ends up with a rather weird result if you mix both. If you want to do a dict merge for both string and integer keys you can use `+`, but the order of operands is a bit weird there.
if you create a file in a folder with contents "&lt;?php echo "this is native php script" ?&gt;" and run within this folder the command "php -S localhost:8000" and go to this url in your browser you will have the simplest native php web app :P . Now if you change the contents to this.. &lt;?php $data = array("message"=&gt;"this is native php script"); header('Content-Type: application/json'); echo json_encode($data); you will have a json response :) it will be very interesting and helpful in my opinion to check out those youtube videos on how to create your own MVC framework in php. It will be a great exercise. 
Laravel - Hot &amp; Cool CakePHP - Handy, &amp; Excellent documentation YII - Fast, Secure &amp; Modern CodeIgniter - Developer friendly Zend - vibrant community
I have a lot of faith in PHP7 but for other reasons than phpng. However I still believe it's very good for php devs to have a fully operational hhvm around. It's like jruby+puma for the ruby ecosystem
PHP 5.9.9 is actually a few versions behind 5.5.24. Don't ask me how that works.
Came here to say this. A more sustainable pattern to learn is functional programming, since most of the guidelines within the SOLID principles simply enforce functional relationships between classes, which is often times only necessary because programmers put semantics ahead of actual system design. As an example, we often conceptualize classes needed for a new system based on nouns that describe human participants and their possessions in a system (users, admins, accounts, pages, transactions, etc.) without completely understanding how they interact. SOLID provides some useful insight into how to design objects such that their interactions or behaviors remain loosely coupled as a system grows, but also, in my mind, adds unneeded complexity to small systems where most problems could be avoided by simply defining behaviors more explicitly. After writing some functional code you start to wonder how much the object oriented approach has actually hindered proper system design by providing a way of reasoning about a system's components that puts classification semantics ahead of behavioral contracts. 
assume you mean 5.5.9... it works because 24 is 15 bigger than 9... so x.x.24 is 15 patch releases ahead of x.x.9 that is to say it's not like decimal counting.. each number is delimited by a period but they are each integers that just count up.. which is how come you see things like 1.0.10 (which is not the same as 1.0.1, it's 9 ahead)
The commit is [here](https://github.com/php/php-src/commit/f4264ebc6499b82f892cefb54c0e4a0e9642e1d9), it looks fixed.
What is database usage like in general? I mean, surely if your MySQL query takes 100ms to execute, HHVM can't do anything about that since it's part of the MySQL server? Unless HHVM does something to make it more efficient?
I really like slim for small projects
It's not a competition at all for me. I've gone between frameworks and languages and I have no issues with existing projects or that CI is being maintained. I find the existence of countless CI projects to be pretty awesome. The problem is that people are taking the maintenance of CI as some sign of it becoming relevant again. Which it is not and both the time required take and the end result obviate any reason to rewrite or bring it to par. New projects being started with CI will start with both feet in a legacy mentality and well behind the curve in a lot of convenient functionality. I know for a fact there are people starting new projects with CI today and they are reinventing plenty of wheels and writing considerably more code. Newer options obviously assist them in trimming down the total lines produced (and thus legacy/maintenance burden). It's blatantly obvious to the already-aware, but the CI project would be doing a great service if they said somewhere: "you know, this is mostly maintenance, go use Laravel for you new project". Besides that, I have no grudge against them for existing at all.
My two experiences with using slim is that I always start small and I'm happy with the results, but in the long run, as features are added, I end up implementing a full custom framework. Unless you really know is a throwaway project, I think slim is way too minimal.
No, the Opcache does not perform any JIT-ing (which covers the process of optimizing the opcodes emitted from PHP to native machine code and then running that machine code instead next time), it only removes the compile step from the setup process for each request. The opcache removes the need from parsing the PHP file into its corresponding opcodes on each request, and instead retrieves the cached sequence of opcodes (or AST) instead.
Thanks! https://wiki.php.net/rfc/intdiv seems really intriguing, https://wiki.php.net/rfc/switch.default.multiple is one of those "wait, that was possible until now?" moments :P
PHP7 will have compilation to machine code. Originally that project was a rewrite called phpng, but they decided to use the phpng base for PHP7. Edit: Apparently this is wrong, due to the mass confusion of the PHP JIT experiments, which may never see the light of day. :(
Thanks guys!
True... I didn't take in to account Hack.
i wrote up [a tutorial a while back](http://programmingarehard.com/2013/09/26/zero-to-jenkins.html). You might find it useful. Hopefully it's not too out of date!
I just tried this last week. The stuff at jenkins-php.org is a nice start, but most of it was unnecessary. The problem with not having access to the shell is that phpunit will need to be run from within the application source itself. From what I understand, not having access to install PHPUnit on the server means it should be installed as a dependency via composer. From that point, it can be executed using an Ant task. I don't have an exact recipe since I'm trying to dump this from memory after a lot of flailing and experimentation, but it seems that the page for the [Jenkins Clover PHP Plugin](https://wiki.jenkins-ci.org/display/JENKINS/Clover+PHP+Plugin) might have some useful information about defining the Ant task.
"first part of this series" links to example.org ;-)
&gt; AFAIK PHP7 will have some optimizations with its Abstract Syntax Tree and PHPNG changes, but HHVM still does compilation to machine code which I would have presumed to ought to still be faster in theory. Actually, if anything, the AST change makes things slower. It requires a new structure to be defined that previously wasn't. &gt; ELI5 how can PHP7 be as fast as HHVM? Well, to understand this comes down to the fundamental task of optimization: [figure out what's slow, and make that faster](http://blog.ircmaxell.com/2011/08/on-optimization-in-php.html). In PHP, it turns out that a significant amount of time in execution was spent just managing memory (up to 33%). So a lot of time was spent analyzing that problem and figuring out how to both make memory allocation cheaper and use it less. So PHPNG was the byproduct of that process. It changes the way variables are allocated. Previously, every PHP variable was allocated individually at runtime. In 7, that's not always true anymore (many variables are "stack allocated" by the C compiler ahead of time). At a really high level, by making the internal data structures more efficient, memory could be used FAR more efficiently, which led to the speed gain. This may seem counter-intuitive. How can memory improvements be faster than compiling to native code? Well, to understand that, we need to look at the relative cost of memory fetches: Type | Size | Access Time | :-----|:-----|:--------------| L1 Cache|32 kb per CPU core | 4 CPU cycles | L2 Cache|256 kb per CPU core| 10 CPU cycles| L3 Cache|4mb shared per CPU| 40-75 cycles| Ram|2gb - 64gb| 250 - 400 cycles | The L1 cache is extremely efficient. So a memory fetch only "wastes" 4 CPU cycles waiting for the memory to be loaded. Compare that to a main memory read which takes 250-400 cycles. Also note that the faster caches are smaller. So you need to be careful about what data lies where in the caches. So PHP7 exploits this phenomenon by trying to optimize an effect called [Cache Locality](https://en.wikipedia.org/wiki/Locality_of_reference) which tries to put frequently accessed data near each other (in the same place). Without getting overly technical, a high level example would be how arrays are implemented internally. Previously, a separate memory block stored keys as did values. Now, they are stored in the same memory block. So a single fetch from RAM is likely to fetch both the key and value at the same time. Based on that, what's a better way to optimize? Take a 50 instruction task and make it 5 instructions (which would be what JIT compilation does) or take a 250 instruction task and make it 4 instructions (which is what PHPNG does)? Ideally, doing both will give you the best end result. But for a first step, the memory improvements are far more valuable. And that's exactly how PHP7 is as fast as HHVM. And you'll notice, more CPU bound applications will tend to be faster in HHVM while more memory bound applications will tend to be faster in PHP7. With that said, a native-code compilation could make things even faster. By running native code, there would be fewer branches (if statements) which definitely makes code more efficient. However, keep in mind, nothing comes for free. That compiler will incur a cost both in terms of complexity and at runtime. JIT compilation isn't always the best strategy (you can see that by cases where HHVM is actually slower than PHP, yes they do exist). But for most usages it's a good approach.
It's simple: 1. Zend was trying to build a JIT at one point in the past 2. They noticed that while benchmarks were fast, real world applications weren't really that fast 3. After much profiling they determined that memory access/allocation was the real performance problem 4. Fixing memory offered a significant peformance boost, which became PHPNG: [more info about memory optimizations in this thread](https://www.reddit.com/r/PHP/comments/31mwu0/experimenting_with_hhvm_at_etsy/cq499xr) JIT was just an experiment at the start. The product of that experiment was a re-layout of the memory architecture of the engine. That alone had a tremendous performance boost. &gt; because a lot of internals needed to be reworked to make JIT efficient Not to make a JIT compiler efficient, to make the end code efficient. The compilation process is largely tangental to the actual runtime. &gt; And then phpng became the basis for PHP 7 Yes, but PHPNG had nothing to due with a JIT compiler except that the experiments with the compiler led to the realization that memory optimizations would have a significant effect. &gt; But it does appear that JIT is not part of PHP 7, and in fact, I can't find a statement of how JIT fits into the PHP plan. It doesn't. At all. &gt; There is a ton of confusion surrounding this, and from reading various forum posts, I'm not the only one. Yup, because some bloggers care more about clicks and views than they do about getting content correct (cough phpclasses cough). In the end, the way to get correct information out there is to share it. Which is what I'm trying to do in this thread :-)
&gt; Well, someone might have told you that but, publicly, they don't seem to be interested. They don't? They are opening more and more parts of their infrastructure to the world. They have people who aren't employees who have commit access. It seems that you're trivializing what they have been doing. Everything is a step forward. Would it be nice if they dropped everything and made a foundation today? Sure. Is that practical? No way. 
&gt;&gt; But it does appear that JIT is not part of PHP 7, and in fact, I can't find a statement of how JIT fits into the PHP plan. &gt; It doesn't. At all. If true, this is very disappointing. :(
In theory, yes. However they are already doing some of these techniques. Their architecture is different though which means that while the high level idea is easy, the details don't translate as well. In short, it's normal optimization. You profile, determine the slow part **for your usage**, then fix that slow part. Rinse and repeat.
This is one more reason why you have a `public` or a `web` directory. 
I think you're correct about talent. However, I don't think it is because of Hack. Anyone can learn that in a day or two. No, it's because they are looking for HHVM developers (free, paid, and potential hires). I think this is the biggest reason. It's also brilliant. 
&gt; They are opening more and more parts of their infrastructure to the world I believe that there are three main goals here: * Free developer time (minor, Facebook is rich). * Free QC (minor, Facebook is rich). * Personnel recruiting tool (huge, brilliant). However, basing our relationship on a recruiting tool makes me feel somewhat uncomfortable.
Why is it disappointing? The underlying technology shouldn't matter. Only the end result should.
What a good answer ...
I respectfully disagree. PHP7 scalar type hinting will take allot of the wind from Hack's sails.
&gt; The underlying technology shouldn't matter. Only the end result should. That is true, but I find it difficult to believe that a token interpreter can achieve the same performance as compilation to native code. If so, then great, but that would only indicate that the native compilation isn't as good as it could be. Edit: Downvote? Is it not obvious that the issues of the overhead of a token look-up and little ability to use native code optimization are not going to just go away through handwaving?
This has a lot of code smell. https://github.com/CreativForm/easy-upload-image-class/blob/master/core_image_upload.php#L406
You'll resolve this and a plethora of other possible security issues by moving your publically-accessible files into its own nested directory. Look at SF2's structure: https://github.com/symfony/symfony-standard
&gt; The problem is that people are taking the maintenance of CI as some sign of it becoming relevant again. I've not seen people doing that. I've been trying to explain to people the opposite, but the majority seem to be jumping to "Fuck this and fuck you" far before thinking "Oh this is brand new and amazing now." &gt; Which it is not and both the time required take and the end result obviate any reason to rewrite or bring it to par. Yeah my article wrote about how pointless it would be to try and rewrite CodeIgniter and I hope they don't. Some API improvements and adding namespaces might not lead to a huge rewrite and replacing some libraries with Composer components would be a good start, but its all going to be small. Since I wrote that Laravel has smashed on, rewritten itself 3 more times and while it is very snazzy I doubt I'll ever use L5.x. Laravel has moved onto being a whole lot more than anything like CodeIgniter ever was, and TBH it's a bit too much for many. All the bells, whistles, addiction to repositories, a community of controller TDDers, etc just make the whole scene too much for a lot of people who are just setting out. If they said "maybe go use Slim" then I'd be right with you, but Laravel is really not a logical replacement for CodeIgniter these days. To loop it back to what got me wanting to reply to you: &gt; What is the effort for though? Definitively yes, due to all the projects that still rely on it. :) Other than that I think we mostly agree on stuff.
I kind of like the first one, compared to the include-y thing. You could probably extend the HTML package that Laravel uses, so people could do things like `Form::open("whatever_the_args_are")-&gt;bs3h(2, 4);` or something.
Another reason why I will never use wordpress.
Try this Static Code Analyzer (for PhpStorm): https://plugins.jetbrains.com/plugin/7622?pr=phpStorm as an addition. In my opinion crutinizer-ci is a little bit noisy, comparing to SensioLabs Insights. 
On certain level, yes. But JB are really constrained with inspections profile. Upper (now it below) I mentioned an valuable addition for PhpStorm, especially if you are from Symfony2/Zend world.
&gt; better support functional programming I'm not convinced that PHP *should* be providing better support for functional programming. ;) Overall I agree though, I'd really like to see object primitives, among other things. Being able to do things like `$someArray-&gt;filter(/* method */)-&gt;merge($otherArray)-&gt;etc();` would be great and help address some of the dumb inconsistencies in PHP's standard library.
What is so bad about wordpress? Do you have an alternative? 
Good thing this is a security issue with a plugin and not WordPress core itself.
This sums it up - you're doing it wrong if .git is part of your document root. 
Yeah, but they can't fap to that. Edit: It's been deleted, but the username was I_cant_fap_to_that.
Nothing bad with wordpress as a blogging tool. Problem is that it's commonly used to build more than blogs. A lot of non technical people will ask you to build wordpress powered websites because they know how to use the admin panel, or because they read on the internet it can do this and that. There are tons of tools out there which are better designed for X or Y specific need, but which are harder to sell to clients as they've never heard of them. The reason WP is so popular is that it's fast and cheap to build with it. Sure, you can make plenty of good money by assembling lot of 3rd party code quite easily. But that also mean you expose yourself to having unsecure parts in your code.
Yes, but fact is you cannot do much without plugins in WP.
Thing is, this wouldn't require a BC break, and could be added in 7.x — why not have a go at adding it yourself? Or writing the RFC and see if you can partner with someone who has the technical know-how to do the implementation?
+1 for October cms. Awesome tool
I barely understand what a JIT is. Why would the presence (or lack of) a JIT make you more interested in HHVM?
They have asked me not to reveal that. It's a very, very popular site. The biggest Laravel site I'm allowed to talk about is probably the Olympics APIs built by Infostrada Sports. They were a primary sponsor of Laracon EU. Also had millions of hits.
We expose an API allowing them to run queries asynchronously, without using callbacks: http://docs.hhvm.com/manual/en/hack.async.mysql.examples.php We have similar extensions for memcached (via the mcrouter extension) and curl - all 3 are included in HHVM 3.6. While this doesn't happen automatically, or make your IO faster, it does mean that you can do other things while you're waiting for the IO without introducing callback spaghetti. It is possible to fake something similar with generators (and we used to do exactly this), but we found building it into the language to be better for code readability and for performance, as we often let another thread do a lot of the heavy lifting - and that's completely transparent to the caller.
&gt; Why do you say I would have a bad time if I didnt use Symfony form component? It depends on what you're doing. If you're doing something like my example, then the validator component alone is perfect. Validating an associative array is [slightly more complex](http://silex.sensiolabs.org/doc/providers/validator.html#validating-associative-arrays). Imagine a bunch of stuff like that everywhere in your controllers. Gross. Using the form component let's you create form types with different fields and glue in validation with it. It also handles binding incoming request values to the form and validating all behind a nice API: /** @var $forms Symfony\Component\Form\FormFactoryInterface */ $form = $forms-&gt;create(new SomeCustomType(), $someObject); $form-&gt;handleRequest($request); if ($form-&gt;isValid()) { // ... } &gt; Object validation on the server side is just another check (since we cant rely on client side). I wouldn't do object validation for server side stuff. Invalid objects shouldn't be able to be created at all -- their constructors or setters should error. Use the symfony form component (as described above) or another input validation library ([Aura](https://github.com/auraphp/Aura.Filter) and [Laravel](http://laravel.com/docs/5.0/validation) come to mind). An input validation library probably has a nicer format that you could theoretically parse and use on the client side.
&gt; I wouldn't do object validation for server side stuff. Invalid objects shouldn't be able to be created at all -- their constructors or setters should error. What if the user disabled javascript, and now they were able to submit a POST without a password. Wouldnt you want some way to validate the object that you created from the POST has all the valid stuff (aka has a password). Even if your setter doesnt allow you to set a blank password, how would you prevent the object from persisting later in code. Ex: $user = new User(); $user-&gt;setPassword($this-&gt;input-&gt;post('pass')); $user-&gt;setName($this-&gt;input-&gt;post('name')); $entityManager-&gt;persist($user); Keep in mind, I am trying to decouple validation of objects from the Framework (Codeigniter and Laravel) so I can share it between the two. 
Yea, which I thought was incredibly ironic once I saw the content of the gist. :P
I work on Hack, and while I'm incredibly happy that PHP7 got scalar type annotations and think it's a huge step in the right direction, it's not really getting close to what Hack can offer. Hack has a much richer type system (generics, etc) -- but also has a typechecker that can do instant, global type analysis. It can mechanically verify and check your types' consistency without running a single line of code. Not only does this give instant feedback the second you save your file, but it also can check codepaths that you might hit only very rarely in production, such as error handling cases. With PHP7, you only get an error if an invalid value actually occurs at runtime. Incredibly useful, but only one step along the way. Hack also has many other features beyond just its type system, such as async functions and XHP.
Two things: 1. If you object doesn't allow black values, it should throw `InvalidArgumentException`s or otherwise when those values are set. 2. I'm not saying don't do validation, just do validation on the incoming data ($_POST or a request object or a form object) rather than the PHP object itself. For your use case, however, object validation probably makes more sense. It's definitely going to be easier to share between two frameworks.
I have the latest version already. Guess I'm going to freenode. Is there a workaround where I can just download the box, put it where Vagrant looks for it when running `vagrant up` for the first time, and problem solved?
I'm using [WP-FFPC](https://wordpress.org/plugins/wp-ffpc/). Works fine with HHVM. Before that I was using W3TC, but somehow it has grown in many directions at the same time turning into a giant plugin that does too many things. I hadn't heard about wp-supercache in 5 years. It's amazing that good old file cache is still a thing.
Looks like i got slapped by the WP police on reddit. Must have came over from their reddit to neg anyone that spoke out against them.
Sorry for the double reply, but I just want to point out that I consider myself a 'serious developer' and I build enterprise level solutions using WordPress as a framework and the customers I work for are pretty happy with it. Sure, there are some moments where I hate it and would love to be doing something more _elegant_. But most of the time I'm super happy with how well it works for the business need.
Fair enough, but Wordpress plugins have so many of them, that it's more like a minefield that is best avoided entirely.
Years ago I used CMS Made Simple and it was really good. Not sure if it's still as good. 
It's a blog platform with rudimentary CMS features. Fantastic for blogging, but people wanting a CMS are probably better off with a real CMS. 
Yep: public function setPassword($pass) { if (!$pass) { throw new \InvalidArgumentException('Password cannot be empty'); } $this-&gt;pass = $pass; } Your objects to guard their internal state and make sure they can do their jobs. If a user can't do its work without a password, then don't let an empty password be set. Some good reading on the subject: http://verraes.net/2015/02/form-command-model-validation/
Cool, thanks for the good info and now the good read :)
My instinct response to validate plain old php objects is the Symfony Validator Component. Just wondering why you mentioned that using the Validator component would violate single responsiblity principle? I tend to think Symfony's Validator stays out of the model all together. 
Now, thats an interesting blog, yes, it does have some minor issues here and there, but it looks good from the outset. 
There's a typo in the 'Group Use Declarations' section. The 'With Group Use' code snippet has a duplicated 'ClassC' when the second one should be 'ClassD'
I would recommend using my validation library https://github.com/siriusphp/validation 1. can validate "deep" arrays 2. comes with lots of rules 3. simple API To validate objects you must implement your own "value retriever" mechanism.
"Hey Mum, this guy on the internet says you have to learn Laravel now and stop using Wordpress for your successful online store"
Dude, that was *your* logic.
I have a drop-down list, say for example it has 3 options, then I select option 01. Now, when I append a new drop-down list (by clicking the button "Add Deduction Item" in my case), option 01 in the appended drop-down list will be disabled. The whole thought is, when I select an option in the first drop-down list, that selected option should be now disabled in the appended drop-down list, and so on. I have searched this problem over the internet. I found some but they just don't work for me because my problem is not really similar to those I found. I tried this fiddle: http://jsfiddle.net/rajan222000/yww8apn9/1/ But still don't work for me. I noticed it has static number of drop-down lists. I tried var deductionID = 'deduction_item_' + count + ''; to make it dynamic, but I don't know why it doesn't work. I really need your help with this.
Thanks, this helps a lot! 
Isn't Ars technica powered by WordPress?
If you're deploying anything meaningful, do not deploy your source code database with it. That's just asking for trouble. Who knows what might be in there (despite best efforts to keep it clean and safe).
Those are going to change soon, Ill be shifting the paradigm a lot as soon as v3 comes out
Not sure. I think Wired is.
Wel... i don't agree with this: &gt; Dependency injection is not effective if: &gt; &gt; You will never need a different implementation. &gt; &gt; You will never need a different configuration. &gt; &gt; If you know you will never change the implementation or configuration of some dependency, there is no benefit in using dependency injection. This is somehow true, but in 99% of cases you do not know what will happen tomorrow. And even if DIC in your case doesn't have any pros, it doesn't have any cons. Why do i need to resolve all the dependency graph by myself? p.s. I don't like the way Symfony DI is implemented. I use PHP-DI + Symfony DI in my projects.
I swear, people around /r/PHP just like to complain. 
A long wall of bullshit. Before i reached certain level, when I was looking at DI, I though: "why the fuck I would even need that?" But DI is a way to go in web programming. There are various useful tools which may be exchanged, database types, storages, caching services, queue services, authorization modules etc. Also it helps keeping code clean, as in most frameworks dependencies are in fact constructor injections, which mean, all you have to do is to look at class constructor and you will know what other components of your system it uses. Especially useful when maintaining a code written by other programmer. Also Unit Testing is a breezee when using tools like Mockery alongside with Dependency Injection. Dude in this article said that why he would test using mock objects, "customers are seeing real objects so I must test a REAL thing". Good luck at unit testing a system that uses: * module that makes orders for real cash from external service * module that uses external api * module that uses external api and passes user authorization data (yes, put your volatile data in unit test source) * module that sends emails * module that creates pdf invoices * module that uses database objects without mocking. This guy has no idea what is unit testing at all. Also he said that dependency injection is unnecesarry, and posted example of someStaticClass::getObject( 'some-object' ) which itself is a service container useable with dependency injection. Why I would write someStaticClass::getObject( 'some-object' ) when I can already do it with for example App::make( 'some-object' ) in Laravel which is almost exacly the same? Why would I even query service container instead of passing interface in constructor? When I pass interface in counstructor and assign it to private class variable, I have full IDE help for this class. How the fuck IDE could know what methods will have an object returned form someStaticClass::getObject( $string ) ? Wow I cant believe people are posting that crap articles.
The article consists about 70% of wikipedia definitions. The other 30% is an opinionated rant. The main idea is that you dont need DI if you will never need a second implementation of your dependency. If the author was correct than following his logic there is also 0 point in actually encapsulating the dependency into a separate class, just merge the code of the deprndancy and the deprndent class into a huge god class, right ? Nope
&gt;When you say that "injecting dependencies is the best way to go" you forgot to add "in butt cuckoo land". This guy is great. 
Read some of his other posts. His one speaking out against people calling his code terrible is pretty good. 
Don't forget [Artax](https://github.com/amphp/artax) &lt;3
True, true. Completly Agree. But, in order to effectively run Unit Test in a large code base we need infrastructure and in Enterprise world is way more different and constrained. For enterprise I mean something like Bank, Insurance or Telco.
I actually somewhat agree with his philosophy of using patterns that are beneficial to you in your own circumstances, and where I work, we definitely follow some patterns more closely than others because it's efficient and pragmatic to do so. That said, if this guy has made a living building software with that framework of his, it must be rather specialized in nature, because the whole idea of standard "transaction types" and concrete database table classes looks like general tomfoolery. I'm generally averse to unnecessary complications in design and sometimes balk at framework features that make simple scenarios more abstract than I feel they have to be, but general-purpose frameworks like Laravel are successful because the same abstractions and patterns can be applied equally to practically any scenario. No need to memorize 300+ "user transaction types." 
If you don't know what is going to happen tomorrow, why plan for it? You also say it does not have cons, that is not true. Debugability is a problem if all your calls dissapear into heaps and heaps of containers, interfaces and anonymous functions to keep it all together. It also has a performance impact that everyone seems to forget about.
No problem. Let me know if you need anything else.
Using WordPress for an online store is a pretty stupid solution. And strangers on the internet is our main source of programming answers...
Thanks for feedback. Yes, that function can be code smell, that can be replace with only MD5 but idea is to hash image name better then MD5. You can give us your recommendation. Thanks!
Could you open an issue on the Github repository if you feel it is necessary?
Fantastic feedback. We will start to fix using this feedback. Yes, we know some issue about this function, you're welcome if you whant to help us to together made one great universal plugin. 
No they haven't. Object identifiers are passed by value. Of you want to pass an object by reference you still need to use &amp;amp;. Granted most of the time this difference is not relevant.
&gt; There is no effective difference between being passed a pre-instantiated object and being passed the name of a class which can be instantiated into an object. "There is no difference between giving a pre-assembled princess castle to my toddler and giving the name of the princess castle and the money with which to purchase it" &gt; The fact that I have achieved this in a different way just shows that I am capable of "thinking outside the box", of "stretching the envelope" whereas the "paradigm police" are constrained by their own narrow-mindedness and short-sightedness. ... &gt; Unfortunately most OO programmers do not have the brain power to evaluate DI to see if it would actually provide any benefit in their particular circumstances. ... &gt; As far as I am concerned it is just a big joke, a big con, just like most of the other design patterns. This is another one to be added to my "to be ignored" list. Please, someone elevate this man to the title of programming deity, for only through worship can we hope to be granted some of his boundless knowledge and escape the dreaded paradigm police.
That what I say to most PHP developers that still are using PHP though :p.
Just briefly looked at it and really like the ideas you have put into it. Great job, starred it to check on progress on GitHub. 
&gt; "why the fuck I would even need that?" I was pretty quick to be sold on the benefits of DI, but once I started doing, I realized that you had to keep bubbling object creation all the way to the entry point of your application. Literally, everything had to be instantiated in index.php so that it could be constructed and dependency injected, and this felt weird to me. Then I discovered dependency injection containers and all was good.
Why do we even post and discuss this kind of inanity?
So a site that works, is easy to maintain and suits the needs exactly is bad? Get real.
Awesome. I'm currently using https://github.com/bobthecow/Ruler. How different are these two? Have you benched both? Which one is faster under load? Load being, 250rps at least. :)
You can find snippets of his code floating about - god classes are us...further it seems totally acceptable to him to have god classes that deal with program logic and display, and he has the nerve to call this "3 layer" architecture (where I guess there are *conceptual* layers? but actual separation in code, no). I think the issue is that like most of the things he rants about he fails to see that with all things there needs to be *balance*. Yes, there are cases where it's simpler to do away with that extra layer of indirection and perhaps hardcode some trivial dependency where you probably shouldn't... but that doesn't mean throwing the baby out with the bath water. He seems to find specific issues with patterns, use cases and principles and uses those specific cases to just "nope" the whole lot... which is really odd. But then you look at the quality of the code he's producing and it's not difficult to see why he believes these things. He's attained a certain level of "mastery" (i.e. he can write some basic logic statements that spit out some useful crap on a page) and believes there is no need to learn anymore. In fact he can't see anything *wrong* with not wanting to learn more. Dunning-Kruger effect perhaps.
You're correct, but this isn't the same semantics as passing the *object identifier* by reference. The the vast majority of the time the difference is irrelevant because you update the object's state via its class' public API so the fact that you have two copies of the same identifier doesn't matter (since they resolve to the same object in memory), but there is a difference: function foo(MyClass $obj) { $obj = new MyClass; $obj-&gt;bar = 'changed'; } function fooByRef(MyClass &amp;$obj) { $obj = new MyClass; $obj-&gt;bar = 'changed'; } $a = new MyClass; $a-&gt;bar = 'original'; foo($a); echo $a-&gt;bar; // original fooByRef($a); echo $a-&gt;bar; // changed Because foo() receives a copy of the object identifier (ie, by value), when it assigns a new instance to that variable the original object identifier is not affected. There are two separate copies of the identifier in the two scopes. The second case passes the object identifier by reference, so when a new instance is assigned to that variable, the object identifier is updated in both scopes and the original value is overwritten.
Type random things until the errors go away? Aka the Student paradigm. Hell, nope, can't do it.
In my experience, as long as they don't **only** use PHP, they tend to be well reflected. I use PHP professionally, even Wordpress, but I don't shy away from calling them out for being awful (though in PHP's case there's usually more invalid criticism than there is valid).
That's right, in fact that's the only practical difference I can think of.
I used Goutte recently and really liked it :)
Would you accept pull requests of edits?
Yeah, looks great. It manages to do the important parts of what doctrine does with a lot less configuration and boilerplate.
Thanks!
No. Programmers in general like to complain. Sometimes, they will complain about stuff they honestly don't even care about just for the enjoyment or to stir the pot. I can't help but to imagine 20,000 Sheldons (from Big Bang Theory) reading Reddit, whining, and bringing up irrelevant points about semantics. I think it's Aspergers that is at the root. I swear, as a group, most of us have it, lol. 
Holy crapsticks. I know he still tries to keep PHP4 compat, but doing password hashing yourself is madness. He could at least be sane enough to use [phpass](http://www.openwall.com/phpass/) if he still needs to worry about PHP4...
Despite not being recognized at all, I did report a handful of bugs (including a timing side-channel in their HMAC comparison). Please upgrade.
I love DI. However, I prefer factories and builders over IoC containers and XML. 
I have been using [`bobthecow/Ruler`](https://github.com/bobthecow/Ruler) for some time, but I will say that it's not very actively developed. I've had a pretty trivial pull request in since Jan 12 and it's one of four. None of them have been touched and the last commit was in September. I will say I prefer the way [`bobthecow/Ruler`](https://github.com/bobthecow/Ruler) works, but with just one author...
Oh crap! That is so not ok. 
It's quite simply an awful logo. I'm not a graphic designer or someone who often obsesses over design, but it actually bugs me that someone would stick with that logo for a project they want people to take seriously. Literally all they need to do is remove the pink thing, just have the "Hoa" part. Done.
Do you have PDO ? saying mysql will lead people to think the mysql_ functions which are deprecated. Are you following any of the PSR guides? Have you read/looked through PHP The Right Way ? Not sure what markup/styling means, are you talking about HTML/CSS ? Have you looked into any of the frameworks yet? Are you at least conversant with MVC or other patterns? Basic ideas about security? Some type of source code control, git, SVN, whatever. Isn't a course breakdown but you removed those with listing basics. 
Framework experience, SOLID, some tricky SQL exercies, basic terms like REST, SOAP, JSON, javascript experience, HG/GIT/SVN experience, Responsive Web Design, CSS what came to my mind
I wrote a whole lot before I realized that [PHP The Right Way](http://www.phptherightway.com/) covered everything I had to say on this topic.
**foo-domain** * business logic **foo-validation** * data validation * data filtering * data hydration **foo-doctrine** * persistance via Doctrine but yes, you've got the basic idea
Apparently it's even better with Cloud To Butt installed.
tomorrow we're gonna change the world! or at least refactor ALL THE THINGS \o/! 
You could just not allow the VM to have access to the host couldn't you?
Right, I would need to copy my project from my HDD to the VM though, plus setup the database and the other stuff, but I'm lazy ;) I take what I said about the VM back…
There are. Humbug is squeeky new so I decided to defer PHPSpec support while it was under development and how we handled just a single adapter was continually in flux. A significant portion of Humbug's development revolves around optimisations and those are unique to each adapter. PHPUnit has code coverage, junit logs, etc. PHPSpec does not, or not in the same form. If you check my Github contributions, you'll spot a phpspec-extensions library and I also contributed TAP output support to phpspec. A lot of the ground work has been laid already, but implementation and, more importantly, optimisation will take time. I also suspect that phpspec and behat would benefit the most from incremental analysis in the absence of code coverage, so I want to finalise that over the coming weeks too. So, for now, Humbug 1.0.0 will be PHPUnit only when release, and we'll try for 1.1.0 to get in PHPSpec.
It sounds like you've got a good handle on the broader PHP ecosystem with discussions of frameworks and vagrant, git, etc. My advice would be to stick it out for another year or two and keep learning, attending events, etc. While doing so, start building up a github portfolio and where possible contribute to open source projects. That will not only give you real world experience, but it will also show potential employers that you are ahead of your game and more than capable of taking on bigger responsibilities. Good luck! :)
I hope this article is useful http://www.theeffectiveengineer.com/blog/how-do-you-know-its-time-to-leave-your-job 
Hi; I am a web developer since 2008, I code with PHP and a little bit with JAVA. I have worked in several agencies and let me tell you this: every resignation is dificult. you are never sure of your next job and always regret leaving the team with which you had a good times. But if you are convinced that you do not advance in your current job, it is imperative to think about a change. English is not my strong point too.
could you explain main difference between isolate and doctrine. Actually I see the same concepts, I'm not sure I understand correctly what is isolate for If I use Doctrine
...or you could use factories.
When you say hydration, I assume you mean hydration from form posts? Doctrine does hydration also.
Yup, I don't do it anymore as I said I use it long ago around 2008-2009, I now use the password_* function, or use full-featured auth package like sentry
I think it would be best for you to stick around a bit longer. At 9 months you couldn't have seen much. I actually think its good you are going through the "trenches" as a developer. Having to deal with bug fixes and crappy code can actually be a good thing. That said, I wouldn't stick around for more than another year or so. Once you got 1.5 to 2 years of doing grunt work, its definitely time to move on. I highly suggest finding a company with a larger dev team since it is super important to eventually work with many people. Good luck!
I agree this is just giving his website some traffic and he'll think he has a public. What's going on in here is just beating a dead horse.
&gt; Dates in the m/d/y or d-m-y formats are disambiguated by looking at the separator between the various components: if the separator is a slash (/), then the American m/d/y is assumed; **whereas if the separator is a dash (-) or a dot (.), then the European d-m-y format is assumed.** From the docs, means it is looking for month 31.
Sure. A decent user log-in and sign-up system for instance, which is part of many a social medium and many a web app, contains quite a complex set of processes. A software architect experienced in setting up process flows can think their way through and have such a system built (or build it themselves if they are a programmer, too). A highly-technical programmer without architect skills will be able to program that system, but might not be able to think it through or design it, themselves. I have worked with both kinds of people. The latter programmer will benefit from using an application framework that features a true-and-tested sign-up and log-in system.
This guy is obviously not a programmer (or software developer). He's a tinkerer. 
Don't care the logo. Give feedback on the documentation :-) .
Nice :) .
Factories only get you so far. You're still tightly coupling implementations of things inside of your factories, and you must still inject those factories anyway. A DI container is in fact just a massive factory anyway, but one which uses callbacks for lazy loading of dependencies.
add /r/lolphp. Seriously. Any other list of updated php gotchas. This has two purposes. 1. One cannot do 'professional' work without having a vast knowledge of these gotchas. You are a professional PHP developer when you can sidestep these without thinking.. 2. Let them know what they are entering into! 
PHP The Right Way is a set of guidelines, not a structured A-Z syllabus. You can't just point a junior (or someone starting out learning PHP) at PHP The Right Way and not expect them to get stuck or confused. PHP The Right Way is a resource you could point to *from* a syllabus, but in and of itself is not a syllabus. I've been wanting to create an open source syllabus on Github for PHP for a long time, something that we as a community curate and maintain for the EXPRESS purpose of getting someone with zero programming experience up to solid proficiency, teaching them best practices and core concepts as they go. You know everyone says "Just go to laracasts.com if you want to learn Laravel"? They say that because laracasts *is* the de facto way to learn Laravel. And as it turns out, Laravel's popularity soared (and continues to soar) because there is an awesome resource that gets people up to speed on it very quickly. Why does PHP itself not have something similar, and something *official*? I'm not talking about documentation. Documentation is a reference, not a structured guide for someone thinking "Where do I start? What should I be learning?" If we want PHP to become more ubiquitous and even more popular, and we don't want newer developers being lost to "easier" languages like Python and Ruby (thinking in terms of when PHP7 comes out and we have Java-like strict typing and return types), then we need a way of on-boarding new developers as well as course-correcting developers who have learned bad practices. If we also want those new developers to learn proper conventions and practices so as not to proliferate the bad code that other language communities use as ammunition for steering people away from PHP, then again, we need something LIKE phptherightway, but more formally structured and even more basic and beginner-friendly. The training material itself can be collected from or referenced from all over the place, but the guided structure still needs to be created and maintained in an official capacity. And not just syntax and language features, but CONCEPTS - concepts that are even lower level than PHP - like request/response lifecycle for servers, http, and how PHP fits in to that equation. Surely if we have FIG, then we can have a similar committee within the community of core contributors capable of curating an official A-Z syllabus.
I'm in a similar boat, I am not learning anything at my company and I'm not growing as a developer there. However, I learn because I spend an additional ~30 hours/week working on my own personal projects, and freelance projects that give me the control and flexibility I need to push my skills. I'm not the smartest person or the fastest learner, so I make up for it by brute forcing it and learning and practicing. Earlier tonight I finished reading Modern PHP (awesome book btw, do recommend!), which talked about how you can use Xdebug with KCacheGrind to get profiling information about your application performance, and how you can add ?XDEBUG_PROFILE=1 (I think) to any URL to invoke profiling on it. Had no idea you could do that... So I just decided "hey what the fuck, why not try it?" and started playing around with it. I would never get the chance to try stuff like that at work, so I do it on my own free time. It's the only way I know I can stay relevant and up to speed (and learn new things). I read a lot of books, a lot of articles, watch a ton of talks from many different developers (many of whom don't even write PHP - people like Bob Martin, and others). I talk programming and software design with my colleague at lunch, I answer questions on reddit and laracasts, even write fake articles nobody will see just to organize my thoughts on a subject. I just immerse myself in knowledge whenever I can (at the expense of sleep, and sunny days outside....) There are a couple of advantages and disadvantages to this though. One advantage is it makes me better at my job, even if my skills and knowledge are barely being utilized by the projects I'm working on. Another advantage is that it helps me to be an advocate at my company for better work - work that more closely aligns with the skills of the team - work we can charge more for because they're skills other web shops don't have as much of. The downside of course is that once you've "seen the light" and worked with modern tools, have a solid grasp of object oriented design and software design principles, being stuck on projects where you don't get to apply those things is really painful. Ignorance really is bliss. I've had the misfortune of being stuck on a few endless Joomla projects that have taken ~1300 painful, teeth-gnashing hours to finish (each) - something we could have finished in ~400 easy, rewarding hours (with tests) had we used a real framework like Laravel or Symfony. And of course another downside is the ridiculous time investment needed. Of course, it's worth it in the end. I can crush any interview now. Aside from jobs that need really specific knowledge about something like Salesforce integration, there are no programming questions that would trip me up. For now I'm holding out that I can influence my company to start to transition away from shitty projects, and start getting more worthwhile projects, thereby increasing my salary AND providing an opportunity to things better. If I can't, I'll be hunting for another job. I'm like you, I REALLY like the team I work for, but I can't keep spending 30 hours of my free time every week just to practice and apply best practices that I'm not even getting paid to know....
Great, good work on creating the video and promoting the same. I watched the video, and also checked the github code examples. A few things I came across In the video, relationship part I was having a confusion how to define it ( At-least to me ) . I was looking at the quickstart example and noticed how it is defined. The video doesn't covered Category before but jumped into the Relationship part. It could have shown the Entity of Tag, Category, Post and how the relationships were defined. There is a lack of documentation on connecting with mysql etc. You may want to define the AUTO_INCREMENTID in that case, else it will throw errors. Is there a way we can see the queries executed, like some sort of logs ? Or push to a PSR-3 logger ? Regarding the mock and testing, how can we pass the data in a relationship query ? From your example if we are testing $fairies = $fairyRepository-&gt;query() -&gt;relatedTo('flowers') -&gt;find(array('flowers')); So we can pass the values for fairies and flowers. So far all looks good playing with it. And keep the good work. Thank you
PHPBridge has a nice curriculum to follow: http://phpbridge.org/intro-to-php/intro-to-php
Bug fixing and legacy code support will never grow you as developer. You need to leave company and search for more creative place. Good Luck!
Checkout [http://www.phptoday.org/](http://www.phptoday.org/). You can subscribe to [RSS feeds](http://feeds.feedburner.com/phpToday) to get the latest news. Disclaimer : I've created this website :)
Symfony offers a Translation component (https://github.com/symfony/Translation) which can be used stand alone. This component supports Xliff, Yaml, Po, etc. as translation files. More information can be found here: http://symfony.com/doc/current/components/translation/usage.html
First of all thanks for this question, it's realy good one. Isolate was not created to replace or to compete with Doctrine. You are right that some parts of Isolate project can be used to do same things as Doctrine ORM (Unit of Work and Lazy Objects). Those components were created to track changes and save them in storage types that cant be handled by ORM's, like webservices or filesystem. The role of Isolate is to create an abstraction for persistance. Following few lines of pseudo code explains the idea of Isolate. $persistenceContext = $isolate-&gt;getContext('doctrine_orm'); $transaction = $persistenceContext-&gt;openTransaction(); $transaction-&gt;persist(new Entity('norbert@orzechowicz.pl')); $persistenceContext-&gt;closeTransaction(); As you can see there is a $transaction which represents abstraction that I mentioned before. Now when you are using Isolate Doctrine Bridge, $transaction will become an instance of ORMTransaction which use EntityManager under the hood so the Isolate UoW and LazyObjects are not used at all. If you decide to use Isolate UoW (because u are uing webservice as storage for example) then $transaction will use it to track changes and commit them. Why? Because after some time it might be necessary to replace database with webservice or ORM with ODM. It might also help at the beginning when you are not sure how big the project is going to be and you would like to use filesystem as a first storage, databases are expensive. Without transactions abstraction you will be forced to rewrite every single part of your application that reference to specific storage during migration. Hope I made it a bit more clear for you. 
Tried it on multiple codebases, and it caught every case where a magic constant was used, or where there was coverage leakage.
Nope, never needed it. I use MAMP on my own machine, and Vagrant at work. I'm sure there are positive uses for it, I've just never found / looked for them.
[Fixed](https://github.com/hoaproject/W3/pull/52), thanks!
What do you mean?
TAP output is in PhpSpec 2.2.0-beta, should be stable before end of the month. I'm looking forward to Humbug 1.1.0 :-)
Thanks, we'll look into that!
Ah yes, I totally ommited the configuration part in the video =( Actually the original reasoning was that including configuration and so many code examples might make it look more as a tutorial than a presentation, although now I see it;s vital to understanding things. The best way to debug is probably to insect plans like $plan = $query-&gt;..-&gt;planFind(); Steps in the plans are the ones building an executing queries, although there isn't a pretty printer for those yet. As a quick hack you might put an 'echo' in [here](https://github.com/PHPixie/Database/blob/master/src/PHPixie/Database/Driver/PDO/Connection.php#L43). I'll be adding a PSR compatible logger support to the database module soon ( it's actually the first feature planned to be added after 3.0 release). Regarding mocking: $query-&gt;expects($this-&gt;any())-&gt;method('find')-&gt;will($this-&gt;returnValue($someArray)); Or if you use phpixie/test : $this-&gt;method($query, 'find', $someArray); Thanks for all the input, I really appreciate it ^__^ 
Still paid $77,000 tho...
Intl is wat you use for localization. (l10n) The OP is asking for packages for internationalization (i18n). Although these subjects have very much to do with each other, they are very different. See: http://marc.info/?l=kde-devel&amp;m=95424577708315&amp;w=1 For l10n I would use Symfony its Intl Component. 
Supply and Demand.
I wouldn't say that. There are far more cheap PHP jobs out there that drag the statistics down. But if you're doing some serious programming the language doesn't matter that much
$77,322 is what? junior? senior? and most important of all, WHERE?
Well you guys do have that free NHS (at the moment at least), we have to pay at least a nominal fee for crappy high-deductible insurance. But otherwise, it's the burden of having a number of tech hubs and a permanent lack of talent. 
From the introduction page of the [Intl](http://php.net/manual/en/intro.intl.php) package: &gt; Internationalization extension Intl is the complete package for both l10n and i18n: - [MessageFormatter](http://php.net/manual/en/class.messageformatter.php) is used for translating messages (what OP asked for). - [NumberFormatter](http://php.net/manual/en/class.numberformatter.php) for currencies and formatting numbers. - [IntlDateFormatter](http://php.net/manual/en/class.intldateformatter.php) for dates and times. - and a bunch of other useful classes. Edit: [Here](https://gist.github.com/renan/a7f080829ee68c786418) is an example of how to use MessageFormatter for translations.
&gt; But if you're doing some serious programming the language doesn't matter that much Not sure if troll or serious
Your implication that everyone in the US has "crappy high deductible insurance" is idiotic. And it's such a burden having an average salary 1.5-2x the national average and being able to all but walk on to any job. 
Thursdays
This is all kinds of wrong
For example...
Also, as a guy currently working with PHP, but having been in the industry for 15 years, I wouldn't classify myself as "a PHP developer." My first language was GWBASIC, my first web language was Perl, and my favorite scripting language personally right now is Python. PHP gets me paid. People who identify as solely PHP developers are either younger and less experienced, or a member of a vast swath of developers who make a living working on preexisting products like WordPress and Magento. 
This has become more true of PHP in the last three years. 
Some people that classify themselves as PHP developers can only do small Wordpress installs and management. They don't build applications that take more time and more skill therefore aren't paid as much. 
That's a hell of an oversimplification.
I'm fairly certain PHP has the highest disparity in salaries too. A senior developer can break into 6 figures, whereas a junior developer (or "wordpress enthusiast") is probably getting paid peanuts. 
&gt;or a member of a vast swath of developers who make a living working on preexisting products like WordPress and Magento. This. I know a great deal of people who claim they're PHP developers, but couldn't code their way out of a box... but they can present you with a cobbled up WP website in a jiffy.
Rick?
Damn, you stole my joke :) But I also peek at https://news.ycombinator.com, you can find cool stuff being made everyday, using (or not) PHP.
You seem to be fairly self sufficient from how you've describe yourself and in a position where you are trusted by the company to get things done, above and beyond what your expect to do. This could be an opportunity for you to push the company forward in the way that it handles its development process, but only if thats what your after. You should voice your concerns with you boss and be honest with them, doesn't sound like they can afford to lose you and should then be more open to listening to what you have to say. This could be a huge opportunity for you to grow even more, but you've got to want to do it on your own or you'll just find yourself getting huge demotivated. Maybe ask for some budget for training/events considering your now the sole developer with no one to grow with. Guess i'm saying to look on the positive side more, you've got quite a lot of good things going on by sounds of things. Just need to decide if the lack of mentorship is a bigger need for yourself now.
Such a stupid comment to write. I'm brazilian and I love my job (currently in the UAE), and there are plenty of well-known and great developers from Brazil, as well as other countries like it. Being brazilian and being racist against brazilians is one of the major problems we have.
Before looking at it in depth: Wouldn't it be easier to have laravel just spill out data (json) and have static (and dynamic js) content be served by something else(io.js or node.js or if one doesn't need the additional features nginx/apache/wesyn)? No need for an extra php-extension (v8js) and additional flexibility by seperation.
Happy cakeday btw 
I'd sooner take myself to france for a government-mandated 3 months of vacation and a lesser salary than stay.
I fucking todaso. 
Yea, I think good PHP devs gets paid the same, or only slightly less than other langauges. PHP just has much more newbies because of lower barrier to entry.
There are some that use this approach, but I guess the latency created is not worthy, since it's not that hard to install v8js. Also, doesn't react-laravel has this flexibility being a package ? It has a directive that can be changed transparently without the programmer know the difference.
Here is quick alphabetical (and definitely not complete) list of people I follow who talk about PHP. * @assertchris * @CalEvans * @Crell * @enygma * @fabpot * @funkatron * @grmpyprogrammer * @ircmaxell * @padraicb * @philsturgeon * @pmjones * @rdlowrey * @rdohms * @s_bergmann * @SaraMG If you really want to keep your ear to the ground you could **shudder** read PHP internals (http://news.php.net/php.internals/). For your sanity I recommend, if you do this, that you subscribe to the daily digest: https://php.net/mailing-lists.php
Humbug enforces a timeout, defaulting to 10 seconds, for each mutation testing process ;). You can configure it at setup.
Awesome write up. Having used Rocketeer in the past but in a more tightly coupled way to Laravel (4.2) I'm going to try out your approach of a global setup with a root level `/.rocketeer` folder to contain all deployment configuration settings.
I think if you're actually a "senior" engineer in the US (even in PHP) getting paid 77k, you either need a new job or aren't as senior as you might think.
that's the thing with mrarston; he is an intelligent guy, but he has been fucked with on some level. His view of the world outside his window is distorted in the same way as someone who went thru a brutal divorce, or was raped...its almost like php PTSD. I have been working with php for about 15 years, so I could see where that could have happened 'back in the day'. In the year 2000, php was still very much a free for all. You new guys today have no idea (op not included)!!
The second part of your post is fine, I would also like to see numbers from 3 or 5 years out. The points in the first part however are mostly based on conjecture in my opinion. The assumption of php as a gateway language for instance, which may or may not be the case for some or many people. I would wager that since PHP has been around much longer than node.js (which is just a javascript platform), an average php developer has more experience with php than a node/javascript developer has with php. Are you comparing life experience, php experience, or overall programming experience? I'm not attacking you, I'm just saying that it's an incomplete conclusion based on incomplete information about an apples to oranges argument.
Nah, I think the reason is mostly due to the fact that there's a TON of hobbyists, Wordpress experts and Novices using PHP, which brings down the stats quite a lot. Even designers who pick up some PHP will call themselves Web Developers or PHP Developers. The "average" PHP dev is definitely paid less, but someone out of college who decides to pick PHP for his career instead of say, C#, wouldn't necessarily make less money in the long term. Where I live, they would probably make more.
Depends where you live. LA, San Francisco, NY? Yeah, you'll get paid that much. Cost of living is insane. I get paid closer to the Western Europe salaries (a bit more, but comparable) where I work (rural area, small town). I still get paid more than my state's median *household* salary, so I consider myself well compensated.
Judging by many of the PHP development firms I've worked with, this isn't surprising. The number of them who, even when given explicit instructions, can't write so much as a `DateTime` for formatting a date, or an `array_map()`is staggering. I've given the exact line # and change to make to other teams who are handling that code, and read replies that just say "we tried uninstalling and reinstalling our WordPress plugin, and the problem persists! Please advise". It seems like at least half of self-identified PHP developers are just WordPress users, whose technical expertise never goes past "have you tried turning it on and off again?" For a lot of the work I've seen, $77k sounds like they're being overpaid. edit: I should mention that I do think (modern) PHP is actually a very nice language for web development, and when used with proper interfaces, type hints, dependency injection, and ignoring 90% of the historic functions on php.net, is an excellent choice. There are PHP devs out there who are well compensated and deserve every cent they get. The flip side is that the language is meant to have a very low barrier to entry, and very well-known, so naturally more rubbish devs will work in PHP.
You are correct, whatever hydration you're doing between your validators and your domain (be they form posts, API calls, whatever).
It's all about cost of living, really. If you're a senior in some semi-rural place or a place not known for it's tech scene (and thus doesn't have skyrocketing rents, and other associated costs) getting paid 77k isn't bad at all. Chattanooga isn't Irvine and Dayton isn't Chicago
As much as everyone loves the php circle jerk, this is true. 
PHP is hardly the sexy startups language these days. 
The react components will still be components though wont they? I might be misunderstanding but this seems like a system for making use of them within a blade view environment rather than a system for generating react components.
Here's a table for quick compare. Language | Salary | % increase to PHP ---|---|---- Objective-C | $98,828 | 27.81% Node.js | $96,539 | 24.85% C# | $94,280 | 21.93% C++ | $91,739 | 18.65% SQL | $91,431 | 18.25% C | $91,264 | 18.03% Ruby | $90,536 | 17.09% JavaScript | $90,259 | 16.73% Java | $89,054 | 15.17% Python | $88,966 | 15.06% PHP | $77,322 | --
My wage as a PHP dev with 5 years commercial (Over 10 as a student/hobbyist...and yes, I'm embarrassed looking back at that code now) is *slightly* above the western European average. Very slightly. Of course, this doesn't take into account different areas and living costs. I'm sure I'd need at least 33% more if I was living in London for example, and could get by on a fair bit less if I was living in Spain (Outside of Madrid or Barcelona, at least) or Portugal for example.
No, I think what he means is that there are more amateur/hobbyists included in the survey results for php vs other languages, not that they are bringing down the price for experienced pros.
I started out on C++, but I have specialized almost exclusively on PHP (but these days, also NodeJS and increasingly HackLang [which seems to be about as good as Node in many instances]) and JavaScript (jQuery, Backbone, Angular, etc.) and SQL [all servers] for seventeen years now (and I'm just in my early 30s). In Texas, I routinely earned $125-140,000/year for the last few years, and then when I moved to NYC a couple of years ago, I am making $175,000+ (last one was $185,000 plus bonus). I quit that job to get a 100% telecommute job for $65/hour.
Everything mentioned in http://devzone.zend.com/4693/php-7-glance/ was first proposed and submitted to PHP Internals (https://wiki.php.net/rfc/), argued about, pulled apart, and finally passed or rejected there. While the conversation is very technical, it gives you an idea of what issues are currently being looked at and gives you a deeper understanding of the inner workings of PHP. It's a very vocal place so wear something fireproof.
Eheh, I thought that as well. Although my first shock was UK vs NL. And then they said "no reimbursement for public transport", no 25 payed holidays (not including religious holidays), no pension, no health benefits. Once I did the math, my disposable income in NL ended up being a bit higher then going abroad. US salaries tend to be barebone. Also when you compare taxes, I learned that many Americans have to get a private contract to haul their garbage away. I pay 330 a year to the city in taxes and for that everything is taken care off. Not just garbage but sewers, the entire city infrastructure and services. Look at disposable income and quality of life before you head off to the US thinking the streets are paved with gold.
Aha, thx!
I'd add that experience isn't everything. Someone installing basic Wordpress themes for 5 years will have 5 years of experience, but he won't be paid as much as a Senior Developer from another language. Someone working for 5 years on large products in PHP or huge websites might.
"You need to diversify yo bonds, nigga"
Most PHP positions that are anything but graduate in the UK are above the western average. Lots of companies hiring terrible PHP programmers for terrible salaries I think
You monitor every commit to the parser? That's how you stay up to date ?
I was kindof surprised to see Node devs so high up on the list. In my circle, it seems like the older experienced guys are balking at Node entirely, and it's the younger less experienced people that are embracing it.
&gt; Such a stupid comment to write What about your comment? You went all Wharglebargl over your own biases ("I love my job" so the comment is stupid!). There's nothing troublesome about being Brazilian according to that data. Although PHP is at the relative bottom of the payscales, it shows up. We don't see Haskell or Erlang (which get paid about the same as Objective-C devs), illustrating a bias that has nothing to do with PHP or Brazilians.
That would be awesome, thank you!
&gt; I pay 330 a year to the city in taxes and for that everything is taken care off. Not just garbage but sewers, the entire city infrastructure and services. Is this water and electricity too?
Boring troll is boring. You sorta just wandered into a /r/earth with a username theWorldIsFlat saying how the sun is going to die. 
So he chose to use globals for dependency management to avoid the boilerplate during object construction time. Really novel idea.
http://www.phpdeveloper.org/ http://www.planet-php.net/ http://www.phpweekly.com/ And Twitter ;)
Thanks for sparing Indian, Argentinian, Ukrainian and other devs.
Thanks. Out of curiosity have you ran any benchmarks on few thousands of records how fast the performance is ? 
Don't takes complains in bad sense. Hear and think when you calm down. Sometimes it may make things better :) .
19,483 is a small sample size? "A sample size of around 500–1,000 is a typical compromise for political polls. " [source](http://en.wikipedia.org/wiki/Opinion_poll)
Same here. In my current job, I do about 50/50 PHP and .NET, but I started programming in '88 with Basic on C64, then learned Pascal, then some C++ in college, Classic ASP, Perl, THEN PHP, Coldfusion, .NET, some Ruby on Rails, Java (Android), Objective-C (iOS), python, Node.js, and a bunch of supporting stuff along the way. So while I do PHP development, I wouldn't identify myself as a PHP programmer.
Today, PHP is way better suited for writing large scale application than python or ruby ever was. Especially with the mutation of php called 'hack'-lang or the upcoming php7. PHP is able to express typehinting for arrays and interfaces directly and also for primitive types using phpdoc. Classes can express inheritance and visibility of members similar to java. That enables tools like PHP-DI to do a great job at automatically wiring instances of objects and IDEs to easly understand the static model of an applications source code. At least, PHPStorm does. PHP's std-lib is a horror, but who cares? Look at awesome-php or php-league to fix that. Python and ruby only have a cleaner std-library and a better designed language from an esoteric point of view. Nothing that is worth money. Really, anyone who says, that ruby and python are better development foundations is simply not a good php-developer. 
Should MessageFormatter be used in conjunction with gettext? Right now I'm using gettext (.po files) because I can't find tools / softwares around ICU messages. Specifically there is nothing to extract translations (such as the xgettext utility) and no software to actually understand and translate (like POEdit, Pootle or Transifex). Is gettext 100 times more mature in that regard or did I miss something?
Hehe...so far we have: http://www.phpweekly.com/ http://www.phptoday.org/ Now, all we need is www.phpthishour.com and www.phpbytheminute.com :) 
I have a haystack ready for you, should I send it as the first parameter or the second?
 $request = $baseRequest -&gt;withUri($uri-&gt;withPath('/tasks/user/' . $userId)) -&gt;withMethod('POST') -&gt;withHeader('Content-Type' =&gt; 'application/json') -&gt;withBody($body); Isn't that a syntax error on line 4?
Sometimes choosing the boring technology is the right decision. 
A large chunk of my job is HTML/CSS/Jquery-ing a design and turn it into a responsive wordpress site, etc. etc. and I wouldn't call my self a PHP developer either. I'm definitely working toward that goal, but for now it's mostly creating some simple plugins, playing with the API, etc. SOME DAY....
&gt; Correlation does not imply causation. Except when it does. 
Hey, I do a lot of non CMS stuff, but have you ever spent a good deal of time wading through Magento's code pools? It's enough to make you want to punch a baby.
It's back.
Senior level here, paid around $100k. Location and skill matter.
These figures are averages. You would be getting 15% more if you were doing something else. 
No, those have been privatized so they have become far more expensive. 
Yep, good spot, i've just submitted a [quick PR](https://github.com/php-fig/fig-standards/pull/499) Edit: PR accepted :)
+1
Sending hay? Make sure you're using the right manespace.
Take a quick peek at the topics [tagged [PSR-7] here](https://groups.google.com/forum/#!forum/php-fig) - it looks like it's the accumulation of many 'papercut' issues that collectively might require changes to names / signatures.
It was not the usage of the break that annoys me, but of the "break 2;" The following code would've been way better: outer: while ($i &lt; 10) { while ($j &lt; 10) { if ($j == 5) { break outer; // breaks out of two while loops } $j++; } $i++; } In this case it is explicitly defined which loop you break out two. This has two advantages. First of all, it is much clearer to both the person who wrote the code as well as other developers what is going on. (They do not have to count which loop is broken out to, because counting is harder than it seems). Second of all, the code is much robuster in refactoring, the code will still function or give an error if you have changed something, rather than terminating another loop. E.g. while (first) { while (second) { while(third) { break 2; } } } Now, if it turns out the second loop is not needed anymore, most people would refactor it as this: while (first) { while(third) { break 2; } } This obviously will return in wrong behaviour, that is not noticed at first. If however a named break was used, this problem would not have occured.
Your question doesn't entirely make sense. But you can't get the value of something based off the id tag, as it's not sent to the server, you must use the name tag instead ` &lt;input type="text" id="txtMyAge" name="userAge" /&gt; ` Then in PHP: ` $userAge=$_GET['userAge']; //Please for the love of all things, sanitize your inputs by using filter_input, I'm only giving you an example. `
You need to put it in an input so the form will submit with the variable. If you don't want the end user to see it put it in an input with the type: hidden. 
^^I ^^hope ^^so ^^:)
The trick is become a senior php developer, then you get decent salaries. This isn't a fairly easy road and takes time and skill itself. There's a huge difference! The average salary in the US for a senior should be 80K minimum. In W. Europe however this pricing drops dramatically (closely to half) which is where I live now and experiencing such effect. There's more to the pie than what's on the surface.
Depending on Experience. Because PHP can be used by such a broad experience base, their numbers will naturally be a little lower. But that doesn't mean we're paid less when comparing actual knowledge of developers.
I did not expect Node to be that high up!
Why is it that people who come here claiming to have experience with other languages always seem incapable of the most basic research?
I've always liked phpacademy on YouTube. 
&gt; Today, php has the richer eco-system (and I also see magento and wordpress as reputation-problematic), a bigger community and great tool-support. PHP's ecosystem is still very lacking. There are a number of quality frameworks, but the ecosystem as a whole is still poor. While I have zero desire to use Ruby, they have a very large pool of well maintained (this part is key) Gems to choose from for almost any scenario you run into. The PHP community still suffers from "Not Invented Here", and&amp;mdash;while it's definitely improving thanks to some amazing communities&amp;mdash;it still has a way to go before anyone has a right to dub it "richer" than Ruby or Python in regard to this.
Just after i thought something like that, thank you.
All of the $wag young boy, all of it!
All that XML... my eyes... my poor eyes :(
Evidently your comment also wasn't what it was supposed to be...
No, It was exactly what it was supposed to be, but just like to original post, kinda dumb. 
Accurate. 
Having built such a thing in-house for a large publication system before, I appreciate you posting this and will gladly take a look at it.
What the fuck
It's how you get to the end of line in vi; I'm so used to it that for a minute I completely forgot PHP's variables and was wondering what vi had to do with PHP.
This sparks my interest to contribute.
This shouldn't affect your users unless you're using so many resources for your cronjob is starving other processes on your system (Unlikely as both CLI and Apache PHP configurations place limitations on memory usage (https://php.net/manual/en/ini.core.php#ini.memory-limit) to prevent this. A simple `top` command while the cronjob is running should let you know). Each different session (if you use sessions) can be handled separately. However simultaneous requests from the same session (open 2 tabs in the same browser to the same web page in your application) will wait to be sequentially processed due to each execution requiring a lock on your session file until it's completed (since you can write to $_SESSION at any point in your scripts execution). You can actually release this lock sooner if you wish by calling session_write_close (https://php.net/manual/en/function.session-write-close.php), but you won't be able to modify $_SESSION after that.
Maybe because most of his clients are on PHP 4? After all, he is building a legacy framework that is mostly suitable for legacy applications and legacy servers, its not unreasonable that his clients are in fact PHP 4 users. 
Sigh. Is it bad that I automatically read that as "all of the wag young boy" and was very confused, especially since $wag was not defined? 
I think your API as well as the documentation need more work. - Methods shouldn't be called `getIsInitial()` or `getIsFinal`, but `isInitial` and `isFinal` as they return a boolean - It shouldn't be possible to set a state that is both initial and final (or should it?) - You shouldn't build method names from strings like you do [here](https://github.com/michcald/fsm/blob/master/src/Accessor/FsmAccessor.php#L126). Find another solution, eg. a callable argument. - A few of the namespaces seem superfluous; eg `Michcald\Fsm\Model\Traits\Common` (why "Common"?) or `Michcald\Fsm\Stateful\StatefulInterface` (why "Stateful?) - The trait `Michcald\Fsm\Model\Traits\Common\PropertiableTrait` seems quite an overkill. It turns any object into pretty much anything. - I'm also not sure about some names. It seems to me that the Accessor is actually the State Machine, because it's the highest level object that ties it all together, while what is now called `Fsm` is a class holding only definitions Good luck and also have a look at https://github.com/yohang/Finite
How would one go about submitting multiple headers then? Would it be multiple calls to withHeader(), or would it be an array passed in?
So I left this running yesterday: &gt; Time: 10.43 hours Memory: 45.25MB Wow.
&gt; No active maintainer
Using a session handler without locking is also a good approach. My setup includes Memcached with [`memcached.sess_locking`](http://php.net/manual/en/memcached.configuration.php#ini.memcached.sess-locking) turned off. I don't store volatile data in the session, pretty much use it for storing a user id, so I really don't care about race conditions. 
To be honest, XML mappings are by far superior to annotations and YML because you get: - direct validation via our XSD - autocompletion - much better performance (not that relevant if you have caching enabled, but the difference is noticeable in dev environments)
If anyone is actually interested, apparently it's a thing - and hand made from real gold: http://technabob.com/blog/2011/07/10/gold-4-keyboard-key/
Bind shift+4 to capslock or any other button you never use
I tend to prefer class based configuration, this way I can throw it whatever format I like
With the interfaces as they currently stand you'd have to do multiple calls to withHeader.
Caps Lock is the best key to switch between keyboard layouts if you need to type in not just English.
Thanks! =)
A little context would help, you know ;). How many tests? How many source files? How many generated mutations? Do you have performance blackspots in your source code or unit tests? How long do those unit tests normally take? Do you have the rest of the result output? You haven't posted any of the results other than time, and a memory cost which looks surprisingly low. Most of that memory would be Code Coverage data which increases as a factor of source code line count and test count - so it's unlikely you tested anything large enough to warrant 10 hrs.
ah fuck, tl;dr, thanks :)
PHP: Create Your Own MVC (Part 1) : https://youtu.be/Aw28-krO7ZM This might help you.
 - Create View (Presentation) layer - Create Business Layer - Create Controller Layer, which decouples business logic from view logic - ??? - Profit. Instead of MVC consider to build your first request/response framework. MVC is UI pattern.
that's a great idea!! I have capslock disabled, but will make it work that way
You need to use two backslashes, one for PHP and one for SQL. $sql = "SELECT * FROM books WHERE title LIKE 'Don\\'t%'";
Hi, thanks for the reply! I'm currently experimenting with code without using it. SELECT concat(firstname,' - ', userid) FROM names WHERE firstname LIKE '%Jack%' Do you know how to escape these quotes without bound parameters?
Doodoodooodoodadoodoo not Doodoodooodoodadoodoo totally not the same. 
the issue has been fixed. you should be able to read now.
Just wrap the entire thing in double quotes? "SELECT concat(firstname,' - ', userid) FROM names WHERE firstname LIKE '%Jack%'" No need to escape -- at least not for that specific query.
You don't ever (**ever**) drop variables - global, or otherwise - directly into a query string. As /u/chrisguitarguy said below, use bound parameters. Even if they aren't ever touched, seen, referenced, fondled, handled, caressed or anything else by a user. Get into the habit now, it's worth it. Also, you could just concatenate the string $query = "SELECT whatever FROM whatever WHERE whatever LIKE '" . $_POST['var'] . "'"; I still cannot stress how absolutely *wrong* this is, however.
I get that but if it was to be done how would it be done? 
Unfortunately my only "unused key" on my Mac (§) is bound to #.
javascript too
You also need [these business cards](http://www.puremetalcards.com/cards/gold-silver-business-cards/gold-22kt.html)
You'll probably have more luck over at /r/phphelp or StackOverflow then here - /r/PHP isn't intended to be / used as a support channel.
[Belgian keyboard](http://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Belgian_pc_keyboard.svg/500px-Belgian_pc_keyboard.svg.png) master race reportin' in.
It's not to be done. There is never a reason to do. There is 0 valid reason to do it. It is always bad practice. It is always the wrong thing to do. Stop doing it.
It's not like I don't know how to type "PHP tutorials" on youtube, I'm asking to see which specific resources people with experience would recommend. 
I understood everything (up to and including) IDE. I used to be a Computer Science undergrad (Did about 2 years) before leaving it and so half of what was said made sense. The rest? lolnope. Anyway, cheers for the explanation guys!
That would be great! I'm available for help about finding your way in the code!
To be honest I'm surprised you got this far, and this is where you get stuck. Can you explain to us why this is confusing you? I mean you got the other fields... Also a few pointers here. This is a homework assignment so I won't list everything I see that I think you should improve. Having said that I think you should know: - In HTML, all attribute values should be surrounded by quotes. So you do `&lt;input type="text"&gt;` instead of `&lt;input type=text&gt;`. - You want a `&lt;head&gt;` element around your `&lt;style&gt;` and a `&lt;body&gt;` element around everything that follows that, and you want to close that `&lt;html&gt;` up at the very end. - Form submission is normally done with the POST method instead of the GET method. - The most important thing, though, is: **escape everything that goes into your database or into your HTML**. You have two fields without `mysql_escape_string` calls, and you need to get into the habit of escaping *every single value* that goes into a SQL query, **especially if it's a GET parameter**. The same goes for outputting HTML, always always use `htmlentities` or something, neglecting to do either is a serious security risk. If you ever plan on writing PHP for a living, pick up this habit now, while you don't have to unlearn not doing it. - The mysql_ functions have been deprecated, you should switch to something else. Of course, your teacher may have taught you to do it this way, in which case he/she is a bad teacher and I would not trust them with my projects unless I were in a position where I could review their code. - Develop with the `error_reporting` setting maxed out if you can. No matter which PHP version you use, -1 should do it. This will get you into the habit of writing clean and compatible code. If you REALLY want to know how to write good PHP code, check out [PHP The Right Way](http://www.phptherightway.com/) but this may be a little advanced for you right now, judging by the sort of thing you're struggling with.
I would do DateTime by instance, and DateTimeImmutable by value. The reason is object references. Since DateTime is mutable, you can run into an issue where they are equal now, but not in the future, hence why I'd suggest differentiating them.
That's why I wanted to invent and Kickstart new coders-only keyboard. But every coder laughed his ass off. They told me "why extra row of keys? shift is not okey for you you black sheep?" tsss
Wow, this page has layout has issues: * I had to make the page 1300 pixels wide before the dumb horizontal scroll bar went away. :( * The popup bar at the bottom warning about cookies is lame. :( So far, 2 unhappy faces. I expect better from a good developer. Ok, now for the actual content. * If you are into ORM's, then Doctrine 2 is pretty much the de facto winner of PHP ORM's. * Within the ORM category, the Data Mapper (or Table Gateway) architecture won over the Active Record architecture. That war is over and Active Record lost. Look at the issues the Rails folks have with tests and testing speed. The issue is always with the slowness of hitting the database for every test. Mocking out Active Record objects is hard. Conversely, not mocking them out (i.e. hitting the database) is slow. Neither is acceptable. :( * I am at the point and stage in my life where I don't want to deal with XML anymore and will "nope" and burn with fire anything that forces it. :( When I think about Active Record, I can't help but be constantly reminded how every Active Record model is really two completely separate concepts (domain object + persistence management) that are mashed together into an unholy abomination. This breaks good engineering practices and this shows in the community's collective experience with it and with any system that uses it. :( All in all, I give this article a review of 5 Unhappy Faces.
Big down vote for using "XSD" in a sentence. 
XML? Nope. Burn it with fire.
Dangit Sheldon.
My first thought was yes, it makes a lot of sense. On further consideration, though, this could itself lead to weirdness if support for other value types was an existing/future requirement. If this is the case I would be inclined to suggest always using the value - the operations would only be true at the time of execution but this is standard and expected behaviour when state is mutable. 
You'll have [this problem](http://www.nhplace.com/kent/PS/EQUAL.html) with any class type, not just DateTimes, so why not simply make a note of it and let your users decide to deal with it however is appropriate for their use-case? E.g., if your users consider two DateTime instances equivalent if they're the same day, they could presumably do something more like `-&gt;groupBy(function ($row) { return $row['date']-&gt;format('m/d/Y'); })`. Or similarly if they want to group their DateTimes by year, or by month, or by day of the week, or if they want to group using any other kind of class.
I want that speed. F the old constructors 
In my question I mentioned I am using TeamCity, but TC does not come with built-in modules. It only runs what you tell it to run. And regarding Jenkins, as mentioned, I'm trying to avoid SaaS options because we have enterprise clients so everything needs to be reproducible without relying on a 3rd party. 
Jenkins can be run anywhere you want. It's not a SaaS.
&gt; Why does every tool need to have an equivalent in every language? I certainly never suggested that. PHP has been around a lot longer than Ruby. So if the answer to PHP deployment is a Ruby tool, it would surprise me. &gt; If a tool works, who cares what language it's written in? A tool "working" is much different than being able to customize, integrate and support in critical environments. So if I need a Ruby tool, developers &amp; build servers will now each require a Ruby environment, some knowledge of the Ruby language and then knowledge of how the tool itself works. As I mentioned earlier, I'm not suggesting this is infeasible, but surely you can appreciate the benefits of a tool that skips much of the learning curve and technical challenges. To give a concrete example, we switched our front-end team to a Node.js workflow using Grunt. This is nice because they already know JS so they can read and manipulate the build configuration with minimal learning curve. To compile SASS you can either use Compass (Ruby) or node-sass (Node). Since they already have Node, why not use the Node plugin? This doesn't mean the Ruby plugin *shouldn't* be used (and in fact it was before node-sass existed), but why would you? 
What my company does right now is far more basic than what others are doing, but also more prone to error. We just use a POST hook on our repo that POSTs to a url in a project which has a small script in it to pull in changes from the repo. It's not very resilient and there's no error detection (if a pull fails it just fails and doesn't alert anyone). But it works for us, for now at least. 
Mine is bound to 'hide/show iterm2'
Will checkout Ansible, thanks!
Actually, Ruby and PHP both came out in 1995. You're probably thinking of Ruby on Rails, which was released in 2005.
Yes, in the context of this discussion I am referring to Rails.
Git &gt; 2.3 has [push to deploy](https://github.com/blog/1957-git-2-3-has-been-released), which means you can push to a non-bare repo - essentially deploying it. Might be something worth looking into.
god, the codecademy javascript course is fucking *useless*. no wonder my shit never works!
That looks really interesting. If you're using a web based repo (BitBucket in particular) will this work without any configuration in the repo settings? Right now it looks like BitBucket is using git 2.1.1, will that prevent push-to-deploy from working, or will any push to the main repo also use the deploy setting?
To be honest this language is money.
You generally don't need to know the technologies required by your tools - only how to use the tools themselves. Sometimes a tool will use configuration in the same language (e.g. Grunt), so you may need to stumble through enough of the language to work with that configuration, but it isn't as if you need to learn the whole language...
My firm was founded on rails clients, so I'm now just used to cap for deployment. There's not really any reason why my deployment tool needs to be the same language as the code I'm deploying.
This really appeals to me. While I think it is a 100 lines (or whatever) purely to prove a point I think it could use a few more lines to make it a bit more fault tolerant. Bravo!
We use our own custom system that basically checks git revisions and if there's a newer revision on the targeted branch it automatically runs our deploy/upgrade scripts - just setup a cron job and let the rest take care of itself basically - once it works there's very little humans need to do except write code! Before writing our own, we had used gitlab's CI as well as beanstalk and some others that I don't even remember, none of them quite fit what we wanted so we wrote our own.
Phabricator + Jenkins + Maven + Composer (+ some Ansible in certain cases) = magic
We use this too. If you're using the Atlassian suite of tools, everything just plugs in together and is nice. 
&gt; PHP has been around a lot longer than Ruby. So if the answer to PHP deployment is a Ruby tool, it would surprise me. First of all, that's factually wrong. PHP hasn't been around a lot longer than Ruby. Second, wtf kind of backwards logic is that anyway?
Why? Capistrano isn't a Rails app.
We've rolled our own internal git server and use Deployer. I don't see it mentioned too much around here but it works wonders for us.
We used to do a git pull and if there was a failure it was a nightmare. I recommend doing the following: git fetch github master; git reset --hard FETCH_HEAD; This forces it to be at the head and destroys any non-committed changes on the branch. (Which you shouldn't ever have anyway!) I have never had a problem doing it this way, the deploy will always work every time and never have conflicts. 
Use Ansible. It is really a pleasure to work with. It is so simple and so easy to setup/configure. 
Why can we check more then one answer if there is only one answer? "Which function is the most useful one while debugging ?". I know that var_dump() is more useful than print_r() but both are useful while debugging.
&gt; We use Gitlab for the repository (instead of Git Gitlabs still uses git, of course. I'm sure you meant github or something like that. I just wanted to point that out so others aren't confused. 
More like just push to bitbucket as a 'backup' or central repo, and push to deploy to push to the actual testing/production servers from your local dev environment.
It is complicated which is why I'm looking for a tool first. What do you use to sync files? Or how do you handle redundant files being left on the server?
&gt; I'd prefer to avoid another environment (Ruby) if possible. This does have a cost and mixing languages is problematic from a staffing perspective. This is a practical issue that is sometimes treated as a trivial concern, in theorycrafting. I understand the impetus to seek a homogeneous toolchain. &gt; Are there any "gold standards" for CI in the PHP world? No. The most effective tools for this come from Rubyists who happen to be very interested in how to do CI well. It's just a matter of mindset, I suspect.
I feel like you're the first person who read my entire question and actually answered it. Thank you, I will definitely look at everything you mentioned. I did add Composer to the project right away, I'm pretty active in Node at the moment so my first question was where do I get the package manager? Hah
Yeah my bad :-) I meant instead of github or bitbucket 
&gt; you just drop .txt files, written with the famous Markdown syntax Why not .md files, written with the famous Markdown syntax?
Welcome to /r/php.
I think he was just saying that he's used to npm, so when he jumped into PHP he was looking for an equivalent, which he discovered was composer. Or maybe he was insulting your mother. I can never tell.
&gt; CMS or web framework? Neither. It's just a blog engine. It's not a bad idea -- a lot of blog engines are a pain to work with, and even the easy ones take a surprising amount of work to get started with. The execution, however, leaves a lot of room for improvement.
Composer? PSR-0? PSR-1? PSR-2?
We use a combination of [Beanstalk](http://beanstalkapp.com/), Capistrano 3 and Phing. When we push to master, Beanstalk will kick off a shell deployment on out build server. The shell deployment checks out the latest version and starts Capistrano. Capistrano does the actual deployment to our CI server. We use Phing only as a build tool, not a deployment tool. So Phing is run by Capistrano as part of the deployment process. Phing will then run Composer, Bower, Grunt, etcetera.
"Oh hey, PHPSpec? Okay I'll read this" "... A video? Naaaah"
PHPSpec is way too much magic for me to trust it to work reliably.
I just know from experience that any library that relies a lot on reflection, dynamic method calls etc. are prone to breaking, prone to having misleading error messages, difficult to understand and difficult to debug when you run into a problem. I can't give a specific example without actually spending time with it - and again, from my experience, it usually takes some time before the problems actually start cropping up - time I'm not willing to invest in it.
If I was brought into your project, needed to add a feature and were asked to write tests following the standard of that gist, I would either spend a ton of extra time just figuring out how the tests work (and probably still understand it wrong) or just avoid writing tests altogether. In either case, the end result is suboptimal. If this is a real test of yours in a real project that's in production I'd sincerely ask you to consider rewriting it completely. I'm not kidding.
Interesting idea. Could this be implemented as composer hooks instead of requiring a separate .phar? Would it be possible to define composer dependencies in fiddler.json and then build (or append to) the composer.json from that, removing the need to define dependencies twice?
Would any of these work with multiple environments behind different firewalls. - i.e not directly connectable or ssh able? Do any offer pull type checking to see if a deploy command has been made on a central CI server?
You could add the build step as a post install/update hook to composer: { "scripts": { "post-update-cmd": "php fiddler.phar build" } } Your second idea is completly the other way around, adding the dependencies to fiddler.json and then calling composer from fiddler. This would work as well, for example using "composer require library version". However I am not sure its practical because of Composer requiring versions, whereas Fiddler just assumes that everything right now is the versions you want.
I've read the difference in use case between PHPUnit and PHPSpec a billion times but never really understood it. I don't suppose anyone fancies explaining it to me like I'm 5?
Oh man. One day you'll figure it out. I hope. 
Do devs in US really get paid almost double compared to Western Europe?! If so, glad I'll be moving to the US soon :)
I imagine that if I have a huge repository with several sub-projects, there is a possibility that two or more of them will require incompatible versions of a composer package. Wouldn't you want to get a warning/error if this was the case?
Not on my phone sadly.
I finish reading still hungry ... more please ...
That is not supported. You can see this as both good and bad, depending on your context and it would be a vaild opinion. 1.) you have many different customer projects at different pace. You don't want to upgrade every project at the same time, because some depenency changed. This is a case where multiple repositories make sense. 2.) You have homogeneous projects that depend on stable third party software. In this case you don't want to bother with manually upgrading everything over and over again. A single repository with only one version is fine for you.
Well, make them named constants ;-)
A bunch of the optimizations seems like something the runtime should do. Like ++$foo or $foo += 1. Have you measured how much faster one is over the other?
I never saw the original post but have been using your plugin for a while. This comment isn't related to your post, but I would just like to ask for some improvements in the plugin. It would be great to add auto fixes for these inspections that are provided. Then, it would be great if you can add the reason for why the inspection optimized option is better.
oh well, programmers and the stupid thinking that "my language is better than yours." I've programmed in C C++ C# PHP and so on... PHP is one of the easiest languages to learn. I currently develop in PHP. PHP 5.7 is coming... open source languages such as PHP with free frameworks are storming the web development. Problem is most people that don't like PHP never programmed PHP or if they did, they didn't do it using OO concepts... 
I usually just use Firefox. I'm on-the-ball like that. It's also prettier than Nagios.
I haven't looked at the code (only read the readme file) but it's a bit strange that objects need to inherit from PyPhpOn. Have you considered making it a trait instead? 
Touché. 
There is no reason you can't use $this-&gt;isWatched()-&gt;shouldReturn(true) if you dislike the object state matcher. It's equivalent to $this-&gt;shouldBeWatched()
&gt; You must really hate behat Myself, I hate behat not because it's necessarily bad software, but because it gets overpromised as a silver bullet, and then misused to create the same shitty *kinds* of tests we had before, except with additional levels of complexity by people who know even less about what they're doing. 
Note that if you are *debugging* scripts, the interaction of your IDE and XDebug can turn formerly-parallel runs into sequential ones. I had that problem once trying to diagnose a bug which was actually a race-condition, so it kept disappearing when I turned on debugging.
Er... what? Firefox the browser?
Maybe this thread will help you (Haven't found any database yet) http://stackoverflow.com/questions/3217492/list-of-language-codes-in-yaml-or-json
i use this one - cause i made it (a long time ago). I also use newrelic though. But I have more control and customization with phpmonitoring. It just depends what you're trying to monitor. https://code.google.com/p/phpmonitoring/
Don't be too optimistic ... yet :)
Server online = good, server not online = oh dear.
I like using chrome too because if my server is down I just hit the space bar and chrome let's me play the dinosaur game.
Nagios. Free. You can configure it to monitor tons of stuff, disk space to threads. The email alerts are great.
For uptime/alerts: http://www.phpservermonitor.org/ For general monitoring: http://munin-monitoring.org/
[Graylog](https://www.graylog.org/) and [Sentry](https://getsentry.com/) (not free) for alerts.
Not PHP nor do I see a reason that it *has* to be PHP but [Zabbix](http://www.zabbix.com) is pretty good.
Doctrine and its naming conventions? What naming conventions?
I'd like to hear a little bit more behind your reasoning for not using Propel or Doctrine. I haven't used Propel, but is there something about its XML schema that is off-putting? Or do you just not like XML for some reason? And, as /u/dadamssg said, what naming conventions are you referring to?
Doctrine. 2.5 was just released, and it is pretty nice.
I don't know why you should be scared of Propel for its XML schema, as you can auto generate the propel schema using the command 'propel-gen -reverse' with the right settings.
Idiorm.
You are welcome, glad that you liked it )
http://www.twilio.com/lookup There's an option. It's not specifically PHP but a web service that can do it for you.
I'll start adding fixers soon (May/June - will create tickets for this). Some of fixers will be contributed to PHP CS Fixer first and to plugin then. Currently there is a reason to not add fixers - I collecting feedback from people regarding side-effects (first plugin release was just in December), so it difficult to really corrupt something at the moment. For other readers: optimized cases reduces some overhead existing in original code.
BTW. next release is 1.2.x increment, so I'll take advantage to announce here new upcoming inspections: * Slow alter in foreach: improved and re-activated by default; * Deprecated constructor style inspection added; * Reference mismatch inspection added; * Magic methods validity inspection added; * array_push(...) miss-use inspection added;
I agree. Additionally the problem with magic is that IDEs don't understand it, and people reading code driven by magic will be confused by it. I'm all for having what OP is doing in PHP's core, but at userland level it's best left explicit with some painfully verbose, but painfully obvious (to both IDEs and programmers alike) calls, i.e.: $callable = FuncUtils::closure($this, 'methodName'); and not: $callable = $this-&gt;methodName; I'm glad PHP has magic methods, they can be used highly selectively for some needed functionality (say, making existing public properties read only, or requiring they be set to a specific type and format of data), but it's best used when the value outweighs the performance loss and confusion and not just for small syntactic conveniences.
What does this offer that something like gulp doesn't?
Google have something pretty sure it's called lib phone Google it. It's open source I think 
Sure )
None.
Doctrine's syntax isn't similar to what you're used to on purpose. Instead of using the active record pattern, it uses the data mapper pattern. As you said, one approach or the other isn't bad, but they're different and have reasons for doing things differently.
Are you sure that $id is a comma separated string?
Eloquent and its data mapper fork : Analogue
Hi, this is true. In fact, creating a trait is in the TODO list. I've started with the class case because this way is easier (I don't have to handle inherited __call or __get methods). The trait case is a little bit more complicated, I think today or tomorrow will be done.
This is a common problem that can catch people out, see this, it explains everything you need to know. http://stackoverflow.com/questions/1586587/pdo-binding-values-for-mysql-in-statement
Hello, in this case I'm using reflection as an instrument, but in other (more consistent) languages this syntax sugar is done without needing reflection. I've also added many tests to ensure I don't introduce undesired behaviors, and of course, this library is designed for who needs it, not for everyone. I'm aware that it's possible to introduce problems if the inheritance tree is complex and the magic methods are redefined many times. Currently this code isn't designed for magic-lovers, but for people who needs a little bit of more consistency. In general I don't like to use "magic", nor accessing properties &amp; methods that don't exist. This library only adds new ways to access those attributes that actually exist in a more "clean" (with less corner cases).
THe thing that I like with Doctrine2 is that you can develop fast with the queryBuilder and then optimize your query using SQL and resultSetMapping later, it is so efficient to make a POC for a client and then get serious.
So is each task an abstraction around a separate php script ? I posted [this](https://github.com/jayesbe/php-process-executive) to github recently. Its a lot more lightweight and uses the process control extension to fork off processing. Different purpose but if Robo could do the same thing I would be interested. I do like how Robo has abstracted tasks though, has given me ideas on how to enhance ProcessExecutive. However I would prefer to use shared memory to communicate between parent and childs.
That's called an LRN dip. As /u/haydenk1337 says, Twilio provides an API. I believe a cheaper alternative is [Alcazar](http://www.alcazarnetworks.com/data_services_lnp_lrn.php). I could also recommend other even cheaper alternatives, but only if you were able to do a somewhat large commit.
Another option is Dataloop.IO. Designed as a SaaS replacement for Nagios, Graphite and Dashing.js (except with a drag and drop interface and extremely simple setup). I saw the comment about New Relic so thought I'd chime in, as we're a fraction of the cost and probably provide most of the functionality in this use case, if a bit of work is put in.
Large commit to the PHP world? Like on Github? I am currently working on making multiple APIs and source on github to help future PHP developers.
I'm using the CakePHP 3 ORM https://github.com/cakephp/orm . It also offers a library for direct interaction to the database that works like PDO but abstracts much of the differences between the different database providers https://github.com/cakephp/database I would say there are plenty good reasons to use those libraries and I'd like to summarise some of them: * No need for complex configuration using external files or annotations. * Uses the DataMapper pattern, which makes it simpler to decouple your app from persistence.. * Very expressive an intuitive Query API. * Support for composite primary keys. * Very efficient query model, for example it uses JOINs for associations where possible. * Ability to hook in plenty of different events. * Automatic data type casting, even to complex types or value objects * Built-in data integrity checks. * It is still close to SQL, which is a big plus for me. Being able to tweak and optimise the resulting queries is important.
Lol I think he was referring to money.
I never used the migration tool. [My biggest project](https://github.com/Longwelwind/ThreadsAndTrolls/blob/master/src/Entity/Character.php) has something like 20 entities, and I've done the table by hand (PhpMyAdmin). I don't understand what you mean about getters/setters. Since Doctrine2 directly modifies the attribute of the model object, you can manage the attributes the way you want. Really, the only thing Doctrine2 forces you to do is to use the ArrayCollection object for list of entities.
Ok, it's not really clear from the documentation, though.
So the only requirement is to have hard coded private attributes in your class, right ?
Doctrine2. There is no other data mapper ORM afaik for PHP.
&gt; This excludes answers from everyone who happily interacts with a database via other means. Maybe that's intentional?
If you're looking for mobile provider information, what you want is a HLR check. These can provide you with current provider information (as well as original, where original allocations are published) as well as information such as whether the phone number has recently been active (whether the phone has recently been switched on), and whether the HLR check was call-barred (which would indicate a phone set up to only receive calls from specific numbers). As far as I know HLR checks work for all international mobiles. They won't work if number redirection is used - such as for UK personal numbers that begin (0)70 (since the number you're given isn't actually on the mobile network, and as far as I know there's no service that allows you to translate the number into the final destination number). Providers: * [Doluna](http://www.doluna.com/hlr-mobile-number-lookup/) * [Infobip](http://www.infobip.com/messaging/services/number_context/) ([Dev Docs](https://developer.infobip.com/api))
Maybe it is, but 9 times out of 10 it's due to the question asker having tunnel vision about the types of available solutions to their problem. It doesn't hurt to have an alternative or two.
Hard coupling a class with a superclass that adds syntax features to it only to address *circumstantial* CLI usage would be a big mistake in terms of design. If you want CLI convenience you can have CLI commands for those cases. You can have a PHP superset right there in CLI to create closures on demand and whatnot without having to extend anything in any given class. Likewise for creating tools for mathematicians. It feels like you're describing a DSL, and a DSL shouldn't be hard-coupled to a dozen preselected classes in your code, it should be a tool available for all accessible types where the use case lies (i.e. where mathematicians are supposedly using it). As for IDEs, in Eclipse PDT / Zend Studio and others, if I type $this-&gt;foo and this property does not exist (even if the method does exist), it's an error, with red squiggly underline and everything. And if I have to turn those checks off, it means I'm letting through plenty of bugs I'd catch early, i.e. it makes my IDE a lot less useful. It's not worth it.
Not true, there are some out there. ;) https://github.com/vlucas/spot2 https://github.com/cakephp/orm https://github.com/analogueorm/analogue To name a few.
Can any PHP ORM create the database(s) and users initially at the beginning of a project?
In CakePHP 3 you just need to implement a EntityInterface and there is trait that you can use in any class that implements the interface. There is a base class for simplicity sake which is basically an empty class using the Trait and declaring that it implements the interface.
Well most of the time AR *is* bad
There are two requirements that Doctrine makes which can be seen as a coupling or inflexibility: you can't use public fields for mapped data, because then Doctrine will not be able to initialize a proxy when it's needed and you have to use ArrayCollection for related collections.
If you're concerned about price, I would suggest you consider whether it actually needs to go on every server you have? If they're all the same servers serving the same apps, does it really need to be on every box? Its a fantastic product, maybe you only need it on a few boxes?
SQLAlchemy. 
Behat/mink and the tools it imitates are meant as a really high level concept tool, so I tend to let that pass. If your goal is to write a DSL/language that non-programmers can use to create automated tests it's hard not to have a lot of "magic". And frankly I'm not aware of a lot of better alternatives. I think it's worse for PhpSpec because it's a tool written for programmers, not non-programmers, so there's no need to make an effort to make tests readable for non-programmers - and that there is a established, viable alternative in PHPUnit.
You get to write you tasks in PHP. Easily the best feature, to me. :)
Safest: Don't use CodeIgniter... SQL Injection is rampant.
That's a respectable stance to take, but I myself would prefer to listen to people who have actually used it extensively before casting a negative opinion.
Done, now you can use traits :) .
Sure, I only have a few minutes though. LOL *hands over free time* I'd like this to be used in a real day of code, for example, if you're a web developer, do it at your work place or whatever just to see what results you get (besides other devs commenting on how ugly it is). :) I'm interested in seeing if it boosts/decreases how well you think through the day.
As in a commitment to a large number of requests.
I doubt it would boost anything other than a brain aneurysm. 
Thanks!
Cool, because I figured that in the reply. Did you take a look a packagist.org?
Doctrine can, using "migrations".
Well i think you can always submit a PR if that feels wrong to you. There is no 'flush' method so it actually make sense to me. It's still a young project, but I'm happy to see some alternative to Doctrine emerging. 
There is no such thing as you described in current version. Also "you will find all the missing stuff to prevent SQL Injection"? No you won't. All of the important parts are escaped in CI drivers.
But... why is that a thing? Who cares what language it is? Being the best tool for the job is about far more than being in your "favorite" flavor of computer words.
i tried it as an alternative to gruntjs, but i rely alot on watch tasks, to compile changed files of coffee and less stuff f.e. my builds increased drastically in time. again, this shows that some stuff isnt meant to be done in php
LiskDAO
Demo: https://reflection-browser.herokuapp.com/
i dont THINK theres anything i should be worried about being shown in there... But if anything sees anything that could be used maliciously against me, let me know and ill take this down.
A tie between Eloquent and Doctrine depending on if I need CRUD or something more complex 
 $your_comment = str_replace( "Here, here", "Hear, Hear", $your_comment ); // oops typo 
[League\CommonMark](http://commonmark.thephpleague.com) It supports the full [CommonMark spec](http://spec.commonmark.org/). Great code, performance is reasonable and being worked on. Well maintained, fully tested, etc.
Nope: https://github.com/bcit-ci/CodeIgniter/blob/develop/system/database/drivers/oci8/oci8_driver.php No escape method... And that is just a start, you need more for proper security... 
Why not just replace instances of 'here' with 'hear'? :p
or even every instance of "re" with "ar". But brevity &lt; readability
Escapes are in parent classes. There is not much to escape in the driver you linked (most things are handled by parent classes), but you can find there some stuff too (search for escape).
After looking at it, I agree your original is semantically best. Could toss a variety of strings at it, and it would achieve its goal. Plus readability. 
Thanks, this makes a lot of sense. I guess I could alter the `Auth` controller to do that. The `crypt` style hashes always contain `$` characters, so I could do it with a simple regex, so the line "update user to login with crypt next time" would not be necessary.
I am not a smart man. ;)
I'd avoid the regex if you can. If everyone currently in your system is MD5d, just set a flag for every account and toggle it when they go to crypt. Also, good for you for changing this.
And thus WRONG, each database needs different ways to escape things.... Just freaking look at Doctrine drivers.... 
+1 I have tested a lot of them. Supporting the CommonMark spec is invaluable, plus it's well written (i.e. you can read the code, compared to all other implementations which are just a huge unreadable class). The only downside is if you need Markdown Extra, in which case Parsedown is probably the best alternative.
I also recommend Colin O'Dell's CommonMark implementation.
I would actually take the approach of creating a new column and checking if the column has a value. If not, authenticate with MD5, and if it passes, generate the new password in the new column. The obvious benefit here is that it allows you to see whether or not all your users have new passwords or not, without having to use a `LIKE` or `REGEX` SQL statement.
Agreed but I usually don't even bother with a flag. Just check against your new style first, if it fails try against MD5 and if that succeeds, update the password. If you use the PHP 5.5 password hashing stuff, it's best practice to be checking if passwords need to be rehashed anyways, so you can just wrap that check to include checking against your old MD5 style passwords.
No they can not be converted. crypt()/password_verify() can use MD5 as an algorithm but a salt is mandatory, it uses multiple rounds, plus it does some weird transformation. This can not be replayed without the password. Either crack and rehash them, reset them, or build a compatibility layer. Edit: why downvotes? I think I'm the only one who's directly answering the question
Just try to validate using crypt, if that fails try md5, convert.
I usually do this by checking the hash length, no need for a separate field. MD5 passwords = 32 chars and password_hash() ones are 60 chars.
That's a nifty approach. There is no differentiating the two kinds of passwords if I do that, though. From a security standpoint that may actually be an advantage but I'm not a cryptographer.
I understand. Personally I like having to switch between languages just to stave off boredom. But then I've been doing this shit for too long and find all of it boring. It's just a paycheck :D
You could also add a column in the database to mark which have been updated if you're concerned at all about the extra check. However, MD5 is pretty cheap processor wise... so it's not a big deal. From a security standpoint it is a big deal. MD5 is very outdated, so if someone got ahold of your database it wouldn't take much effort to figure out the password your users used. Moving everything now to use `crypt()` (with a proper algorithm of course) will solve that problem. If you're on PHP 5.5+, I recommend looking at `password_hash()` instead of `crypt()` as it generates secure salts for you.
I am into php/web-dev just to create sites for friends, family-business and myself which pretty much means, I make `$0` every month from it but I don't mind, since it has become a hobby now. Which also means I can't hire someone under these conditions, hence I do everything by myself, from front-end, back-end and system administration. It's very tough, but not insurmountable. It is also a very good way to learn full-stack web development. The only downside is, that with all the learning of so many things at the same time, it will take you longer to become an expert on a particular language. I usually keep notes, and stickers to write whatever I think I should do and just make a time to start something, I also use version control to manage updates, issue trucking ... so I guess in my situation it is doable. 
Element for element... What parts of your tasks run slower? 
This is exactly how I've updated some legacy apps. Easy and simple.
you are so funny....!!!!
&gt; and of course, this library is designed for who needs it Do those people realize who they are? "Marketing" is a bit of a dirty word (especially among programmers) but I think the project could benefit from it... In particular example scenarios that show off how the solution can save time or effort.
Eh, I dunno. In that situation I like tasks to be run in a more agnostic way anyway with APIs. But there are a million ways to skin any given cat, no doubt.
Don't do that. It leaves the less secure hash of the password in the database.
I'm guessing you sanitize, then convert? Will that mess up markdown at all? 
Very clever.
What setter/getter interface? We don't force any interface on you: that's the point of a data mapper.
You can use public attributes as of Doctrine ORM 2.4 - the initialization works for those as well.
These are not conventions, these are APIs existing in Hibernate and JSR-317 You can rename them to whatever you want by simply putting an adapter in front of them :-)
AR only works for really simple use-cases (hahahahahaha, "simple software" :D ), anything that you expect to grow in complexity usually requires either: - hacking around it - migrating to different approaches (`TableGateway`, `ActiveQuery` or `UnitOfWork`) To compare the complexity, here's how AR looks like: // assuming the library is not complete crap, you have constructor injection here: $user = new User($orm); // depending on whether you can modify the constructor or not, you may use // the constructor for required values, or have an invalid object in memory for // a while $user-&gt;setUsername('ocramius'); $user-&gt;save(); Here's how `UnitOfWork` looks like: // custom constructor (user defined) $orm-&gt;persist(new User('ocramius')); $orm-&gt;flush(); Here's how `TableGateway` and `ActiveQuery` could look like: // usually user-defined API here, works also for bulk operations $tableOrQuery-&gt;insert(new User('ocramius')); I actually see `ActiveRecord` as quite complex when compared to both `TableGateway` (which is loved by non-ORM fans) and `UnitOfWork`. I left transactional boundaries out of the comparison, but those should really be discussed as well. Another very annoying thing is dealing with dependent records with `TableGateway` and `ActiveRecord`. Assuming that your `User` depends on an `Address` instance, you have to code the order of operations correctly in both these approaches, whereas the `UnitOfWork` approach defers the order of operations to the actual transaction that will happen implicitly when flushing. 
Monolog is good. Why not use the PSR-3 interface again? I don't see why you would need to use the log level constants when logging (in your services).
Join #phpmentoring on freenode.
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**Yoda conditions**](https://en.wikipedia.org/wiki/Yoda%20conditions): [](#sfw) --- &gt; &gt;In [programming](https://en.wikipedia.org/wiki/Computer_programming) [jargon](https://en.wikipedia.org/wiki/Jargon), __Yoda conditions__ (also called *Yoda notation*) is a [programming style](https://en.wikipedia.org/wiki/Programming_style) where the two parts of an expression are reversed from the typical order in a [conditional statement](https://en.wikipedia.org/wiki/Conditional_(computer_programming\)). A yoda condition places the constant portion of the expression on the left side of the conditional statement. The name for this programming style is derived from the *[Star Wars](https://en.wikipedia.org/wiki/Star_Wars)* character named [Yoda](https://en.wikipedia.org/wiki/Yoda), who spoke English in a non-standard syntax. &gt;Yoda conditions are part of the [WordPress](https://en.wikipedia.org/wiki/WordPress) coding standards. &gt; --- ^Interesting: [^Conditional ^\(computer ^programming)](https://en.wikipedia.org/wiki/Conditional_\(computer_programming\)) ^| [^Mace ^Windu](https://en.wikipedia.org/wiki/Mace_Windu) ^| [^Sansho ^the ^Bailiff](https://en.wikipedia.org/wiki/Sansho_the_Bailiff) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cqak6dh) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cqak6dh)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
I'm casting a negative opinion on reflection/magic-based tools in general, not just PhpSpec. I use Mockery, which I like, but it falls under the same magic category, and I'd apply the same criticism and give the same warnings to people asking about it. This magic is the main reason I've started using it less lately, instead using regular stub/fake classes if it's not too much work. Also, if Mockery starts breaking or showing flaws, it's just a mocking library that I use, not my entire framework, so I'm far less screwed than I would be if I found out PhpSpec was ruining my day after writing 100 test cases.
&gt; I had issues with finding a Markdown Parser that works easily with Laravel 5 Any PHP Markdown package will work with Laravel 5, or any other framework. Store both the source MD and the resulting HTML and you're all set.
Some CMSes (like Drupal and Wordpress) use some sort of marker field within the hash to decide which version of the authentication algorithm to use (it looks like $X$&lt;thehash&gt;). I always thought that was a good idea, it makes it easy to keep the hashes in one field and futureproofing it (because what's safe now isn't necessary safe in the future).
When I was talking about a security standpoint, I was referring to /u/rossriley's point: `crypt($password)` may be much more secure than `md5($password)`, but that doesn't mean that `crypt(md5($password))` is at least as secure as `crypt($password)` or even as `md5($password)`. Your reply indicates that you might have missed that point. It's like thinking you can make random numbers more secure by somehow combining two random numbers: all you're actually doing is decreasing the entropy pool. I'm by no means an expert on this, and I think part of being good at anything is knowing what you're *not* good at.
The outputs from `crypt`/`password_hash` code the algorithm (and salt) in the output. There's no need to explicitly do strlen checks. This will suffice: if (!password_verify($pw_from_user, $hash_in_db)) { if (!hash_equals(md5($pw_from_user), $hash_in_db)) { // fallback // login totally failed } else { $new_hash = password_hash($pw_from_user, PASSWORD_DEFAULT); save_password_to_db($new_hash); } } else { // upgraded password is valid, continue as normal if (password_needs_rehash($hash_in_db, PASSWORD_DEFAULT)) { $new_hash = password_hash($pw_from_user, PASSWORD_DEFAULT); save_password_to_db($new_hash); } } Adjust and refactor to taste, but you get the general idea. Plus by using this approach, you a) prevent timing attacks by using a good password comparison function b) will automatically update passwords to a stronger algorithm if one becomes available c) use good crypto settings by default If you're running &lt;PHP5.5, grab [this hash_equals](https://github.com/ircmaxell/password_compat) library to do this for you, and [this](https://gist.github.com/kAworu/9a97ac4ecd418dac3436) gist for hash_compare
Which is exactly why it is bad. Your domain objects should not know anything about how they are persisted.
Thanks, I got explained earlier by Ptibiscuit. As I earlier it's not that obvious from the documentation. I like to know how the things I use works, so I had a look at the code to understand the hydration process, which I guess uses reflection, still not that clear.
Sometimes your programming language is holding you back, and you have to use alternative ways of achieving your goal. Would you stop using Doctrine because they use reflection? That's an implementation detail that you should not care about, because it will work as expected 100% of the time. The same happens with mocks. Once we have anonymous classes in PHP we'll reduce the amount of "magic" mocks we create. Should we not use them because PHP doesn't have native support? No, we still use the tools we have at our disposal to aid us in our development. You could create fake classes, but they'd slow your design process and make your tests more difficult to understand. Of course, you should *always* favour real classes over mocks when possible. As I said previously, I'm with you in that we should avoid magic *in production code*, as it's difficult to maintain, doesn't provide static analysis, etc., but in a TDD environment we're working with different goals and rules.
Edit: I thought I was answering to another comment. The Entities have absolutely no knowledge of how they are persisted, that is one of the design decisions that was made with the Cake 3 ORM.
just set it up, awesome service..
I totally agree with you.
&gt; I don't use it ;) Actually, neither do I (for other reasons), but them using reflection would be a very poor reason not to use their library. &gt; Not sure what you're saying here. Fake/dummy/stub classes are usually just tiny classes that extend another but override some methods (example). These can in some cases serve the same purpose as a mock, but with less magic. This is what I refer to as a "real class" - as opposed to what Mockery does which is generate class code at runtime and eval it. Yes, I know what you were referring to. The problem is that in every test method you test different things, and you either end up with lots of these fake classes that are only used once, or with bloated ones that are hard to work with. Additionally, you're keeping them too far from where they're being used. &gt; Honestly, I am inclined to consider tests part of the production code. You'll suffer just as much from poor maintenance/design of test code as non-test code - although obviously the exact same rules do not apply. You seem to see tests primarily as a way to drive design, whereas I value them more for the safety net they give me when I have to make changes further down the road. I use them for both driving design and having a safety net. Quoting from the [Wikipedia article about TDD](http://en.wikipedia.org/wiki/Test-driven_development): &gt; Test-driven development offers more than just simple validation of correctness, but can also drive the design of a program. By focusing on the test cases first, one must imagine how the functionality is used by clients (in the first case, the test cases). So, the programmer is concerned with the interface before the implementation. This benefit is complementary to Design by Contract as it approaches code through test cases rather than through mathematical assertions or preconceptions.
Actually, I did a research on this and I came across some of the characteristics of MD5, one was of the pivotal one among was it was irreversible and hence very secure and most of the prominent sites are still using this strategy. I really appreciate you going through the blog and putting in the effort and valuable suggestions. 
&gt; Anything in particular that you are struggling with? not now. Just was going through the whole docs on the orm, database on the pdf. And I was wondering where testing was covered for Entity. I will surely get back to you when I get more deeper into it.
Interesting, I think I'll take a look at this. How to manage the ongoing development of private packages within an application context is a problem I've been facing recently. I've resorted to editing directly in the vendor folder which I really don't like. Laravel's workbench is an okay solution (I'm working on a Laravel 4.2 application), but I feel like a solution needs to be at the Composer level rather than a Laravel-specific solution (which I believe was removed in Laravel 5 anyway). Hopefully this package is the solution, or at least a start in the right direction.
Eric, all hashing algorithms are irreversible in a trivial sense, but MD5 is often reversible due to how fast it is to compute, especially on GPU or specialized hardware. And you don't mention salting, which means it's absolutely trivial to attack such an MD5 hash through lookup tables and/or rainbow tables. I'm afraid your advice is very outdated. Research more about hashing algorithms, such as Blowfish. Read about salting. Read about crypt(). Likewise saying that "MyISAM seems to be the perfect choice for most cases" in 2015 is odd because most developers know this is a legacy engine which doesn't support basics like transactions. MyISAM is today at best an odd edge case you may select for transient caches and the like. InnoDB, which you also talk about, is the default choice on MySQL today and MyISAM shouldn't even be mentioned in any sense, especially to beginners. Your advice about not using star in SELECT to achieve much faster performance is highly overstated. Not using star is a good rule of thumb, but it won't result in a detectable performance improvement in most cases as the database still reads the full disk sectors the record is in (unless your table has large BLOB and TEXT columns you do *not* want to select). The thing you save is not receiving those columns over your connection (which helps a bit, but only if you do *not* need most of the columns). Also, the performance of star is virtually identical to that of listing all columns explicitly (test it). Likewise, Memcache is not a "database caching" technology. It's just a caching technology. You're going to confuse people who know that databases *have their own cache* which they can enable, and this is part of the database, and not related to Memcache at all. And last, your terminology about "static vs dynamic" URLs is a bit off. It seems you mean stable &amp; pretty URLs, versus ugly &amp; unstable URLs. But they're all *dynamic*. If you go through a router, this is always resolved dynamically, not statically. You have a static URL when you point to a static asset like an image, JS file, CSS file (and even that can be a bit odd to call a "static URL").
&gt; Actually, neither do I (for other reasons), but them using reflection would be a very poor reason not to use their library. I have plenty of other reasons, like it being bloated and convoluted. I think it boils down to the same thing though - it's doing a lot of "magic". I don't want to single out reflection in particular. &gt; Yes, I know what you were referring to. The problem is that in every test method you test different things, and you either end up with lots of these fake classes that are only used once, or with bloated ones that are hard to work with. Additionally, you're keeping them too far from where they're being used. This is a valid concern, but again it varies from case to case. Also, it's mainly a limitation of PHP, not a design choice. When anonymous classes get shipped with PHP7, avoiding mocks will be both easier and more readable than it is now. I'm fully aware of how TDD works, I'm just saying I'd rather spend a little bit more effort writing the tests and having them a little bit less readable, if it means I can be more confident that my tests will still run and be maintainable several months/years down the line. I could be entirely wrong and PhpSpec turns out to be completely stable, but my judgement is based on past experience with tools written using similar methods (using "magic").
Indeed we used the "workbench" workflow before but we decided to create this plugin because we have to share packages with different versions between our projects, without git pushing or composer updating. It took a lot of time for developers and it was too hazardous, because you push a feature that might be buggy. Now, you can make a modification into a package, and all projects which use the package have the modification.
 ZEND_FUNCTION(strlen) { zend_string *s; #ifndef FAST_ZPP if (zend_parse_parameters(ZEND_NUM_ARGS(), "S", &amp;s) == FAILURE) { return; } #else ZEND_PARSE_PARAMETERS_START(1, 1) Z_PARAM_STR(s) ZEND_PARSE_PARAMETERS_END(); #endif RETVAL_LONG(s-&gt;len); } This is the code to be more exact. Basicly it takes the first argument as a zend_string, and returns the len variable of the zend_string (As this is calculated before). 
Why don't we have a sublime version of this? This sounds awesome!
Where can I get started learning php core development? From the basics of how to compile PHP
/u/BringTheTanks explained very well why you shouldn't use MD5 for storing passwords, but here's my two cents: since PHP 5.5, you can use [password_hash[(php.net/manual/en/function.password-hash.php) to generate a strong, salted hash of a password (and [password_verify](http://php.net/manual/en/function.password-verify.php) to verify it) If you have a server that runs PHP 5.5 or higher, this is **definitely** my preferred choice, rather than creating and storing a salt separately.
Off-topic: trying to read what this library does, the `if everything is important, then nothing is` principle came to mind. I'd reduce the amount of bold text in the first paragraph :)
Wordpress has, and always will be a security playground because the mentality around sites built using it is just write/download a theme, install some plugins, do a little customisation and deploy. They're hardly ever maintained -- leading to a whole lot of sites being exploitable. Wordpress is a blogging platform and should have been kept that way. It's not scalable and shouldn't be used in fully fledged websites. This is my 2c, meaning it's my opinion. I'd love to think that wordpress is a reliable and secure option, but i'm yet to be proven wrong.
The part where you have to change the dependency's type in composer.json puts me off this. Is this really necessary? If I have an existing package added to packagist or my Satis server, but want to spend a day doing some local hacking/testing on it, I shouldn't have to change its composer.json.
Needs to be updated - consider sending a PR :-)
Why should one use mysqli instead of PDO? 
Going to check out that, thanks 
Thanks for the recommendation Read the documentation and Ion Auth seems complete and light. Any advice or disclaimers before I integrate it?
And if people aren't running 5.5 there's always [password_compat](https://github.com/ircmaxell/password_compat) for 5.3.7+.
Plus, if you have a special type that requires extra processing/logic, like [one of those](https://github.com/composer/installers), it probably won't work. Perhaps using more configuration, like listing the packages you wan't to symlink, and using events would be a way to solve this without using custom types.
We actually use Satis to manage all our private repositories, so adding the private repositories isn't the problem. The problem is, once Composer has pulled it in, how do you go about editing, committing and pushing changes in a project context? We manage a few Laravel-specific packages, containing service providers, routes, other laravel specific stuff, and it's much easier to write and edit the package when in the context of a Laravel application (rather than developing the package independently). The only way I've been able to accomplish this is either using Laravel's Workbench, or using composer to pulling in "dev-default" in a project, and making amends directly in the vendor folder. This plugin potentially provides a better solution than both of those. I'd be interested to hear from anyone else that has any other ideas of package development best practices from within the context of an application. It's something I've been researching for a while, and I still feel the process is really messy.
This looks really cool. Definitely will try it out.
Your trick works only if your package is hosted on Github :(
thanks, it does seem simple as I had thought. Is this the only part that makes streln work, or is there some other reference to it, that I should know about? 
https://github.com/doctrine/dbal/blob/master/lib/Doctrine/DBAL/Driver/OCI8/OCI8Connection.php Look at the quote method.... 
If the purpose of your test is to ensure that the login page works, the test shouldn't need to do all that stuff with the session, user manager, login manager, firewall etc. Your test should load the login page, fill in the login/password fields and submit the form. You don't **have** to write this in another testing framework, Symfony has PHPUnit test cases for functional testing that uses the http client, DOM crawler etc. which makes it fairly easy to do. See [this link](http://symfony.com/doc/current/book/testing.html#your-first-functional-test) for an example - I'd read the entire page if I were you.
I will implement a wildcard, like : "acme/*".
Thanks, feel free to feedback !
Your test should look something like: 1. Set up the client to follow redirects (`$client-&gt;followRedirects()`) 2. Request the login page as a HTTP request (`$client-&gt;request(...)`) 3. Fill in the login form (`$form['username'] = 'myuser'`) 4. Submit the form (`$form-&gt;submit($data)`) 5. Check that you were redirected to the correct location (admin dashboard on success, back to the login page on failure)
I use php 5.5's built-in Zend OpCache, but admittedly used the same lib in php 5.4 (before it was included). In addition, I'm mega sold on redis, which I essentially use to cache SQL data views, config files, php objects, HTML templates, or anything else deemed as heavy and/or time-insensitive. On top of that, I actively use and tune the MySQL cache, GZIP compression (nginx), and DNS-level caching (cloudflare) for static content. My opinion is that these systems are all integral components of any scalable enterprise-level php environment, and because of that, you should fully understand and employ them in a manner that best suits your company, product, build processes, etc. Stash seems superfluous. It's easy enough to write trivial wrappers in your own code. Whenever I make a call to predis, I never call the redis library directly - I created a simple CacheProvider which offers up methods to wrap the calls. This is simple enough such that you don't need to spend a few weeks learning a new library/framework for stuff which is better implemented manually. Also, what if they stop working on it, a bug impacts critical use cases, etc. Edit: in addition to the other benefits of the above caching stack: enterprise scalability. Redis clusters, stateless php clusters, mysql clusters... All of these tools continue to excel/scale even when you've got multiple servers processing requests in parallel Edit 2: sorry for wall of text. Another reason why manually implementing/tweaking your caching strategy is important: your setup and strategy will differ depending on your product, build process, environment, etc. Learning the libraries and implementing them directly will give you more granular control over your overall caching strategy, and likely the ability to make it more effective 
No, just use bcrypt and be done with it (via something like password_compat). And don't use peppers, [they aren't good](http://stackoverflow.com/questions/16891729/best-practices-salting-peppering-passwords/16896216#16896216)
I'm using stash and it works fine.
I use Doctrine Cache (http://doctrine-orm.readthedocs.org/en/latest/reference/caching.html) nice api, lots of backends. I'll be re-evaluating this though once PSR-6 (https://github.com/php-fig/fig-standards/blob/master/proposed/cache.md) passes
This works for me. http://pastebin.com/MnvKE9yR 
Have you tried using &amp; pound; (no space) instead? So in your HTML encode all pound symbols as &amp; pound; which will then be displayed as £ when viewed and it should also be searchable in mysql. Alternatively, you could have a seperate currency column in MYSQL like this link explains... http://stackoverflow.com/questions/11119072/pound-sign-shows-as-a%C2%A3-when-entering-it-into-mysql
So, if I was to remove any reference of/to strlen() from the source except for the two places where it is mentioned above, would the function work? 
Terrific! Now use the other code I pasted below. Try to get echo $con-&gt;error . " is the error!&lt;br&gt;"; after the insert statement.
Sorry, ignore the Make_UTF8() line. That's a function I stick on most pages. function Make_UTF8() { echo('&lt;meta http-equiv="content-type" content="text/html; charset=utf-8"&gt;&lt;/meta&gt;'); } It doesn't need to be int(50). This is how I would personally set it up if it's only for this purpose. I always have 'ID' first and fully capped. Then capitalize as I go. `Table`=ID[Int(5)], Clicks[Int(10)], TimeStamp[Int(15)] Feel free not to use Int(15) for TimeStamp. I'm just a simple kind of integer guy. Does everything work now?
Laravel cache
Ah no. There's also the [arginfo](http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_builtin_functions.c#108), and the [function entry](http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_builtin_functions.c#262). And of course, the opcode I mentioned requires [compiler support](http://lxr.php.net/xref/PHP_TRUNK/Zend/zend_compile.c#2816) and some code in opcache also dealing with it.
Sorry it is a long, complex query. See the query as: $query = "SELECT * FROM `data` WHERE `notes` LIKE Lower(\"%" . $searchterm . "%\")"; Running the query directly in mysql replacing the variable of course with the actual search term returns the results we want. The problem is when the search term is passed through a field in a form. 
This is what my connector.php looks like. &lt;?php error_reporting(E_ALL); ini_set('display_errors', '1'); $IPAddress = "123.456.789.10"; $DBUser = "userName"; $DBPassword = "password1"; $DBAccesses = "default"; $con = mysqli_connect($IPAddress, $DBUser, $DBPassword, $DBAccesses); if (empty($con-&gt;error)) { } else { echo("Error: " . $con-&gt;error . "&lt;br&gt;"); die; }
Thanks, sums up the answer. 
i've only read about PhantomJS and I dont know how it works in practice but it looks like solution for your problem. But still it sound weird to compute anything in js directly from php.
Java-style static initializer syntax would probably look nicer: class Foo { static { // initialization code here } } But that's going to happen initializer blocks should be a thing in general, IMO. Create's some nice, clean code with [anonymous classes](https://wiki.php.net/rfc/anonymous_classes) in PHP7: $object = new class extends ArrayObject {{ $this['oops'] = true; }}; Not something you'd do in normal code but convenient for things like testing. 
&gt; The problem is when the search term is passed through a field in a form. This may be the problem. Make the form a GET and look at how the £ is urlencoded. You'll probably find as /u/SkepticalMartian said that there's a character encoding discrepancy ISO-8859-1 to UTF-8. Most likely the form is submitting as ISO-8859-1 and the database is receiving as UTF-8.