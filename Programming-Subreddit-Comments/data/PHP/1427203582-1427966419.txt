It's not in the docs, but IMO even worse, it's very unconventional. It shouldn't *have* to be documented because it shouldn't break from convention in this way.
Sorry man, but I've worked with Cake 2.0 and after reading through the documentation on Cake 3.0's "ORM", It's not quite as production-focused and developer-friendly as Laravel is. Save for BC-breaks like this, Laravel is still a more efficient tool than Cake is. Cake's "convention over configuration" is the same in Laravel. Almost zero configuration out of the box, yet it doesn't hammer those conventions and assumptions into you. It makes you explicitly declare routes, because you SHOULD explicitly declare routes. Cakes default route conventions aren't a good thing. At all.
https://github.com/laravel/framework/commit/cfa7fcb#commitcomment-10339594 That is an important comment in that thread that needs to be highlighted. Open source isn't an inflexible dictatorship. GrahamCampbell does a *lot* of work for Laravel, but sometimes he gets far too attached to specific implementations.
It probably should have taught you to have a dev/staging area instead :P
It is still basically a one-man-show, isn't it?
As far as I can tell, yes
But you'd have to run composer update/install at some point wouldn't you? and the post update composer hooks that laravel ships with run the optimise command at that point - so even if you were running this off the production server (which is the correct approach.. run all this stuff in staging, then transfer what you need over to production), Or you were committing your vendor file (and nobody should be advocating doing this!) your file would be in the right place and the folder permissions wouldn't actually matter? Or am I missing something here? 
Exactly
Why so serious son?
It is a bit of a begginers question - what are the main differences between Cake 3 and Laravel 5. I invested a lot of time in Laravel, I am curious should I learn and transfer to Cake 3? Are there any advantages?
I created an account only to echo this.
Basically this.. I worked with Cake for years and whilst it was great vs rolling everything from scratch, it was for the most part painful to work with. And it looks (from a cursory glance of the docs) that many of the Cake 2 sadnesses still exist (the explicit requirement to specify which variables you want serialized when creating json api's.. or the extension based request handling... /users = html, /users.json = json, /users.xml = xml... instead of using accept headers still appear to remain in this "state of the art" framework). As someone who has used both I can honestly say I've been several times more productive, and made more money using Laravel. To pass it off as some hipster toy, or to call into question the fact that it's unashamedly run by a BDFL (something that many of us are actually thankful for, because we avoid the tyranny of the masses) is pretty off base.. and shameful coming from people who represent a framework they are trying to pass off as serious.
Actually, once I realized a handful of people were broken by this change, I fixed it.
My bad. Many people seem to jump on semver as if it's somehow "the law" that everyone must just "follow"..because "reasons". Semver is great and all if you're willing to accept the freedom that it asks you to give up - and for many (most?) projects this is entirely acceptable... but just because one project or another decides not to doesn't mean it's time to grab torches and pitchforks. And yes, I pretty much agree with what you're saying. It should have been a minor version bump (5.1).. and being "sacred" about minor version bumps shouldn't be a thing (who cares if we bump a minor version every month? this is actually not that uncommon a thing). I wouldn't care if I was using 5.23 by christmas... and I doubt anyone else would either. Either that or have a less promiscuous default composer.json version (though this would limit rolling out security patches to people quickly). Of course, there's nothing to stop an individual changing the composer.json to be a little less eager with updates if such things are a concern (or using it to perform a rollback to the last known good version). 
It should be noted that your opinion is not entirely without bias, as you were very put-off by not getting your own, specific way in terms of how packages are developed and maintained, then started your own framework after rage quitting Laravel - and have had a history of basically trashing Laravel at every opportunity from then on. It should also be noted that I fixed this unintentional breaking change.
This simply means that you can optionally tell `curl_*()` to communicate with the remote server via HTTP/2.0. If the remote server doesn't support the protocol the two parties will speak HTTP/1.1 as before. There are two scenarios in PHP userland where you can benefit from the use of HTTP/2.0 in a curl client: 1. You're retrieving multiple resources from the same site *concurrently over the same connection*; you may experience performance improvement by avoiding the "head-of-line" blocking problem because HTTP/2.0 allows the multiplexing of multiple transfers concurrently over the same TCP connection. 2. You're connecting via HTTPS (h2). Encrypted h2 sessions are negotiated as part of the TLS handshake via the TLS ALPN extension. This means you can establish the crypto session with fewer TCP roundrips via HTTP/2.0 than you'd be able to do with HTTP/1.1 (a performance benefit).
Rocketeer gives zero-downtime deployments.
I wrote a really long post about this previously but I can't find it because Reddit's search capabilities were written by a canteloupe. I started learning Angular and really didn't like it. I felt like I was polluting the HTML, and the whole structure and architecture felt kind of... eccentric. Angular is also in a weird limbo at the moment in terms of new development, as all knowledge gained essentially resets with Angular 2.0. That's not a criticism of Angular 2.0, but it does mean that framework will have to earn its supporters in a different field than what Angular had. I started learning Ember a while ago. I struggled a lot. Learning its conventions and dealing with breaking changes from a moving target, especially in Ember Data, the persistence component, made it hard. I've come back to it more recently, and it's been surprisingly impressive. The use of a CLI to generate elements in a way that conforms to and works with Ember's assumptions is invaluable. It also has a fantastic ecosystem of add-ons, meaning things like deployment and adding functionality are hugely simplified. For example, the ember divshot addon let me trivialise a deployment process for staging. The ember font-icon library lets you do things like `{{fa-icon '"camera"}}` with just two command lines. Ember Data has evolved to become solid and reliable, and abstracts out connection to a RESTful API for persistence. Newly upcoming features are equally impressive. Liquid Fire is an animation framework that lets you specify extremely simple syntax for transitions. I implemented it just tonight and it took surprisingly little effort to make my simple mobile app go from basic routing to css transition animations. This is an absolutely killer feature and I wouldn't know how to do some of what I'm doing even in something like jquery.
With all due respect this suggests that the things you're doing are not particularly big or complex. Implementing a single-page app of any size with some jquery events quickly becomes unsupportable.
What exactly in Cake 3 ORM is not production-focused or developer friendly? I'm genuinely interested in understanding your view.
&gt; the explicit requirement to specify which variables you want serialized when creating json What do you mean here? You can basically create any json response with or without manually specifying the variables that you want serialized. Of course, telling the framework which variables you want to display is the preferred way. &gt; or the extension based request handling... /users = html, /users.json = json, /users.xml = xml The use of accept headers has been the default since 2011, but the extensions support exists because it helps developers changes the response format without special tools. Maybe a honest read in the official documentation can help misspell the misunderstandings? I'm also open for answering any specific questions you may have.
Great. Thanks. I'll give it a go:)
3-4 years ago it was a disaster
Yes, I am very frustrated by that response as well. I hear you. I have spoken with Graham privately about this response and expressed that it can never happen again.
Yes, but this is pretty heavy with a lot of stuff going on and the requirements are pretty strict on response times.
It is a circlejerk though. Every other thread about Laravel is singing its praises, but as soon as one little change was made (that didn't affect anyone who had their project set up properly), Laravel is literally the worst thing ever and Taylor is literally Hitler. Also you seem to have made this account specifically to bash Laravel. I hope you're happy with yourself mate ;)
Nobody is forcing you to update though
&gt; I found it nearly impossible to call an existing helper from a custom one It should be straightforward to inject the HelperLocator itself into a helper: &lt;?php use Aura\Html\HelperLocator; use Aura\Html\Helper\AbstractHelper; class MyHelper extends AbstractHelper { public function __construct(HelperLocator $locator) { $this-&gt;locator = $locator; } public function __invoke() { return $this-&gt;locator-&gt;otherHelper(); } } ?&gt; Did you try some other approach? &gt; or to extend one of the core ones Which one(s) did you try to extend?
Yeah but I like bug fixes and new features. It's not a lot to ask for minor versions not to include breaking changes, pretty much everything else manages it.
Well maybe it's changed since, keep in mind t'was a few months back. What I was trying to do was a custom select extending the core one to prefill some of the parent's argument with values formatted by mine or something
&gt; larareddit &gt; redditor for 5 hours Did you create a throwaway account just to complain about Laravel?
But without even checking the changelog...
While on this topic: You may want to keep an eye on *how* Graham is supervising issues and PR's. Some hinting words: hasty, rude, condescending, arrogant, and defensive. And no, I'm not bashing him. I know very well how capable he is, and how much he has been contributing to Laravel and PHP.
Thank you for your patience.
No. People like me picked Laravel over Symfony (or any other frameworks) for good reasons. This whole thread, I believe, was created only for Laravel to be a better framework, not to advertise another.
I loathe duplicated logic. Invariably, the duplicates diverge to some degree with age and developer transition. I've thought about this over and over. Yes, you need unit tests. However, I can't seem to get around the fact that the most palatable solution for me, personally, is to keep any non-client specific logic on the server and just ajax the results to the client when needed. If there is logic that is only needed on the client, then I keep it on the client and no ajax is needed. Again, no duplicated logic. For me, the only real exception to this is validation. However, in this case, I kinda consider the validation logic on the server and the validation logic on the client to be different. Specifically, on the client it's better to use the term "form validation" and on the client I prefer the idea of "object validation". Of course, we need to set aside the obvious fact that a form can be modeled as an object, thereby, messing up my metaphor.
Don't get me wrong, I'm a big fan of Laravel but your point is 100% valid. Your account name and timing made me wonder if you're a more well-known user who didn't want to criticize Laravel publicly, that's all.
I'm pretty sure the vast majority of Laravel users have had little to no problems with stability over the last couple of years. Otherwise it would not be so popular. While this issue was inconvenient, anyone who did a Composer Update command on a live site, resulting in a broken Laravel 5 system, doesn't know what they are doing in the first place. I would never go back and update the Laravel framework for a previously finished project without a pressing need, like a security fix, or a necessary bug fix. So for me, stability has been a non-issue. I've never had a site go down due to a Laravel framework related problem.
Well, if making an AJAX call is too slow maybe your server isn't up to the task. :P
What about the case where the composer vendor directory isn't called "vendor"? Composer has a [vendor-dir](https://getcomposer.org/doc/04-schema.md#config) parameter that allows you to customize the directory. Can you at least add a config option? Or maybe parse it out of `composer.json`?
Just use the -O option. $ wget http://br1.php.net/get/php-5.3.29.tar.bz2/from/this/mirror -O php-5.3.29.tar.bz2 =C= 
&gt; keep in mind t'was a few months back I don't *think* the HelperLocator approach I suggested would have changed in that time, but my memory is not always perfect. &gt; a custom select extending the core one Yes, I can imagine that would have been a little tough; the Select helper is one of the, if not the most, complicated helpers in the package.
I think we're talking about the same thing, tho? Regardless of how you encode those rules as data, you'll still have to build some kind of engine to interpret and implement them, no? And thanks for the compliment - yay me! :)
He noted this in the issue tracker as one of the reasons for rolling it back.
I dont think that the php site has anything to do with it. I **think** that wget just uses the last part of the url as the filename that gets downlaoded. The -O option would change the filename to whatever is specified. (I hope thats right...)
Your spreadsheet is wrong… It's not (new - old)/old, but (new - old)/new (or 1 - (old/new)).
That will not work, as you can see in the [page source code](https://github.com/php/web-php/blob/master/include/do-download.inc#L35): there is no ``readfile`` involved, instead, you are redirected to the actual file. This way you don't have to handle the resuming of downloads, etags, etc and can leave this to Apache. ``wget`` seems to be unable to use the filename part of the last URL it fetches a file from. Report this error to the authors of ``wget``.
The numbers are correct, it just gives false illusions. It's about what you compare to and in which context you put it. When I read "95% faster", I immediately think… "oh, 20 times faster". And not "I can do 95% more ops".
20 times faster would be "it takes 95% less time". When you want to say that the speed has doubled (approximately), it is perfectly correct to say "95% faster". No false illusions here.
Really see no reason to pay 99$ for what I can get for free in Eclipse or Aptana. 
As someone who is happy with the tools he currently uses: Would you mind pointing out what it is that makes the ide stand out? Making it worth the extra 50$ per (commercial-)license over phpstorm?
Regardless of benchmarks, you can just look at any test suite out there, like [this stuff](https://twitter.com/Ocramius/status/580422850949046273/photo/1) Times are consistently halved, but I didn't check PHP 7.x + XDebug yet (because test times are what matters most for me personally)
[**@Ocramius**](https://twitter.com/Ocramius/) &gt; [2015-03-24 17:36 UTC](https://twitter.com/Ocramius/status/580422850949046273) &gt; @jcchavezs I’ve been using PHP 7.0 for a while now. The advantage is clear: @CalEvans [[Attached pic]](http://pbs.twimg.com/media/CA4TgNvVEAAOf1u.png) [[Imgur rehost]](http://i.imgur.com/AffvgDK.png) ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
&gt; But that's not really fair. scrypt() as a function wasn't really designed for the every day developer. A friend of mine wrote a Node.js package called "scrypt for humans" for abstracting a lot of details away. https://www.npmjs.com/package/scrypt-for-humans
i sublime, i can select a word with ctrl+d and the same words in that document with ctrl+d spam, or alt+f3. i can select a bunch of lines and then split up the selection to every line with crtl+shift+l. when i search, i can select all results with alt+enter. in phpstorm, i can only make multiple selections by holding alt and clicking where i want to select... right?
Yes it does. In fact we introduced an all new SDK. Whatever gave you the idea that it doesnt? See http://komodoide.com/resources/
Its been almost 30 days, how has your progress been going? I also just purchased this book.
There's a shortcut that replicates Ctrl+d, forget what its called as I instantly remapped it. Not sure about line split, not something I've used, but there's a lot of multi selection tools so might be there
Given that my employer either pays for the tools we use (commercial phpstorm license) or subsidises them (if we choose to use an other tool) I wouldn't qualify for the 99$ option. The more or less comperable PhpStorm license costs 199$/129$. Looking at Komodo I'd need to pay 245$/87$. Ok, my message above might imply something different. Your pricing model appears to be competitive if I got it right. edit: You might not want to hide the 87$/year for upgrades in a footnote. I might not be the only one who only swiftly looks at the page and infers the wrong thing.
1) I didn't want to burn a bunch of cycles on 3v4l.org to benchmark PHP 2) You're only running each benchmark once, which isn't a good test. I dunno who runs 3v4l.org, but I'd be happy to throw my full benchmark up there, if they don't mind me chewing up a bunch of CPU time.
Yep, the $87 a year gets you all the upgrades and gives you support. Quite competitive :) Note we are selling one IDE with all our supported languages, as oppose to one IDE per major language. So factor that into the prices.
AJAX is indeed asynchronous, well done. However, processes like the OP is describing often are not - they are linear progressions. If a step of a process is contingent on validation/calculation of a previous step, you're going to have to wait for it to complete before moving on to the next step. Thus, AJAX being asynchronous is moot as the actual process being served by the AJAX call is not. I dunno what background you have, but anyone using or developing apps more complex than "hello world" should be aware of that.
Oh please. Don't get over defensive just because I called you out on your ridiculous claim that web apps cause a beach ball due to AJAX requests. Yes, the calculation will take longer when you have to do an AJAX request instead of doing it in JS. But it shouldn't be more than a fraction of a second, unless your server is having issues, it will be plenty fast. OP wanted a solution for having to duplicate logic. I provided a total reasonable one. If you think making AJAX requests in a JS app is not doable you are the one who doesn't know anything about writing web apps. Because that's exactly how the web works.
It's pretty simple. - Bob is the owner of a website. - Bob has user account #1. - Bob has administrative rights on his website. - Mallory is a user of Bob's website. - Mallory has user account #243. - Mallory only has no special access on Bob's website. When a user logs in, Bob's website sets a cookie that stores the user account, and the login status. - When Mallory logs in on Bob's website she gets a cookie that states she has user account #243 and is currently logged in. - Mallory manually changes this cookie to read user account #1 instead of #243. - Mallory now has a cookie that states she has user account #1 and is currently logged in. Mallory now has access to Bob's account, without having to provide Bob's password. (Oops.) 
composer.lock read only.
That's what properly implemented semver is for. If the patch level increases, there should be no reason to check the changelog. If the minor level increases, you should check the changelog. If the major version increases, there will be breakage.
I'm not being defensive - I was being slightly snide because you're obviously clueless, what you're saying is garbage, and I'm calling you on it. Unless you're on a LAN with the server and you know your maximum load in advance, there is no way to guarantee decent response time. Plus, the OP has already said in previous comments that AJAX isn't suitable due to lag times making that a no go as a solution. You'd have to either be incredibly naive or incredibly new to the web if you've never encountered a web app that locks down the app and shows a spinner while it completes an AJAX request. Which, incidentally, has nothing to do with browser choice. Unless you're so hugely inexperienced in web development as to think that it's the *browser* that was being referred to when talking about the app freezing user interaction while it makes a call out to a server. Which, given that you called it a "beach ball", seems likely; Mac boys are generally graphic artists who like to fancy themselves as being web development savvy because they use Adobe products to create images for web apps and copy/paste jQuery into whatever's being generated for them by some point &amp; click IDE.
&gt; because you're obviously clueless Says the idiot who claimed AJAX requests cause beach balls. I'm a lead web developer and I've been programming for over 25 years. You're an imbecile. I"m done wasting my time on you.
Yet another example of how Laravel-as-a-business is getting completely out of hand. Taylor is a great man, don't get me wrong, but this is not how you manage a framework used by thousands of people. Responsible for weekly keeping the technology stack of a high profile app in order and normally this involves running "composer update" on several staging servers, running some pre-deploy scripts for readiness and the (unit &amp; integration) test suite and sending a merge-request to the reviewer for the production servers. What is supposed to be an hour of work maximum turned out to be a FUCKING day of work. The entire sprint and its allocated resources were completely skewed due to me and several others spending time on finding out what the problem was. If I saw these commit-comments earlier I would have spared myself a lot of time. I had to work extra hours to get on schedule again. Monday was deploy day and it was entirely wasted by finding out Laravel introduces a MAJOR change in a MINOR version bump. If semver is anything, it is introducing FUCKING SANITY for developers. Though I have been foolish to believe a modern PHP framework would adhere to semver by default, this is a fucking joke users of the framework get to pay the price for.
I don't think there is fancy .htaccess rewriting, just something like ``ErrorDocument 404 /error.php`` I would say.
95% faster = 1.95 compared to 1.00. 1.00 / 1.95 = 51.28% less time. 
That's the idea yeah, to deploy the same code ( our back office ) on all the servers, and keeping them synchronized to the repository ( the common trunk ) , I'll look into Capistrano, thanks for the answer! 
You can always ask sales to reset your trial :) Right now you could just download the last RC as well which is identical to the final release and is still good for a few weeks - http://downloads.activestate.com/Komodo/nightly/komodoide/latest-master/
If the page only refreshes you need to look at the &lt;form opening tag with the action. Also check if the $_POST['registerbtn'] is called by placing an ECHO in the next line. This way you can see if this function is called
Yeah, IDE is a great product. I've used the trial in the past and loved it. But as I said, I can't justify spending $$$ for debugging functionality that I can get in Notepad++ for free. I'll definitely give IDE 9 a trial again, just to see how it's progressed though.
Fair enough, it's not your personal comments I was referring to, to be fair. I wasn't sure of the level of involvement of some of the other people but they seem to put themselves across as though they're involved in some way, and then are incredibly rude.
I'm trying to list products. With addtitional data. Db version is mysql 5.6 innodb al tables. Queries can be the little problem cause there are same queries executing couple of times. Im working on fixing it. I have redis installed too. But not on my dev\local enviroment. Do you guys know any doctrine dbal extension where I can save recurring queries to static cache varianble?
&gt; you should find a real solution instead of a hack. Oh believe me I know. I'm not new to programming, just PHP. By the time I realized how many ifs the tutor was using, I was already to deep to start a new tutorial so I followed it. Not the best start to learning PHP.
That's reassuring to hear, it wasn't the impression I got from reading the above link!
that for tip. I will try copying in on my local env and trying to test it. But problem is that db is couple GB. And i have couple of different DB.
Thaks for that tip. I already have this set for 4096k. But it only speeded by 1-2 seconds.
Yeah, I agree, and is something I talked about with Graham personally and he does feel bad about in retrospect. He issued an apology on the thread.
&gt; A temporary breaking change is not apocalyptic - it is life. I can almost smell your .NET background in that sentence. 
I'm confused. How can it possibly have been unintentional? You intentionally committed the change, did you not? How could it not be a breaking change? Why would any directory designed to store code files be writeable by the webserver user?
I don't know where you've been looking, but from my 2 years of experience the international Magento community is thriving.
It's writable for every server I've worked on I assumed it was pretty common. If you run Composer install on a server it writes to the vendor directory. Anyways, that's why it was unintentional - because I didn't intend to break anything. I don't really have anything else to add on the whole situation (which has been resolved).
What version of PHP are you using? If you're using 5.5 or later, you ought to replace this line: $password = md5(md5("didsgnig".$password."w35ojngDSR$")); with this: $password = password_hash($password); Which is cryptographically secure, and provided by PHP itself. 
Vi mode is natively supported. I am not aware of anyone sharing git or preforce keybindings, you would have to set those up yourself. Example: https://github.com/Komodo/Komodo-Sublime-Keybinds/blob/master/Komodo-Sublime-Win-Lin.kkf
Line 67 of activate echo "&lt;form action='./activate.php' method='post'&lt;/form&gt;; You've got a closing &lt;/form&gt; tag there, and at the bottom on line 86
Amazing that you've managed to dupe people for that long into thinking you know what you're talking about. Poor suckers. And if you're a lead and this is a sample of the quality of your leadership, I can guarantee your devs are very unhappy campers indeed. As for AJAX requests 'causing' *spinners* (not beach balls, thank you, and most devs would use the word 'displaying') ... if you've never had a web app grey out and show a place holder while it's doing a server request, you are way too deeply stuck in your 25yr old development mindset while using FrontPage to create pages with notices like "best viewed with IE at resolution XYZ". 
Agreed... you either end up with callback soup, or you end up having to write your own "framework" of sorts to enforce your own conventions and keep things manageable. Neither of which sound particularly fun.
What languages are you referring to? I don't know of any that don't require your application to interpret its own input in some way or another.
Here you go: https://www.youtube.com/watch?v=hAkKC8DKN9A&amp;index=16&amp;list=PLF99B82E8685AA149 
That gist is just fucking cruel. There is no reason for this. 
Even if we're talking about literal strings and not semantic ones, there are several `$_SERVER` keys that are non-strings (e.g. `REQUEST_TIME`, `REQUEST_TIME_FLOAT`), input from `$_SESSION` can be virtually any type, and so on. So, no - all input in PHP does *not* start as a string (literally or semantically).
It's not intentional because he didn't mean to break anything and has since fixed it for those who did have issues. 
Taylor I don't think you're gonna convince people here. The pitchforks really are ready. Just keep coding awesome code and ignore all this bashing!
Check out https://www.easypost.com/. Their PHP SDK can be found here: https://github.com/EasyPost/easypost-php
It wasn't so much the change, but certain replies shortly there after that set me off most, and believe me, I tried to be as civil as I could. Your explanation is completely understandable, and I agree, but in actuality, the fact that any of these paths are hardcoded is a little strange. Perhaps a better solution is to move the files to some logical default location, and allow users to be able to override the default through the application configuration.
This is a bit hard to follow, but assuming table_exists() contains tablecreate.php line 41, `$conn` is not scoped for that function. The fix sorta depends on the surrounding code (e.g. is this a class?) but you could try changing: function table_exists($tableName) { to: function table_exists($conn, $tableName) { And change: table_exists("membersin") To: table_exists($conn, "membersin") That would make the code execute, but there's probably a better way to detect a table than trying to select all rows from it.
This is way off topic I guess.. I'm happy to discuss privately to save any further "misconceptions" on a public forum. Hit me up. 
Lolwut? temporary breaking changes happen *everywhere*, all the time, despite the best intentions. We do things to mitigate them (and there is a case that could be made that perhaps Laravel could have mitigated it by having some sort of 'canary' build that people can check before it goes live) but at the end of the day all we can do is reduce the chances of a break happening.. it's impossible to protect against every possible eventuality..and claiming that this is somehow a .NET culture thing is incredibly stupid.
A penny per package is fairly cheap ;)
Can you expand on this? I actually really like the Symfony API.
It's fine that Laravel assumes `vendor` *exists*. In a very large proportion of web hosts, though, `vendor` is not **writeable** by the web server.
This is a really solid post. You may not be the writer, but hopefully someone can answer my question. I am constantly working on our Magento environment that is in a load balanced cluster via Haproxy. Sticky sessions work pretty well for us, but I wonder about the Redis solution where the info is stored in memory instead. How would that work - would we need an additional server in the cluster for just storing the sessions or is it low usage enough to put it on...say...the database server portion of the cluster?
As someone who is about to be launching a Magento environment with HAProxy, what are you using for S3 integration? I'm trying the AoE AmazonCDN extension but I've had trouble with it. For some reason, when my images are uploaded to S3 the colors get distorted. 
a) you shouldn't be doing those things as the webserver user. b) you shouldn't be running composer on production servers.
Rasmus showed a number of benchmarks in his PHP Australia talk. The results are similar to what you're getting. http://talks.php.net/oz15#/drupalbench (use left and right arrows to navigate)
&gt; composer.lock read only. "... Final Destination."[\*](http://knowyourmeme.com/memes/no-items-fox-only-final-destination)
Is there an example library that implements caching in a way you'd prefer?
I use opcache in all of my development environments 
If this breaking change costed you one DAY, then you have yourself to blame first, not Taylor. Yes, he made the change. Yes, he could have followed Semver. Yes, his project collaborators could show a better attitude. But one DAY to find out and fix this problem? Come on. Maybe Taylor is right after all. Such comments are just toxic.
Examples? I've been working on a Symfony project for the last few weeks, and it didn't seem much worse than other projects of similar focus and scope. (Sure, I've made a few pull-requests for clarifications in the documentation, but at least they make that pretty painless to do.)
&gt; stopped reading there. It's obviously to let devs know which methods are part of the HTTP spec and which ones aren't. You cannot use visibility to determine. It has been tried in the past with Kohana. Ask them about it That's not a reason.
As a starting point, you can use something as simple as [file_get_contents](http://php.net/manual/en/function.file-get-contents.php) to get the HTML/XML of a remote page. Then you want something like [DomCrawler](http://symfony.com/doc/current/components/dom_crawler.html) to break down the document and extract the parts that you are interested in. What you do from that point obviously depends on your requirements. 
Fwiw, php 7 and hhvm are generally trading off leadership in various benchmarks, and as performance improvements are made. Expect hhvm to be about equal to php 7 performance.
The way to fix your problem is below: In the form action, you don't need to specify register.php since you're posting to itself. Change the form action to an empty set of single quotes, or do this: &lt;form action = '".$_SERVER['PHP_SELF']."' method = "POST"&gt; Once that is change, your form will post as you wish. If you're every curious to see what your post variable contains, do a print_r($_POST); Adding &lt;pre&gt;&lt;/pre&gt; tags between the print_r will format it nicer for you to see. The other advice give previous to my post are certainly good things to do, but as a beginner, I think you've done good. Another obvious error I saw was that you have $getuser = $_PST['user'], and it should be $_POST['user']. For example, Rather than showing errors one at a time, I typically throw each error into an array and display on the page. I.e., if(empty($_POST['username'])) { $Errors[] = 'You must enter your username.'; } else { $username = $_POST['username']; } Obviously the above is open to many hacking attempts, but sanitizing your inputs will come later in your learning. Then I loop through the errors above the form. if(isset($Errors)) { foreach($Errors AS $Error) { echo $Error . '&lt;br /&gt;'; } } Let me know if you ever have any questions in the future. I'm always open to providing an extra set of eyes, feedback on code, or help that you may need. Best, Dan
I'm not sure I understand what you're saying. Our api is pretty simple: $value = Cache::read('key'); Cache::write('key', $value); Seems pretty straightforward. As far as the proposal, it's just that, a proposal. Doesn't make sense to implement something that isn't finalized - though we will do so once it comes out. Maybe I'm misunderstanding where we are "going against convention over configuration"?
For point six, I'd love to hear your thoughts on the way that Laravel does it (I quite like it, as of L4, i haven't had time to use L5 or read up on its changes unfortunately)
I don't like the action suffix, but the base controller has a lot of methods, so it's a nice way to avoid collisions. If you don't like it though, just don't use it. You can define your controllers as services, or just implement __invoke()
I've very publicly defended Taylor in the past, and I've been an advocate for Laravel in the past. I'm willing to chalk this up to Graham just losing their cool. They didn't necessarily ask to be community leaders and I can't even pretend to imagine what it's like to have every.single.line. of code written scrutinized by the community at large. All that said, dudes lost a whole bunch of cool points in my book--especially when you consider Laravel/Forge/Envoyer is Taylor's full-time occupation. Common sense: just shouldn't talk to your customers (the Laravel community) that way. I get they didn't ask to be community leaders (see paragraph #1) but they are. In Graham's own words, "Not out fault, sorry."
annotations should be a good enough example on why the api sucks
I dunno; my preference is to just avoid terminating and use Layer 4 load balancing instead. You lose the ability to use sticky sessions (though needing them is a bad sign; doubly so in an actual failover event), but it's faster and easier to configure. I could argue it's a bit more secure as well since the SSL keys won't be present on a server directly connected to the Internet, but that won't stop a heartbleed-style attack. You can still do your health checks over SSL internally which is nice. I like your point about using the latest and greatest internally. Though you're only as secure as your weakest point so that's more of a feel-good (if your internal network is owned, too late)
I can chime in here too. Definitely recommend akami. Best CDN out there. Did a lot of testing and several days in row on different times and akami was the only! One with good constant speed. Sometimes other providers added after a day or two around 100 or two hundred ms to the request for no apparent reason. Hm when I write about it I wonder if it is because they use the same stack? Or even secretly the same backend? 
Uhm, no, it really isn't. "If it has annotations, an API sucks" is *not* an example... It isn't even a real argument, it's just some personal article of faith that you're asking me to blindly accept. Is your beef with `@Route`? Because design-time annotations are functionally the same as having controller/action name conventions, with the added benefit of being far more explicit about programmer intent. 
It would seem you are suggesting to extend the framework based on this single incident, which makes it a dick thing to say. You don't have to update to every single commit. If people reviewed the commit logs, they would have known this vendor change might cause issues. Taylor works extremely hard to develop Laravel and doesn't deserve this kind of treatment in this thread. 
I agree. However, while Symfony may be a bloated mess, it's a very stable bloated mess, so I usually let it pass. Doctrine I have no love for, though.
Without knowing anything about the Symfony router, that seems like an awful long constructor with too many optional arguments. As the end user of a router class, I'd probably prefer something like $router-&gt;addRoute('/contact', [\AppBundle\Main::class, 'contact']) -&gt;linkedAs('contact') -&gt;withMethod('POST'); in a builder fashion and let `addRoute()` deal with the inner complexity of the `Route` class. 
Not the first heavy handed Laravel "Minor" update that broke things, and won't be the last. This is why it's best to stick with Symfony for stuff you care about, they understand backwards compatibility and have a LTS policy on every release. None of this half-arsed attitude to deploys. The worst thing out of all of this was the attitude. They may have posted saying "Because fuck you, that's why we changed it". That's the feeling that I got from their posts on the github issue.
All those empty defaults make me now understand why someone wanted that crazy default keyword to skip parameters and automatically give defaults.
Pretty sure that the PHP's opcode cache preserves docblocks.
Don't forget to take the server configuration out of the source control as you have different server configs for Apache and NGINX.
Open to SQL injection attacks. Use bind parameters to help secure your query input. http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers#Running_Statements_With_Parameters You're going to have to use PDO or the mysqli libraries. mysql_query won't do it.
It *sounds* fun, but I recently came off a project which had some 50k lines of javascript under management that was written in just this way. Eating burning hot coals would have been more fun...
Seems to be kept up-to-date: https://github.com/preillyme/v8js/ I would like to know if anyone is actually using it in a production environment. 
1. They're optional. 2. They're only optional if you want to do things the hard way. OMG MY DOCBLOCK HAS CONFIG AS WELL AS DOCUMENTATION IN IT, CALL THE POLICE! if you've actually used them you will realise they work. well.
you guys just have no idea what you're doing. Symfony is built on discrete components and is flexible enough that you can change practically everything about it to suit your needs. Please give an example of the "bloat". Also, what exactly do you think is wrong with doctrine?
&gt; (fluent interfaces fall out of favour, OOP gains or loses popularity, whatever) You could translate that to: McDonalds falls out of favour, breathing gains or loses popularity, whatever
For activate.php, I think: $getuser = $_GET['user']; $getcode = $_CODE['code']; Should be: $getcode = $_GET['code']; As there is no such thing as a CODE [superglobal](http://php.net/manual/en/language.variables.superglobals.php) in PHP. 
Just wanted to point out that the problem has been fixed by @JawsDB_admin :)
With the default settings it does, yes.
While I don't particulary like them, they're not *just* comments, but used for meta-programming.
Sure, why not. That's what git does with its porcelain and plumbing commands, right? - http://git-scm.com/book/en/v2/Git-Internals-Plumbing-and-Porcelain
We load balance multiple magento servers (about 6) and we used to use sticky sessions but we've changed our setup to the following and it works pretty nicely: - Load balance using least connection - Session sharing using [Cm_RedisSession](https://github.com/colinmollenhour/Cm_RedisSession) - Full page caching backed by redis [Cm_Cache_Backend_Redis] (https://github.com/colinmollenhour/Cm_Cache_Backend_Redis) (we actually use Magento Enterprise so this is built in but it's just Cm_Cache_Backend_Redis rebranded) - Search powered by Solr (Integrated into Magento Enterprise but I'd rather use Elastic Search) The redis server is actually a master-slave setup behind HAProxy for fail over tolerance. We get pretty nice performance from this setup. 
Very sorry to read this just now. Thank you for putting this up. Didn't know him personally, but knew he was a stand up community member. 
Redis will east up RAM, since it's an in-memory data store, so putting it on your database server is "dangerous" in that it might compete with an otherwise high-usage database (Assuming Magento is still a very database hungry app :D ) I'd recommend a separate server, but it depends on how much your Magento site is used! (Whether you use a cluster with Redis is up to you as well, and depends on how business critical the Magento install is to you/your client).
I meant are the pre-defined keymaps from other editors bundled. I like when everything is working out of the box and I don't need to spend 2 hours in the preferences / configuration.
&gt; Vagrant + Samba instead of shared folders. This is a most performant setup that i had on Windows host One of the big reasons I switched to OSX -- NFS beats samba by a really wide margin.
Very sorry to hear this. I'm going to piggy-back on this with a continuing concern of mine: you (the reader) need to get some life insurance. I've seen too many developers pass away unexpectedly (2 friends personally), leaving behind families with no reasonable income. 20-year level term life insurance at 8-10x your yearly salary is not expensive, and will make the lives of those left behind *so* much easier. Your spouse (the other parent, etc). should be insured too, because taking care of the kids yourself *and* working is going to be very difficult; that insurance money can hire help for you.
PHP's class model has been ... let's say adapted ... from Java, so they just took whatever is in there without really thinking if it fits well in a more dynamic language. So some things are a bit weird.
Thanks! We are testing varnish w/turpentine for the FPC. We have multi-store going for Canada and the USA so we ran into problems with the standard FPC, but varnish doesn't seem to display the same issues. If we are using redis for sessions and it sits on its own server I might as well test it for full page caching too! If I might ask, what kind of performance were you getting? We have server response time down to an average of 1 to 1.5 seconds without full page cache and using sticky sessions. I want to get us to 500ms server response time on at least the home page.
Why shouldn't interfaces be used in more dynamic languages (in the way they are used in java)?
You can force the web server you are on via the sticky session cookie (SERVERID of s1, s2, or s3 in the write up but it could be anything in real life). So pre-CDN I had them input all media into server1 and then had a cron job running that pushed the media folder to servers 2 and 3 every 5 to 10 minutes using rsync since it will only push new files or folders. Post CDN I still do that but at the end of it all I have server3 push to Akamai after it is done receiving from server1.
rofl! sorry to hear that! I never get involved with JavaScript applications for that particular reason. Management is a nightmare and the frameworks don't make things easier IMO. Instead of solving the JS problem we took it all the way to the backend with node.js now. I just... don't like that! I can not for the life of me find a better way of doing things with JS. Projects always become a nightmare to manage!
Stop talking out of your ass. 
We've got it down to about 450ms with the aforementioned setup on the home page, category pages are about 700ms. Admittedly, you can get much better performance with Varnish and Turpentine (initial testing brought us down to 50ms response times) but if you have to make use of ESI more than 2-3 times on the page you start taking a big performance hit (went to 300-400ms). Given that we were able to achieve similar performance with a properly configured FPC and nginx, we went with that because it was easier to manage. 
Good info - thanks! And yeah, we're pushing a steady average of over a million requests per hour with spikes during social media events since the client has several hundred thousand "real" followers on FB and Twitter and a email list just as large so every MS counts!
Interfaces are useful for library and framework developers. Let's say you want to build a widget that does something but requires a database connection. You might define an interface like so: &lt;?php namespace Username\Product; interface DBAdapter { public function getPdo(); } You can then implement this interface for MySQL like so: &lt;?php namespace Username\Product; class MysqlAdapter implements DBAdapter { public function getPdo() { // ... etc ... } } And then you can do the same for MSSQL, PostgreSQL, SQLite, Oracle, etc. When you're writing your widget that requires a database connection, instead of specifying which connection type you need, you can just specify that it must be something that implements `\Username\Product\DBAdapater`. &lt;?php namespace Username\Product; class Widget { public function __construct(DBAdapter $db) { // ... } } This allows people who wish to use your library/framework but chose a different RDBMS to just pass the relevant adapter to your Widget class. The interface itself doesn't contain an iota of implementation details, it just specifies the methods that must be defined. As such, `DBAdapater` establishes a contract between `Widget` and `MysqlAdapter`. Widget will only require certain methods to operate, and MysqlAdapter will implement them. How is an interface better than a base class? **Because you can implement as many as you want.** This is what's meant by "Design for an interface, not an implementation."
Precisely that. :-)
According to the internals list there is no JIT in PHP7.
&gt; It highlights that the method is an HTTP endpoint and avoids naming conflicts. If you have other (non-http-endpoint) public methods on your controller, it is doing too much. The problem is doing too much in the controller, not "highlighting that the method is an HTTP endpoint" (which all controller public methods should be). &gt; They're natively part of other languages, they're a bit of a hack in PHP, but they work. They are not application logic, they are configuration. Annotations are **NOT** configuration. They are hard-coded meta-data. You can use that for configuration, but you're abusing them. It's **literally** identical to you hard-coding that configuration in your application (because that's precisely what annotations do). Instead, annotations are designed as a way to express meta-data. You can use that meta-data to make decisions in other areas of the application, but it's most definitely not configuration. &gt; You want to see all the routes? php app/console router:debug. It's much, much, much easier to work when you can see everything about the route right where you're already looking at code. Yup. Because we should have to use external tools to determine one of the most fundamental things about our app. Instead of placing it in a common area where it's trivial to see how routes relate to one-another (and hence judge consistency and better understand how they relate), let's scatter it around. &gt; Ah, there you go. Yes, it's like ini but better. It's not a Symfony thing, nor even a PHP thing, it's used all over the place. If your markup requires non-trivial structure (which Symfony's does), then use a structured tool. And no, YAML is not a structured tool. It's a free-form language. When I say structured tool, I mean a tool that validates and helps you structure your code, not one that requires you to maintain the structure yourself. You can create a DSL for this. Or you could just use objects. Which are built into the language, and everyone knows how to use. Oh, and they validate themselves. Awesome. &gt; Again, just use the annotations. They are much, much, much easier @Method({"POST", "DELETE"}). Again, abusing annotations. They are metadata, not data, not configuration. Here, you're telling the application how it should behave based on the annotation. That's **REALLY** bad. &gt; Only if you insist on doing things the hard way. That's the entire bloody point. The easy way is tight-coupling, abusing programming concepts, weird decentralized configuration and overall blah. The hard way is, well, hard. And that's why the OP's original point of "Symfony has a terrible API" makes sense on at least some level. Now, at the component level, almost none of these issues apply, which is why I say "at least on some level".
Failed to mention we're running HHVM as well with PHP-FPM as a failover incase HHVM crashes (which it has) with nagios event scripts restarting it when it fails. Didn't really find a good tutorial, we just tweaked and experimented.
I must be dumb, I still miss the point. What would be different if the interface was not defined ? You said : &gt; You may create an interface, Cache, which defines what caches do. But in interface, you just write the name of the mandatory function of the class, not the core of the function right ? So how would I have not to rewrite all the place that are using the interface if the core of the function is written in classes ?
So the core of the function accelerate() is written in both classes ToyotaCamry and LambourghiniAventador, and not in the interface, right ? So what's the use of the interface if it just defines the functions needed by the classes ? It just does that ? 
Ah, thanks for the great responses! I'll figure out the issues, I'm sure. Now that I have the new environment that no one can see but me I will be able to work out the kinks.
To be more accurate: return types will be included in PHP 7.0 which is not yet released.
keep trying. there's loads of life insurance companies out there. if you can get cheap term, get it. 
I've installed one of yesterday snaps on my computer, and made some tests on the homepage of our biggest website. This is a real world benchmark, with a real heavy website we have made, 95% of its code is written by us. These times are purely PHP processing, no DB execution time and no server caching: - PHP 5.5.3 (EasyPHP) : 0.54s, 13.4 Mb (memory usage) - PHP 7.0-r4be8d79 (custom) : 0.25s, 12.3 Mb (memory usage) Very Impressive.
Interfaces define _what_ can be done, classes that implement those interfaces define _how_ it is done. When you write the code that needs to cache you always pass the interface. Elsewhere, in the code that creates the cache object, you decide what type of cache your app is using. As long as all caches use the same interface the _what a cache does_ part stays the same and the _how a cache does it_ part can vary.
In a not strong typed language it is usefull as a contract between developers. But in other languages the compiler will need to know what methods are available. So you can do something like this in C#: List&lt;ICar&gt; listOfCars = new List&lt;ICar&gt;(); Lambo lambo = new Lambo(); Toyota toyota = new Toyota(); listOfCars.add(lambo); listOfCars.add(toyota); listOfCars[0].accelerate(100); listOfCars[1].accelerate(100); You could not do something like that without an interface because a list can only hold one specific type (class). When we promice that all objects in the list are cars that at least have some shared methods, we are able to add them to the list.
&gt;So the core of the function accelerate() is written in both classes ToyotaCamry and LambourghiniAventador, and not in the interface, right ? That is correct. &gt;So what's the use of the interface if it just defines the functions needed by the classes ? It just does that ? well defining the function of the class can be pretty useful, particularly if you are using other peoples code. A great example of this is the [Psr\Log\LoggerInterface](https://github.com/php-fig/log/blob/master/Psr/Log/LoggerInterface.php) now this interface is maintained by the PHP FIG, an independent third party if you will. It allows you to write code that uses a Logger class in a way that it doesn't matter what Log provider you use, you might use [monolog](https://github.com/Seldaek/monolog/blob/master/src/Monolog/Logger.php) or [Klogger](https://github.com/katzgrau/KLogger/blob/master/src/Logger.php) or one of the 100's of other implementations that exist. It also means that if you were to write a logger that implemented the interface, it could be used by any of the thousands of applications that need to log stuff. To give you an example of how widespread the use of this interface is, github shows [348,321 code results](https://github.com/search?l=php&amp;q=psr\log\loggerinterface&amp;ref=searchresults&amp;type=Code&amp;utf8=%E2%9C%93) when you search for it.. and all it does is tell us how to write a message.
Seems like a Event Dispatcher, but without an Event class, which I find neat.
Whoops. Fixed.
The difference is that in class Two you do not need to have a public function count if it doesn't implement the interface. In your first code block, if you do not have the public function count() then you will get errors as you are not following the interfaces' requirements. This ensures that you can have class One, Two, ... Fifty and that when you get an instance of that class passed to you there will be a count() function to utilize. If you are not implementing an interface, there is no guarantee that specific functionality will be followed.
Sure, it was entirely an assumption, I'm all for more rigor between developpers, so if Interfaces can help at that, it's all good. Thanks, now I see why it can be useful.
This is **NOT** an Observer. It's a [Mediator](http://sourcemaking.com/design_patterns/mediator). More info: http://blog.ircmaxell.com/2012/03/handling-plugins-in-php.html
Looking better isn't the point. The point is that it has too many optional arguments before you get to what is arguably the most important argument: the HTTP request method. `$route-&gt;get($uri, $handler/options);` is so much more expressive, readable, and logical.
That's good advice. I have three kids and no life insurance. That's getting fixed now. 
The best bit was &gt; Really sorry about my earlier comments here. This has been resolved now. 
Cool! I guess I'll need to check it out myself Edit: I'm abit sad to notice that the composer installation doesn't support Symfony 2.6.*. Also note that fabpot has moved [PHP-CS-Fixer](https://github.com/FriendsOfPHP/PHP-CS-Fixer) to the [FriendsOfPHP](https://github.com/FriendsOfPHP) orginization 
docblocks afecting functionality is very bad
Was he sick or just die randomly?
I have looked into commit hooks, that's very interesting, thank you!
Thanks for the tips!
Hey Taylor. Thanks for all your work. I wanted to tell you, that in my opinion, you handled this sitation greatly. I hope all the hate doesn't drag you down. Try not to read too many comments. They are from people who forgot that they're communicating with actual human beings. I met one of these haters IRL at a conference last year. Face-to-face he was *of course* totally nice and respectful. We discussed our issues, found common ground and moved on. Some people still need to learn being respectful *online*.
It's specially easy to miss the point with PHP, because you don't need to *know* a method exists before calling it and you don't have to specify a variable type. Suppose, in the above example, the following code: class Cache { // This class has no method } class MyCacheClass extends Cache { public function get($key) { ... } public function set($key, $value) { ... } } class MyOtherCacheClass extends Cache { public function get($key) { ... } public function set($key, $value) { ... } } class MyThirdCacheClass extends Cache { // This class has no method } Now, lets suppose we have this class that uses some cache type. You know FOR A FACT that this class will only be able to use either `MyCacheClass` or `MyOtherCacheClass`, never using `MyThirdClass`. Now, you can define in your constructor something like this: function __construct(Cache $cache) { $this-&gt;cache = $cache; } Both `MyCacheClass` and `MyOtherCacheClass` can be passed as an argument to that constructor, because they both extend from `Cache`. MyThirdCacheClass can also be passed, but you just know it won't. Now, if you call `$this-&gt;cache-&gt;get($key)` somewhere, it will work fine, because both these classes have the `get($key)` method defined. But this is not intuitive, nor would it work in other strictly typed languages, like Java or C#. In these languages, it would throw a compiler-error, saying there is no such method `get($key)` in the `Cache` class. And it would be correct. After all, you, the programmer, know there will never be a `MyThirdCacheClass` passed as an argument to this constructor, but the compiler doesn't. Neither does whoever is reading your code. It would be much more elegant if you could define a contract, like this: interface ICache { function get($key); function set($key, $value); } And now, you can inform your `MyCacheClass` and MyOtherCacheClass` classes abide by this contract, like this: class MyCacheClass extends Cache implements ICache { public function get($key) { ... } public function set($key, $value) { ... } } class MyOtherCacheClass extends Cache implements ICache { public function get($key) { ... } public function set($key, $value) { ... } } And, in your previous constructor, you can change the parameter type from `Cache` to `ICache`: function __construct(ICache $cache) { $this-&gt;cache = $cache; } Now, if you ever call $this-&gt;cache-&gt;get($key), you don't risk getting a class that doesn't have the `get($key)` method defined. This is the preferred approach, as it makes it obvious that whatever object is passed to the constructor, they HAVE to have the `get($key)` method implemented. If some other programmer forgets he can't pass `MyThirdCacheClass` and tries to, PHP will now throw an error right when he instantiates this class, warning him his parameter HAS to abide by the ICache contract, which means he HAS to implement the `get` and `set` methods. Maybe $this-&gt;cache-&gt;get($key) only gets called in some specific situations (inside an IF, maybe). If that's the case and you don't use a contract, your application will break *sometimes* and will work *some other times*, making this too hard to debug. IF you use a contract, and require the parameter to use this contract, it will always work or will never work, making it much easier. PHP makes it hard to understand, because you could simply not typehint the parameter, like this: function __construct($cache) { $this-&gt;cache = $cache; } And you could easily call `$this-&gt;cache-&gt;get($key)`. If the $cache variable you passed had a `get` method, it would work. But, again, this is a PHP feature - being loosely typed and only checking for methods in runtime. Other languages (and intuitiveness) would make the check in compile-time, and would throw an error (or would confuse the hell out of someone).
I'm keeping my fingers crossed you, Taylor, or someone of your ilk will knock it out since you're far smarter and less lazy than I am (you wrote the book on APIs, afterall). I just wanna use the shit. :) It is sortof amazing this particular problem hasn't been tackled yet. A wheel for easily interacting with these shipping APIs must've been reinvented a few thousand times by now by various ecommerce companies. 
&gt; not "highlighting that the method is an HTTP endpoint" He also said, "avoids naming conflicts", which is the real reason for the "Action" suffix. &gt; Annotations are NOT configuration. They are hard-coded meta-data. http://i.imgur.com/g5iyljL.jpg &gt; Instead of placing it in a common area where it's trivial to see how routes relate to one-another Finding routes is not at all trivial when they're in a single file. I'd argument it's quite the opposite. A configuration file with hundreds of routes is very difficult to read, and finding the route configuration I'm looking for is no easier than typing `grep -l the_route_im_looking_for` inside my controllers directory. Not that I've *ever* had to do that. I know exactly which file to check when I'm looking for a route definition because the file/controller is named after the route. &gt; Here, you're telling the application how it should behave based on the annotation. "Here, you're telling the application how it should behave based on an INI value." Sounds pretty much the same to me. &gt; It's literally identical to you hard-coding that configuration in your application You couldn't be more wrong. An example of a hard coded value is having some magic number mixed into your business logic, eg `if ($value &gt; 42) { ... do something ... }`. Giving that number a label and defining it outside of your business logic is the opposite of hard coding, and configuration values defined in that manner are no more or less hard coded than values defined in an .ini file or another .php file. The only time that's not true is with distributed libraries/code, and I've literally never seen a Symfony bundle where developers were expected to modify the source code in order to change configuration values. Any annotations used by the bundle are meant to be "internal" and not modified by outside developers. &gt; The easy way is tight-coupling, abusing programming concepts, weird decentralized configuration and overall blah Erm, well, at least in your opinion. The Symfony way of doing things promotes very lose coupling. To the point that I can take a controller out of a Symfony app, and drop it into Laravel app without making any changes. There also isn't any abuse of programming concepts. There's only your opinion regarding annotations, which many high level and popular programming languages make use of without any problems. Symfony also promotes a strongly centralized configuration paradigm outside of it's route configuration. My primary project has 3,000 lines of configuration, and it's all in one location. There's nothing "weird" about Symfony's incredibly flexible configuration design.
"Faster" refers to *speed*, not time. "Iterations per second" is a measurement of speed. There are roughly twice as many ops/sec, which is 100% more (specifically 95% in this case). So everything is running 95% faster, which means it takes 51% less time for a given set of operations.
Released v3.0 a few days ago after full refractor.
&gt; At any rate there's nothing in here that suggests it's necessary to have the 'Action' suffix. Except for the naming conflicts we already discussed. And since Symfony tends to follow good programming practices with lose coupling, you can easy replace the routing component that requires "Action" to be part of the method name with your own component that doesn't have such a requirement. Which is kind of the point of Symfony. It doesn't force you to use any one particular philosophy. It only has an out-of-the-box setup that you're free to ignore. &gt; it just needs someone to design a non-shitty API for it The Symfony framework already designed a non-shitty API, you're just not using it. Instead of using the higher level abstractions Symfony has provided, you're mucking around with low level APIs, and guess what? Low level APIs are always hard to use. That's why we build abstractions on top of them. Hell, that's why PHP exists! Because using low level C was a pain in the ass. If you don't like the built in abstractions (configuration files, annotations) then Symfony is flexible enough to let you design your own with very little fuss. If you want a more simple syntax than the one provided by the `RouteCollection` class then you can create your own.
&gt; He also said, "avoids naming conflicts", which is the real reason for the "Action" suffix. What naming conflicts would those be? If not for public methods (which you didn't argue), what other naming conflicts are possible? &gt; http://i.imgur.com/g5iyljL.jpg It's not being pedantic. It's being realistic. There's a *massive* difference between data, metadata and configuration. Drawing those lines is incredibly important. If you don't think it is, fine. But it's most definitely not pedantic. &gt; "Here, you're telling the application how it should behave based on an INI value." Sounds pretty much the same to me. One is hard-coded with the application data, and the other is in a centralized configuration file. Yeah, not the same. &gt;You couldn't be more wrong. And that is why you fail. Let me put it this way: /** @Method({"POST", "DELETE"}) **/ public function updateAction(...) Now, what happens if I realize that I want that action to run on `PATCH`? I need **to edit the source code**. Which means it's literally hard-coding. It's the same as if I said: public function updateAction(...) { if (!in_array($method, ["POST", "DELETE"])) {... That's why it's hard-coding. To change the behavior, you need to edit the definition. Hard coding is fine. But you don't hard-code configuration. You hard-code logic. You have to. But leave configuration where it belongs. &gt; Erm, well, at least in your opinion. Actually, in a lot of people's opinions. Here's [a great talk about the problems with this approach](http://www.infoq.com/presentations/8-lines-code-refactoring)... &gt; There's nothing "weird" about Symfony's incredibly flexible configuration design. Nothing "weird". It's magic. And it's designed to be magic. Which many of us consider to be a very bad thing. You don't? Good.
&gt; This package is developed for educational purposes only. Do not depend on this package &gt; as it may break anytime as it is based on "CURLing" the Google Translate website. :Spock's eyebrow:
&gt; What naming conflicts would those be? public function public() {} &gt; It's not being pedantic. It's being realistic. Your reply is pedantic because we already know annotations are meta data. There was no need to point that out. It's absolutely correct for /u/novelty_string to say Symfony route annotations are *configuration* because that's how they're being used. Your reply comes off like you were thinking, "I could only think of 5 reasons why I think you're wrong, but I really wanted an even 6, so I'll harp on you using the word 'configuration' in relation to annotations." In short, you could have just let it go, and nothing would have changed. &gt; One is hard-coded with the application data, and the other is in a centralized configuration file. Configuration values *are* application data, but you're fussing about which file contains those values. In the real world it doesn't make a lick of difference whether I dig into a .php file or an .ini file to change a configuration value, and the values are no harder to find when they're not centralized. In the real world you're going to check the source code half the time before changing a configuration value anyway. Either because you forgot the name of the configuration value, or forgot what type it's allowed to be, or your forgot how it's being used, or any number of reasons. We're not using development tools from the '80s. It's *really* not so hard to modify configuration values regardless of where they are defined. &gt; It's the same as if I said `if (!in_array($method, ["POST", "DELETE"])) {` There's a big difference between scanning through the body of a function to find the value you want to change, and changing an annotation which sits right at the top of the source code that's been highlighted by the IDE. It's literally no harder than changing a centralized configuration value. &gt; I need to edit the source code. "I need to edit the ini file." Sounds the same to me. &gt; Actually, in a lot of people's opinions. I didn't say it was an unpopular opinion. I'm simply pointing out that you're getting religious about it instead of being pragmatic. Generally my problem with your argument is it very theoretical, but it's not real-world practical. Yes, I'm sure there are many *books* that say not to use annotations or not to mix configuration values in source code, but in the real world most of that advice can be safely ignored, and much of it *should* be ignored. It makes sense on paper to say "keep your configuration centralized" but in reality your routes are almost never going to change, and may never, ever change. And when and if you do need to change them you will probably be making some changes to the controller code as well. Trying to keep your routes in a centralized configuration file is only making your life harder as a developer for the sake of doing things the "proper" way. A good developer knows when and how to break the rules.
Sounds like a job for [socket.io php-emitter](https://github.com/rase-/socket.io-php-emitter)
Interfaces (or at least abstract classes) are mandatory for dependency inversion. See this fairly good article [SOLID: Dependency Inversion](http://codingjourneyman.com/2015/03/02/solid-dependency-inversion-principle/).
&gt; Just because you don't understand doesn't make it not practical. And just because I don't agree with you doesn't mean I'm some noob that doesn't understand. I've got 10's of millions of lines of code to my credit as well as a top 300 website getting 25 million page views a day. This isn't the first time I've disagreed with you, and it's not the first time I've seen you pull the "you just don't understand" card. It's weak, and it's the reason I stopped paying attention to you a long time ago. You're going to fit right in with the PHP internals crew. They also like to belittle people instead of listening. &gt; You need to experience that pain I've experienced the pain of doing things the way you're describing, and I couldn't be happier switching to annotations.
&gt; This isn't the first time I've disagreed with you, and it's not the first time I've seen you pull the "you just don't understand" card. Disagreeing is fine. But that's not what you said. You said (I'll quote again): &gt; Generally my problem with your argument is it very theoretical, but it's not real-world practical. Unless we have different definitions of "real-world practical", that's basically saying "it doesn't work at scale". And it most definitely does work at scale. So either we have different definitions of "real-world practical", or there's a failure between us to communicate what we're talking about. Hence why I said "just because you don't understand doesn't make it not practical". Just because you haven't seen it work doesn't mean it doesn't work. &gt; I've experienced the pain of doing things the way you're describing, and I couldn't be happier switching to annotations. Precisely missing the point that I made. You need to experience the pain so you can clean up the rest of your architecture. Bypassing the pain with tools like annotations works for a little while. It makes everything feel great. Until you need to refactor. Or until you need to onboard the next junior dev. Or until you realize you made a flaw in your architecture (face it, everyone does). Then that pain will hit you 100 times harder. I'd rather feel a little bit of pain in the beginning to prevent me from a lot of pain in the long run. You disagree? Fine. All's well and good. Just don't pretend or portray that the concept I'm talking about as "not practical". You're exhibiting the exact behavior you're condemning me for. *side-note*: you've really written 10's of millions of lines of code? 
I've benchmarked other pages, it's more impressive. Something like 0.7s (5.5) against 0.27s (7.0).
i'm referring to the ones that from extending the controller, especially something really common like getUser() . I do hope the action suffix can be rethought in symfony 3 though.
&gt; You do get notices in 3 other cases Alright. You can't try to slip that in like it doesn't matter. Those notices are failures. Unit tests will fail as a result, and any half decent framework will convert the notices into exceptions and fail. Where the conversions don't fail is the same place non-strict type hints won't fail, which is the whole point. Non-strict type hinting serves almost no purpose. Adding a non-strict type hint is like not adding a type hint at all. Ultimately I believe those developers pushing for non-strict type hinting are those who don't want type hinting in the first place. But for the sake of "compromising" they've voted for a crippled feature so that everyone can feel like they got what they wanted.
Why?
first of all, comments shouldn't affect functionality by definition. second, it will make writting documentation to have an impact on the execution. third comments shouldn't affect functionality by definition. forth an error on configuration is a hell to debug like that. fifth comments shouldn't affect functionality by definition. 
**Day 1** * Make sure form validates line1 and line 2 correct and handles errors appropriately. * Check Form redirection **Day 2** * Figure out how to use websockets. * Write script so you can kick off a process that will use web sockets to update your "rendering.. please wait" page you made yesterday. This is replicating your `php sends up link to results.php` **Day 3** * Write python script that can accept data from some other source * Write python script that can render text on to pre-existing meme * Write Python script that can upload to imgur 
&gt; Thousands of developers are using annotations in Symfony apps without having any of the problems you're describing Many of them are having the problems I'm describing. They are just chalking it up to "that's what programming means".
Maybe. My claim is impossible to dispute or prove. All I know is that I've used every big PHP framework out there, and Symfony is the one I like the most. Which is saying a lot, because it's also one of the slowest frameworks, but I tend to blame PHP itself for that.
Ah I forgot to mention that I **'d out the email address just for this post, it's set in the actual script. If there are no errors as such, any other reason why I should get a 500 error from it? Thanks for the help.
&gt; All I know is that I've used every big PHP framework out there, and Symfony is the one I like the most. Of every big framework in PHP, I think Symfony is the best, by a long shot. However, I'm not talking about writing code using frameworks. I'm talking about using components. Using packages. Using platforms... What many would call using "a microframework" (well, some of them. Silex at least behaves this way).
It is to make sure you implement all the methods required to do the work in your system. That way if you swap classes you can be sure it will still works. This is a very loose definition because the interface not set the type return, and when you implement a class in PHP you cannot check if it implements an interface unless you check it through reflection. If you check it through reflection you are burning cycles. 
That's still unnecessarily ugly. More proper templating solutions aside, how about a [heredoc](http://php.net/manual/en/language.types.string.php#language.types.string.syntax.heredoc). $body = &lt;&lt;&lt;BODY From: $name_field E-Mail: $email_field Telephone Number: $telephone_number How many nights: $how_many_nights Date of arrival: $date_of_arrival Date of departure: $date_of_departure Number of guests: $number_of_guests Which room: $which_room Specific requirements: $specific_requirememts Additional Information: $additional_info Stayed before: $stayed_before BODY;
Why is it better than other existing event dispatchers?
No, but happens the same: &lt;?php namespace test; class FilterInputTest extends \PHPUnit_Framework_TestCase{ public function testFilterInput(){ $this-&gt;assertArrayNotHasKey('HTTP_HOST',$_SERVER); $_SERVER['HTTP_HOST'] = 'www.example.com'; $this-&gt;assertArrayHasKey('HTTP_HOST',$_SERVER); $this-&gt;assertEquals('www.example.com',$_SERVER['HTTP_HOST']); $this-&gt;assertEquals('www.example.com',filter_input(INPUT_SERVER,$_SERVER['HTTP_HOST'])); } } PHPUnit response: Failed asserting that null matches expected 'www.example.com'. Expected :www.example.com Actual :null
Ah yeah, of course. Thank you!
You bet. I also recommend EditRocket for its ability to validate PHP. That's what I ran the PHP through to find that there weren't any parsing errors. Then I actually read the code and saw the high potential for variable misnaming. If changing the variable doesn't work, I'm going to agree with the other responder that you need to look at your outgoing email on the server. It may be set to disallow PHP's mail function. If so, you'll have to use a fancier email function or class. Good luck!
&gt; However, things such as managing scope and having to solve the callback chaining problem is just too much headache! ES6 "fixes" a lot of that. For example the "let" language construct which will give you a locally scoped variable (instead of "var" which can be promiscuous). Class is also introduced, which is really just some sugar... a first class ".extend" construct I guess. The point is you can write code like this today, there are transpilers which will rewrite the code to something that will run in browsers. &gt; I think the reason for my distaste in JS comes from its inevitable coupling with the view (in the traditional MVC sense). I don't quote know how this is true... Ember for example will have something like: **users.hbs** &lt;ul&gt; {{#each users}} &lt;li&gt;{{name}}&lt;/li&gt; {{/each}} &lt;/ul&gt; **UsersRoute.js** export default Ember.Route.extend({ model: function () { return this.store.find('user'); } }); With a bit of config (and a model definition for user), this when you visit http://your.site/users, it will perform a GET request against your API, pull back the json payload for users, and provide the data to the template.. seems relatively decoupled to me? At least as decoupled as some "traditional" web-mvc app? &gt; It is for the most part used to manipulate HTML and css at the end of the day. That's what JQuery is for... but modern js frameworks provide you with the infrastructure necessary to build *maintainable* single page apps, with loads of things beyond just manipulating HTML and css... * 2 day data binding * routing (which in the JS world means maintaining the expected behaviour of bookmarking, back and forward buttons etc) * management of communication with the server * templating In fact, at least when it comes to ember, you don't generally directly manipulate HTML at all. You manipulate state and ember maps that state onto templates. &gt; If you had to choose between using JS or PHP/Java/etc on the front-end which one would you choose? For web development? Javascript. &gt; However, I personally don't find it appealing enough to work with I don't find vanilla JS appealing to work with either...but applying the same arguments for why shitty JQuery soup pages riddled with callbacks to modern JS frameworks is a bit of a stretch....
Yeah, it's just a workaround/hack to avoid Google's official API (Google Translate API is paid). So maybe Google will block your server's IP for much activity O.o who knows.
/r/php isn't a technical support subreddit. Go to /r/phphelp
&gt;It means your runtime behavior changes based on something that's not expressed in code, anywhere. How is this different from configuration? Are you saying that you shouldn't use anything other than code to define routes? Does this also apply to other use cases for annotations? &gt;you could simply scan the route table Database table? 
php doesn't have support for annotations, the work around is using docblocks which are comments.
&gt; Of every big framework in PHP, I think Symfony is the best, by a long shot. I'm glad we can agree on that. I was feeling like I had taken crazy pills. I hadn't considered rolling my own framework based on Symfony components. Even though I'm more than happy to use their components in my open source libraries. Though I'm not real sure what could be gained by stitching together your own framework besides a performance increase, and "throw more hardware at it" is kind of my motto these days. I only need to click a few buttons to fire up more EC2 instances when the app starts to slow down. I suppose you might roll your own framework if you dislike the Symfony framework as a whole, or dislike certain features, but most of the default features can be easily changed within the confines of the framework. Still, it might be fun to full around with rolling my own microframework, even though I swore to never create and use a custom framework ever again.
I don't know if you're opposed to annotations, or the fact annotations are defined in comments in PHP. If it's the latter, then you're just being pedantic, if it's the former I'll repeat my question: why?
Ah OK. Thanks.
i would love if php had annotations but it doesn't. and to answer your question read here http://www.reddit.com/r/PHP/comments/3054vt/ircmaxells_thoughts_on_the_design_of_apis/cpqpjx6
Definitely, but rsync has it's own quirky issues, like time before the copy happens and it's only one direction :/ Ultimately, I really want to convert to working through docker instances from a linux host so I can just do volume mounting at native speed. Dreams, man.
Think of it as similar to strict type hints for function parameters (a new feature in PHP 7). Strict type hints don't "give you" anything over weak type hints, except errors. It causes errors when you pass values that don't conform to those hints, and some people find that error-throwing behavior useful for catching mistakes early. Similarly, defining interfaces forces those classes to conform to the defined structure, or else it'll error and you'll catch the mistake. In both cases (strict type hints and interfaces), the stricter discipline isn't necessarily "better". There are frequent heated debates about strict "error early" approaches vs. more dynamic approaches. PHP allows you to program in different styles, and Java-like contracts is one style you can choose.
&gt; Are you saying that you shouldn't use anything other than code to define routes? Correct. &gt; Does this also apply to other use cases for annotations? Most. There are definitely valid use-cases for annotations. I'm not saying they are all bad. I would look at the way PHPUnit uses them as a good example (with the exception of expectedException). &gt; Database table? No, I meant more a file (or collection of files) that defines your routes. So not a literal table, but a file that really just defines the mappings for you.
which is meta wrong and wrong at the same time
Wow, great read. I didn't realize my classes had that big a footprint.
Pubsubhubub
Btw, reading I did not read the comment that started off this thread, and I agree it is shameful. Our policy, and the one I personally try to do in every place Im speak is to never look down on other people or technology. I actually thing Laravel is a great framework, with some deficiencies as any other framework could have, including Cake.
If a class is final it should implement an interface and have no other public method declared except those in the interface. This way you can mock the interface. If you have a final class that doesn't implement an interface just extract it.
Exactly this. Do you make value objects implement an interface too?
Do you need to mock value objects?
Um... None of that needs PHP, its really just JavaScript, but I'd be happy to whip something up for you quickly. What's your local time, and how much time do you have till you need it?
Thank you! Programing is not my strength, so I'm not surprised I said something dumb. It's about 10.30 here. I'm picking up the hardware from my friend at 16.30, so if you could manage it by then so we can test it and make sure it all works, that would be brilliant.
Unfortunately I don't have time to help. But I can say that you probably don't need PHP for this. A simple jQuery carousel with some click handlers and HTML &lt;audio&gt; element should do the trick. Here is a quick carousel example. Like I said, I don't have the time to do the audio stuff but maybe someone else can pick up the torch quicker: http://codepen.io/anon/pen/EarMwW
This might be of some help. Or not, your choice http://www.reddit.com/r/PHP/comments/30ct11/help_art_installation_with_deadline_today/cpr7ntd
I'll send you something by 14:00. Probably earlier, no later than that
**/r/PHP is not a support subreddit**. Visit /r/phphelp for help,
Eh, tossing up between using jQuery and a plugin or plain JS. It's really easy to do in straight JS and CSS3, and probably perform better on weak hardware
You can secure it with mysql\_real\_escape\_string . Don't do it though since mysql_ has been deprecated and is being removed.
mysqli and PDO can still be injected. The reason to not use mysql_ is it is deprecated meaning months down the line you'd have to rewrite your code. A bad programmer is going to mess up all three just as badly.
As flattering as it is, I don't really have any way to receive donations
Ended up going pure JS. With key bindings, music playing, carouselling (next and previous), I clock in at about 100 lines of JS and 30 lines of CSS. I could have made it smaller, but I figured I may as well put this up on Github, so I went and tried to write neat code
Man, I love donating to Doctors Without Borders, they were instrumental in saving the world from a horrible ebola pandemic. So I'm going to make my donation to them. I would also like to point you to www.worldreader.org, my favorite charity on Earth. They have an extremely low operating budget ($1,000,000/year) and all the people who work for it *must* be living on a pittance. They mod eInk previous generation Kindles by giving them rubber shells, reinforced screens, and a solar-panel self-charging case. They then load each with thousands of books for a complete education and then train African students in the poorest places on Earth how to properly care for them. Then they're either sent to the school library or (in more advanced deployments) delievered to every classroom. Each kindle benefts 5-10 students. Every $1,000 donated totally transforms lives. And I think it's one of the best things we can donate to now for a better world tomorrow. 
Here's a picture of a pretty decrepit school in Uganda. Before WorldReader reached them in 2013, their entire town of 400,000 had only 3 textbooks in the entire city. Now, they have 500 kindles, each with about 10,000 books on them. The vast majority of the city/shanty lacks electricity altogether, so while the students are actively learning, they place the kindles outside in the specially-designed Kindle-shelf solar charger, designed, produced and deployed by WorldReader. Now isn't that freaking awesome?! http://cdn.worldreader.org/wp-content/uploads/2014/12/bookmark-hammer.jpg
Here's what the kindle bookshelf charger looks like from behind the solar panels... For the ones outside, they are equipped with a steel mesh and locked. http://cdn.worldreader.org/wp-content/uploads/2014/08/charging5.jpg
Reddit by definition is a forum, why would we want to register over there... You have no decent content, nor any real appeal.
If you don't want to, then don't. Some people will want to. People already have. I'm not forcing anyone to do anything, just wanted to advertise it a little.
I think I spent more time setting up the Github Page than I did making the thing as a whole. Never set up a Github page before. Feels good. http://garethp.github.io/CSS3-Carousel/
Wow, that's an amazing read. This has officially become one of my favorite charities of all time.
I wasn't aware of the new comparison operator which is cool, but ya I was hoping it was going to be something more comprehensive too.
For higher quality comments: https://news.ycombinator.com/item?id=9269465
It doesn't even load with privacybadger/ghostery/adblock enabled 
I was going to say to check out Laravel until I read it at the end. It is what made me excited to develop again.
There is also this [units of measure](https://github.com/triplepoint/php-units-of-measure). 
Really glad to hear it! :) ... I think 5.1 will be great as well and it only takes about 30 seconds to upgrade!
Hmm, do you have your own version? The higher 4.x version is 4.2 . Anywayz, the 5.x version is one of the best things in life.
6\. '0x20' == '0032' evaluates to false now (finally) http://3v4l.org/kQZQW EDIT: I wrote 6. Why it shows 1. ?
Whatever it was, I spent one day with it, then 5 came out. As you know, they moved a number of things around in 5, right after I learned where they were in 4.x (x=whatever version it was right before 5) It was a confusing night, that night.
Haven't gotten into 5 yet. We are about to launch our web app soon and figure we will upgrade post launch. Going to run through some Laracasts and the docs to get ready for it. Besides hotfixes and revisions, it will be the first thing I do. Also Laracon is in my town this year. Would love to go, but can't it isn't in the budget.
The future of .net is looking up now that it's been open sourced. I think if you no nothing about web development and you don't care how you complete a project, .Net webforms can be a fast way to do the quick and dirty. But its like everything Microsoft (at least in my mind), as soon as you want to move past the basics, the tools sort of leave you hangin'.
I would say the people who allowed it to be a thing in the first place, but then there's also the PHP marketing people.
The page itself is titled *"PHP 7 Infographic - 5 things you need to know"*
7 months for 7 can't be too soon.
Nope, you don't need it in that case. If you have nobody depending on you, then life insurance is probably not something you need.
I tend to become nervous when I see a blacklist approach on security.
my name is chabawaki, who are you to say otherwise?
\o/ return type declarations. I think I love PHP just a lil bit more today. 
Just out of curiousity, what is remaining? Are all the new features integrated?
I still fear the "hexadecimal as string becomes exponential number" ~~bug~~ feature. e.g. `"0E55" == "0E91"`
&gt; Note: you don't have to name an interface with the suffix of `Interface`. Personally I believe you should always program against the interface when possible, and that means the interface "deserves" the nicest name, because it's the one you want everyone to be typing and reading. In other words, better to have `interface Foo` / `class FooImpl` instead of `interface FooInterface` / `class Foo`. 
`FooImpl` is not good enough, but +1 with the fact that ugly `FooImpl` is at least better than `FooInterface` nonsense :) This article on the subject is awesome: http://verraes.net/2013/09/sensible-interfaces/
Can you post the code for the getCustomValue('address'); it should look something like public function getCustomValue($value) { foreach($this-&gt;customValues as $customValue) { if($customValue-&gt;getName() === $value){ return $value; } } } 
This is my function: public function getCustomValue($name) { foreach($this-&gt;customValues as $customValue) { if($customValue-&gt;getName() === $name){ return $customValue; } } } The problem is *$this-&gt;customValues* always comes empty.
I've just realized this sub is not for help. Stupid me. Sorry. I'll post this on /r/phphelp. Thank you for your attention anyway!
Cool library! I was looking over it and one of my first thoughts was: "Wouldn't it be neat, it there was a method/hook to override the default nouns &amp; adjectives, for personalized ones?" Might be a dumb idea, but then again, it was just a passing thought. 
&gt; `FooImpl` is not good enough I agree when it comes to most use-cases, where you expect/allow many equally-valid implementations. In that scenario, the developer should be able to think of a more-specific name for the default implementation(s) you ship, because it can be compared or contrasted to the other potential ones. However I think there is also a different case: When you will only ever have one production implementation, but you're working around a deficiency in your testing tools regarding proxies/mocks. (This applies more to some other languages.)
And I'm saying the title is wrong. Not sure what your point is.
So, are we just skipping 6?
It sounds like you might benefit from a library I wrote, where you can process all of your data server side and just drop the charts into your page. Maybe give it a shot and don't hesitate to message me if you run into any issues. [Lavacharts](http://lavacharts.com) 
[**@phpconfnz**](https://twitter.com/phpconfnz): &gt;[2015-03-27 01:32:46 UTC](https://twitter.com/phpconfnz/status/581267587113168896) &gt;We are glad to announce that our Call for papers is OPEN NOW!! [#php](https://twitter.com/search?q=%23php) [#php](https://twitter.com/search?q=%23php)NZ15 [*cfp.phpconference.org.nz*](http://cfp.phpconference.org.nz) ---- [^[Mistake?]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Error%20Report&amp;message=http://reddit.com/30g2c9%0A%0APlease leave above link unaltered.) [^[Suggestion]](http://www.reddit.com/message/compose/?to=TweetPoster&amp;subject=Suggestion) [^[FAQ]](http://np.reddit.com/r/TweetPoster/comments/13relk/) [^[Code]](https://github.com/buttscicles/TweetPoster) [^[Issues]](https://github.com/buttscicles/TweetPoster/issues) 
This is more general "trying new stuff advice"... I've never used a Javascript framework, but might need to soon. I've always been fairly conservative with running the latest operating system etc. I prefer to wait a while and see if any others are encountering too many "dot zero version bugs". I've changed my tune a bit recently though, when it comes to web stuff at least. About two years ago I started building a fairly big website using Bootstrap 2, even though Bootstrap 3 was about to be released. I really regretted it, because there was a lot of useful stuff in version 3, and it was released as stable while I was still working on the project. I ended up having to upgrade the whole site to v3 in the end anyway, so I wasted heaps of time both: **learning** and implementing v2, which is useless to me now. So, especially for "a hobby project", I'd just go with the new version when it comes to web frameworks. Downsides might be: * Does it support old enough browsers for your project? I only worry about IE9+ these days, and charge hourly (on top of main project quote) for prior support * The only downside really is that there's less support out there right now (forums, StackExchange answers etc). I just realized Angular2 is still really in the design stages, so it might to too early right now.
Yes. I use it in all my projects. I love it and never had a problem with it. It provides just enough abstraction for my liking, and never gets in my way. Edit: nothing is appearing because the name of the library is **Red**Bean, not Read. 
Thanks for posting a worthless picture about all the shit **we've been talking about for months already**.
Repost this without all caps and we'll let it through.
Hi, you can use an Embeddable to build this support and use EntityListeners on postLoad and prePersist/preUpdate I happen to create a bundle for Symfony a couple weeks that does exactly what I described here. Tomorrow I will likely open source it at http://github.com/carmigo Cheers,
Really enjoyed the show Cristian &amp; team put on last year. Had a chat with him at PHPOZ15 and seems a new venue will make this year even better.
Just wanted to piggy back. I use as well and love the schema builder. 
Looks like you want to make what's called an Entity-Attribute-Value (EAV for short) system Try setting the customValues to eager loading first off. You'd probably be better off to make a custom repository for users also, that way you can write your own SQL/DQL queries to gain control over what's being loaded. Additionally. If your associations look like this User.customValues -&gt; CustomValue.customField -&gt; CustomField When you loop you don't have a name column on your CustomValue, unless CustomValue::getName() is something like: Function getName() { Return $this-&gt;customField-&gt;getName(); } I built a very powerful EAV system for my company on top of doctrine. I would explain more but I'm on a mobile at the moment. Let me know if I can help more. 
as a vim user. sell phpstorm to me
PHP6 kind of exploded into PHP5.3 and PHP5.4, and since it was A Thing (tm), they decided to skip it and go with PHP7 for a release. Also, that infographic does not include the strict/non-strict scalar type hinting feature, which lets you adjust how type hints handle input. *missed a few words here and there
It was awesome. You missed it. (In all seriousness, PHP6 ran into serious issues with the unicode refactoring, and was abandoned by intent. It was a dead end, as happens now and then in development.)
Why not a plugin or two? It is not like I want to fire up "just another ide" or I'm alone with that?
"Join our facebook page for updates" Is there some reason they can't just post updates on the site instead of having me sign up for a facebook account I don't want?
How do you know that someone doesn't have Facebook? They will tell you
Thanks for the kind words. I had the same idea but have omitted this for now. I will take a look at this again. //EDIT: How about public $nouns and $adjectives? So you can edit them by yourself (or overwrite them from a file?) //EDIT2: Done, v0.1.2 is up. Thanks, Atrox
Looks like it kind of is: &gt; Nuclide is a set of packages implemented on top of Atom, and we are working closely with GitHub to contribute upstream to the core project.
~~I have~~ There are just two **important** programming style rules (the most important first): 1. Use Allman style 2. Suffix interfaces with "Interface" Everything else is nonsense ;)
I just wanted to point out that I noticed in your examples you had an interface, then you had an interface been extended. I honestly didn't even know you could do that, and it seems like potentially a recipe for problems, so I was curious to find out more. Your next topic title was "Extending Interfaces", which... didn't do what I expected it to at all. It talks in no way about extending interfaces.
If it always comes empty then it might be a problem with mapping info.
Oops. That section should be titled "Implementing Interfaces" and has been fixed. What more do you want to know, and what problems do you perceive?
An IDE is an editor and a pile of functionality integrated into it... so if you add enough plugins to an editor, it's an IDE!
Naming things is second only to tabs v spaces in causing developer contention.
I've used it sometimes to put together a prototype really quickly. It does the job, but I wouldn't use it on anything serious
&gt; TLDR: Optimize your class-names for coders, rather than optimizing your file-names for file-managers. Im NOT optimizing it for filemanagers. I *AM* optimizing it for coders, because coders look at files in various contexts. In VIM nerdtree, in CTRL+P, in Finder, in Sublime sidebar, in Windows Explorer, in Github.... in many different contexts outside of just PHPStorm or Eclipse. 
I don't think this is bad. Pushing required versions for new major releases is a good thing, imo. However, many people I work with skipped 5.4 and went from 5.3 directly to 5.5 and intend to stay there until php 7 has proven to be stable (A few month and patch releases after initial "stable" release, no chance for an upgrade to 5.6). Waiting for 7.0 and building a sophisticated library using the new features that enable new architectural decisions ("yield from" and anon. classes) might've been worth. And having a popular library showcase how the new features can be used might even help adoption in the end (Wishful thinkin, I know). However, this largely depends on adoption. I hope companies will be faster to upgrade than php4 -&gt; 5.
When you use composer to install and/or update, it also sends to packagist PHP version that your are using part of his User-Agent header. My proposal is to collect this data and publish the results in packagist stats page. This data might look something like [this](http://seld.be/notes/my-view-of-php-version-adoption). Because composer is used in development, staging and production, I think that the resulting data could be useful to package maintainers in making a better decision when choosing the minimum PHP version required for their package. If you would like to view this feature implemented, subscribe to the issue on github and maybe Jordi will make this come true if the community is interested.
Well, what is with those who have Facebook blocked at work?
PHP 6 only runs on Windows 9
any code that was _client accepted_ ;)
That's a bit concerning if you're a full-time PHP developer and you've forgotten that interfaces exist.
An editor with a sufficient amount of plugins can do that just fine. For most things that you would say an IDE does, there's almost definitely an emacs plugin, and probably plugins for Sublime Text and Atom. Probably the main bit that's largely missing is automated refactoring, which is a relatively modern development in IDEs... but there's even bits and pieces of that floating around.
IMO, this could give some insight, but it should not be taken as accurate. If you have a build system, it can use a different PHP version to install the composer package than the PHP version which is used to actually run the package. I see people using hhvm only for composer install, but not to run their app. Also, continuous integration can generate a lot of install depending on how it's set-up.
I agree, RB is actually a pleasure to work with.
I'm using RB via composer. So that's definitely not true. And not sure what your criticism in #1 is, one merged file is better for performance than hundreds autoloaded.
And I'm saying the only way to communicate is to use a common vernacular. Doing otherwise would be the height of stupidity. If I tell you my name is "Frank" but you insist on calling me "Bill" because you think that's more appropriate then all you're doing is hindering communication regardless of how "right" you think you are. Not sure what your point is.
You can have tests without following TDD.
What's the purpose of this versus using mysqli's native OO interface? You have methods like /** * insert_id * * @return int|string */ public function insert_id() { return mysqli_insert_id($this-&gt;link); } but one can already do `$db-&gt;insert_id`; It also is doing a lot more than wrapping mysqli. There seems to be a registry of connections? And calls to static methods too. In addition, this library uses the @ error suppressing operator, which should really be avoided.
You just proved my point. If I called you "Bill" when that's not your real name or nickname, I'm in the wrong. And the author calling it an infographic when it's not an infographic means they're in the wrong too.
See in this thread, pretty good answer: http://www.reddit.com/r/PHP/comments/30csa2/im_excited_about_programming_again/cpsagdi My story: been using vi(m) since the late '90. I basically did all my programming work for years in it. vim: automatic phpdoc formatting? gotit. php debugging via xdebug? doable! Easily finding files in project &gt; 1000 files? Possible. I love my workflow, I configuring "things to death". Did so many years with my vim config. Tried Eclipse pre-SSD times but computers back then just didn't cut it. But at some point I actually got tired of feeling like working with something stitched together. Software projects grow, teams grow, codebase grows, file/line counts grows, databases too. Variations of technologies increased. Then there came a breaking point for me where I, mentally, couldn't handle to keep all the things what I need seamlessly to work together in vim. Tried PhpStorm, never looked back. The PhpStorm vim mode isn't comparable to vim itself, but basic motion keys are supported, heck even ":sort" works nowadays (although buggy sometimes). Even supports :split and :vsplit, very important for my workflow. But more important: finally I've the feeling really being able to "handle" all of it. PHP debugging with breakpoints and introspection while debugging? Check. Refactoring? Renaming classes, moving classes in the hierarchy, moving methods? Check. Parses my PHP source and knows where the errors are! Check. Can connect to database and autocomplete tables/columns? Check! Integrated git support? Check. Vagrant/ssh support? Check. Since I've started using PhpStorm a year ago I also ventured more into IntelliJ for Java and RubyMine for Ruby. Wasn't disappointed. First time I really also enjoyed debugging my Ruby stuff (which was running in JRuby were I used multithreading which was a b**** to tame). On the downside, you don't easily write custom scripts to configure your stuff. Either the plug-in has it and provides a settings dialog or it won't happen (and I'm definitely not feeling like writing Java plugins for the IDE). I realize and know, because I did, you **can do all of it** with vim; but a) not out of the box b) setting up ALL of it takes your time and, for c), I'm pretty sure it will never work as seamlessly as it does in a IDE. And btw, I'm still having open my g/vim a few times a day to do other text related stuff. On my current team no ones used vim but sublime. Six months after I joined everyone is using it now. What did I do to sell it? Nothing, because I believe everyone should define their own workflow. But they just realized the potential of using a proper IDE instead of a text editor. Their development workflow with PHP matched their use of a text editor. The project already is quite big and they were still dabbling with pr() or var_dump(). It has it's uses, but if you just realize how much time you loose in complex systems with this methods when you know setting a conditional breakpoint gets you there in a second. And it never occurred to them how to improve it because they clearly acted bound to the limits of their text editor. PhpStorm even has multi-cursor support like sublime and even I started using it; sometimes it just has its uses. Sorry for the wall of text. I'm not actually selling it and not affiliated with Jetbrains. But discovering PhpStorm a few years ago put back the joy for me working with PHP and I think my text reflects that. For me it's all about using the right tool for the right job.
How not? What is an IDE if not the things it does, integrated into a single UI?
Damn you redhat!
I'm not sure what you're saying is "definitely not true". Those are direct quotes from their own documentation. You CAN use it with composer, but they discourage it. "No composer, no auto-loaders, no configuration, just download and run!" I didn't mean to say you couldn't use composer, I meant to say that if you think downloading a tarball and unzipping it, then including it in your php code is "thought out" by comparison to using dependency management to manage dependencies... RedBean reeks of the "bad old days" of PHP. If you had to download it from PHP Classes I'd not be surprised. I don't want to manage all my dependencies through composer except for one. I would rather just use something else. 
A big part of it is us expecting it. Those of us developing on the cutting edge need to insist on hosting environments that support it properly. We can't rely on the bulk low end of the market to push it. They're too busy sitting there making wordpress sites while eating paste.
My condolences.
Writing tests for your code is a reasonable proposition, in general. TDD makes sense for most use cases. Some people are overzealous about it, the same way I'm overzealous about telling open source projects about security flaws in their code every chance I get.
Hopefully I can convince our server guys to trust him, thanks for the tip!
From my book, [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp): &gt; For our purposes, a legacy application in PHP is one that matches two or more of the following descriptions: &gt; &gt; - It uses page scripts placed directly in the document root of the web server. &gt; &gt; - It has special index files in some directories to prevent access to those directories. &gt; &gt; - It has special logic at the top of some files to `die()` or `exit()` if a certain value is not set. &gt; &gt; - Its architecture is include-oriented instead of class-oriented or object-oriented. &gt; &gt; - It has relatively few classes. &gt; &gt; - Any class structure that exists is disorganized, disjointed, and otherwise inconsistent. &gt; &gt; - It relies more heavily on functions than on class methods. &gt; &gt; - Its page scripts, classes, and functions combine the concerns of [model, view, and controller](https://en.&gt; wikipedia.org/wiki/Model–view–controller) into the same scope. &gt; &gt; - It shows evidence of one or more incomplete attempts at a rewrite, sometimes as a failed framework integration. &gt; &gt; - It has no automated test suite for the developers to run. &gt; &gt; These characteristics are probably familiar to anyone who has had to deal with a very old PHP application. 
I work with a codebase that decided to roll its own functions on top of vanilla sqlite (non OO) functions. Now I have to convert hundreds of thousands of lines to a DAL just so we might be able to have a reasonable shot at converting to PDO and then another RDBMS by extension. Lesson: just use PDO the first time :(
Personally I use phing which has tasks for SVN and git and is built on php so you can easily add custom tasks. We are currently looking into the switch over as well and in my build file it looks like I can swap out the SVN export task with a git clone to a temp directory and the git checkout-index from that temp directory repo to my main apache web root, the rest of the tasks can run in place.
&gt;I never said it's a good idea to force people to like a page in order to get updates What the fuck does that have to do with what he said? Are you an idiot?
If you need something a bit more bleeding edge than Remi, then I have had a lot of success running https://webtatic.com/ for several years in my organization on multiple servers.
Sorry I am bit confused, but why does $foo = []; mean you are stuck on 5.3? I thought as of 5.4.X you could use short array syntax for array creation. I'm pretty sure I'm doing so in 5.6 right now all over the place, with strict error reporting enabled. See: http://php.net/manual/en/function.array.php#115181 
Honestly I've never been able to use PDO due to numerous bugs with the mysql implementation that have never been fixed (probably on purpose, Oracle wants you to use the mysqli extension).
ah, I get it now! Thank you.
&gt; But we have literally no details Actually, that's not true. We do know [what it looks like and how it works](https://code.facebook.com/videos/1483231821892511/introduction-to-fbide-hack-dev-day/) :)
I just want to say I'm a big fan of your ditching the framework and going for a fully component-based approach. Looking good!
https://github.com/gabordemooij/redbean 2028 commits. 
I mean if you are using something like laravel with blades, it knows how to do the code completion, understands that your brackets and command structure aren't typos and may even understand something about the structure, like when you create a new template, it knows by default where it should live, I think. I'll have to test that.
does it support yii2?
Yeah, I talked to them about running multiple concurrent versions of php and they balked. Maybe with this firepower they will give in. Thanks for the info!
Thank you very much for this tip. I've never dipped into server administration short of getting my own stuff to run on some vagrant setups.
It seems to work well (tho only just set it up - we were moving to new servers so thought we'd give it a whirl given its supported by redhat). Caveats - if you want php-mcrypt its not included in scl for php55 - but remi does a repo called 'php55more' that includes extensions redhat dont package in scl (havent tried that yet but will be doing for mcrypt) Also I went with apache24u from ius and php55 from scl - with hind sight I wouldnt mix and match between ius and scl - I'll probably swap to apache24 from scl at some point instead as the php-devel package for php53 won't install as its got dependency conflicts with the ius version of apache24 (thats only an issue if you want to compile your own php extensions I guess)
It's old, poorly written spaghetti code, possibly without any tests, that nobody wants to touch for fear of breaking everything, but is still forced to, because it's the main cash cow of the company. Also: no time to refactor, the company needs to stay competitive on the market, so marketing already promised new features to customers.
I'd like to formally say: fuck your attitude. Me and the Jones have disagreements a lot but we don't hate each other and this is not a competition. I don't want people like you speaking for the League. You are not making anything better for anyone with this sort of statement. I want more teamwork and less tribal bullshit. Aura is a component vendor very similar to the League, and I wish there were more of them.
Maybe I wasn't clear. I agree 100%. Was pointing out his contradiction. He says laravel is the best, but by his logic he should be following symfony, since it is more popular (not to mention that it is also superior).
Really? I keep seeing league stuff get screamed down purely based on being anywhere near the league and not based on its merits. I don't support that jackholes attitude about /u/pmjones or throwing the League name around like that. I even said as such [up here](http://www.reddit.com/r/PHP/comments/30i0t4/aura_3x_plans_or_the_past_present_and_future_of/cpsu4wq).
better than phpstorm?
Its not built that way to start with, thats my big beef with calling those two (and others) an IDE...
&gt; or is it an interface that they're implementing? Why does it matter? The important thing when browsing code is identifying the core concepts. That's where the naming should help. The fact that it's a class, an interface, a string or an int doesn't really matter unless you are looking at the details, and that's happening when coding. Then a name suffix couldn't tell you also if the class is final, which interface it extends/implements, etc.
I've been doing well using Git and [AWS Elastic Beanstalk](http://aws.amazon.com/elasticbeanstalk/). Beanstalk is one of Amazon's systems for deployment and auto scaling. I use the [eb command](http://docs.aws.amazon.com/elasticbeanstalk/latest/dg/eb-cli3-getting-started.html) to associate Git branches with Beanstalk environments, eg the master branch == production environment. After updating the branch I use `eb deploy` to send the changes to Beanstalk, which automatically deploys the code changes without any downtime. Feel free to PM me if you have any questions.
i hate netbeans, too much configuration. i found it hard to work with more than one project at once. do you have a tutorial for conditional breakpoint?
Having services depend on services is not code smell, and it could even be said "that's half the point" of dependency injection. It's perfectly normal for a service to depend on another, which has it's own service dependencies, which each have their own dependencies, and on, and on. Building complex services with nested dependencies may seem a little smelly at first because of the complexity, but that's why we use service containers. To deal with the complexity. [Pimple](http://pimple.sensiolabs.org/) is an easy to use service container you may want to play with to get the swing of things. Using Pimple your controller example could be written like this: #### bootstrap.php use Pimple\Container; // Defining your services. $container = new Container(); $container["stream_factory"] = function($container) { return new StreamFactory(); }; $container["logger"] = function($container) { $stream = $container["stream_factory"]-&gt;createStream("/log/files/prod.log"); return new Logger($stream); }; $container["couponer"] = function($container) { return new new CouponApplyService(); }; $container["discounter"] = function($container) { $discounter = new ProjectDiscountService(); $discounter-&gt;setLogger($container["logger"]); return $discounter; }; $container["quotations"] = function ($container) { $quotations = new QuotationService($container["discounter"]); $quotations-&gt;setLogger($container["logger"]); return $quotations; }; You treat Pimple like an array, and assign closures to each array index. The closure is responsible for actually creating the service. When you access the service via the container, eg `$couponer = $container["couponer"]`, Pimple calls the closure to create the service. The service is returned by `$container["couponer"]`, not the closure. Note that we are nesting our services. The "logger" service depends on the "stream_factory" service. The "discounter" service depends on the "logger" service, and the "quotations" service depends on both the "discounter" and "logger" services. #### YourController.php public function showQuote() { $project = "blah"; $container = $this-&gt;getContainer(); $coupon = $container["couponer"]-&gt;findOutBetterCoupon($project); $quotations = $container["quotations"]; $quotations-&gt;quote($project, $coupon); return View::make( 'the_view', ['project'=&gt;$project] ); } As a side benefit the container (by default) implements a singleton pattern, and will always return the same object when retrieving a service. Accessing `$container["quotations"]` will always return the same object instead of creating the service from scratch each time.
I'm still looking for an easy way of debugging laravel projects inside a vagrant machine with phpstorm.
It is impossible. Storm &gt; all
Those are not facades, those are plain static methods. Seriously guys
From the PHP developer who brought us [simplified password hashing](https://wiki.php.net/rfc/password_hash) / [password_compat](https://github.com/ircmaxell/password_compat) and helped with the final push on [Strict Type Hints (v0.5)](https://wiki.php.net/rfc/scalar_type_hints_v5)... Generics for PHP!
Wow, this looks very similar to [a library I wrote](https://github.com/TimeToogo/PHP-Generics) over a year ago now.
No offense, but Anthony's Generics is 10x better than yours and feels more natural. Of course you deserve credits for thinking of a way to make this happen, but from a user experience point of view it's really nowhere near as good as Anthony's. 
well, Nuclide looks like it's a stand alone installed desktop app;...looks different to the web based thingy we saw..
No reason to sell it to you. If you dig Vim, stick with it. For me, getting autocomplete and folding to work how I want it to, is always a challenge and never feels quite right. The autocompletion/folding features in PhpStorm are great straight "out of the box".
Can you give an example of a bug you've run into
It's funny to me that when a well know developer creates something ridiculous like this everyone is like "wow, that cool you can do that" or "very clever" But when a developer no one know does it people say things like "that's stupid, you shouldn't do that", "why would you do this, it's really bad" Just a thought. 
I noticed this when debugging some javascript in phpstorm 8 over the past couple days. It is pretty handy, and I'm happy to see its available for php debugging now. 
Generics for PHP... written in PHP? This way lies madness.
http://www.phptherightway.com 
Did you even try reading the ReadMe?
It's because this is generally a bad idea and is done as a joke, which is pointed out in the project's README file. 
I believe that's my coding checklist from the mid 2000s. :)
how is it irrelevant? it clearly shows the rb repo used for packagist/composer actively being maintained.
It's irrelevant because they're not telling people to use it or promoting it. They're telling people to download a tarball. You're really not getting this are you?
your initial comment made it seem as if composer isn't supported at all. which isn't the case. if someone wants to add RB via composer.json they can. 
You misread my initial comment and I've corrected you on what I meant to say. I've already acknowledged that you CAN use composer. You're continuing to argue against a point I **did not make**. Stop it. 
Wow!! Thank you very much!
I feel like this is whooshing way over my head. What is it doing, and why is it so interesting?
I may be wrong but I'm pretty sure it's called ternary because it has three parts :p
First, some code: /** * This class stores arrays of items. It is strongly typed, meaning * only items of a specific data type may be added to the list. */ class StrongTypedList&lt;T&gt; { protected $items = []; public function add(T $item) { $this-&gt;items[] = $item; } public function get($index) { return $this-&gt;items[$index]; } } $pdo_list = new StrongTypedList&lt;PDO&gt;(); $pdo_list-&gt;add(new \PDO("...")); $pdo_list-&gt;add(new \PDO("...")); // This results in an error. Only instances of PDO can be added // to the list. $pdo_list-&gt;add(new \DateTime()); $date_list = new StrongTypedList&lt;DateTime&gt;(); $date_list-&gt;add(new \DateTime()); $date_list-&gt;add(new \DateTime()); // Again this results in an error. Only DateTime types may be // added to the list. $date_list-&gt;add(new \PDO("...")); The breakdown: class StrongTypedList&lt;T&gt; This defines a class with a generic type. The token `&lt;T&gt;` provides the *label* for the type. Kind of like a variable is a label for a value, the `&lt;T&gt;` defines the label `T` to represent our generic type. We don't know what the type will be yet. We are only defining a label for the type. You can use any label you want. `&lt;Y&gt;`, `&lt;Foo&gt;`, `&lt;TTT&gt;`. It's up to you. public function add(T $item) This defines a method which only accepts type `T`. The label `T` is the same label we used when defining the class. Whatever label you chose to use, you put that in the method signature. Again, we don't know yet which variable type is being type hinted, so we use our label `T`. $pdo_list = new StrongTypedList&lt;PDO&gt;(); Now we created our first instance of the class, and we finally told the class what type `T` represents. In this case the type `T` represents an instance of `PDO`. What you've done is semantically equivalent to defining your class like this: class StrongTypedList { protected $items = []; public function add(\PDO $item) { $this-&gt;items[] = $item; } public function get($index) { return $this-&gt;items[$index]; } } Now you may ask, "Why didn't we just write the class like that in the first place? What's the point of this funny 'generics' stuff?" The answer is here: $date_list = new StrongTypedList&lt;DateTime&gt;(); Using the *exact same class* we create a new instance of StrongTypedList, but now the list only accepts a value of type `DateTime`. It's almost like we defined the class using: class StrongTypedList { protected $items = []; public function add(\DateTime $item) { $this-&gt;items[] = $item; } public function get($index) { return $this-&gt;items[$index]; } } The point of generics is reuse. In languages which don't support generics (like PHP) you would have to define **two** classes if you want a list of `PDO` instances and a list of `DateTime` instances. In other words, instead of defining one `StrongTypedList` you have to define two classes: class PDOList { protected $items = []; public function add(\PDO $item) { $this-&gt;items[] = $item; } public function get($index) { return $this-&gt;items[$index]; } } class DateTimeList { protected $items = []; public function add(\DateTime $item) { $this-&gt;items[] = $item; } public function get($index) { return $this-&gt;items[$index]; } } This is a waste because both classes **do the exact same thing**. The only thing that makes them different is the _type_ they use. Instead of defining two classes, we can define one "generic" class. class StrongTypedList&lt;T&gt; { protected $items = []; public function add(T $item) { $this-&gt;items[] = $item; } public function get($index) { return $this-&gt;items[$index]; } } If you're still confused, consider the algebra expression `x + 2 = 12`. Here the label `x` is a "placeholder" for an unknown value. In our class `T` is a placeholder for an unknown type. The code `public function add(T $item)` tells PHP that the method only accepts a specific type, but you don't know yet what the type will be. `T` is a placeholder for the unknown type. PHP won't know what type until runtime when you create an instance of the class using the code `new StrongTypedList&lt;PDO&gt;()`. _Now_ PHP knows that the label `T` represents the `PDO` type.
Legacy code is code written by the guy who was there before you... 
You could make a function to do something like that, if you really wanted. function true($expression, $output) { if ($expression === true) { return $output; } return null; } &lt;?= true(1 === 1, 'hello'); ?&gt; But.... ehhhhhh........
&gt; When you create a sub-function to better organize your code, you don't expect the caller to have to call the sub-function. Instead, the original function calls the sub-function without the caller being aware of that. Do the same: a service can use sub-services. Like this quote! It's inspiring! Thanks!
I found this great SO post today: http://stackoverflow.com/questions/17745937/ddd-domain-services-what-should-a-service-class-contain I found myself have MANY services too ... not sure how many functions should one service have. @mnapoli , for the SO question, do you have any new idea from then on? What's the DDD way of doing this? It seems there's always the same few people focus on the same questions : p
From the readme: &gt; TL/DR: don't use this Agree ;)
Although this discussion is really silly, I'm sure the interpreter would be capable of going "oh, you didn't include a colon part, I guess if the expression evaluates to falsey I won't do anything". I mean, it doesn't scream at me if i don't have an 'else' statement for every 'if'. I'm not saying this should be the behaviour at all, but it could.
Ah fun, I posted that question a few years ago. Now I don't have an answer to that question, but that's because I don't think there is any. I.e. I don't believe there is one true way to write services (or code for that matter). I know it sounds like bullshit abstract talk but I now try my best to do one thing: group things together that solve the same problem. Is creating "quotations" a whole concept in the application? Fine build one service for that. Also nothing beats experience, i.e. trying and iterating. A stranger on the internet can't solve your problem better than you because you have all the business knowledge, and you have the experience with your model. Fix what doesn't work, identify what does. It doesn't matter if you break a few "rules" if that works better for a specific use case. You are not sure which of A or B is better? Then try them both (at a small scale)! [Controlled experiments](http://verraes.net/2014/03/small-controlled-experiments/). And always keep in mind that the solution to problem A is not necessarily the same solution to problem B. I remember wanting to apply DDD to a simple e-commerce website: mistake. The services here were dumb and the model was anemic, which I learned was "wrong", but in fact it was perfectly fine.
Do you know about iconv and ASCII//TRANSLIT out charset? I think this is better solution than make big array with national characters. PS. Thanks for polish language support in your class :) 
But what happens when its falsey? Does it return null, empty string, exception? Must admit it does throw me at times as I use &lt;?=$x ?: $y ?&gt; a lot
I think the README covers that very well, you couldn't miss it even if you wanted to. So I see no problem here.
I agree, Aura may not be the best framework ever developed in PHP. Every user have his own preferences, likes and dislikes. As a person who likes Aura and sometime criticize strongly I think the 3.0 goals to move as a component vendor is nice. There are many things we need to learn from the packages designed in Aura or other frameworks. You may agree / disagree with me. But frankly you should check the code and how dependencies are handled to make it independent of other libraries. Happy PhPing. Thank you! 
You are half right. &amp;nbsp; Contrary to what many believe, especially from PHP world (_we all know to which framework we need to thank for that_), a Facade's main role is not to hide a complex API and/or to help you avoiding reading the manual for a more complex API ; on the same note: a Facade does not imply that it should be static. &amp;nbsp; A Facade's main role is to reduce coupling. Because of this main role, a side effect appears: it wraps a (_sometimes complicated_) subsystem with a simpler interface. 1. Each Facade should have limited knowledge about other units 2. Each Facade should talk only with its friends, not to strangers (see #1) 3. A Facade should not have any `new` reference in it 4. Because of #1: You can (_should_) have multiple Facades for a subsystem, each using different units from it 5. It should not forbid you to access the subsystem directly. &amp;nbsp; Facades are a structural pattern, so if #3 is found in a class, that transforms the class from structural to creational (_aka Builder, (Abstract|Static|Simple) Factory [Method]_).
&gt; But I said that here because you just opened the issue and immediately posted it on Reddit. Depends on how you define and understand _immediately_. The post on reddit has been added a few days after I created the issue on Github. &gt; As we all know, posting a GitHub issue is asking for loads of people jumping in the discussion for writing +1 or sometimes unconstructive comments (amongst good comments, I'm don't want to generalize too much). I comment on a issue only if I have something to say. If I'm just interested in the subject discussed, I subscribe to that issue. I look at the number of people subscribed to an issue as a metric on how popular is the subject discussed and most likely so do other maintainers. &amp;nbsp; I posted the link on Reddit to bring awareness and point the interested people to the right location where they could subscribe for updates. On any public issue tracker you will have silly comments and that is OK, because it is an open project, developed in an open manner, where anybody can jump in. In software development and open-source in particular, you need thick skin, so if you are annoyed by silly comments, false bug reports and trolls, maybe open-source is not for you. &amp;nbsp; &gt; So to sum up: if you are asking for a feature (i.e. not submitting a PR), let's wait for what the maintainer have to say before calling the whole world into the discussion. I don't know how do you maintain your projects, but if my users are asking for a (_sane_) change, I will do the change. I open-sourced that project so others could use it and if I don't satisfy the demands of my users, the main reason for open-sourcing something is lost. &amp;nbsp; &gt; And Packagist is open source: https://github.com/composer/packagist Ah, that's good to know. Thanks for the heads up! I will go right now and create a feature request regarding this subject.
That's completely not my experience, and I (shamefully) admit I visit this subreddit every day.
Actually that would make a hell of a PHP reddit thread :p
&gt; now do you understand why I prefer discussion before sending a PR with a feature ? My time is precious to. yeah! you were right to do so ;)
&gt; Following the other logic posted, wouldn't it just remain exactly as a variable did if it wasn't set? Since it is the first time the variable is initialized, in PHP I imagine it would likely be NULL. But this just seems to me like terrible practice because of the reduced readability. Why change the behavior of the ternary operator when all you have to do to not change anything would be $someVar = ( $someVar === 'something' ) ? someFunc($someVar) : NULL; It spells out your intentions pretty clearly what happens if the conditional is false. Instead of having to know in PHP a variable is NULL when no initial value is assigned.
Honestly, I don't care for the shorthand PHP operator usage, so trying to combine it with a ternary, I would have to say no.
Yeah thanks for that (a few of the typos might be because I wrote it at 1am...). Im currently working on a script that runs on Vagrant up (like /u/thescientist13 suggested) that will do everything I wrote down at once. So that you can just clone my repo and run vagrant up and done!
Didn't mean to say otherwise, it's just a mess to look at and read.
I see, that's strange. So this means the voting is still going on? Will new votes passing the closing date count? If so, new votes can still change the results for closely contested RFCs? 
Yes, yes it is.
This is useful It works without the need of having "mbstring" and "iconv" Don't understand why its getting downvoted. 
All code is legacy code :)) (jk) 
What would you return for the else? Empty string? False? 0? null?
Thats's awesome, you guys did amazingly this time. Thank you both so much! 
Not according to the Golang people!
This seems like a perfectly sane and reasonable package. I'm gonna use it in production!
I've tinkered and tinkered with Atom. When I pull Atom and sublime text up side by side the fonts in Atom just look blurry. What the heck!? How do people use it like this? I've tried in Win7 and Win8.1. I've tried different themes, different fonts. Everything that I can think of. Am I the only one that this bothers? 
Yeah, but if you have tests in theory you can make code changes and see if the tests still pass. 
I'm late to the party on this, but the first thing I thought of was Meteor, and sure enough - there's a client/server same logic validation: https://atmospherejs.com/copleykj/mesosphere
When people write such things how do they deal with the possibility of conflicting IPs of vagrant boxes? The OP just hardcoded it in the VagrantFile but I guess that could cause issues?
How do you go about setting that up? 
Thanks buddy! :)
so...WordPress is legacy?
Not to be an ass, but: &gt; ternary: composed of three parts. As others have said: &lt;?= (1 === 1 and 'Hello') ?&gt;
I'm working on one. I'll post the link when I get back to my pc. Edit: This is still very much work in progress; and I'd appreciate any PRs to be made. https://github.com/alexbowers/atlas/tree/dev
I love Go, and I like the slow approach the devs take to change, but yeah... could use some generics.
Forgive me for being lazy with my words -- what I was getting at wasn't so much speed of latency issues, but rather code complexity and state management. (I was just assuming tons of requests implies tons of complicated logic).
That's how you configure it. It's designed to be configured the same way in PHP as in JavaScript, with service location. It doesn't really have much to do with the API. Edit: This was for an older version, before \SciActive\R was renamed to \SciActive\RequirePHP.
But anyway, I'd like to hear your feedback. If I can make it more understandable, and easier for you to use/more useful to you, I'd love to. How could it be changed so that it would better suit your needs and make more immediate sense? (Last time I put a new version up here, I got tons of useful feedback from the community. I really value the feedback you guys provide. It helps me make a better product that can be more useful to the community. :D )
Best of luck to you! I'll definitely be watching this.
easy integration with the rating APIs. 
I dont understand what you mean to rating API. Please can you provide a link or more info? Edit: Ah, found it: http://www.ups.com/content/us/en/bussol/browse/online_tools_rates_svc.html
"Logical operators should be avoided" - https://insight.sensiolabs.com/what-we-analyse
Elegantly put!
&gt; No, I know that, I'm asking what it is about the compiler that's so different that things like this are hard in Zend, but long implemented in Hack. They have paid, full-time developers that have worked on Hack and HHVM for years and designed Hack to be analyzed more easily for security reasons. That is certainly a non-trivial difference.
Citation, please? I don't think generics have been proposed. We had the arrayof RFC but that's a small, small sliver of generics.
Great win - well done /u/krakjoe &amp; /u/philsturgeon
I didn't set anything up to make it do that.. I simply starting doing some JS debugging and it was there. or do you mean how do you set up the JS debugging? https://www.jetbrains.com/phpstorm/help/debugging-javascript.html
&gt; With this in place, its very easy to create event listener classes Event listener classes are just functions with baggage. Use functions.
Don't use mysql, learn postgresql. Its really free (mysql isn't) and is a vastly better database all around
Part 2. This is where you actually learn about _interfaces_. To allow either an instance of `Person` or `Pet` to be passed to `printsNames()` we extract a common interface between the two classes. We do that by creating an interface. interface Nameable { public function getName(); public function setName($name) } Then we change our classes so they implement the interface. class Person implements Nameable { protected $name; public function __construct($name) { $this-&gt;name = $name; } public function getName() { return $this-&gt;name; } public function setName($name) { $this-&gt;name = $name; } } class Pet implements Nameable { protected $name; public function __construct($name) { $this-&gt;name = $name; } public function getName() { return $this-&gt;name; } public function setName($name) { $this-&gt;name = $name; } } Finally we modify our `printsNames()` function to allow any instance of `Nameable` to be passed as an argument. function printsNames(Nameable $person) { echo $person-&gt;getName(); } The `Nameable` type hint guarantees only instances of that interface may be passed to the function. The `Nameable` interface guarantees any instance of it will have a `getName()` method. The object passed to the function may have _other_ methods, but that doesn't matter to the `printsNames()` function. That function only cares about printing names. You just used an interface to make your code more reusable. Creating the interface didn't save you from typing less code the way inheritance does. In fact you had to type more code! But the interface made the `printsName()` more usable. Instead of only being able to print names from `Person` objects, it can now print names from _any_ object that implements the `Nameable` interface. It might be a `Person` object, or a `Secretary` object, or even a `Cat` object. Your code is both more _type safe_ and _reusable_.
If simple stubbing and mocking is not useful enough for you, then you can at least be content that this "feature" is a half-way gap to implementing nested classes, which will certainly be handy and will be in by PHP 7.1. Also I'm a bit confused about your claims of Java and C# not being "real object orientated languages". That sounds like some odd real scotsman argument that I don't quite understand.
This sort of thing should be hidden behind something like... $config = [ "mysql" =&gt; [ "host" =&gt; "127.0.0.1", ... ] ]; Nymph::configure($config); The thing with RequirePHP is simply an implementation detail that should be hidden behind your API.
This doesn't make more sense when transliterated to JavaScript.
Save for the static method call and superfluous use of double quotes, this is passable.
I mostly code in other languages, I forgot that double quotes is not the same as single quotes in PHP. As for the static method call... I couldn't remember whether PHP has function autoloading.
Looks similar to AspectMock https://github.com/Codeception/AspectMock
Since PHP 5.4 you can access protected properties of a class by binding a closure to it. Nothing new here
People keep going on about Ternary being three parts, but that's not the real issue here. In programming languages you have lots of primitive 'parts', like statements and expressions, e.g. $hello = 1; // This is a statement (3+4+5) // This is an expression A statement in a sense is some kind of instruction to do something whereas an expression is something which evaluates to a value. Now here's the important bit. The if-else construct is a statement, it does something, this is why you can have just an if statement, if its false it just doesn't do it. However, a ternary operator is an expression - it HAS to return a value when evaluated. We could default it to return something but its not clear what that should be, maybe null, maybe an empty string - it's hard to say. It's much easier not to have a default and to have the programmer be explicit.
&gt; It's not technically difficult to add ~~generics~~ anything to PHP. It's politically difficult. Fixed.
The fact that there are other ways of doing something isn't a good reason in itself to not include a feature. Convenience is often a great thing, and unless you've used anonymous classes in a language that already allows them (such as when writing code for Android using Java - they're a great way of extending a single method of a class that does almost what you want when setting up an event listener). My experience is that anonymous classes make it easier to read the code, as you don't go chasing references through a couple of extra layers just to implement or override a single method with one to three lines of code. 
This is great! It will really help with creating tests.
I didn't know MySQL wasn't free.
Well closures are objects, but functions are not, except in languages that functions are first-class objects. I was talking about functions in general(considering PHP's nature that functions aint first class objects), not just closures. Anyway, sometimes its not just single function method in a whole class. How about in this case: http://docs.oracle.com/javase/7/docs/api/java/awt/event/WindowListener.html Lets not worry about how useful a window listener functionality is in PHP, I just use it as an example since the WindowListener class has multiple methods/functionality you can implement, not just one. Such cases are not rare for event listeners. Okay you may say that with function you have different ways to achieve the same thing, but I prefer the class way. Like I said, it's a matter of choice. The fact that you like the function way, does not mean the other ways are wasteful and stupid. 
Functions closures can't implement an interface though. I actually see this as a useful feature that can improve the convenience of using SOLID packages. Packages can specify very segregated interfaces that must be injected, and clients can anonymously implement those interfaces and conveniently plug them in without needing to define an entire class. If callable type hinting allowed you to specify inputs and outputs, I'd be more inclined to agree with you. But I actually see some very practical use cases for this.
&gt; opens door for future nested/inner class, maybe by PHP 7.1 Oh God... why is everyone insisting on turning PHP into JS/Java? I mean I get it, it is cool and all... But isn't everyone exaggerating a bit when it comes to anonymous funcs/classes? 
It is, see my post above
Besides that, access tokens are used for identifications. Clients report to the created project - it is a log and exceptions tracking app
#####&amp;#009; ######&amp;#009; ####&amp;#009; [**MariaDB**](https://en.wikipedia.org/wiki/MariaDB): [](#sfw) --- &gt; &gt;__MariaDB__ is a community-developed [fork](https://en.wikipedia.org/wiki/Fork_(software_development\)) of the [MySQL](https://en.wikipedia.org/wiki/MySQL) [relational database management system](https://en.wikipedia.org/wiki/Relational_database_management_system) intended to remain free under the [GNU GPL](https://en.wikipedia.org/wiki/GNU_General_Public_License). Being a fork of a leading open source software system, it is notable for being led by the original developers of MySQL, who forked it due to concerns over its acquisition by [Oracle](https://en.wikipedia.org/wiki/Oracle_Corporation). Contributors are required to share their copyright with the MariaDB Foundation. &gt;It intends to maintain high compatibility with MySQL, ensuring a "drop-in" replacement capability with library binary equivalency and exact matching with MySQL [APIs](https://en.wikipedia.org/wiki/Application_programming_interface) and commands. It includes the [XtraDB](https://en.wikipedia.org/wiki/XtraDB) storage engine for replacing [InnoDB](https://en.wikipedia.org/wiki/InnoDB), as well as a new storage engine, [Aria](https://en.wikipedia.org/wiki/Aria_(storage_engine\)), that intends to be both a transactional and non-transactional engine perhaps even included in future versions of MySQL. &gt;Its lead developer is [Michael "Monty" Widenius](https://en.wikipedia.org/wiki/Michael_Widenius), the founder of MySQL and Monty Program AB. He had previously sold his company, [MySQL AB](https://en.wikipedia.org/wiki/MySQL_AB), to [Sun Microsystems](https://en.wikipedia.org/wiki/Sun_Microsystems) for US$1 billion. MariaDB is named after Monty's younger daughter Maria, similar to how MySQL is named after his other daughter My. &gt;==== &gt;[**Image**](https://i.imgur.com/YC9hq9X.png) [^(i)](https://en.wikipedia.org/wiki/File:MariaDB_Logo_from_SkySQL_Ab.png) --- ^Interesting: [^XtraDB](https://en.wikipedia.org/wiki/XtraDB) ^| [^Navicat](https://en.wikipedia.org/wiki/Navicat) ^| [^Michael ^Widenius](https://en.wikipedia.org/wiki/Michael_Widenius) ^| [^InnoDB](https://en.wikipedia.org/wiki/InnoDB) ^Parent ^commenter ^can [^toggle ^NSFW](/message/compose?to=autowikibot&amp;subject=AutoWikibot NSFW toggle&amp;message=%2Btoggle-nsfw+cpuknb4) ^or[](#or) [^delete](/message/compose?to=autowikibot&amp;subject=AutoWikibot Deletion&amp;message=%2Bdelete+cpuknb4)^. ^Will ^also ^delete ^on ^comment ^score ^of ^-1 ^or ^less. ^| [^(FAQs)](http://www.np.reddit.com/r/autowikibot/wiki/index) ^| [^Mods](http://www.np.reddit.com/r/autowikibot/comments/1x013o/for_moderators_switches_commands_and_css/) ^| [^Magic ^Words](http://www.np.reddit.com/r/autowikibot/comments/1ux484/ask_wikibot/)
GPL isn't free. MIT is free.
Ok, so the correct fix I think would be to hint callback types. Not cargo cult in one of Java's dumbest misfeatures. &gt;In my opinion it would be much better if we could use anonymous functions like interfaces with signle methods. It actually works and I find it much more elegant than anonymous class Yes, precisely.
For the record he is also a php-src contributor, and helps us us a lot with his experience as a distributor.
&gt;Functions closures can't implement an interface though. so fix that. Seriously, what is cleaner? array_sort($array,function($x1,$x2) { /*compare and return result" */}); or array_sort($array, new class() extends Comparator { public function compare($x1,$x2) { /* compare and return result */ } } ); A lot of noise signifying nothing.
&gt;Lets not worry about how useful a window listener functionality is in PHP, No, lets. This is an edge case. The difference between making this anonymous and a named class is tiny and a named class would be *much* more readable. Again, you're just cargo culting a bad feature from Java. &gt;Such cases are not rare for event listeners. IME, the actually are and, if there are more than one method - readability benefits HUGELY by making it a proper named class.
Have you actually tried using PHP arrays and profiling your code to verify that you aren't falling victim to premature optimization?
Where I work, we tend to treat people with respect, teach those who don't know and are willing to learn, and reserve the firings for those with inflated egos.
nested/inner classes isnt just java...
&gt; class is object oriented, function is not. enough said. I am an OO purist No you're not. If you were you'd be working in a proper OO language like Smalltalk of CLOS where this: aBlock := [:a :b || "Do stuff with a and b"] is an object. There is nothing non-object oriented about a closure or function as a first class object. Blocks in Objective C are actually Objective C classes (and implemented at the C layer no less!). Blocks in Smalltalk are first class objects. We are most of the way there in PHP. $thingy = function($arg1, $arg2) use ($local_thing1, $local_thing2 {/* stuff */}; $thingy is functionally the same as your one method anonymous class or the Smalltalk block above. $thingy($a,$b); vs $anon-&gt;operation($a,$b); Furthermore, the creation of thingy is much cleaner and easier to read than $thingy = new class($local_thing1,$local_thing2) implements SomeInterface { public __construct($t1,$t2) { $this-&gt;$local_thing1 = $t1, $this-&gt;local_thing2 = $t2; } public function operation($a,$b) { /* do something with $a and $b */ } }; How insanely silly is that? Very very silly. Only one line in that mess serves any actual purpose. I'm an expressive purist. It is why I like PHP. It mostly lacks gratuitous syntax and is more OO than Java or C#. This proposal brings us down to the signal to noise level of awful languages like Java where only about 5% of the program actually does anything. 
you keep using that word, but i don't think you know what it means.... Joke aside, I'm not really sure you are qualified enough to know every possible use case for something in a language. 50 incredibly smart people would seem to disagree with you.
That would be fugly. I'd go with a documented named class so you could actually read your code.
I know what the word means.... You just cant seem to get over the fact that people disagree with you and that you might be wrong. Thanks for the emotional downvote.
And why is that? You have a source?
Good OAuth clients can handle renewing tokens without hassle, so don't like perceived difficulty of implementing a client alter your decision. Hopefully, you are using an existing, proven OAuth server package in which case I would go with their suggestion on the matter (The few I know of expire their tokens). If a token is compromised, it'd be better that it weren't good forever. 
I'm only downvoting comments that do not contribute to any discussion, as the rule is with downvoting. Never downvoted you. &gt; And I'm not wrong. That is such a 5 year old mentality lol /unsubscribe
because using an extended anonymous class isnt complex if it only has one method. If you don't like the feature, don't use it. Stop bitching about it already
I do not trust you as a source.
Do you even know that whether or not to use a language is not the choice of developer, but the project/app or the company itself? It's hilarious you are talking about the choice of languages when you have no clue of what are you are even talking about. Can you say every PHP internal is a procedural programmer just because they write native C code to extend PHP? You are talking total nonsense. Also how do you know PHP is the only language I am familiar with or the only one I use? I work on a .NET and Python project too, both are full-fledged OO languages as compared to PHP. But I like PHP, I am glad it's undergoing some positive changes. Of course I know smalltalk is the purest OO language, and lives up to the hype that everything is an object. However, smalltalk's syntax is very unfriendly to modern programmers, and there are many other reasons why smalltalk is not being widely used by company's projects. We are here talking about features that can make PHP more OO. It is not about what language we should use, but how we can improve the language called PHP. If one day blocks in PHP are objects, I am happy, but one step at a time. 
you implied that adding nested/inner classes would turn PHP into java, when really, its just turning it into a first class language (as several other languages have nested/inner classes).
I'm curious to what your project is about? Willing to share?
When you are in doubt regarding security, always design and write your code thinking about worst case scenario. &amp;nbsp; I usually issue my tokens with a 1 hour TTL. If a token is stolen, can you find out that a token has been stolen, revoke it in under 1 hour and keep that performance 24/7 ? 
That's a great idea. Thank you for your help, and I'll implement this for the next version.
You're not really adding anything constructive to the conversation right now, so if you did keep quiet until you can, it would be appreciated. Feel free to point out more areas that could use improvement though. :)
Now to deprecate and remove the mcrypt extension, because the underlying api that it is using hasn't been updated since 2003...
The results for Nette and PHPixie are especially curious, I think. I never even heard of them before the survey.
Skipped 5.4 and are unwilling to do the 5.5 -&gt; 5.6 jump as they believe that the effort required to test applications and "fix" them is better spend on the 5.5 -&gt; 7.0 migration ("do not touch the same code twice, if you don't need to" and "better be happy that we consider upgrading to php7 within 6 months of its stable release at all"). Im not entirely convinced on that path, but I can understand the reasoning. 
I have no input, but I'd be willing to bet that that's the case just like any other country in the world except Japan since the creator of Ruby is Japanese so they use that.
Your project is crazy and I love it :)
I disagree with all of what you just said, and you only answered the part of my message that began "Also,"
I have been using RedBean for about 4 years now since version 3. We are now at version 4.1, with 4.2 coming out soon. I would like to address a few points. 1. RedBean allows you to take a super simple idea (eg my idea for a Startup Company that is funded and going global). And it allows you to rapidly build on this idea. 2. I have been using RedBean on the same project for the last year and I am still loving it, it just doesn't get in the way. 3. A few things I really love when saving form data, eg a users details. You can do this with few lines $user = R::dispense("user"); $user-&gt;import($_POST,"name,email,pass,firstname,lastname"); (all data is now ready to be saved). // You would have validated your variables that you were importing were first valid. R::store($user); // done. 4. Very quickly traverse the database. eg if we a record that belongs to a user. Eg invoice. we can get the company name with something like this. $companyName = $invoice-&gt;user-&gt;company-&gt;name; // assuming an invoice belongs to a user, who belongs to a company. 5. And lots more goodies. Design Considerations. RedBean is very dynamic, it will create tables, keys, indexes and rows dynamically. One comment is that "don't use RedBean in production". I don't know where this comes from, that is like saying "don't use any ORM in production". What some commenters are worried about are creating new tables/rows in production dynamically. With RedBean you can negate this issue by calling R::freeze(); Now RedBean will not create anything dynamically and will be like all the other tools that require to "muck around" manually creating columns. I personally feel this just slows down you development process but I do keep a close check of my database with tools like Navicat. You can even R::chill(); certain tables and let other tables be dynamic. Speed. Not an issue. Programmer development speed, "amazeballs" you can just work on your app/prototype/startup and not muck around with the DB so much. Having said this. For BULK inserts eg several thousand records. RB is not fast, do this in pure SQL. In my whole app, I have several lines that I have manually done in pure SQL. But this situation is only importing massive CSV files. Speed is critical here. Have I used other ORM tools? Not really. I have my own stack that I have found to be working super well. Silex, RedBean and Smarty (Twig would work just as well but Smarty has some real great stuff and "has" been super fast). Would encourage you to at least try this and some other tools. 
PHP reserved the toplevel/global namespace (and in PHP 5.3+ the PHP root-namespace) to itself. Any library that puts stuff there is doing so at it's own risk: &gt; Namespace names PHP and php, and compound names starting with these names (like PHP\Classes) are reserved for internal language use and should not be used in the userspace code. - http://php.net/manual/en/language.namespaces.rationale.php &gt; PHP owns the top-level namespace but tries to find decent descriptive names and avoid any obvious clashes. - http://php.net/manual/en/userlandnaming.rules.php Most functions are grouped by appropiate prefixes: - array_walk - str_replace - etc... The wtf is however, that not all functions are named according to these standards (parse_str, strcmp) and that some functions in some extensions have their parameter order reversed). edit: reddit eddit ate my eddit...
Well, that explanation means these two new functions should have been put into a namespace like `PHP\Crypto`, but instead the RFC just adds more functions to the global namespace.
Which is consistent to the naming rules that worked through the past decade(s). Having two functions in a namespace now and every other function using the (well working) prefix style would be worse. If you want to alias the existing functions into appropiate namespaces you'd need to redesign the entire API. (As you don't want to keep the inconsistencies). That is a task that shouldn't be done within the timeframe that was available for php7 (as there are big conceptual questions to be solved). &gt; Well, that explanation means these two new functions should have been put into a namespace like PHP\Crypto, but instead the RFC just adds more functions to the global namespace. No it explains that it is fine for php to place functions into the global namespace. If we like it or not it's documented.
Having a sort experience on e-commerce (I'm working on a platform the last year) I think that the software reflects the needs of the industry, every business handles common procedures completely different. It's extremely difficult to find a common ground. As a small example, for my business an "exchange" means that I need to create a new order, someone else might as well just swap the product on the same order, someone else will add the product and just adjust the inventory...try to put this under an interface :S Interfacing the software means that you have to interface the business as well.
&gt; Which is consistent to the naming rules that worked through the past decade(s) ... using the (well working) prefix style Sigh.. &gt; The number of functions and classes in the global namespace is often pointed to as an example of why PHP sucks, which is a valid point, and we don't seem to be doing anything to reverse the trend. From [PHP: a fractal of bad design](http://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/): &gt; As namespaces are a recent feature, the standard library isn’t broken up at all. There are thousands of functions in the global namespace. PHP dumping all of it's functions into the global namespace isn't exactly "well working", and like I said in my first comment, it's a source of criticism. &gt; That is a task that shouldn't be done within the timeframe that was available for php7 It shouldn't be slated for PHP7. The process should have started *years* ago. I actually asked this exact same question *[2 freaking years ago](http://www.reddit.com/r/PHP/comments/zrprk/the_new_secure_password_hashing_api_in_php_55/c67owc2)* and we're still no closer to cleaning up the global namespace. And I got the same basic response you're giving me now. "Because no other core functions are namespaced yet." Someone needs to draw a line in the sand. The longer we wait the more of a mess we'll have to clean up later. Every function/class we dump into the global namespace *now* is a function/class that needs to be fixed *later* when and if we start putting globals into namespaces.
You have to explain why, that's the rule :)
For starters, Laravel is the only one not broken down into major versions, nothing said can excuse that. You get a certain amount of echo chamber in a community (such as sitepoint) They have written 32 articles tagged as Laravel since the beggining of last year and only 24 for Symfony. So as a Laravel user you are more likely to read sitepoint then if you were a Symfony user. Lastly take a look at installs on packagist and Symfony components decimates everything in terms of installations (excluding monolog). You may "use Symfony" and not even know it.. Like the SYmfony HTTP packages that Laravel depends on. Just to make it clear, I am not hating on laravel at all. Just this survey.
Yes, PHP is huge in China. I did a simple search at www.51job.com (one of the biggest job sites in China), the rounded # of results for some languages are: * PHP 16000 * Java 35000 * .Net/C# 14000 * C++ 10000 * Python 900 * Ruby 170 The Python/Ruby numbers are about right, imo. Django/Rails are just not that popular/hyped up in China in comparison to, say, in the US. PHP frameworks still rule, the local ones (Discuz, PHPWind, ThinkPHP, Eshop, PHPCMS, Dedecms, etc. ) are popular, but WP, Joomla, Drupal and Zend framework have big presence as well. 
I agree that Laravel should be broken down for clarity. I believe the argument is that Laravel 4 &amp;amp; 5 are not architecturally different compared to, for example, Yii &amp;amp; Yii 2. Laravel 5 was after all originally just 4.3. It was made 5 mostly for directory structure changes. I'm not saying I agree, quite the opposite. But I think this is the logic. As for the Symfony thing, I think referring to the components and the framework interchangeably is misguided. In my day job we use a custom in-house framework (for the worst of both worlds!) and we use some Symfony components, but it would be highly misleading to say we "use Symfony". In fact, if you're going to follow this logic, every vote for Laravel should go to Symfony instead - as you said, it uses some Symfony components...
Developers have a hard time fighting over spaces and tabs. You want them to standardized their User Interface?
The title limited me to 300 characters, so I'll elaborate a bit here. I'm using the http://roots.io Bedrock WordPress environment, along with the Sage starter theme (not relevant to this topic). I'm also using a couple custom-built plugins, which I've setup as composer packages and have hosted on a Bitbucket repo. One of these plugins requires Redux as a dependency. When I run composer update from within the plugin directory, Redux is correctly installed to the vendor subdirectory within the plugin's directory, based on a setting within the plugin's composer.json telling it to install wordpress-plugin type packages in the vendor directory. However, when I try to bring the plugin into the Bedrock installation by adding it to the top-level composer.json file, Redux is installed to the wordpress plugins directory, rather than that specific plugin's vendor directory. How can I tell composer (specifically, Bedrock's top-level composer.json) to, when installing this plugin (installed as a composer dependency via the top-level composer.json and a custom bitbucket git repo source added to composer), follow the plugin's individual composer.json file and install the Redux dependency based on that plugin's composer.json specifications, and not Bedrock's top-level composer.json file configuration?
https://philsturgeon.uk/blog/2013/11/benchmarking-codswallop-nodejs-v-php/ The above link references this: http://rojan.com.np/scraping-nodejs-vs-php/ (read the update) In the end it looks like node vs react are just about the same in terms of performance.
I'm not sure why you got downvoted for this, it's spot on.
eli5 psr7
You should read http://www.phptherightway.com first. 
Maybe this is a bit more for the experienced developer than for a guy starting with PHP.
I'd agree that a good 50% will go totally over the head of a beginner, but I think it's better to know what's there than get stuck learning, for example, SQL without PDO. 
I'm probably missing something obvious, but what's the benefit of adding random_int() as opposed to just implementing this new logic as the guts of rand()? Or, more to the point, where would I use rand() after this goes live? Is there a noteworthy speed cost to these new methods?
I would suggest you reading some well written PHP books, although this is a bit old fashioned. For example: http://www.amazon.com/PHP-MySQL-Web-Development-4th/dp/0672329166/ref=sr_1_16?ie=UTF8&amp;qid=1427697951&amp;sr=8-16&amp;keywords=PHP+5
&gt; You may "use Symfony" and not even know it.. Like the SYmfony HTTP packages that Laravel depends on. There's a difference between using Symfony the framework and using Symfony components. Laravel uses parts of Symfony to get a major leg up - meaning it's sole developer can concentrate on what makes his framework unique as opposed to reinventing the wheel writing new implementations of precisely the same things.. But unless you REALLY want to, you don't actually "see" the Symfony when you're developing a Laravel app. And developing in Laravel is quite a lot different to developing in Symfony.
/u/utowel - Looks really nice. Considering giving envoyer a shot for deploying a cougar php app. Got a question that i could not find the answers to. - Would i be able to run DB migrations from envoyer? Thanks and keep up the good work!
This is pretty cool. We built something in house a couple years ago that does something similar. We call it the "Transposer". Helps us to transform client specific data files into our applications standard format. 
It's a standard interface for programmers to get stuff from remote services. Basically the idea is that you can have different types of services that all work differently under the hood but the application programmer doesn't need to care because as long as the library they are using implements PSR-7 then they all work in roughly the same way.
So, according to you, Grand Master of Object Oriented Programming Concepts, C# and Java are not only not *real* OO languages but they're also *broken*. Thanks for your enlightenment. Please do impart more of your wisdom upon us.
Thanks
how will it be a bc break? how would it be major at all?
First of all, not only are you stupid enough not to read what I wrote, but you are also so damn nuts that you put words into my mouth. READ and THEN comment. Besides, first class language? PHP already is a first class language. Just because other languages went a certain route does not mean everyone else has to. Language diversity is a VERY good thing. Jesus christ...
It's not a major BC break because practically nobody uses the ternary in the left-associative way. Had anybody bothered to write an RFC for this, I'm sure it would've been accepted.
I'd ask /u/Rarst or /u/CoenJacobs . They're pretty hardcore Composer users inside a WordPress environment. :)
It supports a conventional way of using http transaction as an object. For example, you will never have to use $_GET, $_POST, $_PUT ... like as seen here, but with http library, everything becomes class/method and you will use instead `$http = new psr\foo\bar\http` then simply do `if($http-&gt;isPost()){}` something like that to check for submitted input. So, the interface is just a way of telling you what your class should look like.
the mail list goes apeshit everytime someone tries to fix it. last time they simply opened an issue, then labelled it 'not a bug' and used that circular logic to prove its not a bug
I take it you couldn't be bothered?
That's a good article regarding URL Rewriting with Apache. However I think URL Rewriting is less relevant than it used to be. With the wider use of frameworks and Nginx, it seems like today it's a better idea (or at least more common) to just forward every request to a front controller and then handle your routing with PHP.
take a deep breath before continue reading.................. google is sort of blocked in China and that's why baidu become #1 so easily.
Well something needs to hold it ultimately. You can smear the logic all over your middleware, but there would still be a *central* part that does request to database and stuff
What confuses me about your idea is, how would it work? Would you have one middleware per route? Or like, per controller, and then conditionals or something? I mean it's an interesting idea, I agree with the core principle, but I can't picture what that would look like code-wise. Do you have a code example?
&gt; What I’m thinking is perhaps a better idea would be to have a Request class that is more like a parameter bag, and has nothing to do with HTTP. This way it could be used for even CLI apps. Like a Command? Eg used with a Command bus like [Tactician](http://tactician.thephpleague.com/)
This is needlessly complicated. If you use a front controller, that is a file (say `index.php`) that handles all your requests, you only need one directive: FallbackResource /index.php For nginx it's similarly simple: location / { try_files $uri $uri/ /index.php$is_args$args; } Only when this is not enough, dive deeper. But if at all possible, make your life easier and just use a front controller.
s/remote services/local middleware services/ surely?
Definitely. You could just add the migrations as a deployment hook.
Reminds me a lot of [Symfony's Options Resolver component](http://symfony.com/doc/current/components/options_resolver.html) which can be pretty handy.
It's code that hasn't been updated/changed when newer versions of a language are released that deprecate code that was previously used. For example, code written in PHP4 that needs to be maintained for whatever business reason (too expensive to rewrite or not enough resources to rewrite).
No. Iterating through `$GLOBALS` with a comparison to `spl_object_hash()` is already a massive hack to do something you shouldn't be doing in the first place. If you want to reference the exact instantiated object within a class, use `$this`. If you want to track the exact object as it goes through your program flow, use the variable outside the object to do so: objects are passed by reference.
You don't. That's not how Composer works. If you can specify the dependency in the main `composer.json` file, you can specify where it needs to be installed. You can't do this to the dependencies of your dependencies (the plugin requiring Redux in this case), as that would become a mess. Can you not load the required files from the main projects `vendor` folder? This is really how it should be done and what you are trying to work around is probably a limitation by the way WordPress works. If you really want the dependency just in the plugins `composer.json` file, leave it there and just do the Composer commands in that folder. That's how I do it in a similar situation as well.
http://www.baidu.com/index.php Actually works. I guess PHP can 'scale' after all. 
Nifty? No, only horrible. I've used this behavior in the past to stimulate things like the "game seed" found in a few card games. 
Zend 1 and Zend 2 are way different. Yii 1 and Yii 2 are way different. Laravel 3, 4, and 5 are all essentially the same thing. There is the justification.
&gt; why is everyone insisting on turning PHP into JS/Java? That is EXACTLY what you wrote. Thanks for pointless attack though.
I'd do it if the deadline hadn't already passed...
If by "internals team" you mean "subscribed to the internals mailing list" (which anybody can do), then yes \^\^
when is this useful in terms of wen applications?
What the hell is going on. I demand a revote. Since when is unanimous acceptable? Hmm? We must have controversy, girls and guys, we must have it! I propose an RFC against unanimous voting. All those in favour please write the RFC for me and say aye. All those against say aye.
maybe we need to just make a voting already on the ternary operator too. thanks for help gixing the constructor, its one of those big php issues that made the entire language seem bad
I understand where you're coming from, but what's the best solution that also maintains backwards compatibility? All the existing functions live in the global namespace, but any newly added functions like this go in a namespace?
http://php.net/manual/es/function.get-object-vars.php this?
Spot on. This is why my company went with Laravel. We were able to see computer science students with no background in PHP be productive after 1 week watching Laracasts. 
It looks good! There are some things that I think could be improved like in `loadClass` method, I would not initialise one instance of every type at once but would lazy load them as they are requested. What's the reason to not do a triple-equal on the `equals` method directly, instead of checking fqcn and name? Just comparing one instance to each other could do the trick I think.
how about drupal? 
To be honest, anything installing with "make install" on my systems seems like a maintenance nightmare. Would be way cooler to build matching packages and put them into a local repository like for example java-oab did.
There is 'Rationale' paragraph, it talks about where it could be used. Basically it's working with non-blocking stuff (be it IO or communicating with other processes, anything), here's a good example of where it would be super useful: https://github.com/amphp/amp
ohh i get it now. thats very tricky, how about if the object is inside an array? or the object itself is a property of another objec? or a variable inside a method/anonymous function?
If you're ever in a position where you feel the need to do something like this, you're doing something terribly, terribly wrong.
While I usually agree with you, I feel like the first 4 bullet points can easily be handled by a CMS. Most of the dev work would be done on the 5th bullet point. Also, the low budget isn't something like $500, it's more like $10k.
&gt; PHP 5.4 or newer is recommended, but CI will still work on PHP 5.2.4 Here's hoping CodeIgniter 4 requires 7.2 (given the amount of time between releases).
looks like none of the documentation links lead anywhere...
Sorry about that, I got carried away and ran out of time :) I hope that the blog post linked from commerceguys/tax at least provided some explanations. In Drupal Commerce 1.x we used rules to handle taxes. However, taxes have become so complex that the number of rules exploded on every single site we developed (1 per country + 1 for B2B is already 29 just for the EU, and that's not even covering all possible variants). So we ended up with a lot of logic that wasn't unit tested. That is why I implemented tax resolvers this time around. You register all of your resolvers (and an optional weight), the first one to return something wins. A single resolver class can replace many many rules, making debugging much simpler. For example, the [EuTaxTypeResolver](https://github.com/commerceguys/tax/blob/master/src/Resolver/TaxType/EuTaxTypeResolver.php) class handles B2B, B2C, physical and digital products, even corner cases such as "US store registered in the UK to collect all EU VAT on digital products" and "thresholds for selling physical products to other countries". I've documented the tax holiday use case and other US exemptions, and I believe that the zone functionality goes a long way towards supporting the country problem you mention. Still, the US system is complex enough that if a store has nexus in a state that uses [destination based sales tax](http://www.accuratetax.com/blog/destination-origin-sales-tax/), the only option is to use a commercial service. In any case, I'm very curious to see where the community takes the tax library. We've already received some great feedback from both FoxyCart and one of our internal teams, which will drive some future API additions.
Nope, I still stand by my statement. Your statements give me the impression you haven't worked with CMSes before.
Yes: https://github.com/bcit-ci/CodeIgniter/blob/develop/composer.json
Hi from a [fellow enum author](https://github.com/commerceguys/enum). I like your PHP 5.5 minimum. Will try to raise my own from 5.4 by the end of the year.
Well it kind of laid dormant for a long time while EllisLabs found a new owner didn't it? They just got this thing a little while ago. I expect new versions to come out a bit faster now
It's not easy at all, but it is super powerful. Still, your scope is huge, which means that you'd need to spend a lot of time getting familiar with many different modules and how they interact.
Codeigniter 3 includes 2 new configuration values related to it. I'm not sure what will happen if users try to extend Codeigniter classes using Composer $config['composer_autoload'] = FALSE; $config['composer_autoload'] = '/path/to/vendor/autoload.php';
no namespaces no composer no phpunit still has "defined('BASEPATH') OR exit('No direct script access allowed');" at every file. DB.php is a function not a class no psr-2 support honestly i wouldn't use it at my projects at all
doesn't composer require php 5.3? one of the features of CI3 is that it supports php 5.2
What's the point?
that feels like having to use cones when everyone else is using wheels.
I've written a package we use internally that does something similar. It takes multiple rows of data from a source like a database table, uploaded CSV file, etc, filters it, transforms it, validates it, saves it to a repository as new data or updated data, and then returns a DTO with data on how many rows it filtered, created, updated, failed validation, etc. The functionality for filtering, transforming, and validation are provided by optional classes specified either by constructor arguments or setters.
All the forum links indexed on google are dead as well.
Then don't call it middleware. Call it a Command Bus or a Chain of Responsibility or a Decorator-Based approach. But middleware has a very defined meaning, please don't confuse it further for people before they get introduced to it.
Thanks....er, that was a test! well spotted!
Exactly. I don't see the point of this at all!
CodeIgniter still supports PHP 5.2, this is totally beyond irresponsible and incompetent. I completely agree with Anthony Ferrara: http://blog.ircmaxell.com/2014/12/on-php-version-requirements.html
Well here is the other thing, I also have an idea to dump the whole HTTP thing in those layers. Instead they would negotiate a request and response format depending on the chain. I explained it in some detail here: https://groups.google.com/forum/#!topic/php-fig/59SLMOqWH6g I think it's a pretty novel idea to project architecture, so I'd love to hear your thoughts =)
It was so promising when these guys took over codeigniter.. I was really hoping to see at least namespaces and psr support. Turns out it's just another pile of crap. (sorry, but it's true)
Yeah, I figured that would be the case. Thanks for the input.
Looks nice! It would be good to mention its ubuntu/debian specific (apt-get). Also I would probably want to use an optional flag or something for the extensions. It isn't clear it installs a couple of php extensions too, and some users may not want those extensions.
Not really. The point of complaining is that it is harming PHP in the long run. Look, we are moving to PHP 7. A lot of good folks are doing great work in other frameworks to take advantage of new features/patterns. The problem with being ass-backwards is that it hurts your career. Imagine learning with CI and then you get hired by a company that uses Symfony2 and some really complex stuff. Oh yeah, you'll get laughed at when you don't understand: namespaces composer phpunit psr-2 and look like the very junior programmer that you ARE! So tl;dr codeigniter developer = junior developer
I am working on a patch for language-level enums. I don't have an RFC because I don't want to commit to doing it just yet, but it seems relevant to share what I have so far. The syntax is like this: enum Color { Red; Blue; } Note the semi-colons instead of commas. This is so they are as similar to Hack's enums as possible, but I'm not sure about that decision. What do you guys think? Some features of language-level enums that hopefully happen: - Use `Color::Red` syntax (no property/method magic) - Can use them in type checks, meaning `function f(Color $color){}; f(Color::Red);` works as expected - Can use them in switch cases - `Color::values()` to retrieve an array of all the values in the enum - Can compare them with `&lt;` and `&gt;`, since enums have a natural order (the one you defined them in)
Maybe in the future it will get more modern
It doesn't matter if the file is not accessible via the web root. If it is (which most CI projects are), this prevents a direct access to the file. Which you can also do via .htaccess and whatnot, but this bakes it into the code and leaves less for the end user to deal with.
I was super excited when I first started learning Laravel too. Laracasts is awesome. Dayle Rees has a great book for Laravel 4, that will still be very useful learning 5. The companion site is a great resource by itself - you can find that at http://daylerees.com/codebright. When I got stuck learning about the Symfony framework was helpful, as most of the laravel components are built on top of Symfony components.
Err.. first of all, Yii has been out since 2008. Secondly, Yii1 and Yii2 are two completely different Frameworks. Yii2 is a complete rewrite that carries on the spirit of the original Yii ([source](http://www.yiiframework.com/news/76/yii-2-0-alpha-is-released)). Laravel 5 on the other hand is just a new version and even largely backwards compatible. You can get even large L4 apps running as L5 apps in 1-3 hours. Same for Zend1/Zend2 and TYPO3/Flow, two completely seperate frameworks.
Better practice is to have those files outside of the 'web root', so they are completely inaccessible by the browser. If you look at the file and directory structure of Laravel or Symfony (for example) you'll notice this is the case, with a fairly sparse 'public/' directory which only really contains your web assets an a single index.php.
Hmm, to be honest I don't like the hack implementation of enum. ~~It forces you to define scalar values for all enum values while most of the time you don't use the value assigned to the enum value.~~ **edit:** Ah, I must have misread, you don't force the enum to have values.**/edit** My personal preference however goes out to java-like enums where enum values need not be assigned a value but are always singleton objects that can even implement abstract methods defined in the enum. You can use them as simple enums like you explained them, but the Enum values also are anonymous classes implementing the abstract methods of the enum. When there's no abstract methods there's no need to define anything making them plain enums. If you don't know them yet you can study the java enum library for details: http://docs.oracle.com/javase/tutorial/java/javaOO/enum.html. They are pretty awesome imo. If you don't like enums as objects but would rather keep them simple, I'd go down the C# lane where enums are restricted ints(well, sort of) and manually defining a value is optional, for details look at https://msdn.microsoft.com/en-us/library/sbbt4032.aspx Tl;dr, this is my personal dream scenario: enum SimpleColor { RED, BLUE // maybe ';' ? } enum AbstractColor { RED() { public function asInt() { return 16711680; } }, BLUE() { public function asInt() { return 255; } }; // Must be implemented by all enum values // Could also be inherited from an interface public abstract function asInt(); } enum ConstructColor { RED(16711680), BLUE(255); private $intVal; // Must be called by all enum values private function __construct($intVal) { $this-&gt;intVal = $intVal; } public function asInt() { return $this-&gt;intVal; } } 
I think it was the right decision not to split up the Laravel versions. Laravel 5 is just an update to Laravel 4, sharing pretty much all of the codebase. Looking at Zend 1/2 and Yii 1/2, they are complete rewrites sharing pretty much no common code. They *are* seperate frameworks.
Priority for these "guys" was to finish releasing 3.0 which was supposed to be PHP 5.2 compatible from the start (and took lot of effort to remain so, so they did not want to scrap all of that). Only now after releasing it they are not tied to PHP 5.2 anymore and we can expect PHP 5.3+ features.
For people with old CI Apps they also released bug fixes for 2.x which are worth getting.
to be fair, "it's complicated to migrate my companies work" is a comparably weak argument against or for any technology. It might not be suitable in that particular case, but that should not be used in a general discussion. It's a bit like saying C++ is a weak language, because you wrote your game in Java and don't want to change your project now... /fewcents
Laravel uses [Composer](https://getcomposer.org/) I'm still looking into it, but I like what I see so far.
&gt; yii2 has been out just a couple of months. thats completely truth &gt; Yii2 is a complete rewrite that carries on the spirit of the original Yii sure, still people who use yii1 would probably want to move to the next release of
Right now, PHP-DI and Symfony mashed together. I have two composer projects, one is a domain-model which is wired with PHP-DI, and it defines some interfaces (i.e. repositories for save/load.) Anyone who wants to use the domain-model has to provide concrete implementations to PHP-DI. The second project is the main Symfony site, which uses the domain-model as a dependency. The Symfony-side uses its own DI to wire up services and repositories, and supplies them when it initializes the domain-model framework. (The configuration for this lives in its own web-page-less Symfony bundle.) I chose PHP-DI because I wanted (A) constructor autowiring and (B) "lazy" loading, since 99% of the time only a few of the many possible command-handlers and repositories will need to be loaded up and used to service a given web-request. I *could* have used Symfony-DI in both places, but I really wanted to emphasize that the domain-layer is separate from MVC/UI concerns. So far it seems to be working OK, mainly because almost all the wiring flows in a Symfony-&gt;PHP-DI direction. The opposite is not as automatic, and the one place it happens I just inject the set up the Symfony service to "pull" its dependency out of the DI layer.
Pimple is nice because it's so damn small and simple, plus it's compatible back to php 5.3.2, which is sometimes important. But other containers you will find offer a much more full feature set. ~~Laravel's container is fully decoupled from the framework and you can easily use it by requiring "illuminate\container" in your composer.json. I've used the Laravel 4 container in non-laravel projects in the past because I was already familiar with its syntax, it worked great.~~EDIT: See comment below. [The PHP League also has an excellent container](http://container.thephpleague.com/). Really I feel like all the options you have listed are excellent. Aura and Symfony both make high quality components. Just take the containers that meet whatever your base requirements are, throw them into a hat and pull one out. You aren't going to go wrong. The only one I have reservations about is Zend and that's just because I have no experience using ZF2 components whatsoever.
if you initiate with header('Content-Type: text/html; charset=utf-8'); php should use utf8 internally as a default. At least that's how I do it for quite a while now. I think I haven't made anything iso-formated since html5 came out. I think the thread you linked only talked about making it a default. But I admit I only read it in parts.
its bad for autoloading. what if i have a project that only requires a handful of CI classes and i don't want to bootstraps CI for example: i don't want to bootstraps ci, just use the db conection.
I agree, and sorry I could not add more examples before on why people will keep using Codeigniter.
Oh, that's a part of Laravel then, as OP said. Thx.
Still not quite ... composer is not "part of" Laravel, though Laravel does leverage it to great effect. Composer is a completely independent open source project that is now used by most major php frameworks and libraries for dependency management.
my point is this. many people still use yii1 because yii2 is fairly new and they are still learning. how to use it or haven't get a new project to test yii2. 
There are composer packages. https://github.com/alexbilbie/Proton have a look at this - how easy is to make your own framework. If you just need something light, have a look at silex or slim.
That kinda says it all
Exactly. And the same is not true for Laravel. L5 is just an iteration. Nobody would start a new project with L5 *"because it's still new"*... because it isn't.
"If simple stubbing and mocking is not useful enough for you" That's a handy feature to have, regardless of if you like it. A lot of people mistake "I personally wouldn't use this feature." with "This feature has no use." which is at the very least short sighted.
we will have to endure that shame on php 7. i hope for php 8 thats the first rfc on vote
Sorry, I'm letting people to think for themselves this time.
&gt; Laravel's container is fully decoupled from the framework and you can easily use it by requiring "illuminate\container" in your composer.json ~~This is true for Laravel 4 but [not the case for Laravel 5](http://www.reddit.com/r/PHPhelp/comments/2znaxz/what_happened_to_the_helper_app_in_laravel_5/).~~
&gt; how do we not cause major bc breakage? Breaking backwards compatibility shouldn't be seen as the ultimate sin. We do it all the time. I doubt code written for PHP 3 would run smoothly in a PHP 5.5 environment. The trick is to make the changes *slowly* and give developers plenty of time to adapt. Moving core functions into namespaces would happen around PHP version 9 or 10. But a journey of a thousand miles begins with a single step, and we're not even taking that first step. We can start moving in the right direction *now* with the goal of a complete change over to namespaces somewhere in the distant future. We could, for example, add the `PHP\Strings` namespace to PHP 8 which contains a `strlen` function, while still having a global (but depreciated)`strlen` function. In PHP 9/10 the global function is removed, which would give developers years to update their code. While we're in the process of moving functions into the `PHP\Strings` namespace we can fix the inconsistent naming and argument orders, which kills two birds with one stone. For example the global functions `strlen` and `str_repeat` become `PHP\Strings\length` and `PHP\Strings\repeat`.
yes. as I said. Laravel uses Composer, a seperate tool, for package managing, but has it's own internal dependency injection container. I might not have made that clear enough though. 
Maybe you are aware of this but just in case: http://php-di.org/doc/frameworks/symfony2.html You can integrate PHP-DI to Symfony.
That's not true. Here is the L5 Illuminate Container package: https://github.com/illuminate/container/tree/5.0 It has one external dependency - an interface - and it's composer.json is extremely clean. You can pull in and use Illuminate/Container independently like you could before. Reddish_Radish is actually correct. The link you linked to has nothing to do with the container's independence - it's just referring to the location of the `app()` helper function that provides global access to the container if you want to cheat a little...
Yup, i know. I just havent taken the plunge yet....
[Auryn](https://github.com/rdlowrey/Auryn) - because it does DI correctly. 
Oh yes please! &gt; Note the semi-colons instead of commas. This is so they are as similar to Hack's enums as possible, but I'm not sure about that decision. What do you guys think? Very good choice. Honestly it's like tabs vs spaces, everybody has its own preferences. Hack compatibility is a good argument, especially if it's the only one. Autoloading is essential but you mentioned it in another comment. &gt; Can compare them with &lt; and &gt;, since enums have a natural order (the one you defined them in) I'm not sure about that, it wouldn't feel natural. Have you considered letting enum options have a value? You would need to add a new `-&gt;getValue()` method or something similar on the value.
Just... wow. I love this! If you made a full query provider for MySQL I'd be all over it.
Check out PHPixie. It's as easy as CI and Kohana but with autoloading, namespaces, orm, templating etc. New version supports Mongo, custom compilers for your templates etc
Their site isn't responsive, which is a bad start...
&gt; im not sure if Google Search Trends are a good tool for China yea, thats why i said: ...im not sure if Google Search Trends are a good tool for China
Ah, I should have explained more clearly: if you don't have any abstract methods the enum should just look like the first code snippet in my reply, so the whole method-stuff is only required when there's an abstract method.
You might get voted down but I think you're absolutely right.
I learned about dependency injection, dependency injection containers via Aura.Di . It served my needs, and is easy to use. I know a few people who love the same and contribute in one way or the other.
So instead of using something standard which has a ton of tutorials, help articles, and screencasts you suggest building your own framework out of components that don't necessarily go together easily? Brilliant! /s
This content is ripped. Copy and paste a few of the paragraphs into Google and you'll see the author just ripped off other peoples answers.
That's because he stole all the content.
&gt; Why exactly are using two DI containers? If you mean two instances, it's because the domain-model part is it's own independent Composer project and repo, meaning independent versioning and unit-tests. Most of the wiring inside it should not be alterable by the outside web-environment. My fear of using one Symfony container for both would be that it could cause undesirable coupling, forcing us to upgrade them in lockstep. &gt; If you leave your domain model plain PHP The domain objects are all direct PHP, but there's also a Command Bus which routes each Command to the appropriate Command Handler, and each Command Handler needs a different selection of repos/services. Since most of the time the system will only get one Command per startup (e.g. a form-post) that means only a small portion of the handlers (and *their* dependencies like repos) ever need to be loaded. That's where the lazy-loading is a win. &gt; I.e. if you want to expose your domain model to Symfony2 you'd create a Symfony2 Bundle for your domain model. There's a Bundle which connects the two DI systems, provides Doctrine ORM XML configs, and creates a Symfony-centric "Command Runner" service. The "runner" just wraps the Command Bus with (A) Doctrine transactional logic and (B) timing and logging information for display in the Symfony Profiler. However, that bundle does not contain the Domain classes, nor their core wiring. Those still live outside the Symfony project, via Composer dependency. I'm trying to get the company to move to a model where we can develop new logic in the domain model *first*--along with nice unit-tests and quasi-BDD stuff--and *then* create all the nasty UI code in the Symfony project.
You're actually right.
The framework website FRONT end means nothing in regards to the actual framework.
I know that solution but trust me there're people who don't know how to do that. 
Good to see. IT needs more female voices, so it's good to see you giving that opportunity.
I suspect if that many choices exist, you may actually be dealing with a "value object" type.
I would recommend it. Last year was super value!
That looks really nice, I have a few toythings that I tinker with to learn and experience coding without whole frame works and this looks really nice.
Dude, in 2015 we still do the routing in that way? 
Thank you for your feedback. I would like to respond with two points I think are important to bare in mind: 1. The call for papers has just opened. Like 2 or 3 days. It is highly unlikely that all the women who were going to apply have applied. I do not know how many have applied, since I have nothing to do with the conference organisation. 2. I am friends with the organiser and [based on the conversations I have had with him] I don't believe there are any quotas to fill. This is simply a case of organisers and community members wanting to see more women speak at the next conference. &gt; So, while the gender disbalance is worrying, sometimes you have to decide what do you care about more: superficial appearance of diversity, or quality. They are not mutually exclusive. Of course I could always improve the ways in which I communicate these things. My message is still that we are seeking more women speakers. And I believe that brilliant women speakers may find out about the conference as a result of the few messages I've sent about it today. :)
Even though I use them fancy PHP routers and so on myself, we have to admit that just because there's something new and shiny around, doesn't mean the boring old way no longer works :)
Here are two great articles about how to get more women to speak at your conference : * [Beating the Odds — How We got 25% Women Speakers for JSConf EU 2012](http://2012.jsconf.eu/2012/09/17/beating-the-odds-how-we-got-25-percent-women-speakers.html) * [How I Got 50% Women Speakers at My Tech Conference](http://geekfeminism.org/2012/05/21/how-i-got-50-women-speakers-at-my-tech-conference/) Unfortunately, as /u/BringTheTanks already told you, just asking for more women is not enough. But anyway, it's great that you are ready to take some actions to promote diversity ! Thank you for that !
Come on man, for quick and dirty projects there's no better option. I use it for a bunch of scraping, batch processing, db querying and 10-pages-for-a-1000EUR-in-a-weekend client side projects that run on shitty shared hosting servers. You can't beat unzipping a tiny package, change a few lines in the config file and be ready to go, without ever having to even consider what's running on the server. Previous company I worked for did very well building commercial sites in CI. Never did we sit there crying about "I need namespaces!". Also for noobs to learn a framework, get to grips with MVC I doubt you can find a better solution. Nothing "just works" straight out of the box like CI does. Laravel is completely awesome, new features in PHP are very cool - I completely agree. When I first checked out Laravel say 1,5 years ago and asked the question "should I use V3 or V4 for production" nobody could give a clear answer. Now I work in fucking Zend and we have constant problems with the latest versions of PHP having weird PDO bugs, composer updates destroying an entire project for fuck knows what reason. Keeping everything up to date and dealing with the problems caused by constant updates takes up way too much time ... Sometimes I miss quick &amp; dirty.
Replacing a fancy word does have the additional benefit of augmenting our way of thinking though. Naming it differently and providing a clear mechanic of how it can be utilized may nudge devs into the right direction. Though I do agree with your point, hence the "Were we using middleware all this time?" part
While I agree with Anthony's point, the fact is that CI are targeting a large portion of users who still have PHP 5.2 hosting. Not everyone is in a position to dictate what hosting users have - really we need Wordpress to ditch 5.2 first.
I like it how the most popular comment, + gilded, starts out with that it "probably won't be a popular comment". Trust me, the boy's club approves of your comment.. (Not trying to invalidate your points)
yes. I confused that in my first post, was corrected and agreed that I made a mistake. Thanks for summing it up again... 
As far as I know, php does not read the header, but if you use php to call the header, not plain-text html, php will take it. But I agree that the string-operations regarding utf8 could use some optimisation. 
The code you present also uses `ReflectionClass`, which is the biggest drawback of enum-libraries. In contrary to phenum you do not have shorter syntax (`Color::RED()` vs `new Color(Color::RED)`) and the instances of one enum-value are not singletons: // Using your library the following code will give 2 instances of Color $color1 = new Color(Color::RED); $color2 = new Color(Color::RED); // while when using phenum these variables will point to the same object $color1 = Color::RED(); $color2 = Color::RED(); So using phenum you could argue that Color::RED() is a singleton, Color::BLUE() is a singleton, etc.
"Looking for women to speak at PHP New Zealand" FTFY
As far as I'm concerned your gender should be irrelevant in the decision making process. The whole point of equality is that we don't discriminate based on what you are. So with that in mind, an anonymous selection process is a fantastic idea and I strongly encourage this process because not only should it help with the diversity (unless you get really unlucky) but it's means that the selection is based on merit and not a quota.
So now the only difference between our implementations is that phenum has "constructors" (which they aren't strictly speaking, but they pretty much work that way) that allow you to set up the singleton instance on an enum value individual basis. If you were to add that to your code and the add some phpdocs, because you should have phpdocs when publishing your code, you'd pretty much end up with the implementation of phenum, in terms of size and functionality. &gt; For the methods, I'm reluctant. I'm not fond of magic methods either, but in combination with the phpdoc method-hinting, it works pretty neatly. I'd much rather delete this library and use native enums, but until we have those I'll stick with this. **edit**: ~~I was just wondering, will your code work with 2 enums having different values? Won't they share the private static arrays, making the enum loaded second not work?~~ **edit2**: ~~Here's an example of what I mean~~ **edit3**: No need for an example since you were doing it right all along. My bad.
Paying customers dictate what version of PHP is available. If you are using a shared host who refuses to update, move to a different host... That's the message responsible framework development teams should be putting forward.. not "lol we'll just continue to support PHP 5.2 and oh look we wear our shoes on our heads". 
I used to do the same thing, but it meant a lot of duplication everywhere. The argument against a simple inline callable, again, is just better structure and reusability. [Fractal's docs have a similar explainer.](http://fractal.thephpleague.com/transformers/) But yea, if you don't see the benefits, that's fine, you don't have to use it. I'm just providing free software here. :)
I wasn't trying to make it seem like closures and classes are mutually exclusive. In practice, sometimes you want it reusable, so you make a class. Sometimes it's one off, and you want it inline. Another way to reuse is by returning these closures from a factory (static or not). I'm just trying to drive a point that it shouldn't be so rigid, because even Java (which the PHP community seems to copy a lot) is not so rigid anymore. In Java if I pass a lambda to a method expecting an object of interface Foo, I can. In PHP I can't, and if you typehint your methods to expect an interface, closures can't be used directly. This results in pointlessly verbose code scattered around files with couple of lines of logic in each.
Yeah man. Fuck everyone who isn't like me. 
I am *quite* definitely not talking about asynchronous code here... In practice reusable vs once-off cases for input filtering are close to 30/70, which is quite natural as often the input you filter contains a service-specific command, which contains a reusable piece of data (say entity of some sort). The entity is reusable (and its filters *will* be reused), the command wrapper around it with related details however isn't. In this lib you have statically codified some current practice of how you split the work, but when you find one more place to split it would you add more interfaces? How many filtering stages you have is situation specific. Codifying it as a fixed set interfaces implies I need to always have the same number of filtering steps with the same semantics, which means sometimes I have more than I need, and sometimes less than I need. So giving up that liberty requires some solid reason IMHO.
Again, I'm providing free software here. I only have so much time to educate people. If you don't see the point, then don't use it. It won't hurt my feelings. A decent amount of people seem to get it. :)
I'm fully open to the idea I just don't get it, so to speak, but please don't use "I provide free software" as a reason to shut down a debate. It makes it worse for everybody.
&gt; There is an old RFC to make such a Comparable interface part of the PHP core, that recently has been reanimated:. It would be great to see this as native feature in PHP 7.x, If it's already usable, why should it be added to the core? What would be the benefit? 
We use ZF2's DI. It's a bit of a bitch to set up and is inefficient as hell out-of-the-box but if you do manage to configure it right its pretty decent. It can be used independently of the framework, as well as using it with ZF2 apps we're also using it with our Slim apps (just because we'd gotten used to it / had put time into configuring it).
The way you put it sounds like the selection will be preferential for women, even though maybe it is not. The speakers chosen should be chosen according to their contributions, race and gender should be completely irrelevant.
For those that might not read the UString RFC, its proposing an extension to work with UTF8 string that is enabled by default and ships with core. If it doesn't get into PHP 7.0 (and it does look like that ship has sailed), it could still be part of a 7.1, 7.2, or future release.
No that's different. The talks have to be judged on their own merit. It is bad when people favor male speakers to female ones, but when someone is actively looking for female speakers, just because he wants to have diversity it's hurtful to the community in general. How would you feel if your talk was accepted not because of the hard work you put into it, but just because you are part of some demographic? I would hate that
Generator delegation is about concurrent processing; it's not about CLI vs. web SAPI applications. To understand how this functionality can be used let's think about what has to happen in order for us to multitask processing tasks ... **A Multitasking Use-Case** * We dispatch some unit of work in the form of a function call; * the function returns *immediately* even though the task hasn't completed yet; * we continue doing other things while the async operation initiated in step #1 is happening. * ??? * Profit! So how do we know when that other work has completed? Traditionally we use callbacks and you might do something like: function myAsyncThing($foo) { asyncThingFoo($foo, $onComplete = function($error = null, $result = null) { if (empty($error)) { asyncThingBar($result, $onComplete = function($error = null, $result = null) { if (empty($error)) { // handle error here } else { asyncThingBaz($result, $onComplete = function($error = null, $result = null) { if (empty($error)) { // handle error here } else { // and the nesting continues ad nauseum } }); }); } else { // handle error here } }); } Now this is fine, but it quickly leads to a situation where your entire application happens inside callbacks and becomes very difficult to reason about. Before you know it your application is moving horizontally much faster than it's moving vertically. It's tough to write code this way and even tougher to read code that's written this way. Not to mention error handling is notoriously difficult because if something goes wrong your stack trace is far-removed from the code where the actual problem occurred. This is what people often refer to as *"callback hell."* So what we want to do is write asynchronous code that looks and feels similar to how we write normal synchronous code, right? This is where generators come in; remember that generators are nothing more than suspendable functions. This means that we can manipulate generators to wait for asynchronous operations to complete and subsequently resume where we left off when they finish. So let's do away with the callbacks from the above example and instead assume `asyncThingFoo()`, `asyncThingBar()` and `asyncThingBaz()` functions return a "placeholder" object for the eventual value which has yet to be resolved. This placeholder is generally referred to as a `Promise` and it exposes methods like `Promise::then(callable $onSuccess)` so a holder of the promise can be notified when the operation completes. We can now rewrite our above function as a generator like so: function myAsyncThing($foo) { $bar = yield asyncThingFoo($foo); $baz = yield asyncThingBar($bar); $bat = yield asyncThingBaz($baz); return $bat; } In the new generator function we simply yield a `Promise` any time we have an operation we want to wait for (and completely eliminate callbacks). We only need about 40 lines of "framework" code to create coroutine functions to automatically resolve generators which yield promise objects. Frequently this sort of thing happens inside of a non-blocking event loop and the asynchronous operations use that event loop to resolve their promised results. **So How Does Generator Delegation Figure In?** Generator delegation using the `yield from` syntax makes it much easier to write code in this way because we can break up the various parts of an operation into multiple generator functions instead of having one monolithic generator. This is the same governing functionality employed when we split up object functionality into smaller instance methods. The coroutine that processes yielded `Promise` objects from `myAsyncThing()` in the above function doesn't care where the promises come from -- only that they are yielded. `yield from` allows us to factor out generator yields into multiple subgenerators like so: function myAsyncThing($foo) { $bar = yield from asyncThingFoo($foo); $baz = yield from asyncThingBar($bar); return $baz; } function asyncThingFoo($foo) { $async1 = yield someAsyncThingReturningAPromise($foo); $async2 = yield someAsyncThingReturningAPromise($async1); $async3 = yield someAsyncThingReturningAPromise($async2); return $async3; // returned to the $bar expression in our top-level generator } function asyncThingBar($bar) { $async1 = yield someAsyncThingReturningAPromise($bar); $async2 = yield someAsyncThingReturningAPromise($async1); return $async2; // returned to the $baz expression in our top-level generator } The above example code should make it clear that `yield from` allows subgenerators to pass through their yielded values as if they were part of the original top-level generator. Meanwhile the `return` value from the subgenerator is used to fulfill the value of the `yield from` expression in the parent generator. **Summary** It's important to realize that `Generator` functions are not inherently concurrent. You can't dump synchronous code into a generator function and magically parallelize it. It is the capacity of generators to act as *suspendable* functions that allow us to use them in conjunction with a task scheduling mechanism to function as lightweight threads of execution. Generator delegation is simply a syntactic feature to simplify coroutine-based concurrency in userland.
Thank you for this explanation. I am more than familiar with the observer pattern that is "callback hell". However, this "promise" pattern seems to me as if it does the exact same thing; which is handling expected future values. However, the main difference here is that a regular callback is run when the task is done while this yields expected values continuously and "in real time". Did I get it correctly? if so is the case then it is basically an observer pattern that is called multiple times during Async execution rather than just once when the task is done.
Ok, let's start with basics. All you need is a class with a set of one-liner methods returning an instance: function userRepo() { return new SpecificUserRepo(); } If that instance requires dependencies, call container's own methods to resolve them: new UserRepo($this-&gt;userSqlDb()); Every "new" call gets its own one-liner method (except for transient objects of your choice), so there's one "new" per dependency. This keeps your code "DRY". Make methods protected or private, except for the 2-3 dependencies you want to fetch at your application root. To create single instance you have a wide range of options, but I'll give you the most banal one: protected $sql; function sql() { return $this-&gt;sql ?: $this-&gt;sql = new Sql(...); } When you're done (5 minutes later) you'll have one of the shortest and most-easily written classes in your project and it's your app container. It's easy to write - you're simply calling constructors, almost declaratively. Just like container binds! Except... without the container libs. Let's see what we avoided: third party deps, string configs, array configs, XML, YAML, annotations, parsers, runtime or build-step code gen, reflection. Not bad. When you are ready to start your app, make an instance of your container, grab an instance of your "starting" dependency, and away you go: $container = new AppContainer(); $router = $container-&gt;router(); $ctrl = $router-&gt;route($url); $dispatcher = $container-&gt;dispatcher(); $dispatcher-&gt;dispatch($ctrl, $inputs); Did I miss anything? Let me know which features you're missing from your favorite container and I'll show minimal code reproducing them with a simple class with methods.
When there is such poor representation of one gender it is necessary to take active steps to redress that, to make a deliberate effort to change things. If there's a problem, and IMO there is but that's just my opinion, then changes don't happen by continuing with business as usual. And part of that is helping this one group gain a voice. Is that such a bad thing? You are seeing it as hindering one group, not helping another. That's a matter of perspective.
The change should come from other side, from increasing the number of active women developers. Groups like PHPWomen and RailsGirls increase the actual nmber of female devs. Selecting people for conference based on gender, and even worse, actively looking for speakers of speciic gender if none applied is fixing the symptom and not the problem. People downvoting my toplevel comment think I'm somehow hating on women or whatever, which I'm not. I'm just concerned that conferences try so hard to "look good" instead of actually "do good"
I find that pretty gender discriminatory that you'd specifically ask for **female** speakers. I mean, you're making it sound like you'd turn people down just for being male. If you get a quality female speaker you'd be an idiot to turn them down based on their gender. Inversely, if you get a quality male speaker you'd be an idiot to turn them down based on gender. Equality comes when you stop seeing gender as a factor and you start treating people equally, not when you force the issue.
Save memory with this simple trick. 
Not worth the time changing how you echo over any performance gains this may get. http://www.electrictoolbox.com/php-echo-commas-vs-concatenation/ Even with 4 million echos, the difference in speed is negligible (as shown in the above bench marks). You are better off learning how to cache and optimize slow parts of your application. We are not hand coding assembly any more, this kind of optimization is pointless.
Heaven forbid someone make an effort to actually let a fucking woman have a say.
A little bit yes and a little bit no :) I wouldn't necessarily conflate this with the observer pattern. Promises are in the realm of functional programming. You call asynchronous functions and they return their "result" immediately (or a placeholder for that result in the case of a promise). You're simply using generators to make writing that asynchronous code feel like it's synchronous and handle errors via try/catch instead of endlessly nesting callbacks. An example of the functional nature of promises demonstrates how we could use them in a framework like the one described above to process many tasks concurrently: function() use ($dbClient, $httpClient, $redisClient) { $dbPromise = $dbClient-&gt;query(...); $httpPromise = $httpClient-&gt;request(...); $redisPromise = $redisClient-&gt;key(...); // flatten the individual promises into a single promise // so they can all execute concurrently and await resolution $flattenedPromise = all([$dbPromise, $httpPromise, $redisPromise]); try { list($dbResult, $httpResult, $redisResult) = yield $flattenedPromise; } catch (Exception $e) { // async error handling is easy! } };
Does anyone actually use parenthesis with echo?
I believe in equal opportunities regardless of gender. So imagine you have a free spot to fill in and you have 2 talks by new speakers: * One is a guy who clearly took a lot of time to think the talk out, the slides are nice, the talk is on an interesting non-generic subject etc. * Other one is a decent talk by a girl, its good but of the "run of the mill kind", nothing really special. You sau you'd reject the person who clearly put more effort in just because you want a woman to speak? Does that even sound fair to you? BEcause it doesn't to me. Sex equality means that men and women should have **equal** opportunities and be held to the **same standard**. Inversing sexism is not fixing it.
you're right, there is no point choosing print over echo for speed. The focus is on memory here.
Nope - not all performance is about measuring raw ops/sec. I agree that if it's running fine with `echo 'some ' . $stuff;`, you really shouldn't go back through your code and change anything, but the main reason to use commas is to avoid allocating extra memory for long string buffers. It won't matter if you're saying `echo 'Your name is ' . $fullName` or `echo 'Your name is ', $fullName`, but it could matter a lot if I'm dealing with sets of 30MB+ strings, e.g. `echo '{0:' $bigString . '.1:' . $biggerString . '2:' . $biggestString . '}'`. Especially if you're processing requests in parallel, you could end up with 10 requests * 90MB buffers hitting 900MB -- enough to exhaust many of the servers that might run your code. I'd caution against simply recommending commas as being generally 'faster' though. I haven't checked in Zend, but the compiled instructions in HHVM can actually be faster with concatenations vs commas. If you have a bunch of string literals, then you're actually hurting (though not by much) your performance, microoptimising yourself backwards. e.g. `echo 'Hello' . ' ' . 'world!'` is given as only one instruction (a single echo of 'Hello world!'), while `echo 'Hello', ' ', 'world!'` actually compiles to 3 instructions (stdout 'Hello', stdout ' ', stdout 'world!') As a rough rule of thumb, any echo you do with `&lt;?= ?&gt;` or to echo out variables that are human readable, just keep it to `.` for consistency. If you're echoing out variables that are loaded from a file or some stream that could be arbitrarily long, use commas, and make sure you put a comment directly above indicating why you chose that usage.
&gt; You sau you'd reject the person who clearly put more effort in just because you want a woman to speak? I said no such thing. Fuck I hate when people do that. What I am saying is that this is actually a hugely complicated and difficult question. I've struggled with it in my life too. For quite a few years I ran a popular video games website with volunteer writers. When we put out a call for writers we always got a lot of applicants, hundreds of them. But we always wanted diversity. I'm not saying we had boxes to tick, I'm saying we wanted personalities, not bylines. We wanted gamers who were married with kids, and ones who were single mums, and ones who were older, and ones who were students, and ones who were gay and so on. Not because we wanted to fill any arbitrary quotas, but because we wanted to represent aspects of our audience. And that includes women. The vast majority of the applicants we had were men. Specifically young, 18 - 25 year old straight white nerdy men. Now the vast majority of applicants could be dismissed immediately. Not because of this, but because they just couldn't write well enough. But even so, the pool of male applicants dwarfed female. Taking always and only the 3 best writers, would probably leave us at 100% straight white male writers. But that wasn't our only criteria. There were others. One was who do you represent? Is there a demographic or market we're not currently speaking to well? (For example, we hired one girl purely to target competitive esport style gaming.) If someone was gay... yeah, you know what, that's a voice we want to hear more from. Different ages, different races, different life circumstances or capabilities, different time commitments. But I'll say one thing... we didn't hire people who were bad. We just made our criteria and requirements more broad and valued criteria **in addition to** grammar and spelling. And yes, we valued diversity for its own sake. Because we wanted our readership to be a diverse audience, and we wanted to represent gaming as a broad church, not a monoculture. Even if in some ways it **is** a monoculture we wanted to make changes, to show an idealised view, not a uniform face of a boy's club with a token female. And I'll tell you what... you could never tell. You could never tell who was going to be a great contributor and who would be meh. Both genders put out some amazing content. Some people we gave a chance to largely on the basis of gender did exceptional technical work. So yeah. I'm not talking about taking someone who does a "run of the mill" talk. I'm talking about giving someone a chance. Don't assume the talk is going to be run of the mill before you hear about it, and maybe give someone an opportunity to put their talk in. Don't give them a free pass, but at least give them a second glance. To me it comes down to two simple questions: do you think there's a problem with representation of women in IT? And do you want to change it? If you want to change it, then sometimes men **have** to step back for women to step forward.
As I said, I am new to php -- apologies if I have expressed my problem incorrectly: Even after what you said (if I'm understanding you correctly), I still believe this seems CONCEPTUALLY correct, as the web server CAN talk freely to the main server, so why not? There is no magic here, or no type of firewall bypass, it is simply the client cannot talk to the main server but the web server can (the file is on the web server, not the client, so again why not?). The PHP snippet is running in the middle after a user logs in -- it checks with the main server to see if user/pass is correct, then returns a JSON true/false value and fail reason, if failed: This is a wifi captive portal, where users cannot get internet until they login first. There is nothing "bypassing firewall"-esque about this, as the web server IS the firewall, if you've ever used pfsense. Client &gt;&gt; Web Server (PFSense) for Captive Portal &gt;&gt; Main Server (logs in through RESTful service) So Client gets redirected to web server login page &gt;&gt; client attempts login &gt;&gt; php from WEB SERVER in middle sends curl REST query to main server &gt;&gt; Main server returns true/false to the web server &gt;&gt; via AJAX javascript reads the return value &gt;&gt; if true, log user in and grant internet. Is there a special way to communicate server-to-server that I'm doing wrong? The client's firewall should have nothing to do with the php file on the web server talking to the other side -- should be the web server's firewall .. (EDIT: My point is... I can do the same thing with AJAX with javascript or jquery, so what is the point of PHP if it seems to be running from the client side instead of server side? I must be doing something wrong (EDIT 2: Or perhaps I'm blaming the PHP when I should be blaming something else? Maybe it was just a coincidence the firewall at the time seemed to be effecting this -- are ALL curls run server-side?) *Brain Explodes*
&gt; or would you like to watch an hour long sub par talk on a topic that the speaker has no spectacular experience in I've seen that happen a lot. Speakers who were ill prepared. Speakers who didn't have experience. Speakers who weren't experts in the subject matter. Speakers who had passion, but nothing spectacular to say. And you know what? It had nothing to do with their "chromosome configuration". Every speaker goes through those phases. The problem is that people like you sit down and point to their chromosomes as to why they are speaking, whereas for a man with the same issues you just say "eih" and move on. Speaking is an incredibly difficult thing to do. Trust me, I've been doing it long enough. I've personally had all of those issues. I've given talks on subjects that I wasn't comfortable with. &gt; hosted by someone how earned the place based on merit Way to make imposter syndrome worse. Way to trivialize the complexity of the situation. &gt; You'll know it when you see it and it's pathetic to watch. No, what's pathetic to watch is complaining about how unfair it is. Without actually understanding the situation or realizing that **they aren't offering speaking slots based on gender. They are asking women to submit proposals to be selected fairly**.
It's not that there are "barriers". Its that they're **not applying**. They're not interested. College admissions and graduations, etc, are around 12% female. That's what I'm talking about. 
I just did a bunch of this for a medium-sized enterprise type application. I built in Laravel, which makes it easy to run scheduled jobs and send emails, but the generic steps are: * Write a PHP script/command/class that looks through the database and grabs all rows where your date field is &lt;= the current date/time at the time the command is running. * If your command found any suitable records, build your emails and use something like PHPMailer or SwiftMailer to send them. Hopefully you're using an SMTP service like Mandrill or Postmark to send email. * Schedule a cron job to run at specified times and call the command you wrote in step 1. In my application my email alert commands run hourly. * Profit 
I think it is important to increase the number of females in the field but as a female I find this is the wrong way. I am sick and tired of female quota jokes at my company ( I am the only female) and I am sick and tired that clients don't take me serious. But enforcing a quota in any way wouldn't fix that. I fear it would make things even worse, because people will think the speaker is only there because she is female and not because of what she has to contribute to the conference.
&gt; But we always wanted diversity. I'm saying we wanted personalities, not bylines. Exactly, so what you wanted were people having different perspectives on the subject. It's like getting a conference speaker who thinks all frameworks suck and there is this brand new way of doing things. So it's not really about demographic in the end. What this post is about though is conference specifically *actively looking* for a particular demographic, which I think is completely backwards. What I think we need is some statistics on the female talks that were rejected for a specific conference and how was that decision reached. This way we could actually gauge how much gender is biasing the results. Personally I can't imagine organizers of any serious conferences immediately disregarding women speakers without looking at their talks
I would say the answer to all of your questions here is "yes."
Read this as "HornHub" and was expecting some kind of adult video script... I do like it though.
&gt;Stop reading things that weren't written. But that's exactly what is being written. "Looking for women speakers at PHP New Zealand" is not "Looking for speakers for PHP New Zealand". An easy test to see if this is a problem is to reverse it. "Looking for male speakers at PHP New Zealand". Does this work? Of course not. If someone wrote it like that, it would be a PR nightmare. He's specifically going out of his way to exclude a group based on meaningless criteria for the purpose of padding up the number of female speakers. The road to equality isn't somewhere we get by exclusion. It's somewhere we get when we recognize that merit is the important metric we should be focused on.
Most of your replies on this topic are aggressive. It certainly doesn't help your viewpoint. 
Cron is the way most people will implement this,; most web servers are linux based nowadays, especially in the PHP world. Another way to do this is if you have a queue in your architecture some of them support delayed delivery.
I completely agree. The thin font is fine, just like light grey and light blue is great as well within the proper context. When all of that is paired up with a white background... that's when the back button is clicked. If I have to struggle to read a page, it just won't be read.
&gt; The road to equality isn't somewhere we get by exclusion There's no exclusion here by anyone. For anyone even remotely interested in the speaking scene, they understand the CFP process and that they are looking for all speakers. This is just a call out asking for more women to submit. Is that a bad thing? It's not saying anywhere that they will get preferential treatment, or will be selected on the basis of gender. Just that they want more women submitting. Which I think is a goal we all should get behind (rather than making women feel worse for submitting, as this overall thread is literally doing). Is this the best way of phrasing it? Perhaps not. But it's not nearly what you describe either. Rather than being destructive, why not be constructive and find a way to help improve the diversity? Unless you think diversity is unimportant, in which case please don't even bother replying again.
I think I need to dive into this a bit more. I understand your example but would liek to see it in action. Might pick up a functional programming language then and test it out :D edit: also ty once again for the explanation! 
Diversity *is* important. However it's not as important as getting the best people for the job. If those people happen to be women I'm all for it. My stance is not "pro gender, anti-gender". My stance is "gender is not a metric worthy of consideration when making a selection". The industry is in such a panic to include women at this point that it feels like they'll do it at any cost. This is *wrong* when you start to get so desperate that you'll sacrifice quality to reach that diversity, and it's what I believe will begin to happen.
It is best to think of curl as a browser inside PHP. It runs local and can connect to web services just like a browser. When you run curl on your webserver and try to connect to the main server, your webserver becomes the client and the main server, the server. Curl is always the client. What you are trying to do is not uncommon but you got to create good mental image of what is where. Try running the curl command directly on the web server from the command line. That way you can isolate just one step of your chain. If that works, your problem is elsewhere. 
Python 3 was originally released in 2008. If it's taken 7 years for it to "start to overtake Python 2.7" that's a big problem. PHP only supports old versions for about 3 years. We do NOT want to be in a situation where the majority of our users are an old version. You're right, the same thing happened to PHP 5, adoption was really slow. There were huge campaigns to get people to upgrade. The community had to work really hard to get people to upgrade. If we break backwards compatibility we create a HUGE artificial barrier to get people to upgrade.
More importantly, Laravel 5 is out.
Yes, vote with your dollars.
Fucking **Christ**, thank you.
I find it weird and sad that people consistently see helping one group up as the same as pushing another down. I find it similarly sad that people think ignoring and tolerating injustices is somehow "fair". 
Well, I made a rant about Google's php library for ReCAPTCHA a couple weeks ago, but since then they've actually come a long way. I would try integrating that library into your zf1 library. And yes, people still use zf1 and this would be useful for them. https://github.com/google/ReCAPTCHA
I think there's a fair bit of projection happening in all directions here, and I don't find this bashing back and forth as particularly constructive. If we want to make the community a more welcoming place to people regardless of their gender, then maybe we should start with a more civil discourse, hmm? This goes out to all three of you. /u/enzoblue /u/mattaugamer /u/ircmaxell
Aha, but we have to READ what the site does, before downloading anything. Haven't gotten that far, due to the difficulty to see the content of the site in question. No idea what Humhub does at this moment.
/r/php has NEVER been a civil place of discourse, at least since I joined in 2010. Just look how you treat certain people like StoneCypher. Anyone who doesn't conform to the monoculture around here on any particular subject has historically been treated badly by various people on this subredit, with hardly ever any just accountability. What's worse is that they form downvote brigrades that reach all the way out to the wider web, esp. StackExchange. But fortunately, StackExchange sites *do* rapidly address such blatantly abusive practicies.
Why are you talking about yourself [in the third person](https://www.dropbox.com/s/k7l0lmnzwcbkrtj/Screen%20Shot%202015-03-31%20at%2012.03.10%20PM.png?dl=0)?
ooo thanks didn't realize sessions had videos other than the keynotes and this was one of the talks I didn't get to go to but really wanted to see.
&gt; Well at least I know what level in programming you are.. The level that knows that telling beginners to develop their own framework is a bad idea for maintainability
&gt; I wonder what the answer is to both. It would shed like on discrimination. The answer is definitely yes to both.
Who cares if they aren't interested? I have absolutely no interest in being a nanny, a nurse, or any number of true female supermajorities. Why should a male supermajority on coding be that bad, when any woman can be a developer if she wants? ::shakes my head::
It just sends the header through. This is between you and the browser. PHP has nothing to do with this and it has zero effect on PHP's behavior what strings are concerned. You can send the charset=UTF8 header and still set the default_charset ini directive to whatever else which is then what will be used by PHP. The effect of course would be a lot of "I can't render this" characters in the browser as you told it to be sending UTF8 while not actually sending UTF8, but, again, that's between you and the browser. PHP doesn't care
https://laracasts.com/series
What else do you need to learn about PHP? Anything can be learn by google or http://php.net/MOREINFO
Explain the purpose of tests and the consequences of not having them to your boss and let him decide. 
The only way forward is to justify the need for these tests -- i.e., the company will be able to detect when and where errors happen, the moment they happen. Else, time will inevitably be wasted trying to debug errors through tightly coupled code. This probably won't work, so you'll need to simply please your superiors by delivering the bear minimum, and -- if you want to -- write the tests in your own time for the practice. Meanwhile, you look for a job at a company that values these sort of things.
I mean, your point is valid. Let me try to reword my thoughts. I don't necessarily just want to be better at PHP, per se, but at object oriented programming in general. I'd like to learn how frameworks are _made_, not just how to use them. I want to learn how PHP _works_ not just use it. Maybe I just need to google for that stuff, and start poking around in the PHP source code. Maybe (I have the sneaking suspicion) I'll just have to figure this stuff out too, just like I figured it out for the past 4-5 years. Edit to add: I do think you're right, I could google for it, and I am. I'm just hoping that I can use some of this community's experience to sift through some of that legwork for me. Maybe someone else has been in my position and they have some thoughts on how "they did it."
Get out now lol. 
I'd say you should choose the third option: Leave. As I read it, company policy is holding back your development, and in my experience, this is something that rarely changes, even with a monumental event such as a data breach. Get a job where these practices are common place, you could learn from others, and people recognise that quality != more features. You're ultimately looking for management buy-in for better development practices. I recently moved to a job where this is the case. We have a pretty awful codebase, but there is a genuine attitude to improve it, from senior management down to engineering grunts. Time is being invested, people are learning new things, and it's improving, albeit slowly. I couldn't be happier, as not only am I in a position to learn, I'm part of a much larger change across the business. Edit: To actually answer the question; no, not until now. Previously I'd never been exposed to it, and I didn't have the time to expand my skillset, implement it, and get the feature work done as well. I was also a lone developer, and management didn't listen to my arguments for better quality procedures, even with a streak of awful bugs making it into production.
Not PHP-specific, but I'd grab some used edition of the ["CLRS book"](http://www.amazon.com/Introduction-Algorithms-Edition-Thomas-Cormen/dp/0262033844), nicknamed after the authors' initials. Personally I just gloss over the "mathematically proving it's actually O(log(n))"-type bits in favor of the algorithm explanations.
Definitely good advice, thank you!
My suggested answer is fucking leave. If you have to stay, the way I've managed to ease business people into realizing the value of testing is with acceptance tests. Write small selenium scripts that perform things like submitting an empty form and validating the error messages show, submitting a filled out form and showing the proper success message shows, checking out if you do ecommerce, etc, etc. All these things happen on the screen and they happen _quickly_. Then do it yourself manually and show the time it takes to test things. 
Yii to the rescue: http://www.yiiframework.com/doc-2.0/guide-rest-quick-start.html
http://www.phptherightway.com/ Free. Talks about the current state of PHP and the most used tools and techniques. A bit shallow but it's only meant to put you on the right track, not to be an in-depth guide.
I'm totally in.
That's precisely my point: that's what echoing with commas does. You're avoiding building big strings. 
Good point. My setup is considerably more complicated than I made it sound for the purposes of this example, but yes you will need to log the fact an email has already been sent for a particular record in the db.
&gt; Last time I checked major companies were practically paying young females to graduate with CS degrees. Yes. And they are *literally* doing the same for men graduating with CS degrees. They have been for decades. This is new?
Software is inherently unstable. You can pay for that instability through bug fixes after code gets written, or you can front-load that cost through tests so as to reduce time spent fixing bugs later. Fixing bugs is almost ALWAYS more expensive than minimizing their presence and in the first place, or at least keeping them as isolated as possible that you don't have a cascade effect. Tests also help to create a design that is easier to modify later, WITHOUT introducing new bugs. There is definitely a cost/benefit line for testing. Sufficiently simple projects take longer to benefit from tests than complex projects. Complex projects start benefitting from tests almost immediately. Just explain to your boss the costs of NOT doing tests - even gather data on how much time is spent fixing bugs, or implementing changes, and show him how tests would pay for themselves and then some.
I learned that its best not to talk to project manager about testing at all. It works best for me considered as integral part of software development. Time spent on hard to write test is time spent on developing feature.
I understood that part, I mean that if you are processing variables which contain 30mb strings, you should be flushing them way before that stage. Aside from that, I agree with you.
Did anybody try this with a team of developers (frontend/backend) who work in different branches?
Eh, although I hope not to open a can of worms in saying it, I don't think the PHP community has a "boy's club". There are just some who really appreciate the parent commenter's level-headed even-handed position. Women speakers seem to me to be represented proportional to their existence in our industry. There are of course comments to be made about the gender balance in our industry, but I can think of few other languages/communities where some of the most influential developers are women (Sara Golemon and Elizabeth Smith come to mind). And these are women who are respected because they're extremely competent and contribute a lot, not because they're women striking out into a male-dominated industry.
Please message the mods if you have evidence of this happening. It is something that we're cracking down on hard.
I feel like this is the best answer. Do what you can to keep the absolutely critical items covered and from there do what you can elsewhere but meet your deadlines.
The only people how has said (or implied) that anyone will be selected, based on gender, are you two. That is not reality. Please stop imagining things that aren't real.
What about new female speakers? Those that have come on to the speaking circuit in the past 5 years? I can personally think of only 2 off the top of my head. Two, in the past 5 years. Yeah, we need to be doing better there... While I think that the parent's post is missing the point about getting new speakers. It's something that many conferences have been actively trying to do (if memory serves me correctly, SunshinePHP had a track dedicated to new speakers the past few years). Is it really a bad thing to encourage new people to speak? And considering there's basically 0 pipeline of new women speakers, is it such a bad thing to encourage them? As long as the selection process is fair (not quota bound, etc), encouraging should be a *good* thing. Yet the parent's message here says the exact opposite. Which is why I think the parent's comment is extremely dangerous. It's presenting a single side of the issue in a level-headed way. But its not really level-headed, as it ignores the nuances of the problem. 
I'm very glad to see that CodeIgniter is still actively maintained. While it might be impossible to make this framework relevant against modern frameworks [without drastically recoding it](https://philsturgeon.uk/blog/2012/12/5-things-codeigniter-cannot-do-without-a-rewrite/), it's good to see people making iterative improvements to a tool that is in insanely wide usage. It's not the hottest new thing right now - that's been Laravel for about 3 years now - but it is still used by a shitload of people, so while it might not be PSR/Composer/DI/whatever hot shit term you like to see on your code, I'm glad it's not just sat there _completely_ gathering dust as it has been for years. A little birdy tells me that CI 4 might be PSR-2, slightly Composer based and using a version of PHP which isn't EOL. That'll be nice.
Why is [THIS](https://github.com/smarty-php/smarty) still a thing in 2015? Projects stick around in maintenance mode long after they are cool. 
Holy shit. &gt; please don't quote me on things I didn't say Please don't quote me on things I didn't say. I didn't say the following things: 1. I did not say that women would be selected, over men, because they are women. 2. I did not say that women would be offered any other kind of preferential treatment because they are women. Things I did say: 1. We would like more women speakers at the conference. 2. ...So could they please submit papers. How about next time we all just stick to reading what's said and not adding a whole bunch of irrelevant bullshit, in an attempt to derail a sincere appeal to demonstrably marginalised individuals in our community.
&gt; The way you put it sounds like the selection will be preferential for women Please show me the words that say this. I ask for submission of talks. All I see is encouragement, but I would be open to rewording if what I've said is not above reproach. 
Can confirm. Jobs with TDD listed in job description usually paid more. Source: just accepted an offer. 
It's a bit dated, is it still relevant?
Go for a system or library you know and use (And fix an issue you fought with yourself while you are at it ;D). Symfony/monolog/doctrine might have a large user/contributor base but there is almost certainly a thing you will be able to fix or atleast provide useful commentary on. Also Symfony has [easy-picks](https://github.com/symfony/symfony/issues?q=is%3Aopen+is%3Aissue+label%3A%22Easy+Pick%22). Remember to read [CONTRIBUTING.md](https://github.com/symfony/symfony/blob/2.7/CONTRIBUTING.md) first. Note: Some projects on github provide a CONTRIBUTING.md which details guidelines to ensure your contribution can be as efficiently reviewed as possible. It may also be worth your time to look for mailing lists or forums on the project you want to contribute to. 
Oh thanks! This is exactly what I was looking for.
Hey, If you're interested in CMS'es, we have a nice community going on with Bolt. http://bolt.cm / http://github.com/bolt/bolt/ We're a friendly bunch, and gladly help you get started on some easy picks' or show you the ropes with Pull Requests and such. Feel free to ask questions, or drop in on the IRC channel: #boltcm on freenode or via a browser at bolt.cm/irc 
Look, to everyone balking that this is some sort of anti-men discrimination: it's pretty simple. Whenever you go to a conference it is predominantly white dudes. I have organized conferences. I have attended fucking loads. Getting a diverse range of speakers is hard, and in turn you end up with a white-dude based turnout. If conferences do not have a diverse enough pool of speakers need to go a step further. It's only filling a quota if the non-white-dudes are shit and they're brought in for the sake of it. In reality, there are plenty of wonderful people who just need a bit of extra convincing to submit. If a diverse pool is not chased, it's damaging to the community as a whole to reinforce the idea that the only people "good enough" are those white dudes you see at all the conferences, when really it's was just "there are a shitload of white dudes that apply and we just picked a bunch of them." I'm not some crazed feminist, I've just been around long enough to know that "THIS IS NOT FAIR ON WHITE DUDES" is utter horseshit. http://www.notsorryfeminism.com/2014/12/privilege-explained.html
Not all sessions did, but we did record almost all the talks in the main ballroom where Paul gave his talk.
&gt;Do it at any cost implies that negative tradeoffs are being made ... by giving them free education? Paid programs? Tangible advantages a lot of people never had access to? I paid for my own education, yet, here's Google willing to pony up $50 million to help someone because they were born the right gender? How does that even begin to make sense? It becomes a negative tradeoff when such programs become biased towards a certain gender. I'm willing to concede that the OP used a bad choice of words, and that what it looked like wasn't the intent. However I think it speaks to a larger issue that people are unwilling to counterpoint for fear of being labeled misogynistic. I take issue with the fact that there's presently a move to do anything *but* address the issue in a fair and impartial manner. They're not solving the problem, they're addressing the symptoms. The root cause, as you put it, rarely gets examined well enough to even know what it possibly is. I'm not saying there isn't a problem, but what exactly is the problem? Not enough women in tech isn't the problem, it's the symptom. I don't want to sound like the guy who is saying "women shouldn't be allowed in tech!" because that's not how I feel about it. I want to be the guy who says to a woman "you paid your dues, you definitely deserve to be here, and your contributions are just as valuable as anyone else's.". Right now, the industry IS treating it like a quota. Like if we don't hit some kind of 50/50 equal split there must be something broken. There have been countless stories though tech news outlets about it over the last year. Yet we can turn around and see disparities in many other professions where the same could be argued - there are fewer male nurses. There are fewer male child care workers. Jobs to which it would be argued that men are just as capable of doing, but are often just not usually predisposed to participate in. We don't think twice about those disparities though, because we think we have a logical explanation for it that we happen to be comfortable with. *When people discriminate against men, nobody cares. Man up, take it. When people discriminate against women it's a major problem that is an absolute crime.* I think the phrasing "at all costs" is apt because presently major tech firms are under the spotlight when it comes to this issue, and making no effort to address it in a way that works reflects negatively on them. Women were in the industry long before this became a hot topic, and they'll be in the industry after it stops being a hot topic and the media outlets latch on to something else. 
As an employee, you ultimately have to turn out the project your superiors demand. If they are demanding you to write hasty code without tests, they are asking you to shit in your hand and wipe it on the wall. So be it. You can try and evangelize for change, but I don't guarantee you a lot of success. Making the change from "wild west" to well-tested code base is painful, and the gains are not felt immediately. All they'll see is the immediate drop in velocity, because they certainly can't see far enough down the road to understand the benefits of a well tested code base. I have been working as a coder long enough to have worked _extensively_ on both sides of this issue. Once I learned the gospel of a well tested code base, I never looked back. It's so nice to know that when a change you make has side effects ... your tests will catch it. Changes become much easier, and bugs become fewer and easier to fix. Also, when you're writing your code for testability, your dependency binding becomes much looser, and your code becomes much more modular and maintainable. Get your linked-in profile up to snuff, polish up your resume, continue to churn out the best code you're capable of under the current circumstances and start looking for a shop with better work ethics.
I would turn your last statement back around on you. Suggesting that women be specifically asked to come speak on the basis of their gender ignores the nuances of the problem. New speakers in general aren't particularly common. Definitely not new speakers who continue to speak often. There are only so many developers who have the qualifications to speak as experts on some topic that is widely interesting. Not to mention that there are only so many of those people who are comfortable with/capable of public speaking. You're also mistaking me for arguing that women shouldn't be encouraged to speak. I'm simply saying that this notion of a "boy's club" which is rejecting women from our community is really offensive. I've never seen that in the PHP community, and I like to think I have my finger on the community's pulse, so to speak. Women should be encouraged to speak. Men should be encouraged to speak. Making this an "us vs them" battle in the war on gender bias is just plainly damaging and doesn't get us anywhere.
You are not doubling your work if you write your code _with testing in mind_. When you have external dependencies (APIs, Databases, File System ... whatever), you need to stub. Write your code to be _easily_ stubbed. Write your code to be modular and very well defined responsibilities. When you are coding from the mindset of testability, you generally start writing better code overall (much less coupling, more modular, etc...). When you're writing good code, it's easy to write the tests because the "touch points" become very clearly defined, and your test cases practically write themselves. If you're finding yourself doing backflips to try and unit test something ... time to refactor ... you're probably trying to do too much with the code as written. Refactor, modularize, simplify, reduce side effects.
You and I are in a privileged majority. Encouraging minorities to participate in no way disadvantages you. You can put that pitchfork down now...
I'm holding no pitchfork, and your insinuating that is a rather underhanded and blatant attempt to undermine my greater point. I am not arguing against encouraging minorities to get involved. I am arguing against framing it as "There are too many white dudes. That's unpleasant. We need fewer white dudes and more &lt;insert minority here&gt;." Whether you intend it to be framed as that or not, that's how some of us are made to feel. As if we're less welcome because we're in the visible majority.
Thanks for the reply ... I've actually used your CI based REST tool. My needs were minimal and it did the trick among all available tools at the time. Thanks for that. Yii gets there using already available framework functions and I know it will be easy enough to customize API access based on table values/categories. The thing about Yii is that it automates a ton of the legwork with it's scaffolding features among other features. What do you currently recommend for a REST API with PHP? p.s. I'd probably use ASP.NET Web API if my client wasn't already using LAMP. MS has been bringing a shockingly good game these past couple of years.
Ok there. I apologise for my underhanded undermining of your greater point. It is undesirable that the majority of attendees and speakers are white dudes. And we do want more minority representation. If that disappoints you then we're not going to agree on much else. I believe that is Phil's point, and it is mine too. Let's not read any more into it than that...
I figured yours was already taking care of stuff like this. I just wanted OP to make sure he knew to do so.
If you're looking for the definitions of the status codes, this isn't really PHP specific; have a look in the the HTTP protocol specifications for [HTTP/1.0](http://www.w3.org/Protocols/HTTP/1.0/spec.html#Status-Codes) and [HTTP/1.1](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html#sec10).
Yeah so that clearly isn't the point. I'm not hostile to my own kind (wtf) I'm saying that conferences have to try and ensure the entire stage isn't just white dudes. It's not discrimination to try to give more than one group of people representation. It feels ridiculous to have to say _that_.
And based on the response, *you* decide on whether this is the company you really want to work for.
&gt; New speakers in general aren't particularly common. I definitely disagree. Every conference I go to (and I go to a fair number of them) I see new faces. I see new people who have never spoken before (at least at conference level). Every single one of them. &gt; There are only so many developers who have the qualifications to speak as experts on some topic that is widely interesting. Experts are experts because they speak, they don't speak because they are experts. I've seen talks by "new people" that put the experts to shame. Not because they know more (they don't) but because they present it well. And that's nothing about qualifications. &gt; You're also mistaking me for arguing that women shouldn't be encouraged to speak. I'm simply saying that this notion of a "boy's club" which is rejecting women from our community is really offensive. I've never seen that in the PHP community, and I like to think I have my finger on the community's pulse, so to speak. I don't think that's what you're arguing. However, I can say that it is happening. I know several women who have experienced the rejection level. I could point you to joind.in comments to that effect, but I won't call out the individual women (to make the problem worse). The fact that you haven't seen it is *precisely* the problem. I didn't see it for a long time either. But then I opened my eyes and what I saw was sickening. And this thread (the comments on the post) has a large number of the same warning signs. &gt; Making this an "us vs them" battle in the war on gender bias is just plainly damaging and doesn't get us anywhere. That's exactly the point. Chris didn't say it was "us vs them". People assumed that here in the the comments. Encouraging women to submit proposals in no way harms or undermines men. It in no way hampers quality. it in no way talks about a quota. The us-vs-them battle was assumed by commenters. The great-great-grand-parent (OP of this thread) made it "us-vs-them" by bringing up quotas (which does indeed make it us vs them). And that's what I took issue to. And still do. Asking women to submit is a good thing. Making a quota is a bad one. But everyone here jumped on the "quotas are bad" bandwagon and shamed Chris. Yet he said none of that. The topic has nothing to do with quotas. It has nothing to do with "us vs them" until the commenters here made it that way (oh noes, it's not fair, the same old FUD).
I built that back in 2009 before I knew what the fuck I was talking about. Building a REST API involves HATEOAS, so anything that lets you link to other resources properly is going to help, and if it lets you serialize your data to hide datasource and allow "representations" that is the final part of the battle. Fractal lets you do a lot of that. :)
You're framing it exclusively, even if you're trying to be inclusive. You want fewer white dudes, more non-white non-dudes. That's why what you're saying is controversial. Not because you want to make the community more inviting to minorities, but because you're saying it is too saturated by white dudes.
You do not represent the whole community. And I have listened and responded to your views. I am for diversity. You appear (though I welcome correction if I am not representing your opinion correctly) not to be for it if that means fewer of your ethnic/gender group present. These goals are not mutually exclusive, yet you seem vehemently opposed to my sincere encouragement for more women to submit papers. If you don't agree with me, then fine. But I have listened and expressed my views without malice. I didn't tell you to leave. I only asked that you contribute constructively. I encourage you to do this again.
Thanks for the recommendation, I'll check it out. Your project made me money in short order .. is there something more important? :)
In what way are my responses not constructive, beyond the last (which was only intended as a response in turn)? You're either misunderstanding or intentionally misrepresenting my position. I'm willing to give you the benefit of the doubt that it's the former. As I've repeatedly stated, I'm not against encouraging women to be more involved. I am against discouraging men from being involved. It is divisive and offensive.
And this is why I'm saying that you are framing this in an offensive manner. Instead of saying "it's undesirable that the majority is white and male", say "it's undesirable that there are not more ethnic groups/women represented". The former is exclusive. The latter is inclusive.
I think you're framing it funny. 90%+ white-dudes is not an accurate representation of community, and as such people should strive to make a more fair and balanced representation. If you don't like that phrasing then meh.
I didn't say that it was an accurate representation, and I agree that we should strive for more representation of minority ethnic groups and women. I just don't think we should do that by prefacing every statement with an insult to white men, calling them undesirable.
Tell your boss that the deliverable is only part of it. Writing an accompanying test is the promise to your boss that the deliverable both works and doesn't break other parts of the program. If this place is really a seat-of-your-pants kind of outfit then they've undoubtedly been bit by some new code that broke something in production and made everyone in the company flip out and your boss mistrust developers more. See if they can give you some leeway to get a baseline of tests down. Tell them that it can lead to cool things like CI and then the kinds of quality, code coverage, performance etc graphs that managers love. You can severely reduce the number of world breaking pushes, but it all has to start with tests. Good luck. That place sounds like a vice.
I'm sorry, but you're lacking comprehension of the English language, then. I don't mean that as an insult. I just do not understand how you can see that as not being exclusive. You are saying you want fewer white men. That is excluding white men.
I literally never said that and I'm confused by your stance. 
Joomla can be thought of as quirky to use in some ways eg setting up menus. But try explaining how auto menu creation works in WP based on the difference between a page and a post to a complete noob or lazy office admin, and it starts to feel logical. 
&gt; It's just that men don't need encouragement to submit papers to speak in front of the entitled, white, male masses ...and that's where it all falls apart. You were doing just fine until you decided to apply blanket labels. If you had been reading anything I've been saying you'd know that the entire point of me speaking up is to advocate equal opportunity, and to speak out against gender bias. Shifting the bias from one gender to the other is not equal opportunity. Making men out to be the perpetual enemy and women out to be the perpetual victims does not further an equal opportunity agenda.
Yes, having mostly only white-dudes speak at conferences, and in turn having mostly only white dudes as attendees is a bad thing. I can't see how that statement could be confused with anything other than blatant fucking logic.
What exactly is wrong with white dudes? Why are you self-loathing?
You're correct. Thanks for prompting me to give this another try, I got there in the end. I actually just copy and pasted the app() function into my codebase as I rely on it in my legacy code and added one extra line to my startup code: $app = new Illuminate\Container\Container(); $app-&gt;bind('app', $app); Illuminate\Container\Container::setInstance($app); // this is the new line Illuminate\Support\Facades\Facade::setFacadeApplication($app);
I think in that blog post, Jeff is doing what the Dutch call "kicking down an open door". It's an obvious point that's easy to make and he's not really saying anything. Of course users don't care what language the product is written in, Atwood. So what?
Just test the very core part, forget about others. I know you may feel uncomfortable with it but remember this: the managers need to take responsibility for the quality of products, too.
Ooh.. You're good. I'm going to try this later and get back to you.
There are problems in your post straight off the bat: &gt; I get lots of work thrown at me by a boss who doesn't appreciate the skill of technical work (thinks everything should be done in 5 minutes, and that us devs are all just giving him the run around, that kind of shit). Management shouldn't be figuring out how long things take at all. The people doing the work should own the estimates, and the estimates should include the agreed level of quality that the team has agreed to. It means things will take longer initially but in general cost less in the long run. If management is setting timeframes and pushing for things to happen on their terms then you work in a dysfunctional environment. &gt; I'd love to spend time crafting well thought out code and doing TDD (or at least unit testing), but the deadlines and pressure I'm under mean I am no way able to do that, without missing deadlines by a large margin. Who sets the deadlines and what are the agreed levels of quality within the team you work in? Has anyone had a frank conversation with management about quality? And about how if quality is not a priority it would be unfair to blame the developers for defects in production and so on? &gt; If I said I missed the deadline because I was writing tests my boss wouldnt accept it because if he can't see it on screen I doubt he considers it as work. Getting an agreement about what "done" means can often be helpful. Explain that "It works on the screen" does not mean to the best of your knowledge it is bug free or maintainable. Done typically means feature complete, code complete (all nicely refactored, reviewed and so forth), tested (by whatever regime your team agrees to use) and ready to go into production. But it might mean different things for different people. It's important to have a common definition of what "done" actually means...for everyone's sanity. &gt; Should I be a good dev and commit to writing tests even though no one except me will see them or give a fuck that they are there, and I'll suffer low esteem from always missing deadlines, or should I just churn out what needs to be done to keep boss happy and not give a damn about quality? (the option of saying to boss up front that a feature will take twice as long as he expects isn't really an option) The third option is to find another job. Seriously. If the boss is setting deadlines, telling you how long he thinks things should take and then using his estimates as a stick to beat you with then this isn't a nice place to work. Your boss should set the priorities, but setting the priorities and telling you how long it will take would be like contracting a builder to build you a house and telling him it needs to be 100% finished by next Tuesday even though you have no knowledge of the effort involved in constructing said house. In answer to your question - yes, I unit test when under serious time pressure. I try to avoid serious time pressure where possible. I have conversations early and frequently about the state of individual features and i encourage the descoping of items if they can't make it in. And I have in the past refused to ship features which do not meet quality guidelines (having a good QA on the team can help with this as well..) 
I'm in a similar situation. I want to work on large scale systems, and may take on a job that involves them. My experience with web design agencies hasn't really helped prepare me for that, since load balancing and efficiency aren't regular topics for us devs there. So I need tips or links to websites that offer a good guidance to make that transition for work. At my last job, I have used CodeIgniter (though sadly Ellis Lab no longer supports it, I guess it's time to jump ship to Laravel) with a CPQ application. This is as "big" as a system as I have yet to work with. And for future reference should I avoid web agencies for work if I want to hang with the big boys of web development?
sub'd. Thank you :)
From Dec 2014: http://meta.stackoverflow.com/questions/278726/on-target-answer-deleted-two-years-after-why There are more less recent examples of SE manipulation / rule-breaking linked to that other thread, concerning downvote brigades organized of /r/php users. From what I gather, a mod w/ ~30,000 points was suspended from SE for wontonly harassing me there, completely unprovoked. Though I think that is yet another SE mod thread.
I'm speaking specifically about things happening on /r/PHP. Obviously we have no "jurisdiction" on StackExchange, but we're trying to bring the state of discourse on /r/PHP toward a higher standard.
I disagree, otherwise all tech conferences will just be old white dude conferences that women never want to go to. Geez, even now representation of women at tech conferences I go to is only around 5% and that's intimidating both as an attendee and as a speaker. To get more women to attend conferences they need to feel more welcome, part of that comes from having speakers that look like them who they can relate to. Race and gender are incredibly important in a field with little diversity, and change will only come from making a conscious effort now so that we can start the ball rolling and look back on these days laughing at how it used to be a problem. By encouraging more minorities to apply the same quality process should still happen to ensure that the speaker is suitable, but in a world where there are so few female speakers on the tech scene we should also be creating spaces where they can gain public speaking skills and confidence. 
So you think that a woman should get priority and be held to a lower standard? That isn't right. There are limited spaces at conference, it should be based purely on quality of the work, regardless of gender or race. There are many conferences where the review process is blind, that is, the paper is given with the names erased from the paper during the review. That is the most correct way to do it. Research conferences aren't the place to be nice, it is the place for leading researchers in the world to gather, listen to, and spread ideas. There is no higher level. They shouldn't discriminate against women, and they also shouldn't discriminate against men. It's not the place to gain public speaking skills and confidence. Important people travel, and pay lots of money to attend these things, they aren't there to waste their time. Come on, this isn't highschool. I attended and presented at quite a few conferences, IEEE, ACM, IFAC... to go to one, it costs around 600-1000 dollars for the fee, plus hotel, plus travel, ofcourse these are deducted from work, but it is still time and money. I'm all for genders to be equal, but it crosses the line when it discriminates against either one. Also, I'd love to see more women in tech, but by merit, not by discrimination....
That's my secret. I don't test. I'm in a similar position as you. Sole dev, 1000 projects at once. Fuck it. 
CI had its time, we should be thankful to stand on its shoulders and this is a fun thought experiment, but it's time for people to move on. If I was BCIT, I'd be a bit embarrassed for wasting resources on CI.
Depends. If you're writing a new function, you have to test it one way or another. Either it goes directly into your production code, you run it, look at the result and see if it did what you wanted it to do or not, or you write the unit test and the function concurrently. Either way, you're testing. One's manual, one's automated. TDD doesn't [always] have to be slow and time consuming. Sometimes it can speed up development because it makes re-running the tests quicker, and you get nice green/red bars to see whether or not you did it correctly, rather than trying to parse some arbitrary result with your eyeballs each time.
I saw your link where you proposed to provide teaching and listened to your TEDx talk. You're a really good speaker and it's really nice of you to offer the support to improve their speaking skills. Btw, i never said having women would lower the bar, most conferences do have a couple women speaking. I just meant the bar should be the same for both genders. Encouraging more people to submit papers does just that, but I still think there shouldn't be any preferential treatment for anyone. As for experience, I guess it comes through experience, from k-12, throughout university, to final project and thesis defense, to conference, to key note. You learn as you go along, get feedback from colleagues or friends, etc. By the time you get to speaking at conferences and giving keynotes, one should already have quite a bit of experience. Anyway, I'm not trying to exclude anyone. It sucks being surrounded by 95% guys all the time at work, i'd love to have more women around, to the point I almost changed to a different career. Based on the quick look at the TEDx talk, you take your work seriously, and probably do some great research. So keep it up, help people out, encourage more people to join sciences and engineering :).
Someone doesn't like my comment. Care to say why ? 
Is there anyone in here expressing an opinion about this situation that's a woman? Because honestly, here's the deal. There are fewer women in tech, and guys who constantly pretend like their fellow dudes don't make women feel unwelcome or unincluded in the entire culture of tech are kidding themselves. Many women don't want to speak because they've had bad experiences. I've had bad experiences. With people like you, who pretend these issues don't exist and that women don't deserve a bit of a boost in a male-dominated industry. I don't hate men, or discriminate against men, but what you're saying is *inherently* discriminatory and the same argument used for a variety of seriously racist/sexist/discriminatory behaviours throughout history. Punch up, dude, not down.
Would the real philsturgeon please stand up
I am philsturgeon!
All of this is clearly indicating that it will be /u/philsturgeon who will today release the previously rumoured Kim Kardashian's Session Handler. And bing it will be popular!
Am I philsturgeon
ahh, yes, I am philsturgeon
April 1st?
But will it properly support HiDPI?
What the sturgeon? 
Let the April 1st trash posts begin.
Haha. Just realised what day it is :D
I can see the potential as a dating app: you meet only people who agree on the same RFCs. No more awkward scalar types debate on 1st date!
Aha! Dracony, I know it's you! You can't hide, not even today.
And it was my first comment too =\ I'm too easy =\
If anyone has to explain anything to you like you're 5, it'll be pointless because you'll lack the mental capacity to understand it.
[It was not him that made that excellent comment.](http://www.reddit.com/r/PHP/comments/30i0t4/aura_3x_plans_or_the_past_present_and_future_of/cpsq7u8)
Why 21?
It has to be!
Well, I clicked the link, and it was indeed philsturgeon.
Sorry for my rude comment
While this is an implementation error, but it gives a good and important remainder that every line of code and extra feature is a potential security flaw.
Ah yes, a nice combination of "use before hmac verification" and "none encryption/verification/etc scheme". Both oldies but goodies.
Going with GIT + envoyer. Thanks for the feedback guys!
I don't know Yii but I'll just point you in the right direction: don't try to merge two models in one view, but merge two models in one model, and then feed that into your view.
You seem to have a problem distinguishing between "white dudes" and "100% white dudes".
Heh. I even fell for Indoctrinator.
Doesn't mean when you are hired you can't do TDD. If anything it means they are open to it. 
I worked one place where they had TDD down and then when I got there they didn't even do unit testing. They also wouldn't allow for you to do unit testing. I learnt my lesson, I ask so many testing questions at interviews I sometime wonder if they think I'm looking to be a QA.
I learned a lot from these series http://fabien.potencier.org/article/50/create-your-own-framework-on-top-of-the-symfony2-components-part-1 on how the internal structure of the symfony framework works
Am I the only one here on this subreddit? Helloooooo? Echoooo?
Hahaha. Classic Jeremy. This is great.
I know right, I still have over a month to wait.
shit just got real, etc
`League\Kardassion`
Yo im at my standing desk, what you need?
There are parts, even layers in every project that aren't code testable. Your site views, and your site controllers aren't quite testable, one reason there's barely any logic in there to test (if done right). Code that interacts heavily with third party APIs is typically not very testable, unless you're willing to write elaborate mocks emulating said APIs. But then what you're really testing is whether you match your own expectations about how that API behaves (and surprise, you do match your own expectations). There are also modules of code which are exclusively utilized by another layer of your app, and it's much easier (and more natural) to test that layer, than do unit testing on what might as well be called an implementation detail of that layer. Everything I'm saying is highly subjective, and depends on specific circumstances. For example you assume OP's project is about business entities and logic, but I see nothing he says about that. So how do we know what his app is like. Not all apps are the same.
Aha! Found you!
I, too, am philsturgeon!
- How critical is the code you are writing? - Does your boss get mad when work goes out with issues in it? - Do you spend much time revisiting existing work to fix bugs? It really depends how important quality is, and if you’re writing simple code that doesn’t really have any issues then there is little point because you won’t be able to sufficiently justify it from a business perspective to your boss. If on the other hand you are scared when you push stuff live and have little confidence in your code go ahead and start taking the time to unit test, and probably acceptance test as well, that makes your life easier and gives you confidence that the code is robust. It might double the time to write code in the first initial weeks but once you have an automated test suite it will likely live on longer than the code itself. When bugs come in you can write failing tests as well so the same issue won’t happen over again. In my experience when working with larger codebases writing simple code with tests around it will save you a lot of time in the long run, this doesn’t just include TDD, but mainly spending good time up front planning and architecting a system rather than jumping straight into your editor.
Thanks for your thorough reply. &gt; There are parts, even layers in every project that aren't code testable. Your site views, and your site controllers aren't quite testable, one reason there's barely any logic in there to test (if done right). You mention controllers as not being code testable, I dispute this. Especially when the logic has been put else where. If your logic is in say two other classes and you're using dependency injection then you can do a simple unit test. Again with site views you can test them even without end to end tests. You give the template engine the data and then get it to render and then do asserts on the output. &gt; Code that interacts heavily with third party APIs is typically not very testable, unless you're willing to write elaborate mocks emulating said APIs. But then what you're really testing is whether you match your own expectations about how that API behaves (and surprise, you do match your own expectations). That is a very good point. Again avoiding end to end tests. Here you would do layers of tests. This is where layering your application becomes important. In good software architecture you would want to decouple pretty much everything, because one thing is for sure you didn't think of something and you're going to want to change it later. So you would have your code that does HTTP requests. You test that it does HTTP requests using something such as robohydra. You then have your code that turns the HTTP return data into your domain code. Then you have your business logic domain code which you would test as per normal. Then you would have your integration tests. I wouldn't say you're testing that the API behaves as you expect, you're testing that if the API behaves like that your application will work. You would have smoke tests to ensure the API continues to work the way you expect it to. &gt; For example you assume OP's project is about business entities and logic, but I see nothing he says about that. So how do we know what his app is like. Not all apps are the same. To be fair I'm not assuming anything about OP's project. I'm merely wondering what you mean. But I would say it's very hard for any application not to have business logic or entities. It's just what the business is isn't what we would in standard English call business. For example an interpreted language executer , I'm assuming you would say this wouldn't have any business logic or entities? Where as I would say it does, it's just the domain is computers and programming languages. You would have the language syntax tokens as entites, the lexer and parser as business logic for example. I would say if an app has no business logic, then what is it doing? If you're app is just a login form, then the business logic is the security implementation. 
looks like unit tests didn't work properly. There's a glitch in the matrix
Sorry Mate. I feel you, but it is done in order to keep the online Sweeptake legal. More info [here](http://adage.com/article/guest-columnists/online-sweepstakes-legal/149206/)
Untick the 'Use subreddit style' button. Or browse on mobile.
I'm philsturgeon.
It would help to get a little more use case explanation here, but if you need need people to electronically sign documents you might check out DocuSign. They have some developer hooks and an API to integrate with their system: https://www.docusign.com/developer-center
The moment you start testing HTML templates by running asserts on the output (meaning, very specific HTML/JS in the output) is where I believe we cross the line of useful tests and go straight into cargo cult testing. Consider what exactly are you testing if you look for patterns in your HTML output. You don't test if the page renders properly, one typo can break that while all your pattern tests work. You don't test functionality, because HTML output can change drastically while the UI remains mostly the same functionally. Only a human agent can determine if the human UI layer is operational. A computer agent can do some basic tests, like check if HTML is valid (this is useful, but also trivial and I wouldn't consider it a "unit test"), but apart from this it can only determine one thing: the code has changed, or the code has not changed. Well, you already know the code has changed or has not changed. We have version control and commit logs for that. You don't need to write tests that fail when you change your HTML, in order to tell you you've changed your HTML... And likewise, at least for me, controllers are so simple and short, and trivial, they're not worth testing. The only thing they do is grab some input, pass it to a service, get service output, give it to template. Writing comprehensive tests for a controller like that could easily quadruple the amount of code you have, with the only benefit being, again... a test failing when you change a controller. Unit tests are most useful for stable, long-term, reusable code, functional code, and code which deals with the domain (which is typically long-term and stable). Controllers and views, at least in PHP, are so "dumb" and so unstable in terms of specifics (as in, it's in their nature that *they change all the time* in a way that'd keep breaking all your tests), testing them is both futile and counter-productive IMHO. P.S.: Regarding OP's project it can easily be, say, a Word to PDF converter, or a site scraper, or god knows what. Judging by the language you used, I suppose you assume his app has CRUD-like models with entities in them, and this is why I'm saying let's not assume things we don't know. Sure, most apps have some sort of "business logic" in them. But it can vary drastically in terms of its nature, and therefore approach to testing it.
Because [Larvel](http://www.reddit.com/r/PHP/comments/30i0t4/aura_3x_plans_or_the_past_present_and_future_of/cpsmkc3) [fan-boys](http://www.reddit.com/r/PHP/comments/30h72a/aura_3x_will_target_php56_as_minimal_required/cpsn2i0).
The thing you need to realize is, often the fact that someone has a different point of view on a topic is *just as valuable* as someone with more technical knowledge. More often, especially at conferences which are not diverse by nature, it's *more valuable*, because tech has a HUGE blindspot called `privilege`. You can learn a *lot* from someone who has a different point of view, even if you might know more about a particular discipline. Seriously, we can stop swooning over new sorting algorithms and the latest Javascript framework for fifteen minutes to hear someone with a different viewpoint talk. Your world won't be any worse off, I promise.
Well its just an amalgamation of recent controversial talks on /r/php : PHP New Zeland was looking for a female dev and resulted in arguments. When framework popularity survey was discussed some saud that if populatity is a valid metric Kim Kardashian should make a router. Plus the usual performance shitstorms. All molded into a single April Fools post. I suppose ig you werent participating in thosrle threads this looks rather idiotic.
For sure they have to suggest PHP 5.4. It is the current minimum version that didn't had it's eol. A framework suggesting a PHP version that had it's end of life would be awkward. Supporting 5.2 may be have a valid reason, but it is a double edged blade. While it may work for CI devs, it also means they'll be stuck on 5.2 for a while and never receive the major enhancements PHP had in the past few releases. `3.0.0` is a major version release, BC breaks are meant to happen. If they still decide to support 5.2 even in this day, that is what I would call utter nonsense to be honest. It is not a blogging platform like Wordpress which mommy bloggers can simply install and start using. It is a framework targeting PHP developers. You're trying so hard about modernizing PHP and I am surprised you're on CI's side on this situation. As long as people continue to support ancient versions, people will never leave their comfort zone and update. If CI stopped supporting 5.2, Wordpress stopped supporting 5.2, people would be forced to update to update their PHP versions, so web hosting companies and distros would be forced to upgrade their PHP versions. Didn't we all had alot of headache due to BC related issues? Didn't we all go crazy because we had to support people stuck on IE6 for a very long time? Why can't we learn from our mistakes? CodeIgniter had a huge chance of killing it. The whole thing was deprecated. The whole project has been transfered to another organisation. Most of the developers stepped away. Nobody would complain if they completely ignored BC and targeted 5.4 minimum. I'm not going to help people create another IE6 and will never suggest anyone to do so. Lastly, the whole release notes has nothing exciting. %90 of the changes are just minimal stuff. "x method accepts parameters as an array now." and even more crazy things like "Added availability checks where usage of dangerous functions like eval() and exec() is required." Yay! Best change ever. Not to mention, it could benefit from existing packages instead of reinventing the wheel. Seems like they've worked on features, which many packages solved years ago. "Added Windows 7, Windows 8, Windows 8.1, Android, Blackberry, iOS and PlayStation 3 to the list of user platforms.", "Added Android to the list of user agents." What? So until yesterday, CodeIgniter couldn't even detect Windows 7? Not even a single guy issues a pull request in the last few years? Meh, whatever. 
Please post all help threads to /r/PHPhelp 
idgi
I'm gonna need more cider to keep having this conversation.
I am sparta...philsturgeon
No! You are!
I love the idea of immutability as it relates to functional programming -- don't update an object, just return a new version. Unfortunately the Hack collections aren't really intended to support that. They seem more like a way to define a datastructure as a constant. I would love them if they worked closer to Haskell -- e.g. if ImmVector::add() returned a new ImmVector, which contained a reference to the last vector and a delta with the newly added elements. Something similar to the immutable.js project.
i wish i could downvote multiple times. please use a closed chat for your personal communication.
As I said, arbitrarily breaking PHP 5.2 support "for the good of the community" is nonsense. Doing so mid-way through a major release after rejecting major changes based on that version would be worse than nonsense, it would be utterly moronic. If they upped the minimum requirement to PHP 5.3 but didn't leverage namespaces or any other 5.3 functionality then what would be the point, other than reminding users to get off PHP 5.2? That can be achieved with documentation and advice, better than forcing them at gunpoint to chose between "a major new stable version of CodeIgniter" or "upgrading PHP / migrating to new servers." &gt; Nobody would complain if they completely ignored BC and targeted 5.4 minimum. The thousands of existing users with legacy applications probably would. Like this guy: https://twitter.com/justinrsteele87/status/583042779682508800 Code still working on PHP 5.2 is not the problem. Letting people think its ok to use that version is. CodeIgniter should be doing everything they can to suggest people upgrade, and I hope their blog posts do this as much as their server requirements do. CI 4 will update the minimum version and everyone will be happy. Until then this is entirely not an issue.
[**@justinrsteele87**](https://twitter.com/justinrsteele87/) &gt; [2015-03-31 23:06 UTC](https://twitter.com/justinrsteele87/status/583042779682508800) &gt; @philsturgeon just took over a product written in CI2. Our team is super excited to move. Real products can't just rewrite every other year. ---- ^This ^message ^was ^created ^by ^a ^bot [^[Contact ^creator]](http://www.np.reddit.com/message/compose/?to=jasie3k&amp;amp;subject=TweetsInCommentsBot)[^[Source ^code]](https://github.com/janpetryk/reddit-bot) 
Spelling errors in the 'infographic' and also talking about CakePHP3 - if this isn't an April fools joke this is very sad.
Philosophically speaking, are we not all philsturgeon?
Yep, the actual information is right there in the paper, but one could argue if it should have brought up better. I.e. an example would have been a great addition. It is sort of an usual problem with such standard definitions where you need to go through a mile long paper deciphering all the possible branches and implementation quirks that may arise.
&gt; in the context of PHP as a web scripting language That's it right there -- if you're doing the basic 'grab some data from a DB and return it to the client' sort of thing that PHP tends to be good at, you probably won't have much need for collections. If you're building several classes to model complex business logic which requires frequent mapping, collections are amazing. The convenience of type-checking alone really makes it worthwhile.
All the links still work... sooo, what's the problem? Just pretend like I'm the most prolific redditter there ever was or will be.
I've tried and benched this approach before (immutable with mutators which returns a new clone with the mutation) and let me tell you why they didn't do it like this - it's really bad for performance. There are, of course ways to optimize it a bit compared to doing naive full clones every time (like Haskell does), but PHP already is slow enough, we don't need more of that. As for Collections being amazing for business logic, if you use PHP the way god intended, your PHP environment is dead within 0.001 seconds. Whatever collections you created are gone. Wherever the information came from was in the form of arrays. Wherever it went to, also. This is why nominally typed OOP collections are an awkward fit for PHP. It's not that I don't understand the value of typed collections, don't get me wrong. But I feel Hack missed a huge opportunity to implement structural typing on PHP's existing arrays (google: structural vs nominal typing). TypeScript implements structural typing for data and if you like Hack, you won't believe how much better TypeScript is at typing transient data like PHP usually deals with. I can tell TypeScript "this incoming JSON from the server has this structure" and boom, I get full static type checking, **without** hydrating the Object instance from my JSON to a specific class/prototype at runtime. Instead I use it directly as-is, yet it has a type. Structural typing means the type *name* does not matter, only the *structure* does.
 &lt;?php declare(strict_types=1);
The same as != 
Http, router, debuger and a pair sandals 
Was excited, then realized this is mod_php only. No php-fpm support, which means Nginx is out. Waiting patiently, though.
... I would have 100 really long lines of code
Well strict types work on a file by file basis, so your framework would literally have no effect when included :P
EDIT: Nevermind, they made a liar out of me.
It's checking if the $var is not equal to ''. This is different than "empty", as empty($var) returns far different results than $var &lt;&gt; ''.
In context of the statement, the if statement is checking if $var is NOT equal to '' The following statement would do the exact same thing: &lt;?php if ($var != '') { ?&gt; EDIT: whoa, my user name is websightdesigns and I just posted this comment but it showed up as if it was posted by philsturgeon... that's wild, haha...
Hump day! Mike, Mike, Mike, Mike, Mike.
Create a custom column in your gridview then just retrieve the related user data ($data represents the model used in the gridview, in your case Payslip): [ 'label' =&gt; 'first name', 'format' =&gt; 'raw', 'value' =&gt; function ($data) { return $data-&gt;user-&gt;fname; } ],
Because today I realized its importance 
Ha... ya I was really confused with that at first. 
I was only asked what I'd write first. ;)
I used to see this back in PHP FI days.
You can trust us.
c'mon philsturgeon, don't try to kid us
I can vouch for the guy.
Without doc blocks. Controllers? How said this is an MVC framework. 
yeah shut up phil :D
philsturgeon is pretty helpful he asks a question and then answers it .. maybe hes the Chuck Norris of PHP
Ah yes, the old school `!=` symbol. Still works in PHP AND MySQL. I have come across this a few times in older code. I recall using it when I was younger in BASIC. And when I first learned MySQL I was taught the `&lt;&gt;` instead of `!=` for a while. 
All of the methods are vulnerable to the `"none"` algorithm problem. The key-reuse problem affects only asymmetric ciphers (RSA based). 
BTW I know you think you want strict typing in PHP, but mark my words, you'll try it once, and never touch it again once PHP7 is out. And I am actually a big fan of strict typing... in languages where this is possible. In PHP it isn't, because even if you enable strict mode, every input you receive, every API you call will continue to produce *whatever* and you'll find it quite hard to have stable code without manually casting and checking everything at every step.
Thanks for the reply, what would I search for to learn how to do this? Pretty new to building websites
Thank you for your thorough response! I really appreciate it.
PHP has built-in facilities for working with HTTP.
It's all about Ajax so you should look into that a bit more. The following article should give you a head start. http://www.webmonkey.com/2010/02/build_an_ajax_dropdown_menu/ Edit : I didn't read the article but it looks like what you need.
This specific key-reuse would be no problem if the consuming library used proper key management, that is separate keys for all the used "protocol versions" (you don't use RSA public key as a HMAC password etc). Mile long page of features and possibility to mix algorithms leads to such complicated outcomes that it is no wonder libraries didn't get it right.
&gt; without manually casting and checking everything at every step So, pretty much like every other language we're accustomed to using?
What did i just watched????? Dafag
&gt; every API you call will continue to produce whatever and you'll find it quite impossible to have stable code without manually casting and checking everything at every step Have you actually tried the code? Because I have. And I've seen people (at least 4 to 5) build small applications (500-2000 lines of code) using the patch as a trial before it went to vote. And none of us ran into these issues. Sure, there will be some people who cast everything all the times. But it's actually quite easy to build stable code without manual casts. And the few places that you really need those casts you can simply make non-strict (like your entrance points to the application). Boom, done.
No, not at all. You'll see what I mean in practice when PHP7 comes out. What strictly typed languages don't do, but PHP &amp; PHP libs do (and PHP7 still does) in most of its APIs is return output with unpredictable variations in its types. You expect boolean but you got int. You expect null, but you got false. You expect int, but you got float. Or you expect float, but you got int. None of this is changing in PHP7. The only thing that's changing is that if you turn on strict types you'll be getting a lot more surprise fatal errors as a result. No language has this weakly typed behavior and ecosystem *and at the same time* does strict type checking. This is why strict_types is not on by default. Because it's unusable, and it's there as a "fan service". You *can't* do strict typing on a *file by file* basis. You either do it wholesale, together with everyone and their libraries, or you don't. Unless you're willing to cut yourself off from the rest of the PHP world, use no open source libraries, and implement everything from scratch, strict typing in PHP won't work for you, or anyone.
If you're using a plain hash, rather than a HMAC, if you're looking at anything in the toke before verifying the hash, if you're using == or === instead of a constant time comparison function ... and lots of other things to take into account, then yes - you are going to hell.
I know how your RFC is defined, trust me. The problem is not calling into strict code from non-strict code. The problem is strict code calling into any code with output from non-strict code. Coercive mode will do absolutely nothing for data contained within our still quite untyped arrays, for example. I wouldn't expect you to bash your own RFC, so it's obvious you believe in this flag. Let's see where things stand in one year.
Yeah I run into this time to time on other things. For example, in MSSQL Management Studio it converts != to &lt;&gt; in views. 
I like Phil sturgeon - says things exactly as it is in his head and often says things some of us would not be willing to say. Keep going Phil - Bristol !!!!!!!
I guess this makes sense, but then again developers should make the decision how they applications fit into php7 before hand, and then detected if strict is enabled to show error or not 
&gt; The problem is not small self-contained applications 500-2000 lines of code. The problem is when you start dragging everyone else's libraries, frameworks and extensions into this. When I said applications, I did mean that they included dependencies. Including frameworks, micro-frameworks, etc. So no, it's definitely not ignoring it. &gt; Let's see what happens, it'll be fun. I'm just tired of the FUD. People who've tried the patch haven't been complaining about the things that people who haven't tried it have been complaining about.
Yeah I don't get it either.
I'm not starting out at all, I have always been involved in projects that are on going and generally have already been built. There has never really been the opportunity to even think of moving to a framework. Most of the time I have simply accepted what is good and what isn't based off of blogs and tutorials alike. I have missed out all the theory and what _things_ actually mean. For example I would go with a high request per second because it _sounds_ good, rather than actually knowing and unstanding what the hell it is. The first couple of years of my "PHP Career" was just Wordpress, developing plugins and theming, it's only in the past year or so I have built things myself, such as basing sites off of Laravel. Thoroughly appreciate the in depth answer!
100 lines, or 100 statements? I can put a lot on one line without line breaks...
Can you provide the code for PayslipSearch::search method? What i do is use the yii\db\ActiveRecord::joinWith method which might prove useful to you.
You have been greatly beaten by [this](https://gist.github.com/samayo/d8c02819a2c49fab7eff)
the buttons are functions and can be edited check http://www.yiiframework.com/doc-2.0/yii-grid-actioncolumn.html#$buttons-detail you can do something like 'update' =&gt; function ($url, $model, $key) { return empty($model-&gt;store) ? '' : Html::a('Update', $url) ; };
People use PHP platforms like Laravel because they significantly improve the development speed and quality of the final application. Developers are very expensive, while infrastructure is not. Caching also significantly reduces the load on the framework, so while performance is important, it's not a deal breaker.
Safest framework ever!
Coming from business application development, generally the ~200 requests a second is not a [major] issue if you only have ~100 staff using it. If more resource is needed you would spin up more vm's and so on. As a Symfony user, it is a great tool to build features for the business fast, but this makes it far from perfect in the same sense as you get in the rapid development box and you get thrown feature after feature which are a business priority. I would agree with fork_that to look at building your own framework. It is a great learning curve and you may build something that works for you (or the business) better than a framework. To advance on fork_that, build it on components like stuff from The PHP League like Route, Container, Tactician and Symfony components. This allows the ease of development and learning curve. Look at micro frameworks too like [Slim](http://www.slimframework.com/), [Silex](http://silex.sensiolabs.org/) and [Proton](https://github.com/alexbilbie/Proton) as they are a good indication of good design and practice. Just my two pence.
Oblig: http://blog.ircmaxell.com/2012/08/thoughts-on-pecl-frameworks.html
Umm.... maybe I'm missing something here. Seems like a few minutes work to me...
I made this. Interested to hear your feedback =)
&gt; In most cases these are clarifications that, had they been made during REVIEW, could have been merged without dropping the spec back to DRAFT God, I hate that. Me: Okay, we're going to be making these changes to this and that. Programmer X: ... sits on ass in silence ... Two week later... Me: We're almost done with the changes to this and that. Programmer X: ... sits on ass in silence ... Two week later... Me: Okay, we're pushing those changes tomorrow. Programmer X: Wait! What? We shouldn't make those changes. It should have been done like this .... blah blah blah Me: Fuck you. You had a whole month to voice your concerns and now you want to get involved and say something?
You and anyone else who's upset about someone trying to make room for women in a male-dominated industry. The fact that you're butthurt about this is ridiculous.
But, I'm sure you'll just write me off as a "straw feminist" just so your self-centred argument stands. I wish I had your privilege and could be upset that someone had taken my dominant role away from me, instead of wishing I had a tenth of your opportunities. http://www.harkavagrant.com/?id=341
Except the return types RFC also passed, so that (already small) issue will be mitigated a fair bit over time.
Yup. You can pay a developer $15k to build an app from scratch over the course of 3 months, or pay them $5k to build the app over the course of a month using a framework, and spend $5k on more hardware to make up for the slowness of the framework. You not only get your app cheaper, but you get it faster.
I am the OP of this topic. The one encouraging women to participate. Please read the original post again.
Please calm down - I am not your enemy.
Not what I expected, but still interesting.
&gt; If you are an enterprise business you should be writing your own framework/comprising your own tools since all frameworks have bloat. I've made that mistake before. The initial client specs required the app do X, Y, and Z, so a custom framework was written geared towards those specific tasks. Sure, there were frameworks that also did X, Y, and Z, but they had *way more* features than we needed. Fast forward 6 months, and now the spec requires A, B, and C. In another 6 months our framework needed more features. Fast forward another year and our framework had become just as large as the open source frameworks we decided not to use, and we're spending most of our time dealing with the custom framework instead of writing actual application logic. On top of that our custom framework didn't have the benefit of contributions hundreds of developers and peer review. Needless to say, I don't use custom frameworks anymore unless I'm working on a very small project.
Forget about the speed of the framework. You should be asking yourself if the framework makes you a better developer. You can always add more servers/VMs if the app isn't handling enough requests per second. I personally don't even take speed or memory usage into consideration when evaluating a framework.
Oh FFS. For some reason all the handles were displaying as Phil Gibson. mistake.
No worries.
thats the fault of the psr team. if you make an issue on github you are told to voice it on mailing list, then on google groups, then on github again.
On `namespaceMap` you provide a map of URI and alias/namespace, but when writing/reading you seem to need to pass the URI again, any chance of being able to use the alias? I sometimes need to use XML and I don't want to be repeating a 200 char-long URI on every writing and reading.
Based on the title, something to turn a binary file with shit like fixed widths/programable widths into a PHP/JSON/XML structure. I could imagine something like that and is flexible could be used to load videogames saves, or stuff like that.
&gt; [frameworks] improve the [...] quality of the final application. I'm not convinced of this statement at all. Most PHP frameworks focus on providing a relatively basic MVC structure and not much else. But a design pattern (MVC) is not an architecture and no framework can provide architecture because it is unique to every project. I'm not saying that frameworks make applications worse, but I often feel that programmers think using a framework is all that is required to create high quality applications, and that is absolutely not the case. Good code can be made with or without a framework. If you have no idea what good code looks like, a framework will at least provide you a little bit of structure for future refactoring. 
A valid point.
These issues are all very minor details and you only really pick them up in the implementation stage. Most developers will wait for the spec to be finalized before trying to implement it so you don't get these micro details till it is almost too late.
I had never tested my app before, so I downloaded the apache binaries to my server (windows / iis sadly) and it tested at 500 requests per second. When i tested it from my computer, where I can get about 1.2MB/s, I only got 50. Interesting enough, the app I tested was built on symfony2 and the app it replaced was built on codeigniter. I tested the codeigniter app and it only did 350, i thought it would have been faster.
router + a simple templating class
It doesn't really matter to me, considering that everything I usually develop is used only by a handful of people concurrently.
You are trying to make it sounds complicated when it's not: &gt; *All discussion happen on the mailing list* If people can't understand that, it's not the fault of the psr team.
What does "Wrap HTTP" mean? Can you give me an example?
Documentation(convention) is another major benefit of framework, knowing a project is based on a well-known framework, you know where to look when facing a problem, and how to learn, but most home made structures(another framework after all) don't have decent documents, with team members come and go, understand the project could be a big problem.
You should imagine framework performance benchmarks like a car acceleration tests. Phalcon is a race car and has a great engine, so it takes 0-100 in a second. Laravel is a truck with alot of valuable assets in the dorso, so it takes 0-100 in 5 seconds. The problem is real applications's performance isn't measured by acceleration tests. It is measured by how long it takes for you to reach the target point that is 5000 miles ahead. So, imagine phalcon quicky accelerates to 300kmh and gets on the highway. It cannot go faster than 300kmh. Meanwhile, your truck slowly reachs 50kmh, but it cannot go any faster. There is one good thing in real world applications: you don't necessarily need to move your truck to the target location via highway. You can cheat. What if you insert your truck to the cargo plane and fly with it to the target location? You will arrive quicker. That said, real world applications rely on too many cache layers that framework's core speed becomes inconsiderable. If I enable nginx cache or Varnish in front of Laravel, it will be much more quicker, because the actual requests will never hit Laravel. When it never hit Laravel, it will never boot PHP. Framework's speed will only matter if you can't cache anything. (e.g an API server) Also, Phalcon will be faster on it's own, but realtime applications aren't simply measured by framework related speed. What about external API calls that takes 2 seconds to run? What about slow/blocking MySQL queries that takes a second to run? So a real world application will look like this: Phalcon 0-100: 1 second + 1 second of waiting MySQL + 2 second waiting curl to process. (4 seconds total) Laravel 0-100: 5 seconds + 1 second of waiting MySQL + 2 second waiting curl to process. (8 seconds total) That is pretty much it. Do you know why developers pick Laravel? Because they're interested in all the assets it carries on the dorso. Like, they want to dig the ground to build their house, and look! Laravel carries an excavator on it's dorso! It has a Excatavator package builtin! So, they go with Laravel. Phalcon users are drag racers so they want to get the fastest engine as possible, but give up on many things: like, they require a 8 line highway (being c extension), they cannot run on muddy roads (extensions not being widely supported on shared hostings), when they need an excavator, they'll attach a dorso behind their racecar which will slow them anyway. That is pretty much how benchmarks and real world applications compared. For example, I currently develop my main application with Laravel (because all the assets it carries are real time saver) and develop my API with something that is much faster (because I have a huge IO on my public API so performance is extremely important, also I just need to carry a single apple with it, so I don't boost my truck to carry that, also framework's boot speed is really important since I need to respond in 30ms, so I pick a framework that boots in 2 ms) Lastly, frameworks and PHP are usually never the cause of the bottleneck. You can always put a load balancer, buy some servers and run Laravel in instances. You can use queues and process heavy tasks in seperate servers. You'll most likely will never reach that point where PHP/Laravel performance can't be scaled anymore. I'm sure you can handle billions of monthly requests using Laravel. Albeit using different nodes to scale, having alot of cache layers in the front. When you reach Twitter level scale, where getting rid of alot of unnecessary servers by switching to a faster framework profits you multimillion dollars every year, you take that step. Until then, don't worry. 
Ahh QBasic. 
Http object. Request/response .. like psr 7
It comes down to what you think a framework gives you. Phalcon gives you speed, but takes away flexibility and ability to debug the framework when an inevitable bug crops up. A userland framework has a significantly less chance of having a memory corruption or segfault bug (i.e. zero chance), for example. If you're using a framework due to peer pressure, because you feel like everyone has to have one, then Phalcon may be a nice substitute for the heavyweights. But there's a third alternative: selectively use light libraries to solve your problems, wire your app yourself, and don't use frameworks. This option gives you speed and stability.
Well, it's their fault for choosing the mailing list over github.
Probably should have replied to /u/Iconate. I wasn't making a case against "bloated" frameworks. Like I said, I plan on using open source frameworks for most of my projects from here on out. In my particular case we didn't need *any* of the features from any framework. No routing, no controllers, no ORM, no templating, none of it. What we needed was about 50 lines of PHP to glue together some .php scripts and connect to MySQL. (This was back when using the mysql_* functions was still the primary way to query the database) So I would have to disagree. There are times when "it has too many features" is a reason not to use a framework, although these days I'll use the Slim framework when I'm putting together a very simple project.
The problem I still see with using prefixes in this manner, is that there's still a sort of requirement for individual element classes to 'register' which prefix they will start using. It's either that, or force people to configure them once, globally. To make it work globally, even when multiple prefixes for namespaces are allowed, you still need to pick a logical unique prefix. Since the namespace url already serves this purpose, this didn't make a lot of sense to me. Consider this example: $ns = '{http://www.w3.org/2005/Atom}'; $writer-&gt;write([ $ns . 'feed' =&gt; [ $ns . 'title' =&gt; 'Example Feed', [ 'name' =&gt; $ns . 'link', 'attributes' =&gt; ['href' =&gt; 'http://example.org/'] ], $ns . 'updated' =&gt; '2003-12-13T18:30:02Z', $ns . 'author' =&gt; [ $ns . 'name' =&gt; 'John Doe', ], $ns . 'id' =&gt; 'urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6', ] ]); I didn't find this that far off from: $writer-&gt;write([ 'atom:feed' =&gt; [ 'atom:title' =&gt; 'Example Feed', [ 'name' =&gt; 'atom:link', 'attributes' =&gt; ['href' =&gt; 'http://example.org/'] ], 'atom:updated' =&gt; '2003-12-13T18:30:02Z', 'atom:author' =&gt; [ 'atom:name' =&gt; 'John Doe', ], 'atom:id' =&gt; 'urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6', ] ]); I didn't find either of these to be too different in terms of legibility, but I found it to be much easier to create a clean, context-free design when forcing people to go for the first approach. One design decision was to treat the prefix as strictly 'decorative'. Registering prefixes has no effect on any of the code, which allows you to never have to worry about mapping these. If I did map them, it would make a lot of things much harder to do. This is particularly the case during parsing. During writing not so much.
Immutability is a very useful property for a class to have. It provides a guarantee that the object you're dealing with is consistent across its lifetime. This makes it much easier to reason about code and removes a lot of possible bugs from the table. If your concern with immutability is about performance, then the correct fix is to fix the language and/or runtime. It's 2015. It's technically feasible to build infrastructure on top of immutability as both the soft- and hardware have become capable enough for this. 
&gt; it appears that your use case did fit a few frameworks Nah. Like I hinted at by saying the mysql_* functions were still the primary way to query the database, this was around 2006. Your framework choices were basically Zend, CakePHP, and Codeigniter, none of which fit the bill.
Wasn't phalcon surprisingly slow on benchmarks?
Why is no one talking about the usual bottlenecks? Database and filesystem. No matter how fast your framework is. Database and file access will slow down everything. This is why caching is so important at scaling. 
I only ever saw it on the Zend php 5.3 study guide.
You've touched on a lot of reasons why using a framework is a good idea, but none on why using another one over Phalcon is. And really, it boils down to the fact that Phalcon is an extension. That's a big hurdle for most devs/teams for various reasons. If it weren't for this fact, I suspect Phalcon would be pretty pervasive.
Perhaps it would also be interesting to see the mean seconds per request for each framework.
In 98% of all Web Apps the database is the bottleneck, because mostly your doing CRUD with some intermediate processes. That said, if your not planning anything really heavy you can go with any of the popular frameworks without running into real performance problems. Also scaling should not be a big issue. But if you design your database very bad your running into problems at any level. So stay with "hardware is cheap, programmers are expensive" and keep an eye on your database.
I suppose I'll have to trust you. I have never heard of this "JS" thing you mention. ;)