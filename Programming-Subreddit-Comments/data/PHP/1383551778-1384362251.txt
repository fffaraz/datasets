Unless you have a web application designed to service _a single client at a time_ it is completely irrelevant what a few hundred asserts in an application being executed _a single time_ does. It is however relevant what several hundred thousand, or millions of asserts do, because most of us design web applications to service much much more than a single client at a time. The fact is you do not appear to know enough about the subject to make useful comments, at all, you clearly don't understand how expectations work and what kind of impact using assertion has on an application. Fortunately, you, and I, don't need to care; the RFC is withdrawn, as am I, from internals ...
Maybe this isn't what you need, but why don't you use Silex? It seems like Klein really is only a router. If you would be using Silex, you could make providers for Mongo and Twig, and you could access Mongo from your Twig extensions. 
re. https://groups.google.com/forum/#!msg/php-fig/ogp03OHbVJ0/qNE3eP0aw4kJ
So, what's the problem? I didn't understand what exactly you want to achieve, but in any case you will need either to create service which will be somehow injected in twig (as an extension) or you can use twig's global context and inject there the service you need.
Ok, here's what I came up with, if I understood you correctly. Still, I don't know why you are using so exotic router. Symfony's router component, for example, will work faster with big amount of routes than this thing, because it won't just traverse through all the routes and apply preg_match to them, instead it will generate if-tree with strpos checks, so basically it will lower complexity of finding right route. (it's pretty interesting, you can have a look at it) $klein-&gt;respond(function ($req, $res, $service) { $service-&gt;twig = $twig = new Twig_Environment($loader, ...); // your tag will be injected with mongo connection so it will deal with database by itself $twig-&gt;addTokenParser(new YouCustomTwigTag($service-&gt;mongo)); }); PS I just noticed that you registered Twig and Mongo as lazy services in $app... Then you will need something like $app-&gt;register('twig', function () use ($app) { $twig = new Twig_Environment(...); $twig-&gt;addTokenParser(new YourCustomParser($app-&gt;mongo)); return $twig; });
wellâ€¦ LTS releases are meant to keep legacy software secure. you're just not supposed to use it for new projects. The idea is, that you develop project with whatever versions are in new distros, actively support it until next LTS and then forget about it for several years. I never understood why people use old LTS for new projects. Just doesn't make sense
I think this still leaves me with the issue of accessing Mongo from Twig's doDisplay method. Basically the code that gets written by Twig looks like: class _TwigTemplate123 extends Twig_Template { protected function doDisplay($context) { $content['tickets'] = $mongo-&gt;tickets-&gt;find(); // $mongo doesn't exist in this context } }
&gt; Also, looks like you setup a virtual host as local.dev, have you updated your hosts file to map that to your IP? This. C:\Windows\System32\drivers\etc\hosts Add this line: 192.168.56.101 local.dev
Then you'll need to create an extension which will export needed functions as Twig functions (Twig_SimpleFunction), so you can access them via context (though I don't know how to access them via context, but xdebug will help you find out)
why do you need to fire all matching routes? in Silex you have before and after filters to execute custom routes on a route collection ( a collection of routes ).
Within that article, it was stated that password() function was used to convert password string into hashed string. However on Mysql dev site there's a statement, as such: &gt;Note: &gt;The PASSWORD() function is used by the authentication system in MySQL Server; you should not use it in your &gt;own applications. For that purpose, consider MD5() or SHA1() instead. Also see RFC 2195, section 2 (Challenge- &gt;Response Authentication Mechanism (CRAM)), for more information about handling passwords and &gt;authentication securely in your applications. So, anyone please explain that discrepancies... 
I'm currently using http://faye.jcoglan.com/ with php and https://github.com/nchaulet/faye-client
If you are using php 5.5 and above you have to use the following function for generating password hashes.... http://php.net/manual/en/function.password-hash.php If you are using an older version of php, you can use this library to get the same functionality as the above function. https://github.com/ircmaxell/password_compat The reason for telling you should not use PASSWORD() MySQL function in your code is probably because its internal implementation of that function may change in the future. So if you take your applications database to a newer/different version of mysql with a different implementation of PASSWORD() function, your applications logins will not work. Because the newer PASSWORD() function may generate a hash for your applications user's login password which is different from the stored hash, which was generated by an older version of PASSWORD() function. 
&gt; The reason for telling you should not use PASSWORD() MySQL function in your code is probably because its internal implementation of that function may change in the future. As it did in the past - the way hashesh are generated by PASSWORD() ws changed in 4.1, and to support legacy software OLD_PASSWORD() was added.
I don't know if it's a good method, but I like to define a salt in a config file and use a hash function. Something like: `function hashPass($pass) {` ` $pass=hash('sha256', $pass);` ` $salt = SALT;` ` $password=hash('sha256', $pass.$salt);` ` return $password;` `}` Although I understand that a random salt for each user is probably a better idea.
I would like to make one update here. People are not stuck on 5.3 provided by LTS because they want to be more secure. They are stuck on 5.3 provided by LTS because they want to feel secure. Typically, LTS fixes are backported from PHP. That means if you keep current with stable PHP releases, you're **at least as secure** as you are in the LTS provided repos. However, that backport does take time. And they don't [backport everything](https://github.com/ircmaxell/password_compat/issues/10). So no, people may be under the delusion that running a LTS supported version keeps them "more secure", but in reality it is far from it. The only reason to run a LTS build, is if you have a support contract with the OS provider. Anything else is pure laziness for a primary language (the primary reason the server exists).
It's a bit of a micro optimisation, when that string concatenation is very unlikely to be the bottleneck in your application. If you're going to work on this code with other people, or even if you're going to come back and maintain it yourself later, err on the side of whichever is *clearest* rather than *fastest*
Using the MySQL PASSWORD() function also means sending the password to the SQL server in plain text and could potentially be intercepted along the way when using tcp sockets.
Nope, shouldn't be that, either!
see http://stackoverflow.com/a/6337021 - the part titled "Using PHP &lt; 5.3.7 (DEPRECATED)" 
Or even better, create a unique salt for each user in the database. 1. Set up a salt in the application's config file. This salt is the same for every user. E.g: &gt; $configSalt = '6espUfusp7pRAbUx'; // hard coded in app 2. Generate a unique salt string for the new user, say: &gt; $user-&gt;passwordSalt = 'bRucaGU7astA3rUG'; // autogenerate this 3. Create the password hash based on a sha1 encoded string combining the password the user enters with the unique user salt and configuration salt &gt; $user-&gt;password = sha1($passwordInput . $user-&gt;passwordSalt . $configSalt); This way the password is a merge of three different values from three different sources.
The RFC has been removed, Joe Watkins has left internals :(
I can't for the life of me understand what this library does.
Mmm, have you read the docs?
I read the entire readme, yes. Perhaps you should give some practical examples to highlight what it's used for.
Two problems: 1) as everyone else pointed out the PASSWORD() builtin isn't really appropriate for an application. 2) If you use a crypt-compatible hash with the $xx$ prefix, it may not fit in VARCHAR(64), depending on the hash. For instance [PHP's crypt function](http://php.net/crypt) has &gt; $6$rounds=5000$usesomesillystri$D4IrlXatmP7rx3P3InaxBeoomnAihCKRVQP22JZ6EY47Wc6BkroIuUUBOov1i.S5KPgErtP/EN5mcO.ChWQW21 as an example SHA-512 hash which is 118 characters. SHA-256 is 75.
No that's really not a good way of doing it. [PHP The Right Way](http://www.phptherightway.com/#password_hashing) covers a better way of doing it using the new password functions. I suspect you're not on PHP 5.5, so the link to password_compact that /u/i_make_snow_flakes is probably better. My advice would be to use something like that. In the past I have used the [crypt](http://us2.php.net/crypt) function and blowfish. The idea is to have a different salt per user (so cracking one password doesn't make it any easier to crack a second one), and to make it slow (to make it less practical to brute force). MD5 and SHA on heir own are bad password hashing functions because they are fast. **Edit:** I see you can't use the password_compact thing. Look at the crypt function I've linked to maybe read [this](http://net.tutsplus.com/tutorials/php/understanding-hash-functions-and-keeping-passwords-safe/). 
depends - if its just for a CMS used by members of the company its totally okay, if its for users of a social platform or anything use Bcrypt / salted passwords with a per-user salt
Please watch this: [ircmaxwell's password hashing](http://blog.ircmaxell.com/2012/10/password-hashing-in-php-talk.html)
You showed clearly you didn't know how expectations even worked when you said that opcodes are not magically removed, you showed clearly that you missed the point that an efficient implementation of assertion does exactly that. Whatever ...
I planned the backend development for only small number of people, mainly for admins (it's web for articles and community, where user don't have to login, just viewing the articles) Edit: will it be safe to save hashed password without all the fuss on saltings and bcrypt functions? Will there be a high probability an attacker might stole the admins ID?
Tacking on to the OPs question: what books what you all recommend? I've recently taken on a php job but it's been a few years since I did it full time and I want to get my skills up to date. I'm not so concerned with syntax and features, but more best practices and patterns. I've noted theunionstreets recommendation and will pick it up; any others? 
I see, so i assumed if i told those admins to use probably like 16 chars-length password, and hashed it with plain sha1, then at least it would make the attacker think twice before stealing admin ID?
In addition to what /u/camus2 said: If a controller in Silex returns `false`, it will continue to the next route that matches. 
as i said, if the attacker is already in your system, he would only be interested in passwords that are combined with other userdata - esp. emails, the length doesnt matter that much, but the thought is stll wrong, if you fear that someone steals those passwords, just use bcrypt - coding this takes less than an hour. see here, http://www.openwall.com/articles/PHP-Users-Passwords the library commonly used is phpass
I believe the new preferred method is to use the password_hash functions if you have them. If you don't there are bcrypt classes floating around. They handle salting and secure passwords in a much better way than using a sha1 or md5 or mysql. While you could be doing worse, you should be doing better if any secure or private information is exchanged. If not what you're doing is fine, and passwords are more likely to be stolen over http. It's worth noting that password hash is intentionally slow. The algorithm is complicated so that passwords are harder to brute force. Make sure you determine it's not overkill before you use it, and always think about what's best for your users If you look back at the original thread there are several pieces of similar advise with what you can do if you don't have the latest and greatest php 
Same here... I guess this is the part where the thing matches the stuff on all the pieces. It seems a library that provides a complex solution for simple problems (imo)
thanks for the link! btw: I never said that I plan to write my own framework. ;) I want to wrtie my own software _with_ a framework.
How can an older, non-official, incomplete (they backport fixes slowly, see ircmaxwell's comment) version be more secure? If you wanted to be secure, you'd update to the latest stable version.
While I appreciate the arguments of using one router over another; the core issue I was facing was independent of the router. I was able to solve this issue by creating an extension in Twig, that had access to the application context provided by Klein. From there, I was able to call the Mongo instance from the Twig template by using: $context['tickets'] = $this-&gt;getEnvironment()-&gt;getExtension('my_extension')-&gt;getApp()-&gt;db-&gt;selectCollection('tickets')-&gt;find();
The problem isn't with collisions, it's with speed. SHA1 is computationally efficient (by design); it's fast. If it takes 0.001 of a second to hash a password, in a day I can try 86 million passwords*. Now imagine I've not got one password to crack, but I've stolen a list of a million usernames and passwords to try and they are all unsalted. It's not going to take long to crack a fair few accounts. Just trying "password" will probably get me 100 or so logins. So to combat that you pick a hashing function that is computationally inefficient. If we play with the complexity of crypt/blowfish and set it so that it takes 0.5 of a second to hash a password, then you can only do 172,800 hashes a day. Compare that to 86 million. It's going to be a lot less practical for a hacker to attack the password list, while asking a user to wait 0.5 of a second to log on isn't so bad. *It's actually faster than that. My shitty little VM just did 10 million in 12 seconds: $start = time(); $i = 0; while($i++ &lt; 10000000){ sha1($i); }; echo time() - $start; //12 seconds
Why add the extra lair of encryption instead of adding a salt to the password? Seems redundant. 
Good response :) I'll look into the password_hash functions this evening when I get home from work, thanks! I read that password hashing functions are often intentionally slow, to deter brute force attempts (or rather, prolong them). I'd never use a MySQL function to hash a password either (advice to anyone who does!) - you'd be passing the plain text password into the query. If, by some miracle someone manages to inject their own SQL in that query (maybe you're still using mysql_query or you haven't used a proper prepared statement), and your query gets echo'd to the page - hello password in plain text, right there on the page (or the email, or whatever).
The aforementioned php the right way is a great resource, although not in dead tree format. 
I'm not sure what you mean by "adding an extra layer of encryption". In practice you'd add a unique salt per password too. The idea is that by adding a salt you protect against rainbow tables. By adding a unique salt per user you're making it harder for the hacker to crack the next password by figuring out the salt of the first. By using a computationally inefficient hashing function you make it harder to crack any password. The crux of it is that if you have password, salted or not, that's encrypted with a single pass of sha1, it's not hard to spin up a few GPU based AWS instances and crack it. A quick bash on my calculator: if you can do 25 million hashes a second using beefier machines, in a month you can try 6.5e13 different passwords+salts. 
http://en.wikipedia.org/wiki/Rainbow_table If you're trying to break an SQL database dump, you can build huge rainbow tables to hammer it with using specialized hardware which can do billions of hashes a second. Essentially you can calculate combinations of passwords and salts until you find them. If you use a proper password hash, you cannot rely on this hardware and building the rainbow table is prohibitively time consuming, effectively preventing brute force on a large scale.
A cool 5,250,000,000,000,000 hashes a month. Might be worth buying two 7970's then. 
Read about Gearman http://gearman.org/ . It might be helpful.
Totally read over the "with a". I swear I read "writing my own framework is a good idea". Hah. Silly me.
Something that was added later than this article was written, is the awesome 'prefer-stable' option: { .., "minimum-stability": "dev", "prefer-stable": true } That way you get _at least_ dev stability, but if there _is_ a stable version, it should use that. 
On an unrelated note, be *really* sure you need to use a BIGINT for anything. An unsigned INT has over 4 billion numbers available, so if you don't plan on going over that it's a waste to use BIGINTs.
6.5e13 is nothing when compared to the entire set of possible passwords. Imagine a password with a minimum length of 8 characters, which allows numbers, symbols, and is case sensitive. That means there are about 72 possibilities for each character in the password. 72^8 = 7.2 E 14 That means to crack a single password with 8 characters at the speed you mentioned it would take over 300 days. Add a unique salt and not only does it eliminate the ability to use rainbow tables but it also increases the time it takes exponentially (because the string length increases). 
Haha indeed, and I almost commented along the lines of _'...however, it does resemble a router, aka. URL matcher...'_
thanks! i'm going to peruse that as well. 
Same here, I use a hashed unix timestamp of the time the user registered as the salt. This is an interesting article and thread and I will definitely look at the new password_hash functions.
Which is still next to nothing when to compared to all possible password+salt combinations. Imagine a minimum password length of 8 and salt of 8 characters long. That equates to 72^16 possible combinations. 
Gearman is a popular tool for creating queues for running background tasks. php-resque is an interesting pure PHP implementation of a worker/queue system. You could have a central cron whose sole job is to put jobs on the queue for processing. In theory you could then have any number of workers to process the queue. If there are dependencies, a worker could add the next item to the queue for processing. I would avoid writing your own customized scheduling system, it's just another system you need to work on. This problem is not unique to you and has been solved before. You can look at flume for log aggregation.
I use [Celery](http://celeryproject.org/). It allows you to define tasks in python (tasks can be run periodically and on-demand). Python-task can easily call shell-script in another language trivially. Communications happen via AMQP, Redis or one of many [other backends](http://docs.celeryproject.org/en/latest/getting-started/brokers/index.html) There is a PHP client for it. It is called [Rhubarb](https://packagist.org/packages/zircote/rhubarb)
See elsewhere in this thread, that can be done in a month with a single GPU. Plus you might be trying to crack a million passwords (if you have that many users), not just one, so each hash has a million chances of being right for at least one password. So that becomes even easier still. I'm not saying it isn't difficult to crack a well salted sha1, but in my eyes *with today's technology, taking into account moore's law* it's still just a little bit too close to being difficult, rather than practically impossible. Either way: switching out a hashing algorithm is hardly rocket surgery. It makes very little difference in coding effort. Why would you choose a fast algorithm over a slow one? I'm not sure I understand what your argument is. Is it that sha1 when not used by an imbecile is good enough? Sure, but my point is that with a little knowledge you can easily do better, and if someone was writing a system that stored my password, I'd be a lot happier if they weren't using sha1. 
And that completely ignores how most passwords are created. There's a reason that a significant number of leaked hashes can be found quite quickly. You don't need to enumerate all possible combinations. You only need to enumerate enough to find the password. With dictionary and complex searches, this can be MUCH smaller than you think...
Are you on PHP5? * built-in functions: * [password_hash](http://us3.php.net/manual/en/function.password-hash.php) * [password_verify](http://us3.php.net/function.password_verify) Else * phpass * composer-compatible 1: [rchouinard/phpass](https://github.com/rchouinard/phpass) * composer-compatible 2: [hautelook/phpass](https://github.com/hautelook/phpass) * original: http://www.openwall.com/phpass/
If you are downvoting this care to explain why? I'm rather confused.
Wait, 100,000 rounds??? Where did you get that?
Trollololololol.
Mmmm not sure what part of my message would be trolling . . .
We use RabbitMQ to decouple the various parts of our application.
I was reminded that our example is closer to this Class MyClass { public function doSomething(MyItem $item) { /** do something to single item */ } public function doSomethingMulti(array $arrayOfItems) { foreach ($arrayOfItems as $item) { if (!($item instanceof MyItem)) { throw new Exception() } } foreach ($arrayOfItems as $item) { $this-&gt;doSomething($item); } } } In this example all elements in the array must be an instance of MyItem. If any are not an instance, doSomething cannot be called at all. Obviously the double iteration is not desired.
could do something like this. Comes down to preference. class MyClass { public function doSomething($item) { $items = is_array($item) ? $item : array($item); foreach ($items as $item) { if ( ! $item instanceof MyItem) throw new \Exception; //do something } } } *edit. was making it overly complicated
The [original RFC](https://www.ietf.org/rfc/rfc2898.txt) from September 2000 suggested 1000 rounds as a "modest" number. Given the rule of thumb that it should double every 2 years, 1000 * 2^(13/2) = 90509. So, close to 100,000. But really, as I said, you should test how long it takes your hardware to perform that many rounds and adjust it to be only as large as is reasonable for your legitimate users to wait.
Would you use javascript to hash the password before sending it back to the server in that case, or are you trying to suggest using ssl for the login page? Without ssl, or some form of client side hashing function, the password will always go out in plain text.
Thanks, gearman was at the forethought of my mind when I wrote this. Was wondering if/when someone would bring it up.
I think you used the wrong terminology. Maybe I just haven't heard it said that way. A full sha1 should only require 80 or so rounds while you may if you desire "include an iteration count in the key derivation technique." This just adds a iterative step that slows down the process but as I understand isn't an extra round in the actual sha1 algorithm.
I think you misread me. I'm not talking about sha1 at all. I'm talking about PBKDF2, used in conjunction with something like SHA-256. And I'm referring to PBKDF2 rounds/iterations, not SHA-256 rounds (which are hard-set numbers as part of the SHA2 standard). PBKDF2 could be thought of somewhat like doing a hash, and then re-hashing that output, and then again x number of times. Except if you do it just that way, you end up severely diluting your input and increasing the number of collisions, which a key derivative function like PBKDF2 avoids by repeatedly reintroducing the original input in a safe way.
Its probably that we are both missing each others point. I'll try and make mine clearer. I'm happy to listen to your side too. I know a wide enough salt makes it much harder. I'm fine with that. But what if your server is comprised such that a copy of your code and a db dump has been leaked. Your master salt and how it's used is now known. You still have a per user salt, but that needs to either calculated in your code or stored against the user, both are in the hackers hands now. You're back to simple cracking as the bits you are depending on to secure up sha1 are known. Now if you used sha1 or sha3, both are fast functions not being used for what they are intended for and therefore password cracking is back to being trivial. If you used a slow function designed for password hashing it would still be difficult to build a rainbow table. Yes sha1 is fine for most cases, but when it all goes to shit you'll be thankful for the extra 10 mins you spent implementing a slow function. 
Yeah, got it ain't about layout or other stuff. I did some searches on this and was a few articles worth looking at. Most seem to assume MVC but it isn't difficult to adjust. Zend Framework's rec : http://framework.zend.com/manual/1.12/en/project-structure.project.html Here's another : http://www.onextrapixel.com/2011/12/12/building-web-apps-file-and-directory-structures/ If you're doing procedural style coding, you should be using a /lib directory to store libraries. And with your specific example of an upload script, the upload files themselves should have been directed to a /media , /user , or /uploads directory. Self submitting forms is easy if you are using a front page controller. Other directories like /templates , /views or /user_views are up to your preference. Believe the min. would be to have 5 files in the web root. * /application_dir or /system_dir or /foosrevenge * index.php * robots.txt * sitemap.xml * .htaccess I'd add /public at least to define where publicly available resources are stored. Does that help ? I used 'project directory structure' as the query on google if you wanted to find more examples. 
When I stared out I was using unsalted md5s. Thank god I had no users. 
I took over a project awhile back with around 15,000 users, and the last developer has decided to store all of the passwords in plain text. Before I salted and hashed them, I took the opportunity to play with the database, and I found that about 1,500 of those users were using their email address as their password. I thought that was a pretty high number.
To quote someone I don't remember the name, but who's words are now ingrained in my brain: &gt; If you don't do SSL, you not even pretending to be secure
I completely agree. It just seemed odd to say that specifically using mysql's PASSWORD() function would cause the password to be sniffable. Any data sent to the server unencrypted is sniffable, whether you use the PASSWORD() function, sha1, blowfish, cyrpt, etc. Edit: HAPPY CAKE DAY!
Why not just: array_walk($arrayOfItems, array($this, 'doSomething')); which feels like idiomatic PHP As a bonus, modern IDEs like PhpStorm will recognize/validate the callback.
Does anyone know what's wrong?
&gt; the time they signed up This is not a unique value. Use their email address instead or a SHA512 hash of it. Non-unique values in any cryptographic method (including hashing with salts) introduces significant weaknesses. For example, you should *never ever* reuse a key in a stream cipher (yes I know this is old news, but still relevant): https://en.wikipedia.org/wiki/Stream_cipher_attack
One tip I would have is to run the admin section of the CMS on internal web server(s) with a reserved address (e.g. 10.x.x.x) that isn't reachable from the internet and heavily firewalled off. You could use MySQL master-&gt;slave one-way replication to replicate the tables necessary for the "public" database servers which serve the web servers. Thus, no access is available to the internal admin servers from the internet-serving ones.
Generally, I agree that less known stuff should never be run directly from the internet, but Composer is by now a well known, tested, reliable and spread out tool. At this point, being afraid of running something directly from their site is, to me, akin to being afraid to boot from a fresh download of a Linux distro for fear someone got into their server and put malware into the installation. I applaud your carefulness, though, and will look into whipping up a command that auto-checks the checksum of the download for future use cases.
The article actually contains a section about `prefer-stable`. It helps a bit, but you may end up getting things you did not actually want. For example: 'I was using `1.0.4` and now the new `2.0.0` release broke everything.'
no your saving it, then using the entire table to translate as many passwords as possible. When you have a DB dump the point is to get as many as possible, not one in particular. Take the 100 most common passwords, generate a rainbow table using all possible 16 character strings appended to the passwords, then check for matches.
Yep sorry should have clarified, always use SSL for sending anything secure. I was getting at the fact that there is no SSL on MySQL connections. Hashing in JS could technically work but it means you are no longer able to use salts, since they would be exposed to the end users through your JS source.
That won't happen if you've set the `require`'s sensibly, right? If I have `"silex/silex": "1.*"`, I'd expect to get the 1.1.x and 1.x releases, but _not_ 2.0. 
PHP (Publish) Sender Mode: https://github.com/pubnub/php#php-push-api JavaScript (Subscribe) Receiver Mode: https://github.com/pubnub/javascript#subscribe-only-mode-exclude-publish-key If you have any issues you can send a tweet to http://twitter.com/pubnub or email to help@pubnub.com
That would be huge and only useful a second time if you found another 16 char salted database dump. You'd be creating a rainbow table for each of those one hundred passwords with every possible 16 char combination. Each rainbow table would be gigantic and you'd have 100 of them. You'd also have to create 100 new ones if the next database used a 40 char salt and those would be exponentially larger. And a new set for an 8 char salt. It's just not practical unless you have several hundred terabytes of space hanging around to use for decrypt passwords, and at that point even the better hashing methods aren't safe. 
Sweet. Thank you so much!!!
Thank you for that. I knew password hashing was important, but I didn't realise just quite how fast it was on modern hardware. Now I see that using bcrypt is very important.
Haven't we all thought that at some point. "I'll just write a simple framework."
Glad things are moving forward! We are always online and here to help!
The title is a bit misleading, none of this is beyond inheritance. It's how to do inheritance properly. When the first snippet had `use SomeTrait;` I imagined it would be a post about inheritance vs composition in which case the title would make sense but then it's just dropped and forgotten about
I can't really give you a "this one is the best" for two reasons. One is that I just don't know, but the other is that I don't actually think it's a valid question. What I can tell you is the difference between them, and what that means. Laravel 4 is newer, but most particularly it's based largely on components from Symfony 2. This means that while it uses some parts of Symfony 2, the way it puts them together and implements them (the actual framework) is different. In particular, Laravel makes a lot more assumptions and has a lot more opinions about how things can/should work. Laravel's developer, Taylor Otwell, has basically decided how things **should** be done. Some people won't agree with those opinions and expectations, they won't agree with the assumptions Laravel has. They will find it constricting or limiting in some way. (Though this is probably more likely for someone coming from Symfony.) Symfony doesn't make nearly as many assumptions. The framework is more flexible and less opinionated. What this comes down to is probably that Laravel 4 is easier to learn, and Symfony is more flexible. If you were going to reach a "functionality cap" you'd probably hit it on Laravel before Symfony, but that said I doubt most users would actually hit one. Personally, I'd recommend Laravel over Symfony for most users. It's very easy to get things up and running, and has a nice architecture. I respect Otwell's decisions (he's way smarter than me) and am happy to follow his lead on how things should be done. I've tried learning Symfony in the past and hit a wall, but Laravel has been fun to learn. This is going to be a strongly opinionated topic. Some people value different things. For me, as a thicko with no exposure to MVC frameworks, Laravel has ticked all the boxes. More experienced devs with their own fixed preferences may prefer Symfony.
Disciples of sprintf!
Take at look at https://github.com/auraphp/Aura.Web/blob/develop-2/src/Request/Client.php#L185-195 where $this-&gt;ip gets set. ;-)
If it matters: MVC frameworks are easy. Models hold all of your queries, Controllers hold all your functions, and the views are just that, what gets displayed to the end user. Find a easy CRUD tutorial using a framework and study it for a few minutes and you'll have it down in no time.
:)
You can put it in a service class or something like that..and use the methods of this class to implement this kind of higher level functionalities.
Good tutorial.. din't know about git bisect.. learned something new.. thanks. :)
Yep, I'm new to PHP, and after trying to start something with Symfony, I turned to Laravel 4 and got something up and running within a few hours. Excellent tutorials I found: * [Laravel 4 Primers: Overview](http://codebright.daylerees.com/the-primers) * [Simple guestbook in Laravel 4](http://laravelbook.com/laravel-introduction/) * [Actually building a simple website with Laravel 4](http://www.codeforest.net/laravel4-simple-website-with-backend-1) 
I agree with you @pmjones. Most of them here are reading from the context of Laravel or Symfony. Sad to see people coming to blame you.
Btw as we are forming internal policy I am using your welcome email as en example on how I want us to do things. Having a welcome email asking about use and offering support is exactly how companies should make sure they grow. Awesome!!!
I was in the same boat a couple of weeks ago, and here's why I (and my team) chose Symfony over Laravel: * maturity: this is obvious, it's been around longer, has a more knowledgeable community and its documentation greatly outshines Laravel's (not that L4's is bad, but S2's way more detailed). This also means that they can release LTS releases, while Laravel has a history of breaking backwards compatibility with previous releases. We felt that we could invest in S2, because they seem to have figured most of their stuff out, while L4 just started (they started using S2 components and Composer only in the last release) * loosly coupled: this was important to me because I was burned before by opinionated frameworks (like Yii) in the past. * Silex: Sinatra inspired micro framework that is built by the same people as Symfony and can be used for everything that S2 is too big. Same components are used, same quality etc. * lack of hype: this is a personal opinion, but I found Laravel's hype to be distracting, especially since I don't understand it. It seems to me that people who are impressed with Laravel are either beginners or have been sleeping for the last 3 years. Don't get me wrong, it's a good framework, but there are frameworks that have been doing the same for a while now. Due to this hype people are constantly trying to sell me something (be it a beginner guide or a more detailed overview of the framework) while Symfony and its community ( or other frameworks like Yii for that matter) give you all of this and more for free. I feel like there's a conflict of interest here. There's also a good talk by Fabien Potencier (lead dev of Symfony) about Symfony and its components http://youtu.be/0erGiEm07b8 
This is problematic since HTTP_X_FORWARDED_FOR is client controlled (just like User-Agent, for example). The code in Client.php overwrites the actual server variable with a user controlled payload. This can happen unless the HTTP_X_FORWARDED_FOR variable is set by "you" (by a reverse-proxy which sits in front of the application).
I use Kohana 2.3 all the time. It has everything i need and is very easy to use. What advantages either of those frameworks have over Kohana?
I agree with all your points except for the last one. The last one seems to be purely based on prejudice.
The hype part or the selling part? I wouldn't mind the hype if the framework lived up to it. Maybe it will. For instance I think that Rails lives up to its hype. 
Can you elaborate on the wall you hit with Symfony?
To be honest, sounds like you're a bit stuck in the "comfort zone". I believe Kohana 2.3 is five years old, right? A lot has changed in PHP, which makes it a much more robust language. To actually answer your question: - Anonymous functions - Autoloading - Decent template languages (Twig, Blade) - Less NIH, more interoperability - Composer
Kohana (with few little changes) works fine with PHP 5.4 so it is possible to use all of this. Except i am not sure what's the point in using things like Twig if PHP is a template language itself...
CryptGenRandom is used on Windows. It is the Windows equivalent for /dev/(u)random. As long as you are on PHP 5.3+, your best bet is to use MCRYPT_DEV_URANDOM (I don't recall any slowness issues with mcrypt_create_iv with MCRYPT_DEV_URANDOM). By the way, are you sure you want to mix random data from multiple sources on your userland PHP code? To avoid (possible critical) bugs, just stay as simple as possible and get the random bytes from /dev/urandom (or the Windows equivalent CryptGenRandom with mcrypt_create_iv function).
&gt; Skinny controllers, dumb views thats how it should be done
never hit any functionality wall in laravel, you can do it how you want, its as flexible as symphony
Not really. It was more just a matter of not having any idea what I was doing. I just found it... hard. I didn't really get anywhere. Maybe I didn't stick with it long enough or whatever. Laravel I was just able to get into more quickly.
Yeah, I'm just going on "what I heard". Which is my polite way to say I pulled it out of my ass. I just wanted to present a balanced view. :)
I don't think that's fair. It's an opinion, not a prejudice. People value different things.
Why if 2.3 works just fine?
If you have to make changes, it's not up-to-date. You really shouldn't stay with an old framework just because you can't be bothered changing. &gt; if PHP is a template language itself It's not. It really really isn't. 
You don't pick a Framework just to pick one. You pick the correct tool (Framework) for the task you have. They're different. And so are your projects.
This is the worst possible attitude. "I'm going to keep doing the same thing over and over because it 'works'". You'll never grow, never improve, never learn. Your career is essentially over now. Well done.
But what's to improve? It has all you need to build decent web app. So if I change the directory structure, class names, reorder few things add bloated template engine will I be improving? Nonsense.
&gt; If you have to make changes, it's not up-to-date. After my changes it is. &gt; It's not. It really really isn't. So why my templates work just fine? Another template engine just adds new dependency to maintain, new syntax to learn etc. just so you can write {{variable}} instead of &lt;?=$variable?&gt;
I don't want to trust any single PRNG since they can have [bugs](https://www.schneier.com/blog/archives/2008/05/random_number_b.html) or even [designed flaws](http://arstechnica.com/security/2013/09/stop-using-nsa-influence-code-in-our-product-rsa-tells-customers/). Mixing is done with hash-hmac-sha256.
Kohana manages scopes, you dont have to worry about it
it does, but, bear in mind, it took a while to get where it is now. there was a time where rails was all hype and there were the folks complaining about the hype machine.
Solarium should be a dependency that is injected into your decision-making class (using the service container in Symfony2 this is quite easy to achieve). That way, in a unit test you can insert a mock class instead that gives certain results. That way, you can unit test your logic seperate of your Solr index.
This is a fair point, but your implementation is now suspectiple to multiple points of failure. Given the current understanding on the field, /dev/urandom will be fine in a web app situation (the problem is "cold boot" issue, but this will not occur here). It is better to trust the crypto experts on this, and just stay simple and read from /dev/urandom (as it is recommended). For example, see http://nacl.cr.yp.to/ and how it handles randomness. P.S. I'm writing a small blog post on this with a bit more detail about "cryptographically secure random number generation in PHP applications". Hopefully get it posted soon.
&gt; What this comes down to is probably that Laravel 4 is easier to learn, and Symfony is more flexible. If you were going to reach a "functionality cap" you'd probably hit it on Laravel before Symfony, but that said I doubt most users would actually hit one. Easier to install, too, in my experience. When I last installed Symfony, it killed Apache on my dev box. That *really* surprised me, and it pissed me off, too.
&gt; Prejudice: preconceived opinion that is not based on reason or actual experience This is what my definition of prejudice is and, based on my assumptions of op's commments, seems to be the case in the situation.
Okay, so then we agree that Laravel doesn't live up to the hype. Why are you saying the last point is prejudiced then?
Would really like to see these get absorbed into Laravel's core, to be honest.
Now would probably be a good time to stop talking before you sound any more like an idiot.
It's a good read, but i suggest you read comments. Most people agree that using template engine is counterproductive.
My implementation is very similar to [this](https://github.com/ircmaxell/random_compat/blob/master/lib/random.php), but it always requires at least two sources to be available.
One of the reasons... But definitely a good example of one of the many problems.
As hinted below, my main point was to show that you can do OOP without inheritance, and also to introduce a new viewpoint of how to approach OOP. If it doesn't "click", the next post should really drive the point home (once I finish it). 
Very true, though what if they were to change their email address? The hash would then no longer be valid (unless you got them to re-enter their password to confirm the email change, then re-hashed it... that would work actually)
Out of curiosity, why is it so important for a salt to not be predictable? I would understand how it would be very important for generating unpredictable SSL keys, but isn't a salt's purpose basically only to make rainbow tables not work? Wouldn't even a fairly predictable, very short salt also be more than adequate for its purpose?
Where do you see salt mentioned? But no, salts don't need to be unpredictable. They need to be unique. And with a significantly strong random source, and a significantly long random generation, you can be provided with statistical uniqueness.. With a generator like `/dev/urandom`, a 128 bit salt is typically quite sufficient. To put that in perspective, the 16 characters would have 2^128 permutations. If every person in the world (7 billion), generated 1 salt per second, it would take over 100 years of generating those salts to have a 50% chance of having just one single collision across all of them. (thanks to the [Birthday Attack](http://en.wikipedia.org/wiki/Birthday_attack))...
If a single item is an associative array, and you still want to be able to handle both single and multiple items in one method each, this is what I usually do. One is for values, the other is for references: /** * Do something with an associative array or an array of associative arrays. * * @param array $items * @access public * @return mixes */ function doSomething($items) { if (!$items) { return; } if (!is_int(key($items))) { $items = array ($items); } foreach ($items as $item) { // do something } return $ret; } /** * Amend an associative array or an array or associative arrays with data * * @param array &amp;$input * @access public * @return void */ function amendItems(array &amp;$input) { if (!$input) { return; } if (is_int(key($items))) { $rows &amp;= $input; } else { $rows = array (); $rows[] =&amp; $input; } if (!is_numeric(key($items))) { $items = array ($items); } foreach ($items as &amp;$item) { // amend items with data } } 
Oh, you didn't. If it's okay, I would like to hijack your post then and ask about this as I was always curious. So why is it important for salts to not clash? Even if there are clashes, wouldn't it only matters if the passwords were the same as well?
Yep, I din't mention it's only meant for salt generation. Btw thanks very much for all your blog posts and stuff you put on GitHub. I've learned much from you.
You'll find this opinion to be prevalent in the minds of many developers, mine included. "Artisan"? I'll love developing in PHP now because I use Laravel? The marketing is very distracting, and one of the main reasons I stay away. The other is the absolute over-use of statics, even though he's calling them facades. I highly dislike this because it builds bad habits in developers who may not realize what's going on behind the scenes, and if they ever encounter a non-Laravel situation they'll continue doing the same thing and run into problems with testing, etc.
Awesome! I'm glad that I could help! And thanks for the kind words!
Interesting article, certainly will give it a go if one of "those" bugs pops up again.
I see, but aren't namespaces just bells and whistles? They just trying to bring all the nonsense from Java. If PHP was meant for something different than web development, i could understand. But that stuff is just introducing another level of unnecessary complexity. What do you use namespaces for? 
Btw2: why doesn't password_compat use mcrypt_create_iv if PHALANGER is defined?
Well your reply really makes me agree more with what the other commenter sai about you just being in comfort zone. Namespaces bring obvious features: * No need for Super_Long_Unreadable_Mess_Class_Names. Maybe your apps don't have so many nested levels and you haven't stubmled into this problem, but right now I'm editing a PHPixie\DB\Driver\Mongo\Conditions\Operator class which would be ridiculously long without namespacing * The ability to easily substitute classes later: use Awesome\Implementation as Implementation //can later be switched to use Awesome\OtherImplementation as Implementation Not to mention Kohana 2.3 doesn't receive any security updates or bug fixes anymore. Also it has a ridiculous "hook" system which was abondoned byt he developers in the 3 version 
Reading all of the other replies makes me think we've just been trolled. :-/
What a contentful statement. Is there a reason why do you need such a bloated framework just to pull some data from the database and show it to the user? (which is what any website essentially is)
Mercurial also have similar bisect command. Even svn have. Just saying.... 
Mmm, yes, you're right. Would need a list of trusted proxies there. Thanks for pointing this out!
Thats correct. No problem!
&gt; PHPixie\DB\Driver\Mongo\Conditions\Operator If you use things like that, there is seriously something wrong with your application. Definitely you caught some corporate/java thingy virus :) &gt; use Awesome\Implementation as Implementation This just creates mess - but i can see the point - the more mess you make, the more you have to spend time on your code and in some areas you get paid more. Kohana 2.3 is old and i have not seen any exploits for ages. I am actually working on modified version so it does have some fixes for bugs that i found. I can say that this "hook" system is indeed flawed, but that is just one of the few downsides. That framework just works and i especially like how it reuses PHP for templates and how MVC is organised in general. 
 function getRandomNumber(){ return 4; // chosen by fair dice roll. // guaranteed to be random. } &amp;nbsp; [^\(Credit ^to ^xkcd)](http://xkcd.com/221/)
[Image](http://imgs.xkcd.com/comics/random_number.png) **Title:** Random Number **Alt-text:** RFC 1149.5 specifies 4 as the standard IEEE-vetted random number. [Comic Explanation](http://www.explainxkcd.com/wiki/index.php?title=221#Explanation)
Not sure what you're saying?
I've done similar things with strings a while ago: https://gist.github.com/raveren/5555297
Please elaborate on how would you structure PHPixie\DB\Driver\Mongo\Conditions\Operator ?
Yeah the SVN version is a seperate tool modelled off of the git/hg command so it behaves exactly the same. The mercurial version was also released a few years after the git implementation but I do agree that this could've been a more tool-agnostic approach seeing as Bazaar and Fossil support it as well. 
Yes, but that's the state of brute forcing for low hanging fruit from a compromised password DB dump. Or at least that's the Cole's notes version of why the big security gain for the bulk of the passwords is handled by bcrypt or some other proper password hash which takes almost .5 seconds to computer. By the nature of the hash calculation, you cannot buy specialized hardware that would hash 60 billion a second, and you could not even build a rainbow table in a real time frame for a 2 character salt. Edit: and just as a note, you create those huge rainbow tables, then link them back to the DB to get as many password/email combos as possible. Those are quite valuable, especially if they get into your email. People with simple passwords also tend to be people with password reuse problems, making the hit rate better than it should be.
It performs query optimizations while supporting nesting logical operands. Mongo qill not use indexes on nested logic operands. Right now I believe you've just never done even a medium sized project. Otherwise you would know why its a good idea to follow SOLID principles and keep stuff separated in different classes
ORM is alright for simple stuff, but in a large scale projects where you have to execute complicated queries using ORM is just nightmare to debug and maintain. Probably you would spend more time debugging why ORM is not getting things right than just optimize query by hand. Some companies hire people to just do that. ORMs look nice in the docs and sure for a simple blog or cms it is enough and indeed speeds up work, but for high traffic large scale projects you have to do it by hand.
You're missing the point of dependency injection. In your second example the controller is choosing which objects it should use. With dependency injection, whatever instantiates your controller is supposed to choose the controller's dependencies (which is what happens in the first example). As a side note, you could simplify the controller by handling the password hashing inside of your user repository. That would get rid of one of the controller's dependencies.
Maybe take a look at [Pimple](http://pimple.sensiolabs.org/), which creates dependencies on demand as they are needed.
pimple does exactly what i'm referring to in the first example
Your app should not be aware it's being dependency injected. If you are passing DI container within your application, is not DI anymore. What's worse you are actually hiding real dependencies, so there is no way to tell, what is required in order to instantiate your UserController. In your 2nd example you just essentially have created service locator disgusted as DI. "Don't call us, we call you" - that's the hollywood principle and that's what in essence, DI is all about. This is asking, not telling: $this-&gt;hasher = $this-&gt;app-&gt;make('hasher'); If you are in doubt, try to write a test, for both of your examples. It should become clear, very fast that implicit defined dependencies are much easier to work with or maintain. While service locator approach requires to maintain/care/clear the global scope. I personally use root composition approach for my DI: http://blog.ploeh.dk/2011/07/28/CompositionRoot/
I'm not sure you're understanding my point. Pimple doesn't alleviate the problem, it encourages it. 
Passing the container effectively turns it into a service locator, which is indeed an anti-pattern. There are numerous issues with using a service locator, namely: * It creates an unnecessary dependency to the service locator/container * It hides class dependencies * Errors only reveal themselves at runtime * It makes maintenance harder as it's unclear what resources you are working with, and it's very easy to make breaking changes which would cause code somewhere else to stop functioning and not be notified of it Instead, you should inject dependencies via their interface/type, not by passing a container. I believe the issue you are having is that you find it tedious to retrieve the resources from the container and inject them yourself, but if you have an event-based architecture, you could easily have a service provider jack into the stage of that resource's invocation and inject your resources. Also, having *some* resources in the container (i.e. those that make sense putting there, such as the things people usually tend to implement as singletons) also makes this easier for you, as you could have the factory wire the dependencies for you. 
&gt; In your second example the controller is choosing which objects it should use I'd have to agree and disagree. While the controller is explicitly asking for a dependency, it's not choosing which object is returned by `Container::make()`. This may be more of a service locator pattern, but I find both DI and SL patterns to be equally easy to test, and both introduce dependencies, so it really comes down to preference.
Thanks for response. Could you clarify your second point, "errors only reveal themselves at runtime"? When else would errors reveal themselves? The biggest issue i'm seeing is the wastefulness of the object creation. Classes have "dependencies" that very often never get used. 
Then maybe you should explain your pointer better. The bulk of your post talks about the waste of passing dependencies that may never be used, so if you're asking something else, you should be more clear.
Having some objects created for nothing is not critical on most applications, but i think i undestand your point. On pimple, you can use the method "share" and let the container to worrie about instantiate things. it will create the object only when you ask for and will give you the same instance on the second call. Reference: https://github.com/fabpot/pimple#defining-shared-services Obs: English is not my main language, sorry for any mistakes :)
Missing dependencies, passing dependencies of wrong types etc.? These are easily detectable from an IDE. 
This question is extremely vague because you have yet to figure out why the application is slow. I would do that auditing and find out that first before trying random things. As for the other points, Apache is fine, but definitely switch to Varnish for HTTP caching. PHP-FPM and upgrading to 5.4 or 5.5 are also things to consider. 
The application is not slow but I can tell you the faster it gets the higher its conversion rate. So I am just looking for ideas to speed it up and want to get advice on what will have the greatest return on my investment. Edited the post.
gotcha. thanks. 
I discussed this in my post [A Triste Against Service Containers](http://blog.ircmaxell.com/2012/08/object-scoping-triste-against-service.html). 
Because Pimple encourages constructor injection, it will create instances that have the potential to never be used. Pimple does not solve the concern i have. I'm just trying to get a commentary going on the downsides of classes being container aware.
Yes, although `Pimple::share()` is used to return a static instance of a class. Even without `share()` Pimple creates dependencies on demand. You may configure hundreds of dependencies, but none are created until you ask Pimple to create them. You are absolutely right though. Worrying about creating a few objects which may not be used is a waste of time and thinking.
thanks. i'll definitely read through this.
I already addressed your concern: &gt; You're over thinking things, and should have bigger problems to consider than whether a few class instances passed to another object are going to be used or not. In regards to Pimple I said: &gt; Your only real concern should be avoiding a container that creates hundreds or thousands of objects that will never be used I didn't say Pimple solves your unused objects problem. That's not a problem. Please take the time to read and comprehend the responses being given to you, instead of trying to rapid fire responses.
they aren't needed if the **show()** method is used
You are correct, you found the DI plot hole :D Lazy loading versus not exposing something similar to a Registry (bad practise), you have to choose one over the other. BUT what you can do is make another class implementing the IoC interface, you could make a restricted IoC by passing the original IoC and an array of "allowed" keys. This way you can always just pass a restricted IoC object to each class instance, specifying in advance which resources the object should have access to. This way you can both not expose your entire IoC, maintaining good practise, and also support lazy loading at the same time.
&gt; My only concern with Magento aside from bloat is their code doesn't use the most modern best practices that are emerging. What specifically are you worried about, the community has come up with many of the goodies that are not default Magneto such as: * PHPUnit * PHPSpec * Composer * Redis * Modman How big is this site going to be? It really affects the choice you need to make, if a decent size and you can afford a decent architecture I would go with Magento. Not heard of Sylius, looks interesting will definitely have a poke around I think.
You seem to be confusing making "me think" with spoon feeding you the answers. You say you want a discussion, but you respond to the beginnings of a discussion with hostility. Good luck. &gt; You can lead a horse to water, but you can't make it drink. \-Anonymous 
Specifically the PSR standards from the PHP-FIG. It's not really a huge deal, but sometimes Magento just feels cumbersome to work with and hard to find documentation. That being said, I haven't done a lot of work on magento platforms and I may be just looking in the wrong places. 
thanks
I've read somewhere that the next version of Magento will use Composer together with HTTPKernel, Twig, and perhaps some other Symfony components. That doesn't help you right now, though. 
Yeah documentation is pretty bad, but once you use it enough it is normally fairly easy to step through and work out the "Magento" way of doing things. Enterprise level ecommerce projects are large, Sylius does look like a good replacement for OpenCart but I don't think it could touch the Magento space.
You can also make beer without alcohol. Is it still beer? I guess. I agree that inheritance is not "strictly necessary" for OOP in the same way that alcohol is not strictly necessary in beer. In my personal experience so far I would agree with your (from what I can discern) conclusion that you just end up using a combination of inheritance and composition and that's totally fine. I have found so far that traits and composition are best reserved for and suited to things like polymorphism where you're tacking the same behaviour on to disparate objects rather than as a substitute for inheritance altogether though. I think inheritance and extension is still a good thing to use and enforces dependencies within a given logical boundary, e.g. - My "email" namespace in my app can use inheritance all it wants, but when I want to tack a "mailable" behaviour on to an "invoice", compose that behaviour into the invoice rather than extending something from the "email" namespace. The coupling argument here is pretty weak in my opinion, regardless of which option you choose you're going to be introducing a dependency on something, whether it's a composed behaviour or extending another class, it's just more convenient and makes more sense to compose the behaviour in scenarios like this. If, however, I wanted to create a "billing" system in my invoices namespace that cobbled together and emailed a bunch of invoices, it might make more sense to extend some base class from my email namespace (like a distribution list) vs. tacking on a "distributable" behaviour. I'm assuming that (for the purpose of this example) the billing system really would be a distribution list at it's core, not a composited class of many behaviours that just happens to have email distribution as one of its functions.
Yes. I think the thing about using share or not is by choosing to use the same instance or a new one.
That would be a great step forward for Magento. Maybe some better documentation too :)
I am very happy with Prestashop
Yeah, I'm not trying to go enterprise level luckily. I think I'll look further into Sylius, and see if it's ready for production yet. It seems the community is actively developing it, which is fantastic.
Another good post. It kind of meandered around a bit, but made for an enjoyable read.
You know, OpenSSL uses /dev/urandom. And if OpenSSL's broken, so is pretty much all cryptography commonly used on the Internet today. I somewhat doubt that your service is more important than real-time access to everyone's email, credit card purchases, and online banking, or you *probably* wouldn't be programming it in PHP, statistically speaking.
No I haven't, but now I sure as hell will give it a try. Looks like it should save a boat-load of time. Thank you!
OpenCart has always been a pretty quick setup and I've used ZenCart before, but not in a while. OpenCart has definitely been my go-to.
&gt; You know, OpenSSL uses /dev/urandom Yes, but it also does quite a bit more. It is good to acknowledge this: http://timoh6.github.io/2013/11/05/Secure-random-numbers-for-PHP-developers.html#what_is_wrong_with_openssl_random_pseudo_bytes
Just a couple notes: Try nginx instead of Apache. I'm not trying to sound like an nginx fanboy, so I'm not going to rant about it, but just give nginx + php-fpm a try and see what you think. Stick with application based page caching, because caching dynamically generated pages with Varnish is kind of a pain. Unless your pages have absolutely zero state. However, I still recommend Varnish to cache static content, such as images. A request for static content handled by Varnish, is a request your httpd doesn't have to handle, and that makes your httpd happy. That being said, I've never used Varnish installed on the same server as the httpd, and I'm not sure you'd get a huge performance increase when Varnish and the httpd are sharing resources. The database is almost always the biggest bottleneck in an application. Gather a slow query log, and index, index, index. Improving your queries and table schemes will usually give the most noticeable performance boost.
No, I will give that a try, thank you for the suggestion.
Ahh nevermind I see you are Core Managed since you are using Ubuntu. Unfortunately Best Effort only gets extended to fully managed boxes. 
well that's an interesting thought. I'm surprised i haven't seen this more often. Following this idea it would seem like you would split a typical controller into at least two for one resource, **UserViewController** and **UserStoreController**. I guess it really depends on how efficient you want to be. This comment opened my eyes a bit. thank you
As far as spinning a new instance take a look at what the Storm Server API has to offer: http://www.liquidweb.com/kb/a-brief-introduction-to-the-storm-api/ https://github.com/liquidweb/php-stormondemand http://www.liquidweb.com/StormServers/api/docs/v1/
The question is whether your application being broken would affect your users significantly compared to all the other things that would be broken if OpenSSL's RNG was found to be flawed. If it wouldn't, don't bother putting extra effort in; you will likely flaw your application in even worse ways. If it would, go find a different crypto library to use.
Recommend taking aoom at Stripe. 
I seem to recall that this sort of criticism was thrown at Symfony back in the day. This is what they said about Rails. And this is what they are saying about Node.js now. Heck, this sort of thing happens to most new interesting things. There are always naysayers. Eventually they get established and then accepted and then the hype moves over to some new tech. :) About using static, I see your point, but I don't see it as a reason not to use a great tool.
Upgrade to PHP 5.5 and install the Zend Opcache. Really, really helps.
Do you think I should try and upgrade Ubuntu? Will it make the php upgrade easier? Also when you say "install the Zend Opcache" this comes installed with PHP 5.5 no? As in all I have to do is upgrade to PHP 5.5 right?
Yeah that looks like a good book!
Yes thanks for this.
Prestashop looks nice and full-featured. At very least they're up front about what you're getting. The site is clean and definitely less abstracted than Magento's. OpenCart still seems like the better choice for a lighter weight shopping cart application.
I'm looking at the code right now, and maybe it's just me but a lot of it just doesn't make any sense to me. private function mergeBuffers($buffer1, $buffer2) { if (ord(self::$state) % 2 === 0) { return hash_hmac('sha256', $buffer1, $buffer2, true); } else { return hash_hmac('sha256', $buffer2, $buffer1, true); } } first of all, why the state? and why merging to buffers with hmac? Then in the genSecure function he generates multiple random numbers and depending on whether it succeeds or not he overwrites the or merges them using different random number generators. Why? Why not use 1 algorithm? I have more questions but I need to run. https://github.com/ircmaxell/random_compat/blob/master/lib/random.php 
Installing Varnish is a great first step. Then I'd move onto PHP-FPM which I love. But yeah, like the others in this thread said, what exactly is slowing down your application? I wouldn't suggest switching to AWS as it might require restructuring your application for negligible gains. I'm a huge fan of Linode and you can get some pretty great response rates with them. Let us know what you do and what works.
Stripe is a payment processor, not an ecommerce platform. 
Prestashop sure is a great platform. The community is growing rapidly, it's it relatively easy to extend the functionality. Despite the not very good documentation imo it's well written and easy to navigate through the source code and understand it as well. I personally maintain a shop with &gt;20k products and Prestashop handles it with ease.
In my experience the best thing to do is to get a profiler on it like xhprof to see where your code spends most of its time. You usually find that there are a few pretty simple things to do that make a huge difference. 
&gt; will look into whipping up a command that auto-checks the checksum of the download for future use cases. Good stuff. Sorry if I'm coming across as a little paranoid, but even php.net isn't immune to compromises as we are all too aware of.
It's https://github.com/timoh6. Glad if this helped.
&gt; "If we removed inheritance from the equation, what doors would that open" Haskell. Jokes aside, I look forward to the next article in the series! You've got my attention.
How many SKUs do you have? Is this an existing site or are you looking to re-platform? Why are you building the site? What I am getting at there are a lot more questions that need to be asked when choosing an e-commerce platform. Typically the life for a e-commerce site is roughly 5 years. If you want to build a business off of this site, rather than just something to play around with, limiting yourself to php, rather than many of the available Saas services, or even other languages, might not be your best option.
I write nearly all of my controller actions as independent classes, unless I can effectively group together a few that have shared dependencies. Take a look at the https://github.com/jonleighton/focused_controller for some further reading, though it's rails based.
If the optimisation is the only thing that bothers you, you could look at injecting lazy proxies, see http://symfony.com/doc/current/components/dependency_injection/lazy_services.html
I don't think it's all hype either, but I constantly get the feeling that people are trying to make it out be PHP's great response to Rails or something like that. When equally nice/nicer frameworks exist and have been around for some time. 
thanks for the link. didn't know this existed
Thanks.
You should not be working for anyone, anywhere. I would not allow my company to hire you. So incredibly ignorant, talking out your ass about things you don't understand with no interest in improving yourself or your ability simply because your old, unsupported framework does everything you want it to with no appreciation for what it doesn't do.
Production profiling is always nice because you can see better which areas represent hot spots for optimizations. While just speculative optimization might not result in as much value. The problem with it is that you would have to configure it to profile a small percentage of requests, and aggregate those results. In practice this turns out to be hard.
I'm hoping someone can enlighten me, what exactly is a "secure" random number and how is it different from a non-secure random number?
I'm pretty sure sublime text is non-free software...
Sylius is nice and light weight. A few bugs but nothing too severe.
The only problem with it i'm finding is that it's not even been released as beta yet.. That sort of hurts my changes of winning my boss over on using it. Because I'd absolutely love to use that.
Anywhere from 1000-5000 SKU's most likely, across multiple sites. We're trying to re-evaluate our ecommerce platform, currently we're using OpenCart but we're trying to shift our paradigm into a platform we can deploy quickly and actually architect to be a good solution. Personally, I feel like OpenCart is a piece of trash and I really want to move away from it. It doesn't have proper extension support, the developer doesn't care about serious security vulnerabilities, the code is terrible. I just don't want to work within it, maybe I'm being ridiculous but there has to be something better out there that doesn't suck to develop for.
New commit, with attribution to you ... https://github.com/auraphp/Aura.Web/commit/53fea58aa91511f554f8eaf9245137e500dbae7e#diff-bc676fc7fefa1e4d0198da1f390ad867 ... and the file at that commit: https://github.com/auraphp/Aura.Web/blob/53fea58aa91511f554f8eaf9245137e500dbae7e/src/Request/Client.php Please let me know if you see anything amiss, and thanks again for your assistance.
A cryptographically secure pseudo-random number generator (CSPRNG) produces random numbers in a way that is difficult or (ideally) impossible to predict. This is important in cryptography because if an attacker can predict the output of the generator then everything generated on that system can be broken. The standard PHP rand() and mt_rand() functions are not CSPRNGs, as it is possible for an attacker to determine the "seed" value of the generator, thereby making it possible to know the value produced on the Nth run.
&gt; Sublime Text 2 may be downloaded and evaluated for free, however a license must be purchased for continued use. **There is currently no enforced time limit for the evaluation.** http://www.sublimetext.com/2
I don't think you understand the definition of [free software](http://www.gnu.org/philosophy/free-sw.html)... it has to do with the license and not price
What exactly are you going to want to customize that is not included in the base versions if the software that you are looking at? Are you just looking for a custom theme or looking for other integrations? Things you will want to look at is site speed and how the platform handles mobile. You may not get the speed you want from base Magento, but there are lots of extensions out there that will help a lot.
&gt;You may not get the speed you want from base Magento, but there are lots of extensions out there that will help a lot. Proceed, please
One of the big advantages Magento EE has over community is that it has built in Full Page Cache which really speeds up Magento. There are several extensions out there which are built for community which add similar caching ability. I would not consider using Magento without a full page cache solution.
https://github.com/magento/magento2
It's been 2.5 years since announce; I'm betting 2.5 more before anyone's tried it.
Sounds like it's time to write your own. p.s. feel free to pm me with magento questions
Zencart is a horror show for developers. The code base was a mess last time I took a look at it.
Haven written two e-commerce platforms (one for a custom solution, and one to release as a free product), it's not an easy task, nor is it something that should be taken lightly without understanding an immense amount of security, XSS, stability, update cycles (and an easy to use update system from inside the app), etc... Doing your own e-commerce solution is only advisable if nothing out there is to your needs, and you have a very competent team ready to get their hands dirty with some complex situations.
WordPress + WooCommerce - it's very extensible, I'm loving it so far.
I have no idea how the licensing looks, but I love woocommerce for Wordpress.
1. Some containers offer lazy injections, i.e. it injects a proxy object which loads the service only when it is used for the first time. That solves the problem of performances. 2. Depending on the container has many problems already detailed in other answers. But yeah in short, it's not dependency injection anymore. 3. On a side note, I find many of my controllers end up with really long constructor (to get everything injected). I've written up about an alternative solution here: [Controllers as services?](http://mnapoli.fr/controllers-as-services/)
http://www.drupalcommerce.org/ anyone?
Redis is actually included with Magento 1.8.
Stole it from the community though :P
Last time I used osCommerce it was fucking terrible. I think this was before 2011 though. Maybe it's better now. There were security holes and our site got hacked.
This is a really bad idea. You looked at what password_hash() returns? ;)
FYI it'd spelled cheAtsheet 
str_replace had always been a really cool function for me. So much so that when needing similar functionality in JavaScript, I just copy this: http://phpjs.org/functions/str_replace/
Why on earth would you use a predictable number as the source of a random number? You may as well just return 10;
Looks cool, but I don't understand what sets it apart from native PHP implementations like ReactPHP and Ratchet? Not trolling; just trying to understand. Would you mind elaborating?
thats not a cheatsheet, neither a tutorial
That is true, but it appears that the code follows a similar structure of setup-&gt;loop which suggests to me that "each request" may indeed mean each long-running request. I actually dig extensions like this because they take what's fairly non-standardised and present something that can become a standard, shippable addition to PHP SPL. Good work.
&gt; which is basically parsed on each request. Not in any sane setup, it isn't .... That extension will only build in a few setups, the config.m4 is not flexible enough to use ... 
For many clients there's this mentality that if it's 'free' it's shit and if it's not complex it's crap. Complexity and/or licensing must mean that it's brilliant! A more legit reason for wanting licensing is that you get support with it which a lot of businesses require, if only for peace of mind
This extension is very experimental... and it works only with apache2handler. The main two advantages are: - the frame decoding is implemented in c and it's faster than php implementation - the extension extends apache2 to handle websockets trough php and you take advantage of apache security Disadvantages are that the extension uses the apache2 socket directly and it's a huge hack (i am not an experienced c programmer) and it does not use php's SAPI 
&gt;it has a huge performance gain Oh, I seriously doubt that. The difference is most likely negligible. 
The string returned by password_hash() will have only as much "randomness" as there is in the password argument. Which in this case is pretty much nothing.
Provided example BaseController implementation does it, but Symfony does not enforce this. Symfony itself fully supports defining controllers as proper services that are completely unaware of DIC logic.
How does it make it more secure than a single source (say /dev/random)? Why perfectly random source such as /dev/random is not enough? Why does it need to be mixed with openssl_random_pseudo_bytes if bytes where already available from /dev/random?
I've still got an osC site in production, fairly low-profile, but it does some sales. Fucking thing has been rock solid since Oct 2008 (knock wood, maybe today's the day!). But don't use osC, not if you want to be able to sleep at night. It's a security nightmare, and dev'ing themes/functionality is a bitch.
correct, but there's nothing stopping you from editing the config.m4 to point to the correct libraries. I do know about optcode caching, so, yeah you wouldn't have php being parsed on EVERY request in a sane setup. but... never-the-less it's still more efficient to have a compiled C extension than native php, that's all I'm saying
The password_hash() function generates a bcrypt hash. It is NOT a CSPRNG. If you only need 160 bits of random data, I suppose you could pull the salt value and decode it (given the proper decoding function, which is NOT base64). The bits before and after the salt are not random in any way.
The idea is that you may not be able to trust a single source, or that an available source may have insufficient entropy. The mixing function here looks like a valid implementation of a mixing function from RFC 4086, section 5.
The easiest example I can think of, which is from personal experience (I had a webhost politely ask me to fix my code a long time ago), is when dealing with email. The SMTP protocol is purely text based, and this is how you'd write an email from the command line: ehlo mydomain.com mail from:&lt;me@mydomain.com&gt; rcpt to:&lt;you@yourdomain.com&gt; data This is a test, please do not respond . quit The `data` command marks the beginning of the message, and the `.` marks the end, but for the other commands, they are separated by a linebreak. Ok, that's nice, but so what? Let's say you wanted to make a contact form, and you provide an input for the user's email address. If you do not strip out CRLF, then the user could enter in something like this: me@mydomain.com\r\n rcpt to:&lt;spam_address_1@domain.com&gt;\r\n rcpt to:&lt;spam_address_2@domain.com&gt;\r\n rcpt to:&lt;spam_address_3@domain.com&gt;\r\n data\r\n Buy Cialis!\r\n .\r\n I'm not sure if that'd work 100% as-is, but that's the general idea -- by injecting linebreaks, they can inject additional recipients, change the body of the email, and so on. See the [notes about "additional headers" on PHP.net's page for `mail()`](http://www.php.net/manual/en/function.mail.php#62875) for more info.
Yeah, I guess you've got a point. In my mind i'd install an extension if I were going to use it extensively. So, to me, there is going to be a good performance gain because I'd use it a lot (if I used it). On the other hand, one of my favorite things to do is to use old servers that would other wise just be more e-junk. so squeezing every bit of performance out of my code as possible is a goal I often have. I like to be efficient with my resources, and I like to recycle. Not to mention, while 2ms off of a request might be a small gain when looking at a narrow view of the situation. but when you broaden it to the lifetime of an application that 2ms adds up to a lot of extra room for more requests, and (I hate to point it out but...) electrical savings. Put a Kill-a-watts meter on a server sometime and try to run some tests between optimized and non-optimized code. You'll see a difference in electric usage on your server.
This is true
Well there is something stopping most people, they do not know how to do that sort of thing. I was making the observation that to deploy in more places the config.m4 is skinny. It is more efficient (C vs PHP I mean, not this project vs any other), but it's nothing to really rave about to be honest, there's complexities in writing your ideas as an extension in the first place, take this project for example, right now it will run in unix with apache2handler, whereas a pure php version can run anywhere there is php ... additionally when you write an extension you only expose functionality to the user, they still have to execute the zend vm to get at that functionality, it's not the answer to everything is all I'm saying ... It's a cool project, whatever, I'm just making, valid, observations ...
What do you mean by QB? I did a quick Google and the closest computing thing I could find was QuickBASIC which I doubt you meant that.
Never used Solarium or Elastica (and I must confess I don't know what they are) but I have used both ElasticSearch and Solr in large scale production. Both performed beautifully. Both scaled to large amounts of traffic beautifully. Recently we had to make this decision again and we went with ElasticSearch. It's easier to use in an AWS setting and just easier to use.
Thanks. Changed in Title.
So sorry, yes QuickBooks Enterprise, 2013 compatible. Sorry, been working w it so long I just assume everyone and their mother uses it.
If you cannot trust /dev/random it seems a game over. But thanks for explanation.
As /u/Tomdarkness refers to below, [HTTP response splitting](https://www.owasp.org/index.php/HTTP_Response_Splitting) is one method, though you can still overwrite headers without specifically splitting the request. Basically, a response from a webserver is much like an SMTP interaction, in that CRLF's separate each header, and a double CRLF separates the body content from the headers. It helps to know that cookies are set via HTTP headers (`Set-Cookie:`), and redirects can also be implemented with the headers (`Location:`). Also, I believe duplicate HTTP headers will overwrite previous headers. Combined, these present a lot of opportunities. [Here](http://projects.webappsec.org/w/page/13246931/HTTP%20Response%20Splitting) is a pretty good article that covers the problem.
Yes, in fact, I do doubt that it would make a huge difference if all it's doing is handling the network overhead. As for Phalcon, that's not even remotely relevant here. I wasn't contesting that compiled code is faster than interpreted, but rather if it'd make a significant difference in this context. 
it's
awesome thanks for the info
MySQL (my db) can do custom order bys but Doctrine cannot but now that I think about it there could be a way possibly to do a [native sql query](http://docs.doctrine-project.org/en/latest/reference/native-sql.html) and make it work.
I don't think I had to buy any payment modules. However, I have no problem buying modules. To me, it is a business decision. I would much rather pay a $100 for feature that is ready to use, than build it myself. It usually takes more $100 worth of my time to make something similar.
There's the Quickbooks PHP DevKit. https://github.com/consolibyte/quickbooks-php Maybe look into open-sourcing your library?
No argument with you on paying for stuff like that. It's just important for people to know that the "open source" elements of such a project only go so far and that you will either need to develop your own solutions or pay for existing one in order to get a fully functioning Prestashop.
**Question 1.** Errors are automatically passed to the view without you having to, simply call $errors in your view. Example: &lt;input type="text" name="email"&gt; {{ $errors-&gt;first('email') }} See: http://laravel.com/docs/validation
**Question 2.** Personally I use count(), for example: @unless(count($posts) == 0) @foreach($posts as $post) &lt;p&gt;{{ $post-&gt;title }}&lt;/p&gt; @endforeach @else &lt;p&gt;No posts.&lt;/p&gt; @endif 
In regard to question 2, I've seen and have opted to use the `count()` method on Eloquent collections. @if($users-&gt;count()) // loop in here @endif
Agreed. 
In regard to question 3, the best you can do in this instance is use the `prefix` attribute for the group, you will still have to specify the controller manually. Route::group(array('before' =&gt; 'auth', 'prefix' =&gt; 'admin'), function() { // routes prefixed with 'admin' });
What if I want to prefix "listing" too? Does Laravel support multiple nested route groups?
I'll check count documentation. Do you use count for every response type? (e.g array, eloquent collections, objects, variables or booleans?) I used "empty" all the time, but it fails when the response is eloquent collection object.
1.) If that is how you structure your views, then that is how you pass the data to it. 2.) You definitely don't want your views knowing anything about the type of data, other than the fact that it is iterable. Even taking it out of the view you seem to be exposing an awful lot of ORM level logic in your controllers, so lets skip all of that. $users = Users::findAReasonableNumber(); //bla.. -&gt;with('users', $users); That method should be doing the toArray, or at the very least returning false if there are none found. Or you can still return the collection and do this: $users = Users::findAReasonableNumber(); //bla.. -&gt;with('users', $users-&gt;count() ? $users : []); Or whatever you like. It's your code, you decide. You definitely dont ever want to use User::all(). 3.) I wrote an [article about this](http://philsturgeon.co.uk/blog/2013/07/beware-the-route-to-evil). 4.) Yeah thats how namespaces work in PHP. Write `use View` or reference it as `\View`. Either one. 5.) You don't. I've been meaning to send a PR in for that since I mentioned it to Taylor in about October 2012. I've been busy. Can you PR it?
1. I want to refactor how I develop my views. Right now, inheriting views using -&gt;nest method isn't very flexible. I would like to get the same functionality, but be able to rely on methods like withErrors(). I'm not sure if there is even better way than this. 2. So, we create new methods in our model about how we would like to retrieve data? Sounds logical. Gotta dig deeper though. 3. I read that article few times already, but what I'm asking is nothing about magic. Right now it is 'admin/listing/add'. What I want is, 'admin' to be grouped, 'listing' to be grouped (inside admin group), and use 'add' method inside. More inheritence, more flexible and more dry. It doesn't look so magical to me... I'm not sure if Laravel supports nested route groups though. 4. Strange. Whenever I try to "use View" or "\View" on my "My\Personal\Namespace" namespace, I always get an error. Shouldn't it be something like: "use SomeFoundation\SomeProvider\Blahblah\View"? 5. If I had knowledge about the internals of the framework, I would develop and PL it myself. All I can do is to create a request for it now. My contributions to the framework doesn't exceed fixing some minor issues. 
I could have sworn I already saw this posted a few days ago now.
I'm not sure why you are getting so many types. When *can* expect more than 1 record it always returns as a `Collection`. When you expect a single record it's either as `Model` or null. Also, a trick is to use let PHP loosely check the type. ``` @if ($model) {{-- returns true for all 'truthy' values --}} @endif ``` For any query you should really only expect one or two different types.
It should only be `use View;` assuming you have the `View` alias set up in `app/config/app.php`.
Should do, either use multiple groups or change the prefix to `admin/listing`.
* Warning * Google Translate API is now a Paid Service.
Yep, when you use `use` it pulls the class from the global namespace. Assuming you haven't changed the aliases in `app/config/app.php` the global `View` will be fine. Otherwise, it's `Illuminate\Support\Facades\View' (which I am getting by looking at the alias in my `app/config/app.php`).
If you go with nginx you really don't need Varnish if you're only using it to cache static assets. Nginx loves http requests for static assets and you're not going to run into nginx scaling issues on static file serving.
that's clearly a typo. 'd' being, right next to 's' keys... probably was posted while on my iPhone. You got me though ;)
ElasticSearch is great for large (terabyte sized) data. It scales really well.
I can't address your specific questions, but (as a non-whiteboard user myself), the few times I've tried to draw anything on a whiteboard it looked like crap (letters too small, text at a slant, etc.). If I were going into your situation, I'd find a whiteboard and just practice writing and drawing on it so the only thing I had to worry about at the interview was what to put on it, and not the actual mechanics of doing so. Hope that makes sense (and good luck at your interview).
There are benefits to putting Varnish in front of nginx. For example my organization has two racks of image/video storage servers each with 48 disks. I'm not real sure how many servers are in each rack. The I/O in those servers is usually saturated, our distributed file system (MogileFS) is usually running at peek, and nginx works it's bloody heart out. As far as I know we keep Varnish in front of those servers caching popular content and thumbnails, because reducing requests on the storage servers is a must. Continuously adding storage servers to keep up with demand isn't an option. The servers are expensive, and draw *a lot* of power, which is also expensive, but keeping a couple cheapish Varnish servers loaded up with RAM in front of the storage servers gives us some breathing room. I don't know all the specifics. This is the domain of our sys admins, but I know a combination of Varnish and nginx works well, though I'm not sure they would work well running on the same server. If you're going to go that route, you might as well just use nginx.
Obviously we don't know the company you are interviewing with, they will most likely ask you to state the language you are using, or they will tell you what language (usually whatever you are applying for). It's also possible they may be perfectly happy with pseudo-code. Anyway, they will probably ask you to work through some, usually basic, algorithms depending on the position you are applying for (based on the phone interviews it may be a little more advanced). IMO these things are all about seeing how you approach and work through a problem as well as how you can communicate your solution. This just screams some sort of search/traverse algorithm to me.
Yeah, I'd go pseudocode on it. Who the fuck writes perfect code on a whiteboard? At my current position, I did whiteboard and then further coding in the interview via terminal with open-google for reference. They just wanted to make sure I could solve problems, not code perfectly on the whiteboard. Good luck.
Whiteboarding is generally just writing code on a whiteboard. As a general rule, they're more concerned with your ability to think in code and explain what's going on than it actual 100% accurate and correct code. Just pseudo-code your answer. It also helps to draw charts and graphs and shit, if that helps illustrate your thought process, but usually isn't required. For instance, I got a question awhile back that said "I'm going to give you a dollar amount in cents, and I want you to write a function that gives me the least amount of coins to match my amount. The amount is 42 cents." So I wrote something like: function coin_change(amount) { quarters = amount % 25; // number of quarters ... [actually wrote more pseudo-code to finish this function] ... array_of_change = ['quarters' =&gt; quarters, 'dimes' =&gt; dimes, 'nickels' =&gt; nickels, 'pennies' =&gt; pennies]; return array_of_change } Anyway, it wasn't exactly PHP, but it was close enough that he could see my code and see how I thought about the problem, and so on. That's really all they're looking for, so don't worry too much about it. You're just writing fake (or real, if that helps) code on a whiteboard. Good luck! 
OP don't stress so much. You're definitely over-thinking it (comes natural with any job interview). I've never gotten the "whiteboard" experience, but my coworker recently just did one for a few new potential hires. Here is our process, and kind of what (maybe) to expect. The first thing they might do is ask you a simple riddle. Not even coding in nature. Generally to see how you might assess a situation that has **nothing** to do with coding. Again, this is my company -- not every company in the world. Once done, you'll start doing some basic stuff. My favorite of a co-workers is the [fizz-buzz](http://c2.com/cgi/wiki?FizzBuzzTest). It's easy, and usually filters out the college kids who just kind of sat there through their courses without actually applying what they learned. The next few things will be general tasks. These usually aren't expected to be perfect. Especially since it's a whiteboard. They'll have you write out whatever you can think of, and then they'll go through it with you line-by-line. This is just to see if you really understanding what you are puking out onto that whiteboard. We aren't expecting some type of amazing script to blow us away. Honestly OP, most of this is just a formality to see how you think. If you must, use pseudo code. The way I see it, if they are willing to fly you out after two successful interviews ... it's just to sniff you out. We've interviewed people, then when they come in they just don't mesh well with the team. That's a big point of getting you out there. Best of luck, and feel free to respond with anymore questions!
First off the key to being successful in these type of interviews is to relax and be calm. Whiteboarding is a pretty stressful thing to do in an interview so the calmer you are the clearer you'll think. Secondly when you are given the problem to whiteboard don't immediately start writing. Stop and think about it for a second. Go with the first end to end solution you come up with and don't deviate from that solution. A lot of people screw up when the try to get fancy and end up with a massive bug in the code. Keep it simple. Lastly explain your thought process out loud. Whiteboard coding it more about reasonably approaching a problem. If there are some flaws with the solution you come up with don't abandon the solution just mention the flaws and continue on course. The important thing is you recognize where a problem might be. Good luck and remember the biggest key is to be relaxed. They are paying to fly you out to interview so clearly they see something in you.
This is good advice. All of the interviews I've had involving whiteboarding, everyone has been very accommodating about it. Is the interview in the bay area? And OP, if you are certain you are qualified my advice to you is to just be calm and confident. Why not be? You're qualified. 
If you want it done quickly and easily then use wordpress. If you want to practice and improve your skills then make it custom, or use a friendly framework
I don't recall the exact specifics, but we were using nginx on our cache servers for a long while, and the sys admins were very happy to move to Varnish. These guys have wet dreams at night thinking about nginx, so there must be some key benefit to Varnish for them to switch. Although from my position having Varnish in the mix complicates simple tasks. Beyond the thumbs and hot content the images/videos are served directly off the storage servers using nginx. It amazes me sometimes that people still use Apache.
I'm as anti-wordpress as you can be, but this is the correct answer. Wordpress is a good* way of getting a website up and with fairly minimal hacking can be used as a product catalogue website. If you want to develop or learn, something like a Framework is a better option, but if you just want to get the job done and get rid of it, Wordpress may well be a reasonable option for that. *depending on how you define "good"
what about including the partials to the other templates? if you're using blade then a simple *@include('admin.partials.error')* suffices. but i'd put the *@foreach ($errors as $error)* also in the partials.
You can download [microweber](http://microweber.com) if you don't want to code 
&gt; quarters = amount % 25; // number of quarters I really really hope you didn't write that down.
I'll give you a quick tip. If they allow pencil and paper choose that over the whiteboard! You might find it easier to focus and less intimidating on paper. Plus it's generally easier to read. Leave lots of space after writing each statement. Chances are you will want to define another variable or add a couple extra lines. Without gaps you will be rubbing out many lines to fit everything in. 
The bytes returned by password_hash() will have a big problem, because getting just a piece of them, it becomes easy to crack the whole string. This should not ever happen under a secure random number generator. Of course if you only use the salt part as paranoidelephpant said, it will be probably OK (if it contains enough bits). But that is like hammering a nail with a screwdriver.
Start with defining what the site should be. It's functionality, it's content, etc... Based on that definition you'll have to figure out what the best solution is. What approach or application would best satisfy the needs of the project. If for instance, and I assume this might be the case, you want the site to focus on showcasing your friends products and nothing more. This would be big and nice photos with a small specs-sheet, an user will browse through visually. A site like this is more about interactivity than content. I haven't worked with Wordpress in years, but AFAIK it's still mainly a blog-type of CMS. It seems to me it might be more work and effort in learning PHP and understanding the Wordpress code/api, to convert Wordpress into the site you want. I would suggest learning to work with an MVC framework, there's plenty to choose from. And learn jQuery if you don't know it already. The biggest question you need to answer yourself is how elaborate the backend (administration) of the site should be. For a site this simple (I assume) you could aswel use the file-system as a database. But again, if you can define exactly what needs this project should fulfill, people will be better equiped to suggest what route you best take. 
I'd say try - nGinX with FPM 
For PHP, I need this in my Sublime Text settings: { "word_separators": "./\\()\"'-:,.;&lt;&gt;~!@#%^&amp;*|+=[]{}`~?" } Which will make double clicking on a variable to include the $ symbol. 
I tried PHP Storm recently, and I ended up back on Sublime Text. Why not give the 1 month trial a go for it, see if you like it? But then again, if you're happy with how you're working, don't fix what isn't broken. It's clearly working well for you already!
Sublime is a text editor (which it does brilliantly, have used it a long time). However, PHPStorm is an IDE. Browsing through PHP, autocompletion... Everything is much better integrated. And as PHPStorm also includes WebStorm, it's a perfect tool for full stack development. I love doing Javascript in PHPStorm. 
wat
&gt; Does Laravel support multiple nested route groups? Yes.
Username.
the world of professional php is full of frameworks, I've never seen a project in bare php. When you work with a team, the framework sets several rules so it's easier for everyone to work together and follow the same rules (design pattern, norms, conventions, etc) It also reduce the amount of work, the framework is shipped with basic components you can reuse without having "to recreate wheel"
oh my god, where have you been all this time
I love Sublime Text and used it for quite a long time. But, I have switched over to PHPStorm because it offers a nicer PHP experience. BUT - I have 16 gigs of RAM and a SSD. Before I upgraded my computer, PHPStorm, which is Java based, was too miserably slow. Autocompletion in PHPStorm is more advanced - even with Sublime plugins. With the crazy way PHP has of flipping the order of needle and haystack in functions, the parameter reminders are a joy. If I rename a JavaScript file, PHPStorm goes through and updates all references to the file in my code. Out of the box, it integrates nicely with git and Fogbugz. But, what I really love is how well it indicates that variables and functions aren't used and how it picks up on things that could cause problems - even if they aren't technically errors.
Frameworks are like a big toolbox. Imagine you have to build a dog shed. All you have is wood, nails, a hammer and a handsaw (standard php functions). Which is good enough for the job. For me, that's the equivalent of using no framework. Now imagine you have to build a real house for a human. Sure, you could build a house with the same tools, but it would be way easier using a nail gun and a proper circular saw (symfony2 components).. Then you find out along the road that you needed a blowtorch to do some plumbing... no problem! You go to the hardware store (composer) and get it. This, for me, is using a framework. It's focusing 100% on business logic and less worrying about the other stuff. 
The inspections are awesome indeed.
Recently used ElasticSearch for a couple of gb of data. My data is not big enough to tell you if its scalable or quick enough (it is quick enough though), but I can tell you that integration was ridiculously easy. 
Haha. 87 cents = 12 quarters. I am going to shop here...
We've released Bolt 1.3, with new features, improvements and bugfixes for everyone: - A new feature called 'the Stack' to keep track of your latest uploaded assets. - A running log of all changes to the content (so you can blame whoever introduced a particularly embarrassing typo) - Weâ€™ve incorporated the acclaimed Symfony Developer Toolbar. Much more on the site, _with_ screenshots! Apart from the new features, we've done a lot of work on [our documentation](http://docs.bolt.cm), and we've created a new page listing [Bolt's significant features](http://bolt.cm/features). 
/Increases/Decreases/s But yes, frameworks will make your life much easier in the long run. I would check out Laravel as I have found it very easy to work with and the documentation is very good. 
I know about resourceful controller, but reading Phil's article and my routes not being resourceful (I need to add alot of "only" or "except") makes me want to stay away from that. I made this and this is what I needed. Route::group(array('before' =&gt; 'auth', 'prefix' =&gt; 'admin'), function() { // Slider Management Route::group(array('prefix' =&gt; 'slider'), function() { Route::get('add', 'AdminController@slider_add'); Route::post('add', 'AdminController@slider_add_process'); Route::get('list', 'AdminController@slider_list'); Route::get('delete/{id}','AdminController@slider_delete_process'); }); }); I still have the full control on my routing, just with less typing. I need to find a way to define which controller and which method to be used on group array and I'm set. :)
I did not know about this setting. Upvote for your new information on this.. It makes double clicking more enjoyable now :)
The Laravel project documentation is good for reference, if you *already know it*. However, there are a number of good books (leanpub.com has a few good ones) that help fill in all the gaps.
My quick performance list todo. - 5.5 with opcache - nginx - make sure your cache headers on your assets are good - are you using image sprites? - 1 stylesheet request, JS requests should be at the bottom - maybe CDN those assets? - monitor your queries to the DB. It's usually #1 bottleneck. - make use of memcached for slow queries. - if you have shitload of images, lazy load 'em. What I would do if I were you: - nginx with 5.5 fpm Then I'd do the normal loop of: - Find wtf is slow (audit, monitor, can't do shit without numbers) - fix it 
If error messages are automatically being passed to the view files, then I can do something like: // View {{ @include('admin.partials.error') }} In my error view, I believe should have a check for $errmsg variable: // Error.blade.php @if(isset($error-&gt;getLast()) &lt;div class="error"&gt;Error: {{ $error }}&lt;/div&gt; @endif While it's logical, sometimes I need to render "admin.partials.success" if there is no error and task succeeds. Then, there will be another check, which is: do we render error or success partial? This doesn't look like a flexible solution either. 
if you include messages along with errors you might find [this notification](https://github.com/andrew13/Laravel-4-Bootstrap-Starter-Site/blob/master/app/views/notifications.blade.php) view very useful. btw, the *$errors* of the class MessageBag is automatically passed to every view, even if you don't set it.
I'm currently using IntelliJ IDEA (not just PHP Storm) and while I used Sublime Text for a while, I didn't use any additional packages, so I may cover things you already have. * **Powerful linter**: Picks ups syntax errors, typos, incorrect doc comments, etc. Can auto-add PHPDoc comments and get types right most of the time. Can detect unused functions/classes/variables. * **Autocomplete**: It's intelligent and if something is ambiguous you can add phpdoc comment (e.g. arrays of objects) * **Jump to definition / Find usages**: Even with a project mounted remotely it's fast and easy to jump around * **SQL Autocompletion**: If you're writing plain old SQL, IDEA can auto complete SQL syntax, table and column names (i.e. detect typos, etc). * **Spell checker**: I've horrible spelling, this is actually a really useful feature for me :-) * **Normal IDE stuff**: Source control, basic refactoring, debugger, etc. I guess the killer feature for me is that I can jump between PHP, HTML, JS, CSS and Python code and still have all these features.
Good examples, though I'd rather use `array_map` than `array_walk`. `array_map` returns a modified copy, with your `array_walk` example, you modify the original array, which could lead to side effects if your array is used elsewhere. I'm not saying your example is bad, but if you want to teach people a good way, then you should probably show a bulletproof solution, even if it's a tiny bit less efficient (because seriously, who cares if you copy an array or not, that's not what will slow you website down). Also, `array_filter` is pretty useful and could deserve an example too :) (using foreach to filter is really overkill).
If I use if($response), it will fail, because Eloquent returns an Eloquent Collection (an object) if there are no entries in database. It casts to true. Honestly, I don't know. I used Laravel 3 using !empty and had no problems. In Laravel 4, Eloquent seems to be returning so many different data types. I don't exactly know, but methods like -&gt;first() or -&gt;get() or -&gt;all() seem to be responding different values depending on your query. Sometimes I check for NULL, sometimes FALSE, sometimes array, sometimes an object containing arrays, sometimes array containing objects, sometimes just plain string response etc. 
I'd say most projects use frameworks today. There is no reason to re-invent the wheel all over again. I'd never code php without a framework nowadays (except from very small stuff). I've used Silex for a personal project and must say it's very nice to use. Small but still comes with a lot of features that are the core help when using frameworks.
3.) It absolutely does have that feature but if the reason for using it is a string looks too verbose then you're absolutely doing it for the wrong reason. It doesn't matter. Verbosity over random tricks. 4.) You reference where the class is. View is a global class, so you reference it in the global namespace. \View or use View will reference it in the global namespace. If you're getting an error paste the error, as just mentioning an error happens means we are unable to help. 5.) Fair enough, it'll get done someday.
While I'm sure phpstorm is a great IDE, I' starting to think that this subreddit is plagued with JetBrains shills, Everytime, the topic proposed can vaguely be related to phpstorm, you get a few people praising its features. This is supposed to be a thread on plugins/features/tricks for sublime and we already have 3 of these.Ironically, this is a bit off-topic as well
The OP asked if was missing anything, and the answer is "yes, php storm" for all the reasons mentioned above. I'm one of many many php devs I know that made the switch and I'm a better developer for it.
Also various tools and scripts. I love restfull tool
Thanks so much! 
Thanks for the reply! You guys are awesome!
&gt; OP don't stress so much. You're definitely over-thinking it (comes natural with any job interview). I over-think everything. Anxiety issues. :) Thanks so much for the reply! I'm feeling much more confident from all the great advice and tips here. 
Thanks so much! That seems to the most common piece of advice -- remain calm. And, tell them why I'm writing what I'm writing as I write it. 
Great tip! Thanks!
You guys are awesome. Thanks!
SublimeText is good for text (and script) editing. For large projects I prefer a proper IDE. PHPStorm has some really neat database and git integrations which I love.
&gt; "word_separators": "./\\()\"'-:,.;&lt;&gt;~!@#%^&amp;*|+=[]{}`~?" http://i.imgur.com/h9LU68r.gif
Minor thing, but the screenshot of the symfony toolbar that you have doesn't inspire much confidence. 86 queries and almost 3 seconds for execution time? Did you just pick a really huge page with 50 posts to showcase the toolbar?
I completely agree Dayle Rees has an awesome book on Laravel that I recommend. 
In other words: RTFM and learn what functionality is available to you.
I would love it more if it would follow redirects :) But tasks are making me so very happy right now. If I'm working on a FogBugz ticket, and switch to another one, PHPStorm checks out the correct git branch for me and opens the correct files.
A common misconception is that people who use frameworks are only people who use MVC frameworks... I'm sure you don't outright use frameworks like Silex, Laravel, Symfony, etc... But I bet you have a collection of stuff you made that is reusable, right? That's basically the gist of a framework... A reusable base of code. So unless you rewrite EVERYTHING from scratch every new project, you're using a framework whether you think you are or not.
OP explicitly asked, "Am I missing out by not using PHP Storm" - so yeah, that's part of the topic.
I almost always ask people I'm interviewing to whiteboard something, what you're really trying to understand is their ability to work out a problem and communicate their line of thinking, since this is critical in working in a group. The whiteboard is preferable because I don't have to hover over you (or read upside down) to follow along. My $0.02 is to not worry about your handwriting, or writing 100% correct code (we all have access to google, I don't need you to know all of the format characters for date). It's highly unlikely that they are buying you a plane ticket and spending part of their day with you if they have serious doubts about your PHP. Focus on writing out your thought process and explaining it, don't worry about being wrong, and if you realize you are wrong, that's ok, and say so! ("i just realized, this isn't going to work because X, so instead I'll have to Y"), things like that. Whiteboarding is an exercise in communication, above anything else. Good luck!
I agree with all the answers here. I would walk off a job if they were planning to start a new project in PHP and not use any framework. It's really shooting yourself in the foot. The benefits are so numerous for a framework that the burden of proof really falls on any person who doesn't want to use one, but I'll try to explain why I use a framework. Pretend you need to write a website where users can login and share a status. Without a framework, the first thing you need to do is create an authentication system from scratch. That will take a while and there's a fair chance you'll have some bugs or security holes. Most frameworks would already provide built in authentication, or at least a lot of tools that handle the majority of the work. You start working on that and immediately realize you need some routing system to control your urls, so you write a routing system from scratch, spending more time doing something every framework has already done better. Then, since you've been in the business a while, it occurs to you that maybe your boss will be so impressed with this application he'll decide to compete with facebook, and of course they will want to switch to Oracle or some other database to be more "enterprisey." So you whip up a database abstraction layer to make your application database agnostic, and to ensure all your queries are piped through the same place, enabling system wide protection against SQL injection. You just did a ton more work that all frameworks have done for you. Then you realize you have way more code than you originally planned. You'll need to start focusing on separation of concerns, and so you write some classes to help you load views, and you write some base models for all your models to inherit from, and of course a bit more code to tie all of this together with a usable interface and to manage dependencies. More work the framework would have already done for you. Finally, all that is out of the way and you get back to your authentication class, you create your user model and you have users who can log-in. You create another model for status updates and finally, your company has some internal software to share status updates with each other. They are happily sharing statuses and, as expected, your boss starts talking about expanding this application to become the next Zuckerberg. Fast forward a few years, and all your experience and ingenuity lands you a job with Google. Your boss is sad to see you go but deals with the loss by hiring Jim, a guy with years of experience in CodeIgniter, Symphony, and Laravel. Shortly after his arrival they discover a bug in your authentication system, and you never added support for CONCAT functions to your DB Abstraction code, which Jim needs for some performance upgrades. So Jim spends weeks reading through your code trying to figure out what's going on. Afterall, you didn't have time to document it very well since you were busy re-inventing stuff that frameworks already do for you. If you had used a framework there probably wouldn't be any bugs in the authentication system, and if there were, Jim could probably Google the solution in a few minutes time, or already know about it due to his experience with frameworks. Even if he didn't know the specific framework you used, he could undoubtedly read the documentation online and figure it out quickly, but we have no such luck with our undocumented in-house barebones solution. And so Jim is tasked with sifting through your mess to fix the authentication system and improve performance. But, its been a tough few months for Jim. His old company went under, and shortly after his unemployment checks ran out, his girlfriend met a guy with a job and dropped Jim like he's hot (fire hot, not George Clooney hot), and his mother is loosing her battle with cancer. Reading through your undocumented code is the last straw, and after a grueling and unproductive day of trying debug your authentication system he decides its just not worth it anymore and steps out the window of his 13th floor apartment. In the end, your boss wasted a ton of money paying you to do a worse job re-writing stuff that was available for free, his plans to take-on facebook were thwarted by realization that his status updating application is an unmaintainable mess, he has to hire another programmer, Jim is dead, and his Jim's mother is gonna die alone. So that is basically why I use a framework.
Well, that's what I get for trying to get a release out in a rush. Don't really know what happened there, to cause it to take so long. Re-took the screenshot, and now it's about 10% of that. (it _is_ a page with about 50 posts in different contenttypes, yes) Thanks! 
I have to admit that I missed that part. 
I've started using this completions kit package and it's decent: https://sublime.wbond.net/packages/PHP%20Completions%20Kit
I've worked on a system built without a framework for a lot of years. We started out with inline queries, inline logic, and ad-hoc html output. This was back before frameworks were well known. It worked for its intended purpose. But the system worked so well that people wanted to keep using it and wanted us to keep adding new features. As we did, we realized that having queries, logic, and presentation all in the same place made it really tough to add new features utilizing existing data. So we rewrote everything to use more of a MVC approach. Now it pretty much works, but it could be better. If we had started out with a framework in the first place, we could have saved ourselves a lot of work and we'd have a better system today.
"I've never seen a project in bare php." ^ lolwut
* [GitGutter](https://github.com/jisaacks/GitGutter) * [SideBarEnhancements](https://github.com/titoBouzout/SideBarEnhancements/tree/st3) * [SublimeCodeIntel](https://github.com/SublimeCodeIntel/SublimeCodeIntel)
It's really not like that "Ruby is better than PHP" kind of thing at all. Sublime doesn't have the level of integration PHPStorm has. I still use Sublime as a text editor, which its great for, but PHPStorm has better code inspection, better enforcement of style guidelines, better VCS integration, built in debugging, and better autocomplete and navigation. A lot of the little things like knowing if a variable may not be set, getting a warning if the function may not return the type you expect, and seeing unused functions/variables can not only help your write better code but can help you prevent introducing bugs into your code. PHPStorm also has a more active company working behind it so release cycles are a bit more consistent. Sublime is a great product, but PHPStorm has some tools that I now know I could not get by without.
This highlights the problem I have with SublimeText: it's nice and fun to use, but only for minor stuff. To get it to do the more complex stuff requires fiddling with and installing a non-trivial amount of plugins and settings, and even then you're probably not going to get all the features you want (or those features aren't going to be fully-implemented). So after all that work you end up with a strong text-editor, or in other words, a weak IDE.
Consistency for when I leave an application behind or inherit an application. If the next developer comes along at sees it's in Symfony 2 of ZF2, at least they have a starting point to maintain it. 
Sorry please forgive me as I am not so much a coder, but handle the server that this is running on. This looks to be something that needs to be inserted in to the particular script, is that correct? As in inserted in to the problematic script? 
There is any experienced c developer who is interested in the developing of this extension?
I'm actually almost exactly where you're at. I do have one significant complaint. PHPStorm takes a while to load. That bugs me when I just need to open something quick to check or add a TODO I just thought of for a file I know I'll be working on later, etc.
haha, I actually have never gotten that question before, it just popped into my head as I was writing the post, so I didn't really think too much about it before dropping it in there. Plus, on my phone on a train, so... that's my story and I'm sticking to it :)
The one thing you will miss, that AFAIK you can't get anywhere else, is multiple cursors and fuzzy-search file preview/file opening/function finding/menu navigating. If I could get these things added to an IDE, I would switch in a heartbeat.
I agree with a few of your points (specifically "it's easier for the next guy"), but I lol'd at the idea of poor code causing someone to commit suicide. Thanks for the laugh!
I use them for things that are done on basically every site. You will (almost) always need a db connection. Why re-write that procedure every time? Validation happens whenever there's user input. Why write the same functions over and over to check the same info? It just saves time and frustration. Also, as you use it, the code can evolve, making you more efficient and it more secure. Hopefully. 
You most likely want to register an error handler in a global place that gets used by all your scripts. For your purposes, though, you just need to set error_log appropriately and read your logs. 
No chance. Unfortunately around half of the core PHP contributors are perfectly happy with procedural code and basic OOP support. They reject OOP improvements and feature additions that would enrich, but also complicate the language. In their vision, if it aint broke, don't fix it. Strict typing is, for example, something that has been discussed many times, but as you can see, it still isn't in PHP. So I believe it's very good that Facebook brings an alternative on the table, it will shake things up a bit. Maybe it will finally provide a PHP replacement that's compatible with most PHP features but which will evolve faster. Who knows what the future holds? It's beginning to get interesting.
does PHPStorm have multiple cursors and the ability to fuzzy match open new files?
if so, how?
We have error log enabled, but maybe debug logs will help more. Thanks for the info :)
Does ST have remote Xdebug integration? That's spared me from so many headaches.
haha, yeah, that should have been / instead of %, with % used to determine the remainder for the other coins. My actual solution would have looked a lot more like /u/hoppipoppipolla's.
Hahaha I didn't notice until I decides to answer the question for myself. 
&gt; Unfortunately around half of the core PHP contributors are perfectly happy with procedural code and basic OOP support. They reject OOP improvements and feature additions that would enrich, but also complicate the language. I'm a bit more comfortable with procedural as well, but as said around these parts, *porque no los dos?* Procedural code can benefit from strict or static typing just as much as the OO side can, and it could lead to PHP becoming a more... cohesive language, I guess. As it stands, the procedural side is completely different to the OO side, and there's not much synergy going on. The fact that I'm referring to them as "sides" is (imo) a sign that the language has a rift where it doesn't need one. I could get behind a radical project that seeks to shake things up for PHP. Perhaps Hack and its two modes will be a precursor of such an improvement and provide PHP's devs with (imo) much needed competition and motivation to improve the language. The future *does* seem interesting.
Yeah, it happens. I really, really dislike whiteboarding because it's very hard, imo, to debug things. When you're used to seeing things in a very structured, very even, very regular font with regular spacing, it gets really hard to see things in your own handwriting on a whiteboard. I mean, when was the last time you wrote more than a handful of words with a pen/pencil? And when was the last time you wrote *code* on a whiteboard? Probably a really, really long time. I prefer providing a homework assignment and let me do it at home, or at least give me a laptop and let me bang it out on a keyboard.
Got one for variables that have a dash (to select entire string rather than just the chars either side of the dash)? It's the #1 reason I use underscores in css class names rather than dashes.
Version 1.5 with namespaces is online and packagist ready.
This largely depends on your workflow and your ideas on project management. git was my first VCS and I came into it with no assumptions or expectations. I started with `git init`, `git commit -a`, and `git push`, and the docs on GitHub were perfect (along with [Pro Git](http://git-scm.com/book)) for teaching me. I still don't use git's advanced features, but am mostly comfortable with `diff`ing, branching, merging, even maintaining submodules, tags, and rebasing if I *really* screw up. Based on my experience, I've learned that it's less about the tool, and more about how you personally manage a project. I've had to learn more about managing a project than I have using git. A study of workflows will benefit someone more than learning a specific tool, imo.
&gt; 16 gigs of RAM and a SSD Realistically this is overkill unless you're running several VMs on top of everything else. You can run it with far less.
&gt; it's nice and fun to use, but only for minor stuff You really haven't discovered the true power of sublime then. Once you learn python and dig in to the API/script integration you'll find that it's far, far more. 
Here are a few features of PHPStorm you don't mention, some of which might be available to Sublime via plugins: * Built in DB CRUD/admin tool * Autocomplete of SQL statements, awesome SQL procedure editor. Really handy for autocompleting ORM properties too. * Integration with vagrant * Awesome Google App Engine support supposedly including emulation/simulation tools (haven't tried this yet) * Terminal integrated * Integrated with frameworks' command line tools and other framework utilities * Intelligent code navigation pane (navigate by function/property rather than by line number) * The git commit, pull, pre-commit code sniffing and reformatting is reaaally nicely integrated and saves time/keystrokes/mouseclicks over anything I was using before * Control + click to go to the definition of a function or a base class. Control + hover over function name to few the documentation for that function * Automatic creation of getters/setters inside classes if you ask it to. * On the fly code improvement suggestions next to your code. * the awesome "view on github" in the context menu. Saves me soo much time explaining how code works/where code is to colleagues, especially telecomuters. Gist and Bitbucket integration too. * Class/trait/interface inheritance diagrams * Full x-debug integration * Buitl-in REST client * Code quality tools are extensive and include JavaScript, CSS checking and JQuery optimization * Presentation mode which is handy when you have other developers crowded round your screen * Smart project initialization (with composer, Twitter Boostrap, etc.) * Great IDE for node.js development too * Understands code in .phar * Live front-end editing The downsides: * Sublime's fuzzy search works better. In PHPStorm you have to specify if you are looking for a filename, class or symbol. * Some of the smaller features don't work quite as well as NetBeans, such as the uppercase, lowercase and switch case and also the line duplication keyboard shortcuts, but the ability to import key mappings from your favourite editor is close enough for me. 
Cool library! In fact it's the first Markdown parser in PHP that actually has good code quality and architecture. Only issue I have is with the name - wish it was a bit more obvious so I would've found it earlier.
OP was specifically showing how to alter the original array without creating a new array, which is a valid use case. Especially when dealing with very large arrays. Telling him to use `array_map()` very specifically defeats the purpose of his example and the use case behind it. Yes, some people care about making copies of very large arrays. Additionally there are no side effects I'm aware of from altering the original array with `array_walk()`, and judging by the examples on php.net, altering the original array seems to be one of the primary uses for `array_walk()`. The PHP devs have also kindly given us the `array_walk_recursive()` function which can modify elements in a multidimensional array. Doing the same with `array_map()` is a little more complicated. OP could have mentioned some of the gotchas when accessing array elements by reference, which does have side effects, but that's not an issue with `array_walk()` because -- I assume -- the referenced array elements are destroyed when they go out of scope of the callback function. Using `array_map()` may be the "good way" for some situations, but is most certainly the bad way to handle OP's situation. I do agree OP missed his chance to cover some of the other nifty array functions.
Uhm... in the docs class YourExtension implements ExtensionInterface { // Necessary if your extension calls other events $this-&gt;markdown; ... That would generate a nice little fatal error :)
You're right! In the traditional sense that "you call a library and a framework calls you". I can't help myself but to think modern PHP framework as a collection of library glued together to ease your life, like Laravel. 
I can only agree, I have missed a good markdown parser for a long time, and I wouldnt recognize Ciconia as a markdown parser. 
I was resistant, but I've given in and will never look back. I just built a CRUD site using Laravel 4. I used the Eloquent ORM, and seriously during the whole project used like 1 actual SQL query. Everything else just worked once the model was created using the Eloquent syntax. It also provided just the right bag of utilities done 'right' that I would have had to write or import anyway from an old project.
Just a note; all the string functions starts with haystack as the first parameter, and the array functions has needle as the first parameter. It's not really crazy, it just follows the C way of doing things (makes sense, as PHP was originally just a very thin layer over C). Proof: https://gist.github.com/salathe/1672543
Obligatory self promotion: https://github.com/KyleWolfe/PHPErrorNet - Not in it's best form yet, but I have it running in a production environment.
yes, it does!
I use PHPStorm to Develop and SublimeText to fix little bugs, review specific parts of the code, or make little changes. Don't drop Sublime for PhpStorm, keep sublime and gain PhpStorm instead
Despite some code quality issues, [Markdown PHP Extra](http://michelf.ca/projects/php-markdown/extra/) has become the de-facto standard for extended Markdown. It's fine to support things beyond it (e.g., triple backtick for fenced code blocks), but at a minimum, support everything it provides. I'd really hate to see PHP go the way of Ruby where there's a [half-dozen competing libraries](http://xkcd.com/927/) that all support 90% of the extended Markdown "spec" but fall short in different, non-interoperable ways.
I haven't been able to get it working.
Due to it being based on osCommerce
Yep, and osCommerce has a code base excreted from the bowls of hell.
The short answer is it adds a [number of new features](http://michelf.ca/projects/php-markdown/extra/) not found in Markdown proper. The longer answer is Markdown as a spec has not been updated or expanded since 2004, and the maintainer of the spec, [John Gruber](http://en.wikipedia.org/wiki/John_Gruber), has indicated ([documented by Jeff Atwood](http://www.codinghorror.com/blog/2009/12/responsible-open-source-code-parenting.html)) he has no interest changing the spec as it is. Nevertheless, there's been 9 years of real-world usage of the format and there are tons of inconsistencies and major holes, necessitating extensions and expansions. One of the first (if not the first) major expansions was via Michel Fortin's PHP Markdown Extra, which implemented a number of suggestions from the [Markdown mailing list](http://six.pairlist.net/mailman/listinfo/markdown-discuss). The PHP Markdown Extra page lists its additions, but they were common sense stuff like: * Footnotes * Tables * Markdown within HTML blocks * Fenced code blocks (wrapping code in `~~~` instead of indenting it four spaces) * Better handling of underscores * Being able to add classes and IDs [Marco Arment](http://en.wikipedia.org/wiki/Marco_Arment) either used PHP Markdown Extra without modification or re-implemented it in Tumblr (originally a PHP app) in 2007. As Markdown gained more traction, other apps started to extend Markdown as well and since Tumblr was one of the largest Markdown implementations, many used the same extensions (all derived from PHP Markdown Extra). [GitHub](https://help.github.com/articles/github-flavored-markdown) decided to ignore PHP Markdown Extra's extensions and added a number of their own, which has lead to a totally wacky situation with Ruby Markdown libraries, where there's at least 3 currently libraries that implement GitHub's flavor of Markdown (or subsets of it), their own extensions (e.g., mixing [Liquid](http://liquidmarkup.org) into Markdown documents), and various subsets of PHP Markdown Extra's flavor of Markdown. PHP Markdown Extra is older than dirt and has some code quality issues, but it's a known quantity in PHP: if you're parsing Markdown in PHP, you're almost certainly using it (or a derivative of it). If you want to go back to basics and only implement the strict Markdown standard that's fine, but if you're going to extend it, at least use the extensions everyone's already familiar with in PHP as a baseline.
It saves me time on boilerplate code. The big one is routing: pretty much any application I write is going to involve a routing script, and if I'm left to my own devices, I'll re-write mine from scratch every time because I'm sure that I could make it better. So using a framework spares me that temptation. They usually handle things like form validation, database connects, session management, etc. -- things you always need but that are boring or time consuming to write. Another factor is working with other developers. Sure, once you've written all your own boilerplate code, you could recycle that, but other people would need to spend time figuring out what you were doing, whereas if you use a fairly mainstream framework, there's a good chance they'll already know how it works, so they can skip to the important parts.
Very impressed with this. Bolt seems to be a serious contender on the CMS scene.
I use sublime because it's _not_ an IDE. We use a framework which is highly based on magic functions and so autocomplete won't work most of the time. And the simple autocompletion from sublime is useful enough. But damn, I love those multiple cursors. I can't imagine how to work without them anymore I just use some plugins for aligning code, one for phpdocs, small equations
If I could supply gold I would. Thank you!
I used to write a few objects here and there and then reuse them/tweak them in a few projects I would develop. It saved me lots of time, and essentially it was my own "personal framework". Of course it was buggy and was essentially a mash up of several vendor plugins with abstraction. After I got the grasp of what I was doing, I moved on to production frameworks. The main reason behind it is my own code was bad, other frameworks were better AND tested with a large communities behind them. 
Silex isn't so much a framework as most people know it. It's a "micro-framework". This means that while it takes some of the heavy lifting out, it's really not the same as a full-stack framework. That's not by any means a bad thing. I made the same transition. Using a micro-framework is a good way to learn the benefits of handling things like front controllers, and routing. You can see the how it works without a big investment in learning time.
when i used sublimecodeintel i had from time to time freezes when the context menu popped up, but in theory it would be sweet. haven't really checked out the jump-to-definition feature. does it work well? i've read that ST3 should come with a such a feature.
It runs well enough for me with 6GB and an HDD, but i'd like to go to 8 gigs so that I can spin up a vagrant vm or two without issue. 
Because PUT isn't intended to be used to posting data. That's what POST is for. A PUT request is used to identify an entire entity, such as a full object. Not just parts of an object. Does that make sense?
Because HTTP PUT was not a serious thing when PHP, and specifically, those superglobals, were implemented.
-- Michael Scott
My group switched to Zend Framework about 4Â½ years ago, shortly before I got there. It was primarily to standardize things: we are 3 to 4 developers with individual projects that we generally maintain ourselves. Until somebody leaves (which just happened again two weeks ago), that is. Since everyone has his own individual coding style and there are myriad ways of doing any given task, it just got crazy to maintain the older systems whose structure was completely different from any other. 
although, this is a decent question, I feel like you're just talking down on PHP. There's a short list of things in php that aren't as pure or perfect as we'd like them to be.. *shrug*
I've seen lots of large projects done in bespoke PHP without any framework usage. So I can basically make the same argument from the opposite point of view. I've seen how bad it can get when you **don't** use a framework.
I'm not arguing this point, but it does lead to a logical question. What **is** a framework? Seriously. I've heard the term "framework" applied to pretty much everything I'd consider a framework - Cake, Laravel, Symfony, CodeIgniter. I've seen it applied to things that seem to me to be a borderline call, such as Drupal or the above definition. I've seen it applied to things that I would consider by no definition to be an actual framework, including Wordpress and PHP itself. So... seriously... what is, and is not, a framework?
Yeah, that first one sucks a lot. "But... I could just... ARRRGHH!" 
There are some insanely huge gaps in the documentation. Such as the "lists" function. Basically undocumented. It's pretty fundamental.
Yeah, I'm in the same situation. "If I knew then what I know now... etc."
$_POST is a convenience feature. The actual data sent by the web browser is always in php://input. When dealing with a web browser, POST data can be sent by the browser in 1 out of 3 standardized formats: application/x-www-form-urlencoded, multipart/form-data or the fairly pointless text/plain. You can read more in the [HTML standard](http://www.whatwg.org/specs/web-apps/current-work/multipage/association-of-controls-and-forms.html#attr-fs-enctype). But the standardized version of HTML forms don't allow PUT as a method, making it fairly pointless to support those types for PUT. For POST, PHP supports the first two formats and automatically translates them into the $_POST and $_FILES arrays. For form keys with brackets in them, PHP turns them into arrays. For multipart/form-data, a whole bunch of complex stuff gets done with the uploaded files and you get your $_FILES array populated. That's very nice functionality when dealing with web browsers and most PHP devs don't even think about what's going on between the web browser and PHP. But beyond web browsers, you're not playing with HTML; you're playing with just HTTP. HTTP/1.1 places no restrictions on the payload type and doesn't define any that you have to worry about. And indeed, lots of modern APIs expect their data in the form of pure JSON, YAML or XML. Ruby on Rails supports automatic parsing (which made the [early 2013 YAML exploit](http://www.sitepoint.com/anatomy-of-an-exploit-an-in-depth-look-at-the-rails-yaml-vulnerability/) so much worse). Laravel also has a few undocumented methods that can [help with raw JSON data](https://github.com/laravel/framework/blob/v4.0.9/src/Illuminate/Http/Request.php#L406). But since this code doesn't exist automatically, you need to draw a line somewhere. Rails supports a whole bunch of formats, Laravel left it at just JSON, pure PHP leaves it up to you.
Just to expand on what you said, PUT was not a serious thing in *browsers* (and still isn't) when PHP was being designed, and PHP was designed around browser clients. Serious APIs using HTTP came along much later.
Most people are going to steer you to WebStorm/PHPStorm - personally I'm still a loyal ST2 user - will move to 3 once it's out of beta.
Don't get me wrong, I love PHP. It's like the wild west of programming.
They usually have discounts around the holidays. Sometimes as much as 75% off! So keep an eye out.
I asked it to parse something. Site went offline. :(
I use Kohana 3 and love it. That is all. 
You can just remove the dash from that same string. It's just a list of characters that should be considered "word separators". The string posted is the same as the default, just with $ removed.
Me neither. Who the fuck codes by using their mouse? 
There's nothing of the sort in the RFC 2616 specification.
Plenty of people do hobby sites in PHP or otherwise don't derive their income from PHP. I field a question now and then from a friend in a dead end job teaching himself IT, and while he's not going a coding route, it would be out of his price range. I do agree that any person employed to write code who can't get a license for a $100 bit of core tools is a sign that something is wrong: priorities of management, too timid to ask for what is needed, etc. Finally, as another reply points out, JetBrains does have 50% off sales now and then (I haven't seen the 75% the other reply mentions), or at least have had in the past. Plus they allow you to renew at 50% off (or allowed me to in my last renewal).
Aptana is worth checking out plus it's free! I liked sublime a lot, but I found the FTP lacking. http://www.aptana.com
I use PHPStorm for OO PHP, specifaclly ZF2 development. I use ST for css/javascript, and especially when I need to work with CSV files or the like. The multi-cursor saves me SO much time. My coworkers even give stuff to me with a comment like 'here, let your sublime thingy take care of it :P' I love ST.
It's in the documentation. http://www.reddit.com/dev/api#POST_api_comment
This code contains a goto with the comment #trust me Why the fuck does anyone need a super fast markdown parser? Either do it in the client, or cache it to memory/disk.
The name sounds like an Italian pornstar or smth. The parser is yet to be tried out:)
I never had any speed complaints with PHPStorm on my 4GB system. I have a Logitech G15 set to show how much RAM/CPU apps are using, and PHPStorm never crested 1GB for me. It is possible you are working with much larger codebases than I though.
A couple of minutes? That is pretty bad. On my 4GB Windows 8 system it never took that long. Maybe 20 seconds, maybe. I did have an SSD, though it was hooked up through SATA 1 so it was hardly blazing fast.
You can not really "emulate" or tackon an IDE in a text editor. That would be like having a bicycle then trying to tackon a pickup truck. An IDE and a text editor are completely different tools, much like a bicycle and a truck. They each have their advantages and can at times accomplish similar tasks, but not always. No there is not an IDE that launchs as fast as a simple text editor. Trucks do not get as good of gas mileage as bicycles, they are beefier and built for bigger jobs. I apologize for beating the analogy to death, but I hope you get the point. Sublime text is great, for a text editor. Integrated development environments are inherently slower. They actually compute your code and understand it to a large extent. This naturally takes resources, but it also has enormous benefits. It means that the app can work with you, point out flaws, debug, all sorts of fancy stuff because it actually understands what you are doing. If you want a fast and easy to use IDE look a PHPStorm. It takes a while to get accustomed to an IDE and see the benefits, but once you do you will never go back.
Neither of those are reasons to not make the effort to optimize something. 
Cache it. There is no need to compute anything twice. The compiling of markdown to html belongs in the time scale of writing the markdown in the first place - minutes.
But they both are. Premature optimization leads to silly things like using GOTO, and then explaining the usage with a comment like "trust me"? If the goal of this library was to create a fast parser, then there should be a need for a fast parser. But markdown would be parsed once and cached, so no special need for speed. Solving problems before they exist with code that requires "trust me" is just bad. E: if the point was just to create something fast for the hell of it, then awesome! But it's like clever one liners, they just create hard to maintain code for no reason.
After vim, eclipse and all its friends, netbeans, st2 and 3. I finally stranded at phpstorm and will never go back. If you take your future in this profession seriously you spend that insane amount of 50? bucks.
The reason for this confusion is due to the poor implementation of the MVC in the framework. If your controller would take care of a SINGLE action, like show() you wouldn't find this strange. Frameworks should have been made so that you write class UserController_ShowAction { } instead of what you have posted. Somebody else said that your controller would know to much if you use a DI container. But the way frameworks are build the controllers already know too much; they are aware of ALL the actions they can execute. That breaks the single responsibility principle and makes you use inject "proxy" objects if you want to optimize. Regarding what people said about testing the controllers, I find that controllers should be the last thing you would test in an app. They should be thin (get data from request, pass it to some services (validators, ORMs etc) and return some data for the views). I doubt that if you have the other things in the controller are tested your app will become unusable because of the controller.
Good, and the online comparator is great. But: - no support for Github fenced code blocks - no support for tables Also, I tried my biggest markdown file (20 pages), it was parsed in 5ms rather than 30ms. Yay! Or not, I don't care. It's so fast anyway that really, I can't see the difference. Most of my files are parsed in 1ms or less, what is the point? Performance is *not* everything, and it shouldn't be your only selling point. Except in very rare cases where I would want to parse a whole database of markdown files. Code problems: - no namespaces - singleton is useless, I can do a "new" - code seems very complex with all the regex. I don't want to be the one maintaining it - one big class, with few big functions -&gt; try splitting that up
Not a single part of the parser depends on the "goto". You can remove the block that contains it and the parser would still work.
Yes, but my point is that most of the time people will want to return a copy of the array. So it's better to teach people about `array_map` and copies, and show the "modify the array" as an more advanced/specific use case.
You would probably want to cache it for websites that attract huge amounts of traffic. For the majority of websites, though, a caching system might introduce an unnecessary complexity, especially if a regular article gets parsed in less than a millisecond.
But it would be slower? Why is it there? Why don't you comment it properly? I don't think you understand what I'm trying to say. If this is just an experiment, then it's nice. But it looks like you want people to use this code in production. Hacks like goto explained by comments like "trust me" should not be used in production, particularly when you are solving a non existent problem.
I've gone over the api documentation three dozen times trying to figure out what I'm doing wrong. Could you be a little more specific?
I haven't tried both - only Solr (http://www.yousmellgood.co.uk/) - which I found to be awesome, but complicated and fiddly to get working. Going from Symfony 2.0 to 2.3 with Solarium caused plenty of things to break - my fault for not reading their docs - but that's never fun on a project that you haven't worked on in some time, having to dig back through the code. That's a side issue really though. I would sway towards Elastica if I were to re-do that project, as it pops up more and more on blogs / reddit / mailing lists etc - which to me, means more of the harder questions will have already been asked / answered by the time I find myself encountering them. 
Thanks for this, I have some `json_decode(Request::input())`'s to remove
Remarkably unhelpful. 
Worth noting that there's a free license for those who work on open-source projects. 
Well excuse me for preferring more control and less overhead.
"I've seen it done wrong, so it should never be done."
No, it's pretty much just wrong. 
That's a truly impressive statement. Probably about the most misinformed and arrogant thing I will encounter this week, congrats.
I've added my code to the post and added a comment where I believe the issue is.
Mostly, sending to secured API URLs, you'll need to send a session-token in a header or in a query parameter. You get that session-token, with an additional refresh-token, when the user authenticates with reddit, and reddit calls your page with the tokens for this user. This token allows you to access content "as the user". The session-token is valid for some time(mostly for an hour). After the hour, you have to send a request to reddit, with your refresh token, to get a new session-token.
Alright, **differently from a lot of viewpoints that tell you that you are faster with a framework, this is not true**. You are not actually faster with a framework enough for it to have an impact in terms of release dates and marketing time from the perspective of a client. Especially to get the MVP (Minimum Viable Product) on the market. Chinese software development principles have shown this very argument to be true for years with a market dominated by raw code and no documentation where the only thing matters is a release and not a maintenance. I can very easily create a very simple website that takes user information and shows some private data just by using bare-bones PHP. I can make a similar project happen with a framework in the same time frame (depending on needs, sometimes faster, sometimes slower). But what happens when you use a framework is that you cover all the bases you would never have time to cover when just writing a bare-bones PHP project. All the little things that will matter down the road that make your software better to maintain, refactor, support and develop further. Does your project have an API from the get go? Proper HTTP headers? Caching? Maintenance testing? Unicode support? Automatic documentation generation? This is where using a framework gives a huge benefit. **Using a framework does not help your code today, it helps your code tomorrow.**
Are you storing the tokens in a Database? Surely, when he logs out and the session gets destroyed, you won't have a token anymore and he'll have to login again. If his token got invalid in the meantime, try refreshing. If refreshing does not work, send him to the login.
How is it unhelpful, the term framework is exactly the same meaning of what a "framework" we use is meant to be... 
Really? I didn't realize page 54 doesn't say this: "The fundamental difference between the POST and PUT requests is reflected in the different meaning of the Request-URI. The URI in a POST request identifies the resource that will handle the enclosed entity. That resource might be a data-accepting process, a gateway to some other protocol, or a separate entity that accepts annotations. In contrast, the URI in a PUT request identifies the entity enclosed with the request" in other words, use POST for passing parts of an entity's data, vs PUT for passing the entire entity.
Personally I use it just like I said. If I've got a front end UI that uses backbone (for instance) I'll probably use PUT when saving an object because i'll be sending a complete object structure. However, things like a sign up form, or even a contact us form, I'd use POST because i'm not sending a full object structure, just pieces of a much larger structure found within my application. IMHO, thought, there's not much need for PUT if you're working with a browser as the client anyway. Things like REST API's however are the place and time to use such a verb.
Can I ask why "loading fast" is a desirable characteristic of an IDE? I mean I don't spend my whole day opening and closing my IDE. At most I open it once per day and if I don't shutdown my PC it might be open for days on end.
The segment you just quoted does not support your argument. You're misinterpreting it completely. Read the rest and also compare to the section which precedes it, namely "9.5 POST". 
A colleague of mine use Aptana, and for some reasons SFTP on it is really (really really really) slow and he ended making a rsync script instead. One thing to consider if you use it.
Yes, you are possibly right. OP could have *eased* into advanced array manipulation by starting with the basics. I guess it depends on his target audience.
Christ. I haven't even had a chance to migrate my code to ZF2 yet, and they're already talking about ZF3? Ain't nobody got time for that.
It's way to early to be talking for ZF3. ZF2 is still an undocumented mess that the majority of ZF1 developers are unwilling to touch. Not only is the learning curve high, but a lot of the new features, patterns and models are poorly documented, not documented or event have out of date documentation that is incorrect. From a commercial perspective you cannot use a framework which runs a non-negligible risk of causing showstopping issues due to poor documentation. ZF1 didn't really get any commercial traction until 1.8, and ZF2 has a long way to go before it reaches that point. If ZF3 comes along now, before ZF2 has been properly accepted then professional developers will start moving over to more stable frameworks while ZF will become more of a hobby developer framework where its okay to turn the ecosystem on its head every couple of years. 
For reference, all max_upload_size does is prevent reading large inputs into those arrays; they're still available through stdin.
What is "an essential supporting structure" of a web app? What does that even mean? In concrete terms (no pun intended) what does that actually convey. I have an app. It has a user object. That supports the structure of the app. Cool, my user object is a framework? Hardly. It's a generic term defined here. It has little or no utility in this context. Even if it wasn't, you haven't even mildly touched on the actual questions I raised regarding what is or isn't a framework. Is PHP a framework? By that definition.. sure why not. Wordpress? Yep! Everything? Absolutely! If your only contribution to discussion is dictionary definitions, you have nothing to contribute.
The ZF2 documentation is pitiful. They really approached it fron a "everyone will use our components all by themselves" so most of the documentation doesn't deal with integration with their actual framework. So $this-&gt;getServiceLocator() in controllers isn't best practice? The only example in the documentation does exactly that. How am I supposed to know to do the right thing? Its like these guys made a framework, didn't tell anyone how to use it, and now upset that people aren't doing it right. Here's my advice gor ZF3: hire a technical writer.
`[the original parser][mdPl]` at http://parsedown.org/explorer/ is being left unparsed.
For a moment I thought that was "Zend Engine 3" and really wondered what was going on.
I was hoping this article would give me a more in depth look at ZF3 and actually explain what we should be doing instead of $this-&gt;getServiceLocator() in controllers.
 idiorm and paris
At what point are we going to step away from markdown and build a robust html parser? Am I off base here?
I never knew this. Thanks!
Thanks for reporting this. The issue is [resolved](https://github.com/erusev/parsedown/commit/4403fe4d96dbb3f495e206ca0613d0e1b702559e) now.
Not to be a dick, but I don't see the point of posting a link to a post containing links to articles. There's no added value.
Doctrine consists of two parts, and ORM and a DBAL, you can use just the DBAL as a standalone component if that's what you need. &gt;Are there any very light weight ORMs that provide the kind of performance that we'd see from just a DBAL Obviously no, an ORM is always going to cost more performance wise than a DBAL. Doctrine is an extremely well written ORM, unless you are using it incorrectly, it won't give you performance problems. There are a lot of people on this subreddit that love to throw the "doctrine is heavy" mantra around, and my personal opinion is that these people have either: - never tried it, but saw someone else say "it's heavy" and keep repeating it - couldn't be arsed to learn it so they went with something easier - didn't understand it The docs and the library is larger than any other ORM currently available for PHP, but larger library != slower code. The code is larger because it implements the data mapper pattern, instead of active record which all of the other ORMs do, so with Doctrine you don't have to do shit like "User extends Model". Your entities don't have to extend anything. Just look at the numbers on packagist, on the [first page of the most popular packages](https://packagist.org/explore/popular), 7 are from Doctrine, with most of them hitting the 2million download mark. For reference, paris is on ~4k, redbean ~7k, and idiorm is on ~6k. If Doctrine were really that heavy and slow it wouldn't show these numbers. If you still think it's "too heavy for our purposes" tell us your purpose, so we could give more accurate answers. Sorry for the rant, I'd just like to see this "Doctrine is slow" mentality end.
Eloquent from Laravel, also known as Illuminate Database as a standalone is quite good
"The biggest need for an ORM really comes from the need for a DBAL" is like "The biggest needs for a bike really comes from the need for wheels". While a car has nice wheels too. Do the different databases need joins between database? Do the models span more databases? Do you actually use an ORM in your current project, if yes, which one? What are examples of queries you are going to use? Which SQL syntaxes (which servers)? Active Record: Redbean PHP (sort of) https://github.com/Surt/Granada Data Mapper: Doctrine Propel Light weight ... from your requirement "we support multiple DBs with different SQL syntaxes" you are not looking for light weight. "I realize that performance and ORMs are kind of incongruous" No they are actually very performant at what they do. Unless you don't know how to write JOINs. "however we need a happy medium between the two" i think you are expecting something different then is actually realistic. What are you expecting? "and most modern ORMs (including Doctrine) are just too heavy for our purposes" Then why ask for an ORM in the first place? Seriously when it comes to performance no other PHP ORM is going to outperform Doctrine by large amounts. In fact measuring the performance of ORM's is one of the least meaningful things to do. Feature set is number one. Why? Because it depends on how you write your queries, how you use cache and how you need your results returned. 
you might look into this function connection_timeout() it returns true or false (technically 1 or 0) http://www.php.net/manual/en/function.connection-timeout.php
Thanks, this looks great. Going to do some speed comparisons to see how it performs.
I think it's fairly important to point out that ORM's and DBAL's are two different things and shouldn't be confused, as they currently are in this thread. Doctrine even spun out their DBAL to make Doctrine DBAL: http://www.doctrine-project.org/projects/dbal.html This is actually used by Illuminate\Database too, as it _does_ work incredibly well. Taylor wasn't going to use it, but the amount of work that kept going in to the database layer was just getting a little silly, and some things like column renaming are insanely hard to do in MySQL without writing a LOT of code, so it made sense to just use it. FuelPHP has a pretty good DBAL too: https://github.com/fuelphp/database
Thank you for this clear explanation! It does make sense to make it more clear which dependencies a controller has. So what you're saying is that they would recommend moving to constructor injection as opposed to the service locator pattern by using factories? I suppose it does improve code readability and dependencies. Regarding plugins, what makes them so special that they can't be used through constructor injection as well? Is it the fact that plugins are just always supposed to be around?
To be fair, it is pretty damn slow. For me, though, the benefit of being able to code maintainable business logic in a way that makes sense and is undeniably reusable greatly outweighs the additional processing time it takes to hydrate object graphs instead of miles-deep-multidimensional-arrays. And anyway, when you hit a part of the application where Doctrine is the bottleneck, it's easy enough to drop down to raw SQL and skip the ORM altogether.
Awesome breakdown, thank you.
I've been using it daily with sftp (mainly AWS servers) for the last year or so and haven't run into any problems yet. I previously used netbeans, and the FTP in there was truly abysmal. My colleague and I politely referred to losing work from FTP sync errors as "getting netbeans-ed"
No longer working there. Feeling happier now. :)
Are people actually using RedBean in production? Serious question. It's my favorite ORM but the fact that a typo can create a new field makes me shudder. Of course, from that feature comes the beauty of RedBean, so it's not like I'm complaining
I really thought using dummy data was a common thing. I wrote my own classes to import dummy data, because at the time stuff like faker didn't exist. I'll have to take a look at faker, because it's probably better than what I have. Thanks for the article.
That's pretty bad. It reminds of a place I contracted at that forced me to store CC information even though it wasn't needed. I ended up leaving, because what they were going to do put lots of people at risk. Another time I was contracted to audit a piece of software that was in production and oh god it was a mess. Before I even got access to the code I poked around and gained access to the admin interface via the password OR 1='1. You'll never guess what I found there. Full CC information in plain text along with everything I needed to steal their identities. As you can imagine the source code wasn't much better. I ended up telling them they needed to remove the software from production and go back to what they were using and fire the contractors for negligence. No idea if they did or not, but just looking at it pissed me off, because it's people like them that give PHP devs a bad name.
Nope, please tell me more
I just run the tests, in which some of them creates entries as part of their expectation. Anything wrong with this approach?
Were there absolutely no PCI compliance audits? That's sketchy as hell.
And illegal
This has "contracted Chinese programmers" or "1990's" written all over it. I don't know how anyone with a sustainable income could get away with that in the States.
Haha, that's pretty bad. In my case, that's only the tip of the iceberg. I don't fault any of the devs for making any bad decisions though. The culture of the company had issues. It was very much the case that there was an inner ring / private club that you had to belong to and, if you weren't accepted into that inner ring, anything you said would fall on deaf ears nor were you given any merit or acknowledgement for the work you did. There was a complete lack of transparency (often you wouldn't really know what you would be working on even the next day) and even the team leads were the most cynical about management. It was the sort of environment that bred "office politics", doublethink and negativity among developers - even towards each other. Not the worst place in the world to work, but they really need a serious shakeup to work out these problems. Unfortunately, I seriously doubt that will happen due having this "inner ring" culture. So glad I'm no longer there. If there's one lesson I learnt from that company was how important it is to work for a company where the management is capable of understanding the work you have done and evaluate your work on merit rather than based on their personal perception of you. Without that, you are at the mercy of other people who may have agendas or poor judgement.
&gt; performance is not everything Parsedown is not just about performance. In fact, its performance is almost a side effect. What it is about is an alternative (and a hopefully better) approach to parsing Markdown. I should have probably chosen a different title.
Why are you hydrating 10,000 objects in memory? That's ludicrous
It's basically an application that holds products that have all about 1k-10k possible configurations (lenghth, diameter, material). It got bigger than the client expected à² _à² 
That's great, very useful. Any hints on where to keep and manage these tools? Presumably you don't want it in your main code repository that could end up in production, *just on case* it gets run, *zap-truncate!*
You would be surprised how many company bosses have a nephew who can "do this stuff". I have just this week had to disable some PHP that a client's "developers" uploaded to their site due to how insecurely they were written. The ability to bypass the admin password to get into the personal details of UK dentists was only the tip of the problems in these scripts. The SQL injection vulnerabilities in EVERY SINGLE user input, opened up the entire Drupal database (that they had scatter-gunned with their own tables) to the Web. Muppets. FTP access has been revoked. Oh, they didn't use us to write these scripts, because they had cheaper developers they could use. Now they have scripts disabled by me, my time taken to unravel the remaining mess, and who knows what law suites could result from data that may now have got out. Don't scrimp on doing things properly folks; it's a false economy. */end choir preach*
I find it iteresting that Heroku doesn't mention this on their website (just like 'normal' PHP support).
First, welcome to the exciting world of localization (pun intended)! Opinions will likely differ here, but if you are in a position where you will need to display local times to users around the world, you will run afoul of many difficulties if you store times and dates in your database using a local time zone (especially one that is subject to Daylight Saving Time, such as most of the US and Great Britain). My recommendation is to store time in the database in UTC (since this was a significant reason for its devising), and shift the time for each user based on business rules. This may be based on a "guess" as to what their local time may be using either Javascript or "geo IP" look-ups, or by actually asking them what time zone they are located in. Considerations: * Methods for automatically ascertaining a user's timezone are not foolproof. If it is critical that you display the correct local time, provide a setting that the user can change. * DST begins and ends on different dates in the US and the UK. Moreover, some municipalities in the US do not honor DST at all! Be sure your system accounts for these cases (or at least provides a way for the user to configure their own settings). Ultimately, storing the time and date internally using UTC assures you that you will not have weird situations with scheduled tasks or maintenance operations if the time suddenly changes at the start or end of DST. The worst thing that can happen is that you display the wrong time or date to a user due to a bug in your code, which is easily fixed and won't corrupt anything. Say you have some job that looks for records created beyond a certain window of time, then DST ends and the clock moves forward one hour, you suddenly expire a bunch of records you shouldn't have. That's the kind of stuff you have to look out for if you store local time in your database. It might not be a dealbreaker for you, but something to keep in mind.
Programming time is very hard. Bakuretsu already gave you some good advice, and I agree that storing UTC is best and would also recommend to ask the user about their timezone (and then preselect the users timezone somehow) since the errors of this type can be easily noticed. I want you to read the [list of falsehoods programmers believe about time](http://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time) and think about that. Also, the [second post on that topic](http://infiniteundo.com/post/25509354022/more-falsehoods-programmers-believe-about-time-wisdom). 
a nice way of telling the time (for things past) without bothering with timezones is saying something like "2 days ago" ... "2hours, 5 minutes ago" or even "today". that way just save the unix timestamp - and it'll be correct for the whole world.
I signed up with Reddit just to contribute to this. Most frameworks are a real and serious waste of time, IMO. One justification is that learning them is good for your career. I'd agree with that, but the basis of it all is a lie that will eventually come to be seen as one. Frameworks are not faster for simple sites, and they just cannot do complex ones. Why? Because they make the simple stuff very much harder to do. I'm about to start a job that requires me to use FuelPHP, so I had a look at it. Putting a form together is easy in HTML, but because FuelPHP is a framework you have to configure two or three arrays that will call up objects that will then... echo back exactly what you could have just written out in HTML. Get this, there is approximately twice the amount of code to write and the overall syntax is both obscure, unique to the framework, and under-documented. Want to style those form inputs? I'd normally add a class and be done in about a minute. In the framework, I'll have to find out how to add a class first - and will take about 100X the effort and time. I know (really!) that there will be a way to do that BUT you need to know what that way is and the need for research is what slows everything down, hugely. It's as if HTML/CSS/jQuery/PHP/MySQL are too easy, so we have to find a way to take a week getting a form in place on a page. "Oh, but you can do complicated things with frameworks" - I completely disagree. They make the easy difficult and the difficult impossible. You know who makes internet systems that cost half a billion and don't work? People who try to do everything using one tool to control another one that controls a third one that actually puts something on screen. "Oh, you can save time by re-using components you have already built" - reusing code is Ctrl-C!!! jQuery is great because it gives you tools to do things - use them when they are needed, and treat yourself to one that works well and is particularly well-suited to the needs of your application. Frameworks limit your choice, so before you know it you will be trying to alter and then debug something that doesn't quite do what you need it to. And because everything is abstracted away into five separate files, you will be a long time debugging. "Oh, you won't have the security protection, because... you might forget to escape your output. So you should trust the clever people who made the framework". Problem is, if there is a security hole in, say, RoR (I remember that there was...) then every site ever made with it is vulnerable and the whole planet knows it. "Oh, but frameworked sites are easier to maintain". No they aren't. There is more code and it is scattered over a dozen or so different files. You might get lucky and find that a site has been built with a framework you already know, but it probably wasn't. The thing that annoys me most is the superiority complex of those who use frameworks to produce 'better' or 'more complex' sites - really? Which internet are they on, then? The net I use is full of lumberingly slow sites that have awful user interfaces and replicate the same mistakes again and again. "Ooops!!! Did you type the link incorrectly?" No, I clicked a link on your framework-built website. Anything big and complex that works is written in PHP or lower. Working with frameworks lets you build a site provided your client, and you, are happy with producing something that has been done before - if not, put another couple of zeroes on the bill and submit your tender to the big corporations and government departments that can afford to spend other people's money producing lousy sites. In general, things like Bootstrap and jQuery are popular because they give you more than you put in. With frameworks, other than those you can use as libraries, it's the other way round. Try and come up with a better counter-argument than the usual 'I use frameworks because I am clever, so you are not clever'. Please.
xor has a lower precedence than assignment. So your line is evaluated like ($test = $negated) xor ($condition_negated) If you're actually working with booleans, then you can just use the bitwise xor operator: ^ $test = $negated ^ $condition_negated; 
I see, thanks! Btw, it's really super idiotic that something has lower precedance than assignment
A simple env check protects you from that. This lives in my main API codebase but just bugs out if you try it on production.
Nothing wrong with that approach. You are doing database seeding with extra checks in it. We seed then test, because we put a LOT of data in in one go, then test things after some more (some of which insert things too), but trying to test each and every bit of that data on the way in would be mind-numbing and slow. If it works for your app then awesome :)
Good point. The configuration for the fake data generator could go into environment-locked configuration files, just like database settings. 
It's probably pretty new.
Yeah, it's kinda weird. All the word versions of those operations have lower precedence: and, or, xor.
PHP's `or`, `and`, and `xor` are inherited from Perl. Larry Wall added the super-low precedence versions of the logical operators to allow for the `do x or die()` constructs that were popular among Perlers. Python inherited them too. Best advice is to avoid `and`, `or`, and `xor`.
well we have &amp;&amp; for AND and || for OR, how come there is nt ^^ for XOR?
`password_hash` has a library that will work in PHP 5.3.x. You should really look into it and use bcrypt over PBKDF.
I don't have time to read PHP rant blog posts, but I fixed the issues I could infer from the headings. New version: http://docs.php.net/hash_pbkdf2 :)
Hehe, I didn't spot that before. 
i do like them for other reasons as well... sometimes i don't know the date or time right now - so a precise absolute time means nothing to me - but with "2 hours ago" i instantly know when it was - no matter if i'm in the middle of a 48 hours coding run or just woken up. the difficulty with that approach is that you have to keep the times up to date if your user stays on the page for a long time. if you specify your posts with "2hours, 5minutes ago" and the user stays on the page for an hour - the timestamps don't mean anything ... but you can fix that with something like "...&lt;span class="tm" data-tm="123456789"&gt;5 minutes&lt;/span&gt; ago..." and then loop through all .tm elements once a minute and update the string.
I consider it super idiotic that people rely so much on order of precedence being what they think it is instead of just using brackets to ensure the instructions are always executed in the correct order.
a good part of this article is about that function in particular.
Well I wouldn't be using the 'xor' at all if a consistent operator like &amp;&amp; or || existed for this operation. I know not knowing the precedence level is kinda my fault, but to justify myself I never ever used 'or' or 'and' in my life before so that was something I stomped on by accident. al I'm saying is that we need consistency. If there is and &amp;&amp; for 'and' and || for 'or' and why there isnt '\^\^' for xor ?
I've only had experience with ZF2's DI. It can do this, you just specify implementations for your interfaces and, if you have multiple implementations, which implementations should be preferred for injection into different instances. However, I'm sure this would be a common thing in other PHP DI implementations otherwise you'd never be able to use interfaces.
Can you show me an example of how it would look like? I can't google the interface based DI solution in ZF2
Here is the link to the presentation: [Taking PHP seriously](http://www.infoq.com/presentations/php-history) Basically, the guy (Facebook HHVM engineer) said that yes, there are lots of tiny problems with PHP (like inconsistent function naming, parameters order, some weird behaviors with type conversionsâ€¦), but that's not really important compared to the whole. On the other side - the workflow of a PHP dev (Ctrl+S and F5 instead of compiling or restarting a server or other stepsâ€¦) - the fact that we don't have to deal with concurrency (new process for each request) - and the fact that requests don't share state -&gt; less bugs, easier to grasp (again, new process for each request) makes it a **very** productive language. He says they noticed at facebook that you take any good engineer and he will pick up PHP very quickly and be very efficient. I cannot agree more with his conclusions. I have experience in Java or .Net and I am **extremely** faster at developing in PHP than in other languages. So it makes me very sad when developers from other languages pick on PHP and its inconsistencies and think everything related to PHP is bad. Because in our day to day work, we are really not affected at all by all these details.
Yes.
Well its definately not what I was talking about. You still need to do a lot of code to get the result. The c# way is much more automatic
I don't think any of the ORMs will provide acceptable performance when you hydrate 10k records.
See: http://framework.zend.com/manual/2.2/en/modules/zend.di.instance-manager.html#preferences for a simpler way. However, if you have multiple implementations for a interface I don't see how it is possible for c# to be automatic. How does it know which implementation to inject? You'd have to tell if somewhere and if your constructor signature changes, say to use a different implementation, you'd need to modify something. I mean c# can't read your mind as to what implementation to use.
You can find php buildpacks on heroku's github. And a quick search on google will give loads of results. They just dont want to do customer support for PHP stacks , that's you wont find any doc on their website. But you can install anything you want on Heroku , i run a neko web server , who has heard of neko here ? as long as you can compile binaries on heroku server and write shell scripts , whatever solution you chose will run there.
no you could deploy PHP apps on heroku for years already. Just dont expect any support on their side.
Just wondering how this performs? We use scrypt and we originally tried a PHP implementation of the algorithm but with reasonable parameters it took over 30 seconds to calculate. With the same parameters the C extension takes about 200ms on the same machine. If we picked less intensive parameters to make the PHP implementation complete in a reasonable time we'd be throwing away the whole point of using scrypt in the first place.
that's one shouldnt use ORMs in that case.
 * Why would thhe performance hit occur if caching is utilized? * Don't use static calls? * How is one xml file with a key value interface-&gt;class map not obvious? * Thats the point of having a DI to elt it figure it out * What primitives? Examples? 
That's... just a little silly. What was OP supposed to write? $test = ($negated) xor ($condition_negated); Do you write code like this? $test = (2) + (2) OP got messed up because of the unexpected behavior of logical operators in PHP, not from a lack of brackets. No one in their right mind puts brackets around a single left and right hand operand. I consider it super idiotic when people don't trust or know the order of operations, so they put unnecessary brackets around everything. We're taught the order of operations for a reason.
Primitives are numbers and strings. In some languages also booleans and dates. In this extra configuration info needed for the dependency but not something that belongs in the server's config file.
&gt; fast hasing algorithms Run your article through a spell check before you post it, goddamn.
What are you caching? Often I see people cache the services but not the controllers. So every request needs an expensive reflection call to build a new controller. Other instances are more subtle. I've seen cases where non-cachable objects such as data models needing service references. So they too need to run through a reflection call. Note that I'm referring to C# reflection which is proportionally expensive. 
You misunderstood me. I didn't mean cache actual objects. Just cache the "expensive reflection calls".You only need to clear cache when you change some signature. So the reflection calls will only happen once. I mean at the end you end up caching a list of dependencies for each class thats all. Extra configuration info would go into some sort of Config Reader class that would also get injected As for a static call graph(sorry for confusing that with static methods), it should be no bigger of a problem as it is for example with symfony2. Using containers like Pimple will also not give you the advantage of static call map anyway. So this argument applies to the DI container idea as a whole really. 
I'm trying to do something related with a project called Emergence (http://emr.ge), which uses a virtual filesystem to provide a containerized runtime environment for PHP-based web applications. It allows the VFS to "extend" a remote VFS over HTTP so that you can "override" files in a copy-on-write fashion, and it hashes and tracks every write so the state can be rolled back to any point in time. SabreDAV provides developers read/write access to the VFS behind each application and a web-based IDE provides a quick way to hack on it without a native WebDAV client. My goal is to provide a bare-simple way to redeploy and hack on web apps that helps you minimize forking and plumbing. MIT licensed and always looking for feedback and collaborators.
For absolute times, always store in UTC, always convert on display to the user's timezone (LOCATION NOT OFFSET), always display the timezone and/or offset on with the time on display (so there is never ambiguity), and always provide a way for the user to change their settings, always use a library for handling the conversion (google php timezone) For relative times, e.g. recurring events, always store the user's time with the user's time*ZONE* (as in, Europe/Berlin) NOT *CURRENT OFFSET* (as in, UTC+0200 or CEST, etc), this is because offsets change, with DST, or politics
&gt; (I'm looking at you Pimple) Hey, I like Pimple! But -- being serious for a moment -- some people prefer writing code to writing configuration. There are valid opinions coming from both sides of the debate. Personally I have no interest in using configuration for a DI container. I'm doubly less interested if the configuration is written in XML. Anyway, just pointing out that writing code instead of configuration is a con for *you*, and not a con in general.
Its not that I have some particular love for XML )) But if you write buillder functions for everything its just busywork. 0% of all that can be automated by the DI for you. E.g. if you declare that some class expects 3 interfaces theres no reason to manually tell it which implementation to use each time
My rule is: Always, always, always save in UTC ... it's consistent and you'll immediately know when you fucked up the front-end display because your localized time will be wrong.
That's helpful! I would still try to store all of the time data in UTC though, for the sake of simplicity.
I wrote the Laravel PHP framework. Before I got into PHP a few years ago I was a .NET dev. Laravel's IoC container basically works exactly like the C# containers you are describing, as I based it off the IoC containers I used in .NET. You can simply "bind" an interface to an implementation. When you resolve a class it will use reflection to read the type hints and inject. It is available stand-alone as well.
Nice to see your comment. I appreciate. Yes Laravel is one of the good framework. Coming to Cygnite Framework - You will find much clean code, simple architecture, best performance, very light weight, and of course we are in development, you will much better features in coming days. I am sure developers will enjoy the simplicity of cygnite framework. 
&gt; much clean code like Laravel? &gt; simple architecture like Laravel? &gt; best performance, very light weight Please quantify this instead of just claiming it.
I can't help noticing that this really looks a lot like Laravel in structure and appearance. As far as I can see it's basically the same but without a lot of the key features, like migrations and a good ORM. If you want to stand out from something like Laravel you have to do one of two things: do more than Laravel, or do less than Laravel. Doing more is hard. But doing less is viable. A lot of people are leery of the performance overhead of a full-stack framework. I think they're wrong, but that's not the point. If you want to sell as an alternative, performance is a good approach. &gt; Cygnite is high performance php web application framework Orly? How is it high performance? How much better does it perform than Symfony or Laravel, and in what conditions? If you're going to talk about performance you need to actually back it up with something, otherwise it's just talk and a waste of everyone's time. As a closing point... English is obviously your second language. I hate to be rude, but the site is littered with spelling mistakes and grammatical errors. It might be shallow but that may put some people off. At the very least it's something that you should look at fixing.
Any link to a usage example?
Cygnite is short for Code Ygniter ? )
This website is absolutely rubbish on Linux Chromium. Extremely choppy thanks to the stupid social media sidebar and I can't even click half the links because there are invisible divs over them for some reason. Edit: Reading some of the source code, I need a shower.
Wait. &gt; Coming to Cygnite Framework - You will find much clean code, simple architecture So this looks simple and clean to you? return array( '/sayhello/(\w+)/(\d+)' =&gt; 'home.test', '/blog(/\d{4}(/\d{2}(/\d{2}(/[a-z0-9_-]+)?)?)?)?' =&gt; 'home.crons' ); I call it madness. 
For people looking one of those frameworks that does less than Laravel, but is claimed to actually be the fastest, check out [Phalcon](http://phalconphp.com/en/).
He's using regular expressions, which are naturally noisey (and I prefer them over custom syntax for their power), other than that, what's wrong with it?
It's not simple, not readable and not flexible. Have a look how Laravel handles it: Route::get('user/{name}', function($name) { // })-&gt;where('name', '[A-Za-z]+'); Not simple: Laravel is much more simplier. Not readable: It's easy to add 4-5 parameters to Laravel and manage them easily with where causes, yours will be a 40 character long regex string. When you look at Laravel route, you can easily see it takes one parameter. Can you see how many params do blog take? Not flexible: What if I want to get regex patterns from somewhere else in my application? Here, let's take another example: Cygnite::loader()-&gt;router-&gt;get('/hello/(\w+)', function ($name) { echo 'Hello ' . htmlentities($name); $defaultController = ucfirst(APPPATH).'\\Controllers\\'.ucfirst('home'); include APPPATH.DS.'controllers'.DS.'home'.EXT; $defaultAction = 'indexAction'; call_user_func_array(array(new $defaultController,$defaultAction), $paramArray = array()); exit; } ); versus Route::get('hello/{name}', 'DefaultController@index')-&gt;where('name', '(\w+)'); Seriously, what's the idea of releasing a framework when you can't even call controllers directly via your routes? Develop your internals and call your framework better than Laravel when it's done. 
Hey, I wrote [PHP-DI](http://php-di.org/) and it does exactly that.
First of all appreciate your feedback and suggestion @mattaugamer. Yes we are working to have ORM features, and much more into the core. "Typo" yes sure. We are looking at all those sections. as we are growing we will have most of the thing fixed. Day to day we are improving. So please be patient. Your suggestions and feedback highly appreciated. Thanks.
@WorstDeveloperEver I guess you have missed out. Yes you can call the controller directly from routerconfig.php and alternatively you can use routes.php. return array( '/sayhello/(\w+)/(\d+)' =&gt; 'home.testing', '/welcome/(\w+)/(\d+)' =&gt; 'home.users', ); It will call your home controller -&gt; testing action. It's up to developer how they use it. For much more we are working on it. Thanks.
The list of falsehoods is really good, and should be required reading for anyone considering dealing with time in an application. Time manipulation is so often misunderstood that it probably ranks near the top for things programmers (even experienced ones) habitually get wrong.
"today" is ambiguous and should never be used unless you're taking the timezone in to account because what the server considers to be "today" may not be "today" for the user. Fuzzy timestamps are fine, except that they also become ambiguous if your unit of measure becomes larger than "weeks". For example, if my start date is November 15th, and my end date is December 15th, how much time has passed? Logically we can say 30 days, but how do we tell if it's a month? November is 30 days, December is 31 days. Which measure would one use? Since month and year measurements change, they greatly complicate things. Worse still, the larger the fuzzy value, the harder it is to tell exactly when something took place. If I tell you a post was made 126 weeks ago from today, can you give me a specific date without having to think about it? Unless you're the guy from *Rain Man* I'm guessing probably not. As such, they are not a good way of accurately depicting a specific date/time in the past after a long passage of time. They're great for short-term time measurement, or cases where precision doesn't matter so much.
This is still a very unclean way to do so compared to Laravel. Instead of just proclaiming it is cleaner, why don't you actually make a test application in this framework and Laravel. Then put the code up so people can have a look around. You may also realize in the process that Laravel is much cleaner (and simpler) in its current state than Cygnite.
Nice work. I don't understand why you are changing the default timezone since you are using a DateTimeZone object. As far as I know the DateTimeZone object is sufficient and you shouldn't really be changing the default timezone, like, never. If you want to avoid timezone dramas always always keep your default timezone to UTC and nothing else. EDIT: Ah I see you are creating a DateTime object, but are still using the "date" function. Instead of, &gt; date("D m.d.Y [F]") you can use: &gt; $dateTime-&gt;format("D m.d.Y [F]") and in that case "date_default_timezone_set" is no longer necessary. 
The Zend Certification for PHP5 has never gotten me much (other than some "interesting" comments). Zend Framework certification is something that is sought by a number of companies in California.
Zend Certification is not that well regarded by employers. Few have heard of it. Those that have heard of it don't much care.
* Code is not PSR compliant * Code gave me a cringe fest Wow.
I studied for it but didn't take it. It's definitely a serious test. If I was hiring, I would consider it a big positive on a resume. It won't teach you everything you need to know about PHP, but it does cover a good amount of stuff. 
If you only care about speed, then use a key value storage backend like Redis. Otherwise you need to be more precise about what you actually mean by speed, and which other requirements you have like are there relationships (user) and/or multiple structures involved?
The user is able to input regular word/short sentences
It would be super fast to "insert" into /dev/null although you might have some issues retrieving the data again.
I got certified a few months ago. It's fairly simple if you had some experience. Actually I only had like 2 days to study due to a rather tight schedule I have. i suppose with 2 weeks of study anyone could pass it
What hardware are you working with exactly? Is time a real factor here, or are you just trying to throw in all the data ASAP to minimize user impact on script load? Have you tried breaking the form into smaller pieces? Have you tried utilizing queues?
In CodeIgniter you can change the *routing* to whatever you want. When these kinds of questions arise you generally want to make sure you have a firm grasp on what type of structures you'll be needing (for example, your controller may actually be "book", and all the example paths you gave would all eventually re-route to your books controller with various arguments letting you know how manipulate your "book" controller). The "controller/action/id" structure is broad and simple enough to handle a lot of scenarios you might encounter (especially when learning), but not the only way a well structured framework will let you build your app.
I lost respect for the Zend PHP test when the first question on the practice test was something like "What's the return value of count('Salamander');" I suppose, to be fair, I should have looked further, but I don't really have an interest in memorizing all the silly nuances of the relatively inconsistent PHP API.
I pipe all important data into /dev/null because it's crazy fast AND webscale. 
An easier way to make this so you can differentiate is localhost/genre/sci-fi/title/rainbows+end for example. So you just check the index of 'genre' then the next key in the request array for the actual genre to route. It allows you to put the attributes in whatever order you like and however many you like. You should make sure to include them all in your page metadata for crawlers to know they all point to the same page. Edit: why downvote without telling me why? :(
if the problem is book sorting, I would handle it this way. You have one controller action, lets call it sortBooksAction() in your Books controller. That controller passes parameters like genre, authors, book title, etc to a sortBooksBy() method in your bookCataglogue model/class. These parameters could be an array where you have the most important sort first and the least important last. Then you can dynamically create a sql query with ORDER BY statments in the order of your array. You would return these results back to your sortBooksAction() which would then pass those results to your view. Your view then renders the html. I like to think of the controller as a traffic director. I don't use it to process any logic. It just passes data back and forth from my models and views. For this example you would really only need one controller action with one model function. Your model function should be able to process any number of conditions passed into it and return the proper data. Hope that helps 
With most MVC frameworks, the Model in this scenario would be 'books', and the controller action would be 'index' (keeping it nice and RESTful). Then you would have controller parameters spelling out index criteria. With that, the non-finessed url would be something like: localhost/books/index/author:h_p_lovecraft/editor:jim-smith/ To view book details, it would be something like; localhost/books/view/at_the_mountains_of_madness With routing, you can do all sorts of things, especially if you know regex, so that the first url could look like: localhost/books_written_by_h_p_lovecraft_AND_edited_by_jim_smith and the second could be something as simple as: localhost/books/at_the_mountains_of_madness I don't know a ton about zend or codeigniter, but symfony2 is a framework that lets you abstract out the model completely (with some configuration) and might be a good first framework to learn. CakePHP is more straightforward MVC, and also very easy to start with.
&gt; You should make sure to include them all in your page metadata for crawlers to know they all point to the same page That is, they should have canonical link elements in the head, and those should all point to the same URL.
This relies on guess work, guessing isn't logic. You can't define a pattern on guesswork. This could be done by giving properties a weight, and looking for hits in order of weight before serving a result. That result would be the first hit. However, I think this is a horrible confusing approach as you'll never be sure what the result will be. Stick to controller/action/id, with these logical default actions - book/&lt;title&gt; -&gt; view one book, or a list of multiple books share that title - author/&lt;name&gt; -&gt; list of books of author (same as author/books/&lt;name&gt;) - author/bio/&lt;name&gt; -&gt; view bio of author - genre/&lt;title&gt; -&gt; list of books of specific genre - editor/&lt;name&gt; -list of books of editor ... etc The solution to your problem is a parametic search engine. this could be done by param/value pairs. (search/author/orson+scott+card/genre/sci-fi) 
im sitting it on tuesday. definitely seems worth it if you get one of the 50% off vouchers (which you can pick up from pretty much any PHP meetup/conference) and your boss to pay the rest. 
I earned my ZCE two years ago, however real-world projects is what actually gets me a job.
Actually that's something you should know, since count() will always return 1 if given a non-array. This can introduce unexpected results.
Just a note that you have a typo in your main headline: Discover Cygnnite
Yeah exactly :) thanks
How often would you really want to use count() on a non-array?
let's say the database contains &gt; 500.000 rows, is this solution going to cause a performance issue in a scenario of many many requests / second? i'd rather create more controllers and more modular db structure or maybe i just got your answer wrong
You could try something like slim or fat free if you don't want to mess with mvc yet
@pushad As mentioned we are growing and doing all changes one by one. So please be patient. Once people get familiar with CF, we will move the original site to main server. We are just collecting suggestions, feedback to improve it as much matured framework. If you find any "Typo" please rectify and send us in community page - Changes Tab You are also welcome as member if you would like to improve and have best features in it. Thanks anyway. 
Definitely time for a refactor. Even if you didn't use an ORM you'd still have to load those objects into memory. Unless you can work around it some other way 
the application will rely on few external rest api web services for data and other other tasks and i do want to offer a public api to share some of my app data (i still have a vague idea how to properly do this, do i need a rest server class? can i share only part of my data? in this example only authors and editors? how to secure and protect public and private data? etc) thanks for the link btw ;)
A project I worked on had million plus rows. As the devs couldn't implement any DB improvements (we were compartmentalized out of the loop) what we did was to schedule queries for downtimes (think cron jobs) and then cached that query. It wasn't the most super awesome solution, but it was fairly successful in lowering query times. I'm not involved with that project, but I'd love to hear more about other solutions that are available to us back end devs. 
It's worth noting MVC is quite an advanced architectural pattern. Most frameworks use an approach similar to MVC but it's not true MVC. In fact MVC is not web applicable in any traditional or sensible way. Mainly because MVC is stateless. If you're looking for something similar there are variants, Web MVC, MVP and so on. Here's a couple of resources. [Web MVC](http://osteele.com/posts/2004/08/web-mvc), [MVC for Advanced Developers](http://stackoverflow.com/questions/16356420/mvc-for-advanced-developers/16356866#16356866), [Is MVC suitable for web apps](http://stackoverflow.com/questions/7621832/architecture-more-suitable-for-web-apps-than-mvc/7622038#7622038), [Understanding MVC views](http://stackoverflow.com/questions/16594907/understanding-mvc-views-in-php/16596704#16596704)... there's many more of these but the main point I am trying to get across is that it's not simple, and if it is, it's probably not MVC but an approached based off MVC.
What you are describing in a more generic way is sometimes known as "facets". Multiple sorting and filtering criteria are fairly common and many MVC frameworks definitely know how to handle this. In your scenario above, you would probably have a rule that would be :controller/:action/*params so for example: bookstore/books/genre/sci-fi/language/english This would be mapped to controller =&gt; bookstore, action =&gt; books, params =&gt; { genre =&gt; sci-fi, language =&gt; english } So as you see, everything after the :action parameter is grouped together in an array or hash for you that you can then use in the controller action to perform further filtering against your models. Obviously this is just one way to handle it, but it's a common one. 
isn't a mvc approach based app proper for rest services? so why is not web applicable?
The thing is, it becomes hard to differentiate between localhost/&lt;genre&gt; and localhost/&lt;book title&gt; unless you make a specific thing like one argument = book title, two args = genre + book title
Research how faceted searches are implemented in MVC, there will be examples available.
If you are not comfortable sending JSON (of your parameters) to the server by post, you could implement multiple controllers for specific search types. 
I could be wrong on this. But no matter how many controllers you had, your traffic would all be routed to the same server, hitting the same db. You could DDOS any url pointed to that machines IP and take it down. My company has several tables with rows close to a million. We have those tables indexed on common fields to speed up queries. In your scenario, you would never return all 500k records at once, instead you would optimize your db and your query using the EXPLAIN function, ensuring you weren't looking at all 500k rows with every query. If you create multiple controllers to handle basically the same functionality with minor changes, you will end up with code that is difficult and annoying to maintain in the future. Personally, I feel that whenever you are going to copy and paste a function/controller/whatever to change a line or two, you probably aren't doing something correctly. You could test your theory though. Using apache benchmark or something similar, you could simulate like 50,000 simultaneous requests (i think), apache benchmark will output a bunch of useful data about request times and such. Just need to create a database with 500k plus rows of dummy data. When I was learning .net stuff in school, there was a fairly large practice database available for demo stuff. I am sure mysql or whatever db you are using has something similar. Again, I am not an expert at this stuff, this is just the way I would handle this scenario. 
Null isn't a value, it's the absence of a value. unset isn't a value. This is why they return 0. The point here is that it has unexpected behaviors and you should know about them.
&gt; but what if i want mix parameters like: localhost/genre/editor localhost/author/book-title You seem to be assuming that all the parameters have to be path segments. They don't. In fact, the query string seems better suited here. localhost/books?sort=genres&amp;sort=authors&amp;sort=book_title&amp;sort=editor
What you caught me on was I didn't say "non-array value" which was what I meant. In any case, you should know about php's quirky behaviors if you expect to be proficient in it. 
Most sane programmers would never use it with a non-array value. It might be marginally useful in cases where a function can take multiple types and will work with the input type regardless. Realistically though, the fact that it doesn't error means you might overlook it when there's a problem. Knowing the behavior may aid in debugging.
I took it for the first time a few months ago. The company I currently work for wanted me to take it within the first few months of employment. Unfortunately, I did not study well enough and failed. I spent a lot of time trying to memorize all the 3rd and 4th optional params in all the string and array functions because I was told that would be a large focus of the exam (the gotcha questions, that you normally don't use day in and out). I did well in that area, but completely bombed the security and web features part of the test. I would have loved to take the zend courses before I took the exam because I was not confident in the areas that I would be tested on. Some blogs said one thing, while others said another. The books on amazon where outdated, etc. A lot of people say just to read the php manual with the guidance of the zend php study guide to show you where the emphasis will be. In hindsight, I would say that the last option was the best and also cheapest way to go. I definitely will retake the test at some point, it's more of a personal goal now. Fortunately my company has given me a pass on the time frame for passing the exam since they like the work that I have produced thus far. Best of luck if you decide to take it.
Well, ideally no part of your application logic stands apart the API. Don't just think that your authors and editors are approach vectors for an API, but everything, including things like URL links. Otherwise you'll have a website and then an API, which is the way things are done the old-school way where the API is just an additional layer or a plugin. And then you'll have to update both if either gets changed, which is never a good idea. Imagine that your whole website works as an API, so something like this happens: * You fetch the URL that the client requests, such as your 'localhost/sci-fi/id'. Then you take that string and make an internal API call to see what page (view) you are trying to load. This is already an API call and not some 'core application'. * For example, this API call returns 'sci-fi' as the name of the View that you need to load, so you load that View with another API call and also send that 'id' as a parameter to that View. * This View internally will make a request again to your API, to load sci-fi data of that specific 'id'. If it finds data like that, it populates your View with this data, otherwise it loads another view, like 404. * In your case, you would have API calls (that go directly to controllers) like 'url-solve' that returns what View you are trying to load, 'load-view' that loads your View logic and then that same View logic makes an API call to load sci-fi data, like 'fetch-scifi' with a parameter of that 'id'. In every API call that implements your controller, your controllers may (and some may not) use models to fetch specific data for your use, such as your author information, page structure and so on. I know that it may be a little difficult to think about your website as an API, but this is the best way to do it because in that case you're entirely decoupling your entire application from View logic and templates and whatnot. You will have a true application that simply represents itself differently based on how the client requests data to be shown - either as a website, native mobile app or a partner requesting other 'sci-fi' data from you.
If you are a front end developer, why even bother with PHP? You can do MVC on frontend with Angular or Backbone. Power your frontend app with an API written in Node (you already know JavaScript, right?) You could even use Parse for the backend and focus solely on the frontend.
Would you be willing to outline a (simple) example of an API-centric design in code? I liked the article, but it's difficult for me to grok things like this without concrete examples to study.
+1 on this answer, i don't think i could've said it better myself.
Okay, I'll check it out. Thanks!
Thanks. I was looking into the courses as well as the exam. I don't think I could do it by myself without the help of some training prior to it.
This is what I figured. People are going to want to see examples of work. But real world work and certification can't be a bad thing, I suppose.
I don't know if it's fuzzy match, but only a minimum of characters to identify the file/class name is required. E.g. typing "zsxt" can match Zend/Service/XmlRpc/Transport. php . But it can be really any characters as long as they are contained of course and are in the right order. There are more nuances to it, best they are experienced by testing. 
If you're wondering why the downvotes, it's probably because this is pretty common knowledge among PHP developers. Maybe not for novices, but most developers know this.
Btw you forgot the vimplugin :) I never thought it could really be used in production based on my experience with vi modes in Firefox and Eclipse. It's not prefect but one can get used to it. 
Just being "fast" is rarely what people want. There are bunch of requirements that are more important than just computer cycles, and that's the reason why there are TONs of databases out there. Start here: http://en.wikipedia.org/wiki/ACID Also how will you read and represent the stored records later? Do you need super fast (indexed/cached) selects? Too many factors.
uhm yeah, that was sarcasm. his question was rather unspecific. that.. uhh.. yeah. 
I so saw through that sarcasm in your post! /s
I purchased the recorded training. Or rather, my job did. The recorded training has good and bad points. I thought recorded training was a bit hokey at first but I've gotten certs that cost $5000 and they do it too, so I guess its pretty standard. I was expecting some physical books or something. That aside, the recorded training did have some good points in it. It covered a good majority of the language and how some extensions worked. A big part of it was understanding how to take the ZCE test since its a bit of an unconventional test topic. For example, some answers had to be typed, it wasn't all multiple choice, so the recorded training went over how to narrow down your answers and the proper way to answer questions. Edit: Spelling.
your question has nothing to do with the MVC pattern at all, but with routing/rewrites regardless what framework you use, think like "url parameters" like a lot of people mentioned here already if you need good SEO url you can just put a good rewrite in your webservers config or an .htaccess file.
I can't tell if it's a joke. I kind of want to write the worlds worse framework now. 
You seem confusing REST with MVC. Most MVC frameworks account for REST with a "routing" mechanism. Oftentimes though what is offered out of the box simply isn't enough for your needs.
Anytime someone criticizes PHP I just think how I haven't had to be in an office more than a couple weeks in the past 6 years, and PHP allowed me to do that. The language words for creating database driven web apps, and works well. 
Congrats! 
Are we allowed so see the application? :)
prefer to develop again fake dummy data over real dataset, unbelievable. 
Mostly I'm going to agree with what most other people have said. This isn't about MVC, this is about rest. What you should be thinking about is "What is my stuff?" or more specifically, what are my resources. In this case, everything you're talking about is a book. http://localhost/books/ The action and id are then additional resources or "end points" for that resource. http://localhost/books/1277 is the book with the id of 1277 Doing a post request to /books/ should start a new book. Doing a put request to /books/1277 should update that book. Basically what you want is the most common kind of request - get. And you want it on books. http://localhost/books. But you want to be more specific, and that's fine. What you don't want to do is start adding on bits of path, because that will stop the pattern having any meaning. What you want to do is add query string parameters. That's what these are for. http://localhost/books/?genre=sci-fi You've still got the get request for the books resource, but you're providing a little bit more information. You only want the stuff for that one genre. &gt; localhost/genre/editor/author/book-title You want to avoid things like this. You don't need to know all of that to find a book. It can be tempting to make things hierarchical, as it seems logical. But don't.
A lot of arguments against PHP are hugely outdated. Modern PHP can be used by good developers to rapidly build high quality software solutions. People criticising it are usually criticising either bad programmers, making out of date arguments, or criticising facets of the language that are intrinsic to its nature (like PHP is crap because it's not strongly typed). Or, in some cases they're making valid criticisms of some of the genuine warts of the language.
From my experience, most people who criticize it just haven't learned about the changes in the language in the last half decade. 
Congratulations. I've done tons of things in PHP that work just fine where others have said not to do so. Some people have valid criticisms and others are set in their old ways. For example I've created some scripts to do system management for myself and people were like "Oh, don't do those in PHP, it's icky. Use Perl." Okay, sure. I think people in general should not be so biased. It's amazing how people will write off an entire language for no reason or extremely outdated reasons. Give me a good reason NOT to make or do something in PHP with hard facts, not just "because it sucks." 
Honestly the OP could post it to Github, Bitbucket or something. TIA! :)
How did you manage the whole no office bit? I've just started learning PHP (since I'm sick of my office job), and I'm really curious!
Land some big clients and try to develop SaaS. Word of mouth also words wonders, and most importantly don't waste time with clients that won't pay. That is where the largest chunk of my time went into early on. Learn to spot red flags with clients. 
&gt; "Oh, don't do those in PHP, it's icky. Use Perl." I'm always confused when people say that. I've seen just as much if not more horrible code wrote in Perl than I have PHP. I use to code web apps in Perl and you couldn't pay me to go back and do it again. 
Gratz OP, now when they talk shit you can say it's the programmer not the language that makes a code base bad. If they still want to argue you can say "Yeah, who was the only one that didn't get own in CTF?".
Don't expect big clients straight away, build a portfolio of smaller sites for family and friends, and showcase it, word of mouths spreads extremely fast if you do a good job.
Also build your own projects out that you keep wanting to put off. Seriously, I had a lot of emails from my old bandcampdownload.com site. I miss that site :-(
So am I. I think they are just old fashioned or not knowledgeable most of the time. If you can get the job done in what you know, and it works properly, then what does it matter? I've written various non-web based things with PHP that actually do the job and get it done, so what's the big deal? It's nice to see some other people out there making bigger things with it as well - like m0n0wall, and how most of the system scripts including the entire boot time configuration is written entirely in PHP. However, I can admit that it would probably have been much faster to write it in something else, but it still gets the job done. It's not a system that needs lightning fast boot times. Likewise, I hope never to become an old curmudgeon who ends up saying to others "should have done it in PHP" for no reason other than it being what I know and am comfortable with. People just need to be more open minded in general and that lack of an open mind combined with PHP's history has really hurt it being taken seriously in my opinion. :(
no need for the closing ?&gt; php assumes it automatically when end of file is encountered. This will save you from lots of trouble with stray spaces and newlines ending up in your html output
Online is the worst place to find clients. You're competing with twelve zillion people from Romania who will work for less than you can survive on. Network, hit up your friends and former colleagues, go to web-related events in your city, etc. Person-to-person contact will get you the best gigs.
Yes, there is some stupid design in PHP that seems like leftovers from a time where the language was never intended to be as big as it is, such as why do some function names have underscores between words and some are just in one word, and why does strtr have the subject string as the first argument, while str_replace has it as the last? But these things are easy to get used to, and you can just make your own wrapper functions to get around it if it bothers you. They're not really a problem for anyone with more than a couple of weeks experience with the language. The only real "problem" with PHP is that it's very easy to write shitty code in it. You don't want an inexperienced PHP dev creating your important system that handles user personal data. But this doesn't mean you can't write good code, it just means it's easy not to. Once again experience removes this as a problem.
PHP: get shit done. just be careful though. 
Sorry, but I don't really accept this. Having to look up basic functions to see if they have the argument order the same is dumb. Having woefully inconsistent naming conventions (is_null/isset/empty or strtolower/nl2br) isn't actually OK. I'd be more forgiving of this sort of thing if it was a legacy issue that was being resolved. But it's not. PHP 5.4 added hex2bin(). For what it's worth I've been using the language for something like 10 years. I still struggle with some of the shit you say takes "a couple of weeks". This sort of shit could be fixed by having a convention and transitioning towards it, aliasing incorrect formats of the function, to later deprecate. But no. If we give a shit about the language we shouldn't be dismissing valid criticism. We should be shouting it from the rooftops. But in any case, this is actually not what I was talking about. I was talking more about the fact that PHP remains a routinely non-object-oriented language. PHP 5.5 added maybe two **dozen** new functions to the global scope. About the same as most minor updates. I have no idea how many there are now, but thousands. Genuine improvements to the language are routinely rejected, such as scalar type hinting. PHP has some serious flaws as a serious language.
Just because the language PHP sucks doesn't mean you can't write nice code in it. A good programmer can make good software with the most horrible languages.
Yeah we get it PHP sucks. The naming of the functions is usually the first argument people resort to when hating on it. And you know, you can't argue with it, it does fucking suck. But it doesn't mean you can't write proper software with it. For some stuff alternative libraries are available that take away a lot of the crap. Other times you just need to put up with it. Here is just one example of well written code can make a difference. **the bad** $var = someFunction(); if (isset($var)) { doFoo(); } **the good** $objResponse = executeRequest(); // or w/e if (null !== $objResponse) { doBar(); } I know it's just a goony little example and that there are tons of situations where it doesn't work this way. But having a nice convention will allow you to write very nice code. //One of the biggest issues I have with PHP is that arrays are maps but don't provide proper error handling $responseData = executeSomeRequestThatReturnsAMap(); if ($responseData['code'] === '404') // ERROR array key doesn't exist or something { } If you take time to write nice code on the other hand try { $objResponseData = $objRequest-&gt;execute(); if (IHttpResponse::CODE_404 === $objResponseData-&gt;getValue('code')) { } } catch (EKeyNotFound) { } or $objResponseData = $objRequest-&gt;execute(); if ($objResponseData-&gt;containsKey('code')) { $strKey = ... } I mean I'm just trying to show how a nice code style (eventhough you might not like mine) can actually result in very nice PHP code. You don't have to use the outdated cancerous shit everywhere. 
The only reason I stick to ST is multi line typing. Once you get used to it you can't go without it anymore.
yes, i work with ajax, i don't get why i should use javascript if: - my app doesn't have any task that must require javascript to be solved - my app doesn't have advanced control panels, graphs related with stats etc., there's not much to enhance on the front end - why the hell should i add an extra layer of 400kb for something that html/php can do properly - i prefer to write all my ajax calls in vanilla javascript and i'm a performance maniac :) - i'm not a fan of heavy js apps, i believe javascript is a feature and website should work without it aswell, on my private laptop i browse with js disabled by default
thanks, actually after this post on reddit i have much clear idea how to continue :)
&gt; But it doesn't mean you can't write proper software with it. To paraphrase a very high quality rant against PHP, "you can build a house with a rock, but what carpenter in his right mind wouldn't just get a hammer?"
I don't agree with that metaphor. Most arguments against PHP are dumb things that go wrong when you use features that you shouldn't be using in the first place. Yeah it's bad that those features actually exist. But it still doesn't mean that you can't make nice software with it. Your metaphor implies that using PHP is bad because it's harder to build websites, or because it would take more time. But everyone that has ever used PHP knows that's not the case.
Most of the people that criticize PHP have never used a lot of php themselves... To be fair people that criticize PHP are like blinded fanboys. They will argue that python, ruby or java is better. "PHP is shit, scales badly, bad performance, etc". But in fact, its the person that build his application that is responsible for those aspects. Maybe its easier in php to create a bad application ?... Also, where I live, most of the schools are learning Java to their students, and keep telling them that there is only java that is worth it...
Php developers are too busy working to take the time to bitch back. 
At this point people composing about how awful php is have never actually used it and are just regurgitating pop wisdom.
i am going to take a swing a say you don't have [rewrites](http://httpd.apache.org/docs/current/mod/mod_rewrite.html) enabled.
mod_rewrite is enabled on my Webspace.
I've been developing web apps with PHP for a long time and yah, there is a lot to criticize. There's some stuff that (after coding with different languages you discover that are NOT the norm) I find extremely annoying, in particular: * -&gt; I hate the '-&gt;' so many keystrokes for something you use a lot * Not being able to guess order of function names or the order of params. After 9+ years i still have to check the docs for function names * Error handling, error messages &amp; debugging. * Verbosity, you end up writing A LOT * Composer still has a way to go * It got pretty stuck for some time and it's been improving lately (but recently lately) * It lacks a cohesive community, you have a bazillion devs &amp; communities, everyone doing things differently These are the reasons why lately I've been working with other languages but going from these to "do not use it" is a huge leap. PHP is also awesome, super stable, mostly expectable, works everywhere and with everything, pretty fast and easy on system resources. It really works and it's up to the developers to not do a piece of shit (which you can do with whatever you choose).
I use PHP on a daily basis and get paid to do so. It is much harder and much more annoying to build websites with PHP than in Python or Ruby. PHP is certainly not as bad as it was a few years ago, but boy it is clunky. I much prefer languages that were designed by someone who acutally knew what he was doing. 
You need to use your .htaccess to point all paths to an index.php file. Then use a routing engine to pass back view files that are required for that given path. For example: &lt;IfModule mod_rewrite.c&gt; Options -MultiViews RewriteEngine On RewriteCond %{REQUEST_FILENAME} !-f RewriteRule ^ index.php [L] &lt;/IfModule&gt; Will point all urls to index.php.
In `redirect_request()`, couldn't you turn that mess of elseifs into a switch and avoid allocating another variable (`$count`)? I'm thinking something like this: switch(count($components)) { case 0: $controller = 'home'; $action = 'index'; break; case 1: $controller = $components[0]; $action = 'index'; break; case 2: $controller = $components[0]; $action = $components[1]; break; case 3: $controller = $components[0]; $action = $components[1]; $id = $components[2]; break; default: header('HTTP/1.0 404 Not Found'); exit; } 
That's good to know. I just figured cutting down on variables and elseifs might improve the speed (by a tiny margin) and the readability (by a lot, imo). A unit test would be able to tell you which is better.
Nah, there are plenty of people who like it and use it (like me), who still don't like how awful some parts of PHP are. I mean, go look at some of the stuff in /r/lolphp. Makes me glad I've never used the ++ operator on a string.
I really hope that in PHP 6.0 we could break all the things needing breaking to make the language more consistent.
Ah, so adding it to the constructor isn't totally bad. With the DIC method, would that mean each class that has dependencies would only need to add the DIC to its constructor, and then go through the DIC to get its "real" dependencies? Thanks for the video. He explained it pretty simply, and the visual aid helped as well.
cutting variables decreases memory allocation for the script (which is important) however if/elseif/else is faster than switch [phpbench](http://www.phpbench.com/). We are talking about microseconds obviously, but since we are looking at concurrency with multiple instances, it might serve better to decrease the scripts memory allocation.
ok, so i redirect everything to index.php and there i parse the url and get the right content. do i get you right?
The hatred mostly stems from the fact that PHP has no clear direction or leadership. This has meant that all number of horrible language and API design decisions have been made and got in, which simply don't happen on quite the same scale in other languages because of better leadership and code review practises. PHP's love of backwards-compatibility also means a lot of terrible things have to be left in... we took way too long to remove register_globals and magic quotes, for example.
Best response I've ever heard. Will be using this, thank you!!!
It's not bad to pass a dependency to the constructor. In fact, some people consider a container (or "service locator") to be an anti-pattern. I don't think it is. But unfortunately neither technique is perfect. There's a lot written about this online. Martin Fowler has good stuff to say about it.
Well, in any case of DI, you're injecting the dependencies through the constructor. So that's what you want to do in the first place. And if you inject the DIC into the object, you're not using DI, but Service Location. [Which is **not** the same](http://blog.ircmaxell.com/2012/08/object-scoping-triste-against-service.html). Adding each dependency to the constructor **is** the preferred way of getting dependencies into the class (DI). All other steps like containers or setters or whatever are just there to try to make your life easier, but are not necessary.
Well, `&amp;&amp;` and `and` are not identical, and neither are `||` and `or`.
What would you expect from this code? $test = 0 or die(); Because that's precisely what we have here; if you think about it in those terms it makes more sense (though I believe `or die()` is an anti-pattern of its own).
&gt; the fact that a typo can create a new field makes me shudder How do you mean? (I've never used this project so I'm fully in the dark here)
That is correct.
Oh my, that sounds like juggling chainsaws.. thanks for the info.
Actually, while I do agree that PHP is non-deserving of a lot of the hate it receives, it's interesting to note that one of the operators of PHP's "official" IRC channel (##php) has a notorious dislike for PHP. I guess more accurately it could be characterized as a notorious dislike for PHP being used in the wrong situations, but the definition of "wrong situations" is sticky.. +1 for the database driven web apps and ease of programming, though.
Bitching is not a problem. Plenty of PHP developers bitch about the problems with the language. Problem is when people start saying stuff like "They had no preference what it was, as long as it's not PHP". Its not a perfect language but it WORKS. Some people get too blinded by its faults to acknowledge its advantages. 
None of the bad things about PHP are show stoppers. 
Because PHP is not a rock, its just an imperfect hammer.
Eh, I'm not sure the last is really a bad thing. There is never a single right way to do something. When "everybody" does things differently, the best few options will get noticed, without wondering if the single "right" way is really right.
&gt; ... it turns out extracting Aura.Dispatcher was the key to reducing the Aura.Web package contents. With Aura.Dispatcher, any object can be a controller, since it can dispatch to any method on any object (as well as dispatching to closures). In turn, there is no more need for the Aura.Web package to provide a base controller with interfaces for various implementations. Instead, you can dispatch to any object you like, with the dependencies you prefer, as your controller. That controller object can be implemented at the framework level, or in a separate package or bundle. &gt; &gt; As a result, this means that web-specific request and response objects can be in their own package independent of any particular controller implementation. The Aura.Web v2 package contains only those request and response objects. &gt; &gt; ... &gt; &gt; Whereas the v1 package included controllers, renderers, and other functionality, the Aura.Web v2 package provides only Request and Response objects. These objects are independent of any particular controller system, and independent of any specific HTTP delivery mechanism, which means they can be used in any new or existing codebase without introducing other dependencies.
Actually "how to write a simple webserver in php".
Yes exactly, one of the deifferences is precedance. All I want is the same option for xor
I have no expectations from that code. I (like you) would never use, and have never used it. I always assumed those `or die()` statements in the php.net examples were meant to simplify the examples, but were not actually meant to be used.
So then you would also write code like this? $test = (2 + 2); ?
Since you're not trying to use Magento or OpenCart, Prestashop is an option, as is using WordPress. You can use the WooCommerce plugin or WP eCommerce if you go that route. This article takes a look at using WordPress for eCommerce. http://blog.nexcess.net/2013/04/23/using-wordpress-as-an-ecommerce-platform/ Hope you find it to be a valuable resource.
My first suggestion is to adopt a more [standard coding style](http://www.php-fig.org/psr/psr-2/). Right now, your code is very dense and hard to read. My second suggestion is to make the router more flexible. The way your router works, the URL must always be `/controller/action/id`. No exceptions. What if, for example I want a URL like `/r/PHP/comments/1qdid5/custom_url_router_and_front_controller_critique/`. Your router would reject this URL as `404 Not Found` just for exceeding three path segments. Instead, the router should let us have full control over our URLs. For example: if ($uri === '/home') { return array( 'controller' =&gt; 'home', 'action' =&gt; 'index', ); } elseif (preg_match('#/r/([^/]+)/comments/([^/]+)/([^/]+)#', $uri, $matches)) { return array( 'controller' =&gt; 'comments', 'action' =&gt; 'show', 'params' =&gt; array( 'subreddit' =&gt; $matches[1], 'id' =&gt; $matches[2], 'slug' =&gt; $matches[3], ), ); } Then if the user really wants, they can configure their own generic URLs. } elseif (preg_match('#/([^/]+)/([^/]+)/([^/]+)#', $uri, $matches)) { return array( 'controller' =&gt; $matches[1], 'action' =&gt; $matches[2], 'params' =&gt; array( 'id' =&gt; $matches[3], ), ); } Also, the router shouldn't assume to know the organization of the larger application. It shouldn't assume to know where controllers live or how they're invoked. The router should simply return a set of data indicating it found a match and the parameters associated with that match. Let the larger application decide what to do with that information. While you're at it, change the router to accept the URI as an argument rather than pulling directly from `$_SERVER['REQUEST_URI']`. The larger application can still pass in `$_SERVER['REQUEST_URI']` if it chooses, but we might also want to pass in an arbitrary URI for testing and automation. Also, don't use user input such as the URL for anything sensitive like filesystem operations. What if, for example, I were to put something funny in the URL, like `..` for the controller? I could probably get creative with this and cause some damage. Next up, your controller render method always spits out the same header and same footer. But what if I need to vary the header depending on the page? What if I need to change the title? The meta description? What if I need to include different styles and scripts? This too is way too inflexible. Instead, just include the template you need. That template can include common code in whatever manner it wants.
#1. Test and Behavior driven design is awesome and Behat is perfectly acceptable tool for it. The only thing I'd advise is don't get fixated on "Tests First". There are time when you have to write some code to understand what you're going to test. Especially starting out with TDD. #2. The first question I'd ask myself is what is the difference between the two? The biggest separating factor is going to be your "decorator". One will be building JSON objects and the other will be building full web pages. But don't couple your App controller to your API controller. Instead, inject a repository into both and give it extremely simple methods for retrieving the pertinent data. Perhaps try making a pure REST Application with something like Ember and skip the "App" controllers all together. #3. I would personally keep them together, especially starting out. No real advantage to separating them initially. 
Hmm, Ember seems really cool. I've heard of it before, looked at it, saw .js and quickly dismissed it as "a frontender tool". However, looking at the examples, it seems to me that, even though "it's javascript", it's a bit of both, it does frontend AND backend jobs. Thanks for your further insights!
Firstly, thank you for the feedback. Yes, there are a few constraints with this router and controller; these are intended to keep that implementation size small and controlled. Also, there is no autoloading concept with this script; only files needed are loaded. Also, please keep in mind that this is a router *and* controller so this *is* the larger application. Yes the router could be made more flexible, we could add localization as well to the URL scheming if we wanted to as well. Currently the application this is intended for does not require such complicated url scheming, however when it does, that would certainly need to be revisited. I am very curious about your statement concerning a security concern with the URI and the file system access (this is part of the feedback I am looking for); In what way would you compromise the system security (if possible could you provide an example) Would you be referring to a previous directory (..) attack? If a controller doesn't exist, it returns a 404. For context, here is the layout; yes the page title can change. &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;&lt;?php echo $this-&gt;meta-&gt;title; ?&gt;&lt;/title&gt; &lt;meta http-equiv="content-type" content="text/html; charset=UTF-8"&gt; &lt;meta charset="utf-8"&gt; &lt;meta name="viewport" content="width=device-width, user-scalable=no"&gt; &lt;meta http-equiv="content-language" content="en"&gt; &lt;meta name="description" content="&lt;?php echo $this-&gt;meta-&gt;description; ?&gt;"&gt; &lt;meta name="keywords" content="&lt;?php echo $this-&gt;meta-&gt;keywords; ?&gt;"&gt; &lt;link rel="image_src" href="&lt;?php echo $this-&gt;meta-&gt;image; ?&gt;"/&gt; &lt;meta property="og:title" content="&lt;?php echo $this-&gt;meta-&gt;title; ?&gt;" /&gt; &lt;meta property="og:image" content="&lt;?php echo $this-&gt;meta-&gt;image; ?&gt;" /&gt; &lt;meta name="twitter:title" content="&lt;?php echo $this-&gt;meta-&gt;title; ?&gt;"&gt; &lt;meta name="twitter:image" content="&lt;?php echo $this-&gt;meta-&gt;image; ?&gt;"&gt; &lt;/head&gt; &lt;body&gt; You are correct, there is currently no mechanism for adding or removing scripts and styles from the template. This is intentional (for the time being as there is only 1 page in this application).
Thanks for posting. I found this a really interesting read. I've been moving in this direction for a couple of years and been struggling to explain it.
I'm in the same boat as you mate. Been really interested in this concept for a while and working toward that direction. ircmaxwell does a fine job in this post.
Here's a [nice, in-depth](http://ralphschindler.com/tag/dependency-injection) article about dependency injection in PHP from Ralph Schindler, one of the Zend Framework engineers. He talks about a couple of different approaches and the pros and cons of each. PHP is not a language built from the ground up with this kind of thing in mind (like Java for instance). As a result, there is some difference of opinion in the community, and it's best to consider a few different viewpoints before deciding what works best for you and your project.
I was talking about HHVM support, not PHP
I discovered also, we need to ignore the query string when routing so I have updated line 6 to `$components = array_values(array_filter($split, function ($value) { return !empty($value) &amp;&amp; strpos($value, '?') !== 0; }));`.
yes but I would define a standalone **TestRepositoryInterface** that doesn't extend anything. Only define methods you plan on making use of in your controllers or wherever. Try to hide doctrine behind your interface. Then your controllers/services aren't tied to doctrine
Oops, replied before I saw your edit. I was thinking that I should do a standalone too but I also would like to be able to mock EntityRepository's methods since my controller would use also those methods.
no problem :)
just heard of aura, looks pretty cool. Might give it a go when i start up something new.
I hear "viewstate" and have nightmares of ASP.NET webforms development.
Oh I know, I'm not advocating for them. This just happens to be an efficient way for me to store short lived information securely without the need for persisting the information on the server. :)
That sounds like a good idea as well. I wasn't sure if you were looking for something to make just to make, or something that was going to be of use to you.
Oh god, let's not do this. ASP.NET Webforms is the bane of my existence. 
Well, this is kind of a basic question lol. Lets say you had an array users, you could loop through them and call the given function on each one, using all the data associated with that user. On the other hand, since you can have arrays of mixed objects, polymorphism comes into play. So, technically you could use the same functions for different kinds of objects. It would make more sense in a more elaborate application. Sending an email is one thing, but running queries and pulling in data is a little different. One example would be if you needed information for a person, would you rather have a person object with all the info in it, or store like name, age, occupation in separate variables? Or with a DB object, would you rather setup a DB object with connection info once and use it 5 times or use separate data to call a static function every time? OOP is definitely a lot different in PHP than other languages that are continually running, but still important in the long run, especially for extensibility down the line.
Most MVC frameworks have similar tools like Yii's Gii. Some use command lines, and therefore I do like Gii -with it's simple user interface - a lot. What is it that you don't like about it?
Are you familiar with OOP in any language? Knowing that might give people a better context in which to answer you.
Yes, in Java
I see, so a class named User would mainly be used to access its variables and a few methods like editPassword() etc. ? What about the editpassword.php page? Should I have to create a new instance of class to simply use the editPassword() method?
The HTTP Response may contain an X-Powered-By header (however this can be disabled or overwritten).
I liked the post as well and am generally a fan of ircmaxwell's posts. I've been writing a lot of my OO code over the past year or two in a functional style, avoiding state, and it's worked well.
Silex is great if the applications are small; at it's base it only really provides routing &amp; DI (in the form of pimple) - everything else is opt-in. I've made several small applications with Silex, ZF2 Db &amp; Twig and it's a powerful combination with a fairly low learning curve. While the simple design is a great strength when working on smaller apps the lack of structure and ad-hoc nature of composing some of these pieces means that for medium sized apps upwards you usually benefit from something more structured. For larger applications i've recently been working with Symfony2, Doctrine &amp; Twig and although it's a beast to learn the ins-and-outs of the various components that you can leverage (and their interactions) the result is worth the time invested. A great example is the symfony2 forms &amp; validation components and their use with Doctrine; You can build a mapping of Form types (a class that represents a form element or group of form elements) to doctrine entity structures, this means that on form submission Symfony will return you a fully hydrated doctrine entity. Validation is defined on fields at the entity level; by defining a form that maps to entities you can validate the form implicitly and have twig automatically output validation errors next to the appropriate fields. If there is any more work to do post-submission you have form events (pre &amp; post submit etc) and once form has validated you can persist your entity structures in a single line - you just have to configure the appropriate cascade options in your doctrine configuration. The result of these abstractions is that a controller in a symfony application rarely exceeds 20 lines and is more usually 10 - each responsibility for processing a form submission is handled at the appropriate level and in an abstraction that is inherently reusable throughout your application.
What is the output of print_r and count($rec) 
I don't necessarily think it's the cause, but ... what is a "tb" tag? :)
Have you tried doing a var_dump in your for each? It will tell you the contents and also if you have null values. Also as mentioned, tb is not an html tag, I believe you are thinking of td
print_r($rec) gives me the array number plus the objects id,name,description etc. I believe it has the objects, but maybe is not setting it correctly?
ooh yeah my bad, its suppose to be &lt;td&gt;, but yeah it didn't change anything.
I try it, and yeah its returning me null objects, so I guess the error goes back to my findAll function, and yeah my bad, tb was suppose to be td.
* [Illuminate: Database](https://github.com/illuminate/database) * [Aura: SQL](http://auraphp.com/packages/Aura.Sql/1.3.0/)
I don't know if this is relevant or not but you are missing a closing bracket in your findAll function.
So $rec is an array of arrays or objects? If that's the case you're trying to echo something which can't be echoed. &lt;table class="table"&gt; &lt;?php foreach( $rec as $r ) { ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$r['name']?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php } ?&gt; or &lt;table class="table"&gt; &lt;?php foreach( $rec as $r ) { ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?=$r-&gt;name?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php } ?&gt; Also... do you have short tags enabled? &lt;?= won't work without short tags being on in php.ini.
I'm confused about a couple things. First is the statement: &gt; For example, what if before hand, we called $response-&gt;addHeader('Content-Type: application/jpg')? Now, our response is weird (its body is text, but its headers indicate application/jpg). And the solution: function addPoweredBy(Response $response) { return new Response( $response-&gt;getStatus(), array_merge(["X-Powered-By" =&gt; "Us"], $response-&gt;getHeaders()), $response-&gt;getBody() ); } However I don't see how this solution solves the problem. You are not prevented from passing a weird mix of values to the Response constructor. Such as setting the "Content-Type" header to "application/jpeg", and setting the body to plain text. The solution also takes the long way around to avoid writing setters, but ultimately you get the same exact same behavior. The following function: function addPoweredBy(Response $response) { return new Response( $response-&gt;getStatus(), array_merge(["X-Powered-By" =&gt; "Us"], $response-&gt;getHeaders()), $response-&gt;getBody() ); } And the following class: class Response { public function addPoweredBy() { $this-&gt;headers["X-Powered-By"] = "Us"; return $this; } } Do the exact same thing. Both add an additional header to the response without regard to status or body, and both leave the other response values (status and body) the same. In fact the `addPoweredBy()` function *is* a setter. You've just taken the setter out of the Response class, and put it somewhere else. There's another type of class which I think merits special attention, and that's validation classes. Classes which validate data and processes. In your example the Response class may handle the validation itself, or another entity may handle the validation, but at some point your system must validate the response values, which solves the "weird mix of values" problem, which is the only use case you've given for your approach. I guess I don't understand what problem your approach is solving. It sounds as if the approach creates a more complicated architecture (with a few maintainability issues thrown into the mix) while gaining nothing.
this. $rec is an array of Recipe objects so $r-&gt;name not $r['name']
but $r-&gt;name its giving me nothing :\, just blank space. Also I just notice something I have two php files. One is the view where its how the website is suppose to look, and the other one I'm just calling it test.php where I'm testing stuff, in test.php I have include_once( "recipeview.php" ); and in this page is where I'm getting the blank page, but if I swtich to recipeview.php I get an error " Invalid argument supplied for foreach() " could that be the actual error? I'm sorry I'm just kinda learning php and I like it, but is really confusing.
inside the loop put a &lt;? var_dump($r); ?&gt; and paste the result for one row note: if you dont put it inside the &lt;td&gt; youll have to view source to see the output
If you're just dealing with one user it may not be entirely clear why OO helps, but imagine you have a bunch of users (or whatever) and want to change things about them: $user = User::find($id); $user-&gt;setPassword('new'); $user-&gt;save(); $user2 = User::find($anotherId); $user2-&gt;name = "Frank"; $user2-&gt;save(); The idea is to model the real world with your objects. 
If $r-&gt;name is null then your database fetching is incorrect or there are no matching records, the loop itself is fine.
this is what I'm getting " object(Recipe)#3 (6) { ["id"]=&gt; NULL ["name"]=&gt; NULL ["description"]=&gt; NULL ["preptime"]=&gt; NULL ["totaltime"]=&gt; NULL ["rating"]=&gt; NULL } object(Recipe)#4 (6) { ["id"]=&gt; NULL ["name"]=&gt; NULL ["description"]=&gt; NULL ["preptime"]=&gt; NULL ["totaltime"]=&gt; NULL ["rating"]=&gt; NULL } object(Recipe)#5 (6) { ["id"]=&gt; NULL ["name"]=&gt; NULL ["description"]=&gt; NULL ["preptime"]=&gt; NULL ["totaltime"]=&gt; NULL ["rating"]=&gt; NULL } question why I'm getting object(Recipe)#4,5,6? isn't suppose to be like object(Recipe)#0,1,2?
Is your Recipe class' __construct() function setup to accept an array and populate it's public variables appropriately? If not, then change $rec = new Recipe( $row ); to just $rec = $row; Assuming that works, were switching from objects to an array, so go back to your original $r['name']
I did it, but again its just blank. I have another function, a Find function that looks one item at a time " function find($id, $dbh){ $stmt = $dbh-&gt;prepare("select * from ".Recipe::$tablename." where id = :id;"); $stmt-&gt;bindParam(":id",$id); $stmt-&gt;execute(); $row = $stmt-&gt;fetch(); $this-&gt;copyFromRow( $row ); } and this function works fine, I give it the id and it shows me the correct recipe.
Non-static methods are used to work with non-static properties. They're just a tool. Static properties get shared among all instances of the class. Change it in one you change it in all of them. So say you had a Color class with red, green, and blue properties. You don't want all your colors to have the same color. So you want the red, green, and blue properties to be non-static. $red = new Color(255, 0, 0); $blue = new Color(0, 0, 255); Now say you want your color class to have a method that returns the hex code for the color. Color::hex()....Hmm wait, something wrong here. If hex is static then how does it know which color you want the hex code for? It doesn't so you have no way of knowing. So, okay. $green = 100; Color::hex($green); Okay there we go, we'll just pass it in. Hmm wait, still wrong here. $green isn't a color, it's an int. So, better fix that. Now we have to write a type hint in our hex function to make sure we only get Colors passed in. public static function hex (Color $color) And now it works but we want to subclass Color now with AlphaColor which takes alpha also and returns an alpha hex code. $transblue = new AlphaColor(0, 0, 255, 100); Color::hex($transblue); Hmm wait this is an issue, does Color::hex know anything about alpha? We need AlphaColor::hex($transblue); Oh but wait what if we have a function that's handed a color but we don't know which kind of color? Do we? if (get_class($color) == "Color") Color::hex($color) else AlphaColor($color); And it gets more absurd as we go on as we could just do $color-&gt;hex(); But instance methods are just a tool. OOP is just a set of concepts and you can solve all the problems some other way. But if the language provides some high level syntax to solve a problem why not use it? But it might not matter much for you. You may never subclass your user class or do anything else that would cause a problem. After all there's buttloads of PHP code that only uses static methods and it works just fine. 
Use fetchAll() instead of fetch() to get all rows function findAll($dbh){ $stmt = $dbh-&gt;prepare("select * from " . Recipe::$tablename); $stmt-&gt;execute(); return $stmt-&gt;fetchAll(PDO::FETCH_ASSOC); }
omg that works, Thank you soo much. So what I found out was that I was passing an array through the for each loop, but the variables where empty, with fetchAll when I put var_dump($r) it was returning me the values of each object. Thank you soo much.
Also real world example I worked on a site recently that used a UserProvider class with methods like loadByUsername or loadByID that took the DB connection in the constructor as a dependency. This way you could hook it to the production DB or a test DB in the tests. Static methods wouldn't work so well here. $test = new UserProvider($testDB); $production = new UserProvider($productionDB); UserProvider::loadByUserName() &lt;&lt; What does this mean? Which DB are we loading the user from? Not that we ever used the two DBs at the same time, but PHP doesn't know the difference.
No problema. Good luck
does the cache needs to be session aware? Cause that would imply that the cache has a certain state and therefor can not be a waist able object. Cache should imho be stateless and be rebuildable by every instance (read vps) without being dependent on a other instance. That being said, depending on the budget and php version I would go with plain old APC, or indeed look at something like memcache or redis. Because you could setup the last two on a separate instance and share cached data. Sound contradiction airy but it is not if you treat cache stateless. For example product information is most likely to be the same for every user regardless of their state. User information is strictly bind to a single user. (and debatable if it should be cached in general) 
&gt; An external company are doing some work for us [..] We would like to check it's correct before spending the money on another security scan. \*TRRRINGG\* "Hi, this is StereotypicalAussie. I was wondering if you guys did get around to updating that old PHP version yet." 
Yep. Illuminate is also known as the ORM Eloquent and a query builder (since that's what you're looking for) called Fluent. It's what's used in Laravel framework, and is an excellent option. I'm less familiar with Aura.
If all you want is an SQL Query builder, Aura SQL is exactly what you want. It's great.
I think you miss typed something in your code example. Your first addPoweredBy function is identical to the original and does not call your response class addPoweredBy function. I think the point the OP is trying to make is that if there is a bug, then it is right there in the controller - the first bit of code you look at when tracing out the problem, rather than nested away in some default of an inherited class. I agree, this example is not very good. It is too simple. But from experience, I have had many instances of bugs that were tricky to track down due to this, and fixing them would have an impact on other parts of the program, making them hard to solve. Validation would happen in the value object, so they are validation classes. At least that is how I do it. I see them as stateless models, which are then passed to behavior classes associated with the model to perform tasks.
I am probably stupid but I don't see anything new here...
You should quit. 
[https://github.com/philsturgeon/nonblockingbro](https://github.com/philsturgeon/nonblockingbro)
I had to fire up Fiddler to monitor some AJAX calls, and noticed when I came back to it, that there was a tacking call being done every 20 seconds. Well I knew it wasn't my app I'm developing, and only other thing open in Firefox was a docs page at php.net, using their new layout. Closed that tab, they stopped. Browse back there, they start up again... A little overkill on data tracking don't you think?
hehehe - its a government organisation - so its just the way it is. And here's the kicker - we only got IE8 2 years ago... we've been using IE6 until 2011!!!!
It's actually a quite useful feature, which I believe was inherited from Perl. Allows you to do this, which is a frequent occurrence in older PHP code: mysql_connect(...) or die("Couldn't connect to MySQL");
So?
You're right I suppose, just want to double check it in all server environments etc too and really just wanted to test it, thought there must be a way!
You know what? We realised today after much *facepalm* that it's in Firebug or whatever addon you want to use.
That's great, thanks.
This is just an analytics software, equivalent to what google analytics would be doing. Nothing to see here.
made an additional update: the controller and home variables get initialized to 'home' and 'index' and we can remove the first if statement. Also, inline with MoTTs_ idea, removed the restriction on maximum of 3 url segments decreasing the code size further.
From what you're saying, sounds like it's not a certification on being able to write good PHP code, but a certification of knowing function descriptions off by heart?
That was my impression from the practice test, yes. That being said, I think it would be difficult to make a standardized test for being able to write good code. It's a terribly subjective thing so a scantron wouldn't be able to puzzle it out.
That video is great, and I was reading the Aura PHP DI docs a couple of days ago that explains how to use their implementation of a container, but what I'm still struggling with is where the code to initialise a DI container should go in an MVC application.
can you run vms without being fired? Theres those free VM images MS offers for testing .. :)
Why don't you use a portable firefox?
&gt; What about the editpassword.php page? Use a routing class for anything but the smallest of projects or learning excersies. I would highly recommend you pick up a framework as It would teach you a lot about organising code effectively.
Chivalry is not dead!
Flamebait much?
You should read blogs on your own time. =D
Just to clarify as that read funny: Illuminate is the name for the components used by Laravel, not specifically the Eloquent ORM or anything else.
That has absolutely nothing to do with this very specific conversation about the speed of making a shitload of multiple HTTP requests. This was not posturing, this was an analytical review and debunk of the shitty "benchmarks" people like to throw around.
Aww, I just want to know! I want to know what to look out for. I'm a web developer, but I'm self taught and I assume things like this escape my self-education. 
This is something the theme designer did and I never got around to disabling it, because neither I or anybody I know uses that shit. I'll take it out shortly. :)
At the end of the blog post Phil links to [phpsadness.com](http://phpsadness.com/), give that a read if you'd like to know where PHP has problems :) The assumption you're flamebaiting probably comes from the answer to your Q being in the blog post :p
If you actually read the whole article you would have your answer. In the very bottom there's a link to [why PHP gets so much critisizm.](http://phpsadness.com/)
Yep, another guy pointed that out also. I'm a dummy.
He mentions it a few times that it's nothing inherently new. He's applied some simple labels to common OO concepts. Those labels that map well to problems that exist in the PHP(web dev) problem space so that hopefully some newer PHP devs are able to "get it" a little faster. I enjoyed the read.
Thank you. I wasn't upset or angry, I just _really_ don't want to get lumped in with the trolls, or have anyone make any assumptions that aren't there. &gt; Oh goody, a framework versus language post. That was a reference to the fact that pretty much any title with X v Y in the title is bullshit, especially when they compare apples with oranges. :)
Just because a person is at work doesn't mean they're doing something on company time.
Can you provide me with a link to some example of how to do this? Thanks.
Step by step instructions: 1. Check if the request is a POST request. If yes, read on. If no, skip to #3. 2. Check if the posted token matches the token in the session. If they match, proceed with the action. If they don't, show an error message and let the user re-submit the form. 3. Generate a random token and put it in the session as well as in a hidden input field in the form. For each new request, repeat these steps.
PHP is a language used by people ranging in skills from newbies that have a hard time grasping what an array is, to the seasoned developer that's got a mountain of systems programming experience. Everybody has different needs, and some people are pushing PHP to be more like Python and Ruby, while others are afraid of added complexity and barriers.
Would the session ID not be a sufficient enough token to use?
&gt; i'm looking for new ideas The CodeIgniter Router is pretty popular, maybe check that out? http://ellislab.com/codeigniter%20/user-guide/general/routing.html https://github.com/EllisLab/CodeIgniter/blob/develop/system/core/Router.php
Can you install Chrome Frame?
There's no mistake in the code. Reddit just merged two code examples into one "block". I'm pointing out the `addPoweredBy()` function and the `Response::addPoweredBy()` method do exactly the same thing, so where is the benefit to read-only "value objects"? Why would I avoid adding setter methods to the `Request` class, when the `addPoweredBy()` function *is* a setter.
you are the ^^w3counter 1%
They don't do the same thing. One modifies state (and hence every pre-exsisting reference to said state gets modified), where the other creates new state that needs to be plumbed into the application. And no, `addPoweredBy()` is not a setter, as it doesn't modify existing state. It just creates new state that can be used or thrown away by the application. It's not a massive difference when you first look at it. But it is really significant, because it means nothing can modify state that you don't explicitly allow access to modify it (via a reference, or by replacing state with the return value of a function call). 
This is where parameterized arrays/iterators would be a good idea. Your loops and maps should not have to handle this type of inference.
I have no idea what you're talking about, or why you felt the need to reply to my comment with the glaring implication that I'm "dismissing the flaws in my tools." Please don't judge me based on my appearance and your personal preconceptions. I'm just pointing out that the parent's questions were loaded and vague.
Could you give me a short code example?
His (admittedly flamebait) post asked about the problems in the language. You responded by placing the blame on new programmers and "different needs".
I'm not blaming anybody, and I don't think his question was flamebait. He's just confused and he's asking a question that has no real answer.
And here I refer back to my previous post about dismissing the flaws in your tools.
Thanks for that pointless comment. Maybe next time you can open your own sub-reddit where only you have access and post there? Or send PMs to yourself?
The only downside I see is that it only works for arrays, not all iterators (which are getting more and more common).
I would argue arrays and iterators also need to be unified under a generalized type hint since they often exhibit the same behavior. Extending the Traversable interface to the Array object would fix this nicely.
I pretty much universally use Laravel now, so the DAL in that. Which I think is just PDO. 
I pretty much reached the same conclusion. But doesn't the article expect the reader to have a knowledge of FP concepts..a bit too much to ask from newer php devs..I think...
&gt; flexibility, test-ability and explicitness of Functional Programming, Not an expert in FP by any stretch of Imagination. But here are some of my doubts.. Isn't the power or what makes FP different from imperative programming, the fact that it forces the programmer think in different terms, I mean via operation on lists, concepts of lazy evaluation and pattern matching, resulting in a much concise and clear solution, which in turn eliminates many source of errors present in imperative programming. I mean, isn't the immutable nature of stuff in FP is only a part of forcing one to think in different terms. And what FP achieves in the end, is the result of a different thought process, rather than due to the immutable nature it of its variables themselves. So what I am saying is that, I cannot see this duplicating 'flexibility, test-ability and explicitness of Functional Programming'. 
So I just took the test today and passed :D It was a lot less about the "gotchas" than the practice papers made out, there were probably about 5 questions out of the 70 that had missing ampersands in a foreach or that kind of thing going on. I honestly didn't think I did that well, and melted in my seat in relief when the notice came up saying I'd passed. Time will tell if it's been worth it job wise though, but I definitely learnt a lot in studying for the test that I'd have probably never otherwise come across.
How does it compare to savant?
The font is very hard to read on that website. The contrast is a bit too low.
Pretty typical for a site developed in 2013. It is either analytics or an interface for upcoming interactive features. I would place a high percentage guess on the former, although it's worth considering that there could be other uses.
I work with government organisations pretty much on a daily basis. This is pretty much a universal condition.
While it's been quite a few years since I've used Savant, Plates is basically a more modern take on it, adding features people love from compiled languages like Twig. Interesting you should mention Savant, that's actually the first template system I used way back in 2004. Plates is available via Composer. It's PSR-2 compliant. It offers inheritance, layouts, folders, nesting, sections and more. It's also super easy to add your own extensions, so you can customize it for your own app. Probably the closest thing I can compare it to is the [Aura View](https://github.com/auraphp/Aura.View) package (which also looks great actually). The one thing they've tried to solve in their library is auto-escaping. I've left that out of Plates as I feel trying to do that in PHP causes more problems than it solves.
That's the designer in me. Thanks for the feedback.
Yeah no problem :) Library looks promising though.
It wasn't meant to explain the benefits. It was meant to introduce a new concept. This is something that a doctoral thesis could be written on. Hardly something that a couple-page blog post can do justice. Instead, I wanted to introduce the concept. And then in later posts we can refine it and really tear it apart. But for now I just wanted to introduce it, and then refine and distill it later. This post represents the point of the funnel. Before, it was buildup. Now that it's in the air, we can start really talking about it and digging through the possibilities. It also represents about 2 years of thought on my part. I've been working on the ideas for a while now, and finally have them at a point where I can speak about them comfortably. But that doesn't mean that they are concrete. It's still being molded and getting tweaked.
This is pretty similar to the views/template system that's part of [fuelphp](http://fuelphp.com/docs/general/views.html), with some added twig/blade-esque inheritance. Seems like it could be useful. Thanks for sharing. 
As the author of Savant and Aura.View (and Zend_View ;-) I think Plates looks very interesting. After using auto-escaping for a while, I agree with your take on it; Aura.View v2 will remove that behavior.
Completely unnecessary, in my opinion. How about "PHP - The native PHP template system." The only argument that template libraries have on native PHP is output escaping, but that's not a very strong argument.
Thanks korve! PS. I've added a little more contrast, although I'm still not sold on how the code looks yet. I'll try solve that later.
That means _a lot_ coming from you Paul. Thanks for leaving a comment.
Bro, this is just PHP. ;)
Can't help much with out seeing any code, at lease some snippets that you think are the problems.
I've been using unirest.io. Highly recommended.
I have no idea where the script fails. It'll be working fine one minute, and then the next it won't pull down the data required. And when it doesn't, it won't pull it down for a good two minutes, which leads me to believe that something is crashing or something similar. I have Debug.Logs on the app side, and where it 'breaks' is when the app tries to connect to the php script. What causes it? No idea yet. I've tried on PC, Mac, Android, on 3G/4G/Wifi, and the same issue occurs.
Here's the code. &lt;?php //CONNECTIONS ========================================================= $hostname = &lt;correct&gt; $username = &lt;correct&gt; $dbname = &lt;correct&gt; $password = &lt;correct&gt; $link = mysql_connect($hostname, $username, $password) OR DIE ("Unable to connect to database! Please try again later."); mysql_select_db($dbname); //============================================================================= $house = $_POST["myHouse"]; $score = $_POST["myScore"]; $questionSelected = $_POST["questionSelected"]; $question = $_POST["question"]; $correctAnswer = $_POST["correctAnswer"]; $answerA = $_POST["answerA"]; $answerB = $_POST["answerB"]; $answerC = $_POST["answerC"]; $answerD = $_POST["answerD"]; $funct = $_POST["funct"]; $secure = $_POST["secureString"]; if ($funct == 'addScore' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "SELECT * FROM HarryPotterQuizHouses WHERE HouseName = '$house'"; $result = mysql_query($query); if ($result) { while($row = mysql_fetch_array($result)) $scores = $row["Scores"]; $finalScore = $score + $scores; echo 'The final score is: ' . $finalScore; $query2 = "UPDATE HarryPotterQuizHouses SET Scores = '$finalScore' WHERE HouseName = '$house'"; $result2 = mysql_query($query2); } } if ($funct == 'getScores' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "SELECT * FROM HarryPotterQuizHouses"; $result = mysql_query($query); if ($result) { while($row = mysql_fetch_array($result)) { $scores = $row["Scores"] . "#"; echo $scores; } } } if ($funct == 'uploadNewQuestion' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "INSERT INTO HarryPotterUploadedQuestions (question, correctAnswer, answerA, answerB, answerC, answerD, upvotes, downvotes) VALUES ('$question', '$correctAnswer', '$answerA', '$answerB', '$answerC', '$answerD', 0, 0)"; $result = mysql_query($query); } if ($funct == 'upvote' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "SELECT * FROM HarryPotterUploadedQuestions WHERE question = '$question'"; $result = mysql_query($query); if ($result) { while($row = mysql_fetch_array($result)) $votes = $row["upvotes"]; $newVote = $votes + 1; $query2 = "UPDATE HarryPotterUploadedQuestions SET upvotes = '$newVote' WHERE question = '$question'"; $result2 = mysql_query($query2); } } if ($funct == 'downvote' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "SELECT * FROM HarryPotterUploadedQuestions WHERE question = '$question'"; $result = mysql_query($query); if ($result) { while($row = mysql_fetch_array($result)) $votes = $row["downvotes"]; $newVote = $votes + 1; $query2 = "UPDATE HarryPotterUploadedQuestions SET downvotes = '$newVote' WHERE question = '$question'"; $result2 = mysql_query($query2); } } if ($funct == 'getQuestionForVote' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "SELECT * FROM HarryPotterUploadedQuestions WHERE number = '$questionSelected'"; $result = mysql_query($query); if ($result) { while($row = mysql_fetch_row($result)) { echo $row[1] . "#"; echo $row[3] . "#"; echo $row[4] . "#"; echo $row[5] . "#"; echo $row[6] . "#"; } } } if ($funct == 'getNumberOfQuestionsFromVote' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $result = mysql_query("SELECT * FROM HarryPotterUploadedQuestions"); $num_rows = mysql_num_rows($result); echo $num_rows; } if ($funct == 'getNumberOfQuestionsAnswerVote' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $result = mysql_query("SELECT * FROM HarryPotterFinalQuestions"); $num_rows = mysql_num_rows($result); echo $num_rows; } if ($funct == 'getQuestionForAnswer' &amp;&amp; $secure == 'ca8c4b71c9774183d8f9866e265073bb94725ea1') { $query = "SELECT * FROM HarryPotterFinalQuestions WHERE number = '$questionSelected'"; $result = mysql_query($query); if ($result) { while($row = mysql_fetch_row($result)) { echo $row[1] . "#"; echo $row[2] . "#"; echo $row[3] . "#"; echo $row[4] . "#"; echo $row[5] . "#"; echo $row[6] . "#"; echo $row[7] . "#"; } } } mysql_close($link); ?&gt;
Well, if we're going to comment about the website design rather than the library itself, then I guess I should point out that bottom of the logo is being cropped due to scaling issues. You really shouldn't be scaling down graphics. I understand that you're doing it to accommodate retina displays, but different platforms use different scaling algorithms, and the result won't be as good as you hoped it would be. Instead, I suggest you do it via CSS by polling the pixel density using the @media rule. Github used to have the same problem, but I raised the issue with them and produced an infographic to help demonstrate the issue and how to best solve it, after which they changed it to a CSS-based solution. They have since moved on to use a font-based solution. Unfortunately, that suffers from issues as well, such as different font rendering and scaling depending on the platform. 
I wasn't talking about enabling logs in MySQL, I was saying he should implement logging in his code, at both ends.
There's a whole slew of bad practices in this code, mind you. All from using deprecated extensions to being riddled with SQL injection vectors. 
Like I had said, the code works fine, there are no errors. Where it always freezes up is after line 63 of the Unity code. I will get a Debug saying that it is 'GETTING ANSWER' (which to me just means the script was called), but it never gets a response from the server. It just hangs and doesn't download anything else.
How can I make this more efficient and better? Like I said, I'm a newbie still learning and while it WORKS, I knew it wasn't efficient. Any pointers and what not would be great!
Yes, the MySQL db is hosted by GoDaddy. Are they known for MySQL issues?
[PHP: The Right Way](http://www.phptherightway.com) is a good place to start looking. *Definitely* don't use mysql_connect(), mysql_query(), etc. Those are deprecated and insecure. You should use the mysqli functions, or better yet the PDO extension. PDO abstracts the connection specifics which is a good step towards maintainable code, and also prepares the queries to prevent [SQL injection attacks](http://bobby-tables.com/).
Thanks again to everyone and anyone who views and responds to this thread. Getting feedback really does go a long way. 
There are a ton of things you could do. To name a few: * Move over to PDO * Use parametrized queries * Move your database stuff to its own layer, allowing you to change the underlying functionality without disrupting the rest of your code. * Separate your concerns Also, I'm looking at your queries and your tables are not that great. You're going to have concurrency issues with that stuff. For instance, the up/downvote thing isn't going to be reliable at all. What you're doing there is not atomic.
I think looking into [PDO] (http://php.net/manual/en/book.pdo.php) would be a great start. Don't use mysql_ functions anymore. 
I'll keep this in mind. What other services are out there that are better than GoDaddy? 
Is this likely the reason that the connection/database drop and crash? If it is then, I'll likely just scrap the php script and start new using PDO.
There's Aura.Sql v1 at https://github.com/auraphp/Aura.Sql/tree/develop which bundles connections, query objects, schema discovery, and a data mapper implementation. And then there's the v2 packages: - Aura.Sql v2 https://github.com/auraphp/Aura.Sql/tree/develop-2 - Aura.Sql_Query https://github.com/auraphp/Aura.Sql_Query - Aura.Sql_Schema https://github.com/auraphp/Aura.Sql_Schema The reasons? (1) I'm the lead on the project, so clearly I'm biased. (2) The packages are completely decoupled and have no external dependencies. Download the one, and that's all you get, and it works as-is. (3) The v2 packages are even *more* decoupled. The new SQL package is an extension of PDO, so anything you have type hinted to PDO will continue to work. The query objects work with any database abstraction layer that uses placeholders. The schema discovery package works with any PDO connection (not just the Aura.Sql ExtendedPdo object.) For more, be sure to check out http://auraphp.com -- hope this helps.
A question for you. Is there a 'go-to' complier for PHP/PDO? I've used Eclipse for Android, MonoDevelop for Unity, I did a Google search for PHP compliers, but I'd like to know which one is **THE** PHP complier.
This is a bit like being told most of a joke, and then being told I'll get to hear the punchline later. It's just my opinion this isn't your best writing, and at this point there's nothing to discuss. I'll keep an eye on for future posts.
Thanks for that. Note that the v2 query builder (in progress) is even more decoupled, in that it does not require any particular kind of database connection: https://github.com/auraphp/Aura.Sql_Query (Full disclosure: I am the project lead.)
[Serious] I typically use the standard templating systems provided by various frameworks (not Twig or Blade, just the typical "view") and have no problems getting the job done. Sell me on using this instead of what ships with the framework.
I know Netflix uses it, because there was that issue not too long ago where Netflix was down for a bit cause of AWS going down temporarily. Honestly, I think I am going to bail on GoDaddy, I've heard people complain about it for too long and I'm sure that AWS is going to be more than I need anyway, just as long as the price is right.
There's always Aura.Sql. Version 1 at https://github.com/auraphp/Aura.Sql/tree/develop bundles connections, query objects, schema discovery, and a data mapper implementation. The v2 packages, in progress, are: - Aura.Sql v2 https://github.com/auraphp/Aura.Sql/tree/develop-2 - Aura.Sql_Query https://github.com/auraphp/Aura.Sql_Query - Aura.Sql_Schema https://github.com/auraphp/Aura.Sql_Schema (Note that I'm the lead on the project, so I have my biases.) Regardless, the packages are completely decoupled, independent from each other, and have no external dependencies. Download the one, and that's all you get, and it works as-is. The v2 packages especially are decoupled from each other. The new SQL package is an extension of PDO, so anything you have type hinted to PDO will continue to work. The query objects work with any database abstraction layer that uses placeholders. The schema discovery package works with any PDO connection (not just the Aura.Sql ExtendedPdo object.) For more, be sure to check out http://auraphp.com -- hope this helps.
Hmm...so you don't know for sure that your app is making a successful connection, right? The debug statement 'GETTING ANSWER' happens before creating the WWW object, so you may be hanging there, or at 'yield return w;' When I POST funct and secureString to http://algebrainiac.us/Apps/Quizzes/harrypotter.php the response does not contain any data (although it does return a 200 OK status) -- perhaps there are problems parsing w.text if it's empty? Are you getting 'GOT ANSWER' in your debug or an error message in your label component? Are you entering the if statement starting at line 69 at all? Just throwing out some suggestions -- not too familiar with Unity.
When the app works fine, the Debug console shows: "GETTING ANSWER" "GOT ANSWER" &lt;whatever is in w.text&gt; When it hangs: "GETTING ANSWER" And it'll just stop there. 
&gt; I'm not suggesting that native PHP templates are better than compiled templates (like Twig) Oh... *puts the pitchfork down*
Thanks for the enlightenment! I think I'm going to move away from GoDaddy, AWS seems to be where the party is at. :D
(Is this sarcasm or a serious question? I don't know if PHP even USES a complier.)
Fair question, and honestly, I'm not sure I'd go through the effort to replace a framework's default implementation with Plates. I find they are typically pretty tightly integrated anyway. I created Plates primarily for when I'm not using a framework. It certainly could be used with a framework, and would no doubt add some cool features, but that wasn't really my goal for it. At this point I guess I'll see how it gets used...not really sure what to expect. Thanks for asking a valid question. Not sure this was the greatest sales pitch. ;)
Do you mean a compiler?
Oh, yes. Sorry, typo.
Very interesting. I'll look forward to the beta. 
Again, not too familiar with Unity, so forgive my ignorance...do you think the issue is in yield? If you try to poll w.isDone instead of yielding, does it work? Or does that make no sense?
Well, I'm only giving you this critique, because when I buy the books you eventually end up writing, I would like them to be sharp! ;) I'll give you some examples of what I mean. I feel a bit like an English teacher writing notes in the margin of an essay with a red marker. Section "Functional OOP". &gt; Well, for a trivial example like this, there isn't much to gain. But let's take a more significant example. Let's talk about generating a HTTP response. You end the section without explaining what was gained by the alternative approach. You set an expectation in your readers that was never met. Section "Make Response a Value-Object". &gt; Once you store it, it becomes global state again, and you lose the benefits you've already gained... You still haven't explained the benefits of your approach, so what had I gained, and what did I lose? --- It's fine if you plan on explaining the benefits in future posts, but a good read should end each chapter with something thought provoking, or at least a good cliff hanger. You're target audience must be composed of experienced engineers if the concept is doctoral thesis worthy, but you used 2,460 words to explain a concept that could have been explained to experienced engineers with two paragraphs. So you could probably cut 75% of the fat out of this post, and get on with explaining the pros and cons of stateless design, which is what I thought the post was leading up to. I guess I feel your thoughts weren't clearly organized, and the post was a bit chaotic, and it made too many assumptions about the reader's knowledge of functional programming, and the benefits of stateless design. The post led me to only one question, "Why is this approach beneficial?" You could have at least said, "This approach leads to *far* fewer bugs than other approaches, and in my next blog post I'll explain why."
This can be done including the relevant CSS in the e-mail. When you send your mail, you need to ensure you are sending HTML. Some example code (completely untested!) that shows the inclusion of CSS where the font is set to 10px Tahoma: $to = 'blah@blah.blah'; $subject = 'Test HTML E-Mail'; $message = ' &lt;html&gt; &lt;head&gt; &lt;title&gt;Blah Blah&lt;/title&gt; &lt;style type="text/css"&gt; *, html, body { font-size:10px; font-family:Tahoma; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; This is a test &lt;/body&gt; &lt;/html&gt;'; $headers = 'MIME-Version: 1.0' . "\r\n"; $headers .= 'Content-type: text/html; charset=iso-8859-1' . "\r\n"; $headers .= 'To: Person &lt;blah@blah.blah&gt;' . "\r\n"; $headers .= 'From: Me &lt;blah2@blah2.blah2&gt;' . "\r\n"; mail ($to, $subject, $message, $headers); That's all there is to it really. Ensure it's a HTML e-mail with the appropriate CSS included whenever required. As an aside, I would recommend using something other than the default PHP mailer. [PHPMailer](http://phpmailer.worxware.com/) and [Swift Mailer](http://swiftmailer.org/) are popular alternatives.
A problems with the PHP community (generally speaking) is that there is a lot of bad example code out there due to age and/or oblivious developers. There are lots of [tutorials](http://net.tutsplus.com/tutorials/php/why-you-should-be-using-phps-pdo-for-database-access/) out there on PDO - it works similarly to what you're doing now with the exception that you need to bind the parameters into your queries instead of concatenating them so it can prevent SQL injection. But really... don't *ever* use the mysql extension. It may also be beneficial to write around a framework like [Laravel](http://laravel.com/). You can learn a lot by working with well-written code.
There is already a templating engine in Node that has the same name as yours. http://flatironjs.org/#templating https://github.com/flatiron/plates
Just wanted to comment how beautiful the site is. Unexpected for a PHP library. The documentation is excellent too. Great job man.
makes sense, php is in fact a template language, stuff like smarty is just nonsense imho
What was the thought behind selecting that font, if I may ask? 
Oh you've got to be kidding me. I'm certain I did a Google search, and I checked Packagist, but I missed that. At least it's not another PHP library.
I'm sorry :(
This is exactly how I felt about this post.
I came across a few issues with the site, I've marked the page and highlighted the issue. http://platesphp.com/variables - To assign variables to your templates just add them as *paramaters* to your template object. http://platesphp.com/syntax - Only ever have one statement *in a each* PHP tag. - Other than *templates variables*, avoid variable assignment. ---- With that out of the way, your library looks useful. I may use it for a project I have coming up, I like that you've kept it simple instead of trying to get it to do everything. There are a few things I have thoughts on. -- I think you should add in a 'diagnostic mode' that tracks when/where/what the internal state changes to. Much like a stack trace, I should be able to output a trace of everything that happened to a specific variable in a template, all variables, template render order, and all of the above at the same time. The reason for this is quite simple. As of now, template variables are "global" in that they're shared throughout all of the rendered templates. Whether it's a layout, nested, child, what have you. This implies a possibility of collisions happening where a subtemplate changes a variable that affects it's parent because it uses said variable further down in the template (just as a simple example). I get that it shouldn't happen, but it can, and it will happen. The other reason is because it can be difficult to reason about a template order without going through each and every file. Since you're doing the setup where you can set the folder structure manually, there's also the possibility of not being able to find the templates easily. There's also the issue of conditional rendering of a template via if statements in parent templates. A diagnostic could easily tell you everything that was actually used to render a specific template. Much much easier to diagnose/trace a problem, and if you're just getting into the system, waaaaaay easier to get a feel for what's going on. With a diagnostic mode you can do things like have it output a "trace" of various things right before it renders, output it to a predefined variable that the dev can echo somewhere, the specifics of how/where it gets output aren't important, as long as you're giving developers the tools to be able drill down through the magic happening underneath. I've long been of the opinion that the best abstractions give you a mechanism for drilling down into them (and through them). An ORM that lets you define SQL directly is a good example. -- I would also consider enabling a "mode" that throws an exception as soon as a variable is assigned to twice. Something akin to the "fail fast" mantra during development. - I personally think you should enable an alternate syntax for variables. Some suggestions 1. $template-&gt;scoped("ns1")-&gt;title 2. $template-&gt;ns1-&gt;title 3. $template-&gt;set("ns1.ns2.name") = "bob" 1. $this-&gt;scoped("ns1")-&gt;title 2. $this-&gt;ns1-&gt;title 3. $this-&gt;get("ns1.ns2.name") I personally prefer 1 or 3 as I think 2 has too much magic. The advantage of this is that it's symmetric with the way you're doing the ExtensionInterface stuff, and allows people to scope their variables if they feel it necessary. If you do this I think you should recommend that they use the default "global", and fallback to the scoped stuff if/when they find a clear need for it. 
I dig it.
Wow, thanks for much for the very detailed feedback! This is great. First off, I've fixed those spelling and grammar mistakes. Spelling has never been my strong point. As for your stack trace idea, it's a good one, and your concerns are valid. I'll just have to think through how that could be done, bearing in mind possible performance losses.
I'd be interested in seeing said infographic :)
I just got back home, but thanks for the reply. Yeah, there was a lot of code out there and examples that I used to create the code that I posted. So, I'm glad that everyone on here is letting me know that this is incorrect and that there is a better way to do it. What is Laravel? I mean, I would like to learn PHP well enough to perhaps one day add it to my resume and have a job using PHP, MySQL, Unity, Java, C#, JS, or what not. 
Ah okay. I wasn't sure, but thank you for letting me know!
This exchange brought a tear to my geek eye.
You mean [Museo](http://www.myfonts.com/fonts/exljbris/museo/)? It's just a nice modern typeface, and since the entire website is pretty much type, I wanted a font that had some design aesthetic to it. I choose it's lighter weights (100 and 300) to reflect the library, which is actually extremely lightweight (all in less than 500 lines of code).
http://laravel.com/
Negative, as of PHP 5.4 the `&lt;?=` shorthand is [enabled by default](http://www.php.net/manual/en/ini.core.php#ini.short-open-tag). And yes, Savant definitely influenced Plates.
I thought Taylor came from an ASP background...could be wrong.
Why use short echo syntax but not short tags? I though short echo was the same as short tag syntax.
I think you're right, I've just been looking Laravel up recently and remember reading him talking about taking over some stuff inspired by Rails.
Ok, please do update. I'm curious now.
Huh, look at that! Well I'm glad to hear it... I've been avoiding it thinking it was deprecated. Add that to the list of things that I thought were going to be deprecated, but actually aren't (I'm looking at you iframes)
Very good job on the site. Regarding the project itself, can you extend sections from the included templates? Another thing in comparison with twig is that twig encourages to use objects itself, instead of using many different template variables. I can call a method or public variable without the risk of generating a fatal error in case the object method or member variable isn't available. This means I can reuse my templates in more places. I think it can also lead to cleaner code, both in templates and in where ever you are calling it from, as you don't have to assign many individual variables. Have you considered this in the design. 
Okay, so here's how I tested it: Debug.Log("SUPER 1"); WWW w = new WWW("http://algebrainiac.us/Apps/Quizzes/harrypotter.php?", form); Debug.Log("SUPER 2"); yield return w; Debug.Log("SUPER 3"); I got a SUPER 1, and SUPER 2, but then it broke.
Ditto.
I think that's `&lt;?` you're thinking of, which is definitely deprecated and never should have been used in the first place.
I've DIY'd something similar for a few of my projects. I did my property storage a little differently, using [`__set()`](http://prototype.php.net/manual/en/language.oop5.overloading.php) to store values in an associative array, then using [`extract()`](http://prototype.php.net/extract) to convert keys to locals when exposing them to the templates themselves. I found being able to use variable names directly in templates to be a little more concise and readable: when I'm writing template code, I don't care about the fact that values are coming from some object somewhere, I just want to use them. To each their own, though, and either way is, IMHO, infinitely better than tacking on a compiled template system.
Separately -- if you want to make it easy to distribute use composer or a phar.
I won't be using this. But I like you. You noted yourself that you made this for when not using a framework, and pretty much everything I do now is in Laravel, so I won't really be replacing Blade with this. But still, I think you've done a really nice job with it. If I was looking for a template engine on a bespoke app it would be this. You've made a lot of good choices with it. Composer, PSR, inheritance, etc. Nice job.
Look into class autoloaders... Read https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md for the standard, but I'm sure there are much better introductions. Composer is a good starting place to find the most common modern conventions in how to structure a non-trival PHP script. See http://getcomposer.org/ or Google for a Composer tutorial This, and many other topics are found at http://www.phptherightway.com/ You also want to ignore everything if you're just doing a trivial, tiny one page PHP script. Most resources assume you're creating a more complete site written entirely in PHP.
Very good answer. I'll only add this: - with Propel, your model is your database schema - with Doctrine, your model is your PHP classes, which allows to use all features of OOP (inheritance and all) even if they don't exist in a RDBMS
&gt; default ORM for Symfony 2 (and I believe it is) For symfony2 to my knowledge ther is no promotion for Doctrine, Propel or pure PDO. So it is left to the user.
First appearance, it looks awesome. Looking forward to do some testing.
I still managed to fap to that
I think you could have stopped after "As the author of Savant and Aura.View (and Zend_View". You win.
*dramatic string movement*
Challenge accepted!
I don't see the point of this. I've always looked at template engines as a means for front-end devs to make layouts with little to no PHP knowledge. This excludes those devs. So, if I had to split front and backend, most likely I'd allready be using a framework with it's own template engine or mvc pattern. Not using a framework, or building my own what benefit is &lt;?=$this-&gt;title?&gt; to &lt;?php echo $this-&gt;title; ?&gt; or without MVC pattern &lt;?php echo $title; ?&gt; 
The Standard Edition still ships with Doctrine included and configured, so one could think that it's still considered the default ORM that way.
It's probably done to get an idea of how long the user views the page. 
I think this could be the start of something useful
I completely agree with this. For almost all the apps I've made I go with the 'time since' method. It cuts out a huge step in process and like you said, it's correct to everyone.
As far as I know, propel hasn't officially released version 2 yet. Doctrine2 was the first to reach code-complete, so it became the go-to with symfony2. A lot of the online documentation for symfony2 was written in early stages of its release. At this point, doctrine2 has moreless become the standard within sf2. With that being said, symfony2 still declares itself as being agnostic to whatever you use, since it is a loosely coupled framework. I highly recommend generating a few simple db objects with the cmdline utility, then manually editing the foreign relationships, and finally using the crud generator within the cli utility. From here, you will have a usable application to get your hands dirty with some working code. I think you'll find that the nature in which you can retrieve and save data to your database is as simple as using setters and getters.
More accurately, how long someone has it loaded in a browser tab somewhere, not that they are viewing it. 
You didn't close the serious tag and now I can't use a joke answer.
&gt; The main difference, it appears, is that in Doctrine you use a Manager object to perform the database persistence whereas in Propel each entity/model object comes with code to persist itself to the database. Having worked with systems that do both, I definitely prefer the Doctrine approach. My objects are objects that just happen to be persisted. Sometimes. When I use the repository pattern, I might get something that isn't persisted, I might get something that is. As I'm developing, it doesn't really matter. When it comes to unit testing, the difference is night and day. There might be an easier way, but I always felt that it was a huge pain in the butt to work with mocks that extended an Active Record implementation. When using Doctrine, mocking is identical to mocking any other class, or you can hydrate it with fake data. I've recently built a pretty big project using Doctrine and I can't see any reason why you'd be shooting yourself in the foot using it. You can mix the built-in repositories with custom repositories and even drop down to PDO if you want to crunch some big data sets. 
Thanks. Actually, Aura.Router is one of the projects that i used as a base, but i will take a look again. I know the Aura Project since your presentation on Brazil on PHP Conference 2012. Another one i used is the Respect\Rest: https://github.com/Respect/Rest 
I need to point out that; Zend Framework and Doctrine are no less "third party" than ratchet. 
A few problems: - the whole PHP is designed for start, run, exit (on every request) - shared nothing - everything in PHP is synchronous (blocking), and "all" 3rd party libs/frameworks too The main problem should be solved somewhere else than in PHP (i.e. in Apache or Nginx). Nginx already supports proxying web sockets (to node or ratchet or whatever). I have been thinking this too. I don't particularly like these "my code is the web server" type of things like node.js too much. Currently the best that I have found is OpenResty with Lua, but that is currently missing concurrent read-write support on the same socket (it's coming soon, though). But realtime support is not the only thing PHP needs to stay relevant. I think PHP needs JIT too (facebook has been doing this). But in the meantime we live in a pologlot world. To develop future web apps, you usually need more than standard LAMP. You may also need NoSQL db's, and a lot's of client side Javascript. I think that OpenResty with LuaJIT (probably the best JIT there is for so called scripting languages) is almost a perfect solution. You can also utilize your Lua skills in Redis scripts.
Similarly, nodejs isn't "within" javascript 
Shameless. Have a down vote. 
I would highly recommend PDO, here is a good starters tutorial for connection and basic queries as well as introductions to prepared statements: http://prash.me/php-pdo-and-prepared-statements/
I was about to post the same question. I created an app in ZF2 and Propel and am porting it over to Symfony and Doctrine. So far I am not particularly sold on Doctrine, in particular its verbosity. It seems like I am writing a lot more code to do the same thing.
I only used Zend DB in ZF1 and was not overly fond of it. I have used Propel a couple of times and liked it. Now I am exploring Doctrine, which I am not yet sure how I feel about yet.
zend and doctrine is 3rd party too... also you need ajax for realtime applications also when using node...
&gt; That said, systems like (especially) React/Ratchet are highly comparable to Node in performance problem : you can implement the reactor pattern all you want if the io is not async it doesnt matter,it will block. php db drivers are not async,nodejs db drivers are.same for file apis , process apis , network apis ,etc ... php is not built for that. NodeJS si not perfect either on the rdbms side,but it's the easiest way to build modular realtime apps, and they are the future of webdevelopment. PHP will still be there for classic enterprise apps, php libs are mature.
PhPlates :)
While there isn't an "official" ORM for Symfony 2, your impression is correct that Doctrine tends to be the preferred ORM when working with Symfony for a number of reasons. 1. As folks have noted, since it uses a Data Mapper pattern your data models are just Plain Old PHP objects (they don't have to extend a base class like you do in Propel or most Active Record implementations). This has advantages for testing and has also meant I've used model classes I created for Doctrine in other non-Doctrine projects. 2. Support for Doctrine in 3rd party bundles tends to be better than support for Propel. This is anectodal but in my experience even when Propel options are provided (such as in the FOSUserBundle which allows obth Doctrine and Propel) examples/documentation are often focused on Doctrine. 3. Once again someone mentioned this but Propel 2 is not out yet (its still listed as unstable) so most propel implementations in Symfony 2 use Propel 1.6 which is an older package than Doctrine 2. One of the cons of Doctrine I would say is Complexity/Learning Curve: ActiveRecord is simpler than Data Mapper (at least in the case of Doctrine vs Propel). People also note that they feel it is slow but its not something that I have dealt with much and you could mitigate that with caching (Doctrine comes with caching features for queries, results, etc.). I can tell you as someone who is active in #symfony on irc and the mailing lists you are much more likely to find help/support on Doctrine questions than Propel and I have seen the response "I don't know I use Doctrine" many times to questions and I dont think I've ever seen "I don't know I use propel". Thats not to say one is better than the other but without a stable 2.0 version of Propel and with Doctrine having more community support I don't see a reason not to use it for Symfony 2 projects. 
&gt; If appropriate, make object properties public to avoid unnecessary methods as this uses less memory in execution: Please don't do this. Expose only as much of a public API as necessary, hide the rest. &gt; Use the language construct isset() before any operation: // Slower if (isset($foo) &amp;&amp; is_array($foo)) { return $bar; } // Faster if (isset($foo)) { if (is_array($foo)) { return $bar; } } This is bad times. Not only could you achieve the same with `empty()`, but this also breaks object calisthenics. Try to keep as few indentation levels as possible. Here you've introduced 2 instead of 1. &gt; An example XDebug ini configuration for OSX w/ brew: Use a VM. In conclusion * don't try to micro-optimize, you'll just make it worse, * always aim for readability over perceived optimizations, * think of the developers (and yourself) that will actually be using your code.
Since you use "header('HTTP/1.0 404 Not Found'); exit;" more than once, I would put that in a function. You could then easily add more functionality such as logging the bad request, all in one place.
&gt; Please don't do this. Expose only as much of a public API as necessary, hide the rest. And end up with symfony2 like performances... sure.
getters and setters are still 99% not needed in the most applications, there are better ways [not performance wise] (like laravel does it with mutators and their setters)
 // Slower if (isset($foo) &amp;&amp; is_array($foo)) { return $bar; } // Faster if (isset($foo)) { if (is_array($foo)) { return $bar; } } sorry but the second one is slower (more adresses &amp; more to parse), in the first one it breaks anyway if isset returns false
Posts like this tend to prove that micro-optimizations aren't worth the time. Take the construct `isset` example: // Slower if (isset($foo) &amp;&amp; is_array($foo)) { return $bar; } // Faster if (isset($foo)) { if (is_array($foo)) { return $bar; } } Let's test it out: http://3v4l.org/DndhE If you look at the results, in 5.5, it's MUCH faster (twice as fast) to do the "slower" method. In 5.4 and 5.3, it's the same (if not slower). So no, don't bother yourself with tiny micro-optimizations like this. Focus on writing correct code, and then test it for speed later.
At least you've narrowed it down to the offending line. Now to find an alternative way to implement the functionality.
You throw this number out, but provide no backup. Every major, professional project will use getters/setters. Using `__set()` introduces ambiguity and leads to a leaky API. Simply opening up public properties, without the use of `__set()` introduces brittleness into your class. See my other post regarding this. Laravel's magic methods are *not* the thing you should be pointing at the show how it's properly done.
What if you continue checking it until it's true? Something along the lines of while(!w.isDone); -- will run loop until w's payload has completed downloading...maybe add a little loading indicator for the user. This is obviously a blocking operation, whereas using yield is asynchronous. Like I mentioned in the above comment, you were able to narrow the issue down quite a bit from your original post, which is good. Maybe post this in a C# sub or forum? Hope you can figure it out soon. Update me with the results if you remember, please! 
You're confusing things. * I don't say these things because I read about them in a design pattern book. I speak of them because I have had the displeasure of working in projects that didn't have a single getter/setter and figuring out how everything works is a **nightmare**, * DB write/update isn't related to SF2. You may be thinking of Doctrine? Either way, Doctrine is one of the more performance ORMs available, it has been optimized, correctly, quite a bit, * There's a reason design patterns exist: *people use them* and they have been vetted. Your note about classes is ... confusing. Not using classes makes testing extremely difficult, and creates sloppy code within PHP. Other languages have a much easier time of not using classes, but working in a purely procedural codebase in PHP reminds me of Wordpress 100% of the time.
you dont need to open up hidden properties and I never stated this. Getters and setters are still 99% of the cases obsolete. as an example: why would be a name property protected? but a password property should ofc. only hide where needed.
I agree that micro-optimizations are not the golden standard for optimization. I'm not claiming they are. To be fair, comparing 5.5 to 5.4 or 5.3 also doesn't take into account the built-in opcode cache in 5.5. That piece was based on (possibly old) benchmarks ran at: http://phpbench.com/
But, but... Zend is _"The PHP Company"_!
Most of this is snakeoil while the rest should be common knowledge (APC, profiling, etc.).
http://philsturgeon.co.uk/blog/2013/11/benchmarking-codswallop-nodejs-v-php
It depends on what you mean by "long", but generally, having one large script that handles everything becomes a nightmare to maintain, at some point. If you're using OOP, then you could just give each class its own file. If you haven't, I'd spend some time researching design patterns.
Why a password property should be different than a name property? We are talking about code. Encapsulation is not about protect or hide information. Is about control, maintainability and simplicity.
Hi, welcome to the sub! Normally I'm huge on developers learning how to do things themselves, and then implementing their ideas. It's a great way to learn and to become better at their craft. However, as I mentioned in [this thread](http://www.reddit.com/r/PHP/comments/1petuy/order_form_for_small_business_should_i_learn_a/cd1kqpx) about someone not familiar with programming/PHP and wanting to implement an order form, you should stop what you're doing and hire a professional. A simple contact form? Sure, whip it up. Want to make a little comment script? Great idea! However, you're now dealing with people's private information, be it payment information or social security numbers. If either leaks out it could hurt your user financially. If you make mistakes in your code (you will) and your stuff gets hacked, you may also be liable for any damages caused to said user(s). I know I sure as hell wouldn't be happy to know someone leaked my social security number, name, address, phone number and date of birth! tl;dr: pay someone else to do it.
Isn't the if statement short-circuited, so if the first expression is false, it won't go any further? I fail to see where the optimization is in the article. 
I don't see any evidence to justify your assertion in the links that you referred to - that one seems to be plucked out of thin air?
 + 1116 % isSet() AND is_array() of a non set value Maybe I made a mistake and misread that line.