To be fair, the two bottom classes are part of a framework, and I'm in the process of refactoring my shit now using DI containers or tightly coupled classes
But it has a immutable date class, thats not really immutable at all. Maybe its just a facade? 
yes, but please, don't use the clusterfuck language that is javascript for this example. there are lot of things in it which does not make sense in other programming languages. a constant should not be mutated nor reassigned, it is not logical. it called constant for a reason. it's value is contast. if you modify the object in the example you wrote, you actually change it's value. therefore its not constant.
Maybe a better example would come from C++, where there is a difference between a constant pointer and a pointer to a constant. And you can also have a constant pointer to a constant. But the question OP asked still does not make sense, since there is still a difference between a value and a pointer pointing to it.
how to delete someone else's php extension
 class Amazing { public static $OBJECT = "Foo"; } echo Amazing::$OBJECT; // Foo Amazing::$OBJECT = "Bar"; echo Amazing::$OBJECT; // Bar ?
We all know it's a bad idea, but don't be a dick.
&gt; if you modify the object in the example you wrote, you actually change it's value. therefore its not constant. In the case of a value object, yes. If we're talking about in context of reference, or even identity, it's up for debate.
&gt; Barring web workers, javascript is also synchronous and single threaded Single threaded, sure, but it's asynchronous with many more things than just web workers. 
The value of the variable is constant, it can't be changed. If you assign an object to a variable, you just assign the reference, which IS constant. You can't reassign it. The object itself is still mutable.
Definition of constant (from Google): adjective -&gt; occurring continuously over a period of time. noun -&gt; a situation or state of affairs that does not change. Just based on the definition a mutable constant doesn't really make sense. Maybe if you can expand the concept and languages that it is used (that you have seen) this thread can be more educational.
Ruby has mutable constants; you can mutate the objects they refer to (assuming they're not frozen), and assign them to different objects at run time (with a warning; avoidable if you remove the constant first).
Amp is fully compatible with ReactPHP with the [adapter](https://github.com/amphp/react-adapter).
Last time I checked runkit didn't support PHP 7.
It's not. Just listing alternatives. And listing why you may or may not want to use it.
If you have your .travis.yml file in the root, why not move your circle.yml file as well? 
&gt;In JavaScript, const means "can't be reassigned", not "can't be mutated". "Can't be reassigned" and "can't be mutated" are synonymous. Mutation is reassignment. What I suppose you're getting at is that in Javascript, Java, etc. a const can hold a reference to an object, and the variables in that object can be mutated. But that's not the same thing as mutating the value of the original variable itself.
Good idea. Do you use that way? How would you get such information in the CompilerPass? 
How do you approach this topic in your application? What Symfony version and test framework do you use?
Thanks. A lot of posts in the thread had good info, but yours had a nice concrete example that made sense.
I don't attempt to test private services. I use unit tests as well as the WebTestCase for integration tests. Never felt the urge to actually test Symfony services directly.
will that prevents you to use it?
_Motherfucker, that's called a ~~job~~ variable._
It's what u/nikic said.
A convenient snippet for puppet users: package { 'php-runkit': ensure =&gt; absent } ~&gt; { exec: 'echo "someone is fired" | mail devs@example.com', refreshonly =&gt; true } 
There is another similiar library: [https://github.com/paragonie/easydb](https://github.com/paragonie/easydb)
Or use a keyed array for a single static property, and then it can be iterated on. If that's too much typing, __callStatic() can be abused to make access easy.
I see. So this post is not for you at all?
&gt; without an external (albeit possibly another PHP script) influence. No, you don't need any external scripts/processes/threads in your php application to get "non-sequential" execution. Yes, with stream_select this "external script" is your OS, which allows you to do other staff while waiting for data. And yes, for things like filesystem you will need some API which supports async I/O. But... with stream_select you could write your own event loop which will use callbacks, so you could have non-sequencial execution. But `exec` will just be synchronised sys call. So no concurrency happened (at least for your php script). &gt; I think we're both trying to say async has been possible for ages in PHP Yes. But I also wanted to point the difference between generators (and async/await) and async php. What generators do, is that they allow you to write non-sequential code in sequential manner. For example, first async php framework which used generators was amphp. ReactPHP was available event before generators was introduced in php (at least it didnt' rely on it).
As someone who has tried for a while now to get a Remote Docker server set up with XDebug, could you please give me this documentation you used to set it up? Thanks in Advance.
Thank you /u/pmjones for providing this library. Your books and your documentation usually is top-notch and very well written, and I grew a lot as a developer reading and using things you created. Could you try to briefly describe how the different Atlas libraries relate to other approaches like Doctrine (DBAL-ORM), [Pomm](http://www.pomm-project.org/) and Ting? I think I'd enjoy reading such a blog post.
Why not just use python or nodejs? Sometimes PHP just isn't the right tool for the job.
We recently tested running PHP on Lambda. We haven‚Äôt tested cold starts yet. Our test only contains requests to 'warm' Lambdas We measured the next results with Cloudwatch: |Script|Memory|Average API Gateway latency|Average Lambda execution time (duration)|Minimum API Gateway latency|Minimum Lambda execution time (duration)| |-|-|-|-|-|-| |`echo "Hi from PHP!"`|512MB|19.9ms|8ms|11ms|1.26ms| |`echo "Hi from PHP!"`|128MB|23.3ms|11.7ms|12ms|1.19ms| |`phpinfo()`|512MB|40ms|16.5ms|22ms|5.84ms| |`phpinfo()`|128MB|65.6ms|48ms|20ms|5.96ms| We took a totally different approach than how PHP is usually ran on Lambda. Although these results are great, this was just a quick test to check if our approach would perform better than the usual PHP on Lambda approach so I am sure we can improve the performance even further. I also highly doubt that running `phpinfo()` was a good way to check performance. Are the Cloudwatch metrics you show in the image minimum or average metrics and with how much memory did you run the Lambas there?
&gt; Are the Cloudwatch metrics you show in the image minimum or average metrics and with how much memory did you run the Lambas there? These are the average execution time. And I don't remember exactly but it was with memory &gt; 1024M. &gt; We took a totally different approach than how PHP is usually ran on Lambda. How do you run PHP in your case? Is that some sort of a daemon?
Thank you I‚Äôm not sure if I'm allowed to share, but if I‚Äôm allowed to, I‚Äôll let you know and maybe make a blog post. It might take a week though...
What? An HTML *comment* with contact info to the original developer and a published date?? And they were upset about that? I cannot even begin to understand the mentality on that. What did they think you'd do by leaving a comment that innocent?
Have you tried variables?
How does the php opcode cache work with lambda? I'm not sure but if you run php-code always in clean env, there is no cache from previous exec..
I'm not 100% as I gave away the extension to someone else to maintain quite some time ago, but I *believe* he updated it through 7.1 at least.
No they aren‚Äôt. Assignment binds an identifier to a value. Mutation is an operation on the value itself. 
In computer science, \*re\*asssignment is considered mutation. It's variable mutation, whereas an "operation on the value itself" is structure mutation. See e.g. [Mutation: Structures and Variables](http://cs.brown.edu/courses/cs173/2012/book/mut-struct-vs-var.html) \- section 8.2 deals with variable mutation. Conceptually, they're both exactly the same kind of operation at a certain level. For example, to mutate an object involves mutating one of its instance variables. The only difference between mutating an instance variable vs. a local or global variable is where the variable's value is stored. Otherwise, it's essentially the same kind of operation.
Correct, you have to assume there will be no caching. In practice the containers running your function do get re\-used if you call your function multiple times quickly, but this is an architectural anomaly for Lambda and you shouldn't design with that assumption.
I actually got Laravel running on Lambda a couple of years ago: [https://cwhite.me/hosting\-a\-laravel\-application\-on\-aws\-lambda/](https://cwhite.me/hosting-a-laravel-application-on-aws-lambda/) While it worked, I don't recommend it. Neither Lambda nor Laravel are designed for this.
&gt;PL theory makes a distinction between rebinding and mutation. There's a distinction in the sense that a binding refers to an association between two things, such as variable and value, and mutation refers to changing some previously existing association. "Rebinding" just means "mutating a binding". It involves changing \(mutating\) the association between variable and value. So again, once you get into *re*binding or *re*assignment, you are dealing with mutation, by definition. &gt;You‚Äôll notice that in languages like OCaml, there are no variables in the traditional sense, only identifiers and expressions. I'm not sure why you think that's relevant \- in OCaml, all variables are immutable. Explicit mutable boxes \- ref cells \- are used to support an operation equivalent to variable mutation. But since OCaml variables are immutable, there's no reassignment or mutation of them. The equivalence I'm pointing out is evident in the fact that if one is absent, so is the other. Reassignment of variables is mutation, and lack of reassignment of variables means no mutation of variables. &gt;bindings can be shadowed at will. Shadowing is not rebinding or mutation. In shadowing, a new variable environment is introduced in a new scope. Variable bindings in the new environment override bindings with the same name in enclosing environments. But the original bindings still exist, and have not been mutated or rebound. To reiterate, in any language which supports changing the value of a previously set variable, such reassignment *is* mutation.
I think this can't be PHP native performance. A wrapper?
This looks pretty good, and the syntax isn't bad. Of course it would be faster if implemented into the core, but other than that I'm having trouble seeing downsides to using this from userland.
Autocompletion though: phostorm doensnt know its a collection of a type, meaning you still have to typehint in eg. Loops
I could never see myself using a transpiler for PHP. Gross. It's just a crappy experience in development to have to run a separate service to watch for file changes and stuff. It also just complicates version control too. What if someone forgets to transpile before committing? Should you even commit the transpiled output? The list goes on. I'm just gonna hold out until the proper RFCs pass.
I like this. Personally I would use something like this as a basis for designing Value Objects, which I'd design on an application\-by\-application basis. I'd certainly like to see this sort of functionality added to PHP's standard library, or at least made available as a PHP extension.
The JS community managed to do it though. With good enough tooling there‚Äôs no large impact on development. Unfortuntely different ecosystems tend to ignore eachothers successes, and have difficulties learning from eachother. Of course, I also prefer core support. But what if a popular transpiled version is what‚Äôs needed to push for writing this in C? Wouldn‚Äôt that be worth it?
Value objects are a good use case! There are more things you can do with this, in a no-OO way. Rust is a good example of a language without classes but that doesn‚Äôt seem like a miss because of these strong typed data structures
Rust can be plenty of OO through Traits.
Can I write a function which takes a parameter hinted to a collection of some class?
Not unless you make a dedicated class, like IntergerList or PostList
haha every function that starts with `runkit_` is pure gold.
I have the prefect solution for this **NEVER USE EMPTY**
I misunderstood, sorry.
It sure can :) Though people often link OO and classes one-to-one. That is, of course, incorrect.
I have tried similar approaches in the past and even written my own userland library for structs. In the end I dropped everything because PHP and the whole ecosystem is not yet ready for it. Since PHP 7.2, however, DTOs and Value Objects with strong typing already worked natively and well, even in conjunction with PHPStrom, phpstan, nullabes etc.
I feel your pain. I've tried to make Pre very easy to use, as a result. It still needs a lot of work though, in terms of source maps and IDE support.
&gt;Stickied postModerator of r/PHP Agree docker image would be easy and good for easy peasy installation.
It's easy. Try this one: https://i.imgur.com/wXHI6WN.jpg
Awesome!
Could probably write a phpstorm plugin to address that
Why would PHP not be the right tool to write HTTP applications? Here the only thing missing is a native integration by AWS. The whole "lambda" architecture is actually closer to PHP than all other languages because that's how PHP has been working since the beginning: every HTTP request is handled by a separate process that is scratched at the end of the request. So PHP is perfect for that. There's just the support from AWS that's missing, and I believe it's just a matter of time before they fix that.
Out of the box it is not supported because PHP is running as CLI. However I am planning to work on that, opcache can be used in CLI processes.
&gt; I don't mind that LSP can be broken, it's goal is to show that these features in PHP core would be nice. Don't quote out of context :p
I'm on PHP 7.2 and I've been looking for a way to set Aggron2 as the 'PASSWORD_DEFAULT' constant. Is this possible? Good article btw, password_needs_rehash() is often overlooked so I'm happy you included it.
`PASSWORD_DEFAULT` is defined in [sources](https://github.com/php/php-src/blob/a7fe2570d3ce6915d4ea85c62c0f880ddc225ba7/ext/standard/php_password.h#L32), so only way you can change it is custom build.
Read "Clean Architecture" by Robert martin, or watch some conference talks about the subject, you can apply a lot of it to your Laravel projects, eye opener for me.
Thanks, when will Aggron2 become the next default? 
What is interesting, I've seen this link in Today's highlights in my mobile Chrome
I think it would be a better idea to just deprecate the whole function.
OH god: runkit_constant_redefine ( 'FALSE' , true ); Then watch the world burn...
FYI, x is MB of server RAM, y is ms of HTTP response time
Alright thanks. Wanted to be as secure as possible. :)
My first thought as well...
You don't have any phpstorm plugin writing experience by any chance? üòÅ
&gt; I already hate the JS workflow as-is JS-workflow is the definition of how-not-to.
Plot twist: `true` is already redefined to `false`, so this changes nothing 
If we deprecate and remove everything related to dynamically working with variables, the potential performance improvements could be big.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [php/php-src/.../**php_stdbool.h** (master ‚Üí 95c9d9d)](https://github.com/php/php-src/blob/95c9d9d2d7f696e5e9cd05692195b4e4071e0d40/win32/php_stdbool.h) ---- 
Some, yes, haha
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
The short answer is that the ReactPHP platform is not synchronous
It would be ok with me if we could hook into the autoloader and to transpilation there. With everything cached, it would not require a build step even for production. Maybe even possible with a steam wrapper? Like `include('transpile:///path/to/file.php')` It would certainly make debugging harder and lack IDE support though...
The RFC process for password_* requires a separate vote for a change in the default algorithm, and isn't something we can pre-schedule,
&gt; describe how the different Atlas libraries relate to other approaches This is more difficult than it might seem; having said that, it might be fun to explore the history of ORMs (and their lineage!) as I did with [the history of PHP frameworks and library collections](https://github.com/pmjones/php-history).
And windows can understand the forward slash in paths now.
Funny that Windows can understand both forward and back slashes while linux can't
Can we also kill `extract` please? I need to work with a code, which uses this, it's hell to know whether this variable exist or not. Someone used that to pass around 30 parameters to another function. My IDE slows down around that crap :D
Hey Brent, thanks for this, it looks very nice! A couple of weeks ago I did this: https://github.com/pwm/tc It's only for collections and very bare bone, but if I understand 0xRAINBOW correctly, maybe this could help? I'm happy to chat more about this topic as I'm also very interested in getting some more type safety in php.
Read the article. 
Unix filenames are a minefield in general: https://www.dwheeler.com/essays/fixing-unix-linux-filenames.html
Didn't read the article huh?
&gt; as a long time windows user and php developer, i can only say: do not use DIRECTORY_SEPERATOR! it has no real benefit but really can break things.
&gt; What if someone forgets to transpile before committing? Should you even commit the transpiled output? Your CI should handle transpiration for you. Only source code should be committed.
Uh... don‚Äôt use a constant that is designed as a file system helper when building urls. Maintain better control over your code path.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [symfony/filesystem/.../**Filesystem.php#L457** (master ‚Üí 7033756)](https://github.com/symfony/filesystem/blob/70337563d9da65b39fdedd90bc5b221015c26803/Filesystem.php#L457) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dzk2l78.)
This is a good exercise, and I believe many of us are fed up with implementing stuff like collections of certain types and the like. Indeed it should be built into the language.
yeah this guy doesn't seem to understand what the constant is for
y tho
You spell "SEPERATOR" with an E. The correct speeling is with an additional A, SEPARATOR. Please correct the article.
Wait, is this a setting or something? I'm on Windows 10, and the cli does not recognize the forward slash, either directly through CMD, or even through php exec\(\). \&gt; vendor/bin/phpunit 'vendor' is not recognized as an internal or external command, operable program or batch file. It works only with backslashes.
I feel like this advice only accurately applies to URLs not local file paths. To some people using DIRECTORY_SEPERATOR only on local files is obvious, to others it may not have been. I just feel like it'd be more accurate if they specified their article is about URLs. I would have preferred if the author made this more clear, but maybe that wasn't their goal.
It wouldn't solve the LSP issue, as you can use `TypedCollection` as a typehint somewhere, and pass in an `IntegerList`. This would break LSP, as the contract states `TypeCollection`, a user could pass in `StringList` and the code would break. The fact is that you cannot type hint a collection of &lt;something&gt; without special syntax, or when using traits. My approach was not to use traits, because you'd need to specify a separate class for every collection of types you'd want. It would kind of defeat the benefit of generics. But to be clear: this can only be solved if the syntax was added to the core. Nevertheless, I would love to talk more about this :) feel free to talk to me on [twitter](https://twitter.com/brendt_gd) or via e-mail: brent@stitcher.io
No it‚Äôs just weird 
Or just don't run PHP on windows. Use VMs.
I did, that way is more clean.
Aahh yeah great! Those are also amazing features üòÅ
Are you using a templating language like Twig or Blade? In that case, you're already using a transpiler. I think those serve as proof of concept that it's totally possible to transpile without the crappy experience.
Not sure when it does and doesn't work but `cd vendor/bin` would work
I look forward to the next posts "don't put your private ssh key in URLs" and "don't use shell_exec for running DB queries".
Yeah that's a good point. If it's done on request and cached it wouldn't be too bad. I was thinking more of the JS style where you run a file watching service. The other thing is it would need to be as config-less as possible because it's always a pain to mess with.
just wait until the day you accidentally paste a thousand line of codes in your shell instead of pasting them in your editor :p
&gt; I see very little benefit in using PHP inside AWS lambda. It's a vendor lock-in and offer little benefit to PHP. Many providers offer serverless hosting, not just AWS. You can also run that on your own servers with Kubernetes now. Regarding the benefits you can read them in details [here](http://mnapoli.fr/serverless-php/#advantages). The main things: - very high scalability since you are not limited by your server (no need to scale up or down) - pay for what you use instead of paying for your unused server's CPU time PHP's request isolation is great, but serverless is not limited to that. I think it's a mistake to think that because PHP works like that it has nothing to gain from serverless architectures.
The JS community managed to do it because browsers only run one language: Javascript. They _had_ to transpile if they wanted features the browsers didn't support. If you want to use a language with more or different features, just use another language. With that said, I slightly agree. I think Hack did have a nonzero impact on getting some of the features PHP 7 has locked in. So I'm of two minds about it.
Forward slashes have always worked for me in Windows 7...
Hm, yep, the more I think about it, it's pretty much impossible to solve in a nice way within php. My lib actually has the same unsoundness java has, which is what you say, namely that you can have covariant function parameters. Hack does it well: https://hhvm.com/blog/9215/covariance-contravariance-and-super-type-constraints but I bet that was a ton of work :)
I can‚Äôt say I disagree, but I‚Äôd like to see a better designed replacement. Short object notation in modern JS is pretty handy, and compact is the closest equivalent. 
thx, fixed
i haven't used it for that, just ran into such traps buy usinh 3rd party libs.
this does not make sense, there are some cases where it makes sense to have backslashes in your path
i also would not always use it. &gt; it is the better choice nearly every time maybe we can say nearly is 90% :D
but it works fine ;)
your comment is funny but it reminds me to the situation as i told a guy he should generate a key (i sent him a manual with screenshots) and told him to send me the public key. guess what he send me...
I'd argue that one shouldn't be doing anything with undefined variables \(except making sure that yes, they are indeed undefined\), so by certain perspectives, these applications are broken already. This would just alert the developers \(and users, if the error reporting settings are set to show warnings in production\). The developers of these \(already\) broken applications would have a choice: Keep their apps broken and not upgrade to 7.3, ignore the warnings and suppress them in production, or fix their junk. And, since yes, it would point out to developers of broken applications that their app is, indeed, broken \(i.e., if approved this RFC is not backwards compatible\), the PHP RFC process requires a 2/3rds vote, instead of a simple majority.
Agreed. Just look at the process for developing front end workflows these days. Node, webpack, and JS in general is a living, breathing example of what happens when you tack on band-aid solutions to problems that should be solved natively. Not to say there aren't some incredible things going on in the JS community because there are, but the development experience is an unorganized mess. I would hate to see the same experience creep into the PHP world. If you need a better type system, maybe not use PHP?
What if you do or `./vendor/bin/phpunit` or `php vendor/bin/phpunit`?
The only thing constant is change. amirite?
 $mySecondArray = $myArray; sort($mySecondArray); // Would do the trick
"Know the difference between a directory versus an URL."
The fuck are you even talking about? I know reading is hard for you, but have you even *tried* looking at the article?
FWIW - Not sure about the other languages mentioned, but JavaScript and Python have `.sort()` which also sorts the arrays in place. This behaves the same way. In Python the sorted array is not returned, in JavaScript it is.
Yes, indeed I have. You're not the be-all-end-all of PHP best practice though. (please don't take this harshly as it's not meant to be a slight) I just don't think your advice should be applied to composers automatically generated autoload.php files. Nor should it be applied to fully CLI scripts/apps/tools that don't interact with HTTP/URLs.
"Good enough tooling" - Yes, choose 1 or 2 of the 10,000 available choices. Make sure to properly obfuscate the process and not document how the entire shitshow is put together so you can make the next dev's life a living hell. Fuck transpiling. This is why I won't touch JS.
Just to reinforce my point /u/Gipetto is saying what I'm saying too. Since URL Paths =/= File Paths why would you use a file system constant to create URLS. Again, I'm not saying your advice is wrong or bad - I'm saying that the more accurate complaint is about libraries using it incorrectly and in improper context. Heck, even the PHP docs allude to this being the case, just look at the pages breadcrumbs: &gt; PHP Manual &gt; Function Reference &gt; File System Related Extensions &gt; Directories As we can see this is grouped under "File System Related Extensions" and, again, URLs are not the same as File System paths.
Close but not the same. From an API perspective your File Paths are like Private APIs and your Web URLs your Public APIs. Sure there's overlap - but using a File System constant to build a URL would be like exposing part of your Private API directly rather than building a method for it in your Public API.
There is API platform, see https://api-platform.com/. You need to install a bundle or two for the authentication, since it depends on your user model as well as the kind of authentication you want, but it's relatively quick to set up and well documented.
You make intelligence look fdumb
Those templating languages are pain in the ass. Crappy IDE experience, hard debugging.
you never commit transpiled code anymore than you commit compiled code. you build and deploy the output of these steps
I like your explanation of the functionality and advice. Best of all Collections have become more popular so there's a few good choices for using them independent of Laravel.
It's perfectly acceptable for a piece of software to have system requirements, one of which would be the OS. As long as that use case is understood, documented and communicated, it's a perfectly healthy practice. At my work we know we will never run our applications on Windows, thus we do not spend time validating they work on Windows. We bundle Docker images with all of our applications, and those are the intended runtime. 
This is not quite correct. The equivalent pattern in python is: sorted([1, 2, 3]) The reason is that it comes down to who wrote that particular PHP feature and which language they were trying to copy at the time. A lot of early PHP copies C functions, and here in PHP idea is that the argument behaves like a pointer to an object. In C void functions are quite common because the language is statement oriented and very inexpressive. In dynamic languages there's no justification, and here its an idiom imported by imdiots. 
Sure, but that's tedious and means you need those tools on the other end. If you're just committing a static site, then it's much easier to just have the build output in the repo. "Never" is a pretty strong word here.
Idk, I like blade. There's lots of good syntax/snippet plugins for it. Makes it easier to make sure things are properly escaped than just going vanilla PHP, so I like it.
Of course, it's better than php for templating. But you must admit those points are true. Crappy IDE and debugging experience is because it's transpiled. So you get same disadvantages if you start to transpile in backend.
I don't agree with that, I've never seen any issues with blade.
Well ya gotta touch it if you're doing anything in the browser but yeah you don't need to adopt the build tools. It's something I've been mostly avoiding myself. Sure my project isn't using the latest JavaScript greatness but it's all really fecking straightforward for someone new to pick up.
Ditto. Phpstorm works great with blade.
And a lot of people shit on JS for doing that when the term constant implies that the value never changes in any way in pretty much all other languages (And in math/science in general.) I guess the JS people used `const` thinking it'd be like a constant pointer in C, but most people wouldn't cite it as a good thing you need to double const (ex: `char const * const str`) to get an immutable reference to an immutable value in C so I wouldn't put that forward as a good choice on JS's part. 
Plus you have to remember, that array in PHP is not the same as array in C\C++, under the hood [they use hashtable](https://nikic.github.io/2012/03/28/Understanding-PHPs-internal-array-implementation.html). So overhead of copying such an array would be higher.
Why don't make it working as extension using c or zephir?
Why not? I moved to Typescript and I love it. 
don't forget `file_http_stream_socket_ftp_usps_get_contents_get_last_errno()` and `file_http_stream_socket_ftp_usps_get_contents_get_last_error_message()` and that to set TLS options, you need to use `file_http_stream_socket_ftp_usps_get_contents_real_init()` instead! ...I write PHP all day every day, and this is how I cope. 
[removed]
This isn't getting search results with PHP, it's how to use an API that gives you the search results. LOL
For me: Laravel gave me the least headaches.. 
`extract` can be useful in some cases, such as PHP-based templating systems. (Not that I like them, but they do exist.)
A least we can access private/protected method/properties out of class scope
True, it's now impossible to get Google search results without paying for proxies or CAPTCHAs.
Does php 7.3 support trailing commas in grouped namespaces? use Blah\{ MyClass, }; Currently I have huge blocks of use namespaces and I currently write most of my namespaces like so: use Blah\{ InitialClass , AdditionalClass , AdditionalClass2 }; Reason is I have a code base where the core code gets reused in multiple projects, but sometimes I may want to override or extend a class before using it so I'll comment out one of the classes but it looks kind of messy and this was my 'solution' to that problem. 
With JS you don't really have much of a choice but using a transpiler. For PHP, there's big convenience avantages to not needing one.
you should've have put a disclaimer then. This is quite an indirect advertising to me.
HackLang has this. They're called "Shapes".
why are you using dot notations in the examples ? `$serp.set_serp_api_key("Your Private Key")` should be `$serp-&gt;set_serp_api_key("Your Private Key")`
you just cloned array, it's pretty obvious thing to do....
That is really cool man. Nice work
Because fuck you, that's why! 
Because it doubles the ram usage instead of modifying it in place. With the way it is now you can still clone it if you want.
So...... I actually am really close to releasing my framework which does this. https://github.com/Divergence/docs/blob/master/controllers.md#json-api-reference There's no way for me to do universal authentication because each system is different. To mitigate this problem I made a trait you can use with your models: https://github.com/Divergence/docs/blob/master/controllers.md#permissions You just make the permission checkers return true or false depending on your boiler plate.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [Divergence/docs/.../**controllers.md#json-api-reference** (master ‚Üí 56a3b07)](https://github.com/Divergence/docs/blob/56a3b07b8c5a9a632d63478e30024736ae8283ab/controllers.md#json-api-reference) * [Divergence/docs/.../**controllers.md#permissions** (master ‚Üí 56a3b07)](https://github.com/Divergence/docs/blob/56a3b07b8c5a9a632d63478e30024736ae8283ab/controllers.md#permissions) ---- [^delete](https://www.reddit.com/message/compose/?to=GitHubPermalinkBot&amp;subject=deletion&amp;message=Delete reply dzl36w8.)
Still the king \(we deserve.\)
Besides the very interesting tidbits about how PHP 7.x is being optimized, the best take away was [Phan](https://github.com/phan/phan) - the static PHP analyzer. 
Man, phan looks awesome. It's the kind of tool I need at work.
Why bother releasing new versioning if you want to maintain Backward Compatibility? That reasoning never made sense when everything is iterable in every language and is eventually abandoned at majors anyway. Why bother with the pretense? 
I like how he owns up to screwing up the original design (~5:15) and admits PHP isn't focused on breaking backwards compatibility nor the 80% of the web that has some component of PHP code. Flak, a consequence of owning the territory.
I agree but I would love strict typings for PHP. I hate that there‚Äôs no compile step where a majority of the issues are found. I just started with Java for a project and while I don‚Äôt love the JVM, the typings are awesome. If someone were to make a superset of PHP with strong typings I‚Äôd use it in a heartbeat!
They also dropped the old mysql stuff, which probably broke a lot of old crappy code, but people should be using mysqli or pdo and prepared statements anyways.
Sweet. I've read the slides a couple times before \(they show up in some google searches I've done\) but never watched the talk. Glad I did, he gave a lot of extra explanations on top of the slides that I didn't get before.
It's rather good, I can object two things: 1. inconsistent use of prepared statements. This is an idiocy that eventually will lead to injection. Although the present code is safe, such an approach, when it is left for the developer to decide, whether to use prepared statements or not, is a sure call for disaster. 2. Some cargo cult code that is either harmful or of no help. Examples are sanitize input in the registration page and a separate database user. Dropping tables is not the worst scenario could happen, especially given regular **backups** you are surely doing, aren't you? Whereas select or update injection could ruin your app no less effective. In a nutshell, consider every measure you are going to add, just like you did with strip slashes - find out what does it do and whether it's applicable for your case. As opposed to blindly copy/pasting them
Where can I get the slides?
extract/compact, variable variables and eval are all important language features for metaprogramming. The language shouldn't seek to accommodate people who do foolish things. It's a computer, it does what you tell it to do. Let's have a language that gives us broad leeway over how we instruct it. Just be smart about using it. TBH most of my job and livelihood is based on the fact that PHP programmers 10-20 years ago were not careful and produced buggy, shitty systems that now need intensive maintenance and bug fixing. It's kind of annoying but at the same time there's not enough new features and new products being built to keep me employed versus the amount of existing systems that need maintenance, so I'll take it.
I don't know why you're being downvoted because you're 100% correct. When I upgraded a million+ LOC ancient (quite a bit of it was PHP4 style) codebase that made _extensive_ use of the mysql_ functions I used the wonderful DShafik's [shim library](https://github.com/dshafik/php7-mysql-shim) and it just worked. I made use of several 'shims' provided by the internals team in order to do the migration and php7cc to find compatibility errors and by myself managed to migrate this codebase with very minimal changes (regex with executable flag, constructors with object names, a few others I've forgotten now) in a pretty short period of time (a couple of months). No bugs either which was _huge_ given the lack of tests or programmer discipline in the formative years of the project. This is one of PHP's greatest features IMO. Look at the debacle of python 2 vs. python 3 to understand just how well the team are managing, especially given what PHP evolved from.
WE NEVER BREAK USERSPACE! 
Thanks for your reply! Some follow up questions: &gt;inconsistent use of prepared statements Do you mean to say prepared statements should always be used? I'm currently checking to make sure this is the case, because I know it wasn't originally and I had to convert the queries &gt;...especially given regular **backups** you are surely doing, aren't you? Honestly, no. The live site hasn't been updated in close to 6 months, but I do have a current backup of it. Once I push the massive changes I've been doing the past 6months to the live site, i expect to get an influx of users and will make sure to do probably weekly backups at first &gt;Some cargo cult code that is either harmful or of no help. Examples are sanitize input in the registration page and a separate database user. I do have the default root user, which I never use, an admin user that Has all privileges on the applicable db so I can make changes and a standard user with select, insert, and update privileges, which the site uses &gt;Whereas select or update injection could ruin your app no less effective. Can you explain the a little further? 
Yes, it only makes sense to use prepared statements for the every query that uses a variable. The point was not to push you with a kiosk, but to make a point that SQL injection is not the main reason for losing your tables, so you ought to have backups anyway. And once you have, delete based injection becomes not that scary, at least to hassle with distinct user. There is nothing to explain actually, other than a strange superstition that make some people do believe that SQL injection is something that drops your database. SQL injection is the ability to run any bloody kind of query. So you have to prevent injections, not dropping tables. 
http://talks.php.net/concat18
[http://talks.php.net/concat18](http://talks.php.net/concat18)
Thanks for find bug in our code, you are genius.
I knew about DCE, but wasn't aware how clever it is. Can I assume that every redundant intermediate variable (like those introduced for readability) will be eliminated?
[Phan](https://github.com/phan/phan) sounds awesome, but doesn't it kinda overlap with PhpStorm code inspections? How much value does it bring for a decent codebase with decent test coverage? Anyone care to share their experience?
You can't run phpstorm in CI. Running the checks there ensures they're run, even if some dev edits their code in notepad.
Oh, that is certainly a valid point, though I've seen some teams using [grumphp](https://github.com/phpro/grumphp) in the past and ironically these had the worst codebase among the ones I've had pleasure working with. It seems that most companies apply tools like this retroactively in response to apparent problems in the codebase that could be easily solved with tests, code reviews and enforcing good IDE.
How about using an anonymous class instead? Allows for preventing external use, as well as prevents declaring multiple concrete (and named) classes in one file. 
Personally, I would define the two classes in separate file, but keep them together in the namespacing and/or filesystem to make it clear that the two belong to the same software component or module. But "best practices" are just that. They're not concrete regulations to follow slavishly. Just be sure to document your reasons for breaking with convention.
I was also thinking about that. Would you make the anonymous class from a method within the `Tuple` class? Because declaring it outside of the class definition means you need `global` to access it, that's a no-go.
I agree, but don't you think that when a class that shouldn't be used from the outside, is autoloadable; it also counts as a code smell?
Just document that it shouldn‚Äôt be loaded anywhere else? Or maybe hmm. File structure is hard. Idk. 
I also considered a separate namespace, but than there's the following issue: this package has three data structures: `Tuple`, `Struct` and `Collection`, meaning all of them should get their own namespace, or should be bundled (together with `TupleIterator`) in one. Both options seem like moving the problem to me.
&gt; File structure is hard. Idk Yeah :D
Glad you like it!
 Lovely girls only here come faster http://fxbdb.poleoa.pro/Y3MnvL
Can you guys give me real example where `extract`
Can you give me real example where extract and compact are necessary? It's evil. Even if it's template, I want my IDE to be able to tell me what methods/properties I can use. You mentioned metaprogramming, can you show the use case, perhaps it's a feature that shall be used with real care. 
So, basically he wanted PHP to be like... JSF? Do I hear that right?
To do this, the \[\`@internal\`\]\([https://www.phpdoc.org/docs/latest/references/phpdoc/tags/internal.html](https://www.phpdoc.org/docs/latest/references/phpdoc/tags/internal.html)\) tag could be used.
In my opinion I'm against it. I get that it's an edge case and you don't want someone to use the class, but I think even edge cases should try to be as standard as they can be. Code is, in my opinion, meant to be read by other developers. Maybe not right now, maybe it's not even intended, but at some point someone else other than you is going to be digging through your library. And they're going to see this and just be confused as fuck. Going against conventions of an entire community just causes more confused than it's worth (in my opinion).
That's a valid point, thanks!
I always go stupid first. Maybe multidimensional arrays could work ? ``` $data = [ [ [ ‚Äútype‚Äù, ‚Äúdata‚Äù ], [ ‚Äútype‚Äù, ‚Äúdata‚Äù ] // etc. ] ]; ```
Unfortunately, the type definition doesn't happen at the same time as when data comes in. So you'd still need to loop over both to parse them into one. 
1. In composer autoloader you can declare php file for an class - it would solve autoloader problem. 2. Your Iterator class looks like a solution for common problem of iterating over parallel collections so I would definitely create new file for it. 
Why would you want to autoload a class that will never be used except by one particular class? And testing a private class makes as much sense as testing private methods. By the way, feel free to start working on marking classes as private. At which point someone will be working on it.
I especially love this with coroutines (Guzzle's P\coroutine, or AMP\call). Easier to add when you can simply take you existing methods and throw some yields in front of them. Easier to change $user = Users::get(1); to $user = yield $userLoader-&gt;load(1); than $userLoader-&gt;load(1) -&gt;then(function ( $user ) use ( $closure, $vars, $that, $you, $need ) {
JS is really only "async" in that it has the event\-loop shipped as a built\-in, but an event loop is a pretty simple piece of code. PHP isn't purely "synchronous" because it doesn't come with an event\-loop, any more than JS can't use a database because it doesn't ship with PDO. With composer used everywhere, it's a trivial matter to simply install an event loop. There's also a lot that can be done concurrently (even without an event loop), by defining when you have to make a request, vs when you actually need its data. e.g. I could make great use of promises by sending an HTTP GET to some webservice, then running all the queries on my local mySQL db, and when they're both done building my response. So if my webservice takes 1s to respond, and my queries take 1s to run, Promises give me an easy way to wait 1s while both run, instead of 2s to do one at a time. P\coroutine( function () { $client = new GuzzleHttp\Client(); // Start my request, but don't wait on it $postsPromise = $client-&gt;getAsync( 'https://example.com/stories' ); $users = Users::get_all(); // Now wait for those stories to load $posts = yield $postsPromise; // Then return an object we build, that shows all the posts by user yield posts_by_user( $posts, $users ); } ); What's especially cool, is since we've already written this using promises, if we _did_ later take this method and run it inside an event loop, it would get even more efficient. If we'd already finished getting our `$users`, but the `$posts` hadn't finished loading, this thread could go and run something else while we wait for them to load.
Just want to add that not everyone uses PhpStorm; even though it potentially has a huge majority. I generally just stick to using Atom since it's had decent integrations for a while now. Even outside of those IDE style integrations though I've still liked using phan.
nah, phan is worst out of trio of php static analyzers
As a developer who didn‚Äôt write the project, I would appreciate having each class in its own file. If I want to find the implementation I don‚Äôt want to have to guess where it is. I mean it‚Äôs not bad if I have to open a few files before I find the source code I‚Äôm looking for, but as the number of classes grows I‚Äôd rather just be able to spot the file in the finder. Also since it‚Äôs an open source project people might like to add to the class. Then at what point should it be broken out into its own file? Just a few things that came to mind. 
I use [FakeSMTP](http://nilhcem.com/FakeSMTP/) for this
This is already supported since PHP 7.2. PHP 7.3 allows trailing commas in function calls.
thanks, guess ill upgrade from 7.1 to 7.3 :)
Meh, it's fine. But as you see most people see it black &amp; white. Current solution is even better though. Even better would be to get rid of iterator completely, imho you don't need it.
kind of yeah. He wanted to make it easy for designers to design around his output data so all he needed to do was embed the c code into the templates and you wouldn't have to worry about the designers screwing up any business logic. Problem was he added a lot of C like syntax into PHP and people enjoyed writing php and wanted to do both the front and backend with php. 
You should also write and document your code as if you'd have to learn it all again in a few years. 
That's all true, but in refactoring you may want to move functionality between units (e.g. classes) of your application, or adjust the interfaces through which they talk to each other. That means that at least some of the unit tests that test those individual units are likely to need to change. I'm not arguing against TDD here, just saying that tests do sometimes need to be updated as part of a refactoring.
Presumably Bergmann is recommending the standard process of doing a build for production with the composer --no-dev option to not include PHPUnit. But by doing that means the artifact you deploy isn't quite the same as the one you tested with PHPUnit. How do you know that it works if it hasn't been unit tested? What if you accidentally make use of a class that comes from a package declared as a dev dependency? And you have to run composer install twice, once to create the testable version of the package that includes PHPUnit, and a second time to create the deployable version. How will you find out if there's something wrong with the script for the second run of composer install. I think there might be an argument for abandoning the distinction between dev and production dependencies and just having one self-testing application.
Yeah, im kinda gald about the way thibgs went as well. In a way I think thats what helped in getting it so popular in the first place :-)
For only $49 I can shave ‚Äúhours‚Äù off my laravel project. Once.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
As a side note, all browsers flip backslashes in URLs to forward slashes. Because what OP experienced is not exactly a single occurrence. It's a very common mistake. Technically backslashes are not legal in a URL as-is (they need to be URL-encoded, or otherwise encoded).
&gt; I beg to differ : I encountered many issues with third-party librairies and tools who didn't used DIRECTORY_SEPARATOR. Remember that constants like __FILE__ or __DIR__ will have \ on Windows. Yes, they will. But as long as you *expect* both types of slashes, and *use* only forward slashes when building paths, you're covered. Windows treats both slashes the same for compatibility. I don't use DIRECTORY_SEPARATOR because it gets verbose as hell, I mean: $foo = __DIR__ . '/assets/main/foo/bar.jpg'; vs: $foo = __DIR__ . DIRECTORY_SEPARATOR . 'assets' . DIRECTORY_SEPARATOR . 'main' . DIRECTORY_SEPARATOR . 'foo' . DIRECTORY_SEPARATOR . 'bar.jpg'; I work on Windows, deploy on both Linux, BSD, Windows... despite the scary warnings and reports of "many issues" like you talk about, so far with me: zero issues. So then one has to ask, what is an example of the "many issues" you experienced? 
Short object notation is a basically free feature that integrates with JS symbols, and can be type checked and autocompleted by the likes of TypeScript etc. Compact is a function that's not nearly as fast as a construct, uses strings (no error detection, autocompletion) and has awkward behavior, for a function, as it reads vars out of its scope. Every time I see compact/expand in code, the effect is me taking a very very deep breath and preparing for a shitty day with variables coming from nowhere and going nowhere all over the code. So while there might be some superficial similarity, I'd say they're *quite different* in practice. I wouldn't mind them going away before we figure out a replacement.
Not that big, because we already do most of it. The compiler detects uses of "compact" etc. and falls back to slower opcodes/execution, but when it's not present, it's as if they're not in the language at all.
Yeah, eval() is important for metaprogramming, although, generating code to a file and loading it from there kind of covers most use cases (template compilation etc.). Loading from file also works with opcache, while eval() doesn't. But I'd like to be enlightened how the heck is extract/compact so important to metaprogramming. We can just use arrays, you know? 
Names talk "PHP in 2018". First slide titled: "1980s". Sorry, but no.
This article manages to make something simple very long and complex, and get most shit wrong at the same time. Quite impressive.
Dumb.
It is actually possible to run PHPStorm inspections in CI, but it's not the most straightforward thing to set up.
&gt; if the original post asked how to create a new sorted array it didnt
wtf
PHPStan is much better. Speaking from experience here, I added a PHP static analyzer to our CI pipeline last week.
I‚Äôve added a static analysis step as a requirement to passing builds in a large, old, and actively-developed codebase. It catches a decent number of issues every day in new code added. As others have pointed out, static analysis isn‚Äôt a replacement for a well-tested codebase, but sometimes it isn‚Äôt feasible (for business reasons) to have tests that fully cover your code. In that scenario static analysis can be a lifesaver.
&gt; Why would you want to autoload a class that will never be used except by one particular class? Because if there are exceptions to basic assumptions like how things are loaded, the project has started turning into spaghetti.
Is this masked advertising for the swole package ?
Where did you get the initial statistic that web developers allot less than 50&amp;#37; of development time on the actual application business logic? Are you inferring that more than 50&amp;#37; of code is more than the typical boilerplate? Is this larger percentage including a Discovery Process? I question this one simple statement to the point that I find your service to be in question as well.
Swoole is not a package, its an extension with a lot of promise. It could change a lot of things in the industry. I wouldn't consider it masked advertising of it though lol. Rather, its a way of making a more fair comparison of PHP7s true potential in a battle with node.js. 
Also by the way I am not affiliated with Swoole, I jus discovered it recently myself. I doubt that author of the blog post is connected to Swoole either. 
Also by the way I am not affiliated with Swoole, I jus discovered it recently myself. I doubt that author of the blog post is connected to Swoole either. 
How about Node 10?
How about some apache-worker mpm? 
Worked here I'm interested now 
lol wow I wasn't expecting this type of response. I did find some of the stuff to seem unnecessarily complex, but I figured it was just my ignorance that made it seem so. Do you have any advice on how to proceed instead?
Up your game with Event.
The techniques in this article are both outdated, use bad practices *and* simultaneously are massively overkill for 99% of all userland projects. This is quite a feat to do simultaneously! # Overkill: 1. Bruteforce prevention (Use bcrypt instead. If you're running a more secure site, usually, if you're worried, just use a captcha) 2. JavaScript hashing of the password. Usually not necessary. 3. Session jacking (the login + userbrowser thing). Normally not a problem you need to worry about but good if you're dealing with storing people's money, and such. # Outdated: 1. *NO MENTION OF* **SSL/TLS**! This is the unequivocable necessity for all login / registration systems. And Google Chrome will start THROWING ERRORS later this year (I believe November) for all unsecured login forms. 2. **Doesn't use PDO:** Do NOT use `mysqli` any more. It should be treated just like the `mysql_` functions, which have been **removed** in PHP 7.0. 3. **Doesn't use composer:** 90% of this stuff should be bootstraped using composer packages, even if you're not using a framework, which I would recommend first. 4. **Doesn't mention bcrypt or the more secure password hashing methodologies:** See http://php.net/manual/en/faq.passwords.php
Honestly one class per file is kind of weird. Look at other programming languages: essentially PHP is the only one doing this. The autoloader should work, yes, and a one-to-one mapping is certainly easy, but that doesn't mean it is the best way. I prefer iterators that are tied to a data structure to be defined in the same file the data structure is. I'm clearly in the minority here, but think about it.
How is "Search Box" a quality of a web developer? This post is absolute garbage and spam.
Compiled( machine code) will always be faster than scripting, a fair conparison would be a c++ compiled module for nodejs for web requests
How does swoole compare with PHP\-PM?
I don't agree with suggesting JWT/Paseto tbh, makes it harder to deal with revocation and such. If it's in session, revocation is much easier. Admittedly it is one more thing to worry about in backend architecture, but I think session is useful for all kinds of things anyways, things that don't really have a place in a token. If you're going for full\-stateless, sure, but I think it's a lot simpler/easier to just stick with sessions.
In this case, PHP is also hampered by the fact that the author is running with a single core. Nginx and PHP work particularly well with multiple cores. Node is generally a single\-threaded server.
Php-fpm receives fastcgi requests, swoole receives directly http requests 
Basically seemed like he was describing something like what Twig and Blade are today with their Raw php counterparts. He wanted 
This benchmark is for requests/sec. What about average response time?
Doesn't C, C++ and Java also have the same convention? I agree with you, of course. My solution for now is to use an anonymous class, feels like actually the best approach, as now I'm 100% sure no one can use the iterator from the outside.
[removed]
I think he's referring to php-pm https://github.com/php-pm/php-pm not php-fpm
Oh, my fault... 
In Java developers usually put the helper classes as private or public inner classes. In kotlin you can put everything everywhere.
[removed]
If you can have multiple nginx listeners in front of a php-fpm pool, is that really that different to having the same nginx listeners in front of a pool of nodejs listener processes?
gr8 b8 m8
Why is node so much slower with nginx in front of it?
CodeIgnight is an all time favorite in the community many many years ago, because of its simplicity and light-weight code-base. The original developers stopped pushing newer versions and it became obsolete as PHP itself improved. You can still use it for small projects, but you'll quickly realize the features you're missing or the amount of work arounds you'll need to build compared to a modern framework. A new group has been working on version 4, but it's taken years to really see progress. Today, Laravel is usually the choice for many. 
In general it's a highly coupled framework - everything loads and has almost direct access to everything else. There's very little, if any usage of patterns such as Dependency Injection that are recognized good practices in OOP. This makes it both much harder to test and harder to change things to another library / way of doing things at a later date. It's highly rooted in the PHP 4 / early PHP 5 ways of doing things and, despite being "bought out" by a college who are apparently (and disturbingly) now using it to teach students, has made very little attempt / progress at using better practices or moving with the times. It doesn't use SOLID principles. It doesn't even use namespaces. And it has made only cursory nods towards even acknowledging Composer exists. Like many frameworks that use bad practices, it suffers from the trait of appearing initially alluringly simple, but once you've started using it and find you're hitting its limitations, its drawback become apparent but because of its tight coupling its difficult to move away.
If you like it, keep using it. Just keep in mind that there are other ways, when you find out you some colleagues work much faster than you, can implement features that seem impossible, and can reuse a shocking amount of code project to project, while also catering to specific customer needs.
What the hell. This is not nice at all. 
We've made the similar thing in Go (https://github.com/spiral/roadrunner), performance boost gained by elimination of the bootload logic is very promising.
For smaller projects, a simpler framework is good. For larger ones, a more complex framework may be required. CodeIgniter *is* simple, but at the same time, it's archaic, half-abandoned, buggy, and extremely badly designed. If you like CodeIgniter, you'll love some of the other better lightweight frameworks out there. &gt; What are the reasons that Code Igniter might not be recommended? Why would you *recommend* it? It makes simple things simple (but no more so than, say, Slim would), and hard things impossible. It was mediocre, and then PHP moved on and its competitors surpassed it. Now it's just a relic.
Another framework to be aware of is CakePHP, its my favorite and the documentation is really great. I agree with the comments from everyone so far, if you are using code igniter and accomplishing projects and getting paid then there is nothing wrong with doing what works. 
If you like it, keep using it, just be aware of its limitations. I personally came to rest on Yii after trying a few different frameworks out.
The ‚Äúdatabase language thing‚Äù is Laravel‚Äôs ORM, called Eloquent. You can use it in other projects - I actually use it with CodeIgniter myself. 
CodeIgniter is great, used it for years but... Laravel is just a lot easier for me with Eloquent.
What the php license is created for?
You deploy PHPStorm to the CI server, then there's a command line script you can run (see [here](https://www.jetbrains.com/help/phpstorm/running-inspections-offline.html)) It's definitely more cumbersome then your typical CI tool, not gonna lie
That's certainly... interesting, I didn't know about this functionality. How does that work license-wise?
&gt; I don't agree with suggesting JWT/Paseto tbh, makes it harder to deal with revocation and such. Let's see. I have developed more than a handful of live sites, some having very sensitive personal data, that use JWT tokens as the authentication system. The way I design systems to avoid the need for token revocation is to give them a TTL of just about 1 to 10 minutes, depending on both the sensitivity and level of user interaction on the site (lots of interaction = shorter TTL). Simultaneously, a so-called Refresh Token with a Much Longer TTL is issued, usually 30 minutes to 1 hour, per site. Every time they access an actual *page* on the website, their TTL is analyzed. If the TTL has expired, then automagically, the `GET /auth/jwt` route is called, passing it the Refresh Token (who's only authority is to generate a new general auth token). The Refresh Token, of course, has more session-specific data in it, such as the user's browser agent, IP address, active client site and a determinate nonce (based on a shared secret). In this way, I never ever have to worry about revoking tokens except at password reset, but that's a very small window.
PHP runs separate processes for requests. Node ends up funneling it all back to one process.
There are lies, damn lies, and benchmarks. What are these tests really testing? Without a significant amount of non-trivial work being done (where 'work' is reasonably close to the sorts of things you'd actually expect to do in a production environment) you're pretty much always measuring things that aren't really all that related to real-world performance. Especially with trivial code snippets you're letting what are otherwise fairly minimal confounding factors (like small spikes in resource usage by other processes that are largely idle) muddy your results. For example: nginx being slower than the naked framework: of course that's true! Often the whole purpose of nginx is to remove the need to run your code at all and serve the static content very quickly (which it does admirably) or it exists to allow multiple backend services to all seamlessly come together on one host on one port (which is also does admirably.) You've used neither of these features yet still incurred all the costs of running nginx. You're using nginx in the most useless scenario possible (proxy all traffic unconditionally). If you compare PHP/Node + nginx with a workload that allows nginx to shine at least a little (ex: serve a bunch of static assets) you'll see the performance gains it's supposed to have, and if you used nginx in a workload that really lets it shine (ex: hosting multiple distinct services with distinct backends on the same port on the same machine while scaling pretty well) you'll find you're doing things that you simply cannot do without nginx. (Or comparable software.) Similarly: what does pushing a bunch of elements on an array really test? It tests how well these particular versions of node and PHP handle memory in some extremely contrived circumstances, and the one that loses this benchmark could potentially win other contrived benchmarks just fine. In the real world there's basically never a reason you'd care that much about the speed of filling an array up - either it'd be fine regardless of tiny differences in performance, or it wouldn't be fine for reasons requiring a better data structure anyway.
Yep, this right here. The tight coupling of "models" to controllers was an immediate problem in almost every CI project I ever worked on. You access a model from the controller with `$this-&gt;model`, and you needed to follow its naming conventions and folder structures. You *had* to do things its way, which led to unintuitive, sub-optimal designs. I don't know if CI3 is any better, but any framework that's not making use of auto-resolving dependency injection and PSR-4 autoloading is archaic and will quickly turn any project into a trainwreck.
For the same reason, people suggest using Python over PHP today. Its what is currently popular and trending. In fact, I believe the same will happen with Symfony/Laravel when something new comes. I saw great things in the past with CodeIgniter. Its simplicity is what also makes it relatively secure and overall the projects I see done with CodeIgniter perform faster than those on Symfony which is a bit bloated. The only negative thing I could say is that since they handled it over to a university, it has advanced little vs other frameworks in the recent years. I actually like its simplicity and prefer it over more bloated frameworks. Don‚Äôt let anyone suggest you to the contrary because in the end, it is all about preference. The story is always the same, first CakePHP, then CodeIgniter, now Laravel and now the new hot stuff seems to be Phalcon. You should just stick with what fits better to your project. Personally I think projects done with Symphony are slower than those on CodeIgniter in terms of performance. Some people like bloated frameworks but other prefers light ones. For example, if you build an API, you might want to look at something even more light like Slim. Just pick your poison and if CodeIgniter is what you like, go with it. Each framework has its pros and cons. Some developers even suggest not using frameworks at all because they consider all of them bad.
The true question is how well that works in a real application. You need more than just the event loop to compete with node. Otherwise, if you use PHP's normal, synchronous functions you will block the event loop all the time and then your downloads and file operations will all halt and you end up with a poor performance, single\-threaded server application. You can't just say "Bam! I have an event loop now!" and magically everything runs in parallel and is faster. Let's say you use password\_verify with a proper iteration count. That's going to block EVERYTHING in your event loop while it runs for like 1 second until it yields. That's why node has its thread pool and uses that to run synchronous, expensive actions like filesystem operations, DNS requests and cryptography asynchronously \(from the event loop's point of view\).
Honestly, the tight coupling of *everything* to the controller. `&amp;get_instance()` &amp; co. are the special hell of Code Igniter. Indeed, I realized that the ever-present $CI property stand not for "code igniter" but "controller instance."
PHP\-PM \( React as base \) uses build in Zend functionality. Like AMP it runs into a issue. In order for the coroutine behavior to work, they need to use a specific build in function in Zend \( sorry, forgot the name \). And that function is slow. As a result PHP\-PM / AMP will be faster then pure PHP but can not reach the speed that Swoole can. Swoole has its own http/coroutine written in C and is not subject to this. [https://www.techempower.com/benchmarks/#section=test&amp;runid=ae097e87\-3b23\-402c\-8f51\-1608e16dd11a&amp;hw=ph&amp;test=json](https://www.techempower.com/benchmarks/#section=test&amp;runid=ae097e87-3b23-402c-8f51-1608e16dd11a&amp;hw=ph&amp;test=json) php\-swoole 1,125,676 amp 294,947 php 256,104 Here you can clearly see this in effect.
I used CodeIgniter extensively for years and it was much easier to use than competing frameworks like Cake or Zend, it just got out of the way and let you build things quickly. I probably still have private client apps happily running on it today. The biggest issue I ran into with it was loading 3rd party libraries. The new maintainers fixed that by adding Composer, and that alone was a major improvement. But if I was starting out today and needed an MVC framework I would skip it and go straight to Laravel. Taylor took a lot of things that were great in Rails and various PHP frameworks and built them into what Laravel is today. I‚Äôve got some major sites running on it today and have never had a framework-related issue.
Wrong place. I apologize.
&gt; college who are apparently (and disturbingly) now using it to teach students Just went through the program. We used it in one class and collectively hated it. 
Thank you for publishing this in video format, it will most definitely help me in the coming months of my study.
Lots of good responses here, but I'll throw one more opinion on top. I used CodeIgniter for years before my company switched to Laravel. Been using Laravel for about 5 years now and it's so much better. CI was good for its time, but to be competitive they would need a complete rebuild. Reminds me of Ember vs Angular/React/Vue for JS. Ahead of it's time, but newer stuff is just generally built much better based on the lessons we learned from the previous generation.
Think about this: If you had used username and password, would you implement the auto-login feature differently?
Half (or more) of the guides i find on how to implement authentication cookies suggests to save an encrypted version of the password in the cookie. This also sounds like a bad idea tho, but haven't put much thought into it as it doesn't fit my use case anyway. Is this not the right place to post for help?
and this is not the right sub for posting job offers.
I wonder what will be the next ‚Äûthing‚Äú after Laravel but I bet folks will complain, too :)
I don‚Äòt understand why opinions can get downvoted..
No. /r/PHP is for the discussion of the PHP language.
Apologies, I can see that now. I'll remember for next time.
Try phpstan instead
Just a thought on this \(and I realise it is specifically a YouTube tutorial\) \- I often follow tutorials and such, however I rarely have the uninterrupted time \(or headphones handy\) to follow a video for more than a few minutes. Have you thought about providing a transcript with code snippets? The reason I ask is just that I think it may increase your reach, as I say I rarely watch videos because I read quite quickly \(and am time poor, particularly at work\), so often articles reach me better. If that's not something you're interested in doing then that's fair enough, but I thought I'd throw my two pennies in :\)
Also, thank you for going to the effort of creating and posting this online!
An often overlooked topic I'm glad you've posted this one. Unfortunately I think you're right with regards to people still using things like MD5 to store their passwords. Ultimately it is the user who loses it if a security breach happens.
Fat-free framework (F3) has been my go-to for years on small projects. Makes me happy to see someone else mention it.
This is why Java has inner classes.
Laravel evolves so quickly, I think it will always be the next thing. Unless PHP falls completely out of fashion. 
Cool, I didn't know that. 
Depends on what type of service you build. For small projects you should take care of these things: SQL injection (prepared statements), strong password hashing (password_hash()), limit the number of tries to log-in (e.g. captcha) and XSS injection (I don't know of any standalone package, I let framework handle this). I would really recommend using some framework in your next project (or even in the current one if you have time to rewrite). Good ones are Symfony and Laravel (and probably some others).
Codeigniter used to be the easy/reliable framework - 11 years ago... If you still want that simplicity, without needing to learn Laravel (which, you should btw.. but really its 'just' a tightly packaged set of composer packages now) - checkout using something like Lumen or Slim for your routing, and then use Eloquent for your Database ORM if you dont want to use just Doctrin - you can basically just cherry pick your main components from composer packages and have a much slimmer, faster, loosely coupled stack with whatever you want. However, if you are doing anything beyond simple page routing and CRUD, use Laravel - there are so many more pieces in middle ware and security etc that you do not want to - and should not try to, roll your own.
Hey good job on this, it looks great! At work we often have to write importers/exporters which most of the time do pretty trivial things. Unfortunately we‚Äôve moved to Go for this sort of thing most of the time, and wrote our own ‚Äòbase‚Äô importer to abstract common tasks. It looks like you‚Äôve put a lot of thought into it, especially around data manipulation. Is there a way to add data items based on the value of other data items? As in get the value of an existing data item and act accordingly in the callback? How are you dealing with types of things? Especially into and out of CSVs, JSON and databases?
This could be handy for the GDPR requirement of data portability.
&gt; It's the Sears of PHP frameworks. Ouch.
Indeed. But like Slim, it isn't just for small projects.
Zealotry.
\&gt; In [this case](https://github.com/TechEmpower/FrameworkBenchmarks/blob/ad121c56c991c11653f89c37e3f7b37853bb1291/frameworks/PHP/php/swoole-server.php#L11-L13) you basically compare C vs go, or not? Yes and no ... Basic PHP is also comparing C and Go. Yet, PHP its results are much worse. I always have had issue with how Go and NodeJS have been pushed as the great saviors and fast languages, when in reality PHP is just as fast under the right conditions. People focus on the speed but not the reason for the speed. PHP its bootstrapping and syndrome nature that Go and co avoid as compile languages. That is the real power behind those languages and the easier deployment compared to C/C\+\+. \&gt; Also why do you compare go\-prefork instead of fasthttp? Overlooked it... but does not invalidated the point that PHP by default is way slower because of its blocking nature. \&gt; Also it will require your application to be written in a way it could took all the advantages of this platform. True \&gt; I will probably just switch to kotlin/go. Take it form somebody who has programmed in Kotlin, Go, Rust and a lot of other languages. The grass is not always greener on the other side. Go, Kotlin are good languages but they are not designed if you are looking for fast \( and / or framework less \) designing websites. I have grown frustrated at Go for running into situations where things that are so easy in PHP end up taking half a page or more code in Go. Kotlin relying on Java has the same issues as Java \( being memory hungry for its JIT is one thing. Its one of the same reason i do not use C# ... \). Swoole while not perfect, delivering the performance of Go, with the easy of PHP. And that is a great feat. Ideal? No ... Ideally PHP finally gets out of the stone ages and start delivering a more competitive solution but until they do, we are stuck with a\) going to different languages or b\) finding a solution in the PHP eco system. Like with any project, it depends on the community adaption. But unless somebody can show me a language that is fast to develop, easy to get people going, with the performance of C/Go, we really do not have a lot of choices, now do we?
Whats wrong with mysqli?
This is basically an ETL library. Very elegant. I had to write something like this recently, but we only have access to restful apis, and their business logic and async nature called for a queue workflow.
&gt; PHP allows for constructors of child classes to have another signature, while keeping an invariant type system for all other functions. As with many things PHP, this inconsistency increases the confusion for developers. This is not an inconsistency nor a violation of LSP. How an object is constructed has nothing to do with its interface.
So swoole is a realistic production setup.
As long as official support is missing it's just a workaround and avoiding to use the language that is actually supported. I'd love to see PHP support in faas providers but so far it's been rather crap. Azure offers beta support but it's so bad that we decided to rewrite it to C# as Microsoft wasn't very supportive as long as it's beta.
Do you mean yield? https://secure.php.net/manual/en/language.generators.syntax.php
Looking at the code you've done a really good job and clearly put the effort in. I haven't taken it for a spin yet. That said, looking at the WordPress Post and Users sources, it would be great if you could allow for a table prefix option. Then u could default it to wp_ . This will cater for users with a different table prefix.
Nice project! I'm using it to run gRPC server in Go, which translates all buisiness logic to PHP workers. Indeed, performance is great and all works perfectly. Thanks!
That's not how it reads at all, you might want to reword that.
The original post has been deleted, but I'm quite sure it was a question among it.
I bloody love [PsySh](https://psysh.org) for debugging PHP.
I will, thanks for the feedback!
Well, i've updated it: no more static design, just a trait that implements static methods if programmer will need it. Hope for your feedback.
You are at right place :D :D :D :D :D 
&gt; That is the real power behind those languages and the easier deployment compared to C/C++. Since my application are running inside docker container I don't have much difference in deployment process if my app is written in C++, go, rust or php. So for larger projects PHP not brings this benefit anymore. Also there are serverless approaches (lambda and so on) which makes your python/java/node application much simpler to deploy. Even if it binds you to particular cloud provider, or other problems (like damn dynamodb) &gt; because of its blocking nature. And also it's dynamic nature. Yes, with php 7.2 it has more specialized opcode handlers for situations where types are known, but most of the time you will need additional runtime overhead to deal with dynamic nature of php. JIT could reduce this even further but PHP will never be as fast as java or rust. But if PHP will get to the point where difference will be only 1 orders of magnitude slower, this will be enough for 99.9% of the use cases. &gt; looking for fast ( and / or framework less ) designing websites. I don't make websites, I make web applications (SPA + API). I also don't understand the point of "framework less". &gt; I have grown frustrated at Go for running into situations where things that are so easy in PHP end up taking half a page or more code in Go. Go is very primitive language, it doesn't give you lot's of syntax sugar. but what it does is code generators, which allows you to dramatically reduce amount of code. Also, there a re lots of use cases where features of go (like structural typing) reduces amount of boilerplate. Also I found that most of the problems with go goes from habits with other languages. Like "I have exceptions, so i don't bother myself with proper error handling nor will reduce length of my stack traces" &gt; Kotlin relying on Java https://github.com/JetBrains/kotlin-native - if you like to not rely on JVM. It's still more prototype rather than production ready solution, but it looks promising. Also as for JVM, there are [GraalVM](https://www.graalvm.org/) from Oracle. You may find this interesting. &gt; being memory hungry for its JIT is one thing. It's all depends on programmer skills. if you look at benchmark, first place is tooked by netty framework which is java. And it can't be fast if it not uses memory efficiently. But yes, this requires a lot of practice and understanding of how JVM is working. Also I don't really like Java since it verbose (at least now it has local type inference) but JVM is very nice platform. &gt; are stuck with developers who knew only one option to solve problem. Even if their tool are not the best for it. Would you use PHP or Java to do some CV/AI research or would you took python? Probably latest (due mature ecosystem in this solution space). Or will you took PHP or Javascript for embedded programming with highly limited resources, or will you took rust/c? PHP has it's own place in this world. 
Thanks a lot! This was originally written to help with a task of migrating data from an ancient Drupal 6 site. To answer your questsion: Yes, you can add data items based on the value of other data items. Here's an example that will add a 'test_account' data item with a value of '1' if the 'email' data item has a value of 'test@example.com'. ```php $migrator = new Migrator; $migrator-&gt;setSource($pdoSource) -&gt;setDestination($pdoDestination) -&gt;setFieldsToMigrate(['id', 'email', 'name']) -&gt;setKeyFields(['id']) -&gt;setDataRowManipulator(function($dataRow) { $emailDataItem = $dataRow-&gt;getDataItemByFieldName('email'); if ($emailDataItem-&gt;value == 'test@example.com') { $dataRow-&gt;addDataItem(new DataItem('test_account', '1')); } }) -&gt;withProgressBar() -&gt;migrate(); ``` Regarding data types, it is currently up to the source and destination objects to ensure that the data item value has the correct type when retrieved and set. If you need to change or enforce a data type for a specific migration, you can manipulate and/or cast the `$dataItem-&gt;value` via the `setDataRowManipulator` or `setDataItemManipulator` callback, similar to the above example. Really appreciate your feedback. The aim is to make this tool as flexible as possible.
[Permanent](https://help.github.com/articles/getting-permanent-links-to-files/#press-y-to-permalink-to-a-file-in-a-specific-commit) GitHub links: * [DivineOmega/uxdm/.../**uxdm-sources-and-destinations.md** (master ‚Üí 9a73ee1)](https://github.com/DivineOmega/uxdm/blob/9a73ee19d6effd24a04ef8201804bbd5293e636b/docs/uxdm-sources-and-destinations.md) ---- 
I‚Äôm still waking up, and though that said PHP 3.4.0 was released. 
I think you need to look at that benchmark a little more closely. :-)
Its relatively new but I think is quite promising. Not sure who uses it in production yet. I am playing around with it these days running various tests (havent had rime for anything indepth and exhaustive yet). Planning on testing it out on one of my smaller production systems in a few months to see how things go. 
Wow, good stuff! 
Thanks for the compliment! It is definitely ETL like. Although it was never intended to be used for data warehousing, it can certainly be used for that. At its most basic, all you would need is a UXDM migration setup to run on a cron job with various time based conditions \(perhaps using the PDO source's \`setOverrideSQL\(\)\` method\).
Thanks for brining this up!
Shame I didn't post this earlier, it might have eased the process a bit! I actually wrote this mostly because of issues with a Drupal migration, but I was sick of writing bespoke scripts for moving data between different format dbs. I've used this for everything data migration since.
Nice!
That was the original plan: create a video and a blogpost that goes into more detail.But it turns out that creating and editing the videos is quite the time sink \(not complaining, I love doing it\). So I understand that a transcript would be great \(totally agree\), but it would give a huge amount of overhead I'm afraid.
Thanks for watching :\)
Completely fair response, it's a very difficult weigh up and I don't think many people appreciate the amount of work that goes into creating these kind of projects. When my little one is asleep I'll have a second attempt at being able to sit and watch properly
I'm also curious about why mysqli is bad.
Code looks good :) nice work. I might take it for a test drive soon. 
&gt;Modern CodeIgniter Genuine question - whats changed since Ellis Labs ended development on it? Last I checked very little was being done that would improve upon what was there already, and compared to modern frameworks that's pretty archaic and slow to work with.
And another view - I hate CakePHP and use it every day at work. Dont get me wrong, it's a fair and powerful framework...but it's got a ton of bloat and god awful code you cant get rid of. Plus it's development is not in the communities interest. The company behind it use it for enterprise customers - if a feature someone suggests isn't useful for them, it wont be added. It's a very corporate feeling community, with a lot of old hat developers who seem to love complaining about Symfony, Zend, Laravel etc. Personally I find it slows me down significantly compared to Symfony and Laravel but hey this is all about opinions and I fully respect anyone who uses and likes Cake.
Awesome!
Hey your links are broken. Interested in checking this out.
Definitely saves time and hassle. Any support for fs permissions planned?
Fixed, didn't know why reddit added backslashes automatically
Good job! :-)
Useful! Nice job.
Nothing improves skill like writing own framework. Good job! Keep going! 
Thank you! If you run into any problems, feel free to open an issue on GitHub and I'll jump on it. :\)
Regarding your second example, you would use `implode`, which leaves you with a very readable array. 
&gt; Still getting 900 errors that are not a part of my code base You should run the tests only on your codebase, for example src/
All good points. &gt;It's nice that PHP can be made faster, but you can do that with most languages Yes, but this is a PHP reddit. :) &gt; PHP's real problem in 2018. You mentioned the word "problem" several times. I don't look at it that way, PHP is one tool among many. You seem to be evaluating PHP with the scope of an umbrella language -- is not. PHP is still relevant in 2018 and good for many development tasks but surely not all. PHP is not the only language I love, and there are other languages more suited for various things, I agree. Bottom line is that the PHP team and community are extremely active. Its always undergoing improments, always evolving and keeping up, PHP7 for example introduces massive improvements. Things like Swoole give it even more of an edge. This OP is just highlighting some of those specific aspects... not intended to be a complete overview. Appreciate your thoughts of course. 
Absolutely
The vast majority of professional PHP developers, who think they know OO programming, earnestly believe taking their procedural code and putting it into a class is OO programming.
Well, if you are using "static classes" and call it OOP, somewhere a small kitten dies.
Thank you
That‚Äôs a tough call. Personally, I didn‚Äôt have good experiences with code igniter early on, so you may want to look around for someone else who may have more experience with it. It felt very limiting to me. A few years ago, I think there would have been a stronger case for Code Igniter, but it feels like its stuck in an approach built around older versions of PHP. Newer versions of PHP are going more of a Java direction with Traits and Namespacing, etc, so I think that experience would be more valuable. Code Igniter feels like it would maybe be a better introduction if you had zero programming experience, or just wanted to kick the tires on PHP or see if web development in general is something you‚Äôd be interested in learning more about, but last I checked it didn‚Äôt really make you stick to MVC, so again I think Laravel offers better insights into the MVC dev method and modern feature of PHP ~7.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/explainlikeimcaveman] [ELIC: CPU Instruction Pipelining](https://www.reddit.com/r/explainlikeimcaveman/comments/8mrn05/elic_cpu_instruction_pipelining/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
Also, in some countries it doesn't matter if a TOS or contract or whatever has a ridiculous clause: if it's illegal, it's void.
Stack Exchange has a question about this ;-) https://law.stackexchange.com/questions/28180/how-does-ses-arbitration-clause-hold-up-under-the-gdpr
Good article but that `$product` is not a good example. Changing just one field in a single entity is a valid business operation. For example the background color of a box in a CMS. That piece of code could only be improved a little bit by allowing `$product` to be initialized directly from constructor arguments but I would refrain from making entities (or aggregates) immutable. Of course if setters can be grouped or moved into methods that more closely fit business operations that would be better but that's not always possible.
Lawyer here: I disagree on the mall cop part. The arbitrators are usually top of their game lawyers in the specific field, particularly if it‚Äôs the AAA. However they get paid really well so arbitration can be more expensive than traditional litigation because the litigants pay higher filing fees and arbitrator fees. These costs are subsidized by the taxpayers in traditional litigation. It‚Äôs more of a ‚Äúoh you were damaged $500.00. Do you really want to risk $3,000 in filing fees to win $3,500 back at best?‚Äù Litigation can be super expensive too, but many states wil have some version of a small claims court designed to let litigants sue if the amounts in question are under a certain amount. ($10,000 in my license state of Texas). Now some companies will carve out small claims cases from arbitration clauses. But not all. 
Yes. It raises a lot of good points but the examples a bit meh. I was thinking about how this... $invoicedAmount = new Money(50, new Currency('CHF')); $paidAmount = new Money(50, new Currency('CHF')); if ($invoicedAmount-&gt;getAmount() === $paidAmount-&gt;getAmount() &amp;&amp; $invoicedAmount-&gt;getCurrency()-&gt;getCode() === $paidAmount-&gt;getCurrency()-&gt;getCode() ) { // do something } ...seems a bit procedural itself and could be refactored to only doing one check. $invoicedAmount = new Money(50, new Currency('CHF')); $paidAmount = new Money(50, new Currency('CHF')); if ($invoicedAmount-&gt;getAmount() === $paidAmount-&gt;getAmount()) ) { // do something } Currency differences can be dealt with in the `Money` class.
I'm pretty much awake, misread it as that too. üòÇ
I agree that sometimes you just want to set something. Nothing wrong with having a setter in that case. But if you have to call a getter before you can set the new value, it's a good indication that you can move that logic into a separate method.
Another example is the $request\-\&gt;send\(\) in Guzzle or the $response\-\&gt;send\(\) in Symfony that are mixing record like representation and "send something" responsibility. In pure OO an object method should only have side effects on the receiving object, this is not the case when I call $request\-\&gt;send\(\). In a lesser extent, PSR 7 StreamInterface::\_\_toString\(\) have side effects on the receiver stream, which is very unusual for a conversion method \(to\*\) and IMO highly error prone: who can imagine that \(string\)$something will return different values when called twice ?
Uh oh, I may be a bad php programmer. :\( Nothing a little code rearranging can't fix though! :\)
Most arbitrators aren‚Äôt unprofessional rent a cops. That‚Äôs my disagreement. I am typically against arbitration in consumer transactions, however. Don‚Äôt interpret my above post as pro arbitration. 
That's true for the majority of every professional developer. This is not a php specific phenomenon. 
Phalcon docs really need improvement 
The issue been created
Awesome. Thank you.
Correlation is not causation!
I get where the author is coming from, but I feel this is much more about DRY business logic, than it is about OOP. OP's examples show a bad factoring of a problem and they say "that's procedural, not real OOP" and then he improves the factoring and says "this is now OOP". But that's not "procedural" vs. "OOP", this is poorly factored problem, vs. a better factored solution. OOP is not drastically different than procedural code. It's a superset of it, which the mental model different, but in practice every object is a bundle of state and procedures that go together, for better encapsulation, abstraction, flexibility, and reuse. Not every example of bad code in C you've seen is "how procedural code do". It's just how "bad programmers do". ^^&lt;/ZeFrank ^^Voice&gt;
Having dozens of methods that gets and set things internally can also be very close to cargo cult OOP programming. The idea isn't avoiding getters and setters, the idea is to not centralize the business logic of a common use case within the object. If there's no common business logic, then just wrapping get/set doesn't achieve much, other than add lines to your project.
&gt; In pure OO an object method should only have side effects on the receiving object I agree with your point that the Guzzle/Symfony requests are not factored properly, but this "calling a method won't produce side effects" idea really doesn't work in practice. I agree the "send" method shouldn't be on the request itself. I mean "send" where? It's like ActiveRecord which "saves" itself. It's a non-sequitur. Say in my projects this would be rather: $server-&gt;send($response); $client-&gt;send($request); That said, a request/response will change their state after they are sent, because their bodies are streams. A stream can be 2 kilobytes and all in RAM. Or it can be a streaming video you're receiving from a socket right now, and gigabytes of size. As you can guess, in the latter case, caching the entire stream by default, in order to allow for an "immutable" request/response would be extremely wasteful and even crash people's applications in some cases with out of RAM / out of disk space errors. Way I did this is every request/response has a body object, is available to be read once and then it starts returning `-&gt;isAvailable()` false. If you want to read it multiple times you can explicitly clone the body or request/response, but then if your body is huge, it'll be cached to disk. At least the action is made explicit through cloning. So, basically design is hard. 
Why do you ignore the `composer.lock` file and not use an `.editorconfig` file?
Mysqli isn't bad, per\-se. Not using prepared statements is bad. Much of the code written for mysql\_\* functions are just converted to mysqli\_\* functions without changing the queries to parameterized prepared statements. Note that it's also possible to have unsafe queries in PDO. The only real difference is that converting from mysql\_\* to PDO isn't as trivial as doing a search and replace of the function names, so code rewritten into PDO is far more likely to use parameterized prepared statements. It's a code smell, rather than actually being dangerous. People who have had to fix insecure sites see mysqli\_ as often as mysql\_, and rarely see PDO in insecure parts, so even though the solution is to use prepared statements, the way to find insecure sections is to look for mysql\_ and mysqli\_.
Thank you so much for the positive response! I was in no way shape or form expecting to get this many upvotes. So true. I definitely will. This isn't just a for fun side project. Between myself and a few of my colleagues we have dozens of mutual agency clients we've been dealing with over the past decade that are using an older version of the Models &amp; Controllers in this framework. It's important to note that when ActiveRecord from this codebase was originally written we could not really find a good ActiveRecord implementation in PHP that we wanted to use so we ended up writing our own. One of the platforms we've built with it is basically Blackboard for Highschools - [Slate](http://slate.is/) - [Github](https://github.com/SlateFoundation/slate) It is currently running in production at a Philadelphia magnet charter school. Our API controller is actually designed to work perfectly with the Ext.JS store model. Check out this 2011 [blog post](https://www.sencha.com/blog/sencha-touch-and-ext-js-spotlight-jarvus-innovations/) from Sencha on us. We somehow landed a gig with the Philadelphia Eagles to build them a mobile app. The back-end was using our PHP. My follow up road map: - Add a MySQL to Model builder for the CLI tool - Add a controller API builder for the CLI tool - Add PSR-15 support to controllers - Import Users, Sessions, Media (Suite of Image, Audio, Video, and Document (pdf,word) models) and associated controller - Unit test the above - Implement an ActiveRecord collections class that implements Traversable &amp; Countable I would love some input on any other important things I probably (definitely) missed!
Wow, that's interesting! USA seems to be a real Laravel bastion. Europe seems to largely prefer Symfony (and maybe Nette? Germany and Czechia are pretty fond of Nette it seems).
I would add the `.editorconfig` because regardless of what editor you use it‚Äôll adhere to that (and we have people that use at least 5 different editors. I used to hear that you don‚Äôt bring in the `composer.lock` file but it‚Äôs nice and to have the reference point for debugging or to see if another developer did something silly (because while your `composer.json` file might not change, your LOCK file can). It‚Äôs up to you, was just asking, code looks great too, I‚Äôll have to give it a run on a domain I bought to do offline hash generation, bcrypt convert/deconvert, password generation, etc.
Will $invoicedAmount-&gt;equals($paidAmount) always be the same as $paidAmount-&gt;equals($invoicedAmount) ? 
Thanks for the feedback! I appreciate that you've taken such an in\-depth look at how the UXDM sources work. I definitely see where you're coming from. The reason I decided to go with paginated data rows as the intermediate data structure, was to provide a standard format that can be easily used by any type of source or destination. You're right, this is not going to be most performant option for some use cases. However, I feel it's reasonable robust and very flexible. To somewhat mitigate performance issues, some sources \(such as the PDO source\), have a `setPerPage` method that lets you determine the number of records retrieved per page. Assuming you've sufficient RAM, setting this higher can significantly speed up migration. Still, I realise it is not as performant as streaming the data directly.
maybe build it with a bunch of raspberry pies...lol
Oop is data and functions upon that data grouped together. It doesn't add any extra lines to a project to keep those functions within a class. In the worst case, each function is very specific and only used once by a client. That is still better than the internal details of an object leaking across the entire application.
E-mailed it to you
Probably, but that's up to your application to define.
What's wrong with static controllers or static methods in an ORM to pull instantiated objects? Or global helpers?
Pretty much this. I'm full-time php dev and I saw way much of a code that has been only encapsulated in static classes/methods and autors just called themselves "gurus" and shit. 
See, I can understand promoting DRY and OOP principles and why you want to be concerned before it happens. I appreciate the article for this reason. But this feels a *lot* like premature optimization to me masquerading as good programming practice. We've condensed a single conjunctive if statement into a function call, which is either trivially obvious if the conditional is used a lot or mindlessly useless if it is used rarely. For example, why would I use an `equals` method when I could create an `Invoice` object with a list of `Payment` objects, both of which contain `Money` objects. Then I just need a function for Invoice called `isPaid` and I no longer have to care where I check for monetary equality since it only happens once. That's arguably less procedural and more OOP, which \- by the blog's admission \- is inherently better. Or, why not just take advantage of the OOP getters and setters and convert the money into whatever central currency my app is based on and have a boolean toggle for `isPaid` so I never need to know if currencies are equal except for the one time when I actually check the amounts. That really reduces the number of procedural lines I need, right? Either one of those solutions could work based on what the developer needs, as could the solution in the OP. But I agree that there is an inherent problem with just shrugging off a simple if statement as bad because you can arbitrarily define a use case where you might need to modify the if statement. Yes, all code has the potential to be changed if the situation changes, that's part of the point. Obsessing over single statements without being concerned on the actual flow of objects is less of a OOP vs. procedural argument and more of a nitpicking decision. Again, appreciate the message, but could probably use a little more depth than a single example to actually demonstrate "good" versus "bad" programming.
That's globally scoped and procedural code. With basically no way to actually unit-test the code, that uses those static structures. as for ORMs, there is also the minor issue of what type of design pattern are you using. If it is active-record, then you already by default are violating multiple (actually, all of) SOLID principles even if you avoided using procedural code.
&gt; then just wrapping get/set doesn't achieve much I disagree. Since type hinting I've pretty much always used getters/setters nowadays for entity properties - hiding them from the public scope. There is so much to gain from this and making sure an integer value is an integer, or a string being a string etc.
So I should make the method two times? Is this practical?
I see what you mean. I do think moving logic from service-level clients to the objects responsible is specific to OOP. "Tell, don't ask", the Hollywood principle, the Law of Demeter are more specifically about encapsulation. Don't let services do work the objects should do themselves. I think that's the point the author is trying to make. DRY could be an added benefit (although DRY is not always favorable, which is a discussion for another time).
Thing is, in procedural programming this would be called "modular programming" and there'd be the same advice that every module should be well encapsulated and handle its responsibility in full. A module in C is basically like an injected service singleton in OOP. The same best practices comply as to who does what. Yes, OOP has a name for it, but every style tends to have different names for the same things. There's a saying, if something good is lost, it's doomed to be reinvented.
So he looks at the code where `persist()` doesn't do anything but `flush()` is the function that persists data to the database, and what he has a problem with is getter/setters? Several frameworks across multiple languages use this exact same get/set pattern to represent data. The idea behind having a Repository and Service classes is to move logic *out* of the Data classes thus keeping with the Single Responsibility Principle. In this example, the `decrementAmount()` probably should go in a `ProductService` class or something rather than product. There are definitely cases where you want to add some methods to Model classes, like a toString() sort of thing, or validation perhaps. Regardless this problem has been solved. Putting behaviour in Model classe sis not it.
NB: I've not looked at the code yet, so this may not apply! If class A is only ever used in conjunction with class B, should they not be part of the same class? Maybe implementing the iterator interface?
Maybe this will finally help make things better for the Magento Cloud.... So many headaches due to [platform.sh](https://platform.sh) this year with Magento cloud.
Imagine someone actually reading this shit.
Hopefully not too old already: https://2016.webcampzg.org/talks/view/event-sourcing-the-good-the-bad-and-the-complicated/
ES is not supposed to "solve the ORM problem", although I know where this is coming from, I've seen bloggers so hyped about it they say it makes ORM obsolete. That's a non-sequitur. If before you had the state of your system in the database, now you have an event stream which can be used to produce this state in the database (and other variations/projections from the event stream). That's it. You will still query your state and if you needed an ORM before, you'd need an ORM again. Now I'm not a big fan of the mainstream ORMs, and avoid them for reasons entirely unrelated to whether I use ES or not, but I'm just saying ES has no relation to ORM use, other than using ORM to write/read the *events* themselves would be a major overkill. Regarding your "is ES is applicable to everything" question. In theory it is. That's it, a theory where time, resources and disk space is infinite. In practice, there are many parts of your application where state changes so often, and keeping track of the events forever is so unimportant from business point of view, that wasting CPU cycles and disk space to keep a record of it forever would be an example of excessive gold-plating. And the other constraint is time. Your time. Event systems do take extra time to develop, so you need to see what your return on investment is for making a part of your state event-driven or not. Also just like I don't think "ES vs. ORM" doesn't make sense as a debate, I think "CQRS vs. N-tier" doesn't quite make sense. CQRS is not something that *replaces* the N-tier architecture. It *adds* to it. Hence the extra effort etc. Also pure CQRS, with all the strict requirements such as "commands shall never return a response" - this only makes sense for system of great scale (millions of transactions a second etc.), or systems of great performance requirements (like real time multiplayer gaming servers for example). In the usual case, structuring your flow in commands (that CAN return data) and queries) in an N-tier paradigm is your best bet and my personal preferred factoring of a system. It's not "pure" CQRS. But CQRS was never meant to be your entire app at all. 
First of all we should ditch that false dilemma between *It's not OOP without principles* and *principles are just "suggestions"* and acknowledge that following principles is mandatory for good OOP, but they're different for different kinds of **o**bjects (as language contructs), and for some none applies (data structures?). This will bring some respect to both principles and developers (as they're no longer driven like fence bouncing herd). The key is to *know the difference between objects* and not arbitrary trading principles for convenience (or forcing them for sake of "purity"), because this can be easily confused with ignorance. Maybe ORMs not giving back real **O**bjects, because it's data structure producing tool, and data structures cannot be abstract, encapsulated (getters/setters are OOP cargo cult or at least defensive programmming) and you need knowledge of its nested structures that might be seen as "dependencies". If we decide it creates business *O*bjects then having getters and setters there tells us straight in the face - we don't. 
&gt; You can't run phpstorm in CI I take it you've never heard of [Upsource](https://www.jetbrains.com/upsource/). It's CI, by Jetbrains. With the inspections for PhpStorm. I've even managed to install plugins like PhpInspections EA, though plugins aren't officially supported
Why would it be "perfectly fine"?
Hm, I *had* heard of it, actually, but you don't run into it often. I had completely forgotten about it, but good point!
CQRS+ES is a good fit for process-oriented domains, and a terrible fit for CRUD domains. Most software I write is process-oriented, so I'm also currently in this kind of tricky situation: &gt; the problem I'm having now is that I cannot see any problems that a CQRS &amp; ES introduce The biggest problems I've seen so far are: * versioning/upgrades in the event store * the huge amount of projections Business logic and process managers are dead simple, easy to understand and debug, so I'm totally sold on those, but the projections are just soooooo painful! 
ayyy, careful you dont waiver rights from 35 other corps, I mean people.
That wasn't the question though.
You can play with the platform with a free-trial. There are some ready-made templates (both in the trial wizard and on github) so you should be able to be up and running in a couple of minutes and see what is buzz what is not. "Deploy to the moon" definitely buzz. Everything has Caveats. So take everything that is promised with a grain of salt... or better yet, test it for yourself. Or don't hesitate to ask.. and we will be transparent about what use-cases are a fit. Which are not. But I, personally think this is a darn cool thing we built. (co-founder here)
We run the cloud solutions (so basically, we provide a business model) for a bunch of mainstream open source PHP projects. Symfony, Magento, Ez Platform ... as such... we are, possibly, not "just another provider" in this space... So hopefully, this news is relevant. If not, my excuses.
You're saying we shouldn't have naked properties, but protect their invariants behind setters and getters. **We agree on that**. I didn't say we shouldn't have getters and setters. I'm discussing an example from OP's article, in which common outside calls to getter/setter are *wrapped* in a dedicated method, for example, instead of this: $stock-&gt;setValue($stock-&gt;getValue() + 10); You have this: $stock-&gt;incrementValue(10); This *can* be useful or even necessary when there is unique business logic in incrementing stocks that you don't want callers to get wrong, or to replicate in multiple places throughout their code. But in the basic case where the wrapping method `incrementValue()` simply does: $stock-&gt;setValue($stock-&gt;getValue() + $amount); And there are no plans to evolve it from that, then this additional method doesn't achieve much.
I've recently started to use it at a new job so admittedly I'm still very new to it all but the biggest thing I've found like a few people already have said is the time it takes to develop when using it and also (i think) most importantly, when to use it. One project I've taken on at my new job was done with 100% CQRS &amp; ES but all it needs is basic CRUD and even then once items have been created, the company we built the site for are not updating or deleting items very often so it's become overkill when we could have used the out the box Laravel Eloquent and controller resources for simple CRUD features, it would have made life so much easier as they have decided on numerous occasions that they wanted new fields on the forms or fields removing, yet ES has made that a ball ache! Of course project scope could change so you made find yourselves in the situation of doing simple CRUD and then finding you need to scale and it would have been better to use ES but such is life and there's no real way around that other than attempting to improve your planning stages so you are able to make a better decision to start with. As with every design pattern, they all have their pros, cons and situations where they are best suited for so half of it, is learning those situations so you are able to identify them allowing you to make the correct decision about which pattern to use.
are you unable to test a class that uses `array_flip()`? it's a globally scoped function... globally scoped functions are not inherently bad, it depends on what they do. They are always bad if they use global state.
Zend actually provides training courses for the Certificate, although they're rather expensive. [http://www.zend.com/en/services/training](http://www.zend.com/en/services/training)
Hey, I'm a Zend Certified engineer, don't buy any courses just use books and play with the language: http://www.zend.com/en/services/certification/php-certification-study-guide https://edward-designer.com/web/passing-php-5-3-certification-exam/ https://github.com/basselin/php-certification-training https://www.amazon.com/PHP-Zend-Certification-Study-Guide/dp/1484232453
The author seems to have avoided describing how this style of code should handle errors. Designing your classes to just do stuff is great. After all, who wants to call `isValid` or `canSave` or `hasSpace` methods all the time? However if you stick to designing your classes in a "tell, don't ask" style they need to have a way to indicate something went wrong. What if the user you're resetting a password for is suspended? What if the disk ran out of space? What if the product is out of stock? What if the shipping address isn't able to be shipped to? Some people like to create a errors property on the class and fill it with errors. However if you take this approach you're simply replacing a method call before the thing you want to do with a method call afterwards. Who wants to call `empty($foo-&gt;errors)` all the time? The correct way to handle this is to throw exceptions. You tell the object to do something, and if it can't be done for any reason it will throw an exception. This exception object doesn't need to be a string with an error warning. They can be custom exception classes that contain an array of messages for the front end. Tell, don't ask is a great way of designing your classes provided you introduce exceptions into the mix.
&gt;I was interessed in taking the Zend Certificate How did you ever end up getting that idea in your head?
I think you are mixing DDD with CQRS+ES, they fit very well together but he is asking for CQRS+ES only. I think the main advantage is performance. your writing side will be focus on write and the read for read. The big downside is a more complex architecture, for small projects without a very complex domain/features maybe is a overkill
That cert is worthless. 
Just to add some pedantry to this sort of thing: &gt; I've noticed is there's no such thing as a CRUD domain There are no 'ES domains' either. There are ES domain models, and there are certainly CRUD domain models, and we use them to model our business domains. Whether it's a good or bad choice in each case is contextual, strategic, and above all has no right answer
There are whole frameworks made using this .. and then all users of one of those frameworks will call the author(s) "gurus". 
I was looking for a certificate for php. That's the only one I found. Why do you say that? 
Could you elaborate? 
global variables are bad, global state is bad. functions can be completely independent of state, and if they are, there is no issue in them being global. what is functionally different between a static function and an array function? Where they reside makes no functional difference.
To an employer (speaking as one), Zend Certification means nothing. It shows nothing about your experience and what you're capable of. Merely that you took the time to get a piece of paper. I'm not saying you personally wouldn't learn anything, and if that's your only goal then definitely pursue it (someone else has linked where to go to find courses). But if you're doing it to help your employment prospects, I honestly wouldn't bother. Instead, spend the time picking up some side projects. Look at other frameworks, learn how they work and what do. Maybe even look at other languages, skills are often (but not always) transferable.
If you have any ideas then provide them, what exact improvements?
The main thing to remember is that no solution is 100% good for 100% of cases. Thus, if you use CQRS and or ES (as both concepts are independent) everywhere, you will most certainly be applying it to cases where your gains are actually negative. Regarding CQRS per se, I've had pretty good practical success by combining GraphQL with a more traditional CRUD pattern (exposed via JSONAPI), where my app clients' can choose what to use for reads based on their own needs and not my imposition. 
We use CodeIgniter as a relatively simple replacement for classic ASP internal (mostly CRUD) applications and it seems to be working well for that. When I went to work on standards for our applications (like naming standards), one thing I noticed about CodeIgniter is that the development group never worked with PHP-FIG at all (making it the only development group for a major PHP framework that didn't, to my knowledge) and didn't make any effort that I know of to comply with basic standards like PSR-1/PSR-2 that most other groups seemed to be signing off on at the time (although some of those other groups didn't sign off on later PSR's that got too restrictive for them?).
They tried out a CodeIgniter-only package management system called [Sparks](https://github.com/seejohnrun/sparks) but apparently abandoned it in favor of Composer, which is good.
You shouldn't have a composer.lock file in a library because you don't actually control what version of any of your dependencies a project will be pulling in, so it might accidentally hide issues which you've introduced by relaxing or changing your version constraints.
Not sure what'd be an objective criteria for determining a "rich domain". But I know things like: - Do I need a definitive history for auditing purposes? - Do I need to easily create multiple projections for reporting and precomputing complex queries in a scalable way? - Do I need eventual consistency (this is more towards CQRS, but it also involves ES). - Do I expect the domain model will change a lot and I want a sure-fire way to migrate from one to another without the potential of losing or corrupting data? - Do I need the business insight that can be gained by tracking highly granular events in time as you can only do in ES?
My [99% unit tested](https://codecov.io/gh/Divergence/framework/src/master/src/Controllers/RecordsRequestHandler.php) static singleton controllers beg to differ. HTTP Requests are singletons and rely on server state. Yea, you can instantiate them but then you have to pass an object around when you want to actually use it. I've been looking at [PSR-15](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-15-request-handlers.md). The concept of passing around a `ServerRequestInterface` object to a handler just so it can access a GET variable strikes me as an anti-pattern. Sure it becomes easier to test but at what performance cost?
All good points and some touch on the benefits ES provides (eg. a free audit log). Obviously there are other solutions to most problems as well (eg. BI/ETL tools, separate audit/activity logs). Checking your events before implementing ES will tell you what is *happening* in your domain. It will give you insight on how affected to changes your model is or if things like eventual consistency are even possible.
Ya know, you‚Äôre right, since this is the core library it shouldn‚Äôt. But once you clone it and start a project then you keep it. My mistake!
You can try Flyimg https://github.com/flyimg/flyimg which provide image resizing, cropping and compression on the fly with the impressive MozJPEG compression algorithm. One Docker container to build your own Cloudinary-like service. 
The only thing that helped me is actually the official study guide. Get that, study it, learn the tricks of the questions, and you got it in the bag! Why did I take it? My employer wanted me to take it since I was the only one who knew PHP there and they had no idea how to measure my knowledge. I would say the test isn't really an accurate representation of skill, rather more memorization of methods and arguments.
What's your objective with this certificate? Are you hoping to land a new job, get a raise at work or build your own self\-confidence?
They are gurus... just of marketing, not programming.
You might want to take a look at [Certification-Competence Correlation](https://martinfowler.com/bliki/CertificationCompetenceCorrelation.html) by [Martin Fowler](https://martinfowler.com). I‚Äòm also a Zend-certified PHP developer(5.5 and 7.1), but nobody ever asked if I was. 
You have to be very careful with what you choose for your aggregate roots. We tried ES where I work and within months we had aggregates with 10,000 events. So to know the current state, we had to load 10000 events and replay them, for every request. This was adding 1-2 seconds for each request plus significant network traffic between the web servers and DB server. Now imagine this in 2 years.. Just not sustainable. Use ES when your aggregates have a very limited set of events (e.g. An order in an ecommerce system could be an aggregate as the life cycle of an order is short).
The search engines sometimes point to a different language page. It could probably use some meta tags.
another vote for phpstan. no ast extension necessary either
preach. compact and extract are brutal
I got my Zend Framework Architect about 2 years ago. The courses were very expensive but I was tutored by Evan Coury, a core contributor. I can show employers that I was, at the time, serious about my learning and knew ZF2 inside out. I'm glad I did the courses and got the certificates as I left school 20 years ago and getting back into exams and the nerves that go with them was a real challenge. I'm sure that some courses are worth doing, and others less so. Their value can only be measured by you and perhaps future employers. Some of whom will see value in them while others won't.
That's interesting. Is there any performance test results?
Imagine if one flag is a superset of other flags: const FOO = 1; const BAR = 2; const BAZ = FOO | BAR; Now imagine combining FOO with BAZ using addition versus bitwise OR...
Quality package. I think I got a use for it. Only thing is, I'm not a big fan of using composer for including enormous mountains of code into my projects. Not to mention, I'm not going to include extra Laravel code for no benefit at all. I have read through your library and it seems I can ditch everything but the License, src/JsonQ, src/JsonQueriable and src/Exceptions/*, so this is probably what I'm going to do. Just in case, anything I'm forgetting that's important for this library to be usable as a plugin?
I use bitwise OR because that's how it's documented and less likely to cause any WTF
Just decode the JSON into an array and use any generic data processing library like [YaLinqo](https://github.com/Athari/YaLinqo). This is reinventing the wheel in a shittier way by limiting it to just JSON.
What's the reasoning there? I understand you don't use the Laravel parts, but why not just bring in the entire package? It's literally just files sitting in vendor. I'd understand if there was some significant performance impact because of the Laravel integration, but that doesn't seem to be the case here.
As someone who used CodeIgniter for years, what framework would you suggest to look into instead?
&gt; There is no reason to commit composer.lock in library. It has no real benefit for the user, might cause some problems in tests down the road. How? I always commit the lock file even in libraries because it helps to recreate the testing setup precisely.
Projects using your library won‚Äôt be respecting the contents of the lock file though, so it kind of makes that irrelevant. Your code should pass with whatever version of the dependencies that satisfies the requirements
Depends upon the utility of the project. If it's a drop-in library meant to augment some partial functionality, committing a lock doesn't make sense, since you've written the code to work up to a specific version and depending upon project requirements you can get into requirement hell where lib A needs an update and lib B, which depends upon a shared requirement by C and JsonQ can't process because JsonQ is locking. Compare that with a standalone application that is supposed to run on its own, then a lock makes sense.
&gt; Just decode the JSON I haven't looked at this specific package yet, but i'm working on trying to figure out a way to avoid this. We are getting extremely large JSON responses from a third party API connection that we have no control over and running it through json_decode kills our applications performance. These responses can be around 10mb+ in size (The biggest we have had so far is 30mb). At the moment we are just throwing resources at the problem which is fine for the short term, but we are trying to come up with a nicer way to handle this. Json decode is not always the best approach.
also: http://jmespath.org/
Bullet #2 may be OK for libraries combined with `~1.0` \(or whatever the major version is\) in composer.json. I don't think it's a good default strategy though, always commit the lock file when in doubt.
That isn't the case for the dev dependencies though.
why so many of you guys have this need to be assholes? even some good feedback sometimes come loaded with gratuitous snark. c'mon guys! this is not how a community is built!!
Steaming JSON. You can still use YaLinquo because it operates on traversables also.
holy cow, can I ask what the use case is for JSON responses that big? We've used [MySQL's JSON data type](https://dev.mysql.com/doc/refman/8.0/en/json.html) in some places, but those are some real real big documents. 
Searching for hotels/flights in big cities, like Paris and such.
I like the concept. I would normally decode the JSON and bind it to a Symfony ParameterBag, essentially making it queriable. It's not the *best* method, as it's intended for HTTP but it works.
Likely the configuration. I had some horrible performance until I turned proxy_buffering off. There are likely also issues with thread pools and keep alive holding back the performance. 
And it has a well needed design refresh to get it up to date with the look of other Google products.
Yes, there's a PHP implementation, among other languages. The AWS SDK (the PHP one at least) uses this internally so it's solid.
My bad, I've been just a tap away but cannot found the libraries link first.
They work the same in this instance, because the developers chose values of those constants (they're just integers behind the scenes) that end up being the same regardless of the operation. In this context, JSON_UNESCAPED_SLASHES (64), JSON_PRETTY_PRINT (128) both add/or to the same value. (64|128) === (64+128) === true If you know how bitwise OR works behind the scenes you can imagine scenarios where it gives a different result than addition. 0011 (decimal 3) OR 0101 (decimal 5) = 0111 (decimal 7) 0011 (decimal 3) + 0101 (decimal 5) = 1000 (decimal 8) // Different to the prior result 
Cool project.
To give a more real world example to what Sara already explained: If you're absolutely certain that each flag is only added once to your mask, you can use an ADD operation. Otherwise, an OR operation is required. E.g.: I have an option called human readable, which is the combination of JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_UNESCAPED_SLASHES | JSON_NUMERIC_CHECK. If I add that to my mask and later on some code says it wants to add the JSON_NUMERIC_CHECK, then by ADD operation, the JSON_NUMERIC_CHECK is added twice, resulting in a wrong mask value. When using an OR operation, assuming all flags are multiples of 2, the mask will not have this problem and when reading the options, json_encode properly reads your mask. This goes wrong when using an ADD operation.
This is really cool to know. Awesome insight Sara :)
Hats off for taking the time. Maybe you want to take a look at [How Company Frameworks Increase Technical Debt](https://www.petermorlion.com/how-company-frameworks-increase-technical-debt/) by [Peter Morlion](https://twitter.com/petermorlion/status/1001351790246481920)?
What exactly is it supposed to do? It's endlessly loading for me and there is a message on the right hand side that makes no sense; &gt; on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)abort("on the web, we need the wasm binary to be preloaded and set on Module['wasmBinary']. emcc.py will do that for you when generating HTML (but not JS)"). Build with -s ASSERTIONS=1 for more info.
It's a tool to run PHP code in the browser, like 3v4l, but without server interaction. See this screenshot: https://segmentfault.com/img/bVbbuXe?w=1470&amp;h=731 It's seems that browser didn't load the wasm file ccorrectly. What's your browser?
Google Chrome
What should I not be doing?? I want to sell a script simple. Just pass by if you're not interested and let interested buyers bid. 
Oh, but what it _could_ do is run preprocess.io code without the docker containers running behind it...
I'm using Chrome 67.0.3396.62. Currently, I can only reproduce the error message by block the network request to https://oraoto.github.io/pib/php.wasm . Can you open this link directly in the browser? 
Can confirm. Is scuffed.
Oh no, I made PHP not portable between browsers :(
It runs well when it loads. I wonder if there is a way to reduce the size of the php.wasm file.
This is pretty cool. I wonder if one day we can use PHP on the front end and the back end...
A doggy?
chnagelog: [https://blog.phalconphp.com/](https://blog.phalconphp.com/)
Just knowing that this is possible is getting me excited. Think of all the applications; for things like mobile PHP IDE development or browser compiler generators for PHP, or kid-friendly teaching tools...
:\[ full stack is not single stack ;P
Anything but Javascript please.
Maybe throw it into sqlite database and then query using https://www.sqlite.org/json1.html.
Also dead for me, runing Chrome 66.0.3359.181 It does seem to have failed to fetch the wsam file.
How do you suppose I could intercept calls to `require`, `include` etc. so that I could bundle other source code files into JS and run them through the converted interpreter? 
Sure functions can represent almost the same code. But functions in PHP do not have full type \(e.g. you can't typehint after function that takes Person, and returns Age. But you can have class that implement such interface. Thus it looks fishy if you need multiple classes in your code in no more then 0,01&amp;#37; of cases.
If I open [https://oraoto.github.io/pib/](https://oraoto.github.io/pib/) it downloads the file. But when opening the page it is blocked. I think uBlock origin doesn't like it: [https://i.imgur.com/pe1yOvC.png](https://i.imgur.com/pe1yOvC.png) Turning off uBlock origin fixed it.
Emscripten support filesystem emulation, and all libc call to the filesystem will handle by Emscripten. 
I have ublock too.
How big? With pwa you get 50MB om the user machine..
Just like Laravel and Symfony certification, Zend certification really is pointless. Any decent employer will base their hires on real experience, not the fact that you were willing to throw money at a corporation to give you a pdf saying you can code.
It's actually works!!! Try [this code](https://oraoto.github.io/pib/?code=%253C%253Fphp%250A%250Afunction%2520xrange%28%2524s%252C%2520%2524e%29%2520%257B%250A%2520%2520%2520%2520for%2520%28%2524i%2520%253D%2520%2524s%253B%2520%2524i%2520%253C%2520%2524e%253B%2520%2524i%252B%252B%29%2520%257B%250A%2520%2520%2520%2520%2520%2520%2520%2520yield%2520%2524i%253B%250A%2520%2520%2520%2520%257D%250A%257D%250A%250Aforeach%2520%28xrange%281%252C%252010%29%2520as%2520%2524x%29%2520%257B%250A%2520%2520%2520%2520var_dump%28%2524x%29%253B%250A%257D%250A%250A) Previously, I run the same code, a longjmp error comes up in the javascript console.
If you're using snapshots, you're asking a domain object to retrieve its state which is then saved in the DB. And if you're doing that, imho you're losing one of the key benefits of ES which is to avoid the object-relational impedance mismatch. 
I compiled it with assertions and it works with generators locally.
The later versions \(es6\+\) are delightful. 
Full stack is essentially just front end + backend. So in my cheeky shitpost example, that would be JS + NodeJS üòâ
"New developers who want to add PHP to their tool aresneal"
As neat as this is, it's really important to know that this won't result in a valid UUID (based on the specification).
Sure, but I wonder how often you'd want UUIDs just for the sake of being UUID ;)
Right, people want UUID for all their other properties and benefits, not just for looking nice.
The same can be said about random_bytes() and a little bit more so. The security part here affects also the collisions, with (proper generated) UUID4 you see a collision about after creating 2^61 UUID4's, with the random_bytes() example you see a collision after about 2^64 outputs. While the difference is inpractical, but it is good to remember UUIDs won't save you from collisions more than 16 random bytes (as above said, you'd need "more" collision checking with UUID4 than with 128-bit random number).
Could you give some example where UUID would be better choice? Of course something else than "this protocol requires UUIDx formatting".
Why, though? Why bring in files that have absolutely zero value to me?
If all you're doing is using v4 UUIDs, and will continue to in future, sure. UUIDs can: * Be stored alongside v1-3+5 in a column, without colliding (guaranteed) * Have cross-platform tools for e.g. converting between byte and string representations * Have a recognised format so they can be more easily used in data interchange
Now I'm not saying I have a particular preference about CQRS+ES but I do want to chip in into these "problems" &gt; Your application crushes and now you have to restore all entities. Assuming that you have snapshot every 1000 events you have to apply around 1000 events to each entity to restore application state. Might be painful but the fact that you can re-build your entire state from scratch is one of the advantages of ES. Assume your CRUD app crashed: you are basically f***ed now. Also depending on the technology used, rebuilding state _can_ be pretty fast. &gt; In PHP it‚Äôs tricky where would you store entities. Don't know why this would be a PHP specific problem &gt; You can‚Äôt just store them in RAM Why not? &gt; What when you are forced to scale up and you just add read replicas and something terrible like replica lag happens? Some processors now validated requests based on old entity state. This is not an ES problem. This is a scaling/Eventual Consistency problem. &gt; Frameworks like Lagom based on akka stack use actor pattern to ensure location transparency and to be sure that each entity is processed just by single actor in the same time. While Lagom is (very) nice, it introduces a giant pile of accidental complexity which in my opinion, is irrelevant for 99% of the projects out there. ES is hard enough as is, don't need to make it even more complex by solving distributed problems that won't exists for most use cases out there. &gt; Beside all this distributed system problems there are also legal ones. Actually in my opinion ES can solve this quite elegantly. Only save reference id's to user specific data, and store that outside of your event stream. 
same issue, latest firefox
A little under 10 years ago, I wrote the **Don't Ask; Tell** article on Encapsulation.... http://www.phpu.cc/books/phppro/solid_oop/encapsulation
Not sure about these benefits. PHP has bin2hex() and hex2bint() (can convert between byte and string presentations). Also, recognized format as UUID, but I'm not entirely sure does that make anything more clear in THE APP's data interchange (its' just an UUID for the app).
You can just ignore this message as long as the Run button shows up. If the button is Loading forever even you refresh the page, it's truely broken :(
Hey, oraoto, just a quick heads-up: **truely** is actually spelled **truly**. You can remember it by **no e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Um. There are several different types of UUIDs. One common type is v4, which is, yes, 16 bytes long and has 122 bits of entropy, and yes, you *could* easily replace that with 16 bytes of randomness if you have no particular desire to follow a standard, interact with systems that are expecting actual v4 UUIDs, include any sort of versioning info, have no need for some of the niceties (type hinting, etc.) that a good UUID library provides, and feel like the extra 6 bits of entropy is somehow critical to your application. So sure, it'd be accurate to say "in many cases you can just do `bin2hex(random_bytes(16))` to get a kinda UUID-ish string instead of generating a proper v4 UUID". &gt; UUIDs are obsolete Well, no. There's a reason why UUIDs are a standard, and the standard isn't "slam 16 random bytes together and go home". If you *personally* don't need that standard, then it's not useful *for you*, and never has been. That doesn't mean they're obsolete. Databases aren't obsolete just because your app can get away with storing some info in a flat text file. But if you *can*, sure, knock yourself out?
UUID4 *is* a bunch of random bytes. Other variants of uuid are more interesting because they're tied to a MAC address or a domain, so you can generate one, make sure it's unique on your machine, and have the absolute certainty that it's unique for every other machine without needing to access them.
Guidelines: * If you need a unique ID, use `bin2hex(random_bytes(16))`. It's simple and strictly better than UUIDv4. * If you need to interoperate with UUIDs, use UUIDs. Duh.
Do you know the algorithms used to generate UUIDs? The chance for collisions is not only based on the number of bits a UUID has. Take Unix timestamps for example, they also are only a 32 bit value, bit if you "generate" one each second you have a collision chance of exactly 0% - ofc, this is highly simplified, but a similar thing counts for UUIDs.
Every time you need a unique identifier, like when adding stuff to a DB.
Every time you need a unique identifier, like when adding stuff to a DB.
No uuid is timebased random bytes can generate duplicates &gt;2
In such case random_bytes() way is better.
Update: 2 months on from when I posted this and I've come a long way. I've done a heap of different things to the site e.g. completely reworked the filters, new property page, new lightbox images, event logging, etc. Over a hundred commits since then. But, more than anything, I've got some customers. I've had just under a hundred people sign up and just under half of those have listed a property so it's coming along well. https://peoplelikeus.world if you want a look. Thanks to everyone who offered opinions when I posted this. It helped a lot.
Yep, the difference is inpractical. I wrote it because often has been said "UUID4 doesn't have collisions while random_bytes() do" (like in this very thread already has been said that). Interop is a solid reason, but like the case with DB ids which was recently blogged about, it is not an issue (random bytes would be a better fit).
Yes, I see it's becoming Python \(which is not a bad thing\).
The odds of collisions is negligible for all intents and purposes.
&gt; but like the case with DB ids which was recently blogged about, it is not an issue (random bytes would be a better fit). I didn't read the linked blog about db ids. But if it's about performance random ids like you are generating have the exact same problems (it's a "long" string and it is random).
&gt; A bunch of random bytes.... not so much, you'd need extra "does this ID already exist" checking, which makes much more complicated to use than just generating a UUID. Or you can double the size (`bin2hex(random_bytes(32))`) and you can expect a birthday collision after 2^128 versus UUID's total keyspace of 2^122.
Not necessarily - if you use the UUID type ([e. g.](https://www.postgresql.org/docs/9.1/static/datatype-uuid.html)), it would be foolish to not use a proper UUID, as you might get problems
Here is the full change log: https://symfony.com/blog/symfony-4-1-curated-new-features
Not with random bytes. Id generation should chevk for existance
Hey, remco\_cloud, just a quick heads-up: **existance** is actually spelled **existence**. You can remember it by **ends with -ence**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
The odds that a cosmic ray flips a bit and makes the id check function return the wrong result are orders of magnitude larger than a collision of a properly generated 128 bit random number.
That post talks about something I already inherently understand. That's kinda why I had to spend the last 6 weeks unit testing this code base and writing documentation. There's a ton of sites still using it. To be perfectly honest though I really enjoy using my framework since I know it inside and out unlike the major others out there. I do want to make it PSR compatible though.
The leak is because you are not freeing the result of the call to zend_eval_string ... because you can't, because you can't define a zval (I don't think) ... A solution is to write a single C file link it to embed, call (or exports) startup/shutdown, and export a function that calls zes and free's the result ... I can't get this to compile locally, because of undefined function warnings (explicit_bzero), and missing networking functions (dns stuff). I saw you mentioned ditching networking/streams/etc to make the binary smaller ... and I wonder, without that stuff, how useful is PHP ?
Honestly, it is not even a question in 2018. A notice is an error al the same. Using undefined variable is a bug. Period. 
I code by the motto "warnings are errors". I keep notices/strict settings turned on in both my dev environment and IDE, and eliminate any warnings that appear. Side note: Inconsistent formatting aside, highlighted (warnings on) lines in the editor make it embarrassingly easy to tell which of my colleagues *do not* use a proper IDE.
For a single ID, yes. But what happens when you have a million+ IDs ?
Thanks, I was looking at some Github documentation last night but never saw this key piece: &gt; If you don't have write access to the repository where you'd like to create a pull request, you must create a fork, or copy, of the repository first. For more information, see "Creating a pull request from a fork" and "About forks." So what I need to do is fork the project to my Github account and then create a pull request from it.
phpStorm does it well and then you can also have static analysis tools like vimeo/psalm or phpstan/phpstan which are both really cool for that
&gt; Should I develop with notices turned on? Yes, if you write code that doesn't work the first time you run it, often there will be notices that let you find the problem fast, debgugging without notices is slow. Fix the notices, and don't use @ everywhere. &gt; Is being able to use undefined variables a feature or a bug?? Feature. But Notices are features too.
Every IDE has "linters" and/or a "problems views" that give you warnings about detected problems in your code. I haven't used VS Code for PHP (I do use it for TypeScript), but as I understand it, [the PHP linter is installed by default](https://code.visualstudio.com/docs/languages/php). If it is working, you should see a red dot to the right of any problematic line in an open file, and problematic files should be red in the side bar.
It starts to matter roughly when you have 2^64 IDs (million+ has nothing to do witch such scale).
I'm using php-cs-fixer. VSCode is great at intellisense &amp; phpdoc and it works quite well. It's also picking up syntax errors no problem. [Screenshot](https://i.imgur.com/42N2fKm.png) [Peek Definition](https://i.imgur.com/8VqWKBQ.png)
This is a good point. I'm not familiar with Postgre UUID, but I think there is not much difference between indexed UUID column or something like indexed CHAR(32), or even BINARY(16).
Run at -1 (E_ALL these days I think) and see what happens. Most libraries these days are pretty good and don‚Äôt spew garbage; those that do often have alternatives. If you‚Äôre feeling ambitious, set up Phpstan or Phan too - they can help catch errors before you‚Äôve been run your code. They‚Äôve saved me plenty of headaches. 
 `&amp;&amp;` is not doing what you think it is there - that will evaluate to true and get run as whatever constant has 1 as its value. You should use `|` which is bitwise OR when combining flag values like that. 
lmao! Thank you actually this has been nagging at me for a while. I knew something was wrong with it but I couldn't quite put my finger on it.
Browsers are quite limited, all networking must go through XHR and websocket, all file must be embed and pre-loaded, and there's no signals at all. To actually make a client-side application, the most needed is a proper interface to the JavaScript world rather than all the server-side stuff.
WebAssembly: Modern ActiveX(or whatever plugin you like).
Hey there! My name is Alexandria, and I represent AmeriCommerce. We may be able to provide eCommerce software in a way you haven't seen before. Our customer support always answers the phone and they're super helpful, and we also have instant messaging on the site if you have questions about anything you see. We also have a free 14 day trial that gives you ALL the capabilities of a paying customer to see if we really are the right option. americommerce.com/features Check us out!
Check this https://getcomposer.org/doc/02-libraries.md#lock-file
Glad to help! That's the kind of thing that the static analysis tools I mentioned in my other comment helps catch, by the way (though I have no idea if they'd get that specifically)
Your title says "UUID are obsolete" and then recommends UUIDv4. Doesn't follow logically. And if you're trying to say "UUID standards other than v4 are obsolete" than that's clearly incorrect. UUID are a set of standards and when you need to participate in a pool of UUID of a specific version and they require that version, then you need to produce that version, because if you don't, they'll kick you out. Some UUIDs have meaningful data in them like MAC address. You can't just ignore that and use random bytes. You're not compliant. Some UUIDs have a namespace component (say your company), which is registered separately. You can't use random bytes and therefore use unregistered namespaces, or someone else's namespace. You're not compliant. So before you say "KISS", maybe "DYRS" (Do Your Research, Stupid).
Start from reading this very page
Maybe give a try to laracats, It's php/laravel/vue learning site. For free courses you can try Brad Traversy on youtube :)
Because it takes actual effort for you not to. You need to find another package to use \(when the better one might be tied to Laravel\) or fork it and remove the stuff you don't want. The files do literally nothing but sit there on the disk. It's not even using a lot of disk space, a few megabytes at most perhaps.
1. this question should be deleted from here and asked in /r/phphelp 2. storing long arrays in a file is not the best idea. lacking the context, though, it's hard to offer any other solution
Nit for the author of the changelog: Argon2i isn't encryption. You shouldn't be [encrypting](https://paragonie.com/blog/2015/08/you-wouldnt-base64-a-password-cryptography-decoded#passwords) passwords.
&gt; These responses can be around 10mb+ in size (The biggest we have had so far is 30mb). Am I the only one here who thinks this API you speak of should provide a better way to extract/deliver datasets? Transmitting 30mb of JSON-formatted data in a single request seems like a horrible idea to begin with.
Session data is stored on the file system at a location set by session.save-path in your php.ini: [Reference](http://php.net/manual/en/session.configuration.php#ini.session.save-path) You can check the size with `du -h /directory/` Whether or not it's slow or not depends on your server's hardware and load.
No one's gonna do your homework for you. Go to /r/phphelp for this type of thing.
i thought it was stored in ram because its temporary
It's a Symfony thing. All the way back in 2.0 they called the main hashing class PasswordEncoder since technically it can be used to encode passwords as well as hashing them. Just one of those historical things not really worth fixing.
You should be using PDO. 
Session is stored wherever you please. You can implement the [SessionHandlerInterface](http://php.net/manual/en/class.sessionhandlerinterface.php) class and use whatever storage you damn please. However, it is accepted as a bad practice to store too much data in the session. This data is prone to erasing, big time. Whether your users delete a cookie or just switches browsers, the session data would be toast. To answer your question, it probably won't have significant effect on the server compared to other methods, however, it's a bad practice which introduces code smell. Re-structure your application. 
It is usually stored in the /tmp/ folder which is meant to be temporary but usually is only cleared on restart. I'm not sure about the rules surrounding how linux deals with the /tmp/ folder but clearing the data in it is largely a result of the Linux kernel and the distro.
Except it is worth fixing, going forward. People who think "encrypting passwords is the correct thing to do" will end up doing something like [this](http://www.cryptofails.com/post/87697461507/46esab-high-quality-cryptography-direct-from).
Hello Everybody I'm a PHP Developer and would Love to help and Join a Project I'm doing this for Experience \(so not for money\) If you are Interested please PM me
Yes there is. You get type safety. Same reason why postgres has types for things like ISBNs.
session data re not "temporary", for obvious reasons.
Thank you. Alright, I've implemented the cookie auth, but I've run into an issue I don't quite understand, would you be able to take one last peek and see if you can see where I messed up? The issue: After opening the site and being logged in for a while with no activity, all of a sudden i get a lot of errors about vars in steamInfo.php not being set, along with $_SESSION['steamuid'] not being set. I haven't touched this file at all, and the issue started today. Also, I was still logged in and could browse around. Also, the debug var (as set below), "$debug_login", was not set either. Logging out and logging back in fixed it. This is my login_check.php: require_once ('./steamauth/steamauth.php'); $allowed_uids = array( "765611xxxxxxxxxxxx", //user1 "765611xxxxxxxxxxxx", //user2 "765611xxxxxxxxxxxx" //user3 ); if(!isset($_SESSION['steamid'])) { if(isset($_COOKIE['cauth'])) { $cookie = explode("|",$_COOKIE['cauth']); foreach($result_staff_arr as $staff){ if(($cookie[0] == $staff['uid']) &amp;&amp; ($cookie[1] == $staff['cookie_hash'])) { $_SESSION['steamid'] = $staff['uid']; $debug_login = "DEBUG: auth=cookie"; } } } else { header("Location: ./login.php"); exit; } } else { if((!in_array($_SESSION['steamid'],$allowed_uids)) or (strpos($_SESSION['steamid'], "7656") !== 0)) { header("Location: ./login.php?denied"); exit; } $debug_login = "DEBUG: auth=steamauth"; } include ('./steamauth/userInfo.php');
It's possible. I've seen a site that stored several MB of data in each users session. Every time they logged in it would tons of shit from the database and put it in `$_SESSION`. As a "fix" for sessions disappearing too soon a previous developer increased the session lifetime and it got to the point where the sever ran out of disk space due to PHP session data. That was a joy to debug.
Reverse ChoosingBeggar
I'm guilty of creating meta_data fields in relational databases to store various configs. Kinda my own way of having my cake (nosql) and eating it too (sql). I generally use this on settings type data that I don't think will ever need to be queried, but with this... What I am trying to say is I love this.
Thanks for sharing. The mailcatcher ruby gem broke on my system after upgrading to Ubuntu 18 and now I have unit tests failing because of it, sigh. It might look at implementing this if I can't get it working.
https://github.com/silviodelgado/flywork Help is welcome.
I recommend first learning very basics, it's not that hard to get grasp about syntax and basic commands. Most of stuff you do is really small set of things, loops, conditions, basic calculations, string manipulations, dates, database queries, etc. and those are fairly easy to learn. After learning basics, what I would recommend is start a small project that is interesting for you. When I was learning, I made web based role playing character sheet. It wasn't much but it was still good learning experience with data sanitation, validation, and framework basics. And most importantly, I was really into doing it cause it was something I enjoyed. Important thing is that you do things that you find fun. I have seen so many abandoned projects cause people just picked "just something" and they wasn't enjoyed doing it. Problem based learning IMO is really good way to learn more advanced stuff and even some basics, but problem should be realistic and interesting. Also most people learn different ways, if you learn better by reading, read guides, if you learn better by watching and listening, use video tutorials. If you don't know what's suits you, try bit of everything and see what works best. Lastly, PHP documentation is always your friend, don't hesitate to read and check things from there.
Welcome to corporate. Lol
I've fixed my patch to readdir_r, and it can do filesystem access now. [Example](https://oraoto.github.io/pib/?code=%253C%253Fphp%250A%250A%2524it%2520%253D%2520new%2520RecursiveIteratorIterator%28new%2520RecursiveDirectoryIterator%28%2522.%2522%29%29%253B%250A%250Aforeach%2520%28%2524it%2520as%2520%2524name%2520%253D%253E%2520%2524entry%29%2520%257B%250A%2520%2520%2520%2520echo%2520%2524name%2520.%2520%2522%253Cbr%252F%253E%2522%253B%250A%257D%250A%250A%2524bench%2520%253D%2520file_get_contents%28%2522Zend%252Fbench.php%2522%29%253B%250A%250Avar_dump%28strlen%28%2524bench%29%29%253B%250A%250A%252F%252F%2520include%28%2522Zend%252Fbench.php%2522%29%253B%250A)
Indeed there is the flexibility which is not the case with UUIDs. I'm not sure why such a simple and guaranteed to be unique approach seems to scare people here. A few good points have been brought up regarding UUIDs (Postgre UUID type), but other than that (like IDE autocompletion), I'm not sure what's the problem.
I guess someone will eventually compile Firefox to Wasm and run it in Chrome...
Yes, develop with full debugging on, fix what you see \- makes for a much more reliable piece of code. If your functionality relies on a variable being undefined, and someone goes and updates that later because they have a different \(better?\) approach to error handling, it could well break something.
Even if its not stored into the session in every request, a large $_SESSION can be a drag on performance, because PHP calls `serialize` and `unserialize` on it in every request. If the payload is a few MB large, then this can take a noticable amount of time. If you are running a Profiler on your code, you can see the performance by looking of the duration of the `session_start()` function and in case of writing into the session you should make it explicit at the end of your request by calling `session_write_close()`, then you can see this performance in a Profiler as well. In combination with the fact that the session PHP module acquire locks to enforce sequential access to the session, if you are using Ajax requests a lot with a slow session, each ajax request to your application will become much slower and block the following ajax requests.
Hey, beberlei, just a quick heads-up: **noticable** is actually spelled **noticeable**. You can remember it by **remember the middle e**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
Nice to see dd() made it in!
https://github.com/bandwidth-throttle/token-bucket/issues/19 https://github.com/bandwidth-throttle/bandwidth-throttle/issues/3
I don‚Äôt see anyone scared, besides OP. 
I'm not sure what is the problem you think we think is the problem. Or why do you feel the need to say a standard in wide use is "obsolete" simply because you don't *have* to use it all the time. There's place for the entire range of solutions.
The place is not a matter the thing is important. Learn basic script first and make a work on it. It automatically pulls you to a next step.
I don't know anything,should I start with some basic.
Obsolete is of course a strong word to use here, but it looks to me UUIDs are overused. When unique identifier is needed, naturally UUIDs comes to mind. Simple fact is random_bytes(16) is better for that purpose.
An error occurred during a connection to elysiumpro.in. Peer‚Äôs Certificate has been revoked. 
PHP-CS-Fixer is a really nice project to contribute to
It looks like JSON is imitating XML :P * JSON Schema / Swagger =&gt; XSD (XML Schema Definition) * JsonQ / JMESPath / JSONata =&gt; XPath * JOLT / JSONT / jq =&gt; XSLT Transformation * JSON Feed =&gt; RSS 
http://www.phptherightway.com/ Is a very good resource to learn PHP and learn the best practices of using it. I also saw that /u/diegatt suggested laracasts, I also rate that as a very good resource for learning PHP. There is also a subreddit dedicated to helping people if they are struggling with specific php problems /r/phphelp Best of luck learning :) 
&gt; It's a Symfony thing. Ah, the Laravel excuse. :-/
Yes, exactly. Let me know if you need any help with this. I'd be happy to help you to start contributing.
The Symfony team is pretty good about accepting pull requests. If you feel strongly about the name and the docs then feel free to submit one. And while it would not take a whole lot of effort to add an encoder that does something like your link, I'm pretty sure most developers just use one of the built in classes.
do you have Discord ?
??
How are we gonna Contact in Real\-Time
TL;DR; Make personal projects an try to use the new stuff on them. ------ Most of the things you named were born in different years. If you don't know nothing, is hard to get "up to date", but you have to remember, sql injection is not "a thing" anymore, yea, still a security concern, but most frameworks/library you use comes with free protection (Y). This happens with most topics. Before docker we had Vagrant, before Vagrant we had virtual machines, before that we had, nothing... Ajax, Media queries are things you learn on web development (they're not like "staying up to date" now they're part of the basics and should be in any php/javascript/css course for web developers). Answering to the question, how do I keep to date?, [1] I follow some people on social media (like jeffrey way, webos, etc.) who run screencasts. When they share something I haven't eared before at least I try to understand what's about. (of course this don't make me stay up to date). It depends: - PHP is my main language. I try to stay always up to date in PHP, each 2-3 months I read the news RFC and if any of them has changed they'r status (Now there are a lot of blogs who shares resumes of this). When a new version of PHP came out, I try to migrate what I can to the new version and use the new features. - ¬øAnd with anything else?, Whe there are technologies I can't use at work (like js front-end libs/frameworks like react, angular, vue) I just try to use any of them in my personal project, as I know from [1] what are the "new things" I can try then in personal project.
There are lots of possible answers to this question but I would recommend in particular: 1. join local user groups and attend meetups \(I went to PHP user group meetup last night\) and 2. attend conferences. These are the best places to stay abreast of evolving technologies and give you a good gauge of how your expertise compare to other professionals and where you might be lacking.
Read PHP updates documentation, follow blogs of well-renoun developers, see what new Github PHP-trending projects use, get involved in online discussions.. etc. 
Help is welcome... https://github.com/like-it/Priya or https://priya.software 
I think one can achieve this "compare to other professionals and where you might be lacking" without attending to meetups/conferences. I attend a local meetup, I had such a great time there, but, I don't feel they have give me what you meant :(, Internet seems to be just a lot more efficient.
it's not really an either or. Reddit is a great source of info on new evolving tech, but there is particular value in sitting down with other professionals who do a similar job to you, with similar challenges to you and just chatting about how they overcome them. The reason a lot of developers get stuck in a rut is because they only learn about new things by searching for them, and you only search for things you already know about. I go away from every meetup or conference having learnt something new.
&gt;If you don't know nothing, is hard to get "up to date", but you have to remember, sql injection is not "a thing" anymore, yea, still a security concern, but most frameworks/library you use comes with free protection \(Y\). This happens with most topics. You can't be serious? Even if your library protects you in the majority of cases, you still need to know how SQL injections work and how you can prevent them. The same applies to XSS and friends. If you blindly trust your framework/library, security vulnerabilities are almost guaranteed \(from experience\).
&gt; Each framework has its pros and cons. Some developers even suggest not using frameworks at all because they consider that all of them suck. I lean more towards this opinion, but I've been trying to keep an open mind and think 'within the box' of these frameworks. The problem is, you're essentially thinking inside the box, rather than free to implement a minimal amount of code to utilize a maximum amount of performance. Personally, there is a neurotic/ocd tendency within many of these frameworks, PSR*s and other projects that, while suit their purpose, are quite obnoxious and constraining. Then you get people who chastise "NakedPHP", so either way, you should think for yourself, and not about "What's cool this week". Unfortunately, if you're looking for a job these days, you're going to have to be prepared to deal with Laravel egotists and their "randomly abstract unique" neurosis. =P Let the down-votes begin! =P
With regards to web application security, check out [Top 10 OWASP](https://www.owasp.org/index.php/Top_10-2017_Top_10). While the PDF itself isn't comprehensive alone, there are links on each point to more documentation to better understand the specific vulnerability.
I have mentioned this [before](https://www.reddit.com/r/PHP/comments/655rn3/stay_up_to_speed_with_php_by_reading_these_feeds/dg7t76k/) but will share again because it has always been so useful to me. Instead of spending time foraging for info, I subscribe to weekly newsletters that are relevant to what I am interested in like [PHP Weekly](http://phpweekly.com) [(latest issue)](http://phpweekly.com/archive/latest.html), [FrontEnd Focus](http://frontendfocus.co) [(latest issue)](http://frontendfocus.co/latest), and [Web Operations Weekly](http://webopsweekly.com) [(latest issue)](http://webopsweekly.com/latest) and have about 100 curated articles/posts each week ready to pick from. The [Cooperpress](https://cooperpress.com/publications/) website has a bunch of additional languages and topics that I didn't list here. Also, check the "Awesome _____" projects on GitHub and subscribe to their repos for updates. For example, [Awesome PHP](https://github.com/ziadoz/awesome-php) and [Awesome Docker](https://github.com/veggiemonk/awesome-docker)
Excellent thanks 
That make's me think: maybe I haven't engaged correctly with people on meetups. Maybe I'm not getting most of the meetup I have went to. Gonna try to engage more next time.
thank you!
I think everyone drifts away from hobby programming. I wouldn't worry about it.
There's three levels of knowledge, maybe ~~4~~ 5 you should really care about: 0. I know this software's purpose/goal/utility. 1. I've set up this software + run it, and understand its general architecture. 2. I am confident enough in this software to put it on my resume. 3. I have mastered this software. 4. I contribute to this software's ecosystem/community. Learning something like Jenkins to level 1 takes maybe 3-4 hours, to level 2 takes 10-15 hours, and to level 3 maybe 50-100 hours. The beauty of the modern Internet is that if you've got a whole bunch of software to levels 1/2, Google can be the glue you need to help with implementations, etc.
How is modern Symfony? Is it still a thick/heavy framework, or has it learned from Slim/Laravel/etc on being more lean? Anyone have a good URL for comparisons with Symfony 2?
Symfony 3 and 4 are still the same fundamentals as Symfony 2 with some added sugar to make things easier (`MicroKernelTrait`, autowiring in the container, etc). Laravel isn't *lean* as much as it favors convention over configuration. Symfony is the opposite: lots of configuration, very little strong convention. Whatever convention is in symfony tends to be a moving target -- do we even `AppBundle` anymore? I personally like Symfony, but it took a lot of fighting with it to get to this point.
Yeah that's what i was thinking as i navigated through this...
&gt; My IDE slows down around that crap :D How is that a reason to remove something. Get a better IDE
Man, this ran me through a 2 hour rabbit hole. Damn you!!!!
The laravel/laravel "starter" is opinionated toward things Taylor feels most sites will end up setting up and using by the time all is said and done. The Symfony skeletons are opinionated toward giving you just enough to get going and leaving you to add the rest. So yeah, Laravel's base install is heavier, but it's two different approaches and IMO there isn't anything wrong with either (and I'm saying this as someone with production apps based on both frameworks, so I'm not trying to fanboy either one here).
This... I've got various personal/side projects and they're what keep me "young". When I see something new that I want to try/play with - to the side projects I go. There's typically somewhere I can apply the cool new thing - if not, I probably don't need it.. or I need a new side project! :D (If only I had time these days)
So I said the exact same thing as you yet you down voted me. Laravel comes with way more things and is heavier from the start.
yeah, let's just not allow you to post anymore
You would put something on your resume after 10 hours of it? And say you've mastered it after 50 hours of using it? Wow.
I'd say Symfony is still the leading framework when it comes to OOP and best practices. Also it's very lean and fast since it uses a compiled + cached container+routes. With Flex your app is completely empty without any bloat (which Laravel is).
Maybe try some new frameworks or even languages? I know that I love learning new stuff, and this keeps me coming back.
I've just created. But my english is poor. Hope we can communicate fine. My user is silviodelgado
Their language is they "have mastered this software" in "10\-15" hours, not 50.
Obviously being subscribed to this sub. I'll add[ Hacker News](news.ycombinator.com) while not PHP, certainly a good mesh of tech and happenings in silcon valley. Hacker news its actually my default homepage so I skim through it each morning.
If I could ensure that new developers knew at least one thing that would save them a lot of pain it would be: How to normalise a relational database: https://msdn.microsoft.com/en-us/library/cc505842.aspx If you're not normalising your data then you're not using a relational database properly If you're not using SQL properly then it's going to fuck with you and you're going to jump to some silly ideas like "SQL is slow" or "SQL isn't flexible enough" If you believe SQL is slow you'll do dumb shit like install a NoSQL solution/cache, and then try and use those systems for relational look ups, then that'll start going slow, so you'll throw some more EC2 instances at it and put it behind a load balancer And before you know it you're desperately trying to keep two data sources in sync, burning money into hardware that can only get you so far and the moment the cache needs to be flushed your application falls apart
to answer your actual post, read hacker news and lobste.rs, unfortunately they so rarely post the helpful things like how to do indexing, or measure performance effectively or speed up your workflow but it will keep you abreast of new tech
php weekly is surprisingly good!
I don't know why php\-fpm keeps terminating children. This is causing my service to be unavailable! Does anyone have recommended reading on demystifying PHP\-FPM?
In your PHP FPM config did you configure these settings? pm.max_children = 50 pm.start_servers = 5 pm.min_spare_servers = 5 pm.max_spare_servers = 35 
In your PHP FPM config did you configure these settings? pm.max_children = 50 pm.start_servers = 5 pm.min_spare_servers = 5 pm.max_spare_servers = 35 
Does anyone actually find any worth in this sort of books? Like apart from "High Performance Images" they all look like your basic reference manual + blogpost-worth amount of additional commentary. With both reference and commentary being outdated few months after publication. Don't get me wrong, there are a lot of good and really useful programming books, but all of those "$c Cookbook", "Learning $c", "$c definitive guide"... ($c being a specific technology/language) Does anyone actually find them useful at all? 
no i have 10 max\_children but regardless, what causes the children to terminate? that's the main thing i'm wondering. in apache, even fatal errors would end the current request, and the next one in line would go though; it didn't cause the entire server to terminate i read that logrotate sometimes terminates the children, any idea what else causes them to die?
It will terminate existing fpm processes to serve new ones so you are just filling the max and then it's killing the old ones in the middle. Increase your limit. Make it like 500. Do you have enough memory? Increase your pm.max_requests = 500 as well.
I have been wondering the same exact thing, as I have been having issues with some of my scripts. Thank you so much for the tips you have provided though.
Np man :P 
xdebug profiling and webgrind are your friends, also slow is slow query logs etc https://xdebug.org/docs/profiler https://github.com/jokkedk/webgrind &gt; You don't always need to scale up This is somewhat true, but some times it cheaper to pay for a more powerful server that to pay for developer time
 &gt;Also pure CQRS, with all the strict requirements such as "commands shall never return a response" - this &gt;only makes sense for system of great scale (millions of transactions a second etc.), or systems of great &gt;performance requirements (like real time multiplayer gaming servers for example). Or in the case where you have a microservice architecture for scaling or fault tolerance. if you are using a event bus to communicate between microservices return values of a command call cannot be communicated. 
&gt; SQL is one of your enemies, if you don't need to use it, then don't. I think you should reconsider the way you worded this statement. I *think* I understand what you were trying to say (I.E. limit calls to the database), but someone might get the wrong idea. With regards to application performance, well written SQL can be a great performance improvement. Case in point, I just rewrote some sales data algorithms that were largely PHP powered (with nested SQL queries) into optimized SQL queries and the processing time went from 244 seconds down to 3 seconds.
CQRS is overly complicated for many domains. For example e-commerce or CMS is probably not a great fit for event sourcing , or at least not writing the entire system that way. The main thing seems to be (imo anyway) if you need to frequently roll back entities to an earlier state, or make projections in such a way that some entities have the state rolled back to an earlier revision. Also a big problem with it is that events cannot ever change, so it is not a great plan for a system where your domain model is unclear. If I am having trouble expressing the business logic as a DB schema then ES/CQRS will probably work in that scenario. Additionally you may have part of the system where it fits and part where it doesn't for example your user accounts probably have a lot of state changes reads and updates but never rollbacks or projections to the past. In this case it is probably quite safe to write these as simple CRUD type entities. If you are using microservice actually this would be easy because each part of the system does not really care what architecture the other parts are using so you can use CRUD on your user system and CQRS on other parts. Eg, when handling user management events you can simply write those changes directly to the DB instead of storing an event stack and replaying because odds are the cost outweighs the benefits.
I agree also its worth considering that many objects in the domain rarely if ever need to be rolled back to a previous state or even projected at a previous point in time. For example in our system user accounts have frequent state changes and reads but never neeed to be rolled back (if someone screws up a password just reset it,not roll it back), and they persist for a long time. So it would seem that the costs greatly outweigh the benefits. If you are using microservices i would imagine it is quite easy to solve the problem simply because you have an API of some kind (boundary) around the domain so the other systems do not really care what the underlying mechanism is. The world outside the user microservice should not be able to distinguish whether it is event sourcing or CRUD "under the hood". 
TDD is generally assumed to be testing on the level of unit though, those are integration tests. You can have a passing integration test and a failing unit test for many reasons. Its better than nothing but I prefer to write my integration tests in behat+mink and unit tests in phpunit. If you find behat too intimidating or too much overkill, Codeception has a much nicer API for writing integration tests than PHPUnit and I believe there is a way to bootstrap laravel into codeception
ah, is that all it is? i thought something wrong in my code was causing the processes to terminate! thanks for the insight and link!
I'm pretty experienced (10+ years), and I try and keep my skills up to date. It's not difficult to learn a new language/paradigm when you already know so many things. There's a lot of value in having a wide skillset. 
I've been at it for over 10 years as well and would never consider myself a master of something after 50 hours using it. Being generous that's less than 2 weeks of using it on the job. If you were sitting across the table from me interviewing and told me you mastered a language in 2 weeks, you wouldn't be getting a call back.
I went for the 15 USD bundle because the SVG books and a couple other books interested me. SVG is something I'm wanting to learn but haven't made the time for it because I've been messing around with my VPS and other projects involving that. I don't care much about the React books, but hey, they come with the bundle so why not.
Well, it can. By sending another message back on the event bus. The choice to go CQRS and the use of event bus is not necessarily the same thing. 
I think it depends on the context. Saying you‚Äôve mastered an entire language in 50 hours is extremely difficult to believe while working with some smallish random composer package could easily be ‚Äòmastered‚Äô well within that timeframe 
[@petermorlion's latest tweet](https://i.imgur.com/4iyi4Hh.jpg) [@petermorlion on Twitter](https://twitter.com/petermorlion) - ^I ^am ^a ^bot ^| ^[feedback](https://www.reddit.com/message/compose/?to=twinkiac)
So much this, sql is not enemy but your friend, but you have to use it wise, if not you can mess up a lot
Rule #1: Don't spend too much time on small optimizations when doubling your server capabilities costs less than an hour or two of your time.
Sir if you need to work with a code which is not supported well by any tools that can support my work than why to bother? The IDE is PHPStorm and I don't think you can find a better one on the market. 
Both links you provided are written by idiots. I was wondered for a bit why I cannot find the notorious "single quotes are faster than double" but then found it just worded differently. It's a pity that such lists usually are compiled by people who have no expertize to do a sanity check for all the garbage they found on Google, piling everything in. Some suggestions there are plain idiocy, like "echo is faster than print" and some are outright harmful, like "error messages are expensive". But the most harmful idea from these lists is the notion that speed optimization is achieved by means of following such idiotic recipes, not by means of **profiling and optimizing the found bottlenecks**. 
Old PHP is absolute trash. 7.2 is the shit. Laravel is the amazing. You can make REST Api's super quick. I would jump right into Laravel if you already have some experience with programming. If you understand OOP you shouldn't have any issues. There are a couple things like ServiceProviders/Facades that you may need to read up about but you can check out laracasts if you need to learn anything.
Well for the first question, PHP is now a first class language, rivaling all the other major interpreted languages like Python and JavaScript and Ruby. But it wasn't always that way and it was badly misused. Of course there are still relics of those days so many PHP developers still have to work in that legacy code. WordPress was one of those projects that misused PHP, or rather exploited it's former strengths. See PHP used to be a templating language. One of the reasons WordPress is so flexible and pluggable is because it exploited that. You basically template your whole app in PHP templates. No OOP (at least back in the day). To be fair that's how all major PHP projects were back in the day. In fact a very common approach back in the day was to structure your page like this: start the HTML -&gt; do some database calls -&gt; write some more HTML -&gt; etc etc. All in one file (or maybe split up into multiple templates and then included in one file). No separation of data or display. No separation of business logic. It was bad. But it got things done and it was very approachable and so it took over the world. As for frameworks, if you're just doing REST APIs you should do lumen instead of laravel. But if you need templating and other things laravel is a good choice. There are other options of course but those are the ones I'm familiar with. Not really related but cool. I have some coworkers experimenting with Swoole. Swoole is still experimental. It's meant to be like a nodejs runtime for PHP. Exciting things are happening in PHP land. 
When it comes to frameworks, there are two suggestions you‚Äôll hear the most by a long shot: Symfony and Laravel. A lot of people prefer Laravel, and a lot of people prefer Symfony. You‚Äôll probably also hear defenders of the one, bashing the other. Try them out both, see what works best with your workflow. For me personally, i prefer Symfony. Using version 4, it‚Äôs just lovely.
I probably don't apply for the kind of job you interview for.
Swoole is so great, boosts the performance so much.
Can't really improve on what /u/macaronisoft has said here :) The only thing I would add is generally theres no need to use mysqli or PDO anymore, it's a lot less time consuming (and arguably more enjoyable) to use one of the major frameworks, most of which have now adopted an ORM layer (although a few of the less popular / older ones have either an Active Record setup or just use their own layer on top of PDO. Take a look at the major players; Laravel, Symfony being the two main ones, Zend, CakePHP, Yii and Phalcon being the just as good but not as popular other options. Also as I'm sure you'll know already, one of the best things about modern php is composer and packagist. They kinda blow a lot of languages out of the water now in terms of how amazing the community has become and the amount of reusable code out there. Need a complete push notification system working in 30 minutes? No problem, you just grab a package and integrate it. Things like the PHP-FIG were an essential part of making php what it is today. All (sensible) php developers now follow the PSR coding standards they set out, meaning you can pretty much drop into anyones project and not be overwhelmed by their choice of syntax.
I'd say 5.2 to 5.6 is the period when PHP transitioned from trash to modernity - eliminating ridiculous shit like register globals and magic quotes, adding things like closures, namespacing, and steadily improving its OOP implementations. 
Two most popular frameworks are Laravel and Symfony. Personally, I think that others don't provide much extra, and some can even hinder your development (Codeigniter). Laravel is more convention over configuration, while Symfony configuration over convention. If you have more Java Spring experience, you will understand Symfony much faster. If more Django, probably Laravel is better for you. Symfony is harder to learn, and you need to know more concepts and design patterns. It quite nicely modular, but you need to be a more senior programmer to make it right. As an example - even on Symfony docs pages you will find Controller classes calling straight database - something that is quite ok for prototyping, simple websites or small applications - but a no goes for a bigger thing, especially as a monolith application. Also, Symfony (version 2 &amp; 3) quite often comes with some not-easy-as-first things like Doctrine with Unit of Work or Console things. So you would have to expect to learn much more from different sources, sometimes concepts that will take longer to click-in in your brain why it's done the "harder way" (like Doctrine stuff vs Eloquent). It's a quite nice framework which I prefer, cause it's more powerful and elastic in the type of workplace that I typically work - more than one team of developers, mainly senior ones. Laravel is easier to learn, and it's fully backed with lot's of options already included. You get nicely done queue system, so you don't need to know RabbitMQ i.e. If you will follow the conventions, you will write code fast in really "elegant" way (but not always "solid"). It's the best tool for fire-and-forget applications, small applications, and small teams. It doesn't scale so nice as Symfony, mainly because the framework is designed like that - scale, fast to write, easy - just pick both, not three of it. If you will have a more experienced developer, Laravel won't have scaling issues, but you will have to expect to throw out some of his parts and replacing with other things - i.e. queue system or global App/User that are handy but should be passed differently. I've done that once and the hardest part was not the code, but the people. Laravel is quite nice to be used as a microservices - if you would like to do this in PHP for some reason (like performance is not crucial). From your post, I think that probably you won't hit the scaling problems or performance problems, so I would advise you to go with Laravel, but come once a while to Symfony Docs, just to read how some basic and typical stuff can be done in a different way with different concepts.
&gt; xdebug profiling and webgrind are your friends, also slow is slow query logs etc You should take a look at this extension https://github.com/NoiseByNorthwest/php-spx which allows you to profile a web page and analyze the profiling report via a web UI in a matter of clicks. Disclaimer: I'm the author.
Please don't do Laravel. It gained it's popularity because it makes complex things look easier by obscuring the complexity with facades and helper methods, but does not eliminate the complexity itself. And some things are just garbage, like dd(); in collections (wtf? don't you have xdebug?) Laravel uses a lot of Symfony components under the hood, so I suggest you just look into Symfony and make your life easier. 4.1 is beautiful. Once Laravel hype dies out, we'd be left with tons of shit code written by people with little understanding of the processes because it was 'easier and more quick'.
To the other part of your question: the hate. It‚Äôs fashion. It‚Äôs religion. It‚Äôs politics. It‚Äôs mostly bullsnot. I don‚Äôt bother to engage in it. The job determines the tool.
no mention of phptherightway yet? ok [http://phptherightway.com/](http://phptherightway.com/) don't jump directly into framework, search [packagist.org](https://packagist.org) for any library you need
This should be the first comment.
PHP gets a lot of hate because of its legacy (very crappy code and practices, no OOP, no package manager, etc) and because still today can have a lot of unpredictable behaviors, see [/r/lolphp](https://www.reddit.com/r/lolphp/). The more you code with it, the more you'll understand that hate. But it gets the job done and can be satisfaying at the end. Considering your OOP background, i suggest you to start with this [tutorial](https://github.com/PatrickLouys/no-framework-tutorial) that explains you how a basic personal framework is structured. It helped me a lot! After that, you can "sew" your own framework (suggested only if you are working on specific stuff) or stick to a well-estabilished existing one. I'll prefer Symfony, it's very modular, performant and well-written. And don't do much wordpress plugins, they are the less satisfying things to write imho :P
Symfony FTW : ) The main problem is that once you've mastered Symfony there is 0 reason to switch back to Laravel. If you've never used any PHP framework, most people will recommend Laravel just because the community and support is more active. More devs working on the same problems you will encounter when using the framework.
&gt; Symfony is harder to learn What's hard in reading the official documentation and following it blindly. It works! It always has for me : )
There are stuff you will never use or find any use for. Because each web project has different requirement. Don't try to learn everything. Become good at the few tools you rely on daily. Explore sometimes new tools and see it can do something you're already doing better. And relax. It takes time and practice to be find your tech perimeter. It took me about 5 years to reach my tech 'maturity'.
What is the difference between Laravel dd(); and Symfony dd();? Aren't they the exactly same thing?
With the caveat that once you find yourself having to bump up your server specs regularly, its time to optimise. Throwing money at it only fixes it for so long.
&gt;The only thing I would add is generally theres no need to use mysqli or PDO anymore, it's a lot less time consuming \(and arguably more enjoyable\) to use one of the major frameworks, most of which have now adopted an ORM layer \(although a few of the less popular / older ones have either an Active Record setup or just use their own layer on top of PDO. Whoa there. This needs clarification. PDO and ORM's **are not mutually exclusive**. Just about every modern ORM is a layer **on top of** PDO. Since OP is familiar with Java, this should make perfect sense: **PDO is to PHP what JDBC is to Java.** ORM's like Doctrine are extremely similar to Hibernate. ORMS like Laravel's Eloquent or CakePHP's "Model" layer are ActiveRecord implementations, very similar to arjava, activeobjects, or javalite. All of these layers sit on top of PDO, the same way that Hybernate, activeobjects, etc all sit on top of JDBC.
Yeah sorry, didnt mean to imply they arent used, more that you dont use them directly so much anymore and instead the ORM you use sits on top of them.
I choose frameworks by amount of magic they have. Less magic, better. Symfony 4 \- has no enforced structure \- you choose how to develop. It can configure it self via flex composer extension. Writing your crud with enterprise level API? No problem: [https://api\-platform.com/](https://api-platform.com/) After 5min you writing models and working on ACLs. All magic here comes from DI, and little bit from annotations. Laravel \- way to much magic. If you need to do it fast \- it's way to go. You have everything out of the box. But things like: `event(new ShippingStatusUpdated($update));` are just terrible. In conclusion Laravel is "need shit get done for web". Symfony from version 4 is "need shit get done with php". P.S. Check this list: [https://symfony.com/blog/the\-30\-most\-useful\-symfony\-bundles\-and\-making\-them\-even\-better](https://symfony.com/blog/the-30-most-useful-symfony-bundles-and-making-them-even-better) And this [http://gwan.com/](http://gwan.com/) 
You should get into symfony. I tried laravel but this framework is weird for me, symfony 4.* Is beautiful.
I started from symfony and really can't understand what people see in this weird laravel ü§î
You don't have to invent an architecture, it's already there. You don't have to write wrappers around symfony classes - they are already there. A lot of shit is automated, specifically the IoC container, whereas in Symfony you'll have to list everything yourself while Laravel would just tokenize the bloody argument list and create the instances that you need. Honestly, I see Laravel as a step-up from Symfony where you do more, with less. And Eloquent is a very sane ORM. When I see Doctrine I really want to throw up. I really like how everything in Laravel is simplified. PHPized if you will. I mean if we need to flex our programming skills for even the most basic of to-do apps and to showoff, we'd do it in C right? And we'd write our own webserver too. Event-loop based. \m/ 
They do the same thing, yes, but the context is different. Laravel's dd(); is a part of the framework and you can't get rid of it. In the case mentioned - dd() in base class that defines global collection behavior - it does not add any value, and is used in one specific scenario. Symfony's dd(); is a added functionality by vardumper component, which is available only if you need debugging components for development. Symfony's debugging components are meant to be non-intrusive and they do not interfere with any other parts of the code. It implies, that you'll remove them once your app goes to production. To have debugging tools as a non-removable part of your code ([look](https://github.com/laravel/framework/blob/a49d506112917ad80a48f1dca3a5010a741dc37a/src/Illuminate/Support/Collection.php#L296)) is a bad idea and it could be easily abused. It would be much better to have dd(); moved to trait and be only used in classes that specifically require said behavior.
event('shipping.status.updated', [$update]) is perfectly viable alternative, too. Or is your problem that there's a helper function that retrieves the instance of the event dispatcher without you doing so in 2-3 lines of boilerplate code?
Omg can you crawl out of Taylor‚Äôs ass have an original thought for half a second or are you that stupid and biased? You offered nothing to this post including and tangible reason why prior to you‚Äôre beloved 7.2 php was trash. It‚Äôs people like you that make php look bad.
I‚Äôm sorry what? Don‚Äôt jump directly into a framework? Are yy smoking something I‚Äôm not?
Well how else you could sharpen your sword from time to time... 
Funny you mention dd, since Symfony just added a similar function. 
&gt; When it comes to frameworks, there are two suggestions you‚Äôll hear the most by a long shot: Symfony and Laravel. A lot of people prefer Laravel, and a lot of people prefer Symfony. Simple: in Europe you'll get Symfony. It originated in a French Web agency and spread from there. In the US it's Laravel because it was made by a US dev.
The gist link has some really old tips, many is no longer true or tips for ways you should not write software anyway. Biggest performance tip I can give is to avoid calling PHP-backend at all, i.e. use HTTP caching. Second tip is to Avoid ORM if possible. ORM in PHP is a big mismatch because classic PHP-setup does not keep any state between request, therefore reading up entire entities and multiple relationships in memory is often just a big waste of time. Just read exactly what you need from the database, don't include columns that wont be needed. Third tip is not read file contents into memory. This is a classic mistake because *file_get_contents* is so easy to use. When working with large files, you rarely need the entire file in memory if you for example is parsing it or if you just going to output it to the buffer. Use resource streams to work with your files. 
So is it just me or did e watch this thread go from the reasons php use to get a lot of hate, many of which already pointed out, into posing match between why laravel sucks and why you should not go with it AND why x,y or z is better? This is why php is hated, the divided community. We can‚Äôt even seem to stand together and say the same thing, with out throwing around hatred for frameworks in general or specific frameworks. I would have to say: community. We are one of the most divided communities, we have our fan boys and girls and Apache helicoptiters of specific frameworks and tools with in php and we have our haters. We can‚Äôt seem to stand firm together. I mean to be honest before you argue against this just scroll through this thread, it starts out great and then turns to shit.
First point, yes, unless optimising your code will take longer and cost more for a minor boost than upgrading the server. You should also look at optimising the server itself \(depending on the bottlenecks\). Second point, yes. 100&amp;#37; Yes. If your code will run on PHP7 immediately, or with only minor tweaks \- do it, upgrade and don't look back, the benchmarked difference between 5.x and 7.x are crazy. Third point, needs clarification, as stated it seems more harmful than helpful. Offloading processing to the DB is hugely preferable to multiple loops or nested queries in the PHP. Learn to use SQL properly, if you're filtering, searching or aggregating data in PHP, there's a good chance you could do it more efficiently in your initial DB query. Fourth point \- what? Unless your ajax script is ridiculously heavy, or you have a tiny number of available connections on your server, this should be OK \(although, used sparingly with some intelligence\) My suggestions would be to use a profiler, or even htop and an strace on high cpu/memory threads to see whats happening when the server starts to chug.
I fail to see the reason you're having so much fun about it. dd() in Symfony is a part of optional component, but not the framework itself. Besides, why have method duplicating the one that exists already ([helper](https://github.com/laravel/framework/blob/a49d506112917ad80a48f1dca3a5010a741dc37a/src/Illuminate/Support/helpers.php#L547) and [collection](https://github.com/laravel/framework/blob/a49d506112917ad80a48f1dca3a5010a741dc37a/src/Illuminate/Support/Collection.php#L296))? Am I truly the one that has to do reading? 
I think [this tweet](https://twitter.com/GeeH/status/1001823549303205888) says a lot too.
&gt; The main problem is that once you've mastered Symfony there is 0 reason to switch back to Laravel. I've used both fairly extensively on medium and large projects (in terms of both traffic and complexity, some have been high-traffic/low-complexity, some, like intranets, have been low-traffic/high-complexity) and over the years I've implemented a lot of different architectural patterns in both. The bulk of my professional work moved from Zend, to Symfony, to Laravel. I still generally lean towards Laravel unless there is a good reason to choose Symfony (generally when there is an existing team with Symfony experience). Both frameworks can be (ab)used to make terrible systems, both can be used to make maintainable, performant systems at the scales that the overwhelming majority of developers are working at. In my experience, for the vast majority of projects that modern PHP is used for, from basic CRUD record management systems to complex ERP systems with extensive reporting and processing requirements, a well planned Laravel application tends to be easier to grok, with more concise code than a similarly designed Symfony application, but really there's not a huge amount of difference there and quite a lot of it comes down to personal preference in the kind of code you like to work with. Laravel is going to get unwieldy if you aren't considering the overall architecture and design of the system, but frankly, so is Symfony.
I would recommend you spend more time writing vanilla PHP before you dive into frameworks to help you understand the underlying language and stack better. Keep doing what you're doing.
There is a case to made for having a working knowledge of what the framework-magic is actually doing for you. But it's kind of a dilemma. Not using a framework will make anything you do take forever while using one from outset tend to teach you not to question the magic.
So the third one should be phrased as "do not read the **large* file contents into memory". Same goes for the second tip. Most of time there is nothing wrong with loading a few extra columns for a single record. Let alone the whole tip is illogical: ORM is not a life-critical tool, of course it can be avoided. At the cost of more tedious development. So the whole tip should be reversed: use ORM by default, occasionally falling back to raw SQL for the resource-heavy operations. HTTP caching is good for a static site. In the real life there are always dynamically changed elements. Imagine Reddit using HTTP caching for its backend-generated contents. So this one should be used with caution. Cache invalidation is the second hardest problem in Computer Science.
It's always a mistake to get hung up on 'My Coding Language is Better than Yours' meme. It sounds like you've not been coding *that* long - after a while your realise that all that matters about a language is (a) can I write clean, well organised, legible code in it with no restrictions (b) is there sufficient APIs/Extensions/Frameworks available that I don't have to reinvent the wheel (c) is there a large enough community that I can find the answers to potentially obscure questions easily. PHP meets all the above criteria with ease. It did grow out of a rather hacky scripting language at the beginning and there's a lot of crappy legacy code around and some syntax that is quirky to say the least. But that's true of most real world languages that have paid their dues. As to frameworks - just choose what works for you, or more importantly works for the environment you're working in. In the past I spent a lot of time with CodeIgniter and although it's very long in the tooth now I still reach for it occasionally as it's extremely fast, very, very lightweight, and if I'm simply after some straightforward code to do something like provide a RESTful API to a database it still is the framework of choice in those specific circumstances - although I'm going to give serious consideration to Lumen in future. For anything more substantial for the past few years I've been reaching for Laravel, or if I'm working with a CMS type site the Laravel based OctoberCMS. The arguments I'm hearing for Symfony though are inclining me to look at that for my next project. A word of caution. I'm not a fan of ORM and I'd encourage you to learn SQL beyond the trivial level. ORM seems to me to attempt to match two less than fully compatible ways of structuring data together and to my mind doesn't simplify code, makes complex queries difficult to code (does the WITH statement even exist for instance?), and in fact obscures it for purposes of debugging and particularly tuning. ORM is great if you need cross-database abstraction (and why I use it when I do) but generally I find skipping the ORM layer to be faster and more robust. YMMV of course. 
I mean, you don't have to use it. Like many things in Laravel, it's useful and **optional**. You won't always have access to XDebug, say you are on your girlfriend's PC who doesn't even have an IDE to begin with but you are at her place and you needed to quickly debug some variables because of something your colleague wrote. You'd write boilerplate code I'd write $collection-&gt;dd() To be honest though, I had no clue they've added this function to the 5.6 branch xD who would've thought and the collection class is the class that I open in the API docs most often. It is also true that many Laravel developers just don't have XDebug, especially those that work on Windows. So that's that. And apparently it seems a lot of Symfony devs as of late don't have it otherwise they wouldn't have asked for dd(), as XDebug is really good at showing the type of variables and their properties. I've worked in a lot of companies, only one of them required mandatory use of XDebug in dev environment. Another had XDebug loaded in production but I quit this one quickly. 
I think a variable or a property is what you're after. A mutable constant is an oxymoron.
From your comments I can conclude, that you haven't seen Symfony since 2.x DI container in Symfony (starting with 3.3) is autowired and you have to do *0* configuration for it (except for edge cases, which are few). Eloquent is Active Record implementation, whereas Doctrine is Data Mapper and you need to know, when to use each of those as they solve the problem in different ways. Besides, you can trow away Doctrine in Symfony, and use whatever you want, but I'm not sure that's easily done with Laravel. When I have to work with laravel, I imagine Taylor reading symfony docs and then saying 'wtf is this shit, it's too hard, I'll do it my way'.
What is with these religious wars when talking about frameworks? Laravel uses facades and helper methods, sure, and there are \(potential\) issues with that, sure, but you are seriously pulling the other one if you think that such practises result in universally "shit" code. This kind of thing always amuses me anyway, given that PhP is widely regarded as the red\-headed stepchild of the programming community anyway, so the unjustified superiority complex just ends up looking doubly insecure.
I've seen some disgusting Symfony projects. Not doubt about the fact that no matter which framework you pick, you can do some crazy shit with it. People tends to love 'simplicity' when talking about Laravel. I'm a bit of a perfectionist, I go down to the frontier of the framework to iron the low level implementation details and go custom only when absolutely required. I guess that's why I'm biased towards Symfony. Where people see 'raw' and 'hard', I see important details.
I work with Phalcon everyday. I'm not impressed and I'd prefer to work in another framework.
&gt; I'm a bit of a perfectionist, I go down to the frontier of the framework to iron the low level implementation details and go custom only when absolutely required. I guess that's why I'm biased towards Symfony. Where people see 'raw' and 'hard', I see important details. I'm just not a fan of unnecessary busy work. ;) I think a lot of people who mostly use Symfony and have only given Laravel a cursory look don't realise that it is eminently customisable. While it favours convention over configuration, there's little configuration you can do in Symfony that isn't straightforward to do in Laravel if you've put a similar amount of time into learning it under the hood. It's not even particularly painful to replace most core components of the framework if you really have to.
You don't have to use it, that's true. But why have it baked into Collection class? why not make it a trait? It just does not belong there, it violates the separation of concerns. I'd do dd($collection-&gt;getElements()); which kinda invalidates your argument. And btw, it is much safer as you can control the behavior of a function without the need to modify the global behavior of the class that has lots of dependents. Xdebug is not a silver bullet, but it makes life much easier if configured properly (either local or remote) 
My first question would be, why write it in PHP?
I guess it depends on how seriously you want to take it. Technically you could just (assuming you're on a Linux machine) do something like `php -f /path/to/your/script.php &amp;` and it will run happily in the background. I don't know if that counts as a deamon though... You could take a look at http://supervisord.org/. This will monitor the status of your scripts, restart them when they fail and log events for you. I know this is used a lot with job queues and such to ensure a script is always running. I'm not sure if it's relevant for your use case though... As you have acknowledged, regardless of your booting mechanism, once your script is running you will need to make sure you avoid memory leaks. PHP7 is a lot better than older versions of PHP so I would recommend you try and use the latest version (7.2) to get a head start. Outside of that I can't offer you a lot of advice. PHP isn't known for being used to write services that run for days or weeks at a time without being restarted. Having said that, don't let that stop you from trying it out! Some people write scripts that are only designed to be run for an hour at a time or so. This is where Supervisor comes in. It can restart your script for you when it dies by design. This will help you avoid memory leaks that cause problems. In theory you could achieve this with a cron job... If you want to listen for things there are some functions in PHP you could take a look at queues (such as Beanstalk or RabbitMQ) which provide some helpful blocking functions. If you don't want to use a queue you may have to implement some `usleep()` calls in a loop. Again this isn't the most polished way of doing things, but if it works it works... What's the deamon for? The advice I've given is quite generalised!
This makes zero sense.
I have a PHP deamon that does this: while true:
I have about 15 daemons running using php, rabbitmq, and supervisord. They run flawlessly. They never need to be restarted. Literally never. And they are easily scaleable by creating multiple instances under supervisor. 
&gt; You don't always need to scale up, i.e getting better/more expensive servers, you should take a look at your PHP code before you invest time into moving servers. Labour is expensive, cpu time is cheap.
Go to conferences, follow the right people on Twitter, read a few blogs/news aggregate sites.
Rebooting it is probably the most important part of a daemon. 
Thank you for reply. Fair point.
It might be a small daemon that supports a web application. Choosing another language (and possibly framework) would introduce a lot of unknown and potential time waste! If you're comfortable in PHP then it makes sense to at least figure out if PHP is a viable option...
https://laravel.com/docs/5.6/broadcasting - WebSocket You still haven't told me what's your issue with the event functionality in Laravel so I really can't help you out there but you are spreading misinformation. Think about it for a second. However I've always wondered ... why use PHP for WebSocket o.O Node.js + Express.js and socket.io are absolutely perfect, you can get backend application in ~20 lines of code who communicate with events and Nodejs has better throughput than PHP. I don't like Javascript on the backend either but hey, it does the job and I don't have to write servers in C/Java. And chances are, my solution won't really be faster than Nodejs.
Just because you can doesn't mean you should. Why bother with all the extra complexity when most other languages come with this out of the box? The fact that you praise that it "runs flawlessly" as if this is some sort of big achievement should be a red flag to begin with: why would these even be in contention? This should be _expected_ behaviour. PHP is a tool. You don't _have_ to use it for everything. 
&gt; But why have it baked into Collection class? why not make it a trait? You make a fair point there. From my personal observation though, most Laravel devs don't give a flying fuck about the existing traits. And there are some really good ones. So chances are, most devs would've missed on this feature. I wonder if Taylor added it himself or that's some pull request. Will check on that.
Oh absolutely you dont have to use it for everything.. and I don't. Hence why rabbitmq and supervisord are also used. They're all tools. Except I am using Symfony + Doctrine and I want to reuse code. Why should I duplicate code in another language because of the perception that PHP can't do it? PHP can definitely do it. 
That is a fair point. 
I would suggest you take a look at [React PHP](https://reactphp.org/) and [React PCNTL](https://github.com/mkraemer/react-pcntl) I use Bunny for RabbitMQ if you need a queuing piece but the main parts of the daemons I have built are using the above packages. I would like to share the code I have but unfortunately I can't at this time. 
Look at php-fpm specific log file. It should tell you why it terminated a child. It's most probably because of your php-fpm configuration but it also could be that your script crashes the PHP (segmentation fault). 
I work with it every day too, I'm very pleased with most (but not all). I'm curious what your complaints are.
Technically you could just \(assuming you're on a Linux machine\) do something like php \-f /path/to/your/script.php &amp; and it will run happily in the background. I don't know if that counts as a deamon though... That's not, the main issue is the fact that the process is still attached to the terminal and will be terminated on a hangup. A nohup fix that point \(as well as a terminal multiplexer\). You can see this well detailed response on the difference between nohup and a deamon to understand what are the other other concerns [https://stackoverflow.com/questions/958249/whats\-the\-difference\-between\-nohup\-and\-a\-daemon](https://stackoverflow.com/questions/958249/whats-the-difference-between-nohup-and-a-daemon)
&gt;Most positive things are its simplicity and its speed Speed is not a concern for me. I don't agree with the simplicity. Phalcon has poor/bad documentation compared to other frameworks, [the user community around Phalcon are in no way helpful when questions or issues arise](https://www.reddit.com/r/PHP/comments/7a8ove/is_phalcon_actually_used_anywhere/dp8bxiz/), and a bunch of stuff \(like naming conventions\) are all but intuitive. It works \- but I don't feel like Phalcon is the right tool for any kind of job.
I would ask myself the following questions: I will have to learn PHP, their version, upgrade paths and security stuff, no question. I need to control a webserver, too - maybe Docker. I need to apply things I know are good and necessary, that is testing, version control, all that. Actually it takes a while to learn and use all that properly. Also about securityheaders, how to implement proper SSL and at least fundamental knowledge about OWASP, best practice, PSR, encryption, hash functions.. privacy protection... license questions.. I certainly will have to learn a lot of HTML / HTML5, CSS. All this is already a LOT. But then: Do I really want to learn JavaScript much? Do I want to add even more dependencies in my project on top of JS that will change over time and bite me in the foot one day? If I chose a framework, am I able to determine which one will be good for my use cases on the long run ? Do I trust a product that is there only since a few years? Can I be sure that the framework I use will not be abandoned? Does it develop in a way I will follow? Am I the slave of a fashion now? Is the cost / benefit relation still below one? Or do I have customers I can bill by the hour? Would I be better off with less code? Less abstractions? 
[Here ya go](https://twitter.com/taylorotwell/status/878997361321816065) 
You are right, but it's like that "for historical reasons". We display a note about this in the docs: https://symfony.com/doc/current/security/password_encoding.html
Symfony 4 is the leanest PHP framework, as you can see here: https://twitter.com/symfony_en/status/882182266893598720. It's also the fastest PHP framework, as you can see here: http://www.phpbenchmarks.com/en/comparator/frameworks.html
&gt; I imagine Taylor reading symfony docs and then saying 'wtf is this shit, it's too hard, I'll do it my way'. To be fair, that's really how software evolves and improves over time. Always good to have competition. 
It was more of a personal plea than an attempt on structured solid answer. Reasons to use/not to use any tool or framework are numerous - the only thing you should consider is how well this tool will help you complete your objective. My personal experience with Laravel is overall bad. Laravel 3 was my first framework, but since then I grew up to understand one simple thing - you have to **understand** what you're doing and why you do it the way you do it. Symfony is not exactly a framework, but a collection of components that play well together. They're interchangeable and they do great work helping you understand, how they work. After a year of Laravel, Symfony was truly liberating experience. I like having more control and less magic. I don't like it when my tools do the thinking for me, it never ended well. Taylor trying to anticipate every possible use case ends up with, for example, Collection class being 1894 lines long. It's like packing 50 pound suitcase for vacation only to use swimming shorts and sunscreen. Trying to think of everything at once makes no sense, but makes you look like a busy person. Laravel is really good at concealing the complexity but it is also concealing the inner workings of your tools, giving you "here, this will solve your task, don't ask why" attitude. I guess, that comes from the Taylor himself - when confronted with critique, he resorts to arguments about how easy something is to use, or how awesome the community is. I failed to find any discussion where he gives straightforward answers to questions about architectural choices. I'd be glad if someone proved me wrong. Anyway, I'm just ranting about something that's out of my control, and we couldn't keep people from shooting their legs off. But we could at least try. 
Yeah now I am totally confused.I didn't even have Symfony in mind.Now I am stuck between the two and right now I don't even have specific needs.I get that some framework is suitable for some case and some for others.The thing is I don't have a particular need right now.I just want to be able to use a framework efficiently and land a good nob after my CS degree.Seems like you read through this thread quite well.What do you suggest?
 `"""` `do the UNIX double-fork magic, see Stevens' "Advanced` `Programming in the UNIX Environment" for details (ISBN 0201563177) http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16` `"""` From a repo I worked in recently, the link is dead but the book is on it's third addition. If currios the repo was in python but you should be able to get the gist of it. [https://github.com/jegesh/python\-sqs\-listener/blob/master/sqs\_listener/daemon.py](https://github.com/jegesh/python-sqs-listener/blob/master/sqs_listener/daemon.py)
If you use resource streams from the beginning you never end up in that situation, because is not always apparent what will be a huge file in the future. That means that if you adapt your application to "speak" streams, you will never make that mistake, or at least it is easier to repair to just use another method that reads the stream further down the line. No, it is not illogical about the ORM. You have of course helper methods to help you build the correct queries. And it does matters, fetching unnecessary columns is a cost, in IO, memory and CPU. For every request. ORMs fool you into doing bad abstractions, thinking that one table matches one class. It doesn't, because it is relationship database, so depending on your view, you get different results. So one API may need some columns from one table and another API needs columns from multiple tables, however both may speak the same primary key. So what usually end up with doing is JOINs in php, that is just bad. And the HTTP caching, you can perfectly use ETag in that situation. 
There's not much detail here as to what's actually happening, is FPM restarting children over and over again? Is this intermittent and restores itself? I've covered two common issues below, others have covered worker pool sizing being insufficient, from your descriptions your concurrent request volume aren't very high, but also be aware that by default the number of active connections to a socket is 128 (on most distributions I believe), but can be raised at the OS level, or use port binding instead. **If you're losing in-flight requests when reloading FPM** In your global FPM configuration file, define: process_control_timeout = &lt;your max execution time, or a sane value according to your application&gt; FPM supports graceful reloads via sending a SIGUSR2 signal (which upstart/systemd etc. send when the reload action is performed). Requests can still end up being terminated however as the default setting for process_control_timeout is to wait an incredibly short time for the child to finish request handling before just terminating the child. **If your service becomes completely unavailable and requires a manual FPM restart** Check your FPM logs, if you're seeing: WARNING: [pool POOL_NAME] child 16463 exited on signal 11 (SIGSEGV - core dumped) after 3825.102408 seconds from start NOTICE: [pool POOL_NAME] child 21814 started Over and over again, in your pool configuration file, define: emergency_restart_threshold = &lt;number of children that exit with an error during the interval, e.g. 10&gt; emergency_restart_interval = &lt;time interval, e.g. 10s&gt; This guards against catastrophic failure at the FPM level. I've seen this happen when OpCache (which is shared between children) becomes corrupted, resulting in FPM repeatedly attempting to spawn children that segfault. This can be due to a bug in the VM OS, the Hypervisor OS, or the PHP release itself (and probably a bunch of other factors). Note PHP 7.1 has multiple releases that have such bugs, for example: http://bugs.php.net/75579. You'll want to look into fixing the root issue of this, but this setting is a pretty sane thing to define regardless so manual recovery isn't required. 
Are you sure on this? I'm fairly certain FPM will not terminate requests currently being handled, it will just drop the new requests sending a 502 back upstream?
:D I know. But we are on /r/PHP So after learning JS sombody will be full stack Symfony \+ Angular/React developer, right? ;P
Agree on streams. Orms fool you into doing bad abstractions is partly true, but still the suggestion makes no sense. You either use ORM or not. Partial use till take most of benefits. To respond properly with ETag you must perform the entire backend logic, a thing you are trying to avoid
Taylor who..?
You're right. In my company we're comfortable with PHP, so it's our first choice.
Thanks for your answers. We currently have deamons managed by Upstart and some with supervisord. Some of them do PostgreSQL \(Doctrine DBAL\) / REDIS \(Predis\) / Webservice \(Guzzle\) / filesystem \(Flysystem\) operations, ... and we can have some memory leaks. We don't know how to debug these long\-lived scripts.
Yes, avoid partial use of an ORM. My recommendation is not to use them at all, by I understand that sometimes you need to, based on team skill and product goals. It is not that difficult to write helper methods for select, delete, update and insert. Don't use them directly, rather use them in each repository. And there is another thing I dislike with ORM, many ORM thinks that the entity is the same as the repository. And another problem with ORMs is that you think that reads &amp; writes operates on the same storage, but in a big application thats not always the case. Sure, with my approach you may need to write a bit more code, but I prefer that over that blackbox magic that ORMs usually are. With etag you need to do the request, but you don't need to do the computation, that is at least a half win.
&gt; I think I understand what you were trying to say (I.E. limit calls to the database), but someone might get the wrong idea. don't forget some people think it's a good idea to store files in databases ¬¨_¬¨
For REST use Slim3 and write your own database stuff.. fuck the noise that is laravel and lumen.. Or have a look at Igni Framework if you want pure unadulterated speed! Swoole &lt;3
I have something like this in /etc/init/yourdaemon.conf that will automatically respawn the script if it dies for any reason. `# Events` `start on startup` `stop on shutdown` `# Automatically respawn` `respawn` `respawn limit 20 5` `# Run the script!` `# Note, in this example, if your PHP script returns` `# the string "ERROR", the daemon will stop itself.` `script` `[ $(exec /usr/bin/php -f /path/to/script.php) = 'ERROR' ] &amp;&amp; ( stop; exit 1; )` `end script`
&gt;We don't know how to debug these long\-lived scripts. Just dont make them living too long, they should terminate themselves after a defined period of time and supervisord will auto restart them.
Read http://www.phptherightway.com first from start to finish. Give a speed read through https://www.php-fig.org next and be aware of what basic psrs are out there. Read up on "dependency injection" too, and know how to `implement` an interface. You should make composer the first thing you install on any project. People dive into frameworks too quickly and end up generating vendor reliance to the point of addiction. It's more important you understand interfaces that will let you install/write modules that continue to work. If I give a shout-out to any lib, check out Guzzle. You mentioned ajax, and this will let you integrate with other sites very easily. It also comes with promises, and is used by the excellent AWS lib (which is also something that learning will help you land higher paying jobs). Also [immutable.php](https://github.com/jkoudys/immutable.php) is a great way to manage collections of data if you're finding the built-in array functions inconsistent and annoying to work with. 
That's funny! I spent YEARS working on Symfony 1-2 projects, started on Laravel in January 2016 and haven't looked back! Laravel is **amazing**.
Swift?
Slim is excellent, and fully PSR7 based. 
I am really really thankful Mr. Otwell has such a *passion* for making a sophisticated, yet easy to use framework with minimal bootstrapping and still pretty low technical debt!
Nevermind you're a PHPstorm user, there's no point in arguing with you. Yes you're right your IDE is the best and if something doesn't work with it it's not the IDE fault it's that other thing's fault. Bless PHPstorm.
Funny enough, it makes a lot of sense. I spend a lot of time in the CMS space. WordPress and Drupal are favored heavily by US agencies in part because of there being US corporations backing them and the projects leaning toward a en-US style presentation out-of-the-box. Whereas Joomla's heaviest market share is in the EU, where the biggest portion of the development ecosystem exists and the core product being more EU friendly (en-GB presentation out-of-the-box and core multi-language capabilities). I'm not saying that location is the primary decision maker, but if you look at trends you'll notice things like that.
&gt; I also dived into mysqli and heard there's more better one called PDO.I am currently doing some basic projects that has simple CRUD functions. It is not so much that PDO is "better" than mysqli but rather is more widely used. I think it is safe to say that most third party libraries that interact with a database do so using PDO. And while there a few edge case scenarios which mysqli might handle a tiny bit better, there is really no good reason not to use PDO as a default choice. Much more importantly, make sure you always use prepared statements for anything involving parameters such as data values. That protects you against a fairly wide range of attack scenarios. And while I'll steer clear of the framework wars, consider installing the [Doctrine Database Abstraction Layer](https://www.doctrine-project.org/projects/dbal.html) (DBAL) as a first step. The DBAL is a thin layer over PDO and offers a number of convenience functions. Functions you might be tempted to write yourself especially for CRUD stuff. // For example, instead of things like: $sql = 'INSERT INTO table (a,b) VALUES(?,?); // You could do: $db-&gt;insert('table',['a'=&gt;$a,'b'=&gt;$b]); 
It doesn't fail at all and it doesn't leak memory at all, sits consistently on one value for all the time
Your personal preference regarding ORMs is not overly shared by other developers, to say the least. Etag saves you bandwidth, not a backend call. To send a 304 you need to know whether your data has been modified or not. To do so you need to perform your business logic all the same. 
The hate is rooted in history when PHP was not a very good language. However now with the invention of composer, proper namespacing and other things, it's amazing.
Built a control panel and backend permission broker daemon using PHP. Sometimes having familiarity and native serialization are necessary, plus it does a fine job forking, masking process titles, and handling ~10k req/sec.
Because it hard couples to framework. It can make seem that event is part of php, but it is not. It's bad example. Yes. We are migrating to nchan \+ php. 
That makes total sense. I noticed, in Finland, where Linus Torvold is from, everyone uses Linux machines. Ask a Fin what Microsoft is and they scratch their heads. Interestingly, Australia, the inventor of WiFi, are the biggest consumers of it while everywhere else people just connect to their routers over Bluetooth. And you know ol‚Äô Mark Shuttleworth, British inventor of Ubuntu? Yep, explains why most British home computers run Ubuntu. I hope my seething sarcasm illustrates how ridiculous your argument is. Even if there‚Äôs a modicum of truth, you‚Äôre a classic example of why they teach statistics at Uni: correlation does not equal causation.
You should not learn framework to "land a job" Learn two things - the language and what tool to use for the task at hand. Knowledge of specific tool only rarely is beneficial - if you know only symfony/laravel, you probably won't find a job in an agency that does WordPress. You have to learn the core concepts, edge cases of your language and basic concepts of most popular tools on the market. The real-world job and real-world tasks will re-shape your knowledge anyway.
That makes total sense. I noticed, in Finland, where Linus Torvold is from, everyone uses Linux machines. Ask a Fin what Microsoft is and they scratch their heads. Interestingly, Australia, the inventor of WiFi, are the biggest consumers of it while everywhere else people just connect to their routers over Bluetooth. And you know ol‚Äô Mark Shuttleworth, British inventor of Ubuntu? Yep, explains why most British home computers run Ubuntu. I hope my seething sarcasm illustrates how ridiculous your argument is. Even if there‚Äôs a modicum of truth, you‚Äôre a classic example of why they teach statistics at Uni: correlation does not equal causation.
Are you sure you need a daemon? Do you need to accomplish something that cron, a queuing system, etc, can't?
Also Dries, inventor of Drupal, is from Europe, so please try to rationalize your delusional theory now?
So you are telling me that having a global function, that takes a string and an argument list, is hard coupling to a framework? Good luck with your migration, lol. 
Can you elaborate on what you meant by Codeigniter will hinder development? I don't have much hands on experience with frameworks but I'm moving into a job that uses Codeigniter so your comment has me curious.
I mean, If OP has much time with no specified deadline, start with building from just router and DI container, create simple controller dispatcher, and gradually adding functionality, service, etc by adding more libs without tied into specific framework. once he/she get used with that, working with any framework is easy, since they share common pattern, just different additional feature
And at the same time coming across as an immature dick with an over inflated ego bolstered by sycophants.
Connect to routers over Bluetooth?
Seriously? That‚Äôs the only concern you have, despite my other examples? Did you then also go on to miss the sarcasm? üòÇ
They just need Laravel's marketing and a Jeffrey Way.
Codeigniter was a nice framework that I've also used at the beginning... in times of Zend 1. Later came KohanaPHP &amp; FuelPHP - mainly because Codeigniter didn't wanted to migrate his base code from PHP 4 to PHP 5, so community done that by themselves. So Codeigniter was always behind the actual stuff, for example it doesn't use composer, is built to work on PHP 5.3.7, with recommended version of 5.6 (which will be out of security patches soon... and we have PHP 7 for I don't know, 3 years almost?). It's full of bad practices like global things, god singletons etc., also lacking good practices like dependency injection or proper unit testing (has it own "solution"). It's easy to pick up, and easy to learn bad habits, which could be later hard to get rid off. If you learned and mastered Laravel / Symfony, Codeigniter will be a breeze in terms of how it's complicated, and also a lot of curses how it's complicated to do anything testable/scalable/maintainable/integrate with other libraries. And you will be forced to write in PHP 5.6, cause probably it will fail it's compatibility in few places for newest versions of PHP.
What is good or correct in a technical sense is not a majority decision. If a developer has good arguments about ORM, I will listen, but I don't accept it just because they are in the majority. Majorities are often wrong. It depends how &amp; when you calculated the Etag. You can either calculate on insert or before read. En Etag can by anything, timestamp what not. And it can also be a huge win for the client, if it as mobile for instance on slow connection.
Well, moving from Symfony 2/3 to 4 is quite a revolution so it needed proper introduction.
It's much better, but there are still warts aplenty, and will be until the core team decides to do a major bc-breaking version.
Okay, hipster dev. Take a dump on a solid framework because it's not up to your, "standards".
The issues with PHP don't tend to come up quickly; they're the sort of thing you run into when debugging a million line production app and cause you to tear out your hair. For instance, this week I found some code that works by happenstance because you can index into a Boolean without getting an error (it returns null), and so an incorrect config just plugs a bunch of null values into a function instead of throwing an error like we expected.
No piece of software ever written to serve an actual purpose runs flawlessly. Your statement is odd.
But your comment is written in Python? ^/s
You have a point here but it has been drawn too far away from the initial topic. I agree that there could be arguments against or pro using ORM. But the question was on performance while ORM is not always being a bottleneck. I agree that ETag could be a win for a client but the question was the performance of the server. I don't know what is your usual app, but I am working with such kind of apps that require so much business logic like permission checking, many processes' results checking, many modules' messages checking etc that it is a world away from your single record's timestamp checking. So I am bound to run the usual business logic on every request.
PHP Wordpress Spaghetti code nuff said Laravel is making a come back, and I'm pretty impressed with its performance, structure, scalability and architecture
What I've noticed is, anytime I am dealing with a tech person, or in a tech thread, the subject **never** stays on topic. People always begin going on a tangent and having to be autistic about every single detail It's like one of the reasons stack overflow has such nazi moderators. I think it's a tech-head thing.
I fail to see how SSL and httponly make this any unlikely. Basically, if someone has access to your PC, they could get your login and password for the site and don't hassle with cookies at all. So I'l like to hear about the real life scenario you are trying to defend from.
Fingerprint the browser and store it in the session ( see https://github.com/Valve/fingerprintjs2 )
I'm guessing this is for a user session cookie. So keep in mind that the more secure you make it, the harder it will be keep your users logged in. For example: You can store IP and browser information, but dynamic ip addresses and browser updates are a thing. You could tie the cookie to: - Chrome - Chrome 6x - Chrome 61 - Chrome 61.xxx localStorage can also be used; make the client do some math, or generate a public/private key during login and sign a message on every next page load.
I think the point is that if you use plaintext http hijacking someones session by sniffing network traffic is actually very easy. Although in the scenario that OP describes, actually copying and pasting the cookie, you are right it doesn't make any difference at all.
Yeah, don't write it in PHP, implement all the logic in a different language to gain nothing, but at least you have something to do.
Wasn't it because people using Laravel that also use Symfony kept pushing for it to be added? Also, they rejected it in the past for various reasons and only added it because so many people kept asking for it. i.e. they gave in to peer pressure. &gt; Not everyone has experience with a debugger That's a pretty shitty reason *for* the `dd()` function, IMO. But whatever to each their own. I think I'd really like to see it in a dev dependency for Symfony though so when you're application is in prod, the function doesn't exist at all.
systemd is also your friend here. By adding this to /etc/systemd/system/your-service.service you get auto restart on failure and start on boot, as well as the ability to control it with systemctl just like mysql, apache etc.. So much better than the old shell script way of making a daemon. [Unit] Description= Your Description After=mysql.service network-online.target [Service] User=username Group=username Restart=on-failure ExecStart=/usr/local/bin/myphpscript [Install] WantedBy=multi-user.target 
[https://github.com/mac\-cain13/daemonizable\-command/](https://github.com/mac-cain13/daemonizable-command/)
About memory \- don't load large result sets from database, process files using streaming if possible, watch out for growing arrays. In complex daemons, I rather do the business in a method and call that from loop while avoiding global scope variables, this way the GC can do its job and I don't have to worry about disposal that much. Take advantage of long\-life process when appropriate. You can cache data in an array structure, so you don't have to query a database all the time and you can obtain results instantly. Just purge it from time to time :\) PHP is acually pretty good for this use. Once everything gets loaded, it's pretty fast and unless you do a mistake, no memory leak will occur. I've developed tens, maybe hundreds daemon scripts and all of it runs for months or years. Usually the reason of their termination is a reboot or upgrade.
In the article, there are integration tests for API that is being written and Coordinates service is also unit tested. I'm not familiar enough with behat to say much, other than I have no problems with integration tests in Laravel, so extra dependency makes no sense for me at this time. Apart from behat I'm with you on everything you have written including unit testing and SOLID.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I am really envy of your Emacs skillset... It doesn't slow down...you can use any deprecated function on the market. Bless extract/compact ! 
&gt; if you think that such practises result in universally "shit" code. If one does not understand all the implications of approach one uses, then with high probability result will be of poor quality. And this happens all around - with Laravel, Symfony, Zend, CodeIgniter, you name it. You can write shit code with any of those. It's just that Laravel does not encourage you to look under the hood and ask "Why they did it this way?". But if you do look, you're gonna end up with more questions. Why does it use so much static calls? Why there is so much global state in apps? Why do you have to use public properties to make events work? There's no direct answer to those, instead you get "Ok, instead of static calls you could use helpers with access to global state" kind of answer. So yes, I think that by obscuring complexity instead of battling it, Laravel promotes writing poor code. And I'm truly sad that people just google 'best PHP framework', get first search result and do not consider alternatives. 
Having the same cookies in different computers is exactly the purpose of using your gmail account to log into chrome. Or using the same appleid on iOS and Mac browsers. If you want to make sure someone isn‚Äôt opening your computer and copying your cookies, lock your computer.
You can do what is increasingly popular at retailers. General actions can use a cookie, but restricted actions need a login during the current session.
I'm not sure if that's a serious question, but I'll answer seriously: I've got a ton of queue workers and whatnot written in PHP. Biggest reason being that I have a bunch of classes written in PHP that encapsulate various models, operations, and other domain concerns that are already written in PHP. Another reason is that, while my team has experience in a wide range of languages and platforms, PHP is the common denominator since most of our work is written in PHP. Another reason is that it works just fine. Just write an infinite loop, don't do anything stupid, and let systemd or supervisord manage it. Honestly, your question suggests to me you're willing to knock it despite not having tried it (at least not in the past decade or so).
This is super wrong. Laravel has a lower barrier of entry and is much quicker to spin up and get going. For an MVP it's perfect, but once sites get out of the MVP stage it doesn't \(or it used to not\) handle scaling as well as other projects since it's heavily opinionated. Symfony is more difficult to get going but more powerful. It requires more configuration by the user which takes more time, but it's not very opinionated. Symfony has redefined the entire PHP eco\-system with it's modules that most major projects are now dependent on, including Laravel and Drupal \+ many many others. [https://symfony.com/projects](https://symfony.com/projects)
&gt; Not sure what to make of this code Post it in /r/phphelp
Ha, instantly see a bug. Will execute one run regardless of the max runs param. Could have guessed that anyone writing such code wouldn't write *bad code correctly*........
It does work on phalcon.
I think a lot of the hate is because its the current cool thing to hate on. Much of this is accepted by new programmers/CS students that just learned beginner level Java or Python, and since PHP is different it must be bad. I started programming in C so I‚Äôm more pragmatic about languages. If I need to make a website I go with PHP because I‚Äôm not wanting to sit around Starbucks oiling my beard and tweeting about Bad Deisng Fractals (lol), but instead I get shit done.
Do you mean $maxExceptions?. Otherwise increase the run count (ignoring exceptions) in a finally block (PHP 5.5).
I agree that the size of the community is of concern - also to me, and some things in the framework too. I have worked out my own solutions here and there. Speed is one of my absolute main concerns. I have for example written a small extension in zephir myself to speed up some things and I intend to do that for larger parts of my applications in the future. I have never found the community to be outright unhelpful, they're always polite and considerate, but I have experienced that important bugs (and my PRs) went ignored for too long. I took the approach to just patch my own version and keep it in sync with the official version. However, I think it's better today. By simplicity I mean two things. 1) it's easy to remodel the structure of the whole framework in ways that better fit my needs. 2) even though phalcon is a compiled extension the code of the framework is very simple to follow and understand compared to Symfony which I used before phalcon. I believe this is because Symfony is forced to do all kinds of magic and trickery to get things done with acceptable speed while phalcon, because it's compiled can do them straight forward without any speed penalty. That said, given all the positive talk about laravel I'd probably recommend that to a newcomer rather than phalcon because phalcon needs to be installed on the server with a few other extensions and libraries as well.
Just use Laravel. You'll find it easier, more direct, less wiring, and more people willing and able to help. All of the possible reasons to avoid Laravel will NEVER affect your project unless it gets tons of traffic and/or becomes exceedingly complex.
Well ok sure, keep the sword razor sharp and at the ready, but don‚Äôt waste your skillz on the Python folks, save it for IMPORTANT fights like Kirk or Picard?
This is a really good idea e.g. pages with personal info should always ask for password, or opening any admin control should always ask for password. Thanks a lot for this üòò
This is looking promising. I'll check it. Thanks.
Whats your attack model? If the attacker had access to the cookies of browser, the user has bigger problems to worry about. Just mark them httpOnly, https, and samesite where applicable. If you fingerprint the browser, this always results in annoyances to the user in case the user is on a shared connection which is the majority, or if the user updates browser.
Some legit arguments can be made against PHP's standard library, this is one of them: ``` array_map(callable $callback, array $array1) array_filter(array $array, callable $callback) ``` Luckily the language has improved over the years, Today, with proper IDE support, developing in it can be quite pleasant. Which framework you choose in is a non-issue when you're proficient enough in the language. A good starting point is laravel &amp; symfony.
Oh please don't! Do you really want to login to the site again after updating your browser?
PHP7 is actually decent (though some of the leftover standard library APIs are awkward/bad due to legacy compatibility) the hate for PHP has everything to do with it's history. it was pathetically bad for many many years. PHP5 was the first version that didn't feel like handicapping yourself to use. PHP7 is the first version of the language that is worthy of choosing for its actual merits. 
I took over a Symfony project years ago that has me flabbergasted to this day. The agency "used" Symfony. They put the entire application in each controller constructor and copied the code to subsequent controllers so there were numerous copies of the application riddled throughout the application. It was so bad that it was honestly quite impressive at just how bad it was.
I like symfony also. I think it's been very good since version 2 at least though. 
I understand what it does...
not my code. It's probably what the author meant, but IDK, they are not available for comment.
;-) I like that, but I think it's the intent it's in a bit of code to call an API which apparently throws exceptions (at least according to this code).
Throw it a condition that is would check for the the particular error expected and re-throw the exception otherwise, and there will be no reason not to approve. 
It's more looking at an old code-base. There is no record of the business problem it solves, so I'm thinking to just remove it and see if it causes problems. Profiling shows the damn thing sometimes takes a full minute to complete a few simple HTTP API calls in worst case, but in that case either the API library it's wrapping, or the people providing the API need to pull their finger out at and fix the problem.
If at first you don't succeed, fail, fail again.
you could store just an expiring auth token in the cookie, then validate that if it's matched using the user-agent string (unlikely to change), the IP (more likely to change), or any mixture of things that should be sent in a valid request.
Please test that with users so you're not pissing them all off or impacting their productivity.
Sometimes errors are inevitable. We have such a loop around a Google Analytics API call. Though I forgot to mention an exponential delay also implemented there. But of coruse if there are people who you can push to fix the error, better to go this way. Either way I would start from logging/emailing errors to get an idea what is going on.
why not? Chrome isn't on version 1825 and you can check for parts of the browser string. You couldn't just use browser UA anyway, if used on it's own it's worthless as the attacker would have access to it.
and encrypt your user directory, and use different passwords for each service.
Yeah that was my thought although it does have a maxRuns argument to limit that and doesn't have any of that crazy `0` or `-1` case crap.
I'd just do it once per session, or after an inactivity timeout; but it depends on what kind of stuff you're securing.
Wow. Just...wow.
Love building custom applications in Phalcon. Ability to customize my code base from the ground up and still have the performance is a plus. Phalcon Micro Api &gt;&gt;&gt;&gt;&gt;&gt;&gt; Lumen
True. I also like the zephir language to build my own extensions.
If it never throws an exception, it ends up in an endless loop....
There are reasons to use Laravel over Symfony. Laravel is using Symfony components and it's less barebone than Symfony out of the box
Here is your history lesson: PHP itself was a simple scripting tool once upon a time, but it was easier than PERL and 100 times better than ASP PHP/WEB/HTML was frowned upon by C/C++ etc developers because it was so "sloppy" and wasn't a real language. However it dominated the internet and made changes over time, just like any other language does, to become something quite powerful. 10 years later or so, Codeigniter introduces a lot of people to Frameworks, other frameworks existed but CI was the popular one. It had cute features to create a view and some easy DB calls and bam.. you got Hello World showing up! Was much easier to create what you wanted in a structured way instead of 1000s of php files with includes. Then Symfony, Laravel, Cake, Yii, Zend etc were working out their features, gaining popularity, and being accepted as "professional" over the way Codeigniter did things. However all of them had legacy features that when Laravel came along, it built on top of mostly Symfony and Composer packages, took what it needed but added all the cool new features of PHP and gave us Eloquent(Db) and Blade (views) wrapped it in their version. Well within 3 years, Larevel went from version 3 to 5 and each iteration changed about everything and old code became outdated and couldn't migrate to new base etc etc. This particular structure changes and ongoing alterations, was impressive to some and frustrating to others. But the world around us evolves. So the cool new thing to do was build API calls only due to Mobile Devices. No Views Needed, plus with all the new JS frameworks, the "full framework" wasn't really needed. The new goal was to return JSON really really fast. (used to be XML but that was bloat). Laravel, for example, framework was too bloated to handle this so they made a smaller version called Lumen. Lumen, howeever, is still slower in response time than Slim or Phalcon's Micro Apps (which run 10 times faster) Phalcon and Ice came along and decided to create Compiled C Frameworks that install on the server giving you extensions to PHP at your fingertips without a code base of files you have to install. You can run a complete API system with ONE PHP FILE now, and some people think that is cool. So the last 5 years, it has come to heated battles of who is doing what better, what is the right way, etc etc. But ignore all that and pick whatever tool you feel makes you happy today, because tomorrow you will be rewriting your code anyway and it will probably be in something else. The only solid thing in all of this is Composer. All the other frameworks just give you a layer on top of it to run the packages. 
This is basically a \`retry\` function \- it's fairly common for unreliable endpoints. The only issue jumping out at me is that it doesn't return the result of the function or raise its own exception to signal it is giving up.
Popular PHP Frameworks: [https://github.com/codeguy/php\-the\-right\-way/wiki/Frameworks](https://github.com/codeguy/php-the-right-way/wiki/Frameworks) I'm a fan of Opulence. Dive into the project you want to accomplish. Not the framework. A lot of framework components can be installed, decoupled, using Composer, the defacto package manager in PHP. What yarn/npm is do JS. You can pick and chose what you want and build it on Slim, of Phalcon, for example. Welcome to PHP.
I came across a similar Helper some time ago. Saved it because I've actually been in the position where I needed it. Haven't actually used it though. I should retry using it again. 
https://github.com/packaged/helpers/blob/master/src/RetryHelper.php Also came across this one while searching through resources for the first one: https://github.com/stechstudio/backoff
That is the best idea of the thread. :+1:
Hmm maybe. But I feel like half the devs I meet here in Berlin prefer Laravel. The other half loves Symfony. The cool thing is, though, that we all can agree on how awesome both of these frameworks are :)
&gt; correlation does not equal causation It sure does not. But let me check a random French job board for [php jobs](https://remixjobs.com/Emploi-php): I don't see a lot of Laravel contrary to Symfony. Frameworks are like project management solutions: it spread because you have people pushing them to make money. The Symfony backers had more marketing power in the EU. 
Back when it was new, Code Igniter felt so awesome. But now I hate working on our legacy CI apps. So many bad practices, it really makes me appreciate Symfony even more.
Symfony and Laravel are both solid choices (no pun intended :)).
&gt; that we all can agree on how awesome both of these frameworks are Having seen how the php ecosystem changed between the first release of SF2 and now, we can thank them. And the composer team, php-fig, thephpleague, paragonie, ircmaxell. And the crazy people behind the php internals and the php documentation.
I work with a pretty large codebase. We don't put the vendor dir into git \(there's no good reason to\) but we do deploy the vendor \(rather than running composer on our deployment boxes, which is very risky\). We check in \`composer.lock\` to git, which pretty much guarantees everyone sees the same \`vendor\` files. Then our deployment script runs \`composer\`, compresses all files \(including vendor dir\) and deploys that tarball to each server.
You could create a CI pipeline on something like Gitlab which will: * Checkout your project * Run composer install * Save it as a build artifact which you can either download and manually deploy or have the pipeline do it for you. https://docs.gitlab.com/ee/ci/pipelines.html 
+1 for Symfony over Laravel.
I use git in the vendor dir, it are submodules in the main repository. Some are own repositories, to manage versions. I am not using composer that much
Interesting stuff. How is Async PHP implemented? Multi\-processing?
The fact it's been highlighted here and nobody really knows what it's for or does kind of explains everything really. Wouldn't pass code review where I work that's for sure.
i suppose but that is not a return value , as in there is nothing sitting and waiting for a synchronous return, it is just raising another event. The original "write call" would still be considered to be returned as soon as it successfully passes the message to the bus. You'd also have to be in a situation in which the system can raise events back to the user (push notification or sockets) which is not always the case though it seems like more system are being designed thatt way
Please, don't add vendor, or you will kid so many kittens. Just add composer.lock and on the servers execute only composer install. You fill have exactly same code 
In CQRS the commands should not beam back events about their completion, lack thereof, or send any other information back. It's like this: - Commands get thrown into a blackhole. The observer never sees anything back. - Any changes or events would be coming back from one of the read-only projections based on the *event stream* coming out of the command handler(s). The distinction may subtle. I mean who cares if the command handler sends back an event, or the read projection sends it? But then that's the entire point of CQRS. That you seggregate those responsibilities, and the command handlers never ever ever ever return anything themselves. As for async and sync, tunneling between them is very easy (if not always practical). Yes, call+return becomes two events, and likewise if you have "event X to Y, and then response event Y to X" you can abstract it as an asynchronous call+return. They are interchangeable, as long the the returning event doesn't take so long, the synchronous caller times out. But CQRS isn't about that.
I have done this before, i'm phone now, later i'll share my experience with you.
one of the filters in ublock is for .wasm files served on github.io unsure why.
one of the filters in uBlock origin (and possibly other lolckers) is for .wasm files served on github.io, unsure why though.
Do an array map in both PHP and Node and then ask yourself if you hate PHP
If you're looking for some experience I would suggest choosing something that you use already thats written in PHP and helping out with it. For example I work a tonne with SilverStripe \(a php CMS\) so I've done the odd bug fix, etc for the CMS itself and addons that I've used. If you can't find something you use that you think you can help with you could go over to Github and check out the trending repos and see if you can help on any. Another option for just learning is to find some small php app and try to rebuild it. I've found it helpful in the past when learning go lang as it let me understand some of the core concepts that I was missing in regards to how they manage state/environment If you're just looking for a fun idea I would recommend having a look into GTFS and trying to write an app with it, GTFS is basically a way of storing a tonne of info about transit systems, e.g. all the trips/routes a bus takes, the stops, the times, the actually gps shape. With that you can create some pretty fun interactions such as a map that shows where all the buses are, on the backend you can experiment with trying to import the data performantly and ensuring during the import your site still works, looking into how to get the timetable from the database \(way trickier done than said\). If it interests you feel free to PM me and I can help you out with it and give you some pointers
Assuming this is a web app, might be worth getting some browser tests in place, even if there's only a few sanity-check tests. It requires a bit of up-front effort, but it is amazing how many times it can save your bacon once you start doing refactorings. 
Heads up on typo: &gt; Do you work on different project with different **datbase** backends 
I've tried a few things to varying degrees of success: * Reading a book for a new language that gets you to build a project, for example [Programming Phoenix](https://pragprog.com/book/phoenix/programming-phoenix). * Try something really different from what you normally do, for example I started playing around with procedural generation and making caves \([example of caves](http://www.roguebasin.com/index.php?title=Cellular_Automata_Method_for_Generating_Random_Cave-Like_Levels)\) which can be fun, especially the visual aspect * Stop doing hobby development and reading about it for a few weeks or a month or so, this will help stop burnout
+1 for the recommendations on adding composer.lock and running `composer install` somewhere *other* than the deployment server. the main downside using this pattern is the possibility that a change to composer.lock would require changes on `composer install` and packagist/github not being available at build time. more often than not, you won't see deps changing (hopefully), so you can usually get them from the build system's cache. otherwise, you can look into using something like packagist.com to mitigate this problem: https://packagist.com/features/mirroring-composer-packages
You might wanna read [Modernizing Legacy Applications In PHP by Paul M. Jones](https://leanpub.com/mlaphp)
This seems straight forward, but I‚Äôm worried operations is gonna push back on modifying our deployment process. The impression I‚Äôve had is they‚Äôd like to try and keep everything as similar as possible between the legacy code base that doesn‚Äôt support composer that the majority of our clients run on and the modern environment. When you‚Äôre deploying, do you already have those vendor projects locally accessible or are you fetching them from some CDN? Is there a concern about an inability to fetch those dependencies during a rollout if the CDN host is down? Trying to think of things i might get asked. I have a knack for looking like an idiot in front of ops and I‚Äôd like to break the cycle.
Change is always a hard sell, but using a package-manager as part of your process generally results in better software in the long-run. We have some local dependencies (via a host GH instance) but most of the dependencies are stored in GitHub proper. We've never had a significant issue related to a public GitHub or NPM outage.
Please Join here https://discord.gg/NgHdRXE
&gt; I also dived into mysqli and heard there's more better one called PDO.I am currently doing some basic projects that has simple CRUD functions. PDO is more flexible and therefore more widely used. If it makes no difference to you which one you choose I'd recommend going for PDO for that reason alone. Both support parametrized queries and things of the sort so you can't *really* go wrong here whichever choice you make in the end. &gt; Should I dive into Laravel right away? Honestly, if you are familiar with OOP concepts and things like DI, REST and MVC, I don't see why not. If you happen to know all of the design patterns by heart, then you should know Laravel Facades aren't Facades in the GoF sense. Just mentioning this to take away any confusion before you start, not to rip on Laravel. It's a good choice. Laravel has a pretty active subreddit. Also the online documentation is good and the source code is insanely well commented. &gt; What portions of php do I need to have a strong understanding of in order to feel at ease with Laravel. The following tips would actually apply to any framework you decide to go for. [Namespaces](https://secure.php.net/manual/en/language.namespaces.php), [autoloading](https://secure.php.net/manual/en/language.oop5.autoload.php) and especially [Composer](https://getcomposer.org/). Composer is kind of like Maven or NPM/Shrinkwrap. Composer is ubiquitous in modern PHP development, and all modern frameworks rely on it. Composer leverages namespaces and autoloading to make packages/modules easily and transparently available to you. The concepts themselves are simple but when combined are very powerful and IMO this has been a real revolution in PHP land. See also [PSR-4](https://www.php-fig.org/psr/psr-4/) and the examples linked at the bottom of the page. In general, I would strongly recommend you look at www.phptherightway.com. It's what the name suggests it is: as close to a definitive document on best practices in PHP as any that I know about. I would recommend it to anyone new to PHP, whether they are a noob or a pro. &gt; In django I used Django Rest framework to make RESTAPIs.Does Laravel do that in php? It's been a while since I last used Laravel but I believe it comes with a command line tool that lets you create boilerplate RESTful controller classes with a one-liner. :) Happy trails!
Maybe it's because European companies visit, talk at, sponsor, and have stands at conferences in Europe more often than in the United States. And of course vice versa.
I know what you mean. I started out with CI, and then tried out Laravel and was like, wtf is happening here! It seems like there is a bunch of new stuff I need to learn. 
&gt; I imagine Taylor reading symfony docs and then saying 'wtf is this shit, it's too hard, I'll do it my way' Probably more of 'wtf is this shit, it takes too much to set up, but I could write a framework that glues this all together in a more streamlined way'. It's no secret that Taylor and the Laravel community in general take a lot of inspiration from Apple. From marketing to the product itself, everything is streamlined and made to work intuitively out of the box. And in the same vain that OSX has its shortcomings as a result of that goal, so does Laravel. But a good understanding of the system makes you recognize the benefits. I used to develop on Linux. After switching to OSX for my day job, the polished UI and UX of OSX caused me to go out an buy a macbook for personal use. I imagine Laravel is the same way for a lot of developers.
You‚Äôre conflating symfony jobs being popular in Europe with the cause of that being due to the founder being there. 
F3 (fat free framework) doesn't get aot of live but the community is awesome and doesn't force you to use all its components, you use what you want and ignore the rest. Its fast and well documented. It also includes PDO db calls or you can use anything else (or an ORB).
nice. we self-host gitlab and i just ended up putting the OSS v2 registry on top of the NFS mount which is mounted to the gitlab registry storage pool. i needed to get at the manifests to scrape image labels, which this let me do. cool that you figured this out tho.
Ah, is that via the Docker API? I found [this article](http://www.pimwiddershoven.nl/entry/request-an-api-bearer-token-from-gitlab-jwt-authentication-to-control-your-private-docker-registry) that shows how to do that, but I didn't try it - it seemed rather involved to me. I've not tried my client on a self-hosted copy, but I assume it'd be the same. 
Recently tried to do the same. I found the correct way to do this is to edit your main project's composer.json and add a "repositories" field. Look composer documentation for the exact format this should have (I'm on mobile, sorry), but I rember the path had to be relative to the project and point to that package's composer.json, I can't remember exactly if I used type VCS or path, but you may try both. Then after saving you must install your dependencies using @dev as a version number. Composer will create a symlink pointing to your packages folders. If you need more help, let me know tomorrow and I can't check my composer.json with more detail. Also, make sure your packages folder is not on the same path as the main project.
That's pretty neat. I ended up just using HTTP auth in front, since our developers weren't using this registry - just the CI/CD process. Obviously this wouldn't have worked if we were using hosted gitlab.
`docker inspect COMMAND` returns JSON on a specific image.
Thanks for the reply. I do have the repos referenced, although they do use absolute paths. I'm not sure if that would make a difference to the updating process. "repositories": [ { "type": "path", "url": "C:\\Libs\\MyLib2\\src", "options": { "symlink": false } }, { "type": "path", "url": "C:\\Libs\\MyLib1\\src", "options": { "symlink": false } } ]
Awesome resource! Never heard of it before, thanks for sharing! 
&gt; Besides, you can trow away Doctrine in Symfony, and use whatever you want, but I'm not sure that's easily done with Laravel. `composer require "laravel-doctrine/orm:1.4.*"` It's about that easily done. Laravel 5.5 has automatic package discovery, so you can start using it immediately. 
If I understand correctly you‚Äôre wanting to develop multiple packages locally that are included in a local composer.json? Check out studio: https://github.com/franzliedke/studio
Does that work on a remote GitLab instance? I am hitting into the limits of my knowledge of Docker here. I know `docker inspect` works locally, but can one run that on a remote Docker object, if one uses `login` first? I think GitLab exposes its registry API to the outside world. 
Oh. I've never used hosted gitlab. I've always run my own. Try and see if you can run the docker command during in your build script?
He can't, someone updated is-thirteen this week and half the dependencies broke.
I'm sure `docker inspect` would work in my build process (it's on CircleCI), but I think the local Docker daemon would expect the object reference I pass (hash, network, image-name, container-name, etc) to be local. I think one _can_ configure the local daemon to send requests to a remote instance, but I don't know if that is subject to the same auth system as `docker login` (or indeed whether the GitLab instance would be connectible in that fashion). 
Those telling you to use Symfony are just the old-timers who are stubborn against change (I know, because I was one of them). After being forced to use Laravel for work against my will, it only took a few months for me to appreciate it is as the far superior framework.
PHP is the bomb.com
tl;dr: Following or ignoring best practices has tradeoffs, which include upsides for doing it "wrong". I'm going to be the odd one out here, and tell you that ignoring their recommendation may be the best approach _at first_. If you're dealing with a large existing codebase that has real users, there's more to consider than what you have to do in a random hobby project. I speak from experience here, having added Composer to an existing codebase that started before Composer existed. Following best practices (gitignore vendor) means: - No dependencies directly in your repository, keeping it smaller - Somewhere in your build/deploy process, you must run `composer install` - This means if any dependency is no longer available at its source, you're screwed - You can set up Private Packagist to deal with this, which is yet another thing to set up and maintain. It's also not free. - Vendor updates are way easier Checking in vendor, against the recommendation, means: - Vendor updates are a pain - This tends to mean you do updates less often, which can result in security issues going unpatched - Lots of third-party code in your repo - Temptation to "fix" third-party code locally - Zero chance of new deployment problems due to e.g. github being offline, a dependency being removed upstream, etc - Near-zero chance of "hey your code broke my machine!" "run composer install you putz" "oh, right" - But a significantly higher chance of forgetting to actually check in your vendor updates What's the right answer _for you_? - If you want to introduce the least change possible right now, check in vendor. You can always delete it later after further testing or updates to your process - If you want to do it right from day one, follow best practices. By doing this, you're accepting the risk that an upstream codebase might be unavailable right when you need to push a critical bugfix, resulting in extended downtime. This can be mitigated with additional work. What's the chance that this actually introduces problems? Across "six or so" packages, probably very low. If you're already at the mercy of github (i.e. you're using github.com for your company's source control; in contrast to an on-prem solution or different host), _way_ lower. In many years of using Composer, I've had a single package actually deleted from the upstream, and it had been marked as deprecated for a long time. In the long run, I would _strongly_ advise getting to a point where you're following best practices, leaving vendor outside of version control. But as you know that means changes to your deployment process, and possibly new infrastructure. _Whatever_ you do, do not put yourself in a situation where you're running `composer install` on a production host. Vendor gets pushed out with all other code.
Every tool has it's strengths and weaknesses. Before Node, JavaScript was one of the most hated languages around. I remember when Rails came out Ruby became the best thing since sliced bread, for a little while anyway. The wheel will turn again, probably sooner than later. Ignore the technology snob neck beard hipsters. Use the tool works best for you, for whatever reason.
I really love php. I discovered swoole recently and put a lot of faith in it as a replacement of nodejs for building fast and scalable api but unfortunaly, it's fall apart in term of perfomance. So if you don't need async, php is really great and have many good frameworks / libs, but you should also learn nodejs/javascript.
Depends what needs debugging - logging more is sometimes enough. If they‚Äôre getting stuck (or appear to be), you can set a signal handler that listens for `SIGUSR1` or something and dump a stack trace to a file for future inspection. If you need more than that can offer, you‚Äôre probably into strace territory. 
There are also things like https://github.com/php-pm
Best practices is to always use tools designed specifically for what you're wanting to do as often as possible; you'll already find specific suggestions for tools to help work with daemonizing from others here. If you need to write it all out, first make sure it properly daemonizes and handles all signals cleanly. For memory related issues, I've always had problems with memory deallocation for long-running php programs whether run as daemons or not. Depending on your version of php and settings, php is sticky in allocating memory refusing to actually release it. Sometimes setting a variable to null helps and sometimes unsetting variables works, but not always. When you run into an issue where memory deallocation does not work, php is holding onto the memory allocated to it, but will mark it as available instead of releasing it back to the operating system, and there are valid reasons for this functionality. For the long-running, data processing programs I've had to run I've always had to resort to forking a child process to do the actual data crunching so when the data in memory is no longer needed the child process terminates and the operating system properly deallocates the memory. If such a child process wasn't used, then the program's memory footprint would never shrink in such cases. By forking, the parent process remains small in memory while the overall footprint expands and contracts only as needed. As for specific monitoring tools, if approached correctly then any system tools for monitoring processes works.
Don't. https://software-gunslinger.tumblr.com/post/47131406821/php-is-meant-to-die
The most annoying thing about this is that when I'm working on a website that uses my own framework I generally want to symlink to my dev version of the framework on my machine to see how new things would work in a real website but I do not want to commit different composer.json to git because other devs working on the same site might not be creating new features in the framework. Even if they were their local copy of the framework might be in a different location relative to the codebase.
Just read up on writing daemons for *nix systems - follow all the rules, handle signals, fork your daemon, set process title so you can monitor it easilly, work with PID, remember that connections have timeots, so you need to keep them alive - for example mysql connection - ping it every so othen. if you are using PDO - there is no "ping" method, so just send "SELECT NOW()" or "SELECT VERSION()" or whatever very light query you fancy, say, every 30 or so seconds and it will keep the DB connection alive. Check also what MySQL connection timeout is set to. Same goes for all the network connections like redis, rabbitmq and whatever tools you are gonna use.
See [`igorw/retry`](https://github.com/igorw/retry) by [Igor Wiedler](https://igor.io/archive.html).
I have some services running with php in docker containers and they are able to run several weeks without restarting them (highest was about 4weeks but they were only ‚Äûrestarted‚Äú for updates). I‚Äòm using ReactPHP for them and it works like a charm - even with blocking sql queries (yeah I know it kind off defeats the purpose of an event loop but hey, reactPHP is really good even for things that aren‚Äòt heavily dependent on async processing). The containers got a memory limit and restart-always policy so even when there is a memory leak (which there isn‚Äòt) the containers will automatically be restarted. Footprint is very low, just a couple of MB ram. The script itself accepts signals (which is now supported by ReactPHP natively) to gracefully shutdown. The only thing that took me a bit to figure out was how to start php as PID1 inside of a docker container (as I was a newbie to docker).
You can always host your own proxy for packages that are used by your organization with something like satis. See: https://getcomposer.org/doc/05-repositories.md#hosting-your-own
In your opinion, why do you prefer symfony? 
I learned Symfony before studying Laravel, and it just felt like a step backwards. I feel like there's a false sense that Symfony is much more difficult, and that drives newer folks to Laravel. Laravel used to have a more simple directory structure, but Symfony 4 has achieved this. I prefer Symfony's form handling (don't have to use a 3rd party). I prefer twig to blade for templating. Maybe that's configurable, but I am a big proponent of opinionated frameworks and following standards for the purpose of maintainability. Back to the form handling, the course I was following had form actions defined in the blade tempalte. I'm assuming he was using a 3rd party library because there was nothing built in. This felt sloppy in comparison to Symfony's form builder. The routing in Laravel felt like a mix of old school and hack. This isn't any fault of Laravel, but PHPStorm support for Symfony is much better as well. Granted, it was a while ago I evaluated Laravel, but I saw enough to know it's not for me when I have the choice to start a new project with it.
That's pretty outdated. We have some daemons running over a year while using Doctrine, why don't they crash like they're supposed to?
I think it would be a good idea to add the insights section to the post. Better yet, I would re-post this as a link and add insights as a comment.
&gt;Several functions should be replaced by operators : array\_push, is\_object, func\_get\_arg, chr, call\_user\_func. OK, using `[]=` for `array_push()` is clear. But the rest? What is the operator notation for is\_object\(\)?
&gt;md5 is the only widely used crypto function Oh no
I think it's referring to instanceof, which is really a keyword... 
It's not specified whether it is used for storing passwords or stuff like that, so these might still be other, legitimate uses.
`func_get_args` can be replaced variadics ``` function test($param1, $param2, ...$arguments){} ``` `is_object` can be forced by php7.2 `object` type ``` function test(object $obj) {} ``` 
i feel you bro
yes. Just like crc32, md5 may be used for cache naming, where security is not the target but a side effect. This is not differentiated. Yet, changing those md5 to password_hash() or hash() should be an instant task. 
I don't know why people are downvoting you, but that was my feeling, it should be solved by explicitly handling the API error.
Yes, that's the one. Unless the method is checking for ANY KIND OF OBJECT REALLY, testing with instanceof provides the added value of filtering it. 
I'll keep that in mind for the next time. Thanks for the advice. 
package-lock.json
This is a good thing. Gives the more compitent of us more jobs.
no \`var\_dump\` .
I use it when I am dynamically building pdo named parameters. I do an md5 of a counter to make sure :param1 doesn't fill in :param10 it becomes :param.md5(10) 
I use Laravel‚Äôs dd() dump-die so often, I feel like that should be standard everywhere.
Hello, Do you know any php 'discord channel' for quick help and after hours talking? :\)
Fixed. Thanks!
Init all variables. Makes it clear what's available too.
PHP 7 has finally been released some time ago with many great new features ‚Äì and it will also help you keep your WordPress website in tip-top shape. See now how to use PHP 7 in your WordPress to make it faster. 
Backwards compability is probably an important issue for many of these projects, so I'm guessing it's not an option for those that want to be able to run on older versions of PHP. 
God damn PHP is an ugly language 
Gotta switch it up to debug! 
As ugly as Javascript. 
Great php usage and update guide for wp users 
Hi I am doing web development specially in php from last 6 years, I am at senior engineer level at my job. currently i am thinking of doing side project just for fun, i was thinking about doing project management project kind of JIRA but with limited features , would this justify my experience or should i do more be like creating frameworks with DI/IOC , creating libraries but this feel like more for me.
Just like any other natural language in the world. Take English for example. A local germanic dialect at first, it was influenced by Norse, Latin and French and become quite a mess. You could spell "fish" as ["ghoti"](https://en.wikipedia.org/wiki/Ghoti) in it but who cares? Half of the World is speaking it all right.
Blogposts and fake accounts will get you banned on Reddit quickly. Yes, everybody should move to PHP 7. Wordpress should refactor their code too, but they won't.
So, I recently reviewed Keybase, They have a Nice Community, for Devs and others Hacking stuff, Anyways. I don't know if it may sound wise, If I create another version of it, Explicitly for Hackers, and of course Dev Ops. Implement Tournaments, and Hackathons every now and then, What do you guys think? :\)
Look up job listings online. It will give you a more accurate information than someone's opinion on reddit.
From my perspective as a hiring manager I‚Äôm more interested if it‚Äôs something you‚Äôre excited to talk about than if it‚Äôs a specific type of project. Do the thing that‚Äôs fun and that you‚Äôll learn from.
You just have your friend following you around to hype your posts? Or is that other account even real. I‚Äôm not sure which is sadder 
Honestly, a lot of PHP criticism is perfectly valid and is not politics or religion. However, it's *overblown*, kind of became a meme in itself to hate on PHP.
...what are you doing where that‚Äôs a risk? If your parameter names are user supplied (which is the only situation I can imagine that being an issue), that‚Äôs just a fancier SQLI hole. 
You cant go wrong with Laravel.
I'd go for a JIRA clone
Php is not worth learning now no. Nodejs is the way to go for the foreseeable future.
I almost never use that since I discovered PsySh and Clockwork
Pgp for hackers? Pgp is a weak crypto algo..
It should be instant if it is in new code, not quite that simple (but still easy) when you have an existing database.
Serverless, Lambda, Faas with Node.
In this day and age, I don't think anyone really cares how big your package is, it's more how fast it is and is it well built. Looks cool though :)
For Message Signing, but if there's a better algo you can prefer, Say it pleaseeeee? :D
Yeah thats the point, though i have focused on the size(30kb) to let people easily understand how small the package is. However, thanks for your positive comment, if you have time please play with this and let me know your thoughts. I made it to maintain some of my static sites, and it worked for me pretty well.
By the way I was also thinking about creating my own Mathematical Algorithm for Hackers to guess, and decipher or decode. :\) I don't know if its a win, But who knows. It might be a hit someday, Never could guess the future though. For the Algorithm I had in mind, It might have similarities to Diffie \- Hellman Algorithm, Although reconfigured into my own Calculations. :\)
Correct me if I am wrong, but isn't everything meant to be under `/src/`, `traits` and `store` and above this. As both `traits` and `store` and still apart of the source.
Yes, you are correct. I will update the file structure soon. :)
Also, you probably find the comments in the code misleading because later i updated most of the methods but forgot to update the comments.. 
Features: * Digital Signature, and Verification of Messages. * PGP Storage, and Key Exchange Platform for Hackers. * And stuff, Like you know? Privacy, Secrecy, and Keys.
I find it hard to believe that `array_merge` is used more than `strpos`...
So yea I just did that, there are jobs for php in junior departmen wich fits me I guess, but they are all WordPress stuff :\(, guess it might not be worth giving money to learn PHP even tho its easy.
how do u delete all cache? 
I've never seen environments where code editors are forced. Usually there is a recommendation to go with one thing over the other, but at the end of the day it's about whatever tool set you to be more productive. I don't think it's unreasonable to standardize on a single tool though. Having a consistent configuration for all Developers can remove a lot of roadblocks in variability in the teams velocity.
&gt; is it common practice to have a require that devs use a particular IDE simple... hell no! &gt; only way to provide internal technical support wait what? for what does any dev need tech support on their own IDE? I haven't seen this in my whole career. Forcing any developer on a certain IDE is counter productive. If he is using vim and is good with it, let him do it. If you are not familiar with the IDE he is using, he can't be a 100% productive.
Hi, you can delete all the stored cache using the `deleteAllCache()` method, please go through the docs at https://sleekdb.github.io/ and let me know your thoughts :)
is md5 is a crypto function? 
intuitive 
I wonder if they're just looking at final products, if functions really only used during development wouldn't get very high ranking.
You relies on file_put_contents (without LOCK_EX flag BTW), which means (at least): - no atomicity (crash or i/o error in the middle could corrupt data) - no isolation (concurrent read could read intermediate changes) IMHO you should make it clear in the doc or fix it.
Yes, but a dated one.
They are form fields that are well defined and sanitized before it gets to the query builder. The iterations are selections in a drop down. So it's like :dropdownfieldname.md5(item counter from the drop down). I don't think there's any chance of sql injection attack using this method but I suppose I could be missing something. 
[PHP-Ref](https://github.com/digitalnature/php-ref) is quite nice
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/u_matthewesp] [Top 100 PHP functions you should know](https://www.reddit.com/r/u_matthewesp/comments/8o2488/top_100_php_functions_you_should_know/) &amp;nbsp;*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))*
ü§†
I use md5 for quickly hashing something for creating unique keys for caching reasons as well as for verifying the integrity of data like a checksum. seems like a perfectly reasonable usage of it. I would never use it for passwords. bcrypt or libsodium would be the best thing for that.
Maybe `$foo === {}` ?
Anything coming from a form can be tampered with. What you've done _might_ be safe (I'd have to look at the code to know for sure), but it's definitely an anti-pattern, and a completely inappropriate use of a hashing function. Really the only time you should have generated parameter names is from a query builder - and those tend to either match known column names or just use an incrementing counter. In either case, there is zero chance of a name collision (unless the counter itself is broken; e.g. it fails to increment)
It's one ALTER (maybe) and a small code change in the vast majority of cases. Granted on a high-throughput DB an alter may actually be non-trivial, but such a change absolutely must be prioritized.
Simple answer, yes. Its used for so much more than WordPress and as a developer it will only help you to learn as much as you can about any and every language/tech that you can.
THANKS
yeah, I force phpstorm onto my peoples... with php inspections.
We have a standard IDE where I work at. That's mostly because we have many home made tools, and that's the easiest way to get everyone up and running. It's not impossible for someone who wants to use their own IDE. 
Sure but if that dev is working on a large codebase with little to no documentation to help then maybe they might not be able to read through the code as perhaps an IDE would in tracing back function references?
I'm there. ;\)
Yes, but it is not considered a secure one.
Why not use ":dropdownfieldname".intval($item_counter) ? Note: dropdownfieldname should not come from the form. 
Party pooper here: tests please! Don't continue further development until you got extensive tests (both unit and e2e), as otherwise the package cannot be relied upon downstream, and is just a cool demo.
&gt;is_object can be forced by php7.2 object type &gt;function test(object $obj) {} function test(object $obj) {} is not a replacement for is_object(). Is_object has a different use case; for example when a function has an argument that can either be an object or something else.
https://www.reddit.com/r/PHP/comments/8mh6cu/why_is_code_igniter_not_recommended/