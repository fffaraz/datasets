There is also[ an interesting link](https://w3techs.com/technologies/history_details/pl-php) in the sidebar, showing that in August `PHP7` is finally surpassed `PHP4`(!) usage. 
Jesus, as much as I'm glad PHP7 is picking up steam, I'm nauseated by the fact that PHP4 is still in use. Shit's older than Windows XP.
I think the ratio remains pretty much the same.
&gt; Shit's older than Windows XP not really. PHP 5 came out in 2004 which is 3 years after Windows XP. The last release of PHP 4 was in 2008, 7 years after Windows XP came out and 1 year before Windows 7 came out. Still. It's very old and people really should move on.
I think there are no people behind there servers to move on. Just some abandoned projects nobody cares of.
 php -r “readfile(‘https://getcomposer.org/installer’);” | php Hahahaha ... no. (It won't even work because of the quotation marks.)
Things that make these stats useless: - We don't know how many sites they don't know the language for, might as well be 99% of all sites. And then those 99% might be written in COBOL for what we know. - They don't count servers, they count "websites", i.e. they likely count domains. There are millions of cyber squatters running their "websites" off a single server (and that is probably one reason why PHP4 is still showing up so prominently in these stats - they don't care). Also it'd be more interesting to see stats about how much of traffic (in page visits) runs on PHP, as the Internet is full of dead sites no one visits, which are written in PHP. Also, do note the majority of PHP sites are WordPress sites... They're technically PHP. But not the kind of PHP any sane developer would write in 2016. 
I don't understand how this is an argument for storing database metadata outside the database.
That's it. I'm never gonna use a framework anymore.
I use phpmig and write versions to file, zero issues.
This looks like it was written from a beginner. It doesn't even come close to being REST. Pretty much everything is wrong from urls, over response data, to the returned status codes. There is literally no error handling. Everything but listing all users will produce an unhandled exception when an invalid id is passed as argument. This in itself is bad enough, but being hosted on a blog from a _managed_ cloud hosting provider is outright scary to me. If the rest of their work is half as sloppy it's a disaster waiting to happen.
And what % of web sites uses wordpress?
[WordPress is used by 26.6% of all the websites, that is a content management system market share of 59.3%.](https://w3techs.com/technologies/overview/content_management/all)
&gt; Also, do note the majority of PHP sites are WordPress sites... They're technically PHP. But not the kind of PHP any sane developer would write in 2016. That does not make *any* difference. Wordpress PHP is still PHP. 
&gt;I don't think you understand Laravel or PHP as well as you think you might. Maybe, I don't have 15 years of experience in PHP after all. But I would prefer if you could prove me wrong rather than just saying that, as this comment doesn't get me anywhere :) &gt;I think you might be attributing to Laravel what you might have experienced with other frameworks in other languages. Such as? (no trolling, I'm just not sure to understand why you are getting this impression) &gt;Laravel is only opinionated in so far as it suggests a convention Precisely. To me Laravel is an opinionated version built on top of Symfony components. Because choices were made, things could be simplified in Laravel: using auto-wiring as a standard, have an Active Record ORM, extend a lot of Symfony components to simplify some things to make them easier to use in certain context. . If you are fine with those choices then it's good enough. But if you are looking for something more flexible I would rather go back using Framework bundle (which is what the Symfony framework truly is) which is just a DIC with a way to register extensions and expose a configuration, and then you have the Standard Edition which FrameworkBundle with all the components and ready to use to fit most easy use cases. &gt;you can tell it to GFIS. Sorry I didn't get that
@10xdeveloper This tutorial is written for beginners as stated in the title "Simple Rest Api". It would be great if you define more how the URL'S are wrong?. In the kick start tutorials the focus is manipulation of records you can see many tutorials on internet regarding this. But yes the second part of this tutorial has an extensive approach to error handling. When it comes to Production environment the approach is different for coding. 
Looks nice, finally a decent modern message handler! Thank you.
as long as you have only one server
what the OP might have wanted to say is that people should stop copying Laravel without knowing what they're doing. what I wanted to say is that this is not really a Singleton if used right
I haven't looked at your project yet - but is there any reason you built it yourself on top of Redis instead of using the [Disque](https://github.com/antirez/disque), the sister project to Redis that is focused on queues? /other than it sounded like fun of course.
Well firstly I wanted to build a purely Redis-based message queue, as I'm already using Redis in other parts of my app and don't want to have to learn and manage Disque on top of that. Secondly, Disque and other message queues provide no way of serializing/deserializing commands, and handling them via a command bus within a PHP application. So BusQue is unique, in that it combines the 2 concepts of a command bus and a message queue. And also because it was fun :D
It's not just abandoned projects. I've been making websites for small companies for years that pull their content from very simple databases. Most clients can be taught to use a simple sql app, and it gives them a sense of ownership so they don't come running to me for every tiny update. Some of these sites have had the CSS redone to be responsive or get a facelift, but if the mysql and php part is functioning, I don't touch it. That means leaving the server alone too. Why bother?
Thanks for feedback but to show the records posted and updated in a tutorial id is needed to be revealed. the parameter data is caught in request variables and then doctrine take cares of all. great advice i'll read that.
I think you forgot the /s tag 
what's that
I'd argue that most of us who have been PHP devs for 5+ years have used CodeIgniter at one point or another and are grateful for it. That being said, it is an outdated framework that still has roots / methodologies set in the PHP 4 days. There is nothing wrong with moving on from it and recommending more modern frameworks like Laravel/Symphony/Silex/Lumen for new projects.
Instead of checking for dots you could check for slashes and mitigate/prevent the problem.
If it works dont mess with it
Can also question: Another framework would have made it with less effort maybe? So ryanwinchester is totally right.
Just adding another one today. PHP7 baby.
Please dont assume a significant percentage of websites use COBOL as backbone.
so "static-files" is now a server side programming language?
Wait, is PHP7 usage still so low, or is PHP4 usage still so high?
Not really, it's more the lack thereof. A bit like how often "atheism" is listed as a religion while it's the absence of it.
Damn, that's lower than I expected. It's a shame a lot of hosting providers are so slow with catching up on new PHP versions.
I expected Python and Ruby to be much higher. Also kinda surprised that ASP.NET is over 15%.
That's not how statistics work. You're thinking of representative samples. This is not a representative sample. **Edit**: Sigh, for those unaware: https://en.wikipedia.org/wiki/Sampling_bias A representative sample is, simply put, a big enough fully random sample, where "big" is determined by standard deviation of the results and several other factors, read here: http://www.itl.nist.gov/div898/handbook/prc/section2/prc222.htm Even if we blindly assume the sample is big enough, which is generous, it has to be fully random. Getting a truly unbiased fully random sample is very hard to do in the real world, BTW, it's not like running mt_rand(), because it's very easy to allow an unknown bias in your sampling process. But let's be generous again, and assume their sample of "websites" is truly random. If you then take that sample, and *exclude every single sample where you can't determine the server-side language, while keeping everything else*, that sample stops being representative, you just biased it. So the results of the remaining biased sample can't be extrapolated to the entire web. The result is useful if it was defined as "what is the share of languages on the web, that are configured to advertise themselves". I'm not saying the study is shoddy, obviously you can't detect an undetectable language. But they could've included the percentage as "Unknown", which would help a lot, and also it's incorrect to extrapolate those results to the entire web.
"the majority of PHP sites are WordPress sites" That was my first thought too but digging into it, I see only 26.6% of all websites run on Wordpress. Ref: https://w3techs.com/technologies/details/cm-wordpress/all/all That makes 55.5% that run on PHP without WP. Wordpress does take a large chunk of that but not the majority. I am surprised to see such a small percent for Javascript and Python. With how much buzz there is around Node, I thought Javascript would have a larger chunk of the pie.
&gt; People here just read 'CodeIgniter' and their fangs show as shiny as the sun. Well that's a shame. You'd think that all PHP developers would support interesting PHP frameworks, regardless of whether a particular one is their favorite.
Pairs of packaging systems for the same language make nice natural experiments: we're also asking about SwiftPM vs Cocoapods (for Swift) and cabal vs stack (for Haskell), so we can try to factor out the effect of the language and see what effect the design choices of the packaging systems are in isolation. But maybe we're too late for PEAR :-(
Aw crap. My bad then. 
&gt;Also kinda surprised that ASP.NET is over 15%. Any specific reasons for this? Azure seems to be getting more and more popular.
Did PHP ever get "real" closures yet? A closure is supposed to be able to access all other variables that would normally be in scope outside the closure from inside the closure. Do you think that will ever happen? Did the performance of closures ever improve in PHP 7? In PHP 5, I tried attaching "methods" to objects once as closure properties. I had to use magic to get them to be callable the normal way like a normal method. It worked but it made it seem like closures don't perform very well. I also would really like to be able to autoload functions in addition to classes. What do you think are the chances PHP will get this? I know there are tricks to get something similar to this working and it is not essential for getting software to work, but I really want it. What is up with arrays? I know arrays are supposedly hash tables. But if that is really true, it should be possible to create a simple linked list data structure that uses less memory than a PHP array. Yet no matter what I do arrays still use less memory... In a way this is good, because it means arrays perform fairly well. But at the same time it is frustrating because whenever I have memory performance issues, nothing that should help actually does. All this makes me think that arrays are not actually hash tables, but there are multiple data structures PHP uses to represent an array, and it simply chooses the best one and changes its decision on the fly based on how it is being used... Once again that is all PHP 5, has any of this changed in PHP 7?
Maybe it's because I'm not really into Windows development, but I personally almost never see it or hear about it. I got the impression that it mainly used to be popular before PHP got traction. (but I might be wrong about that) But when I see it the wild, it's a really old government website ;)
&gt; for laravel you require some extra permissions on the server, console access, composer, etc I like Codeigniter myself, but this statement isn't true. Laravel can be very simply deployed on shared hosting without console access etc.
Ugh.. what is this for loop doing there? That is terrible. (at 8:40 in the video) You could just do factory(App\User::class, 5)-&gt;create(); And create a user template inside your ModelFactory file like this $factory-&gt;define(App\User::class, function ($faker) { return [ 'name' =&gt; $faker-&gt;name, 'email' =&gt; $faker-&gt;email, ]; });
I think the best take away from all these comments is a) MVC when implemented correctly is easy to learn and use in practice, hence its large adoption rate over the last 10 years or so. b) Its core design goal IS to separate your form from your logic, imho it does this pretty well which makes it great for building web apps and c) most importantly when choosing a tool for a job, pick the right tool. MVC is great but not always the right way to go about things. First thing that comes to mind is an API of some sort. 
Lol nice! 
Having used (and still support) a CodeIgniter-based app for many years, I don't find it very interesting compared to any of the more modern frameworks, and especially not compared to the variety of mix-and-match packages one can use to build their own 'framework'. What do you find interesting about CI?
&gt; it's what we are saying with Wordpress, until Wordpress server will get hacked and the internet powned. All pages can get hacked. I guess that the even majority of WP users dont get powned. Which is suprprising since most people setting up a WP site know very little. But the WP-security team have made the foundation reasonably secure. And Ill add that. Through the years I visit a lot of customers that ask me to manage their Wordpress sites. I always oblige and I have yet to see a hacked one.
Is there anything else out there like this? It seems like such a natural fit for handling regular expressions. I've worked on a couple simple PHP classes to handle simple regex, but never thought to create a meta-language for it. Perhaps some sort of RFC for SRL is in order. This seems like something that could be implemented in a multiple languages! Great work!
Seems like there was a [RFC for function autoloading](https://wiki.php.net/rfc/function_autoloading) but it doesn't seem like it was ever voted on. Kind of sad. But with PHP 5.6 you can do a roundabout function autoload with a little help from composer. In composer just tell it to "autoload" the files with the functions: "autoload": { "files": ["src/MyNamespace/Utility/Foo.php"] } Then in your code you can add a `use function` statement: // assume you want to use the function bar from the below namespace use function MyNamespace\Utility\Foo\bar; bar($value);
Thanks for the positive feedback :) Yes, in fact, some of the commands are easy to muddle up. Sadly I couldn't find any better fit. But if you have any suggestions, I'm happy to hear them.
It seems silly to me that people are trying to remove the question of technology from the equation. No one would question whether or not a factory would be more profitable were its workers to have equipment which produced widgets faster and/or enabled them to make changes to their widget production easier. Yet somehow, you talk about developers using a framework in the same regard, and the tool they use is not a factor? There's a reason that companies develop the means of production in the first place. Now, someone can make an argument that codeigniter is actually a poor tool (compared to other tools) and that other tools may be equally or even more capable, but to say "they could have used any other framework" is only true in the most shallow sense. They could have used no framework. They could have written their own operating system too in order to host it. They could have run it on a cluster of 486 computers. They could have written it in notepad.exe. Of course they could have done all of these things and still potentially make $25 million in **some** timeframe. But it's absurd to attempt to dismiss the role of the technology used. It's not simply a matter of liking what you work with. What you work with can and will affect bottom line.
Thanks! I haven't found anything else like that. I've found some query builders for regular expressions like I'm using internally but no meta language. For me it seemed totally obvious so I tried to implement it, since Regex gave me a hard time before. I'd be pretty happy if this would spread across multiple languages. I might try to implement it in Java as well, but for other languages my knowledge isn't strong enough. If anyone wants to help, I'd much appreciate it.
If you want to do it 'the right way', then you do need more access on your host. A simple, normal shared hosted will not let you do a good deploy, installing/updating composer packages on production directly, etc. There are a few limitations, not as much as using PhalconPHP, but codeigniter was the wordpress for frameworks, drop it, use it, that was it.
Sadly, it isn't. Of course we'll all be biased towards our framework of choice, but being able to recognize the pros and cons of each one is a huge and important thing to do. It's not so common or not as much as I'd like for people to have that critic thinking.
nice
&gt; What do you find interesting about CI? Thank you for asking, but it's not currently in my toolbelt, and I played with it far too long ago for my opinion on the matter to have any value. For the sake of the PHP ecosystem as well as the developers who use and like it, I'm simply glad it's around and kicking, and appears to be evolving substantially for version 4.
In New Zealand there's a lot of ASP.NET jobs, more than web development jobs in other technologies.
Must have been pretty damn reliable; I can't imagine any sane developer staying around to maintain something like that. 
Reliable, or just so bad they're too scared to change it. I'm gonna go with the latter, especially seeing as that's what he basically told me.
Very, very sweet. Almost like another having another nerd down the hall to double check my expressions.
This is really cool. 
Pretty cool but I've never understood why people find regex so hard
Who doesn't? Btw, awesome project /u/androtux. Starred and watched, definitely going to be checking up on it.
Hmm, good point. Wouldn't be too bad if it's just optional, I guess.
Maybe because it is not something you must use often. If I used it more often I would end up learning it well enough so that I am not bothered when I must use it. But because it takes some involvement and I don't use it often I then feel disheartened when I have to use it. 
As someone who works with regular expressions every day... This is awesome. I don't have to bother teaching weird/obscure rules if people just use this. :]
Hm. I might end up making a node package for this
Because it's a one way trip. Putting the rules together is one thing, but then understanding what you have written is tough, especially the process of debugging it.
lots of deployment tools do exactly what you describe, but one simple script, idk.. take a look at http://deployer.org/. its very friendly for a introduction to deployment
You might want to check [Paragon Initiative blog post](https://paragonie.com/blog/2016/08/on-insecurity-popular-open-source-php-cms-platforms). They obviously are a bit biased as they have their own CMS to promote, but they still are quite trustworthy. 
Maybe Rocketeer? http://rocketeer.autopergamene.eu/
I'm tempted, but I my follow-through can be lacking at time. :) A JavaScript port would be great for the documentation so you could put everything on the client-side!
Capistrano was the first tool I heard of that did this. Although it is pretty common place now.
Next, it'd be GREAT to have some kind of "cost" algorithm to estimate how "expensive" the generated query is.
&gt; Did PHP ever get "real" closures yet? A closure is supposed to be able to access all other variables that would normally be in scope outside the closure from inside the closure. Do you think that will ever happen? I think it's pretty likely that this will happen in conjunction with a short closure syntax RFC. A previous RFC on the topic has been declined for 7.1, but /u/morrisonlevi is working on a new one for 7.2. &gt; Did the performance of closures ever improve in PHP 7? Don't know off the top of my head whether there were any closure-specific optimizations in PHP 7.0 (beyond general improvements to calls). In PHP 7.1 we landed a couple of improvements to lexical variable binding, which should reduce the cost of each bound variable. &gt; I also would really like to be able to autoload functions in addition to classes. What do you think are the chances PHP will get this? There's been a recent discussion on the topic recently: http://externals.io/thread/187 The tl;dr is that we'd like to have this, but there are some pretty tricky questions regarding how function autoloading interacts with the global namespace fallback for unqualified function calls. There does not seem to be a good answer to this problem yet. &gt; But if that is really true, it should be possible to create a simple linked list data structure that uses less memory than a PHP array. But how do you create that data structure? Unless you're implementing it as an extension, you will create it based on objects. Each object has a pretty high memory overhead, excluding properties it's something like 128 bytes in PHP 5 and 40 bytes in PHP 7. Implementing a linked list in PHP is pretty much a worst-case condition, because each node has few properties, so the object overhead dominates. (Unless you have an intrusive linked list in mind, which is integrated into the structure of already existing objects.) &gt; All this makes me think that arrays are not actually hash tables, but there are multiple data structures PHP uses to represent an array, and it simply chooses the best one and changes its decision on the fly based on how it is being used... In PHP 5 arrays are always hashtables (and wasting lots of memory). In PHP 7 there is one a "packed array" optimization for integer-indexed arrays with dense increasing keys (i.e. a "real" array). However, this only discards a small part of the array structure (4 out of 36 bytes), namely the hash table (while leaving the backing data array the same). [More on HTs in PHP 7.](http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html) 
&gt; Did PHP ever get "real" closures yet? A closure is supposed to be able to access all other variables that would normally be in scope outside the closure from inside the closure. PHP closures can access outside variables. Whether it's explicit or implicit isn't what makes a closure "real", despite what some trolls might say. Now, I'd prefer PHP's closures indeed imported variables implicitly, but I know this has been through RFC's a few times and it failed to pass every time. It's not an issue of performance. It's an issue of semantics and syntax. &gt; I had to use magic to get them to be callable the normal way like a normal method. It worked but it made it seem like closures don't perform very well. Closures are fast. Routing them through magic methods is obviously not that fast. I'd question if you need all this, maybe you can share your use case? I'm sure you can address just about any use case through traits, decorators and composition. You don't need magic methods most of the time. &gt; I also would really like to be able to autoload functions in addition to classes. What do you think are the chances PHP will get this? There's been a proposal, but I'd say don't wait for it. Because of the way functions resolve in a namespace, it's impossible to make a semantically correct autoloader for functions that also performs well. Instead, do the next best thing: static public methods in a class. Think about it - what do you care if it's \Foo\Bar\Baz\function() or \Foo\Bar\Baz::function()? You have a way to call it, and it has input, body and output like any function. &gt; What is up with arrays? I know arrays are supposedly hash tables. But if that is really true, it should be possible to create a simple linked list data structure that uses less memory than a PHP array. Yet no matter what I do arrays still use less memory... Surprise, objects also hash tables. Objects are optimized when possible (the hash table is share at the class), this yields some RAM savings, but they're not like C++ objects. You seem like you don't use PHP 7, so I'll just say you get tons of performance and RAM usage improvements there, no matter what you use. &gt; All this makes me think that arrays are not actually hash tables, but there are multiple data structures PHP uses to represent an array, and it simply chooses the best one and changes its decision on the fly based on how it is being used... Once again that is all PHP 5, has any of this changed in PHP 7? http://jpauli.github.io/2016/04/08/hashtables.html
When I first start out with it, it was very scary! Now I've been dealing with it for about 20 years now, it's not so much as it's scary, as it can be frustrating at times, even with tool like RegEx Buddy to help you out. Also with as powerful has regex is, it definitely has weaknesses.
When it's getting too complex, the [x modifier](https://php.net/pcre) helps so you can add line breaks and comments. Of course when it comes to this you should already be worried. OP's solution seems to solve this issue quite well.
I treat regex like functions, if they're too big maybe you should break them apart into things like parser combinators
I can't think of a single time that I used regex without having to lookup how to use regex. Very interesting project which could certainly save a lot of time when you need to use it every once in a blue moon. 
I decided i'm going to go with how Django handles multiple admin backends and allow for a class to be extended instead of having multiple config files.
I'm slowly working through it but there's some parts I don't like. Gives no justification for why it calls service locators an anti-pattern. All the page controllers use the http request and response when I feel the page controller should only worry about giving the right output for the right input and another layer above that should handle taking the output from the controller and sending it to the browser via the http response.
I like the optimism!
Not going to lie, I misunderstood this to be regex that compiles to sql for some reason and I thought you were a sadist. Love this idea now that I understand it, though. Hah.
Yes.
&gt; you wouldn't want to commit and/or upload your vendor folder directly, would you? I often go with local composer install + rsync entire application to remote. I don't want my prod servers tied up resolving/installing composer dependencies. I usually have some front-end build chain that also needs to generate files, so it's not an extra step beyond what I would normally be doing. I won't say it's the only approach, but it has worked well for me in the past...
Your first example with the email address is a little convoluted. To match an email address, it can be greatly simplified: /^[\w\.%\+-]+@[\da-z\.-]+\.[a-z]{2,}$/ Also, you can easily make regular expressions easier to read: /(?(DEFINE) (?&lt;local&gt;[\w-\.%\+-]) (?&lt;domain&gt;[\da-z\.-]) (?&lt;tld&gt;[a-z]) ) ^ (?&amp;local)+ @ (?&amp;domain)+ \. (?&amp;tld){2,} $/x Though, to actually match an email address, the expression actually is: /.+@.+/ Though I get the point you're making. I actually found your syntax to be harder to read than a well thought-out regular expression. But I'm in the minority. Just thought I'd share my opinion.
really good work! 
This looks really awesome, regex can be hard to get right this could help alot of new people to regex build consistent rules. The inclution of a "query" builder is also good.
Holy shit, that's cool.
maybe this lib could be useful for building the js one, just define the grammar and let jison build the parser http://github.com/zaach/jison
an email can be much more complicated than that, just go with `/.+@.+/`...
Coders should take the time to understanding Regex. That being said, this idea has some great uses elsewhere. For example: * Code maintainability (Easier to read at a glace) * Indent formatting for separating expressions into blocks * Build queries in run-time by appending string, sprintf, etc... * No more excessive escape characters I don't know if I'm on board with your syntax, but I really like the idea. I would lean more towards a syntax that allows you to use regex inside of it. A benefit to this could be adopting it as a new backwards-compatible standard spec. Also, if anyone is concerned about the performance overhead because it has to be preprocessed during runtime: consider that regex strings are rarely defined in loops. And perhaps a cacheing mechanism could be implemented if it is a concern.
I did look at Laravel's queuing features, and it seemed like one of the most complete queuing solutions currently available for PHP. But it also seems very coupled into the "Laravel way" of doing things, and I would have to take on a lot of Laravel dependencies and coding style if I wanted to use it in my project. Also where Laravel has multiple queue drivers, BusQue is designed to work only with Redis, meaning the behaviour can be specified more exactly and the codebase is simpler, at the cost of interoperability.
A sharded database may not support tables that lack a sharding key (e.g. splitting by user_id) so metadata tables like migration status may need to be stored elsewhere. That could be another database, some other storage, or could be added to your application as part of a build/deploy.
Then you store the file on the database server. 
Honestly I used to loathe it too, then I practiced my ass off with regexr, and now I hate then slightly less
Bravo, very, very nice work. Next, why don't you make Perl readable
I don't. I actually kind of enjoy it. But that doesn't make this any less awesome. Kinda wish I'd thought of it.
always nice to hear about new stuff, but please stop using the word powerful :) also, why another orm, why another template engine. it's only a matter of time for something to come up that can compete against the major ones that are out there right now, but it really feels like a waste that people are still trying to reinvent basic things that don't need reinventing from the ground up, at this point atleast.. thousands years back wheels were round, they still are. but at the same time this is a bit of a paradox, i know it's a good thing that we contest each others ideas and conventions and at some point in time we are going to use a better twig, and a better doctrine/propel/whatever, but you really need to back it up with very strong arguments at this time, and not words like hey, its 'powerful'.. after all, you're not improving on existing technology, you're doing it different not only that, it actually pushes me away from using your framework, cause i don't want to throw away all that twig and doctrine experience and start over again. look at laravel, very opinionated(cough) but still, it skyrocketed because it offered an entry level to basically everything webdevelopment 
&gt; It's fast. &gt; Opulence is written in PHP 7, for PHP 7 &gt; It can handle 500 requests/second on a cheap 512MB server and 2,000 requests/second on a modest 8GB server. &gt; Most of Opulence's settings are cached to reduce overhead on each request. Is this considered fast? We have the power of what was considered a data-center not long ago, inside laptops weighting less than 2kg and this is the best we can do in late 2016? And this is probably a fine tuned hello world benchmark. Well I guess if everything around you are snails, your sloth looks fast. This is not a rant towards Opulence or even PHP. It's to the sad state of web dev. &gt; Need to store passwords? Try our [hashing library](https://www.opulencephp.com/docs/1.0/cryptography#hashing). Why do you need to wrap bcrypt or anything if we now have [this](http://php.net/manual/en/function.password-hash.php)? I'll stop here.
*flips tables* Keep it strict! Look at the minefield of compatibility issues with different markdown libraries. There was a little ambiguity in the original markdown spec (such as it was) and now there are dozens of libraries which produce a smorgasbord of not-quite-the-same output. On the other hand, JSON works everywhere because it's strict. No optional trailing commas, no optional single-or-double quotes. IMO remove `of`, or keep it, but don't make it optional. Given the strength of what you've made here (which is very nice by the way) is certainly _not_ that it's concise, I wouldn't be entertaining arguments about the syntax being overly long myself.
I agree with your sentiments about wanting web apps to be faster than they are, but all I can do is compare Opulence to what else is out there, and it does quite well in that regard. Good catch about the hash link. The hasher class is a holdover from a time when Opulence supported older versions of PHP. You're right about PHP 7 though - it is a somewhat irrelevant class now. I've updated that portion of the site to talk about Opulence's encryption library, which *is* very relevant.
If this is considered for very simple applications, I'm already scared by amount of boilerplate for medium complexity app: use Opulence\Ioc\Container; use Opulence\Routing\Dispatchers\ContainerDependencyResolver; use Opulence\Routing\Dispatchers\MiddlewarePipeline; use Opulence\Routing\Dispatchers\RouteDispatcher; use Opulence\Routing\Router; use Opulence\Routing\Routes\Compilers\Compiler; use Opulence\Routing\Routes\Compilers\Matchers\HostMatcher; use Opulence\Routing\Routes\Compilers\Matchers\PathMatcher; use Opulence\Routing\Routes\Compilers\Matchers\SchemeMatcher; use Opulence\Routing\Routes\Compilers\Parsers\Parser; $dispatcher = new RouteDispatcher( new ContainerDependencyResolver(new Container()), new MiddlewarePipeline() ); $compiler = new Compiler([new PathMatcher(), new HostMatcher(), new SchemeMatcher()]); $parser = new Parser(); $router = new Router($dispatcher, $compiler, $parser); $router-&gt;get("/foo", function () { return "Hello, world!"; }); Does anyone will ever use these components outside of framework? Isn't it possible to replace them in any other way? Looks like decoupling for the sake of decoupling, while the truth is that it will almost never used. I'm pretty sure no one will remember this amount of boilerplate easily, so that it will be just copy-pasted most of the times. Would be nicer to have extremely simple interface right from the beginning.
My ex wife wouldn`t agree you you mr bot.
Lmao
Same for me, custom software is my business but I have some old clients that uses an custom CMS (10 year old sinn of mine). The CMS is centered around a flexible-custom-fields-ish way and it would be nice to be able to offer an alternative if the want to "upgrade". So far October CMS seems to be an good alternative.
Valid point. The problem with that is, if I decide to remove `of`, it breaks all currently built expressions using it... But I get your concerns and it might be better to break it now than in a few years.
Wait, I have an idea. We'll put all this boring wiring code in a static class to make it simple, and call it a façade...
A quick search for "human readable regexp" yields https://verbalexpressions.github.io/, with implementations in many languages it seems. Haven't tried this nor OP's solutions, so I cannot compare.
Thanks for the correction URL's are updated. Actually the main concern was to show how you can make simple REST in symfony that's why data was the main concern. But if you exactly use /user/ route in URL anybody finds this is user route that's why to hide this Different route names was used.
What makes a framework a "PHP 7 framework" ? Are "PHP 7" libraries somehow superior to the "PHP 5" ones?
This would be golden.
&gt; This is not a rant towards Opulence or even PHP. It's to the sad state of web dev. Love it or hate it, the architecture of PHP has a lot to do with this. You can't reload your entire environment, including some increasingly complex software on every request, even with opcache, and expect best-of-class performance. And software can't be simplified forever, because as you gain that next 1% of server performance, by dropping features and flexibility, you lose 50% of developer performance. I was here in the PHP 4.0 days when PHP development was about running SQL queries in the middle of your HTML, and I think we all agree we don't want that anymore. Well, step by step... we don't want this, we don't want that, and we have the modern status quo of loading at least a few dozen classes per request (and that's minimal, some frameworks load hundreds). Compare PHP results to something like Play (based on Nette, which is written in Java), PHP will always be about 10x to 100x slower... Unless the architecture changes. Maybe one day.
I do appreciate the links and will have a look. Honestly when I need to use them, my main reference is google. I honestly don't use it enough, but you are 100% correct in that it is a huge benefit if you truly have a grasp of regex.
&gt; You are guaranteed to have a clean session, without having to worry about race conditions and memory leaks on every request. Architectures like Play and Node don't suffer from race conditions. As for leaks... with PHP the only reason we have so many components with leaks is because leaks don't matter, *because* of the architecture. In other words, PHP encourages leaky code. Change the architecture, and all those leaks will be fixed very fast. There's also a way of fixing the remaining subtle leaks: reboot the environment for a given thread, but not after every request, but after every, say, million requests.
ItIsNotAStandardAndShouldNeverBeAsItIsExtremelyAnnoyingToFuckingRead. I_hope_you_got_my_point.
&gt; This is the effect of absolute obedience to the rule "inject all the things". You're saying this sarcastically, but this type of code is written once for a project, and then not touched for months. It gives you the flexibility to define and change your architecture where other frameworks don't allow it. And if you're absolutely certain you'd **never ever** change the wiring... good news, you can put it in a class and call it Application, or something, like all other frameworks do, and reuse it across projects. In any case, don't mock people who give you configurable components. The easiest thing in the world is to wrap this configurability in something static and monolithic. But the reverse scenario is almost impossible: to start with something static and monolithic, and make it highly modular and configurable.
I have not yet taken a look at the implementation or performance but have you considered using hoa/compiler instead of manually building your compiler ? unless you are well versed in compiler science, it would probably be more efficient (both for performance and maintenability / stability)
This was exactly my point! Something like that should be available out of the box and used in docs. Why would everyone write or copy-paste the same shit in every project? We are all about re-using code, but wasting time on glue for components built in the same kitchen. Seems ridiculous to me, could be much better experience.
&gt; This was exactly my point! Something like that should be available out of the box and used in docs. Opulence is presented as a series of components. It would make a lot more sense to present how those components interact in docs, than hide their purpose via superficial shortcuts. &gt; Why would everyone write or copy-paste the same shit in every project? Are you serious? I just told you - put it in a function and reuse it. Did I say "copy-paste" it? You can reuse *your own code across projects*. I'm not sure if the message it coming across, so to reiterate: you can have *your own library* with your favorite shortcuts, configured *precisely as you want them*. It took me 3 seconds flat to wrap that construction logic in a function for you, imagine what you can do in *minutes*! &gt; We are all about re-using code, but wasting time on glue for components built in the same kitchen. Seems ridiculous to me, could be much better experience. Your complaint is akin to someone seeing a sophisticated set of chef's kitchen tools and shouting "why isn't this all packed together in one tool that fits in my pocket, like my Swiss Army knife!" I think Laravel is for you. Opulence is for other people. And that's fine.
An implementation very similar to this does exist, and has existed for some time (a handful of years anyway), for the Emacs editor. The function is called `rx` and takes, as its arguments, a series of Lisp forms describing the regex pattern and it returns a regex pattern as a string (so you can use `rx` inline with actual regex search or replace functions). The source code is self-documenting of course: https://lists.gnu.org/archive/html/bug-gnu-emacs/2010-06/txt3kD3wY38UI.txt Really cool to see a PHP 7 version of this idea!
Ah. Just noticed that. Please consider the LGPL instead. This will still require anyone making and distributing changes to the library to use GPL to. However, under LGPL someone making a commercial closed-source project could include this directly in the project. Under GPL they can't. The author may have strong views on software freedom around this point, but the fact remains GPL over LGPL will reduce the situations this library can be used in. :-(
The nice thing about it being a PHP 7 framework is that any Opulence interfaces or base classes you'd like to extend are using return types and scalar type hints. Otherwise, it's frustrating to write your app in 7, but have to write anything that extends Opulence in 5.*.
It's mostly an interesting comment because CodeIgniter is widely seen as obsolete (IMO somewhat, but not entirely, unfairly). Other than that, yeah it doesn't make any difference.
I still use it on occasion, it is fast and easy to get up to speed on. On the application side, anyone that knows MVC should be able to use it effectively without much effort. It also deals well with lots of corner cases. On the framework side, it is poorly designed in some aspects. The code is tightly coupled and hard to unit test properly.
I literally had to call my works web host to get them to update our site to 5.7... Otherwise I was stuck on 5.4. :/ I hate not having direct access to servers.. 
I love regex. People think I'm a wizard that can parse huge unreadable tomes.
From the context it looked like you did, otherwise your point has nothing to do with the previous poster's point on why CI is preferred on shared hosts.
Why? The PHP 5 libraries and frameworks use phpdoc annotations that achieves the same result for you in the IDE
Why is this being shared here?
I use Yii. Can't tell you I enjoy it. Yii has very serious issues when used within a company. I'll enumerate some: * It doesn't adhere to SemVer, which makes upgrading even PATCH versions (which they call minor versions) a nightmare. I can't run a `composer update` without sending my entire stack to Q&amp;A to assure it didn't break something, because they break backwards compatibility when upgrading, for example, from `2.0.8` to `2.0.9`. These are intended breaks. It's awful trying to keep up with the framework. Upgrading from `2.0.0` to `2.0.9` requires me to read 10 different sections of an upgrade guide. * No LTS as of right now. * Uses obsolete patterns (and some anti-patterns) in the name of simplicity (singletons, for example). It's not a bad choice until you need to scale your product aggressively. We've tripled our development team, and we are starting to feel the need for more robust dev processes. But we can't work with unit tests, for example, because there are static calls everywhere, which creates hardcoded coupling and thus our tests aren't truly 'unit'. Integration tests or no tests at all. * Doesn't adhere to PSR2, which is just weird at this point in time. * I just know that we'll need a full rewrite when Yii3 is released, differently from other stabilished frameworks, like Symfony (where 3.0 is just 2.8, without deprecated features). I wouldn't recommend Yii for any use case other than non-commercial projects. Commercial projects will need to scale eventually (unless you're writing something that is predicted to tank) and Yii will get in your way. There are a lot of cases out there of companies who outgrew Yii. Mine is one of them. Building a product with Yii means building technical debt into it, almost necessarily. Every single discussion I had where I pointed its architectural flaws were just met with "you don't need to use X feature if you don't like it", which is pretty much "Yii isn't bad if you don't use it, it's just bad when it's used".
I think it's nice. For those who don't know or like regex I can see it being useful. I'll suggest it to a few of my co-workers (programmers) and see if they can use it. I've been using regex for so long that for myself I find what you've done a bit difficult. Too much to re-learn that it would be easier to just stick with regex. But still, it is a good job though.
Yes it does, the framework is a c extension. We were talking about Laravel though
&gt; But it's funny you mention extra permissions being a road block to people using laravel while you suggest PhalconPHP which requires a full on extension to the language... I thought you were replying to this part which says that Phalcon requires an extension to run. He says that Laravel runs as is on most hosting platforms.
This article is pompous and flat out misinformed.
Running the composer command from the documents resulted in an error: php -r "shell_exec((file_exists(getcwd() . '/composer.phar') ? PHP_BINARY . ' composer.phar' : 'composer') . ' dump-autoload -o');" 'composer' is not recognized as an internal or external command, operable program or batch file. I ran the dump-autoload manually so no problems but at least on my windows development machine, the composer executable lives in a bin directory accessible via $PATH. I kind of wish you used some of the PSR interfaces for things like Request/Response. I understand why you didn't but it does mean that Opulence will have to spawn it's own eco-system. Looking forward to messing around with it. 
&gt; You can still use anonymous classes in your own code if you like? What do you care if the library you are using used anonymous classes or not? I gave you at least three distinct points why I care right up there... - Library performance. - The library can mold its APIs differently (stressing more on light SPI adapters) when they know the users have access to anon classes. - Encapsulation of instance creation and focus on interfaces (you can't create the class directly, only through the intended factory). &gt; Does opulance have some amazing feature you can use with anonymous classes? Because I didnt notice any I don't know Opulence in detail. I'm speaking from personal experience as some of our apps and internal libs are now PHP 7+ only, and it has changed the way we design them. If it weren't for a stale Phalcon 2 dependency in a few legacy projects, we'd be 100% PHP 7 by now. It helps a lot. I'll mention one more improvement in PHP 7: the ability for method names to be anything, so words like and() or() list() array() and so on become accessible as method names, which are very common in ORM, expression builders and so on. It makes for a more elegant API.
Hmm, I'll have to investigate that error. Thanks for reporting it! I understand your concerns about not using the PSRs for requests and responses. PHP badly needs abstractions for them, but I just felt like the PSR was lacking lots of important functionality and was prone to accidentally writing bugs due to immutability. If there ever was a better implementation out there, I'd adopt it in a second.
The syntax for the classes in methods wont get obsolete, it's the same syntax in 7. 7 adds more features to the syntax but doesnt deprecate it
shouldn't a framework be something simple... $framework = new Framework(); $framework-&gt;get('/', function () { return "Hello World"; }); $framework-&gt;run(); 
Yes, but why continue writing code that is essentially PHP 5 just because PHP 7 is backwards-compatible? Considering it's a brand new framework, I might as well embrace the future (and the current).
Here's one using envoy: https://dyrynda.com.au/blog/an-envoyer-like-deployment-script-using-envoy
Yep, no disagreement there. It's a hacky solution. Just thought I'd mention it anyway, as there is a "use function" ability in 5.6+. I've just used static methods on classes though.
If you create a project using composer create-project opulence/project You get all that stuff in bootstrappers ready to be used, you don't need to write a line of that code. On the other end, if you want to use the router outside of the framework, the documentation tells you how to do it.
Should it be simple or something modular and customizable that CAN be made that simple?
This is great. I've just expected documentation to show simple things first and then expanded explanation how it works under the hood. In this case docs only show expanded version.
you_just_proved_your_point_in_a_fucking_efficient_way ButItIsSadlyStillUsedEverywhereAsAStandard thanks_sir
Last week someone post a link for a "Custom-sizing PHP thumbnail generator code" that was exactly like this.
All I can say is; ***Why?*** What would the benefit of something like this be?
Camel case is the PSR standard iirc
This is a totally awesome thing to make! I am really glad you made this. Don't let the naysayers get to you! This is exactly the type of thing "wise" programmers are trained / born to think is bad. They will give you so much grief. Just ignore them! Keep building cool and interesting things! All the arguments against this type of thing don't stand up under a more... enlightened analysis. The main questions are is there already a better tool and how can this be improved, not is the general concept even a good idea. At first glance, the language looks a little bit too wordy. As far as languages go, there are regular expressions on one end of the spectrum, and SRL on the other. Perhaps I would change my mind if I had actually used it.
Objects are hash tables! This make so much more sense now! I think the hardest resource limitation to work with in PHP is the amount of RAM it uses. Although I did eventually solve most of the specific problem cases I had by not pulling all the data into memory at once in the first place. Although sometimes it is difficult to do that and it would be nice to be able to have larger arrays (element count) that use less memory. It is good to know PHP 7 is much more RAM efficient in general.
FWIW, this site has PHP User Groups: http://php.ug/
Yeah, it would be nice to chain directly off a newly constructed classes. I have a lot of `(new Foo())-&gt;bar();` syntax sprinkled in a lot of my code.
`i` isn't just supported by PHP. It's a commonly used modifier and helps to keep the expression clean.
I like that this has its own DM ORM as an alternative to Doctrine. I find Doctrine to be clunky and cumbersome with really scatterbrained documentation. A DM ORM as simple and concisely documented as Eloquent is sorely lacking in PHP IMO. That said, the API for doing routing in Opulence? Hoo boy. That is some next level Java right there. :( The facade pattern exists for a reason.
&gt; Also, you are right, I don't actually need to use closures and magic in that way. But I like exploring wild ideas. The best code I ever wrote started out as a hacky, wild idea. Eventually it evolved into readable, clean, fast, code that removed tons of duplication from the project and allowed me to express complex functionality with a small amount of code. I'm all for exploring wild ideas. :-) But I'm still curious what's the use case for what you described, as I may have a more efficient factoring of it. If you want to share, of course.
5.7 is a lie
so I have a little app in PSR-7 how do I convert it or bridge it to Opulence without having to re-invent the wheels since Opulence does not: - follow PSR-7 (which is fine by me) - does not provide a bridge (like Symfony does ... reused by Laravel) The same question could be ask for a convertion from HTTPFoundation to Opulence 
You have to wrap the instantiation in brackets: (new SomeClass())-&gt;someMethod()-&gt;someOtherMethod(); Have a nice day!
Unfortunately, I do not have any kind of bridge for PSR-7. I looked into implementing such a thing, but it wasn't trivial. I'm not opposed to it, but writing a bridge for a poorly-implemented PSR that never gained a huge following just isn't high enough on my priority list. That's not meant as a snobby comment - I just have other things to tackle before I'd allocate the time to write such a thing. If you're feeling up to the task, you can always submit a pull request ;-)
Thanks for the tip with any character and kudos for fixing it that fast.
Anthony Ferrera gave a good talk about other issues that affect performance in PHP. http://m.youtube.com/watch?v=qjYyC47rdVs. I know Laravel is very guilty of "string magic" and dynamic method calls, which affects its performance. Would love to see a Blackfire profile against modern frameworks though, just to see where each spends most of its time.
I was thinking "literal" instead of "literally," because every time I read it, a 13-year-old girl's voice appeared in my head.
I think the point he was making wasn't about how knowledgeable you can be, but about how much you can effectively spread your time in a single role. It's perfectly possible, and not that hard, to know the full stack. But the point I think he was making is about what you can manage to do in your 40/w day job. You can't realistically do all of that and still deliver a custom solution in a reasonable time frame by yourself. Or, at least, most people can't
I quite like it as well (that's not to say I find it easy, mind). It's like a logic puzzle.
I loved 'literally'. Honestly when i read the syntax i mindgasmed. Regex finally made sense. begin with any of (digit, letter, one of "._%+-") once or more, literally "@", any of (digit, letter, one of ".-") once or more, literally ".", letter at least 2 times, must end, case insensitive
I know there's a lot of love for php but it seems easier to write it in c#. But I guess sometimes being able to work in your favorite language is worth it. 
I like the idea... my only criticism is that I think it goes too far in the direction of verbose. I think a middle ground would be more useful, and have a better chance of catching on. Something like this: anchor_start, atleast(1, [ digit, letter, any("._%+-") ]), "@", atleast(1, [ digit, letter, any(".-") ], ".", atleast(2, letter), anchor_end (it could all be on one line, of course)
There are such servers, one was even written as a C extension for PHP, to eliminate the overhead of parsing HTTP requests and producing HTTP responses in userland (because the built-in functionality can't handle a persistent process). The problem is the ecosystem won't follow a third party solution. So this option will remain a fringe option that many libraries and extensions will choke on, as they've not been tested in a persistent process based primarily around asynchronous execution. Things will change when this becomes one of the PHP binaries that come out of the box. Like CLI, CGI, FastCGI and the Apache modules.
Yeah it's true, most people can't. I did say it's very demanding. Definitely not something I'd recommend for devs who are just getting into the job market, and most of the time it's not the optimal solution - it's just what a company tosses out there because they're being cheap and stupid. I just don't think it's the impossibility that he's making it out to be. It's rare, and it really heavily depends on the person and the company, but it's not something that only happens once in a blue moon.
It's not impossible, but it's really hard to juggle all of those responsibilities in a single role, and if you do you're not likely to get paid enough to be worth it. Or, at least, that's my take on it. I have the skills to act as a Full Stack, and in some jobs I've swapped roles enough to have filled in more than half of those positions during my time there, but I would never get in to a job that's Full Stack off the bat. Rather, I go in to roles that are for Senior Developers, and my other skills come with me.
I can understand some of those points. But I would like to point out that in a in PHP you have much of the same options. Composer, PHP7, HHVM, FirePHP, Xdebug, etc.
It's sad that my experience with Magento has made my initial reaction to want to (I'm not a complete dick) down vote magento posts by default. We haven't upgraded to using Magento 2 yet. Not sure if we are waiting for more stability/bigger user base, or if the idea of upgrading 20+ magento 1.x sites to 2 just makes me want to curl up in a fetal position in the corner. Good luck in your endeavors.
&gt; always nice to hear about new stuff, but please stop using the word powerful :) Some alternatives: - Amazing - Magical - Insane - Unbelievable - Great - Wonderful - Incredible - Far Better - Truly Improved - Innovative - Phenomenal - Gorgeous - Terrific - Disruptive - A Dream To Use - Exciting - Outstanding - Beautiful - Remarkable - Fantastic - Exceptional
This is an excellent talk to watch.
I hope by "they" you mean regular expressions, cause this is really concise and clear: if (false !== filter_var($email, FILTER_VALIDATE_EMAIL)) { // carry on }
In my experience "full stack developer" has meant "someone who I am going to end up begging to stop doing front end after they are done with the back end work" &lt;-- front end dev who believes in strong separation of concerns in code and work roles
You are definitely right. But can you develop an app/game and instantly run it on a tablet/phone/PC? Can you instantly run it on any OS? Just picture Xamarin Studio, but for PHP powered by Peachpie - this is one of the objectives. 
Deployer? http://deployer.org/
http://deployer.org/ ?
Laravel and Symfony did not embrace PSR-7. Symfony wrote a bridge for it, but doesn't dogfood PSR-7 because it's simply not as powerful as HTTPFoundation. By extension, neither does Laravel.
I never said/wrote that. If you had read me correctly I just talk about a bridge that's all. My only concern was about the lack of documentation to help me migrate from another framework to yours &gt; this has nothing to do with PSR-7, PSR-7 was used as an example on a side note I see in the documentation this: &gt; - A default PHP timezone set in the PHP.ini While in PHP7 [this RFC](https://wiki.php.net/rfc/date.timezone_warning_removal) was passed . Unless I misunderstood something, you seem to be not using a PHP7 feature in a PHP7 framework. Anyway this framework is looking good at first glance. I just feel the marketing around it should be improved.
Good catch! That's a holdover from when Opulence was supporting PHP 5.6. I agree that I need to do some better marketing. Part of it is combing the docs and improving them, and writing a lot of tutorials and evangelizing to spread the word.
I'm not one of those don't reinvent the wheel guys. If you run into a difficult problem you should look at how other people made theirs though. They took the time to understand the problem initially and will probably have a better solution, especially since sites like stack overflow allow peer review. It's like telling a surgeon to just cut away until he learns. Eventually he will (end up in prison) be able to perform surgeries, but the guy who learned from those more experienced will kill a lot less people.
Because the author is an awesome hacker and you plebs are not. That's not how I feel, but I'm pretty sure that's how the author wants us to feel.
Hmm. I don't remember if I had any purpose other than just to see if it would work. I started making classes that way for a time to see if it would lead me to other interesting ideas. Eventually I stopped doing that, but I left the magic in there, so I still could do it. I think after that I only used it in the case that I had an object and I just wanted to add a method to it that I would call that only would be used in that one context and I could just add it to the object right before it would be used with a small amount of code. I know this is also one way you could use composition over inheritance if you pass in objects to factory functions.
You say that, but this is super attractive for dev on a plane. Just need a decent BT keyboard...
Stuff like this tends to happen when developers who aren't versed in security write escape routines for dangerous functions: http://www.openwall.com/lists/oss-security/2016/01/19/16
I don't think I've ever read a single positive post from you. The community could use a little less of your poison.
Completely agree. OP's question is the kind of thinking that caused the dot-com bubble, and sadly we still see it today. Technology doesn't make a business. Business makes a business. Published in 2001, [Business @ the Speed of Stupid](https://www.amazon.com/Business-Speed-Stupid-Technology-Disasters/dp/0738207683) is still extremely relevant today. I strongly recommend it.
&gt;Senior Web Developer &gt;Freelance Haha, this guy is like those dudes that say they are the President of their company when their company is a 1 man startup that hasn't started development yet. &gt;If your first instinct is to open a new browser tab every time you find yourself dealing with a complex issue that affects multiple technologies, you should reconsider your working habits. How about, "If your first instinct is to assume you know everything about every new complex issue then you can go find employment somewhere else because you're an arrogant idiot."
I'm so sick and tired of the anti stack overflow circle jerk. My job is to write software that works and to do it in an efficient amount of time. If I can find a solution to my problem, check it to make sure it's accurate, and learn from it in 10min instead of 10hrs, then I am going balls deep into "borrowing" someone else's solution. Fuck anybody who disagrees with me.
To be fair, 5.6 is still a good minimum version. Sure, 7.0 features are nice, but not everyone can target it yet.
You shouldn't have any information disclosure by outsiders knowing the route for users. Hiding your routes behind confusing names is pointless. Remember, security through obscurity is not security at all.
The issue is debugging. You can easily write a comment that gives a statement about the regex and a few examples, but if your regex is missing an edge case, good luck parsing the regex itself to modify it to fix that one edge case.
Interesting idea. Might be useful to occasionally use themes to keep things fresh. My current favorite is https://phinx.org I don't own or maintain it, but I do love me some migrations and seeds. 
In case anyone is wondering if there is something similar for Android, there is [this](https://play.google.com/store/apps/details?id=com.esminis.server.php). Has php7 with a load of extensions enabled. There is also a [decent editor](https://play.google.com/store/apps/details?id=org.kidinov.awd).
&gt; But the sucky part about it is that companies want to hire one 'full stack' developer because they don't want to pay the salaries of more than one, without realizing that someone who actually does have the skills to do all of the above to a professional standard will cost as much as a team. Bingo! 
I'm trying to convert to and from a `DateTime` using `z Y` format (day number/year) but it seems to be off by 1 day: &lt;?php var_dump(DateTime::createFromFormat('z Y', '239 2016')); var_dump(DateTime::createFromFormat('d/m/Y', '28/08/2016')); var_dump(DateTime::createFromFormat('d/m/Y', '28/08/2016')-&gt;format('z Y')); Output: object(DateTime)#1 (3) { ["date"]=&gt; string(26) "2016-08-28 01:08:44.000000" ["timezone_type"]=&gt; int(3) ["timezone"]=&gt; string(16) "Europe/Amsterdam" } object(DateTime)#1 (3) { ["date"]=&gt; string(26) "2016-08-28 01:08:44.000000" ["timezone_type"]=&gt; int(3) ["timezone"]=&gt; string(16) "Europe/Amsterdam" } string(8) "240 2016" https://3v4l.org/p1rnL Is this a bug, or am I doing something wrong? Using day 0/the 1st of Jan seems to work as expected: https://3v4l.org/BqIkM
I believe Magento is most used eCommerce platform in the world. Checkout this blog for [Magento 2 tutorials](http://magenticians.com/category/magento-2-tutorials) you can even contact them for any help.
Simple - you get task regardless of type and you finish it. You can't argue that it isn't in your skills set :)
Ah yes. Thanks OP! (I would have been very happy with LGPL myself. MIT is good tho.)
Opencart was stripping out ".. /", not "/"
&gt; You're saying this sarcastically, but this type of code is written once for a project, and then not touched for months. It gives you the flexibility to define and change your architecture where other frameworks don't allow it. "not touched for months" -&gt; change that to years. what did you earn out of that configurability?
Why not take a laptop with you then?
&gt; what did you earn out of that configurability? I earn the ability to choose the best components for an app, components from different authors, and quickly wire them to make them work as one. I've also had to replace components for a project during maintenance, and it's nice when it goes without a hitch. In the long run, you'll have to replace components even just because some of what you use gets abandoned. That's a fact of life, and frameworks are not immune, the PHP graveyard is full of once-popular frameworks. The fact you can update your app piece by piece through adapters and wiring means it's possible to do at all. Because when your framework (or compatible framework version) gets abandoned, and you need to replace *all or none of it*... you're in deep trouble. It's time for a complete project rewrite then. And that is incredibly hard to pull off without disrupting your business for a significant period of time. Also, the trick is to keep interfaces that compose in your bootstrap wiring simple so they are simple to reimplement, decorate. This allows me to add concerns like: logging, caching, admin notifications, security checks, fallbacks, without writing a single line of logic: just through compositing and decoration in the bootstrap. I know it's hard to realize you can solve *actual problems* in the wiring configuration, but this is the result of relying on a monolithic framework. Because I have control over the wiring, I don't need YAML/XML configuration with hundreds of settings you need to find in the framework manual, with the hope it does what you want, nor I need to copy-paste logic in my controllers when I need to solve a system-wide or module-wide concern. I change a couple of lines in the wiring, and it's done.
That's a really neat library with much wider use cases. Shame it's hard to find small libraries like your and mine.
I usually do take a laptop with me on flights. But an iPad Air 2 is tiny compared to the Macbook Pro I have. It's much lighter, and is able to charge from a standard USB charge port (which you can expect to find on any long-haul flight). 
Why do people get so mad at the tools other people use?
are maymays allowed here?
Symfony or Laravel. Both are pretty easy to learn and have great documentation.
If you just want some routing, middleware and modularisation, try Slim. The basics can be learned within an hour or so! 
I'd use Silex, it's lightweight and small. 
If you want to do something quickly and for fun Laravel - you'll build something working in few hours. if you want to play with something more powerful but a little more hard - go with Symfony. 
I found this library today - https://github.com/php-ai/php-ml I will play with it later. Anybody has any experience with it?
You should be picking the right language for the job. Not shoving your favorite down some tube trying to make it work on the other side.
2.8 is an LTS (Long Term Support) version: http://symfony.com/doc/current/contributing/community/releases.html#long-term-support-versions Upgrading to 3.* from 2.* includes breaking changes, so it's important that there is a 2.* with long term support, as the upgrade may be a massive undertaking for larger applications. With the launch of 3.* they changed their LTS policy: &gt; In the Symfony 2.x branch, the LTS versions are 2.3, 2.7 and 2.8. Starting from the 3.x branch, only the last minor version of each branch is considered LTS (e.g. 3.4, 4.4, 5.4, etc.) Full details can be found here: http://symfony.com/doc/current/contributing/community/releases.html
Starting with Symfony is not as quick as you imagine.
but it pays out in the long-run, enterprise-wise.
&gt; If your first instinct is to open a new browser tab every time you find yourself dealing with a complex issue that affects multiple technologies, you should reconsider your working habits. Depends what the author means there. If the article is suggesting never consulting documentation past initial encounter then it's the result of a lazy, ignorant and dangerous mindset that treats IT as something that benefits from static comprehension like soccer or cricket, brushing your teeth etc. The truth is the rules are not so fixed in IT (slightly ironic). Libraries might change their public API, or stop being maintained, something like libuv might come along and present a newer way of handling programming tasks. If everyone did not ever consult the web problems would shoot from all directions. If you just consult the web, you'd never innovate. The thing about testing and CI, maybe it improves things, maybe not. It helped me recently, but in general I think you win some you lose some. Also the StackOverflow (SO) bit... SO has amazing variance in it's quality (it's neither all bad, or overwhelmingly good). The only way to make it better is to contribute and take up more time (at least as much as the original authors maintaining existing or pruning dead subjects), so I'm not sure it's entirely sustainable long-term...
[You could try rolling your own.](https://github.com/PatrickLouys/no-framework-tutorial)
Slim is great. Works extremely well for something so simple.
I recommend you to read http://symfony.com/doc/current/create_framework/index.html. it may be useful for you.
This is very interesting but quite far from a "quickstart".
Hopefully not. At least this obvious troll meme should get the boot.
True. Based on the rest of their post they sound like a hobbyist with free time. So I figured this tutorial might pique their interest. Also, I'm pretty sure winter has been coming every year for a really long time.
Laravel is pretty fantastic and you can get started pretty quickly. Symphony is a good framework and sometimes it's better than Laravel but it's certainly not nearly as quick to start up with.
My concern is more generally, "developers who aren't versed in security write escape routines for dangerous functions", not specifically what OpenCart's vulnerability consisted of.
Try the Zagg folio keyboard case, its thin and you can use the iPad as a laptop. if you turn of the backlight it works for a long time, own it now for a month and have not charged it
No php intl and no mbstring, :(
Sure, but such an escape routine is regex too. And whitelists are pain in the ass to maintain.
Laravel is a great starting point for an MVC framework. It's really powerful, everything makes sense (once you get used to it), and it has pretty decent, albeit not complete, documentation. The community around it is also really active. You can probably find any answer to any question you might have on Stackoverflow.
Or lumen ir you want it to scale to laravel 
It's a matter of personal taste. I find Symfony a lot more intuitive than Laravel or Zend Framework for example.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/phpsec] [Do any white papers exist that cover best practices regarding PHP encryption? • \/r\/PHP](https://np.reddit.com/r/phpsec/comments/50hdat/do_any_white_papers_exist_that_cover_best/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
I don't find Symfony intuitive at all. For example, the "methodAction" convention that Symfony requires in controllers. Why is the "Action" suffix necessary? Why does the router need a `_` before the `'controller'` property? Why is the controller bundle, class and action separated by colons? To say Symfony is intuitive is stretching the limits of imagination.
This is all very well documented. Besides...you are not required to use this at all, you can also use the @Route annotation with the SymfonyExtraBundle and use any method name you like.
&gt; Why is the "Action" suffix necessary? its not. you could also do something like: /** * @Route("/yolo", name="yolo") */ public function yolo(Request $request) { return new Response('yolo'); } &gt; Why does the router need a _ before the 'controller' property? you're defining "defaults" for your controller, thus you need something like "_" for defining reserved/special variables. &gt; Why is the controller bundle, class and action separated by colons? because easier than the whole namespace. [here're](http://slashnode.com/using-logical-names-symfony/) more information about why symfony does that. i don't want to defend symfony or to convince you why symfony is good, just wanted to tune in and explain couple things. overall you're not even forced to use all of this, it's just part of the symfony full stack, you could also build your own framework around the components, with your own conventions which suit your needs better... its basically what taylor did with laravel.
Or only replace the parts of Symfony Framework that you are not happy with, it's that flexible.
Always my starting "framework" it allows me to use the best components with it
&gt; I'm asking you fellow PHP'ers, what would you add to this list and do you guys have any ideas on what kind of project this could be? You're listing a lot of things up there, imagining a framework that does *all* of the above in a *comprehensive* way is scary, IMHO. I wouldn't want to be bound to a monster that does literally everything for me in a single tightly intertwined package. I'd say, rather, make a list of things you want, then start removing things that libraries do just fine (i.e. don't need tight integration the way a framework does). Then see what remains in the list. That's the purpose of the framework. Make sure it handles it comprehensively and professionally. I'd also see how well that framework integrates with third party components. I keep hearing this kind of impressions from framework users, and that's pretty damning to me (for the framework): &gt; Yeah, I'd like to use library ABC for this, but I use framework XYZ, and when I use third party libraries they don't fit the XYZ way of doing things, so I prefer something that's make for XYZ. **EDIT**: And as an advanced bonus, see how well your framework could work with another framework in the same project. Most frameworks fail here as they take over your project like parasites and don't have that flexibility. "There can be only one (framework)!" But some are open to cooperation. 
The road map explains this and a lot more: http://symfony.com/roadmap and here: http://symfony.com/doc/current/contributing/community/releases.html There's even a [graphic showing when various versions will be released and supported](http://symfony.com/doc/current/_images/release-process.jpg). Note that 3.1 is supported until July of 2017, not January.
For example when you want to instantiate depednencies for a class automatically you need the reflection API to get the constructor parameter type. Just a single example tho.
&gt; migrating a whole project to Symfony 3 is kinda of a hassle No, it's not. Symfony3 is exactly Symfony 2.8 without long-deprecated features. If you're not supressing deprecation warnings in your dev environment, upgrading is a matter of changing composer's version constraint and running `composer update`.
I hardy post here on Reddit. But I had to do with magneto2 in the last few days. I can not recommend it for production all use. Too much things that are broken by default. At least all those that I had to touch lately. The developer experience is not really good. Too much context in the dev docs is assumed to be known. Too less information in the Internet about common problems. Then you have the stack exchange posts which may relate to your problem but have no answers. I tried like half an day to try to get the shipping step in the default checkout process disabled. I resigned and just used css to hide the elements away. I feel like it's overly complex even for that modular approach they have. I have the feeling no one really can have a whole overview how it works. But that last one is more my feeling no real argument. I would suggest to wait at least 1-2 released into magneto 2 before even thinking about using it productive. It currently feels more like beta to me. Beware this is my own perspective on this topic. And I only causally touched the magneto1 ecosystem. But there I got at least things done. 
To illustrate with examples, Laravel, Slim, Phroute, Klein. Those routing APIs are dead simple and extremely developer friendly. Annotated routes are very unituitive because they are scattered throughout your code, and use a propritary string-based DSL instead of native code. They are also inherently slower to develop with, because you need to watch specific folders for changes just to the router knows where to look for them. This means either a watcher that compiles when changes are made, OR it means a slower response time during development as the framework needs to look in all of the given folders and classes to find a matching route. Plus having to register/declare which folders to look in is needlessly cumbersome and not at all intuitive. Also, I don't build apps from the request handler to the URI, I do the opposite: I design the best possible URI schema for my app, THEN map handlers to the URIs. *That* is what is intuitive for me. When you annotate routes, that process can't happen. You define a handler first and then attach it to a URI. This not only feels very backwards, it makes it seriously hard to get a conceptual map of your schema right in code. You HAVE to run a command to list your routes in a terminal, and then figure out what will and won't conflict. There are few things in webdev that I hate more than annotated routes, especially in PHP where annotations are just comments are implement via a propritary third party DSL. Also, the fact that I have to add SymfonyExtraBundle to even get access to them is even less intuitive. "Don't like the unituitive defaults? Here just install this extra package to get access to an even less intuitive alternative". How about Symfony just fixes it's routing and controller API so that out of the box it's simpler and easier to work with?
The Doctrine 2 ORM uses reflection to directly access an entities properties while either hydrating the entities from the database or dehydrating the entities to the database. Doctrine also uses reflection to create entities while hydrating thereby bypassing the constructor. The net result is that your entities can be pretty much database ignorant. I used to do something similar back when I was using the Symfony form component. The form component uses a property accessor to map properties to and from form objects. Out of the box, the accessor only tries to access public properties. If no public property is found then it tries get/set methods. Which is fine but you end up with endless getters and setters just to support the form component. I plugged in my own accessor which could access private/protected properties as well. Worked well in my opinion. Reflection is also used by many debugging tools.
Forum software is a good gauntlet to put yourself through. Build a forum in each framework. It's a lot of work, but you aren't going to learn a framework doing a small amount of work in a small project
Suppose you're given the task of retrieving the full list of public controller methods in one of your projects. ReflectionClass::getMethods works great for this http://php.net/manual/en/reflectionclass.getmethods.php
&gt; Symphony Minor pedantry: you probably mean [Symfony](http://symfony.com/). [Symphony](http://www.getsymphony.com/) is indeed a thing - it's a PHP CMS. 
Yes, it's a great way to write applications. Basically it's like marrying on your first date, because your Cupid profiles match. 
lol the day I see a game made in PHP running on my iphone is the day I will eat some paper.
If you want help, you're going to need to be a lot more specific in your request. Essentially, your question is on par with "how do I fix an engine", and it's hard to know how to respond when you don't know if you're talking about a jet engine or a car engine. Anyway, this really isn't the subreddit for support type request -- checkout /r/phphelp
Username checks out.
they added it back in
We haven't implemented it yet, but it's really only a matter of time. It's on the roadmap, we just prioritized other functionalities so far.
I use it to route HTTP API calls to object methods, without having to write hundreds of routes manually. It's also useful for unit tests. Some containers use it to match dependencies automatically, but that's a bad idea, both architecturally and in terms of performance.
Challenge accepted. We demand video proof.
I expect to be able to view the source.
Frameworks are great. We all love frameworks. But it's also fun to use "no framework": https://github.com/PatrickLouys/no-framework-tutorial/ Even if you decide to go with Laravel/Lumen/Slim/Yii/whatever, giving the above a read will be informative.
Keep in mind the interoperability works both ways. Hence, you can, for instance, write plugins for WP in C#.
Yep, that's pretty much it. It does some additional checking to see if the type hint is for an interface, and if so, to see if a concrete implementation has been registered with that interface. Laravel 5 also introduced the concept of tags, so you can specify which client classes get which concrete implementations of the interfaces they type hint. This allows for more use of polymorphism via the IoC without having to resort to factories or abstract factories. That said, over-use of tags can become cumbersome and hard to maintain quite quickly, because you're effectively marionetting your application's dependencies through IoC configurations.
&gt; Sure it is. Laravel packages can define a service provider which includes its own routes file. Done. So you are also having routes "scattered throughout your code" which you didn't like, not so different. Putting a "routing.php" file in a directory without any context or namespace and a bunch of static methods (I know they're called facades but it's still a static method with a sprinkle of behind the scenes magic) is good api design? I disagree, I think it's very ugly to have so much magic. &gt; Route::get('user/profile', 'UserController@showProfile')-&gt;name('profile'); Also assumes you are putting your controller in a specific directory with a specific namespace, I don't see how much this is different from using a format like "Bundle:Controller:action" format like Symfony uses and documents. &gt; Also, the fact that I have to add SymfonyExtraBundle to even get access to them is even less intuitive. This bundle is loaded by default in the Standard Edition so you don't have to add anything. It's fine if you dislike Symfony but it's just your opinion, nothing more so don't present it as facts please.
&gt; Can we not agree that every framework has some specifics you need to know about? I'm not trying to convince you should be using Symfony, I just want to show you how you think of this subject is opinion, not fact. I can point to more specific nuances Symfony requires you to know, than Laravel, to do simple routing. That's my point. Laravel is more intuitive because it has less specifics to know about, and literally requires less code to define routes than Symfony. Simpler implementation, same effect. Even when you start diverging from Laravel's default behavior (e.g. the default controllers namespace and single routes file), it still remains simple. You can talk about opinions vs facts all you want, but the FACT remains that to do basic routing in Symfony requires more specialized convention than Laravel (or Cake, or Slim, or Silex for that matter). But ok. You're not a fan of Laravel I get it. But you ARE a fan of Silex. So my question to you is, do you not see the night and day difference between Silex routing and Symfony routing? Silex is simple, straight-forward, and intuitive. Symfony is out in left field. 
You don't understand I guess, that's fine...I'll explain once more :) &gt; I can point to more specific nuances Symfony requires you to know, than Laravel, to do simple routing. That's my point. Laravel is more intuitive because it has less specifics to know about, and literally requires less code to define routes than Symfony. As a developer I'd like to know what's going on so I can take control when needed. I don't like having static methods all over the place that work all kinds of magic which is Laravel at it's base. Not saying it's bad, I just don't like it. &gt; Simpler implementation, same effect. Even when you start diverging from Laravel's default behavior (e.g. the default controllers namespace and single routes file), it still remains simple. Again a matter of preference, I think Symfony's currently default method of routing with annotations is the easiest I can work with but the alternative in putting it in yml (or xml, php...what you want) is also great. &gt; You can talk about opinions vs facts all you want, but the FACT remains that to do basic routing in Symfony requires more specialized convention than Laravel (or Cake, or Slim, or Silex for that matter). I still agree at some point but maybe the apps you create are so much more simple than the projects I'm dealing with. For me the way of Symfony makes much more sense so it still stays an opinion. If it was a fact we would not have to disagree in the first place. &gt; But ok. You're not a fan of Laravel I get it. But you ARE a fan of Silex. So my question to you is, do you not see the night and day difference between Silex routing and Symfony routing? Silex is simple, straight-forward, and intuitive. Symfony is out in left field. I'm not a fan of Laravel, you got that right. Also, I'm not a fan of Silex (anymore!) since I've ran into a lot of limitations of that framework (routing being one of them). Silex has some use cases for me still but for serious apps I'm only using Symfony because it has proven to me to be more flexible and easier in development because a lot of stuff is solved for me which isn't in Silex. You don't have to tell me the difference between them, it's clear but I don't understand how you will not accept for some reason that I prefer Symfony's method of handling routing. Btw, when using Symfony with the MicroKernel you can also use Symfony with the routing method you prefer, how's that for simplicity ;) http://symfony.com/blog/new-in-symfony-2-8-symfony-as-a-microframework
&gt; As a developer I'd like to know what's going on so I can take control when needed. I don't like having static methods all over the place that work all kinds of magic which is Laravel at it's base. Not saying it's bad, I just don't like it. Sorry, but this smells a bit like FUD to me. It's code, not magic. It's not hard to reason about what a static class is doing. Also, it's FAR FAR FAR FAR FAR FAR less magic than what the framework has to do to convert doc blocks into functioning code (which in itself is a tragedy - comments should not affect the execution of code.....) But regardless, I'm not debating the internal complexity needed to make routing a reality, I'm simply talking about the developer API. Laravel's requires fewer tokens/symbols/conventions than Symfony does, whether that's annotated routes, or ones defined in PHP. 
I've used the container technique before, can you elaborate on the downsides (aside from performance)? Or do you have any links to resources on the subject?
Reflection has very few legitimate use cases and it's very expensive resource-wise. If you find the need to reach for it, consider the possibility that you're architecting your code wrong.
That's a hell of a corner use case.
That is a valid point, but usually things that start out as a small project grow and making the wrong choices can mess things up. I'm currently working on a huge project that started as a vanilla project then moved to Silex at some point. They implemented bundles/modules but in an awkward way where you have to extend base models, controllers and other base-classes that create a long chain of abstract classes that have way too many methods, configuration is passed around as globals, badly implemented stuff that Symfony brings out of the box and would be easy to just pull in into Silex but no one bothered and lots of other choices that are now making our lives harder. This is just less likely with a symfony. I've seen projects go bad with symfony as well, but that is usually on a smaller scale and can be fixed easier because the framework gives you a solid foundation you can work on. Also, even a small app is more than just a route and controllers. You have forms (with validation), persisting data, maybe caching and that's just the very basic stuff. You can do all that with Silex as well, but starting with a full framework will steer you in a direction that will likely work in most cases and prevent you from making a bad choice also you don't have to wire everything up yourself, which is exactly where you can create bad design that is just a hell to maintain or change. That's not to say this has to happen and microframeworks are a bad choice, but once your project grows all the freedom and lack of guidance they give can become a burden especially when you are not an experienced developer.
I'm not so sure. I'm not a popular conference speaker (like many brilliant people I know), but even so. I've been to 6 international conferences in the last couple years, and each trip involves at least 16 hours on a plane, in each direction. That's 32 (return) x 6 = 192 hours without internet, in a cramped spaces, with a limited supply of power. That's more hours than I spend at the office, in a month. I could (and probably should) buy the smallest Macbook Air I can get, but getting a BT keyboard and a server-capable, PHP-based environment is a cheap first step.
That should basically "Just Work." If you're not handling transactions manually, Doctrine wraps everything in a transaction on flush(). So if your first process hasn't flushed yet, doctrine hasn't said anything to the database. If you are handling transactions manually, you can call flush() all you want, and updates will be persisted to the database, but they'll be inside an active transaction. Those changes won't be visible outside of the transaction until you commit() them. Edit: You can watch this in action yourself by writing a little CLI script with some "Hit enter to continue" stuff, and watching the queries that get executed (if you're using mysql, see general_log and general_log_file)
How the annotations are converted to php is visible in the manual with the click of a button so speaking of FUD... ;) Also I just showed you how Symfony can also handle the same routing system as Silex and Laravel has. Just please understand that for me as a developer and the apps I create the routing of Symfony is much more flexible and easier to use than to put all my stuff into separate files. It's OK to think different, like I said...just don't present everything as facts.
I'm simply responding to you. You can't complain about the internal complexity of Laravel routing, but then give annotated routing a pass. &gt; Just please understand that for me as a developer and the apps I create the routing of Symfony is much more flexible and easier to use than to put all my stuff into separate files. It's OK to think different, like I said...just don't present everything as facts. And I'm saying you can achieve the same thing with a simpler developer API than what Symfony has exposed. It's just poorly designed.
CakePHP is easy to get started with and has pretty good documentation and a friendly community; they have my recommendation.
One thing to do is to put it up on packagist (for use with composer), with adequate documentation on the site (so that we don't have to go to GitHub to find out more). If the readme on packagist can convince me that this library is awesome, even though not yet widely used, I will probably just use it. 
&gt; Reflection has very few legitimate use cases and it's very expensive resource-wise. it's a good thing reflection can be cached once since code in production is not supposed to change. The "expensive" argument is bullshit.
Obviously picking the right tool from the start is an important part in planning your site. If you just need a simple site, like a blog or something with light CMS capabilities, then a micro framework is great. If you want to kind of roll things your own way, but use a micro framework as a backer, that's great too. Silex definitely can't take the place of Symfony, and I would recommend going with Symfony if you need something in that class. Sounds like just a lot of inexperience in your example situation. I don't think things would be that much better had they started with Symfony.
That would be like building an outhouse [with one of these](http://www.swapmeetdave.com/Humor/Workshop/Trencher2.jpg)
Delivering an entire application, including knowing a bit of how to build it for marketing and business requiremnts is the, IMO, best definition of full stack. It's self sufficiency, but not a guy in a dark closet sort.
I am curious about the reflection caching that you mention. Do you suggest that storing a serialized object in something like memcache is faster than processing the reflection of a class? Or is there some kind of php built-in caching that I am unaware about?
The only major downside is it can encourage sloppy design because of how it lulls you into a false sense of the "cost" of those dependencies, which can be especially problematic *if* you ever decide to pull that code out and into an einvironment that doesn't support automatic dependency resolution. You're left with the dependency tree, but absolutely nothing to actually construct it. This means you have to dig through the whole dependency chain to figure out how to construct it with factories and what not. BUT, that's a bit of a boogeyman because that kind of change is a major architectural decision anyway.
No, i'm talking about caching as code caching AKA code generation, just like template parsing can be cached into regular PHP code to be reused later. That's how Doctrine works, that's how most Symfony components work. Doctrine ORM for instance, uses proxies instead of the models defined by the user when it returns records from the DB. The proxies are generated only once (in production). Almost any reflection operation can be cached into PHP code that doesn't use reflection. That cache is "warmed" before deployment so reflection is never used on production. If you think about it, reflection is just code introspection. That introspection only has to be done once if the program never changes. PHP can generate PHP files then the generated code can then be required.
 //div[@class="xpath-is-so-2001-I-use-css-selectors-I-am-a-hipster"]
&gt; If it generates nothing then so be it Oh yeah, no big loss on your end, right? Just the poor bastard that actually thinks that working for free would be worth his while. I kid, I kid. But in all seriousness though, you're a piece of shit.
How many hours are you expecting this young, inexperienced person to work for? I can understand the general distaste industry-hardened professionals are going to have for you here, because what you're offering is a gamble that an indeterminate amount of work/time is going to be worth the 10%-15% potential profits you're going to make. &gt; If the business goes down then I'm going down too If it's a business (and has therefore any risk for failure) then it should be able to pay for contractual/employee labour. I hope the project works out for you, but in a way that you can make the time of the people who work with you meaningful for them. Employers are too often in a position to be able to mentor and protect the inexperienced, when they instead feed on the inexperience. I'd hope that's not your intention, but this post does not support such a hope.
this offer is hilarious Given I am an *experienced* teenager (means my skill is good enough to be sold for $$$), I am hurrying up to apply for a free work, *if the guy decides whether I am great enough* Like all communists, the guy thinks that other people are ought to work for his wealth :D 
Post it on Reddit. But consider the amount of preparations for the task. It should be a real good demonstration to impress people, not just the link. 
&gt; Looking for an experienced young teenager The above sounds like an oxymoron to me, most of the time experience comes with age. Only very less % people in their teenage will be experienced in programming **IMHO**
Build a website to show it off, add awesome documentation to the website to make your product stand out. Make the website search engine friendly and visitors will come through the search.
&gt; looking for experienced young teenager [...] under 16, over 10, and is experienced in PHP and MySQL That's hilarious. Good luck, dude.
Seems kinda shitty that you'd release a non open source tool for an open source project. Not to mention a yearly subscription model on a software maintained by (what seems to be) a single person. Cool looking tool, but I feel like you're kind of missing the point of an open source software built on an open source language.
To be fair, it wasn't general inexperience. They actually were knowledgable when it came to building features like a reporting engine with forecasting, fancy pivot tables and unit conversions, but the architecture - holding those pieces together - was something they lacked experience in, because they only worked with vanilla php and handrolled frameworks before and wrong choices from early on just piled up. This is exactly why I advised against using microframeworks. They picked Silex so they could have more freedom and because it meant that they could keep more from the old vanilla project without having to change it. Not wanting to spend time on a large scale refactoring or full rebuild with little benefit to the business is a valid decision. The microframework was basically just for holding the MVC-part together and keeping the business logic untouched. On a B2B-project of that age and scale doing a full upgrade is almost never an option and takes a while. At the same time it leads to weird mixtures of old school PHP and modern php. Also developers started building e.g. their own event system that we replaced with Symfony's event dispatcher, because probably they didn't bother looking for existing implementations or felt it was too hard to use them in their mixed up legacy-/microframework-codebase. Replacing it with Symfony's Event Dispatcher took longer now than if they just went with Symfony in the first place, because their event system is obviously deep down and spread all over the code base now and has some quirky magic that we needed to understand and replace. On the other hand people will probably complain in the future that moving away from Symfony is super hard because the project is now tied in with Symfony, but honestly being tied into your own framework/components is usually not better, at least from my experience.
Well, posting here in /r/php is a good start. But to garner interest, you have to push for quality and explain to people why they should be interested. Here are some general pointers what I look for when I see packages/projects posted here: * Makes sure it has a good documentation. More often than not, I quickly lose interest if the github repo does not properly explain what it is, why do I need it, or how to use it. Writing good documentation is hard and time consuming, but definitely worth it. * Make sure your package is available via standardised distribution channels (i.e. packagist) and has stable releases. If it's a library and I can't install it via composer or it doesn't have stable release (i.e. semver 1.0.0), I probably won't pay too much attention. * Indicate that it has some effort put into it. Having something like a a Travis badge and code coverage badge are good quick indicators that you have a proper build process and do automated testing. If I'm going to use something, at least I need to be able to trust it. * Don't forget quality of the code itself. Proper api documentation in the code that provides type hints, for example, is a huge plus when working with fully featured IDEs. For example, here are some of my libraries that, while not hugely popular, has at least gained some interest purely through my reddit posts: [CSRF library](https://github.com/Riimu/Kit-CSRF), [PHP variable code export library](https://github.com/Riimu/Kit-PHPEncoder), [URL Parsing library](https://github.com/Riimu/Kit-UrlParser).
Thanks very much for taking the time to write that detailed response. That's very helpful
While the comment isn't written in the nicest way, I share the same reservations. How do you want people to try your product if you're expecting them to subscribe for a year before being able to even have a look at it, especially if it's aimed at the WordPress community, which is mostly rather integrators than developers? And then there's also the thing with it looking like you're alone in supporting it. What's the plan?
...and such a bright lad is occupied with a more interesting/profitable project already
Yeah, a bit misleading talking about cross plattform and then reading "Windows and Linux coming soon". So it is not cross plattform.
To be honest I have done stuff like this before (and I'm pretty sure this is how symfony's DI container works) but in retrospect I'm not convinced it's a very good idea. You're making it a bit easier to write code at the expense of making it quite a lot harder for PHP to execute the code. Reflection is faster than it used to be but it's still probably going to give you a largely unnecessary overhead on every request. That being said maybe you could just generate all the mappings using reflection and avoid the runtime overhead.
I haven't used transactional() much, but anything within the scope of the transactional call shouldn't be visible to the rest of the world until it returns. As I said in my edit, it's pretty easy to get your head around it if you write a couple of experiment scripts, and watch what statements get to the database, when, and what order. 
Lol. As he is an edgy communist, he indeed is not sharing everything he got, but only 15%.
I from the other comments do not see any problem with developing closed source tool for open source programs. It is up to the author and its business strategy to decide, if he thinks it is better for the project to stay closed source. I would like to ask if I understand it correctly, you are using this just for local development, there is no support for automatic/continuous deployment to the live or staging enviroment, correct? I am also missing which OsX versions are supported. 
I think most people here think you're looking for a micro framework. If you want to get your feet wet with frameworks I actually wouldn't start with those. Check out Laravel (because it's easy and has really good beginner-friendly documentation), then look at Symfony, then maybe build your own framework with Symfony and/or Laravel components.
I would build something you actually want. Some small neat tool for you and your friends to use. Something that makes it easier to coordinate your poker games. Whatever. Scratch an itch!
Dupe https://www.reddit.com/r/PHP/comments/50awiv/compiling_php_to_net_core_on_docker_with_peachpie/
xD I hope things can stay some what calm
oops, sorry about that.
&gt; t Thanks for the response anyways, even if it was against the post. I appreciate the opinion, just to clear some things up, I don't really know if it's a complex system. I just wanted to put it that way because it sounded cool. No, but really, it's mainly just API things, which I'm not really sure how to do and can't find any good pages telling you. I've tried a lot of different ways, and I've given up. The only solution for my website is somebody else, and since I can't afford to pay a full salary (I'm not of age either), I thought the best solution would be to ask if somebody else was interested. Also, 15% is a good amount, considering it's constant no matter revenue. I could also change that amount if needbe, everything is up for negotiation. Either way, thanks for your feedback. 
Actually that's a typo, the website is related to Roblox/Minecraft.
It's a great deal won't you say, I'll use that money to start a country.
What were those keyboard designers thinking, putting the Roblox/Minecraft key next to the CSGO one...
There's even a catch... &gt; if it generates millions then you will still get **up to** 15% He tells you where the ceiling is, like an ISP, but where's the floor?
Exactly. Examples need to be in the real world. Actually understanding OOP, for example, is also hard when you only see "Animal and Car" examples.
Those keyboard designers clearly weren't "under 16, over 10, and is experienced in PHP and MySQL".
Same reason Listerine claims it can destroy up to 99% bacteria. To deceive gullible people. It's particularly effective when used on teenagers. Somewhat relevant xkcd: https://xkcd.com/1096/
It's our top priority at the moment as the requests keep coming in. We will try to get it done ASAP.
http://i.imgur.com/7drHiqr.gif
Thanks for the feedback. It seems like a trial period is something people want, so I'm going to talk to the team about it. As for the not having videos or guides yet, I'll be recording screencasts today so that'll be resolved soon! And as to your other comment, I'm not the sole programmer. We have the entire team that I work for behind this product. We're not going anywhere. And as for your concerns about open source software having paid tools along with them, please check out [my comment here](https://www.reddit.com/r/PHP/comments/50kt6n/i_just_launched_a_desktop_app_for_local_wordpress/d75aquu). I think it's perfectly reasonable.
But if they are PHP devs then haven't they already moved onto PHP? **How can a PHP Dev do Java before PHP if they are already a PHP Dev and have never done Java!?** I need answers!
As I said [here](https://www.reddit.com/r/PHP/comments/50kt6n/i_just_launched_a_desktop_app_for_local_wordpress/d75aquu), I'm not alone in supporting it. I will pass along all of the valuable feedback about a trial period to everybody at the office today. In the meantime, if you want to try out the [CLI](https://github.com/ezekg/theme-juice-cli) and see the difference it makes in your workflow for free, by all means, try it out.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I think they were trying to say a version of: developers should stop learning languages and start learning concepts and design patterns. 
Not sure if this is what you're looking for but I've found this project: https://github.com/ircmaxell/Tuli/, made by ircmaxell, he is a pretty known guy in the PHP world.
Laravel. The tutorials at [laracasts.com](https://laracasts.com) will get you up and running in no time.
Awesome. Let me know how it goes!
Exactly what do you want to get from the analysis? Errors, missing type declarations etc? PHPStorm has a reasonably decent error detector built in. Just right click on a directory or file and do "inspect code".
"Wet their OOP-feet in Java(OOP) before moving onto PHP(OOP)" is how I believe it was supposed to read. Like a php dev that wants to move to OOP should do Java first (in their opinion).
&gt; You still need to rely on the module manager to use the services wisely since as senior manager you don't have the time to check every piece of code. But at least you have limited the module's playground. Is that sort of what you are saying? Yes. And this is good, because we have Conway's Law to deal with anyway: https://en.wikipedia.org/wiki/Conway%27s_law So this analogy between software and companies is not arbitrary. And the boundaries between modules are not just software boundaries, they're also boundaries where we can split teams: every team handling one or more modules, and being responsible for what happens *inside* the module, while the lead architect is responsible what the modules' dependencies, public APIs and interactions are. In a nutshell, I'm talking about manual injection, but instead of it being flat, it's hierarchical. This means that "accidental" sharing of state and dependencies between modules doesn't occur, and it makes the whole contraption manageable, because in each context, the scope of the problem of managing dependencies is kept relatively small. Note that not all services have to be defined at the root. A module may define some trivial internal dependencies to pass to its components, which are configured however the module pleases. What you see at the root are dependencies which are either shared by multiple modules, or intentionally made injectable from a module for configuration purposes. Sometimes modules with a lot of dependencies will accept their dependencies in the form of a interface implementation that has methods like getThis() getThat() etc. Think of it as a module-specific container: it has nothing except dependencies that the module needs (therefore avoiding the "service locator" problems). Then the module can provide an abstract class with defaults for this interface, so the caller doesn't have to provide *all of it*. Instead, the caller can override what it wants to change only, by extending the abstract class.
Whilst I am not familiar with Cake and how they go about writing unit tests, and I don't really understand the example you have given, as a rule you should want to write single tests for each use-case. Tests are like a living documentation. The naming of the tests describes the behaviour under test. If you try to lump everything into a single test, you won't easily be able to encapsulate the behaviour of the test in its name. The give away is also "unit" in unit-test; if you are testing multiple behaviours within a test, then they are no longer a unit. 
&gt; Also, 15% is a good amount, considering it's constant no matter revenue. That's not what "constant" means. That's *incredibly* variable and *entirely* dependent on revenue, you said it yourself, it's exactly 0-infinity dollars, you can't get more variable than that. Being paid hourly is constant no matter revenue.
Is the real benefit of a JIT for PHP just performance or are there other impacts?
"Unit" actually comes from the scope of what you test, not how you spread the test logic across your test methods.
Look, we're not trying to ruin your project but you're basically asking for a red ferrari and telling us you've already got the red paint. The html/css part is the easy part, but you will probably want user handling, safe and secure content management, safe api communication and so on... this is a lot of stuff to know (and do right) as a teenager. No offense.
Awesome! Good luck :-) !
Symfony\Components are decopuled by design. When you create a project and pull in those components into your domain boundary you tie yourself to them, making it harder to migrate away from it. This is one of the major argument people put forth against big frameworks. In our case it's a calculated cost, but future developers might disagree with that decision and complain about us breaking boundaries to our business domain making it dependent on Symfony. The problem is not Silex itself, but developers who are inexperienced when it comes to organizing their code. Symfony provides guidance and components out of the box, with Silex you have to pull them in and set them up yourself. This might lead to people solving problems with custom components where existing solutions exist and maybe work better. The Event\Dispatcher was just an example for such a case in our project. I disagree with Symfony being harder to learn. It takes you by the hand, which Silex doesn't. Just look at templating which comes out of the box in Symfony and has to be setup in Silex, same goes for Security, Forms and many other features. Additionally Symfony provides easy to use helper-methods in the controller to access them. For someone who hasn't worked with frameworks before starting with Symfony imo is way easier than with Silex because of it's "batteries included"-mindset.
No offense taken, one of the most important things with projects is keeping an open mind. Thanks for the constructive criticism
Between automatic PHPUnit Detection from `composer.json` and Remote Interpreter support for Docker, I think it's shaping up to be a pretty good release. I'm also rather chuffed myself. One of the (small) bug reports that I submitted from 2016.2.1 is fixed in this version
&gt; Is the real benefit of a JIT for PHP just performance or are there other impacts? Performance becomes a categorical shift when it's significant. For example, if PHP was as fast as JavaScript (which uses advanced JIT), you'd need a lot less binary extensions for things like parsing, image and multimedia processing and compression, advanced computation, doing statistics and so on. So it's performance is never "just performance" if it's *really faster*. It'll change the entire ecosystem of PHP. 
It's compiling to machine instructions that run directly on the CPU. While running from bytecodes is basically a loop with a giant switch ... case statement in it (sort of).
Complexity is yet another resource. As I said, very few legitimate use cases. Libraries use it to integrate your code in. Code you write shouldn't need to reflect on other code you write,and if it does, perhaps you're going the overcomplicated way around the problem you're coding for.
For people who wants to learn more about this kind of stuff, it's called a polyglot.
This use case is perhaps relevant to 0.001 percent of developers.
will this have any impact on future PHP's ability to compile and run on non-x86 architectures?
The framework has to fulfill some requirements: maintainable, good documentation, easy understanding, and what ever the company that uses a framework likes to define as a must have. But at the end: There will be a lot of frameworks which will fulfill those requirements. It doesn't matter which one you take. Otherwise the statement could also be "4k Benq monitors with 144hz made $25million for Uber". Who knows if they also would be that successfully if they worked on Samsung monitors...?
And like others have said, this is a great way to manipulate a teenager to do stuff for you because they'll vastly overestimate the chance that this earns anything more than $0. Teenagers don't have bills to pay, but their time shouldn't be treated as complete disposable crap, especially for those experienced enough to do what you need them to.
Also, unfortunately I'm at HS when I get back I'll respond more thoroughly to your comment. 
Part of the site I work on deals with csgo internals and I get wayyy more than 15%
I started programming by learning OOP in Java, then went to C, then to C#, then got into web dev and PHP. It made no difference to me. OOP is OOP regardless of where you learn it from. The only thing that changes is the language syntax.
Hideous
Brian Will makes a lot of videos talking about why OO programming in general isn't good. Take his word with a grain of salt. He does make good points, but at the core OO programming (AFIAK) wasn't intended for speedier programs, it was meant (when done correctly) to prevent spaghettifying of code by pairing methods and data that are correlated together into one neat bundle for organizational purposes. There are people to this very day that side against pairing data and functions together, and think that OO programming is just an abysmal thing to happen to programming. My opinion is that OO programming is a pattern that you use when you need to, and only that. Do you need OO programming for everything? No. Is OO programming useful? Yes, it just depends on what you are trying to do. 
There is no such thing as optional. If a wide audience starts liking something and it is generic enough to apply everywhere, they will apply it everywhere. If you don't follow the dogma your code is shit. OOP with all bells and whistles is very complex and the implementation even more so. OOP is just used because no one knows better. It is shit tho.
Thanks, I understood some of those words.
Controversial. Still recommend everyone watch this. It's interesting stuff.
holy hell man can I hask you how long have you been in the field? You seem to know a lot and in detail. I always look for your answers here.
And then you learn that all you code is IO bound. 
Well it is not like purely imperative code with globally used functions everywhere is the alternative. If you do it right you can mock functions too.
IMO most interesting bit about the whole interview: &gt; **Cloudways:** What are the best features of Yii according to you? &gt; &gt; **Alexander:** Error handling and debug toolbar, code generation, forms, query builder and active record, data providers and data widgets, strong i18n layer, REST API framework.
Consider whether SaaS offerings meet your needs first (e.g. Bigcommerce, Shopify). There's still customizing and theming work to be done on the front end, but the hosting and most importantly, checkout process is looked after for you. Implementing a full stack e-commerce site can be technically very involved, and there are security PCI-DSS (credit card data safety) implications for your client depending on how you structure the payments on the site. In this space Woo Commerce would be an entry level system, Magento would be a larger more enterprise grade system. If you were to go with either of these systems, strongly consider using a managed host instead of self-hosting. In my opinion none of the Laravel alternatives are mature enough yet to be used in production. Self rolling your own e-commerce framework is like self rolling your own password encryption - never a good idea. If this is your first go at an e-commerce site, I'd strongly recommend going the SaaS route. You'll learn a lot about standard e-commerce design patterns and best practices, while still gaining coding experience while theming the front ends. Edit: s/SASS/SaaS/ props JackOfAllFates
What are the new feateres included in this release?
s/SASS/SaaS/
Cart/checkout is the biggest part and will backleash if you don't have experience. So find a solution that is solid and fits your needs. That is likely a cart software or service. (You could also use a generic shop software and just use the checkout.) I'd built the actual shop by hand, use whats most comfortable. Just get more requirements from your client and agree on a design or template and you can get started.
I like a lot the nullable return types
I know some speakers personally and they usually (sure, not all, but most do) travel in Business Class anyway. So there is usually at least enough space to work with a laptop and, with most airlines in Business Class, there's also a plug socket (you should bring a world adapter with you though).
Just checking in at the Helpful Comments From Airhead2016 Appreciation Station
That may well be the case, but I have never (nor has ever been done for me) been able to afford business class seats to go from South Africa or New Zealand to conferences in Europe or the States. This is all my personal experience, and a desire to try something new talking.
Not relevant to you is not the same as not relevant to [made up statistic] percent of developers. Let people enjoy what they want to...
The number of contributors who have the skill and other resources (time, etc) to work on a JIT native machine code generator is significantly smaller than the number who can work on the general interpreter. I'd prefer the main PHP implementation to not have one in order to keep it accessible. I am unsure how widespread this opinion is - it seems a lot of users mostly care about how much faster it makes their programs.
multiple projects... same frame!!! awesome. now we just need to get my draggable windows to split them like eclipse has!
That's one of the possible VMs, but the typical PHP VM you run is using indirect dispatching (i.e. `call (%rax)` (function pointer dereference + call)).
[removed]
So a proper JIT for PHP might result in game changing performance improvements. Not just incremental. What other sort of things might this open up for us? Might it allow a port of a library like lodash without eating all of the memory and be performant? "Lowish" level libraries written in PHP rather than C?
Where can I learn how to build IKEA furniture without the instructions?
I don't learn very well from text and would prefer a video series somewhere. 
Just try building something. A blog, an api. Slim is pretty straight forward.
Is there a way to update a doc-block parameters without creating a complete new comment block? If not i hope they make that a feature.
"Basically all dependency injection means is that if an object needs something, you pass it in." Dependency injection finally makes sense to me. Thank you, author!
I've been writing complex, working PHP for almost 20 years. I never really think about whether my code is technically OO. Most of it isn't. Because I end up maintaining most of the code I write, I do think about how what I write affects maintainability. I like having classes that can be reused for basic things. I wrote some procedural code for pagination a decade ago, and I eventually rolled it into a function, and then a class, and I use it everywhere. I like Composer for the autoloading feature. I like config files. All these things save time. I care little whether they are OOP or not. I do care a lot about performance, because poor performance costs me money - having to pay for more server power, etc. That said, I was forced to use MS office365 today for something. I'm sure that was built by people who make a ton of money and are way smarter than me, but that shit sucks balls and is annoying as hell to use.
&gt; Our container is pretty helpful, but it’s still a bit annoying to use. Having to write $container-&gt;set(...) for every dependency is tiring. Wouldn’t it be nice if the container could just figure out what you wanted? Relevant: https://www.reddit.com/r/PHP/comments/50hs8u/lets_talk_about_the_builtin_reflection_api_when/d74z4g5
How did you handle the payment security part as that was/is the thing I'm most scared of as I have no clue how to properly go about it
I actually found multiple laravel solutions but they're all very much in baby shoes and I don't feel comfortable using them yet, I'm probably being paranoid but since I've never done this I rather go with something more established
Thank you, will check it out!
I use it extensively, and am moving away from it due to its instability and core integration, which makes it a mess, at times. Still required for runtime interaction though. At least for introspection, I am moving to https://github.com/Roave/BetterReflection, which is 100% userland.
I love this comment so much! Why is everyone just downvoting it? :-(
You are making a lot of shortcuts here: &gt; - Just add something to your constructor signature, and you get it. No oversight, no questions asked. No interfaces to follow, no architecture (or architect) to align with. Having used both autowiring and non-autowiring containers there is absolutely no difference here. Whether you have to add 1 line of config or not doesn't mean you'll follow interfaces/architecture or not (or whether you'll go "ask an architect"). &gt; - Qualifiers. "We'll never need more than one of XYZ!" You seem to carefully sweep under the rug than most autowiring containers also offer to configure injections manually… What usually happen is when you have more than one of XYZ you *do* write configuration. So in the end you only save writing configuration for trivial stuff, but it's often a big save. &gt; - Artificially introduced empty classes and interfaces. I've been maintaining PHP-DI for 4 years now and I've only seen this done twice by very junior developers asking help in the chat. Nobody does that, this is very bad code and roughly anyone who architects an application knows that (else they have much bigger problems). &gt; a component gets what it needs, without knowing where it gets it from, while the caller has control over what's provided. Unfortunately with autowiring, the provider gives up their control in favor of automation The whole post sounds so ignorant but this is the best part… "People who use autowiring don't know how to ask for interfaces in their constructors!!1!1"
JIT to my knowledge is mostly useful for long running processes. It's part of why java code usually needs "warmup" time period, because the code itself is being optimized as it runs more and more. So the JIT is figuring out how to speed up the execution in real time. So if you were to write a web server in php, it would probably run faster with a JIT, because the webserver would have time to be optimized. HHVM is a binary and it also has an JIT
&gt; Having used both autowiring and non-autowiring containers there is absolutely no difference here. Whether you have to add 1 line of config or not doesn't mean you'll follow interfaces/architecture or not You ignore scope and responsibilities. The team that writes a module typically doesn't define the application config. So if they can change the contract on their side, without the other side even knowing, this will be abused (unintentionally or not, it doesn't matter). In a small one-man project there is indeed no difference. Barely anything makes a difference in a small one-man project... &gt; You seem to carefully sweep under the rug than most autowiring containers also offer to configure injections manually I'm not swiping anything under the rug, I'm talking about autowiring. Passing parameters manually (either via PHP, or some YAML monstrocity) is not autowiring. And once again, don't ignore scope. The config is at the app. The qualifier is at the component/module. If you control the module, you'll start adding qualifiers there, as that's what you have access to. There's no good use case for qualifiers. At all. Autowiring encourages those, as it's the step of least resistance when you get multiple instances of the same class/interface at your container. &gt; &gt; a component gets what it needs, without knowing where it gets it from, while the caller has control over what's provided. Unfortunately with autowiring, the provider gives up their control in favor of automation &gt; The whole post sounds so ignorant but this is the best part… "People who use autowiring don't know how to ask for interfaces in their constructors!!1!1" That's not even *close* to what I said. I'm talking about why dependency injection is done, interfaces or no interfaces. It's about inversion of control, and when you don't control which component *exactly* is about to receive your container pseudo-singletons, then you have given up control. The fact you can "optionally" decide that (when the app crashes and burns on startup) doesn't mean you're doing a good job preserving your application's architectural boundaries. This is letting chaos reign and putting out the bigger fires at the last moment with custom rules. Also, please act like an adult, and present actual arguments, instead of making up "!!1!1" quotes.
glad to know you like the interview.
&gt; The team that writes a module typically doesn't define the application config. That's again a big shortcut. Teams working on their own modules without control on the config doesn't represent the majority of projects. "One-man projects" are not the only other option at all. &gt; I'm talking about autowiring. Passing parameters manually (either via PHP, or some YAML monstrocity) is not autowiring. OK I understand, but then it's like saying a fork isn't useful to eat because it can't cut: yes it can't cut but you don't use the fork alone, so it makes no sense to discuss the fact that the fork can't cut. &gt; and when you don't control which component exactly is about to receive your container pseudo-singletons, then you have given up control. I don't understand why you think there is no control. I think you are seeing this from your specific POV with teams working on modules but not the config/application, but that is far from representing all projects out there.
What are you talking about? 
&gt; If they [developers] have control of the config of their dependencies, then the control of their dependencies wouldn't be inverted would it? [Inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control) is not about inverting the control between developers/architects, it's about code. Components give up control in favor of the application: &gt; Inversion of control (IoC) is a design principle in which custom-written portions of a computer program receive the flow of control from a generic framework Whether you apply it to teams/humans and their workflow is up to you, but it's not required and I disagree it should be presented as "the only way" to do dependency injection. Especially since there are developers of very different level in here, working in very different contexts (one man projects, simple projects, agencies, big/complex projects, etc.). Not everybody need to have developers working on components separate from those writing the config. &gt; So, I guess autowiring is probably useful if you stop giving a damn about a project the exact moment you ship it. I tend to work on long-term projects, so I care what happens after version 1.0. I've always been working on long term projects and autowiring has always worked well. Of course it's always possible to shoot yourself in the foot, but that's the same with anything. Anyway yet another shortcut. &gt; I gave an example of a random controller grabbing an SQL connection for itself. What about code review, pair programming, tests, communication in teams, asking questions and explaining stuff to junior developers, etc.? You can't prevent, for example, a junior to do `$db = new Mysql('...')` in a controller yet it doesn't mean we should "deactivate" somehow the ability to do `new` in PHP.
I always prefer using https://www.prestashop.com/ Or http://www.opencart.com/ They both have demos, so you can check their functions before installing. If they meet your requirements and I believe they will you can go and check their code. Prestashop is harder to learn if have to make custom modules etc. Just stay away from magento and osCommerce.
I think op wants PHPDoc comments to automatically update when the function or variable is changed. I wish this happened too and if you're reading this comment and there is a way to enable it feel free to explain!
well I was planning on doing a video series, but time is becoming an issue. our slack, irc channel and discourse site, are a great place to start
I think that'd make the ide too opinionated. I don't want it to automatically change my doc blocks. It's nothing a quick alt+enter can't fix anyway. 
I don't know about them, but I want to tell you something... **Happy Cake Day**
Clearly you haven't been around internals much.
+1 Handy set of commands to have. You should post this to /r/laravel 
Will do!
&gt; Should we expect that when the JIT compiler is implemented, PHP's speed will be on par with Node.js? Probably not. JavaScript engines have had thousands more man-hours put into their performance. If a JIT compiler is implemented properly for PHP it should at least bridge the gap quite a bit, but don't expect it to rival a JavaScript engine.
then you wouldn't use that feature, I'm all about having more options that not everyone uses. If I add a new dependency to my constructor and I can automatically update the doc block based on the parameters starting at the first @param line then that'd be an amazing feature for me. May look into modding/extensions to make this possible. And yeah it's not really a big deal, but updating doc blocks that you just generated a few minutes ago can get tedious.
Note that this is from 2012 and describing PHP 5 arrays. The same topic (still for PHP 5) is covered more thoroughly in the [PHP internals book](http://www.phpinternalsbook.com/hashtables.html). I have another post with a basic overview of [hashtables in PHP 7](http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html), but it does not cover the internal API.
I'd prefer a better title for this post as this is Laravel related but not stated in the title at all.
You couldn't change your $PS1 long enough to take that screenshot?
I'd prefer this was posted to the /r/laravel containment board instead of bleeding over into here.
I tried posting there but looks like its getting marked as spam.
We don't have a set release date, sorry. We released the Mac version first to validate our product. I personally wanted to launch with the Windows version, but we hit a lot of complications and it just wasn't possible. I'm working hard to get it done as quickly as I can. I'd love it if you signed up for the newsletter so that I can keep you updated on the status of it. We'll be rolling out a Windows beta just like we did for our Mac app as well, so you'd be one of the first to know. Edit: Another thing that you could do is test out [`tj`](https://github.com/ezekg/tj), the CLI, on your Windows machine and report any issues that you experience. I'd really love the help from Windows users.
I tried exploring this when wanting to created memorized methods on a class. The goal was to have something that would otherwise look similar to this if it were valid: class Reticulator { function __construct() { $this-&gt;reticulate = memoize( array( $this, 'reticulate_raw' ) ); } function reticulate_raw( $spline ) { … } } $r = new Reticulator(); $r-&gt;reticulate( $aGoodSpline ); IIRC I ran into the same issues with being able to invoke those class properties without going through a mess.
"Amazo" Hello lawsuit.
 &gt;Just stay away from magento Why? Could be overkill?
There are two existing decent solutions for this (although not completely automatic). Both require to have enabled: File -&gt; Settings -&gt; Editor -&gt; Inspections -&gt; PHP -&gt; PHPDoc -&gt; PHPDoc comment matches function/method signature (make sure it's with severity "Warning"). 1. Whenever you see a warning/highlighted argument, put cursor on it, press Alt+Enter -&gt; "Update PHPDoc Comment". 2. Code -&gt; Inspect Code -&gt; File or entire dir. In results select PHPDoc -&gt; "PHPDoc comment matches function/method signature" and press on "Update PHPDoc Comment" button. This will update the docblocks for all methods where it found something wrong.
Those are very good feedback. Would you be kind to create a pull request? 
Don't give them up-front pay, you've said yourself that you only expect "10 minutes a week", at $20/hr, you can pre-pay around a month and a half with $40. Of course, this brings up the issue that you can't actually work on a codebase for 10 minutes a week, the reason almost everyone has a 1 hour minimum when freelancing is that it takes you a while to get set up and get your mental model of the codebase ready, at that point you're 10-30 minutes in and you've only just started writing code at full speed.
If you post to a payment provider URL there are expanded PCI-DSS requirements.
Given OPs experience level (above), Magento would be way too complicated a platform.
probably I should use the word library instead of framework?
do you find it an helpful library/framework or? any other inputs?
Compile PHP yourself, with all the extensions compiled statically into it?
There's a few options to get what you want here. Here's a few ways to get what you want, in increasing "goodness" (and complexity!). You can decide to go as far as it makes sense for you. 1. Learn to install these on RHEL7 and then script that using Bash scripts so you can repeat the process. Keep in mind you probably want SELinux enabled (enforcing). The [video here](https://serversforhackers.com/video/battling-selinux-cast) and especially the one linked in the resources section of that article can help you learn about SELinux. 2. Learn Ansible, Chef, Salt or Puppet (I'd suggest Ansible to start), which are "better" than Bash scripts in that they give you a sharable (read: put into version control), repeatable (can keep repeating the build steps without worrying about bad side affects, which bash scripts can't typically do) way. These are great for multi-server environments, or anything even a tad complex. SO WORTH KNOWING. 3. Use Docker. It can help you build small images that work together and can run on any platform. Docker's main purpose isn't necessarily to make everything super secure. Instead, it's main benefit is in helping you develop a build and deploy process where you can worry a tad less about the host server (e.g. your RHEL 7 server) since each container is sort of it's own little server that barely runs anything. Overall, however, if you're asking about Docker and Vagrant without really any idea of what they are, I'm guessing you have a bit of a ways to go to wrap your head around what all the tools are. Vagrant, which I haven't mentioned yet, is really only about running local virtual machines for development - it's not a tool for provisioning production machines, although in theory it can be bent to that purpose. Hope that helps and doesn't confuse more!
Id prefer if you had more than a week of experience with PHP before you got all whiny :)
My best advice is to try and make friends with the AS/400 developer(s). At the company I work for it's one lady who is very busy and is the only person who knows how everything works. After we were put to work together on a project and asking endless questions, I was able to build an order entry application. A good starting point for questions (and self-discovery) is to look at the database (called a library). Just start exploring the database/library of tables (called files) and start asking questions and take good notes. You may want to look at a database client like [DBeaver](http://dbeaver.jkiss.org/) to browse the data. Start to understand how there are no ids, just composite keys. You won't be able to derive relationships from foreign keys (because there generally aren't any), so start to look at field (column) names to make assumptions - and then ask questions along the way. While you're trying to learn about the 400 data, try and get the existing php script mess you're dealing with under version control. See if you can bring up the 'application' on a separate development server. It'll be important that if/when you break something, that you can revert your changes. It'll be a safeguard to allow you to make bigger/bolder changes. One of the first changes, being some configuration management. You'll want to see if you can get you development application pointed at a development library (database) on the 400 - so you can run or perform some test without touching live data. When first starting out, I had no luck connecting to the AS400 using only odbc. I had to install IBM's proprietary iSeriesAccess-7.1.0-1.0.x86_64.rpm from their website (login required) before anything would work. Hope this helps a little. Edit: A little more details from a build script I use to install iSeriesAccess on Ubuntu 14.04 https://paste.ee/r/wUQq4 (note that I copied/pasted the external files into the script)
To start with, absolutely no test. If it's to learn and have fun, that's ok, if it's meant to be something serious I wouldn't even bother looking.
I'm not sure why they never caught hold, but I would definitely welcome the addition!
Alot have changed in the past few hours. What you are seeing now is different from what was up before. With the feedback from https://www.reddit.com/user/phpdevster I have take out almost everything so basically there is nothing there to show at the moment as I am still changing up and pushing.
but which values in the`$options` are valid? are valid for a function? which have defaults and what are they? You can't know without looking at documentation or delving into the code. Fine, if the documentation is simply and the code is legible but this isn't always the case. You also can't typehint the values in the array you're passing in. I also don't think it'd cause a bc issue - positional params would (as best i can tell) continue to work. 
Previously on Reddit: https://www.reddit.com/r/PHP/comments/266y2o/state_of_named_parameters_rfc/ PHP is an open source project - you could either contribute this feature yourself or sponsor (aka pay) someone to spend some time implementing it? Also, the [list keys](https://wiki.php.net/rfc/list_keys) was a step towards a possible implementation. 
&gt; This means you can't tell how the caller is going to call your function, which is a problem One possible RFC that might be worked on at some point solves this problem by only allowing functions to be one of either: * Called by position - which would be all existing functions. * Called by name - which would have a small bit of new syntax. That solves the problem of needing to support two different modes in a single function, as well as avoiding the "how the heck do we retrofit named params to all existing functions" problem.
Why MongoDB? Seems like a hassle to set up a server just for some data. You're not doing any inserts or updates, and the queries are just select all. Why not just save out the results as json files. One for the county list and one each for the cities in country. Faster, easier, and less resources required. Hell you don't even need any code.
I don't know if this is feasible, but Rob Allen is doing a tutorial on building APIs with Slim 3 at PHPNW tutorial day: * http://conference.phpnw.org.uk/phpnw16/schedule/ * http://conference.phpnw.org.uk/phpnw16/speakers/rob-allen I won't be at the tutorial day, but I'm there at the conference, hopefully see you there :)
Named parameters are a whacky solution to an artificial problem. If a function signature is confusing it probably something wrong about the function. 
One area they're very useful for is boolean arguments. WordWrapper::wrap($input, $cols, $break = true); Coming back from Scala where that's recommended I really miss it.
Mother of information! Thank you very much for all this things! Now I understand how the data is organized and called, but I have a question: can I use the PhpStorm database clien to connect to the AS/400 database? I don't want thousands of programs to work with just to get my job done, I mean it'd be nice if I can centralize all the tools in one. About making friends... Well... It will be kind a difficult because the only guy, who understands how that machine works, is from a consultant company and probably I'll have to bomb him with all the questions via email or phone calls. The development environment is my high priority. It seems this company was buying the machines directly to IBM, so I have all the liceses, installation CDs and more. Is there any documentation about how to use that CDs and in what order? Because IBM is not very famous about providing full documentation.
You don't have to. Use docker exec on your running container.
Too bad the same didn't happen here.
Named parameters are a bad idea. They were a bad idea in Python and they will be a bad idea in PHP. What PHP needs is static polymorphism like Java . You can define the same method many times with a different signature. Named parameters lead to BAD API and codebases.
$gpw6 is base64_decode $ioq8 is _POST So this script looks if you have an input called n828043 sent with POST. If it finds $_POST['n828043'] it will eval the return of base64_decode of $_POST['n828043']. Basically someone sends a request to your site with a post parameter called n828043 and can run custom php code.
So essentially this is the code: if (isset($_POST['n828043'])) { eval(base64_decode($_POST['n828043'])); } It simply allows someone to execute code directly on your system by posting it to your system, hidden in a variable called n828043.
Get out while you can.
I think you meant to say an `$options` value object.
Pretty much this. Can't do much about it on an existing system though.
There are too many possibilities for anyone here to answer that. If you google that specific code it looks like a static variable used in attack kits that exploit WP going back to at least 2008. Could be any one of hundreds of potential vulnerabilities but seems like it's a basic script kiddie style attack so basic steps would be things like: * if you know when it started restore from backup prior to that date * update all your plugins * check you DB for unknown users * reset all your passwords including hosting, ftp, database etc * watch your logs especially your mail logs as this sort of thing is usually used to turn your site into a spam relay and if dodgy stuff continues to occur time to look at upgrading WP itself * if it still continues there is likely long hidden exploits injected into index pages or htaccess files or something if you don't know how to hunt for that sort of thing research or enlist expert help
There are tons of mvc based frameworks out there. A simple google search will show all kinds of projects. All modern frameworks will use OOP principles and you be doing yourself a huge service to at least learn the basics. Honestly you won't get anywhere if don't understand the core OOP principles. Pm me if u need some more help on where to start.
Surrender is not an option.
I keep seeing the book [Moderning Legacy Applications in PHP](https://leanpub.com/mlaphp) by /u/pmjones on various places online (almost as if the marketing gods are trying to get me to buy it!). He's given a few talks on this as well, I just recently watched [this one](https://www.youtube.com/watch?v=65NrzJ_5j58) and I think it would be great start for you. He actually gives you a great starting point before you need to buy the book. Disclaimer: I haven't read the book, but based off the quality of the video, I'll still recommend it.
I'll break it down to you how I see it. **Models** So we're working with an asset/laptop tracking app. So we will have various devices associated with a location and/or person. It makes sense to have a model named `Asset` defined as something like: class Asset { // The primary key in the db. public $id // Your company's internal asset number/id. public $assetId // The estimated value of this asset. public $value // Laptop, Desktop, Monitor, Table, Chair, etc. public $type // This would be a one-to-one relationship public $location // Any other properties you need } Now we have our model for our users: class User { public $id // Could seperated these out to $firstName and $lastName public $name // One-to-many relationship public $location // One-to-many public $assets // Any other properties you need } This is just a very basic broad overview of models, each framework has their on ways of doing things. Now we come to: **View** There is nothing special really about the view, IMO. There should be _no_ business logic here and its role is to primiarly display the data (Model). That's it. The views is basically just plain HTML or whatever templating engine you use. **Controller** A controller is responsible for handeling requests and creating or preparing responses to a mapped route. There should not be complex business logic in the controllers. public AssetController { // Display all the data on assets public function index() { render([ "view" =&gt; "views/index.html", "model" =&gt; Asset.all() ]); } // Mapped to /asset/create, method POST public function create() { new Asset($params)-&gt;save(); redirect(["action" =&gt; "index"]); } } This is a very basic/broad overview, the other redditors here have given great comments as well.
Thanks for the response! I'm willing to learn docker but before I start does it require Internet connection on the server it is being deployed to? Because as I mentioned these servers are locked down, so ideally I would need to have a package prebuilt and then unpacked on the restricted server. EDIT: I just found this - https://github.com/davidgaya/docker-apache-php-oci which seems to be what I'm looking for. Now I just need to figure out how I make this image so it can be deployed on servers with potentially no outside internet connection
Look in your server logs. Probably vulnerable CMS or plugin install.
The primary extension I depend on is oci8 which itself depends on Oracle instant client. I may explore this option if docker is not the solution I'm looking for.
Why do you think named parameters lead to poor APIs?
Yes, that's what I really want 
ITT: same old antiquated arguments against new features. somefunction( method = "newmethod", type = "sometype", obviousness = true, width = "5000px" height = "1000px" depth = "10px" ) vs somefunction("newmethod", "sometype", true, "5000px", "1000px", "10px") The effect compounds in more complex functions or initialization of classes. Named parameters massively improve readability and allow a developer to know what each variable type is.
Why not both?
Well the real problem is we don't have real method overloading, so we have to resort to workaround which break static analysis.
I don't find this to be inconsistent at all. Inconsistency would be to allow spaghetti ways to call those functions, but by clearly differentiating how to call which function I don't really see new problems arising.
Yes, hence [pickle](https://github.com/FriendsOfPHP/pickle): &gt;Pickle is a new **PHP extension** installer. It is based on Composer and the plan is to get Composer to fully support it. See https://github.com/composer/composer/pull/2898#issuecomment-48439196 for the Composer part of the discussions. &gt;Pickle fully supports existing extensions in http://pecl.php.net, running the following will install the latest available version of the memcache extension:
Exact same answer. PSR-2 is my recommendation. Make sure you hook up something like StyleCI or Nitpick CI to enforce it on your commits and PRs. 
PSR-2 specifies camelCase for method names. Functions, properties, and variables are not mentioned.
&gt; They were a bad idea in Python How so? I write plenty of Python, it's been great because it tends to make things more readable if done right and has no meaningful downsides relative to positional-only argument passing I've ever seen since you can still do fully positional-based calling. &gt;You can define the same method many times with a different signature. Ignoring for a moment that it'd be really hard to do that in PHP given behaviour as it exists now: How is that related to named parameters? &gt;Named parameters lead to BAD API and codebases. In what way?
Just keep Composer how it is now. Something you can go download and use separate from the language. Programming languages don't have to be in the business of managing packages. I know several languages come with the most popular package managers pre installed, but the most they really need to do is say "this is what's currently popular with the community" and link out to go download and install that as well Edit: language extensions might be a bit different, but I don't know that I've ever used one. How does Pickle currently work? Is it similar to Composer in that they have a repository of user created extensions that you can install via command line?
*twitch*
I've found that `camelCase` to be the most consistent between packages and libraries. `snake_case` will prepare you better if you ever decided to pick up Python though (that's both a pun, and a fact).
You might use Wordpress....
Relevant reply: https://www.reddit.com/r/PHP/comments/50hs8u/lets_talk_about_the_builtin_reflection_api_when/d78i3pu
&gt; How does Pickle currently work? Is it similar to Composer in that they have a repository of user created extensions that you can install via command line? Pickle can install extensions from private repositories in the same manner composer does with PHP packages, but it can also install directly from PECL. It is a definite advantage over the current PECL tool, but I don't think it is a game changer in the same way composer is. As for PEAR, the library should remain as is, curated and what not, but it should be accessible through composer. There is no need to have two different tools especially that PEAR is old and clunky.
This playlist is good (Authentication with Slim 3) https://www.youtube.com/playlist?list=PLfdtiltiRHWGc_yY90XRdq6mRww042aEC (and its not only for authentication as title say)
This is correct. I prefer snake for variables.
Nice, based on slim microframework
The Quorum Language has [data](http://dl.acm.org/citation.cfm?id=2534973) showing camelCase is slightly more readable across developers of different skill levels. If you have something that shows different (like across non english speakers), I'd be interested.
I've run `gis.php` (ghost in the shell) in the past to detect vulnerabilities in PHP sites. https://github.com/gdimi/Ghost-in-the-shell
&gt; I don't want thousands of programs to work with just to get my job done, I mean it'd be nice if I can centralize all the tools in one. Adorable! Welcome to development in the Enterprise, amigo.
You kidding?? This gig has Job Security written all over it!
I used to be a camel, but found my snake life to be more readable. In some rare cases, as a camel, it's hard to know how to hump things like initials or 1-letter words - which either leads to more rules or inconsistency. Just a (new) personal preference and I'm fine coding to match either style.
snake_case for PHP, and camelCase for Javascript. I use both extensively in all projects, and this is one way to help distinguish between them at a quick glance. 
I use camel for methods and it's variant studly for classes and snake for variables and functions.
Just checked out the changes. Much better, nice work!
The `$` doesn't make that easy for you to distinguish which is which? In fairness, I do sometimes use `$variableName` in js when I'm working with jQuery objects, but I feel like that's not a popular convention.
To be fair, Java will definitely do a number on your opinion of OO. The other day I was watching a colleague get a new employee up to speed on my company's Java architecture, and the hierarchy tree he was digging through was (I kid you not), 9 levels deep. 9. He was just trying to find a method to show the new employee, but had to keep going "Nope, click through. Click through again. Nope not there either, keep going". I'm just a UI developer at the company, but I felt actively embarrassed by what I was seeing :( I've rarely encountered PHP code like this, but apparently it's common in Java. So I can understand why a Java programmer feels slightly violated by OO.
/u/k_u_r_o_k_u_s_e point depends on what he means. Named parameters in and of themselves are not bad. If however they allow for arbitrary optional parameters, that's when things go wrong. Optional parameters are *generally* a code smell, and they make usage of the method very unclear to the caller. If you have say, 4 named params, and only certain combinations are valid (e.g. param1 and param3, or param2 and param4), that's just poor API design. You can't know ahead of time what param combinations are valid. With method overloading, you can explicitly declare multiple valid variations of the function's arguments via explicit signatures, which then make it clear how to call the function. So I tend to agree with /u/k_u_r_o_k_u_s_e that if named params are implemented as a way to facilitate the spread of optional parameters, fuck that.
There's a great tutorial on this exact thing at knpuniversity.com. That's how I learned OOP PHP, they start with a procedural PHP app and each lesson teaches you a different facet of OOP while converting the app one piece at a time. 
This is true on that one line in OP's post, but somewhere in the script eval has to be typed out in order to run the virus, they've basically made a cipher of the alphabet and in order to execute their cipher as php code they need to run eval on it. But yes technically they could do: function TotallyNotAVirus(...) {eval(...) ;) 
http://i.imgur.com/S9sZCOD.gifv
I do this too... 
I like camels. And studly for class names. Constants in full caps and snake. It's all personal, but I like to think it saves me keystrokes of underscores and it's easier to read. It's quite possibly because I've seen a lot bad code and it happened to use snake case. So I now associate snake with bad code. Also in Javascript and Java and C# and any other language I've ever encountered I've never really seen a lot of snake case. 
Everyone else here is saying just pick one and be consistent, some are saying one way or the other, but I'm going to break it down into why. When you use underscores you have to type more characters and you have to type the exact same combination for everything. _ requires one of two key combinations: `Left Shift + -`or `Right Shift + -`. If you use right shift then you're using your pinky and stretching your middle or right finger up. The more you do that as a distinct key press the more awkward it feels and the gymnastic exercise it puts on just one hand. If you use the left shift then you're committing both hands to moving at the same time, making it harder to type fluently. Basically every time you have to type an underscore both hands go whoosh to opposite sides of the keyboard and any flow you had while typing is now gone. CamelCase, on the other hand, doesn't require any special symbols, uses one less key press, and best of all allows you to use either shift interchangably while maintaining a flow to keep typing. It's a lot closer to typing actual sentences versus symbol-laden code. Readability is also an important factor in choosing a style. Underscores increase the spacing between words, which can seem good at first, but they also make the spaces between words the same as the spaces between operators and other variables. This inadvertently makes it harder to distinguish distinct variables, operators, or concepts without putting more mental effort into breaking apart the full code flow. Thankfully the difference between these two styles for readability is largely about familiarity. Once you've been exclusively reading and writing camelCase variables for a couple of weeks the brain adjusts and it's just as easy. Another benefit of camelCase is line length: for each word in different parts of a single line of code the further your eyes have to travel from left to right and back again to read multiple lines of code. So, to summarize: I strongly prefer camelCase in any code that I write or maintain.
So, I'm personally a fan of each table being a class, and formatting it that way. Doing a framework can help with this, and utilize some nice code. So say you have a table for laptops, and a table laptop_peripherals with a column inside it "laptop_id" you can easily automatically create classes in yii (and im sure many other frameworks) where you could load your laptop, then do something like count($laptop-&gt;peripherals) (very simplistic idea of what I'm talking about) Now, as far as starting the process. I would do it in stages. Start writing the classes for your MAJOR areas. Then, pick a section, preferably starting with the most important areas, and re-write them in OOP. From there, to easily integrate, have your page load the OOP pages in an iframe or, if you can just load it in there. Then, from there, when you start to get it going, swap. Have your OOP actually do the controlling, and load only old pages in iframes. From there, just keep plugging away until you're done.
Well, since everyone is giving opinions, I figure I might as well too. I've always used snake_case for variables and camelCase for function names. I know it's not really necessary, but I feel like it helps me differentiate between them.
I'm not talking about who *creates* an instance, but control over who *receives it*. I don't know why people write replies and they don't even read what I'm talking about. &gt; Any good auto-wired IoC will also pass the calling context into the key lookup so that the factory can still decide which implementation to give to which calling context. Tell me how you tell your favorite DI container to *not give* any database connections to any of your controllers, because they shouldn't have access to it. How do you control *that*? And how intelligent it is to think about dependency flow in terms of blacklists in the first place (I forbid A, B, C, D, E, F... and 300 others to get PDO), instead of whitelists (I give X and Y access to PDO). Manual injection is a whitelist. Autowiring can at most have a blacklist, and many autowiring containers don't even have *that*.
&gt; Autowiring can't create a PDO instance in the first place. I never said it does. I don't know why people write replies and they don't even read what I'm talking about. The problem is lack of control over who *receives* which instance, not who *creates* an instance. Tell me how you tell your favorite DI container to *not give* any database connections to any of your controllers, because they shouldn't have access to it. How do you control that? And how intelligent it is to think about dependency flow in terms of blacklists in the first place (I forbid A, B, C, D, E, F... and 300 others to get PDO), instead of whitelists (I give X and Y access to PDO). Manual injection is a whitelist. Autowiring can at most have a blacklist, and many autowiring containers don't even have *that*.
Thanks, I'll look for that.
&gt; Camel casing looks horrendous What you use looks great. What you don't use looks horrendous. If you start using camel case, you'll get used to it. &gt; What is most common for NEW open source PHP packages? Camel case. Case isn't that important, but think of it this way: you have a limited "budget" to disagree with common standards, before you're just rejected as a "lone wolf", so spend that budget on important disagreements, not minutiae, like camel case. Just go with it and within days it'll "blend in" in your mind and you won't think of it ever again.
&gt; But what should you use with a clean slate and without legacy code?? Just FYI, PSR-s 1 and 2 are not for "legacy code". They're pretty much the norm for modern PHP projects. Right now.
I've read some Yii books that do, you might want to try some of those. The thing is, people writing the free stuff don't have the incentive to put that much effort into it. Pay for a $10 book on google books or amazon kindle for your tablet, and it's a bit of a different story usually (and those apps let you usually preview, so you can see if that put in that effort)
Don't do OOP for its own sake. Do it if you need it. &gt; I was repeating myself an awful lot There is no connection between this and OOP. You can repeat yourself with or without OOP. Instead simply make clean, easy to understand functions. Organize them well into files. And it makes little difference if you bundle them in classes. OOP is good when you have shared data (shared state) between a bunch of functions. OOP is good if you subclass things. Otherwise there is little reason to use it. Especially don't use it as a function organization tool. (Having multiple files works better for that.) &gt; Am I supposed to code methods that spit out all my form controls and other page elements? No!!! Never do this. It leads to utterly unmaintainable code. Just write HTML, that's what it does. (If you try to do it you'll end up with such an enormous mess of functions that add this element, and that attribute, you'll rue the day you ever thought to do such a thing. And forget about ever having another programmer work on it - it's easy to find people who know HTML. Your custom set of functions on the other hand, not so much. The worst part is after you are done the functions won't actually be helpful anyway!) You can make some helper function for things like `SELECT` loops, and helping you automatically add `CHECKED` to `INPUT` elements, but nothing more than that, and make sure the functions work fine if you intermix them with real HTML.
If you PM me I'll help you design a Jenkins pipeline for deployments. 
Can you go into a little more detail on why facades are bad? And why Active Record orm (might) be an issue as well?
That's great, perhaps you can share some tips on how to get up and running. I personally use EB and it can be as simple as point and click to setup and deploy a PHP stack taking literally less than 10 minutes. And also on the other end of the scale can be fully customised and automated. EB also has some neat features like 0 downtime deployments an platform upgrades with automated rollback.
header('Location:http://whateveryourmachinenamedomainnameis/dashboard.html'); I don't really understand your problem. Though you'll need to set something in your users session marking them as authenticated. Also you should be serving your html from a php file so you can do authorization before rendering. You should have a read of this: http://php.net/manual/en/features.http-auth.php and this http://www.homeandlearn.co.uk/php/php14p1.html
You could do that, but it's probably not a good idea. So let's say you can access your form at the URL "http://myraspiserver.com/index.html" (or maybe you enter the IP address of the Pi instead of a domain name, it doesn't matter). you could use `header('Location: http://myraspiserver.com/dashboard.html')` and it would probably work. The problem with that is that your autentification becomes useless since anyone could just go directly to dashboard.html without using the form. What you need is some kind of authentication middleware : a portion of code that will run on any page that requires authentication, check if the user is logged in, and redirects him to the login page if he's not. Of course you'd need a way to remember if the user is logged in from page to page, which is where [sessions](http://php.net/manual/en/session.examples.basic.php) become useful.
&gt; We get these all the time on Drupal/WordPress installations God bless.
Camel case is the worst thing ever invented.
[removed]
Perhaps I didn't explain myself well. I get the strong impression you haven't used an autorwiring container before. There's nothing about one that prevents you from manually wiring up objects. (You *have to* for instances like PDO.) So if you don't trust your controllers manually define them. The real solution to the problem is code review, though. Fundamentally there's nothing that can stop a developer from violating the app architecture. All they'd have to do is manually instantiate the object in the controller.
`XMLHttpRequest` is still a great tragedy
I used to use snake_case, but I've now converted to camelCase. It feels more consistent, especially since I use camelCase in all my JS too.
Thanks, I hadn't had my daily dose of misinformation yet.
&gt; As a UI developer I'm embarrassed you feel qualified to comment I've been writing OO PHP for a hell of a lot longer than I've been a UI developer. I can assure you I'm far more qualified to comment on the quality of OO code than the UI code I work on ;) &gt; Are you implying procedural code would have made finding a method easier, or perhaps some other paradigm? What evidence do you have to substantiate that the paradigm has anything to do with ones ability to navigate code? If your colleague cannot navigate his own code you are feel to feel embarrassed for them if you must but do not falsely attribute their incompetence to object orientation. What the honest to goodness hell are you on about? Where on EARTH did I say procedural code is better? Did it not ever occur to you that I was simply implying the Java my company has written is merely *poorly designed* OO code, not that OO is a shit paradigm? 9 levels of inheritance is a ***textbook case*** of why composition is preferable to inheritance, and why when I write OO code, I *never* write more than 1 level of inheritance, because there is precisely no scenario that justifies more than 1. My point was merely that really opaque lasagna code appears to be common in *Java* OO, which is why I'm not surprised that this guy's feelings towards OO has been tainted by it.
Ok, let's see. Beacon me when it gets finished, if you don't mind 
[removed]
how could i forget about archive.org :3
Well that's comforting. I've yet to see it with anything I've worked with, excluding the project I worked on with a guy who shared that convention with me.
I would make a small non-php, python or bash, service that runs on a timer file and updates a file/db or can be queried on demand by the PHP application only. I would not try to do this from a Web app.
You seem to think that being more angry makes you more correct. If you don't understand or you don't care where the line is between modules, configuration and application (which your code examples seem to demonstrate), then I have no case to make here. So, that's fine. Keep doing what you do. My advice applies to large modular applications maintained by more than one person.
You'll need to parse the output of an external tool, more than likely. Found this gist that does exactly that. https://gist.github.com/cschaba/4740380
**tl;dr; Because Wordpress**
I do understand precisely how it works. My focus is around contract between modules, and modules and application, and how autowiring makes these contracts implicit, unclear, and helps components violate them (due to ignorance or pressure of deadlines). Your focus is on catching me not understand how containers work, therefore we're not on the same page. Matching by type is never the whole picture. If you have a NumberIterator instance, it may provide a sequence of prime numbers, or a sequence of random numbers, the type alone doesn't help. Autowiring encourages designs with overly specific types, that *only exist to aid the autowiring container*, ex. PrimeNumberIterator, RandomNumberIterator. This is logic you could configure at a runtime instance, but autowiring forces you to create explicit static types for it. This is one aspect of the issue, another is who has access to what in a large app, there are lines and autowiring removes those lines. Everything goes. My opinion is not exactly controversial, not in the software industry as a whole, but maybe in the PHP industry, as we're always lagging a few years behind Java and .NET on these matters: https://www.google.com/webhp?q=autowiring%20is%20harmful Autowiring allows serendipitous ad-hoc injection of dependencies that don't belong at the layer they're requested. This encourages modules that take on more responsibilities than they should, increased reliance on a specific application's environment, and results in less reusable code. It also results in very surprising bugs, where the component causing the trouble is not where you expect (say: you expect domain state artifacts to be caused by your domain layer), because *anyone anywhere* can take on a dependency and mess up your business logic. You respond "fine, then use manual injection there". Which... is, after all, the whole point: remove autowiring and the problem goes away. Telling me "fine, don't use autowiring" is not an argument in favor of autowiring, is that also something you beg to disagree about, or can we align about basics of logic, at least?
&gt; Control-classes are where the work takes place. So any calculations, db-interactions, ... . Basically everything that's not output. NO. The controller accepts Input and convert that to commands to your Model or View. The controller is usually nothing more than a dispatcher.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I guess I don't know what else to say besides repeat myself. You're operating under the assumption that autowiring is a turn-key solution. It's not. Saying "that's not autowiring, it's manual" is facetious because there's no other way a container with autowiring could operate. You *have* to tell it how to resolve classes it can't figure out on its own. And again, the *only* way to stop programmers from doing things you don't want is code review. Removing autowiring offers no protection. All they have to do is manually instantiate the class and they can be stupid to their heart's content.
&gt; Saying "that's not autowiring, it's manual" is facetious because there's no other way a container with autowiring could operate. You have to tell it how to resolve classes it can't figure out on its own. Man, the misunderstanding between us so so big, it's becoming hilarious. I'm not saying that what autowiring does is *manual*. Seriously how can you read my comments and interpret it this way. Do you just read every second or third word? How does that work?! I'm saying that if you have to replace it with custom instantiation everywhere where autowiring *could screw things up*, in the numerous ways I already gave examples of, you'd have no place left that's autowired. And then you're basically not using autowiring at all. Because you're literally not using it. As in. Literally. Am I clear enough? I don't understand how to be more clear at this point. &gt; And again, the only way to stop programmers from doing things you don't want is code review. Removing autowiring offers no protection. All they have to do is manually instantiate the class and they can be stupid to their heart's content. You can't instantiate something in the module, because you don't know the settings for it often enough, or it relies on components whose settings you don't know. In the case of the database, It'll just crash during unit tests, where the database logins would be different. So it *does* offer protection. But unit tests can't detect when a component is basically reaching out and taking something from the container, that it shouldn't. Autowiring emulates all the drawbacks of service locators, while pretending it isn't a service locator. Protection is never absolute. You can use closure binding and reflection to read protected and private properties, as well. Does that mean... let's declare everything public! No. When intent is clear, and friction drives people towards the proper solution, this is invaluable, and it should be exercised, instead of allowing complete chaos. How does autowiring communicate intent? Its intent is "have everything I have, I don't care". So module writers just take on that offer.
[removed]
It's not abandonware; many of its flaws just can't be fixed because of backwards compatibility. I've looked into fixing numerous SPL bugs only to find out there would be a non-trivial BC break associated with them.
Nice troll.
I think I'll have to explain a couple of things to give you full insights into your own questions. [JSON](https://en.wikipedia.org/wiki/JSON) is a data format, [json_encode](http://php.net/manual/en/function.json-encode.php) is a PHP function that returns the JSON representation of what you give it. Ionic, will by default send and receive JSON data, and will know how to handle the format (this automatically answers question A). As `json_decode` already is a function that does the complete decoding for you it would be useless to create another function to call on every route. ~~You can do something like this instead ([source](http://stackoverflow.com/questions/28073480/how-to-access-a-json-request-body-of-a-post-request-in-slim)).~~ $app-&gt;post('/some/path', function () use ($app) { $json = $app-&gt;request-&gt;getBody(); $data = json_decode($json, true); // parse the JSON into an assoc. array // do other stuff }); ~~This will give you a full associative array representation of the POSTed JSON array.~~ You only need to do this once, and not for every field (answers question C). **Edit:** use the function mentioned below instead.
we tend to lose that when moving the website around: https://bugs.php.net/bug.php?id=63351 one can regenerate with doxygen using ext/spl/doxygen.cfg
Thanks! Very useful information.
I just took a look at the docs of version 3 of the Slim Framework and it's actually possible to get the array directly from $app $parsedBody = $request-&gt;getParsedBody(); $parsedBodyField = getParsedBodyParam('fieldname'); See: [http://www.slimframework.com/docs/objects/request.html#the-request-body](http://www.slimframework.com/docs/objects/request.html#the-request-body)
I'm working on a side-project and my initial goal was to execute user-submitted code and execute it in a secure sandbox with time and memory limits. Also I need to let user access some PHP API from that sandbox. And it had to be a general purpose language. So after various searches and attempts to use, and then fix/patch/rewrite existent solutions [php-v8](https://github.com/pinepain/php-v8) come up. I have to find some time between my office hours and pet project hours and my family to write more details and with more advanced examples and elaborate more on some internals of php-v8, but with a lack of such time I found no better way than start publishing at least reference to that extension so people start ask or look into and provide feedback. Potential use cases are numerous, if even considered to be countable. From simple evaluating business logic rules to headless browser written in PHP to crawl web and to node.js written in php. I would also like to hear how people can use this extension. I hope it will be useful for community. I also applied very permissive license - MIT, so potential use cases may not be limited with and open source solution only. 
FIG?
 $name = tempnam(__DIR__, 's'); file_put_contents($name, '&lt;?php sleep(5);'); include $name;
&gt; I'm saying that if you have to replace it with custom instantiation everywhere where autowiring could screw things up, in the numerous ways I already gave examples of, you'd have no place left that's autowired. What you've done is create a scenario where your own code is untrustworthy then extrapolated it everywhere else. You're essentially arguing if a car in a traffic jam is only as fast as walking then you should just walk everywhere. &gt;You can't instantiate something in the module, because you don't know the settings for it often enough, or it relies on components whose settings you don't know. How does this happen in a way that's less work than just doing code review of the constructor before commit? It's literally one line. &gt;But unit tests can't detect when a component is basically reaching out and taking something from the container, that it shouldn't. Autowiring emulates all the drawbacks of service locators, while pretending it isn't a service locator. I think the lines are being blurred here. The core problem you're dancing around is enforcing separation of concerns. Dependency injection as a pattern can't solve that either. Only programmers can do that which is why you have a scenario where one developer writes the controller and another writes the higher level application code that instantiates it. But that's ignoring the root issue which is developers that aren't getting the guidance and oversight they need to contribute proper code.
Is this the real life? Is this just fantasy?
It's hard to provide example of how to "sandbox the scripts properly" out of context. "Properly" may really depend on a what task is that. But normally you set time and memory limits in js (and optionally in PHP, but they are normally set to some sane values by default) and just execute code. Like in ["hello world" example](https://github.com/pinepain/php-v8#demo): $isolate = new \V8\Isolate(); // here you can set some isolate limits, like memory or time, e.g. $isolate-&gt;SetTimeLimit(10.5); // in seconds, float part means microseconds $isolate-&gt;SetMemoryLimit(1024 * 1024 * 20); // 20Mb, in bytes $context = new \V8\Context($isolate); // here you can pass various values, objects and functions to js runtime, modify existent objects or whatever else $source = new \V8\StringValue($isolate, "'Hello, World!'"); // here you can load source from file, e.g file_get_contents('some.js') $script = new \V8\Script($context, $source); $result = $script-&gt;Run($context); // result can be any of V8 value, either primitive or object. echo $result-&gt;ToString($context)-&gt;Value(), PHP_EOL; // for simplicity, we cast result to string and just echo it, but in real life you may even not rely on script result and get result in some function call or so Things get trickier when you need to integrate PHP API into js runtime. The rules of thumb, as always, not to trust to any user data at all. Potential resources breach may appear if you have some setter on an object which pass value from v8 right to php. This way "evil" user may bypass js memory limits and start bloating php by large string or object, depends on a task and setter. Though, if you have php memory limit set you are kinda safe. I'm thinking about tracking whole process memory (for now js memory limit track only memory used by js only) like in [node's quard](https://github.com/beest/resource-guard) module. But real impact of that and real cases are subject of further research. I have a php library that wraps php-v8 extension to provide automatic way of transforming and bindings of types and objects between php and js runtime which covers most of my current needs, but it is under heavy development and not yet ready to go to public.
It's real, you can try it by your own (if I get your message right).
A person who can manage servers and can make them secure (to an acceptable degree) alone is worth his weight in gold. And that guy sure as heck won't have time to add CSS to divs.
You can always find border, degenerate cases in any approach. That is not a true reflection of that approach though.
Nice, but where did you get all the information you needed to understand DB2 and the AS/400?
Or a developer the hard way. :P
Hi there, does one file stored in different folders uses the same cached content in Opcache? I mean whether file location affects Opcache or not?
Here's how some other folks are doing it: https://github.com/etsy/phan
How would this differ (other than being specific for PHP) compared to /r/forhire ? Splitting up jobs to several subreddits might make it more difficult to find jobs.
No escape from reality.
&gt; Source - http://www.geonames.org/ Given that the data is available under CC attribution license, where is the attribution?
Please no, I know this is very much a personal opinion but an interface or abstraction should contain that information in the name.
How is that information will help you at any point? When you see it in code you already know that it is an interface, because of *interface* or *implements* keywords. It also won't help you with autocomplete as it is a suffix. To me, it seems like this information is redundant. We don't have Function, Variable or Class suffixes, why a special case for Interfaces?
&gt; How is that information will help you at any point? Can you tell me at a glance of this directory structure, which one the interface is? /src SessionDriver.php DBSessionDriver.php FileSessionDriver.php You picked `SessionDriver.php` didn't you? WRONG. It's a base class. There are no interfaces here. How about this one? /src SessionDriverInterface.php DBSessionDriver.php FileSessionDriver.php &gt; why a special case for Interfaces? Because they carry special meaning in your code. They describe a contract, not an implementation. When scanning a list of files, I very much like to be able to parse out one or the other, especially when groking a codebase for the first time. It lets me get a basic picture of the architecture of the application without ever having to open a file.
In the same directory structure can you at glance say which file contains, classes, random collections of functions, configurations, traits, abstract classes, static classes.... So my question is basically: is that information necessary at the directory listing level, and is changing the name of classes is a best way of bringing such information in, instead of say a better directory structure...
I like the `Interface` suffix since it stands out in an out-of-context code review (in a github pull request for example). When using the suffix you can spot an error instantly: public function setFoo(FooBar $fooBar) Without the suffix you’d have to check whether `FooBar` is an interface or a concrete implementation.
If the library provides a set of functions, no, but the file names would not be called "DBSessionDriver" in that case, it would be called "db_session_helpers.php" or something similar. A CamelCased filename usually indicates a type, function files may of-course be CamelCased too, but in that case the filename wouldnt be so specific as "DBSessionDriver", instead similar to "DBSessionFunctions". Configuration files are almost always separated from the source, and a static class is not considered different from a normal class. Traits are named "SessionDriverTrait", just as interfaces, an abstract class would be "SessionDriverAbstract". Just to expand to the example /u/phpdevster compiled earlier, in case you need more concrete hands-on: /src /config db.yml (*bad example name, yes) file.yml (*bad example name, yes) SessionDriverInterface.php SessionDriverAbstract.php SessionDriverAwareTrait.php FileSessionDriver.php DBSessionDriver.php session_functions.php (wait wuuut?)
I meant that it will not help you to quickly find an interface if you don't remember exactly what it's called. Like if it was a prefix, you could start typing the prefix and see all available interfaces in the current scope. I'm not saying that suffixes make autocompletes harder, just that they don't have any additional advantages...
&gt; In the same directory structure can you at glance say which file contains, classes, random collections of functions, configurations, traits, abstract classes, static classes.... Sure. &gt; classes All of them starting with a capital letter &gt; random collection of functions N/A, I never used them &gt; configurations Whenever a file ends in `.yml` or `.xml` or whatever :) or starts with a lowercase. And is in `app` directory instead of `src` &gt; traits Has a `Trait` suffix &gt; abstract classes Has an `Abstract` prefix &gt; static classes N/A, I don’t think it’s a good idea to use those. Anyway, why would you need to distinctly recognize them?
http://www.unixguide.net/network/socketfaq/1.3.shtml http://php.net/manual/en/intro.sockets.php Does that help?
aka: let's make everybody write `use Namespace\Section\Name as NameInterface;`
Generally, there might be copy-paste and literally anything else, so you have to check the whole commit normally, rather than some distinct part of it completely separately.
Not really, no.. The first link explains it well enough, but the documentation may as well be hieroglyphs.
Thanks, fixed now: http://svn.php.net/viewvc?view=revision&amp;revision=339985
&gt; You picked SessionDriver.php didn't you? WRONG. It's a base class. What is the practical difference between a base class and an interface to the consumer? In other words, if I type hint SessionDriver, why would I care if it's a base class or an interface? It abstracts a concept, I can substitute implementations. Might as well be an interface.
I can't understand what means "ok" or "not ok" in your example. What exactly are you looking for? Are you mechanically checking that everything depends on interfaces? Is this the most common and most important error you have to fix during code review? I don't understand where you're coming from.
not an error, but a code smell maybe, or something to look more into: shouldn’t this method rather expect an interface instead of a concrete implementation? I expanded on this [elsewhere in this thread](https://www.reddit.com/r/PHP/comments/518drb/phpfig_vote_remove_the_interface_suffix_in_future/d7a51ag)
This mentality encourages creating interfaces where none are needed. It's a self-fulfilling prophecy: distinct names require creating interfaces from the start, and then you look for the distinct names... If interfaces didn't come with suffix "Interface", then you could start with a single class, say "FooService", and typehint for that. Then the moment you need a second implementation, it'll be trivial to refactor it so "FooService" is an interface, and the default implementation is, say, "DefaultFooService", without breaking any of the code that typehints "FooService". It's worth thinking about that for a second, before you reject it.
I agree with your arguments, it’s definitely something to think about. Can you expand on why you think the interface isn’t needed? In either case it exists, the only difference is if it’s explicit or implicit. Is there anything wrong in choosing to be explicit most of the times? I feel like this is something your company’s culture needs to shape.
&gt; So if the suffix is not relevant for typehints It is relevant to typehints, since you (the consumer of a 3rd part library) would want to use an interface there — if given choice — instead of an abstract or a concrete class, to allow the most liberty when providing the dependency. &gt; It doesn't matter. I get an instance of it and I use it. Yes, but you don’t want to narrow it down too much and require a specific base class, you only need to enforce the interface. And since it doesn’t matter to you, but could matter to the implementations, it’s best to restrict as little as possible and go for the interface. 
Open your eyes, Look up to the skies and see.
Sockets are a way of 2 computers talking to each other. A socket can either be a UNIX socket unix:// or a TCP port tcp:// (both have adv and disadv). Without going into much detailed code (the docs have plenty of examples ie. https://secure.php.net/manual/en/sockets.examples.php), you will need at least 2 scripts: one to be the server and one to be the client. The server opens a socket and waits (or listens) on that socket until a client connects to it, sends commands/text, waits for output and disconnects.
So now I know the second thing to find in file for, but I've never seen that used, I always run into ones that look just like OP's 
What exactly point are you trying to prove? Because it's not very clear. If the type was named "SessionDriverInterface" would you have an eureka moment and type this instead: class DBSessionDriver implements SessionDriverInterface {} It'd still crash, unless it's a marker interface with no methods... You can't extend/implement anything without reading some details about it. The name alone won't help you.
Could I make the server/client on the same page?
I'm just a poor boy, I need no sympathy
Looks great, I can definitely think of a few uses for this, but I'd want to see the project more mature/stable before I used it for anything important - gets my upvote and star though!
You are right. Java, though, more or less forces you into an OOP mindset.
Interesting discussion going. I personally think a good argument for keeping the suffix is that it's easier for new team members to jump in and understand what's going on in your code base by understanding what the typehints mean at a glance. Sure you could instantly check by using ctrl+b in say phpstorm, but I mean being able to see it at a glance without having to even ask that question is a no-brainer. I also don't care if it's the suffix 'Interface' (`MyClassInterface`) or Prefix 'I' (C# ex.: `IMyClass`) as long as it's consistent throughout your codebase as well.
The consumer isn't the issue here. It's the developer's ability to glance at the file structure and understand what's going on. If they need to build their own session driver, the difference between a base class and and interface is substantial. When I look through a list of files and see an interface, but no apparent base class, I know the intended design is flat - no inheritance, no having to grok the responsibility split between a parent and a child. An apparent base class with no interface means something else entirely. The suffix ads clarity to the design of the code when looking through its src files.
Assuming there is or isn't an interface just by looking at the file structure is kinda dangerous anyway, don't you think? Like, drivers could instead use inheritance. So you'll need to open the code anyway to see in what way it's implemented. And once in the code you'll see whether there is an interface and where it's located.
it's just that the FIG is defining interfaces, not implementations, so these files from your example should probably not even live in the same directory.
CamelCase is the general convention. Personally, I like doing a combination of both. CamelCase for Class, method and function names; snake case for variables and properties. Constants get snake case too because I generally put them in all caps.
Hi, you're right it's more a simple guide than a complete guide :) I'm sure the author meant "complete" because the tutorial has all the steps a beginner needs to know to get Elasticsearch working.
So basically you created yet another template engine. 
&gt;I'm not the author &gt;I changed it What the fuck?
the name of the file is different, so it has other cache. you could try to play with opcache.use_cwd, and turn it off. but it is risky
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
How can you come into this thread, write messages like this, and try to seriously convince us you're not the author? How stupid do you think we are? You even used your real name in your handle...
These sorts of debates have existed since the dawn of time and will continue till the heat death of the universe. All three currently published applicable fig standards use the Interface suffix. As do almost all (if not all) of the major components and frameworks out there. So, like a college football replay, it is up to the anti-Suffixes to provide indisputable evidence that using the Interface suffix actually causes harm.
&gt; an interface or abstraction should contain that information in the name. Let me reuse the words of my 3 year daughter: Why?
Good thing everyone uses PHPStorm. Oh wait.
Something similar I did a year ago, with exports as JSON, CSV and MySQL, and data for airports, cities, countries, regions, timezones, etc.: https://github.com/delight-im/FreeGeoDB
Don't know if it was mentioned in the FIG discussion, but I recommend reading http://verraes.net/2013/09/sensible-interfaces/
I would be curious to know from where this difference comes from, and more importantly how the difference is so big for your code base. I do have a little difference, but it's only 5% slower in xdebug...
The difference between complete and basic is just a matter of expertise. 
&gt; I never used Interface suffix before even when it was already a part of the PSR standards, [so I wont use it anyway no matter what FIG decides](https://www.youtube.com/watch?v=vbmNquz89U4).
 class FooBarInterface { // screw you reviewer! }
if you are talking a web page, no. if you are talking a script then yes. The problem with sockets and web pages are the server listening is a constant process, a web page is just a quick execution run. Sockets are usually a backend services like an irc server, queue processor or something like that. The client could easily go on a web page because they are just connect-do-something-disconnect (like a web page).
Start by trying to get a good grasp of the data layer. Having a solid understanding of the database structure will give you a better idea of what's going on in the spaghetti code. Once you've done that move to the UI and work your way back.
I usually just scrap it and start over... there is a point where trying to maintain legacy code is more of a waste of resources than starting over. I guess every project is different, and depending on the size and scale of the project that threshold is different. In every situation I've always pushed the client and explained how they are throwing money away now by wasting programmers time to maintain a horrible mess, and how it will ultimately cost more to maintain the legacy code.
rekt.
Are you trying to use PHP as a purely functional language? I honestly don't really understand your questions.
That is difficult to support. Using the given country/countryId example from the article, what happens when countryId is finally removed after being deprecated? The old API would need to be updated (internally) to support the new field, so that the external API doesn't change. That might be a simple example, but I'm sure it paints the picture of the cascading changes required to support old APIs. Unit tests would need to be curated for each version. Using semvar would help a lot. I'm writing this and thinking about Ebay's API. They have a rolling 2-week release schedule for the API. It isn't semvar, but they allow you to target a specific version of said API (to a point, I'm sure).
Great article. Are you planning a series?
Get [Vagrant](https://www.vagrantup.com/) and [VirtualBox](https://www.virtualbox.org/wiki/Downloads). [PuPHPet](https://puphpet.com/) will allow you to build your own boxes pretty easily and tailor them to your production environment. [Homestead](https://laravel.com/docs/5.3/homestead) is a pretty good general-purpose box. Other tools I've heard about around here - but haven't tried yet - are [Docker](https://www.docker.com/) and [Ansible](https://www.ansible.com/)
Scrap it and start over is compelling... the great big rewrite in the sky.... and it might work, for small enough problems, where the feature set is easily understood. For larger systems it's fraught with problems. You end up maintaining and adding new features to the legacy while the new system comes up along side it. Rewrite projects nearly never land on time, and your rewrite starts to suffer the same sorts of time pressures that got you into the legacy mess in the first place. For my taste, there are 2 circumstances where a rewrite is advisable. Either the problem is simple enough to describe and understand that you can reason about the system in it's entirety up front, or the rewrite is actually a "replace with a new piece of software that operates in the same domain but does things entirely differently, with a whole new feature set", at which point it's a new project and you avoid the need to get like-for-like behaviour between the old and new.
&gt; I usually just scrap it and start over... there is a point where trying to maintain legacy code is more of a waste of resources than starting over. This entire team is new - this can't be a viable option. If it some programmers were more familiar with the site and the subtleties of the domain then maybe. But with everyone being completely new with no documentation... you would have to gather all the specs from scratch and probably lose customers when you break something.
+ Typo at "replace $customer-&gt;firstName by $product-&gt;firstname". Took me some time to understand why you were able to replace customer with product + The "No one want's to know your secrets" part is something I care about deeply, too. But it was not really written clear enough, IMHO. Maybe starting off with something like *"Use established standards as far as possible! Country codes, date formats, time zone codes, Airport codes etc. Use common tables for identifiers, don't invent your own."* would make it clearer for readers like me. Nice write up! Felt more like a rant rather than instructions on how to write a good API, but I enjoyed the read!
So much for pick a convention and stick to it.
&gt; the data as it's modeled in a database with how it's rendered to the client - REST discourages that behavior so that the same data can be represented in different ways. The other criticisms of REST are similarly criticisms of poor software design and poor API design. Thanks for the feedback. To the typo: It was late yesterday :-) I corrected that. About the clearness of "No one wants to know your secrets": You're right, I think I'm gonna rewrite that part. Thanks, David
There's some solid advice on naming implementations but I don't see much of a cohesive idea on why the Interface suffix itself is bad. The only argument seems to be that it forces better implementation naming but then it immediately undercuts that with examples of bad naming schemes (e.g. ```DefaultTranslator```).
Thanks for your feedback. I'm trying to edit my article and to make that Doctrine thing clear :)
Not sure I follow. He's indeed saying that DefaultTranslator is a bad name and I would agree. It's also something I've seen in code. Why is it a bad example? 
At some point you might have to drop support for old API versions but I think more of a cycle of years rather than days. Currently for our API, we provide unit tests for each version to ensure that it keeps working. Of course this might become hard, if you have 200 versions :) We maintain a connector to the eBay API that was written about 2011 I think and I'm pretty sure it still works with the API version we hooked on then, which I'm perfectly fine with. And if that version gets deprecated in 5 years from now, it's also okay for me. But I should make that clear in the article. Thanks for your feedback.
We all feel stupid once in a while, it's part of the job, don't sweat it. If you got a bunch of functions of data that belongs together because they're all related to the same type of entity you could move them into a class. I'm not completely sure what you're trying to achieve, but if all you're doing is taking some files and zipping them, looking into MVC and other organizational patterns might be overengineering it. Try to keep it as simple as possible, list up the exact steps you have to do (find files, check for existence, create token, add to zip files, etc) and sketch it out starting with one function per step. Keep it simple, focus on your actual goal and forget about everything else until you need it. Don't overengineer. And don't worry too much about feeling stupid or like you're totally not cut out for this. We all have that, it's so common that it has a name :-)
I'm honestly more curious about how you only have 5% difference when comparing running code with phpdbg without xdebug enabled to running code with xdebug enabled. My own experience is that xdebug itself already adds a considerable overhead to running code. Using code coverage features even more so. For a simple example, look at the builds of one of my libraries: https://travis-ci.org/Riimu/Kit-PHPEncoder/builds/129680541 Notice that the build using 5.6 is generating code coverage with xdebug. The tests run in 5.97 seconds. The 7.0 build, however, is using phpdbg without xdebug enabled and the tests run in 346 ms. Of course, 7.0 is already faster than 5.6, but that alone simply does not account for the fact that the tests are 1700% slower in the older version. This is only a small library with few fast tests, but I'm seeing very similar results in bigger projects as well.
Haha yeah, this is exactly what this is about. Instead of being implicit in the file/class name, we do double the work and use aliases instead.
Many good points. You don't even need to have an external API to see these issues. I've seen single page applications written in ExtJS and Angular having very similar issues with their backends. Developers tend to be even more careless when the only intended consumer for the backend API is the frontend application. One additional common dangerous practice I've seen is trusting the user input too much. Image if you'd have an API call as follows: function update($data) { $entity = $this-&gt;repository-&gt;find($data['id']); $entity-&gt;update($data); $this-&gt;repository-&gt;save($entity); } In other words, an API endpoint that updates entity data based on provided user input. Not only do you create yet another dependency between the database structure and API, but imagine what happens when you're updating data for a User entity and the user happens to have a field called `super_admin`. I have actually encountered this more than once in production applications. (And this is forgetting the fact that like in the example, most applications tend to forget to also validate if the end user is even allowed to update the specific entity) With modern JS applications, I've seen too much reliance on the front end validation and completely forgetting the validation in the backend. Just because it isn't available in UI, doesn't mean one can't forge the requests themselves.
Your first example is the result of bad devs. At first you have a SessionDriver class. No need for anything more: you typehint against SessionDriver because that's what you need. As you don't know if you'll ever need multiple ways to handle sessions why bother? YAGNI. Once you decide to have more than one implementation you refactor and move your concrete class to its implementation class and make the SessionDriver class a simple interface. You don't have to change any other part of your code. A change to create more flexibility in some of your architecture should not impact other parts: it would mean you have too much coupling.
 $egypt = (new Country)-&gt;find('EG'); Is there a reason for this (in my eyes) strange syntax? Why not have it as a static method: $egypt = Country::find('EG');
You use "simple" and "lightweight" alright, but where's "modern"?
&gt; It sounds like to me you've had too much object-oriented kool-aid. This made me LOL!
[removed]
https://raw.githubusercontent.com/rinvex/country/master/resources/data/countries.json It appears to be just parsing it from a massive json file... 
It should be stated like that. "... for all 249 countries covered by ISO 3166-1 alpha-2" OP: Could you clarify that?
Doesn't make any sense. The data gets loaded and parsed on each construct as well, so it makes even less sense.
Some hopefully useful feedback: - The model is a *layer*. You have a customer *entity* within your model - As soon as you use Customer::getById() within your entity you've moved to active record and given your entity the responsibility of retrieving data for itself - Your entity shouldn't be responsible for formatting itself so it can be presented to the client - this is for a layer further up - Wants doesn't have an apostrophe (want's) ;-) - Your toArray() method - you shouldn't be able to initialise a Customer in an invalid state. It will *always* have an ID if you follow this rule
As far as I understood it, both versions are perfectly fine syntax-wise. But since "just forget about them" seems to be a lot easier and less prone to mistakes, than having additional loops checking for validity, people just prefer the easy route. 
Nice catch, thanks :)
OK, but as long as you've an object already instantiated that never called again in the same request. That's the simple reason behind. Let's say you're manipulating multiple countries for at the same time: $country = new Country(); $egypt = $country-&gt;find('EG'); $japan = $country-&gt;find('JP'); That's the case where the current syntax may be useful, otherwise I'd like to make it just a static call. Maybe you can suggest some solutions?
If they have access to eg. a gitlab server, you can set up your own docker hub on gitlab, or set up a completely stand-alone docker hub and build the image and upload it to your hub directory.
You could use legacy code together with Symfony, making all the new features with Symfony and leave the legacy be. Here is an example how to make it happen https://github.com/cvuorinen/symfony-legacy-example 
That's pretty much appreciated benchmark, caching and/or separating country data into individual files is considered now for next update. I've only one concern: if country data being separated into individual files per country, that would be great for single country calls, but may be it would be bad decision if we're calling all countries as a list, right? (reading 250 files this time) Another suggestion is to supply another light version of `countries.json` that include only the most used attributes, so it would be light on memory, and doesn't affect performance that much. And when needed, single countries may be called later with full details included.. I guess that's better, don't you think?
Hi OP. Thank you for the effort and time you've put into developing this, I bet it will be helpful for many people! However I'd like to put attention to a Unicode standard that exists in this field. The Unicode Consortium maintains a CLDR - [Common Locale Data Repository](http://cldr.unicode.org/). CLDR is a comprehensive data package that contains ALL the unicode information (numbers, calendars, currencies, phones, countries, languages including formatting data in different locales as well as plural support) including translations to all languages and it's used by almost all the operating systems, and many many frameworks and libraries ([source](http://cldr.unicode.org/#TOC-Who-uses-CLDR-)). However CLDR is just data, you need some library to work with the data. I do not work with CLDR in PHP (I do in javascript) however from a quick google search I've found at least two, looks like solid, libraries that works with CLDR: [Punic](https://punic.github.io/) and [ICanBoogie/CLDR](https://github.com/ICanBoogie/CLDR). I only post this to advocate usage of proved, popular and maintained libraries and hopefully avoiding [xkcd/927](https://xkcd.com/927/). However those who might need a simpler solution, without any translations or locale supports - I bet your library will be useful for them!
I don't follow your logic here: &gt; Unlike objects, PHP returns arrays as copies by default. However, if an immutable object property is an array, mutable objects in that array compromise the parent object’s immutability [...] Especially avoid arrays as properties; use only with extreme caution and care. Can't you just say "avoid mutable objects as properties, including as nested properties in arrays and immutable objects you hold as properties". Arrays are not the problem. Objects are also not the problem, as long as they're not mutable (recursively). Arrays are too valuable to throw away as internal state, they're basically our only sane way to encode a set/list/map/collection of any kind.
FAIL: method called that is not defined in interface on line 483 of file [...].
Nice idea, just a shame it requires mongo when flatfile would've been more than sufficient.
Add a keyboard shortcut or change of keyboard, there's no way we are gonna break 80% of the websites just because of someone complaining of a shift+4 combination. Alternatively just change of language.
Haha, gook luck convincing anyone!
If you want to deep copy objects you can always use https://github.com/myclabs/DeepCopy. And it will eventually help you to point out where you need mutability.
Hence, the "optional" part =)
I wanted a REST solution. `var_export` gives out data in valid PHP code.
As if we already don't have enough problem with the tab vs space and interface suffix, you want to add something optional besides that? You actually enjoy creating mess are you not?
This. We already can't distinguish functions and classes (hence `use function`). Variables are even harder because they are not declared and used in constant/function position.
I sometimes write javascript with all local variables prefixed with $ it is beautiful and there is nothing you can do to stop me.
If you enjoy having tens different ways to declare the same thing, pick JavaScript not PHP. We already have enough problems with tabs vs. spaces, indentation, camelcase or snake case or pascal case and so.
 "I don't like this language, let's change it" Rather than, i don't like this, i'll stop using it. Just migrate to Rails, or something else... For me (and i'm not really developing in PHP that much lately) it's nice to be able to view variables easily.
I don't think it's a good idea because I doubt the pros outweigh the cons. This involves a lot of work in the Zend engine to add this functionality AND keep PHP backwards compatible at a certain level. To be honest, I don't see any problems in typing Shift + 4 a few times in a row. While programming I make use of the Shift key a lot: @ ! % ^ &amp; * ( ) { } | &lt; &gt; : " ~ + _ are all characters I can't type without using the shift key.
&gt; I ~~sometimes~~ ALWAYS write javascript with all local variables prefixed with $ it is beautiful and there is nothing you can do to stop me. FTFY ;)
Because it enhances readability, and being able to read your code later is far more productive than anything you could save by taking less time to write it.
That's hilarious considering the euro has been the far more unstable currency in recent years, and may very well collapse in the not-too-distant future, while the dollar is the world's undisputed safe haven currency.
I guess I just have to take the role of the Sauron of the PHP world
&gt; This involves a lot of work in the Zend engine to add this functionality AND keep PHP backwards compatible at a certain level. If we have to get technical, it wouldn't take a lot of work. It'd take three distinct steps: 1. Make all identifiers case-sensitive. Common coding conventions ensure breaks here will be rare. 2. Put identifiers in shared symbol tables (instead of one for vars, one for constants, one for functions, one for classes/traits/interfaces). Case-sensitivity and common coding conventions ensure collisions will be rare. 3. Resolve against the shared table, whether there's $ or not in front. But...who cares, I guess.
I spared a company millions in operation costs by moving them away from eZpublish. It needed a whole cluster of front-end servers to serve 1M+ pageviews/day.
We're still talking about semantics aren't we? Because while I agree that versioning in bigger projects might deviate from the norm, it is still a necessity to throw away smth or introduce BCs at some point. And that point should be nothing else but a major version.
Why? I love reading PHP code. I can spot variables so easily.
With an [azerty keyboard](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b9/KB_France.svg/522px-KB_France.svg.png) it's fine :)
Good point, I'll update this CVE on next April 1st so it also reflects the fact that the dollar is a single point of failure.
I love my $.
Thanks for your input. I will fix the typo, regarding toArray() -&gt; this is stuff I keep seeing in many applications, but as described in the text this is an example to point out that this is the wrong way, especially if you want to expose different views on the same object for different purposes (e.g. a public API) and it simple does not belong to the model :)
Not sure how simple you're thinking. How about: - A photo gallery - A shopping cart - A blog Do any of these sound appealing?
What I've done when dealing with a huge JSON, (or actually, initially a VDF: Valve Data Format), is: * Cronjob every day that does: * get the VDF (sort of like YAML but just a tad different) * convert it to a JSON string * `json_decode` the JSON string to arrays * `fopen()` a file (countries.php) * `fwrite()` to the file: `fwrite($f, "&lt;?php return " . var_export($jsonArray) . ";");` * Use it as `$countries = include(__DIR__ . "/countries.php");` The PHP file is about 15% larger in size, but it's over three hundred times faster to process than going through the JSON every time.
&gt; If I'm reading it correctly this could open you up to code injection. If you're fully in control of the source file the risks should be manageable, if not you're playing with fire. It's possible, but very unlikely. The VDF provided is on an official Valve URL. If the converter fails in anyway, it throws an exception. The converter doesn't do any eval'ing. &gt; What are you using to read the VDF and converting it to JSON? I'm curious about what seemingly is a superfluous step. I'm not sure. Was just a simple function I found somewhere. Hold on. edit: https://github.com/rossengeorgiev/vdf-parser/blob/master/vdf.php And then just the `vdf_decode` function.
&gt; The VDF provided is on an official Valve URL Okay, now I'm really curious. What's that contain?
This is an older URL, but still works: https://steamcdn-a.akamaihd.net/apps/730/scripts/items/items_game.51d2ccf27a2adfc3bca508320f5de6eba1241688.txt It contains information about weapons in Counter-Strike: Global Offensive ('items'), but also statistics on professional CS:GO players during official Valve sponsored events. Stuff I need starts at string "`"pro_players"`"
Looks good, although I would suggest using a more specific namespace, because since *Math* is a pretty general thing to do, there might be high probability of collisions with other packages in one project.
This is where the factory pattern would be very useful. Factory contains knowledge of the data, and then constructs a new Country object from the appropriate parts of that data object. $country = CountryFactory::makeFromCountryCode('US'); Then the factory can load the data once and utilize whatever caching mechanisms it needs to improve performance.
Major versions CAN introduce breaking changes, but not SHOULD. This doesn't bring any performance or (significant) convenience improvements, while makes incompatible most of the code written before. Such "improvement" is dead on the arrival.
I would really like it if the downvoters explained why they're trying to hide a generic, neutral discussion about something.
Ohh I see, I wasn't thinking of a scenario where a user could upload pictures but thanks for clarifiying!
Just don't even try to refactor your legacy app without any real resources. It's risky and usually not rewardable. There is no solution for old legacy app. Your app has unresolvable technical debt. Actually your project is bancrupt. Best thing you can do is implementing new features as slow as it possible to force project owner to kill and rewrite the project and hope you're no going to be eaten by second system syndrom.
Do you think so? The namespace could certainly be changed to MathPHP instead of Math. It would be great if it were the case that there were so many PHP Math libraries that namespace issues were a problem =). I'll take it into consideration. Thanks for the feedback.
minor point here - but in phpstorm and, I belive in Sublime too, the autocomplete feature picks up if I'm using an existing variable name and prefixes the $ automatically. I'm usually not hitting $ as frequently as 3 time in each line.
Had a quick flick through on my mobile at the readme and it looks like you've put a lot of work into this, it looks very well done, I'll take a proper look when I'm home :) 
Good point, but isn't there an alternative variable variable syntax? I'm pretty sure there is a function for the same functionality.
You're welcome. Not only will you become PSR-4 compliant (if you're into that sort of thing), but an end-user of your library can use a different vendor's library called math without any conflict.
Don't forget, renaming an argument in the signature, renames it in the DocBlock.
Wow very extensive, may solve me a lot of tedious code I write! thank you
yeah well you know, sometimes this is not enough :)
&gt;it is still a necessity to throw away smth or introduce BCs at some point When you need to yeah. But this kind of change (the $ sign) has absolutely no value, besides being controversial I think it will only cause problems. It would only be good for some people with the NIL syndrome and like to rewrite existing projects who don't like this $ sign.
&gt; // Basic matrix elements (zero-based indexing) The horror!
But then doesn't need illuminate/support! :S
eval() ? ;)
Immutable Streams? Seriously? Streams are immutable by definition and suspect to unrecoverable side effects. If your domain models depend on that you can also s/quote/rot13/.
I did state quite clearly it really depends on the size of the project. OP hasn't mentioned how big this existing project is. Are we talking 10+ million lines of code (which if it's legacy and custom is probably a procedural nightmare)? If it is really large, sometimes things can be compartmentalized and replaced piece by piece, suppose that depends on how the current system is structured. Are we talking about a site laid out as a bunch of .php files in the top level directory, each implementing their own session functions, or is there at least some level of "libraries" (I use this term loosely) of functions included throughout? Is it written with a single access point (a la mod_rewrite) where the libraries are loaded and then initialized? Is everything exposed in the global scope, is there any level of classes or even namespacing? You need to start with basic, lower level things, like DB interface, configuration, sessions, user accounts, etc then work your way out from there.
So, let me rephrase to make sure I understand you correctly "an interface or abstraction should contain that information in the name." because "It's not a class". Thank you very much to make that point clear.
This is a very common way to do it, for example: - [C++ Boost](http://www.boost.org/doc/libs/1_61_0/libs/numeric/ublas/doc/matrix.html#1Matrix) - [Apache Commons Math](http://commons.apache.org/proper/commons-math/apidocs/org/apache/commons/math4/linear/RealMatrix.html) - [Math.NET Numerics] (http://numerics.mathdotnet.com/Matrix.html) - [C++ Eigen](http://eigen.tuxfamily.org/dox/group__TutorialMatrixClass.html)
There is something else wrong if those JSON files are timing out. I recreated your data in a large JSON file and it loaded fine, although relatively slowly in about 800ms. Are you saying the JSON decode took over 30s? And like I said earlier, with a country JSON you are running `json_decode` on the **exact same string** that your API is returning. You might have some file read problems on your system. &gt; cache file -&gt; array in client application. No, you would load the cache file in the API microservice. That's how this is set up, it's a REST API, not a PHP component loaded in the client PHP application, so it would be: cache file -&gt; array in PHP microservice -&gt; JSON result of API call -&gt; array in client application. And again, you would do the same exact `json_decode`.
&gt; **protected** $bar; I saw this inappropriate visibility on many different other places. Where does this habbit come from?
It's simply noise. You don't use the suffix "Class", do you? There is zero benefit for clients, knowing whether a type is an interface, a class or an abstract class. Please prove me wrong on this. You want one harm? DDD is currently sexy. It will bite you there: The domain experts will not give you anything with the suffix "Interface" for the ubiqitous language. A second harm: Now you suddenly realize that you need to refactor a class to an interface (or vice versa). You can only hope your test suite will protect you from any missed renaming.
No worries dude!
would have thought php db2 library would be able to connect, but not sure how complete it is. Spent some time in 2013 with some files the library read and it seemed like there were field types missing from the ERP data-source we spent time attempting to reverse. There are lots of PITA setups like this where if I'm honest; other technologies or methodologies make more sense than PHP
I would add that I would use Value Objects and streams by having the immutable object only hold a string representation of the pointer to the stream when possible. An example would be a class called BlahDomainBlahFilePath that would contain the path to the file in a private string and not the actual file stream/resource. BlahDomainBlahFilePath would be responsible for holding the value and validating that it is indeed a valid filename (and maybe if the file exists -- I would think about that some more).
It's not the correct way to do it. And those examples do not show that it's a very common way to do it either way. Regardless, I was making a joke. Working with matrices and having a one based index is key to accuracy and notation. This is one reason among many that the language R is becoming more popular each year. Anyways, I don't expect you to change your mind or the code.
One-based indexing would certainly be more in line with mathematical notation, and from a user perspective it may make more sense. I wonder if the zero-based indexing is merely a convention followed because the languages themselves use zero-based indexing. The interaction then between language arrays etc. and Matrixes classes may be easier to work with if the indexing is the same. I'll give it some thought and do some research into this. If one-based indexing for Matrices is clearly better then there is a case to be made to refactor now while it is still under development.
Came here to say this. What is that even returning? a `Country` object? then what is `new Country`? A country-less country? Doesn't make the tiniest bit of sense.
A TODO app.
The POST goes directly to the payment provider - meaning the shop never gets in contact with any payment data. None of the common methods need any additional/specific PCI-DSS verification or anything like that.
In R, it seems like the c() function, list(), data.frame(), etc. all create objects that are one-based indexed. So the Matrix fits in with this scheme. It seems like consistency with the rest of the language was probably a more important factor than mathematical syntactic correctness when these other libraries (C++, Java, C#, etc.) chose to use zero-based indexing for their Math data structures.
I've spent a bit of time in PHP (13 years) and never once thought "i wish I could stop typing $". I've also programmed in MANY other languages and to this day, I find PHP easier to read/distinguish. If we're going to add anything into the core, it should be strict typing, but I know why that isn't happening.
make it final :p
To be fair, fuck `$$`. Tracing the source of a bug when `$$` is being used can be horrendous. Friends don't let friends `$$`. 
This is how I've done it. It makes it a heck of a lot easier when there's some mashup of the two in the same file for some reason.
Yeah, exactly, the `(new Country)-&gt;` syntax doesn't make sense.
If you are just using collections you can switch to tightenco/collect. Or just use arrays, they aren't that bad :D
You can create a MiddlewareProvider and unit test that the provider attaches middleware to specific routes. Then you can mock or prophecize the router and assert that an instance of a middleware is added to your desired routes.
Sooooooo... It's Cookiecutter for PHP?
I would look out for providers who have an Omnipay adapter. They are still not 100% interchangeable but having a somewhat standardized API is a good start.
Yeah, that guy is also somewhat known in the PHP world.
"Ketch was inspired by khaos for node."
Sorry but this has gotta hit the top spot for 'worst php idea ever'.
man you can write all the namespace and all the objects! And then you can even send a postcard! why just use a command on the command line.
I believe the license is dumb. like you are trying to be funny or original but no. 
Aside, you don't have to instantiate a PurchaseManager, you can get the classname using `PurchaseManager::class` instead of `get_class($instance)`.
I just see the MIT license. Was it changed? **EDIT**: Oh, the README adds "postcardware". That's third time I see a PHP package like this in the last month or so. Apparently postcards are trendy.
&gt; Postcardware &gt; You're free to use this package (it's MIT-licensed), but if it makes it to your production environment you are required to send us a postcard from your hometown, mentioning which of our package(s) you are using. &gt; Our address is: Spatie, Samberstraat 69D, 2060 Antwerp, Belgium. &gt; The best postcards will get published on the open source page on our website.
Because there is more than one way to do it. Believe me, this wrapper's existence doesn't deprive you from the command line way in any way. It just adds another possibility for anyone who wants it. If you personally don't find it useful - just move on. A good wrapper is always a good thing. For example, there is PHP a curl extension with these CURLOPTs all around. And there is Guzzle for anyone who wants to write a sane code. For the life of me I won't understand why this sub is so hostile to any new open source contribution. Wonder if any of you who is voting this post down ever contributed a line of code.
Probably. I'm noticing also the packages in question are quite useless.
hi dad
&gt; The things you list would probably take multiple work-years to do just for PHP core, and then would take a lot of time for extensions and all PHP userland libraries. I did refer to the work of figuring out the conceptual changes that have to be made to obtain this feature, while also preserving BC for most of the existing code (so we don't end up with a Python 2 vs. Python 3 situation). PHP 7 is an example of this kind of evolution. Indeed PHP 7 was *a lot* of work on the core, and extensions, but conceptually it was a very clean upgrade and it didn't introduce any serious BC breaks for people's PHP5 code. PHP 7 also made changes in the Zend API to make under-the-hood changes more encapsulated in the future. And both you and I know that changes to the core and breaking extensions will likely continue with PHP 8. JIT is coming, and other features are coming. Extensions will get broken. So *in theory* one could sneak also changes I listed, and not do much more additional damage to BC breaks than are already needed for PHP to evolve. But again, this is all just brainstorming. I don't mind typing the damn dollars :-)
From time to time turn the troll mode off. It helps. Your rant here is irrelevant to the topic. If you find this wrapper bad - then criticize its particular drawbacks. If you have no idea whether i's good or bad - just move on. If you are trying to sell the idea that using third-party wrappers and libraries is bad in general - well, turn the troll mode off. 
Not that this matters realistically, but just a thought exercise: shouldn't this be mentioned in the license itself, instead of in a separate section? And can it be still called MIT-licensed with that requirement?
Does it need anything server-side? Like multi-player support or global score boards? If not then you'd be set with just Javascript on the client side. If so then I'd still suggest you to make the fun part using Javascript first. When you get to the point where you really need server-side features then yes, you can choose PHP for building API's. Should you? Well chances are you may want to use websockets for real-time interactions, and in this case some other languages may suit your needs better. But then again come up with a more precise requirement, it'll be easier to make a choice.
I think the emphasis should be on *If you don't want me to call it boolean don't do it yourself*. It might have caused less confusion if the error message actually said *bool given*.
&gt; PHP is a good choice because you can host it pretty much everywhere. For a website, maybe. This isn't true once you need real-time communication using, for example, WebSocket.
&gt; Value types are "locally" mutable, and passed by copy (i.e. by value, which is natural enough for a value), like PHP arrays. Maybe I'm missing the point of Immutability then, because doesn't this achieve the end result that people want? The way I see immutability, it's not that I don't want my objects to ever change (If I have an object that doesn't change, I just don't add setters), but that I don't want *other things* to change my variables. I don't want to pass my variable off to a function and not have my copy of it change without me explicitly saying that it's allowed to. Am I missing the point of immutability?
&gt; Am I missing the point of immutability? You're not, it's rather that *one* of the points of immutability is "no spooky action from distance", but immutability is not the only means to that end. Another means to that end is mutable values that are passed by copy (which internally can be copy-on-write, like PHP arrays are). Mutable values with local mutability are more efficient and comfortable to work with. Immutable objects become a pain as soon as you start dealing with collections, or even worse, nested collections. In PHP, you can locally mutate an array value like this: $a['b']['c']['d'] = 123; With an immutable object (that here implements ArrayAccess for brevity) this would look like: $c = $a['b']['c']-&gt;withItem('d', 123); $b = $a['b']-&gt;withItem('c', $c); $a = $a-&gt;withItem('b', $b); A joke I've heard about this problem went like this "with immutability, when you want to turn up the thermostat in your house, you need to destroy the whole house and replace it with another house where the thermostat has a higher value". If we can ensure collection access is uniform across all immutable collection objects, it can be possible to do this: $a = $a-&gt;withItem(['b', 'c', 'd'], 123); But that's still not as natural as mutable collections. It's still good to differentiate truly immutable values from "locally mutable" ones, because immutable values have other interesting properties, say there's literally no difference for immutables whether you pass by "reference" or by "copy", as the value never changes. This allows interesting optimizations.
Im planning to build cyvasse, its the Board Game mentioned a lot in the books of game of thrones (A Song of Ice and Fire). Thanks for the reply!
If I were to build a game like you describe, I would first decide whether or not any data needs to be persisted (high scores, player profiles, undo/redo, etc). If the answer to that is yes, then you certainly would want to use PHP (or other server-side language) as a backend. Also, depending on how in-depth you wish to make the game, this could present an opportunity to create yourself an API (i.e., REST, SOAP, etc). There are several frameworks, specifically micro-frameworks, that you could use to ramp up your back-end pretty fast. If you wanted to get more hands on, framing a "custom framework" could be done in a reasonable amount of time and/or effort (I'm using the term framework loosely in this context). Whether or not you decide to create a server-side backend, you're most definitely going to need a front-end. The front-end will be comprised of whatever Javascript framework you choose (Angular 1/2, React, Flux, and so on) and some sort of CSS framework (Foundation, Bootstrap, etc) for styling. My best advice that I have is to always keep it simple. Your concept is not a monumental task, but I could see it being very easy to go off the proverbial rails and over-engineer your app if you're not careful. The same can be said for picking your programming tools. PHP shines when it comes to a learning curve, but in the same vein, it can be difficult to write maintainable code. You may or may not care about that. Good luck, and let us know how it turns out.
Thanks a lot for the insightful post, its really helpful! 
Thanks for the details answer! It helps a lot! Im still thinking about making it web based or a rich application, so this really clears thingd up.
I started with PHP 5, and always thought it was a pass-by-value language. Though in hindsight it's because I learned JS before I did anything close to Objects in PHP, and then most of my career I worked with good libraries that don't go mutating parameters. I think it was only recently I learned it was pass-by-reference for objects.
This is absolutely true, but it wasn't the point of my answer, it was all about asking the right question.
Not entirely true because solutions exist to make your PHP fly with sockets too.
I do the same in JS, yeah. At-a-glance knowledge of what the var contains.
From when you expect that someone, in the future, might want to subclass and not have to use reflection just because you wanted to put `private`.
It's not really unique to software. Any type of project that has creative involvement and ever changing requirements will run into the same issues. Ever seen a house being built that has the owners changing their mind on things throughout construction? It's a guarantee that the construction wont be finished on schedule. If they were similar to new house construction where you have a well defined blueprint and build schedule that you've done before then sure it would be easy to estimate development times. Though, if that were the case you would just make a copy and not worry about it. Software development (especially on existing projects) is more like renovating an older house. Sure you can estimate time and budget, but until you start working on it you really don't know what you're in for. Couple this with constant owner/boss/manager/client input and you have a recipe for things taking longer than planned.
I've seen a lot of similar articles lately, and they all boil down to "We can't estimate the unknown". What no one addresses is the word "estimate". Estimate's aren't intended to be fixed. I think the articles ignore this because many new developers just don't know how to effectively communicate with their clients (or bosses). For my day job, I work for an agency and am in charge of creating or reviewing / approving estimates for our development team. I've gotten to a point where I'm pretty good at it (usually +/- 10%). A few things I've learned: * Spend the time to really understand what you're building. Charge for discovery if this is going to take a significant amount of time to figure out. Early in my career, I spent a lot of time doing research for things on my own. It helped me to be a better developer, and made taking on an architect role later in my career easier. * Track your time / effort / whatever, and communicate how this is going compared to project milestones. We update clients weekly on time spent and where we are compared to the estimate. If something is going over, communicate why. Was the scope poorly defined? Did the request change? Did a new request come in? Every other service industry from mechanics to construction does this. Developers should too. * Use past experience and outcomes when estimating future jobs. This obviously takes some experience, but you can get there. * If you're working directly with a client, have a solid contract. We have a 10% overage clause that basically says "This is an estimate. If we're beyond 10% off, we'll need to discuss with you and possibly charge more or reduce future scope". This is especially useful if you estimate individual chunks. * If you're working with a manager or boss, pad the estimate. Whoever you're working for should know you well enough to understand how accurate you are at estimating. I tend to pad estimated from all of our new guys as a matter of practice. I also try to explain why I'm padding those estimates. In the end, an estimate is just an estimate. Sometimes it's really hard and tiring to stand firm on your estimate. Sometimes you need to show your work to justify the number you come up with. If you spend the time to make an estimate, and can show how you arrive at the number, many people will understand and respect that. Being detailed also helps overage discussions down the line. Finally, if any of this makes you uneasy, just switch to agile. I'm 90% sure it was invented to allow developers to continually charge clients.
Said solutions do not work under traditional shared hosting setups, thus my comment. It negates PHP's everywhere-ness.
PHP is fast if you're used to PHP, but it has no particular speed advantage over similar languages. If anything, something which is overall more consistent (like Python) is probably easier to work with.
I'm totally with you. But all I read was "project", implying it's for internal use only with limited time since you wouldn't be allowed to create this sort of application without legal work. Therefore going the "home-development" route, which is fine by me, as long as it stays out of professional environments. 
horrible idea. http://i.imgur.com/BBrf3yN.gif
&gt; Back in the good old days it was not uncommon to see a Class suffix We are now not in those days. We have now first class language constructs. Do you still use the _ prefix for private visibility? &gt; But this is actually a secular debate so reality is required. Why do you do that? What's so hard or unfair about that simple question. Let me rephrase it for you: What is the benefit for clients, knowing whether a type is an interface, a class or an abstract class? &gt; In any event, when the ubiquitous language gets down into the weeds, it tends to be expressed in terms of entities and value objects. So yes, there are no interfaces There is more than that. There are repositories, factories and services possibly as interfaces in the domain layer. They are all part of the UL and when it comes down to the implementation you will have your own diverged language with all those suffixes. &gt; &gt; Now you suddenly realize that you need to refactor a class to an interface (or vice versa). &gt; You must be very fortunate that the only time you ever need to rename something is between classes and interfaces. Sorry for not beeing clear. It was all about showing as requested one harm. I did bring up a second. Try to focus on the case I presented. &gt; The vote is currently 16 - 2 in favor of keeping the suffix. Argumentum ad populum
&gt; Finally, if any of this makes you uneasy, just switch to agile. I'm 90% sure it was invented to allow developers to continually charge clients. If you make changing requirements or adding features painful enough, it's surprising how many "MUST HAVES!!!" turn into "eh, maybe later." 
According to PSR-4, you need a 'top-level' namespace. There is no requirement for two levels of vendor\project before any class names. You just need the top-level namespace before any class names. So as it is currently Math PHP is PSR-4 compliant. They even have an example of this in the Zend example. Zend is the 'vendor' namespace, and the class 'Acl' would be \Zend\Acl. Lots of high-profile projects do it this way and are PSR-4 compliant. For example, Monolog, Slim, PhpAmqpLib, among others.
Really nice share, I don't know much use but I did enjoy the research behind it.
 eval("if('$param1' $comparator '$param2'){return '$whatToReturn1';} else {return '$whatToReturn2';}") This looks really insecure, I wouldn't use that function or the whole application that you got there at all. `htmlentities` alone is not enough to sanitize strings that get fed into `eval()`. May I ask, what did you _pay_ for that function? Also, allowing HTML in the parameters (what you requested) would be removing these two lines entirely $whatToReturn1 = htmlentities($whatToReturn1, ENT_QUOTES, $default_charset); $whatToReturn2 = htmlentities($whatToReturn2, ENT_QUOTES, $default_charset); **NOTICE: This is an even greater security risk as these values get fed into `eval()`. You have been warned!**
i can't believe you paid money for this.
Yes it is. I find it very useful in the jQuery case, since there are two different but similar domains used: jQuery collections and HTMLElements. You immediately know that you need to `$element.html()`, but `element.innerHTML`.
`list ($value) = array_values(compact($variableName));`
The $ sigil for PHP variable is okay for me. It does make variables easier to identify, and makes certain features possible(aka variable variables). Other than one extra character to type, it has little to no disadvantages. I dont think it really is necessary to remove or deprecate it. A better topic is whether to get rid of the dot(.) sign as concatenation operator. There are actually many good reasons why dot(.) is a terrible choice for concatenation operator, and my suggestion is to just use plus(+) operator as all other popular programming languages do. 
Hehehehe
This advice is golden.
A simple portfolio manager. An interface to upload images, create categories, and set images to display by category. Bonus: resize the images on upload.
Not sure about this page, but a lot of front-end frameworks use a TODO app as an example. I think can be done better in JS, but it can be done in pure PHP if that's what you want to learn. Or you can use JS for the front-end and PHP for the backend, which would give you some good knowledge about how the two can play nicely together. Good learning experience either way.
Well Python and Ruby are dynamically typed too, and they both use Plus(+) for string concatenation, so this is not an excuse. Also like I mentioned, we can use another operator for string concatenation anyway, Dot(.) is just a terrible choice. If Plus(+) isnt good, Dot(.) is even worse. 
And all you ever mentioned was, like I said, highly subjective and optinionated reasons. Basically, everything you say boils down to ". is terrible because it's terrible and bad code can be unreadable". What if I now say ". is good"? Why am I wrong?
Because Dot(.) is terrible for the objective reasons I listed. You consider them subjective because you fail to see how its been proven as a bad choice. Readability for instance, is not a subjective opinion, but an objective fact if its unreadable to most people. Similarly Perl ditched Dot(.) for string concatenation, it is an objective fact, not personal opinion. Sure you can say Dot(.) is good, but you have no reason to back it up. 
What Perl 6 did was basically to bury the language. I'm not a fan of sudden BC breaks like these. But I enjoy figuring out a smooth path to whatever change one may want to implement. Someone wanted to remove the need for "$" in front of variables the other day. I don't think these changes bring enough value, but technically if we really wanted to do it, we could do it, and do it *gradually* without breaking people's code making sharp turns. Heck I can give you a set of distinct steps that turn PHP into JavaScript over the span of half a dozen major PHP versions, and without sudden BC breaks :P Change management is art.
I'll bite the bait. Point a: "There are other operators that should be used because . is terrible." (Subjective) Point b: "Worse readability" (Subjective. Use syntax highlighting, good formatting and " to avoid this) Point c: ". can be used in other contexts." (Subjective. No reason stated why desirable or why \\ is inferior, only more possible bc breaks WHICH ARE ALREADY POSSIBLE) Point d: "Another language has done this as well" (Not a valid reason at all. Should we change PHP to work like Shakespeare?) Aaaaand suddenly we notice that your points are anything but objective.
Well you can just use Nikita Popov's scalar objects extension, this will not only give you object oriented string, but also object oriented array, number and any scalar types you want: https://github.com/nikic/scalar_objects Alternatively, there is an extension for UTF-8 string, you may want to check it out too: https://github.com/krakjoe/ustring
I will counter all your arguments: Point a: "Since Dot(.) does not fit the mental model of a programmer, it reduces efficiency and productivity." (Objective, it doesnt fit the mental model of most programmers, not just myself.) Point b: "Worse Readability" (Objective, readability is the experience from thousands of coders, not just myself.) Point c: "Using Dot(.) for a minor task like concatenation is essentially, a waste of a very useful operator." (Objective, String concatenation is a minor task in most applications, and using Dot on them is a waste) Point d: "Another language has done this as well" (It is a valid reason, because Perl 6 did this for a reason, and no other modern language uses Dot for concatenation for a reason.) Just because you cannot see the objectiveness and validity in my points, doesnt mean it is completely subjective. And yet, you havent given me your reason why Dot(.) is good to counter my points. 
It's just.. not a good idea to do that I'm afraid. And I'm speaking at someone who wrote a library like this years ago. The wrap-in-object unwrap-to-string game gets old really fast, not to mention the pointless performance penalty. If you want a uniform set of string methods, nothing beats a good old boring "utils" static class. You can alias it to "s" if you will.
Well it not only saves you from s(...) wrapper, its more powerful if you use it on PHP 7. For instance, you can do something like this: "This is a String"-&gt;toUpperCase(); So yeah, you can use it on string literals since PHP 7, so Id say its another improvement. 
I don't mind hosting, I have a few servers.
Sounds like a great idea. Do you have the patch ready? Be curious to see how you implemented this.
It's not weird at all, it's an aspect that much of the data the language works with is string-based inputs from HTTP requests that may or may not be numeric depending on the context it is utilized in. So your only argument is that the dot is not a good character of choice for the operation of concatenation, which is irrelevant given the backwards compatibility implications of changing it and the fact that it is a matter of subjective preference to utilize a different character. After all, the tilde can be utilized is text strings as a matter of confusion; in fact, pretty much any character would be a point of confusion since any character could also be contained in a string.
&gt; it doesnt fit the mental model of most programmers It fits fine in the mental model of PHP programmers, who *gasp* use PHP first and foremost! &gt; readability is the experience from thousands of coders You're very alone in this regard. In the list of mental gotchs in PHP, the dot falls wayyyy down the list of things most coders struggle with. &gt; Using Dot(.) for a minor task like concatenation is essentially, a waste of a very useful operator. What else would you use the dot for? And I don't know what applications you're involved in, string concatenation is heavily involved in practically anything PHP is associated with, seeing at it is primarily tasked with outputting, I don't know, TEXT. &gt; Another language has done this as well Perl 6 is dead. Find someone using it for anything on the scale of a Facebook. Your points aren't objective, they're illogical.
That's an entirely separate can of worms, as type-juggling is one of PHP's strengths along with one of its weaknesses, depending entirely on what you're attempting to use it for. For working with data that could be any number of types it can be a godsend to be able to essentially force data into certain types, plus stronger typing requires more definite model of the domain that can be a hindrance in scenarios in which you want to put together a quick and dirty solution. While it has gotchas, it still lends itself to a flexibility that can be useful.
I believe the standard way is to make it so the endpoint checks for valid credentials in a http basic authentication header.
Woocommerce is great for simple shops.
Also etsy, but +1 for shopify. Maintenance is not fun or profitable 
The only problem I have with Twig as I use it more and more, is that the `{% %}` syntax is really awkward to type. Why not keys closer together like `{+ +}` or `{: :}`
Not sure why you think Dot(.) isn't suitable for concat. Dots(.) are used to concatenate sentences together to form a paragraph, and to join whole numbers to decimals. And using Dot(.) for namespaces doesn't really make any more sense than backslash. The real problem is using *different* characters - most languages use Dot(.) for namespaces and method accessors, while PHP uses different characters for namespaces, static accessors and object accessors. Honestly I never understood why PHP couldn't at least use `::` for namespaces. 
Most frameworks provide convenience methods to declare routes, in which you can specify the http verb like $app-&gt;put('entities/{id}', function($request, $response) { ... }); Authentication is usually dealth with route middlewares, meaning that you check for certain cookies, session vars or headers, and if the check fails you return a 401
At this point, every one of your ideas has been so unfathomably shitty that I have to believe you're just trolling now.
Old style constructors, like in the article, have been deprecated in 7.0
while at it lets disallow single quotes for strings and rename php to java.
This specific error message is even documented: http://php.net/manual/en/functions.arguments.php#functions.arguments.type-declaration It really should be fixed.
How would the parser know the difference between function(arg) and constant (parenthesized expression) ?
&gt; I think you might be surprised how many real programmers are there that still write own libraries and own algorithms Nope 'real programmers' are refactoring the absolute dribble that others have produced by writing their own libraries. The majority of my work is re-writing shite code rather than producing any new code base.
Don't reflect that on me please, because my work isn't _refactoring code of others_. I produce new, own code, mostly. That doesn't mean I'm re-inventing the wheel, I look for existing stuff and if it looks good, I use it. If it doesn't, I create it. I don't copy other code over and change variable names, I read their code, try to understand it and interpret it own my own, with own algorithmis, trying to optimize them at points the others may have forgotten. Of course you occasionally stumble upon things you can use as-is or only need minor refactoring, but I don't re-write shit-code. Why would I? It's shit-code. I understand how it works and reflect it with own code. It's not a big secret that many people are "programmers" because there is StackOverflow. Every person that changed a line of CSS somewhere once is calling themself "Frontend-Developer" today. But how many people could actually write a working, functional framework from scratch? I wonder. And as it seems, it's less people than I thought.
Thank you for your opinion. Fortunately, is not shared by the professionals.
[standard azerty layout](http://xahlee.info/kbd/i/layout/Belgian_kbd-s.png)
Quoting myself, &gt; Personally, I like the $, it improves readability I just don't think that _you don't type $ often_ should be the reason to keep it (and I think it's a false statement). There are several other, better reasons to keep it, e.g. simply readability.
&gt; I just don't think that you don't type $ often should be the reason to keep it (and I think it's a false statement). We're not looking for a "reason to keep it". It takes no effort from anyone at all to "keep it". It's there already. We're instead looking for a "reason to remove it". And there isn't a *good one*. Furthermore, I didn't just say "you don't type $ enough", I said "you don't type enough" in general. An average programmer produces several hundreds to a thousand lines of code a day. Let's say you're the mythical 10x programmer and you do 10 thousand lines a day (I wouldn't draw a direct connection between "productive" and "lines" in general, but let's go with it here). You can type that amount of *text* in about an hour. So **what are you doing the rest of the time**? Thinking, testing, debugging, sketching, reading. But *not* typing. 
That's going to be funny when you don't have strict types. echo "5"+"5"; or $a = 5; $b = "5"; $c = $a+$b; // whatyawant? 10 or 55?
Yes, and a vendor namespace is required. From PSR-4: &gt; The fully qualified class name MUST have a top-level namespace name, also known as a "vendor namespace". `Math` is not a vendor name, it's a library name. A vendor name is missing from this namespace.
Trust me. Save yourself the hell of indefinite WordPress maintenance stress and don't go with a self hosted solution like WooCommerce. Stick with Shopify.
I was hoping it was like the middle of the night or something and they were just being sleepy dumb, but no, it's like 1:30pm.
Definitely fishing.
I'm not sure if you're joking, but United Kingdom voted to leave European Union, not the region known as Europe. And the naming "Europe/London" is not governed by PHP.
Europe is a continent and cannot be left. Brexit is about leaving the EU (european union)
You're best off using Xdebug, or you could write a function which takes any var as a param, then outputs a script tag containing console.log(&lt;?php var_dump($var) ?&gt;). But just learn Xdebug.
If you do modern app development, a good chunk of your responses may be API responses, not HTML pages, so it's advisable to keep your debug log separate from your output. You can send debug information in headers, but the problem of how to capture this in the browser remains, particularly with AJAX calls and side-loaded resources (like generated images, etc.). What I do is I log things to an sqlite database, and then I display the log entries in a separate tab (as a separate web app), with details about input, output, request IP, URL and so on.
&gt; What is the bad thing in having a linter that checks for no whitespace/newline after ?&gt; instead of omitting that tag? What is the bad thing in just omitting that tag? It's completely superfluous code.
&gt; Estimate's aren't intended to be fixed Try telling that to a project manager.
Not directly related to PHP but still usefull: https://chrome.google.com/webstore/detail/json-formatter/bcjindcccaagfpapjjmafapmmgkkhgoa
&gt; What is the bad thing in just omitting that tag? Technically it is okay. But logically it is just wrong. You have opening and closing tags for anything that is not self-closing. Why should I omit the closing tag for PHP? To mit it is illogical nonsense relying on PHP's error handling regarding the missing closing tag instead of carefully make sure that there is nothing behind this tag.
The space ;-) If you don't like this, we have "#", which is redundant in its current meaning, as it's a line comment, same as the more popular "//".
Great, thanks so much for this. I'm quite new to this though, and the third installation instruction is holding me up: &gt; Put ChromePhp.php somewhere in your PHP include path. This PHP include path is on my server, correct? I'm editing a Wordpress file--does that mean I should place the file in the wp-include directory? Or can I just place it in the same directory as the PHP file in-question? Or does it not matter, so long as I properly specify the path and file when I include the file in my code? Thanks again!
I probably should have mentioned that I'm a PHP novice. I'm using Chrome to edit a PHP file for a Wordpress site, and want to be able to print messages to *some* kind of console during this process, to ensure my code is doing what it should. What would you suggest for someone like me? Many in this thread, and in other search results, suggest simply using Firefox for these tasks. I wouldn't mind giving Xdebug a whirl though, but I'm sure it would have a steep learning curve for me.
Repurposing `#` to string concatenation is a BC break.
&gt;&gt; create a phpinfo.php (name doesn't matter) next to the index.php in your project. To be clear, I need phpinfo.php to reside in the same directory on my server as index.php? I don't place it anywhere on my local machine, correct?
Clockwork. Ref: https://github.com/itsgoingd/clockwork-chrome
I'm not sure, but it seems like you don't know where PHP's built-in error log is. So type : echo phpinfo(); Search for "error_log" in the resulting table, this gives you the path of the error log. All bugs are reported there. Also be sure that you have these two lines at the top of your scripts, so all errors are logged : error_reporting(E_ALL); ini_set("display_errors", 1);
The location isn't really important, as long as you can access it through your browser. Putting it in the same folder as index.php is simplest, just don't upload phpinfo.php to your production environment, that's a security risk.
Any way to uncomment comment blocks in phpstorm without highlighting the full comment block? Kind of annoying way of doing it :/
&gt; just don't upload phpinfo.php to your production environment, that's a security risk. OK thanks for everything. It has been very enlightening, but I'm getting a bit out of my comfort zone. I'm going to speak with my web host. I think he should be able to guide me a bit more on this. Cheers for everything--upvotes all around.
What differentiates this from etsy/phan ?
firebug in firefox is crucial
Ooooo..... Sexist!
why not?
Because being part of communities take time and effort, and if you're not getting anything out of it... ¯\\\_(ツ)\_/¯
Sure, i'm not forcing anyone of you into it. Would be nice to have some PHP-devs on there anyway, right now I think most of them are JS devs. Free to join, just wanted to share since a lot of people were enjoying it. 
Will Firebug along accomplish what I want? Or do I need FirePHP as well?
It's not free. You're required to create a login with a commercial company who may then do evil things with your data. Also, IRC is better. There are plenty of topic-specific channels on Freenode and other networks, and I can view them all in one window instead of having to have dozens of different Slack windows open. If you like web-based clients, I believe IRC Cloud is frequently recommended, or for self-hosted there's [The Lounge](https://thelounge.github.io/)
At work we're a little more sophisticated, but for my personal projects I usually just use `git pull` or `scp`. If I have to make changes to a database then I apply the changes then promptly do a git pull or scp.
Interesting project certainly will be giving it a look over lot of good thinking gone into the security clearly. Only negative I see straight off is it looks very 90s a flat UI would be a lot more appealing. Know thats a minor thing but to attract people who would normally be drawn to WordPress or similar the backend really needs to look the part straight out. 
Ohh, DeployBot looks awesome. It looks like it allows running builds in a Docker container on their servers. That would definitely solve my first problem. I looked at Dploy.io (it's predecessor) a few years back when we started with Beanstalk, but back then the deployment options in Beanstalk and Dploy.io were exactly the same. It seems that DeployBot has a bunch of nifty features that Beanstalk is still lacking. Thanks for the tip!
Thanks, DeployBot looks awesome. We've been using beanstalk for years, and completely missed this. **Edit for anyone still reading:** E-mailed Beanstalk support, and they do offer free DeployBot accounts for paid beanstalk users. Appears that they need to manually override the billing setup, so you'll need to contact them.
Sorry for being shallow and superficial, but good lord, that UI though...
Sorry mate, it's not my business to speak for the company. I only feel comfortable discussing personal projects and the things I do on my own time.
We use [fabric](http://www.fabfile.org/) and [GNU make](https://www.gnu.org/software/make/). Takes a little effort to set up but worth it once you start needing custom commands.
Rasmus' explanation of Etsy's system is worth a look https://codeascraft.com/2013/07/01/atomic-deploys-at-etsy/
This is how foil was born : http://gm.zoomlab.it/2015/template-engines-i-moved-from-love-to-meh-for-plates/ . Probably you will find some reference to different template engines ;-) and ....
Our deployment strategies are all over the board. Once there was a `sync2.php` script on the production server, ;) some other time it was a `git pull &amp; make` combo, and in some other case it was an opsworsk app with chef scripts. But we’re no longer medieval and we try to build [12 factor applications](https://12factor.net/). There are a couple of requirements we like our applications to meet: * The whole process from commit to production needs to be automated * The process should consist of a test step, build step, deploy step and a release step * One commit has exactly one build, and this build can be deployed to any environment (production, staging, qa) * The build should resemble a binary and require as little outside dependencies as possible It looks like your goals are similar to ours, so let’s dive into details. # What is each step? The whole process is a [continuous delivery approach](https://www.wikiwand.com/en/Continuous_delivery). 1. It starts with a commit. Each commit is deployable, but not necessarily to production. Either way a build needs to be done. To do this you need to connect your VCS repository (via a webhook or otherwise) to a test/build environment. After the test suite passes, the application is built and stored. 2. After a successful build, the process goes to a deployment step. Depending on some factors (the branch the commit was pushed to for an instance), the deployment may or may not run, and it may target different environments. This way your `master` branch may deploy to production, the `develop` branch to a staging env and each branch starting with `feature/` goes to a separate q&amp;a env. 3. The deployment step only ensures that the latest version of the application is available on target nodes. The last thing left to do is to switch to that version, and it’s called the release. There are some strategies you can use to reduce downtime and have the ability to rollback — you’re familiar with capistrano so you probably know them — it keeps a bunch of recent releases on disk and only switches the `current` symlink. # Build tools First of all, look at heroku. It has a build script called buildpacks. They have some common interface to build any PHP app, including specific actions for popular frameworks. In your case you could `require` phing in your composer file and add the build script to the `post-install-cmd`. You can even stack buildpacks together so that you first use a nodejs buildpack and run npm &amp; bower &amp; gulp and whatnot, then build the PHP app using composer &amp; phing. After a little learning it really covers 98/100 cases (in my experience). But you of course don’t wan’t to lock-in to a specific platform. Don’t worry, since this mechanism is used in many other, open source tools. [Dokku](https://github.com/dokku/dokku) for instance uses [a buildpack-ish script](https://github.com/gliderlabs/herokuish). This has an added benefit, since it compiles a docker image. This way the build is highly portable, needs no dependencies other than docker itself and may contain not only the code, but also the runtime (like apache &amp; php-fpm with modules) and some basic configuration (env vars, `php.ini`, `.htaccess`, etc). I’ll give you some examples. For your build server you can use anything comes up in google for a `continuous integration` query. Popular ones are Jenkins (self hosted), [CodeShip](https://codeship.com/), [Travis](https://travis-ci.org/). I guess they all have a distinct test and build steps, or even a custom pipeline. It’s better to use a popular one (even if it costs slightly more) because of the community and integrations. You are not the first one that needs to build their PHP application, so there is no need to reinvent the wheel here. There are a lot of out-of-the-box plugins — for instance to integrate automatically with github, gitlab or bitbucket and report build status. If you’re not into docker and rather have a zip file, it’s common practice to pack all the build artifacts (i.e. compiled application) and push to a S3 bucket. Again, there are probably tools you can use for that instead of writing your own. I like to use [wercker](http://wercker.com), since it uses docker for build environment, has a large community and enables you to create multiple build pipelines. This is a [sample wercker configuration from one of our apps](https://gist.github.com/mlebkowski/f261481dbfafb1354d41c44a68830c73) using herokuish to create the docker image and then to push it to the docker registry (so it can be pulled/deployed). # Deployment tools Capistrano with some plugins is just fine for deployments. It doesn’t need to build the app if you done this on the build server. All it needs to do is to rsync the package to all servers. Or tell them to fetch it from S3 / docker hub / wherever. I don’t have much experience with capistrano, but I assume that it may be complicated to use it in a distributed environments. If you’re using docker (yep, I’m a fan), you can use the [docker cloud service](cloud.docker.com) to deploy. I even [created a wercker step to make a blue-green type of deployment](https://github.com/mlebkowski/wercker-step-bluegreen) using docker cloud. It warms up new application containers, scales them up, then switches the load balancer to them and then scale down the previous version. As far as I know docker cloud can be replaced for [Kubernetes, and here is a simple introduction](https://www.youtube.com/watch?v=pozC9rBvAIs). Both those solutions run on distributed systems and use a service discovery to tie the application back together. Another important thing is a GUI. It’s nice to have a "deploy" button. You have a continuous delivery (every commit is deployed automatically), but maybe something goes wrong? Or you’d like to check the progress of the deployment. Or make a rollback. Or create a new (non-automated) environment… Docker cloud helps a little with that, but generally I don’t have a great solution for that yet. # Final words The one thing I learned from all the years of deploying applications is to use existing tools and concepts in an automated manner. If you stray from this path you end up with a weird legacy system, not portable to other applications. The build server always builds any app the same way (run `composer install` for example) and the build details are in the application code (`phing.xml` or composer scripts, etc); Similarly the deploy server knows how to launch a package (just run a docker image and forward a port), and the build contains the runtime details (is it a nginx, a node script, a go binary…). Hope this helps a little ;)
`rsync -av *` and Codeship get us through. I use Phing on a couple of projects.
That a template engine is as fast as bare php is not just naive, it is a lie. Not to forget that compiled template engines need a warmup or they may blow up in your face. Pure php is easier to extend then any compiling template engine. Pure php is easier to read out of the box because every editor can highlight it. Pure php needs no learning, there are not even minor problems. Pure php debugging will never fail you. Valid reasons to use a template engine: * less verbose and specialized syntax * prohibiting php/smart code in templates Anything else is just a weak excuse.
Then why post at all? You have added literally nothing to the conversation. 
&gt; Point a: "Since Dot(.) does not fit the mental model of a programmer, it reduces efficiency and productivity." (Objective, it doesnt fit the mental model of most programmers, not just myself.) Did you know that you are gay? It's objective because I say so! Give evidence or this point will remain completely subjective. &gt; Point b: "Worse Readability" (Objective, readability is the experience from thousands of coders, not just myself.) Again, no hard data. You state this and that's it. Your points don't suddenly become objective just because you say so. &gt; Point c: "Using Dot(.) for a minor task like concatenation is essentially, a waste of a very useful operator." (Objective, String concatenation is a minor task in most applications, and using Dot on them is a waste) So you are saying we should completely break every application that has ever existed because we either could use the operator in an unforeseen future context or because we could break even more? Doesn't that sound nice? String concatenation can be a small or a big part, before you don't give any data on this (e. g. based on GitHub projects) this point will remain entirely subjective. &gt; Point d: "Another language has done this as well" (It is a valid reason, because Perl 6 did this for a reason, and no other modern language uses Dot for concatenation for a reason.) So? Should we also adapt every change that Java gets because it's a modern language? &gt; Just because you cannot see the objectiveness and validity in my points, doesnt mean it is completely subjective. And yet, you havent given me your reason why Dot(.) is good to counter my points. Every. Single. Damn. Point. You mentioned. Is subjective. You are either too dense to understand that or you are just trolling, and the sad thing is that based on previous times I replied to you I am leaning towards the former.
I never worked with etsy/phan. They're both static analyzers, just like phpmd and others. What might differentiate them is the fact that they're in different developing stages. Also, it seems that currently etsy/phan has more complete documentation. 
Other than saying how I deploy my personal PHP projects?
&gt; Technically it is okay. But logically it is just wrong. Logically your entire file is PHP. The PHP open and close tags are just an alternative way of writing an echo instruction followed by a string literal, nothing more. Those two lines of code are basically equivalent: echo "hello world"; ?&gt;hello world&lt;?php So you feel uneasy you don't close the PHP "block", but I feel uneasy because you basically insist to end your files with an empty echo instruction. Those are the same: ?&gt;(end of file) echo '';(end of file) Things are not what they seem sometimes.
[deployer](https://github.com/deployphp/deployer) purely for it's simplicity.
Just use [monolog](https://github.com/Seldaek/monolog), it's the basis logging tool for the main php frameworks and it has a ton of features. I totally recommend whoops for error handling. Another tool I do recommend is [blackfire](https://blackfire.io/) for a preview of function calls and overall structure of your code. 
 Did you ever think that there's a reason why not a lot of women want to get into programming? Google tech event sausage fest, or just take a minute to think.
This is basically a DIY version of Capistrano (i.e. symlink based deployments) with the added component of a couple Apache extensions (mod_realdoc/incpath) to prevent issues with the symlink switch ending up desyncing or wrecking requests half-way of a deployment (all of which can be sorted out with the built-in $realpath_root variable on Nginx, btw). It's a good approach, and basically the only choice if you don't want downtime AND don't want to maintain a couple of servers and a load balancer to switch between them while deploying, though it doesn't answer OP's questions (since he's already using Capistrano).
Your question is ambiguos. What is monitoring? What is monitored?
So we talk about competition with the likes of Zabbix? Do you care about the front end solutions (fancy graphs) or the monitoring agents? Or both?
Yes, Zabbix, Datadog, New Relic etc. What I will be building is a service which takes data from agents, and shows you graphs, sends alerts etc. 
The way you handle exceptions is certainly the most annoying I've ever seen. 
&gt; The first problem is that building the application now happens on the webserver. That means the webserver needs to have all kinds of stuff installed like Node.js, NPM, Bower, Gulp, Sass, Composer, etc. I don't see this as a big problem. Bower is obsolete anyway and stuff like Sass is used via npm/gulp. And 99% of the time it's not running. My usual setup is hosting the git repo on the server and running gulp and composer install on a post-receive hook. 
Very thorough! Thank you very much :-) I'll definitely look into buildpack. It sound like that is something we could use. Unfortunately we don't use Docker (yet. I'm having trouble convincing our sysadmins) The problem with Capistrano (we use it pretty much in vanilla style) is that it wants to do a checkout on the webserver and run buildsteps there. It doesn't appear to be useful for building on a build server and then just deploying the build artifact. But perhaps it can be done. Wercker also sounds good. I will look into that too. Thanks!
I saw deployer mentioned in the Symfony docs. How stable is it? And can it build locally, then deploy the built files? It would be nice to be able to ditch ruby (we only have ruby for Capistrano)
This may not address all of your concerns, but one thing I do is keep all of my dependencies in Git. (stuff provided by composer, etc.) That sounds wasteful, but it gives me the advantage of having a much simpler deployment process--if I can connect to GitHub, I can download everything I need for the app. It also ensures reproducible builds, which is very important to me. You mentioned using a deployment server to build what gets deployed, which is also not a bad idea. If you want to distribute your software as packages, you should totally use FPM: https://github.com/jordansissel/fpm I use it at work in a large production environment and it works great! In your case, you could create a ZIP file, convert it to an RPM or .deb, and include -d in the fpm command to specify dependencies. Good luck! 
I'm imagining some sort of RFC 1149 compliant flow. We do similar stuff at my work.
NPM installs all that stuff, you don't need Bower. Example: https://www.npmjs.com/package/jquery Install that, use Gulp to concat/compress then copy it from node_modules to your public directory. 
You've made clear that PHP.ini files are the same. Are you also positive that the same extensions are loaded? Sometimes some of the symlinks inside conf.d are missing from either cli, cgi or fpm. There are some extensions that don't run in one of the environments. Apcu for example is disabled on CLI unless you explicitly set so. If there are any error handlers declared in fpm runtime, disable them. Some libraries handle errors and convert them to exceptions. This helps normalizing the workflow and allows for nice, informative exceptions BUT any undlandled exception becomes a fatal error. In other words, what is a warning in CLI becomes a fatal in fpm Have you tried this behavior relaxing the basedir restriction? I believe the CLI runs as the current user, whereas the fpm process usually runs as www-data. I wonder if the problem is somehow related to the parent folder being non iterable to check for its contents. Is there any chroot setting for either environment? This would change readable folders.
[Forge](https://forge.laravel.com) + [Envoyer](https://envoyer.io)
Wow great thank you, I was planning to do the same thing as tensile, I'll definitely contribute there.
Posting this for laughs/tears. I work for a branch of the federal government. Development computers cannot connect to the internet and the only connection to our production servers is through web-based Citrix RDP through our other government managed non-development computers. Our "deployment" process is to burn files from our development computers onto a CD, transfer them to the other computer, RDP into the server which we have limited control over and automatically creates a mapped network drive back to our non-development computer when we log in, copy the files up to the server using Windows explorer (which is extremely slow, often fails and corrupts the files, and often loses connection half-way through), then copy them into our application. Yup...fantastic.
Mainly custom scripts that grep log files at this stage. Also, for basic stats and connectivity we have [Observium](http://www.observium.org/) setup. We are looking into implementing monitoring software in the future, when we get some more time!
I do this too, its probably only slightly better than using FTP.
Do your bash scripts end with `/#!/bin/bash`
What do you do with Envoyer that Forge doesn't do? First time I hear of Envoyer.
This is a Laravel tool - I don't see any way atm of making it a truly generic one - but I'm at the point where I'd like to get feedback from the community at large how this might be beneficial, and what direction I might take in a couple of key areas. If you work with other frameworks that have this type of tool available, would love to hear about them!
No internet means no Stackoverflow?!?!?!
They don't even have to start with it.
Via floppy disks, couriered to our admin and carried over and copied at the colo.
Wow, how do you get anything done? Personally I'd run like hell if I encountered that...
Looks very nice! Will definately try
Currently the CI tool (snap-ci) builds+tests (phpunit) the code. If that passes and someone clicks on 'deploy' it ssh's into each running server and goes git fetch/merge and symfony cc. I've investigated building .deb packages from the code, which would at least provide move atomic deployments.... ( there's https://github.com/wdalmut/php-deb-packager ), but we're not there yet.
Why not simple run your own proxy? All this stuff in your git repository is just noise. You can run either [satis](https://github.com/composer/satis) but if you're cool and your company depends on it, you use [toran-proxy](https://toranproxy.com/)
I simply SSH into the server, navigate to the codebase and run `git pull &amp;&amp; make`. I use Git to pull the latest changes to the codebase onto the web server (the code is hosted on GitHub). I then use GNU Make to run the Makefile which contains instructions for things like compiling Sass, installing Composer packages and running migrations. If I ever move the codebase to a new sever I know all the things I do during a deploy are kept in the Makefile (which is tracked in Git) so I don't worry about settings things up too much. Bonus points for if you can automate SSHing into the server and running that command using Ansible. It certainly sped up deployments for me. :)
Assuming you're using Composer to manage your dependencies: If you commit your composer.lock file to your source control you are guaranteed to get the exact same versions of all dependencies when you run composer install on the web server. You then don't need to track your dependencies in your codebase (which some would consider bad practise).
His main point is that his co-workers didn't want to adapt to a template engine and that is basically the reason why he made foil. It's not really related, the OP already knows Twig.
Ah, I see. Well, he might have a point for that specific situation, his co-workers simply didn't want to adapt. He basically wrote foil for his co-workers. It's not a major reason of why people develop template engines, though haha There are also people, like me, that would've simply left the company, directly. Not because they don't want to use a template engine, but because of the attitude regarding it. Either them or me (Me, most times.)
And how could you add a friendly deprecation notice when the old class is being used with you method? I think that's what /u/mglaman was asking about.
Awesome, now I'm inspired. I will write a scaffold-generator for Ketch-templates with _even easier_ syntax that will invoke Ketch automatically for you. Maybe I'm getting old, but I feel like this is going too far :(
Please, just push the `composer.lock` and you always have the same packages in the same versions. The only thing you're doing is avoiding to run one command (`composer install`). I don't get where it eases up your deployment process. The only reason I could think of is that you're not allowed to run `php` from the command-line. You're not even decreasing the amount of data to download, it's just from another source, basically.
I can just imagine you wearing a [tin helmet](http://i3.kym-cdn.com/entries/icons/facebook/000/016/146/eird-al-yankovic-tin-foil-hat-160x160.jpg) during the whole process.
Probably you missed to read the whole article? Wasn't the article about he moving away from Plates due to certain reason? So I was mentioning every developer have their own preference and probably may create their own. So the point is, we should not blame them.
It seems you missed to read it. He was using Plates, but Plates sucked balls, so he made an own one. But the main focus for it was to have a template engine that he can work with with his co-workers, which was the initial reason why he used Plates at all, he would've gone for Twig or Mustache otherwise. He's writing exactly that. Of course everyone has their own preferences, but we also somehow are able to all use PSR-2 now, why aren't we able to make one template engine somewhat the _main template engine_ which is simply the main answer to questions regarding it and people that want more (or less) can always go and get more (or less). If all people in a project agree, heck, go and use Brainfuck for your templates, no one cares. But if someone asks me, today, right now, what kind of template system he should use for his project, I'd repeat the name Twig over and over again. He can google for stuff, he will find over 100.000 results for any question he might have, it's broadly accepted, well written, clean, functional, dynamic and has everything you wish for in a good template engine. I would point to plain PHP, if you want less, you're a purist and eat raw meat and to Jade, if you want more and you're willing to make everyone hate you for it, but make you love yourself (No hate, I love Jade) 
Nice!
Yeah, i forgot about that in the example but with that approach you don't need to know if the variable exists or not. &lt;?php /* @var $this ViewClass */ ?&gt; &lt;h3&gt;&lt;?= $this-&gt;active ? "active" : "inactive" ?&gt;&lt;/h3&gt; In a view, a variable just don't popup or start existing from nothing. It's a variable defined by something, or someone. I literally use the approach above, because the view file is a part of the view class (separated by two files) i always have; type-hinting, auto-complete, scope, separation, DI and whatever i need. This is not possible with Twig as far as I know.
I agree completely that this won't be for everybody. Almost certainly, it will be built for the stack I use at my company; with the plan that it should be extensible enough for other stacks to pull into it. I would say it is a service though. Eventually, it will take in performance metrics, deployments and cluster details to help you determine whether or not you are allocating resources properly, whether or not a deployment was detrimental or progressive. In terms of dealing with logs, that is quite a way down the list of features I have in the pipeline for it. It is something I definitely want to tackle one day, but for now, I would say that graylog or and ELK stack is certainly going to be a better fit. I hope that one day that situation will change, but I don't see it anytime soon.
* Create a release at github * Start a Jenkins (https://jenkins.io) job that ... * ... does composer etc. so, the "build" does **not** happen on the application server. * ... does automated testing * ... finally builds a debian package. With pre/post install scripts. * Use Ansible (https://github.com/ansible/ansible) to deploy the debian package and requirements to production servers. 
munin
&gt; Please listen to this man and take the time and do this Thanks for this. I truly take what you say to heart, and I *really* want to install. In this instance, there are two hangups right now: 1. The (Wordpress) website in-question is live, and critical (medium sized business). Is setting up and using Xdebug recommended in this case? I'm seen some sources say that PHP debugging is not recommended on a live site. I should note that the edit I intend to make is very small, non-critical, and will be quick to carry out. I would also not need any more PHP debugging after. 2. Someone very nice in this thread tried walking me through setup, but I got hung up at the [wizard](https://xdebug.org/wizard.php). I didn't know where in my Wordpress installation I should upload my phpinfo.php file. Thoughts on those? Again, I would *really* love to get xdebug setup, but I'm just at a roadblock here. I fully understand that xdebug would be the most productive, and the whole point of my post is to increase my productivity. Even though the PHP edit I'm making is small in this case, I'm interested in a PHP debugger for the future, when I will be making heavy duty PHP edits. edit: Maybe it would be best if I started over with a new post in /r/phphelp on how to install xdebug and get it working?
Yeah, it's a matter of personal preference, and I agree and totally see that it's a bit time consuming when creating simple views. The good thing about that approach is that each object exposes their relative API, and don't rely on a view to make everything available for you by automagic. As you can see, I got access to user divisions simply because the `User` allows for lazy loading, even though it's not part of the view. That's why I usually never argue during the Twig/PHP/Smarty or whatever conversations, because everyone have their opinion. Whatever works is good.
You can also do that with Symfony Console's `&lt;fg&gt;` and `&lt;bg&gt;`-tags. Never stop developing and I don't say it's bad that you developed this, but it's re-inventing a wheel we already have and that is Symfony Console. It's probably the roundest wheel out there. If it helped you doing even better stuff in the future, that's good. But you won't get many users on this I guess.
I did not actually reinvent the wheel. I acknowledge that the **wheel** was already there, what I did was, simply create a spoke, as one of 'em had broken and I didn't want to replace the entire setup. It is not an entire CLI lib. It is **one** class for quickly add auto-padding, line integrity, resize and word integrity feature to your next CLI app (or part of an app).
At work at bud but I'll take a look at this when home in a few hours
Hmmm, this is a really good idea. Thanks for this. &gt; A comment system which creates a relationship between 2 database tables, expanding on number 3 this could be adding reviews to the products. Can you explain this a bit more?
&gt; won't get many users I agree. Thing is, I am developing an app in PHP devoid of any complete frameworks. I am using Propel as an ORM and Monolog for logging. Performance is of essence in this app, not because of the number of simultaneous users but because this app is co-hosted on a FreeSwitch (VoIP) server. There is a part where I need to add some CLI capabilities and I can't justify dev time on ncurses, thus I came up with this. And as the title of the post says, it is useless after all.
The logo is of a conductor
Better marketing to corporate PHP users who don't understand what it is.
yep. Decent illustration...logo, not so much
For us, it is much better than FTP. Everything is triggered on commit, and we're a WP shop, so usually no tests or compilation. For my Laravel projects, it automatically runs the various Phing builds. I for the most part never have to FTP or SSH anywhere anymore, which is nice.
First up, congrats on this event*ful* journey! (Pun intended). The following is my opinion and by no means do I claim to possess authoritative knowledge on development paradigms. But, I program primarily in JS (Node &amp; Front-end), Golang and PHP. So, in course of using Node and Golang, event based programming comes pretty naturally. I like to picture event based programming in terms of the Observer pattern, albeit a little advanced. So, the idea is, one part of your app generates a message, much like a drill sergeant shouting a command and then other parts of your code, like the cadets, all start feverishly performing their duties. See, the idea is that **all** the cadets start performing, *together*. It is this async and simultaneous performance that this elusive in PHP. So, the idea becomes a tad redundant. I understand that there are multi-threading features/support in PHP, but, they are not as mature/easy-to-use as some of the language that I just mentioned. Granted, Node doesn't support multi-threading, but it is async in nature and thus can very well manage task delegation between I/O. But, the very nature of progressive interpretation of PHP makes it very difficult to manage. The closest you can come, is emulate or use *reactphp** or write a thread delegation, management and handler and then immerse in event based programming. Sorry for the long post. Hope it helps. 
Ha ha.. totally! Fuck these corp managers. The worst are the mid tier, 5+ years experienced ones. They are so bloody out of touch with reality. Btw, I was one of 'em 'til recently. But, I was always better informed.
Sure, as applications get more complex they require larger data sets and its better to put this data across multiple tables instead of one table, this makes expanding your application much easier and also helps with data normalization. Lets say you have a products table and it holds the products information such as id, title, price, description etc now you could add a column for the products brand and store the brand name such as Apple or Microsoft in this column. This now produces a problem, someone could enter in the brand as apple and another person could enter Apple, this makes managing the data and keeping it consistent difficult. What if a product has multiple brands? do you just keep adding columns to the product table? This is not the correct way to do things but I see it all the time in old applications. So for the above example you will have your product table and you will have a reviews table. The reviews table will "link" to the product table using whats called a foreign key which is the unique ID of the product table. So your review table will have columns like, id, title, review, product_id, where product_id is the foreign key linking it to your product id in the product table. So to get the reviews for a given product you would have to reference the product_id column in the reviews table and in more complex relationships carry out JOINS across the tables. The query would look something like SELECT * FROM reviews WHERE product_id = '*the current product id*' This is a vital skill set to learn as all aspects of modern application development will involve joins across multiple tables
Actually PHP does not natively gives you threads, neither async, but you can simulate async using yield and yield from, the exact same way asyncio in Python does (I guess there are extensions to give you threads or async, some of them like cURL may use it internally too - but that's where my knowledge stops). As you said, node does async, not threads, your events are not concurrently run, but as much as PHP does they are just run sequentially (one after another) aside of the fact you don't control the order it does not give you anything more. The only use case where you would actually get a performance boost is only if one or more of your listeners hits an IO-wait at the system level, case in which the monothreaded node JS engine will run another async operation during this time, but that's pretty much it. Aside of that, I do like your explaination, it's a good one!
doesn't the --prefer-dist flag download the zip instead of clone?
&gt; Performance is of essence in this app Probably a side note, but why did you pick PHP if performance is the main goal of this application? What was your thinking behind this? I love PHP but if performance is one of the main goals of a proejct PHP certainly wouldn't be in the top 10 languages to chose from.
I think on the composer.lock, it should not be committed if you develop a library or package, but if you develop an app, then it should
I understand [*why*](https://getcomposer.org/doc/faqs/why-can't-composer-load-repositories-recursively.md), but its inability to recursively resolve dependency repositories - it's a bit too reliant on packagist (or a proxy) in this regard.
I like it, too, but man, it's 2016 and it won't hurt having a CSS-colored background here and there and maybe do a transition at some point. Fast is cool and all, but if you want it _that_ plain, simply use Lynx or disable CSS in your browser haha It could take more width on wider screen-sizes, reading-text could be a bit larger, maybe a different, smoother sans-serif font that's easy on the eyes, playing with typography a bit. Not even requesting fancy images or huge JavaScript widgets, sliding or fading stuff, just a more _modern_ base design. Also, the **logo** :(
I see your pain. But, I can't help but share these two links for *your* views on them: * http://bettermotherfuckingwebsite.com * http://bestmotherfuckingwebsite.com
I find the output when a conflict is encountered to be very misleading. I don't know whether it's the way I define my dependencies but it's never obvious which packages are conflicting, maybe it only shows the low level conflict? And not which entries in my `composer.json` are causing the conflict
O boy! This one's a real pain in the butt, I swear. Have you ever used npm? or may be bower? do you like their style of dependency management?
&gt; I'd love to use it on Windows like this Check the website. Not sure when it happened but windows now has an installation executable. No option to NOT add it to the PATH but oh well. And why would anyone want to install phpunit globally? That is just asking for trouble.
I don't share their views. It starts with me thinking serif-fonts are not easy on the eyes. Composer is not using one, so that doesn't matter here, it's also really subjective I guess. They are design fonts, they are good for headings or slogans, maybe for books that are read on paper, not on a screen, but not for body copy in websites if you're not writing a text-based RPG of some kind. Not saying they are wrong, they are very right regarding text-column-widths, line-heights (Composer's site could need a bit more line-height), constrast etc. Composer's site gets most of this right. Another thing is, I understand that it's favorable to keep a site as fast and easy as possible thus reducing design down to a bare minimum, but there is simply no valid reason to do it, since technology evolved just good enough that it doesn't really matter if we send a 2kB CSS together with our 400kB response content. No device, smaller or larger, using any kind of todays internet supply technologies, will care. https://getcomposer.org/doc/00-intro.md Look at this wall-of-text. No one wants to read that. You hit CTRL+F to search a key-word why you've been on that site at all and ignore the rest. The fonts need to be a bit larger, the letter-spacing could be a notch higher. Increasing page-width isn't the same as increasing text-column width, I was thinking more about placing some SVG illustrations left or right, an icon for stuff here and there, some colored lines that separate stuff, a fixed navigation can't really hurt, separating categories/grouped blocks of text through full-width boxes with different background-colors etc. What I am also missing is something like: **You're new? Never used composer? Want to get started? 5 simple steps to get you running!** Yes, play a bit with buzzwords, make it look like it's already popular as fuck and not like it's written by some debian package author that didn't update the site since 1995 and optimized it for Netscape Navigator. What is this when you hit "Getting Started" and you're presented a book, full of unimportant information coupled with some important ones when all you wanted was simply knowing how to structure your project right now when you want to use Composer. This is not me talking, I know very well how to install composer globally without even reading the docs, this is experience talking, experience of programmers who simply have it worse than me and don't get things just as fast. Programmers that are scared of reading whole books just to get to know a really simple and small technology. Keeping it at 7 lines of CSS doesn't look _smart_, _small_, _easy_, _lightweight_ or anything to other developers, it mostly looks _lazy_ as there is simply a lot of more potential for a project that....well...completely rules the PHP world right now. Composer should look like something official, something big, something where developers see the site and say "I can't get around this, it's the biggest thing in the PHP community". Composer is PHP's future and it should reflect that on the website in my opinion.
Another side note: The Symfony console component is a library and does not require the Symfony framework. 
Totally off topic but I'm intrigued, what database did you use and what clustering method? I recently set-up a mySql cluster using Galera, my first use of Galera and I'm very impressed.
Oh I see, Forge does the deploy process but I don't think the does the "last 5 builds" part, health checks etc. Is it easy to configure with Forge?
That is passionate! I feel you man.
Galera is awesome. I have used it. I am personally in love with Percona XtraDB under Galera. Have you tried it? I am using HAproxy for this one though. As that one clustering technology could be leveraged with the entire stack of Kamailio + FreeSwitch + Nginx + Mysql (Mariadb) + NodeJS (for WS to facilitate browser based SIP calling).
I see, is it possible to use Envoyer without Forge then? Sorry for all the questions :P I'm curious and pretty new to deployment overall.
It's adding PATH for the composer installation directory, yes, but not for the global `vendor/bin` directory and that is the main problem. I want global phpunit because of 2 reasons 1) The pecl-extension is just as global (At least if you have the PHP install dir in your PATH) 2) I hate it adding a ton of requirements to my dev-dependencies, especially large things like PHPUnit. It's annoying for everyone that installs your project and forgets `--no-dev` in `composer install` I rather have a global PHPUnit installation. If it breaks for you, you can still install it locally and run `vendor/bin/phpunit`. It's not only for phpunit, it's for many development tools like phpcs, cs-fixer, symfony-project-bootstrap commands etc. I like it when I don't have to think of them every time I start a new project, I like it when they are _just there_.
\#itsdonewhenitsdone
Yup! You just add a server and it generates a key for you. Add that to your remote server and tell Envoyer where the public directory is and it will handle everything for you. You don't even need to be using Laravel. You can delete the existing hooks (IIRC, besides doing a git clone, it only does a composer install) and add whatever you want.
Speed. The lack of a parallel download mechanism in core. Something like: https://github.com/composer/composer/pull/5293 . The plugin works great and really makes it go much faster.
In a good or bad way? 
In cases where you don't have interfaces to typehint against and you've got typehints against concrete classes or you're doing instanceof checks, you could cause a B/C break by messing with the class inheritance going the deprecated class extending new class route. So aliasing is one way around that.
Agree on this.
No I haven't tried it, I'm primarily a developer (ironically I do PHP, GO and Python professionally like yourself, and many more for personal hobby style projects) but I have been using Linux as my desktop for over 10 years so always had a keen interest in the server/dev ops side of things and my new position I'm the sole guy so I'm doing everything end to end. 
In way there are no comments in composer.json because of json - it's my biggest complain. I have lots of situations when I would like to comment why do I use this version of library and not buggy another.
I've not experienced that before, it's always been a legitimate conflict for me, just difficult to track down the cause
Does anyone know if PHP-Fig (or any other community) will make an Interface class for DI?
A `composer install` on a project that depends on my library will not even look to see if my library has a lock file or not. My lock file only affects developers working on my project, not those that depend on it. Am I understanding you right?
Tell me something, if there were an ncurses based CLI interface for Composer, would that add value?
Actually you're wrong, if you --prefer-source with specifying a single or a set of packages when you install or update, it will fetch the source for those only. This is very useful when you have lots of dependencies and don't want to fetch everything from source but the packages you own. It might be documented another way, but I'm actually using this, at this very moment, and it works like a charm.
ReactPHP and PHP-PM are great ideas, sadly most frameworks can't run with it because they have too much global state and will pollute your context.
&gt; corporate PHP users who don't understand what it is lol what?.... wow
Did you do `composer require symfony/whatever` to get that error? If so would doing `composer require --with-dependencies symfony/whatever` work instead?
I have been having trouble where a third party library we use (from a popular payment processor) requires 700,000 lines of dependency code. For our small use case, we don't ever hit any of it. It is listed as a requirement, which makes everything slower. In composer it is very difficult to say "I know package A requires package B, but we don't ever want to install it.". So either your autoloader is an extra 5000 lines longer adding up to 1-2ms per script run, or you have to manually edit a load of stuff every time you run composer update. The composer.json/composer.lock system is clunky at best. I think it should act more like apt, which is an industry standard for package management. 
I met someone who's company just started using PEAR like a year ago, and I believe they also just upgraded from PHP 4.? to 5.4 around the same time.
We have a custom deployment tool that interacts with our Github Enterprise server. Basically, we select the prod tag and click build, and then push it to all of our loan balanced servers at once. In the background, it's basically just checking out the tag, runs build scripts, and we're done.
*faints
- it's very sloooooooow - it eats a lot of memory - managing constraints is a hell - in fact, all composer's dependecies system is a hell
The non-development computer has internet access and we can usually get to most of the tech websites (SO, etc). we need to. Anything we need to download and put on our development computers needs to be transfered via CD though.
* Error messages are often misleading ¯\(°_o)/¯ * Using private VCS repositories is a pain. i.e. when a package loads a private VCS the project itself has to define the repository again. (⇀‸↼‶)ᕗ 
No, it will not. What I was talking about is that pushing the `composer.lock` to the GIT-repo is the only way to avoid people suddenly having newer versions of libraries that you didn't test yet that might break. I had this problem a while ago, I developed Tale Jade and added a dependency, my own config library Tale Config. First I had a library style where I prefixed all privates with `_` and then I changed it in all libraries except Tale Jade, including Tale Config. Well, as it also used a trait that accessed `_options`, suddenly Tale Jade users were [reporting about errors](https://github.com/Talesoft/tale-jade/issues/67) that `_options` is not defined and I wondered why. The reason was pretty simple, what I did was requesting `talesoft/tale-config:~0.1`, which will also update to 0.2 on `composer install`. I didn't push the `composer.lock` (See [this commit](https://github.com/Talesoft/tale-jade/commit/ca286b6e1b5045de09e6580ff2981539cfa519a0)) What happened? I changed Tale Config from `_options` to just `options` and released a new version 0.2, thinking that Tale Jade would still use 0.1. It didn't. It updated to 0.2 for users that just installed Tale Jade and they directly got errors. Notice this would've also happened with `^0.1`, it only wouldn't happen with `0.1` which would require a change of the composer.json each time I actually _want_ to update. Simple solution? Push `composer.lock`. That was the day I started always pushing it. You can always pull your own library, run `composer update` to update all dependencies, test everything calmly and then re-push the new `composer.lock`. It's one of the things composer actually does really well. Learn from my experience with that, trust me (Or run into the same and _then_ learn from it, you choose haha)
Agreed. Troubleshooting/debugging could be a lot easier with proper messages.
It would make things fancier and fancy isn't too bad mostly, but it wouldn't really add _value_. If you add an interface for something like $ composer configure and then you get an ncurses based interface where you can e.g. define composer globally and add important PATH stuff, that would add value. But it would also require one more step to get your environment up. If you're thinking about creating a *nix-installer with ncurses that gives you a step-by-step installation for composer where you can choose to add to PATH or not, that would add value I guess. Personally I don't need fancy interfaces, but that's really subjective, I guess it could help a lot of people. $ composer init -i or something like that could call an interactive interface to create your project or it could be default and you disable it with `-n` or something. $ composer manage could open an ncurses-based interface that allows dependency-management, adding of auto-loaders etc. (Basically, the `edit`-version of `composer init` with ncurses)
thanks for your understanding. it's hard :-/ what about including something like Prestissimo for speeding-up the thing? what about memory consumption?
A very detailed analysis. Point noted. Hold the thought, let's see if I could turn this into a side project.
Maybe it should just change its name to Conductor then. 
Ha ha... I apologize for it. I used to have a gf back in the day. Her name was Novia.
Look up xdotool for controlling firefox with bash... Scrape the site structure, get a sitemap with the full URI for each page. Dump the list into a text file. You can send firefox a URI, wait, then send keystrokes to save as webpage... put that in a loop based upon the text file. There may be better ways, but you'll get "the complete" webpage-- static content with manipulated DOM additions, linked files (css, js, fonts, images, etc.), and I think the cookies. I'm not sure on that last one. Hope you have a big hard drive. Last time I did this I had 5,000 copies of an unusually large minified and concatenated main.js file... extrapolate that in your mind for elements on every single page like the CSS and header/footer assets.
&gt; I have been having trouble where a third party library we use (from a popular payment processor) requires 700,000 lines of dependency code. To me the problem lies with the library and not Composer. A piece of shit library is a piece of shit, there is not reason why Composer should become more complex and try to tweaks things to fix a problem at a library level.
Our system is split into maybe 6 repositories some of which flare pulled into our 'core' product. Things like an api client, a console management tool etc. These have been built separately to our core since the core is on a legacy framework and doesn't use composer for autoloading so we built these as separate library projects to pull into as a composer requirement on top of the framework. The problem we have is that these systems are pretty large by themselves too, and when we want to edit them we don't want to make changes inside of the vendor folder because we want to have feature branches etc for testing, and code reviews etc. Here is an example of our composer.json (with some stuff swapped out) { "version": "0.2.41", "repositories": [ { "type": "path", "url": "/var/www/vhosts/company-console" }, { "type": "path", "url": "/var/www/vhosts/another_project" }, { "type": "vcs", "url": "git@bitbucket.org:company/barcode.git" }, { "type": "path", "url": "/var/www/vhosts/shop" }, { "type": "path", "url": "/var/www/vhosts/api-client" }, { "type": "path", "url": "/var/www/vhosts/control-api-client" }, { "type": "path", "url": "/var/www/vhosts/company-utils" } ], "require": { "unionofrad/lithium": "1.0.1", "swiftmailer/swiftmailer": "5.4.*", "robmorgan/phinx": "0.4.6", "vlucas/phpdotenv": "~1.1", "erusev/parsedown": "1.5.2", "neitanod/forceutf8": "~1.4", "tedivm/stash": "^0.14.1", "mdx-dev/li3_newrelic": "dev-master", "ianrodrigues/barcode": "^0.6", "company/shop": "self.version", "company/api-client": "self.version", "stripe/stripe-php": "3.*", "company/control-api-client": "self.version", "company/another_project": "self.version", "bugsnag/bugsnag": "2.*", "mandrill/mandrill": "^1.0", "omnipay/sagepay": "~2", "omnipay/paypal": "~2", "nesbot/carbon": "~1.13.0", "elasticsearch/elasticsearch": "^2.2", "tightenco/collect": "^5.2", "aws/aws-sdk-php": "^3.18", "naneau/semver": "^0.0.7", "jsq/amazon-es-php": "^0.1.0", "company/utils": "dev-master", "sunra/php-simple-html-dom-parser": "^1.5" }, "require-dev": { "codeception/codeception": "*", "fabpot/php-cs-fixer": "1.1.*", "company/Console": "dev-master", "company/control-api-client": "*", "company/shop": "*", "company/api-client": "*", "company/another_project": "*", "php-console/php-console": "~3.1", "filp/whoops": "^2.1" }, "config": { "vendor-dir": "libraries" }, "autoload": { "psr-4": { "Project\\Shop\\": "../../../current/domain.com/src/Shop" } } } This is how we have it locally, so that symlinks are setup. But when it comes to releases; this means we have to swap out all the repositories for the correct paths on BitBucket, and we also have to replace the required versions with "self.version" so that the same version always gets pulled in. We have tried many things, but nothing is simple with this sort of setup, but without this setup, its painful
 &gt; You then don't need to track your dependencies in your codebase (which some would consider bad practise). I'm not calling bs or anything, but I was wondering if you happened to have any links to articles or case studies handy on how that's worked out in production environments? I'd certainly love to read more about this from people who have done it before. (And conversely, how the way I'm doing it now could backfire) To be honest, what keeps me up at night is that [something like this might happen with Composer](http://www.theregister.co.uk/2016/03/23/npm_left_pad_chaos/), and suddenly none of my projects can build. I am also cognizant that Composer is essentially a free site, with no SLA, so any such outage that might happen could be lengthy in duration. Then again, maybe I'm just overthinking things. 
Laravel... Easy. (Eloquent is the Orm)
This can be resolved by using _comments as a key in your .json file. It's not optimal, but it's something. There you can use an array of strings to put your comments.
Put your rsync command in a shell script so you sync to a release directory and the swap to symlink from www-&gt;release1 to www-&gt;release2. The script will only take 5min to write and test, but it means you have no downtime and nothing breaks if rsync cuts out halfway through. 
Codeception testing library will let you interact with pjs. This could be used to do the scraping as well
I usually just build my routes out with Slim. For ORM I flip back and forth between Doctrine and CakePHP's ORM. I've been toying with the idea of building my own ORM as well.
ORM: [Doctrine2](https://github.com/doctrine/doctrine2) Router: [FastRoute](https://github.com/nikic/FastRoute)
&gt; So remove as many unknowns as you can. Sometime you just can't. This is not something like "cut PSD to PNG", for example I use sketch - it just does that for me and i can spend time on some different activities. But sometime you have much more complex design and you need to work my hand. And in 90% of time you need to estimate something before you can have any understanding of full scope of work. 
Thank you! I'll see what I can do.
We currently use composer for deployment. The deployment script uses "composer require" to require specific commit IDs from git. Unfortunately sometimes i get weird error messages because that commit is not on the dev-master or whatever branch. But maybe i'm just using it wrong. 
Installing multiple versions of the same package, I understand this is mostly a Php thing, but it would be very nice to do. Now you are mostly forced to use old versions of packages, because there is a package with an outdated dependency or you simply get stuck.
&gt; But maybe i'm just using it wrong. Sounds like you probably are. Assuming you're deploying a typical app, you should have composer.lock in your VCS, and your deployment scripts should simply be running `composer install`. That ensures you get the exact commits that you've tested against. 
I like the [Klein](https://packagist.org/packages/klein/klein) router; I haven't had to use an ORM yet.
Router: [FastRoute](https://github.com/nikic/FastRoute) or League route (based on FastRoute) ORM: I don't use a ORM (too slow and inflexible). I prefer a flexible and performant query builder like: [cakephp/database](https://github.com/cakephp/database)
Composer could/should just prompt you if it needs to upgrade extra packages to update the one you requested. Not optional upgrades, just required ones. Pretty sure apt does this.
ORM: Doctrine 2 Router: Symfony Routing Component
I'm a fan of [RapidRoute](https://github.com/TimeToogo/RapidRoute), it's faster than FastRoute and I prefer the API. ORM-wise, I'm not a fan of Active Record but as I've been using Laravel a lot I've obviously been using Eloquent a lot too which is pretty nice. Haven't really found time to explore alternatives yet. 
Likely more relevant numbers: https://seld.be/notes/php-versions-stats-2016-1-edition That is, unless you're actually interested in what PHP version people run their WordPress installs on, rather than what the modern ecosystem uses.
Huh well look at that. Yeah, Laravel is a great php framework with a adoption by large companies. It supports a bunch of external entities like mq and nosql out of the box, and eloquents relationship model and query builder are dead simple. Eloquent got autotexted 
It's mostly old abandoned projects just sitting out there that no one looks at anymore. Not a big deal.
I could imagine an ncurses interface being handy at the moment you do a require without a version number and it actually lists the versions available and if they are compatible with your current selection of packages.
Things like what happened with npm are rare and honestly, you should have it in mind, but not worry. If you really want, you can point composer directly to each repository. Additionally, the `composer.lock` contains the commit hash of each package set up using `composer update` so you should never get different commits when doing `composer install`. Better yet, you don't even need to commit your `composer.lock` if you have your version constraints correct (generally that's `^1.0.0` to receive anything that is version `1.0.*`). If a library doesn't version with backwards compatibility in mind, you probably wanna rethink using it anyway. Additionally, you really should *never* include your vendor dir. Your code reviews become horrible, you git repositories will start growing exponentially.
Router: FastRoute ORM: None, I use an optimized query builder.
&gt; It's mostly old abandoned projects just sitting out there that no one looks at anymore. Not a big deal. Not the case: https://w3techs.com/technologies *"We include only the top 10 million websites (top 1 million before June 2013) in the statistics in order to limit the impact of domain spammers. We use website popularity rankings provided by Alexa (an Amazon.com company) using a 3 months average ranking."*
ORM: [Propel](http://propelorm.org)
Speed, mostly. Takes about two years to install phpunit and its dependencies
I've been happy with Laravel lately on some pretty large-scale projects, and Eloquent was surprisingly simple to grasp for my first experience with ORM. I can't speak to alternatives which is why I was hoping people would be willing to discuss their objections rather than simply hitting downvote. Laravel also integrated very smoothly with Elastic Search on a recent project. 
Have you used RapidRoute and Laravel together? If you are, why not use Laravel's built-in router? I'm just curious.
I must be in the minority of people that got a kick out of the composer logo.
*^choo ^choo*
How to create a local WP dev site in 5 seconds: composer create-project roots/bedrock
Building your own ORM is a lot of work, but totally worth it. I did exactly that after getting frustrated with Laravel's and now I've got something that's exactly what I want 
I use ELK stack for this (plus some other Elastic products). 
You do realize that what you have there has nothing to do with local development, right? Bedrock is an alternate WP project structure. You would need to use Trellis (and Sage) in order to create a full Vagrant development environment using Bedrock. To add to that, Bedrock is 100% compatible as a `tj` starter template. Your argument is invalid.
For a standalone router, I like [Phroute](https://github.com/mrjgreen/phroute). It's based on FastRoute, but has a better API and a lot of feature parity with Laravel's router: * Groups * Filters * Support for configurable dependency injection resolver ORM: Eloquent.
I've never opened my server to attacks this fast before! Thanks!
Just woke up. Give me ~8 hours to process this and reply...
&gt; You would need to use Trellis (and Sage) in order to create a full Vagrant development environment using Bedrock. You do realize that Trellis and Sage are respectively an alternate Virtualized server and theme, and aren't necessary in order to make Bedrock itself work, right? Any basic LAMP/LEMP stack (see: [PuPHPet](http://puphpet.com)) outside of Trellis will do just fine. There's no argument here. Your spam post is just garbage.
Nowhere did I say you couldn't use any other LAMP/LEMP stack. I was only stating that Bedrock is in no way comparable to this tool. Bedrock would be better compared to [Sprout](https://github.com/ezekg/sprout), our starter template which takes some inspiration from it. You're creating a straw man for no reason and I don't understand where the negativity is coming from. All I'm trying to do here is share a tool I've built.
Care to elaborate...?
&gt; Have you ever used npm? do you like their style of dependency management? Only slightly more than I'd like a bullet to the head. There've been days I'm not sure it'd settle out in that order, too.