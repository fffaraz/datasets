Actually, sitting on 16 answers, it is 50/50 between speed and type hints
As some already said, it's nothing like what happened with npm. Besides the difference of intend (with left-pad, the author meant to delete his packages), in a matter of minutes forks have been pushed under nelmiobackup to which Packagist nelmio links have been redirected to: almost no builds have been broke and unless you where on dev-master, all tagged versions where available very quickly after the incident. &gt;Shrinkwrapping your apps with all the vendor code can be useful and is a common practice in the NPM world. I don't get it. If there is one think I would reproach in npm, it's that the shrinkwrapping system is unreliable and a pain to use. With composer always have your composer.lock which is the equivalent of shrinkwrap. And if nelmio packages were not cached it wouldn't make a difference as the source code would not have been found anyway (before backup packages were being used).
With all of the recent PSR-7 middleware talk, I was reminded of a related issue that I previously encountered: ServerRequestInterface#withAttribute() allows you to attach data to a request which could be useful to middleware further down the chain, so why does ResponseInterface not allow the same thing? I had a case where I needed to inform the outer middleware to do something if the response contains a certain flag. Since there is no withAttribute() for responses, I had to use a HTTP header instead. This seems inconsistent. Was withAttribute() intentionally not included in PSR-7 responses?
IIRC you need the readline extension for this to work, which means you almost certainly can't get it working in Windows
I believe he was talking about modern frameworks that you should use for newer projects... Cake doesn't really make the list for that in most peoples' minds these days.
I created an Angular 2/Lumen starter kit. Uses Webpack for bundling. Bootstrap 4/Ng2 Bootstrap. It comes pre-packaged with Angular 2 (page|component|directive|service|pipe) generators. Link: https://github.com/jaesung2061/anvel Some (light) documentation at http://anvel.io. The website is exactly what you get from installation.. It should be enough to get you started if you are familiar with Angular 2.
Well, safe to say we all seem to love Jordi and everything he's doing for PHP. I'm taking him out for a whisky or three in a few weeks. 
Oh man, recently my work moved to new servers but our master git repo was still on our old servers. We also had an old no longer used repo on that same old server. Well today when migrating the git repo from our old server to the new server I accidentally cloned the unused repository without realizing it, so it was about ~2 months of changes behind. Thinking everything was good I deleted my local copy to re-clone from scratch just to have a fresh clean working copy, made some changes and commited and pushed the changes, and then deployed them. Well...I just deployed 2 month old code, and had deleted my local copy with the changes since then...Thankfully I had a backup from a week ago and deployed that temporarily just to get things working, and my coworker had an up to date version of the repo which we then used, but when I realized what happened my heart sank. (Sometime after the initial clone I did the old servers were physically taken down so the actual good master repo was no longer accessible by ip...so I couldn't just start over &amp; clone the good repo - in retrospect I could have avoided all this if I planned ahead and migrated before the day of the actual servers getting taken away)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] [Php programmer makes awesome discovery and the fellow php programmers cheer on...](https://np.reddit.com/r/lolphp/comments/4lzhye/php_programmer_makes_awesome_discovery_and_the/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
It works without readline, extremely awkwardly; It's just not interactive - you may as well write your test code to stdin of php process.
phpdbg is a thing ... var_dump is not a debugger :)
It would have been interesting to see how junior/senior dev answers differ. It would also be interesting to see the same questions answered by sysadmins ... It's going to be the case that a lot of people don't actually make the decision about upgrading; It's either in the hands of seniors or sysadmins.
Use "weight". The heavier items sinc to the bottom, and lighter items float to the top. We use it in Drupal, and once you know it, it becomes pretty obvious just by looking at the values. 
The response is more or less a status code, headers and string... no need for attributes. &gt; response contains a certain flag At least in Slim you can execute stuff before or after in a single middleware... if not, use a header and remove it later.
Thanks! Happy to hear that the video helped you and happy to hear it was easy to follow. At the moment I am working on a Solid Principles series. I would be happy to create a video for dependency injection. Please subscribe to my channel and you will get notified when I do the video on dependency injection. 
&gt; they have strong opinions too. Strong opinions or Philosophy, when coming from experiences and ones own mistakes are good. Strong opinions and Philosophy coming from groupthink, shallow understanding, little or no experience with the target use cases, lead to flawed reasoning and lead to development that is 'all over the place'.... &gt;Have you ever participated in an RFC thread? If you talk back to these guys, they will stop responding after a while. Or gang up and attack you with down votes and personal attacks...And everyone will give a pass, because you have gained enough hate because you don't play along with the circlejerk.. 
I would suggest not to clear the cache in production. Deploy the code in a new folder, warm up the cache and then change the symlink to point to the new folder. See how Capistrano handles deployments.
&gt;phpdbg is a thing.. ..that no one uses.... 
um, isn't that the whole point of distributed repos? sht happens... it got deleted, but there are other copies... whew! restore! Done. No?
Please don't draw conclusions too hastily ;) Edit, allow me to explain myself: Not every company, or industry, or institution, has Q&amp;A, staging environements, TDD, critical production servers etc. If I was working in avionics, banking, the medical industry (or anything that requires strength of the production systems above everything else), it *could* be a failure. Even there, not every production server is critical. But i'm not. Sometimes letting interns do mistakes on real-life situations (granted it is not the end of world if they mess up) is the best way to teach them. I've been working there 8 years ; not so much a failure for the "institution" after all :)
I created a tool called Sunscreen (initially wanted to call it 'Condom - don't go in without protection' but thought some may deem it a little crude) which is aimed to give you a leg up when working with dependencies in a ports and adapters fashion. Link: https://github.com/jenkoian/sunscreen The gist is when you install something with composer it will automatically create a wrapping interface and an adapter for the library (if supported or easily guessable). Still early days, pre-alpha if you like, but some peoples may find it interesting.
It doesn't really matter how much Laravel and Rails do share, and how authoritative /u/utotwel/ is. What is more important, and what I tried to emphasize - Laravel is not hurting the PHP ecosystem, no matter what is happening inside Laravel's ecosystem (and that is natural for PHP, as language encourage to write reusable solutions, and just to make wrappers for framework integration, not vice versa). But Rails - do hurt and influence on each aspect of Ruby ecosystem.
I would argue that legacy HTTP servers are really mature (NGinx, Apache, etc...) and thus are really efficient when it comes to security when compared to fun, modern and sexy new software. They also are a lot more stable. They come with numerous advanced features about security, file serving, performance etc etc etc, it would take years to get as fast and as feature-rich than those servers, that's, in my opinion, a very good reason not to implement the HTTP protocol within FPM itself. I think that everyone should keep one and only one job, and remain isolated from the rest, it's best for security and reliability. If you loose FPM because it crashes, your chain takes over, meaning that your reverse proxy cache will serve cached stuff on error, then the HTTPd will continue providing support for things that are not plugged in FPM or serve nice error pages, etc...
Can someone explain how I'd set two different headers in two different middlewares in the same response with request-only middleware? $queue[] = function(ServerRequestInterface $req, $next) { return (new Response())-&gt;withHeader('X-First', '1'); }; $queue[] = function(ServerRequestInterface $req, $next) { return $response-&gt;withHeader('X-Second', '2'); //How do I get $response? } I don't see the advantage of this, can someone explain? --- Edit: I figured it'd be something like this: $queue[] = function(ServerRequestInterface $req, $next) { return $next($req)-&gt;withHeader('X-First', '1'); }; $queue[] = function(ServerRequestInterface $req, $next) { return $next($req)-&gt;withHeader('X-Second', '2'); }; but it seems pretty backward (X-Second will be set before X-First in this case) What does this apply to? Can someone point me to some obvious advantages of this pattern?
&gt; See the list of all libsodium constants in the reference. In every case, \Sodium\FOO will be transformed to SODIUM_FOO. WTF? They want to add *more* global constants!? That can't be right... I don't care if the extension is installed by default, but namespacing is a *good* thing.
&gt; "Why not ***just*** parse HTTP requests" Go for it. Tell us how it turns out. I'm sure that handling HTTP requests can't be that hard. After it hardly took any time at all for projects like Nginx to become mature projects that are stable. /s aka - https://signalvnoise.com/posts/439-four-letter-words
I always use `ordering`. I saw it in Joomla and (surprisingly) it made sense to me. 
+1 for the surprise. 
what do I need to change to get it running? We seriously worked with outdated software, that´s why I also got problems with PHPmyAdmin.
[Here's FastCGI implementation in 275 lines of Go](https://golang.org/src/net/http/fcgi/fcgi.go). Why should HTTP implementation using some HTTP parsing library be much larger? There's no need in all that nginx features as you'll have some front-end server anyway. Jetty, Tornado, Unicorn, Gunicorn don't compete with nginx.
Look into the `mysqli_*` functions or PDO. I would recommend PDO but `mysqli_*` will be a bit more familiar coming from `mysql_*`.
I agree. It'd be somewhat nice if it was something like DateTime, where you can either do: $dateTime = new DateTime(); or: $dateTime = date_create(); Being able to do either of these would be nice (using the examples from the RFC): $sodium = new Sodium(); $key = $sodium-&gt;randombytes_buf($sodium::CRYPTO_SECRETBOX_KEYBYTES); $nonce = $sodium-&gt;randombytes_buf($sodium::CRYPTO_SECRETBOX_NONCEBYTES); $message = $sodium-&gt;crypto_secretbox( $plaintext, $key, $nonce ); $key = Sodium::randombytes_buf(Sodium::CRYPTO_SECRETBOX_KEYBYTES); $nonce = Sodium::randombytes_buf(Sodium::CRYPTO_SECRETBOX_NONCEBYTES); $message = Sodium::crypto_secretbox( $plaintext, $key, $nonce ); But then we're having a small bikeshed here. ¯\\\_(ツ)\_/¯
You rather switch to PDO and burn everything you've read about `mysql_*`-functions, **ever**. It was removed because it's the primary entry point for people to start bad coding practices. It was pretty unintuitive to escape any user input in it and it had quite a few problems and missing features (e.g. prepared statements). It's just a big, fat security risk using any of the `mysql_*` functions nowadays. Small example to get you started with PDO: //Connect $pdo = new PDO('mysql:host=localhost; dbname=database_name', 'user_name', 'password'); //Prepare with Parameters (?) $stmt = $pdo-&gt;prepare('SELECT * FROM `users` WHERE `name`=?'); //Execute and pass parameters ('YourUserName' will be the `?` above, it will be automatically escaped) $stmt-&gt;execute(['YourUserName']); //Fetch all found users into an array $users = $stmt-&gt;fetchAll(); //Fetch only one user (or null, if none found) $user = $stmt-&gt;fetch(); //or fetchObject(), fetchColumn(), see PDOStatement Docs) //Iterate found entries foreach ($stmt as $user) { //do something with $user } 
I hate the dual implementations of object/functional datetime (i feel like there are other things that are like this as well?) I'm not sure I would recommend it as a superior solution to having properly namespaced, object oriented functionality.
&gt; I'm not sure I would recommend it as a superior solution to having properly namespaced, object oriented functionality. Sure, they're a marmite item, but imagine that your key/nonce are from a database (for some reason), so you only need to call the secretbox call: $message = Sodium::crypto_secretbox(...) vs: $sodium = new Sodium(); $message = $sodium-&gt;crypto_secretbox(...) I skip an object creation because I don't need the object for just one function call.
Yeah, there's much other stuff, such as `$stmt-&gt;setFetchMode(PDO::FETCH_OBJ)` as well as overriding the statement class, but people coming from `mysql_*` usually aren't that deep into OOP, or they'd use PDO already, that's why I didn't mention it. But you're absolutely right, your snippet is basically default in all libraries already (Wondering why it isn't PHP's default)
Use `mysqli_connect()`.
No, the bootstrap first includes `../vendor/autoload.php`, sets up your environment (php_ini values, checking for extensions and requirements), initializes important services (database, session) based on the passed config and at the end calls your front-controller/module-dispatcher/router(that in turn calls a front-dispatcher of any kind) **public/index.php**: &lt;?php $config = include(__DIR__.'/config.php'); include '../includes/bootstrap.php'; **includes/bootstrap.php**: &lt;?php include '../vendor/autoload.php'; Db::connect($config-&gt;db-&gt;host, $config-&gt;db-&gt;user, $config-&gt;db-&gt;pass); Session::start($config-&gt;session_name); //Use some PSR-7 implementation or something alike $kernel = new HttpKernel($config-&gt;kernel); $kernel-&gt;add(SomeMiddleware::class); $kernel-&gt;add(SomeOtherMiddleware::class); $kernel-&gt;add(SomeRouter::class); $kernel-&gt;dispatch(); `config.php` is in public to ease up deployment with different configurations later on. You could always restructure that, load `config.php` in `bootstrap.php` or use some cool config abstraction (Something like [Tale Config](http://github.com/Talesoft/tale-config), it's not that stable, so don't use it in production, just look at it to get some inspiration)
Yes I agree Laravel and Rails share some philosophy similarities, but the solutions we come up with in light of that philosophy are often different.
It won't help even slightest.
Yes, error reporting, unlike other stuff, is rather essential. One practically can't go anywhere without having an error message in case of error.
I assume using HTTP 1.x is more or less as complex as FastCGI if using an appropriate library. HTTP server libraries provide a fairly [simple interface](https://www.gnu.org/software/libmicrohttpd/tutorial.html). It should be even simpler as there's no multiplexing (i.e. fastcgi request ids).
Here's a good [overview and introduction to PDO](https://www.sitepoint.com/re-introducing-pdo-the-right-way-to-access-databases-in-php/) and how to replace mysql functions with it. And [another older one here](https://www.sitepoint.com/migrate-from-the-mysql-extension-to-pdo/).
If they go truly want to go through the changing of the Sodium namespace to nothing and make it all global? Hell no! Leave libsodium as a PECL extension. If I was a libsodium dev I'd come out and tell them, "No. Keep the namespace or go to hell. It is namespaced for good reason update your backwards coding standard." Instead the libsodium dev wants to break all the old code just to get it into PHP core? Ugh. I've always wonder why there were so many damn functions for things that would clearly make more sense and/or be more intuitive as a damn object. Apparently it is the broken coding standard.
One of the best resources for succinct PDO examples and explanations is [PHP The Right Way](http://www.phptherightway.com/). It's also a must-read in general if you're new to PHP or haven't written PHP in a while.
Honestly, the code above is more informative and helpful than these indeed succinct examples you linked to. I don't see how phptherightway could be any great resource to learn PDO
mysqli is not deprecated and if you're migrating from mysql it's a lot less hassle than pdo.
At this point I feel like we should make our own backwards-incompatible PHP fork, with ~~Blackjack and Hookers~~ Scalar Objects and functional name/parameter/namespace.
You see, all this deprecation business is *probably not for adding i to the function calls*. Besides, your fear for PDO is groundless. If you care to face the facts, it's [PDO a lot less hassle than mysqli](https://phpdelusions.net/pdo/mysqli_comparison).
Why is your config in the public directory if it's not meant to be accessed directly? For cases like that, I typically have a separate `setup` folder
Because you can have the same app ran on different spaces with different configs. /var/www/vhosts/site-a/config.php /var/www/vhosts/site-b/config.php /var/www/vhosts/site-c/config.php and the _index.php_ of them would then bootstrap from something like /opt/your-app/includes/bootstrap.php Just a dirty example.
I like the namespace myself, but a few people in the internals team already expressed "this violates our coding standards and we will vote no"
Could you make that a secondary voting option? For example: **Main vote:** Should libsodium be added as a core extension? **Secondary vote:** Should libsodium be placed globally or within the `Sodium` namespace?
Again, the idea is not to replace nginx. The idea is to replace nginx to php-fpm interface from fastcgi to http. From my understanding the front server should not open 10k connections to fpm, it only needs a single one. There's no 10k FastCGI connections, right?
trello
Did you bother to check the examples by the link provided? 
Granted it was only added in 5.4 so don't feel too bad. That was what, 2011? 2012?
Holy crap is that awesome. Thanks for sharing!
Then make libsodium an external extension like MYSQLi is. Best of both worlds, I say. Extenal extension is basically a bundled extension but requires external deps to compile. See http://php.net/manual/en/extensions.membership.php
Do you mean commit your vendors tree? 
I think that https://github.com/php-pm/php-pm might be a good solution in future, as it's a lot faster and way more suitable for container usage.
- Backwards compatibility - mysql was removed because of security-problems and it was lacking a ton of common mysql features (Prepared statements, transactions and rollbacks etc.). People also didn't know how to use `mysql_real_escape_string` (apart from the fact that it was a pain to write)
Why are you always so quick to get aggressive? Relax buddy - it'll be alright.
In fairness, the draft was updated since GP wrote their comment.
Thanks for dealing with them for us and being willing to compromise :) Unlike quite a few others in the thread by the looks of it, I'd rather have something guaranteed-available in core via a global name than extension-only but pretty (though all else being equal, I'd prefer the namespaced version too)
I thought we were talking about dingo/api here, got confused for a second
It was 2012, but still :)
There is an essential difference between these two functions that makes isset dangerous when it is used to test whether an array contains particular key or not.
Because FastCGI is less feature-rich than all HTTP 1.0/1.1/2.0 features. It would simply be more work. I had the same discussion with PHP-PM with guys that blindly assume that you would want to replace apache/nginx/lighttp etc, which is simply not the case. However, in the case of PHP-FPM it's probably just as pointed out above. To be honest, I'd rather want to move PHP-PM to a fastcgi protocol as its easier to implement. HTTP has too many features that are actually not necessary, only if you want to handle real http clients like browsers.
I thought this was Dingo API, got excited for a second. :(
Object oriented uses exceptions on error, function based returns false on error. It's different coding styles. I don't like using exceptions for code paths that happen in the normal flow of things, so I prefer function based. if(($zone = timezone_open($tz)) &amp;&amp; ($date != .....) { //use date from user } else { //use system default } Writing that with exceptions is not as clear.
It might hit home a little better if there were side-by-side, as close to real world, examples shown using middleware and not using middleware. Hell, find a couple of popular repositories on Github and demonstrate how much code is needed for both. Conceptually, middle-ware is easy to grasp. But taking the concept into reality can often get lost in translation.
I think it's safe to say you're making your life harder than it needs to be. Your tests should not need to be so fine-grain; if you want to go that deep, I'd suggest a holiday first that doesn't end until you've counted the sand on the beech. 
For async architecture perhaps. It's also not yet production ready, so be careful. I noticed /u/marcjschmidt is here; I'm quite sure he is not advocating it's use for anything PHP, but rather specific use-cases but I could be wrong.
&gt; Here's FastCGI implementation in 275 lines of Go. Here is a llama https://pbs.twimg.com/profile_images/269279233/llama270977_smiling_llama_400x400.jpg Why? Because PHP is not written in Go so the llama makes as much sense in the context of PHP as offering code written in Go. The other part of this... &gt; It is based on C structs As-is PHP one would imagine... PHP is written in C; unless you count HHVM implementation, which is still not in Go Also as /u/Danack mentions HTTP is much more complex than FastCGI... So It would take more code, especially if we rewrite PHP in Go (which I have to admit I'd love to see attempted, just for a giggle).
Did you know you could proxy forward to apache running mod_php and get PHP over HTTP. I'm not stating it's a good idea, but it might make you happy to learn this can run as a proxy that nginx forwards to...
"or you're doing it wrong" - the sure sign of a good opinion
Thanks for your work Scott
&gt; http://psysh.org/ As an alternative, there's also [boris](https://github.com/borisrepl/boris).
The author is named Dan Ackroyd!
&gt; think about the difference to the user. There isn't one. Sure there is, you just have to rise past looking at *syntax* and consider *semantics*. * Namespaces are an *explicit* grouping mechanism which is widely understood by tooling and by reflection. In contrast, the underscores of EXAMPLEEXTENSION_A_B_C are just an implicit and weak convention. * Namespaces involve less typing, because you can `use` (or alias) them once, and type the shorter portion afterwards. But with naive prefixes, you're stuck typing them forever. * Namespaces handle deeper hierarchies much better, and (being mixed-case) avoid issues where word-boundaries within a single organizational unit are hard to scan. * We should all know *from experience* that underscoring everything creates ugly and obtuse APIs, promoting prefixes seems like trying to roll back the clock and go back to PHP4-style code. &gt; And to complete me argument realize that `\Sodium` is `also` a global! [...] So if globals are bad, that would be bad too. That's a specious argument, because `\Sodium` is **ONE** global, instead of a string found in *several dozen* globals. As a namespace, it has an explicit hierarchy below it, clearer ownership, and mechanisms to avoid collision and confusion. 
I suspect that I'm missing part of the point of the post, because I don't see who or what's being "harmed" to be quite honest. If you are going to install many things globally, you should expect them to clash now and again. If you need Laravel stuff for your projects, you should require or require-dev the Laravel stuff in your project. That way you keep project-related things in your project, it's why people use Composer instead of PEAR these days. If you have a bunch of packages that you want in most or all your projects, then simply make a package that depends on all of those packages. If those are going to clash, then you're SOL either way, if you really need all the clashing packages. I get that composer global require, if it does what I think it does, is best avoided, so I get that the person on Github is calling for its deprecation, but I don't know about "harmful". This is like saying that putting orange juice in your car's gas tank is harmful, or writing a PHP application with no functions or classes is harmful.
Maybe something like "sort_weight"?
&gt; I don't see a reason to try and force php to make BC changes to include this package. I don't understand what you mean by this. It seems to me like all the less-reasonable demands are being made *against Sodium* ("drop your namespace"), rather than against the PHP core. Adding new default-stuff runs a risk of a collision breaking existing code in the wild either way, whether somebody out there has their own single `\Sodium\*` namespace or whether they have their own constellation of SODIUM_* constants/methods/functions... But the namespace is a heck of a lot easier to fix or work-around via aliases, and is a lot closer to what I consider "proper, modern, well-made PHP code".
Oh, the kids have "great ideas" here we go again. Just read the damn HTTP spec even for 1.0. If you do a HTTP server, you need to do it all, according to spec. Because there are tens of thousands different HTTP clients that are varying in features and how they work. And a lot of them actually do weird shit. And you have things like HEAD, OPTIONS, PUT, DELETE, and all over the place. Hell, try handling an upload of 1-2GB video. Oh, y'r saying don't use the HTTP server we just built to do that? So, I need to proxy it through a nginx server that is actually capable of doing that, has buffers and caching and makes sure we don't run out of memory? So, I ask you again, what is the point then, if we starting to hurt on even fairly simple stuff? I'm not even talking about DOS and DDOS possibilities here. There is a reason HTTP servers take decades to build and harden and feature proof. Have you looked at what HTTP/2 does? And why would I need a HTTP 1.0 or 1.1 server, if all my clients are 2.0?
If you're going to downvote, at least read through the end! 1.5 pretending it's a 2 and hoping to transition to a 3. 1.5, say what? I don't know, don't care if you're jerks and don't think it matters, I don't think the FIG should be disbanded and the FIG has produced some very solid recommendations in significant portions (and occasionally, in entirety) of just about every accepted PSR to date. TLDR; I would surmise that deep down 3 was the original goal, even though significantly more 'verbal' voting members continue to say otherwise, I think the subconscious urge to be so public from the get-go was a desire to become the standard bearers of userland, and that's fantastic, it's welcomed. (could be wrong, just looking from the outside in). My only grief with the PSR's and FIG, with the community looking at you as a 3, is that you didn't take the time to find out what was best (cough PSR-2), you went with the 'might is right' mentality from a very small subset, and in some cases (it seems) just unmitigated personal preference. We adhere to several of the PSR's and will likely continue to do so, but with all due respect, I would urge FIG to stop hiding under the "we're just doing this for ourselves, but you can look if you really want to" covers, and take up the mantle and responsibility of 3. Be comfortable going back and re-evaluating accepted PSR's and find out what's BEST (logic, syntax, UX), not what happens to be the most widely accepted at that moment. Then take the time to implement these personally (among the panel) and see if they stand the test of time, then publish and tackle the next obstacle. I appreciate the time you guys (and gals?) have spent developing the PSR's and think, despite any shortcomings, the community at large has greatly benefited from them. Written purely for the encouragement of (and a desire to see) FIG embrace 3, and embrace it well.
I particularly enjoyed the "I need perfect English" bit...
&gt; a blog post like this would immediately get an interview if it was handed to me, [minor] syntax errors or not OP edited his post, but these were not minor syntax issues. He was using a variable that didn't exist in an essential way, and clearly trying to `fclose` a string instead of a file handle. PHPStorm warns you about this sort of thing, and it sticks out like a sore thumb to me. Maybe if you're in a position to hire people, you're in a position to review code; how do you feel about having to review code that quite clearly cannot work and has obviously not been tested even once? I know that this is just a blog post and the point of the post is clear even with the errors (I guess this is why people are downvoting me: they feel I'm overreacting and my remarks are uncalled for), but are you really sure this sort of thing doesn't at least give you pause when an applicant hands it to you? Keep in mind, I pointed him to his glaring errors and *he still missed most of them and kept them in his post*. I may not have been polite, but I stand by my words.
Why do we need http 2.0 to forward requests from front server to fpm? 
Very simple website (static website,...) -&gt; all the logic in the controllers and templates More complex (blog,...) -&gt; put logic in services who directly access db etc Even more complex (small ecommerce shop, ...) -&gt; proper domain model that gets used by the controllers directly, persistence separated Business app with long expected lifetime -&gt; service layer in front on domain model, controllers only receive DTO, know nothing about domain Of course this is just a guideline, it all depends on how complex your project is and how long you expect it to live.
You made the argument about execution order -- which I think is entirely invalid. It's a stab in the dark to make a point that didn't need to be made. 
I mainly meant a middleware should never be more than a few lines of code because if it's more than that it should be calling out to other classes which do the heavy lifting. **Those** classes should be in a re-usable package which any middleware implementation can trivially use.
I'm writing a "simple" database intranet tool to maintain a collection of a couple thousand files (the largest of which is maybe 2.5kb). Is it *really* awful or just *kinda* awful practice to store the contents of each file using base64_encode() to just blindly dump/retrieve the file contents (not worrying about SQL injection/errors/charset)? We won't ever need to search by the contents of the file, just compare different versions. (assuming the impact on system resources are unimportant) edit: to ask for suggestions
Oh wow... This person sounds like they might actually need you to help them get crayons out of their nose... On the flip side of your comment &gt; I like a relaxed atmosphere in a work place but serious makes you wonder if anyone seriously applies. I like a reasonable client or employer, but laid back is usually a problem... You lay-back on a beech, you lay back at night. If you lay-back all the time you'll just end up soft around the middle, not being great at getting stuff done.
If you go to the website attached to the job not only does it need a redesign but also throws up a JS popup when you go to close the site. I could never work for a company who did this.
Somewhat contributing to the discussion, I still use ? in URLs so that I can track where traffic is coming from. For example, I might link to my site: http://starcresc.com?ref=reddit.com and it would show up in Google Analytics for me so I could see where the traffic is coming from. The ? works in Wordpress and Joomla both with and without the SEF urls enabled so its a handy tip for anyone that is interested.
I also like the "you only know PHP if you know "certain framework" line 
Hmm. Working out have nothing to do with looks, but with your healthy.
&gt; If you need Laravel stuff for your projects, you should require or require-dev the Laravel stuff in your project. Well said, now convince the horde of people installing installers (heh) with 10k derived dependencies via `composer global`. &gt; I get that composer global require, if it does what I think it does, is best avoided, so I get that the person on Github is calling for its deprecation, but I don't know about "harmful". It encourages the old style PEAR-alike installation, which is what we strive to get away from when dealing with legacy cruft. `composer global` is not that bad, but people that are new to development in PHP didn't experience the same annoying behavior, and may be tempted to repeat the same mistake again. In an ideal world (where things work for more than 5 minutes), we could just have individual docker containers, each with one particular tool/project installed: docker exec -it phpunit phpunit docker exec -it my-framework install-zeh-framework-whatever Sadly not viable to everyone yet. 
maintained by a single author? ORLY? http://contributors.rubyonrails.org
The way I read it, the libsodium maintainer is trying to get his package included in core php, but to do that he has to drop his current namespace and use the global namespace to adhere to the php core style guide. I think it's kind of silly too, the namespace is much much better, but that is the reality of the situation as of right now. PHP Core seems to require the change, and that's what people are discussing. My reply is just pointing out that the discussion about the namespace change is seemingly a related - but different - discussion that also should be had.
See to me, I see laid back as in, no formality. Like if a company expected me to wear a suit to sit in an office on an average day while dumb buzz words get thrown around I would turn them down. I just like to get a list of what's needed of me and get down to it, the less formal the better. To me software development works best when I can feel free to do as I wish as long as I hit targets.
Make it framework agnostic. Otherwise, Laravel is a fine choice, or Symfony, or Zend. If you don't know CLI, learn it, it'll be good for you and is not that hard. Typically every framework uses composer now.
No, reading the whole post it ended up being polite and balanced. Didn't seem angry or ragey at all
Actually looks like it's the UK based on the website, but doesn't surprise me too much.
Totally agree. I wish that "composer global" installed each project in its own isolated directory as the GitHub OP suggests. Would be so much better than current situation. Lately I just clone the repositories down into some "tools" directory and add them to my `$PATH` manually.
That's a moot point; if that was a requirement then you wouldn't be using either technique as they both involve cleaning up resources at the end the scope. Although, relying on RAII will cleanup resources as soon as they are no longer referenced -- so while somewhat unpredictable (if you can call it that) it would be very close to ASAP. 
This is sort of what I was looking for, thanks!
You just don't like to work for dicks then haha. Me neither ;)
Can you explain what this does exactly? I'm genuinely curious. 
I remapped some of the keyboard shortcuts (select line at cursor, duplicate line, move line + more) to match Sublime Text so there is less mental overhead when switching between the two.
From the article: "HTTP Middleware is by no means a new concept, either in general, or to PHP.".
Pretty cool, I've been working on something extremely similar to this, except with Silex and focused in usage for microservices.
The only two modifications I make to stock PHPStorm is CMD+Shift+P for run any action (from CMD+Shift+A), and turning off OSX's mapping for the CTRL+Up and CTRL+Down keys so I can do CTRL+Shift+Up and CTRL+Shift+Down for expanding multiple cursors. Essentially, I wanted to mimic the shortcuts I was most familiar with and used the most. Other than that I keep things pretty stock. Couple of small tips I have found useful: * Use CMD+K (commit), CMD+T (pull) and CMD+Shift+K for git actions * Under Preferences &gt; Language &amp; Frameworks &gt; PHP &gt; Debug uncheck anything to do with force break, it can be confusing when you hit a breakpoint on something you didn't set it on (especially if you end up using external PHP include paths) * If you're like me and use PHPStorm in a full-screen window, don't be afraid to bump up the font-size, you have a large editor space so take advantage of it (and your eyes will thank you for the lowered strain)
Haha you're being facetious with the second one, right?
Writing an entire PDO driver instead of an API wrapper is generally something that isn't done nor justify the means. I'd say your first solution with the iterator is a good solution, and I personally would prefer it over a PDO driver, it would also be the expected solution since you're working with RESTful.
This is a good place to find commonly used shortcuts https://www.jetbrains.com/help/phpstorm/10.0/keyboard-shortcuts-you-cannot-miss.html and code formatting CTRL + ALT + L (adding SHIFT shows options). 
Sorry I didn't formulate my question clearly enough. I don't want to write a PDO driver - I only wanted to implement the class with the same design pattern PDO uses (call execute() to prepare stuff, and the provide fetch() method).
I usually do this as you suggested with Iterator. I.e. the user doesn't know about the fetching in middle of the iteration. Keep in mind that you'll need to wait for each request to finish, so there will be delays in the iterating.
Double shift: search anywhere. Ctrl + F12: Skeleton of current file. Ctrl+ curly braces: jump to the start/end of the code block. Install the gitignore plugin. Quite helpful to me. You can bookmark code with ctrl+ f11. In project settings, define different scopes. Libraries, themes, modules, core, etc. You can execute find, replace, etc just inside scopes. There are lots of actually useful tips in "did you know" from the help menu. 
Some shortcuts I always use: * Ctrl+D: duplicate current line/selection * Ctrl+B: jump to declaration * Shift+Ctrl+N: go to file * Click a line number: select whole line * Ctrl+Q: documentation popup * Double-press Shift: search
Yes, I know, it works exactly as you described. But what I like about fetch() is that it supports various fetch styles. But now thinking about it, I can achieve the same with the Iterator - I can supply the fetch style to Iterator's constructor, and current() will then return the element in the desired format (array, class, etc).
Get a magnifying glass. Like a really big one.
Watching this series: https://laracasts.com/series/how-to-be-awesome-in-phpstorm
What actions do you use?
In addition Ctrl+N searches for ClassName. Together With Shift+Ctrl+N and you never will touch mouse again when navigating through project. 
Not necessarily a phpStorm only feature (net beans and eclipse have it too) is using a mouse with back and forward buttons to jump around the code.
Every action you click on in the menu's are available in this menu. Also the configuration options in the menu's are added and the commands that are made available through extra plugins. Some handy ones: - New scratch file - Toggle presentation mode - Project - New - Commit - Debug - Refactor - ... 
They say they don't want to re-invent the wheel but they ignore that re-invention is advancement and specialization and thus optimization. Most devs are just lazy and will downvote me now.
For TDD it's more about theory, the logic and steps pass from programming language and tools freely. So you don't need a PHPUnit specific book. The best TDD book I've read is https://www.amazon.de/Driven-Development-Example-Addison-Wesley-Signature/dp/0321146530/. Read that then start applying those processes to your development flow.
I think that the point that the author is trying to make is that `isset` and `empty` both can hide potential typos, refactor mistakes, and other mistakes. For example, $config = []; ... if (isset($cofnig['some_key'])) { ... Will go through and run perfectly fine, whereas $config = []; ... if (array_key_exists('some_key', $cofnig)) { ... Will throw a `PHP Warning: array_key_exists() expects parameter 2 to be array, null given` making it easier to spot the typo. Same thing with something like: $foo = 'bar' ... if (isset($fooo)) { ... vs $foo = 'bar' ... if (null !== $fooo) { ... The first will run without any indication that there's a typo, while the second will raise a `Notice: Undefined variable`. I'm not sure if I completely agree that, because of this, empty and isset should be avoided or used more sparingly. I tend to use `isset` more often than `!== null` or `array_key_exists`, especially the latter in cases where I want to quickly check if a key exists in an array I'm not sure exists, such as: function foo (array $options=null) { if (isset($options['bar'])) { ... 
You're answering to a post made by a spam account :-)
ctrl+alt+shift+n -&gt; find symbol
When working with objects, no need to type `$this-&gt;` just type the method or variable you want Actually you almost never need to type `$`
The concept of HTTP Middleware for PHP has nothing to do with HTTP Middleware elsewhere. It doesn't reference headers or a protocol; it's part of the application; the name doesn't fit.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
And I'm still right :) Damn^I^need^more^coffee
I'd recommend Growing Object Oriented Software by Freeman and Pryce over any other testing book. I haven't read any PHP or PHPUnit specific testing books.
I don't like clutter so I don't have too many open tabs at once (Tab closing policy in settings - I set mine to 5 tabs open at once) and then I mainly use: * Recent files dialog: **CMD + e**: * Find a class: **CMD + o** * Find any file: **CMD + shift + o** Reformat code (having set your coding standards :)): **ALT+CMD+l**
I will upvote you because being lazy is actually a great quality.
/u/jeffreyway did an awesome set of PHPStorm intro videos which cover everything from decluttering, to theming, to keyboard shortcuts, to templates/macros... it's basically my goto for "tips". And it's one of his Free series...https://laracasts.com/series/how-to-be-awesome-in-phpstorm. I use probably... 70 or 80% of what he mentions in there. Also the plugin ecosystem is a bit of a goldmine if you're happy to wade through it to find stuff. The Emberjs plugin is great if you use Ember, the Doctrine Annotations is a must have if you are using annotations, and the .editorconfig plugin saves configuring code styles at a project level (just reads the editorconfig file and applies them).
The question is, why shouldnt they use PHP frameworks? What are the alternatives? 
The IntelliJ IDE platform comes with a builtin productivity guide, which was really helpful for me. You can find it in the Help menu "Help -&gt; Productivity Guide". It helped me to discover new features, even after using PHPStorm for a long time, because it no only lists the productivity features, it also shows you some statistics about your usage of them.
I'd upvote him too, but I cba.
Press ctrl-w a few times to select progressively larger amounts of text. E.g. if the cursor is in the middle of a variable, pressing ctrl-w once will select the variable name, twice the whole variable, three times the statement, four times the method, etc. Press shift-ctrl to reduce the selection size. 
I tend to agree as well. Disk space is cheap. If you download the library once on a machine that shares projects (VM or host, either or) then install it in each locally and reap the benefits of a well structured project - not to mention composer will cache so each subsequent install is not a problem. Also development environments should mimic production as much as possible so if you're installing composer globally in production then you have more worries to think about.
On mac, it's option-uparrow and option-downarrow 
Don't worry, it reflects good on libsodium: no one's doubting its usefulness/quality, so we're bound to go for the more superficial/aesthetical bits.
If you use symfony, install the symfony plugin. Amongst other things, it give you autocompletion and validation for services, parameters and annotations, and adds the route names to 'go to symbol'. Install the PHP Annotations plugin too if you want the use-statements for annotations to not be marked as 'unused'.
&gt; Better yet update the standard to allow for namespaces. Gee, that would almost make sense, wouldn’t it? Namespaces have only been a thing for, what, going on seven years now?
Ctrl-w expands the cursor text selection incrementally and intelligently based on where the cursor is set initially. It's great. I use it quite a bit to grab strings. Ctrl-alt-I fixes indentation of everything highlighted. typing /** and then pressing &lt;enter&gt; will generate a doc block for the function below it
&gt; I had a case where I needed to inform the outer middleware to do something if the response contains a certain flag. This is why I don't like PSR-7 so much......people are using it as a global variable pass information from one part of their application to another. If you do need to pass global information around like this, it would be better to do it in a 'clean' way, rather than hacking a Response object to store application state.
On find I always select the "Preview occurrences" option, makes it so much easier, I don't know why it's not a default.
I've always just used "order". 
It's such a minor thing but such a convenience for me. Once I am all tested locally and ready to push files up to a staging environment for further testing, before committing my final, merged changes to git, I go into the Version Control window. Then I just select the changed files (including any that have been removed) and right click and select "Upload to..." and select the deployment server I want the files on, in my case our staging environment. This saves me having to root through the entire project or waiting for a sync to occur. It even deletes files on the server that are showing as removed in the Version Control window. 
My most used shortcuts (osx): 1. SHIFT+F6: Rename variable, classname, filename, ... 2. ALT+F7: Find usages 3. CMD+SHIFT+O: search file 4. CMD+O: search class 5. CMD+ALT+◀️, CMD+ALT+▶️: Jump cursor in history (very useful) 6. CMD+W: close current tab 7. CMD+SHIFT+W: Reopen last closed tab (custom shortcut) 8. CMD+click: Follow definition (of variable, class, etc) 9. ALT+Enter: Quick fixes (initialize constructor arguments to class fields + setter, update docblock etc) 10. CMD+N: Generate stuff (getter, setter, overwrites, implements) 11. CMD+D: duplicate line 12. ALT+SHIFT+⬆️, ALT+SHIFT+⬇️: Move current line/selection around (especially useful if you have used CMD+D before) 13. CMD+F: Search in open file 14. CMD+SHIFT+F: Search in files
&gt; Why Most Web Application Developers Use PHP Frameworks? Because it saves time and time is money.
Not PHP specifically but web server related, I'm using the Let's Encrypt project to create a certificate for the 3 domains on my VPS as per instructions [here](https://certbot.eff.org/#debianjessie-nginx)] but I'm a bit lost when I get to the webroot bit. I'm using nginx on Debian Jessie.
Can you provide an example or further explanation of the 'clean' way that you suggested to pass information between middleware?
Robert C. Martin made some very interesting tutorial videos on TDD on https://cleancoders.com/videos (Episode 6.1, 6.2, 19.1 and 19.2). The example are in Java, but it is very easy to translate to PHP.
JetBrains has a nice PDF reference card you can print out: https://resources.jetbrains.com/assets/products/intellij-idea/IntelliJIDEA_ReferenceCard.pdf
People like him remind me why I love RES' 'tag user' feature. It helps me remember [who shouldn't be taken seriously](http://i.imgur.com/l6KLecm.png)
I'd love to see a good working code inliner: $closure = function ($a, $b) { $funca = function ($a, $b) { return $a + $b; }; $funcb = function ($a, $b) { return $a * $b; }; return $funca($funcb($a, $b), $b); }; Inlined: $inlined = function ($a, $b) { return ($a * $b) + $b; }; This is *NOT* a weekend task though. It is long/painful and full of weirdness all over the place.
&gt;Please ask this question on /r/phphelp . oh my bad :)
http://stackoverflow.com/questions/228164/on-design-patterns-when-to-use-the-singleton Simply because the OP doesn't know when to use a Singleton doesn't make it "stupid". :/
And what makes you say that?
Regardless, has nothing todo with the job at hand. Should not be asked.
Will we ever be free of the plague of "copy stuff from other people and wikipedia" blog posts? EDIT: The first thing I thought when I saw this was that it's from an article by /u/nikic I read ages ago. Little did I realize this is actually the same exact article from 3 years into the past. Come on dudes, check the timestamp before posting to reddit.
I always use a framework regardless of what I am building, big or small. So I cant answer how to do it with out one as it would turn into you structuring it like a framework.
 &gt; I think this is something that should be implemented in the PHP interpreter, probably when it gets a JIT engine. Agree, but meanwhile, we'd need something to make this work (critical path for doctrine 3, for example) &gt; Anyway, a cool idea, but I don't see a way to do it well. I gave it a shot, then abandoned due to lack of time. Most of the work involves simply filtering out which functions can be inlined (pure functions only). Most of the work involves following the steps of [reckti-ct](https://github.com/google/recki-ct)
Maybe even better: Lisp-like macro support. Perhaps it's possible through the new AST extensions....
MVC Framework and this is why I use Phalcon. [edit] Apparently MVC isn't a problem and Phalcon isn't a library.
This is true. Every single time one of these articles comes out the author is thinking about one particular project of theirs that went very wrong. So instead of pinning the problem on poor planning they turn to "everything must be maximum extensible!" The problem is that not every project needs to be designed like a massive enterprise level application. The failure, that I see over and over again, is a tendency to over engineer an application and not recognize that over engineering is JUST as bad as under engineering. 
A lot is possible via AST. Heck, we wrote https://github.com/Roave/BetterReflection, which allows to replace entire methods during autoloading :-P
Never heard of it myself. There's not that much commit traffic on Github, few stars (lol), and it's basically all done by one guy. One man projects are typically worth avoiding for project dependencies. What if he loses interest or dies? If I'm working on a project that matters, and nearly all of them do, I don't want to be in the wilderness. &amp;nbsp; Would it really be that hard to migrate to Twig? It's really nice. Twig already has a huge userbase, so most problems you encounter are a quick search from being solved. &amp;nbsp; &gt; it's likely that you will encounter some issues That's from the author. Not on my project, thanks!
Taking from the database example from the author, you can use Singletons and still have multiple connections to one or more databases. Singleton, like other design patterns, are tools, and as developers we need to understand our tools and when to use them and when not to use them. Instead of parroting "Never use Singletons", it should be "Use Singletons sparingly".
They're going to con him into working 20 hours of overtime over the holidays but act like it's totally cool because the boss got him pizza those 3 nights. ...not that I've ever had that happen to me.
One day, at the twilight of humanity when there are only a handful of us left someone will make the last shitpost before they die.
It's just a prank bro!
I wouldn't personally do it with a logger as in a complex logging setup you might need multiple instances. But there are a variety of situations where you'd want something like it. (e.g. Loading fixed immutable configuration from disk that should not be modified while the process is running is a very common use case.)
[removed]
So I needed a message queue for my Symfony application. I actually already put RabbitMQ into production using https://github.com/php-amqplib/RabbitMqBundle, but found RabbitMQ to be somewhat overkill for what I needed, and am having memory management problems with it. So looking into the alternatives I saw that lots of people are building message queues on Redis. The most popular PHP package seems to be https://github.com/chrisboulton/php-resque, but the project hasn't been maintained in a while and the code is slightly outdated (no namespaces, global state etc). I've also been using https://github.com/thephpleague/tactician in my app so wanted a solution that integrated well with this. This is hot off the press and I'm yet to put it into production so proceed with caution, I'd like to hear anyone's opinion or constructive criticism though, and maybe even get a pull request :) I built it for Redis but it is backend agnostic, I'd be interested to see it implemented with a different storage adapter! 
As stated in [From STUPID to SOLID](http://williamdurand.fr/2013/07/30/from-stupid-to-solid-code/), the rule of thumb is "use your brain". To go further down the road, have a look at [Object Calisthenics](http://williamdurand.fr/2013/06/03/object-calisthenics/).
&gt; Very few good places for them come up. They exist is the point and when they do they simplify things when working with other people. I didn't say "RUN AROUND AND USE SINGLETONS ALL THE TIME". I linked to a stackoverflow thread that happened to have a number of answers with reasonable use cases.
Singletons aren't stupid, but defining them in the way most tutorials do is. Most DI containers are producing singletons by default, but aren't structured in a way that screw you over. 
This: https://plugins.jetbrains.com/plugin/7622?pr=phpStorm The EA Inspections plugin is just so good!
&gt; "Valid" is such a loaded word. What do you mean by it, specifically? There are plenty of reasons why even the noted uses of singletons are undesirable. It simplifies code for handling immutable global states (and is functionally no different than using constants) and handling resource contention. The problem with the line of argument you are using is you now need to explain why constants, under no circumstances, should be permitted in programming since one of the use cases is literally just to organize constants (loaded from configuration) into logical groups to simplify management/loading of those constants. 
&gt;and when they do they simplify things when working with other people. Do they? How so? If you're using it as a means to exchange data between code they write and code you write that's probably a very bad thing, and if you aren't what makes a singleton vs something else that much harder to document for others to use?
There is a company registered in the UK with the same name, so it's possible that they're UK based. Having said that, the director's address is in Panama https://beta.companieshouse.gov.uk/company/08583694 They also posted the same ad at [remoteok](https://remoteok.io/remote-jobs/17362-remote-senior-php-programmer-with-good-logic-analytics-understanding-of-statistics-natural-breakthroughs-research) For posterity https://i.imgur.com/SgWy3fS.jpg 
&gt; Do they? How so? If you're using it as a means to exchange data between code they write and code you write that's probably a very bad thing, and if you aren't what makes a singleton vs something else that much harder to document for others to use? I was going to write a longer explanation but honestly... I'm not going to argue with a half a dozen people on the internet about singletons. There isn't a point. If you can't figure out the answers on your own, you shouldn't be using them because you clearly don't understand them well enough to do so.
Accept this one stipulates you being dumb for doing x over y and some times x is the fastest way to get the project done.
&gt; The problem is that not every project needs to be designed like a massive enterprise level application. This. I am so sick of these articles that basically belittle you into thinking that if you are doing it there way or the 2016 way you are doing it wrong. Not every project can be done 100% perfectly. If it could be, we wouldn't have jobs.
In my next release i'll try. :)
http://martinfowler.com/bliki/TradableQualityHypothesis.html
If you are interested in job queues in particular that are based on Redis you may want to look into [Disque](https://github.com/antirez/disque). Created by Salvatore (creator of Redis) for this very purpose. It's PHP library is [disque-php](https://packagist.org/packages/mariano/disque-php), which I developed 
ctrl-alt-shift-insert (yeah, really, press them all) and you get into a scratchfile, I used to use notepad++ for this, but now PHPStorm replaced notepad++ almost entirely when I found that shortcut. 
Thanks, I actually already looked into most of the different queue options including disque and your PHP client. I gave disque some strong consideration but for my purposes I preferred to build something which uses plain redis, which I'm using in other parts of my application - so I wouldn't need a whole new service. Other than that disque looks great, but for a plain-Redis-based message queue in PHP there aren't many good options at the moment.
Thanks???
It shouldn't be a try it should be a thing that's always done. Testing is crucial
The [Grumpy Testing books](https://leanpub.com/b/grumpy) are pretty good.
I agree. It's very good. However, it has a number of pedantic recommendations that I routinely disable. Otherwise, I find it generally useful.
Something like flysystem for managing domain names and virtual servers with various hosting companies. 
Well in the footer of the site it gives a UK address. But a Director in Panama looks pretty appropriate for the company described
It appears to be the same - I've actually never tried the middle mouse button due to RSI.
I had this book in english it's pretty awful like most php books at that time.
The root of your misunderstanding here is the presumption that constants are okay for configuration. *Can* you (mis)use them this way? Absolutely. But you *shouldn't*. Configuration is dynamic and immutable, whereas constants are static and immutable. It's a very big difference, with varying degrees of importance depending on your particular app.
 &gt; it has a number of pedantic recommendations And I keep suggesting new ones \o/
The art of saying nothing
 global $db;
I am part of that, yes. More snow cones are welcome, I won't stop anyway :-P
I might still have this book somewhere or the wife might've thrown it out. 
Ha! I would be terribly disappointed if you didn't like snow cones. Or didn't stick to your pedantic ways. (I can always ignore them!) Why, if it wasn't for the useful code you've written, I'd... never mind.
Ha, look what I found at the library: the mythical PHP 6! https://files.nytsoi.net/NEo0.jpg https://files.nytsoi.net/p9wa.jpg https://files.nytsoi.net/O9ST.jpg
The passwords you're sending via POST should be encrypted at the transport level using https, see: https://letsencrypt.org The way you are using password_hash() is the recommended way, yes.
I would change `__toString()` to include the leading `?`. Then add a new method to get the class name without the `?`. In general, I don't like using `__toString()` for anything other than debugging; I view it as subject to change. Thus I might also add another method for getting the class/type name as it appears in the function signature (with the `?`) and then update the description of `__toString()` to something generic like "Gets the string representation of the type" which might change over time. PS: Thank you for updating the reflection classes. I depend on them and they're very handy!!!
What's the procedural equivalent of this
You mean a build system like Ansible, just tailored for different providers?
I just threw up a little. It didn't help that the book pictured above was in a language I could understand...
Yeah, all serializers will be *similar* in terms of having certain mechanisms like normalizers. What annoyed me in the libraries I found: * inability to provide any custom logic, only what was possible in the configuration (this is mainly JMS Serializer's fault), * no possibility to register a simple handler for given target (class + direction) without declaring separate class or polluting entities with serialization logic (this is the Symfony Serializer case). Of course with PHP7 I could use anonymous classes, but still, any kind of "supports()" method is weird for me and I really don't understand why Symfony as a whole went with such approach, * it was written only for the specific purpose useful for the author without really solving a problem (no cycle detection, cannot extend with other formats, etc.). With Serializard you register a callable for given class that receives an object and operation context, you're free to control the process as you wish. The library does not get in your way any time, it only hides the "technical" details such as object graph traversal or detecting cycles. It follows the rule "simple is easy, complex is possible". I really recommend you to try it, I'm all ears for feature requests any will happily answer any questions.
I have done this...
Thankfully, it's been at least 5 years since I've used the global keyword. Probably about the last time I used `include()`
I use it with homestead, you basically need to add your your docker instance as a remote server in the settings menu then set php unit to use that remote server to execute. Googling how to do it with vagrant will be exactly the same as docker 
Awesome, thanks. Edit: Not sure if this matters but my application is a .NET application so I am not entirely sure letsencrypt is going to work. I'm guessing I can mimic the behaviour by encrypting it and encrypting upon arrival.
I still have drupal 7 projects where you pretty much need to use global once in a while.
Well, ain't that a blast from the bast. I started with PHP in 2000 at v4.0 when Apache's Server Side Includes couldn't cut it anymore. Good times sitting in my friends shed hacking up crappy websites and arguing on usenet. :)
Yes it is possible in companies that have competent senior devs. I have seen it in multiple companies. Hint: the software is the core of their business, they are not agencies. There is a lot of crap PHP out there, but there are also companies with competent programmers that value clean code very highly.
Not at all relevant, letsencrypt is just a certificate authority that issues certificates for free. This is handled by your web server (nginx/Apache), your server side application doesn't need to know anything about it. I'd strongly recommend just using HTTPS and not attempting to implement your own encryption.
Singletons are stupid. Even in that Stackoverflow thread the answer is completely wrong. It's really common to switch between logging to files, memory, sql databases and maybe different file formats as an example. The only valid point where singletons are okay is in an application that's not designed to interact with other applications (which can work and be successful, see WordPress or Joomla), but that doesn't mean they are well written. People just don't know that they are badly written, because most of the common users of these softwares can't code at all. Before you use a singleton, you're better off using a static class, anyways. Then your code won't be a mess with`getInstance()` every two lines. You start with a single entry point, e.g. `$app = new App($configFromWherever)` and do something like `$app-&gt;run()`. With good dependency injection and good access patterns you won't ever need any kind of singleton. You're not a monster for using singletons, but you're not having the best structure you could have. That's all.
&gt; Most DI containers are producing singletons by default This. Its funny how people here hate singletons but aren't aware that they've been using singletons all along! Symfony, Silex, Pimple (version 2 and later) defaults to a shared connection (aka singleton). Laravel even tells you its a singleton: App::singleton('foo', function() { return new FooBar; }); Singletons are useful. People should stop parroting what they've read from evangelists unless they know what they're talking about or they'll give the wrong ideas, like singleton is evil.
Totally misunderstood how all that works. Thanks for the reply. In terms of my current code I wouldn't need to change anything, all I need to do is implement letsencrypt on the webserver?
Thanks for clarifying!
Really? I thought with the "OOP isn't even necessary for this or that" resurgence of late that maybe some standards for reasonably "solid" procedural work had been established.
Some of these may exist, but I have a hard time finding them - Barcode Generation (It exists, but it's old, it should be PSR-4 compatible, on packagist and support all major code-types, 1d as well as 2d (e.g. QR) and provide a way to add own adapters and own code-types. Colors etc. should be configurable and it should work with GD and Imagick) - Server Management (Primarily Unix, would be a huge library, but it should be able to control a bunch of common *nix OS with a common interface, including resource monitoring, log watching, updating, installing software, extensions for e.g. managing your webserver over a common interface (With adapters for nginx, apache2 etc.) or your database servers, extensibility to e.g. also manage things like minecraft, teamspeak or factorio servers. Not an application, just a library to write your own control panel. - Working NTLMv2 authentication without cURL or other extensions (*nix has huge problems with it, but as far as I know it's possible) - Really good and extensible graphics library that can work with GD and Imagick, maybe even SVG. There are some already, but they mostly have fancy interfaces and lack some stuff (e.g. good color manipulation). [I am working on this already](https://github.com/Talesoft/phim), but I lack time for it, if someone wants to take over, tell me. - A faster SCSS and LESS compiler without invoking binaries - A really good socket library that can handle IP and Unix sockets with PSR-7 compatible streams and a solid event system based on [PHP Sockets](http://php.net/manual/en/ref.sockets.php) - Basic clients based on above socket library (e.g. Mailer, HTTP, XMPP, IRC) Thats all coming off my mind right now, I might add more.
Currently, as my webserver has no certificate (to my knowledge, I'd have to check with the owner), my POST requests are sent unencrypted. If, when using my browser, I have to hit the padlock to use HTTPS how do I tell my application to use HTTPS instead of HTTP? I know you've mentioned it will handle it automatically but is there any way to ensure it is on my end?
OOP is never _necessary_, it just makes things easier (not only easier to read and write, but also easier to maintain and extend) You can still write functions for common entry points into your OOP world (`create_request($method, $uri, array $headers): RequestInterface`, Composer can load function-files just fine. You just don't create global states of any kind, not with singletons, not with static classes, not with some kind of registry-crap. The only variable in your global scope should be your `$app/$program/$bootstrap` or whatever and maybe the required `$config` that was loaded before it.
I agree with this. `__toString` shouldn't be used to obtain the class name and the documentation should just state that. There should be a dedicated method to obtain the type-name as well as fully qualified classname or the corresponding `ReflectionClass` directly.
I though I was in /r/croatia
uh oh. I see you are new here. Do some research on how SSL works. And then get yourself a web server with a valid SSL cert and make sure requests on port 80 are redirected to 443. Besides, Google favors secure sites these days.
heh. Good old times :) Lots of memories looking at that style of code.
don't you still have to do something like spl_autoload_register(function ($class) { include $class . '.php'; });
Agreed. I'm the opposite of OP. In the early days I was uneasy or ignorant about the framework. My controllers were fat and the polar opposite of DRY. Now I keep reasonably clean controllers. No need to be fanatical but simplicity pays off in many ways. 
LOOK AT THIS GUY ESCAPING HIS QUERIES YOU AFRAID TO TAKE A RISK, BOY!?
Well, to be fair, at the time I don't believe there was any readily available dynamic website system other than PHP, with a heavy accent on "readily available". PHP was really accessible to all, and the availability of nice scripts helped.
That book was the main argument given for naming the latest version PHP 7.
&gt; Yes it is possible in companies that have competent senior devs. I have seen it in multiple companies. If with the most competent senior devs out there, it always comes down to the business needs, When do they need it and how fast do they need it and what does it need to do? I have worked with some really awesome senior devs and I have worked with some really crappy ones. At the end of the day, if the business is harping down there neck to get feature X out or they loose clients A,B and C - that dev will do what ever it takes to get the jazz out the door. So believe me when I say this "practice" this concept of 100% solid, dry, testable code is impossible in a business world. Can we get 80-90% sure, with a lot of pressure on the business people to give us the time to clean up the code, to remove the legacy clutter and such. But in actuality, its more like 60-70% solid, clean, testable code. We all have our "I would like to do ..." But then the business trumps that with "we need to do ... " Oh and by the way, the examples I gave are companies where the software IS the core of their business. 
Risk? What do you think magic quotes is for? There's no risk!
How about you stop taking everything so literally?
I have also been at two, and the one last year was better in terms of talks/details (more code oriented), but the one this year was better in terms of inspiration. Purely for PHP improvement it's certainly not the right conference, I think it is more about getting new perspectives and it is usually best to go to talks about topics in which you are not an expert. Sure you can theoretically learn everything by yourself at home, but a huge conference has the advantage of many different topics which give you some insights in very different areas and actually being able to discuss it with people who are there with you. The workshop day was also quite interesting.
That was probably the best selling one, but there were actually a tonne of books that were either entirely or partially about PHP 6 — I went through Amazon and counted them up for a punchline in a talk a couple of years ago, and I think the final count was somewhere around 20 (albeit some of those were probably translations of other books, and some were newer editions of older PHP 5 books that just mentioned PHP 6 in a single chapter as a "here's what's coming" type thing).
Why don't you write your own function to get the duration? I would take a few wav files, see how long they are in duration, and compare that to the file size. Then calculate a ratio of duration to filesize (duration : filesize ). Then write your function. You'll just need to do a little googling to find how to find the size of a file with php.
Have you even tried? * http://www.mcpressonline.com/programming/web-languages/easily-manage-wav-files-with-php.html * http://www.techaspirant.com/php-code-to-find-duration-of-an-audio-file/ * http://www.getid3.org/ * http://snipplr.com/view/285/read-wav-header-and-calculate-duration/ * https://stackoverflow.com/questions/3069574/get-the-length-of-an-audio-file-php BTW Please post such questions on /r/phphelp .
Uh .... 
md5? hashing? What are these words? You mean you can't just insert the password into the database?
I use [exiftool](http://www.sno.phy.queensu.ca/~phil/exiftool/) to get metadata from pretty much any filetype. It's a pretty amazing program. It's not PHP, but it should be in most Linux repos, and covers every common format with a heap of useful metadata fields. Use the -j switch to have it output in JSON so you can parse it into a PHP array.
One of my aunts got me a php 6 book for Christmas... shit, 6-8 years ago. It was basically just php 5 but just completely full of errors. I actually joined a #php IRC channel to get help with my code and was absolutely slaughtered for my incompetence until they found out I was learning out of a "php 6" book and then they just felt sorry for me. It's also how I learned about using @ to suppress errors because every example used them liberally causing my code to fail silently and just aggravate the hell out of me because as far as I knew I was doing it all right.
What's this `$_GET` thingy? Is that to get the original name if you've screwed up `$name` somewhere else?
Anyone else having this issue right now?
You can contribute if you want to.
 use func Sodium\randombytes_buf as randombytes_buf; use const Sodium\CRYPTO_SECRETBOX_KEYBYTES as CRYPTO_SECRETBOX_KEYBYTES; $key = randombytes_buf(CRYPTO_SECRETBOX_KEYBYTES);
did anyone took an screenshoot?
It sure is. &gt; Expired: Thursday, June 2, 2016 at 7:59:59 PM Eastern Daylight Time
Yep.
Is this satire?
Whoa. Thanks for this. Will be using it from now on
if that could be accepted, it would be really great. I really really really doubt that it ever would be. the default should probably be without immutability though.
where does phil have a high opinion of himself? I've followed him on twitter for awhile now, and read some of his posts, but certainly not all. I didn't get that impression. Can you point it out to me?
I thin the watered down `inmutability` is atrocious. I think a more usable approach would be that HttpMessages (Response and Request) should become inmutable after being sent or received and completely modifiable during the building process. Once they are inmutable they should throw exceptions instead. Example public function actionInde($request, $response) { $request-&gt;withHeader(...); // throws exception $response-&gt;withHeader(...); // modifies the $response object iself. } The main usability would be when dealing with apis and communication with third party servers, it would be natural messaging. public function actionOauthLogin($request, $response) { // get data from a third party server $apiRequest = new Request(); $apiRequest-&gt;body-&gt;write(...); $apiRequest-&gt;withHeader(...) -&gt;withHeader(...); // etc. $apiResponse = $this-&gt;apiClient-&gt;send($apiRequest); // at this point $apiRequest and $apiResponse are read-only // we can parse now the $apiResponse-&gt;body and read the data // to know if the login was successful and use that on the $response } 
File size doesn't directly scale with duration
Should probably post to /r/lolphp...
tou·ché
Yeah, the latter: I think it was my "what's new in PHP 5.4" talk (so more than a couple of years, I guess — sorry!), and the whole PHP 6 thing was still recent enough that it had to be addressed. (I think the joke was basically that the PHP 6 project had produced more lines of books than lines of code.)
I don't get it. Why is "secure.php.net" a thing.. as opposed to use.. php.net uses SSL?
well it makes sense that the `$request`can't be edited once received and the `$response` can't be edited once sent.
Wasn't quite available on shared hosting servers at the time as much as PHP, at least in my experience.
I fixed it. I ordered the new certificate today and never got around to installing it.
We have lots of mirrors that are hosted by third parties, secure.php.net lives on the master php machine that the others rsync from.
&gt; POSTing passwords and hashing. // Hooray for super duper secure password transfer. // Don't touch this! $password_entered = md5($_GET['password']); $password_stored = md5($userobject-&gt;password); if ($password_entered == $password_stored) { echo 'yaaay, you logged in! good job!'; } (hint: No. Just no.)
=&gt; is out of the question, the ambiguity is real here :) yield $x =&gt; $x * 2; This currently means yield x*2 with a key of x. 
wiki.php.net is still broken for me
People also still use global :)
That still doesn't explain why php.net itself doesn't have SSL?
Indeed, but now it's just one require in index.php, not dozens of includes.
mm.... what? Why it so? We don't have any square brackets around. So why this is ambiguity? Just because for decades in PHP `=&gt;` means $key=&gt;$value? updated I see... sorry... I forgot that generators can yield key/value... and in that case even parentheses can't help anything... 
[Here's a bit of non-exhaustive history](https://www.phpsecure.info/SearchAdvisories?sRech=php+up+to)
edit: nevermind
&gt; Joke &gt; WHOOSH! &gt; You.
Copy reference, on mac cmd+option+shift+c ... copies either the current class, function name, filename This reference can then be used in storm again to open up the position. In general though its super useful when you talk with others about code.
&gt; Joke &gt; WHOOSH! &gt; You.
real programmers don't use loops, they just `goto`
In your case you will get error: https://3v4l.org/Urv0b So no BC breaks. So the only case is generators... The only possible way with it is.... force users to wrap function expression body: yield $foo =&gt; $foo ** 2 // yield key/value pair yield $foo =&gt; { $foo ** 2 } // yield closure But not sure... this would be rare use case after all... but yes it ambigious
PHP has somewhat [long list](https://www.cvedetails.com/vulnerability-list.php?vendor_id=74&amp;product_id=128&amp;version_id=&amp;page=1&amp;hasexp=0&amp;opdos=0&amp;opec=0&amp;opov=0&amp;opcsrf=0&amp;opgpriv=0&amp;opsqli=0&amp;opxss=0&amp;opdirt=0&amp;opmemc=0&amp;ophttprs=0&amp;opbyp=0&amp;opfileinc=0&amp;opginf=0&amp;cvssscoremin=9&amp;cvssscoremax=0&amp;year=0&amp;month=0&amp;cweid=0&amp;order=1&amp;trc=475&amp;sha=d8a9f07b702ae6252893a7ef73f2f2812bbcbb8a) of CVE numbers with high score (score greater than 9), but as far as I know, there hasn't been that many exploits in the wild. One exception is the [PHP-CGI](https://blog.sucuri.net/2012/05/php-cgi-vulnerability-exploited-in-the-wild.html) vulnerability from a few years back.
Color manip is already finished [here](https://github.com/Talesoft/phim/blob/master/src/Phim/Color.php) and [here](https://github.com/Talesoft/phim/tree/master/src/Phim/Color) (Look at the test file [here](https://github.com/Talesoft/phim/blob/master/tests/pragmatic/colors.php)). What I mean is manipulating the same color in different color spaces. There are some things missing yet (e.g. I'd like a `Color::mix(ColorInterface $color, ColorInterface $otherColor)`) but basically I'd like to do stuff like `(string)Color::fromString('rgba(88,0,35)')-&gt;getHsla()-&gt;withHue(250)-&gt;withLightness(5)-&gt;withAlpha(.4)-&gt;getRgba()` resulting in `"rgba(r,g,b,a)"` This should be usable stand-alone (e.g. for manipulating CSS colors) as well as usable in the graphics library (`Brushes` and `Pens` similar to .NET) Phim (it's my project, I wrote it from scratch) already supports RGB, RGBA, HSV, HSVA, HSL and HSLA with conversions from and to each one. I'm missing LAB stuff right now (I don't think CMYK could/should be correctly implemented, it would never be _real_ CMYK or someone knows how to implement ICC color profiles easily) Phim aims at being exactly what I explained, but everthing other than the color manipulation isn't really well done right now :(
Yeah, I just got it. Now I feel like a dick. :)
What a nerd! My PHP-in-5-minutes tutorial said otherwise, so I rather stick to that. What do you know.
I'll be going and manning the Deploy sponsor stand if anyone has any questions.
Well yeah, under the hood Composer is still using require() and include(), obviously. I just don't have to care 99% of the time.
thanks, judging by the broken english, complete lack of understanding of basic technology and no salary mentioned I think this is a bait for spammers who never read before answering. Some job companies do that to 'trim' the actual people seeking work. But then again I might be wrong and this is legit.
I see. Thanks for replying!
A.C.R.O.N.Y.M. A Concise Reduction Obliquely Naming Your Meaning Or as we say it in the bussiness "shit you make up but sounds correct"
Pro tip: You can "extract()" $user array and you'll have convenience of comparing passwords simply like this: if (md5($password) != $password_hash)
It's not include that's bad, it's the managing of includes in your own projects. Which is now a solved problem.
So since codeception already supports gherkin format, anyone can tell if using this or behat is better?
I just ate ffs!
First things I do when I install Windows: * &gt; use IE to download Fx * &gt; hit shift 5 times to permanently disable sticky keys
Because everyone just _loves_ writing boilerplate constructors!
I'd like to see independent comparison as well
You might want to check out [Latte](https://github.com/nette/latte). It has some killing features, best of which is [Context-Aware Escaping](https://github.com/nette/latte#context-aware-escaping), plus the new 2.4 RC looks really awesome.
Oops, expired certificate!
ROT13 twice? That's, like, almost 170 ROTs.
Even discounting actual language ambiguities with arrays and yield, the actually more significant problem are ambiguities at the parser level. Assume the syntax is `$x ==&gt; $y` to get rid of the language ambiguities. Now, if you want to support type signature, it's possible to write something like `(int &amp;$x) ==&gt; $y`. Imagine how the parser sees this, consuming tokens incrementally. At the time when the parser only sees `(int &amp;$x)` this actually looks like the bitwise and between an `int` constant and the variable `$x`. Only after seeing the `==&gt;` can the parser determine that this actually means something completely different, namely that this is a short lambda. If you consider default values, i.e. `(int &amp;$x = expr) ==&gt;` the problem becomes even worse, because you need *arbitrary*-length lookahead to determine that this a short lambda. In contrast, parsers that are actually used, like the LALR(1) parser that PHP uses, tend to have only a *single* token of lookahead. So you can only use at most two tokens to disambiguate what a certain syntax means. One token of lookahead is a whole lot less than infinite lookahead! There are ways to solve this. HHVM, which implements the `==&gt;` syntax, performs an arbitrary-length lookahead scan in the lexer on every `(` character, to determine whether this is actually opening a short lambda. Alternatively, we could try parsing `(int &amp;$x) ==&gt; $y` etc. as it appears at first, i.e. a bitwise and etc. and then detect and convert this at a later stage. Both solutions are extremely ugly and impose high costs not only on our implementation, but also on any supportive tooling that needs to parse PHP.
TIL, there is a [complete web server](http://php.net/manual/en/features.commandline.webserver.php) included in php.exe (that local(); call got me curious)
I was wondering about this too.
I had this page dogeared :( http://imgur.com/xDN2Lep LOLOLOL
Let's Encrpyt is pretty nice, I just set it up for a few of my homelab boxes. For clients/personal sites anymore I just slap them behind cloudflare's free offering and use cloudflare's origin cert on my boxes that sit behind them. I've been going this route the last year or so... no issues.
[removed]
I knew I was onto something with "facades".
It looks like those twitter accounts are just simply ripping all Reddit submissions to this subreddit.
They are few and very far between. Most companies care about making money over having 100% perfect code.
&gt; Configuration should not be constant (in the syntactical sense). Umm. No. The time to change it is on deployment and it should be constant until the next deployment. I think we use configuration for very different things. Similarly, I'd only be testing the software in the *exact* configuration I'd be using in production since testing every potential combination is generally a bad idea since there are half-finished stuff sitting behind feature flags and would screw up the QA database. Similarly runtime configuration is really bad and you shouldn't do it precisely because of stuff like that. Unless you are building something like Wordpress that is user-installed. It is a web application, not an end user one.
Generally what I do with laravel controller is I have a service that is related, so if we have a LoginController then we also have a LoginService that is passed in through the controllers constructor. All complicated logic thats not just "return a view with x, y and z" is passed to the service so that the service returns usually true or false or an array of values for the view or some other value. I like clean, consistent controllers.
 global $user; Not so bad. Only time I need to use with D7.
I suspect that the short closure RFC failed primarily for these reasons: * The symbol choice (`~&gt;`) * Inability to provide type info for arguments * Automatically closing over variables The first two points can be adjusted. We can *potentially* pick better symbols and provide the ability for type information. The last point is simply something people will agree with or not. The reason the arrow_functions RFC exists is to attempt to solve those first two issues without compromising the benefits of short_closures. With that said the reason the arrow functions RFC has not gone to vote is not because I've been too busy. Rather it's that `fn` must be reserved for this to work. Reserving a new keyword is a BC break and in this case I'm sure it will break code out there. So we've been looking at other symbols so we don't need a new keyword. There are not many symbols eligible. However the caret (`^`) is a possibility: array_map(^($item) =&gt; $item-&gt;property, $data) This is not ambiguous and used in Objective-C already (precedents are always nice). The other potential symbol is `\`: array_map(\($item) =&gt; $item-&gt;property, $data) What do you guys think?
Behat documentation is unfortunately poor compared to Codeception. It is *difficult* to get it configured as you want because you are not provided enough information.
It goes back to our single-token lookahead parser. Note that `($item)` is a valid expression. It can't know until it is too late that it should been a parameter list. Note that it is (probably) fixable in the grammar but it's really, really hard because of all of the possible sub-expressions that you have to make before determining if it's an expression or parameter list. It's the leading symbol that allows this to break because we can match on that leading token and take a different route.
Thanks for the explanation. So, if i understand correctly, there is no real way to implement this without some prefix (function, fn, \^). Correct?
Yep, got that from nikic's answer. So i guess, the shorter the prefix, the better. In that case I would go for \^ (with the Obj-C precedent and everything) :) Thanks for answering.
First stop would probably be to check out https://github.com/composer/installers which allows you to logically separate packages, to treat them differently based on their "Type". As an extreme example, we run several WordPress (Can't think of a project more removed from composer's typical structure and philosophy) projects via composer, and inject all our plugins and themes as composer packages via either packagist, wppackagist and a custom satis repository for our private packages. We're able to mix them all as we can identify WordPress "Plugins", "Themes" and "MU-Plugins" via the composer installers package, allowing us to install "Plugins" into a specific directory, (/wp-content/plugins/) and handle them differently to say, "Themes" and like wise, we're then able to take standard packages, such as Guzzle for example and build plugins that depend upon Guzzle which goes into the standard /vendor/ directory and is autoloaded as usual by composer, while we let WordPress load the plugins as per usual, it works beautifully. The bedrock project (https://roots.io/bedrock/) for WordPress is an excellent example of how to leverage different types of composer packages, and integrate it with a project (WordPress) that was never designed with composer in mind.
&gt; and/or each controller will need a controller factory (something that knows how to wire in the custom list of dependencies). Either that, or a reflection based [injector](https://github.com/rdlowrey/auryn) creating them for you.
&gt; parts of my app might follow PSR-4, whereas other parts (like 3rd party libraries) might follow PSR-0 as I have no control over them. How can composer.json handle this? as long as you're using composer autoloader, you're not concerned on how third party libraries do their autoloading, because composer takes care of that for you.
Sounds like you've misunderstood what Composer is and does. If you were to develop a "complex web-app" you'd use libraries and frameworks, and you'd install all of them using Composer, basically. And then you'd use Composer's autoloader to load their classes (explicitly or implicitly if you're using a framework which uses Composer's autoloader). Whether or not the packages you've installed with Composer uses PSR-0, PSR-4, or neither, is not an issue to you because you've deferred that problem to the autoloader, which Just Works™. CodeIgniter or Kohana isn't "lighter" because they don't use namespaces, _deprecated_ is the word you're looking for. (I can't speak for newer versions of said frameworks, but if they don't use namespaces either they're deprecated and awful.)
They had it on Bluehost, so when I moved my blog to an actual hosted server, I rewrote my JSPs to Perl::CGI.
Hi thanks for the seed file instead of setting data within route suggestion. Current one is just the beginning yeah, I am planning to make everyone can be add their page_token and verify_token to the project and add their own Q&amp;A. That's why I am using Laravel.
/me sighs "Static proxies to service locators." At least you used scare quotes this time. ;-)
That could also work haha. I was going for something that I used to see in this home brew php cms thing some guy built for a friend. It was notorious for using short php tags and that version of echo. All of which was years ago on some server that would constantly refer to php4 as the only version they supported.
Maybe just use `lambda` prefix for oneliners? It'd be obvious, shorter than `function`, is proper name for such expressions and is for example used in python. I'm in favor of function($x) =&gt; $x*$x; syntax though. No need for extra reserved words, function is already used for anonymous functions and this is still a lot shorter.
The `invoke` option is a custom extension of Laravel's router. It is not available out of the box.
Yet it would make using them easier, as namespacing them will avoid function/class name conflicts.
Right, but if I remember correctly, extending Laravel's router is pretty simple and the adding the invoke option itself should only require a few lines of code. EDIT: Upon further introspection I am mostly wrong, it's ~100 lines of code. Derp.
&gt; Do you not call things that are created by Aura.Di "services"? I call them "new instances." When the container *retains an instance for reuse* (via get()/set()), then I call it a service. &gt; Is Aura.Di not standing is as a factory for the controller? (/me ponders) Maybe. Even so, it would not be that "each controller will need a controller factory" as you said above, in the sense that every ContollerFoo needs a corresponding ControllerFooFactory, but that the DI system can factory any object that needs to be created or injected.
Going from 8 characters to 7 while also reserving a new word is not an improvement in my opinion. I don't mind `function($x) = &gt; $x * $x` but it's still quite long and struggled to gain support from some of my peers. This is partly why it hasn't moved forward either. It's just unclear what will be good while also have a chance of passing.
It took me two classes (extending Router and Route) and 131 lines total after docblocks and such. I originally attempted to turn the `invoke` param into the `uses` param, suffixing the `@__invoke` method to the class passed to `invoke`. I can't remember exactly what issues I ran into, but it ended up being more work than that. It's quite possible the process is easier than that, I just missed the logic. Give it a shot, let me know if you run into issues. :)
&gt;&gt; Do you not call things that are created by Aura.Di "services"? &gt; I call them "new instances." When the container retains an instance for reuse (via get()/set()), then I call it a service. Separately, we have a dissonance in our diction there. Though, be that as it may, some component is standing in as the actor which will ultimately call `new`. So whether you are writing a custom factory for each controller, or set of controllers... OR, you are borrowing/leaning-on a component like Aura.Di to stand in as the factory, the investment has an up front higher cost than using service location object (such as a component like Pimple/DIC-in-a-tweet). We could argue whether there is a significant long-term cost to using service location in Controller (and Symfony Console classes), but personally/anecdotally, I've never experienced it. Since I've never experienced the "pain" of using service location with controllers, incurring the up-front cost of the infrastructure to manage creating properly wired controllers (that are marshalled/instantiated on-demand by a dispatcher) has never been an appealing trade-off. After all, I don't treat controllers/console-classes as first class citizens anyway. What's more, in a lot of cases my controllers are closures (I care so little for them I don't even give them a name).
Take Yii2. If you need CRUD, it's great even in the base version. If you spend some time and add a few Gii modules, and, maybe tweak a few things to your liking - oh boy, does it deliver.
&gt; I originally attempted to turn the invoke param into the uses param, suffixing the @__invoke method to the class passed to invoke. I can't remember exactly what issues I ran into, but it ended up being more work than that. If I had to guess, it was probably the controller namespace prepended to the classpath, so`\App\Actions\ListProductsAction` turns into`\App\Http\Controllers\App\Actions\ListProductsAction`. I'll put that on my list of things to play around with on my next greenfield project. You should consider submitting a PR to Laravel, it might get added in 5.3
&gt; be that as it may, some component is standing in as the actor which will ultimately call new. So whether you are writing a custom factory for each controller, or set of controllers... OR, you are borrowing/leaning-on a component like Aura.Di to stand in as the factory, the investment has an up front higher cost than using service location object (such as a component like Pimple/DIC-in-a-tweet). Regarding the higher up-front cost of DI vs SL, I am unconvinced; they are both containers, after all. The primary difference is that DI does its work outside of the object-being-created, and SL is used inside the object-that-has-been-created. (/me shrugs) You can have the last word on this if you like; nothing against you, but I am weary of the topic for now.
&gt; \ The *escape* character for *yielding a closure* makes me cringe. hard. I *feel* that somehow, the caret symbol makes more sense. However, as a lowly lambda user, I largely prefer the parenthesis encapsulation, or at least ~&gt; (and damn your drunk parser)
It's actually quite amazing because each library has its own name space there's general no worry for conflicting namespaces. We use composer to build a rather large and complicated finical application for investors. We haven't had any issues as of yet. 
Ran into one of these a few months back using 2 older/non-namspaced libraries. Can't remember which library, but I ended up dropping one rather than trying to rename stuff.
&gt;a lighter framework like that doesn't even allow for namespaces wait, what year is this?
The vote threads are just for recording votes. There are discussion threads that occur prior to holding a vote.
https://github.com/pmjones/adr
I'm afraid I've already read the github page and it's way over my head. For example I have no idea what &gt;We generally route and dispatch not to a controller class per se, but to a particular action method within a controller class. &gt;It is also partly revealed by the fact that we commonly think of the template as the View, when in a web context it may be more accurate to say that the HTTP response is the View. As such, I think ADR may represent a better separation of concerns than MVC does in a web context. means. I've built sites with login using procedural PHP and I am trying to get a general understanding of what problem ADR is trying to solve.
yup, and with the console you can create migrations, models and then cruds without even opening any text editing software. yii migrate/create create_article --fields="title:string:notNull,body:text" yii migrate/up yii gii/model --tableName="article" --modelClass="Article" yii gii/crud --modelClass="app\models\Article" Done, a full crud from 0 in less than 3 minutes
&gt; I am trying to get a general understanding of what problem ADR is trying to solve. Ah, then you have a great opportunity! First, the general problem is that of "separation of concerns." The concerns are generally labelled "business logic", "presentation", "data access", and so on. In typical procedural page-based PHP, these concerns are all lumped together into a single script. In that script, we include some setup or config files, then we output a header, then a couple of SQL queries to get data, then we manipulate the data, then we output the data, then maybe a few more query-and-output iterations, include a footer, and done. Then you realize that's hard to maintain over a longer lifespan, and you hear about something called Model View Controller. The idea here is that you reorganize that page-based script so that your presentation logic into the View layer (generally a series of templates), your data-access and data-manipulation logic into a Model layer, and all the rest goes into a Controller somehow. The problem with this is that the MVC pattern originated on desktop, graphical user interface, in-memory systems, and as such there is a collection of ancillary assisting bits that define how the Model, View, and Controller collaborate with each other. I'll save you time and say only that those collaborations do not exist in server-side implementations of Model View Controller. In addition, the Controller has a tendency to be a dumping ground for business logic that doesn't "feel" right in the Model, and also to be in control of sending HTTP headers (since most template systems do not deal with headers at all). ADR is a refinement of what we think of as "MVC" pattern as expressed on the server side, to apply it to request/response, over-the-network interactions. It gives a better separation of concerns in those environments. For a short introductory presentation, see [The Template Is Not The View](https://www.youtube.com/watch?v=rlrTyN0aqSk). For a longer one, see [Action-Domain-Responder](https://vimeo.com/106771285). I apologize in advance for the sound quality; the fun really begins there about the 6:00 mark.
Can someone give me the elevator pitch about ADR? What problems does it try to solve? When should you use it? When should you NOT use it? 
The number-one time *not* to use it is on the client-side. Client-side applications already have a perfectly good user-interface pattern; it is called Model View Controller. ;-)
I commute to Portsmouth daily (as a PHP developer), and I am very interested in this event! Will I get enough value for the £115 ticket price? It's quite a sum of money for me, just wanted to get some opinions
&gt; I feel like in a real life situation this pattern creates a lot more classes and files This is true. I have not seen a case where it does not result in more classes (though not always as many as you might think). What's interesting is that the amount of logic in the system has not increased; it has only been reorganized. &gt; so things can get out of hand really quick Maybe, maybe not. Anecdotally, hearing from people who have converted to it, the increased number of classes has been essentially a non-issue; they end up grouping the files somewhat differently, but that's all. But if a larger number of files is the primary architectural hurdle for your application, then yes, you may wish to avoid a strict ADR implementation.
For more clarification, letsencrypt just allows your webserver to work through https, instead of http. So your data goes encrypted through it, even if you send it as plaintext. But still, keep hashing your passwords before persisting them!
Depends if you prefer [spaghetti](https://en.wikipedia.org/wiki/Spaghetti_code) or [lasagne](https://en.wikipedia.org/wiki/Spaghetti_code#Lasagna_code)
Persisting them meaning storing them in a database? 
This is some sexy work.
Yeah, sorry for being overly aggressive, but I would strongly advice newbies to stay away from pre 5.3 libraries and frameworks if possible. (I agree with the points you've made, however)
I should mention that PHPUnit has no namespaces but does work like a charm and is very widely used. 
&gt; it is called Model View Controller Everybody uses MVP, MVVM or FLUX. In MVC view is to coupled on model.
I stand corrected.
I wouldn't go for a template engine that is unheard-of. Most of your junior developers will spend time on these, and generally, everyone will need to know the syntax. Twig for example is dead simple to understand. Smarty is god too, but even though Brainy says it's a fork of Smarty, it is unclear what are the exact changes. This brings another reason as well. Bloated code or sunsetting a large project is not a good reason to fork and publish another library. Those who fork are often the ones who don't bother to create a detailed issue and try to collaborate. I'm not saying the developer of Brainy is one. But speaking from what I have seen, those forks usually go dead when the main developer loses interest. 
[imgur screenshot](https://i.imgur.com/3axaKc6.jpg)
Our code was drop in compatible. 
I've had issues with some old Laravel 4.2 projects
Other people are suggesting Twig, and while it's good I'd recommend Mustache since it has official ports for multiple languages, including JS, so you can render using whatever language you like. Twig has an unofficial port for JS but it has missing functionality and sometimes different corner cases (things like defaults, math functions behave differently between PHP and JS).
Some new keywords were reserved. If you had `class int` (as a way to do makeshift scalar types) in PHP5, it will break in 7 Some incorrect values became compile errors. I saw a list of copy-and-pasted numbers had one show up as an invalid octal number (098 or something). Just scan through all your files and lint them on a PHP7 system to find them (`find . -name *.php | xargs php -l` give or take) Some extensions are lagging behind a bit or not easily available in repos that have PHP7. I was struggling with memcached for a bit, and gearman was a huge pain in the ass to find a working fork. Still, almost all of my code worked exactly as-is, and most issues that do arise manifest quickly and are reasonably easy to fix.
&gt; find . -name *.php | xargs php -l Great, but I had to change it to `find . -name '*.php' -exec php -l '{}' \;`
&gt; use globals are you serious?
I just threw up a little.
The very documentation you quoted says: &gt; *As of PHP 7 the current values will also be returned if the arguments are __passed by value__.* --- It also says right below that: &gt; *This function returns a copy of the passed arguments only, and does not account for default (non-passed) arguments.* Which is why you are not seeing the second argument – you didn't pass it into the function...
The whole thing was a joke, because the entire series of `mysql_*` methods is a pile of hot garbage, just like the rampant use of globals in old-school PHP4
Hah! I definitely won't be making DPC, but PHPSC… I promised my son the beach.
Nope, here for a wedding :)
Very useful for me: Ctrl + Y: Deletes current line.
[Oh You!](http://vignette3.wikia.nocookie.net/steven-universe/images/b/b8/Oh_you.jpg/revision/20151210212037)
In addition to the other comments, if you still need 5.6 for your clients projects, there is a ppa that allows you to both install 5.6 and 7.0 at the same time (and a couple of other php versions, including all extensions): https://launchpad.net/~ondrej/+archive/ubuntu/php
&gt; *To use your own example question, the answer is one LOC using `header()` (as I expect you already know). Why would I bother using a library to do only that?* Because it's not that simple once you go beyond plain ASCII filenames: http://stackoverflow.com/a/6745788/1233508
Thanks for doing that, nonetheless. I too used to downvote-and-vote-to-close that junk aggressively, but it never stops coming, and when I realised that I was spending more time policing it than actually using the site, I gave up.
Yes indeed. 
If you do a foreach($array as $a), the $a will be a copy, you can't update $a and expect $array to be updated.
Are you sure? Both 5.6 and 7 has the same behavior. Updating $a will not keep its value, bit you can pass $a as a reference, and it will work in both 5.6 and 7. But please for the love of God do not do that. 
Swap the php stack, reuse the same custom php.ini settings, and run your test suite. You have unit and integration tests, right? RIGHT? Register globals and several stuff are removed, and php ini values no longer have any meaning. I only had to remove them and my sites worked well in 7.0. 
To expand on the linter, with a larger codebase you may find this easier: find . -name '*.php' -exec php -l {} \; | grep -v "No syntax errors" Result hides files with no issues
The main things I can remember: * Dividing by zero now returns INF instead of false (which is way more correct). * Building arrays with references to other arrays and then passing them to the Soapclient produced some unexpected results... According to the changelogs this should be fixed right now, but we just changed the code a bit and haven't bothered to test the old code again. All in all it has been pretty smooth sailing. edit: Someone mentioned the memcached extension. We already used redis in another application and just switched to redis for all our applications instead of memcached. I ithink it took some work to update our vagrant config, but code wise it was pretty small change. YMMV though, since we only used memcached for session storage.
don't forget HTML and CSS!
&gt; Some new keywords were reserved. If you had class int (as a way to do makeshift scalar types) in PHP5, it will break in 7 Just had this problem with a Silverstripe project where they do that. Updated a dev box to the new version of Ubuntu and all hell broke loose. Just a heads up if anyone is using Silverstripe, the current version probably won't be PHP7 compatible in a long time.
What's wrong with xargs? Not present on your machine?
I just took over a project and the entire thing is based on storing massive amounts of data inside an array named global. It's vomit worthy and not even the lowest point in the code base.
`php -l` only takes one file parameter at a time to lint, so it won't work with xargs
Sounds like Typo3 :)
I wish it had a system like that. It's actually Drupal and comes off like someone using a completely different pattern was learning Drupal 
Nope, it was an actual PHP6 book published based on known PHP6 features back then
Thanks for the fix :) I was mostly guessing since I haven't needed to do it in quite a while. 
Using `-n` will allow limiting the number of arguments per invocation. Example: find . -type f -name "*.php" -print0 | xargs -0 -n 1 php -l | grep -v "No syntax errors"
It's fairly typical of this kind of post. A "tech blog" to drive traffic to an offshore development company. It's pure spam. The content doesn't matter to the author - it's posted here to get clicks. 
Remember that client-side validation using javascript is trivial to bypass, as is basic HTML5 validation.
At that point why not use -exec though?
Just don't forget that outside the foreach, the $a reference is still there.
A framework can make ADR *easier* if ADR is the expected separation-of-concerns, but I can't think of an MVC framework off-hand that *prevents* an ADR implementation.
What year is it?
`eregi` was also removed as of 7.0, actually had a project break because of this, legacy code... sad times ha
I usually do `find -name '*.php' | xargs -n 1 -P 8 php -l` on larger projects that take a bit longer to churn through.
All of these are just assigning strings to variables. Somewhere else, these strings most likely will be concatenated and translated into some other malicious code. Hard to say what they do without seeing where that happens. The end result is usually a means for an attacker to get shell access or upload additional malicious files. Are you/your friend using a popular CMS? Outdated versions of CMS's and their plugins are usually the entry point here. Make sure you've got everything updated.
If you really want to see the internals, you can create a virtual machine, install a regular PHP stack with xdebug, and see what it does. 
 &gt;The typeof() poll will have **to** voting options:
The server is still compromised. Can the server run PHP code? They can for example us the added files to login and send massive amounts of spam etc. 
I agree with this. "Negative integer" seems excessive. It should just be "integer" and then you can see if it is negative some other way. Ideally "typeof" is just worried about the *type* not the details of what is being stored. For example, JavaScript `typeof -3` is just "number". Details are excessive and the fewer return choices the better developers can reason about using it.
Saw this happen as well. 
What about the +0 and -0 case for floats in extended mode? Generally I like the idea, but I think the extended mode (also: Boolean parameter to functions are kinda bad form) is going too far because it concentrates too much knowledge in that central function. Knowledge that's better put into specific places (that know about all the special cases like the +/-0 thingy. 
Thank you! I just realized it is actually you who suggested this in mailing list. I'm not a voting member, but I'm really looking forward to see how this goes. 
this is spaghetti code and it's commercial
After reviewing all the files I deleted them, but yes it could have.
The mysql_ stuff has just been deprecated. But can still install and use it under PHP7 (see https://github.com/php/pecl-database-mysql)
Not PHP
How is it spaghetti code?
The files got there somehow. They'll just get there again. There's a vulnerability somewhere.
Do you mean comical?
As explained in the RFC, php-internals discussions are going more towards `$var instanceof string` rather than adding yet another operator. I personally (also mentioned in the RFC) would prefer the introduction of `is` as operator for exactly that. It is very short and extremely readable.
It was just another explanation after comparing it to all the other languages that use it exactly in that letter combination and stating that it is the perfect complement to `instanceof`. Also note that I clearly stated _in the context of computer science_. Hence, it is not a valid word in normal text.
To be pedantic, it's more than deprecated at this point: it was deprecated in PHP 5.5, and has been removed entirely in PHP 7. While it's still possible to compile the extension against PHP 7.0, it's likely that a later version of PHP will unintentionally break it, and it's not going to get fixed at that point. It really, *really* shouldn't be used with PHP 7. You're going to have a bad time if you do, sooner or later.
Very nice first contribution, hope to see more!
should be better to make gettype return float instead of double. Adding another function to get information about types is not gonna make it consistent. The only way PHP can fix its inconsistencies is by finally breaking things. adding more mud to the ball will only make it a bigger ball of mud
show me any other successful php projects with word "commercial" in their readme.md at their github codebase and including untested .sh (yes shell scripts) in project files and I will shut up.
https://github.com/paragonie/airship/blob/master/src/global_functions.php
global
You know, just because you don't see a use for the extended response, doesn't mean there *isn't* a use for it. Besides, the second parameter in `typeof()` is optional and defaults to `false`, so you can get the necessary `int`s and `bool`s and what have you like in other languages. **Edit:** 
I'd switch default to true, you'd be getting the data you're looking for immediately with less code Otherwise you'd end up with another `T_PAAMAYIM_NEKUDOTAYIM` story Having to do more things than necessary to achieve a simple result In the error case, having to look it up on Google to understand it, more steps than necessary while giving it a sensible name would've made searching for the error unnecessary, in the typeof() case, you'd have to add true to every method call every time you need the extended info, which I imagine would be used more often
Yep, the next (and final) beta release will tie in a lot of UI work I've been putting off, as well as some more room for flexibility. :D
:D, always great to see your work, literally making the world a safer place.
&gt; Although the term "instance" implies a object type. Maybe in the classical PHP sense, but from a definition point of view no. Really though it's not exactly needed, seeing as we already have is_* family of functions.
Looks pretty cool. If I had to suggest one thing though I would replace the strings with constants, or at least make them available as constants. So instead of `$holidays = Yasumi::create('USA', 2014);` I would rather do $holidays = Yasumi::create(Yasumi::USA, 2014); The reasoning is that I would have to look up your library to check if the first letter has to be capitol. If I'm in the middle of coding I would most likely start typing `$holidays = Yasumi::create('united_states')`, then be like "oh wait maybe it's unitedStates, or unitedStatesOfAmerica? Actually maybe usa, or Usa? Maybe USA, crap let's hunt down the file and look it up"... Another example is this one: `$holiday = $holidays-&gt;getHoliday('independenceDay');`. I will most likely have to open up your library, hunt down the file where it's declared and look up the proper syntax (snake case? camel case? ucfirst?). If it were a constant I would just do `Yasumi::IND` and my IDE would show me all the available constants to auto-complete.
[removed]
`gettype` is a bad function name and needs to be replaced anyways. Note that my RFC contains the deprecation and removal of `gettyp` in favor of the new function. No worries, I see it exactly as you do but simply breaking is not always the best way. Introduction of alternatives followed by deprecation and removal is more user friendly and often makes more sense.
I know this is just pseudo code, so I don't know if you're actually doing this, but it's not a good idea to send the password through GET (use POST instead). If someone gained access to your server, they could get user passwords by looking at your server access logs. Plus a person might copy-paste a URL to someone, not realizing their password is embedded in the query string. I'm sure there are a ton of other reasons this is a bad idea. That said, I am by no means a PHP expert, so if my thinking is off on this one, someone please correct me. I don't want to be guilty of spreading false information and I am here to learn.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I'd like to know where there's SQL queries that are vulnerable.
It looks pretty well thought out, nice project.
If you're going to cache on disk like that, at least dump it with var_export. Depending on where the "cached" data came from, the json encode/decode calls likely cancel the performance benefits you assumed this would give you. Have you considered what happens if the string contains a double quote? You also don't want to read the entire cache file into memory only to find out it was a miss. Use [filemtime](http://php.net/filemtime) for that and if you need to store expiration time use a separate file. If you already know the expiration is X minutes after creation just compare filemtime against now()-Xminutes and you won't need to read/write the expiration at all. Finally, read phptherightway.com and stop learning from sources of ignorance like phpclasses and w3school. 
This is a strange way to cache things. It means the server needs to be able to write php files out, which seems odd. Wouldn't it be better to ~~use memcached/redis~~ to only store things that can be json encoded in files named something like md5($key_name), then load them in using file_get_contents, then to json_decode them - that way you aren't writing files that would natively be executable, and you aren't running the code in the cache at any point.
I appreciate your efforts. But please take my arrogant criticism as a different point of view. Sorry if I offend you. 
hmmm... i would almost use it, but in germany, there are different states and every state has different additional holidays... that doesn't seem to work with yasumi just yet
&gt;the longer alias versions of booleanand integer instead of bool and int. These are highly unexpected results for users, who do not know the history of PHPʼs type system. The longer versions are beter imo...
Not really having a `typeof` or `var_type` function and a `type_info` or `var_info` function that are only capable of doing one thing is extremely straight forward; do not forget the Unix philosophy. It also makes both versions faster because they can concentrate on a single thing without checking some input arguments.
Thanks for the feedback! I definitely understand this part is not perfect or could get some improvement :) At the moment the documentation on Github tells you what exact name to use. Let me consider to improve this; alternatively if you have a good way of dealing with this, please help contributing by submitting a PR :)
Thanks! Yes for sure it is not yet complete for Germany. I started with only the national/general holidays. Perhaps later I will add those state holidays.
Just use [ISO 3166-1](https://en.wikipedia.org/wiki/ISO_3166-1) country codes. They are unambiguous. They are easy to convert to and from other formats. They will spare you a lot of trouble when people start arguing over exactly what a country should be called. For convenience and backward compatibility, you can support human-readable aliases, too.
https://github.com/roomify/bat might also be interesting
well, there is a [javascript library](https://github.com/mentum/lambdaws) that uses the character λ directly the code (alt+955 on windows). but thanx for the explanation! 
This is not a good and stable class and I don't recommend to use it in a production system. - Never heard of DRY (`if(!file_exists($this -&gt; cachePath . $file .'.php')) return false;` at least 3 times. At least put that stupid extension in a constant and define a `getPath` method.) - Very uncommon coding-style that will fit like no base you might probably have (I suggest PSR-2 for the author) - API has duplicate naming, but abbrevates things like`String` (`$cache = new Cache(); $cache-&gt;cacheReadStr()`) Why not `$cache-&gt;read()` then? Why not `cacheReadArr` when `String` and `Array` have almost the same length to write? - Forcely condensed coding style. That's not a good thing to do and you don't look like a 1337-h4x0r doing it, it just makes reading your code a pain in the ass - Instead of using standard-functions like `var_export` with the second parameter set to true, this one tries to generate own PHP coupled with JSON-encoding and decoding when arrays are given. Right now this cache would die on passing it an object. - You can read an array or a string, but you can't cache an array OR string dynamically and retrieve it like that, you never find out again if it's a string or array. You might as well pass JSON-strings yourself and read them out with that `Array` method (or you read all JSON strings as string). This is very inconsistent behaviour and won't help you getting up a stable application. - `filemtime()` is not used, so each miss check will always read the whole file. This cache _will_ be rather slow compared to other, popular caches Honestly, don't use it.
Working on that right now. Sara Golemon proposed to call it `var_type` instead of `typeof` to keep the option for a `typeof` operator open. I actually like that idea a lot because it avoids the introduction of a new prefix (namely `type`) in favor of extending an already existing one (`var_*`). My plan is to split it into `var_type` (successor of `gettype`) and `var_info` for the extended mode. Next baby steps will be `var_convert` as successor of `settype` but here I need to collect some info on what it actually should do. We definitely do not need a function that simply performs type casts, it must have some advantage. I will need to research userland a bit more for that so far my research has shown that `settype` is simply not used or directly replaceable by a cast. I would recommend to simply remove `settype` if this holds true during further research.
I don't know much about yii, but I do like cake3 for CRUD applications. It's very fast. I wrote a [getting started](https://medium.com/@Phillaf/cakephp-crud-walk-through-501310a43462#.et46f99ux) guide.
A foreigner such as myself may not know what IND is just as you may not now what the British holiday EMBH or the German PFI (Pfingsten) is days. I would use full words, that would be standard practice.
They get an email with a one-time access code, same as most webistes.
Oh sorry for the confusion, I was referencing my last code snippet $holiday = $holidays-&gt;getHoliday('independenceDay');. I used "IND" as an auto-complete candidate for "independenceDay". I'm not going to lie, it wasn't as obvious as I thought it would be when I wrote it. 
Being "bound to the object context" not as big of an issue in userland. `$var instanceof int` seems just fine, you're asking is the variable an instance of an integer. It doesn't necessarily mean to developers "of object type". Traditionally perhaps, but now that we do have scalar type hinting and reserved words for scalars the naming shouldn't be a big confusion. Maybe it makes a big difference to internals somehow, but this is where I'd defer to the W3C's standpoint on standards. Put end-users needs first, then developers, then engine implementers. In this case, the end-users are developers, so the first two groups just get squished together. Think about how developers will use things and how you can not *need* to break BC as much as possible, before thinking about how internals will handle something. If we can simply update and re-use `instanceof` then that is a clear winner since it means not needing to eventually have to redo existing code. It doesn't matter if makes some kind of sense, *needlessly* requiring at some point code to be changed for some altruistic sense of cleanliness is ignorant. Make BC changes where user-land must update mean something real. 
&gt; _REQUEST Also a bad idea, just check for $_POST. Ignore rest. 
Any particular reason _REQUEST is bad? 
For passwords at least, that still leaves you susceptible to receiving passwords via GET. You'd like to avoid that and make sure you just get it via POST, for the sake of your user's security. I prefer this for my other approaches as well to ensure that the user doesn't get some weird form error (for example: forgot a method="post" somewhere) and sends the form via GET (which makes refreshing them extremely easy and dangerous). It is not a really big deal but it can make a difference. 
By assign text (a.k.a string) do you mean add it onto the number? i.e concatenate. The below would output a random number following by 'thisismystring': echo mt_rand().'thisismystring';
All my information is sent via POST, nothing is received via GET. Thanks again.
Uhh what? Best I can understand is you want to relate a number to a piece of text. $x = new stdClass(); $x-&gt;number = mt_rand(); $x-&gt;text = "text"; or might be better to do by arrays and using the number as the index. $array = array(); $random = mt_rand(); $array[$random] = "text"; 
Yes, but REQUEST leaves you that hole open. So just a precaution. 
I will have a look into the group, where do you all meet?
All extremely valid points, but cut the author some slack they may not have known any better.
this will help me thanks!
You're making the wrong assumption that Mother's day and Father's day are the same around the world. Also for the UK you're mixing up Bank (defined by law) and Public (defined by proclamation each year)
I really like Twig.
&lt;?php //contacto.php include 'valida.php' echo $final;
There are quick CRUD builders for Laravel. I usually just use Jeffrey Ways generators if I want something like that, but there are more sophisticated tools. To answer your question, go with Yii. ;)
My company still uses globals in pretty much every of its functions: `global $DBCONNECT`, `global $IN`, `global $OUT`, `global $DEBUG`, `global $LANG`... Forgetting to adding one of these in your functions if you want to use them is my most frequent cause of bugs. Kind of glad I'll get to do something different by September.
My perception of crawl would be to follow and download further pages of the website, scrape might be more appropriate here. In saying that, I do love a DOM+XPath combination.
When posting code you should put 4 spaces in front of every line, and an additional 2 for every indentation level like: 4 spaces - Level 1 4 spaces - Level 1 6 spaces - Level 2 8 spaces - Level 3 6 spaces - Level 2 4 spaces - Level 1
This is great, i'm planning to contribute with my country's (Morocco) holidays if pull requests are accepted.
Thanks! Any pull request is welcome :)
Thanks for the feedback! I am aware that Mothersday and Fathersday not always are celebrated on the same day in various countries. In the library you can always override the calculation of a holiday in case it differs from the default. As for the bank and public holidays let me have a look. You are always welcome to contribute/improve this library as well :)
Yes, in this release there is already an identifier required (ISO). Let me see if I can make the instance creation more standards based.
PHP will need to find a way to allow for some implicit closure if we want truly first class functions. `use ($var1, ...)` is quite cumbersome compared to how JS handles it.
I'll be there, very much looking forward to it too! :)
I wish I had found this a month ago when doing a holiday calendar app for a class. I like it.
I personally switched to PHPstorm because Eclipse was so damn slow ...
Where are the tests? and bench marks? This looks, personally, like a hack.
please don't. We have enough weird operators that can't be used with functional composition patterns :-(
You're tests do not give enough coverage IMO. So you might want to fix that. 
They could use some clean up yes but lots of frameworks today and CMS's use the concept of global functions.
I work in codeigniter, it doesn't matter that our flagship product is written in it, or that it makes tens of millions of dollars a year in revenue, the code is still a huge pile of shit. 
I can only second that comment. Replacing such an awesome IDE with a Text Editor seems weird to me. I personally use Atom as a quick text editor, but when I am onto a real big project, I cannot imagine coding without PHPstorm.
It seems like you use PHPstorm like a quick source code editor which it isn't, and won't fit the purpose. I use both: Atom as a quick enhanced text editor and PHPstorm to work on projects.
22Mb seems to be more correct. What is it downloading with just 1.64Mb? Also, that custom repository shouldn't be needed
Too many PSRs leads to Java. I hope we don't add anymore.
thank you for this information, didn't know about this.
Do we really need increment/decrement methods in a "simple" cache?
Atomic increment and decrement are essential for most distributed system. This is not something you can do with a get &amp; set. Imagine how a hell it would be to cache an upvote system without that for example.
I like it! It's actually very close to memcached interface. How does that cover serialization of mixed input? It has to be specified if you want to use different library against the same storage.
I don't think the OP had a chance to make many decisions for PSR-6. Most of the work is done by Larry (Cell) Garfield, and despite what others said, it is a good recommendation. Just not enough to cut for every use case. If both PSRs were approved, I wonder how will they decide to choose one. The PSR 0 vs 4 had enough troubles for others to switch and mix, but composer came to the rescue. With two cache interface recommendations, I can only predict it will get only worse. I also agree with what another user said about having. Increment/decrement. They looks like specific implementations, and it is up to the user to have them. 
I like the idea of a simple caching standard, and would even look at creating a similar bridge for [php-cache](http://www.php-cache.com), but I'm not really a fan of the inc/dec methods. Also, not being able to cache null comes off strange to me, but I guess thats not an easy one to resolve, with this method.
~&gt; would have been a great candidate for this, but US keyboards have the tilde in a stupid place (UK keyboards have it right by the enter key, and therefore I'd have no problem with this existing). I have a problem with fn() because it brings back one of the oldest PHP caveats, which is having not-functions disguised as functions (include(), array(), etc). PHP should be making an effort to move away from confusing constructs like this. The ambiguous [fn($x) =&gt; $x + $y] example only makes things worse.
It sure has a few possible spots for race conditions 
Don't underestimate it. Not adding every single state of Germany gives it no use in having Germany in at all :) I'm pretty sure other countries work like that as well. That fact should be built into the base structure of your library :) Good luck and nice work so far 
The canonical data source is not necessarly something you can increment or decrement (eg. a number of relationship), otherwise that would render the cache useless.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
: Poorvi web sol Offer PHP CMS Training Institute in Hyderabad, Vijayawada @ low cost. We offer job oriented Course with Live Projects. Hyderabad’s Best PHP Training Institute. 
Yes. There was a big fuss kicked up about it on PSR-6, so it was left out. I've created a Community Question for it here, for folks to give their opinion on: https://github.com/dragoonis/psr-simplecache/issues/1#issuecomment-223893487
Too many PSRs just lead to more interchangeable libararies, which would be awesome.
This comic has to get an own subdomain. I see it so often, for really good reasons.
As a library author, there isn't a value that would make sense to store "as null".
/u/TorbenKoehn gave his reasons why he dislikes the class and gave examples what he would change. Of course it is never nice to read criticism. It always hurts a tiny bit. But one should be very thankful for being critized - it's the best way to become a better programmer. Especially with a detailed description like the one posted above.
Sitepoint always seems to be so commercial :( Can you give some good words about it? Will it be worth it posting my stuff there? I'm not up for page views or "Hopefully I get good ad revenue", I'm wanting to do this for free, I don't place ads, I don't require people to sign up or give me data to read my stuff. I like being able to get a "Thanks"/Upvote and knowing that I helped people with stuff. I'd also answer StackOverflow stuff (did that for a long time already), but the questions there feel too random, I have deeper knowledge and I'd like to direct people into the deep parts of PHP. The only thing I'm tracking is GA to look if it's worth it posting more and what formats I should choose :)
Depends. Most of the time you do know which type of data your library stores. Could you give examples where you have absolutely no idea?
Is there any sign of life for the pecl memcache extension? I believe it's the only thing outstanding for my organisation to try PHP7. We've thought about moving over to the memcached extension, but it would require a lot of packages to get an update. Also, I believe the two extensions read data differently, so they aren't compatible.
&gt; Atomic increment and decrement are essential for most distributed system. Completely irrelevant when the supplied PSR-6 compatibility is *not* atomic.
Why are you asking here?
No, that's not what I'm trying to say. 
It's a great one! It would be good to see analytics stats to see how often this is used compared to other ones. I predict this is in the top 5% of all xkcd images viewed.
The `*Multiple` methods can be implemented with a performance boost, falling back to a simple loop for non-supporting drivers. This way `*Multiple` would be at least as fast as separate method calls, but maybe faster. There are trivial to implement and the fallback does not break the promise given by the interface (not the case with`inc/dec`, which need to be atomic)
What distro you on? ppa:ondrej/php provides memcache packages.
My Memcached wrapper from 3 years ago seems to follow this PSR: https://github.com/AlekseyKorzun/memcached-wrapper-php Edit: Minus ++/--... never got that to work properly in any caching implementation. That should be piped directly to extension. 
CentOS 6. I'll have a look at remi's packages (that's what we for 5.6). Edit: Remi does have a dev version of memcache for PHP7, giving it a try. I just tried it on my Ubuntu box, and it worked fine. Thanks!
A cache is a temporarily storage of things, to store data the system shouldn't re-compute. That's all what cache is about. Having increment/decrement has absolutely nothing to do with a cache system, as it turns that cache backend into nothing temporary anymore. This should be placed in a SimpleStorageInterface or alike. Btw, related long discussion in PHP-CDS: initial https://github.com/php-cds/php-cds/issues/7 and further discussion in https://github.com/php-cds/php-cds-discussion/issues/4
But that's exactly what I'm talking about. You could also go and implement other greater, deeper caching-functions some extensions contain but then you'd have to draw a line of what you accept and what not. This is about a simple caching standard. If you need `*Multiple`-support and other specific caching-functions, go and use PSR-6. If not, SimpleCache is for you. That's what I was thinking.
According to https://xkcdref.info/statistics/, it's 5th of 1690.
* Not the good place, nothing to do with php * Flash contents can't be downloaded easily, and i don't think your tool is designed for it
A consultant is usually hired for projects (short term commitments) through the company the consultant works in (or own, like freelancers). A consultant could be a PHP developer. You're probably referring to the difference between being employed by a company and the company buying consulting from you. When it comes to the money, you could be a great employed developer and make more money than a consultant. And the other way around of course. Your skills decides what kind of money you can earn.
It's now in. With clear documentation as to when you should and shouldn't use it.
I think SitePoint is a good place to post articles. It has a large audience, which makes your posts far-reaching. It also has a good reviewing process to ensure that only accurate and good quality content is published (along with helping you to improve your writing style). Payment for content is also a nice bonus.
It could be both. One doesn't rule out the other.
thanks!
You lol, but I would say a good portion of the "consultants" out there ultimately amount to nothing more than watch readers, whilst sending you invoices for lots of $.
+1 just felt the tone was a little harsh, which can then negate the quality advice.
And even delete() is not explicitly necessary as null is equivalent to no item in cache, thus we can just `set($key, null)`. (Under the premise that we'll go without exists())
in my region a consultant is just a PHP dev not on contract but hired from another firm. The term is interchangeable with "external developer". They jump in for temporary extra hands on a project or to do short project where it is not beneficial for the company to go through a hiring process. because when the project is done 3 months later they would have to fire the guy... Because of that ad-hoc nature they tend to be a bit more expensive, which either results in more money for the consultant or for his company/boss.
Don't know how good an idea it is, but you could store a serialized NullObject in your namespace.
This post really isn't good advertisement for PHP-FIG... I really don't think another cache PSR would be beneficial to the ecosystem.
I like it. I am from Canada so I will fork this and add in the details for Canadian holidays. Question though: Canada has national holidays and also provincial holidays. Can this be reflected in this?
Consultant here. A few key things: * They are hired on-demand. You need them, you call them. You don't need them anymore, you kick them out. It's company-to-company work, not employment. That's also why the fees are much higher than those of hired personnel. * They are (supposed to be) in a very senior position, able to operate within your problem scope independently * Usually called when things are getting really out of hand (complexity or lack of knowledge in the problem-scope) * Can cover a variety of roles (usually very flexible people, with a lot of experience in multiple fields): * Tester * Teacher/Coach * Developer * Software Designer * Architect * Project Manager * Are good at talking/explaining stuff to various folks in the company, not just the techies In general, a consultant is a good fit for "fixing a problem", "finding a problem/solution" or "coaching a team", but not for actually developing something end-to-end due to the higher rates. These are my opinions, after working as consultant and with other consultants for ~3 years. Hope that clarifies it. I've seen others in this thread refer to "consultant" with actually other definitions (/u/mythix_dnb): &gt; in my region a consultant is just a PHP dev not on contract but hired from another firm. The term is interchangeable with "external developer". This is what is usually a "contractor" or a "freelancer". &gt; Is being a consultant considered a better/ higher paying job than a developer? No, not at all. I have full-time work very few times a year, but I have some advantages (yet they collide with my "paid work" schedule): * I work from home most of my time * I travel a lot to meet with new clients or to visit conferences where I can find new contracting opportunities * I focus a lot on learning new technologies and approaches and reading other people's code, mostly to hone my skills for the next consulting gig * I waste a lot of time in doing paperwork due to taxes (that's because I'm also a freelancer, but you may work as a consultant for a company that sells you out as "resource") * I don't have a fix project, which is both good (developers get bored, easily) and bad (can't stay on a project I like a lot for enough time to see it maturing/succeeding) In addition to that, sometimes it really feels like you are getting cheated: some consulting calls with clients that spent weeks debugging a problem usually end up being 5 minutes long (because I already saw the problem and the solution to it), so I actually invoice for 5 minutes of work. That's probably my own fault though. From a businessman perspective, I'm still a junior :-P 
Honestly, from my experience, in short: - Consultant = People that talk about code - Developer = People that code Consultants usually have higher payment, mostly because they know how to sell themself, not because they have harder work. Many developers end up as consultants once they learned how to talk to humans. They start coding less and running around telling people how to fix stuff and soon they're considered a consultant instead of a developer. Not all consultants can actually code, some of them just know much about it but can't apply it practically, some had similar professions before and grew into it, some are completely incompetent and talk shit the whole day which developers ignore (in the best case). If you want to sit on a computer and _code_, stay a developer. If you want to get paid for talking (shit), become a consultant. It's easy as that.
You have to keep in mind a consultant is a broad term that really just means they provide expert advise. You can hire a business consultant, a design consultant, a php consultant, etc. Like /u/danstorm said it all depends on what the client wants/needs. If they need you to review their setup and find the bottlenecks, like some people suggested, then that is what they want you to do. If they hire you to design and build their entire e-commerce solution then that is what you will do. In my 20+ years of experience as a consultant I can tell you that I am either building something from scratch or going in and fixing something. I've never been asked to just review a particular setup or give advise on a setup and then leave. I think you will find that in most cases a developer consultant, unless hired by a big firm, will usually just mean you are not an employee of theirs (meaning in the US you get paid via 1099 instead of W-2. Meaning you have to take your own taxes out. This is where most people get the idea that "consultants get paid more" but in reality once you take taxes out, pay for medical, etc unless you can write off a lot of stuff, you end up getting paid pretty much the same).
&gt;This is what is usually a "contractor" or a "freelancer". as I said, in my region, where enlish isn't an official language, a "consultant" is a catchall term for external developers. YMMV. &gt;Is being a consultant considered a better/ higher paying job than a developer? No, not at all. It may not be for you. Here it almost always is, unless the developer is bad at his job, or bad at negotiating his pay and has a shitty boss.
That seems very unintuitive for me. A method should have one responsibility, not two. Even though null is equal to not existing, it's still a second functionality in terms of logic.
where is the admin?
A consultant is simultaneously: * A freelance/contract developer * A coach for business (or technology) decisions A PHP consultant is a freelance PHP developer who also coaches business leadership. An application security consultant (what I do) is similar, except instead of merely writing PHP code I also find vulnerabilities in clients' existing code and teach their teams how to fix the immediate flaws and prevent making new ones.
 &gt; It may not be for you. Here it almost always is Agreed, but I don't make more money than an average developer in a developed country. Coming from Italy, I remember earning 15K/year, but currently living in Germany, I really do pretty much the average of all the other devs around here. I know there are consultants that invoice at crazy rates (1000USD/hr - seen that too, no idea how that person would ever produce ROI), but I also recognize their smell :-P 
&gt; Don’t make your (often shy) natural leaders ask for a promotion — just do it. In my experience, when employees are forced to be pro-active w.r.t. promotions they'll often seek promotions at other companies instead. ie. giving two-weeks notice could be less awkward than asking for a promotion. Ask for a promotion and you could damage your current standing at your company but give two weeks notice and altho that'll damage your current standing even more it doesn't matter since you're not going to be there anymore!
Sadly true, and this reputation really makes it hard to be well-perceived as a consultant :-\
I avoid the term Consultant at all costs. Domain Expert sounds better :P
I'm just indicating it will be semantically equivalent. I'm totally not opposed to having delete (for easier/more intuitive API than setting null). Whether it actually removes a key in cache (or maybe still caches null for a little while) should be the responsibility of the implementation, we [users] shall not have any knowledge of that.
A domain expert can't be an external entity - you need to check up on your definition of "domain expert" ;-) Indeed, the word "Consultant" is typically associated with a greedy person, mostly bad figure.
This also assumes that your "natural leader" developers *want* a promotion to management. At my previous employer, I wound up with a manager who, as a senior developer, was told he could take an open manager role or he could leave the company. Predictably, he was a terrible manager. He liked to manage by ambush, didn't share information well, and overall hated his job. While there are several things that he could have done better, overall the reason he was so terrible was that he was forced into a role he didn't want. Not everyone seeks a management role, nor should it be assumed so; for some reason, people who aren't developers don't understand that devs probably don't want a management role. As a dev, I see management making stupid decisions based on politics instead of technical merit, subjecting their people to arbitrary deadlines, making technical decisions that they have no business making, and drastically over-estimating the work capacity of a given group. I want no part of a culture that insists on making these mistakes over and over again, despite the glaring evidence that they lead to worse outcomes. It leads to a paradox; it would be best if managers had been developers of some stripe before moving into management, as they would have a much greater insight into the dynamics involved in creating software, but the culture discourages this by continually making developers the enemy (they don't do enough, they complain too much, they're just playing with computers, they don't do any actual work). By all means, promote your high-achieving junior devs to senior positions, but if you want your natural-leader senior devs to move into management, 1) don't force them to do so, and 2) make sure your corporate culture recognizes that the work the developers do is more important than pretty much anything a manager does, and prioritizes appropriately.
404?
To be replaced by another company that does the same thing, which goes out of business and gets replaced by another company that does the same thing... It's almost as if management acts this way because they know developers understand things they don't, and so in order to maintain control, they do everything they can to make the developers look as bad as possible. That way, if management makes a mistake (which they most certainly never do, they're always perfect) they can just throw the developers under the bus and assume no responsibility.
Like paying a dog and barking yourself.
Didnt know prophecy was included in PHPUnit. Seems to be superior than the original phpunit mocking methods. Going to use that from now on, thanks!
I think generally speaking, companies just need to acknowledge that being very skilled in one area not only doesn't make that person by default a good candidate for being a manager, but often means they would be bad at it. This may be more pronounced than usual in software, but you wouldn't promote your best nurse to brain surgeon, because they're two different jobs, so why do it with developers into engineering managers?
Yeah, sounds about right. Especially when the level of management over you is the ceo... they are infallible.
This is a solution, but this increases the size of the items you are caching. Some people (myself included) don't like this.
http://php.net/manual/en/function.curl-setopt.php CURLOPT_PROXYTYPE is probably what you are searching.
&gt; A few observations: 5.3/5.4 are declining slowly, 5.5 is taking the bulk of it though which makes me a bit sad :) I wish there was more love for 7 now that it shipped in Ubuntu 16.04. Sad, but to be expected. There are *a lot* of applications out there that are either no longer actively developed (but maintained!) or too complex to migrate to 7. For example, we have multiple applications written with Laravel 3 and 4 that use in-house PHP extensions. These are used and actively maintained but there is *absolutely zero* interest in porting them to 7. We'll reevaluate once 5.x reaches end of life, but until then 5.6 is serving us well.
Thank you, but I already tried this. But I wasn´t able to set this option for the curl-session composer is using.
This was an interesting read. I love how people, managers and such will go for more "got it done in 1 hour instead of 8." But the 1 hour causes more issues, bugs and other things later on down the road, regardless of how well it was written. We have some one new here at my company and I am being phased out, this other person does things in half an hour where as it takes me 5 hours, I take my time, test the code, make sure it works and so on and so forth, they write, commit and move on.
Splitting of the functionality is already done. I will follow Sara Golemon's idea with `var_type()` as function name for various reasons. I will implement the extended version as `var_info()` in a separate RFC. Deprecating `gettype()` and `settype()` is important to slowly migrate towards a cleaner language. I know that many people of internals do need like this topic for various reasons but this simply needs to be tackled.
This is not just a software development problem. You can expect around 50% of leaders/managers to fail. Here's a very detailed paper from 1994, but if you like your information in more bytesized chunks then you can browse the pages of something like HBR instead. http://enrollment.mst.edu/media/enrollmentmanagement/enrollment/documents/What%20We%20Know%20About%20Leadership.pdf 
You could also do: switch(true) { case ($var is int): . . . etc. }
"This also assumes that your "natural leader" developers want a promotion to management." You are assuming a promotion means a promotion to management. The author of the piece actually argues against this. Instead he argues to give them the appropriate public recognition. That promotions require going into management is probably still way too common within the industry though. Personally I really agree with (most of) the author's ideas. Being stingy with job titles or even just explicit role changes discourages proactive improvement.
Ask for promotion, given 2 year plan to still get less than market value and no leadership powers. Leaving really can be the easier option
Similarly, but with less comments: http://phpimagick.com/Tutorial/diffMarking
This is what happens when there is not enough supply of software development talent. The salaries are inflated the companies can't afford large enough or talented enough people to drive the results they want. This drives up the ladder causing it to cost more for development, making clients expect more for their money... So on &amp; So on
What about a remember method? It covers about 90% of use cases for caching IMO. public function remember(string $name, Closure $callback, $ttl); Here's my implementation: https://github.com/terah/redis-cache/blob/master/src/RedisCache.php#L118
The worst is when you inherit someone else's rubbish code, and they look brilliant for writing it so fast, but you look like a fool since it takes so long to make changes on top of the rubbish they wrote.
Read as "...shit." 
I am doing that right now &gt;.&gt; 
What do you mean?
Was looking for something like this a while back, found another php script of someone who made a diff class for time slots, so i made the rest myself. Very nice! 
This article should be printed, framed and hung on the wall at every software development company!
Take a look at how Bolt manages their demos. It was honestly the point that sold me the most.
Thanks. I'll fix that in the next push. :)
Exactly! Wildcard SSL is irrelevant now letsencrypt exists. A Slight PITA is SSL for offline, or internal networks, but LetsEncrypt has the promise of being incredibly useful
Surely it uses gzip during the transfer?
If you can implement peer review of code before it gets merged in you can help stop your code base being poisoned by the hit 'n' run coders. But if you don't have any control over this process, well, probably either you have to stick it out or move on.
&gt; This also assumes that your "natural leader" developers want a promotion to management. At my previous employer, I wound up with a manager who, as a senior developer, was told he could take an open manager role or he could leave the company. Predictably, he was a terrible manager. My company addressed this by implementing an alternate promotion path that is not managerial in nature - Software Architect. It is higher ranked than Senior Developer, and has a healthy pay increase (~$140,000/year...in the Midwest). They are basically in charge of the general technological direction of the company's applications and creating the high level flow of how the applications should work. Most of the implementation work is left up to the product teams, which have Associate Developers, Developers, Senior Developers, and Team Leads in them. The Architects also develop small in-house tools for making other developers' lives easier (think Yeoman generators, application templates, various reusable plugins, etc) and help out with implementation wherever they can for short periods of time if needed.
global $this; D:
While I support this RFC, what kind of deranged person would do something like the example given? $a="this"; $$a=42; That's literally going out of your way to break your application.
why did you make a throwaway just to post your own article? 
I think it just shows how thorough the author was while addressing _this_, which is very commendable.
I know someone that asked about using `$$a` in a technical question.
really liked the article and general explication of generators. Good job ! 
Is /u/somerandombuddy seriously looking? If so, we've got some PHP in our stack. http://imgur.com/jobs and/or drop me a PM.
Thank you :) Any improvement suggestions?
I use guzzle to make requests and [simple-dom-parser](https://github.com/sunra/php-simple-html-dom-parser) for actual crawling.
I understand that. However, as letsencrypt is pretty easy to set up and also free, letsencrypt is still a pretty good option instead of one paid wildcard cert.
I think PHP has 20% share because Ubuntu 16.04 ships with PHP 7. I started using PHP 7 some time ago, but most of the production servers I manage started to use PHP 7 because Ubuntu upgrade had it. I had to install some of the extensions (mcrypt, mysql bindings, etc). The 5.5 blame should go to lazy shared hosts. They had PHP 5.3 as the default version not a long ago. 
Thank you! I liked your post about Iterators as well. Keep it up!
Hello OP, good article. I would like to ask, how would you implement something like this: I am getting data (json array of stdObjects, with paging) from some web service API, and then loop through them and returning the objects via yield (i.e. I created a Generator out of webservice API). Everything works as expected, but I would like to enhance my implementation by giving the option to return the data in various formats (array, stdObject, custom class), just like there are several fetch_styles in PDO::fetch(). Should I implement this by doing a switch($fetch_style) { // return yield with desired type }, or just keep my generator returning just one type, and then encapsulate the Generator into another Generator, which will return something else? 
&gt; There are several scripting languages developers can choose from when building applications such as ASP, JSP, Perl, CGI, and PHP. The main debate recently has been between PHP and ASPX... What?
If anyone votes against this RFC, their voting privilege should be revoked. Seriously, this is more like a bug fix.
Why not introduce a this keyword? Makes more sense considering the behavior with closures as well.
Well, in the case of PDO you should pass the `PDO::FETCH_*` constant as an argument to the generator. That would be the most performant way. In any other case (e.g. manual mapping for an ORM) I'd yield the fields as an assoc-array and then map them as desired (e.g. through another generator/iterator. Implementing a `MapIterator` is as easy as extending `IteratorIterator` and overwriting the `current` method) --- Here be examples function get_page_items($page) { $data = json_decode(get_your_data_from_webservice($page), true); //Notice the "true" to ALWAYS get associative arrays. Don't work with stdClass. Please. foreach ($data as $item) { //Assume item is ['id' =&gt; int, 'name' =&gt; string, 'something' =&gt; string, 'something_else' =&gt; string] yield $item['id'] =&gt; $item; } } function get_page_objects($page) { foreach (get_page_items($page) as $id =&gt; $item) { $obj = new Item($id); $item-&gt;setName($item['name']); $item-&gt;setSomething($item['something']); $item-&gt;setSomethingElse($item['something_else']); yield $id =&gt; $obj; } } $itemObjects = iterator_to_array(get_page_objects(123)); function get_page_item_names($page) { foreach (get_page_items($page) as $id =&gt; $item) yield $id =&gt; $item['name']; } $itemNames = iterator_to_array(get_page_item_names(123)); //or build a MapIterator class ItemObjectMapIterator extends IteratorIterator { public function current() { $item = parent::current(); $obj = new Item($this-&gt;key()); $item-&gt;setName($item['name']); $item-&gt;setSomething($item['something']); $item-&gt;setSomethingElse($item['something_else']); return $obj; } } $pageObjects = iterator_to_array(new ItemObjectMapIterator(get_page_items(123))); Start coding like a baws today :)
I think there was not even a "no" vote. I think they didn't even asked, they just assumed everyone will vote "yes" and just published the results.
Choice of the certificate depends on website owner or administrator. After all, now certificate is renewed and will expire on 3rd June 2019. 
Small notice: &gt; These kinds of high performers are actually low performers when when TCO is factored in. double "when", maybe you want to know that. I am still reading, so I can't give a feedback right now.
I would be interested in learning of any real world code that this is a BC break for. It would obviously be a break for something like: function foo($bar) { var_dump($bar); } @foo(); But I'm not aware of anywhere this has been used....
It's an ecommerce platform. There will be hundreds of installs on a few dedicated servers. Each user will have their own webshop. The platform will be huge. It will have all the bells and whistles that need while running a webshop. EDIT: No complex algorithms. The complexcity is on the database layer (reports, searching items, listing of items).
PHP 7 and Laravel/Symfony is the way to go. Larger user base, easier to find programmers. 
I actually don't have an answer for you. This will be third platform I've been part of and "it's how we have always done things". I suppose with this SaaS with one code base, editing one customer's webshop would be out of question?
Would you mind humouring me, and casting your eye over this. To be clear, I'm NOT the original author, but read your reply to his post with interest and thought (as a relative novice) that I should try to tidy it up and fix/improve it, taking your points into consideration: http://pastebin.com/g3dzcXUw One thing I'm not sure on is the filemtime bit. I get that it's faster, but I've got a bit confused about the TTL. I feel that when reading the data out of the cache it's not necessarily known what TTL it was set with, without reading the expires value out of the file? How would you approach that problem?
Are there any benchmarks for PHP 7 + laravel? Is it possible to have &lt; 100ms pages for ~20 concurrent users? The page would consist of categories, products, images. The usual webshop stuff.
Then the framework typically doesn't matter: slam a varnish instance in front of it and you're done.
I've seen that one used in PHP templating to 'remove' access to the object scope inside templates.
&gt; How slow is it? I don't want to end up having pages load for 500ms+ That's impossible to answer as it depends on what you're doing with it. If it's a simple CRUD app and all you're doing is reading a few records from the DB with a simple select, and you haven't created hundreds of service providers and middlewares, and you know how to avoid N+1 queries, the a request will execute between 20-50ms on good hardware. But you could fuck up and forget to add an index on a very large SQL table while doing a `where` select on the column you haven't indexed, then it will take 2000ms, which is not Laravel's fault, it's because you set up your table incorrectly. I can't comment on Phalcon - probably because it requires specialized environment to run and a different workflow that requires compiling, which is likely only suitable for people who truly NEED performance. HHVM is something extra that needs to be installed and set up. Lots of people DO use it, but since PHP 7 is almost as fast but with a lower memory footprint, most people will just use PHP 7.
Yes. Did you? Where is it stated that deprecating `instanceof` is part of the RFC if `is` is implemented? 
Interesting. Does laravel handle any indexing itself or is this something I will have to take 100% responsibility of (I have no trouble with it). AFAIK laravel is able to build the tables itself? Wouldn't it know how to handle foreign keys etc.?
You are responsible for creating your tables. You can define the table schema in a Laravel migration, which looks like this: &lt;?php use Illuminate\Database\Schema\Blueprint; use Illuminate\Database\Migrations\Migration; class CreateClans extends Migration { /** * Run the migrations. * * @return void */ public function up() { Schema::create('clans', function(Blueprint $table) { $table-&gt;increments('id'); $table-&gt;string('name'); $table-&gt;integer('leader_id')-&gt;nullable(); $table-&gt;integer('legacy_clan_id')-&gt;nullable()-&gt;unique(); $table-&gt;integer('status')-&gt;default(1); $table-&gt;timestamps(); }); } /** * Reverse the migrations. * * @return void */ public function down() { Schema::drop('clans'); } } When you run your migrations, it will create a table for you based on that definition. You would also want to specify your indexes in these migrations, or create new migrations to add those indexes afterwards. That way your database changes are all version controlled and super easy for other developers on a team to set up.
Yeah this is the thing I was speaking of. Thanks for your help!
Here comes premature optimization
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Because changing frameworks afterwards is so easy. GL with your projects and unpreparedness.
Why not start with Lumen as a middle ground between the two and see if you really need full Laravel, it's smaller and faster but you can switch to Laravel later if you need to without much hassle.
I'll check it out. Thanks!
the varnish server sits infront of your web-server... its more or less like cloudflare, but something you maintain. &gt; How does varnish know when it's allowed to show cached version? Cache headers &gt; Lets say a product has gone out of stock. In this case varnish should not show the cached version of the website. Load time sensitive info via AJAX, IE don't use server side rendering &gt; What about having mostly cached websites but few changing things (like banners etc.) on it? Again AJAX. &gt; Wouldn't varnish make rotating banners impossible? Nope. Heck you can serve the rotating banners via varnish &gt; Or would I have to move the banner logic to JS instead of PHP? yessir.
 &gt; Lets say a product has gone out of stock. In this case varnish should not show the cached version of the website. You prune the cache when transactions happen. &gt; What about having mostly cached websites but few changing things (like banners etc.) on it? Wouldn't varnish make rotating banners impossible? Or would I have to move the banner logic to JS instead of PHP? ESI tags, Web-components or JS (your pick) There is a good talk by David Buchmann about it: https://www.youtube.com/watch?v=uL5t1mG2_SQ In general, the performance of Varnish in front of your app makes such a difference that you would wonder why you didn't use it before.
Nope... not at all... it just takes a different design.
So it doesn't... TIL. I only went with var_export because you suggested it in your original post. So serialize/unserialize would be your recommendation for a generic simple cache class then?
Holy cow. I never thought of this even though I've been doing PHP daily for 12 years... Thanks so much. This opened my eyes!
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What framework do you prefer?
I am just looking for statistics in order to see what classes of bugs would have been skipped easily.
Yes, `serialize` is the most common and stable way, JSON if you know you won't save objects or larger, multi-dimensional arrays. I actually had a `VarExport`-Adapter in Tale Cache before, but I removed it, it brings more problems than it solves. `var_export` is awesome for dumping PHP-config-files or code-generation, but it's not really suitable for caches (Which doesn't mean you _can't_ use it, if you really want)
Hence the quotes in my statement. :)
Yes! This is so important for the advancement of the professionalism of our industry.
Everybody is usually nervous too (even regular speakers) so don't beat yourself too much about it. It's also part of the "fun" (what makes speaking "out of the ordinary"), embrace it. Couple tips: - walk before the meetup/talk: helps channel and evacuate stress into "physical effort" (instead of letting it build up inside) - you can take breaks during the talk (e.g. to catch your breath, have a look at the time, …), e.g. on "title" slides (before each main part). It also helps catching everyone's attention back. - have a bottle of water, and don't be afraid to drink during such a break. Yes there'll be a silence but if it's on an appropriate slide it's OK, and it's much better than to have hoarse voice and be uncomfortable And also remember people are here for the topic, not you. They care about the topic and what they'll learn, they usually won't care if you stutter or have a shaky voice.
&gt; If phalcon is so incredibly fast why is not everyone using it? What's the cons of phalcon? Because performance isn't the number one concern for a lot of people. Phalcon requires an extension to be installed which is problematic. Understanding Phalcon's internals means understanding things which are not PHP, which is not interesting to everyone. And a complete lack of mindshare. There isn't (to my knowledge) a terribly large community forming around it which newer developers to the framework can lean on for learning and support. Certainly not compared to Zend/Symfony/Laravel etc. 
I spent about a year researching Laravel &amp; Phalcon. I tried both. I'm now using Phalcon for everything, and am very happy with it. Even ignoring the performance stuff, I like it for a few reasons: * Loosely-coupled - I prefer to use the framework mostly for the fundamental stuff like: routing/MVC/ORM etc, and tend to write my own classes for anything more specific most of the time anyway. Phalcon doesn't really care how, or how much I use it. * Breaking changes between versions are very very rare. Even the the upgrade from Phalcon v1 to Phalcon v2 (complete re-write in a different language) only required about 2 lines of code to be changed in my project. From what I've seen with Laravel, there's often a number of changes you need to make to your code when upgrading, which seems like a bit of a pain to me, especially if you have multiple separate projects to maintain. * Lower memory usage * I actually found it easier to get started with Phalcon for some reason, I think the loose-coupling and simplicity helped here. It gets tedious constantly seeing people dismiss Phalcon because it includes things that "you don't need" or "don't really matter", (performance optimization stuff). If these features aren't needed, or don't matter, why are they talking about them instead of comparing the other features/upsides/downsides of the frameworks? It's a good framework regardless of the performance stuff. The performance stuff is just a bonus to me. Something having a feature you "don't need" or "doesn't matter" alone doesn't mean it's a bad choice. Obviously you need to weigh up all the pros and cons in total. But assuming your comparison of two frameworks came out about equal ignoring the performance stuff, then the performance stuff on top is a pretty decent bonus to tip the scales. In addition to that, if performance is important: yes the common bottlenecks may often be elsewhere. But it's still a head start. And the fact that "its a compiled PHP module" is only one of the reasons Phalcon is fast... Because performance is the main goal, many other parts of how the framework does things internally are also optimized for speed. An example is the way memory is used when cycling through records in the ORM with a large result set. &gt; What's the cons of phalcon? * if you want to hire people with framework-specific experience, Phalcon is more niche, so devs would be harder to find * smaller online community to get help from (e.g. on freenode #phalconphp has 18 users right now, and #laravel has about 470) * less functionality, Laravel has more by default * harder (but still possible) to explore the framework's code to see how it works internally * needs to be compiled on the server, and additionally would be difficult to run different Phalcon versions on the same server I'm a solo dev, and none of the above are issues for me, so the pros outweigh the cons in my situation. You asked about page execution time in a few places, I've got sites serving fairly simple pages in about 4ms to 15ms with no caching set up or anything. 
I guess if all you're storing is outputted HTML then the quickest option is just to write that (and nothing else) directly to the file, and then just use `return file_get_contents($file)`?
BOLT CM! https://bolt.cm/
Ok guys so when do you specify return type of a function, and when not?
Bonus on the water tip: if you catch yourself rushing, talking to the point of breathlessness, or just have a panicky moment onstage, a sip of water will help you catch your breath. I use this trick with inexperienced speakers regularly. 
Correct answer: by using neither
Ideally, always. You should always know what type your function returns. However, in practice, and since you are using a dynamic language and more often than not you are maintaining code and not writing from scratch, specify a return type when it makes no sense whatsoever that the function would return anything *else*. As always, a code sample would be better, but I'm on a run, so maybe somebody can chip in. This also applies to types in function ~~statements~~ parameters by the way
Lol
You use a return type when the type that is returned is essential to your application's integrity and workflow. Though really it isn't going to hurt to specify it all the time 
Ok, if the ideal is to always return a value, or specifiy a type of function argument, what about the scenarios where a function might return null, array or stdObject? Or a method parameter can be both string and an array. Should such techniques be avoided in php7?
Have you developed a site in either Laravel or Phalcon before? If so the one you're more familiar with might be the better option as development time will be quicker, and you can optimise performance later. If you've used both and are equally skilled at both, then choose the faster of the two. &gt; How slow is it? I don't want to end up having pages load for 500ms+ It's not the fastest framework around, but by using PHP7 and opcache, you can get respectable performance with little effort. &gt; If phalcon is so incredibly fast why is not everyone using it? What's the cons of phalcon? I think the biggest drawback is portability. You can only run the Phalcon site where Phalcon is installed on the server. If you're setting up your own servers that's a non-issue, but Phalcon isn't available on the majority of shared hosts. &gt; Since HHVM supports laravel why is not everyone using it? What's the cons of HHVM + laravel? You might want to use third-party packages and your choices might be restricted by requiring HHVM compatibility. Also PHP7 has narrowed the performance gap with HHVM, and most things will work happily with PHP7.
Yes, but always think about the fact that a user could access your cache files via the web, so make sure to protect them properly (e.g. with a `.htaccess`-file)
Ok practical example: For a last job, client X wanted this template: http://themeforest.net/item/avada-responsive-multipurpose-theme/2833226 Please take a look at the feature list of bullshiznits, do you want to make this template work in Bolt? Or do you want to download/install it and be done with it ;) Everything people want is there in all shapes and forms.. for Wordpress :\ You cant sell 1 day of work vs 1 month of work either, they'll just go the other guy that does want to use Wordpress It's not that CMS that matters, with all its pros, cons, whatever.. Its the platform that sells
Has anyone ever actually used the double dollar sign notation in a real production system without fully intending to troll the next developer?
&gt; You don't always have to use Ajax, edge side includes are often handy http://varnish-cache.org/trac/wiki/ESIfeatures Oh neat, Didn't know of this... It's not very often I get to toy with varnish.
Remember everyone there wants you to succeed. They are not waiting to judge you; they're wanting to get the information you have. Focus on that information. As /u/mnapoli said, silence isn't really a problem. Don't be afraid to stop talking at the end of a thought, read the next point, and go on. It takes less time than you think. Likewise, when you get to the end of a slide, stop talking, focus on advancing to the next slide, look up, and begin again. That helps your pacing and gives you a moment to process the new slide before moving on. As a corollary to my first point, nobody much remembers your mistakes, just the content. Don't be afraid to say "sorry, let me repeat that," and reword something in a better way. What will get you in trouble is looking down at your slides and reading them. As long as you use the slide to cue in your mind what you're going to communicate, remember that you're talking to a bunch of individuals, and they want the information just like you were explaining it to each of them individually. So if you find yourself reading or otherwise stumbling, find a person in the room looking at you and deliver the next thought as an explanation just to them. Then pick another for the next thought, and so on. This is a lot to remember, so main takeaway: everybody wants you to succeed and won't remember the mistakes. Something WILL go wrong; it happens to the best speakers. That's not the point. The point is the information, so if you stumble over something, just go over it again. If it's just a stutter, nobody cares. Let it go. Just remember what you're explaining, and you'll be fine.
From my research, caching will do far more for performance than switching frameworks. Also, it will take a significant amount of traffic to even reach that point.
Could you tell me why you would prefer symfony over laravel?
Interesting. Thank you for taking the time to write all this!
I have no experience on either. I've written two different frameworks myself with ORM, caching, file handling, authing, encrypting etc. but now I believe it's time to spend the time on the actual code instead of the framework. When I started this topic I was unaware that PHP7 narrowed the gap so much. I have dropped the HHVM from the list by now.
That's true.
So the real question here is: Which framework better supports my desired functionality such as caching?
Having implemented a fairly large project with Phalcon, I would pick Laravel for a number of reasons. 1.) Debugging can be a huge PITA and your code behaviour can change depending on the version installed. We ended up building loads of functional tests because of significant changes between minor releases. 2.) Black box - some of the documentation can be patchy when it comes to specifics. On a complicated project digging around in C gets annoying quickly. 3.) The integrated ORM can be hugely painful - if your app is DB heavy I would steer well clear. It is insanely fast, but combining other technologies to scale a PHP based framework e.g. HaProxy and Varnish will save you tearing your hair out. PS I was using the version 1 release. 
For locals no, for properties/methods yes.
The ultimate solution would be to create either a brand new CMS that was API compatible with WP, or writing a compatibility layer for e.g. Bolt CM
From the fact that Dmitry submitted this RFC, you can already suspect that there's likely an ulterior motive relating to optimization involved :) In this case the proposed changes will allow us to avoid checks for the population of the `$this` compiled variable when performing a method call. (As this removes the last difference between function and method calls, this will also allow emitting more specialized call instructions in some cases.)
Lol right? Build the whole project and then switch frameworks at the end to get a speed boost.
&gt; what about the scenarios where a function might return null, array or stdObject? Refactor.
What monsters would write any of this code D: Glad to see everyone voted yes so far.
&gt;Loosely-coupled - I prefer to use the framework mostly for the fundamental stuff like: routing/MVC/ORM etc, and tend to write my own classes for anything more specific most of the time anyway. Phalcon doesn't really care how, or how much I use it. Neither does Laravel.
And don't forget that with today's abundance of deploying tools microservices are easy. You can implement CPU-heavy tasks with Go and IO-heavey with node.js and keep other non-critical code in PHP or whatever your team is better at.
Thanks for the suggestions so far. It will really help a lot. 
Oh! :)
&gt;Ideally, always. I still really don't get this thinking with PHP - it's a duck-typed language and it's never going to be willing to break that and become statically typed. Since it won't, PHP can't take advantage of many of the real benefits of static-typing, but trying to treat PHP like it's statically typed will still strip most all the benefits of duck-typing since you still end up bound to taking care of all the formalism it requires and even then you're still bound to the obviously-meant-for-duck-typing casting system of PHP.
That's good to hear. Thanks! BTW, sometimes the costs are not the problem. If my main problems were hiring and costs I would have mentioned those in the original post.
They're just not in my webroot, easy.
Interesting idea, not sure why downvoted for an opinion... Personally though I think a `this` keyword fits in better with existing ones like `self`, `parent` etc. class foo { function getBar() { return this-&gt;bar; } }
Personally, Laravel is the way to go. But it really depends on what you need to do.
- I don't like the static facades, they could teach bad habits to unexperienced developers. Their main selling point seems to be "beautiful code" which comes of immature and hipster to me. They are obfuscating things for a useless purpose imo. This obfuscation also makes it hard for decent code completion is some IDEs - The default ORM is active record, which I find inferior to Doctrine. - the default templating system, blade, is far less supported by IDEs Mind you, these are obviously all highly personal preferences... YMMV. The fact that so many other projects, including laravel, use many of the symfony components really says a lot about their quality...
I have to check out the ORM thing. It's one of the most important things for me in a framework.
What about Slim ;( slimframework.com
Websocket is just the transport. A robust architecture would separate logic and transport and could work both with REST or websocket independently. I like to use different strategies depending on the communication: For example you can use a REST web API to communicate from client to server, but then receive the information from the server over the websocket (only using it to retrieve data). Long polling can work too, but it's not so easy to implement. Server-Sent events are nice, but do nor work on IE or Edge. Pusher.io could be another solution: their API can connect the client from any browser or even a native app. You can call a REST end-point to push events to all clients connected or just some of them (you can create lobby / channels). Real-time (and bi-directional) will require have an API so the client knows what it can send, but also an API so the client knows what the server can send to him. You're quoting Slack and it's a good example: they have the RTM over websocket, but also a web API, an incoming webhook API (you can receive content over HTTP). The websocket is nice if you build a bot just for your team, but when you start to distribute your app and need to scale it and maintain 1000's of websocket connections, the pain starts to build. Receiving the events over HTTP (webhook) would be so much easier.
- use Symfony - dont make early optimization 
Why Symfony over Laravel?
Another example: StackOverflow will serve the same HTML front page for everyone, and then the personalisation to change the background color for your favorite tags is just a bit of JS running after the loading. If you go firther, you can even store those tags in localStorage or whatever, you don't even need Ajax to give a personalised homepage for everyone :)
Crazy powerful. Thanks so much for showing me the light! :)
Just use http://phpcrawl.cuab.de/
When I was in high school, I was absolutely terrified is speaking in front of people. I'd take a zero on an assignment rather than present it to the class. When I got to college, I was forced to take a speech class for my degree. I took it over the summer so I could get it over with as quickly as possible. For the first "speech", I had to read something aloud. This wasn't too bad, because I could just look at the paper in front of me and pretend I'm reading by myself. For the second speech, I had to spend 3 minutes describing a quality about myself. I chose (in retrospect very smartly) to talk about my stage fright. I got up in front of the class, stood behind the podium, and then proceeded to do everything the teacher had warned us not to do. She told us not to stutter; I stuttered. She told us not to shift back and forth; I shifted my weight back and forth. She told us not to apologize for screwing up; I apologized a hundred times. "I'm uh, I mean, uh.. Sorry, my quality is that I, uh, am terrified of um, getting up in front of people, and uh, I think it's because, um, everyone stares at, uh, at me the way you are all um, staring at um, staring at me now. Um,..." I got an A. She wrote at the top of my grade sheet, "Great acting!" That was the proverbial lightbulb moment for me. I realized that she wanted me to succeed, so she projected that onto me. I realized that even if I had fucked up, she would rather think I did it on purpose, because she wanted me to succeed. And I realized that nobody out there wanted me to screw up -- they all wanted me to succeed too. They thought I was being funny! They thought I was just pretending to be as nervous as I was! I literally almost shat myself, but they didn't believe it! As a result, I gained a lot of confidence in my speaking abilities, and I actually wound up getting a degree in Theatre. Yeah. I'm not kidding. So I guess my big advice is this: nobody is rooting for you to fail. Even if you fuck up, they won't care. Worst case scenario, they'll say "He wasn't a great speaker, but his ideas were good." And ten minutes later, they'll completely forget all your screwups but they'll still remember what you talked about. Good luck.
This is an excellent answer. I'm on the same boat and we're migrating a bunch of projects at our company to Phalcon (that would get a benefit from the upgrade, of course). Not only the performance stuff but also how the framework works both internally and externally when implementing it. The huge drawback I have is the smaller community, and that's it. The functionality can either be filled in with composer packages or your own implementations (of course this takes more time and effort, but if performance is a big concern, composer packages might not be the best fit). Having different versions of Phalcon on the same server doesn't make sense to me, I get the idea of having different projects probably requiring different versions..but if you're going to have a standarized infrastructure with several projects distributed among several servers..having one version of the framework should prove to be a better practice, so that everything is the same for everyone.
&gt; I strongly suspect that this will be a breaking change for code obfuscators. And nothing of value was lost.
Nice RAS syndrome you got there buddy
the first thing that loads on this page is a newsletter signup modal... srsly
&gt; it's a duck-typed language and it's never going to be willing to break that and become statically typed. PHP will (almost certainly) never *force* a type system upon everyone, but it's very much matured (as of 7.1) to the point where you can treat it as statically typed^1 and write your code as such. If you do, you get the benefit of having explicit types that you get it many other languages. If not, it will continue to write with the flexibility and relative unpredictability of python or ruby. The big area that's lacking is that typechecking only happens at runtime since there's no explicit compilation step. I'd be surprised if tooling to fill that gap, like hacklang's, doesn't eventually make it into core. ^1 except for a couple features, such as generics (will probably happen eventually) and sum types (probably not)
[removed]
PHP is not a duck-typed language
I had some problems talking in front of people, and next week I'll give a speech in front of roughly 1000 people. Here is my advice for it: 1. You are doing this because you want to. You know things about the topic, they want to learn from you - as long as you are prepared they will be happy. They will learn from you and that's exactly why they are there. 2. It's completely okay to be terrified. But try to really think about why you actually are nervous - do you even have any real reasons? Of course you could make mistakes and the like, but even that's absolutely fine. Don't be angsty because you are - if you have any real reason, find it and fight it. 3. Try to be calm. I know this sounds shitty, but being calm is the absolute best thing to do. No matter how frightened you are, give your absolute best to speak slowly in the beginning, to have a calm voice, to make enough pauses, and to speak loudly. If you do that in the beginning, you'll continue doing so during the whole talk. All in all: You can be nervous and calm and the same time. Show them that you are not going to let your nervousness get to you, and that you do know what you are talking about - really, everything else will come with it!
A lot of it comes down to it providing a lot of 'out of the box' functionality in a standardized way. Taking Laravel as your example, you get config management, a caching interface, email interface, an ActiveRecord ORM, database migrations, a router, templating system, localization functions, form validation, a queueing system, a console command system, a scheduler, response/request handling, and a lot more, and they all work in a similar fashion and can easily be integrated together. You COULD build your own versions of each of these systems.. and you COULD use a bunch of disparate packages to provide the same kind of functionality.. but if you can't answer why you would do that, and you need all those features, then using a framework with a consistent implementation makes a lot of sense.
How not?
Duck typing is when an object is considered to have a type when it implements that type's API rather than when it declares it implements a type. I'm not convinced it applies in the scalar case you're talking about.
You can write PHP like a duck-typed language though: class Duck { public function quack() { return "quack!"; } } class Doctor { public function quack() { return "why yes, I am bad doctor"; } } function duckTestIt($object) { return $object-&gt;quack(); } $duck = new Duck(); $doctor = new Doctor(); echo duckTestIt($duck) . "\n"; echo duckTestIt($doctor) . "\n"; # &gt; quack! # &gt; why yes, I am bad doctor You can also write it like a non duck-typed language.
well, neither does symfony...
&gt; I've got a time-window of around a week coming up where I have no major project deadlines, so I want to use this to learn and have a mastery of at least one framework that I'm not familiar with yet. I applaud your ambition.
I've worked with CodeIgniter from v2 onwards and still have to use it on some legacy applications. Laravel is my goto framework. Much of the benefit of Laravel only becomes apparent as you spend more time with the framework. Here are a handful of things I now depend on that I never implemented all that well (if at all) in CodeIgniter: * namespacing. App/Product/Create.php (App\Product) vs. App/Product/CreateProduct.php. (without namespacing). Introduce say App/Category/Create.php and without namespacing you have a class name conflict. Now times that by the typical number of models in your app (say x15) and the benefit is clear, if merely for the reduced typing required! * proper functional and acceptance testing * Middleware * Access to Symfony Response and Request * Filesystem * Artisan * Service Providers * Dependency Injection * Eloquent Every single one of these tools completely pants the CodeIgniter equivalent. I could on and on, but 2 years ago I didn't care about any of this stuff either; you just learn to love them through experience. 
First of all: namespacing, now that it's done properly in L5, is a huge advantage. Lack of namespaces *is* restrictive as you have to prefix class names, and get CI to load stuff for you via special functions (`$this-&gt;model-&gt;load` etc) instead of just using classes (`new PostModel` etc). CI's routing is pretty bad tbh, you're encouraged to use magic routes (ie `example.com/controller/method` -&gt; `Controller::method`). Having clearly-defined routes is great. Besides that, Laravel has a ton of useful features built in: user authentication, database migrations, templates (instead of raw PHP in views), cron jobs and queues to name a few.
Cost may not be what you think the problem is, but if you are looking to a framework you are at least subconsciously aware of opportunity cost. You want some library code somewhere to provide the infrastructure you need so you can get on with building and shipping. There is always a "cost". Be that pure dollars, or time you could have spent working on something else or time you could have spent playing with your dog and kids.
&gt; Access to Symfony Response and Request If you look at PHP-PM (not fpm) you will notice that they require a proper request/response abstraction because of the way the process manager maintains code in memory. https://github.com/php-pm/php-pm Wordpress is unsupported precisely because they use custom $_GET/$_POST abstractions that won't work in that environment. I am not not an expert, but I think CodeIgniter would suffer the same fate.
I picked it up from the documentation on the website, which I think is fantastic. I had prior Symfony experience, but that was something I picked up from their own documentation because it is also fantastic. If you end up having specific questions, the learn laravel subreddit (https://www.reddit.com/r/learnlaravel/) would be an awesome place for that. There is also a Laravel Slack channel: https://larachat.co/
&gt;statically typed and write your code as such. Are there tools for doing the static type check? Preferably something that does not require me to use a specific editor. 
Use it and like it!
I think there is mistake in presentation, Twitter isn't build on top of PHP, actually it is Ruby
&gt; But in Javascript functions are first class citizens and it seems natural Pretty sure they're first class citizens in PHP as well. For example, the following works fine $test = function ($a, callable $callback) { echo $a; $callback(); }; $test('Hello, World!', function () { echo "Goodbye, Cruel World!"; }); Hell, so does the following $echo = function ($a) { return function () use ($a) { echo $a; }; }; $test = function ($a, callable $callback) { echo $a; $callback(); }; $test('Hello, World!', $echo("Goodbye, Crueld World!")); But maybe I don't have the right understanding of what functions as a first-class citizen means. What's lacking from PHP that would make functions first-class citizens?
What is the equivalent of that in javascript? 
On using JS for front-end, if at all possible load in a placeholder using PHP or use ESI; it's horrible when AJAX fails or takes too long to load and you have to use a page that doesn't have placeholders. It also reduces re-flow front-end to have placeholders
 var someFunction = function (a) { console.log(this.someProp + ' ' + a); } someFunction.someProp = 'some value'; 
What kind of placeholder should I have for, lets say, product stock value?
&gt; Do they have any real advantage over $_GET and $_POST apart from aesthetic value you get by converting to a $input object? Good lord yes, it's probably one of the biggest advantages of any framework IMO. Hell, even if you wrote plain PHP you should strive for something like this. There's several reasons A) It decouples your controllers from global variables (You are only accessing inputs from your controllers, right? Not your domain or your view layer, right?) and from HTTP. If you follow SOLID Principles (which you should), then your function should only do things based in things directly given as inputs. No global variables. No pulling things in from `$_REQUEST` or similar. B) Your Controllers shouldn't be aware of *where* the data comes from IMO. If you're building the data as part of a unit test or through an HTTP interface, that shouldn't matter. C) Much easier to mock in tests. If you have `public function get(Request $input)`, when you create tests you can just do `$input = new Request($data); $controller-&gt;get($input)`. Where as if you have `public function get()` that accesses global variables, then you have to make sure to know which variables it's getting, make sure they're clean and only mocked data, not polluted from other tests or anything, and then do your mocking by setting global variables. Evil
Most of our devs use VirtualBox anyway especially the Mac devs.
We're doing exactly that at work, take a premade template en make websites as fast as possible, selling them for a really low price It sucks, being a developper is not installing WP themes and soon everyone will be able to make good websites with services like Wix or Squarespace That's why I'm trying to quit this job, this has no value whatsoever, it's boring, you're not improving your skills, you're wasting your time and when you must do something yourself it's always a pain (themes that are made by random dudes from India are always a pleasure to dive into). This business will most likely decline soon, as more and more companies will just do it themselves and prices will be so low that it wouldn't even be worth it
The hardware where your devs work is irrelevant. Where you run the code it's the point here. The place that you run the code should be the same for all of them, and it should be the same as in production. That's why you use VMs where they deploy the code (PHPStorm does it automatically, for example), and you code in whatever OS you like. 
I thought that PHP was platform independent. If you have unit tests this should be no problem, I think. I always try to write my codes in such a way that it has to work whether it is on FreeBSD or Windows or Linux. Also I like to have programmers which run different browsers and operating systems. Different PHP versions is another story of coure, they should all use same version.
The JavaScript closure scoping can also get annoying with naming collisions. Also, JS's "this" works completely different and inside classes you have to `.bind(this)` callbacks most of the time, which PHP does better (It preserves `$this`) Both have advantages and disadvantages. Both will fix those disadvantages with Lambda-Expressions 
Whoah, thanks for taking the time to write all this! The 3. sounds awesome. How does Eloquent handle rollbacks?
&gt; classes you have to .bind(this) callbacks most of the time If you're talking about what I think you are, that's actually fixed in ES6 with fat arrows. Declaring a function with fat arrows automatically preservers this. Which brings on it's own nuisance of inconsitant behavior depending on how you define the function, but I think it's worth the cost
I agree. This guy has taken nearly 5 days to get his environment set up. He is blaming Windows. How can I get him set up?
in javascript functions are objects (with properties, methods etc) ... just like in PHP you have classes with an `__invoke` property. So your question would have the same answer as the one for "what is the actual use case for having classes with an __invoke method?" :)
If he is taking 5 days to setup his dev environment, I would question his ability tbh. Windows or not, that is an awfully long time.
&gt; Both will fix those disadvantages with Lambda-Expressions Lambda-Expresions === Fat-Arrow-Syntax (Which is currently in RFC in PHP and will surely be in somewhere in the future. Here it won't change `this`, but will preserve scope just like JS)
Great, people sometimes giving just up instead of configuring it =) It will be some good surprises when you working with it on daily basis. Do you use quick-fixes already (you can do bulk fixes for some warnings)?
Thought the same on the first day.
For a corporation working in 26 countries with over 50 offices it is. We have zero legacy systems.
It's still not bleeding edge. 7.0 might be called bleeding edge. The real bleeding edge is [7.1.0alpha1](https://github.com/php/php-src/releases/tag/php-7.1.0alpha1).
&gt; True, although that's never happened because we always use the exact same version of PHP. There is much more going on than the version of PHP and MySQL you're using, even assuming you're also all using the same web server version as your production servers. For a start you're presumably using Linux to host the actual servers and while OS X has a lot of similarity to other *nix systems, it is still a very different beast. Further, each developer will have their own set of weird and wonderful applications running that can potentially effect the system that would be present on your production machines. It really is so much simpler to have all developers testing their code in a VM that mirrors as closely as possible your production environment. There's no need to invest in getting your application run in an environment that is completely different to your production environment, when you can just make the same VM image available to all your developers, regardless of the OS they're using.
&gt; Windows always seems to be a really big problem for us especially when we need to give a semi-technical user upload access to an server that requires ssh keys for example. Presumably by "semi-technical users", you mean people who wouldn't be comfortable using SSH directly? If so, have you taken a look at [WinSCP](https://winscp.net/eng/download.php)? It can connect by key to a normal SSH server and gives the user an FTP-like interface for bidirectional file transfer.
What's he actually struggling with trying to get this set up? As you've mentioned in other comments, your system doesn't run on Windows, so presumably he's trying other methods to get it running?
You have my sympathies.
My bad, you're right thanks
&gt; if ($_POST) $_GET = $_REQUEST; I don't know why but I really love this. Almost gives me a feeling of nostalgia.
That was a very clear video, and was well presented and concise. Nice work. I do however have one point to make: `ImageHandler` as a class name was perfect for demonstrating how to improve your code, but I thought you were going to take it a lot further than you did and remove the class entirely. What does `ImageHandler` do? Can you tell me without looking at the code? What do `ImageValidator`, `ImageResizer`, and `AmazonS3ImageUploader` do? It's much easier to guess right? Though I understand you wanted to keep this brief.
I have a file like this. And it's not all code written by other people...
Pure gold.
&gt; $id = @$postData['id']; &gt; &gt; $id = (!empty($id)) ? $id : null; And this steaming pile is exactly why I love the null coalesce operator. I think it's my favorite part of PHP7. That's saying a lot as I think I danced a jig when scalar types made it in. I just wish I could use PHP7 on all my projects. :(
Honestly, Flysystem is not the holy grail in file-system manipulation just because it has a ton of adapters for shit. I had a really hard time managing a synced directory structure with it. The API is not optimal (which really comes down to personal preference), some things are missing _because_ you have a ton of adapters for shit and it's not the most performant solution out there. You don't take a jackhammer when a stupid stone from the floor would do just fine. Before you go and use flysystem for normal file-system manipulation (in case you don't need any adapters, of course), learn about PHPs standard functions and SPL (`file_*_contents` , `f*`-functions, streams, stream wrappers, stream contexts, `glob`, `scandir`, `SplFileInfo`, `DirectoryIterator`, `FilesystemIterator` and `RecursiveDirectoryIterator` etc.) Most of the things Flysystem gives you for normal file-systems are already implemented in the very own language it's written in, it's basically just a wrapper around those with a different API.
This seems way more complicated than, for example, the Slim model, and I don't understand what you gain. 
Apart from what others already said, I'd like to highlight some stuff you can do with artisan: - Scaffold lots of parts of your app, very valuable for rapid prototyping, especially if your app ist RESTful and falls in the CRUD spectrum (create, retrieve, update, delete). - Run or rollback database migrations. When I push code to git master, a git-hook will take care of pulling the code to my staging server, install all dependencies and run `php artisan migrate` to update the database. - `php artisan tinker` gives you a command-line interface to your app. You can use that to create database records (through Eloquent models) or test parts of your app. It's awesome and I couldn't live without it. - queues and scheduling. You can queue up jobs and schedule commands (cron). Very helpful to have that come with the framework. When you deploy your app, you just need to add one single cronjob that runs every minute. Everything else lives in your codebase (and thus, git repo).
Flysystem has its use case, if you're not using any of the adapters it's of course overkill to have it instead of SPL functions. I find it very handy because the requirements of copying files to FTP/S3 can be implemented quickly.
Actually the new PHP 7 null coalesce operator is for this like this, [from the docs](http://php.net/manual/en/migration70.new-features.php): // Fetches the value of $_GET['user'] and returns 'nobody' // if it does not exist. $username = $_GET['user'] ?? 'nobody'; // This is equivalent to: $username = isset($_GET['user']) ? $_GET['user'] : 'nobody'; 
Get a Laracasts subscriotion. $9 well spent and you may only need it for a few months while you learn, but you'll probably just keep it for a while.
You and I must work at the same company! lol I don't have specific examples I can post right now but I will say that the original devs developed right on production. To test stuff out they'd copy file_name.php to file_name2.php and then sometimes they'd update all the calls (or most of them) to file_name2.php but sometimes they wouldn't. And they never deleted the old copies either. And so now we have lots of different copies of the mostly same files. file_name.php, file_name_2.php, file_name_test.php, file_name_test_2.php, etc. And sometimes it's file_name_test_2.php that's being used and sometimes it's file_name.php that's being used. It's really annoying.
 throw new \Exception('jdfgsdjfgjh gdsfjhg');
Yes it does, sorta. :) The original code also sets $id to null if $id evaluates to false. https://3v4l.org/O181P This gets you partially there and, depending on what you are actually doing, might be enough. $id = $postData['id'] ?? null; To fully get the same behavior as the original code you'd need $id = $postData['id'] ?? null ?: null; All using array_key_exists would do is the same as null coalesce in this case. $id = (array_key_exists($postData, 'id') ? $postData['id'] : null); And in this case it would be the same as my second example $id = (array_key_exists($postData, 'id') &amp;&amp; !empty($postData['id']) ? $postData['id'] : null); EDIT: Fixed some typos
I am not familiar with that joke, could you enlighten me?
Search YouTube for "who's on first"
I'm going to guess that it probably does. At least I hope. The WTF there, at least to me, is the lack of type declaration in the function signature and the manual checking of object type instead.
I replied here to a similar question https://www.reddit.com/r/PHP/comments/4n414o/nextless_middleware/d40tqyi While it may not be more "php-like" it seem simpler. I am honestly interested in what I am actually missing from the picture.
 models.Items.findAll({ limit: '1; DELETE FROM Items WHERE 1=1; --', }).then(function (users) { console.log(users); }); If they were using the mysql_* functions this wouldn't be possible. Shouldn't prepared statements have prevented this?
This is Node.js, which is its own beast, so I'm not sure what you're asking. The takeaway here is: If you're using an ORM, when was the last time you looked under the hood?
 Adodb: $false = false; return $false; ...come on!
&gt; It's not like one untyped variable is going to cause the whole thing to fall apart - in reality, the lifetime of almost any given variable will tend to be small relative to the lifetime of the request. It can still very, very easily create an untenable situation for static analysis. Any time the type is only computable at runtime the best you can do to prove type-correctness is check all possible cases of type that result. `strstr` return either `false` or a string for example. Following a call to `strstr` you can't assume you know what type it returned, and so to prove type-correctness in all cases you'd have to do all future checking for both the case of it returning `false` or a string. And of course that compounds with other calls to `strstr` or any other mixed return type function. $count = NULL; $thing = str_replace('x', 'y', $str, $count); return $count; How about that example? What's the type of count? Well obvious it's a `NULL`, except `str_replace` will covertly change it to an integer! This is really one of the big ones with why such a loosely typed language can't be adequately statically analyzed - because variables can change type without warning. Without extremely detailed information like, for example, the fact that `str_replace` will swap out any value in the 4th argument for an integer, you either will incorrectly guess $count to be a `NULL`, or you'll have to give up and admit you don't actually know what type the returned $count will have because it was passed to a function and may be altered. &gt;It's not perfect by any means, but it seems like a very good compromise between static and completely-loose type systems. PHP allows you to solidify a prototype by adding type information (imperfectly, but enough that it's still useful especially with any amount of test coverage). That's what I doubt - I don't really see many benefits relative to true static typing, but you still get most of the required hassle in a statically typed language of specifying types.
It would take too much time to write all my finding, because almost every single file is using hacks, the worst practices, code duplication and any other wrong stuff you can imagine. Basically it's an image on a right http://i.imgur.com/J1svNp7.jpg with more wtfs
Or it was written by someone not familiar with PHP 5. I taught myself to code primarily with PHP around the time PHP 5 was released and I'm pretty sure around that time I (could) have written most lines shown. :x I know it shows namespace usage, but that could have been refactored in later without touching anything else.
Link: https://youtu.be/kTcRRaXV-fg
&gt; far more complex You must be joking I don't understand the aversion to not having `next` as a parameter :)
 if (!$var == '') { // it contain something, Wow
Outsourced development, only 9 bucks an hour per developer, what a bargain!
Thanks!
We all have deadlines that we have to deal with. It's wiring that *knowing you can never come back to fix it* is the painful part. 
Might also be: "found this bad code but no time to fix it now so at least tag it".
Magic booleans
is it because im on a phone that the coee loojs like its all on one line and blobbed together with no formatting? If thats really how it is (sorry if it isnt) why not let something like phpstorm or some tool reformat the code out into something less ridiculous? it was the only way I got through debugging some legacy code where someone decided to be a smart guy and forego formatting altogether as he thought its be more difficult to "hack"
IMHO It's too small a detail to load singularly, and I'd advise you get all product info in one hit and provide a product placeholder. If you have to deal with price, then load the price you'd display in the bulk listing i.e. "from $299". It means you default to the most likely to sell options and price, and use JS to load the more premium offerings. I Have also heard tell of people defaulting to the most expensive option, but I'm pretty sure it can get site owners in trouble as it's morally a bit downwind to mislead people towards purchase stating "from $19.99" then have a product automatically select "$49.99" options.
&gt; then why should I learn Laravel? Because it's *not* CodeIgniter. Checking out different tools of the trade lets you learn new things, see how other people solved the same problems, and generally broaden your palette as a developer.
While yes i get the point, make sure your ORM of choice is still preventing sql injection... The sensationalist headline isn't necessary. This isn't Gawker.
Was this the result of a pay-by-line contract, by any chance?
I almost wrote this off as legacy code before type-hinted objects were available, but then I saw `\InvalidArgumentException` and said nope, definitely a WTF. Edit: one far-reaching maybe is that you can catch exceptions and handle them in code, but a runtime error of passing in the wrong type produces a Catchable Fatal error that halts processing. But don't read this as me excusing the behavior. I'm simply trying to rationalize...
I can't read it at all on my laptop screen :/
&gt; That right there is some award winning shit Still not as bad as: foreach ($_POST as $key =&gt; $value) { $$key = $value; } But a good runner-up at least. :)
Oh yea I agree with that for sure
http://stackoverflow.com/questions/2468487/how-can-i-catch-a-catchable-fatal-error-on-php-type-hinting Seems you're right that PHP 7 handles it differently.
That's something that's always bothered me with prepared statements: you can't parameterize stuff like table names, column names or top/limit values. So if any of that needs to be dynamic you're back to escaping your parameters the best you can, and that's a potential security hole. Is there a reason why db engines can't accept placeholders for anything that's not a keyword ?
Can you explain the difference?
Could be somewhat off-topic, but here it goes. I've gotten to a point where I'm losing interesting in PHP(or rather programming in general). Not because I don't like it, it's simply becoming dull. Same problems, same projects, same thing all over again. Fortunately, lately, I've had the pleasure of only working with good frameworks and decent projects, but even that becomes dull. As it stands the only reason I'm still going to work in the morning is that I need the money. Some of you may think:"Well, if it's dull then you're not looking into new things". Things is, I am, daily. I read articles, I try to keep in touch with what's new and such, heck, I even answer questions on stackoverflow(more out of boredom than anything else). Has anybody gone thru this? How do I learn to love it again? Because, honestly, I started out as absolutely loving to program.
Or simply `extract($_REQUEST)`
That ternary operator. Dear lord. Were they just going for code that looks complex? Totally unnecessary..
&gt; In our little sample $_POST is always set so that IF can be if ($_POST) or if (1==1) or just omit the damn IF. If $_POST is an empty array (and it will be on GET requests) the if statement will return false, do it does do something. Doesn't make the code any less ridiculous though.
If you're already writing good code, can you write better code? Is it covered by tests? Have you tried test driven development? When you have to touch gross old code, do you refactor it? Code written for work is almost always boring, but at least it's possible to take pride in a job well done. Come to think of it, good code is always boring. It does exactly what you'd expect! Perhaps the code is not the problem. How's your relationship with other people in the office? On other teams? Are you respected? Can you take initiative to make yourself respected?
surely just using `PDO` with bound parameters over utf8 charset &amp; input is enough? It seems to be the approach taken in EasyDB
Mostly. You can't parametrize "LIMIT $foo". The way I approach that is to [only ever accept integers](https://github.com/paragonie/airship/blob/d7d4e8900cc8923d8089a7ab6213a76d73818b99/src/Cabin/Hull/Blueprint/Blog.php#L1383-L1384) (bonus: with strict_types).
&gt; Your middleware is not $next-less. You just changed method of injecting $next from parameter injection to setter injection. Well, you cannot have a middleware implementation without a `next`. I was referring to not passing it as a variable to a function. Also, the gist is not supposed to be a fully-working solution. BTW, a middleware does not require $next because it may be the last on the stack. https://github.com/relayphp/Relay.Relay/blob/1.x/src/MiddlewareInterface.php
Alternatively write a single `map` routine namespaced to your project: function map(callable $f, $input) { foreach ($input as $key =&gt; $value) { yield $key =&gt; $f($value); } } Then you only write a transform function instead of the class boilerplate.
They were using git when I was hired. The original devs left years ago but they left their mess behind! I gather the dev who did the git conversion just did `git add *` and then created a dev box and started developing in that, figuring that the mess could be cleaned up later, as time permits, but none of the commits prior to my start date seem to do any sort of clean up so who knows.
Yeah it is a nightmare. This usually happens when the majority of "developers" don't have a dev server environment. They still want to test them, so they quickly FTP the production server, make a copy, modify, and upload. FTP clients even make it very easy to auto upload after changes. I know this because my friend, a WordPress developer does the exact same thing. I watched him doing some changes, and I couldn't imagine how terrible his work life should be. 
...or [register_globals](http://php.net/manual/en/security.globals.php) lol.
Hah. Of course that makes sense, thanks !
"Oh noes! We got the 'jdfgsdjfgjh gdsfjhg' error!"
&gt; because its smaller in comparison to Symfony/Zend What does the size of a framework have to do with anything?
This one got me. Literally went buhhhh what how... o_-
It might break code or tests who parse the error message itself. For example a library might parse errors to translate them. It is not the proper way, but I've seen it done before.
Still not as bad as the time I was called in to fix a Codeigniter site... the original dev said he could build it in 3 months, and he was wrong. He didn't know about or understand MVC, so the whole thing was some kind of horrible Frankenstein's monster that was somehow running as a singleton. None of it was commented or made much sense. It was the biggest, most godawful mess I've ever seen. And then they showed me the 'admin site'. The dev said he could build an admin dashboard for the site in two weeks. The result - a literal copy-paste of the original code in a folder called /admin/, with some half-assed modifications that didn't work right. They paid me over $1000 to get it into some kind of working shape after it had gone over budget by multiple thousands and missed its deadline by two months. I did what I could, then told them their only option was a complete rewrite, and then they said they couldn't afford my rates any more. For all I know, it's still out there somewhere, giving some other poor developer nightmares.
Yep, have had that one.
Does using this package have any advantage at all compared to simply adding stuff to a `config/features.php` file and then using `Config::get()`?
Absolutely correct. Just wanted to show how iterators and generators can be combined easily :)
I'm working with something like this now. I opted for creating what I'm calling sets which I think is best thought of as temporary work areas. * First, I let them select the columns they want via a form and I use that input to create a csv template they download. * Then, I let them import their template back into the system with data. * Finally, if they're satisfied with the results they may publish their data to a production table. I came up with this little master plan while moving code from staging to production. I'm thinking of comparing row 1 of the csv to predefined array or something like that for validation. Hope that helps.
Today is a great day for you! You got to watch "Who's on First" for the very first time! 
I wrote smth like that (without if) a week ago. Ask me anything 
You're using a variable variable to compare itself using a string wanna be boolean...heck, I'm not even mad, you've actually manage to make it worst which is a feat in itself. Sort of off-topic, I've never used variable variables ever. Anybody else use them for some legit reason?
I've done this on a typo3 site. I worked on production. My corrosion control was Ctrl-z. Often i would make changes, save/upload, test. Undox20 ssve/upload and then redo up and try to find the error. I tried for a full year to setup a copy of the site on my local host, without luck, because the typo installation was so old it only ran on an old php-version... And we used an extension that only worked on the old typo version... 
Yeah, my hope is people will compare median salaries with the cost of living in the areas where the bootcamps are based. 
&gt; In Javascript, everything is an object, including integers, floats, strings, functions, and actual objects. Not really, you can call methods on integers, and iirc the way the call is resolved is by implicitely wrapping each primitive type in a matching object type at call time. But a javascript number isn't really an object. But the point remains the same, javascript functions are another type of value part of a relatively uniform type system, PHP functions are not. &gt; PHP lets you create a anonymous function that lives in a variable, but that's not a "first class" function Anonymous functions aren't even functions, they're callable objects.
Still more descriptive than I've seen in the past. Least I can grep that.
Is there a better aggregation of PHP blogs than Planet PHP? I find the layout pretty shit, it's not mobile-friendly and it's a pain to scroll through as they show entire articles instead of an intro.
1969 is some fcked up year
&gt; table names When are they ever a user parameter though? I mean, if some table name prefix is stored in an application configuration and hardcoded at deployment time, interpolating it into a string isn't a problem. I agree on the limits though. 
Whats wrong with just implementing ArrayAccess?
So, instead of `Config::get('flags.feature_one')` in a controller, you'd write `Feature::isEnabled('feature_one')`? I guess the package would be more useful if you could de/activate a flag based on some sort of statistical selection among users, for example to run A/B tests or tiered feature deployments. That would actually be pretty awesome :)
I feel bad for you, son.
` $isColorBlackOnly = (!isset($isColorBlackOnly)) ? 'false' : $isColorBlackOnly; ` What's wrong with this? I do this type of code a lot. It's basically saying "If it's not set, make it default to false", which is useful if you don't know what type of input you'll be getting (you may pass an object, a boolean or an int for example). Edit: I'm assuming this code was written before the null coalesce operator was introduced.
There's nothing wrong with ArrayAccess, it does what it is suppose to do well. I just think it's would be nice to work with arrays in an object orientated way, similar to Laravel's Collection. What I'm interested in are potential pitfalls of such an RFC. 
&gt; Come on that is some retard code We prefer "maintainably challenged" 
I've got a few //I am so so sorry comments. 
True. What about SEO? How well does google handle website that are missing key data from the beginning? Does google know how to wait for the data to appear via AJAX?
At least it's not `expected T_PAAMAYIM_NEKUDOTAYIM`...
I thought it was a legit reason, but then I found out I just didn't know the right way to do it.
I would store an entry in the primary storage and increment the cache. The idea is to prevent recomputation of something like the number of entries in the primmary storage while maintaining a relevant counter in a distributed context. The cache can be invalidated periodically to reset the counter to an exact value. If you only cache the result of a count, you will have a counter freezing for the TTL, which is not really interesting. There are many other applications that could derive from this, just saying.
I remember the utter confusion when I came across that for the first time
array_key_exists is a much better way to handle this, I think that's why it's included
In the implementations I have seen the passing of `$next` from middleware to middleware is hidden from the user. A middleware stack factory creates a callable object that you invoke with `$request` and `$response` only. Example: http://relayphp.com/ The creator of a middleware only has to work with `request` and `response` and don't mind the `next`. Practically, for the middleware developer, the only difference is that, instead of writing `implements MiddlewareInterface`, one must write `extends BaseMiddleware`.
That is one large footer for a 2-line post. How about just: &gt; I am a bot. NB: negative comments get deleted. [Contact](http://example.com/) | [Code](http://example.com/) | [FAQ](http://example.com/)
&gt; if (!$var == '') { // it contain something, Best code comment 2016
RIP kasp3rito
Did you try adding a vendor namespace as part of the {name} such as `Foo\\Bar`? Also, did you try successively renaming it multiple times? I'm unable to do so without running `composer dump-autoload` every now and then. I'm using Laravel 5.2 if that matters.
Are there any plans to bring this to php 7? Like 'session.cookie_httponly' and 'session.cookie_secure'
These things move a lot faster than PHP development... searching through the internals newsletter archives I can't even find a mention of the phrase "SameSite" so it hasn't even been discussed. I'd wait for the RFC to get finalized before even bringing it up. PHP internals does not do RAD, they do design by argument and committee, and the prevailing argument is often "you can implement this in userspace so we're not going to put it in the language"
Generally - yes, it is. For my specific case - not even close! :D
yes thanks :) 
Here here, we are also in the process of redoing the whole platform from scratch. Although we inherited the beginnings of it from a contractor, it's in Laravel 5.1 and is decently written (although we had to scrap the whole front-end part of it, but that was kind'a expected). But we start to hate Laravel more and more, sadly. We much more preferred to stick with Symfony on projects for this particular client - Laravel will come biting us in the ass later down the road, and know of similar things happening at a few fellow companies - they just scraped Laravel out for projects 1.5-2 years in the making and redid everything in Symfony.
That's why we do that at 35 EUR/hour and don't employ a single junior developer :D
better yet http://csiphp.com
For the most part I'm with the majority. For "array end comma" I've noticed this shifting, but never *really* understood why. I've told myself it's an influence from JavaScript, but that's probably just something I made up. Personally I think it looks weird to have a comma with nothing after it, so when I write it I don't include a comma, but if I see an end comma I don't remove it 99% of the time. I guess I'm undecided. What is the reasons to go either way? These are the ones I'm against the grain on: Function/Class opening braces I religiously put them on the same line. It's less vertical space and easier to read IMO. I think it also lines code up better into blocks when trying to scan through. Plus if you use folding in your editor it makes things get more out of the way. I totally do 'else if' instead of 'elseif'. Didn't even realize I was in the minority there. I used to be on the fence about the whole spaces/tab thing, but lately (the past couple years) I've really grown to like tabs much more. Using spaces to align things now feels wrong to me. *ducks* I think having adjacent assignments aligned looks great, but I honestly never do it. It's one of those things I end up wasting so much time on that I just ignore it. This relates to tabs/spaces in my head for some unknown reason. PHP closing tag at EOF: I do this, and I need to stop. It's another bad habit. Although when I'm starting from scratch I usually don't know if it'll be all PHP code in a file until at some point after I start... It's a hard one to break. I have a bad habit of putting no space after if() operators for some reason. I don't know where I picked that up. It's just if() too, I leave a space after all the other ones. *shrugs* I'm trying to fix myself there. 
Oh nice! That's a good reason, especially if you're using a CLI diff tool.
I wish it wasn't the case but there have been some really bad coders using somd really old code styles. This though, this is the point where I just start from scratch cause that code is painful.
I'm pretty much in line with you apart from the PHP closing tag. The trailing comma... It just sits there... mocking you. "Hey there, I'm a ***comma,*** traditionally something comes after me. Even my cousin Oxford has something trailing after it, but oh... Look at that, you've left this unfinished." The point about folding and opening braces on their own line is a good point. Aside from that I feel the function statement itself is enough to indicate that function starts on that line, no need for a new line and a brace. elseif vs else if. I use else if probably because that's how I say it in my head. I'll use spaces to align(well... I let PHPStorm do that) when I have several chained functions. Otherwise I personally don't gain much from it and it feels like a chore maintaining it when the code changes. I never really understood why echo was so often used without parenthesis. In my head I just see it as a function that prints out with the string as an argument. I really didn't think of half of these things($foo -&gt; bar();) as being options let alone how much they bug me 0.0
Well that is part of the point of a placeholder. It's not always dummy content, the example I gave on price would be the lowest price, so assuming you mark it up using microdata Google would think all products were from the lowest price. You can even mark-up offers. As I say pricing is probably something I wouldn't extend this to, it's too small a detail, I'd have a sample product or something taking up the space of a sample product; but if you just used AJAX with no placeholder; Google would pick up nothing!
The section about the databases is quite misleading. Laravel supports a lot more databases than listed in the article. Laravel doesn't support them out of the box, but neither does Symfony. I bet the same counts for Yii. Also, NoSQL as a database? Seriously? It's a concept, not a database server.
Well I did raise an issue on their [issue tracker](https://github.com/laravel/framework/issues/13924) some time ago. Apparently, some guy just closed it without as much as a reply :-( **edit** Just raised it on [/r/laravel](https://www.reddit.com/r/laravel/comments/4nb8e2/in_laravel_52_app_renaming_via_artisan_appname/). Lets see what happens.
Oh yea, I understand it's not a function and I should have noted that. I worded that section poorly. It's just how I 'see' it if that makes sense. I rarely use echo to be honest. If I'm debugging/writing something new I use(in order of desperation): print, var_dump, symfony/var-dumper, and finally xDebug + PHPStorm.
No closing php tag is good practice. It can avoid weird errors when that whitespace you didn't know was there gets output and you get a "headers already sent error". Otherwise, I like most of your style! :) Braces should be on the same line for functions and control statements. It really bugs me that PSR-2 says that functions/classes should have them on a new line, but control statements should be on the same line. Not-consistent much? I like my braces on the same line as the definition. It really irks me to see a line "wasted" by a single brace. The `elseif` keyword really bugs me too. I've always envisioned the else if being a chain of multiple logical statements leading to a structure like: if else if else if And to me, personally, the `elseif` statement breaks that.
https://wiki.php.net/rfc/typed-properties?do=revisions It's waiting for nullable types.
Ah, fair enough. Apologies for the misunderstanding.
I use Relay, `next` is passed to the middleware when invoked. How Relay generates the callback is unimportant to me as a middleware author because that's Relay's job. The only thing that Relay imposes on my middleware is the signature and that signature is supported by many other middleware runners allowing me to switch out Relay. Your system requires me to derive from your objects and ties me to your middleware runner. Additionally, as mentioned before, your system doesn't make the existence of `next` explicit. New developers coming onto the project need to go read your documentation in order to write new middleware whereas they don't need to know about Relay to write middleware for Relay.
This one is in PHP and looks very promising: https://github.com/spatie/dashboard.spatie.be Here is blogpost on how it works: https://murze.be/2016/06/building-dashboard-using-laravel-vue/
https://marc.info/?l=php-internals&amp;m=146418322610639&amp;w=2 &gt; Since some important details regarding the recently accepted nullable types feature were missing from the RFC, the vote has been stopped for typed properties, while we resolve these issues and update the RFC, and implementation. &gt; Voting on the final implementation will commence in the coming days. Basically, the RFC hasn't been updated yet. But since then, there's been more discussion - the latest being 05-29 as far as I can tell: https://marc.info/?l=php-internals&amp;m=146450697823509&amp;w=2
its just still missing the most "basic" features a KPI dashboard needs ... variours chart types, gauge, countdown, numbers. (at least as far as i can see)
Whoa, ~78% - ~22% spaces over tabs. Didn't see that coming...
I also like the extra comma, because if I want to add a new item, I just use the shortcut to duplicate the last line and edit it. I suppose it's just habits.
Absolutely! I couldn't agree more. But *so* much discussion...
it's whitespace https://i.ytimg.com/vi/SsoOG6ZeyUI/maxresdefault.jpg
You say that like it doesn't matter, but if I open your code in my editor and the indentation and alignment is all f--ked up, I'm going to hate you. In theory, tabs let everyone pick their own indentation level, but in practice, tabs almost always sneak in when you're doing alignment, and the code looks terrible on everyone else's screen.
I love your naming conventions :D
just because the majority agrees on something doesn't mean it's correct :)
`else if` can actually be interpreted differently if you don't use curly brackets. [There's a note about it on PHP.net.](http://php.net/manual/en/control-structures.elseif.php)
Sorry, I should have quoted "Didn't see that coming..." I meant he didn't see it coming because it's whitespace. Rule #1 of a bad joke: have to explain it. :) Edit: oh, also the picture in no way supports the joke, the comment just reminded me of the episode, so I thew that in. I'm really bad at redditing.
This. Also works way better this way in vim: `yyci'` or whatever text object/motion applies.
Don't be so hard on yourself. The picture you provided was taken from a scene where the characters were debating spaces vs tabs. Totally on-point. Reddit rockstar status confirmed :) Edit: And I was totally thinking of that Silicon Valley episode when I posted the comment ;)
Code readability
Thank you for verifying so weird...
does this means feature freeze?
Nice job PHP internals, PHP 7 has really come a long way. I do wonder about one thing though, will webhosts that provide PHP 7.0 upgrade to PHP 7.1? And if so, how soon will this happen after PHP 7.1's initial stable release? 
TL;DR: * since variables in PHP have no types, it is possible to change the value of a typed property by-ref (therefore it was disabled in the RFC, which is controversial) * in the RFC `__get` must return a type compatible with the requested property (also controversial) * loads of issues with default values and `unset()` 
I've being following internals, but that's an excellent summary, thanks.
Depends who's your host. The good ones will make it available as soon as it's released.
Ah I see. Again, tried to make it clear in the title :-D
Excellent response! To elaborate further: Perhaps development is not the greatest career for you. If you find yourself interested in the projects, but get tired of the mundane implementation, look at moving into a different-but-related role. Ask to be involved in the project management side of things. If your organization has people dedicated to architecture (aka problem solving), become involved with them. Have you found yourself enjoying working with the terminal and server software? Move more towards dev-ops or server IT. Beyond your organization, look into things not related to PHP. Learn new languages, especially ones as unlike PHP as possible. There are so many facets of business and career that can revolve around web development, and even more so in programming in general. You're bound to find something that helps reinvigorate your work life. And, if not, you're either in the wrong environment that isn't helping to nurture you, or you might just not belong in programming. (Which is okay! Do what makes you happy.)
Maybe try codecademy or team treehouse?
THANKS! I want to see some other features on 7.1 too.
Oh man, I missed short array destructuring assignment RFC. I think I need to change my pants now...
While there is an [enum proposal](https://wiki.php.net/rfc/enum) in draft, this feature will not be part of PHP 7.1.
How does it matter in regard of sql injection prevention? If it's not an int, then it will be formatted as string, the problem solved.
Glad i was able to spot and fix the vandalism you did in the relevant post on SO out of this delusion.
1. It doesn't really matter. There is another example in the article that demonstrates vulnerability that doesn't require the second query. 2. It depends on the implementation. It seems that this lib in question is using a homebrewed implementation of prepared stataments, and a very stupid one. Frankly, the ORM authors practically had no idea what are they doing
Well for PHP it still makes very little sense because you need such a repetitive execution only a fraction of time. And the gain is not that magnificent. If you are bound to run tens of thousands queries in a loop, then it doesn't really matter if they take 10 seconds to run, or only 9.5
There are PHP programmers who are to fix this inconvenience. However, there are still queries where you have to make even *keywords* dynamic. Desc or asc is the simplest example.
This is a post about some shitty ORM which authors has absolutely no clue.
Well for limit it's all right to use a prepared statement
Digital Hostean...
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Is it a draft? Looks like a torn and incomplete article. Altough it calls PHP a winner, the reasoning is unconvincing.
&gt; Yes. As long as you don't need complex queries, where every dynamical part can be parameterized, it's enough. To be honest; i'd question the "need" for any over-dynamic system. You have to put pins in some things, or you'll end up with a rather large attack-surface that mentally costs a lot more to work with; will cost a lot to defend and mitigate, but more importantly; you'll probably end up with grey spoo that has the potential to do 99 complex things, but not do any of them well. I think Twitter, for all it's limits approaches this from a place of simplicity because it's easier to do fewer things well; than try to compete with Microsoft Dynamics etc. The older I get, the more I am drawn to doing-less, but making sure it's better-suited than those doing everything half-assed.
Based on the discussion I had on this thread https://www.reddit.com/r/PHP/comments/4n414o/nextless_middleware/ Thanks /u/Meefims 
That's a good idea for the theoretical musing but it fails when it meets the reality. In the real life app you may need to let the data to be sorted either in the ascending or descending order. Of course you can simplify your app bymaling only one direction. But it will make it inconvenient for the users
First, Hack is not that complex as you imagine that. Second, Fb has been written using pure php, so php is good.
Take a look at MangoPay
Wow, these are some amazing features! Was waiting for the Nullable Types and Void Return Type functionality, the Class Constant Visibility and Multi-Catch features are extremely welcome too. Great job, PHP Internals team! Curious to see what else will make it into this already amazing release!
We shifted our interview focus from Tech to personality ... "does he fit in the team, is he intelligent" ... these are the more important questions than hard PHP-dev skills (those i would seek in a contractor) ... if his php skills are not enough first, we will train him ... if he is applying as a senior and his tech skills are not enough we will probably just let him go after a short period which allows him to get better. Keep in mind: our problem was not finding good people, but losing good people all the time (high fluctation) which is cause Berlin/London are big techhubs with more availble position than avalable candidates ... we now have much better results with involving the team in the hiring processes, doing multiple interviews, seniors get invited to a "hackathon" first together with the team that we do regularly, we dont to skill tests, and we dont do much tech questions in interviews aside form "tell us about some of your projects you are really prowd of" which often leads into tech automatically.
You'll create an assignment and then award those who read your mind and create API endpoint unit tests? That's some unfair shit right there. Not even saying that those endpoint should probably also be covered by behavioral/integration tests that will test the system actually works. How do the candidate knows what you want if you didn't convey it in the assignment? Maybe mention it should be developed using TDD. And judging how well documented code is is also pretty subjective and will depend on your company's standards - e.g. we write docblock explanatory comments just when something is unclear. So communicate that too. All in all, i think a chat with the guy will be much more helpful. So if it's possible (you don't have like 100 candidates), i would advise that. You can check if he's up-to-date with news in PHP and JS, judge his professional skills and his character. If you need to filter before 1-on-1, ask them to submit a repository of theirs they been working on. A pet project. Or how they committed to open source. Basically anything but requiring them to write some random thing just for you - and just to get to the 1-on-1. I would really have to want to work for you to even bother. And even then, maybe i wouldn't find time/energy to do it properly during the evenings/after work. 
Has happened in the past, but sometimes takes 2-3 days for people to notice that nothing ever comes back...
Cheers for the info.
Have you read the linked article in the FrameRunner example?
Interesting list, but I wonder, is there a comparison of fully qualified name vs short name? How many people are using fully qualified names(ie. \Symfony\Component\DependencyInjection\Container) as opposed to short names(Container after an use statement)?
I have seen excessive use of interfaces with only one implementation. If something in a useable project (meaning if its not a framework or library) only has one implementation for a group of possible implementations (like a type of cache, connection, whatever), you should not use an interface for it, thats just over engineering. Using an interface starts making sense if you are adding multiple implementations. Like said, frameworks and libraries excluded from that rule.
How is this silly? I am not suggesting whether a PHP dev should upgrade his own server to PHP 7.1 or not, but clearly how soon webhosts adapt to PHP 7.1 will have an impact on how many developers will use PHP 7.1 features in libraries(as using PHP 7.1 new features will force the requirement to be PHP 7.1+). If I recall correctly, there are still some projects not using namespace because they were aiming at webhosts that are stuck at PHP 5.2. Most are legacy librariesIn general, the sooner webhosts move to the latests version of PHP, the sooner PHP libraries/packages will be up to date. 
Looking for intelligent individuals is what will make your company succeed. Very good approach! +1 from me :)
First of all you can not mutate PSR-7 Response and Request objects, they are immutable - each time you do `with*()` you create a new instance. But to answer your question, you can do `return $next($request)-&gt;withHeader('header-1', 'foo');` in one middelware and `return $next($request)-&gt;withHeader('header-2', 'bar');`in another one. It will result in `$response` with header 1 and 2. BTW - Making `$next` null by default if just bad, but Matthew done that in Stratigility and everyone was/is mimicking him. Community will be withdrawing from that, no one wants to write `isset($next) ? $next($request) : $response`. https://groups.google.com/forum/#!topic/php-fig/sYecuqdYIkY https://github.com/zendframework/zend-stratigility/issues/15 https://github.com/relayphp/Relay.Relay/blob/2.x/src/MiddlewareInterface.php
&gt; That's a good idea for the theoretical musing but it fails when it meets the reality. You do not need to accept arbitrary user-input to change sort order, or sort field... That *IS* reality. You may *CHOOSE* to put user-generated data into columns, but you absolutely do not *HAVE TO*! &gt; In the real life app you may need to let the data to be sorted either in the ascending or descending order. Of course you can simplify your app bymaling only one direction. But it will make it inconvenient for the users I See what you are getting at. I disagree, but I see. Think about the problem you are describing vs what a param string is designed for. Your ORM (if you use one); should not be used for ordering by user input; that is complete madness
good to know. thaks.
There are reasons to implement multiple interfaces in one class. For example, multiple domains can expose an interface that describes the same object, e.g. User. Then you implement them all in one class. The interfaces themselves may even be identical, you just separate them to separate the domains. That being said, overengineering is a real issue :)
It asks for "Single Page Application", pretty certain that implies API endpoints. 
This is pretty much correct, except I typically use `PHP_SAPI === 'cli'`. If you want to know if it is a cron job vs a typical CLI call, just have a command line argument that you only use in your cron script, like `php myscript.php --cron`
http://php-news.ctrl-f5.net/message/php.internals/93852
1000 per month is pretty slim. You could get away with the cheapest box for that, like $5 per month, as long as they are not all hitting at once, and you queries are not terribly inefficient. 
Is there any discussion or something about declaring types for array's elements (eg. int[] or User[])? I've seen that this RFC https://wiki.php.net/rfc/arrayof is declined, but that was a couple of years ago, and since we now have type hinting, I wonder if there's something new about this feature? 
PHP 7 represents huge money savings for them and with that kind of savings they can weigh it against some really pretty loser clients being put out.
I don't think there is ever a reason to store an entity manager in the session, or any service for that matter...
Yeah, my email got flooded this morning :/
Better to use the method, as that can be mocked in tests, while the constant is pretty hard to change.
American size or european?
Is there a native version that the PPA version isn't providing? 
&gt; I've noticed that there are many devs that have worked with PHP for quite some time, and don't know what an interface is, or forget what a protected method is, let alone DI. There is a big difference between PHP Developer, PHP Engineer and a PHP Programmer. My expectations from a developer is that they know how to make a wordpress theme. My expectations from a "programmer" is that they know a little bit about OOD principles, and they have worked in a PHP framework {Laravel, Slim, Lumen, Silex, Symfony ...etc} My expectations from an engineer is that they know how to OOD, and do DI properly. As for your coding process... A Programmer or Engineer should know how to setup a project: - setup git - setup composer - ..etc Where as your typical wordpress dude likely has no clue what composer or git even is. This is a pretty good way to eliminate most of the undesirables. 
Just to add a bit more context to /u/algerd_by's post, [the typed properties RFC](https://wiki.php.net/rfc/typed-properties) was restarted earlier today: https://marc.info/?l=php-internals&amp;m=146555513600805&amp;w=2
How would you mock the method? Just curious
Can you provide some alternatives? I know of Adminer which I like being a single file.
Hi, here's my 20 cents: * I suggest removing performing of sql queries from your index.php, add this logic in your backend * Try not to die when you catch an exception, instead gracefully catch it and don't kill your application - do something else with it * Common.php contains database credentials, i guess for tutorials is fine but always place these on gitignore. * Separate your view logic from your business logic - you basically need some architecture to demonstrate I don't believe this is a very good start for tutorials, this is not very modern php, not object oriented, no namespaces or composer but it's an okay demonstration of basic PDO and the only thing standing out is the file structure that needs a lot of reworking. Keep trying!
I gave it a try after you said you are going to use this for tutorials. Initially i had a way longer response, but decided to condense it into these few points: * Start using OO/functional programming. * Stop mixing PHP &amp; HTML * Use some microframework (installed through composer) - silex/lumen * Free input sanitization * Free routing * Free autoloading * PDO is fine for starters, but you should move to some library that'll abstract it away. - Doctrine's DBAL * I was glad to see the prepared statements, so props to you for that. Hope this helped. 
Here to back up this point as well. The article isn't talking about making a dev a manager at all. It's just giving them an official title (Lead Dev) to go with the role and job they already do. Nothing they actually do would change.
When we want to move our clients to it, we'll still need an external repo regardless of being on 14 or 16. Unless there's plans I'm unaware of for keeping ubu 16 provided packages up to date? Would be a big deal for some of our clients for sure.
I don't think he's into mocking, the file is called *db.php* and is required by *index.php* :-)
Do you think this is the correct behavior?
It's not difficult to secure and has all the features that I need. 
Create another one in the same namespace. If you don't explicitly specify that a function is in the root namespace, PHP will look in the current namespace, and then the root one. Compare: &lt;?php namespace exampleDotCom; var_dump(strlen("foo")); // int(3) ---- &lt;?php namespace exampleDotCom; function strlen(string $str): int { return 6; } var_dump(strlen("foo")); // int(6) ---- &lt;?php namespace exampleDotCom; function strlen(string $str): int { return 6; } var_dump(\strlen("foo")); // int(3)
PhpStorm's database tools are very nice.
You could either use any kind of template system [except Smarty](https://www.google.de/search?q=dont+use+smarty), or you could generate the HTML using PHP echo/print/etc.
If you are processing over $10k per month, setting up your own merchant account through Authroize.net or similar will save you money.
Upgraded to Ubuntu 16 about a month ago for the exact same reason, and I've experienced no issues. I actually had more issues using the ondrej package repo because it was updating every other day, and some updates introduced changes that would break parts of my site.
Ah I see. Thanks! But that only works if my code isnt in the global namespace right? Because just recently I had to test some old code thats in the global namespace...
At one point the package was broken and I couldn't install it for a new server. I'd rather had stable package over bleeding edge latest version, especially since our site is WP and it's not going to utilize the new language features. 
$thing = [] didn't work before PHP 5.4.
SQLyog is "Only available for Windows" :( What year is it? They need to hire a team to rewrite for x-platform.
Maybe i wasn't clear enough. I meant it the other way around. For example you have an application with a simple login and only one type of users, you could write for example an advanced user interface or anything that would make sense and write all your services against that interface. But since you are only using that interface in exactly one class, you would have over engineered your application. A scenario like that makes absolutely sense if you are working on an extendable library or framework. But a lot of devs i have met are writing interfaces just because they might eventually use them in the future, which is only adding unnecessary complexity. For an application like the one described in this thread i would expect exactly zero interfaces. If you would find an interface, it would be over engineering. 
Great, thanks!
Ah i see, thanks for the answer :)
European
Actually, it's best to use PHP_SAPI === 'cli' when constructing your object graph and inject the result into whatever needs it. Mocking php_sapi_name() is the equivalent of mocking Database::getInstance().
Just my two cents, but treehouse is probably better. The php course in codeacademy is very buggy. 
Have you experimented with using environment variables? [dotenv](https://github.com/bkeepers/dotenv) is a useful library for that approach.
&gt; If you have two components with 2 packages, you should decide on how to count them Instead, this way you only have 1 component, 1 package and 2 different repositories, for installation purposes - one is the maintained one, the other is just a READONLY copy. It's not 2 packages nor 2 components.
Yes, this is correct behaviour. Most languages do this (Extending methods always need to implement the exact same function signature, the constructor is the only exception)
With every other thing i can come up with, but -1 for not using framework?
Why don't you post your code to show us where you are stuck at?
can u write code to retrive image from database... 
You have two repositories, `acme/foo` and `acme/bar`, then you count them as two projects. Now, if you have 6 repositories `acme/foo`, `acme/foo-readonly` and `acme/foo-backup` (same for `/bar`), it's semantically coherent to only count 2, because the other 4 are copies (two copies of `foo` and two of `bar`). If you have 3 repositories `acme/acme`, which contains folders called `Components\foo` and `Components\bar`, and then you have separate `acme/foo` and `acme/bar` with copies from `acme/acme/Components/foo` and `acme/acme/Components/bar`, it's coherent to either count them as one project (`acme/acme`) or two projects (`acme/foo` and `acme/bar`), but not as three separate projects (`acme/acme`, `acme/foo` and `acme/bar`). In the Symfony case, Sensio opted to make `symfony/symfony` the main repository, because it's not comprised of components only. So, counting `symfony/symfony` and `symfony/intl` (for example), would include `symfony/intl` twice, but the bridges only once. Couting only `symfony/intl` include it only once, but would include the bridge 0 (zero) times. Couting `symfony/symfony` would include the `symfony/intl` once, and the bridge once. It's the most coherent approach to make sure everything gets counted once and nothing gets counted twice.
I would point you to stackoverflow but with your "do my shit for me" attitude I don't think they'll help you out either.
This is 2016... if you aren't using a URI framework you are doing something very wrong. It's a CRUD app as well, so it should be REST'd
Do not store images in database, so you won't have a trouble showing them
are you paying me?
Not really. From what i know you will only get taught the language itself, no 3rd party frameworks and libraries etc. The test itself ( i am certified) is a joke full of things like: spot an error in these 50 lines of code, and no employer ever in my life gave 2 shits about it. Actually if you were to apply some of those edge case examples you need to memerize for exam in real life, your coworkers would lynch you. Maybe try going for symfony2 certification instead, at least it will tech you the framework
Not using PHP would be the first place to start
I greatly appreciate these links. I already knew that phpmyadmin could be possibly compromised and have always taken action. I will read the report but I do note that this is an outline of the security threats to the "vanilla" install. What I was saying is that it's easy to make it secure. 
Sure, this doesn't work in the global namespace. I'm not sure it's such a good idea anyway.
Well the only way to secure it imo is to have a firewall that blocks all access to it except from an IP address... but even then IPSpoofing blah blah... it's just so much better not NOT use it and then NOT have the headaches of trying to keep it secure.... then again I'm a spoiled dev who uses windows :) ... vagrant is nice :D
http://www.sequelpro.com/ if you're on a Mac.
umm why are so many people voting against it now? It was passing with ease when it made way to voting phase last time. 
lol, good one. the downvotes actually make it even more amusing
After all the recent excitement regarding collections, I started using Laravel's collection class in some of my projects, but found it a bit memory hungry when dealing with large datasets (not really the libraries fault). I wanted to have a crack at a collection class utilising generators so I can still process large datasets efficiently. https://github.com/AydinHassan/collector I would like to eventually implement the same API as Laravel's collection class, however, some methods don't make sense with generators such as *count*, *first*, *last* etc. I would like to support standard arrays and provide this functionality there but not for generators. I hit a bit of a wall with that, not sure how to implement that simply. 
I'm not sure why I was down-voted. If the argument was "what are most people doing, let's try to be conventional" what is wrong with using a report like this to influence your decision? I'm not trying to say one is right vs the other as the whole thing is fairly subjective.
Yeah me neither, personally I'm all for it. My guess is that adding nullables on top of typed props has some subtle implications to the engine, and that the team disagrees on the technical issues more than on the conceptual ones.
Yes I suppose you could call it a scalar object or a "value" object. 
I'm in the middle of doing this now. One thing to bear in mind is that Ubuntu 16.04 comes with MySQL 5.7, which is a bit stricter. It uses the 'ONLY_FULL_GROUP_BY' mode by default which may break a bunch of your queries (those using 'GROUP BY' with non-aggregated columns). 
I'm using a Typematrix 2030 both at home and at work. I like the fact that it's orthogonal and with backspace and enter in the center, and the fact that there's no numeric keypad means it takes less space and the mouse is much closer to the keyboard (yeah, I'm one of those developers that use the mouse :-P). The "home" and "end" keys are very conveniently placed right above the "left" and "right" keys, and it's very quiet, especially with a skin installed. It's also pretty nice to be able to take off the skin and just wash it with soap and water. It takes a little time to get used to it though. 
LOL :) Either way, I wish you well! Thanks for at least considering it.
MacBook Air keyboard :p nice smooth keys, good spacing and all that. But I guess an apple external keyboard would be something along the lines of what you're looking for. Bonus points for being compact, but loses point for price.
Those are not objects
What key do you use to redo (after an undo)?
Back when i was an apprentice i got a voucher for the Zend Certificate. I did not learn for it, i did oversleep so i only had about 40 minutes to do the test with a ton of stupid questions which do not even remotely identify a good developer, and i passed with still 10 minutes or so left. One of the worst developers i know managed to get the certificate with ease. This nearly pissed me off enough to ask Zend to remove me from the ZCE Yellowpages. In short: this certification is a joke! Your most important skill is to think like a developer, to be able to analyze and solve problems in an elegant way. The programming language itself is just a tool to bring your solution to life. If you allready have experience in c and javascript, you probably do not have much experience with object oriented programming, designpattern, solid principles etc. So this is what you should work on. Get yourself books about object oriented development, design pattern, solid principles, clean code, test driven development and play around. You do not master a skill by getting an expensive course or just reading those books, you have to get your hands dirty, write hundrets of thousands lines of code, probably throw 95% of all your code away and simply collect experience. Besides that, it might be a good idea to contribute to open source projects, people tend to bash you for bad code, which if not taken personally helps a lot.
FWIW, I didn't downvote ya.
https://github.com/php-cache/session-handler Allows for using PSR6 compliant pools
If i was to disable these functions, we can assume all php scripts will continue to work on the server? Am I right
Problems at the moment: * by-ref assignment completely disabled (disallows some legit operations, sadly) * `__get` is behaving weirdly, after this RFC is applied * performance issues More on it on the mailing list thread.
Yeah, the concept is good. I think everyone wants a bit of state safety in PHP objects, as it would make our apps much much safer.
I don't completely trust the reliability of wireless, but the rest is spot on.
With this RFC I might actually use public properties again.
Isn't Ctrl + Y the standard redo shortcut? In Adobe software, Ctrl + Alt + Z is the standard step-back shortcut. 