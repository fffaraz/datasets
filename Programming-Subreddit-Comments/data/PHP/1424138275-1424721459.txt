It's probably not going to die as a result. You mention below that chasing the latest buzzword isn't a good idea (also true, it leads to terribly fragmented code bases). But you have to trailblaze sometime, for the sake of trailblazing. We've got some sysadmins/DBAs working in our own data center, hosting some of our code while GCE handles newer apps. These guys saw what Amazon/Google/Rackspace have been doing for years. They never bothered to learn to write code, they never bothered to model their practices even a little bit after major cloud providers, and the excuse was that the company would always need them. Now we really don't need them. If these guys had spent even a little bit of time learning to code proficiently, they might be able to slide into a devops role. Instead, they're dinosaurs. And I have no idea who would hire all those people. They're in for a very painful job search in their 50s, with kids to pay for. The situation with PHP isn't the same. But you should check yourself anytime you catch yourself saying something like, "PHP won't die because of a lack of hinting because it has not died from it yet." PHP can't keep pretending that it doesn't have to implement things which exist in Hack/HHVM -- eventually, that gulf will become so wide that PHP will be irrelevant for new projects.
Thanks! The boost came from a change which lets us parse sequential non-special chars (normal words) as a single chunk instead of iterating per-character.
I'm definitely liking what the php league is doing.
Custom radio station management system. Playlist scheduling, mix and match styles, custom audio jingles. When it comes to getting stuff done, PHP is my go to. 
Are we going to have this argument again? I warned you that the reddit admins may ban you for vote brigading. That's entirely separate from calling people names. You're also the top-level commenter calling people dickheads. The other guy was just responding in turn. How about you stop trying to breed drama and just have a conversation with people? Is that too much to ask?
When you find yourself constantly surrounded by assholes, it's helpful to ask, am I one of them? You're feeding into vitriol instead of rising above it. Don't get your panties in a twist when people respond in turn.
still working on my pet project, mix and matching some gems on packagist and github :) https://github.com/xsanisty/SilexStarter/tree/develop
Well.... The both are anti-patterns. But yeah.
This mixes weak and strict in the wrong place. The person declaring the function has all the control over weak vs. strict but really it's the caller who wants to control that. This is what the latest RFC got right. 
NSA uses PHP, mentioned here http://arstechnica.com/security/2015/02/how-omnipotent-hackers-tied-to-the-nsa-hid-for-14-years-and-were-found-at-last/
I don't really love PHP, but this is something that I made to ease some of the pain working with PHP... http://imakesnowflakes.com/cliche-introduction.html
Currently trying to build my first API using PHP. (Is it cheating if I'm using SlimFramework?) For about 1-2 years I've started to code in OOP but haven't really used it in a real world application. Thought I'd make use of what I've learned. So far it's been going great! Still got a lot to learn (about API:s) but I'm loving it. :) 
From the RFC itself: &gt; This RFC is an investigation into the feasibility of this idea and to flesh out the impact it would have on other parts of PHP This is a just an RFC in draft to try to flesh out an idea. I want to stress that point. This is an experimental, in-draft RFC. Potentially it has a lot of value: it avoids special nullable types, allows the `|false` idiom to be explicitly typed and generally allows PHP authors to be more explicitly dynamic about types. Just to stress it some more: this is in-draft. Oh, did I mention it's just a draft? It's just a draft.
"sum types" and "union types" are generally considered to be the same thing. I am unsure what you think is misleading about calling them "sum types". And also to clarify: I am not sold on the name of the feature; it's just the most accurate name I can think of right now.
Is there any chance to see generics or something equal in PHP7? I would prefer Maybe&lt;int&gt; instead of int|null as return type. That would make the necessary checks more obvious.
&gt; EDIT: I think this is the first real server for original Minecraft, but someone has already created a full-blown server with plugin system for the Minecraft Pocket Edition in PHP . Now that's crazy. I know the author of that software, I believe he's been employed to work on minecraft now, which is a great result for him ... I don't do minecraft (my kids do), but he done a very cool thing.
The coolest thing I have built with PHP is a collection of friends that once saved me from [absolute despair](http://www.gofundme.com/b9dfcg). I hope this is never forgotten, I'll certainly never forget.
Wow, that's awesome! It's definitely a really cool project, love to see interesting languages being used in interesting ways.
Unless there is existing work which I am not aware of I don't think PHP 7.0 will have generics, no. Whether they can be added in a minor release such as 7.1 primarily depends on if any backwards-compatibility breaks need to be made to support it.
Using a regex or what? In my limited parsing experience, regexes using `\G` + an offset seems to be the way to go.
Stylius is looking better and better 
Thank you for your answer. But I will rephrase my question: I don't follow php-internals, so I am not aware of the politics inside it. Is there a chance to add generics (and/or function overloading when using type-hints?) or is it way to early for such changes?
you are extremely incompetent in TDD i see. your inability to generate alternative ideas is weird. hey, there is alot to learn, which is good. TDD saves time, because it makes you write simple code, because it's a nightmare to write a test for a method that consists of 200 lines. nobody write tests for such methods. so, you write extremely simple code, your brains adapts and as a result you will be writing simple code for the rest of the project. so, that's one time saver. another is writing test for simple code is extremely fast and simple. so, about easy to change code. since your code and tests are simple, when you change something, it is a small change. then since tests are small too, they isolate your change in a small piece of code which is easily debugged since, again, it is simple code. and by simple i mean least cyclomatic complexity in a method or function. TDD makes you write less complex code, and makes you _think_ in a less complex way. when you adapt this style of programming, you do it faster even including writing tests. and don't forget that writing tests tests your knowledge of _your_ code, so you basically are one with the code when applying TDD correctly. judgeging from your comment you have no idea what TDD is about and never even used it to it's potential. forget that word "test" and think "simple", "easy to debug", " extremely easy to fix", "less problems in production".
&gt; could still be possible So it could also not be... And I'm all for scalar type hinting, but that last RFC with the `declare()` directive was horrible imo... Aside from it looking awful, allowing to turn the checks on and off at call time makes that the input of the called function is still not reliable... Changing the RFC and fixing this issue, among the others why the last vote failed, will take too long I think... But i'm hoping with you that they will find a good solution.
&gt; `object(class-name)` This would be horrible indeed. Ugliness aside, if you change how class name type hints work, it's also breaking BC, and it's going to affect nearly all code written in the last few years... So you solve one problem to create an even bigger one?
I have used it in the past and overall it was very very useful. I didn't use it for anything fancy, just a simple small business website with information about them. Never really delved into the code base or the ecosystem though so can't comment on anything around that.
Github octocat as Agavi logo. Well done.
based on their website it looks open source, I guess it's always fun learning a new framework.
No love for CakePHP 3.0? It's sitting in the RC phases and should be released Soon.
&gt; it's always fun learning a new framework. I have to warn you here. There are *so* many PHP frameworks, maybe twenty that are very popular (CMS' and Application Frameworks). I wouldn't waste my time with a little-known or irrelevant framework, especially considering it takes years to be half-decent at any given popular framework, and many more years to consider yourself a pro at it. I worked with a Drupal colleague who had worked with it for 10 years and still had a lot of "ah ha" moments. Frameworks are intricate. Popular frameworks are very intricate (lots of hands on the source code). Pick the right framework(s) to learn, otherwise the fun will evaporate very quickly...
I'm using Ceylon, where we had sum types for a while. We use sum types to solve nullables. Our very-root type Anything has only two different sub-types, Object (yeah, Java derived) and Null. Null is explicitly discriminated and any type T? is just dynamic syntactic sugar for T|Null. Thus you can guarantee that you never receive null when you specify Object, and you can always receive/return T? when the situation requires it. Did I mention we already have the null safe navigation operator? And what's wrong about a Number type / int| float?
Oh look it's this article again...
There are usually two kinds of type unions, discriminated unions and sum types. There's a difference, and in the presence of available subtyping it would make a difference (since discriminated unions have to be, well, discriminated, which is impossible when you have interfaces). Calling it sum types is fine.
I guess that works. In the latter case, if type hinting is a must-have for some reason, you can always write two Adapters with a common supertype and rely on that. Or you can have one method that gets the input and calls two type hinted methods depending on the type. But I agree with you about the messiness, I suppose.
I'd also strongly recommend adding CakePHP 3 to this list, as it will see a release in 2015, so you can look forward to that.
I don't use frameworks, but I've been hearing that CI has been making gains under new management. 
If its frontend guys who are screwing up, fix them up with [jshint](https://github.com/jshint/jshint). If you want to go beyond enabling it in the IDE, write a githook to make sure every time a commit is made all the style checks are passed.
I think even with PHP the time is coming to an end, where you'll have these webhosts and have to rely on them offering the correct version of PHP/MySQL/whatever. Current frameworks will only support current PHP (Symfony and Laravel will drop 5.4 support soon). So people who don't want to work with ancient code, will use something like digitalocean.
If you never skinned a cat, you should NOT be writing about skinning a cat. period.
I have used Concrete5 for a few years and it does not take long to master how to build great themes that work extremely well for brochure websites. Great plugins allow for even further expansion of your website if needs be. Write a simple document for a client on how to edit their website and they find it very easy to maintain. The massive concern I have is that the developers are forcing version 5.7 down everyone's throat when the product is still not finished. The documentation for 5.7 is still not even done. There are also an insanely small amount of plugins available for 5.7. Forcing some developers to still use 5.6.3.1. Concrete5 then released 5.6.3.2 after releasing multiple updates for 5.7. So it looks like they are working on both products which slows down the process of moving forward. Be aware that there is no script available to upgrade from 5.6.3.2 to 5.7, but they are promising one will be available in the future. The change is massive for developers and site editors. Although the cosmetic features are brilliant and a few minor changes bring massive improvements for site editors and permission settings, 5.7 is still something you should avoid for at least another year. v5.6.3.2 is the best version of the product. I prefer to use Concrete5 over Wordpress. But having two versions out that are so different has really made doubt what was such a brilliant product for my requirements. Once 5.7 is fully operationally and all bugs cleared with a strong market place, I will be using it. For now I am sticking with 5.6.3.2.
wow you aren't a good developer. you couldn't even gracefully handle easy language such as PHP and I am a loser? it's time for you to shut up about things that you suck at ;) also, your brains can't process word "thworing" as "throwing". seriously, if you can't process that, how could you even be able to develop in any programming language? detecting mistypes must be real hard for you i guess.
How so? Eloquent isn't a repository. The article is talking about wrapping an Active Record implementation (e.g. Eloquent) in a repository class.
&gt; Aside from it looking awful, allowing to turn the checks on and off at call time makes that the input of the called function is still not reliable... You would still, as the writer of the function/method, be guaranteed to receive parameters of the correct type, the difference lies in whether or not those parameters would have to match (strict) or just be able to be cast correctly (weak). I'd honestly be happy with weak typing if input like "6 so stupid" would not convert to an int, but a regular "6" etc. would. I think a far bigger issue is one of scope, especially considering how Symfony, for example, concatenate files in the class cache to improve performance. I don't see that working with the way declare is scoped.
I never said Active Record *wasn't*. I don't like it myself but I don't think it's completely clear cut. AR has several advantages.
Concrete5 is in my opinion the best PHP cms out there. It has a relatively small codebase and I like the fact that you can override any inner module with an outer one, the same way symfony works with bundles. The in-content editing is there for years and templates are actually "plain" html files. It's great for small websites!
Would be great if they could at least re-run the vote for reserving the keywords.
You need to call certain functions before the header-part of the page. As soon as the header appears in your page, the first part is sent to the client. Make sure all your scripts are loaded and executed before that. 
no.
Ok, I am trying to see what other functions are being called before that, is there a way that would specify which function is causing the problem? It says "session_start()" in the stack trace but I don't see why that is the issue
Ah, a 'why isn't my code working' question. Is this a homework assignment? What is the output of the form? Did you know you can do this: &lt;form&gt; &lt;input type="text" name="scores[player1]" value="10"&gt; &lt;input type="text" name="scores[player2]" value="8"&gt; &lt;/form&gt; and have to form put exactly what you need in $_REQUEST['scores']? Storing the scores are an integer instead of a string would be a good idea.
blogspam?
When a form submits you are now longer on the existing page. Do you mean you want to use JS to update existing elements in your HTML based on the form values?
Any reason those values are strings? Cast the values to integers for easier manipulation. Here's what I came up with: $scores = array( 'Player1' =&gt; 10, 'Player2' =&gt; 8 ); foreach($_POST as $key=&gt;$val) { if(array_key_exists($key, $scores)) { $scores[$key] += intval($val); } }
Oh. That makes a whole lot more sense so in other words the default behaviour would be exactly how I would expect it to work in PHP? Well shit now I just feel silly. I got the entire wrong end of the stick.
I've been having fun recently with a git-based ORM db thing. I mean, it's almost entirely useless, and it can't ever be used in a multi-threaded context, but it's been fun.
ThanksI will into saving as integers as well :)
Not exactly. array_merge will replace the old value with the new one, it doesn't add them together. I'd be awfully careful running array_merge on the $_POST array too.
whats exactly codeception? how is it used?
How the hell did Codeigniter make the cut? Even with it being in 'active' development again, it's not something you should, or would want to recommend people choose for a new project. Also, where are Symfony and CakePHP 3?! Seriously, if you're going to spam this place with the same article that gets posted monthly, at least do your damn research.
Man, if you have a simple enough app that using a C extension framework gives you the putsche you need, I think you better research HackLang and NodeJS first...
great comment, thanks. might of potentially helped me out big time.
The name is just terrible... *sf2* is widely used to refer to *Symfony 2* in the PHP community already.
That's crazy!!!! I knew RFCs were just windows for us vassals into the oligarchs' musings... but you only have to commit comment changes and ostensibly whitespace removal to become an oligarch?!? At least over at HHVM, you have to pass a job interview and maintain a career there!
You *do* know that your message looks like spam, right?
no it is not spam. You can set up you can try . $ cd cframework $ sudo apt-get install php5-dev libpcre3-dev gcc make $ ./install php.ini set. extension=smce.so $ service apache2 restart
ROFL that it's my fault you can't type. who even says "throwing excuses"? you still make no sense. no wonder you use joke languages like PHP. seems like it's you who can't "detect mistypes" (do you mean typos?)
It doesn't
And Street Fighter 2 in every other community.
So there is zero information or documentation, the examples are as good as empty, and it's named like it's a C port of Symfony2? I have no idea what's going on.
I'm saying this for your own good: learn english.
The #hhvm channel on freenode is fairly busy (at least during Pacific daytime), and we're very happy to help/talk with anyone using Hack, or who just has questions. https://www.facebook.com/groups/hhvm.general/ is probably the best non-IRC place for now; the more usual places (subreddit, stackoverflow etc) are not really active, but we do keep an eye on them too.
&gt; I've been tasked with setting up an automated testing infrastructure, including unit testing. If someone higher up than your lead asked this of you, you should speak with them. &gt; Time for a new job? With the market for developers as stupidly hot as it is right now, it would probably be beneficial to you. However, the simple fact that your company is even considering unit tests means they're already heads and shoulders above many other companies who view testing just as your lead does. Your lead sounds like he's acting out of some misguided sense of authority and/or power, in reality he's stuck in his ways and is refusing to consider that his knowledge isn't as good as he thinks. Good luck with that, we've all been stuck in the same situation. Job hopping has worked out well for me.
Doesn't this proposition essentially come down to "I propose the voting rights be sold on the open market, with proceeds given directly to Zend"? Zend certification has little to no actual value in the market, few developers of any serious experience have bothered, and there is little to recommend it overall. Making it a criteria to voting would have simply encourage people with little or no knowledge, but an enormously outspoken opinion (like me!) get a pointless certification to allow them an undeserved vote. The idea of a split between a core and the community is a good idea, and I acknowledge the problem you're trying to solve. I'm just not agreed that Zend Certification is the way to go about this.
This isn't a help sub. Please read the sidebar.
Sometimes your world view and another person's world view don't mesh and you have to make compromises. This is very common in the workplace. 
Think I may have this sorted now. Thanks for the help guys!
As well as `int|false` (ie, a type and value combination), how about other specific values, like `1|2|3`? Could make for an interesting FizzBuzz implementation.
I honestly wonder if having being a ZCE would have the opposite effect on your career opportunities, ironically.
I will tell you, that your lead guy is somewhat right - but either he, or you, don't know why. So let me explain and give a solution that should satisfy both of you. So first his point of view. You have got a big codebase. Refactoring it is not a week or month job. It's continous job that takes time and resources, while you have other things to be done. It's also not so easy at it seems at first glance - new, refactored code needs to be working with current one and do it's job correctly. Code is working correctly (at least seems to be working from his perspective), so doing extra job so it will still work in a same way, but with different code (and extra code - cause of tests) - is pointless stuff that doesn't give any business value. He sees you as someone with academic knowledge, without a business experience, who read a lot of "theories" written by other academics and goes after them because "this is the proper way" without thinking and a bit of skepticism. Now your point of view: * You want to have test, exactly unit tests. It's good. * You want to place it everywhere, so if you are working on different feature and brake something miles away in different code corner, unit tests will notify you. * You don't want to write another bad static code and increase the spaghetti-chain of code execution between stuff or create accidental infinite loop of calls. It's also problematic to change some those static methods that are used almost everywhere and can interfere other code in different places. Your (and your lead) solution is not to do unit test at all. Adding them on current stage of code won't bring much business value and won't improve the codebase, rather break it in many places (what if you will find a method that need to be changed, but it's new "correct" version won't work correctly with those another wrongly written 20 classes, and changing them will force a change in another classes etc.?). You need to convince your lead that tests have some value - something that he can gain from them. You have to start from top, not bottom - with system test (and later functional tests). It will be easier, it won't break how current code is working, and results will give a business value that is easier to be seen. Also it will give more valuable response which part of code are not working as intended. About the static methods - try to convince him by writting your code without them in clever way. He bothers about object initialization in memory? Maybe you're using too old version of PHP. If that's not the case, write small classes that when initialized, don't have many methods/properties carried with them. Try to make them handle one single case - avoid multi-logic classess that are doing too much and becomes 1000+ lines of everything. Showing him that approach - of many small classess initialized instead of 500 static methods loaded by reading big php files - can make him start thinking for making code smaller over many files - which later will help to make functional tests, and later unit tests.
&gt; If you think the certification exam is not expansive, comprehensive or rigorous enough (as I do), that should not be reason to vote this proposal down, it'd be a reason to convince Zend Corp. to make it more rigorous. By making the test more rigorous, it would solve your issue AND increase its market value. By giving the ZCE a real benefit, it would encourage great devs to get certified. In a few years, there would be a segregating of the PHP community: Hobbyist noobs who can't pass the ZCE and those who can. Then those serious about bettering themselves would have a goal hopefully worthy of celebrating: Learning enough realy advanced PHP to pass a much more rigorous ZCE.
Uhzbe vf abg jvqryl npprcgrq urer.
CI, but no Cake or Symphony. Laravel is only 4th on the list. How can I possibly jerk to this?
https://hackerone.com/reports/31171 I don't know how secure their codebase is as a whole (haven't set it up anywhere), but they're incredibly friendly and receptive to bug reports. This is a good sign for open source projects.
Moreover, how come a vote can be canceled?
"I get that, but in this case, he's wrong and I can prove it." I think you missed my point. Blanket statements like he is wrong or right is not relevant. You have to work with him, stop obsessing about being right and work with him to reach your goals. Or you can move on to something else, where people understand you. 
Sure, I'm using cURL to establish a TCP stream to the wallet to automate it since I don't want to rewrite the BTC entire protocol. I'm sending random packets of data but I get no responses :C
 function array_something(array $arr) { return $arr; } $test = array_something('test'); // Catchable fatal error: Argument 1 passed to array_something() must be of the type array, string given, called in [file] on line 8 and defined in [file] on line 5 $test = array_reverse('test'); // Warning: array_reverse() expects parameter 1 to be array, string given in [file] on line 11 Tried with a bunch of `array_*` functions and get the same results. So array hints in userland functions give errors, while array hints in native functions give warnings.
Have you considered using Bitpay's free plan instead? They take care of the random address generation and watching for a payment (though it does mean you have to forward to their page). I've never tried it "manually" myself, so I'm probably not going to be much use.
What do you do when a method is called requiring Foo, but you haven't added it to the MyObj object?
I would be much more interested in overloading the various arithmetic operators. It would make operations on sets of numbers just the slightest bit easier and more compact. I was doing a game in Python for a class not too long ago and found the \_\_iadd__ and \_\_imul__ very useful for dealing with pairs of coordinates or operations on a coordinate (add two coordinates, multiply a vector, etc). The problem with a comparison operator is you have to know what aspect of the objects is being compared to say if it's truthy or not. Based on type? On value of one specific field? What makes it less or greater than another object? The spaceship operator is already giving you very similar ability as directly comparing two objects but without giving control on how they're compared. It's a niche usage that can be very useful in very specific ways but generally doesn't add much. Can you give us a use-case where it's more intuitive and obvious to write things as `$obj1 &gt; $obj2` versus `$obj1-&gt;isEqualTo($obj2)` (or similar)? It may be shorter to literally read and write but it requires more cognitive processing and research to figure out the hidden meaning, and there won't be any easy click-through handlers for the IDE to jump directly to the `compareTo` function of the class.
"likely to be idiots at a workplace" "one of them is making a shit decision that's going to waste all kinds of time" Where are people like you coming from? You really are full of yourself. 
&gt; I will tell you, that your lead guy is somewhat right - but either he, or you, don't know why. The guy could be a great "lead dev", but he's being a bad "leader". 
Is the system about to go off the cliff... or no? Do you equate not having unit tests, to everything immediately failing?
PHP works with things very differently than I've assessed IBMi or other Mainframe systems to work. Typically the same server doesn't contain or execute code from multiple environments, instead expecting a complete break and checkout of each environment on different machines or at the very least different paths and URLs. This is one of the reasons why PHP applications use a different design pattern to handle differences in environments. Typically an application should be considered environment agnostic with primarily configuration file differences and minimal direct hooks in the program to say 'if (live) do this'. The preferred method even goes so far as to inject different components based on the environment configuration file (e.g. using a File component instead of a Smtp component for sending mail). I don't see a use for a design like this in PHP, at least so far as development vs production and file includes go. At this point I would ask: What are you doing and how are you doing them that necessitates the usage of a Library List and why? Would a different design or implementation produce the same result and with potentially clearer results?
Looks cool, but then you are relying on a third party and I'm not sure how their payment gateway works but I'm assuming its AJAX polling an API which turns the page green. All of my customers will not hava JS in the browser :/
so how do you propose you do the refactoring and addition of unit tests? drop everything, and refactor the shit out of your existing code? how will you explain that to your bosses/executives? "hey, you know that new feature we plan to add for 2.0? the one that would improve usability? nope, i need to rewrite some shit and do unit tests so we can get clean code." test what you can, whenever you can, but moving business value forward through your technical expertise should be your priority as an engineer.
Such is life when you are a subordinate who isn't very persuasive.
If this is actually a cliff-scenario, remember you can quit. If you don't feel like quitting, it's probably not a cliff-scenario.
Your fixation towards "testing", "doing things properly", not giving a damn about business value, "my lead's an idiot" -- this makes it clear why your lead's your lead, and why you're not. that attitude won't get you far with any team.
&gt; This is the least of the problems I face. Everyone's on board with testing. Obviously not. &gt; Yeah, that ship has sailed. I don't play those games. Then you wont get the change you desire.
But because you're not willing to present yourself in a way that earns respect nobody is going to listen to your logic behind what is stupid and what isn't. He isn't suggesting you play politics which I'd understand rejecting, he is suggesting that you earn respect (the easiest way is through making positive contributions, and to start ones that don't go against everyone else). Earning trust can be done in the exact same way.
The code should be as correct as possible. That includes using static methods where appropriate. Again, there should be absolutely no state at all when using them. With your testing, you should test those directly and then use them as-is in your tests of things that depend on them. Your example there on the bottom clearly has state. It has a database connection. That's going to be an instance of PDO or some connection handler for one of the procedural database APIs. Either way, state. That those are handled through a static interface is ...problematic, even without tests to think of. **Edit:** Looks like your example code could use some DI, instead of instantiating inside like that.
Comparing two objects could mean multiple different things, depending on the object, but that's the whole point of operator overloading. The class gets to decide how instances should be compared. A perfect use case I have come across is a class that represents a SemVer version. Here is some example code taken directly from a random [SemVer library](http://github.com/IcecaveStudios/semver): // Create versions from strings ... $version1 = Version::parse('1.2.0-rc.1+build.meta.data'); $version2 = Version::parse('1.3.0'); // Compare the versions ... $comparator = new Comparator; assert($comparator-&gt;compare($version1, $version2) &lt; 0); Not the prettiest comparison API to start with; regardless, I feel using comparison operators here makes it actually *more* clear what the code does: // Create versions from strings ... $version1 = Version::parse('1.2.0-rc.1+build.meta.data'); $version2 = Version::parse('1.3.0'); // Compare the versions ... assert($version1 &lt; $version2); I feel that in general comparing two variables by testing a comparison integer (...-1, 0, 1...) is obscure in anything but maybe sorting. Your other argument is the general argument against operator overloading in any language, that it is less obvious what is actually going on. I understand both arguments for and against overloading in general and it probably should be used with caution, but it has enough use cases to justify, I think.
But what I'm curious about is &gt; Integration tests are all well and good, but that's not what the goal is here. Who says it's not the goal? Why are you trying to push Unit tests over Integration tests so badly? Don't both have their place? If pushing unit testing is meeting resistance, why not just push integration testing for now? Get some easy wins and use that to prove your point? Also, I'm wondering what the best way forward for you is. Because hint: repeatedly telling them they are wrong probably isn't it. 
Then do so. It was never going to be an easy process.
Instead of return ($a &lt; $b) ? -1 : (($a &gt; $b) ? 1 : 0); You can use return $a &lt;=&gt; $b;
The proposal that was under discussion would have rectified that issue. The type definitely exists, it's just implemented differently internally vs in userland (this is true for all types). The proposal would have fixed that.
We're not talking about playing games. We're talking about being professionals. Its a huge time investment in things you should be doing anyways, building out software that improves the business (and is generally acceptable to the rest of the team). Taking the path of least resistance is crucial anywhere, it would be irresponsible to give someone who hasn't proven themselves the reins to do controversial things. The other devs likely don't have the time to hear something out that *might* be a good idea, but will make the time if they have a high enough opinion to *know* it will be a good idea.
Nobody has suggested its touchy feely nonsense, only you. Its actually being quite responsible for them to not immediately trust a new developer with substantial opinions that go against the rest of the team.
Look at the glass as half full instead of half empty, him writing horrid code just gives you job security when you have to fix his horrid code.
And they're supported in `&lt;?php` files anyways, i.e., every part of Symfony. They're only removed if you're working in Hack.
And HHVM 3.6 will have even more complete async support in Hack.
The src attribute of an iframe requires a URI. You want the srcdoc attribute which allows you to embed HTML directly into an iframe. EG. echo "&lt;iframe srcdoc='" . $result . "' width='100%' scrolling='vertical'&gt;&lt;/iframe&gt;"; 
Maybe try to highlight the actual business value. Everything you say makes sense and it's easy to accomplish but your lead developer is considering things other than just code quality. He has to balance a budget, he only has so many developers, he has timelines to meet etc. This may be the reason for the rejection. Try to come up with some financial relevant to your project, sell it too him. Don't just tell him he's a stupid pleb and that he should listen to you and then get all upset and post on reddit. Also, your attitude in my opinion is a little abrasive, I would suspect he stops listening as soon as you talk to him... I would. TL;DR , Sell it from a financial perspective.
After reading all these comments, I want to clarify your post. The lead is an idiot. Your managers are idiots, and the way they do business and how everyone else does business is ruining the economy. You are the only person correct in this situation, about the code, about unit tests and about how to run a business. [Head explode](http://i.imgur.com/DWrI2JY.gif)
And your approach here makes it perfectly clear why you haven't earned their respect or trust in the year.
You need to get a clue about the bigger picture to understand what is and isn't wrong. The code quality isn't the only aspect of the business.
You can't say disaster is coming... don't you get that? Not having TDD does not make disaster. That is your inexperience showing.
&gt; Basically, I'd rather somebody specified 2 or 3 types (not great) than specify mixed, or simply omitted the return. &gt; &gt; Does that make sense? That does make sense, and *yes*, multiple types are certainly preferable to no types at all, but personally, single nullable types are even better. Still, you might be right that multiple types would suit the average PHP developer better. Let's see how the RFC goes :)
Here's the deal. They care about money. To them, more features = more money. If you're redesigning existing features, you aren't making them any money. Testing is about reducing costs in the future, but doing so requires a large amount of cost up front. So, unless you can justify to them that the work of doing things your way is going to save them money over doing things their way with real numbers, you aren't going sway them. The way I see it, you have 4 options: * Show them your way saves them money * Start doing things their way (while refactoring code to your standards as you touch it) and collect a paycheck * Keep bitching to them and get fired * Find a place that shares your ideals It's up to you, but I'd probably be looking at 1, 2, or 4.
This isn't possible because Google uses the x-frame-options header (set to "SAMEORIGIN"). Also, I wouldn't be surprised if this violates Google's ToS.
&gt; I would be much more interested in overloading the various arithmetic operators. Internal classes already support this (GMP), it's just not exposed to userland.
&gt; Except the idiots on the other side don't understand that spending a little now saves a lot in the long run. I know this isn't unique, but that doesn't mean we shouldn't fight it. ^ this was in regards to management &gt; The fact that there's likely to be idiots at a workplace is not a new concept to me ^ This is in reference to the lead &gt; It should, and we shouldn't accept that. It's destroying economies. ^ And this
This isn't node.js here, this is a massive adaptation of PHP made for, and used on one of the largest websites in the world.
[As Hack uses the BSD license](https://github.com/facebook/hhvm/blob/master/hphp/hack/LICENSE), that's correct.
I think I understand what you're talking about. PHP can do something like what you're talking about but it's not done using a file system override. The biggest problem with the system you've described is that things can get very brittle very quickly. It won't take long before everyone is afraid to touch the framework and instead all changes go into overrides, negating the benefit of the framework or any shared code/service. Some of what you describe can be done using simple Dependency Injection (not to be confused with Introversion of Control containers). By specifying parts of the things that the framework uses by an Interface and then injecting the version of the logic necessary for each product the framework code can be left alone while individual components can be changed where necessary. Another way to accomplish what you're looking for would be to use [Composer](https://getcomposer.org/). By specifying the version of the framework as a dependency of the checkout then different websites can rely on older versions until they're ready to upgrade while other websites relying on the framework can upgrade as fast as possible. Creating a custom in-house composer package isn't too difficult. The fact that the framework needs to change to support different products means that the framework isn't modular enough. It would be better to take a step back, look at what is different between the implementations, and then how to make it such that each can inject the different behavior into the framework. Using Interfaces is a good step in that direction. Why would Products and API files need to be layered on top of the framework files? Shouldn't those be kept in their own directories anyway? I think I may have misunderstood that reference, sorry.
Hah! He sounds just like this one kid we hired right out of college. He came in arguing about crap code (most of it was either made a few years ago, when our platform was an antique or was subjective) and demanded it be fixed. He gave all his reasons, mainly based on what he learned in college. So when given a task like maintenance, he would just start rebuilding the entire codebase...and he never got anything done on time costing the company quite a bit of money. We would have to step in and finish his task. He was fired not long after.
And does so using mysql* functions. 
I like that name "code mechanics". For zburnham, watch a Top Gear Special and imagine the reaction car builders in their design rooms and factories have to their solutions. Watch Junk Yard Challenge and see engineers everywhere wince. And yet, Top Gear Specials always succeed and Junk Yard monstrosities work. What is the best piece of code? A dirty hack the generates money or a beautiful piece of code that doesn't? OP is fueled by theory, he knows the theory of unit testing and it is his way or the high way. That is great, if you got the position to force it your way. But OP doesn't. Someone else is the boss and that boss prefers taking a practical approach to his existing code base. Ideally both would compromise. Yes the idea of strict unit testing is to test just one function in a class and mock up everything around it. Good... that isn't an option. So what CAN you achieve? If you ever want to advance consider what looks better on your CV, "I ran away because they didn't want play my game" or "I slowly over a period of two years introduced unit testing in small steps until we achieved 100% coverage". I recently had to look at a project that was written with HTML and function declarations and variables all in one PHP file for each page of the application. You are bitching about statics? You don't know how good you have it boy. I am not going to question zburnham's skills as a developer but as a co-worker, human being, team member and especially subordinate, he has a thing or two to learn. Perhaps it is indeed time for a different job and maybe he will get incredibly lucky and find a position where everyone agrees with him. It could happen. Or a really small team where he will be in charge. Maybe. Or maybe he needs a kick under his pants into the real world and learn that sometimes you just got to make the best of it. He could learn a lot by finding a way to still introduce testing without throwing a hissy fit and instead work around obstacles and with people rather then "my way or the highway". But considering his reactions elsewhere, I think he needs a lesson on the reality of job hunting with an attitude.
I don't know if you have checked Pagekit, but it became the best PHP CMS for me when I started developping extension for it. :)
I have no idea what you mean, but language is the tool with which I interpret your meaning. From what you have posted, I have interpreted that you mean the lead is an idiot, the business decision makers are idiots , and the decisions they make are ruining the economy. In my defense I interpreted that meaning because it is pretty much what you posted verbatim.
It's handy that your perspective happens to be absolutely true and correct. It must be so great to live in such a tidy world.
The above example wouldn't fit in the mechanics proposed. The second example is missing the creation of the Comparator which says how those two objects are considered less, equal, or greater. By themselves the Version object doesn't know about precedence or the difference between major/minor/patch/identifier parts. Either you would need to inject an instance of the Comparator into one of these two objects or they would have to reach into the global scope to determine it for themselves. The former wouldn't simplify the code any and the latter would break the [Law of Demeter](http://en.wikipedia.org/wiki/Law_of_Demeter) and make it hard to change how versions are compared. The PHP documentation for [version_compare](http://php.net/version_compare) has entire blurbs detailing how two version numbers are compared. Doing this with any other object that has a more complicated or less well-known meaning is a recipe for confusion. I'm generally not a fan of overloading any other operator either except in very simple and very obvious ways. In a project long ago in a far away place a coworker used __set() to mean "merge this other object onto this one and do some sorting based on differences in timestamps". The only thing we saw outside of that function was `$log-&gt;event = $event;` with no clue that the entire $log object was being morphed. How much harder would it have been to do `$log-&gt;digest($event);`?
oh.... its ok bro.... thanks for saying about x-frame- option... kinda new one to me.... :)))
its ok bro.... will manageL:))) thanks 
It's hard to grasp the scope of the project without specifics, but sounds like it's an ongoing application with a large codebase? It's hard to retroactively change a team's development methodology, especially from a non lead position on a project. 
Have you seen http://www.phpinternalsbook.com/index.html
Not error-prone at all. Error resistant. And easier to read. You know what your class needs right at the top. Less methods in the class too &lt;?php namespace Acme\Video\Service; use Doctrine\DBAL\Driver\Connection; use Acme\Video\Repository\TransformerRepository; class DvdUpdateService extends AbstractService { /** * @type Connection */ private $connection; /** * @type TransformerRepository */ private $transformers; /** * @param Connection $connection * @param TransformerRepository $transformers */ public function __construct(Connection $connection, TransformerRepository $transformers) { $this-&gt;connection = $connection; $this-&gt;transformers = $transformers; } /** * @param array $parameters * * @return bool */ public function run(array $parameters) { $scenes = $this-&gt;fetchScenes($parameters['id']); $transformer = $this-&gt;transformers-&gt;getTransformer('video'); foreach ($scenes as $scene) { $transformer-&gt;setTransformableData($scene); $transformer-&gt;transform(); } } /** * @param int $id * * @return array */ private function fetchScenes($id) { $stmt = $this-&gt;connection-&gt;prepare("SELECT * FROM scenes WHERE id = ?"); $stmt-&gt;execute([$id]); return $stmt-&gt;fetchAll(); } }
I had the same issue with their SDK and ended up using consolibytes library (doesn't follow PSRs either). https://github.com/consolibyte/quickbooks-php/ It works for the most part but for some reason the owner seems to not want to tag a new version so I'm stuck using dev-master.
Generally the `Comparable` interface provides the `compareTo()` method or a static `compare()` method which would be used in the comparison overloading; no comparator injection required. If you really do want a separate `Comparator` object (which would provide better encapsulation), then have `Comparable` have a `getComparator()` method instead, which returns a new instance of some `Comparator` object to do the comparison. Same behavior as the existing `IteratorAggregate` interface. Again, operator overloading is powerful, but it is easy to shoot yourself in the foot and should be used carefully.
There's a reason not to implement PSR-0. It's depreciated :)
I looked at consolibyte's SDK, but wasn't convinced. Fortunately our integration only requires basic CRUD operations, so we've just built our own. I'm more surprised that such a large SaaS chose not to follow PSR standards and was wondering if there would be a valid reason for it...
Well, I would even say that blindly using unit tests (and in fact using blindly everything else) is a bad practice. People are forgetting many things here: * There are functional tests (quite often more important) * There are system tests (quite often even more important) * There are code reviews (that can find bugs that no test will catch) * There is XP Programming method (that will teach you how to write better code with less bugs) * Looking at xdebug with breakpoints (like why this loop is taken so many times/why it goes to this part of code at all) * Tests are written by people, and people make mistakes - even in unit tests (which still can pass and seems to be ok) * In Agile you have got something called technical debt - and it has got a reason why it exists (aka get money paid for delivering faster now, and having problems later) * Good IDE can help quite a lot (wrong variables names/types returned and thus casted etc.) I've got a feeling over the web, that unit tests became some kind of "silver bullet" that is supposed to solve every problem. While it's just a tool - very handy and helpful - but just the tool. 
I work on a solution where customers directly pay for changes. When I didn't like the spaghetti code that I was working with, I spent some extra time proving out a new system, then held meetings with customers to get them to fund new features that would allow me enough time to rebuild the entire application with a new framework. It took me 2.5 years from beginning to end but I got it done. What I want is for you to take some of the ownership for the situation. For example, rather than fighting them on it, create a class that wraps the static calls and then create a singleton of it. Whenever you need to reference the static methods in new code or code that you are altering references them, instead use the call to the singleton's method. Add unit tests for these areas and the methods on your singleton class. Then, in a year or so, go back and do some analysis on the number of bugs before and after your alterations in those areas and compare it to places that you haven't touched. You now have concrete data to prove or disprove your assertions. If the data proves it, then you present it to others with extrapolations of how much money the changes that you want will save the company. The whole attitude that someone else disagrees so I'm going to be miserable will get you nowhere in the business world. Either find a way to make the change happen, or stop complaining and go with how things work now.
The opscode cookbook installs PHP from package managers by default. So if you want a newer version of PHP you could upgrade to a newer version of Ubuntu. At my company our servers are all running 14.04, which installs PHP 5.5.
If that's true then fair enough. I don't see it mentioned in the proposal.
&gt; Is there ever a reason not to implement PSR-0 (or PSR-4) standards? Never... unless it'd break BC. If your library came into existence before PSR-0/4 was a thing, then your existing install base would break if you corrected your class naming.
Composer is much like NPM and Bower and other package managers. They only init a script file to read data from. Otherwise everything else is online anyways, so connection is required. kharrison@Pepsi:/var/www/composertest$ composer init Warning: This development build of composer is over 30 days old. It is recommended to update it by running "/usr/local/bin/composer self-update" to get the latest version. Welcome to the Composer config generator This command will guide you through creating your composer.json config. Package name (&lt;vendor&gt;/&lt;name&gt;) [kharrison/composertest]: Description []: Author [Kyle Harrison &lt;kharrison@fortinet.com&gt;]: Minimum Stability []: License []: Define your dependencies. Would you like to define your dependencies (require) interactively [yes]? n Would you like to define your dev dependencies (require-dev) interactively [yes]? n { "name": "kharrison/composertest", "authors": [ { "name": "Kyle Harrison", "email": "kharrison@fortinet.com" } ], "require": {} } Do you confirm generation [yes]? What you're looking for is for it to auto generate it's directory structure where it stores packages, but it's autoload system entirely depends on external remote resources. This is to get around a PHP ecosystem thing, where other systems like Gems and NPM don't need to worry about such an issue **EDIT** unless im missing something here..
&gt; No variable variables: $$x how about $object-&gt;$property ?
&gt; Mixed HTML and Hack code. Use a templating engine or XHP. &gt; Incrementing and decrementing a string (e.g. $s = "abcd"; $s++;). I have an issue with this two. I don't see anything wrong with mixing html and php blocks, most of the frameworks I know use it. And how am I supposed to work with things like excel on php using tools like PHPExcel? They use incremental letters.
It is a old episode, but this FLOSS weekly talks about it. Judging from their interview, they seem to have their heads screwed on mostly straight. http://twit.tv/show/floss-weekly/239
That I'm not sure about (I'm pretty sure you can), but if you can't do that, you can just do $object-&gt;getter($property) instead.
&gt; It's also considered a bad thing to do. Don't use frameworks that do that. Why is it considered a bad thing to do? And as I said almost every framework I know use it, including zend, yii, yii2 and cms like wordpress and drupal. &gt; You can still use incremental letters if you really wanted, you just can't do it with the ++ operator, which is a math operator. Then how?
To use a variable string value as a function name you need to wrap in the in function 'fun()', like so: $call = 'myFunc'; $call($stuff); // will not work in Hack Instead: $call = fun('myFunc'); $call($stuff); // will work This allows them to do more advanced static analysis and know more about the scope of the application at compile time.
Because PHP is inferior in almost every single way to Hack unless you want to make Wordpress, which is perhaps the worst piece of software that has ever been that widely used.
Because it leads to a mixing of concerns. And while Wordpress (which is awful software) does do this extensively, Zend and Yii don't. People who use Zend and Yii do sometimes. As for Drupal, it doesn't do this either in their latest version which they completely rewrote from the ground up, and getting RID of this was one of the motivations for doing so.
I don't know why you got downvoted for those SQL injection comments either, TBH. They make sense to me...
The only Chef-centric site I know of is http://rove.io/, but I'm not sure what version of PHP comes with their box. However, if you're not dead-set on using Chef (or don't really care), there are a few alternatives: * https://puphpet.com - My FOSS with Puppet, * http://phansible.com - Ansible, * http://getprotobox.com - Ansible Good luck!
Are you being purposely obtuse?
no, you are just answering something i never asked
thats exactly the attitude that caused all the phpdrama in the first place
Maybe try something like: echo | composer init &amp;&amp; composer install Doesn't give you the autoloader config you need, but avoids most of the cruft
http://news.php.net/php.internals/83006 seriously? the argument here is that we don't need type hints because ides can generate doc blocks.
The hhvm gets me 'New MacBook' or 'Tesla X' levels of excited. Almost proud to claim myself as a PHP dev.
U forgot 'tiger'
I'd be happy to see #3 for the coersion rules :) Speaking of `mixed`, does this provide any difference over simply leaving it without a type hint?
umm I wonder if its possible to incorporate Nikita Popov's scalar object idea together with scalar type hinting. I've been longing this for quite some time now, it will be so nice if this becomes possible. 
Php storm 9! (supposedly)
Nah, it's included for completeness sake.
Possible yes, but I think that's too far out of scope to fit in this RFC. I could see them merging over time though.
OK, so, what I need is a neural network driven artificial intelligence capable of emotion, reason, logic, conversation, and intuition. It should also be able to render artistic imagery. This is a flat fee, right? I will pay on delivery.
Having a method called `getComparator` would still violate Dependency Injection, require hard-coding which class handles it, and/or require injection into each and every copy of that object. It means having the object know how to sort itself which means having just one way of sorting or having to inject a comparison object/config/flag/toggle into the object. Your object is no longer dealing with just its own responsibilities but also with all the responsibilities that come with sorting/comparing/using. All just to use special language syntax to invoke a method rather than just calling the method directly. It doesn't save much effort in typing, doesn't make anything easier to understand, and makes it harder to keep modular. Sorting and comparing logic should be made according to the usage rather than baked into the object. Other interfaces make more sense. Countable? Traversable? These have specific meanings with generic usages. Comparable, on the other hand, has a generic meaning that will only have specific usages (often only with itself). I don't see this proposal having a significant impact if it were baked into the language versus implemented solely in the developer space in just the places that use it.
It's like a goal post without the golie. So many ways to make something out of OP's offer. /grabs popcorn 
Thanks for doing this, Sara!
C: so I can get to the bottom of the php
If all the PHP suddenly dried up I'd probably dive face-first into C# despite hating the runtime nonsense. That's linux-mono-nginx C#; but C# all the same.
This I like.
Just modify the include path. http://php.net/manual/en/function.set-include-path.php I do the same for handling whitelabeling of view files, so you have a default fallback if brand doesn't have an overridden view.
If both things implement `Comparable`, use that. I'm not saying this is feasible in the real world, but it would be cool :)
&gt; What sort of ideas do you have for declaring strict types? Sara [created a straw poll](http://marc.info/?l=php-internals&amp;m=142413115831919&amp;w=2) on the list with the following choices: &gt; 1. `&lt;?php strict;` 2. `&lt;?php-strict` 3. `use strict;` (psuedo-namespace) 4. `&lt;?php // strict` (I don't actually like HHVM's style, but if you do...) 5. `declare(strict=true);` (As a top-level declare only) 6. `declare(strict=true);` (exactly as in v0.3 -- maybe you liked it) 7. your write-in vote here I tabulated the votes so far, with the following caveats in mind: - Everyone was given multiple votes with no regard to order of preference. If they responded positively to a choice, I counted it. - The original poll misnumbered choices 4-7, so I may have miscounted a couple of votes. - Some people buried their preference in a much longer reply, so I may have missed a couple of votes. That said, here's what I have so far: 1. 3 votes 2. 3 votes 3. 6 votes 4. 1 vote 5. 4 votes 6. no votes One alternative proposed was to introduce a "strict" type hint (e.g. `int!`) to turn on strict mode instead of a per-file option. That option appears to only have one supporter.
I would think some other ID would be preferable since it is only 'strict'ing one component of the language. I have no idea what this better ID would be... But I think we can do better then just that. I hope more suggestions are made!
Thanks for saving me the work of rolling those up so far. :) The numbers are encouraging as I regard 3&amp;5 as the best options, I hope the consensus remains there. I'm REALLY glad nobody is voting for #6. The trouble with the `int!` declaration is that it's callee based, rather than caller, which defeats much of the point of it. :(
Yeah, I like the symmetry 3 has with other languages that have similar features, though 5 maybe makes more sense given PHP's current syntax.
I want to take a look at io.js if that counts, but I don't have the time and I don't know what to make with it.
Operator that serves one purpose that could be solved with a function? Sure. Optional scalar type hints? Nah.
You can define custom autoloaders, and yours can exist along Composer's autoloader. For example: function myAutoloader($classname) { $classPath=__DIR__."/development/{$classname}.php"; if (is_readable($classPath)) { require_once $classPath; } else { return false; } } spl_autoload_register('myAutoloader'); require HOMEDIR . '/vendor/autoload.php'; by registering myAutoloader you're telling PHP to try and include `$classPath` whenever you try to access a class whose name isn't in the global namespace, be it for instantiation or to call a static method. If it isn't found, it will return false and then Composer's autoloader will have his shot. Inside your autoloader class you can try more than one folder. Following your example: function myAutoloader($classname) { $devPath=__DIR__."/development/{$classname}.php"; $productionPath=__DIR__."/production/{$classname}.php"; if (is_readable($devPath)) { require_once $devPath; } else if(is_readable($productionPath) { require_once $productionPath; } else { return false; } } of course, this assumes your classnames have the same name as the file that holds them, and that only one class is present in each file, and all of them lack a namespace. All of this can be mitigated by deciding for a convention, because as in many other cases, it's better to pick a suitable convention than trying to make everything configurable. Also, keep in mind that this won't work for procedural code, only for classes. Using the autoloader to put a modified version of a class in place can be helpful when you really can't control the libraries you're including, as is the case, for example, of [Phalcon](http://phalconphp.com/). You can have 20 custom autoloaders firing up on your app, but of course this has its performance penalties. 
Sure. It's a union type. Suppose we have types `t` and `u`. Then the type `t  u` of their union is defined by the following inference rules (in the language used by [Robert Harper](https://www.cs.cmu.edu/~rwh/) in his book [*Practical Foundations for Programming Languages*](https://www.cs.cmu.edu/~rwh/plbook/book.pdf)):   e : t ---------------   e : t  u   e : u ---------------   e : t  u This just makes formal the notion that if an expression is valid for some type, it's also valid for a union type including that union. This is distinct from the inference rules for the sum type `t + u`, which are these (omitting the elimination rule, and the blather about the uninhabited type `void`):   e : t -----------------   l  e : t + u   e : u -----------------   r  e : t + u This is kind of the same thing, except it *requires explicit injection.* So, yes, it's a "tagged union" in some sense, but mostly in the sense of "how do you implement this on a physical machine?", which the theory doesn't care about. The difference is that it doesn't make much sense to talk about a type like `int  int`, because that trivially simplifies to `int`. Consider, in the context of this RFC, what a declaration like `function f(int|int $an_int_i_guess)` would mean! On the other hand, it's perfectly natural to discuss the type `int + int` and draw distinctions between the constructors.
I would be much more interested in Swift if only it was open source as I gave up on OS X when it went to shit (post 10.6).
&gt; Java: The promise of a more mature language, with tools and technologies to match... and potentially higher pay... search your market before starting java. check which are the tools more used in your country/state, which certifications the recruiters ask
**DISCLAIMER:** I am a current employee of concrete5, and actively work on concrete5.7 I want to make clear a few things that may appear differently if peering into a project. * **concrete5 developers who are being payed are focused on concrete5 v7** When we released concrete5 v7, we handed over most of the control of v6 to the community where they are actively working on and putting out releases for things like bug fixes and security issues. The current "leader" of that effort is Remo, he simply lets us know when he wants to put out a release and we give it a quick once over. * **concrete5 v7 isn't meant to be forced anywhere, its just the latest major version of concrete5.** We didn't attempt to do anything differently with version 7 (other than the backwards incompatibility but I'll get to that) than we have with previous major releases. As soon as there is a major release, you can be sure that it was released because we believe it to be ready to take the place of the previous major version. With v7 this was after several RC's and a full alpha beta process. If you have suggestions for how we can do this better in the future, it'd be good to hear them. * **concrete5 v7 is the first (and last for a long long long time) major release to not support upgrading from the previous version** I was the main proponent for ditching backwards compatibility mostly because large swaths of our codebase were ancient, and that was becoming a reason to write poor code. Because we chose to drop support, we were able to revitalize and add a lot of things including a new PSR-4 source directory structure, runtime-defined routing, ORM instead of ancient active record, and tons of other stuff that make concrete5 a better framework for making websites. * **You should use version 7 for new work, we've made no promise that a full upgrade will ever exist from v6 to v7** We are working on making our import and export better to support for possible content migration, but things like advanced permissions and page types will have a hard time transferring over without a ton of work. * **v7 is documented** We have provided full editor and developer documentation for concrete5 version 7, and have made big strides in code level documentation. You can find those here: http://www.concrete5.org/documentation Let me know if you guys have any more questions or suggestions!
concrete5 is FOSS and has a large ecosystem of plugins. You should not base any decisions you make around software on experiences 4-5 years ago.
The example is a bit too trivial $post-&gt;addComment($comment); $EntityManager-&gt;persist($post); $EntityManager-&gt;flush(); seems a lot less intuitive than $post-&gt;addComment($comment); but real worlds apps will probably do $post-&gt;addComment($comment); $post-&gt;addAuthor($author); $post-&gt;addCategory($category); $post-&gt;addTag($tag1); $post-&gt;addTag($tag2); $post-&gt;addTag($tag3); $EntityManager-&gt;persist($post); $EntityManager-&gt;flush(); So yeah, it might seem overkill to delegate the task to persisting to the Entitymanager, but under the hood you've just saved yourself 5 transactions. It does make a difference.
Go, hacklang, node
C
Definitely. :)
This is currently like this and I don't like this approach.
I think I'm confused about what we're talking about at this point. If the feature appears in the extant literature (e.g. Ceylon) under the name "union type", why do we need to pick something else?
But `Traversable` indicates that something will behave like an array for the purposes of iteration, and typehinting to an interface *by definition* indicates that you don't care about the underlying implementation. So you're semantically accurate, but I don't feel that's relevant to how developers actually want to use the language. Especially since the `Traversable` interface doesn't actually define any methods! I'd go so far as to argue that `Traversable` typehints *must* accept arrays in order to adhere to the LSP (again, it's not strictly accurate, but it's absolutely in line with the intent) Similarly, I'd like to see objects that implement `Countable`, `ArrayAccess`, and `Traversable` be transparently substitutable for actual arrays anywhere. Effectively this: interface Arrayish { use Countable; use ArrayAccess; use Traversable; } (yes, I know that isn't valid code, but it illustrates my point) Note that I am not saying that arrays should become objects. I'm not opposed to the idea, but nor am I advocating it here.
Mixed is already implied by a lack of typehint. Not once in my programming career have I looked at code that accepts mixed types and been happy with the implementation. I don't mean `"10"` vs `10`, but actual mixed inputs where it's actually meaningful. You're guaranteed to have either a) internal casting, b) internal type checking, c) an error, or d) very hard-to-explain code (like, stuff that relies on arrays used as a string is `"Array"`) There are some safe casting directions and safe sets depending on what you're doing, but other things can be wildly unpredictable. The [new scalar types RFC](http://news.php.net/php.internals/83011) covers some logical meta-types that address this well: &gt;A possible list may be as follows (again, we can argue what's in this list separately): &gt;* mixed: any type &gt;* scalar: (null|bool|int|float|string) &gt;* numeric (int|float|numeric-string) &gt;* stringish (string or object with __toString()) &gt;* boolish (like mixed, but coerces to bool) &gt;* etc... I feel that mixed and scalar will not really add any value, but I'm not opposed to the idea of them being added: I'd simply not use them. Literally the only time I've wanted to typehint to either of those was in my own strict-typing/coercion library. Nullable types are usually fine, although I tend to find them to be a symptom of poor error handling earlier in the call stack. I'd like native support for them (as has been proposed with Hacklang's syntax, a la `function foo(?Bar $bar)`) but would be generally careful to use them sparingly. We very often repeat the mantra of "be liberal in what you accept and conservative in what you return" when it comes to API design, but years of fighting stupid problems has convinced me that's absolutely the wrong attitude. Huge classes of errors can be provably prevented by simply knowing what your program is really dealing with.
I think it was reasonable too, but there were a number of objections to it including from all three of the language's founding authors. That's where these revisions are coming from. An effort to get from a bare 2/3rd majority to a real consensus.
I struggle a bit because I want to learn things, but I don't want to just learn how to do the same stuff in a different way. Like, I want to learn RoR, but really I'd just be solving the same problems in a different syntax. Also I can't grow a beard. Python interests me from a "pure language" point of view, but it doesn't solve any problems I have. I'm doing more in JS than PHP at times. I'm learning Ember, which I really like. It pairs nicely with my knowledge of PHP, especially Laravel based APIs to create highly interactive and elegant sites. You can also use it with things like Cordova to create mobile applications. Swift interests me because I think it will be a nice clean modern approach to native mobile apps. And I'm not smart enough for Obj-C. Hack because it's basically just PHP++, and is, as /u/JordanLeDoux said, low hanging fruit. Japanese, because you didn't specify *programming* language, and I have been doing Pimsleur language training while I work.
Just a note on strict vs weak for scalars. There is already a notation to force passing a variable in a certain type: &lt;?php function doSomething($integer){ return $integer * 2; } echo doSomething( (int) "2 cows" ); And another to require an argument to be a certain type: &lt;?php function doSomething(SomeClass $value){ return true; } echo doSomething( (SomeClass) "2 cows" ); // Would return an error, d'uh! echo doSomething(new SomeClass("2 cows")); Why not extend it to the next level and do something like the following to declare requiring weakly or strictly ? It would also allow for different requirement types to be accepted, even within the same method. I have not seen this proposed anywhere for the previous RFC &lt;?php // Strict type requirement function doSomething(int $value){ return $value * 2; } // Weak type requirement function doSomethingElse((int) $value){ return $value * 2; } echo doSomething( "2 cows" ); // Triggers Error echo doSomething( "2" ); // Triggers Error echo doSomething( 2 ); // int(4) echo doSomethingElse("2 cows"); // int(4) A further RFC could then easily introduce weak Class type hints, where any object passed that is not of the required type gets cast as the required type, a bit like the serialize+str_replace+deserialize hack: &lt;?php // Strict type requirement function doSomething(SomeClass $value){ return $value-&gt;name; } // Weak type requirement function doSomethingElse((SomeClass) $value){ return $value-&gt;name; } echo doSomething( "2 cows" ); // Triggers Error echo doSomething( new SomeOtherClass("2 cows") ); // Triggers Error echo doSomething( new SomeClass("2 cows") ); // string "2 cows" // instantiate the object from a __fromString() method, to complement __toString() echo doSomethingElse("2 cows"); // string "2 cows", echo doSomethingElse(new SomeOtherClass("2 cows") ); // string "2 cows" echo doSomethingElse(new SomeClass("2 cows") ); // string "2 cows" Thoughts ? 
I know very little about HHVM and Hack. My impression has been that it's really really good at a subset of things that PHP does, but wasn't exactly for the common man (or shared host). If it hit your sweet spot, great, but it wasn't designed for most cases. Browsing around, though, Hack doesn't seem that far off from PHP, and HHVM is more PHP compatible than I thought. Is this a possible contender if PHP internals can't get their act together?
Okay.
C# is pretty nice, from what ive played with. especially wen using .net 4.5. I've been messing around with it making Mods for the game Rust
[Already discussed/being discussed extensively for the past 2 days.](https://www.reddit.com/r/PHP/comments/2w0ban/author_of_scalar_type_hint_spaceshipcombined/)
&gt; Wasn't this RFC cancelled by the owner? It was [uncancelled without objection](http://marc.info/?l=php-internals&amp;m=142406406910762&amp;w=2) (and [with Andrea's consent](http://marc.info/?l=php-internals&amp;m=142409075917938&amp;w=2)) because it was cancelled a day before the vote was going to end in a landslide.
That has been proposed several times and disregarded by most. The main problem here is that you make the API of your functions weak or strict. But the current "consensus" (if you can call it that, maybe "likely way to go") is that the caller decides if he/she wants to use strict or weak rules when calling functions.
&gt; including from all three of the language's founding authors. I'm sorry but I truly don't get this argument. Zeev hasn't touched src [in 9 years](https://github.com/php/php-src/commits?author=zsuraski) and Andi hasn't done so in [6 years](https://github.com/php/php-src/commits?author=andigutmans). Only Rasmus is active. I may be wrong, but we shouldn't consider Zeev or Andi's opinions somehow "special", especially since they have been idle for close to a decade. At least Andi stays silent most of the time. Zeev on the other hand, seems hell-bent on preventing people from changing *his* language.
You should delete this and repost with a title that provides a bit of context. 
This really depends on your workload :( we've fixed most of the easily reproducible crashes, and will be happy to debug new ones; for this release, we've got to the point where most of the crashes are for edge cases - if a fastcgi connection gets terminated unexpectedly, for example. The good news is that these were fixable as a class of bugs (pointer-ownership) instead of one-by-one, so things should be in a much better state now :) If you still have issues, please file an issue on github and we'll try to fix it as soon as we can.
That's what my class file would do. For example, I could $liblist-&gt;getFile('file.php') and it would scan the library list in the correct order and return the first file found. Sorry for the dull reply, I'm on my phone.
Fuck me how did I not see that. I even searched. :(
Being able to hint to `&lt;T&gt;` would be even nicer :-)
`use` could lead to believe that we are importing `strict`, when we are just enabling a mode, so this makes sense. On the other hand, it isn't very specific (all-or-nothing strict mode? just typehints?) and, unlike `declare(...);` (which I don't really like), it's boolean, which limits future uses of the keyword (for example, if we wanted to start migrating `php.ini` options to code, to enable `display_errors`, etc.; not a big concern, just a thought). Some random thoughts (just throwing them): use numeric, stringish; enable numeric, stringish; use alias numeric, stringish; usealias numeric, stringish; Could it be possible to be strict by default, and force beginners to put `use numeric;` (on each file) or `enable numeric;` (available until disabled, no matter the files) to enable said typehint conversion in their code? **Edit:** wrods
I think that's missing a very simple solution that doesn't add any new syntax or reserved words. Some people are against having to add a line of code to every file. These previous solutions also make it hard to mix strict and weak code. Proposed solution: Code indented with spaces is strict and code indented with tabs is weak. The only issue I see with this is that it's hard (but still possible) to mix strong and weak types on the same line of code.
Yeah I know, I understand. I guess its appropriate to get one thing at a time, although I am a bit worried if scalar names such as Int, Float and String become reserved words as my framework/application use them as class names. Anyway, good luck getting this RFC to work, its nice to know someone else is working on this. And if my guess is correct, you are the one maintaining operator overloading PECL extension, right? 
&gt;Personally, if someone wanted strict type handling you'd think they would be using Java. Strict type hinting isn't the sole difference between Java and PHP, and wanting it in PHP doesn't suddenly make it anything like Java.
Holy crap I just got that
It's great, but there are plenty of articles that compare the syntax. What I would love to learn is how my mindset has to change from a PHP dev background to be able to write good desktop/mobile applications, possibly using swift since it's low syntax barrier compared to something like Objective-C.
Swift and Obj-C although from my understanding Swift will be a lot easier to learn. My Why is because I'd like to make iPhone apps that arent limited by Titanium as it's crazy buggy.
May I suggest [this](https://github.com/Mikushi/Tachyon) if you want a lightweight mvc framework? It's created by /u/pornhub_dev and I find it great, has everything you need.
The chapter on Ruby in *Seven Languages in Seven Weeks* is a really good introduction to not only syntax, but the philosophy behind the language. 
So...no tests, eh? Good luck with that.
I was on like page 10 when I got it... then I scrolled back up to see where he first mentions Taylor and he does make the reference that's easy to miss.
API - Documentation https://github.com/smceframework2/API
Javascript is complementary to PHP. I can manage most of the projects from backend to frontend.
I've added a comment below somewhat related, but could you (or anyone in the thread with the knowledge) tell me why `declare(strict_types=1);` was used over something simpler like `set strict_types = true;`? To avoid adding keywords? Other reasons? It doesn't look anything like PHP (at least not to me), so I'm curious how this was agreed upon. Were there other proposals? Were they worse? Were they discussed? **Edit:** answered in [[1]](http://www.reddit.com/r/PHP/comments/2wcoj3/scalar_type_declarations_v05/copvju0) and [[2]](http://www.reddit.com/r/PHP/comments/2wcoj3/scalar_type_declarations_v05/copttw8)
At this point I wonder if anything short of a fork could dislodge the more toxic and useless internals folks.
&gt; Every other statement resolves into a boolean, except for one with the spaceship operator in it. Why does it matter? You would have to be an idiot to use this operator and expect a bool in return.
FYI, Martini is considered to be an improper usage of Go. You might want to read [this](https://stephensearles.com/three-reasons-you-should-not-use-martini/) criticism of it, and [this](http://codegangsta.io/blog/2014/05/19/my-thoughts-on-martini/) is the Martini dev's response.
It's totally okay to learn both. You may accidentally mix them up at times but they absolutely go hand-in-hand. Since you're learning Javascript, are you learning HTML as well? What about CSS?
&gt; I regard 3&amp;5 as the best options. I think 3 may be a little too confusing / cause too many conflicts with how we import things from other namespaces. As for 5, I don't like it for the same reason I didn't like the last version of the RFC, you don't need the `=true` as it adds no value. declare strict_types; declare(strict_types); enable strict_types; enable(strict_types); The above are the best choices I've seen so far (and out of the 2 I prefer `declare` personally), as they avoid unnecessary clutter being added (i.e. `=1` or `=true`), they don't conflict with existing constructs, and they are still super clear. I think all of the other options in the above comment's list are slightly inadequate. The augmented opening PHP tags would be difficult to manage, i.e: &lt;?php-strict_types-some_other_thing-and_something-else You can quickly see how that would get out of hand... The same story with or without the dashes. The comment approach (like Hack) isn't optimal, and carries with it the same issues I mentioned just above. Maybe constants would represent these things or something: &lt;?php declare STRICT_TYPES; declare SOMETHING_ELSE; namespace Foo\Bar; use Baz\Qux; use Foo\Baz; class Baz extends Qux { // ... } Or, just keep it as above: &lt;?php declare strict_types; declare something_else; namespace Foo\Bar; use Baz\Qux; use Foo\Baz; class Baz extends Qux { // ... } Just going to tag /u/htfo in here too so they see this.
Why are you responding to me with all this? Nothing you said supports the statement that committing vendor code to a VCS is good practice.
This is one of my favorite ideas I've heard. I really like how it leaves the door open to additional applications down the road. mode strict, other-cool-stuff;
Awesome. Once we have this, I think http-based libraries could start sharing components with each other.
Writing an MVC framework is a right of passage it seems.
I don't know about all you other guy's, but I'm super stoked. I just want some more information about how to really ramp up on using HHVM in a production environment and possibly using hack as my primary langauge. Does hack just offer all the php stuff and thensome? I've worked with C++ back in school, and I saw a bit of hack a while ago, I just wish/hope the documentation is even remotely similar to the existing php manual, and if so I'll be totally cool &amp; happy with that.
In that link Andy does not promise an upgrade, he describes content migration as I did. There is still the problem of packages and blocks that don't exist for 5.7. All new sites should use v7, if you are interested you should check out the baked in responsive slideshow we have and the marketplace addons that are added every day. Every site you have that's using v6 is fine to leave on v6 unless they want something only v7 can do, it is fully stable and will still get security updates for the time being. If your clients want new work, you should either rebuild the site in v7 or simply do the work on v6. Using an antiquated CMS for your new clients is a disservice. If there are parts of the marketplace that are missing, develop the add-on and sell it for however much you want. This is the only way that addons ever get made :P Certainly if you feel uncomfortable with a CMS, you should shop around and find out what works best for you and your shop.
PSR-2, copy &amp; paste scripts, limited IDEs, no previous experience with strict typing "I'm not sure what happened. Let's uninstall PHP 7"
If the primary advantage to strict hinting is code analysis, why not simply implement as needed within an IDE? Major IDEs like Eclipse, NetBeans, PHPStorm are all context aware and provide first pass syntax checking. Let the IDEs perform the strict checking, leave the language to do what PHP does darn near every where else... just make it work. Trying to find this perfect middle ground where sometimes the language cares about type, and other times it only sort of cares seems like an impossible goal to please everyone. To SkepticalMartian's point, PHP is not Java. Trying to give it Java like strictness just doesn't jive with the core of what PHP is. The expectation in a language where 2 == "2" is true is that type handling is *handled*.
Sorry. I was trying to make the point that PHP is and should be a dynamically typed language. There are plenty of statically typed languages out there if a developer requires that. If I really felt that strict type checking were that important, I would have left PHP a long time ago. I don't, so I haven't... just sayin'.
Today I learned even ircmaxell is not above trolling people.
**Golang** I do a lot of backend work. I think it's a clean language with built in testing support, "lightweight threading" (goroutines), relatively performant (depending on what library evidently), has a built in HTTP server that can act as a GUI to local machines. Most importantly it's **fun** to play around in, like PHP was to me a decade ago. 
Your game looks pretty cool :) I'm into "old school" browsers games. Would be awesome to see the final result once you're finished.
Not outside of the occasional blog post and video. I have a very hard time believing you'd support this idea.
Whoop!
"support" :-P
It's inconsistent because every statement besides this one is a boolean expression. It needlessly breaks consistency when a `cmp` function would have accomplished the exact same thing. 
Are you using a framework, writing a plugin for or modifying an existing application which may be modifying the error_reporting level within its code? What's the value returned at the point at which the deprecated message occurs by error_reporting()? (You can use the following code to break down the value returned by error_reporting into named levels: https://gist.github.com/AllenJB/2217955c1789f8db7e6c ) If your code is running your code as a web page, have you restarted the web server and/or php-fpm?
You will have to bite the bullet at some point and have to fix this. Generally it is a fairly easy process to upgrade to the mysqli functions. Have you tried the error suppression operator '@'? That might work although I've never tried it with mysql functions.
**Hack:** Seems to combine the best of PHP and C# (my two favorite languages) **Go:** I've heard great things about it; hopefully can find a use for it within my client work **Python:** I started getting into it a while ago but my interest fizzled out. Probably need more exposure to Django and other useful libraries. **Lisp/Clojure:** Something different I already know a good bit of JS, so learning Node/Dart would be a logical next step, but I just don't have a strong enough interest right now.
This is never a good choice! I'd rather prefer using the error reporting level ( I think it is E_ALL &amp;~ E_DEPRECATED) at one point to be able to turn it off and on at will. As an added bonus you won't suppress the warning that is returned when not providing correct function parameters or if the mysql is not available. 
Separate routes is definitely the way to go.
&gt; which fixed several memory leaks and reliability issues &gt; a multitude of other crash and memory leak fixes &gt; including investigation into several longstanding memory and stability issues Sign me up, this HHVM sounds awesome to use in production.
Ha, I made the same comment before noticing yours.
Agreed; using suppression is never a good option but since he asked I tried to give him a solution. 
maybe this? https://floobits.com/
well its actually no surprising, considering CI and Wordpress were the only two major PHP open source software/ frameworks that used to oppose the 'Lets go PHP 5 movement' when PHP 5 was slowly taking over the old PHP 4 a few years ago. When PHP 7 comes out, I'd expect them to pull the same and stay with PHP 5 for as long as they can until forced to move to PHP 7. Still, its understandable to some extent from Wordpress' point of view, as it's the industry leader and it's enjoying all the popularity now so a change may not seem very appealing to it anyway. People say 'dont fix what is not broken', for Wordpress it makes sense. But CI is different, as it is already dying and losing developers to other PHP frameworks, and therefore should have a strong incentive to make some cutting edge changes with version 3. Despite the fact that CI's popularity shrinks everyday to rising competitors such as Laravel, it still willingly stays behind with old fashioned PHP 5.2. It's like waiting for death when you need to make a positive change, in order to stay alive in a tough competition, but instead end up with no effort at all. 
**Ruby, Python** Why: I like using Jekyll and Flask for some small projects, but there is still plenty to learn about the languages themselves. Thoughts: I feel safe developing in PHP and I can usually take an existing code base in another language and expand upon what it has already implemented. I think I fear that I'll do things the "wrong way" when starting a new project in a different language -- not to say that I haven't done plenty of "wrong way" developing in PHP. So with starting a new language, my expectations may be too high on the quality of code I should be writing.
If you think Zeev has contributed nothing to PHP for 9 years, you're absolutely mad.
What? I'm not *thinking* anything. I justed looked at his commit history, and he didn't touch anything in 9 years. That's not an opinion, that's a fact. So, what exactly is your point?
I have made changes in global php.ini and restart apache many times, but the deprecated messages still show up on the web page
Totally agree, let's me throw in a new uri resource within minutes. :) 
For me, Swift has had a much steeper learning curve than Obj-C did. Syntax is an issue, but Swift introduces many concepts that are integral to its design patterns (and its syntax) that are completely alien to me (optionals, structs, generics, and tuples are just a couple that have/are throwing me for a loop). 
CI just needs to die. At least in terms of marketing it to newbies / for new projects.
Yup and this is exactly why type casting needs to be changed.
Hi! I'm pretty sure concrete5 is a very good platform. However, I'd like to suggest SiteSupra (www.sitesupra.org) because of it's intuitive and unique CMS for editors. Check it out and see if it works for you!
You're most likely right. Just throwing something out there. It's just frustrating to me that something as useful as weak type hinting is put on a back burner because of needing to find a way to sometimes make it strict. The other thing that concerns me is that today we're talking about *strict* as a debugging feature. Later a flag like this is going to become a policy to be required. One of those, be careful what you wish for! 
feel your pain, to me CI feels like a glorified php5.1
Big thanks to MWOP and everyone else who contributed to this. Really great work.
umm I wonder though, is it possible to remove scalar type names such as int, bool and string from reserved keywords? 
I modestly suggest you look like you are moving toward an [ADR approach](http://pmjones.github.io/adr) instead of an MVC approach. In short: 1. The controller method (the "Action" in ADR) should marshal the incoming user input, and hand it to a model layer (the "Domain" in ADR). 2. The model ("Domain") layer does all the interesting work and returns the results. 3. The controller method ("Action") then gives those results to a separate Responder object; that's where the switching between output formats should occur. You're already moving in that direction; maybe the ADR paper will help out.
The `UriInterface` has been asked and answered a few times. It's a `uri` only in so far as it relates to the HTTP message, and so other types of URI are irrelevant and this doesn't need to be its own thing. Bringing this up again - especially when in review - seems a) a bit late and b) quite unproductive.
The only issue I could see is when it comes time to learn Object Oriented Programing. Javascript does OO differently than most other popular languages. Javascript uses prototypal inheritance whereas php uses classical inheritance. 
They are reserved Classnames. Very different from reserved keyword. Keywords are disallowed everywhere in the engine (constants, functions, etc). Classnames are only disallowed in that one context. How would you resolve the ambiguity if you could have a class `Int` and an `int` type declaration?
The only other way to do this is to say that lowercase `string` is a string typehint while `String` is a class typehint. While I'm all for case-sensitivity, the fact of it is that PHP uses case-insensitive class names and departing from that here would be one of the famed PHP inconsistencies ;)
Yeah you ask a good question, I'd say using case-sensitivity then. Int is a class, int is a scalar. In this way, only the lower-case(int, string) are reserved, but upper-case(Int, String) are not. umm its not a perfect solution, so I understand why. Ideally we have scalar objects implemented, but it's not likely to happen anytime soon so this means I have to refactor my code extensively... 
I think this solves all the previous issues. I still dislike declare(...) but I am sure no library will use it internally or externally anyway. how long we need to wait before this start to get votes? how long will the voting will last?
Found a typo declare(strict_types=1); function foobar(): int { return 1.0; } var_dump(foobar2()); &gt; var_dump(foobar());
You can implement a `fields` query parameter for your api. Consumers would then pass in a query string listing which fields they want. This should reduce the amount of data you get back and possibly reduce the database/retrieval workload on the API server. Facebook's graph API does this and it works very well. You can request specific fields as well as nested fields and edges. See https://developers.facebook.com/docs/graph-api/using-graph-api/v2.2 
Don't forget "not understanding a joke".
Looking good. I just feel that having to type `&lt;?php declare(strict_types=1);` everywhere will get a drag real quick and should probably get patched up straight away, but that would be no reason to oppose the RFC. 
If you can drop the !, can you get the fizzbuzz case without specifically coding that case? Can you put 3 and 5 in an array at the start, so that they can be swapped out for say, 5,6 and 8? Can you make it into a function? Can you make it throw exceptions if the parameters of that function aren't valid? Can you suggest some unit tests for the function? Those would be good follow up questions in my view.
&gt; When PHP 7 comes out, I'd expect them to pull the same and stay with PHP 5 for as long as they can until forced to move to PHP 7. That's because every shared host out there is going to be *stuck* with PHP 5 because that's what their infrastructure provides. We aren't likely to see PHP 7 adopted on mainstream shared hosting in any reasonable volume for *at least* a year past release of 7.0.0. It's going to take that long, if not longer, for LTS Linux distros and vendors of shared hosting control panel software to get their ducks in a row. As developers of modern PHP, it *is* our responsibility to push hosting providers to keep their stuff up to date, but we can not forget that the *vast majority* of PHP installs are on shared hosts, and the *vast majority* of shared hosts aren't technically competent enough to keep their stuff up to date. It's easy enough for us to just say "well, don't do business with them," but think of the *average* person that installs Wordpress, and think of how difficult moving a site will seem to them.
Sorry, why am I a obvious troll? 
"I don't understand how some people can't program this in a interview test" then pasting shitty code
i think this explains it better http://www.whitewashing.de/2015/02/10/a_case_for_weak_type_hints_only_in_php7.html
&gt; the mixed-mode type hint proposal has been left abandoned. Sort of: http://www.reddit.com/r/PHP/comments/2w8psc/scalar_type_hints_v04_predraft/
Your users can't ignore it. Your code will still always be strict. The users can however call *into* your code however they want to. But once your code is executing, you have full control. Meaning that the boundaries between code are controlled by the person handing control over, not the receiver. The rest is completely up to you.
Perhaps I'm wrong but the references I've seen is that people can't even code a working version let along that of good enough code required for production use. I never said my code would be the best, which is why I've asked on reddit for feedback. Thanks for your motivational comment to a young programmer. Enlighten me to why my code is shitty please? I agree its not the best but I was pretty pleased for only 20 minutes work to get a working solution.
The second paragraph is a bit unnecessary Phil, no?
The only reason people use WordPress is because of the vast amount of plugins. Upgrading the core is easy but doing so kills the one competitive advantage they have. 
I would try to evaluate if the slow down is from the API or the consumption of the API. It is not clear from your post. If the API is taking a long time to assemble the data there is nothing you can do in the consumption of the data, and vice versa. Where does your "product compositions" occur? In the API or are you assembling the data. Your data set is small and the size of the JSON you provided is also small. I doubt that is your problem unless the product list reaches into the 100s. I would also recommend implementing Xdebug to evaluate where the slow down is occurring.
Is there any reason for the less than 3 case, or did you just want to tell your future overlords you loved them? Otherwise, it's an if clause executed 96 times for no reason.
You're brave. You can gain some insight from Anthony Ferrara's [Development by the Numbers](https://www.youtube.com/watch?v=fnRwfjMqKM8) talk.
Whether you believe Zeev's contribution is valuable or not, it still does not stand that his opinion should somehow be "special", or that his opinion should be given any special consideration. He's not granted any special standing in any of the policy documents that set out how internals works...
&gt; what were the 2/3rds of voters at the 0.3 vote doing? Fibbing? ;) Shilling? :p
See: https://wiki.php.net/rfc/scalar_type_hints_v5#why_not_use_use_strict_instead_of_declare Yes, if we were introducing the `declare()` structure that would be a far more valid point. But the fact that it exists and behaves consistently with the current proposal needs to be considered. &gt; The =1 adds nothing to the statement in this case and is unnecessary bloat. Aside from the consistency with `declare(setting=value)` syntax, it has another potential benefit. If in the future we wanted to make it accept multiple values: declare(strict_types=1); declare(strict_types=SCALAR_HINTS); declare(strict_types=SCALAR_HITS | PROPERTIES); declare(strict_types=PROPERTIES); etc. Where we can expand by turning what's an integer today into a bit field in the future. Is this ideal? No. However it doesn't "add nothing". It's done for a reason. Could we add `use strict;`, sure. But we'd lose explicitness (what if we want to add a future strict behavior). Any other alternative requires adding new parsing structures. Is it possible? Sure. Is it worth it? I don't think so. I did suggest at one point to add the concept of a `strict namespace`. This would follow the namespace rules, and only affect code within the namespace. However after much consideration I've decided that the `declare` syntax solves the most problems without relying on purely subjective arguments (plus it introduces no new syntax).
In a public chat room, it was mentioned that: &gt; Ze'ev and Franois have not-so-politely asked me to not put 0.4 forward since they have something they believe they have consensus on. I must edit this to put the clarification made by Sara: http://news.php.net/php.internals/83227
Creating something tends to make you special within the circle of folks who end up working on it. Rasmus/Zeev/Andi are as close to BDFLs as PHP has, and their opinions are well respected and "special" for good reason. Not just because they originally authored the project, but also because they still provide a wealth of knowledge and insight, regardless of whether or not they see eye-to-eye with other contributors. In any case, you can't blame Zeev for other people in internals considering his opinion special, now, can you? He doesn't have any mind control powers that I'm aware of.
do you need to set $loopCond to false before the endwhile somewhere? Maybe your button spinning is an infinite loop. I havn't used that syntax before so I could be wrong.
A lot of people confuse themselves when they try to teach themselves the fundamentals of client-side scripting (javascript) and server-side scripting (php) at the same time. Take a look at this example: &lt;?php $inputField = 'myName'; $inputLabel = 'your name'; ?&gt; &lt;script&gt; function validate(form) { if (form.&lt;?=$inputField?&gt;.value === '') { alert('&lt;?=$inputLabel?&gt; is required'); return false; } } &lt;/script&gt; &lt;?php if (!isset($_GET[$inputField])): ?&gt; &lt;form action="&lt;?=$_SERVER['PHP_SELF']?&gt;" name="myForm"&gt; &lt;label&gt; what is &lt;?=$inputLabel?&gt;? &lt;input type="text" name="&lt;?=$inputField?&gt;"/&gt; &lt;/label&gt; &lt;input type="submit" onclick="return validate(this.form)"&gt; &lt;/form&gt; &lt;?php else: ?&gt; &lt;p&gt;hi, &lt;?=$_GET[$inputField]?&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="&lt;?=$_SERVER['PHP_SELF']?&gt;"&gt;click here to try again&lt;/a&gt; &lt;?php endif; ?&gt; The first thing that I have seen many beginners get confused about is the timing. Even though the javascript is near the top of the file, the PHP runs first. This is because PHP runs on the server, and javascript runs on the browser that connecting to the server. In cases when they are the same (e.g. localhost) this can be especially confusing. Second, JS and PHP cannot talk to each other, at least not within the same script. PHP can insert things into the javascript soure, but that is the extent of the relationship. Javascript cannot read the PHP variables, nor call it's funtions. Similarly PHP cannot call JS functions, and the JS variables are useless to PHP. As far as PHP is concerned, the javascript is just like any other string. It can filtered, concatendate, replaced, printed in a loop, etc. When PHP is done, it sends your page to the browser. (and then PHP is really finished) When the browser receives your page, it recognizes that the javascript is not just any text, it's code, which it runs. I hope my post saves someone some time understanding how PHP and JS are used together. PS I went back and forth about whether to post such shoddy code. But I do need it to illustrate my point.
It definitely looks like an infinite loop (although depending on the nature of the CodeAcademy lesson, that might be intentional). The syntax appears to be OK at first glance, infinite loop notwithstanding.
I'm aware of the options for webservers on Windows, but I'm limiting the discussion to IIS on Windows.
Why am I asking about these?
Thanks for the feedback. I was following the instructions to [install PHP](http://php.net/manual/en/install.windows.manual.php) on a Windows box and noticed that the top comment was from **8 years ago**. I edited the php.ini so that it would use some of the extensions included with it, but when I ran PHP from the command line, it complained it couldn't find or load around three of the .DLLs. They were definitely present in the directory and others were found, loaded, and usable upon testing. Googling for the warnings that PHP was emitting didn't return any useful results and it got me thinking that PHP for Windows is just an afterthought. I do understand that IIS has [its own](http://php.iis.net/) installation bundle. On that site, I see the most recent blog post is from April 2nd or last year. So again, I'm thinking PHP + IIS is just not a thing that's done.
You've put this in the wrong place. Questions like this are best addressed in /r/phphelp. This sub, /r/php is one dedicated exclusively to arguing about static type hints. But to actually help you... You're creating an infinite loop. The point of a `while` loop is to keep doing something until a condition changes. The most common usecase is mysql_query. while ($row = mysql_fetch_assoc($result)) { echo $row['firstname']; echo $row['lastname']; echo $row['address']; echo $row['age']; } In that example, for each loop over a result set, it will set the value of `$row` to the current row in the result, until it runs out of rows, in which case the result is false, and the while loop stops. Your example doesn't change the value of `$loopCond` at any point. If you break down what it's actually doing you'll see why. Set the value of loopCond to true, and you then do a loop 1. If $loopCond is true, echo string 2. Go back to 1 This will go forever. What you more likely want to do is some sort of condition that stops it running. $counter = 0; while($loopCond){ echo "&lt;p&gt;makin loops&lt;/p&gt;"; if($counter == 10) { $loopCond = false; } $counter++; } This code will loop over somewhere between 10 times (actually 11 times, tbh) and echo happily, but when it gets to the 12th loop, `$loopCond` is now false, so it will stop. 
Thank you! I will check it out now!
I did have read those threads :) .
You... really... don't want to try to have two or more people editing the same file at the same time. But I think Google Docs will let you do this. Get git and learn how to use it.
I'm not sure I understand all the hate declare was getting, care to explain? I mean, declare is already part of PHP and meant to be used for engine changes, right?
CI just needs to die. The community as a whole should be warning new developers and then chastising existing developers of working on it and encouraging companies to move over to more newer frameworks.
Well I see this happen a lot. I used to post PSR progress through Draft, Review, Acceptance, etc and sometimes they'd hit some of those steps a few times. People wait until its almost accepted to say "Woah hey what's going on!", and I'm the bad guy when I remind them that they waited a bit too long? Not trying to be an ass, just pointing out that it _is_ a bit late and it _is not_ productive.
Nice at-least the site uses wordpress `Fatal error: Call to undefined function wp_normalize_path() in /home2/firenews/public_html/wp-includes/plugin.php on line 679`
&gt; URIs are useful outside of the context of HTTP messages Yes, URIs are a whole big topic that we could get into, but this HTTP PSR is only talking about URIs in the context of HTTP. So, these URIs live in the HTTP folder and are HTTP related, meaning that larger topic is irrelevant. Making a URI PSR would be a whole extra task, and is again utterly unnecessary for this PSR. Waiting on another PSR to go through, just so _this_ PSR could use _some_ of it seems like a really odd move. &gt; Nothing about streams is even remotely related to HTTP messages Other than the fact that a HTTP Message can be a stream? Again, everything I said about URIs can be applied to streams. It _could_ be a whole big thing then we're just overengineering it instead of specifying the simple stuff for the task at hand: HTTP Messages. I said above - which was taken as offensive - that this is nothing new. These things have all been discussed and decided against, and I stand by that.
Not sure my Moto X can swing that one. 
I'm not sure why it's over-engineering to separate them. I'm not suggesting that they be reworked - just organized properly. You also didn't reply to the (not trivial) problem this poses, which is what happens when other PSRs want to use streams or URIs.
I agree with the sentiment, I just feel it was adequately conveyed in your first paragraph and didn't need to be hammered home in such a way to potentially dissuade further contributions from observing parties in future. This PSR is really exciting though and is most needed. Fantastic work from all involved. 
Interesting. Seems like my codebase is already semi-ADR, just need a proper responder and see if I have anything missing on the domain layer. I'll do more research about ADR, thanks! 
Personally I would love for the restriction for declare() to be the first line to be dropped. This would for example allow to enable or disable strict typing based on whether you are currently running in development or production mode. I'm probably an edge case here (I know http://xkcd.com/1172/) but our 10 years old application with not exactly 100% test coverage would certainly benefit greatly from getting strict types, but I would really still like to run in production without strict types enabled for some years to come. If you still want to keep the first line only thing, then maybe raise a new type of error that's off by default (just like when E_STRICT was added) when a type conversion happens in weak mode. Then I could enable that during development. I really, really want to continue improving the quality of this code-base here and strict types would be an amazing tool in the belt, but only if I have a means to do this only in development mode at least for some months as I'm getting my shit together.
I had a [go at it](https://gist.github.com/0xMatt/0a70941ec42e43aefb67) not that long ago.
This sounds PERFECT! I am going to give it a try and I am SURE I will have questions haha THANKS
also, the MLS should provide technical and best practices docs that will usually go over some very important details regarding that particular server. if you didnt get them, ask your client to request it. dont just skim over it, read the whole thing, but do it after you have a basic understanding of how phrets works. ive found the matrix system of rets servers is the easiest to work with so if they use that, then to me, your already 2 steps ahead. also check what the offset number is for the first listing.. most of the time its 1, but it could be 0, and if it is then youll get an error trying to use 1.. i spent alot of time trying to figure that one out one time. and good luck!! it can be frustrating the first time, but its a real good skill to have, as realtors pay seriously big bucks for this kinda stuff. 
I'm guessing that things have changed quite a bit since you "left" PHP four years ago. It sorta depends on where you were at back then? I think a good place to try and help get back up to speed would be [PHP The Right Way](http://www.phptherightway.com/). The PHP Podcasts site is a great resource for PHP podcasts. I'm biased toward [That Podcast](http://thatpodcast.io/) for obvious reasons. We talk PHP but we talk about a lot of other things as well. Though not strictly PHP, you could consider joining [Dev Book Club](http://devbookclub.org/). Most of the people are PHP developers (at least as far as I can tell) so a lot of PHP-related things tend to come up but the current book we are reading isn't directly related to PHP. [Principles of Package Design](https://leanpub.com/principles-of-package-design) by [Matthias Noback](https://twitter.com/matthiasnoback) could be a good introduction to building and using modern packages in PHP. I haven't read it all yet but Matthias does a great job of explaining general software design principles and the examples are in PHP. If you are looking for resources outside of podcasts/books, I would recommend joining some of the IRC and Twitter communities. I've found those to be super helpful in getting me more involved in the PHP community as a whole and also helping me learn more about what projects are available. If Twitter is your things, Cal Evans has [a pretty decent list of people tweeting about PHP stuff](https://twitter.com/CalEvans/lists/phpeople). A great IRC community you could consider would be [PHP Mentoring](http://phpmentoring.org/). You can join #phpmentoring on Freenode. I'm not saying you need to find a mentor but that is always an option. Just getting involved there (even if it is just listening or asking questions) could be useful even if you don't ultimately decide you want to mentor or find a mentor for yourself. Many of the projects have IRC channels where developers and users hang out. Most of the projects I know about are on Freenode. #composer, #auraphp, #dev-discussions, #devbookclub, #devhell (for the /dev/hell podcast), #silex-php, #sculpin, #thatpodcast. I've found some channels to be heavy on the chatter. I used to frequent #symfony more often but the signal to noise ration for me was too low once I got into the swing of things. I know some projects like Laravel have multiple channels, one for support and one for off-topic stuff. I'd say pick a few channels and see what works for you. I would not suggest joining one and then passing on the IRC experience if that one does not work for you. If community is your thing you could consider joining a local PHP user group in your area. Several of the user groups I've attended have IRC channels as well. #madisonphp, #mkephp, etc. If you decide to come to IRC and you want to say "hi" to get you started, you can find me under the nick "simensen" in any of the channels I listed above. If you can't find a local user group you could always check out [Nomad PHP](https://nomadphp.com/). It is also run by Cal Evans (and company) and was designed specifically to meet the needs of people who cannot otherwise attend user groups regularly.
 &lt;?php for ($i=1;$i&lt;=100;$i++) echo (($x=($i%3?'':'Fizz').($i%5?'':'Buzz'))?$x:$i)."\n"; ?&gt; Based on http://stackoverflow.com/questions/12749261/php-fizzbuzz-challenge Test http://codepad.org/zAq6CdOK
Just because it exists and is meant for that kind of functionality, does not mean it is the best choice. There are alternatives that are better. For example: strict class Cart Uses existing methods to make a strictly typed class without looking ugly or out of place.
&gt; In any case, you can't blame Zeev for other people in internals considering his opinion special, now, can you? I'm not blaming Zeev for other people in internals thinking this of him. I'm blaming Zeev for thinking this of himself. 
Reasonable answer. 200kb should not be a problem at all. I had a project that fetched 1MB of data in less than half a second. With processing and filtering the request (towards us) took like 100ms for a response to be created. Looking into JMS Serializer may help here. Otherwise I would question the API that is called externally.
Surely abandonning mod_php would help the poor users of those basement trash services using mod_php or even older versions of PHP
Format your code if your expect our help.
 while($row = mysql_fetch_array($query)) : should be while($row = mysql_fetch_assoc($query)) : as you are trying to access the var on its associative array name. $age = $row['isbn'];
At first glance it's easy to make the dumb thought that someone passing you values in weak mode means you aren't getting a value of the correct type (because it looks like you aren't). Making the mental jump to realise that the interpreter will make sure you do have the right type can be hard.
People, it's time to fuck this sh!t and move to something better, wether another language, or hack + hhvm. All your valiant efforts are wasted trying to fight people who don't want to see PHP improve. At all. It's all just political sh!t salad now.
The idea is to initially create them automatically but then we need to add specific logic. Creating a CLI tool to generate a whole default component is not difficult and can save a lot of time.
I always wanted to start a satirical PHP: The Wrong Way site, filled with impassioned defenses of crappy practises, on specious and frustratingly ignorant grounds. I'm disappointed to see someone beat me to it. :( 
Pretty sure he was saying that firmly tongue in cheek. 
Sorry for a dumb question, but will we have a better way of casting types in PHP 7, or we will still need to write something like: &lt;?php declare(strict_types=1); require "add.php"; var_dump(add((int)1.5, (int)2.5)); // int(3) Because it looks horrible and the explicit type casting is obviously necessary if we use strict types.
it starts to look a lot like silex ;)
Again, you're right  maybe I am being a little too sensitive as nobody else has taken issue with it. I envy your candour!
The problem was never making that jump. It was understanding how the conversions are made. That's the counter-intuitive part of it all. If you've worked in any other language prior to coming to PHP you'll understand casts. What you probably won't understand is PHP's unique take on casting and its side effects.
No, it definitely is done, but you should use the web platform installer if you're going to do it.
You're the only one who ever really understood me.
This just seems to be a list of javascript powered IDE's.. No mention of other great IDE's such as PHPStorm or the other various non-js ide's out there. Even Netbeans is worth a mention, that served me well for many years! If this was meant to be a list of reliable ONLINE editors then that changes things, but Brackets is included in there hence the above comment.
If I want to use a different container, should I extend `\Slim\App`?
That was my mistake. I thought it was 8 because I saw a forum when I typed that reply talking where people were talking about 5.7. Clear it was my mistake. Did not mean to exaggerate. 
http://news.php.net/php.internals/83180
You may have liked it, but at least 25% of no-votes on the prior proposal were due to that very fact. I can see where you may want to use the feature, but it's a case of 99% of usages are going to make things worse, not better. So with that in mind, limiting it to the file does have advantages.
- Not telling me what to do Off course, I understand that. I guess you could call it recommending, as you said above "You should use version 7 for new work". What I meant to say in my conclusion is that if the developers feel we shouldn't be using 5.6 and I feel I can't use 5.7, then to me that is a problem. I am happy that you have released another 5.6 version (version 5.6.3.3) just yesterday. That makes me want to keep using 5.6. - "do not want anyone using concrete5 that doesn't like it" I did not mention I do not like it. I explicitly stated above I LOVE it. The main issues are a lack of plugins (i wish i had the resource to do so), not 100% documentation (although I understand it is coming), no upgrade script. I mentioned I want to use it, but just can't in my environment. Disappointed you could say that but hey ho. I don't have a problem, at the end of the day we are using Concrete5 for free. So I understand that. - My decisions are my own I have come to decision to move away because of the reasons above and will be back once 5.7 has a good enough market place. I wanted a opinion from a Concrete5 developer and got one. So thanks for clearing up issues for me. - General question. I may be wrong, so please correct me, but why are you guys using Concrete5 - 5.5.2.2a1 for you main website? I thought it would be on 5.7?
It doesn't really contradict. Most operations don't need the precision that large integers provide (on 64 bit platform). Having a slight loss of precision is sufficient for those operations, hence ints resolving float hints is acceptable the majority of the time. However, some usages, like number_format, really are about the *value*. So therefore they should accept a numeric type and decide based on the original value what to do. Really, it depends on your usage what you need. And that's the point I was trying to make. In the 98% use-case, int-&gt;float conversion is fine. It's the 2% where numeric would help...
Ah, I see the `AdWordsUser` class `__construct` method takes a path to the ini. Feel a bit silly to have missed that. Thanks for pointing me in the right direction
- Have you seen/used Designer Content yourself in 5.6? Yes I have seen it and used it on plenty of websites. My clients and team have found it to be crazy useful. - Have you compared it's functionalities with the similar product for 5.7? Yes. I believe your block may be even better. Great work! - Am I to blame if I made it for you guys? No you not. We thank you for developing it. If you really wanted no glory from the block, you wouldn't charge for it. If you are business man you would charge for it. If I was you and I made the block, I would charge for it too. Why not? You spent the time to develop it, not us. - Do you work for free, do you create free websites for your clients? Off course not, you do not have to be sarcastic when I did not bash your product in anyway. That is just being immature in a very reasonable discussion. In fact, guys try out the block, from the videos and screenshots, it looks great. I believe it is great and can be very useful. - How much is $25 per website, if you ask your client like $2000? $25 dollars is not much at all. Although, we produce many websites in a month. This is not the only plugin we would have to pay for or pay to get developed. I rather have that money put back in my team. Whether it is team training (Subscriptions to training websites like Lynda.com) or even team building. As a businessman you must be aware, why pay for something you can get for free? - Just saying I can't do volunteer work, people have to live and earn their bread somehow Off course, complete aggree with you. Like said above, I would charge for my work too. Again I will stress, if there are tons of free plugins in Wordpress, your block is not the only one I would be paying for. So for me and my requirements it does not make sense to pay for your block. That is just me, other people may find it useful, I hope they do. But your block is not the only reason I have decided to not use 5.6 until 5.7 has more plugins. So understand, your block is great, I hope you do well. I just don't think it would be wise for me to use 5.7 atm. That is it. No need to be so sarcastic in your response. 
I'm not really following your example. Is the `add()` function supposed to have int or float type hints? If your `add()` function has int type hints, then passing in floats will fail since float-&gt;int cannot be converted without data loss. It's up to you to sort out your data (whether you cast or use `round()`). If your `add()` function has float type hints then passing integers would be fine (but then why are you casting to ints?!). See the section "Integers Should Be Accepted For Strict float Arguments".
Hey guys, I want to thank you all for your responses, I asked exactly the same question on the JavaScript reddit and the responses where nearly the same. I'm still not sure wich ebook I'm going to buy, so if you maybe have a book to recommend me that would be nice! 
Please - **help me to help you.** Don't ever ever ever run PHP on windows. Please and thank you!
GNU Screen or any of its alternatives works well if everyone can SSH to the same server.
I would say even like 90% maybe more. 
Which is kind of a pity. CI's general approach has a low level of abstraction which makes it easy to follow what it's trying to do. If it rebranded itself as a learning tool, implementing contemporary best-practises it could actually be a genuine asset to the industry. A training wheels framework. 
The HYDRATE_OBJECT on selecting only the columns I want didn't work, an array was returned. I did some research on it and although this is possible through [partial objects](http://doctrine-orm.readthedocs.org/en/latest/reference/partial-objects.html) it's not recommeded. I enjoyed your blog post, that was exactly what I was looking for. The unit of work pattern that doctrine use saves a lot of optimization issues we had in the past that I completely forgot about. Thanks for the thorough answer!
I will sometime this year. It still has a few issues to work out.
Thanks for the links. It's great to know there _are_ options for Linux/PHP/MSSQL . 
Although this is made in Java, it's one of the best implementations of the fizzbuzz problem: https://github.com/EnterpriseQualityCoding/FizzBuzzEnterpriseEdition (This is a joke)
For my company app we use an ORM (Eloquent, specifically) for handling small things like accounts/users/etc. For our reporting we drop into PDO because of the overhead of an ORM, not to mention trying to use an ORM on our dataset (gigabytes per report, usually) would be an absolute nightmare if not completely impossible.
now write it using recursion
here's a pretty optimal solution for($i=0; $i&lt;100; $i++){ if($i%3 == 0) echo "Fizz"; if($i%5 == 0) echo "Buzz"; if($i%3 &amp;&amp; $i%5) echo $i; echo "\n"; }
You could build a PECL extension with the proposed implementation in about 5 to 10 lines of code to change the default mode (set the default for every file, prevent weak mode, etc). The problem with a global solution in-engine is that it's murder to portability (if you're expecting strict, you may be relying on the error being thrown, so weak will having weird side-effects). So if we only talk about per-file in-engine support, it comes down to sugar. there's no practical difference between `declare(strict_types=1);` and `set strict_types = true`. They are identical in behavior. So why invent new syntax for existing behavior?
and not to mention, even after you've done all that you don't have objects with nested relationships, properly encapsulated business rules or any enforcement of consistency. You just have a bunch of arrays. 
I work as a contractor... I have been in 3 shops in a row that rely on Doctrine2. and let me tell you, there's a reason they pay me $75/hour!! And it's to basically rip out all of their findBy()s and replace with pure SQL in repositories. I just did this for a Fortune 100 company, replacing the Indian team's Doctrine for SQL in the Repositories. I only refactored a handful of repos and their services, but overall performance increased by over 20%. I reduced total queries for all the integration tests from ~55,000 to 17,000 by just stripping the ORM from 5 or 6 places. What takes an ORM expert 100 queries a SQL expert can do in about 2 queries. And the end dev can't even tell it's that bad, usually! ORMs are for the hobbled. I was part of a startup last year that basically caved under Doctrine blight. They had me rewrite their core queries, too, but it was too little, too late [due to how they infinitely recursively linked various doctrine objects]. They just couldn't scale past a dozen simultaneous users, and the project ultimately failed after almost a year.
Stupid DQL just pisses me off, all the time! Try doing this: SELECT foo, (bar.id IS NOT NULL) isBarLoaded FROM foo RIGHT JOIN bar WITH bar=foo.bar You *can't*. Even tho it's BASIC SQL. And why the heck do they strip Id from DQL? And why replace ON with WITH???
I've developed a browser-game (PHP strictly), and totally know how hard it is to get it to that awesome level of immersion using 3D graphics and such. I'm actually in the midst of re-building it and simply getting it to work (from code developed in 2007), it's fun converting it to modern standards. The thing to keep in mind is that players that enjoy browser based games arent' expecting those AAA level graphics, they play browser based games because they are quick, "easy" to dive into, and don't require a fancy system to play. 
Hey man, do Codecademy.com. If you haven't already. It's an amazing place to learn Javascript, PHP, and more.
I get the idea that it is Doctrine that sucks, not ORMs. I don't like Doctrine (from what I read in the docs) but I'm OK with Eloquent and ActiveRecord from rails. Its just enough simplification without locking away the db. I know and like SQL, but I don't like having vendor specific SQL cluttering the code base. You can achieve the same thing 90%+ of the time using the abstraction if you take the time to properly use the abstraction.
&gt; function added an int type hint Well, assuming that `find()` didn't use a type*hint* in the arguments, but did still use a type*cast* inside the method body, then I would want the type*cast* to behave the same way it does now in "weak" mode. From the wording of the proposal, that type*cast* behavior would change, even in "weak" mode. It shouldn't do that, if only from just a BC compatibility standpoint. But I agree, if we're talking about using type*hints* that are meant to enforce strictness in parameter types, then yes, type*casting* should also tighten up as well (but again, only by developer choice). Maybe I was misinterpreting that though - I think Sara may have only been talking about coercion that happens from type*hints*, not existing type*casts*.
Like any technology there's trade off. Personally I like the way it speeds CRUD things. About Doctrine I like the Query Builder (which you can have with only the DBAL if you don't want the ORM) when you need logic to compose your query, the entities with the getter/setter etc. Associations can be a bit cumbersome, especially when you need to use the getReference instead of just feeding your models ids. Also sometimes its reliance on the primary key can bit you. Once you're into complex queries and specific vendor functions (like all those postgresql goodies) you should mostly stay away from it and have a clear strategy about data mapping, hydration etc, especially in a team because otherwise you'll end up with a mix of Sql queries, DQL queries etc, wondering each time what kind of data all those functions in your repositories return. Good thing is as /u/leedavis81 said you have access to the underlying PDO connection. For performances and hydration, more people should be aware of the EXTRA_LAZY attribute, and cache cache cache. Can't comment on the event system as I try to not use those magic things that people will forget, as triggers in the DB as well, except for passive logging.
Indeed. If you read the About section of Hyperspace Wars, it indicates that the target audience isn't really casual gamers or those looking for action or eye-candy. I intend for Hyperspace Wars to appeal to players who like to micro-manage; people who would like to play the stock market but either can't or won't invest real money, and theorycrafters and those who go through great lengths to squeeze the utmost highest efficiency out of things. The browser-based version will be a largely a menu-driven game. Think EVE Online, without the pesky, tedious bother of actually having to look at your ships. Hyperspace Wars will be all menus and representative graphics for a pure space-accountant experience. :-P
OK so I have a pretty dumb question and I'm going to clamp down on you, because you happen to be the guy who merged the PR in the link. Please understand that this is not a rhetorical question: what is the use of this PSR? I mean, this is now under review and when it passes review then we'll all have an interface that describes a HTTP message, yes? Well, so what? I guess what I'm asking is, what will people be doing with this interface that makes a PSR a good thing to have? Like what will be the typical use cases for this interface, what will developers actually be doing with it?
There's a lot of people saying not to do it without a lot of evidence to back it up, but I've been running PHP on IIS for operational reasons and for the most part it hasn't been a problem. Aside from differences in setup and installation, the biggest change would probably be handling of permissions. You can't conveniently adjust permissions through ftp like you can in Linux, and if you need to utilize executables through exec or similar commands (such as say webkittopdf), you'll probably need to fight with it a bit to get it to play ball. Some libraries are not too happy to be running on a windows file system, but actual problems have been relatively scarce.
Wardrobe CMS 
Except how many startup projects actually think about this necessary refactoring until abysmal performance has raised its head and put the entire project at risk by being unable to release to a wide audience for even a beta launch?
An ORM is the best tool for the job in situations such as a back-end for business reporting, when you have many, many types of "entity" and they all have certain relationships, and an ORM just makes this a cinch to work with instead of having to write join after join after SELECT after sub-query etc. Also, you can write a PHP function that will convert an Array (even nested) to an Object (recursively) and this is something I use on legacy database code that spits out Arrays. (and Doctrine DBAL)
20 minutes?! Hopefully it was for a junior position! Sheesh!
the doctrine lifecycle events, to me in my experience, I've used primarily when needing to acquire extra associated data not present in the database. For example, on a site I built where I keep a regularly updated redis cache of YouTube API v3 acquired data (I specify this because the api operation by itself to get all useful data is incredibly "expensive" to your alloted api daily usage quota on a high traffic site), I use the Doctrine `@PostLoad` lifecycle event to automatically allow my entity on an individual level to fetch its youtube data separately from the cache. In this situation, it saves me from having to do a bunch of controller logic to post-process video entities to fetch and associate their youtube data 
While I dislike the declare syntax as much as the next guy, your proposals look NOTHING like PHP. They are overly complex and your proposal of "set php.strict_types" is just wrong and completely incoherent with PHP's structure. Surely you have a strong background in another programming language? use strict; would be ideal but as /u/ircmaxell said we'd lose fine-grained tuning in the future (although I'm not sure I agree with tunable type hinting/declaration either, it could become a mess rather quickly). I am STRONGLY against any engine setting regarding this. We had portability hell with many settings in the past (short open tags anyone?), it would be unwise to go that route again.
It's from the RFC: &lt;?php function add(int $a, int $b): int { return $a + $b; }
Think about how many functions, internal or otherwise, return NULL or FALSE... How would you do this with this RFC if there is no NULL? How would you handle empty parameter values that need to be NULL?
That's a fair point. I also don't like some of the code examples I've posted (specially the comment you're replying to, where I've stated your same feelings about complexity, and also the `set php.strict_types` you mention, but wanted to have it written so others could criticise it openly), but at the same time I think we should be open to other language's styles if they start making sense in PHP. I myself don't find `set strict_types = true;` too far off the PHP style, but that's just my opinion. I for example would oppose `use strict;` as we'd be doing magic here. It's a hack to help us solve a problem, and far off an ideal solution (again, in my opinion). I'd love to see how other languages solve similar issues. Ruby, Java, Python, Haskell, long etc. Can we learn something from them? 
Use a JSON Streamer, like https://github.com/fzaninotto/Streamer, and parse it bit by bit.
oh shit, i'm sorry! i'll post it there, thank you!
That wouldn't have worked in any case. `declare` is a compile-time construct, it is not affected by `if`s etc. Your code with the original implementation would have always enabled strict types, regardless of what value `$in_production` has.
[Github](https://pages.github.com/) * Self-hosted * Can use github itself as the CMS interface * All of your changes are version controlled (duh - it's Github) * Can give client access to the repository, and they really only need to know how to use Markdown to edit * Security is taken care of for you So if all you need is articles and things, that's the easiest way to go. If you need actual relational data structures for custom content types, then you'll likely need a more robust CMS.
ORM is useful when you have a lot of database tables with complex relationships. In this case, it will be hard without ORM as you have to write a lot of application code to handle domain model relations. With ORM, it can at least achieve a good separation of concern, while some ORM framework also uses code generation so you write fewer code as well.
It should be noted by anyone that hasn't read the *whole thread* that [Sara slightly mis-spoke](http://marc.info/?l=php-internals&amp;m=142436647205217&amp;w=4), and it was Franois that was rude, not Zeev, and [an apology for the wrong callout was made](http://marc.info/?l=php-internals&amp;m=142437656908754&amp;w=4).
It looks like they're putting the finishing touches on that one right now. [Here seems to be the current patch](https://github.com/php/php-src/pull/1095).
I wonder how this function will behave based on the php.ini config: function test() { $enabled = false; assert($enabled = true); return $enabled; } The RFC says that &gt; zend.assertions is a three way switch: &gt; &gt; * 1 - generate and execute code (development mode) &gt; * 0 - generate code and jump around at it at runtime &gt; * -1 - don't generate any code (zero-cost, production mode) so I think it will return ... zend.assertions is: 1 =&gt; true 0 =&gt; false ?? -1 =&gt; false 
Definitely agree with this. Totally low maintenance, no db, no security issues, still able to easily add content, get to write in markdown.
Can someone explain why I would do this: default: assert (false, "Unrecognized suit passed through switch: {$suit}"); Instead of just this? default: throw new Exception("Unrecognized suit passed through switch: {$suit}");
So, in the latter case, untyped arguments should be used if a proposal for a numeric type or union types does not pass.
This one looks like its passing, good news! 
I agree, the PHP world has a long way to go in terms of how it uses interfaces and using composability over inheritance. This is going to sound tacky but this is pretty much what made me start working on my own framework, so maybe you're interested. https://github.com/autarky/framework
Precisely. 
&gt;But is that not the point of LogicException? What? I *just* said you use assertions instead of exceptions because they can be disabled in production. Exceptions, including LogicExceptions, can't.
I like http://www.codeshare.io/ for super fast code share with syntax highlight. Nothing more than shared basic "notepad" window.
So basically assert( false ) is a way of halting the program when something is coded wrong (just like LogicException) but you want to be able to tell PHP "ignore this obviously broken code". Like in the case of the card suits. EDIT: I poked around on stackoverflow, found a decent post explaining the difference. Still not sure when I'll use assertions tbh, but good to know either way.
True, I personally think it's a little lighter :)
It's the best way to run PHP if you use Windows Authentication.
I expect this specification to have a bit more churn than say something like the PHP specification for the very reason you stated ... Hack is relatively new. That said, I believe the core Hack constructs are fairly-well baked (grammar for types, generics, etc.). We will be adding new features, fixing bugs which will reflect back into the Hack spec....but what I hope for the most is the community to help us with the process. That's a big reason for us to have a spec in the first place.
Assertions are a development tool to help determine the correctness of an algorithm. It's not the same as, nor is it intended to be the same as, the `@` operator (i.e. a global silence button for unhandled errors). If your code is reaching a path that fails an assertion, your code is wrong and it should've been fixed in development. Exceptions are a way to handle exceptional behavior gracefully at runtime. If you run into an exception at runtime, you can specify some part of your program to deal with the fallout of that without halting execution. This includes LogicExceptions: even though the docs say it's supposed to be for code that should not be reached, this is perfectly valid and will not halt your program's execution: try { throw new LogicException(); } catch (LogicException $e) { } Because assertions are a development tool, they can be disabled globally in production. Exceptions cannot have this switch because they are intended to handle actual runtime issues. If you've been using `LogicException` as a poor-man's assertion, then you will want to switch to assertions when PHP 7 comes out.
&gt; If you've been using LogicException as a poor-man's assertion, then you will want to switch to assertions when PHP 7 comes out. It would seem so. I use them like this: // Somewhere inside the routing code try { // Load the controller here } catch (LogicException $e) { if( DEBUG_MODE_ON ) { // Print the trace } else { // Should never get here in production, generic error page if so } }
Programming knowledge is mostly transferable between languages. The main differences would be the syntax and the domain the language is applied in. 
The goal of a university should be to teach programming. The language is just a tool. Whatever you learn in Java will carry over to PHP, just practice with PHP on the side.
I'm currently doing the reverse - learning Java when I already have years of PHP experience under my belt. I'm using `Thinking in Java`, and have basically flown through 250 pages because modern PHP is *so* similar to Java, other than a few syntax differences here and there. My suggestion would be to learn programming using Java. It is *not* on its way out - hell, all Android apps are written in Java! Learning programming using Java will introduce you to OOP concepts which will serve you well in the future and easily translate to PHP and other languages.
If you're going to university expecting to learn programming, you'll be disappointed. You're learning computer science, programming is mostly learnt at home ;) 
Don't bother taking Web Dev in college. It's a joke. Use free/affordable resources online (Udemy, Lynda, Codecademy, etc).
Thanks for posting. Will check sitesupra ) 
The problem is that you're trying to use DQL as SQL, it's not the same. DQL is object oriented whereas SQL is not. If you're using DQL then you need think "different" about how you retrieve and work with your data.
&gt; If we were to compare it to unit tests, wouldn't assert be a poor alternative? There's some overlap between assertions and unit tests, particularly when checking post-conditions (my example) but unit tests only text the external behavior of a function or method, not the internal state. With an assertion, you can also check the preconditions of a function: function foo($bar) { assert(is_int($bar) &amp;&amp; $bar !== 0); return 6 / $bar; } You could do the above with exceptions, but an assertion is more useful when you want to assert that the function will never receive a zero-value or a non-int. That is, it's not merely exceptional that `$bar` is zero (and something that some part of code code/should eventually handle), it should never happen. If the `assert()` fails in development, you know there's a problem with your calling code. Nb. strict scalar type hints are effectively pre-condition type assertions: if the RFC passes and you turn on strict-mode, you should be ensuring that no calling code passes a non-integer to `foo()`. But even then, an assertion lets you also ensure that `foo()` never receives a `0`. &gt; I mean, if you put the asserts in code branches, you wouldn't even notice the problem if execution takes a different path. With assertions, never reaching a path that fails an assertion is a good thing: if you reach that path, you know that somewhere, your code is wrong. It doesn't guarantee correctness, but it does glaringly point out (by halting execution) when you get it wrong. (edit was to expand on scalar type hints)
Ok, will take in consideration! Thank you
As others have said the language is not that important. What is important is that you learn the overall concepts of computer science. Once you learn the overall concepts you should be able to pick up most languages fairly easily. I learned Java at school and had no issue picking up PHP. I think having exposure to several different languages, will make you a better programmer in the long run. What gave you the idea that Java is on its way out? I don't think Java is going to be going away anytime soon.
&gt;unit tests only text the external behavior of a function or method, not the internal state. Correct, but if the unit behaves correctly, is the internal state relevant? Can't it be argued that if the unit operates according to specification, that its implementation (and by extension, its internal state) is necessarily correct? &gt;You could do the above with exceptions, but an assertion is more useful when you want to assert that the function will never receive a zero-value or a non-int. But according to the RFC, assert can be disabled via php.ini and should be disabled on production environments. The code should throw exceptions in this case. &gt;With assertions, never reaching a path that fails an assertion is a good thing I don't agree with this. There could be code branches that are valid, but not for all values. The implementation could be wrong, but you would never know it because the code hasn't been supplied with the values to trigger the incorrect state. 
I don't see the problem. Learning programming should not be specifically about any one language, it's a set of processes and concepts. The language is just the vehicle for expressing those things. A lot of the questions you're asking ( is Java important for programming databases? I always thought that Java was they way out?) aren't really all that relevant to the task at hand. Learn one language, and the next language you learn will almost certainly be easier to pick up than if you knew none to start. It could be argued that knowing Java will open a lot of other doors for you since it's not only capable of doing the tasks PHP is commonly used for, it's also used for many things PHP is not commonly used for such as mobile development (Android uses Java) and desktop GUI programming.
It's open source and I'm open to improvements and morphing the project into something new. Basic highlights: * Simple implementation on a LAMP server. * Easy to roll out and expand upon. * Flexible input of data (GET, POST, Request Body JSON). * Flexible output of data (HTML or JSON based on the URL file extension [.json/.html])
&gt; The code should throw exceptions in this case. If the function should never receive a zero or non-integer value, it shouldn't throw an exception. Exceptions are for when things *might* happen. It's the difference between: function foo(MyObject $bar) { } and: function foo($bar) { if (!($bar instanceof MyObject)) { throw new Exception; } } If I know (or want to ensure) my code will always receive a `MyObject` instance prior to runtime, the former is preferable than the latter. If `foo()` is ever called in a way that `$bar` is *not* an instance of `MyObject`, the calling code is wrong. `foo()` doesn't need to throw an exception (or keep assertions on in production) because it should never happen. Assertions work the same way, except they allow you to ensure conditions beyond types. &gt; There could be code branches that are valid, but not for all values. Right: but if somewhere there's code that's calling branches with values outside the expected range, assertions let you know about that. They are not there to guarantee all values are correct: they're there to let you know when you got it wrong: switch ($foo) { case 1: case 2: case 3: // do something break; default: // $foo should never be set to anything other // than 1, 2, or 3: some code that assigned a value to // $foo before this switch needs to be fixed. assert(false); } 
As I said, &gt; **Unless zend.assertions is 1**, then **the code in the assert will not be run**. So the implication is that if it's zero, the code does not run, and if it's -1 the code does not run.
Actually you could use assertions as a way to combine tests and your actual code if your code or a certain part of your code is written in a way that it's difficult to test separately for whatever reason.
&gt;It's derailed because you seem to have a problem with all the use cases in which assertions differ from unit tests. :P The problem is that I don't see any use cases. Also, see the above edit. &gt;I don't understand why you think asserting that a variable is a certain type is fundamentally different than any other check. I don't, but pulling types into this isn't adding to the discussion. It's not the case I'm talking about. 
But what happens at 2? :p
As I've explained multiple times in this thread, asserts have three main purposes: - checking preconditions - checking postconditions - checking invariance Unit tests only test postconditions. They do nothing for checking preconditions or invariance. *Exceptions* could be used to check preconditions and invariance, but assertions have the benefit of being able to be turned off in production. If you're dealing with situations when there is no chance of the exception being thrown once you've debugged everything and your code is now production, then all those exceptions and try-catch blocks are dead code. If you feel like your life is complete with just unit tests and exceptions, you will not benefit from assertions and that's fine. If you wanted to mix unit tests and assertions (using the former for checking postconditions and the latter for invariance and preconditions), that's fine too.
Be thankful you're seeing Java. My degree taught Eiffel, Prolog, C, Sparc ASM and Matlab. I was at least thankful that C was used in the real world. Computer science curriculums are heavily based around design patterns like strong OO principles, BCED segregation and model design. Although you can do these to an extent in PHP, it's not the strength of the language, and frankly, a few years ago, it wasn't a normal way to use PHP. These are all strengths of Java. "Programming databases" is done in pretty much any language.
Thanks for sharing! Will check it out on non-mobile tonight!
Hmm looks a bit too new yet. I'm hoping to get some decent community support/templates at least.
I'll just leave this here... Wordpress ^RUN ^AWAY! ^^RUN ^^AWAY!
Seriously though. Not wordpress.
Thanks for the feed back. I agree with many of your points. DB credentials should definitely be moved around, but these should be in a place that people can edit for their needs, so they need to be in the GIT repo somewhere. My example should use data from the DB as well. I was up too late to care when I made the example. I will fix this soon. My error handling is pretty bad. But this is left over from me just getting the auto loading to work and I can upgrade this ASAP. As for what sets this apart from other frameworks is the simplicity of use and set up. I have tried third party frameworks for MVC be for in PHP and found them infuriating to setup properly with the server. This is a pretty basic setup, just enable HTACCESS files to work in Apache and your off. While this won't be something you build the next Facebook on, it can get small simple projects actually working in a few hours. That is what I wanted out of it. Of course I will continue to evolve this project and welcome contributions from others! Thanks for your time on the criticism!
Thank you all for your feedback. I really appreciate it. After in depth analysis, I realize that I have many slow queries that could be greatly optimized. I will definitely start caching the bigger requests and maybe implement an optional $deep parameter for the occasional cases where I need the full data. My main concern was the size of the response. I thought a 200kb-500kb JSON response was too big, but in the end it appears that it's fairly common. I'm already using gzip/deflate and I'll definitely take a look at JMS Serializer. I always strive for the best performance so if I can improve the serialization/deserialization speed even just a bit I will most certainly use it. Thank you all.
If you became proficient in Java, you could probably pick up PHP in less than a week during the summer. In fact, when you graduate, you'll probably know a number of languages, or at least familiar with a number of them. Actually, if all you want to do is PHP development, you really do not need to go to college at all, and I'm sure most people here would agree.
When you need to do that, you should drop down to SQL and either use a result set mapper to map it to an entity or live with values straight out of the database. There is nothing wrong or bad about this approach. There's always this expectation that ORM's replace your database layer entirely; they do not. They complement it by modeling your data and providing a more programmer friendly interface to it. When the priority is convenient access to data (most of the time), I use an ORM. When the priority is performance, or the data I'm looking for is particularly tricky to get at, I grab my database adapter and get at it with good old fashioned SQL. I'm not worse off for having an ORM, it accelerates the pace that I write code. Almost all ORM griping (particularly with Doctrine) that I have ever seen basically amounts to lack of understanding the library or the concept of an ORM. 
I didnt only done all the time php. Ive learned Java and C# aswell. :) Ill take a look on the coden conventions :)
As this is a library, why not have your construct function on the DAO class accept arguments required to establish the database connection? This would allow users to pass that info when they activate the class and it's stored for the rest of that object's life. Just a quick thought. But good job on contributing to the community! I've been wanting to do that myself and just can't seem to find the time to clean up my personal libraries for publication.
I like the idea of having the ability to define object comparisons, but I'm not sure this RFC is the way to go. 1. Could be I'm just not getting it, but I'm not seeing how this compareTo() method understand I'm wanting to compare less than or greater than. Seems like a second argument would be required to define what kind of comparison is happening. 2. I don't think an interface is the proper way to implement something like this. This is looking like something for a magic method like what Python did. I would just take the approach of having a comparison type being passed in as a 2nd argument rather than having different methods for every kind of comparison. If this was done with a magic method, then you could type hint the first argument rather than manually checking as in the example. Having type hinting there would also help with IDE syntax checking. Anyhow, just a few thoughts off the top of my head. Again, I like the idea of having a comparison. Best of luck with this.
I was just diving into the Hack docs the other day. Maybe someone can answer some questions I had... * Why no "continue" or "break" support in the language? * Is it that they are supported, but just not with the level? * Who not support calling a parent static method? Honestly, I don't mean to be trolling here. I did some looking around for the justification for those decisions and I couldn't find anything. I'd love to hear the reasoning. BTW, Hack looks pretty darn cool as a language. Looking forward to see what the future holds for it.
The RFC should probably explicitly state what the compareTo is supposed to return, but judging by the code it works the same way usort and everything else does. I think Interfaces are absolutely perfect for this. Magic methods reek of working around the built in language constructs - when what this really is is an interface (and I believe Java implements them like that)
Can you host more than one site with a single account on github pages?
If there is a language there is likely going to be a codebase somewhere to work on. I have worked at several places with a PHP code base, some large and some small. I've been hired as a Java developer, a C# developer, etc, but only once as a PHP developer. 
You can learn the language with not going to school - but picking up how to write good PHP will be a bit more difficult if you are self taught.
Screw the web platform installer in the ear. I have tried to use it on at least 5 different occasions and every time I have felt the need to roll back my machine. It inevitably either installs dependencies you do not want/need or it installs outdated versions of software. edit - I suppose it is okay for setting up a quick test on a throw away vm but I would never use nor recommend anyone use it for a production site.
Drupal 7. If you don't understand the front end vs backend you should learn it.
http://www.teamviewer.com/
Try this. $obj = $statement-&gt;fetchALL(PDO::FETCH_CLASS|PDO::FETCH_PROPS_LATE, 'CLASSNAME', $params); This will pass the results into you object constructor as a numeric array. In your constructor you must name the argument the same as the 3rd argument in the fetchAll method above. So your constructor should look like this: public function __construct($params) { $this-&gt;property = $params[0] } EDIT: sorry not a numeric array. Associative array with column name as index. 
I am currently running a production Drupal site on IIS + MS SQL Server. It is doable and can even provide acceptable performance but I really wish I was on Linux. Every damn issue I have to deal with is off the beaten path and 10x tougher to find solutions for. For my own apps written from scratch it is fine, I would even say in some ways I prefer it to apache+mod_php (but not nginx or fpm). It is extremely annoying that all of the built in php functions that deal with paths use the host operating systems directory separator. This is only mildly annoying if the open source components you use have taken the time to account for it but if they dodn't it is a friggen nightmare of tracking down includes that look like: include '\sites\somedocumentroot' . '/inc/somefile.php';
I dove headfirst into Drupal thinking I could just learn as I went, and I found it getting in the way more than being helpful. I have since switched to Bolt and it feels much simpler and easy to use for me. 
There's no reason to prefer an assert in that example since that case is *only* executed when the program is incorrect. So that would be exceptional behavior. The best case for the RFC assertions is pre/post-conditions on functions where there is an execution cost every time the function it called. 
That's what I figured. I assume Joomla just had more traction earlier but is dying out. The stat isn't wrong though - it does currently have nearly 2x the market share.
why snake_case naming conventions for classes and namespaces?
I know this is the PHP sub, but Express, a node.js framework is awesome for stuff like this. 
Java is certainly not on its way out. You don't see it a lot at the startup and freelance level, but it's huge in big enterprise. From a university standpoint, Java does a great job of fitting the curriculum you'd see in computer science. A university program isn't there to reach you a programming language. It's too teach you the concepts of computer science, so they choose a language that for that goal. To be honest, I wouldn't trust a program that uses PHP as their primary language for a computer science program.
Either way is kinda meaningless. How the hell can you tell I use drupal as a back end if I roll my own front end. There's a lot of crap metrics out there. Be warned.
"To be honest, I wouldn't trust a program that uses PHP as their primary language for a computer science program." No, I wouldn't accept that because it's based on the nature of papers that students choose. If they choose AI or Systems programming, they would be given C++ or Java as their programming language. In case they choose web development or Internet programming, they give you PHP or ASP. Trust me; I chose Internet programming and I was taught both about PHP and ASP with some books to learn them.
You should check out http://getgrav.org/
Can someone TL:DR it?
I think that's the plan. The only thing that looked a little annoying was that configuring categories/etc was all through editing YAML files instead of with an admin interface.
It was proposed before and declined, I think PHP is fine without it anyway. https://wiki.php.net/rfc/annotations
Can we get an Equals interface too when we're at it?
You should do that. I've gone ahead and I've taken the liberty of writing the first draft for you. RFC PHP: Annotations ==================== Version: 0.1 Date: 2015-02-20 Author: Bob den Otter (bob@bolt.cm) Introduction ------------ Annotations basically let you inject behavior and can promote decoupling. One example would be the Doctrine ORM. Because of the use of annotations you do not have to inherit from a Doctrine-specific class unlike the Propel ORM. Using Annotations in PHP ------------------------ Please don't. Just NO. Really pretty please with a cherry on top, do not do this. Comments **ARE NOT CODE**. Code comments should never have an effect on application functionality or flow. Further reading: - http://theunraveler.com/blog/2012/php-annotations-are-a-horrible-idea/ - https://r.je/php-annotations-are-an-abomination.html **Edit:** Ah, I get it. Having annotations as "not comments" would make immediately make this a much less bad idea.
In php's current form, yes. Several other languages have Annotations, and they are in fact, not in comments.
It never made it to a vote? :/
Indeed. Attributes in C# are really useful and I'd very much like to see an implementation in PHP. 
In such case (comment annotations, 'PHP's current form of implementation'), no. I would not want this to be a thing in any way, shape, or form. Edit: I don't think we should put logic into comments. That violates what comments are.
hang on wait.. you don't want annotations in any way shape or form because they wont be implemented in comments? Most people who are staunchly against "docblocks as annotations" have no problem with first class annotation support. They are insanely useful things to have.
I can see them being useful as an event trigger, but I fear their implementation (or usage) would be analogous to method-level traits and tight behavior coupling.
I do not want logic in comments, therefore I do not want annotations to be a thing in PHP as they are 'exist' currently.
I'm all for putting information in comments, that's cool. I'm not for using comments as a mean to alter behavior of a class/function/et all.
You have to have contributed to the PHP project in some way, meaning anything from having commit rights to php-src to editing documentation.
The thing is, with PHP you cannot really do this in real time, users have to update their page manually(or you doing a refresh script that refreshes after amount of seconds) for new content to appear. So PHP is not really optimal for multiplayer games.
This is what native annotations look like in Java: public class MyClass { @MyAnnotation("foo") public void myFunction() { // ... } } and C#: public class MyClass { [MyAnnotation("foo")] public void myFunction() { // ... } } If PHP were to implement annotations it would be similar - no comments involved.
First class annotations wouldn't be in comments. And for what it's worth, even though annotations (as they currently exist) can impact program flow with a comment, or attach some behaviour via a comment, they are logicless. The logic goes inside an annotation class. 
 at least in germany you wont find university that "focus" on an actual programming language, you will have some language specific courses that you can opt-in ... but in the end you're supposed to learn how to code, and not how to learn to code in XX ... in germany though, you can make an apprenticeship in a company that focus on php, of course you dont have a diploma in the end cause you then usually dont learn the gist of how to learn any program language, algorhythms etc. so if you really just want to work with php/mysql consider NOT going to an university ~ but honestly, if you wanna be a good php-senior at some point in your career its better if you didnt start off with "just php"
Being fearful of how a language feature might be used is not a rational reason to not have the feature in the language. That way madness lies...
cool! tkx for taking the time to give me this food for thought!!
For more about using generators for multi threading, read nikic's excellent post [Cooperative multitasking using coroutines](https://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html) (this is the kind of post you should read 3 times).
Dear god. I realize this is a joke, but all jokes have some basis in reality.
&gt; Can we get an Equals interface too when we're at it? Isn't that just a special case of Comparable?
Could you provide an example of the flow you expect? I have something in mind but it might not be what you're looking for.
yes please!
A change that reverses BC breaks. Not every day you see that.
There were a bunch of people opposing the proposed implementation: there were some people who argued that we don't need annotations others that it should use the docblock syntax, others argued that the proposed syntax in the blocks are too complex and alien to the current php syntax. The author did a good job explaining why dockblocks and annotations are differrent and should be kept as such (tl;dr your could should be working when docblocks are stripped, they only convey info to the devs). Then he tried to win over some votes via compromizing into using docblocks for annotations ( https://wiki.php.net/rfc/annotations-in-docblock) but that couldn't get reasonable support from the list either, and the author abandoned the rfc as he felt that core devs kept moving the goalpost and it is a futile to try to push the idea. At least this is what I remember.
I think the title does that
It's a part of this interface only, var_dump($c == $b); // prints bool(true), since it's within the tolerance from the RFC.
This. Though "based on C" is not true - internally, they're quite different - "use a similar syntax, derived from C" maybe
Some things might not have a "larger" or "before" relationship to another, but it might be nice to check if two instances are equal or same.
Yes, it could be used for it. But it would be nice to have equality as a standalone implementation option.
Absolutely, this is near the top of my wishlist for PHP actually. Especially when it would help us get rid of the current ones in comments, while preserving all the useful stuff they provide. I fear a big hurdle will be that, while almost everyone wants SOME kind of annotations, people tend to disagree on what their contents should be represented as (i.e. what will I get back when I call $reflectionClass-&gt;getAnnotations()). I would be fine with a simple set of key-value pairs where key is the name of the annotation (could possibly refer to a class name to allow namespacing and importing with the "use" statement) and value is any PHP scalar or an array (which again can contain any scalars or arrays).
Of course I see it, Infy doesn't have proper response handling for example.
You can actually do all of that today, via the abuse of __get(), __call() etc
Honestly I like the original proposal better, which actually defines a specific syntax for annotation that is easy to follow. Docblocks are supposed to be used as comments, I dont like annotations in Docblocks, which is why I refrain myself from using Symfony Routng and Doctrine Mapping. Using annotation in the place of comments is a big no-no, a big rule of thumb is that changing comments should never break your application. Otherwise, your application is essentially non-reusable. This author provided some interesting reasons as opposition to annotation, and read his first argument for reference(I admit the other reasons are arguable, but the first one I totally agree): https://r.je/php-annotations-are-an-abomination.html
I knew someone would pull me up on that. Derived from C then.
The main reasoning for using YML is that it's really just plain text. It's legible, and it's easy to put into your versioning system as well. We hear this often, that people are initially reluctant to get into YML, but after a short while they really like it. "I never want to configure a site using clunky checkboxes again", etc. 
While I agree many of your points, I was trying to avoid stating my matter of preference and only present the history of that rfc.
I can't count the number of times I have run into issues with naming collision. I really hope this gets through. 
We've already seen two RFCs for annotations, both by Guilherme Blanco. [The first one,](https://wiki.php.net/rfc/annotations) which had a native syntax (like Java, C#) was awesome, and was declined. [The second one](https://wiki.php.net/rfc/annotations-in-docblock), which proposed native methods for comment annotation retrieval is currently "*inactive*".
See this: http://www.reddit.com/r/PHP/comments/1ztstd/rant_it_baffles_me_that_people_think_using/
If a class implements Comparable and doesn't support comparing, doesn't that defeat the purpose of the interface? I would expect an instance of Comparable to be sortable. Couldn't we try to make it nice instead? For reference: http://stackoverflow.com/questions/6970879/java-lang-comparable-and-equals
Agreed, however I think java also gives you more solid foundations of programming. Java was my first language and for the past 6 years I have been programming in PHP. During my time I have seen alot of lower - mid weight self taught PHP devs don't have the core concepts and considations like how data is stored in memory and how to efficiently use/pass it. I think part of it is because PHP is loose by comparison, modern application of PHP is changing that but it's still the developers choice at the end of the day. 
&gt; But they almost exclusively focuses on Java, so i was abit suprised by that. Small anecdote: I was ending my second year of undergrad CS when the Java wave hit (which was part of the whole Sun PR blitz going on at the time). Practically overnight, everything switched from a C/C++ focus to Java and new Sun workstations/servers/products appeared all over the place. Subsequently, this ignited a massive debate on how incoming students wouldn't be able to learn good programming skills and techniques because of how much hand holding Java did for you (e.g. memory mgmt, gc, etc) and how no one would use Java for any kind of serious development (the JVM was looked at as a toy). Fast foward many years later, and you have a constant stream of newly minted Java devs being pumped out of unis left and right, who mostly all ended up with enterprise careers. What language and toolset did they bring with them? Java of course. 
Or rather, adhere to SRP and have a connection class? That way you could manage one connection across all of your DAOs, or give different DAOs different connections where necessary.
What language to learn first is not important, because your second language will need much less effort. When you learn java you will learn java and how to program, how to program is what you really need.. not the java part. Choosing Java or Python or something like C# or PHP depend on the culture of the place. A more scientific place will love Python, but other places have other interest. A "me too" university will just teach java because thats what apparently everyone else is doing. I think there are two type of programmer teachers, these that teach you a language to do something (so they teach you python because thats what the grid computing use, or their bioengineers need), the other type of theacher teach you a language because is the easier language to teach people. Java is not exactly the better language to teach people, but theres no language that fullfill this role, so people default to java. 
I said 'hopefully', and again you dont have to be a dickhead. I wasnt asking your opinion, you can go and chill.
That, and magic methods are horribly slow compared to proper methods.
That link mentions nothing about PHP...
that is more of an implemented feature request (should be mentioned as such in the Changelog), and requires adding JSON_PRESERVE_ZERO_FRACTION to your json_encode call to get the new behavior. but agree, good to have it merged after all that bikeshedding.
looks interesting - one thing, not sure your `.idea` folder should be in git.
Architecturally, you should consider breaking up the single class by responsibility. Maybe a Value object to represent an ISBN number, another class for validation, and another for formatting output. 
Yeah, I have .idea/ in .gitignore, but it's still there... hm. I guess I should remove .idea/ from .gitignore, remove .idea/, push, add .idea/ to .gitignore again. Alright, that worked. I guess there is a better way? Thanks!
Thanks for input. The validation and formatting is specific to ISBNs... what would be the benefit of breaking it up?
Of course not! But using comparable as equals is in my eyes worse then having two interfaces slightly overlapping.
Seems like a very java-inspired approach to PHP: servlets, beans, persistence container.
I found it easier for URL to Class Name conversion. I wanted a URL of '/mvc/controller/action.html' to import the controller_controller class in controller_controller.php. Using snake case lets me just append _controller.php and keep the class names the same as the file names instead of having to capitalize the first letter or force URLs to be cased. It's a small thing that is easily programmed around, but I was in a rush to get this working for a side project and then decided I should use it as a base for more projects.
For what you're describing, I agree. You're describing particular disciplines (or more specifically, what are usually certificate or associate degrees). A bachelor's degree in computer science isn't going to focus on any one of those and instead teaches concepts. Sure, there may be some specific courses that a student can elect to take that may focus on one of those in which case you'd use a different programming language for that course, but not likely for the entire degree program.
I would use getters instead of exposing the fields directly (and -&gt;isValid() for -&gt;valid), leaves you room for refactoring without causing breaking changes. The base class I would have located at \Agnarodegard\Isbn without that additional namespace layer before. Also I'd use uppercase since it's an initialism. Quick tip, you can run the unit test with php vendor/.bin/phpunit and you can leave it as just "phpunit" in your README since you generally go by the assumption that they have it installed globally locally (an unwritten convention). They will know either way how to run the tests. The fancy buttons need integration, for unit tests you would configure travis (I see a travis.yml file but maybe you didn't setup it on their website) and they will provide you the README embedding code. The same goes for the other buttons.
I wonder if this think is such a good idea. With current versions of PHP you are simply not able to gracefully handle fatal errors. So one such error happens, the whole appserver is gone. But I can also see the advantage of having persistent data without the need for serialize/unserialize.
The rfc is for OOP context only.. So the -&gt; before is a dead giveaway of the context. There is no implicit self/this in php like in Java iirc. Context is important, just like the 'use' keyword.. Means different thing when in OOP context ( use namespace vs use trait ) And it really doesn't take any effort to sort out the context if you are actually reading the code.. 
I would probably not take an AI course unless the primary language used was Prolog
This approach is generally discouraged these days. Your URLs should not influence the naming of controllers or methods. Check out Symfony's Routing component http://symfony.com/doc/current/book/routing.html
Ajax anyone? On any given action, or on a timer, you can send and recieve information asynchronously with a php script. Use a game ID, for instance, to store "global" information between all players and use AJAX to communicate changes. Not exactly practical for live updates, but it should work fine for text based where a few seconds lag can be handled. Also check out node.js. Its not PHP, but it's a web based language that is very promising for building server side clients for multiplayer games.
what about through a chat room? Chatrooms in PHP dont have the page refreshed manually . Would it be possible to have some users in the chat receive automatic messages in the chatroom area thats only visible to some but not others?
Ordering, which is really what `Comparable` is, and equality are completely orthogonal concepts. The fact that both operations involve comparisons is irrelevant.
It's also not very ergonomic to try to work around it.
This seems more appropriate for FIG. I don't mind `Comparable` as an interface but the larger PHP community is not ready for operator overloading, and if it were, comparison operators have too much complexity as is. By all means, proceed; but take it out of core.
You can also use `git rm --cached` that will only remove it from the git repository, leaving the folder on your filesystem.
It appears I am against the grain on this one; I don't want "real structure for annotations" in PHP. Here's one example from someone else that illustrates what does happen with annotations in Java: http://www.beabetterdeveloper.com/2013/12/an-annotation-nightmare.html
I feel like I was just hit with a giant rock of wisdom. I am coming from an academic background, and what you've described is essentially the coding equivalent of an outline for a research paper. I am a beginner, and this method is a fantastic shortcut to better coding--at least for me as I try to think about the "grammar" of code. Thank you! 
i had the same argument when i was using java. annotations are meant to provide meta data, not the raw functionality.
&gt; Ajax anyone? &gt; On any given action, or on a timer, you can send and recieve information asynchronously with a php script. This is exactly what I need. Ajax combined with PHP allows this? Do you happen to know any useful tutorials for Ajax turn based text based games lol?
Ahh those templates. Already changed all of them and removed this noise ;)
Serious question - why does this need to be supported in the language? The same thing can be achieved by using static functions: class PostController extends Controller { static function getRouteMetaData() { return Route('/post'); } static function getForUserMetaData() { return Route('/user', 'GET', '/^d+/'); } public function getForUser(int id): Response { //... } } Yes, it's a little uglier - but it's way easier to debug as you can put breakpoints on the line where the metadata is returned. Why does having a system in place for metadata need to be embedded in the language? 
Could you specify: are you against the feature being introduced, or are you simply not interested in the feature being introduced?
Yet, we added `goto` Just because a tool is added to PHP, doesn't mean its going to be used poorly, and it doesn't mean you have to use it either. --- **edit**: Also, as /u/lordofworms said &gt; Being fearful of how a language feature might be used is not a rational reason to not have the feature in the language. That way madness lies...
&gt; which is why I refrain myself from using Symfony Routing and Doctrine Mapping I hope you just mean the annotation parts of those two
That looks way to ugly to me. And I'm not sure i would ever want a breakpoint on the metadata line. This would open the door to doing logic inside those functions, and that just doesn't seem right
Yeah, I would agree that this isn't a "framework". It is more like a boilerplate of code to build upon. Your comment of only taking 10 minutes to have a "deep" understanding is exactly what I wanted. Something that has a very low entry point to accomplish a simple API. While these other frameworks offer a ton of extra features and bell and whistles, my project (at this time) doesn't require most of them. Using something so large seems like overkill; like using a flamethrower to light a candle. Yeah it works, and works very well 100% of the time, but that is too much overhead to accomplish the task. You end up trying to setup and use a framework the correct way and adhere to all of these rules and standards that they bring with them, when what you really want to be doing is solving the problem of not having an API and getting one done now.
This is not true. In most languages reserved keywords are really reserved. In language design being context-free or requiring limited lookahead is considered a positive trait, not a negative one. E.g. C++ is widely ridiculed for practically requiring a fully compiler implementation just to parse a file.
Personally, I really like [this one](http://extensions.bolt.cm/view/a0f0191b-9dcb-11e4-a99b-c5c5895e3a0c)
Allowing `self`, `static`, and `parent` would allow for unclear behavior, such as: $instance1 = new self(); $instance2 = new static(); $instance3 = new parent(); self::methodCall1(); static::methodCall2(); parent::methodCall3(); Allowing `array` and `callable` would allow for unclear behavior in type hints, such as: // type-hints (array, callable) function (callable $callable, array $array) { return $callable($array); } Allowing namspace would allow for unclear behavior with the [namespace "constant"](http://php.net/manual/en/language.namespaces.nsconstants.php), such as: $value1 = namespace\SOME_CONTANT; $value2 = namespace\function_in_current_namespace() $value3 = new namespace\ClassInCurrentNamespace();; $value4 = namespace\ClassInCurrentNamespace::staticMethod();
To put it simply, these are situations where the meaning cannot be determined by the context. You wouldn't be able to tell the difference between a class called 'array' and the type 'array'.
And just generally troublesome when you are trying to create a clear API for your class. 
Why is it discouraged? Is it just because everything else is going that way? Or is there a security/performance benefit from it? Because if there isn't I don't see why you'd want to adhere to something that slows down your API by adding in a step to morph URL string parts into standards conforming class names.
One question about your post (I havent checked the source yet) You wrote your a seasoned Drupal Developer who's written large applications with it ..but this is your first time writing OO? Everything Drupal (from what I've used) has been OO to me..
I just started using it myself. I don't have it in production for anything important (test only) but I did migrate to HHVM from php56-php-fpm in my home lab. The only issues I ran into were with my AES class (hhvm didn't support mhash(); just needed to change my mhash() call to hash()), and ioncube did not work at all. Other than that, it's been a painless migration so far. For a website framework I'd been developing over the last 7 years, it dropped my script runtime from ~7ms per request to ~3ms per request which was cool. I've been documenting my config on my [github project](https://github.com/MMDeveloper/Sysadmin-Notes/tree/master/Linux/Webservers/HHVM/CentOS%207)
&gt; Isn't that just a special case of Comparable? Indeed: on a technical level, it is. PHP doesn't have a separate equality function internally that's distinct from comparisons. Implementing an Equatable interface or similar would require deeper engine changes to make it really useful (yes, you could implement it now by returning -1 or 1 if equalsTo() was false, but then you're implying an ordering that doesn't exist), and that's not something I want to tackle for 7.0.
but if a language feature is being abused or used wrongly, it doesn't necessarily mean the feature is bad or shouldn't exist, right? same way how cars are not banned eventhough bank robbers use them to get away?
Ah cheers for this
I'd suggest using `Mixin`.
It's very easy to miss the minutiae when you're focusing on the big details. ;) Hoping it passes! :D
I'm guessing a combination of a big dev team and deployment of many small, incremental changes. Release early, release often.
&gt; slows down your API by adding in a step to morph URL string parts into standards conforming class names. This task will NEVER be a performance issue.
Wow, thanks for an awesome review! It'll take some time to absorb everything you've written. I'll be busy all weekend writing code, yay. (not sarcasm)
Thank you very much. I'm learning lots.
Thanks! I felt pretty good until I read some posts here, hehe. Nah, I'm good. I'll take your suggestions in to consideration.
1998-2002 Comp Sci BS. We used C like real men. CS1/CS2, Datastructures, Algorithms, Numerical Analysis, etc. .... all done in C/C++. :P
I'm not unfamiliar with xpath, but I prefer straight up arrays (I'm a Drupal-guy). I'll implement the XML-way and see where it brings me. Also, your comment on exceptions in constructors in libraries... I think this is important, but I don't really understand. The concept of throwing exceptions feels strange over all, but that just means I haven't understood it yet. One thing I'm struggling with is a function that checks, say, type of ISBN and will return 'ISBN10' or 'ISBN13'. But what if the input is "illegal" and it's neither of them? Is it ok to return false? Is this where exceptions play their role?
Drupal up and including 7 is procedural, but uses some OO concepts without being true OO. It's true that there is some OO code in D7, and I use it, but that's different from "inventing" it. Drupal 8 is pretty much all OO I think, and this is partly my motivation for learning more about OO outside of Drupal. I don't want to get stuck on an island.
Reminds me of a trick I learned today: you want to add a folder to a Git repo but .gitignore the contents? Here's the best way to do this. 1. Create the folder if it has not been created 2. Add a file called .gitkeep, it doesn't have to be called that but it's the convention to call it .gitkeep. 3. `git add` the .gitkeep file (stage it for commit) 4. Add the folder to your .gitignore file 5. `git add` the .gitignore file 6. Commit. You now have a folder in your Git repo whose contents are ignored, but the .gitkeep file means someone who clones the repository will get the folder. If you'd gitignored the whole folder and hadn't done the gitkeep trick, then the folder would not be present upon cloning because Git does not track empty directories. Note that if there are files in there that you DO want to keep, such as a .htaccess file or something, just do this trick with those files instead of the .gitkeep file.
Interesting, but I don't see where this would be useful. Perhaps for unfinished projects where you start with a file structure you intend to build out eventually?
I agree. If it's not checking whether the type is array, then it's not fully strict so that's just confusing. Otherwise I definitely love the idea.
I agree with Nicoon. It should be compatible with set-theory... specifically: https://en.wikipedia.org/wiki/Element_(mathematics) For example consider the set B = {1, 2, {3, 4}}. The elements of B are not 1, 2, 3, and 4. Rather, there are only three elements of B, namely the numbers 1 and 2, and the set {3, 4}.
And segmented, start with 10% 
because when everyone is using the same conventions it's easier to read source code of others. I wouldn't touch your framework just for this reason. I don't wanna have mixed coding styles in my projects (at least when they differ at such a big level). The general consent in PHP is http://www.php-fig.org/psr/psr-1/
I'm inclined to agree. Making the behavior different from in_array would just lead to another situation where two things look similar but work very differently. PHP has enough of those as is. It also completely alters the meaning when you check for an array instead of any other type. I can see this leading to potential vulnerabilities if either of the operands are controlled by direct user input, since PHP lets any user turn GET/POST data into an array by simply adding `[]` to the name (admittedly the code would have to be fairly poor, but I don't believe that adding another newbie trap/gotcha is a good thing).
Ok, so make them properties... class Post extends Model { public $belongsTo = ['User', 'userId']; public $hasMany = ['Tag', 'postId', 'tagId']; } The point still remains - that particular application of annotations is not doing anything the language doesn't allow for already.
I actually got rid of this in my templates :)
You should actually add that to your global gitignore. 
&gt; `git rm -r --cached` FTFY, its a folder
PHP has mixed coding standards through out itself. Trying to force these on top is like carpeting over a floor that still has trash laying on it. As a programmer you are still going to have to know that it is "is_file()" and "isset()". If you use a modern IDE like PHPStorm the autocomplete and features built into it help keep you from calling "MyFunction()" when you mean to call "my_function()". If there is a performance or security advantage, I'm all for it, but so far I'm not seeing that as your argument.
Ah, good point.
We do this exact thing in Titon :D https://github.com/titon/framework/blob/master/src/Titon/Route/Annotation/Route.hh
Hey! [This article](http://www.infoq.com/news/2014/03/etsy-deploy-50-times-a-day) describes our deploy process fairly well. Let me know if you have any questions!
Ok, so then why not make EVERYTHING annotations and have no properties or methods? Im failing to see the logical distinction between declaring code with an annotation vs normal PHP. It sounds like nothing more than an alternative syntax like `array()` vs `[]`, which isn't bad per-se, but there's no functional difference between them in that case. What SHOULD annotations do that normal code can't or shouldn't do, beyond the syntactic preference equivalent of `array()` vs `[]`?
One suggestion would be to disallow $isbn to be nullable in the Isbn::__construct method since it results in an exception. Why not let PHP handle this for you? When providing library code for consumption you should also always declare your own base Exception class and always throw a subclass of that. This will allow consumers of your code to catch only IsbnException extepsions instead of having to catch \Exception
So you are just stuck in your ways as much as I am. :) There is no reason you can't have: // File: auth_user.php class auth_user extends base_model Consistency does matter.
That's awesome! Thanks for noticing :D
It's discouraged because your class structure becomes tightly-coupled to your URL structure, which forces you to compromise one or both because your URLs might look very different from the logical organization of your controllers. For example, if you wanted to add a new API version with minor changes, you would have to create an class for **every** controller in the `v2` namespace, regardless of whether the functionality was any different.
Thank you, I will take a look at them :-)
You're probably not going to find any of these that are popular / widely used, because they have very limited (no?) usefulness. They're far too slow for use as large data storage, and for smaller amounts of data you don't need the overhead of the manager (just store a flat file). 
Well, you don't need to use annotations for either of those. So i hope thats not why lol
I like this, but I would really like for this to be extended to other types. for example: "foo" in "foobar". Additionally, i'd like to see the inverse "not in" made available. In a completely unrelated note (since it seems like wish fulfillment week), I will *rejoice* if we ever get string and array operations in the $foo[1:3] (return array of 3 elements from position 1) style.
Curious why do you guys use IRC over a persistent chat like HipChat/Slack along with their native apps? Don't get me wrong, I freaking _love_ IRC ( ah the days of setting up scrims in q1 clan arena) but lack of persistence sucks for business. So now I think you must have a solution for that
Yes, and you fail to see that you're not on the same page as the vast majority of all the other PHP developers. But that's your problem. I don't know what else to tell you.
Thanks for share!
Object relational structure is not what I would call metadata.
I dont know if `not` is worth the cost of having another reserved word, when you can just do `! ($foo in $bar)`.
The child is already coupled to the parent via inheritance. I suppose the only time this would be an issue is if the inheritance chain changes.
Alternatively, he can also declare an exception interface and have one or more exceptions implement it. This provides a bit more freedom since you can extend `LogicException`, `InvalidArgumentException`, etc and not just a generic exception class.
Fixed. For those wondering, I originally wrote "it can't count..."
If you want to live on the edge you can try my project: http://stairtower.cundd.net
We had a API service at work that was originally written in Doctrine and we moved it to straight PDO and the performance was so much better. It wasn't an overly complicated system and not many joins but was nice to be able to take what was there and remake it knowing that it was going to be faster and functionally identical.
That's a good question! I think the answer is momentum. We've been using IRC for a long time. Over the years we've built a lot of internal tools to adopt IRC to our company. IRC is core to our deployment process with [pushbot](https://github.com/etsy/PushBot). Certain channels are logged and you can use a webapp to search them. We also maintain an internal fork of the [Subway IRC](https://github.com/thedjpetersen/subway) client that integrates with out staff directory and IRC search tools. It acts as a bouncer for all of its users internally, giving them the effect of persistent chat.
The RFC says you can do if (!$var in $arr) Although that doesn't look right... maybe it's a mistake.
Yes. PHP or Ajax sends text from a database to users. There will be two group of users , say A and B, I want the words being pushed onto the screen or in a chat box to be different, whether the ip of the users are part of group A or B. 
Same. I don't believe he mentioned language feature pegging to the PHP versions, though?
https://github.com/kmfk/slowdb
What do you mean by language feature pegging in this case?
Knowing which PHP version maps to which version of HHVM, etc. Good talk today btw, was definitely one of the better ones.
&gt; That looks way to ugly to me. I agree - but adding a feature to a language just to avoid typing a few more characters is not a good arguments. &gt; This would open the door to doing logic inside those functions, You mean it would be even more powerful, and users would be able to enhance it in userland, rather than having to add features into the core of the language? AWESOME!!1!
That section says that "in" should have the same precedence as "instanceof" for this reason. "instanceof" has a higher precedence than "!", so I think it does work that way, though I've always used parentheses anyway for clarity. As in `if (!($var in $arr))`.
I'd only recommend this if your library throws exceptions specific to it. There's no reason why you can't use SPL exceptions and similar in a package.
I can't imagine that would be easy to implement, if even possible.
I think negating is more readable, because it's the very first thing in the expression. I know immediately that I'm looking for a negation/inverse.
&gt; I agree - but adding a feature to a language just to avoid typing a few more characters is not a good arguments. Definitely not the only reason, and also, ugly != more characters. &gt; You mean it would be even more powerful, and users would be able to enhance it in userland, rather than having to add features into the core of the language? AWESOME!!1! That would be bad. Tantamount to doing logic in the view. Not where it belongs.
seconded.
and is sufficient for many projects. i think their docs mention sites with half a million hits a day swimming along with no problem.
You could just put a `.gitignore` in the folder in question, containing * !.gitignore
It listed an extraordinary amount of things that had to be upgraded on CentOS 6. Does this mean they had to run a yum upgrade, or.... I'm shuddering at the thought of trying to build the latest gcc, libc etc on CentOS from source and trying to maintain it. Sounds like it'd be easier to move to a more bleeding edge platform. 
I started in x86 Assembly, Fortran, ADA and Pascal. All things that would look silly on a resume now, but that doesn't mean I wasn't able to switch to PHP/Python/Java/JS and keep going. The language isn't as important as learning how to properly use computers to solve problems.
I was pretty surprised that the php7 benchmarks are more or less inline with HHVM. Switching to HHVM when 7 is so close seems like a pretty big leap.
Semver says: &gt; Major version zero (0.y.z) is for initial development. Anything may change at any time. The public API should not be considered stable. I'll keep breaking changes between minor 0.x versions (i.e. 0.8.x will only be bugfixes). Once I hit 1.0 there'll be a stop of breaking changes (I don't foresee releasing 2.0 unless I rewrite it for PHP7).
I really want that now. I've always hated *strpos($haystack, $needle) !== false* since it feels like you're using a side effect of a function to make up for the lack of a dedicated function like in_string().
This is long-winded. Just run 'git add -f .gitkeep' after gitignoring the file. Using the -f flag ignores any gitignore rules that may apply.
Thanks for your explanation. It seems a bit contradictory to what ThePsion5 says. I appreciate what you say about consumers not expecting constructors to behave conditionally, I feel this is important, but that would require me to have a validity check on every other method. Each method would return what it's supposed to return (like type() returns 'ISBN10', 'ISBN13') but also a possible false. I know this isn't *wrong* per se (though there is a RFC touching on this I think), but it feels a bit dirty. Also, return true on type() doesn't make sense, so I think using false is not the best either. So what I would like is to not throw exceptions in the constructor and not having to include return false on every method for validity check. Can I leave the responsibility to check for validity on the user of the library? "Always check for validity before using other mehods, or things will blow up". Sounds a bit irresponsible. 
Just to make clear, ISBN::make('123') means that there is a static method called make? Should $isbn be false/true after calling make? This is probably basic stuff, but this is what I need to learn :)
That works for arrays, but there's two problems with it: 1) No ArrayAccess support 2) It would be bad, imho, to encourage this sort of code: $containsKey = false; foreach (array_keys($dictionary) as $value) { if ($value == 'somekey') { $containsKey = true; break; } } Over this: $containsKey = isset($dictionary[$key]); // works for arrays, objects implementing array access, and potentially more Just because the functionality is hidden in a function or operator doesn't make it any better. Adding the `in` operator, as currently proposed, encourages this hidden-bad-code.
That makes sense, but it does have a very, very limited use-case in that case. What kind of website are you imagining being made with it?
&gt; Continue and break are supported at only a single level. Stuff like break 2, is not supported. What's the reason behind this?
Wow, that article seems strewn with inaccuracies. Sounds like it's written by someone who hasn't ever used php.
Yeah for me slack has won this battle. Works on absolutely everything - keeps full archives of everything (including media) and is nicely script-able via it's API. 
I'd say this is a massive security vulnerability. The FPM master process should be checking for permissons before allowing child processes (and opcache) to access a file.
I've made a tag with git tag -a v0.1.0 -m "description" Seems guthub automatically added a release (I thought I had to do this manually from what I've read), but I edited the release and added "pre-release" to it. Now, I don't quite understand what you mean by &gt; Don't have people add dev-master as the package version. I think this means something composer something, but I don't understand what 'package version' means in this context and google is useless to search for concepts. Could you please elaborate a bit? About vendorname, I will change it before I make a release. 
I see! I did not know that, good to know.
I updated the post with SQL equivalents. What do you think now?
&gt; Works on absolutely everything Except windows (which they are working on actively). No one wants to use a second class web client to chat. Only reason we went with hipchat
Ah, indeed, just thought of a case where it changes.. If the user_id on both posts is the same.. Regardless, my expectation remains the same, that it would act as though it's a condition on the overall result set. Any reason you chose to use a subquery here? A join would seem to make this more straightforward, imho.
I just finished migrating all of my sites to HHVM last night. I relished issuing # /etc/init.d/php-fpm stop ;-)
I really agree with your sentiment here. And from my standpoint, I cannot abide by new-line braces and space-indentation in any code. Other than that, the rest of PSR-2 is cogent. By my own rationale, I think new-line braces came from people focusing too much on the aesthetics of their code vs. semantics of a closing brace matching the *statement* that opened it. Indentation levels already solve this problem, so mandating new-line braces is a demonstrably redundant convention. If the concern is that you want to ensure closing braces exist, consider that the absence of a closing brace is a syntax error - thus new-line braces are twice damned as a crutch. Despite this, in what seems like a token appeasement to the newline brace crowd, function and class definitions inconsistently (to the rest of the spec) require new-line braces. It's like bizarro-politics leaked into the PSR process and made it unpalatable to both sides. Design by committee indeed. There's also the whole no-tabs thing which is just further capitulation to regressions and reluctances in editor capabilities. All this being said, if a project is PSR-2 compliant and I'm committing code to it, I abide happily out of respect for the maintainer. If they're using underscore_variables, I'll usually encourage them to adopt camelCasing. But nothing is enough for me to ostracize someone because of their conventions! Outside of collaborative situations where I'm the authority? I same-line brace and tab-indent with prejudice! Finally - PSR-4 is definitely the kind of stuff we actually need. What an amazing gift to the community that is. Nobody could possibly take that away and we are all collectively thankful.
http://www.reddit.com/r/PHP/comments/2wgqkm/announcing_a_specification_for_the_hack/ Posted 1 day ago
This is for cases when you can actually pass a subquery, with limit and offset
But both examples have the same syntax so they must behave consistently. That is why I'm asking which route should it take
Problems like these are why I prefer doing my own joins, honestly.
If I'm writing a library that should be re-used by other projects, I **never** include the lock file. If I'm writing a project that should **not** be re-used by other projects (I think most CMS installations qualify for this), I'll **consider** include the lock file. For your OctoberCMS example - if there's a bug in a particular version of Laravel 4 that affects the quality of OctoberCMS, you can just change the version constraint in composer.json, and this tends to be a better solution than committing the lock file. For example: "laravel/framework": "&gt;=4.2.0 &lt;4.2.17"
It's not really a problem. I can easily implement both approaches
Library code shouldn't include a lock file because it's more efficient for the consumer application (which probably includes many libraries) to resolve the dependency tree to the smallest number of packages / versions needed (multiple libraries can use the same version of a common dependency rather than installing multiple versions). Bundled stand-alone applications could probably go either way, largely depending on the stability of the dependencies used and how they're used in the application I'd say. 
I don't mean it like that - I just think that regardless of which approach you choose to implement, it'll be ambiguous to someone reading the code, so I'd rather do the joins and wheres explicitly.
The whole requirement of "not real" seem bizarre to me. Requirements should be positive ("must be fast enough"), not negative ("doesn't have optional features like transactions and integrity").
Part of the advantage of opcache is not to have to rely on file store access overhead to read code. Having to stat files already in opcache would remove some of that benefit.
I actually prefer snake casing for both accessibility and readability. the accessibility point is due to text-to-speech parsers being able to parse the syntax more easily. I tend to use camel case more frequently however since I'm usually following established conventions.
Well ultimately the selected way would be explained in the doc =) And PHPixie ORM will have a cool feature where you can debug exactly which queries it is going to execute, before actually running them
I think this is consistent behaviour.. In both cases it's taking the hard AND route In the first example, posts which have the name Trixie **and** an id of 5. In the second example, posts which have an id of 3 **and** an id of 5
&gt; Would you expect the above to return: [...] There is only one correct interpretation of the first example in boolean algebra. `AND` is conjunction; `OR` is disjunction. Your example can't possibly mean "X or Y" because you've joined the expressions with `AND` in your DSL, not `OR`. &gt; Should the above return 0 users Yes, for the same reason noted above. &gt; SQL equivalents: [...] You should be using joins, not subqueries. Your ORM should already know how to join `users` and `posts`, based on configuration of primary/foreign keys. **Edit:** More specifically, this code: $users -&gt;where('posts.id', '3) -&gt;andWhere('posts.id', '5'); ...should produce this SQL: SELECT * FROM users INNER JOIN posts ON posts.user_id = users.id WHERE posts.id = 3 AND posts.id = 5
Ah I see, thanks =)
Good job on the library, I can see how useful this would be to developers who are intimidated by the dense &amp; (relatively) obscure syntax of regexes. That being said, i'm not convinced this would be significantly easier to understand for more complex patterns. Plain regexs *can* be complex &amp; easy to grok - when using PCRE you can use the 'x' pattern modifier so that whitespace is ignored. When combined with judicious commenting on the intent of the components [you can create understandable patterns](https://github.com/ptlis/conneg/blob/0e7cf5151ff48906346852cbab92b40de635fab0/src/RegexProvider/MimeTypeRegexProvider.php).
This really has nothing to do with algebra as I'm not trying to substitute AND with OR. The SQL equivalents were added to illustrate the point. The point I can either interpret those conditions as conditions on the entire collection ( SQL equivalent 1) or as conditions on the item in that collection. The first SQL is for the version where I consider conditions as being added to the whole related collection. This way I can get users that are related to multiple elements that TOGETHER fullfil added conditions. The second SQL applies conditions to EACH element in the related collection
Even libraries that I've used for over a year and read the docs multiple times, if there's an ambiguous method or interface somewhere I will always keep forgetting what it does. Maybe it's just me, but I like to strive for an API that requires as little documentation reading as possible. Same goes for your debugging feature. I'm not afraid of not being able to debug it, I'm afraid of writing the code and pushing it before I realise my mistake. I'm not going to debug every query I write to avoid mistakes like that, nor am I going to be able to write tests that catch them all the time.
That's really the single most important advise. Using `/x` is what turns opaque regexps into readable code. Just make it multiline and commented, and they'll instantly become properly manageable code. I've recently been pondering a `psix()` to PCRE conversion wrapper in PHP. Though that's probably unfeasible. (After all, regexps are the only thing too complex to parse for regexps even.)
Yeah, it would be nice. In any case, I think this problem is solved far more easily by simply allowing a configurable prefix that is put before the opcache's hashmap keys, allowing you to use different prefixes for different FPM pools.
I see whatbyou mean. But it is not in fact an OR. Rather its unterpreted as: user must be related to post with ID 1 AND also be related to the post with ID 2. Its still AND, just on the relationship itself.
There's no reason to deprecate in_array().
It's much more disruptive to control flow and thus much harder to statically analyze. It's also a fairly rarely used feature (and many of the uses of it are questionable at best), so the cost/benefit tradeoff is way out of favor of supporting it.
I think maybe you just worded it confusingly. But your example only has 2 expressions, so it's impossible for different interpretations to produce different results: SELECT * FROM users INNER JOIN posts ON posts.user_id = users.id WHERE posts.name = 'Trixie' AND posts.id = 5; SELECT * FROM users INNER JOIN posts ON posts.user_id = users.id WHERE ( posts.name = 'Trixie' AND posts.id = 5 ); Regardless of how you group the expressions, the end results will be the same. So let's look at an example with 3 expressions, using 2 different boolean operators instead: $users -&gt;where('posts.name', 'Trixie') -&gt;andWhere('posts.id', 5) -&gt;orWhere('posts.id', 1); What should this syntax give us? SELECT * FROM users INNER JOIN posts ON posts.user_id = users.id WHERE posts.name = 'Trixie' AND ( posts.id = 5 OR posts.id = 1 ); SELECT * FROM users INNER JOIN posts ON posts.user_id = users.id WHERE ( posts.name = 'Trixie' AND posts.id = 5 ) OR posts.id = 1; These interpretations will return drastically different results, even though they both use the same expressions and operators. That's why *flat syntax sucks for representing nested expressions*. To resolve this problem, you should create a syntax that allows nested expressions to be unambiguously expressed. Here is one possible example, with syntax similar to an ORM we use at work: $users -&gt;where([ ['posts.name', '=', 'Trixie'], 'AND', [ ['posts.id', '=', 5], 'OR', ['posts.id', '=', 1] ] ]); In this way, it's impossible to misinterpret the syntax, as it isn't flat.
better than the previous weak type hints proposals and if they get bools right it'll be pretty useful.
I would change -&gt;eitherFind("png")-&gt;orFind("jpg")-&gt;orFind("gif") to something like -&gt;anyOf(array('png', 'jpg', 'gif')) or something to that extent
umm I still hope that scalar names will not become reserved words, but well Id be happy if scalar type hinting does pass. 
Of course, that RFC needs to pass! I hope zeev is not voting against it since he seems to be the type to oppose such changes. But I can be wrong. 
This, straight from the horse's mouth. Granted, I try to avoid creating libraries with a lot of dependencies, but I would consider it foolish bordering on irresponsible to not track those dependencies. Without doing so, all of those pretty build status icons we love to throw in README.md are literally meaningless. It's the semantic equivalent of committing the vendor/ directory, without the overhead. 
Shit was so cache!
The conversions look much saner, but it still doesn't seem to address strict proponent's concerns. That `int` or `float` can be valid `string` parameters (to name an example) seems like a red flag. Btw, when implemented with return types, `function foo(): int { return "32"; }` would be acceptable? `function bar(): string { return 0; }` too? Silly question: would adding a new predefined error constant like `E_TYPEHINT_ERROR` (that is disabled by default) be viable, despite setting a global state? Or error codes don't work this way?
Check the author... 
I've seen so many attempts at this. it's like the `/x` flag and comments don't exist
~~Isn't this solved by using the full file path for the key instead of "/one.php"?~~ Never mind, I'm probably missing something with the file paths but the real issue is the permissions. In which case, can't the file permissions be cached too?
&gt; That int or float can be valid string parameters (to name an example) seems like a red flag. This is an unreasonable concern by the strict camp. There is no reason why `"123"` should be valid input to a function with a `string` typehinted parameter but `123` shouldn't. PHP isn't a wizard. It can't enforce parameter *semantics* for you; that's your job, as the developer. If you don't want a user's first name to be able to be comprised of digits, then you need to enforce that with a regular expression.
I was talking about a different RFC, the context sensitive lexer, not this RFC that Zeev wrote. You clearly did not read carefully. 
I have my bets on *popcache*.
This seems like a much more sane compromise between the weak scalar type hinting proponents and the strict scalar type hinting advocates. Simplicity trumps all, and having a single behavior for STH I think will encourage a lot more devs to adopt hinting when PHP 7 is released.
That's the very joke answer I was alluding to. (Misses the point on [modern regexps](http://stackoverflow.com/questions/4231382/regular-expression-pattern-not-matching-anywhere-in-string/4234491#4234491) and [grammars](https://nikic.github.io/2012/06/15/The-true-power-of-regular-expressions.html).)
The web client is pretty great. I don't use the native client at all. I was skeptical when we first started using it but it has come a long way in the last two years.
Centos 7 is such an easier installation process. Ask in the #hhvm channel on freenode. We already have RPMs and repos for HHVM. Very stable. :)
Just use commercial bulletin board provider then. Even if you get it running, you'll not be able to keep it patched up. While the code quality isn't as bad as it used to be, PHP "forum" (bulletin board) software isn't usually well-engineered. The existence of manual "mods" instead of diff/patches or a proper plugin system is a pretty clear indicator of the effort required.
&gt; But it is not in fact an OR. Rather its unterpreted as: user must be related to post with ID 1 AND also be related to the post with ID 2. Then why not: $users -&gt;where( [ 'posts.name' =&gt; 'Trixie', 'posts.id' =&gt; 5 ] ) ;
Can you explain what you mean by this? I'm pretty sure once, it's up and running I can take care of it. I just don't have days to dedicate to getting it set up - which I'm guessing is what it would take me, if I need to learn everything as I go. Do you often need to recode stuff? Like updates and things? What is a commercial bulletin board provider? How do they work? Sorry for the many questions
A commercial bulletin board provider wouldn't work for him. He still needs work done for a logo, his ranking system, other miscellaneous items. The work still needs to be done by a human being. 
The danger with this RFC is that the problems are really skillfully spoken over. Namely the section on how internal functions will behave. Really, boiled down it's : 1. Make the change now, screwing BC and making porting to 7.0 a nightmare for most users with existing codebases. 2. Make the change now, but default to having it off except by **ini** setting. So your code will by default work but you can turn on the new behavior by an ini setting. 3. Make the change now, but default to having it on, except that you can turn it off by ini settings. So really, it's screw BC, screw consistent behavior between internal and userland behavior or install another fundamental behavior ini setting. All three suck IMHO. But the though of having an ini setting sickens me. I thought as a language we got past that. We've killed most of the major ones already (register_globals, magic_quotes, etc). We need to be killing them, not adding new ones. And the fact that more people aren't concerned about this really does worry me more than the fact that Ze'ev included them in the proposal (and that already worries me significantly).
Presumably it would have to, as the RFC guarantees the function/method body to receive the type that was hinted. This could get ugly with a by-reference string with an object's `__toString()` method though. Presumably that would trigger the same data loss warning as the other cases (e.g. `"100 apples"`)
This is good! I'm not sure if I would use it to implement something, but if I was teaching regular expressions I would definitely use it! Make people write them in this format, copy the output and put it in a software like RegexBuddy or a web app like https://www.regex101.com/
How hard would it be a library that replace regex symbols with commands in english? And output Like: start_line-find_word(http)-find_all(*)-end_line This could work both ways. Does it already exist?
Depends on the precedence. The RFC says it matches `instanceof` so we should be fine here http://3v4l.org/FQQh2 I suggested the parenthesis for readability to avoid this sort of confusion, but your example is valid. 
A while back somebody applied to the League with something similar. We didn't end up picking it up, but maybe you folks could see if you have enough common ground to work together https://groups.google.com/d/msg/thephpleague/CDS0NoWPWes/hH-fc7rjvGgJ
Yes, what I thought. BTW artwork is done - just need it put in the right places
No
My inbox says otherwise
Which gets us back to the case where a library author can force behavior on a user. That was the entire point of the caller-based approach in that it put the caller in charge, not the callee. And CSS's `important!` is not something to look up to, but the realization that a fundamental flaw was made in the design that they simply chose not to fix. Here, we're still designing the system. We don't need to design the flaw in the first place...
He is correct, I misjudged the actual importance and implications. After I made the ticket I did mail it to security@ as well but did not give them enough time to reply. The original bug relating to this is from july 2014: https://bugs.php.net/bug.php?id=67481
&gt; If anyone ever had a good reason to want exactly certain type, then they will force it either way by doing the whole work of throwing an exception. &gt; That's the point though. It's not up to the library author to determine that. It's up to the calling author. They are the one in control of the data. They are the one knows where it came from and the circumstances around it. So why should the callee dictate how the API is consumed?
Indeed. Non-lossy weak typing/casting is perfectly sufficient for the purposes of adhering to the interface^[1]. I'm concerned about the lack of non-strict types in three situations: lossy casting, by-reference values, and static analysis (and future related stuff that requires lots of detailed type information, like a JIT). Per my original reply, I think the lossy casting issue can and should be handled in a way that's not strictly related to scalar typehints. The by-reference thing is iffy for me; what happens if you pass an object implementing `__toString` into `function inPlaceReverse(string &amp;$string) {...}`, etc? Should implicit casting be blocked on by-reference function calls the same as lossy casting may be? Granted this is potentially a problem today without the hints, but I think it would be exacerbated by the language auto-casting values. For all I care, scalars could actually be an object of type `Scalar` that dynamically changes which scalar interfaces (`int`, `bool`, `float`, `string`, and maybe combined ones like `number`). This is too far off the deep end of OOP to fit nicely in PHP (not to mention that objects are by-ref and scalars by-val), but I think it's a reasonable way to think about how hinting should work. ^[1] Related: using objects that implement `Countable`, `Traversable`, and `ArrayAccess` where array is hinted should be valid, and vice-versa. I brought this up with someone else on internals in a different thread a few days ago.
This thread is cracking me up. If you want to condense it, just write this. $pattern = '/(png|jpg|gif)/'; Or with /u/Disgruntled__Goat's example: $pattern = '/\d{2}[a-zA-Z]{3,10}/'; The point isn't to condense an expanded syntax for an already concise syntax. The point is to utilize a set of functions to express the concise syntax *without* condensing it.
Because they found a reason. For example, it's a private call and the method shouldn't be receiving other types, or it benefits of somehow better static analysis than provided by coercing hints, etc.
Is it well documented that you use sub selects for relationships to other tables? If not, I think this behavior would be very surprising to me. And I'd be surprised to see multiple conditions against a relationship to be "rolled up into one." Is this optional behavior or is it the only way you are considering building relationship queries?
You can comment regex?
I only use it via the web client on OSX in chrome. Works a charm - and has desktop notification support. 
I would actually argue that it doesn't hurt to include the lock file for libraries, as it just gets ignored when it gets installed/used. But it can be rather useless
The issue with this is that then and() and eq() would have to be global functions. 
You can with PCRE at least (I'm not so familiar with POSIX regexes) using the # character. See the [linked example](https://github.com/ptlis/conneg/blob/0e7cf5151ff48906346852cbab92b40de635fab0/src/RegexProvider/MimeTypeRegexProvider.php) from my original post.
Reading Zeev's communication is painful... First the asks for feedback, and receives concerns. Then he goes completely defensive, complains about how "patently false" shuts down the argument, then shuts down the argument with "agree to disagree" which doesn't move the conversation forward. He falls back on the "spirit of php" when it suits him, and dismisses it as a bad idea when it doesn't (dynamic all the things is in the spirit of php - providing options to end users is also, but that's bad). And the tone of the RFC... I though we were making some head way with some mails in the thread Sara was pushing - then the RFC comes out and it paints anyone who believes strict scalar type hinting is a good idea as not understanding, uses dismissive language when addressing his critics, and then paints his own solution in the best possible "there are no problems with this" light. I don't *entirely* like either of the dual mode approaches that have been floated (Andrea's or Anthony's) - but they are at least thoughtful and largely complete. Zeev and friends put together a half baked RFC with no patch, suggests introducing an ini setting and refuses to address criticism of his approach... *sigh*. 
If by global you mean no namespace you can put them in a namespace and use "use function" to import them into your top-level or local namespace. You can also make them functors. $and = new And(); $eq = new Eq(); $and($eq('id',1'),$eq('name','trixie')); 
How this plugin deals with code like this? if(something()){ $newvar="foo";} if($newvar=="foo") echo "something!"; I know if smells but sometimes is not buggy
I don't really see what this syntax would improve over existing one to be honest. Especially having to pass everything to a filter() method makes it very limited in terms of dynamic query building
PHP will outlast Hack. I think PHP will steal some of Hack's ideas and eventually Hack will fade.
Where in the midwest? You also are going to "bite the bullet to learn them", so whats your background? In the Twin Cities they are more desperate for Java and .Net then they are for PHP. In fact, if you are a .Net dev in the Twin Cities let me know because I would love to claim the referral bonuses the recruiters are offering for one these days. But back to the topic on hand. In short, Learn standard PHP first. Most companies either want a Symfony dev or even more commonly a Drupal or Wordpress dev. There isnt much talk about HHVM/Hack here yet. (see: [MidwestPHP sessions](http://2015.midwestphp.org/sessions/))
Yes, of course ;) Still have some residual bitterness about all the issues that traits caused, sorry for letting it bleed over. I've dropped the snarky bit.
And it also gets rid of the best thing that the other proposal provides: static analysis How exactly is an IDE or a SA tool supposed to "know" anything about your code if some strings can be accepted as ints, and some can't? It also means that the very best performance improvements can't be implemented by the interpreter, because it doesn't actually know anything about the code. It provides all the same code USE benefits in a *slightly* simpler way, but it sacrifices all the concrete benefits to do it. This proposal is awful. Without being able to do things like profile the code and provide compile time optimizations, we might as well not even have the STH. Without that, the only purpose it serves is to remove one or two if statements from methods/functions when people *already* don't trust PHP's native casting.
No, you can't decide it later on. I don't know why people don't understand this. How is any static analysis tool supposed to know ANYTHING intelligible if some strings can be ints and some can't? If all ints can be bools, but with opposite behaviors? Anthony's proposal actually provides PHP with the BENEFITS that you should get from going through the trouble to manage types. If Zeev's proposal is accepted, we can't in the future change it so that the interpreter or a static analysis tool knows how to profile the code. It's like Zeev doesn't even understand how computer science works, or how languages work.
Why? Facebook's frontend is written in Hack, and so the language will last at least as long as Facebook does. I don't see either PHP or Hack going away any time soon.
You seem to be dense to combinators but okay. I see what I am dealing with here: https://www.youtube.com/watch?v=_a-W_I7PcSQ. I'll just leave.
I disagree. Hack will find its place in large enterprise applications where its performance means the difference in 10s of thousands of dollars/month in server costs. Meanwhile, the comparative simplicity of PHP will make sure it remains the entry point for anything else not as sensitive to scale. And since Hack can run alongside PHP in HHVM, it will remain the perfect transition language so as to reduce rewrite costs. They'll both have their place, and as long as HHVM continues to support both Hack and PHP, then they'll both compliment each other quite nicely.
Also, Chicago is a ruby town but the node infection is spreading. My advice, don't learn php unless you want to work on WP or legacy train wrecks. 
Nope, the language will last as long as fb sees it fit. If they made another new language like apple did with swift, or move to py or ruby then that will be the end of it. 
Hack is absolutely not about performances, it seems you are mixing up HHVM and Hack.
Definitely PHP first if it's between the two. Dabble with Hack later.
HHVM is the engine. Hack is one of the languages the engine can run.
If you look at /u/dynaaddison's post history you'll see they just keep posting links from the same url (creativedev.in).
Seems /r/php and others have been getting too many of those people lately, it was the same thing with /u/zuckerberg_mery and his horrible only-slightly-English devbattles articles linked all over reddit, but it looks like his account was shadowbanned/deleted.
Dual, easily chosen, mode (as in Anthony's RFC) is the "right" choice IMO. An ini setting would really make things a lot more complicated than they need to be, since: 1 - Raises the possibility of hosting companies to turn it off, screwing userland completely. 2 - Forces you either to use it or not use it for all codes, which is undesirable. Oh and forget about ini_set, because if you use that argument you're going in the same direction as the dual mode! One other thing, completely unrelated to technical details or even the RFC itself: The whole "many others, who shall remain nameless" thing made me *VERY* uncomfortable. Not a good thing to do and adding a smiley doesn't make it better. C'mon, everyone, we are better than that... right?
&gt;It's like Zeev doesn't even understand how computer science works, or how languages work... Man, that statement is so dumb, even for /r/php...
&gt; So really, it's screw BC, screw consistent behavior between internal and userland behavior or install another fundamental behavior ini setting. I don't see how that is the case. Regarding BC break, this is a major version. So I don't get why you are so concerned about the BC break. It is curious to see that the same guys that usually cry out for progress at the cost of BC, flip their stance when it does not suit them..
Ok, then It will be an article. To save time during development following sections could be interesting for you right now: - performance checks (performance pitfalls) - probable bugs rules (e.g. forgotten debug statements or missing parent constructor/clone call) Since rules are applied while typing in, you can without context switch fix it immediately (I also doing PHP development and on my taste it's no harm to productivity).
I know some of those words! :D Thank you, though. Gives me something interesting to check out and learn.
Plugin will complain for missing brackets ( if (... ) { ... }) and nothing more. But if (...) { $x = 1; } else { $x = 0; } will generate warning and propose to restructure $x = 0; if (...) { $x = 1; }
But a lot of the language features are making their way across already, with more likely to come. Return types are accepted for PHP7 using the syntax that hack came up with. Nullable types have been proposed also with the same syntax. I won't say convergence is inevitable, but I wouldn't be surprised to see it happen either. 
In this case it's not about data loss, it's about intention. They are different enough *^(edit: string and int parameters, not the concepts)* to stop and say *"hey, are you sure this is what you want to do?"* To give an invented example: define('ERROR_LEVEL_LOW', 0); function set_error_level(string $level) { // Expects "low", "medium" or "high" } set_error_level(ERROR_LEVEL_LOW); This not real live example, as `set_error_level` in this case should also apply his own validation, but if we assume all functions apply their own validations, we don't need scalar typing. Maybe this example doesn't suffer so severely from this flaw: createUser(string $username) { assert(strlen($username) &gt;= 5); // Checks minimum length assert(strpos($string, " ") !== false); // Checks that no space is included // Good to go! } createUser($user_from_third_party-&gt;getId()); // Runs successfully, although we have created a // user with username "318975" instead of "jimmy"
Only the values 0 and 1 should be accepted for bool. But even that is probably not necessary. 
i was replying to this "If not have Hack be the next zendengine" Hack can't be the next Zend engine, because it isn't one.
It would be nice to take your time and explain in a comment why you down voted Phil's answer. PHP is more widespread than Hack and if you want to make a career, at this point in time PHP is the path to go. Hack is good because it pushes new things and competition it is always a good thing. In the long term I hope that PHP core devs will take the good things from Hack and implement them in PHP. From my point of view, Hack is a testing ground for new features that could arrive in PHP.
I feel the same, php seems to like JavaScript now. A lot of "add ons" but the only real thing is and stays JavaScript.
No, you can't. Because you'll likely have to work with PHP libraries. It's a bit like C vs C++. You need to be able to tell one from the other. So you need to learn both. 
i would've change the "test" method name to something like "matches", or "doesMatch"
Context-sensitive lexer won't help you with your problem since class names and type hints will be used in the same context. function (int $i, Int $objectInteger); Maybe it will be allowed to do something like this: use MyScalarWrapper\String as MString; use MyScalarWrapper\Integer; function (MyScalarWrapper\Int $integerObject, MString $stringObject, Integer $anotherIntObject); p.s. You mention your scalar objects in every discussion. This is pretty annoying.
What about this: if($kasss&gt;0) $foo=1; will it recommend to use "?:;" ?
If you know Hack, you already know PHP.
&gt;Don't learn PHP unless you want to *work*.
&gt; then the RFC comes out and it paints anyone who believes strict scalar type hinting is a good idea as not understanding That is not how I read it at all. I'm more in the "strict" camp (or rather I'm in the "lossy casts must die"-camp) and this seems like a step in the right direction. Though I am sceptical about his claims that there is no performance difference between strict and coerced typing. Once your type system is fully deterministic you can do things like function inlining and passing native types, and making data structures and objects with no pointer indirection. This is huge for performance. I would like this, but I don't believe that will ever happen. Even Java hasn't done that yet. This RFC should take a stronger stance on conversion to boolean though. Casting float or string to bool is just too ambiguous of a concept, better force the programmer to express what he wants rather than standardizing more quirky behavior. I would prefer stricter behavior on numeric casts as well. But overall a step in the right direction. 
Hack is just an extension of PHP language, its still PHP at its core. Id say it does not really matter, as you learn about the same syntax especially as a beginner. 
I've seen only one usage of preg_quote() [1] in your source and in the test() [2] method uses the '/' delimiter. So, from the looks it seems you need to add the delimiter to preg_quote() otherwise your code can generate invalid regex. I mean no disrespect, but this is what I think: Maybe nice for "starters". But I doubt someone having no clue how to properly use regex feels comfortable using the fluent call syntax. Or to put it differently: if someone on my team would use this, I'd have doubts about his/her capabilities. Even a junior. Regex is too fundamental to be hidden away. - [1] https://github.com/gherkins/regexpbuilderphp/blob/cfb5c62f6cf6eb31c7a23a6fc89bcbe3e70894d1/src/RegExpBuilder.php#L652 - [2] https://github.com/gherkins/regexpbuilderphp/blob/cfb5c62f6cf6eb31c7a23a6fc89bcbe3e70894d1/src/RegExp.php#L71
The criticism I made which you quoted is based largely on tone, and specifically on this line: &gt; In addition, there appear to be numerous misconception about benefits of strict type hinting, that to the best of our (deep) understanding of the associated technologies, aren't really there: The implication here is that Zeev et al have extensive "deep" understanding of what's at play (presumably meaning the PHP engine itself) and that strict proponents just don't get it. At the very least, the concerns of strict proponents, and specifically the concerns of Anthony as custodian of the alternative RFC warrant rigorous discussion - this is a hand wave and an appeal to some imagined superior understanding of what is going on. At best there are tone issues with the entire document which is not a way to drive consensus. &gt; I am sceptical about his claims that there is no performance difference between strict and coerced typing. I believe (and I'm by no means an expert) the issue of performance is given the current state of the engine. I would imagine that if fully strict there could be optimisations which would greatly improve things in this area but both camps are (rightfully) shelving conversations about performance - get the feature first, then optimise. I don't have a problem *in principle* with a coercive approach although the boolean cast is a little yuck (boolean ends up behaving as If-null-empty-or-false... and would be better handled with union type hints if this was something that developers actually felt was necessary). The use of an ini setting, however temporary, to facilitate this transition is a rather messy mistake and is they key difference in my mind between the duel mode approach. Duel mode allows opt-in (or out) on a per file level, and still allows for future deprecation and removal of the old rules without taking the ability to opt in or out away from developers, especially on shared hosts where modification of ini files can be problematic. Instead of having an ini flag, the "declare" syntax is introduced to opt in, and the very same roadmap for removal of this is applied to what is being suggested for removal of the ini flag. That is to say in 7.1 you emit E_DEPRECATED for "declare('strict')", and you remove it entirely from 8.0. 
My experience was the opposite. I had to do a double take on the "exactly" part to realise what it was trying to do. It feels ambiguous - "exactly(2)" could apply to the previous or following function. When do the functions stop applying to one token and move on to the next? You're looking at "digits()" in the context of a regex so I think it's pretty clear it's matching digits.
I think you are confusing the words "understandable" and "insane".
Sorry you lost me. &gt; The full file path is either /one.php Either /one.php or what?
Last year the videos all went up end of march
I was under the impression that `composer install` would respect dependencies' composer.lock. If that's not the case, that's a big reason not to include composer.lock with your library code. When people `git clone &amp;&amp; composer install` (or when a CI environment like Travis does the same), they'll get specific dependency versions and tests may pass, but when they add the library as a dependency to their own projects, different versions of the dependencies will get pulled in and code may break. So basically you depend on your library contributors/maintainers to know that the .lock file should be ignored and you always need to `composer update`.
When the system is chrooted, the full file path is /one.php as far as PHP and opcache is concerned. If the system is **not** chrooted, the full file path is the **actual** full file path, something like /var/www/site-one/one.php
I 've attended FOSDEM @ Brussels recently and happened to be there [Nils Adermann](https://github.com/naderman), a great contributor of [Composer](https://github.com/composer/composer/graphs/contributors). He actually suggested in his talk that we should always keep composer.lock in our repos, because this way we ensure that everyone that runs `composer install` will have the same dependencies versions. Only the maintainer should run `composer update` in order to fetch new versions and alter the composer.lock file. Pretty much what it says [here](https://getcomposer.org/doc/01-basic-usage.md#composer-lock-the-lock-file). So yes i keep composer.lock in all my repos.
Really interesting solution. The whole idea of how a PHP apps works now it's so wasteful in terms of resources. At every single request the interpreter has to load all the code and libraries all over again (yes, APC helps a lot, but still the code is loaded each time). Maybe with projects like this and ReactPHP, things will change and eventually developers will start writing more efficient apps and frameworks running in persistent PHP request workers.
&gt; So to fix this, what do we do? Add an explicit (string) cast with the function call? Casting the value so it satisfies a strict typehint is rather ironic, isn't it? It's not ironic. It's the programmer telling the computer "Yes, I explicitly want to use this int in a function that wants a string". I realise that this has been said before, that is the whole point of strictish typing - it forces the programmer to be explicit about casts, and makes an error in the cast be in a position where it can be reasoned about - rather than happening in a random layer that the programmer isn't thinking about (e.g. when the value actually gets sent to MySQLi). btw the int to string case is unusual as it is always safe to cast - and can actually be done without using a cast e.g. `foo("".$number);` - which is always lossless. 
If there's a probability of error, an explicit cast isn't any more helpful than an implicit one, I'm afraid. In fact, explicit casts - because they can't fail - are arguably much worse here. Future problems, such as the variable suddenly becoming a boolean, will be hidden by an explicit cast, where they would have been easily and immediately reported by the failure to coerce.
An explicit cast will mask any future type errors. Perhaps the variable somehow got turned into an array. Guess what? You force it to a string, and your app is now assigning everyone a username of `"Array"`. This function call will now **never** again report any type errors for you. You have functionally removed all benefit of having typehints in that spot.
When you say .NET, do you mean all technologies in general, or a more specific of these ones: C#, VB.net (dear god), F#, MVC?
Why does this prevent static analysis? Surely if you want strict hints any IDE can 'pretend' they are strict and warn accordingly?
What you *send* is not important (or useful) if it's not representative of what you *have*. This is the major problem with explicit casts (which you, ahem, conveniently chose not to reply to in my last post). When you explicitly cast what you have, you're saying "I don't care what I have, just make it a string". You do not gain anything in this scenario over allowing PHP to do the same implicitly. In fact, you *lose* something based on this RFC. Explicit casts will turn *anything* into a string. Implicit coercion will, according to this RFC, only turn certain sensible types and values into strings and report an error on anything unreasonable. So now you have a situation in your code where you *think* you're being safe. After all, you're ensuring that you pass a string to your function that wants a string. Congrats! However, you've now unknowingly made it extremely hard (much harder than if you had not done this) to ever track down future problems where your precondition assumptions suddenly fail (e.g. your variable stops being what you thought it might be when you cast it).
On reddit, people downvote you if they don't like a post you made a year ago. You can't expect this bunch to rationalize their snooty behaviorisms. 
LOL
HackLang has had Zend on the run for a while. The underlying language (C++) and a decisive break in backwards compatibility allows the HackLang team to outrun Zend left and right. Plus, they don't have the pesky human drama of php-internals (and they never publicly squabble about why strict internal data type hinting, either).
You can convert individual files to HackLang and see tremendous benefits. My corporation has a lot of experiments ongoing with this. You simply do not have to (nor even should) convert an entire app to hacklang. Start with the most memory hungry and big array parts and move on down, as time and resources permit.
If you're the only one who specializes in HackLang in your area, who do you think is going to be able to command the big bucks? I mean, come on.
tl;dr: it got better.
but the strict typing is optional, so you slowly add it as you start to understand it. This is why I believe you should just go straight to Hack... because it's PHP + Extra when you're feeling comfortable with it.
Cool library! :)
it doesn't matter how good is your product if no one wants to buy it
Are you sure you aren't confusing this with repo auth mode? Which gives a further 20% performance boost.
I assure you I am not.
I'm glad to say it's been long enough since the last time I used it I didn't notice my typo. Thanks.
This is not a problem with unit tests--it's a problem with not understanding what problem unit tests solve. What you're looking for to detect that bug is an integration test.
Exactly, I point that out in the post =)
[Why not both?](http://img.pandawhale.com/82733-why-not-both-meme-5LvD.jpeg) While I did reach for a meme, I really do mean it. Neither Hack nor PHP is complicated so I would recommend learning both. Start with PHP since that's what the jobs will likely be in, but learn some Hack along the way. Personally my favorite feature of Hack is "offline" type checking.
Interesting but the mere fact that it needs the JVM to even install turned me down...
Is not that something like http middleware? Why don't you mention things like [StackPHP](http://stackphp.com/)?
Is there a source code available of your executable?
&gt; Calls to internal functions could just trigger warnings on non coercive argument? That way BC is kept but you can do it strict if you care. Errors (even warnings) are expensive. Generating possibly tens or hundreds of errors at runtime is going to slow things down considerably (even if ignored). Without a patch, there's no way to know for sure how bad...
&gt; I don't see how that is the case. Regarding BC break, this is a major version. So I don't get why you are so concerned about the BC break Because I don't want to see a Python 2/3 situation. Simple as that. &gt; It is curious to see that the same guys that usually cry out for progress at the cost of BC, flip their stance when it does not suit them.. If you're talking about me, I'm curious where you got that idea. I've always advocated for minimal BC breaks. In fact, I said publicly (I can't remember where) that the only kinds of BC breaks I'd like to see in 7 are those that are statically analyzable. That way we can build a "checker" and a "fixer" to convert code that only worked on 5.6 to code that works on both. This style break would by definition not fit that criteria.
Without it, it won't get the 2/3 because it'll break far too much code out in the wild...
&gt; Reading Zeev's communication is painful... Then call him out on it. On-list. It's hard when it seems that only a few people on list care about it. It makes us feel like we're crazy or blowing things out of proportion since we're the only ones who see it (or are willing to say something)
I've never tried Go; what are the best use case scenarios for it? 
&gt; If you already know what type it is and will ever be, then typehints of any kind aren't benefiting you at all... For a single developer working in a single module, you're right. This will not have significant benefit if you're by yourself working on 1k loc. However, for a 100k loc app developed by 10 people, they do benefit significantly. The reason is it provides clarity when another developer reads your code, and it proves that types are correct in the entire program (which no single person can keep in their head at one point in time).
The code is available on github. Just look into the **src** folder :)
I haven't been in the office so I didn't get the e-mail (or didn't read it). I'll follow up when I'm back at work this week. thanks!
Would that impact by-val parameters as well, since objects are always passed by reference? Despite having worked with PHP for 10+ years, I'm not sure off the top of my head if "objects are always by reference" translates to "the variable will be a second reference to the same object" or "the variable itself is passed by reference". To pseudocode it, do we get this: // no side effect $var = new SomeObjectWithToString(); $__zend_internal_temp_var = (string)$var; $result = myFunc($__zend_internal_temp_var); // $arg is hinted to string or this? // side effect $var = new SomeObjectWithToString(); $var = (string)$var; // implicit cast by Zend engine, this is NOT in your code $result = myFunc($var); // $arg is hinted to string In either case, I don't like the idea of "your object would just go away", but I suppose that's a risk of calling any function with by-reference arguments. Their continued use in some parts of the standard library (array sorting, mostly) is one of the few real issues I still have with PHP core. Maybe because my housemate is a hardcore Haskell nerd, but unexpected side effects scare me, and it's non-obvious at the call site if a parameter is accepted byref or byval (especially since byref calls were deprecated). Syntactially, I'd prefer that byref has to be indicated at both signature and the call site to make it clear that your variable may change, but that's a totally separate discussion. I suppose that's all relatively orthogonal to this RFC, if it's sanely implemented. Hence my belief that we need something to the effect of `E_LOSSY_CONVERSION`
&gt; Scalar type hints will be optional so there is no BC concern. In Ze'ev's proposal, ZPP (`zend_parse_parameters`, how internal functions parse and determine type information) will change. Meaning that yes, under this proposal, there would be massive BC concerns since the way internal functions behave will change (with respect to types at least). So a non-insignificant portion of code that works in 5.x will not work in 7.x. And it won't be clear as to why until you encounter each type error. &gt; Let me quote to you your own words: The quote that you're mis-citing was about *my* RFC. Ze'ev had said that my proposal introduced a BC break because things would stop working when people enabled strict mode. I was pointing out that wasn't BC because it was users enabling (explicitly) a new mode that never existed before. Hence **all** code will work from 5.x to 7.0 in my proposal. The only time you'll get a break is if you explicitly enable strict types. Which is by definition not BC. 
&gt; Docblocks already give us the ability to provide clarity for the rest of our teams. They do from a documentation perspective. But type declarations give compilers and static analyzers the ability to not only provide that clarity, but to **prove** correctness. There's a reason Facebook moved somewhere around 99% of their code to Hack (based on public numbers). At scale, strict types and static analysis just have too many advantages. &gt; And if we have to explicitly cast parameters in order to satisfy these contracts, then we've already lost the benefits of typehinting. These casts are doing nothing but moving the problem up a notch on the stack. But, not only that - they're also removing all further error messages from said bugs. It's a lose/lose scenario. That's a fair concern. But do you see people using explicit casts in Java that often (which has this same type rule system)? What about Go (which has a stricter set of rules)? What about Rust? What about Haskell? What about &lt;insert-strict-language-here&gt;? Sure, some people may do that. But that still doesn't mean that strict types are flawed. And that doesn't mean they can't be used properly.
I tried, but it doesn't appear that the list is accepting new subscriptions. 
&gt; In Ze'ev's proposal, ZPP will change. It won't change overnight and more imporantly, adding E_DEPRECATED isn't really a BC break. I'd be perfectly fine with E_DEPRECATED in PHP7 and E_RECOVERABLE_ERROR in PHP8. &gt; The quote that you're mis-citing was about my RFC. It was and it just as much applies to his RFC. Don't get me wrong, I still think your RFC is the way to go and Zeev should stop sabotaging your efforts, but no, adding some deprecation notices is not really a BC break.
As far as I know there is a rather important difference between acceptance tests and functional tests: Acceptance tests are the conditions your client defines pretty much stating that: "these have to pass for me to accept your work". These usually are functional tests ( "user must be able to log in" ), but they can also be performance tests ( "the page must load in under 0.3 sseconds" ) Also if you make some functional tests by yourself without being instructed by the client, those are not considered "acceptance" tests. E.g. if I want to make a functional test to check if I log all the important data, this is a functional tests. But if my client doesn't care about that log it's not an acceptance tests. At least this is how I learned it.
&gt; introducing an ini setting Anything that introduces a "it worked on the dev servers but doesn't on the prod because a server setting was different" is not a step forward. 
I am not convinced that someone from user land calling a developer out on the list would be terribly well received even by those who agree with me.
Gotta love reddit. I got a couple of PM's from this post, and found one skilled and creative web guru, on my wavelength, who is genuinely interested in the project. I am paying him a good/ fair price for his work, and both parties are happy. Cheers reddit!
Big shops are going to be more attracted to the lower memory and CPU profiles, so it's quite natural that they would jump to HHVM ahead of many others. "Hey boss, I think we can serve 20x more requests per second on our current hardware" and "Hey boss, I think I can reduce the number of hardware instances we need on Cloud X" are both really compelling for that demographic. 
 echo $abacus-&gt;format(); // "1,250.00" It's not clear why formatting from a default of USD will result in GBP.
&gt; Acceptance tests are the conditions your client defines pretty much stating that: "these have to pass for me to accept your work". These usually are functional tests ( "user must be able to log in" ), but they can also be performance tests ( "the page must load in under 0.3 sseconds" ) It's usually difficult to describe an acceptance test formally if it has anything to do with performance... I'd not classify an acceptance test as such personally...It's so variable and often difficult to verify outside of a production-like environment. Personally: * Unit tests (and TDD) prove that you built the thing right... * Acceptance tests are used to verify that you built the right thing &gt; But if my client doesn't care about that log it's not an acceptance tests. If your client doesn't care then the value in doing it to the business *may* be dubious. 
In my experience I have often coded features that the customer wasn't really aware of, nor would understand them. E.g. automated css/js minimizing or something like that. I would then have a functional test for that feature, but it in now way would qualify as an acceptance test. I like this quote a lot though: &gt; Personally: * Unit tests (and TDD) prove that you built the thing right... * Acceptance tests are used to verify that you built the right thing
the reason they suggest using a vagrant box is so you also get a run on how setting up your own server works. but yes, for learning php and testing, the built-in server should do just fine. 
For what little it's worth, I also wrote [this](https://github.com/IcecaveStudios/near) before learning about Box. Same idea again, but with the goal of deriving as much information as possible from the composer.json file (eg, the CLI entry point). Edit: Apologies for entirely absent documentation :(
I used to have a pre-push hook script setup with git that wouldn't allow me to push unless I had unit tests for the code.
I generally use it if I want to run something locally and I dont want to start a webserver like apache etc.
Shameless plug in case such a thing is useful to anybody: https://github.com/IcecaveStudios/duct 
This article is so poorly written.. gah.
How much better though? Still stuck in XML config hell and unnecessarily complicated directory / template structuring? Magento is so bad that I feel the only thing they can do is a complete rewrite and then call it Magento 8 to make it clear that it's nothing like Magento 1....
Where do you find all of those buttons? 
I only do it if I want to test something quickly. Also sometimes when I want to share arbitrary files to another computer on the network.
Your -&gt;to() conversion converts USD to USD in your example.
I use it regularly for running small projects. Setting up Apache takes too much time, the built in webserver just work.
Please can you try again and let me know what error you're seeing, either here or https://twitter.com/MrDanack It's not good if people are unable to make their voices heard during such a critical time. 
Maybe I was just doing it wrong? I signed my email up for the php.internals group on the php.net list subscription page, but never got any emails, including one to confirm my subscription.
Maybe reference this.. https://github.com/puphpet/puphpet/issues/894 Otherwise, note sure.
Use Docker? Fig is great if you need more services than just PHP.
I never touch it, but then again I've always been a linux guy. Creating a new project in a new directory and a new webserver config is downright trivial. My dev laptop has dozens of apps on it, reachable at http://local.productionhostname.com. I get using the built-in web server if you're on Windows, and to a lesser extent if you're on a mac.
I use it entirely for development. My [pre-built Vagrant box](https://github.com/brightmarch/vagrant-box) doesn't even come with an HTTP server, the built-in server is all you need.
*I* would suggest PHP for every project! But I like PHP .. :P In saying that, I think you might be getting it backwards when you say Joomla/Wordpress would be overkill, it will probably take you a few hours to set up a reasonably looking website in Wordpress, but it would take you the same time just to do the backend on a basic site without the design.
I see what you mean. I think I worded that wrong. What I meant by overkill is that Wordpress and Joomla come with much more options and features than this website will need. Also, I have designed websites (HTML) from scratch and I have used Wordpress w/pre-existing themes that I have edited. I am not really familiar w/the process of creating a Wordpress theme from scratch but if I used Wordpress, that's what I'd like to do. I know you can tell from my description of the project that it isn't a huge project but I really want to learn something from it. I've used PHP some in the past, I have edited other scripts to suit my needs, I've done the Code Academy courses. Do you know of any tutorials that go through using PHP to add info to a database? I want to make sure I do everything right. I created a Fighter Database for a MMA event in Vegas a couple of years ago and it actually worked (I was impressed with myself. you could add/edit fighters and their profiles, they had a profile page on the site that got it's info from the database, and you could even create a fight card w/it) but I found out the way I created it was wrong even though it worked, it was not secure. 
That's great! I'll take a look into it. (Looks like Box needs a better PR hahahaha)
I use Travis CI, so after every commit (either to the main repo or to a branch in a Pull Request) it runs the full unit testing suite. Pretty nifty.
My goal with Puphpet was so I don't have to learn any sort of server setup. I like to write code and engineer, not write config files. Thanks for the link though. 
I rarely develop on my laptop (low specs, Linux OS) so the built-in web server enables me to test smaller projects without needing Apache, vhost files, and all that.
Well, the specific things that were whined about *with regards to being a real OSS project* got better. I won't comment on any improvements made to Magento itself, as I'm quite intentionally ignorant of them. 
Like php -f x.php or php -r 'exit;' ? You don't need a web server for that.
That's like saying you can't learn PHP without learning C first.
So the first option may actually be not to build it... At least not via programming. But instead to use some of the good hosted services out there like squarespace or hosted wordpress. Brad The second would be use a cms (prob wordpress). That'll give you more options, but also more things to maintain. Another option to consider is static site generators
If you're going to use Vagrant for this you should be using [Docker](http://docker.io) as well. Vagrant can be used to easily manage the Docker container for development, and you can use [Packer](http://packer.io) to handle production packaging/deployment. 
Thanks. I am going to go the PHP app route. I have done something similar in the past but honestly, I didn't do it the "right way". It was not secure at all. I need to find a tutorial or something to kind of "guide me" because I want to make sure that I really do things the way they should be done and not do things "my way" just because my way works. 
Setting up and configuring a webserver on windows is just as trivial as it is under linux.
3\. instead of reading zend's source code, you can read [facebook's php spec](https://github.com/php/php-langspec/blob/master/spec/00-specification-for-php.md) Job market for PHP in US/Canada is good. It's not just about knowing PHP, it's about knowing good programming principles, OOP, design patterns, algorithms. It's hard to give any specific examples, but merely knowing the syntax won't get you very far.
It's tough. On one hand, I think breaking PHP4 is fine and almost necessary, but on the other hand I see the merits of keeping it working. I come from C++ so I'm used to the standard just adding new features and maintain full BC, but PHP has a lot of WTF-syntax that needs to be rectified or removed.
Its clickbait. 
http://www.reddit.com/wiki/selfpromotion Cmon dude.
How often does the Zend Framework change and how much trouble am I in running an ancient version? I've inherited a codebase which, for some reason, was built by writing all new functions as code within Zend Framework. A number of the stock framework functions have been commented out and replaced with completely handwritten functions. Yes, even the views were somehow implemented as HTML embedded within the files distributed within the framework. The code is believed to have been written in 2005 and has never received an update (neither has the server). I don't even know where to start with this.
I've actually made a habbit of having my vagrant files in its own repository. Inside the vagrant directory, i clone my project to `./project`. In the vagrant configs, my sync directory points `./project` to `/var/www`.
Dont really need to mention StackPHP for this, do you?
What is codeception and how is it used?
&gt;Because I don't want to see a Python 2/3 situation... There is no use sidestepping the inevitable as you try with your RFC. Doing so will only put more warts on the language. PHP7 is a chance for the language to do stuff like these, so I think this is the proper way to do it...And I don't think it will be too hard to write static analyzers to find the breaks, if those can call the php interpreter and use it to find cases that result in a break. Making a fixer might also be possible for simple cases.
Hi! You don't actually have to commit everything inside the puppet/modules folder. If you want, you can install [librarian-puppet](https://github.com/rodjek/librarian-puppet) which will read the `Puppetfile` and grab all dependencies.
Been browsing the site. Never heard of Magento and the site isn't helping any. All I could figure out is I can install it with composer. This is the first time I haven't been able to find the FAQ page. :/
One hopes you are trolling about Tony Marston being in any respect relevant.. But if you read the RFC, this is precisely the approach being taken: &gt; PHP 7 will emit E_DEPRECATED whenever a PHP 4 constructor is defined. When the method name matches the class name, the class is not in a namespace, and a PHP 5 constructor (__construct) is not present then an E_DEPRECATED will be emitted. PHP 8 will stop emitting E_DEPRECATED and the methods will not be recognized as constructors.
you missed the point.
How does one become a voter? And why don't we just remove PHP4 constructors immediately with PHP7? There's enough backwards incompatibilities that PHP5 code won't "just run" in PHP7, isn't there?
Magento is an e-commerce application and framework. Version 1 was built around Zend Framework 1.x. 1 suffered from being built in the early PHP framework days, before many in the PHP community figured out what best practices really should look like. Some consider it poorly engineered, but it's the opposite engineering problem you see in most PHP e-commerce applications: it's *over*-engineered instead of *under*-engineered. I've never looked at Magento 2 before (it uses a [non-standard viral license](http://rosenlaw.com/OSL3.0-explained.htm), and my day job involves e-commerce applications), so for all I know it's fixed some of the more glaring developer annoyances. 
I support this one, some legacy stuff needs to go. 
&gt; Running simple scripts 
If I want to create a caching layer in my application with, say, Redis, how do I go about that? I mean that more from an architectural stand point. Let's assume a Controller, what layers does it know about? Currently it may look a bit like this (simplified): class HelloController { // ... public function indexAction($postID) { $post = $this-&gt;postRepo-&gt;findOneById($postID); return $this-&gt;render('post_view.html', [$post]); } } The controller shouldn't know about the caching layer, right? So who does then? Neither should doctrine. Should it be implemented by using event listeners and therefore integrate with doctrine? I'm a bit lost here, so thanks for your help.
Why not apache?
Isn't this BC break trivial to fix with grep and some regex magic? Sure, there might be some corner cases and you'll have to modify the fix in order to apply it to different projects, but if you don't have a good enough test coverage to catch any issues that might result from doing this, you have bigger problems to worry about.
It's a good read. He lists lots of points, and disagreeing with each one is just too easy, and kind of backs up the point that this change needs to happen. 
All sorted now, thanks!
The first one is from Travis CI as part of the CI package and the rest are from [Badge Poser](https://poser.pugx.org/)
I see where you're coming from and that's a great idea. The idea is to have a range of formatters so you can work with it how you want. The decimal stuff has been fairly light touch as I'm still researching how different currencies do their rounding and how best to implement that. As it stands, any currency can be in decimal form such as 12.3456, but will be rounded on display. I'll add it to the roadmap!
I'd just like to say; using Vagrant (or similar tools) to mimic your production environment is a good idea regardless of what operating system you're running on for development.
&gt; what and why of the function rewriting I've spoken to the lead developer, who still is actually the lead developer. Apparently it's a good way to design things and he likes it. Kill me. 
We've got a restful mocking system for integration tests - we can register expected requests and their responses so it looks, to all intents and purposes,like the remote API the code is calling. This system itself is heavily testable, and one of the integration tests spins it up using the PHP web server (our production CI system uses Apache) and runs some basic assertions against it.
I've had to do with Houses before and there are a lot of systems that already collect all the information you need about them to use. Most are admit-ably not the best to work with, but for small projects with only a few updates every once in a while, they should work. But in general, yes, php is a good tool to achieve that goal. It's definitely a good practice if you are looking for that. If you plan on trying to do it, build the page itself first and then try to automate individual parts one by one. It's definitely a doable project for someone with basic php experience. As long as you are willing to learn and keep trying.
For internals stuff, you should start with [PHP Internals Book](http://www.phpinternalsbook.com/) and not the spec which, by being a "specification", is not about the Zend implementation.
As raddat also comments, that's a bit outside of what I'd call running a simple script. I of course see there being a (IMO tiny) use case where you need a web server, but don't want a proper web server like Apache bound to localhost. I was just asking if my examples were what FranOntanaya were thinking of.
Be honest will that have any impact at all? Based on passed evidence that I have seen, I don't think calling him out will do any difference. He is one of the original developers you know, whatever meaning that may have... . Which on the other hand really tells a lot regarding valid arguments. I've seen the discussion with Anthony Ferrara (who really makes arguments Why A or B) who is from another caliber and the disrespect shown or the condescending tone for his arguments doesn't bode well if any of us mortals would call him out. It is clearly not a nice guy when you have a different opinion, which is a shame. It would be better for PHP if that would be different, regardless of pro or contra for scalar type hints imho. The only meaningful thing that I could do is make sure that the things that I release are also working on HHVM and also stress compatibility in my documentation. In the end it was just a simple line to be added to my .travis.yml file to be sure it also works on HHVM. It is a certainly something that I will keep a closer eye on for those who want an escape route out of this madness. It's funny how a year ago I was extremely against the idea, but I really starting to hope that HHVM gets more traction. 
I generally use it if i want to run something but I don't want to start a server on my computer.
What? They do different things.
I&amp;hellip; don't understand the question. You want to expand (extend?) PHP's library? What does that mean? Developing PECL extensions?
&gt; So then you'll wind up with analyzers that tell you perfectly valid code is invalid. "But it works for me...?". "It says it's wrong, but I still get the right answer". I'm not convinced this matters. Static analysis is an advanced tool, anyone using it would understand the point of using it and isn't going to say those things. &gt; And that's not even coming to the point that static analysis with strict types works both ways (you can infer about types before the call due to the call). Again, I don't see why you need actual strict types in the language to do this. The whole point about SA is that it doesn't actually run the code... so why can't the SA tool just act like the types *are* strict?
thanks for you ,I have learn C program. Because I must use some feature that PHP don't have. Some API written by c ,I need use it in my program of PHP.
As in, scripts with a web UI. Input and output sometimes is unwieldly on the terminal.
Are you seriously trying to condemn an entire language because of parameter ordering? That argument is literally old enough to drive.
Did you even read the RFC?
Nice work, keep it up! :) Also there is documantation link which describes the project better: http://docs.isolate-project.org/
Definitely took a few years for it to click to the point I didn't really have to think about it. Exposure to different systems helps a lot. It's all experience, really. Once you've worked with a few clients wanting blogs, you'll work out the common features that are required and you'll find your direction. 
Unfortunately an upgrade to Cent 7 was slightly difficult (though we have since done it). The upgrade from apache 2.2 to apache 2.4 required some work, as did a couple other things. Also comparing HHVM on Cent 7 to PHP 5.5 on Cent 6 wouldn't have been a fair comparison. The kernel in Cent 7 is much newer and comes with some performance improvements. Also it turned out that actually going through the work of compiling all these things from source gave me a much greater understanding of how HHVM works, and what it uses all these libraries for.
Really great job. Here's the sample project which can be helpful to start working with isolate: https://github.com/norzechowicz/github-manager
It will be a long time before Java is "de-throned" in enterprise land. Two reasons for this, the staggering amount of existing tools/libs/etc Java brings to the table and the readily available pool of developers. Not many PMs or tech leads at your average enterprise shop are going to risk their jobs implementing something new. To paraphrase, no one ever got fired for selecting Java. To jump these hurdles, Facebook would need a massive PR movement and a much deeper ecosystem for HHVM/Hack to make any kind of dent in enteprise land. That's just not going to happen for a long time.
It's pretty useful for testing, especially if you have acceptance tests for an API. You can spin up the built-in webserver, run your tests, and spin it down. Bolt CMS does this: https://github.com/bolt/bolt/blob/master/run-functional-tests
"There are folders for things I didn't even ask to be installed, like java, erlang, epel, mongodb, solr, sqlite. I was going to delete everything I don't need, not sure if anybody has any insight into this." Just remove any modules that you dont need (and dont include it in your manifests .pp files) and check if there are errors after vagrant destroy + vagrant up . PuPHPet is only for simple projects imo - move to pure puppet (.pp manifests + modules) if you want to do some more custom/advanced things and to have more control.
I understand you want to learn PHP but I really do not think re-inventing the wheel is the way to go here. There are many CMS systems you can utilize that will make maintaining this site easy as pie. I would suggest a book on PHP that teaches by practical examples... but that's me. (I don't have any to offer because I haven't read one in a long while)
&gt; This is why I really want PHP 7 to get static type hints &gt; static type hints &gt; static
&gt; Most PHP5 code that is clean of E_STRICT and E_DEPRECATED notices in 5.6 should run properly under PHP7. This is true, and I like the idea in theory, but in practice I'll almost never have a non-trivial codebase where I have full control over all the source that might throw an E_STRICT. For some apps, preparing for PHP7 is easy, but for many the migration requires me to completely replace old libs now because they're throwing E_STRICT + E_DEPRECATED. Don't get me wrong, I'm all in favour of removing embarrassingly obsolete syntax like this. I just want it clear to anyone following the thread that cleaning up deprecated code can be a lot more work than simply cleaning up syntax.
They probably use their work laptops for gaming too. It'll be more work to setup a dev env on Windows vs linux, but nowhere even close to the amount of extra work to setup most games on linux vs Windows. Plus if you're on Windows, you can easily setup a linux VM for development.
Coming from other languages, I would much rather see it the other way around. Just have constructors with the same name of the class.
Not exactly. That statement doesn't quite make sense since there's not really anything you can't do with drupal. Out of the box features of Commerce+magento would be the start of a discussion sure. "They *don't* do different things." Googling doesn't show me much. Mostly being only an ecommerce app with poor cms capabilities. Almost all the literature leaves me wondering why someone would pick magento over drupal thus my question.
Debian on all of my servers for the last 10+ years. Sometimes Ubuntu, if a customer wants it. For serving websites with PHP I either use nginx or Apache with EventMPM and PHP-FPM. I won't get into which OS version, because it's clear that you should always stay up to date with their latest releases to get all security updates.
i have read the website but i haven't seen it in action or anything
If what you say is true, it sounds like you're severely doubting yourself. That being said, a good senior needs to do more than just PHP. You need to explore other languages and technologies, their pros and cons, and apply some of that learning to PHP.
One of the hallmarks of knowledge is understanding just how little you know.
IMHO, The last thing you need to learn is that anyone who professes to be an "expert" is probably a poser. Most of the professional programmers I know - PHP and otherwise - are constantly learning new things, constantly pushing themselves to do better, faster, etc. Remember this "Amateurs practice until they get it right, experts practice until they can't get it wrong. " - Faith Duck (http://www.art-quotes.com/auth_search.php?authid=1725) Keep practicing. :) Cheers! =C= =C= 
Debian because I know it very well and have been using it since over a decade as my preferred server OS. I've had servers with Gentoo, Fedora, Suse etc. as well but Debian just makes the most sense to me. It's purely a personal choice.
&gt; I've seen the discussion with Anthony Ferrara (who really makes arguments Why A or B) who is from another caliber and the disrespect shown or the condescending tone for his arguments doesn't bode well if any of us mortals would call him out. I hope you realize that's me (I'm Anthony). :-D I think part of the problem is that it feels like it's only me trying to call him out. It can (and does) feel like I'm a crazy person for caring when 2-3 people keep spewing garbage. You stepping up and calling him out may not impact his behavior, but it helps massively those of us who do care. And it helps the greater public to see that it's not really 3:1... Especially since he's got so much clout in the community that many assume he's correct (even when proven that he's not).
&gt; PHP7 is a chance for the language to do stuff like these, so I think this is the proper way to do it... And kill the language. If you thought 4-5 adoption was bad and slow (which really did nearly kill the language), 5-7 will be worse. Because the changes to object behavior wasn't subtle. It either worked, or it didn't. With this change proposed by this RFC, it'll sometimes work, and sometimes not. Your tests may all pass, but when you push to prod, everything comes down. Because it's based on values, not types (even the 4-5 switch was mostly type based). &gt; Making a fixer might also be possible for simple cases. Simple cases won't be the problem. It's the complex ones that will kill adoption.
Is it possible to create additional custome flags for the [filter_var](http://php.net/manual/en/function.filter-var.php) function, without altering the source code? Maybe using reflection?
One person? Definitely not. But these antics will continue to happen until the community stands up and demands they stop. So write an open letter instead and get people to sign it. Do something rather than sulk (please? :-).
Magento offers an insane amount of out of the box functionality, while being hard to extend and customize. People tend to leave Magento because they yearn for better CMS functionality and better DX (developer experience). On the other hand, people tend to leave Drupal because they yearn for more prepackaged functionality. (Disclaimer: I'm one of the people behind Drupal Commerce)
&gt; However, when I see some jobs ads asking for senior developer, I feel I would not be able to fill that position. You already have! Directing projects? Comfortable with multiple coding styles? You're good to go. As for feeling like an "expert": don't worry about it. I've been doing PHP for 11 years (since the days of 4.3...yikes) and I too feel like I can do anything. I won't call myself an expert because I feel like there is always more to learn.
Because it's not needed, simple as that... not for developing routine WordPress sites at least.
Okay, thanks :)
Always include it for libraries and for projects. If your library is a dependency composer will ignore it. If someone is trying to build your library/project (especially to run the test suite) you want them to use the same versions you did, not new breaking ones. Otherwise your "pass" badge means nothing.
it's not just a "great idea", it's the correct way to handle currency calculations on computers.. - avoid floating point numbers and stick to integers.
I'll just leave this here http://en.wikipedia.org/wiki/Impostor_syndrome
Learn a different language and become very proficient on it. I recommend Java or Python. This will broaden your mind and give some perspective on what PHP is good and bad.
&gt; I realize I could go with something like Joomla No. No. No. No. Never Joomla. Never. Ever. For a while I had a 15x6 wall in my office dedicated to print outs of memes that expressed the agony of working with Joomla. I want you to imagine a short distance between two points, and then imagine the worst possible way to get there. That's Joomla. So anyway, I know you said you want to learn this rather than just throwing a canned solution at it, but this is a good usecase for Wordpress (not saying you should use it, just pointing it out for reference). IMO there's no such thing as "overkill" - either a tool gets you there fast, or it doesn't. What it does and doesn't come with, and whether you do or don't use all of it, is of secondary concern. If you were somewhat familiar with Wordpress, you could probably have this site functioning in the space of 2-3 hours, and then styling would of course be up to you. That said, since you want to learn this, I would at least build this in the context of a modern framework. Going commando in PHP is fun and all well and good, but using a framework of *some* kind (Slim, Silex, Laravel, Symfony) would be advisable. It's a good tool to have in your belt. If you go with something like Laravel, you'll have secure authentication done for you out of the box - just need to hook it up to a form and you're done. It will take you far longer to learn a framework than it would to build the site in it, but that's fine - invest some time in learning it now, and in the future you'll be able to get things done faster.
I use Sublime Text. And once again, it takes maybe a second. There's no reason *not* to at that speed--plus I get instant feedback.
Check out http://phpixie.com . If you spot any boat there I'll buy you a beer =)
That article, while enlightening, is just one big appeal to tradition. "We've always done X this way, and I want to keep doing X this way!" It'd be one thing if he was a core developer making a case against the change, but he's not. Frankly, if the core developers want to eventually strip out PHP4 style constructors (which are what, 15 years old at this point?) because they believe it's technical debt, then more power to them. Having two official ways of constructing a class is silly (note: I'm not talking about method overloading, which I think is silly anyways but whatever). Railing against this RFC in this manner is like railing against refactoring a code base to remove cruft from ten years ago that's holding back the application because "then I'll have to grep some files and change a few things!" &gt;One problem that I have heard about is when someone creates a non-namespaced class with a method which has the same name as the class and they do not realise that the method becomes the class constructor instead of a callable method. This is ignorance on the programmer's part and not a fault with the language itself. If they cannot be bothered to read what the manual says about constructors and destructors then they have only themselves to blame. &gt; A second problem is when a subclass wishes to call the parent's constructor and doesn't know whether to use parent::_construct() or parent::&lt;classname&gt;() or even if the parent has a constructor in the first place. This situation could easily be rectified in PHP RFC: Default constructors. It's absolutely a problem with the language for introducing the ambiguity in the first place! Whether or not `classname` or `__construct` is the "correct" way to instantiate a class is a completely different matter. And obviously it's causing some issues for people if `MyClass.myclass()` is defined in the hierarchy but someone didn't know that and tried using `parent::__construct()`. Moreover, having a *consistent* name for a constructor makes much more sense *to me* then naming it after the class. I could just `?__construct` or I could write some complicated regex to find the constructors for me.... I'm actually surprised he didn't draw a comparison to the Python community where we have Python 2 which is "supported" but is widely used and 3 which has a lot of cool stuff, but backwards breaking changes has held up many people from adopting it into their business. Hell, even Python 2.2 introduced a huge change: a unified object model which resulted in old and new style classes. To take advantage of the new features you *have* to inherit from `object` And to nitpick his note about Python constructors, it has a both a constructor *and* an initializer: `__new__` constructs the object and `__init__` sets the initial state. Most people don't bother with `__new__` unless they're attempting their manipulating a cache of objects or something.
It's not about the language, it's about the concepts :)
Technology is leaping forward at incredible pace. This goes for any programming language as well, specially for php. So, it is impossible to be at the top of the skill chain, even if you know php well. As there are just too many new tools and ideas coming out every week. I have been into php for 3 years now, and the more I learn, the more I find out I am noober than I had tought. It used to bug me a little, but now I have made my peace with it.
Define "bloated"? At any given time I only use about 1/5th of the features in Laravel. The fact that those features are not being used doesn't mean the tool is bloated, it just means those features aren't being used for that particular project. They do no harm. I have a painters multi-tool that comes with a slot to fit a hex driver in it for some inexplicable reason. I've never used it. Does that make the multi-tool bloated? Meanwhile the stuff that I do need to use, allows me to get to my end goal extremely quickly.
Hi, I've got certified last year Study from PHP.net, pay attention to array function, date, file upload, closures and know the most important things about php 5.4,5.5,5.6. Good Luck
I see a ton of posts on here trashing various frameworks, or people spreading misinformation about using frameworks in general. Sometimes it seems like this advice comes from people who have no experience with a large behemoth of a project. As an example, you seem concerned about how "bloated" frameworks are - what does that matter to you? If you have a garage that you work on your car in, do you only have the tools in there for the current project you're working on? You are thinking about frameworks and the advantages the wrong way. What I'm referring to here is building an actual product with end users and strict requirements, something I have experience in. Even though you are only interested for personal projects, learning these frameworks can help if you ever decide to create a product. Whether or not to use a framework, as well as which framework to use, depends on a few factors. I'll break them down by how I usually determine the need. **How big is the application?** A very large application without a framework and lacking a consistent architecture will fail - *especially* if there's a small amount of developers working on the project. Large companies can get away with more complex, intertwined code bases because they have the workforce to maintain it. If you are a single developer working on a large project, consider a couple things: - You only have so much temporary memory. There will come a time when you can't remember everything about the project, which is where organization of a framework comes in. - Technical debt can kill you. If changes for small feature modifications or bug fixes take up a great deal of time, you're screwed and your product will fail. This is where a good framework coupled with good architecture decisions comes in. If you're familiar with the general architecture, then you don't need to remember every nook and cranny of the codebase. Figuring out bugs as well as designing new features should be an easy task. You should be able to navigate a well designed and architectured project easily to figure out where bugs are coming from, or where to put the code for this new feature. While you can achieve this without using a framework, you need to be an exceptionally good developer and always stick to the architecture you designed. I've seen projects that start out well designed but due to the fact that they were designed from the ground up, begin to crumble. Dirty fixes thrown in to places they shouldn't be, features shoehorned in ways you didn't think possible. While using frameworks doesn't prevent this, it definitely helps in bigger applications by providing a well organized structure and documented conventions. **Will the application need to grow or change in the future?** Another big one here - after you build the initial product, is it going to need to change? In some cases, this answer is no - it might be a one-off project that you don't care about. However, if you plan on having paying clients, the answer to this question is **yes**. At some level, your customers will dictate your product. While it is bad practice to let your customers control the product 100%, you're going to need to add features to respond to the market. The question is, will you or your team be able to keep up? Using a framework will allow you to speed up development while still hopefully writing maintainable code. Again, this goes back to frameworks having good organization and documented conventions. These are a great help to an exponentially growing codebase. **Is security a concern?** I hope the answer to this is yes, and if it is, use a framework. Frameworks such as Symfony have a large support community behind them, and security issues once disclosed are rapidly fixed. A great amount of PHP users seem to have this notion that the public disclosures are bad or a security risk. In my opinion, this is better than the possibly undisclosed security issues in your home-grown codebase that you will only know about when it's too late. Most frameworks such as Symfony help protect against common issues like CSRF, SQL escaping, and XSS attacks. Is it possible to write an entire application without using a framework that doesn't have a CSRF vulnerability? Sure. But at least with a framework using the defined conventions, you can be very sure. **What is the development timeframe?** This one doesn't really need a lot of explaining. A framework will provide a ton of boilerplate code for things like routing, authentication, and templating. Once you are familiar with a framework, bootstrapping a new product is easy. You can get the annoying things not related to your business operations (such as form submissions or database stuff) done very quickly. The best part - in the future, if you need to extend or change the way some of these things work? Most well-written frameworks provide enough abstraction that this is easy to do later, when the time is there to do it. **What framework do I use?** This is the hard one, but I personally always use Symfony for every project. It takes a while to get familiar with it, but it allows a great amount of flexibility and has a very powerful and extendable authentication system (that's my favorite part about it). I can't speak for Laravel since I've never used it. I used CakePHP years back, but it lacks many of the advantages of frameworks I spoke above about. Pretty much the only advantages are consistent conventions and rapid prototyping. It doesn't lend itself well to large projects and I would not consider using it. I hope this helps a bit!
Hi all, I am very new to PHP. I am on a co-op as a mechanical engineering student and I am working on a project that incorporates and arduino microcontroller and a RaspberryPi. So far I have not run into any issues. I have an apache webserver set up on the raspberry pi which is connected to the arduino. I have made link buttons on the webpage that function properly. I am running into problems after the button is clicked. I want to run a python module when the buttons for the web pages are clicked. I have searched for hours but cannot find a way to do this. I have tried using exec() and system() but I have not had any luck. Any suggestions?
Thanks!
learn other languages. imho, nothing gives you more insight in paradigms and techniques as learning a language that does things in a totally different way... good options are java, C, C++ Or try to build some components of a framework from scratch, like an mvc dispatcher, a router, templating engine, etc... Last thing I would say that helped me a lot is: work on many, shitty projects :)
This is exactly what I came here to post. I've been a full time developer for just under 15 years. I've worked on early social networks, disaster management software (think: BP oil spill), major internal government projects, celebrity websites, et cetera. Won awards, was a teaching fellow at Harvard, whatever you can imagine that looks good on a resume. I *still* get that feeling of inadequacy when starting a new job. You can't let that kind of self doubt prevent you from applying. You just push through until that uncomfortable feeling passes and you realize you know exactly what you're doing. 7 years of experience is more than enough to apply for a senior position. Really, in my experience hiring developers, the difference between junior developer and developer is where you're expecting the greatest increase in knowledge. The difference between a developer and a senior developer is often more about being a self starter, understanding how your job is creating value for the company and knowing how to spot when there's a major disconnect between what the client really wants and what they're asking you to provide. And most of that comes down to experience. So, short version, don't stress. Apply, let your knowledge shine through as best as possible, and confidence will follow.
Ive been in the game 5 years. I am humbled everyday.
OK you are right about my "bloated" comments, I just come from a security Linux engineer background and basically the rules I stuck to are if you don't need it on the system get rid of it as its just another possible security entry point. I guess with the frameworks I would like to have the bare minimum and then add the extra bits and pieces I need. Also there is a lot of miss information out there. I started looking at slim, then I read about this problem or that fault or the community being tiny. I just want to make the right choice as I haven't got the time to try each one for its merits etc.
Ubuntu 14.04 also: * I'm lazy and use (X)ubuntu on my desktop machine so I don't have to remember apt-get vs yum vs anything else; similarly for other setup stuff * I like the documented, predictable release schedule of Ubuntu. I know I can update an LTS in 2 years, or wait for 5 years if I prefer, but still get security updates etc. I think this is often overlooked but it's a good facility to have.
i see no advantages of it. specially when extending the functionality. In java for example you need to put the constructor over and over again in every class and make sure you don't use the name of a method the same as one of the extended classes, for example a Widget class with a widget method is not a good practice, but if you have WidgetForm extending from Widget then WidgetForm::widget() sounds completely rational and logical. __construct() might not be the best syntax possible and yet I see it more easy to extend since once I open any class i know exactly what to look for.
how is that an argument?
Could someone explain the best practises for stopping Duplicate Submissions when users refresh the page, etc. I've been reading into Post-Redirect-Get somewhat but I'm not sure how I would go about implementing it, so any resources would be great. :)
I make the analogy like this: If you're doing home repairs, you don't open your socket set and say "shit, I only know how to use the 10mm socket, I can't use this 11mm socket". If you understand 1 procedural language, the odds are incredible that you can pick up another one near instantly.
&gt; If you are worried about this, you shouldn't be using PHP....Seriously. I think this is the essence of what the 'internals' guys have been saying. If your use case needs to be that tight, please use another language... Right. Because PHP doesn't support this mode of typing. Except with objects. Oh yeah, that's right. PHP is already doing *a lot* based on types, not just values. The case here is enabling a strict mode for scalars allows them to behave using the same type system that objects use (hence unifying the problem). &gt; You think it would be too hard for the teams behind the big projects, to fix the breaks if there is a syntax analyzer that can point to the bc breaks in a code base? I honestly don't believe you can build a static analyzer to do that *for these types of breaks*. Yes, you may be able to pick up a few here and there, but in general it's going to be extremely difficult to detect. Heck, 8% of PHP's internal test suite breaks due to this change. 8%. Let that sink in. 
&gt; Start off with answering ... what needs caching? No. Start off with answering "what in my code is actually slow?" Do code profiling *first*, then fix your code. Only when you can't fix your code any further should you consider introducing data caching. 
Yes, sadly that's a big inconsistency, but signatures should be enforced (not relaxed) in both cases. If you really need a workaround, just leave the parameter list empty and use `func_get_args()` inside the method.
Some people have replied ( not on reddit ) that having it like that is the intended "proper" way. So I guess its up for discussion
&gt; Isn't this BC break trivial to fix with grep and some regex magic? Even better, there's already a tool to fix it. http://news.php.net/php.internals/82097
Developers of every programming languages except php hates php for that fact, it took away their job. most of the highest website / web applications run in php. 70% of the websites in the world wide web uses php. Is that akward? I dont deny the fact php lacks a proper networking because of the lack of sockets and threads which is a primary requirement for any enterprise application. But when it comes to web development php is arguably the best out there and will remain so atleast for the next 5 - 10 years
&gt; At that point, you would have to consider yourself more of an expert than the vast majority. I've never met anyone who referred to themselves as an expert who wasn't a raving douche. It's a word other people might apply to you, but never apply it to yourself.
Thank god, I've found a programmer 3 years older than me :') 
I suspected that there might be, but was too lazy to search for it, thanks.
AFAIK the main use case for UoW is with persistence (repositories). Are there any other use cases for UoW? For reference, Doctrine has UoW in the ORM component, coupled to the EntityManager.
I don't know why this change wasn't made with the 5.0 release.
But i liked tabs more than spaces :(
Taken from the php documentation: &gt; This web server was designed to aid application development. It may also be useful for testing purposes or for application demonstrations that are run in controlled environments. It is not intended to be a full-featured web server. It should not be used on a public network. And that is what I use it for. Development, testing and demonstration.
Is ok do something like this: $value0 = 'some value'; $dummyArray = [ 0 =&gt; 'value0', 1 =&gt; 'value1', 2 =&gt; 'value2', ... ]; $$dummyArray[0] = //do something in here; My concern if is ok use '$$' when the last $ it will get the value name of the array.
The reason intval is bad here is that instead of checking for invalid input, it turns invalid input INTO an integer. Meaning you could be accepting a string or other input and just transforming it. It'll *work* but it wont work as expected.
IIS7, because the people that worked here before I started hate me.
Even if you had a point, half the time the PHP script finishes 40-50ms faster.
I found an instance in our production code where a senior developer JSON encoded the PHP session into a Javascript variable. Is this universally bad practice or am I overreacting? He only needed one value out of the session, but he exposed the entire thing.
I have yet to see Hack on a job posting. Even facebook don't list Hack as a requirement. 
Technically, this counts as data sanitization. It's exactly the same as running unknown input through htmlentities() or similar function. I contend that it will work exactly as designed, ie turning anything numerical-ish into an integer and anything else into zero.
You do realize we can't tell you anything constructive from screenshots. Well I can tell you to grab a front end framework to make it look 'pretty'. Just as a comparative, here's a single shot of the developer panel from a current project : http://i.imgur.com/Z0V0LWk.png The only reason that looks good is because I used Bootstrap. If you got questions about building the CMS out, ask. I would ask how do you plan to handle menus and what type of templating system is going to be available for the front end. What security measures are in place? What's the method for storing passwords? 
And a collective "ok, cool" was heard from space.