Shouldn't support be ending on the 20th (28 days), rather than the 10th (18 days)?
Laravel is the future.
Very nice, will check it out sometime. The only reason I wouldn't commit to this is down to confidence, it is "new" and literally has not been around a while, so becomes hard to sell to project managers and the-like. (Who prefer "known" over "good under the hood"). The major point out for this is no "selling point" on the website, the landing page has code, doesn't list any companies and throws out model terminology, very confusing for a non-dev, so I wouldn't be able to present it easily. (Where as Symfony shows you well-known project names and has a case study page), though these take a long time to come up as they're out of your control, so understandable :) The templating syntax I also very dislike (mixing {{ }} with &lt;% %&gt; just feels odd to me... It's why I like twig, its always {} or {%}, i don't switch symbols for different code). I also like Symfonys docblock routing vs writing it in function, allows my functions to stay as functions, that is just personal taste. Anyway, to me it looks great, the only gripe I think needs work is the documentation, it feels like a huge text document all blending together, especially as code examples have a white background. Comparing [your routing page](https://www.opulencephp.com/docs/1.0/routing) to [Symfony routing page](http://symfony.com/doc/current/book/routing.html): - Symfony code is completely obvious as it sticks out. - there isn't any heading colours on Symfony docs so it is very clear what is a heading and what isn't (aside from sizes) - the line height is much better, Opulence has everything super bunched together. - Your notes have inconsistent padding, a lot of space wasted due to paragraph margin 
this is probably the worst type of environment to work in.
just replace the 2.0 with a 7.1 and watch 
I definitely understand the "new" problem. I think right now, since it is so new and won't be used on huge new projects, I'd rather advertise to devs to get them using it in smaller projects. Once it's gained more of a following, I think your suggestion is a good one to market to PMs on the homepage. I chose the {{ }} syntax because it's pretty pervasive across templating languages for outputting data. As for directive delimiters &lt;% %&gt;, I personally felt like making more of a distinction than Symfony did when differentiating outputting data and logic. However, I totally get everyone has different opinions on delimiters. If they bug you, you can [change them](https://www.opulencephp.com/docs/1.0/view-fortune#changing-delimiters). I love Web API's attributes, and I wish PHP would adopt them. Until official attributes are adopted, though, I'd prefer not to (IMO) pervert comments with code. It's a controversial issue, and that's just where I land on it. As for styling (I'm not a great designer), I agree the styling can use some work. Now that I look at it, it does look a bit bunched together. I'll address this. I really appreciate you taking the time to break down what you like and don't like!
I do have a private Trello board with future features, but nothing available to the public. Issues/bugs should be [submitted via GitHub](https://www.opulencephp.com/docs/1.0/contributing#reporting-bug). Since I officially announced Opulence last night, it is a good idea to implement a public feature wish-list to encourage community contributions. I'll port some of them over to GitHub. I appreciate the enthusiasm, and I encourage pull requests!
How dare you compliment me! :)
One thing that definitely should change is that your split out repositories should contain the unit tests, not just the source.
Thank you! It's been a long road and a lot of late nights working on it. It's nice to FINALLY start sharing this with the world.
Thanks Paul. I actually read your blog. Good stuff!
Even php docs says they are discouraged: http://php.net/manual/en/language.basic-syntax.phptags.php PSR-1 Also does not allow them. https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md
Well you can configure phpunit to run your all your tests, even if they aren't in one tests directory. Look at how symfony does it in their [phpunit.xml.dist](https://github.com/symfony/symfony/blob/master/phpunit.xml.dist) 
I did something like this in a previous project with one difference: the Git commit id (first 7 chars) would be stored in an environment variable by a post-checkout hook, and the PHP app would read that. If it was blank, it would read it via `exec` and store it in the environment itself.
I was looking at the tests and was surprised to find: [\PHPUnit\Framework\TestCase](https://github.com/opulencephp/Opulence/blob/1.0/tests/src/Opulence/Applications/ApplicationTest.php#L19). I didn't know we could use something else than `\PHPUnit_Framework_TestCase`
In the docs, should the SQL Data Mappers "update" function really be updating every record in the table to have the same title? It'd be nice to show how to update just one record. 
To me it is just natural to want to read the unit tests along with the code it is testing. While I was evaluating your individual components, it seemed they had no tests.
Sure. Unnecessary comments are worthless (and if they're wrong, is an actual cost), and this might be a good example of code that shouldn't require any comments (as long as it's obvious what width and height represents, and why 10 was chosen). My comment was a response to "Don't write comments within a method" - which is something I wouldn't recommend following as a rule. Sure, the code should be as obvious as possible, but not all code is simple.
Valid point. Let me sleep on this. I don't want to rush to judgement one way or another.
Fantastic. I'm going to play with the system a bit to experiment at least. I'll file issues on the trackers for what I think can be improved.
What new architecture do you think can be built on php7 that couldn't be built on top of php5 and why?
On Twig: &gt; it requires learning a new syntax that differs from native PHP So does Fortune? Granted that PHP had ASP style tags before 7.0. &gt; it's more easily extendable than Twig So you can create your own tags, filters, and functions? I see functions in your docs. The main "ease" bit seems to be about using closures rather than extension class implementation (see `Twig_Extension`) to make things easier, but... $twig-&gt;addFunction(new \Twig_SimpleFunction('shout', function ($in) { return strtoupper($in); })); ...is not that much harder if you don't want to do a full fledged extension. &gt; doesn't require all the configuration that it does. $twig = new \Twig_Environment(new \Twig_Loader_Filesystem('path/to/templates'), [ 'debug' =&gt; isDebug(), // or whatever 'cache' =&gt; isDebug() ? 'path/to/cache' : false ]); That's all you need to run twig (you don't even *need* the debug or cache stuff, it's just a good idea). From the looks of Fortune, it's pretty similar. Not trying to shit on your work (it looks fine to me), but the points your making on the differences between twig seem a bit superficial or ill researched.
Last time I benchmarked it, it handled 500 requests/sec on a cheap 512MB server, and 2,000 requests/sec on an 8GB server.
Hi Dave, Good work on it. I don't recall if I asked you on twitter earlier or not, but I wonder whether there is any reason you didn't made it psr-7 compliance so it can make use of other middleware approach . You can see lots of discussion regarding psr-7 on php-fig, ie why I am asking. Lots of documentation have improved. Nice to see :-) . Thank you.
I hope Taylor has some clean underwear to change into.
My response was misleading. I meant that its entire architecture is based on PHP 5. This means that none of its interfaces/classes can use scalar type hints nor return types. I feel like PHP has evolved a lot in the past year, and I wanted to support those new features from the start.
*shrugs* It really is only a problem if you intend the code to run on shared hosting machines, but there's little excuse to do that today with basic VPSs being dirt cheap nowadays. It's a bit like saying we should avoid namespaces altogether because people may run a php version lower than 5.3; quite frankly, not my problem.
Thanks for delivering exactly what nobody needed: yet another PHP web framework.
You're very welcome.
Some of our WPEngine sites are still on 5.3 :( They have no 5.6 upgrade plans right now - most of their servers are finally on 5.5.
Thanks!
Thanks for the response, that logic on changing-delimiters is really great, just shows how robust your system is. I will defiantly be watching this to see how it grows, and for sure testing it on some personal projects :)
Comments on the Style of Commenting On Things /** * This artefact of another time when processing comments were hard * is a waste of space. * If it isn't a function doc, why would you ever? */ Or this: // Nothing wrong with this, especially after function deftly() { //describes the purpose quickly Or this: /* problems abound, you'll not use me lightly, /* since I can't exist */ within myself */ Or this: # Another way to say a comment; use to offset two styles of comments such as request-&gt;parse(); // to describes a line's function, which is parsing the request into understanding bits # indicates a conceptual division about program flow, such as begin closing connection request-&gt;cleanup(); request-&gt;sendResponse(); request-&gt;closeConnection(); 
"If it works, it is outdated" Fortran has mostly stopped evolving. That is why it is still around. I know this will never happen to PHP: Whichever might be the newest hype of software enginnering and OOP, it will be implemented. People seem to think life gets better with all the new shiny things.
 * Turned all of the Cabin classes into Gears, so that Gadgets can extend their functionality. * You can now add/remove Cabins, Gadgets, and Motifs from the Bridge. * In Landings, $this-&gt;lens() will now... * Gadgets can also override the selected Lens, transparently. It's a shame that this kind of terminology will put me off ever trying Airship. I'm sure you would gain quite a few more users if you used terms that we're already familiar with, within development.
 &gt; parameter names, function name trickery, config semantics, swapping parameter positions Pretty much useless exercise. I can't remember parameters and API of my own libraries :-\
I find the terminology quite endearing, to be honest. Keep it.
Our company (and I HATE them for it) decided it was cheaper to set all of our clients on a HA 'shared' cluster, meaning we have 50 or so sites with various requirements on the server. Not much we can do unless we dump the clients so I guess it's not changing. ^^^Help ^^^me
Most people are on cheap shared hosting and their code works fine as it is. Even if there would be zero problems upgrading, they don't see any benefit. 
Why not upgrade to 16.04?
I've seen it posted on this sub before.
Can't wait to tell all my friends I write code with opulence. ..............
Its def something that I would need if I were to use it. Mainly for validating JSON API data and array input forms. I currently use http://symfony.com/doc/current/reference/constraints/Collection.html
If you are maintaining some open source software, how about making 5.5 the minimum? I know some shared hosts with 5.2 as the minimum, but do you really want to write code without name spacing, late static bindings, generators, etc? Besides, it will indirectly force the shared hosts to upgrade their servers to 5.5 or so.
I've updated the docs to include this hint.
I've increased the line-height to hopefully make the website a little less scrunched.
I did consider it, but I felt PSR-7 was lacking on a lot of features and was bug-prone. I addressed that in [another question](https://www.reddit.com/r/PHP/comments/4p2mjc/new_fullstack_php_7_framework_opulence/#thing_t1_d4iaowk).
As a consumer of frameworks and admirer of people smart enough to roll their own, congratulations! I look forward to watching this grow!
I've added a [wiki](https://github.com/opulencephp/Opulence/wiki/Todo) to GitHub that I'll start using for features that need to be worked on.
https://httpbin.org/
A couple projects I've taken over are 5.3. The lack of generators or worse the lack of a finally block is maddening.
Disclaimer: I'm not a professional PHP dev, I live in CA, and I'm kind of curmudgeon-ey. My perspective might be a little different, but this is what I see out here: If you haven't already, build some things, put them on the web, and publish the code on git. Mention your git account on your resume. Demonstrate that you can build stuff and write good code. Build something that utilizes a popular service's REST API and publish that as well. There's nothing special about talking to these services, but people love seeing "RESTful API" on resumes. [Twilio's](https://www.twilio.com/docs/api/rest) is kind of fun I guess. If you have professional contacts (maybe from your internship), get a linkedin and "connect" with them. You'll probably need references, too, so hopefully these people like you. On top of the skills you've mentioned, learned how to write and perform unit tests. As far as I know, PHPUnit is the preferred framework... if I'm wrong hopefully someone else will correct me. Also familiarize yourself with "agile" (ugh) and the CI/CD pipeline. You don't need to have experience or be an expert, but most employers use stuff like this, and they want you to have an idea of the development process and how code goes from your editor to production. If you can speak confidently (even if not exactly) about this sort of thing in interviews, they'll think you're awesome. Also it's more resume buzzwords to catch eyes. Again I don't know if things are different on the east coast, but where I'm at just about everyone relies on headhunters/staffing agencies. Once you have a nice resume, put it on dice.com. You'll start getting tons of emails and some phone calls. A lot of these guys just blindly mass mail everyone with certain keywords on their resume. Ignore the ones you're blatantly unqualified for. You can reply to the ones where you meet or slightly fall short of qualifications (most companies inflate requirements anyway), but if it's clear the person didn't read your resume before mailing, don't be surprised or disheartened if they never get back to you or stop communicating after a phone screen. You'll have better luck with the guys who call you, or at least send an email that's for you specifically. They usually have something in mind that matches your skills/experience, and they aren't going to waste their time or make themselves look bad by setting you up with something you're not qualified for. Bear in mind that a lot of the jobs staffing agencies have are contract positions, meaning the job is time-limited (six months - year) and you'll be working, for example, "at" Cisco, but "for" Robert Half. These positions usually pay less and have worse benefits. It's up to you if you want to settle for this or not (to get experience or something). But make sure that's clarified in the beginning of the conversation. Sometimes if you're really good the company will convert the contractor to a full-time position once the contract ends. And of course you can apply directly to stuff at Dice, too. Edit - I screwed up the twilio link.
I work for the company that created that certification and I know its contents well. I can assure you that the real certification has nothing to do with the "certificationy" example. The real certification doesn't ask you nonsenses like the ones you listed. Most of the questions require you to have real-world experience developing apps with Symfony. If you just read the docs, you'll fail. That's why it's much more difficult (and hopefully more useful) that other popular certifications in the PHP world.
&gt; Fortran has mostly stopped evolving. That is why it is still around. That's because Fortran doesn't need to worry about numerous things, such as SQL Injection, backwards compatibility, security, etc.
I clicked on api link in navigation
Just the formatting makes me cringe. $connection = mysqli_connect("localhost","root",""); if (!$connection) { die("Database connection failed: " . mysqli_connect_error()); } $db_select = mysqli_select_db($connection, "demo"); if (!$db_select) { die("Database selection failed: " . mysqli_connect_error()); } nnnnnggggggg So many things wrong with this tutorial.
What year is this? 
lol
That involves some backwards-incompatible changes. If you're not already on at least 5.6, then chances are that you're not ready to jump to 7.0.
While I understand these are only for teaching OOP, I would like to point out a few things that would in my opinion improve upon your generic implementations. * `setData` feels like an anemic domain model. If your class requires certain params, make them explicit in the constructor * I would argue that `created` and `updated` should be `\DateTime` or even better `\DateTimeImmutable` objects * You extend everything from `Item`. While inheritance is a very powerful feature of OOP, I would strongly advice to not use it when teaching OOP. Instead begin with Composition/Decoration first. These are much more flexible. See also https://youtu.be/29MAL8pJImQ * Some of the interfaces you defined are not prime candidates for interfaces. That might be confusing. For example `Price` could be a Value Object or a composite Value Object. It's not really an implementation that changes. * Your `getSummary` could be a candidate for a Strategy Pattern. It would show how powerful `Interfaces` are if you have different ways of defining your summary. * I'm quite partial to drop the `Interface` suffix, but that's personal. Here's why: https://youtu.be/2ytO9XqEr3A Hope this helps you improve!
We've just finished migrating all our clients to PHP 7 and mysql 5.6. Couldn't be happier. Some apps are reporting speed increases of 200%!
I use Codelobter: http://www.codelobster.com It has own internal free debugger
Because repetitive links to crappy posts, all from the same site? 
I was working in a company like this once. I fix all those problems. I quit. Simple.
So you're running 5.4.0 and fixing reported security bugs yourself then? Yeah, you don't really need to worry then.
&gt; I've found that pleasant syntax can often lead to good architecture I can't agree with this more. As a development manager and tech lead who has reviewed *a lot* of code in my career, this is possibly one of the best "unintended consequences" of developer-friendly syntax and DSLs, especially in larger multi-developer projects. I am really liking what I see so far in Opulence.. Thank you for contributing this back to the PHP world!
I've never really understood why people like doing protected properties by default. Properties should be private by default and exposed with getters and setters as needed.
I've worked on a product that has been both zend-enoded and ioncube-encoded. The product has a "self-install" option, so customers put it on their own infrastructure - it sounds like you might be in a similar setup. **Note that while both give away the loaders (de-coders) for free, the encoding portions are paid products.** In recent versions of our product, we've ditched Zend completely in favor of IonCube. IonCube is easier to deal with than Zend both in terms of customer support (and really, clicking around their web site!), but most importantly, for end users. IonCube is more backwards compatible, allowing you to worry less about mismatches in php version vs what ioncube encoder version was used. Note that the loader still needs to match the server's php version, but the code itself doesn't necessarily need to be re-encoded for different php versions. Zend is a little trickier there.
I'm an anti-framework kinda guy. I do understand the concept and the benefits, but the huge code bloat generally scares me off. I'm going to make myself try this out on my next project, the feedback here and your own blurb (and responses) have convinced me that I should give this a go. 
When would you use protected?
I'm an anti-framework guy too, believe it or not. That's why I worked so hard to keep Opulence from bleeding into your code. It simplifies creating an MVC RESTful website, but it doesn't have to mix with your application domain. That's not to say you cannot use its libraries within your domain if you choose. I'd just prefer to give you a router, some environment configuration, and bootstrappers to register your components with the IoC container so that they may be injected into your POCO controllers. Pretty much everything beyond that is merely optional.
I'd propose you support dot syntax: $nav-&gt;Core-&gt;get('nav.group'); $nav-&gt;Core-&gt;set('nav.group', 123);
That's evil and hilarious!
One of the pages I find myself going back to over and over to read is [Things You Should Never Do Pt 1](http://www.joelonsoftware.com/articles/fog0000000069.html). If you read the article, it talks about how you make changes to legacy systems. Slowly refactoring a little bit at a time is much, much easier for people in the finance department to handle than the "big rewrite." I am going to tell you now, the big rewrite will never ever ever turn out well. You can plan and plan and requirements gather all day long, but the final product at the end of the day is going to suck more. A better way to think about this is going to parrot what that article says, and what I am sure others in this sub will tell you. When dealing with legacy systems (which I am currently in the trenches on) is to change your mindset. We, as devs, like to act more like Navy Seals with how we approach the code; in and out, no one knows, and the mission is done in whatever way is necessary. Instead, we as devs in legacy systems need to be more like the Army. They bring in trucks, men, and build bases. They OWN the land they are on. You need to OWN that codebase. Refactors should be done to make the code more readable, come up to standards (which as an aside, set a standard you can compare the code to show leadership how it doesn't stack up) and it will also makes the system easier to port. Move your domain logic to a place where it somewhat autonomous of the system it is in, and make interfaces for it. Set up your tests. When you are looking at changes and making them, bake into your time requirements the time to refactor. Like I said, I am currently doing this. I inherited a PHP 5.3 project that was created by a junior dev, and it currently runs large parts of the organization. There was some non negotiable changes that have had to happen, specifically shoring up the SQL injections points. I still have a lot of refactoring to do, but I have a plan and a method. Take ownership of your codebase. It is yours, not the last guys; if it breaks you are gonna fix it. edit: spelling.
As always, when I hear "modernizing" or "legacy" I perk my ears. You may wish to try [Modernizing Legacy Applications in PHP](https://leanpub.com/mlaphp). (I am the author.) Your attention to financial issues is wise. One of the things about the MLAPHP process is that it is very atomic. You can make one small change at a time, as you happen to have the time, to leave the system better than it was before, *and still fully operational*. This means you can integrate modernizing into your existing work, or alternate between modernizing and fixes/features. Finally, note that "converting to a framework" (even one as light as Code Igniter) is a difficult task with legacy systems. There is a lot of implicit knowledge embedded in the system now, and that knowledge will be hard to extract cleanly *unless* you separate the layers of the system first. The MLAPHP process shows you how to separate those layers cleanly; after that, extracting the relevant parts to another framework will be much easier. Good luck!
ok I didnt read here for a week, so I got it. thanks for replying :)
Recommended stack? Put Apache or IIS and configure PHP for it...
depends on the experience level, but its a nice attitude that every article that is below your experience is probably spam :)
It's just devs and dev fanboys thinking they understand operations. They don't.
&gt; Unrolling parameters from an associative array also doesn't make something more or less anemic. I disagree. Throwing in some 'bag' of 'stuff' is bad design. You need to have knowledge of the internal implementation to use it 'the right way' &gt; It won't help to unroll the parameters, it'll only add verbosity to the code. That's a _good_ thing. Unrolling parameters is bad until we get proper named parameters in php. Until then I'd much rather explicitly force my consumer to know what the arguments are, instead of just 'winging it'. &gt; There are three classes in total, so "everything" is two classes extending Item, for the obvious reason that they have the same base fields. Not exactly a bad thing to do. A very bad thing to do. It makes the developer lazy and unaware that they're _not_ the same thing. This type of inheritance is exactly why I banned the usage of `extends` in my previous project. Inheritance for the sake of laziness is an anti-pattern and a refactor nightmare. Yes, inheritance has its place in OOP, but not for code-reuse. &gt; They already might be. There's no type restriction on them. That is exactly my problem. &gt; What exactly would the injected strategy be here? If I want a summary, I probably wouldn't want the result to be arbitrary depending on what strategy was set for summary generation during construction. I'd want predictable output. A lot of assumptions. One of the strategies could be "the first paragraph". One could be "max amount of characters". One could be "max amount of words". If we are talking example here, this would be a great chance to show the power of interfaces.
Do you mean you are teaching people OOP using these examples? First of all you are using interfaces in a bad manner. Interfaces are not abstract classes and I get the idea you treat them a little like that. Interface should describe an action or behaviour which object can provide. For example your ContentInterface and ItemInterface are not interfaces, those two things only provides setters and getters. Setters and getters can be used for changing the behaviour and this should not be interfaced/abstracted as in most cases this is too concrete.
One should have no experience at all to consider as helpful this particular article we are talking about.
I've been dealing with the same thing. An older CI application in which the original developer did not even follow the frameworks standards. I have no qualms with CI (my first framework), but this individual made a complete mess of it hacking routing, bringing in multiple different ORMs then ditching them all for poorly written queries. Terrible stuff in there, bloated classes, spaghetti code, no unit tests. Just bad, bad, bad. I've fixed stuff for performance and refactored certain areas, but I think she's too far gone. I began rewriting our core API in Cake3, but now I am beginning to see that Cake3 consumes too much memory. Literally consuming all my memory allowed per request and I refuse to up my memory limit in my dev environment to get around it. Luckily in my cake apps I create what I call Logic classes that barely use cake stuff so I can pretty easily port the guts of the application out. If I am not able to get memory consumption down then I will likely try just using something like SlimPHP and writing raw queries and such. I definitely wanted to enjoy the ease of development cake brings, but reality is reality. Good luck mate, let us know what you decide on. You may want to look at SlimPHP or Falcon, but there is certainly no shame in going old school if thats what you have to do. I face the same hurdles as you by having to connect into 2 third-party APIs, meshing that data with our own data, and then returning that to clients connecting to our API...brutal.
SSI is real good with PHP, but apparently not as a site design structure provider, but as a service to provide asynchronous vidgets. So, for your task SSI will be superfluous, adding complexity without real gains. Also remember that appetite comes with eating. You may deeply regret the decision to make your system less flexible from the beginning (as SSI is apparently less flexible than full featured PHP). 
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
When Python finally gets typehinting in its compiler, I'm sure there will be a small exodus from PHP.
[removed]
"No automation" is one of the dumbest IT credos I've ever heard. You can tell them I said so. I spent over a decade doing nothing but IT, and anything we couldn't automate was eventually removed (except for taking tape backups off-site - too hard to automate the drive at that time). I've set up developer VMs here as well (`git clone` followed by `vagrant up` and a new developer is up and running), and management loves it. Yeah it took some time (especially since I coded a little front-end to automate enabling/disabling/cloning sites so the devs never have to learn Linux commands and Apache configs), but it is universally appreciated here. Most of our sites are hosted with WPEngine (who are stuck at 5.5 for now, unfortunately), but those that aren't are on VMs with places like Linode and VivioTech and Digital Ocean, all running the exact versions of what they need. I hope your management eventually sees the light and updates their policies to something better fitting modern development and operations practices :)
I'm aware of that, yup. Apache's just the most common one. SSI usually has to be turned on in the config too, making it a lot less friendly than just being a language construct. Is SSI a standard in the sense that every command works on every web server with SSI support and on every platform that web server supports?
[Dev Hell](http://devhell.info/) belongs on this list. PHP and related tech are frequent topics of discussion, but it also has lots of talk about career development that pure PHP podcasts tend to miss.
Dev Hell is on the list. It is the first podcast listed under the [General Interest/Multiple Languages](https://hackerlists.com/programming-podcasts/#general-interest) section.
You'll get no arguments here.
I am in the midst of fixing them all ;)
&gt; loosing data in transit but still completing operations I had a similar bug in a legacy codebase. In our case it was a race condition with concurrency and poor database design choices. Long story short, we switched most of our tables in our database to InnoDB engine, and wrapped complex operations in explicit transactions for an all-or-nothing behavior. In one case of particularly poor design, I had to call an explicit lock table to ensure orderly behavior. Is it ideal? No. But it works as expected now. &gt; I'm thinking of making each step part of a queued event system If these are long running operations and they can arrive in bulk this may be a great idea, actually. Recommend you return a status code like 202 Accepted if you're queuing work, so the client side knows it's received but not done yet. This *could* be a good way to reduce database contention. Instead of, for example, 150 apache processes with a database connection each waiting for a write lock, you could limit to 2/4/8 workers that can keep spinning, biting off a piece at a time. &gt; Thinking of ditching current app as its an oldie using CI and going with more lightweight system Honestly? The first thing I'd check is if you're using an accelerator. This is a legacy system, right? Are you running xcache, apc, or opcache? If not I'd suggest reading up and enabling opcache. You'll get better overall performance almost immediately.
Probably worth nothing that the implementation will completely break any existing use of `__get()` and `__set()`. Arguably implied from context, but it could easily surprise someone (especially in some sort of grab-bag ActiveRecord-style ORM)
&gt; Interfaces are not abstract classes They are very much a special case of that, plus they solve the diamond problem.
What? Fortran is some 60 years old and there are some major codebase out there nobody wants breaking. Backwards compatibility is, at this point, the biggest issue for Fortran. That's why Fortran has little evolution: because it's biggest priority is not breaking anything already out there.
In a project, you shouldn't ignore the `composer.lock` file.
No. For example -- Node.js #2
Great suggestions 
Use xdebug. Don't ever var_dump again. It will change your life.
xdebug is great and I recommend it, but when i'm lazy or I just want to check something really fast, a good old var_dump is useful. (Mostly using Symfony's dump function this days)
Don't you just hate it when trolls say RTFM? I'm sure you already do that. So, I'm going to be nice and suggest some things: 1. If you know an earlier version of PHP, forget it. Move to PHP7. The benefits of PHP7 are so tremendous on code execution performance that it makes sense to migrate to it immediately and to use all of its new features. So, read up on all the new features of PHP7 and try to put them into context. 2. You should learn these design patterns in PHP and when they are suitable to be used: https://github.com/domnikl/DesignPatternsPHP 3. You should learn the differences between [MVC (the most popular)](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) as well as [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel) and [HMVC](https://en.wikipedia.org/wiki/Hierarchical_model%E2%80%93view%E2%80%93controller). 4. I recommend trying to code your own lightweight MVC framework so that you get a sense of why it's important. So, using an .htaccess file on Apache (or the equivalent on NGINX), throw things at your front-controller for parsing and routing to your page controllers. Then, load a bootstrap so that you can autoload model components super easy, load a $view object so that you can inject variables into it, load your view with those variables inside, and voila. [Here's a super simple one to help teach you](https://github.com/nopain/painless). 5. The #1 bottleneck I've seen in the trenches has been database speed. When people complain about a slow website or web application, make certain the database has enough RAM and the MySQL (or whatever you're using) is tweaked with all the latest performance tweak suggestions. Also, a heavily normalized database is great for write performance, but TERRIBLE for read performance. What many big companies do is to split the database into two databases -- one that's slightly normalized a couple degrees but not outrageously complex, and then one that's for archive, history, and reporting tasks that is not normalized very much at all. It's a delightful day when you move from an 8GB database server to a 32GB RAM database server, and when it's fully optimized. Many websites and web apps speed up tremendously by doing that -- or even going from 4GB to 16GB RAM. 6. Apache is most documented as far as a web server, but NGINX is where you want to be until a faster cross-platform web server comes along that's just as capable. There's no .htaccess file in NGINX, but you can do similar things with it if you read the docs. 7. If you don't know Linux and docker, learn those. Also learn the differences between CentOS, Fedora, and Ubuntu. 8. Learn vagrant, chef, and composer. 9. I recommend you get a tutorial on C, C++, and how to make a PHP extension with a skeleton template. Then, load it through PHP and pass strings, integers, and floating point numbers to/from it so that you get an idea what's all involved. It's a great way to optimize PHP for extremely slow code in some use cases. There may come a time when you might need this. Plus, having C and C++ in your skillset definitely won't hurt you. 10. I prefer to code on a Mac because it's less virus-prone than Windows and has much better hardware and system performance, and longer battery life (although things are rapidly changing in PC laptops). I recommend that you consider this for your PHP coding. Also, I install VirtualBox and Ubuntu for when I need to do something in Linux. 11. Learn the Meld tool for Linux -- lifesaver! It lets you do 2 and 3 way diff reports on files. You may also find a suitable tool fro Windows or Mac. 12. Learn git. Some old fogies may want you to also learn svn as well. Not only learn git, but learn how to bring up a nice git server and web front-end manager for it. 13. Learn WordPress and Drupal, as well as under the hood, and how to make plugins and themes for each. 14. Learn some of the new PHP-based site generators out there, which are growing in popularity because, well, WordPress and Drupal are great if you stay on top of the security updates on a daily basis, but a site generator can often give you a more secure website that looks just as great, which clients can update themselves just as well as in WordPress. 15. Every quarter in a year, read up on the latest techniques for blocking XSS, SQL Injection, and other data validation because the hackers are intense and new loopholes are discovered. This affects every programming language, and some more than others -- especially web programming. 16. The latest trend seems that a *LOT* of web developers have moved to Laravel or a lightweight version named Lumen. I definitely recommend considering these, but only after you have coded your own lightweight MVC framework so that you know what's involved and why Laravel or Lumen might be a better platform. Other popular ones are Cake, Code Igniter, and Zend Framework. 17. Learn jQuery. 18. Learn Bootstrap, Zurb Foundation, and Semantic UI as well as custom templates built on top of these. Visit themeforest.net if you haven't done so already. 19. Some may advise you to learn frameworks like Angular JS or something similar. I'm not a fan of these -- I think they can be hacked too easily and also it creates messier programming. 20. I know everyone rages about the performance of PostgreSQL, but the sad thing is that web hosting providers won't help you much with it, while they will with MySQL. In a heavy production environment where I'm on Digital Ocean, RackSpace, or Amazon hosting and tech support, MySQL (or Aurora on Amazon) is where it's at. It's what they understand and can help you scale. 21. I know people brag up and down about NoSQL and platforms like that, but there are actually ways you can tweak a MySQL table to give you just as good or better performance than the NoSQL. 22. Learn how to bring up a high-performance, fault tolerant tiered production architecture where you have 2 or more web servers behind a single IP address with a load balancer, speaking to the same database server (although it should be one with lots of disk space and RAM). 23. Have your company send you to Linux and web security training once you know Linux pretty well after a couple years. Or, perhaps a whitehat hacking class. 24. Learn the best crypto standards in PHP such as the best method to store a password in the database. Read up about PII (Personally Identifiable Information) definition and what you can do to safekeep your customer data. 25. Get used to setting up payment gateways with TokenPay or OmniPay APIs with Stripe, 2Checkout, and BraintreePayments, among others. Learn the difference between high risk payment gateways and regular payment gateways. Also learn why it's best to use a token-based API so that you have very little PCI requirements because your payment gateway is managing the most of those PCI concerns. (You'll want to read up on what PCI credit card stuff is.) 26. Health. As a coder, you'll be doing brutal things to your body. Get into a workout program that involves you for anywhere from an hour to two hours every 2-3 days. And don't overdo it -- some things can damage your hands, elbows, etc. Also, give your eyes a rest by using a larger display that you attach to your laptop over HDMI, a dark IDE editor theme, and turn down the brightness and increase the contrast. As I approach 50, more and more I use glasses now, which I loathe. 27. Find an IDE editor that you love. There are several to choose from. 28. You don't have to work for The Man all the time. You can freelance. It's the web, man -- you can work from anywhere in the world with good Internet. Try it on the side a little with some local small businesses just to get your feet wet. I now do full-time freelancing. 29. Have some fun with your new, mad PHP skills. Think up some kind of SaaS project on the side that might only take 2 to 3 months to code and try out. Learn from that experience. Launch some Google Adwords and (to a lesser degree) a Facebook ad campaign. Write some articles about your SaaS project and put it in some free article directories, giving you lots of nice backlinks. Make some nice side income. Then, think up another one and launch that too. Imagine between these two that you had $20/month per customer coming in, and 5 new customers a month on each website. That's $200/month and it compounds such that if you don't lose any of those customers, by two years you'd have a regular $4800/month coming in. Then, add another payment tier with more features on each website. 30. After a few years, consider bringing up a small business webhosting company on the side with your skillset, using reseller cPanel hosting. Charge a rate slightly higher than A2 Hosting and advertise it, as well as get good backlinks for it (even if you have to pay for those). You'll get a trickle of side income to make your life more comfortable. The support needs aren't that intense with these. Often you can rephrase the questions and pose them to the company you're reselling for in order to get an answer on anything you're stumped on, or you can ask on sites like serverfault.com. Eventually, you can do offshore outsourcing to help you with trouble tickets. 31. Read up on [Code Smells](https://www.google.com/?gws_rd=ssl#q=php+code+smells). 32. Learn about CloudFlare web application firewall or services like that. They are valuable for mitigating DDoS issues. 33. Learn OpenCart. I know there are Magento jobs out there, but man it's slow.
"Do not use PHP for anything serious"
+1 for xdebug. var_dump will still be useful (and xdebug will make the output look prettier!).
Keep it simple. These days I use behat and phpspec to guide me to the minimum amount of actual code to get the feature working. Yes a bit more effort to add tests but really helps ensure the feature works. They also act as a regression test in the future, so if your tests pass still, the feature works still (well, usually)!
Yep, and don't charge 1990's pricing either, I've found. You certainly can't go to the grocery store or the gas station and pay what you paid for those things back then, here in this year. Inflation is mad crazy in many places of the world, as well as the USA. I've found on some tasks that I can easily break off, it's nice to use offshore outsourcing to lower my own costs and thereby have a lower bid in order to get the client project. It's great to need 3-4 tough functions built on a project, or a nice theme or graphics project, and outsource it. When you wake up the next morning, it's in your inbox and may only need a couple tweaks before going into production if you get the right bunch of guys, and luckily for me, I found the right guys.
* Get into the habit of commenting your code thoroughly from the outset, your future self will thank you - https://www.phpdoc.org/ * Ignore any online tutorials, stack-overflow solutions or any other PHP code snippets on the internet that are older than 3 or 4 years (use Google's advanced search date tools to filter out older content). PHP had evolved dramatically in the last few years, and much of what is out there is wrong, insecure and bad practice. * Read every single article here: http://www.phptherightway.com/ * Version all your code using GIT or something similiar (https://www.atlassian.com/software/bitbucket/pricing) * Familiarize yourself with the PSR standards http://www.php-fig.org/psr/ * Learn and understand design patterns: http://www.phptherightway.com/pages/Design-Patterns.html http://www.fluffycat.com/PHP-Design-Patterns/ (Understanding design patterns will help you in any OO language you work with in the future.
I once made a membership product that people could download and install inside WordPress. It was IonCube-encoded. Within 2 weeks, evil blackhat hackers found some way to unencode some of it -- enough to find out that I had a failsafe key in the system that they could utilize. So, be careful on how you code something, and how you rely on IonCube. In my case, what I did was change the project so that if you used the failsafe key that I previously used for debugging, it would redirect you to google hammer (trust me -- don't go to that website).
Thanks, it was more the soft-skills approach I was gunning for. But you are not too far off the plan I wrote. Essentially when anything us being worked on we will update a status bit to be in use. That at least allows the DB to work like a DB. 
LOL. Get outta here. So what's Facebook coded in?
&gt;Some may advise you to learn frameworks like Angular JS or something similar. I'm not a fan of these -- I think they can be hacked too easily and also it creates messier programming. What do you mean by "they can be hacked too easily"?
This is just a general programming tip: learn and love breakpoint debugging. Shouldn't have printf statements, or console.logs, or echos strewn throughout your code in any language.
Build stuff from scratch for a while. Using tools that make development easier is ok (like a nice IDE, a debuger, etc), but don't go straight to libraries and frameworks to start with. Look at open source projects that have good reputations. You don't have to use them or contribute, but look at their code and see if you can pick out patterns. Find people that are good at it and see how you can work with them. Open source is a quick and easy way to do that. IMO, go straight to object oriented if you're new to programming in general. Procedural is easy and less appealing after you know how to properly use objects and classes. Get to know the backend environment along with PHP. If you're using Linux spending time in the terminal learning will pay off no matter what kind of task you have in the future. I'm sure the same goes for other server environments, but I can't speak to those. Stay away from Wordpress. It's fine after you know what you're doing and can recognize the bad things going on in there, but it's an old codebase with way too much legacy junk that can really hurt you if that's all you learn. I'm sure there are lots of things out there like this, but Wordpress is easy to pick on.
&gt; Don't you just hate it when trolls say RTFM? Literally the best advice any new dev can receive is RTFM. Being able to read and learn from documentation is literally the most important skill you can possess. 
Learn python instead. Seriously. 
OP was asking _"[..] when you first started"_; XDebug was born in 2002 several years after I started programming in PHP, so obviously knowing about XDebug when it didn't even existed would have been useless :D But yes, I agree that for a millennial XDebug is a must.
How you do a complete rewrite I agree with, and it won't be approached as a giant sprint, either. I should have been clearer its more about the soft skills of client sitting than project management or architecture. Thank you though 
It was originally coded 100% in PHP. Then, they migrated much of it to a mix of Hack/HipHop + C++. Then, they tried D for awhile on the backend to augment the Hack, but bailed on that, last I heard. (D, supposedly, was easier to code than C++.) Now, however, with PHP7 being as fast and often faster than Hack/HipHop, there's no real incentive that I see to use Hack/HipHop and should just adopt PHP7. I can cover a lot of ground in PHP7 for most of a business app. And if I had something super intensive and needed more power, I'd first consider increasing the database performance or database hardware performance. Second, I'd move to a tiered environment with web nodes behind a load balancer. Third, I'd find better ways to code something so that it ran faster, where possible. Fourth, I'd upgrade all hardware used. Fifth, and only when necessary, I'd code a PHP Extension in C and load it in to optimize certain areas of the application. (Oh, and C can call C++, since I prefer to do most of my work in C++ rather than everything in C. It's more productive and just as efficient.)
I kindof agree on the prefixing, although I've gotten the feeling that it's the unpopular opninion. I would also like to add a tip I heard of: $ss for safe strings (for example something generated within your application or otherwise trusted) and $us for unsafe strings, like input directly from the user or something from a previous user coming from the database. It should make XSS easier to spot, and you'll also hopefully notice that you shuldn't send user input to a method that expects a safe string (that may not have been tested for null-bytes, for example).
No thanks
This is great
Read other people's code. For a long time I spent 10-15 minutes each morning looking through code on GitHub for projects like ZF2, Symfony, Guzzle, etc. I borrowed this idea from tips for becoming a better writer. Good writers also read a lot.
TDD FTW
- people who build frameworks aren't geniuses, and you shouldn't regard them as such. They're as fallible as the rest of us, and will make mistakes, so their word isn't gospel. Learn to think critically, investigate, and question everything. Look at stuff from different perspectives, and don't let yourself get boxed in by other people's "wisdom" - learn about [Vagrant](https://www.sitepoint.com/re-introducing-vagrant-right-way-start-php/) and the evils of PHP bundles. Keep your main machine fast and clean of runtimes and anything you can't get up and running in a jiffy on a secondary computer should your main one burst into flames. Remain portable and flexible. You *will* need to change machines in the most unexpected moments, and you'll greatly appreciate not having to spend a day setting things up. - an open source portfolio is incredibly important, both as a CV, and as a learning tool (contributing to other stuff and getting people to contribute to yours is the equivalent of discussing new ideas with someone) - code *every. single. day.* - separate 1 hour from that for reading (books, posts, anything goes - NEVER spend a day without reading something new), 1 hour on building a social profile (you'll need it later if you want to be part of the community and exponentially increase your knowledge every year), and the rest on coding. - a fit body helps a mind stay fit, too. [Stay fit](http://thewalkingdev.io). - invest in tools: good hardware / software DOES matter. The frustrations good tools can save you from are very much worth it. - learn Git, and go beyond push / pull / branch. Master it. Don't be like most of us and [do this](https://xkcd.com/1597/). - You're here to produce good code, working code, and to ship products. People's [melanin and crotch content **does not matter**](https://4fa6134ddde55ae0092b69e1eb287d2840301d0a.googledrive.com/host/0B6kjFNJtv3yzUjY4M21QenJzdGc/). Be aware that you're now in a meritocracy. - Go to conferences. At first as an attendee, later as a speaker. Even if it's not something you want to do, speak once or twice. You cannot grow as a person unless you experience things outside of your comfort zone. - There's nothing wrong with using freelance sites like Upwork (many will scoff), but don't get your price down just to compete with the third world. Most clients know the third world devs suck, and will naturally be willing to pay a normal beginner's salary for simple, junior gigs. Those who try to negotiate and lower your price deserve to be fired. There'll be more. We're not even close to this bubble bursting, don't worry. However, when you do get a job on such a site, take it SUPER seriously and give it your all - any rating under 5/5 can kill you permanently and forever there, and it's totally worth it keeping it at 100% later in the game.
&gt; vidgets Ah those german widgets. I could not help myself.
There is more money in just about all other modern languages, but PHP is arguably more difficult to write well. Not a popular opinion but one to consider as you invest time in the language. 
I've added a [note](https://www.opulencephp.com/docs/1.0/installing#versioning) about Opulence following semantic versioning to the documentation.
Well, to be honest, the client is trusting you to do a good job. They are expecting you to not lead them astray. It isn't just the money they are going to lose, more that you are going to lose those "little hairs" that the project has grown. The only time it really makes sense for a rewrite is if there is an entire architectural change that necessitates the need for a rewrite. For instance, the client has Site X that is written in ASP Classic (note the lack of .Net there); that is going to need a whole entire rewrite. THAT is when it makes sense to use soft skills, and at that point you can show the hundreds of reasons for a rewrite (the main one being that the platform it was written on is no longer supported or maintained, and has no real upgrade path to "modern" languages). What you have here is not a project that makes sense in any way to rewrite, unless they are asking for different unrelated functionality completely (but reading your post again here seems unlikely). /u/pmjones really knows what he is talking about in things PHP, and in I would guess most thing software development.
Be skeptical with new fashions and develop and maintain your own judgement. You will learn a lot from customers and coworkers, intentional and unintentional. Leave small decisions open until you see why you have to decide and how, clearly. Revise those decisions with growing wisdom, if necessary. It takes time to make things well. You make things well only after you have experienced how bad they really are. Counselling, conveying good or better ideas and to listen closely will be a big part of your job. Try to be a poet when coding: Less lines of code means less to debug. You will always "only" refactor and it's fine - have no problem modifying your code almost endlessly until all the requirements are met. Writing poems is like that. It looks like you're always a beginner - that will never change if you're a good programmer / engineer / artist... Better churn out a fast prototype than deal with endless requirements and get lost in stupid perfection from start. Perfection comes with time. 
A lot of their post is nonsense, just ignore it.
1. Read as much (good) code as you can. 2. Don't reinvent the wheel. 3. Be consistent and keep it simple. 4. Learn how to use Google and Stack Overflow.
This one is awesome.
Objection, your honour: Don't hesitate to reinvent the wheel if the normal wheel can not achieve what your wheel can. But buy or use also wheels of others. Improve wheels. I learned 20 years ago that it is possible and economic to live only with 5% of the heating energy (the passive house) and I live in one. Yet, still 95% of the new houses are not built that way. Progress is sloooooow. People are wayyy uneducated over very basic things and I don't mean that in an arrogant way. Most mix up kW and kWh... Agree to the other points, however :)
Agreed. And then get a PHP job. 
Learn testing - phpunit, etc. You don't have to be religious about test-first or test-driven development, but incorporate some automated testing in your code. It will force you to write more testable code, which is generally cleaner (imo) and easier to understand. It's a learning process, but work at it. It's a great dev habit to have, and the habit will translate to other languages. 
Good luck debugging concurrent programs or network race conditions without printfs and historic logs ;)
Outsourcing small parts. Then, when you receive them, polish them and make them even better. Then, write a lot of your own code. Offshore outsourcing is a great augmenter, a great way to keep costs lower with rising inflation and taxation, and a great way to reduce development time. I use it where appropriate.
and if you receive absolute dog crap back? I'm sorry but as a contractor myself I find the idea of contracting to "save money on development" one of the most dangerous notions that exists. It's bad for the contractor and denies them the financial ability to make the decisions and purchases necessary to remain good at what they do; whilst simultaneously introducing risk at least in terms of likelihood (impact somewhat mitigated if what you say is 100% always followed). Good contractors cost more because they are not salaried, they don't get health cover in with a job, they generally source their own equipment, training, pension-plan etc. Let's not get stuck on this. A Contractor should perform tasks you don't have the time or inclination or skill to do; not be cheap labour without the rights. In some locations and situations it's illegal to use contractors like that.
My lord xdebug is beautiful. Just checked it out. I had no idea it did more than coloured stack traces.
&gt; The only time it really makes sense for a rewrite is if there is an entire architectural change that necessitates the need for a rewrite. For instance, the client has Site X that is written in ASP Classic (note the lack of .Net there); I don't think it's a website... &gt; What you have here is not a project that makes sense in any way to rewrite, unless they are asking for different unrelated functionality completely (but reading your post again here seems unlikely). /u/pmjones really knows what he is talking about in things PHP, and in I would guess most thing software development. OP specifically mentions in other comments they intend to re-use code. I think they are talking about ditching the framework they use and you've gone down the rabbit hole...
With JS, I pass/read straight to/from PHP and let PHP do the leg-work. I just sent json responses back to js and it looks nice etc while leaving business logic out of js (mostly).
&gt; for example, "you can't delete an employee unless you are an administrator" - you must implement it on both the backend AND the front-end Are you advising against SPA? Against AJAX? Because whether or not you use AngularJS, Ember, React, Meteor, SuperStarDestroyer13.13, jQuery, or just pure JS, you'll still have to do that for any operation that isn't done via form-post-refresh. Actually, check that, even for a POSTed form operation you'll still need to implement that logic, otherwise you're making your users refresh the page for an operation that you know will fail. There are very definitely reasons one might want not to use a front-end framework, reasons not to build an SPA, etc, but that isn't one of them.
&gt; then having people realize that it's an object array when they get an error. Most IDEs will make that a non-issue, though.
Overruled. In the PHP ecosystem, there are so many battle-tested, mature packages available that the vast majority of the time it's impractical to recreate basic building blocks from scratch. Definitely hesitate and think it through -- rewriting existing software is often times expensive, time-consuming, and error-prone. Especially as a *beginner*, it's a smarter idea build on what other (more skilled) developers have created. Reinventing the wheel should be avoided at all costs unless it's absolutely necessary.
Get a full scale IDE like PHPStorm or something and it will integrate with xdebug. Change your life, homie. 
? Why not just have it all handled in the API and add a basic front-end error handler? I don't see any way to "hack" a SPA page purely because the front-end and back-end are separate. You can modify ID's in the SPA all you want, but the API is gonna reject it if you don't have the permissions. If your API is hack-able, then you need to fix the API regardless. If you want to keep some proprietary calculations hidden, add function endpoints. The only valid argument I see against SPA pages is that servers can guarantee page delivery performance when the bandwidth is large enough, where SPA is at the mercy of the user's computing power (which I can't see as much of an issue this day and age).
/r/forhire is specifically for this purpose.
I have never, ever, come across outsourced code that was architecturally sound or even had much though in design at all. This is particularly true with PHP which seems to attract more 3rd-world outsource companies that put completion time ahead of quality in order to farm as many projects as possible.
Great tips and links thank you
Never assume people in high places in a projext are experinced, even if they're cv says so. They tend to make mistakes and blame someone esle. Always do your best.
Always encode your php files "UTF-8 without BOM", just had a 1/2 day headache with this shit. 
My God, how to set someone on the wrong track in an instant... Buy a Windows laptop and smack any Linux flavor you like on it, I'd start with Ubuntu, easy to use and learn and a huge amount of support available. Macs are overpriced shitty laptops that look "good" (look up the Asus N-series laptops, like the N750JK or newer, same nice looks, and you can upgrade it! Macs cannot be upgraded) You've also said nothing about, say, Symfony, which blows Laravel out of the water. Not to speak about the fact that PhpStorm is currently the very best and most extensive IDE out there, with native XDebug support, support for real time PHP Code Sniffer and PHP Mess Detector inspections, a database tool, a diagramming tool, a REST client, support for many frameworks, languages and file types, and even more upon that, for less than $10 per month. You're talking about AngularJS which is not a reason for messier code, you just have to know how to build an API or use pre-made libraries (Friends Of Symfony have a lot of handy libraries for Symfony, just like KNPLabs) Learn about designing an application before writing it, if it's good on paper, it'll be better as code, as you reduce the need to refactor all your code because you missed something in hindsight. I can go on quite a bit with this, but my point is, most of your advice isn't sound... 
Please elaborate? Which pieces should I ignore and why? Or if more efficient, which should I not ignore?
Use a VM and usually things will be at least somewhat more reliable (if you don't want to fully switch to macOS/Linux).
eh, would be nice but too expensive
I wish I'd really understood how HTTP requests and responses were built earlier: http://symfony.com/doc/current/book/http_fundamentals.html
Stop doing php Right now! Pick up Java instead. You will be in a much better place in 10+ year. And you will have the option of working other great langauges that run on jvm while utilizing the whole of java's libraries, and a lot of great companies use Java, all over the world... For a great and powerful dynamic language, learn Python3. For a good compiled language learn Go or Rust. For breaking into functional programming learn Haskell. I would suggest learning Haskell before learning Rust... But first of all drop Php like that dumb dead meat that it is..
Don't stop. I know it works on Windows, the junior at work got it to work on his Win7 despite me not using Windows in years. Stepping through a PHP application helps _so_ much.
Learn xdebug before you even pick up a framework it'll make learning whats going on under the hood so much easier. 
Oh, I agree. I also have a mbp and it's a much better experience. Not because the Mac is inherently better, but because all tools are written Mac-first I'll break down and main-box a mac sooner or later. Pisses me off since my pc is worlds ahead of even the highest iMac.
An aspect that gets commonly overlooked with RTFM is the focus on self reliance. It really doesn't matter so much how you learn, just that you're learning to learn. The sheer number of requests that come through the Drupal IRC that are *easily* answered by the manual is staggering. If someone is taking the time to read the source code itself, they're pretty much reading the best manual that exists. 
How to actually do anything. I learned from stack-overflow plus trial and error.
&gt; Stop doing php Right now! Some of us don't have a choice.
I think eclipse and net beans can use xdebug too. And at least one of those is free. I used to have a few PHPStorm licenses hanging around (I run a php user group), but I think I've given them all away. Sorry homie, I'd hook you up if I had one. Srsly, though... If you're not using an actual IDE, you're making things much more difficult for yourself than they need to be. 
Don't be afraid to try for something out of your league. Don't act like a know it all and be eager to learn. I am not aware of any college courses that teach PHP. They may overlook the degree if you are solid in the other areas of the job requirements. Sometimes college guys get upset they are paying student loans and you are self taught. Don't take it personal. If your code is solid and you are willing to learn any good company will be happy to start you as a junior developer. 
Unit testing and better design patterns.
What is this magic you speak of? Tell me more!
&gt; The #1 bottleneck I've seen in the trenches has been database speed. When people complain about a slow website or web application, make certain the database has enough RAM and the MySQL (or whatever you're using) is tweaked with all the latest performance tweak suggestions. There is no such thing as "all the latest performance tweak suggestions" for MySQL. Properly tuning MySQL is quite tricky and it really depends on the database schema, the amount of data and the type of workload - I've seen so many instances of "copy and paste random tuning tutorial" in server configurations. Even simple things like query cache can be extremely helpful for one use case or terribly inefficient in another. If you just start coding, don't worry about it (yet). Sure it's helpful to know as much internals of the RDBMS you are using, but most of the things only get relevant when the performance requirements are getting higher. If you are interested in SQL performance, I would start reading about indexes first. &gt; Learn vagrant, chef, and composer. I agree about composer - this is a must for current PHP development. vagrant is a really good way to manage development environments, although docker gets a lot of track recently and I use both of them. I wouldn't recommend chef though - if a beginner PHP dev really needs server provisioning and configuration management, there are simpler tools to start with (ansible is a really good one). And unless you have some knowledge in Ruby, I wouldn't use chef for bigger deployments anyway - ansible is great for this as well, as is Salt. &gt; I know people brag up and down about NoSQL and platforms like that, but there are actually ways you can tweak a MySQL table to give you just as good or better performance than the NoSQL. It mainly boils down to "use the right tool for the job", "Don't use NoSQL" is just as bad an advice as "use NoSQL for everything". While NoSQL is a really broad term and covers a lot of different products, modern NoSQL databases like Elasticsearch, InfluxDB and the like are usually built with scaling and fault tolerance in mind, while the same is really hard to get right with MySQL. There are also differences in how data is structured and it really depends on your requirements which system is the best suited one. There is no one-tool-to-rule-them-all - I've seen plenty of MySQL databases used for things they shouldn't be used, log data or mail storage for example. 
That's because the way I see it the problem with all those certifications is that they test only that you put enough time &amp; effort to memorize/read the documentation/code. Don't think they would scale if they tested on something like "How well you can develop a web app". Taking that into consideration, and in comparison with Zend certificate, the questions make sense and if you can't remember how it is you have a good chance of logically thinking out the answer.
Well, as long as he/she always makes the IF statement correct technically it's secure. Technically.
such as learn wordpress under the hood, wordpress core tend to be messy if you start learning php code in 2016, I'd advise to learn the core of micro framework like slim or silex, its more readable and has clean structure. regarding to wordpress, it is better to just know how, don't go too deep into the core. also opencart? just avoid it
Learn the basics of vi or vim. You don't have to love it, but when you ssh into a server that may be the only editor available. Don't write procedural code. Just... don't. You might save a bit of time up front, but you will pay for it later many times over.
Mint was my jam for a few years. I do miss it, but I also enjoy being able to play games (I know that there is a much better variety of games being made available on Linux than a few years ago)
Are you a slave?
If pay scale is your main concern, then sure, PHP is fine.
Don't over-engineer. KISS (keep it simple stupid). By over-complicating things, you run a higher risk of failing to complete what you need to do in time and increasing the risk of causing yourself headaches down the line when requirements change and differ from what you assumed future needs might be. "Pre optimization is the root of all evil" Also, "Always code as if the guy who ends up maintaining your code will be a violent psychopath who knows where you live" Also, focusing some time in a code delivery pipeline is super valuable (ie. continuous integration) from the very beginning of a project (rather than being tacked on later). Finally, try to make your code flexible to the technology or environment you rely on. Dependency injection and all that. Always favour loose coupling in your code and architecture. And... if you think something is a great idea and a good software development practice, but everyone else around you doesn't get it - it's not necessarily because you are wrong... they just don't get it... yet... (for example, I've had far too many battles trying to explain the benefits of database migrations that it gives me a headache to even think about it. I'm in a good place now though, don't worry :) ).
I'd like to explain. Although Drupal, WordPress, and OpenCart are lousy programming under the hood, they get the job done and knowing them well will help keep you employed -- especially if you are freelancing. It would be awesome if they were coded from scratch again in something like Lumen. But that's never going to happen.
Completely agree with everything bar Magento. Don't get me wrong, OpenCart is awesome, but a properly configured 1.x, and more so a 2.x, can really motor. It can definitely be overkill for smaller merchants though. If you're reading this, and want to learn Magento, go straight to 2 and forget 1.
I have. Pretty much works out of the box with a wamp setup. I'm also using php storm as the ide. Almost 0 setup required to make xdebug work. If you need help let me know. 
Someone did tell me this eventually, he said "just, whatever function you think your gonna write, look up on php.net to be sure it doesnt already exist. Sure they may look wonky and non uniform, but you wont have to rebuild the wheel so to speak" PHP is one of those languages thats just chock full of useful shit scattered all over the place. And for every function is plenty of edge case alternatives. I cant tell you how much simpler my earlier days would have been had I even known about array_search and usort, rather than writing my own loop routines to find embedded elements amd my own stupidly slow bubble sorts....
&gt; (use Google's advanced search date tools to filter out older content) "Google Search" after:2012/01/01 before:2016/12/31 Easy to do this right from search.
&gt; Good luck debugging concurrent programs In which language with concurrency you can't do breakpoint debugging? If you can add a printf to a line, you can set a breakpoint.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
I have heard Drupal 8 is getting that rewrite. Or at least easier to develop for. Read it while looking into the symfony cmf
Maybe I haven't slept long enough, but why it has PHP 5.3.0 as a minimal requirement and uses traits at the same time?
No offense, but a lot of this stuff is bullshit. &gt; I prefer to code on a Mac because it's less virus-prone than Windows and has much better hardware and system performance Bullshit. The virus stuff is debatable (Macs can, and *do* get malware), but a moot point if you invest in a proper antimalware suite. The performance point is just blatantly false. You clearly have no idea what you're talking about. Did you buy a Mac because you did your research, or because it was flashy? &gt; Some may advise you to learn frameworks like Angular JS or something similar. I'm not a fan of these -- I think they can be hacked too easily and also it creates messier programming. AngularJS is a frontend framework, I have absolutely no idea what you're getting at. As for the "messier programming", I find AngularJS a lot more intuitive than jQuery. It just requires some getting used to, because AngularJS requires putting a lot of thought into your HTML. It's certainly better than jQuery's event and callback hell.
But printfs are not a solution to Heisenbugs either. A single printf statement can easily cause enough latency to make the bug disappear and you are right back where you started :)
This is probably the single most important advice here. Virtually every problem you encounter has been solved already.
Hmm, the set("B") light bulb picture (third one from the top) should have arrows going into bulbs #1 and #4. It's "C" that maps to #4 and #7 as seen in the next picture.
We all wrote something like this in the 90's. Somewhere I have a naive chat that not only used files for the chat logs; but if you posted with 'username' you could impersonate people. Nobody ever realised because the form didn't include a username field, so I just used it to make the chat more "interesting" at times.
- Use Composer - Use Git - Figure out the code of better developers, a lot. - Don't think testing is something you will look at later. Learn how to do it now. Even if you won't write tests for everything it will still greatly improve your code. - Learn PSR1, 2 and 4. http://www.php-fig.org/psr/ Look at the rest too, but don't restrict yourself to them just yet. - Everything is a tradeoff. Don't sacrifice testability or cleaner code for something that performs better if the difference is negligible anyway. The bottlenecks tend to be in the same area anyway (io, database). - Play with other languages. - Have fun! 
&gt; Luckily for me the CEO became a friend of mine Don't count on this. You may have his trust, have earned some autonomy, and he may be friendly, but never think someone on an executive position is *your friend*.
Heres a list of articles and conference talks I've gathered up, from authors like UncleBob, Eric Evans and Martin Fowler. I think they can give you the most important knowledge about software development. Its not specifically about PHP though, its stuff you can use in any language. It goes from stuff about your behaviour as a developer to high level architectures: https://herbertograca.com/dev-theory-articles-listing Hope it helps.
Why have the `property_exists` checks at all? 
Good point, it's now fixed, thanks for the feedback
That's great until someone else takes your file and uses their coding style on it.
Yeah, as a dev using a mac, I was like "dafuk is he saying?" The main reason I use a Mac other PC/Windows is that mac is BSD based, so similar in 99% to Linux which you should be using as a web dev, and (we are coming the less valid reasons) some nice dev-oriented apps that I like are only available on mac, the general look and feel, stuff like that (basically more taste related). Windows is nice and all, but if you're a web dev you want a Linux-ish. 
I think those are valid points. But what about Linux/OSX makes it better for web development? I have all of my tools available on my Windows machine as well. Sourcetree, PHPStorm, HeidiSQL, Firefox with Firebug, and a local XAMPP installation is all I really need. I just gotta be careful with filenames, because the production server runs on Linux.
Overall good advices. Some notes though: &gt; Learn WordPress [], as well as under the hood Yes and no. Learn how to debug/use it, but please PLEASE don't take it as an example. Wordpress works, and does its job well, but the source code should not be something to take inspiration from. It really is terrible. &gt; Learn jQuery Please don't. At least not at the beginning. Nowadays, 90% of basic jQuery usage can be done with standard, basic javascript. To me jQuery is only useful for its plugins to do more "advanced" stuff like modals and things like that. &gt; Some may advise you to learn frameworks like Angular JS or something similar. I'm not a fan of these -- I think they can be hacked too easily and also it creates messier programming. Wut? 
Will give it a looksie, thanks. Would it be pedantic to complain that's actually the [observer effect](https://en.wikipedia.org/wiki/Observer_effect_(physics\)), not the Heisenburg [uncertainty principle](https://en.wikipedia.org/wiki/Uncertainty_principle)? Similar, but different. :)
Here's the definition of a Heisenbug from [the Jargon File](http://catb.org/jargon/html/H/heisenbug.html): &gt; A bug that disappears or alters its behavior when one attempts to probe or isolate it. So *yes*, it fits the observer effect better. Still, the word Heisenbug is only *insipired* by Heisenberg's uncertainity principle and is not a literal translation into software :)
But is that the kind of surprise I like? On a more serious note, can this setting be applied to a list of hosts? Or is it an all or nothing thing? 
Yeah, I remember the term from one of Jeff Atwood's [blog posts](https://blog.codinghorror.com/new-programming-jargon/). But ah, I like the name even if it's slightly-off. Flows much better than Observbug.
That's fair enough then. 
If we were using PSR-4 autoloads, we'd have a single package (as far as Composer is concerned) with all internal class accessible and shared external dependencies. With the approach used in the series, each packages (like `navigation`) have their own external and internal dependencies. This starts to become useful when you also to create different applications in your MonoRepo: app_1 could be using package_1 and package_2 while app_2 could be using package_2 and package_3. I've only used `*@dev` so I wouldn't know if Composer is able to checkout the correct versions if you use anything else.
Cheers, thanks, I'll keep an eye on it
Programming is 75% talking to people to understand their problem, their need, their goals, and their schedule, 20% designing the simplest possible solution that acceptably implements this in an inexpensive (time and other resources) way, and 5% in front of a keyboard punching keys to actually produce code. Code is worthless, **solutions** is the only thing that matter, and code that doesn't fit the problem/need isn't a solution. Too many programmer think they're there to produce code, which isn't correct. If you're always bothered by changing requirements and moving deadlines, then newsflash, this is because you skipped the 75% part and now have to pay for it by having ill fitting code, disrupted schedule and no coherent design.
PHP Storm is such a great IDE it almost feels like cheating.
PHP surely can't have enough frameworks. The more there are, the greater the competition, the less might on bigger frameworks, the higher probability that they will patch stuff and secure things fast. Competition is always a good thing. Remember that in your life, always.
but using xdebug with VI is so hard :) when dealing with comparison operators: use === / !== instead of == / != always, until you really learn the difference and know the very rare cases when == is prefered. 
Never use MD5 or SHA1 for hashing passwords. Just use Bcrypt with 12 or 13 costs...
I doc block all my methods so that the [API](https://www.opulencephp.com/api/1.0/index.html) documentation is easy to browse. I don't over-comment the actual code inside methods, just the method doc blocks.
for simple stuff i always use upwork.com ... alot of php developers there from countries with other salary levels so ... especially stuff thats easy and needs little communication is easy to get there
Use MVC as your primary pattern for developing PHP based web apps.
Thanks. Yes, registering another template engine is [very simple](https://www.opulencephp.com/docs/1.0/view-basics#registering-compilers). Since Opulence is a PHP 7 framework, there's no conflict with ASP tags because they were removed in PHP 7. I find Fortune simpler to create directives and functions for than Blade. It also has 0 dependencies, making it easier to port over to other frameworks and libraries than Blade. Twig is very powerful, but I personally am not a fan of its syntax. However, I understand that many people might want to continue using the templating language of their choice, which is why I made it easy to swap out. Although designers don't know PHP, writing views isn't limited to them. I'd rather make it easier for devs that write views than to make it more difficult for devs and designers to write views.
Can you elaborate? I guess you had bad experience with PHP, but why?
Resdtone 2 will include ubuntu's console
also it makes you understand your code better, many times I have stopped myself mid commenting "wait a second... didn't I already had a function like this?" "this description is too vague... i am sure this function does this?" "maybe it shouldn't return false, it should throw an exception instead"
I keep hearing that PHP is the best language to freelance with. Is this true? If so, how do you get started freelancing? 
I use public properties for example purpose. You can use protected or private properties this has not effect on this library.
You may want to look into something like [Vagrant](https://www.vagrantup.com/) to use for development. Lots of people are saying "work on a Mac!" or "work on Linux!" but I say "work on what is best for you" and then just use good dev tools.. If you're not familiar with Vagrant, for web app development it basically runs a headless VM on your system and maps your project folder to the web server's root on the VM. I'm giving you a quick-and-dirty explanation but I'd recommend looking into it, because it really does solve the problem of having to configure your dev machine with all kinds of extensions and add-ons just to make it feel like a prod server (and then having to re-configure between projects etc).. 
Are you looking for the basics? Because then this book by Dayle Rees will be a great one: https://leanpub.com/php-pandas
array_column ... :D
somehow hiding all the stuff that makes it easy to navigate and putting it to fullscreen seems the opposite of getting more productive. what makes it easy to learn all of phpstorms key combinations (if you aren't used to them from working with other idea based ide's anyways) is the "Key promoter" plugin, which, whenever you do something by mouse will display the key combination you could have pressed. 
There are two types of CDNs: Origin Push and Origin Pull. Origin is your web site, and if you have a Push setup, that means you have to push the files to the CDN first. Complex setup. In a Pull, you just refer the CDN URL, and CDN will fetch the file and cache it if it does not exist in their cache. Pull is the most popular, and is very simple. What I have is a hook in the function that converts relative paths to absolute URLs. If a CDN is enabled, it replaces the base URL with CDNs. This switch is helpful because you wouldnt want to use CDN in dev and staging sites. 1. In a push setup, yes. In a Pull, the CDN will pull and replicate your assets folder structure as it downloads files. 2. Push: no. Pull, yes. 3. A simple str_replace or swapping your base URL with the CDNs would be a bare minimum solution. You basically need to swap the host with the CDN's host. CloudFront supports custom cname domains, and SSL certificates for free for browsers that support SNI. You can use your own domains like cdn.example.com instead of the cloudfront.net sub domain. 
just ordered the book thank you 
but recommends learning wordpress
Semantic distinction here, or perhaps perspective difference. Code isn't worthless. Code is often the foundation of a solution (process modification often is another, avoiding the need for code altogether). But code isn't worthless. "Solutions are the only thing that matter" is perhaps too narrow. I've run in to too many projects that were garbage code but "hey it works!" and the 'solution' to the current problem was prized above all else. The problem comes in when changes are needed (not during initial phase, maybe 6 months to a year later, for example). If the mechanics of the code are horrendous (and many are) it doesn't matter how good of a business solution the current state is; it is now a problem/impediment to the required business changes. This is probably more an issue of semantics, but long term maintainability is something that new devs overlook. If you've never had someone call you about code you wrote 10 years ago *which is still in production*, and then had to go fix it, you've never experienced *why* the code itself - done properly - is important. It's not worthless. Think of it as a 'meta requirement' - maintainable code should be a baseline underlying requirement, even if it's not expressed by the client/employer up front. They don't know any better; you should. Practice going in to other people's old code and try to make a substantive change. How easy is it? What problems did you hit? Do you think you have ways you could do it better? Document those steps out; practice writing code that avoids those problems. And... I'm possibly strawmanning your point, and don't mean to. You *are* correct about the understanding part. Very few projects ever fail because someone failed to put values XYZ in to a database table - even newbs will get there in the end. Projects fail because people don't have a solid, shared understanding of the problem, the end goal and the timeline. Communication is key, and it's something you can likely only get better at with practice, but being aware of the need for it up front, as opposed to making too many assumptions up front, will save you years of learning. I might also quibble with the 5% time. Often it's more, comparatively, and to give people the benchmark that they should only spend 10% as much time coding as they do in meetings is not necessarily the best guideline to set. Agreed that generally communication before and during dev, but the ratios won't be the same for each team or project.
Oh no, he is, believe me. I've even stayed at his home as if I was his family on one trip. I also know a bunch of things even before my company bosses know them, even though sometimes that shouldn't be the case at all. (Of course that doesn't mean I can't get fired or whatever, I know that)
You'll work on websites or webbased applications forever. And you'll only have time for exactly that. You wanted to make a game? An app? You're here forever.
Moreover, a mixture of Redis and Media outlet seems like something so wrong to build upon a CMS, use a framework, or drop the Reddit part :)
He's from Tom the php4 days, he's seen some shit. A man is never the same after php4.
We actually have a new Head of Technology who has rapidly gotten fed up with this shit and I'm writing an email to our provider to set this up. I'm ecstatic. I just broke code because I was using php 5.6 syntax.... I cried.
Hell, I have a mac and I still run a ubuntu virtual box on my machine for developing.
NP8 is a Drupal distribution used by many newspapers and media agencies: http://www.md-systems.ch/en/blog/2015-03/np8-is-ready-to-go 
I am a long-time Drupal developer, have a few core commits behind me, and believe me, starting with a Drupal distribution when you have an idea of your own business is always an error. Drupal is a complex product, hard to learn and hard to masterise, when you use a distribution you add hundreds of contributed modules on top it; every change you will need to make will be difficult to achieve, bring lots of regression, and your implementation choices will be restricted by the modules in use. In the end, for sure, your product will be a very slow beast, and you won't be able to maintain it.
Tried their demo, it seems to be an interesting tool, but I never managed to see the front site because there was exceptions all the way and debug page showing up.
No, but the boss is.
I don't take those jobs. I stared working at an ad agency building web apps for promotional activities and learning on somebody else's time. Met the right people, did some networking, met a guy through a friend of a friend, and now I spend two days a week maintaining an app I've built over the last few years. Sometimes it's a shitty language, but with the right tools it's done well by me. 
Yo! I'm probably one of those guys! I'm still learning, but what alternatives are there to those 3? Recently, I picked up " ternary operators". I assume this is what you mean? If/else's becoming akin to E.g.: sum += value &lt; nextValue ? -value : value;
I wouldn't say it's necessarily the best language to freelance with (in fact, because it doesn't have strict conventions, it makes it a terrible language to share development work on - you need clearly defined standards and frameworks), but most of the Internet runs in PHP, so it's probably more the case that there's plenty of work out there. For freelance work, PHP is a good choice. If full time employment was the goal, truthfully I'd probably learn Java or C#. Python is great too.
Tabs &gt; Spaces
If you use [babel](https://babeljs.io/) there is a [`transform-remove-debugger`](https://www.npmjs.com/package/babel-plugin-transform-remove-debugger) plugin that can be conditionally applied when building for production. Use that and never worry about leaving one in your code again.
It depends on your point of view. Seen as a developer, you want to adapt the product (NP8) to the perceived business case. Fully understandable, you'll risk breaking the product, better start from scratch. But as a product user, you will make use of the end product (NP8) to conform with your business case, without changing the tool. That's why Wordpress has such a high market share. It's used as a finished product on which you apply a theme and a few add-ons. It also keeps cost manageable. Buy a product, customize what is meant to be customized, deliver and focus on the business, not re-developing x modules because you want that block to appear based on a rule that must be compatible with OG 2.x (you know what I mean). As a Web Developer, you do not always have to re-invent everything all the time. Most business owner ideas are weak and ill-fated, our role is to steer the conversation to the content that is pushed to the Web instead of the tool that is used to push the content. 
I'll look for a grunt plug-in when I'm home. Also, would jshint fail over debugger statements? 
I think the reason this library is more complicated is because using the specification pattern with the repository pattern is simply difficult. For example, you have a Users repository interface that is implemented via some DB persistence but also InMemory for testing and maybe even a Redis. interface Users { //etc } class DBUsers implements Users {} class InMemoryUsers implements Users {} class RedisUsers implements Users {} Now let's say the interface defines a method such as: public function findForSpecification(Specification $specification); Using your UserIsAdministrator specification, it's pretty easy to implement when using an InMemory repository, but for a DB or Redis, it's not (would you want to iterate over every user in your DB to see if it's an administrator?). In my own opinion, I've always like the idea behind the specification pattern, but haven't really found a good way to implement it for repositories. 
I do agree with this reasoning, it's definitely true; nevertheless, if someone tells me "I am a PHP developper with experience and want something simple" I definitely won't advise a Drupal distribution :)
Thanks for the clarification of my statement. Couldn't have explained it better myself.
+1 to using version control. 
I very rarely need to do *either* of those things, FWIW. More often than not, the only thing that xdebug is pointing out to me is that a variable has a value I didn't expect. More time than that (for me) in xdebug is wasted time, because thinking through the execution flow, rather than watching it and hoping I spot inconsistencies is a much more effective path forward. You don't *need* a debugger in *any* language. PHP is simple. If your application is making it complex enough that you *need* a debugger, that, to me, is indicative of a problem with your application.
That's certainly a relief. I'm still getting used to wrapping my head around the ethics of OOP, specifically, polymorphism and interface uses.
i'd be interested in comparison vs NetBeans
But at that point, you're basically emulating printf-debugging. You can only execute a series of pre-determined instructions (be it printf or more complex stuff), which could have been hard-coded in the program in the first place, and they would have been much faster.
I've spent many frustrating hours trying to get PHPStorm to play well with my Vagrant VMs, and to this day I'm still stuck with debugging with var_dump because something in the settings is borked and I can't figure out what. I love PHPStorm otherwise, it's like the best IDE I've ever used. If anyone knows how to make that shit work properly, please let me know.
So basically, it finally implemented some features PHPStorm has for years now. I'd always prefer Netbeans over Eclipse, but honestly, there's no better IDE for PHP than PHPStorm (Annotation support etc.)
I basically just instanceof on the specification object in the repo. I tried things like class SomeSpecification implements XXXSpecification, where XXXSpecification implements the translation to backend XXX, but sometimes specifications are complex and require additional dependencies (depending on the backend) to be tested, so no cigar. Instanceof felt weird at first but in practice it works great.
While that's true it has the advantage of you not forgetting to remove your var_dump()'s later on (eeeeehm), is more flexible (you can easily turn it on and off and continue) (i.e. break somewhere else, and when that breakpoint is hit, just enable the other one  sure in PHP you could easily define a global var, but then it's already more complex debugging). The problem with dumping in code inside hot paths is that you get megabytes of data where you have to filter the relevant data out. I'm not saying that print-style debugging doesn't have it's uses; I'm personally using it all the time in PHP (in compiled langs it's not that flexible as each compile typically needs more than 5 sec :x)  where the code I'm dumping from is not hot.
I didn't study, but I earn good money as a PHP-Backend-Dev (Age 25, Germany). I've never been unemployed, I applied once, I worked in 4 companies as a programmer, it usually took me like 3 days to get a new job (I've never been fired, they always came to me for hiring) - Don't be scared, stay calm, sell yourself well. They can't say more than _No_ and there are _enough_ jobs out there. If they wear a suit, they're probably more unsecure about themself than you (or they _have_ to, which is just as sad) - Larger cities usually have more IT jobs, but it happens that they pay less (depending on country and city) - Don't underestimate yourself, don't overestimate the tasks you'll have. Stay cool, if you're halfway good in what you're doing, you'll be better than most people next to you. - You **don't** need to study to get into a job. Even if they say that you need some degree, still apply for it and make sure to present your skills well. - Tell them the price _you_ estimate yourself in (and add a bit!), not the price you think _they_ will pay. If they don't agree, search the next job. - Use an agency. Many of them are free and you'll almost instantly get like 10 companies that you can apply to. Coming from the agency, they read applications more carefully most of the time since it's kind of pre-checked. - **Don't go into startups, find a big company!**. Really, startups close really fast very often. Look for a big company with many employees, you'll be safe for years there and they usually pay a lot more and expect a lot less. What I did to get my current job (Really, I earn a lot): - Created a blog in fluent english with programming-articles that explain stuff. Use your own words, don't copy. Don't write private shit there. - Made a lot of GitHub contributions and own a lot of great repos (active ones, in the best case) - Talk to some agency for programmers, send them your CV - **Take your desired wage and add ~30%**. People pay more than you think, especially larger companies usually care less. - Include your blog URL and GitHub account name in your CV - Go to the interview, stay cool, sell yourself well, speak fluently. I had [Tale Jade](http://github.com/Talesoft/tale-jade), they were amazed and hired me real quick. And most important: **Just do it!** Good luck!
Pretty neat, really having some issues with inconsistent setups at work - two of us are on Windows and one on Linux. Would be really handy if our PHP files were independent of platform
Hacking with PHP book
I tried to learn more about your validation component, how does one validate input, and all I found is ValidationBootstrap which didn't seem to have relevant information. Thoughts?
Yeah, this exactly. I have had many times where had I not had access to a debugger, I'm not sure how I would have solved a problem. It most definitely would have taken significantly more effort and a whole lot more monkey-fucking around. I'm just going to go out on the line and say that if you've never needed a debugger, you've never worked on very complex projects.
So it's a PHP interface library to an existing API right? FullContact I assume is the aggregator of information and this library is just polling that service? 
I suggest you get a waaaaay stronger laptop, if you want to use PhpStorm to the fullest at least. (Also, don't forget to tune your `.vmoptions` file(s)) I suggest a i7 and at least 8gb ram
yes, this is almost like an ad for the FullContact service.
I was looking at something like the UX501VW-DS71T i7-6700HQ 2.6GHz Quad Core 16GB DDR4 SO-DIMM RAM GTX 960M I'd probably upgrade the RAM to 32.
Nobody has mentioned Wordpress yet? Seriously, this is exactly what it's built for. Drupal 8 maybe, but you did emphasise simple. WP with a CDN/subdomain for static components if you like, proper caching - but none of this matters until you're getting 1,000 hits/sec. 
* Don't get wrapped up in continually developing for a platform (ex. WordPress, Drupal, Magento). Instead dive into writing your own solutions to solve these problems. Of course they are not going to be as robust, but if you keep reiterating on these, yours will be better. * Build your own framework, just for learning purposes. By doing this you will gain better understanding of what all that boilerplate code is that Laravel, Symfony and Zend provide to you. Understanding these concepts and how things get wired together is crucial. * Participate in online discussions and if possible attend Meetups or Conferences. * No matter how stupid or simple a solution, save that crap in version control and push it to Github, Bitbucket, Gitlab, wherever. It doesn't have to be public, you just need to have access to it. * SublimeText, Atom and such are great. However, it is highly recommended to get a full IDE, and I would even say well worth shelling out the money for PhpStorm. * StackOverflow, Reddit, and LaraCasts are your best friends. Listen to what they have to say, decide if it is worthy information, and move forward. * Stay out of the PHP Drama. If you follow someone on Twitter or elsewhere who is widely known in the PHP community and they start tweeting about drama, ignore that crap. There is no benefit in participating in it. PHP will still be here long after you, I and everyone else on here are gone. * Don't be afraid to politely tell someone they are wrong and if you do always tell them why, even more important, own up to your own mistakes. We all make mistakes.
This... this this this this this this this this this this....
&gt; So my best tip for PHP freelancing: Don't do it Lol. Are you trying to scare of the competition? Just pick out the nice jobs, where you build shit from ground up or pick jobs that involves well-maintained code. Within your point of view you may say: So my best tip for programming: Don't do it. Or even something like; So my best tip for getting a job: Don't do it.
Skip Chef, try Ansible. A lot less harder to learn and just as powerful.
You could inject your validator into your controller, and then follow the [steps in the docs](https://www.opulencephp.com/docs/1.0/validation#validating-form-input).
I can't agree more. This article was probably the turning point from thinking I understand HTTP to really understanding HTTP. Edit: Another great series is Symfony's "How to create your own framework": http://symfony.com/doc/current/create_framework/index.html
Thing I always loved about Eclipse, it made me feel like a super fast typist. I could key in an entire block of code, then sit back and watch it fill in. Okay, maybe a wee bit of an exaggeration. Still, it was like coding with thick syrup. Never mind the random shut downs where the screen would just vanish. I don't miss it, and I can't imagine even bothering to try it out again.
Just do $estimate *  Works every time. Once had it right by the minute ;)
If you're testing this kind of machinery in your APIs you probably have a lot of repetitive code to determine the HTTP representation of your response at every endpoint. Which is undesirable, as it can be generalized, so then you can focus on what your API does, not how it does it. Define the transport mechanism for response once (i.e. choosing HTTP status, json encoding results etc.) and then test *that* as your transport layer once for all your future APIs, then let your APIs use standard PHP conventions for input and output (arrays for ex., exceptions for errors etc.) and your transport layer can convert it to HTTP for you. For example, for my endpoints, I allow actions to declare themselves "nullipotent" and then I allow access over GET, otherwise I only allow POST, by default. As for HTTP status, my actions throw an ActionException which is converted to status 400, or 200 on returned results (or status 500 for other exceptions, which means a bug in the code typically). No other codes, because there's no need. As you see, a lot of complexity disappears once you make a deliberate choice to keep things simple.
If you're using a framework, chances are that your application can be run as an `Application` class. For example with Symfony: $request = Request::create('/api/v1/fortunes', 'POST', array(), array(), array(), $headers, json_encode(array( 'quote' =&gt; 'Nobody expects the Spanish Inquisition', ))); $app = new \AppKernel('test', false); $response = $app-&gt;handle($request); The advantage of using this approach over guzzle is that your tests will be much faster and more reliable (no network latency or randomness). I'll usually only test the status code of the response, since unit tests will have all scenarios covered. Those functional tests only make sure that everything is wired together (including the database). If you'd like to see a detailed example of how I do it, you can have a look at: https://gnugat.github.io/2016/03/24/ultimate-symfony-api-example.html
pcntl_fork doesn't work when your script is being run as a cron
Unfortunately, support hasn't been added yet for nested array data, but that is on the horizon. I'll add an example to the [existing docs](https://www.opulencephp.com/docs/1.0/validation#creating-custom-rules) to clarify creating rules. If it helps, all of the rules in the validation library are extensions, just like yours would be. If you want to see an example of one, check out the [max rule](https://github.com/opulencephp/Opulence/blob/1.0/src/Opulence/Validation/Rules/MaxRule.php) that enforces a number not be higher than a limit.
At my last job I switched to mysqli from mysql for a major project, and I regret not using the opportunity to switch to PDO.
Take a look at ExpressionEngine. It's a very simplified version of Drupal. It also has custom fields and relationships, making it very flexible.
He seems like the kinda guy I inherit outsourced code from: writing 1 big procedural file that does everything
I use phpunit and mock requests to my API ... 
I use behat and guzzle for API acceptance tests: This is an example I used for a test project https://github.com/aminemat/scheduler/tree/master/features and yes " the application would have to be installed and configured to accept requests" I just point it to a test database and use the PHP built-in webserver, unless I'm using Symfony which takes care of that for me.
Outputs of the Inputs :)
[removed]
Behat, Guzzle, and Service Contracts. Document your service contract (RAML, API Blueprint, Swagger) and a whole world of tooling (some better than others) opens to you.
He wants to test his API, you said you mock requests to your API, I don't see how that works
I think this is the wrong way to do this. It should be handled in a closed list. They should have this discussion, but a debate about an individual should not be hosted in a public forum. 
I don't really understand the vitriol for Paul, I've read his tweets and generally follow the PHP-FIG threads and nothing seems overtly harsh..? 
Thx, I understood that, and it was shorter than the article. I still think I won't use HPKP just-in-case (sounds like a lot more stress keeping key's in safes)
For anyone viewing the thread and trying to figure out context, make sure that the UI hasn't automatically collapsed the discussion thread and hidden the OP or any of the replies - there's only one reply as I'm writing this, but that one reply is very informative and has citations at the bottom.
They seem more formal than the EU parlement, I hope the prime minister secretaries are still having fun, because it should be for the sake of the FIG. It seems rather tense, leads to nothing more than these melodramatic scenarios
It's been a long time since I've deployed it, but I'd say it probably ticks the "good" box too, provided you're not trying to write plugins that hammer the core into something it's not. 
Well, I'm in no position to have an opinion, but after reading through it all, especially the collected "evidence"--some people in there really need to grow some thicker skin TBH.. I'm not calling them posers, but I really wonder if the time spent planning all this, not to mention building up all that unhealthy stress, wasn't better spent talking it over, multiple times if necessary.
Oh look, more politically-motivated group bullying against someone unpopular. I'm totally unsurprised that Anthony and Phil are among those pushing this, given their progressively more aggressive and insulting approach to pushing people out of the community who disagree with their identity politics. Earlier this year Phil took the time to launch into a tirade on PHP Town Hall against Paul and I for disagreeing with his politics. This group of political activists is tearing our community apart. Personally, I'm leaving as soon as I can shift my responsibilities to someone else. I've started having panic attacks, waiting for the next time my career is threatened because I have the gall to speak up about this bullshit. If it's not clear to everyone yet, "toxic" and "harassment" are [dogwhistling](https://en.wikipedia.org/wiki/Dog-whistle_politics) lingo among the regressive left for "disagrees with us". Paul is undeniably vitriolic at times, but he's a great, passionate guy who doesn't deserve to be personally targeted like this. [PHP's community is well on its way to becoming an "inclusive forum"](http://i.imgur.com/YjujXDq.png)
You mock a request and feed it to the router/framework without going through the actual http layer, thus testing the route configuration and API without testing he HTTP layer (Apache, nginx, etc). This is the proper way to unit-test route configurations and will be substantially faster than using guzzle or similar. I you use guzzle, you are requiring unneeded infrastructure and testing systems other than the target system, which is not ideal. 
&gt; Service Contracts Can you elaborate?
Somewhat manually, with Burp Suite and a spreadsheet :(
Thank you for keeping most of the politics out of the post. It's clear that the thread here won't be so lucky. The hate bus has already arrived.
Their JSON and XML assertions seem to be pretty solid. I like that too. Have you seen modules for popular frameworks yet? Symfony, Laravel, ZF (or not) :P If it uses a PHP Browser, i am not a fan of this, but if they bootstrap the application itself and run everything in php without any network traffic, then i think that could be a good solution. (especially since it adds some useful features)
I believe HPHP was supposed to mean "High Performance PHP".
&gt; If you're testing this kind of machinery in your APIs you probably have a lot of repetitive code to determine the HTTP representation of your response at every endpoint. Which is undesirable, as it can be generalized, so then you can focus on what your API does, not how it does it. My examples where a bit wild, i would not repeat myself over and over at those tests. Specific things definitely need testing, like authentication through HTTP auth headers. And those cases are the ones i really want to test. &gt; Define the transport mechanism for response once (i.e. choosing HTTP status, json encoding results etc.) and then test that as your transport layer once for all your future APIs, then let your APIs use standard PHP conventions for input and output (arrays for ex., exceptions for errors etc.) and your transport layer can convert it to HTTP for you. For example, for my endpoints, I allow actions to declare themselves "nullipotent" and then I allow access over GET, otherwise I only allow POST, by default. As for HTTP status, my actions throw an ActionException which is converted to status 400, or 200 on returned results (or status 500 for other exceptions, which means a bug in the code typically). I am doing something similar to what you described there. But the question is not about designing your applications Response mechanism, its about how to test APIs.
Everything that you say may be true without invalidating the concern that any mechanism that gives a person or group power over another will be exploited for that purpose. I think that this concern is a valid and obvious one, regardless of the circumstances. Although you view /u/creatiff's language as regressive, it is clear what his concern is. I believe that focusing on the language is in error.
&gt; He's being put on trial here for his beliefs and **personality** Exactly. There's no specific argument against technical faculties. I think most, if not all of the people listed as complainants would agree that Paul is a skilled developer. Rather, people are upset with how he conducts himself. And when you are part of an organization in an official capacity, and people in that organization become upset, something like this happens.
If I had to define Paul's personality in a few words, the ones I'd use would be passionate, argumentative, having integrity, and controversial. All of these traits make his personality *difficult*, but they're things I look for in technical leaders. I don't want someone dispassionate, reserved, corrupt, or people-pleasing. They need to be willing and able to aggressively defend their position, so that we can come to the best technical decision. It just so happens that being this way makes Paul also unwilling to accept the identity politics bullshit that these political activists are pushing on us. And so, because Paul is *critical*, and these people's ideas only pass muster without criticism, they're trying to get rid of him.
We use PAW https://luckymarmot.com/paw to run API tests. 
Strong criticism is not harassment. Passionate argument is not harassment. The word "harassment" has become practically meaningless now that it means "my pride was hurt".
They're working on a prototype already: [Musings of a PHPDiversity Rainbow Elephpant](https://markbakeruk.net/2016/06/09/musings-of-a-phpdiversity-rainbow-elephpant/) http://i.imgur.com/gNwKkuF.jpg
Just because it isn't *entirely* motivated by identity politics bullshit doesn't mean it isn't mostly motivated by that. I won't speculate as to why Jordi and Fabien are in support of this motion - I'd rather they state it themselves. But I suspect that they don't have any more valid a reason for supporting this than that *they don't like him*, and can do something about it now without being seen as bullying, since there is safety in numbers.
I'm not familiar with any of the players here. For now, what I have to go on is the evidence against Paul Jones presented by Larry Garfield in response to this post. From that presentation, it appears that Paul Jones is a moderately annoying person with some strongly libertarian/conservative ideological adhesions that I would suggest are often more appealing from a perspective of privilege than outside of it, and which are often used to justify insensitivity or domineering attitudes towards those who do not share that privilege. It appears that this is a situation in which ideological concerns that are, strictly speaking, quite orthogonal to the technical development of PHP have been introduced to the discussion. These seem to have been introduced by more parties than simply Paul Jones. There is no evidence presented that Paul Jones was instrumental in their introduction of these concerns. I see evidence of Paul Jones pursuing ideological arguments and introducing ideological bases for his positions within this context. I see clear evidence of other parties quite happily doing the same thing, in the belief that this is normative and justified on their part. Therefore, while it is not clear to what extent Paul Jones may have been instrumental to the introduction and perpetuation of ideology as a topic of discussion within PHP-PIG, it is clear that this topic is a completely normative concern for PHP-FIG to take into consideration. Therefore, I do not see how Paul Jones' ideology can be viewed as disruptive to a group such as PHP-FIG in-and-of-itself unless a pro-actively exclusionary stance has been taken by that group that forbids certain ideologies to its members. Which may be a reasonable goal for your organization, but such is my analysis. What has not been introduced by Larry Garfield is any evidence that Paul Jones has harassed or intimidated members in the manner alleged by the original complainants. Mr. Garfield does not present evidence that Mr. Jones' ideology has been accompanied by disruptive insensitivity or arrogance towards others that is deployed tactically or against anyone in a categorical fashion. The seriousness of this complaint is an order of magnitude greater than Mr. Garfield's presented concerns, if he will accept my apology for saying so, and his feelings about Paul Jones thus seem to be available to us a bit prematurely. The core problem being considered seems to be that of how your organization can best retain efficiency in converting effort and involvement to productivity. It seems likely that Paul Jones has been involved in at least some loss of efficiency in the past, but the magnitude of this lossage is not immediately discernible to outsiders. What will be crystal clear to everyone observing this situation is that, as of this moment, all of you who see such a discussion as necessary are completely complicit in the wastage of that efficiency. You believe, and it may be the case, that the continued involvement of Paul Jones presents a liability so grave that the introduction of new realms of (inter-human, organizational) politics to your organization and the distraction of this embroilment are both absolutely justified by taking this course. You are seeking the least-bad outcome from a situation in which you predict that inertia will result in greater harm. If there is a plan pursue a determined agenda rather than seeking consensus, then you need this to be true, and you should probably take your actions and presentation very seriously, because you have put yourselves into a position where *you* are the greater harm if you are misguided. Furthermore the clock is now ticking. 
Edit: This wasn't constructive. It was an ill-considered way to make a point.
Depends if he wants to eat or not
&gt; However, the traits Paul seems to lack are patience, compassion, and, most importantly, empathy. A leader should be able to defend their position while also listening to and understanding the other side of the argument, taking the time to fundamentally grasp the reasoning and intentions behind the argument. While I don't follow the mailing list so I can't speak to the personalities, I'll say this in response to your comment. There is nothing wrong with him saying "__on this topic, I will not budge__". I would bet money you're being unfair to him here. I bet FrozenFire and others could find and show instances of him displaying exactly the sorts of behavior you're lambasting him for in other instances, __just not this one__. edit: because I just saw this. &gt; However, if your actions gain disrespect and bring a negative impact to the FIG, it hurts everyone, and as Larry put it, outweighs the positives and puts us in the red. This is called group think, quoted below https://en.wikipedia.org/wiki/Groupthink &gt; Groupthink is a psychological phenomenon that occurs within a group of people in which the desire for harmony or conformity in the group results in an irrational or dysfunctional decision-making outcome. __Group members try to minimize conflict and reach a consensus decision without critical evaluation of alternative viewpoints by actively suppressing dissenting viewpoints, and by isolating themselves from outside influences__ You won't see it that way because you're right in the thick of things. But me, I'm an outside, and it's completely obvious by the way you speak about things.
In what way is my example substantively different from what's going on with Paul being expelled and shunned? They're publicly shaming him into compliance on the grounds that they don't like what he has to say or who he is. I guess for my example to be accurate, I'd have to make a modpost calling /u/TransFattyAcid out on being "toxic" first.
The expectations for moderators on subreddits in regards to users and members of a standards organization in regards to other members are different. The rules of Reddit say that one moderator, without consulting the other moderators, may ban a user for any reason, or no reason at all, and the admins rarely intervene. It is up to more senior moderators to police the behavior of junior moderators. The bylaws of PHP-FIG are not the same. To fix your analogy, if you and /u/jtreminio decided that working with /u/AutoModerator was a pain in your ass, and then you got the other four moderators to vote, and the majority decided it was best to part ways with /u/AutoModerator, I doubt anyone would call that abusive. It would be a majority of the moderators deciding that one of them wasn't worth their time. As you yourself have said, dealing with people who actively berate you can cause real-life issues. You're removing yourself from a situation where you have to deal with said people. This is a similar situation but the members here are choosing to remove the problem person rather than leaving themselves.
I use Behat, I really recommend it. Alternatively, there is a tool called Apiary which can help you create an outline and then dump out some tests for you which run in Dredd. 
&gt; There is nothing wrong with him saying "on this topic, I will not budge". I agree - there is nothing wrong with holding steadfast on an opinion. However, going back to the analogy of the leader (and my own experience as a manager), the issue here is how you make others feel while presenting that opinion. If I have a disagreement over a course of action with one of my employees, and I end the conversation with "just do it because I said so", that's going to leave a pretty sour taste and affect my relationship with them. If I take the time to understand their argument, make them feel like they were heard and considered, and then outline my direction in a thoughtful and guiding way, they will accept it much more gracefully, perhaps even walking away happier because of the interaction. While I cannot say that this is exactly how Paul portrays himself all the time (I do not regularly read the FIG newsletter, although I would like to), this is both my opinion based on the things I have seen, as well as the easiest analogy for me to articulate what I feel is lacking and can be improved.
It would be particularly inappropriate for you to act as a partial participant (with clearly stated biases) and a moderator at the same time. You're also creating a false dichotomy here. There is a 2 week discussion period and then a 2 week voting period. If enough members don't want Paul to remain, I guess he won't. That's a democratic process, not bullying. 
I've just read them all. They're laughably tame and totally misrepresented. 
We've had that argument before, and you've not convinced me that there's anything wrong with participating in and moderating in the same discussions. I enforce fairly well-defined rules evenly and fairly, and with amply opportunity to contest my actions. And that's why this is wrong. They're shunning and publicly shaming Paul because they don't like him - not because he's done anything objectively wrong or in violation of their rules.
I'm glad that our brief conversation has given you a chance to express your views on the topic beyond a knee-jerk reaction. I'd suggest you edit some of your earlier posts to reflect your more nuanced viewpoints because they are far more interesting than the vitriol with which your started. Thanks for engaging but it's clear we disagree, so I won't be responding to you on this topic any further. Best of luck with your work to hand over your responsibilities so you can focus on more important things.
Fair enough. I should also mention that Paul is a personal friend that I've known for a long time and I've never known him to be outright abrasive without a reason, but to each their own.
I'm glad Paul has been a friend to you, and am sorry to hear you went through a darker time in your life. I can understand why you are quick to defend a colleague. I don't know if I can continue having a conversation with you, though, if the argument always comes back to this: &gt; this is group bullying purely aimed at *publicly shaming him into compliance* This has been your rhetoric in every post that involved some sort of community self-guidance, particularly revolving around codes of conduct. I simply disagree with you on the merits and intentions behind these types of calls-for-action (COCs, FIG's discussion about Paul, etc.). To me, these are well-intended adults who are striving to improve a community, not a lynch mob looking to expel the few who disagree. Am I right? Are you right? I don't think anyone can say for sure. I do, however, think that it's fruitless to try and convince you of otherwise. I do my best here to provide my opinions and point of view, and encourage others to take a deep breath and put themselves in the other side's shoes for a bit. I do appreciate the conversation thus far, just don't think it's going to go anywhere else at this point. Hit me up on PM, Twitter, IRC, or something, and I'm happy to have more in-depth one-on-one conversations about these or other topics! Edit: That goes for you, too, /u/pmjones. I definitely don't think you're a bad person. Would be nice to say hi in person someday.
I don't think either of the mailing list posts have accused him of breaking any rules. This is not a discussion about rule breaking but about civility. /u/pmjones has arguably not been very civil of late. That is what the supporters of this discussion are saying.
I agree that the hierarchy in play is not the same. I was simply using that as an example (from my own very recent personal experience) to help articulate how I recommend handling a situation where you need to present your argument in a way that doesn't cause the situation to become worse. I believe that tact can be applied to your colleagues, employees, bosses, friends, or anyone in your every day life.
What you mistake for vitriol is simply a strong mixture of passion and frustration. If you think something I'm saying is *wrong*, I'd really appreciate you telling me why. I'm not going to yell at you or punish you for disagreeing with me, but I will say outright that I'll tell you why you are wrong in the strongest terms if I feel there's a need. I strive to be kind and fair, but I don't care much for being "nice" in these situations.
The FIG opened a discussion, willing to hear from all sides and representatives. **If** a vote comes to pass, everyone has the ability to contribute as a democracy. You banning someone on your own accord "because you don't like them" is a straw man argument that doesn't correlate to what's occurring.
Honestly, I think your disagreement with me is mostly borne of misunderstanding my position and my experience. I won't claim I have objective evidence to prove all of my claims. I have some, but for the most part I can only speak to my own experience and the experience others have relayed to me. I have lots of examples I can offer to back up why I believe what I do, and I can only really ask you to trust me that I'm acting in good faith. I've seen a drastic shift in the community's approach to inclusivity and intellectual diversity, and it's happened directly in correlation to the rise in power of a few specific people and their political advocacy. I am entirely open to being convinced otherwise. These people were people who I considered friends until they abused me viciously and directly, and abused their access and influence to shun me from the community. I have been active daily for over eight years in this community. I founded PHP Mentoring, and have done everything I can to be supportive and encouraging to everyone around me. I also co-founded a consultancy whose only purpose was to get developers in the community work, and I've put hundreds of unpaid hours into doing exactly that. I want to believe this community is just becoming better, but the reality is that it's become extremely unwelcoming to anyone outside of the in-group, and it's becoming extremely political. I want things to go back to the way they were, where everyone was friends and everyone was welcome.
I'm pretty sure I can only echo some of the sentiment said in this thread so far, and this is coming from someone who lurks more than contributes to the PHP community (mainly because who takes Joomla seriously anymore...) and some would probably define as the same type of disruptive asshole in smaller circles that some claim Paul is. I've met Paul, I've had a couple of great technical discussions with him. I've got absolutely zero issue with him as a person. But to be quite honest the way some of his stuff reads online, it's really hard to want to converse with him. If he's really becoming that disruptive to things, maybe it's best for all involved parties to split ways for a while, but I honestly don't believe he needs to be witchhunted or chased out because of his personality and his views on some things which contradict others.
Oh, okay. So in your mind the more fair and reasonable course would then be for me to create a mod post on /r/PHP telling the community that some people have complained that /u/TransFattyAcid is a jerk, and we want to ban him. Then, in the midst of the ensuing public shaming, us mods will form our opinion on whether /u/TransFattyAcid is a big jerk who should be banned. We'll then vote amongst ourselves on whether to ban him or not.
The Groupthink phenomenon is an interesting concept. I could see how that may be taking affect here. Whether or not I'm a part of it, I'm not sure I could rationally conclude one way or another. Nice to have that perspective, though. &gt; You won't see it that way because you're right in the thick of things. But me, I'm an outside, and it's completely obvious by the way you speak about things. For what it's worth, I'm not part of the FIG nor do I read the mailing list (aside from when it is shared here). I'm very much coming at this from a general community standpoint as well. I definitely admit that my ideologies do line up with the pro-COC side of things, though, so I may very well be "in the thick of things."
This is still indicative of a code structure where you're tied to the transport protocol a layer or two above where you should. It's not *bad*, but it's not ideal either.
The proposed CoC was sourced from the Ada Initiative, which was a radical feminist organization that was implicated in trying to "collect scalps" by fabricating sexual harassment/rape allegations against influential men in the industry, such as [Linus Torvalds](http://www.breitbart.com/tech/2015/11/04/feminists-are-trying-to-frame-linus-torvalds-for-sexual-assault-claims-open-source-industry-veteran/). The proposer of the CoC was Anthony Ferrara, who directly involved [Randi](http://www.breitbart.com/big-journalism/2015/06/29/harping-on-the-hypocrisy-and-lies-of-twitters-most-notorious-anti-abuse-activist-randi-harper-part-1/) [Harper](http://www.breitbart.com/big-hollywood/2015/07/02/the-fact-and-fiction-of-randi-harper/) in formulating his strategy. She's best known for throwing the FreeBSD community into political turmoil using the same sorts of tactics and drama as we're seeing here now. It doesn't take much cynicism to see the truth of what's going on here.
If you take /u/philsturgeon at face value (and I know that is hard for some people to do) folks who consider themselves "close friends" with Paul talked to him behind the scenes and tried to resolve this without it becoming a public topic. Here's a [quote from Paul](https://groups.google.com/d/msg/php-fig/TDX--AVR45c/o-6FPokwDgAJ) when the vote was held to expel PHPixie: &gt; I voted -1 on the nullification, not because I think Dracony's in-the-group sock-puppetry behavior is acceptable, but because: &gt; &gt; * **There has been no 2-week discussion period, as is customary.** &gt; * This group has no power to nullify, only to expel. I can only conclude that Paul is in favor of a public, two week discussion when voting to expel a member. I doubt he'd want his own expulsion handled differently.
If you are going to mod, put on the mod tag to make it official. And yes, it would be bullying. And a gross abuse of power. 
Just for clarity, what you just said is that you support having a public conversation about how unpleasant/undesirable Paul is as a person - having nothing to do with anything he's objectively done wrong. That's where we disagree. There shouldn't be public shaming of individuals for who they are. You'll never get me to agree with that.
I don't know any of the players here. I don't contribute to any FOSS projects on GitHub. That's to say: take this with a grain of salt. I've been involved for years with community (edit: I should note, literally "my community") activism, and upon reading the responses about Paul's behavior that "warrants his removal", and immediately thought of other members of the boards I've been on. When you have a member that is constantly argumentative, it brings an organization to a grinding halt. Nothing gets done because for every bit of conversation, there is the noise that surrounds it and overwhelms it with its sheer volume. The volume of this added noise detracts from and often runs counter to the mission of the organization, meaning that the only solution is to remove that member for the sake of the organization. I don't know Paul, have never been on the receiving end of his purported vitriol, but I know the person that post talked about: I served on a couple board with someone just like him and almost left because I couldn't stand the constant back and forth that every ... single ... friggin ... sentence generated.
Your comment had no substance, and was purely posted to make Phil feel unwelcome. That's entirely unacceptable in a professional community.
The appropriate way to deal with this would be to approach Paul as a friend, to offer him reasoned and friendly feedback on the ways his way of speaking to some people isn't constructive. Instead, they've made it very clear to Paul that he has no friends in PHP-FIG, and they're seeking to shame him into compliance. This is a personal dispute which should be resolved personally.
&gt; the she brigade You keep stayin' classy there.
[removed]
According to the original post, that is exactly the approach multiple people took. I have even tried to address clearly off topic and unproductive conversation, and was met with absolutely unwarranted vitriol in return. What do you propose voting members do, in the event that many of them approach him privately about this and he refuses to change? What is the next step?
[This reply by someone else in this thread sums up my reply here very well](https://www.reddit.com/r/PHP/comments/4piv4i/phpfig_drama_continues_as_the_group_publicly/d4lmixx).
Being labeled "community figure" should tell you all you need to know. They are not known for their actual contributions - only their online personality.
It's ironic that Paul prophesied the CoC mind cult would be used for this very purpose. 
Yup. What virtuous things I believe according to your worldview shouldn't have any bearing on how my arguments are received, but people like Phil have taken to calling people like Paul and I misogynistic, racist, and hateful, because we disagree with the methods they use. Because of this, people seem to assume I'm conservative (which itself really shouldn't be a criticism worth considering), bigoted, and opposed to the stated ideals the left puts forward. None of those things are true - except a bit of the last one, for the more radical anti-scientific stuff they support. Virtue signalling is, despite what that sneering video would have you think, a real problem. We seem not to be willing to listen to anyone who doesn't first tell us *how much we already agree on everything*. I hate having to do it, because it's fundamentally just ideological bragging.
Absolutely agree, we do that with Symfony but we're not always lucky, legacy code needs testing as well!
Dracony's expulsion was about objective wrongs he was accused of. This is about how much certain people dislike Paul, subjectively.
Eh. I like neither of them, but both of them have contributed substantially on a technical level. They've just shifted themselves to politics more recently.
This looks incredibly petty and political. They're basically trying to kick out Paul because they find him annoying and frustrating.
it wasn't just internals. he quit twice i think. second was all about the code of conduct thing, and saying he's moving to Go. i just wanted it done and see him Go.
Yup. Like a code of conduct. I've stated it repeatedly before - I don't object to the notion of a code of conduct. I object to the one that was put forward, because it was extremely punitive, ideologically-driven, and it created a secret tribunal used to expel unpopular people. I would hope that PHP-FIG could find something better, but then with these sorts of behaviours I don't think they have much more integrity than those who proposed the PHP CoC I suppose.
pretty sure his company still has plenty of php code that he still has to work with. He will likely always be involved in php as long as work requires him to work with php code.
&gt; Can we just start a PHP drama sub? Well, there's /r/lolphp ... I'm sure this thread'll show up there sooner or later.
I usually just say I'm bowing out when I don't think there's anywhere to go in a conversation. I don't take it personally. We've taken the conversation as far as it can go, and we're just circling around moot points at this point. :)
Pixie or PHPixie?
Yup. Someone definitely has you targeted. They report every post you make here, and many of your comments as well. I've asked the admins, but they're more interested in politics than administration these days.
I feel like this is happening because FIG has nothing else massively important that they need to contribute. They got us PSR-0 and PSR-4 which is really what made the PHP renaissance possible (well that and PHP 5.3). NOTHING will ever be as important as defining a standard by code can be easily imported and shared. I mean, we could have wound up with a JavaScript CommonJS/AMD/UMD/ES6 Modules fiasco, but instead we got something totally uniform and consistent that makes serious application development in PHP a breeze. So big thanks to FIG for that, but that was sort of the coup de grce, and am not surprised they've found themselves with enough time and energy to do this in-fighting. Where do you go after PSR-0 and 4?
Yet again you give me a reason to regret having bought your book.
PSR-9 and PSR-10 (Security Advisories &amp; Security Reporting Process) are important and just got a new editor. PSR-12 is an update to coding standards to take into account PHP 7. PSR-1 and PSR-2 are heavily leveraged in the community so updating them seems like an easy win. I haven't read much about PSR-11, PSR-13, and PSR-14, but they all have gotten recent attention on the mailing list. PSR-15 and PSR-16 (Middleware &amp; Simple Cache) both seem to have momentum behind them at the moment. They've been discussed here, on the mailing list, on Twitter, etc. Overall, it feels like the group is working on a lot of things. I doubt any of them will be as prolific as PSRs 0-4 were, but that's OK. There can even have competing/alternative recommendations, like PSR-6 and PSR-16 will be for each other. 
exactly my thoughts, seemed a bit confusing
Hi, saw the post and CMS, loved it initially, however the pricing seems a bit confusing, for example: The free one -- (3 users, 1K content entries, 100K API requests per month) , only 3 users (suppose 3 admins), can write a max of 1000 posts and our app / website can call only 100k API requests per month? Or am I wrong? Added to that: Plus and pro are good but the thing that they offer for the price, seems a lot costly.
We're ok with wordpress but lately looking to go away from the same. 
worth a look, trying in sandbox, thanks :) 
But you would need to install and configure a complete web-server on your build-agents. I like the idea of using the applications front-controller to inject a fake request. Although I can see the sympathy of using real http requests, which would enable you to feed a tester with a descriptive modeling language like RAML. Maybe you can do the same with the front-controller, but i imagine that's quite some work (and mapping) to get it working (at least with most front-controllers i know).
&gt; To me, these are well-intended adults who are striving to improve a community, not a lynch mob looking to expel the few who disagree. Am I right? Are you right? I don't think anyone can say for sure. https://en.wikipedia.org/wiki/Internment_of_Japanese_Americans I guarantee you there were many for whom it was quite clear how much of an atrocity that was at the time. But they weren't listened to. You really need to take step back and ask yourself if people like FrozenFire are really nutters, or do they see something hindsight will clearly mark as a bad idea? The road to hell was paved with good intentions applies specifically to these sorts of issues. And while this is not an atrocity on the level of the ww2 internments, it's still an ethical problem that many people see coming from a mile away.
You can still unit test the class methods themselves without relying on the parent framework, I was just addressing the specific question of testing API routes. 
&gt; while your argument is probably going to be roughly "it's different" Insurance against any future point I have to make? There is no clandestine, instantaneous vote going on. The only people who decide this are the voting members who get to see the whole discussion and decide what they want to do. The power to expel has been part of the bylaws for a long time. &gt; Consider US politics and what would happen if the left or the right actually had the power to bar the other party from being involved in future government. You mean the power to vote a representative out of office? That's the only power being exercised here, and it's already available equally to members of US government as it is to voting members of FIG. So while your answer is probably going to be "no, you're wrong", you're not allowed to have that opinion because it's wrong following my analogy... /s /jk
[removed]
~~Think you're missing the /s /jk at the end there... If not, I don't think we have much left to discuss :)~~ Oh. You were serious? No thanks, I do not feel I need to apologise. Certainly not for obviously indicated sarcasm and levity. I do not agree with the idea you are trying to convey or that your analogy clears that up. But as I said, I'm not interested in conversing with someone who sincerely expects an apology for my previous comment.
So he has no right to speak?
[removed]
Mentioned in the previous post (although maybe unclearly), Documenting your APIs with one of the available formats (RAML, API Blueprint, Swagger) gets you a lot more than just automatic html documentation generation. There's tooling around these formats to spin mock servers and test responses, plus, with a parsed document, you're probably sitting on a giant pile of JSON describing every glorious detail about your API. You can use that data to test all sorts of things.
Can you give an example of a new addition put clumsily? From my experience most of the new stuff tend to behave good and as expected.
The present goal of my life is about avoiding it the longer I can.
Well in the 4th it's still idiotic code like http://prntscr.com/bkdodt and http://prntscr.com/bkdpbl So, from the very beginning these people had no idea what are they talking about. WTF you are recommendinding this old crap that has been just facelifted but remains the same shitcode from 1990s?
Right? I wondered if they were linking to the correct messages.
There are many agencies all over the world that serve one purpose: Finding programmers and get them into companies. Google for them, I'm pretty sure there are some around your location
Should be "all" frameworks with maintained modules. Maybe except microframeworks... But in general they should work to. As an example you can take a test from Laravel demo app https://github.com/janhenkgerritsen/codeception-laravel5-sample/blob/codeception-2.2/tests/api/PostsResourceCest.php
This. Plus runscope
FIG has already solved the problems it was needed for, now it's falling into bureaucratic arguments about topics most of us commercial developers don't care about. All this drama between FIG in the last few months is a joke. Lying members, childish arguments, pedantic bullshit. Take the autoloader and run imo
&gt; Paul is undeniably vitriolic at times, but he's a great, passionate guy who doesn't deserve to be personally targeted like this. This is a very important point. I do not agree with the politic or personal views of /u/pmjones. **But**, this does not (and _should not_) have anything to do with his abilities as a developer. I have not seen him harass members of the community. Maybe he comes out strong and hard on some issues, but is that harassment? Is it toxic? I don't think so honestly. EDIT: I must admit that I do not follow the mailing lists closely, since it's not really aimed at me. I used to follow him on Twitter, where he's pretty active too.
I did some work for a media company, they use Wordpress, which I am not sure I would recommend. Anyway, I don't think that for a "news" site, you want "real simple CMS". IMHO, you need a CMS with rich ecosystem of plugins, support, etc., since you will probably need a lot of functionality beyond a simple CMS.
Interesting pattern, but I'd like to see some more complex examples of that rule-definition language. It is more powerful that Doctrine's DQL for example? (Because DQL is what I would normally use here).
And revoke it, because you know ... VCS history.
A bit off-topic, but I'm impressed by the number of different OS's/DE's they used in their screenshots.
Hey! We're actually working on more straight-forward pricing right now. If you could explain a bit what you find confusing about the current pricing, that'd be super helpful. 
&gt; Hi, saw the post and CMS, loved it initially, however the pricing seems a bit confusing, for example: The free one -- (3 users, 1K content entries, 100K API requests per month) , only 3 users (suppose 3 admins), can write a max of 1000 posts and our app / website can call only 100k API requests per month? Or am I wrong? You're pretty much on point. But the 3 users don't necessarily have to be admins, they could also be simple authors. For smaller sites, and especially static sites, the free plan is a pretty good fit. &gt; Added to that: Plus and pro are good but the thing that they offer for the price, seems a lot costly. We're certainly not the cheapest vendor in the market. I'd argue we make up for it with quality.
1) The function/method declaration (especially now with PHP7) includes most, or all, of the information you would add with PHPDoc - comments written in natural language (the main spoken language of the development team) are so much more useful than PHPDoc-tags. 2) Flame wars always happen. Read both sides of the argument, try to learn something from them and move on. Do not fuel the fire. 3) There's always more than one way to do something.
oh wow what a fail.
He tends to bluntly point out wrongful assumptions and the people can't handle it, so they decided to put Paul's head on a pitchfork.
And if the mailing list didn't use google groups self throttling wouldn't be a problem. I think that rule is dumb. Google groups provides quite a bit of functionality to eliminate email flooding, each user can deal with it on their own. One more reason the FIG has lost it's way. Banning people for excessive commenting? Really? Realllllly?
I think the main point is that Paul is an unpleasant person to work with. I think it's safe to say some members want him out. The community has already lost a few contributors because of him, and the group is now calling for a vote to check if **most** members want him out, or if just a few do. It's alright to start this discussion, IMO, even if he's done nothing *technically* wrong. Like some people said, he hasn't *technically* attacked anyone specifically, but people are just fed up with his attitude. Also, note that if the members **feel** like he's being detrimental to its ability to contribute, he can be expelled according to the bylaws. We're all humans here, not computers, so we know the intended subjective effect of some sentences. There is no need for names to be called for us to detect aggresive behavior. It's not like we have a blacklist of words that cannot be said and, if we manage to take these words out of our vocabulary, then anything we say is ok.
&gt; I'm totally unsurprised that Anthony and Phil are among those pushing this Same could be said about Dracony's support of Paul, I guess. &gt; If it's not clear to everyone yet, "toxic" and "harassment" are dogwhistling lingo among the regressive left for "disagrees with us". So, you've redefined these words to mean 'nothing at all'? Sometimes, people are just plain being toxic and harrassing others. It doesn't matter if they're leftists or rightists, 'toxic' and 'harassment' have very clear meanings. &gt; I've started having panic attacks, waiting for the next time my career is threatened because I have the gall to speak up about this bullshit. I haven't seen anyone going after Paul personally, just after his membership and pointing out his behavior within the list. No one AFAIK has called his boss demanding that Paul get fired. No one's called for Paul to do the walk of atonement. People just want to contribute in peace, and calling someone out for his actions within a forum is NOT a witch hunt. Freedom of speech do not mean anyone can say anything without fear of repercussions. People are allowed to think you're an asshole and they're also free to not want to associate with you anymore. If that's the case, I'd rather see Paul out of FIG than see other representatives leave. &gt;Paul is undeniably vitriolic at times ... &gt; Primary Meanings of vitriolic 1. adj harsh or corrosive in tone This sounds a lot like 'toxic', IMO.
You can get IntelliJ for Java which is practically identical
While this is the overall gist, yes, no one's called Paul a jerk. They called *his behavior*, *within the mailing list*, innapropriate and unpleasant. There is a very important distinction. Paul might not be a jerk as a person, but his attitude within FIG is clearly different than the others'. Some think it's innapropriate, some don't, that's why a discussion is being held. It would be crazy to ignore 20+ complaints from different members, because the secretaries defined amongst themselves what is acceptable and what is not withing the group. They made the right call, opening the issue for discussion amongst the other participants. They should NOT make this decision alone. THAT would be dictatorial.
If you can run commandline tools to run tests, then you shouldn't have any real issues getting behat tests working in a CI context. We test all our APIs with Behat tests; One of our simple read-only APIs (with ~4 endpoints and 3 search options each) has 49 scenarios and 503 steps. Not only is the actual return data checked, but the structure is also checked to make sure it's consistent to spec and documentation.
Please keep it civil.
I think a lot of the issue is, he actually replies back when he thinks someone is wrong with the reasons for them being wrong. I've found there are lot of people who just don't want to know, they want to do it their way no matter if it's right or wrong. One of the quotes in the original email basically said "I don't care if he's right". For a group trying to make standards, being right should be rather important. Edit: typo
I try to install in windows 10 and get this issue =( - phpunit/php-invoker dev-master required ext-pcntl * -&gt; the requested PHP extendsion pcntl is missin from you system. Reading the php documentation i found this Note: This extension is not available on Windows platforms. is there any way to fix it?
Honestly, I feel like that's by pure luck more than because we're doing anything right in the Joomla world these days. Drupal's a bit more complex than Joomla and it's actually increased in adoption over the last year compared to Joomla which has fallen (per the w3techs stats). You've got some of these DIY services like Wix which are too basic for use cases a CMS is strong in. Then there's the flood of CMS platforms hitting the market in the last several years which are still too new for them to have major adoption rates or aren't making a big dent in the market (like Concrete5). Subjectively looking at it, both having been on the inside coordinating release schedules and features and on the outside pissed off at how the project's stagnated, it's at a point where it's too big to fail but too small to grow/succeed.
&gt; but Paul is the one who always throws the bylaws in people's faces whenever he can. In the examples that I've seen (to say I haven't been following that closely up to this point) the by-laws he's throwing in people's faces are the ones he *seems* to think need to be revisited due to ambiguity or whatever. In other words he's trying to draw attention to how they *could* be used and he thinks it needs re-visiting. Having said that - I have NO FUCKING CLUE what Paul is thinking nor what his intentions are. I do not know the man and I'm not trying to speak for him. Only giving my perception.
Honestly though there is a difference between nullification and expulsion. Nullification could mean ALL of his contributions up that point can be nullified. In fact - the CoC itself states as much (I bring it up because I feel like that could have been a motivator for Paul in that issue): &gt; In the event that additional action is required, it may include: &gt; Revert or edit existing commits Reject pull requests Revert/reject wiki edits, issues and other contributions Issue temporary ban (no more than 7 days) It was an important distinction and in the light of something like the CoC, language is important. 
Exactly and to quote from the discussion thread: &gt;Speaking towards open source leaders needing to foster community, I had a pretty negative experience myself with Paul M Jones: https://www.reddit.com/r/PHP/comments/2eh7c7/squirt_php_dependency_injection_with_parameter/ Read it - I do not see harassment. I see someone's code being challenged on it's merit.
&gt; a single individual at an obscure legacy PHP project, great. "An individual who is a founding member of that group, and who is responsible for leading three of its accepted PSRs." FTFY
&gt; Two things that I have never understood are why there's 50/50 argument still over spaces versus tabs The problem is you're only thinking about the left side indentation. If that were all the indentation we did then you're logic is correct but that isn't the only spot indentation is used. Think about lining up array elements on the right hand side. Each array key is going to be a different length (different character count) so if you use tabs that are 2 spaces you're going to have 4 tabs for example but if you use tabs as 4 spaces you're going to have 2 tabs. Now when the other person opens it they have to add or remove tabs and now your code is changing all the time for no reason.
Thanks. Do you use PhpStorm?
As stated in a different reply, it should simply be pay-as-you-go(my thinking here is to have it similar to Firebase). The biggest problem I have with it right now is that adding a user costs $20 a month. I really don't see how that cost is justified and should just be baked into the "records" pricing.
Yes; uncharitably, a "mob" mentality.
Honestly, that's how I learned of him - well more specifically https://github.com/ircmaxell/password_compat and more recently https://wiki.php.net/rfc/adopt-code-of-conduct.
Throttling is so stupid. *ugh*.
 &gt; I've found there are lot of people who just don't want to know, they want to do it their way no matter if it's right or wrong. One of the quotes in the original email basically said "I don't care if he's right". There is a lot to that.
I really wish I knew but I'm in no place to judge because I honestly don't follow their development or news as closely as other CMS' and frameworks which I use more consistently. Every WordPress site I've had the misfortune of getting my hands on has been an utter wreck. It definitely has a market space, but I don't feel like it's the solution for everything like some would make you believe (and the same goes for every generalized solution on the market). I'd love to know what some of these large corporations are doing to make WordPress a viable platform for their large sites. We've got a client at my office who we can't migrate away from WordPress fast enough because her business has grown to a point that their site can't hold up to the traffic demands and is actually costing them business.
&gt; when you are clearly outnumbered in ideology, it may be a good idea to remain silent To me this says a lot about the actual motives. Maybe there is something to what /u/frozenfire posited.
Any community needs to have the ability to police itself and remove toxic actors. A community that cannot will, inevitably, devolve into a backbiting cesspool. I've seen it happen before. We all have. One toxic person can bring down an organization; if they're in a position of authority, even more readily so. Having no accountability for your actions is a great way to encourage toxic behavior. See also: The Internet. Whether you agree or disagree with whether Paul is toxic, the idea that toxic people need to be removed is rather fundamental if you want a healthy community.
&gt; While not aggressive, he has continually showed disregard for the self throttling rules So your first complaint is he sent lots of emails? You know it's not an official rule? Seriously, this guy is taking part too much, he needs to go. I understand no one wants to waste their time with silly email threads they don't want to pay attention to. But kicking people out of a group for having too much to say in a discussion is silly.
So no link, and no record. :-/ &gt; I focus on the present and the future. There's a quote somewhere about being doomed to relive something-or-other ... ;-)
&gt; Nullification **could** mean... Emphasis added. Language is always somewhat ambiguous, and you're quite right that it wasn't immediately obvious the *exact* implications of that wording... ...without asking for clarification. Which was asked, and given. It *didn't* mean anything other than "expulsion for the reason that the original vote was based on invalid information, rather than due to post-vote misdeeds". &gt; I feel like that could have been a motivator for Paul in that issue You may be right, but I feel that paints Paul in a worse light than the other obvious potential explanations do, and as such I'm reluctant to believe it without any proof.
Any plans on migrating to PHP 7? That could potentially eliminate the need of this kind of docblock
&gt; Paul is undeniably vitriolic at times, but he's a great, passionate guy who doesn't deserve to be personally targeted like this. I don't know Paul and haven't interacted with him in any way. I certainly can't say whether your description of him is accurate. However... ...I participate in a lot of community groups, hobby groups, professional organisations, and similar. Being vitriolic would generally be considered a great reason to remove someone from a leadership role, and it *would* often be referred to as "toxic", by people of every political stripe. I have no view on whether Paul should be removed, but I don't think your defence of him as ringing as you imagine, because to a disinterested, outside observer it **SOUNDS** like you wrote: &gt; Sure the accusations are true, and Paul deserves to be removed, but we're mates, so I'd rather not. I'm sure that's not what you think or meant, but at least in the circles I run in, "vitriolic" is a very strong, very negative term; it's a harsh criticism, and I would vote to remove someone I felt was vitriolic from the leadership of any group I belonged to.
Firebug has an option to copy a request as a curl command. Shouldn't be hard to roll your own don't you think?
Same. Type hinting and documentation if the names aren't clear enough. 
Well, if/when you do, I am interested to see it and judge my recollections against it. You know how to contact me. And thanks.
Gotcha. 
Note to self: use a new email address when applying to a job. 
Well, thank you, although I'd prefer it if you remembered that these selections should be accompanied by the context of &gt; It seems likely that Paul Jones has been involved in at least some loss of efficiency in the past, but the magnitude of this lossage is not immediately discernible to outsiders. I will take your comment as a suggestion that you might be interested in my advice. My own suggestion would be to consider the situation as a personal relationship between two people. The bare truth about a relationship is that either person can change it. You don't need to wait for the other party to change it. Either person can decide what they want, and how they want to be treated, and how they are like to treat the other. Neither person is powerless to change what is happening. A relationship is like a transport level. At the transport level of the relationship, it doesn't matter whose *fault* the problems are. The problems are there and need to be fixed. If people have problems with how you are treating them, then there may be an aspect of fairness or unfairness to that, but on the lower level, that doesn't really matter. The problems still exist. People are still experiencing them, and people are still dealing with them by walking away from the group. As an outcome, the group does not like this, and I imagine you can sympathize with that, even while feeling that it is unfair that some people in the group blame you in particular for that outcome. Personally, I believe that your two options in this situation are to treat these problems as real, and undertake to repair them, with or without anyone else's help, whether or not anyone 'ought' to be experiencing them; or accept that the relationship will end.
I do the PHPDoc comments on methods but I don't generally create the external docs.
Two things that stick out to me; First, there is a reason why patterns are patterns and not libraries. This is because their implementation is always project specific. A pattern is a concept guiding (or naturally recurring in) an implementation, not a specific implementation. In this case, the issue is that a repository should have exactly the methods that are required for storing state of the specific entities the application needs and nothing else. A simple repository interface makes it easier to implement the repository with a different type of technology. Having a single possible implementation for a repository which has a number of generic methods for all kinds of applications defeats the purpose of the pattern. Second, a repository shouldn't contain business logic. Neither should a controller. So a controller accessing a repository, as is the given example means that the controller is directly interacting with the storage method bypassing the business logic. Instead, a repository should be an anonymous implementation detail of the respective service or model that the controller is using.
I've used it mainly for type hinting, and more detailed notes on parameters. I have always kept documentation out of it in the sense of how to use a class or system. Prior I never documented with PHPDoc, and used NatrualDocs. However my team got upset really quickly and wanted an easy way to make changes to the documentation, so I switched to a Wiki system. Then that quickly became outdated since only myself made the changes. So they begged for PHPDocs and while it was more up to date no one knew how to use any one elses libraries because there was no examples, or guides, which is how NaturalDocs and the Wiki worked. Overall I am all for PHPDocs, but it sucks on how to explain the usage of a library in general. I'd rather use a topic based documentation, which is why a Wiki, or even a set of markdown documents is far better.
focus on &gt; this kind 
There was no comparison, just an observation about what happens when you start rationalizing good intentions.
Study a lot. Use sites like Lynda.com before paying out for a qualification.
Looks sweet. Eclipse surely has improved a lot since the last time I used it. I'm glad, even if I don't use it for now.
&gt; That could potentially eliminate the need of this kind of docblock function youLose(array $arr) : array { }
&gt; First, there is a reason why patterns are patterns and not libraries. This is because their implementation is always project specific. A pattern is a concept guiding (or naturally recurring in) an implementation, not a specific implementation. Well it says that its an **implementation** of the pattern &gt; Rinvex Repository is a simple, intuitive, and smart implementation of Repository Pattern with extremely flexible &amp; granular caching system, used to abstract the data layer, making applications more flexible to maintain. I dont really understand what you are complaining about here.. its like saying you dont like a car because you dont want a car.. If you dont want an implementation of the pattern then just dont use that implementation and create your own? This package is all about making your life easy and help you get things done.. Isn't that also what frameworks are made for? They give you their opinion about how things should be done and you can either choose to use that framework, pick something else or do it on your own. &gt; Having a single possible implementation for a repository which has a number of generic methods for all kinds of applications defeats the purpose of the pattern. Every common orm i know of has generic methods to help you out, obviously eloquent has them but doctrine does so too: http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/tutorials/getting-started.html#entity-repositories https://github.com/doctrine/doctrine2/blob/master/lib/Doctrine/ORM/EntityRepository.php#L161 Obviously you are supposed to create your own domain specific repository methods but i dont see a reason why you couldn't do the same here.. in fact the author even encouraged it in his documentation https://github.com/rinvex/repository/#code-to-an-interface How is this different from doctrine? http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/tutorials/getting-started.html#entity-repositories (I assume you don't have the same critic about doctrine) 
I use phpdoc comments almost universally. I generally never generate HTML docs from sources. The comments are more for my own reference than anything else.
Oh my various gods - have ALL THE UPVOTES! The sitepoint article got me 90% of the way there, then the xdebughelper Chrome extension to set the IDE key and switching PHPStorm to listen for incoming connections did the job! I CAN HAZ DEBUGGGING WOOOOOOO
Yes, with SwaggerGen to publish end-point APIs.. can't wait for PHP7, it's completely useless otherwise... other than making simple text-editors look like real IDEs.
Seems like a lot of work went into it. Too complicated for a simple pattern. Caching can be implemented with decorator pattern. Diagram is a little confusing, with entity in one and "Model" on other side. 
I think Paul would agree with me that the importance of a transparent decision making process is somewhat diminished in the fervour of a mob reaction. He's concerned with what he sees as the resolute intolerance of those we find superficially distasteful, and the shaming and calls for exclusion which tend to follow. At least, that's how I have always interpreted his comments. Paul, I have contacted you on Twitter a handful of times, and in return you have always indulged my concerns while remaining civil. In comparison, I've been called weird by Phil Sturgeon for politely objecting to a generalisation, and I've been blocked by Sarah MG for, as far as I am aware, politely objecting to the doxxing of a particular individual.
 @param array $arr @return array ?
https://www.phpdoc.org/docs/latest/guides/types.html you can use type[]. For example string[].
Some comments in this thread notwithstanding, I don't think the response on the mailing list has been characteristically "mob reaction" in scale or tone. People on both side of the fence seem to be airing their thoughts politely.
Ditto. Then again, I don't generally work with massive systems.
retro PHP -- love it!
TIL :)
What are you? Like 12 years old or something? 
All the time, mostly for IDE fanciness. It saves a lot of time, and there's plenty of room to describe a function or class in detail. I usually don't generate HTML documentation pages from these blocks, but I do have one slightly complex class where I do this for. I use Apigen.
If everyone named was treated the same as I was, they had a chance to comment on the substance of the post before it was posted. I am a non-secretary, non-member too; but because I was named I was able to review the content beforehand.
&gt; That message was ignored All things considered, I think previous (negative) interactions between you two may have caused said message to be ignored. Perhaps an example of how tone/negative interactions can actually cause a loss of efficiency? :)
&gt; Not quite the same; this is more like an impeachment, where the organization (not those being represented) hold hearings. I don't understand the difference, in this case. Seems like some folks (named and unnamed according to the secretaries) asked for something to be done, and the only "legal" avenue is asking for a replacement for Aura. I don't see how /u/philocto's analogy conveys the same idea, specifically: &gt; what would happen if the left or the right actually had the power to bar the other party from being involved in future government. Perhaps it needs asking: do you feel a more appropriate (and bylaw allowing) approach is better? Perhaps the group should consider that instead, since as many have said, you are a productive and valuable member to the group. 
Paul is highly intelligent, highly opinionated, and highly motivated. In short, Paul forces people to defend untenable positions and it frustrates them. It is easier for those people to kick him out rather than have to deal with the unpleasantness of having one's positions questioned without rebuttal. I would be willing to bet my last shekel that the people who want to oust Paul do not agree with him politically. And while they all worship at the Altar of Diversity, they fail miserably when it comes to the most important diversity of them all, diversity of thought. 
What is the question, tho?
Some months ago, when I joined Reddit, I had some conversations in comments, with people fiercely arguing that raw mysqli is as usable as PDO. So I decided to come up with an article that demonstrates the difference. Besides, there are still A LOT of people thinking that mysqli is as silly as old mysql ext and thus mysqli should be preferred due to ease of transition. In case you implied a to ask "why raw API if there is a Doctrine", just keep in mind wast masses of PHP users who are using raw API and you have to convince them first, not me. 
Joe_Scotto I believe that being a developer is one of the fields you do not need a bachelors degree. Most the of the stuff you will get taught in your first and second year is obsolete by the third year. Either new versions have come out or the technology has been dropped completely. To me, all I see now when a dev says they have completed a degree, is that he/she POTENTIALLY has the ability to sit and study. Degrees are academic courses and not practical. This means a dev could have passed just by completing tasks incorrectly as long as they had a good essay backing it up. I have no respect for "web dev" degrees. I have one it was pointless. Digital Agency - If you are looking for a non corporate environment apply to a small to medium size digital agency. There will be a large variety of projects you would work on. It will be stressful but you will learn a solid foundation in all areas of web dev not just how to use php. Skills like speaking to clients, frontend skills, working with a small team, managing projects. A lot of the work will be down to you. In house team - If you are looking to just be a developer and not have to focus on anything else, I suggest you go down this route. Usually you would only your tasks. You get exposure to a lot PHP or backend focused tasks. Usually less stressful with a lot of experienced peers to help out. I strongly suggest you chose the type of dev you wish to be as soon as you can: - Backend Dev (With Server knowledge) - Backend Dev (With JS and frontend knowledge) - Frontend Dev (With some backend knowledge) - Fontend Dev (With UI/UX skills) 
&gt; In case you implied a to ask "why raw API if there is a Doctrine", just keep in wast masses of PHP users who are using raw API and you have to convince them first, not me. Nah, nothing like that. I was more being snarky at the click-bait title that you picked.
Well it was a flash of insight a second before posting. Looks like my inspiration failed me this time, as on a second glance I'd rather agree with you. 
I've had those times too, but it's *very* rare, and it's usually because the application I was working on was poorly architected. Fixing the architecture problems alleviated the need for a debugger. &gt; I'm just going to go out on the line and say that if you've never needed a debugger, you've never worked on very complex projects. As I said above, I write PHP for a living. The application I'm on now has half a million lines of code, and millions of users interact with the output of this application every day. Assuming that someone is a lesser developer because they take a different approach than throwing new tooling at the problem is a pretty shitty thing to do.
**Edit:** It turned out you're a bit confused about me being confused about your confusion. Makes sense now. ***** I think youre confusing database abstraction with data access abstraction, PDO doesnt provide the former, but it does provide the latter. Well for example a common use case is to test in your app in sqlite prepared by fixtures
Whatever you call it, you cannot test a mysql-driven site using an sqlite database, due to different syntax flavors. Or I am still not getting your comment.
no, youre right saying that you cant use mysql **queries** on a sqlite db, thats not what im saying. but it is possible through **database abstraction**, for which pdo is a good choice to pick over mysqli since we are building a dbal ourselves and we know we are using sqlite to test, we just need 2 adapters, so we are using pdo for the **data access abstraction** we use symfony + doctrine for everything, no exceptions. its very easy to switch configs between environments and test on a sqlite db with just a few lines of code assuming everything is setup correctly 
I just sit back and enjoy the replies.
Use a powerful ide like netbeans or phpstorm. Learn the fundamentals of php first, before moving onto frameworks and cmses. I cant stress this enough. Be consistent with naming conventions and standards. Leant MySQL, jQuery and scss. Don't be afraid to ask for help. Above all enjoy. Webdev is a great way to make aliving 
I would like to add one statement before your first and say "Learn to comment", and also, write clean code that is equal to less comments in code :)
Gildworthy post right here.
&gt; Well, I'm in no position to have an opinion Why are you posting this, then?
Check out [this](http://stackoverflow.com/questions/12859942/why-shouldnt-i-use-mysql-functions-in-php), and [this](https://wiki.php.net/rfc/mysql_deprecation). It's depreciated. The documentation needs to be updated. Your next comment will probably be an argument about how "that's not mysqli," but that's kind of irrelevant. Mysqli was a wrapper for a lot of those functions. It updated the procedural code for an object oriented paradigm. Bottom line: use PDO. It's not that difficult. Try [this tutorial](http://wiki.hashphp.org/PDO_Tutorial_for_MySQL_Developers) to guide you into using PDO.
[removed]
I'm really sorry to hear you funded this. Maybe you can pursue a refund on moral grounds. Try appealing to his good nature.
I wish that was the case.
He also left Google.
Array's are just one example. If you don't do any right side alignment that is probably okay, rather annoying though when you have an array of 50 items and none of them are lined up. Tabs usually break any kind of multi-line break though. I am aware that there are ways to fix this by not having a string, parameter, etc on the first line but instead starting on the 2nd line but why make the file longer than it has to be? The original reason for tabs vs spaces is editors were not customizable back in the day. You couldn't say "hey make a tab 2 spaces" for example. Now most editors are customizable but with that said I've run into so many situations where code just looks horrible when you use tabs so thank goodness editors will let you easily convert a file and reformat code with 1 click. 
Someday we will see generics in PHP... and typed properties... someday...
He said he doesn't hate Paul. He never said that he disagrees with the post, nor disagrees that Paul has been disruptive and vitriolic in the past. 
Real developers use middle-click.
mysql_ functions are deprecated, mysqli_ functions are not
Say NO! to make projects with CMS (like wordpress). You should prefer development frameworks (Laravel) or APIs building.
Consider this: A member gained his status by skewing the usage data of his project and outright lying (unproven directly, but the evidence is substantial). A vote was called and it was basically decided that "whatever, we just may keep him, he seem passionate". A member is abrasive (not abusive) but very passionate and commited to FIG and PHP in general. A vote is called to kick him out because some (idk, majority?) of the members feel it's hard to communicate with him. I can only come to the conclusion that it's fine to lie your way into the FIG as long as you then try not to hurt anybody's feelings. Lately it seems FIG and it's members are living in a bubble and don't know what's happening outside of it. I know they technically don't have to, as FIG is supposed to work towards framework interoperability, but it would be nice to peek outside it once in a while. What i mean is: - This individual is toxic to the group and is therefore directly affecting the ability of the group to perform its aims - Examples? I've seen some abrasiveness, but can we have examples of this toxicity? - I believe this individual is the sole biggest cause of loss of respect and members for the FIG - Yeah, right :D The biggest reason would be politics. Closely followed by the questionable decision to keep a member who entered based on lies (again, unproved if the member did it on purpose). - I stepped down as a voting representative due to this member - Why, what did you dislike? Etc, etc? - The presence of this individual makes me not want to contribute or get involved with to the PHP FIG - Once again, why? - My main problem with him is that every time I opened a threads lately to read up, he's getting into some tantrum with other over small meaningless things. Sometimes he might even be right but honestly I don't even care whether he is right or wrong. They is just plainly disrupting the FIG at this stage. He used to be annoying, but I was fine with that, this is just disruptive though. - This is just sad :( "I don't even care whether he is right or wrong" Basically if you wish to discuss this publicly, you should provide the public with all the information on the subject, so that people don't start to guess everything. From the outside, this whole thing seems like a "Let's keep only people who agree with each other" type of deal which can cause further loss of respect for FIG. TL;DR: If you decided to have this conversation in public (which is nice), you should provide more info on the subject. 
Yes, if you are using mysql-specific features, it's the only choice. 
My mouse is broken, otherwise I would.
You are unbelievable you know that, and you need to stop telling people they are confused it's really annoying, just ask for clarification if the ball doesn't drop. I've explained in multiple ways how the two differ, and what role they play. Re-read the entire thing, because this is very sad. And still youre wrong about your last statement. Choosing the database API is VERY relevant. PDO's DATA ACCESS LAYER is a good foundation for a DBAL, since it has support for multiple drivers, MySQLi DOES NOT, its just an extension for the mysql API. The possible DBAL(that you need to fix yourself) on top of PDO rewrites the queries and emulates missing features. Not that it is impossible to wrap something around MySQLi, we can also go to the moon with a rocket driven by PHP, but the fact that PDO exists for this cause SHOULD hint you to use it for that cause. So if i want to test my shit in something as sqlite, in the way ive told before, which again, is nothing uncommon, (assuming we are writing everything ourselves) then its VERY relevant to choose PDO if i want to rapidly develop 
Having an IDE isn't a requirement either, you can do everything in Notepad. But that doesn't mean an IDE isn't useful enough to be considered a requirement any way
Just in case you forgot: use a new email address when applying to a job.
Well, I'd say I use CTRL+B for this feature more frequently, you don't need to move your hand to the mouse at all. (ctrl+b might be mapped from netbeans, i use netbeans bindings in phpstorm)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
MySQLi is good for one thing though, easy migration of old PHP code written using the old and deprecated MySQL API.
This is not about personal preference, it is about consistency and efficiency. &gt; Language consistency is very important for developer efficiency. Every inconsistent language feature means that developers have one more thing to remember, one more reason to rely on the documentation, or one more situation that breaks their focus. A consistent language lets developers create habits and expectations that work throughout the language, learn the language much more quickly, more easily locate errors, and have fewer things to keep track of at once.  [Eric Wastl](https://twitter.com/ericwastl) Changing the behavior of the existing function would result in a breaking change and yet another disruption during upgrades; we want to avoid that by all means.
Yeah, of course, but it creates another problem of two competitive functions which do almost the same thing. 
I vote to call this function `gettype_real()`
Thanks, that sounds like a good idea :)
Personally I would deprecate it but deprecations are always highly controversial in php-internals that is why I decided to go for the _soft deprecation_ first. Updating of userland code is something we cannot provide and developers need to take care of that on their own. An upgrade is also not straight forward because `gettype()` has different return values.
&gt; This sounds really good on paper but it just isn't possible in the real world. I'd suggest you do more reading about the Repository pattern, including examples. The interface is supposed to be simple, and easy to reimplement. You don't *have* to have a Repository implementation in a project, if you find it hard to do (sometimes there's no point in isolating repository logic indeed). But that's certainly not an excuse for people to write some class with generic CRUD and look-up methods and calling it a "Repository". The term has a meaning. If a developer doesn't give a damn about the meaning, they can simply not use the term to describe their creation. 
Because of the caching layer on top i would assume? It gives you a bunch of common methods that you may use and caches your results while also invalidating old cache on changes which is really convenient. 
&gt; It gives you a bunch of common methods that you may use and caches your results while also invalidating old cache on changes which is really convenient. It doesn't invalidate old cache on changes, just on in-request changes. In other words it detects *some* changes, and blindly misses the rest. If another request has changed the entity you're reading a cache of, that can lead to very nasty data inconsistencies as your app starts seeing more concurrent users. I.e. the irony of "magical built-in cache" here is that you'd only need it when your app sees a lot of use. And that's also when it'll fail most blatantly by corrupting your app state. This is why cache should be handled as a separate concern, with regards to the specific business logic the storage mechanism should implement and with the full understanding of the callers that they may get stale data (which is sometimes ok, sometimes totally not ok). Caching should never be implicit and hidden.
I'd love to see you show me a real world example of the repository pattern with doctrine and eloquent. &gt; The interface is supposed to be simple, and easy to reimplement. I did my fair share of reading and I tried it out myself, but you seem to imply that its an easy task so I assume it wont take you more than a couple of hours to complete. Don't forget to account for the different model class behaviors (setUsername() and $username = ) as well as return types (arrays vs collections) as well as persisting logic (persist + flush vs save()) Go ahead. 
Well, I admire your arrogance, but I don't intend to chew your food for you. From your questions it's apparent you don't understand what a repository interface should be like. I'll just point out again that a repository interface *never* should expose implementation-specific details like Eloquent collections, or Doctrine criteria for input and so on. All input and output should be implementation neutral. This means when you select a result format for entity queries, you can choose *one* of: 1. Associative arrays 2. Entity object instances (as in plain-old-PHP-objects, unencumbered by implementation details). When Doctrine returns sometimes specific to Doctrine, then it's the repository implementation's responsibility to convert it to something generic before it goes out of the repository, so these details don't leak out.
You want me to explain how PHP processes requests? Come on, man...
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
Oh, definitely not thinking of on-list stuff, so definitely not admissible (are we using law terms there yet?) to the mailing list conversation. I think the specific conversation which got Graham to block you was: https://twitter.com/pmjones/status/705793428064444416
&gt; Well, I admire your arrogance, but I don't intent to chew your food for you. &gt; The interface is supposed to be simple, and easy [...] That's so typical.. **you** claimed it was simple and easy and now you pussy out instead of giving me one of those simple and easy examples? My simple point is that it is nearly impossible to abstract everything away so that you can just swap out the implementation for a different one, sure you can create a UserInterface with a getMostPopularUsers() method and then create a doctrine and an eloquent implementation which you can swap out.. But you are not accounting for all the models and return types that you would need to "normalize" in order to swap it out for a different implementation later on.. How would you handle eloquent user models and doctrine user models (entities) ? You could port the eloquent models to doctrine plain old php objects or create a UserService interface that you create a DoctrineUserService and EloquentUserService for that handle the model specific stuff but that is **INSANE**. 
Not so much. It eases clutching to outdated methods. But just slapping on an `i` to each function call is hardly a migration. Moving to mysqli is a bit more tedious. Which is why newbies never bother with parameter binding then.
The cache is at the request level. This means it's both discarded when the request is over, and it doesn't detect parallel changes to the same DB which are happening in concurrent requests. If you don't understand this and the implications of it... Sorry but I was quite generous already, I've given you enough of my time.
&gt; discarded when the request is over Lol what? Why would that be? Do you even know what you are talking about here? I guess i spend enough time with you now, you can go back to your "sexy girlfriend night"
i use them only for type hinting or to declare magic properties/methods 
&gt; Variables in PHP have no type. Yes they do - [gettype](http://php.net/manual/en/function.gettype.php) "Get the type of a variable." It's just that they can be set to another type of value without any problem. 
I'd rather edit that page, rather than cement this inaccurate description with a bad function name... 
Hope that pans out for you soon. If not, there's always other jobs ;)
A value has a type. A variable holds a value. It is reasonable to transitively define that the type of a variable is the type of the value it currently holds. I do agree though that it would be better to talk about values in this context. After all you can also write `gettype(1 + 1)`, in which case no "variable" is involved.
We'll ensure that is is [the end of it] to best we can
PSR-12 works to resolve this.
Of course as a group different specs will have different specs, but just because PSR-0 and PSR-4 were prolific, doesn't mean other specifications have no worth at all. The specifications the PSR accepts to work on have varying degrees of relevance and importance, they don't all have to be game changes to make a difference. * PSR-1 and PSR-2 are now used by a huge majority of Open Source projects and created a standard for coding style fixers and IDEs to have bundled. * PSR-3 is now used to help standardise logging methods between libraries like monolog and implementing projects and has tens of thousands of installs. * PSR-7 has had a huge impact on the future of HTTP message handling in PHP applications and has opened the door for work on middleware (PSR-15 in progress now) and HTTP factories (PSR-17 in progress now) * PSR-6 has helped produce a standard for caching that can be shared between frameworks, libs and applications like Symfony, Drupal and other libs. * PSR-9 and 10 are helping to provide good quality peer-reviewed security policies. * PSR-11 is working to standardise service definitions and container interoperability (.e.g. `$container-&gt;get('service_name');`) * PSR-12 is working to improve PSR-1 and PSR-2 for PHP 7 functionality. * PSR-5 is working to standardise docblocks so you know what your API docs generator/IDEs actually expect and can it makes it easier for people to build other parsers. * PSR-13 allows for defining links/hyperlinks linking potentially to PSR-7 but useful when intergrating and interop between applications like phpBB and Drupal. * PSR-14 is working to standardise an event manager meaning that libs won't have to depend on specific frameworks implementations. * PSR-16 is working to produce a specification for simpler caching than PSR-6 to improve on what we have and provide a compatible alternative for smaller use cases. The FIG is very active, all with things that matter to some extent.
"A few literally got changed numbers while they waited." Please clarify? No PSR number has ever changed, and yes, sometimes PSRs stall in development or take time. The original point here was about making progress on PSRs, which is most certainly happening very actively on a number of PSRs if you look at the repo or mailing list. There have been 4 just go into draft in the past couple of months.
There plenty of interoperability problems left to solve or standards that hold value that can be defined; but yes, as with any organisation, as it scales, gets older and gets larger, growing pains happen, particularly around internal processes. This happened a few years ago with the Workflow changes, and we're now going through a similar period but the FIG will make it through this. I'd also add that there is more technical discussion going on than drama, it's just the drama is more commented upon because people consider it more 'juicy' and requires less technical problem space knowledge so everyone can throw in their two cents. Every political or internal discussion the FIG has ends up on reddit with 50+ upvotes, technical discussions never do with the exception of announcements of new PSRs and going into review stage.
&gt; you don't have an issue with statements like "the variable type of constant FOO is ..."? I do....but only because constants also have a type, so: "the type of constant FOO is..." &gt; It's not as if gettype() only takes variables as an argument. Agree. 
It's not for us to make the arguments for either side of the debate, that's for the voting members/complainants/Paul/community members to do for themselves. All we were doing way moving the discussion to an open location in the form of the mailing list. I didn't want to put words in mouths.
As a general note to you both, I had a call with Paul about this a number of weeks ago when we started receiving complaints and a number of those who complained to us said they'd already tried to reach out to him.
On a side note (as a C developer) there's something confusing me about this code. What do the `RETURN_FALSE` and `RETVAL_FALSE` macros actually do? I'm guessing the first marks the PHP return value and then actually does a C `return`, whereas `RETVAL_FALSE` just marks the PHP return and doesn't return from the C function? At least, that's the only way that the function posted by OP doesn't leak memory? If so, that smells of quite poor design - I'd imagine it's very easy to get those mixed up.
&gt; you need to cast it to zval * basically just to shut up the compiler. https://en.wikipedia.org/wiki/C_dynamic_memory_allocation#Type_safety
&gt; How would you handle eloquent user models and doctrine user models (entities) It's exceptionally easy. Here's a UserInterface that will be consumed by your application: interface UserInterface { public function getID(); public function getFullName(); public function getJoinDate($format = null); public function isCustomer(); // etc, etc. Just an API bucket that answers questions about itself } You then return an implementation of that interface from your repositories, either as a single element, or as a collection of them. You can take the "easy" way out and do what I do: which is make the Eloquent entity implement that interface directly, and then use discipline to make sure you never do anything like `$user-&gt;save();` or `$user-&gt;where('something')-&gt;get();` outside of a repository (since PHP lets you "peek" behind an interface to access methods not exposed by that interface). Or if you don't want to rely on discipline, write a simple mapper function that maps whatever Doctrine or SQL or Eloquent gives you, into a POPO for the repository to return. Now the rest of your application only cares about using something that implements your interface, and your mission has been accomplished - a persistence-agnostic abstraction layer, and an application layer that is now decoupled from the infrastructure layer. Swapping out a storage mechanism only needs to happen in ONE place, and the rest of your application doesn't need to be updated to reflect it.
It was never officially allocated as PSR-4 as the rule used to be numbers were allocated on acceptance votes, then we implemented the workflow bylaw in which we started assigning numbers on entrance votes so they could be referenced by numbers during their development accurately.
I don't particularly like the RFC as it seems to invite to the anti-pattern of dispatching based on literal string values. It feels just as wrong as accessing custom \_\_debugInfo on an object directly to read internal structures. `gettype()` never really was meant to be compared against, but rather as debug function which got abused. The documentation even states "For type checking, use `is_*` functions". Also an if/else structure with is_* functions is faster (as of PHP 7).
The FIG by definition is a popularity contest.
Async queries is the only mysqli specific feature I have used.
&gt;It is reasonable to transitively define that the type of a variable is the type of the value it currently holds... No. So long as the variable can hold values of any type, it is meaningless to say the variable has a type...
Where are the setters for your interface? How do you set data? If you dont have another repository or service class that transforms those POPO into the orm specific models (even doctrine would fail if you use annotations, your POPO are useless) So you have to return POPO from the repository (that implement a UserInterface) then set/get the data, and then return it back to a service that then again maps it to the ORM specific model (Eloquent model or doctrine POPO with annotations for example) Oh, and don't forget to create orm specific service classes to persist / save your entities, since doctrine is different from eloquent here too. Now if you create a generic entity saver interface and create 2 implementations, one for eloquent and one for doctrine then good job but guess what? You ruined the simplicity and the entire point of eloquent at this point. Doing something like this is complete nonsense and insane.
I visited your talk yesterday and it was really good and it answered some questions but not all of them. You were very busy afterwards so I decided not to bug you anymore. Thanks a lot for your talk, the above answers and the tutorial app, they will help me a lot!
Greg Young explained to me that something that already happened in the iOS app is already an event in my system and I think he is right. You make a good point about trusted agents but in this case it's covered. Could you explain what context you are missing to answer the questions perhaps? Also I wasn't aware that Reddit is about flawless English. Probably I made some grammar mistake somewhere but as far as I can see it should be very clear what the questions are about.
Thanks! This has cleared up a lot of things, especially around safe_emalloc and the callback stuff. I had a quick look behind the `RETURN_FALSE` and `RETVAL_FALSE` macros and here is what I found :) `RETURN_FALSE` is just a macro for `RETVAL_FALSE;return` (defined in Zend_API.h line 652 at present): #define RETURN_FALSE { RETVAL_FALSE; return; } That seems fairly simple and straightforward. What confused me was how `RETVAL_FALSE` was defined. #define RETVAL_FALSE ZVAL_FALSE(return_value) That is not at all what I expected, so I dived a little further and found that this is how `ZVAL_FALSE` is defined: #define ZVAL_FALSE(z) do { \ Z_TYPE_INFO_P(z) = IS_FALSE; \ } while (0) This just further increased my confusion so I dived yet even further to find that `Z_TYPE_INFO_P` was defined like this: #define Z_TYPE_INFO_P(zval_p) Z_TYPE_INFO(*(zval_p)) and that `Z_TYPE_INFO` was defined like this: #define Z_TYPE_INFO(zval) (zval).u1.type_info So to conclude I imagine your guess is accurate, but holy crap is the way it's implemented weird :P Are there any internals devs who are more familiar with this who can shed some light?
Well, no visible one but the expression `1 + 1` will result in the value `2` which will be stored in a `zval` internally and passed to `gettype()`, hence, it is a variable but an anonymous one. That being said I think the name `var_type()` is still good because one would never use it for expressions since the type is obvious in such cases. The only reason you want to use it is in cases where a variable is received of which the the type of its value is unknown, hence, you want to know the type of the variable's value it currently contains.
It was right after your talk and you were talking to some other guys already, that's ok. You helped a lot with your talk and with the above comment too. I'll remember it for some other time too though :)
Was hoping for something that returns user-friendly strings for exception messages, but it seems like the RFC deviated from it? We should really get rid of stringly-typed programming: not helpful IMO :-\
Awesome :) Have you got any plans to write anything similar for HHVM? I'm especially interested in how Hack is implemented in HHVM. Is it just some extensions on top of the php core stuff? Or is it a completely separate language?
R-really?
I'd still rely on `gettype()` there: works with previous versions, is good enough anyway, can use `is_*` methods instead. Unless `var_info()` pops up (actual useful functionality), I'll surely vote against `var_type()`, since it can be implemented in userland anyway, and doesn't really fix anything critical (unless I missed a critical scenario/example). TL;DR: YAGNI
While I understand where you're coming from and I agree in some cases it could be better handed like sending one email to reply to 3 emails in the same thread instead of replying to each email by itself. I understand that it can be really hard to keep track of a long and on going conversation that has had say 15 responses in 24 hours. However there are solutions the problem that are not "stop conversing so much". This is the only mailing forum where I've seen such a rule. This implies to me that maybe there is some solution which you guys haven't found. Generally I believe people filter their emails to solve this problem. Also kicking someone out of a group for breaking unwritten rules when you have no many written rules is silly. If it's really an issue make it an actual rule.
&gt; Make the old implementation cached, and then we get a win-win situation where all the previous code works faster. Why would one want to cache the legacy type names? They are not used in PHP anywhere else and we would just waste resources. https://wiki.php.net/rfc/var_type#performance &gt; I didn't understand this bit at all, sorry :-\ As explained in the RFC, it is highly confusing especially for new users that this function tells you that e.g. `1` is a `long` although you cannot refer to it as a `long` in any other context. I remember even how one of internals tried to use `double` together with the typed properties patch and thought it has a bug because it did not support `double` but required `float`. This is exactly the problem that I try to fix. Consistency is endlessly important in a programming language in order to ensure efficiency during development because there are less edge cases a developer has to keep in mind.
The name `gettype()` is off too, so why not fix all problems at once. Having a nice, readable public API is also important.
Fine, but at that point it just isn't worth it anymore. Also, note that e.g. var\_dump() also returns uppercased `NULL`. Regarding unknown type, I disagree, as the value is just as important as an _unknown type_. The variables contents are useless now. Apart from that the only thing you're proposing to change is integer =&gt; int, boolean =&gt; bool and double =&gt; float. We probably should just change `gettype()` here upon the next major version. As even the documentation mentions it shouldn't be compared against, it should be a fairly irrelevant BC break (it's not, but maybe people will then properly dispatch). In that case we don't want _dispatching based on literal string values_ we also don't need all these constants if we anyway don't want to support it.
The PHP community is truly a passionate one, it's comforting to see! I'm not saying these reddit conversations should have happened but It's important to try and balance your time between drama and contributions :) Just think if 50% of people who spent time writing or reading on this thread committed a documentation addition to php.net docs. There's many functions without any docs. There's http://edit.php.net to find the file and post a commit, or you can make a PR on github too! Keep it real PHPC! ;-) 
There comes a point where having more words stops being useful to explain something, and instead starts obfuscating what information is trying to be conveyed, aka "I apologise for writing such a long letter, I did not have the time to write it shorter.". I'm pretty sure that fewer than 10% of the people who 'read' that RFC actually read this part: const TYPE_FALSE = 'false'; const TYPE_TRUE = 'true'; As no-one else has commented on the presence of two values as types. 
&gt; That being said I think the name var_type() is still good because one would never use it for expressions $this-&gt;assertSame("string", var_type(not_a_var()));
Or rather, there should only be `RETURN_*` and no `RETVAL_*`, as the former is used much more often. You can always directly assign to `return_value`. (Or, you know, it's fine as is.)
What you are doing is exactly something you should never do. $this-&gt;assertString(not_a_var()); $this-&gt;assertTrue(is_string(not_a_var()));
Perhaps Coltrame just thought you cache as php arrays, which will indeed be deleted after every request in php-fpm/apache_mod_php setups. However, most caches are built in a way that they are temporarily stored somewhere, either local (when not load-balanced) or in a redis/memcache.
These might help to better understand PHP 7 code: [zvals1](http://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html) [zvals2](http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html) The series you reference was targeting PHP 5 and quite a few things changed in between :) For example, the `Z_REFCOUNTED` conditional doesn't check if the value is referenced, it checks whether the value uses reference counting at all. If it doesn't, there is no need (and indeed, no possibility) to increment the reference count. PS: If you have questions about PHP internals, the best place to ask is [StackOverflow PHP chat](http://chat.stackoverflow.com/rooms/11/php).
Jesus mate... it's an example. I'm not hold your hand. If you need sets, *add them*....
What you just said is at least as vitriolic as what Paul says, frankly. If "vitriol" were sufficient to shun someone from the community, then most of the people "in the spotlight" need to go ASAP. We're a community of software engineers. Almost by our nature we don't have collectively-good social skills. Or at least, the way we engage with each other doesn't look good from the outside.
I know this is not helping, but you should really upgrade PHP. 5.4 has been [end-of-life](https://secure.php.net/supported-versions.php) for almost a year.
This. If you're using any, you should have a good idea of how they work and how they're used. Addressing any open issues you can is a great help for any project.
As someone who have voted more to reject features than accepting them, I can understand how the others will perceive this. First, every open source project has an inner circle. No matter how much sugar we put, that is the harsh truth. If you want to change something radically, you have to get into the circle. Secondly, there is a very good chance that someone else had the idea before you. Those who contribute often are the ones who use it most. If you notice something odd, chances are, the project has its own reasons (technical, historical or political) to do it that way. Three - maintainers will reject PRs that do not pass the tests and add enough coverage to new features you introduce. The more complete your PR, better the chances. Add doc updates, tests, links within the other relevant files, etc. Lastly, the projects that say "No" often are the ones that work better. Larry Garfield did a whole presentation (https://www.palantir.net/blog/saying-no-say-yes) about "Saying No to say Yes". Any features that do not match your projects scope, simply say no. Any fragile code in otherwise stable and well-structured code, say no. They are open source projects. If there is something radical, simply fork and maintain it. They are open source and free. Free as speech. 
I've done some more readings, and digged more deep in the topic and came out with an article about my point of view. Ive just published a new article about Active Repository being good &amp; awesomely usable. Its Part One of Practical Software Architecture series. If youre interested in reading more about the hybrid implementation of Active Record &amp; Repository Pattern, go ahead and invest 10 mins of your time here: https://blog.omranic.com/active-repository-is-good-awesomely-usable-6991cfd58774 It's worth mentioning too that despite the fact that I understand some of the complains here, I don't agree on some, and I do agree on others. These complains I agree upon is the naming, First: I recognize this implementation is a hybrid between Active Record, and Repository Pattern, and it's not pure repository. Second: There's some leaking implementation details in filtration &amp; scoping, and that's likely to be improved in future releases. Here's what I wrote about it: ## A Room For Enhancement Since this is an evolving implementation that may change accordingly depending on real-world use cases, its worth mentioning that the caching layer could be decoupled more, may be Ill rethink the whole caching layer in a Decorator Pattern way. I also admit that this implementation is tightly coupled to Laravel Eloquent in some way, specifically in the context of filtration and using scopes, this likely to be changed and rethought in a Criteria Pattern way in the future. ## The Baseline Design patterns are molds, some like to strictly adhere to them on the basis of principal and well-written code. Strictly adhering to a pattern probably wont give you bad code, but it could take more time and cause you to write much more code. Design patterns are flexible, adjust them to suit your needs. Bend them too much and they break though. I realize design patterns are guidelines, not rules set in stone to be implemented whenever possible. Know what you need and pick a design pattern closest to that.
Would you consider requiring php 7.1 once it has been released? Especially nullable types seems like a worthy addition to this framework. 
Everything changed for me when I started using Tracy\Dumper instead of var_dump(). Would be awesome to see this kind of output from PHP itself. https://github.com/nette/tracy
In OP's defense. If you want to write procedural code, putting it inside of a class is the only sane thing you can do in PHP.
Thanks for the help. The version I posted was a first build, after looking at it for some time I realized I was over complicating things a bit. Here is my current build: https://gist.github.com/TheRealJAG/d2437e76cf6561f06ef559f4a45093a7
Symfonys VarDumper component dump() gets you everything youd need 
I agree with everything you said. Just two points: 1) I personally think that PHP tags should be closed. It just feels wrong to me, because it's like leaving an HTML tag open, or forgetting a closing quote. It doesn't seem disciplined. It's like leaving the fridge open, or not turning the light off. I accept this is my personal view and disagrees with PSR-2, and I wouldn't insist on it from other developers. Maybe I'll get used to it! 2) The point I was really making is fix the problem, not the symptom. Every beginner just makes it work and then moves on without understanding why. If you accidentally make a mistake, your unit tests or the interpreter should kick your ass. Never hide errors when you can punish the programmer and improve the code instead.
It's simpler, which is better but you need unit tests. Try calculating with just two numbers and no operator, for instance.
Well, you could use a framework like php unit. Or, something like: check(10 === RPN::calculate("5 2 *")); check(1 === RPN::calculate("1")); Have your check function output an error message if it fails. Then, as you find bugs or want to implement a new feature, add more tests to prove it works as expected.
Though I appreciate changes like this, wouldn't it be technically better to get this kind of info through programs like xdebug (or other debuggers)?
I'm late to the party and it looks like a lot has already been cleared up. You might want to initialize the numbers array before assigning to it. Also rather than returning text, you should throw an invalidargumentexception
well, yes, exactly. Hadnt considered people going nuts over new features from total strangers, as im not that type of person to do that (Im the type that would fork and forge my own path). In the cases of these projects ive tried contributing towards, has always been within their realm, using their systems, matching their code style, to fix outstanding problems. The "no" in these cases (as these were 0 star 0 watch repos btw) can be attributed to either being frightened by allowing stranger contributions, or intimidation at the throne level: they want to retain total control of their baby. In these cases I cant understand why they wouldnt use a private repo honestly. as for the redis bundle, the pr just got out of hand and I couldnt dedicate the time or resources to accomplish the billion extra steps they were asking me to do before bringing it in :/ Truhfully, To this day Ive just never had a good contribution experience to any project, big or small. Not for lack of ability or attention to the issue, usually just politics as you've clearly laid out. Quite discouraging honestly 
&gt; What you just said is at least as vitriolic as what Paul says, frankly. You seem to have the wrong impression about what vitriolic means if you think anything I just said qualifies. I suggest maybe looking it up and possibly editing your original comment if "hateful, spiteful, bitter, and malicious" wasn't your intended meaning. I certainly didn't present any of those characteristics in my reply to you. &gt; If "vitriol" were sufficient to shun someone from the community, then most of the people "in the spotlight" need to go ASAP. I disagree, but recognize that you probably said this only under the impression that the word meant something else. Anyone who truly is vitriolic *does* need to take their leave. They have no place in a community of professionals. That kind of behavior is what I expect out of /r/php, but not groups like the FIG (or pretty much any group comprised of mature human beings, for that matter). &gt; Or at least, the way we engage with each other doesn't look good from the outside. I think it's very disingenuous to average out Paul's specific actions with those of the software engineer population as a whole here. It seems like you're trying to "soften the blow", so to speak. He has certainly deviated away from mainstream professional conduct within the group, and been responsible for far more conflict instigation than the average member (surely that point isn't up for debate?). Whether that by itself warrants removal is up to the voting members, I suppose. I'd personally prefer he remain in the FIG and simply change how he interacts with people, but I've seen him receive similar advice and not heed it on multiple occasions before, so I'm not sure it's a compromise he's even interested in. If that's the case, I don't really see any other alternative than removing him, unfortunately.
The latest versions of ImageMagick 6 and 7 include the security policy fix, you just need to upgrade your distro/package.
No, that wouldn't work. You'd have to do something nasty like run it through `eval`.
It'd have to be written to that directory as something that'd be interpreted by PHP, which'd be fairly hard to do accidentally.
or pass it as a variable to a function that accepts a callable argument (*call_user_func($var)*, *array_map($var)*, etc or implicitly calling constructors and destructors with *new $var()* or forged *unserialized($var)* )
Nope, not via assignment 
I just discovered about the getimagesize() and it's updated documentation that it doesn't return 7 but upto 7 elements in its return array 
I'm planning to recreate our dev environnment first with docker compose and i'll probably start from the php (the 5.6 one) image.
Between mysqli and PDO, can we have the same flexibility in building queries with prepared statements as we do with strings? Like having a function that can take any associative array and insert/update those fields. Or having optional parts of a query, like an order by or an additional where clause. 
Personally, I use vim myself and I don't consider it a normal text editor. I don't use it for PHP, thought I wouldn't mind if I could get the autocompletion up to the level of PHPStorm. But in general, it's definitely a step or so up from regular text editors. I understand what you're saying, but I don't think anyone is arguing that xdebug is literally a hard requirement for any project, only that it's use is so great that it's a tool that should be in your belt at all times. And maybe it's a tool that works better with certain tools than others. For example, if I'm tracking down a bug or trying to refactor something, the first thing I do is find the unit test that hits that line (or create a new one), and chuck my debug points in somewhere, then run that single test over and over as I continuously refactor. Could be done without xdebug, but as a tool in PHPStorm it's become so useful that I install xdebug along side PHP in any development environment I work in.
Why don't you use `FormData` and [`XMLHttpRequest.progress`](https://developer.mozilla.org/en-US/docs/Web/Events/progress)?
When I read the first sentence I was like "Now he's gonna rage haha" and then I read further and he seemed to realize that he'll just get flamed back and look like a cry-kid so he turned it into an "I love you, everyone!"-post quickly. If just everyone would be like that :)
Ok I missed the entire discussion about this, what were peoples problems with it?
Why was it declined? This was one feature that would have been amazing imho
I always use PDO for new projects, as I find that library easier to use. It is also easy to extend, and it supports multiple drivers, so it would be (realtively) easy to move a project to another DB. MySQLi is great if you have to maintain a legacy app, and don't want to do all the db code all over again, just refactor all the legacy mysql calls to mysqli and it will mostly work out of the box.
Here's [Review of Top 5 Laravel-based CMSs](http://laraveldaily.com/review-top-5-laravel-based-cmss/)
Nothing sensationalist about it. I talk to a lot of people in the PHP community on a regular basis, and they shared their opinions on a current matter. 
I'd be happy to send the money on to the charity of your choice. Let me know which one. You'll need to let me know if you bought the eBook or the paperback, as the royalties are different. 
This is why we can't have nice things.
That's a very different issue than the one OP asked about, IMO.
To be honest, I am not even sure how big a deal the performance is really. Since any time you're going to scale a PHP web site the first thing you do is stop using PHP for majority of requests and use stuff like Varnish. Let's be serious we don't use PHP because it's easy to scale.
&gt; This sounds a lot like 'toxic', IMO. Exactly. I have no idea what kind of experiences /u/frozenfire has had with people who use the term toxic, but I really think he's off base with his interpretation. Toxic behavior is generally negative and tends to breeds more negative behavior or only serve to detract from the situation(just think of toxic waste and it's properties). In that sense of the word I don't see /u/pmjones as being a toxic person. But in my admittedly brief time reading posts on PHP-FIG I end up thinking "Jesus Christ this belongs in a private e-mail or a school yard" when I'm done with one of his. He's not a sole instigator, there's obvious history between some users in FIG, but others seem to be better at leaving it out of discussions where it doesn't serve a purpose. But again to be clear: I'm far from a seasoned veteran in this community. My interpretation should only reflect what a newer(&lt; 1 year of active reading/keeping up) member of the community sees.
It went to a vote before it was ready, IMO. If they addressed the inconsistencies with `__get()` they'd likely get it to pass, even with a performance hit.
Languages don't scale. Architectures do.
&gt; $price to be a float, etc I disagree. Money math should always be done on integers then move the decimal appropriately when displaying the number. The same goes for storing these numbers.
While this is true, some languages are cheaper to run at scale than others.
&gt; He's universally hated by those pushing identity politics on the PHP community Holy shit would you drop this already? Is it not possible to dislike someone for their general behavior without being a militant SJW? And as other user's have already said, personality and, as a result, their behavior within a community is a valid point of criticism when discussing the person's participation in that community. I really don't have strong feelings on this, but your dismissive bullshit is really off putting. 
Keep the money Phil - the technical information in is wonderful and useful - my issues with you are the fact that when you stray from the technical you come across like a Party Member in Orwell's 1984 and your absolute vitriol toward anyone who doesn't seem to hold your victimhood political opinion gets treated by you like a heretic that must be expunged.
Ah, that makes sense, thanks. But how much of a performance hit are we talking here? Is it really noticeable, or only on a nano scale?
I think benchmarks for this RFC show around 15% slow-down when you assign a new value to a property. For internal reasons, if the RFC is implemented, even untyped properties will see around 5% (if I remember right) slow-down due to internal changes to accommodate the ability to be typed.
The hypocrisy of what you're saying seems entirely lost on you. I'm saying little more than "Hey guys, my experience and the experience of many others in this community is that these specific people are going around using political influence to silence and shame people. We should be highly critical of their motives." Whereas, you're being dismissive of our experience, preferring to assume that this group bullying is all done in good faith. Maybe, just maybe, the people disagreeing with this aren't liars.
Excellent argument. Truly top notch.
It's not about "stance in a discussion". People are welcome to disagree with each other in a civil fashion. It's when their behavior becomes toxic and drives other away that they are problematic, regardless of their technical stance on any particular spec. Even Stoustrup should be removed if he were to turn into a belittling jerkwad. Also, to clarify: Paul Jones is no Bjarne Stroustrup. The PHP equivalent would be Rasmus Lerdorf, who has no involvement in FIG.
I'm not dismissing anyone's views though. If I've somehow given that impression I apologize. I think that you've probably got some valid thoughts, comments, and reasoning behind your opinion on this. My issue is that you keep trying to dismiss valid discussion and criticism by labeling it as bullying or "identity politics driven". I fully agree there are some people who fit those descriptions in this conversation. But most of your posts just come off as "they're bully SJWs" without a lot of discussion to accompany it.
My argument is that the key players in this have a clear political axe to grind with Paul, and have openly shit on him publicly before. There are better ways to resolve personal disputes than to open a public discussion on *how big of a dick Paul is*. They are using their political clout to get people to dogpile him and shame him out of our community, as is typical of those of their political leaning. You've yourself admitted that you don't know much about our community. Maybe you should take a step back and listen to some people who do have that experience, even if you don't believe them on the face of it? We're not lying, we don't have an axe to grind. We're just tired of being shit on for disagreeing with these people's identity politics.
I can totally see how it comes across this way. I've spent a lot of time thinking about how to undo this. The problem is, people think I'm acting this way about the PMJ situation because I don't like his views on X or Y. That's really not the case. Regardless of his mens-rights activist background, his love of the SJW List, his constant retweeting of breitbart and other anti-feminism stuff, his confusion over feminism in general, and his fear of CoC, that isn't even the problem. If in the PHP FIG and PHP Internals he was making his points against those in a reasonable way, we really wouldn't have an issue. But, as outlined in the thread linked here, a scary number of the FIG are sick and tired of dealing with him, meaning they're quitting in droves. We can either have Paul sitting there talking to himself (and maybe Dracony) with everyone else gone, or we can keep those members and get Paul out of there. Everything else was tried, and this was a last resort. Assuming I'm trying to knock somebody off just because we don't agree on world views is... well false, but a totally understandable viewpoint if you don't know me well enough to see otherwise. :) 
Yup. It's quite clear from what's written down that you've decided to dogpile Paul because you don't like him. You've previously taken to other outlets like PHP Town Hall to publicly shame him. This is nothing new. At some point I seriously hope you reflect on how your own behaviours are affecting the people around you. We don't hate you - we're hurt by the way you treat us, and you seem unphased by that.
Just because you can doesn't mean you should
I'm talking about you, personally. I know you don't believe you're doing anything wrong, because you have a bunch of people egging you on when you post about it on Twitter, but the reality is that you're seriously hurting good people. It's not some game where after it's all said and done we get to go home and laugh about who "lost". Your actions are hurting people's careers, subjecting them to constant stress and worry, and losing them friends. I've tried to tell you this before, but you seem to think I'm some sort of conservative troll lying through my teeth about what's happening. You have influence. People take action you haven't necessarily told them to, thinking they're in the moral right. You're hurting people. The raindrop never thought they were a part of the flood.
The infighting is a result of people being tired, worn down and out of options trying to get things done _despite_ of this person. With no other options left, they've been forced to try and remove this person, so work can continue on other PSRs. The FIG has lost a lot of members due to being unable to suffer through trying to work with him, so the remaining members feel this is the only course of action left.
If the FIG can't get anything done because Paul is a bit rude sometimes, then the FIG has bigger problems.
The same has been done with you in the PHP community over the years. Perhaps a public discussion needs to be had about telling you to play elsewhere. I'm sure it'll have no effects on your life.
That's absolutely not true. Not to toot my own horn or anything, but the only DMs/emails I get from influential members of the PHP community are thanking me, or asking me to grab a pint. Meeting a few tomorrow now I'm in London. :)
Yup. I'm sure there are lots of people who agree with your bully tactics. Bullies are often popular, because everyone loves to see their opponents "get what they deserve". Just because others agree with you doesn't mean you're right. Just because others are willing to join in on your bullying doesn't mean that it's right.
Many thanks; I've looked all over previously, but couldn't see this (I must be blind!): can you point me to relevant entries in the changelog please?
We use the phpunit + guzzle setup. Requires that a virtual machine be running in order to handle the requests, which is the only way I know of to ensure a proper acceptance test.
[mailing list discussion](http://php-news.ctrl-f5.net/message/php.internals/93858) suggests it has a 15% performance hit on accessing properties, among other things.
I can understand and appreciate that. Sorry if I seem defensive/frantic about this. It's been a huge stress in my life, and is causing me to have to leave a community I've been involved in daily for over eight years now - this feels like leaving a family behind. I realize it's a cop-out, but I don't have the time or emotional energy right now to go through the history of the PHP community and document what I'm talking about. I realize that makes what I'm saying less effective, but my hope is that others who have experienced this same shift in the tone and behaviours of PHP's leadership will speak up.
&gt; a complete web-server Or just use a vagrant box so that you get a consistent machine.
Unadulterated link bait. Don't bother reading. 
Is that not your blog post?
&gt; Posts must be related to PHP, even if indirectly. Where do we draw the line on indirectly? A lot of stuff I see here is pretty vaguely related to PHP, and it's honestly annoying.
Yes. :) It was a joke.
I guess this depends what sort of context your using to define cheapest. If you're talking about labour, licenses, etc then maybe. But if you're talking about the hosting costs, I would disagree. Since you can have other languages deal with a high request per second on smaller machines. Obviously they come with other disadvantages but generally when you're going to scale your application in PHP the first thing you do is put a http caching system in front of it. I've not found that in some other languages they're so quick to do this. But as I said, I don't use PHP for speed. I use it the other benefits, the libraries, the flexibility, the ease of deployment, etc. 
Totally understandable. I try to be open about my experience in the community because at this point I feel I represent a pretty average user in /r/PHP. Folks like yourself are in a position where it might be difficult to see your messages from our perspective. 
&gt; Maybe if you're making a CMS, but I haven't seen anyone deal with varnish for a long time. Normally I see memcached added first, and that's really scaling the database more than the language. I highly suspect you'll be seeing people use cloudflare instead not knowing it's pretty much the same but far less configurable. (But super cheap and hassle free). Also last time I used Varnish was on a social network API, I used cloudflare more recently (mainly to bail myself out of technical debt with ease.) &gt; Well-written PHP on a newer version performs well, period. I believe this is down to what you consider performs well. If you want to have a 1 GB node handle 200 requests per second, I doubt you'll be able to do it with a fully build PHP application without a lot effort. (I'm sure it could be done, using super hot/hot cache patterns, with memcache/redis, etc). But do it in Go is really easy even when you write it badly. &gt; However a lot of it is poorly written and full of technical debt, so during a rewrite into another language, that tends to get cleaned up and the resulting performance gain when there is one is misattributed. This is a very true point. &gt; I'm by no means saying it's the right tool for every job, but if someone is claiming PHP is slow, it's almost certainly not the language's fault. It's not the slowest language but compare it to the JVM and you'll see why nearly everyone moves to it when they're scale goes through the roof. Also while it's not really the languages fault interpreted languages are slower than compiled. But just because I can make a web page reply within 50 ms doesn't mean it can handle as many RPS as other languages can. I remember reading once I can't remember where fastest != the most scalable. This isn't to take away from the language but I think a lot of people overly worry about performance of PHP where most high scale teams I've been in or seen are using full page caching to handle it.
Typed arguments hinder performance of methods where they are used. Typed properties hinder the performance of all properties. Untyped included. At least with the proposed implementation 
I assume this is referring to a (silly) situation where you have a non-`public` property, and "accessing" it through `__get` could return something entirely different? e.g. class Dumb { private int $dumbness = 9001; public function __get($key) { return "Go away"; } } $x = (new Dumb())-&gt;dumbness; // string, not int $y = (new Dumb())-&gt;fake; // this is also a string Honestly, I'm not sure how I'd prefer that to be handled. `__get` is invoked on any attempt to read something that is not a public property, including protected, private, and non-existent ones. It's kind of incompatible at a conceptual level with typed properties. The fact that there may be a non-public property of the same name as `$key` that is being passed through is an implementation detail, not a requirement. I get the impression that the RFC was only providing guidance on the case of accessing a formerly-typed public property that had been unset via `__get()`, which... well, I think the more sane approach is just blocking `unset()`ing typed properties.
If you *wanted* it to happen, you could make it so: class TroubleClass { static function doBadThing() { echo "executing `rm -rf /`\n"; } } class Foo { function __set($k, $v) { $this-&gt;$k = call_user_func($v); } } $f = new Foo; $f-&gt;boom = 'TroubleClass::doBadThing'; But that's horrible for a variety of reasons, and unlikely (I hope!) to ever be done unintentionally.
Oh boy, this reminds me of the time I spotted a live site a while back - used car dealership, IIRC - where every product link went to a Laravel 5 error page. Pretty sure someone must have been fired over that...
Meaning well is not enough; it's the behavior that's detrimental, not just the motivations. Telling folks to basically "just be more tolerant" is not an approach that's ever been conducive to a happy, productive, and well-functioning team.
I'm confused. Are you saying we should be intolerant of difference we don't understand? A mature, well-functioning team of adults should learn to come to understand and accept the differences among them. Paul's a bit excitable. He's no more disruptive than most of them - he's just the least well-understood.
&gt; and your DB abstraction layer I'll have to disagree with that. Input should never be touched - escaping should happen ONLY at output level, not at any time before that. With prepared statements, it's not even needed to escape input. Escaping input before storing it is practically equal to asking for trouble.
By that measure, let's also get rid of Anthony, Phil, and Derick. Because they provoke the same sort of reactions - just from a different group of people. &gt;If the behavior doesn't change, the problem doesn't go away. People do not just "get more tolerant" of things that they find unacceptable, and asking them to never leads to good things. You could say the same thing about gay people, frankly. Social conservatives used to consider homosexuality highly "problematic". Fortunately, you're wrong, though. Having had a lengthy discussion on the matter, society (at least the one I consider myself a part of) has shifted to understanding and accepting these people, instead of considering them provocative and disruptive. There's been a lot of vitriol on the matter, but by and large we've collectively ignored those bigots on both sides of the debate. My position is that we should learn to accept difference in people, even (perhaps especially) if it makes us uncomfortable.
If you don't think it's interesting/relevant, downvote and move on. That's how reddit self-moderates its content.
I don't think "more security" is the key issue people see in CMS systems today. In fact, tiny shared hosting sites aside, CMS security seems quite irrelevant to me, when typically a site would be behind something like Varnish, providing read-only access to the content, and the admin panel won't even be accessible to the world at large.
&gt; If I wanted to build a shopping cart, I wouldn't build on top of a "CMS", would I? * WooCommerce for WordPress * Various Joomla shopping cart plugins * I haven't even looked for Drupal, but I don't need to; several job offers I almost accepted were for Drupal shops so I'd be greatly surprised if there weren't any Typically people go for the eCommerce platforms first, but it's not uncommon to build on top of one of the big three. There's a huge demand for *dynamic web applications* that behave very similar to a blog, even in business needs. I refer to it collectively as a CMS for simplicity (especially since the features we ship are for blogging, but we plan to develop a wide variety stuff in the immediate future atop Airship).
Passport User Database: https://www.inversoft.com/products/user-database-sso
&gt; You can have the most secure core, if your plugins can compromise you, they will. It's guaranteed. It's unclear to me why you're looking to replicate this bad model with your new product. * We require PHP 7, which eliminates a lot of garbage code. * We'll be proactively searching for vulnerabilities in popular plugins. (To anyone unaware: we have somewhat of a [track record](https://paragonie.com/security) for finding vulnerabilities.) * Since we require PHP 7, it's also easier to do static analysis. (Hooray automation!) Additionally, we're going to be developing our own extensions for this, which will be secure. &gt; A "CMS" should manage content through an admin panel, and have an API to access it from any frontend. Nothing more. It shouldn't be a shopping cart, it's shouldn't have a templating engine, it shouldn't manage the frontend at all. For what it's worth, the admin panel is a separate application from the frontend.
&gt; We require PHP 7, which eliminates a lot of garbage code. I'm sorry but this makes no sense to me. Almost all PHP5 code runs fine on PHP7. Heck, a lot of PHP4 code would run on PHP7. How is "garbage code" defined, and why would PHP7 eliminate it? &gt; We'll be proactively searching for vulnerabilities in popular plugins. This only means you'll have very few plugins, or you'll be unable to maintain this without a business model. A good intention is only the beginning. So how do you plan to fund this effort? &gt; Since we require PHP 7, it's also easier to do static analysis. (Hooray automation!) In a language as dynamic as PHP, that won't get you far... Even in PHP7. 
Is the [demo site](https://airship.paragonie.com)'s design some kind of in joke that I missed? Also why does it feel so frustratingly slow to navigate between empty pages? I feel like I shouldn't notice navigating between two empty pages, and there's like 5 seconds of browser loading behavior happening.
You might wanna update your github tagline then :P
Yeah, that's a good call.
Having dealt with the most outspoken folks in that thread, you are both typical of the regressive progressives. You come at any conversation with someone you know holds different political beliefs with chips on your shoulder seeking to be insulted and reading insults when they are not there.
You probably wouldn't use eval because that would execute the bad code. This would probably more likely be a candidate for some sort of static analysis suite or something. 
I'm not trying to discredit anyone. They think there is a SJW conspiracy out to get them, which is a paranoid delusion. Anyone who thinks this way is paranoid. 
So it's not ok when I retweet it, but it's ok for him to tweet it. Gotcha. 
Wut. Even in Wordpress with Varnish, you still need admin panel access. Security is a key issue that people overlook, not a key issue that doesn't exit.
Isn't this wrong https://github.com/paragonie/airship/blob/4d3c60774bad2c870f2a5f7918f789bcf2b17013/src/Cabin/Hull/Landing/Ajax.php#L80 `$blog = (string) $_POST['blogpost'] ?? '';` should be `$blog = (string) ($_POST['blogpost'] ?? '');` https://3v4l.org/WogF7
Something I wonder every time I see someone writing a project for an idea that has already been addressed several times before [1] is what features has project A that can't be found in project B. Seeing the considerable amount of PHP projects like this, can you explain what did you do in your code that makes it relevant against the other options? I took a quick look at what you wrote and don't see anything surprising, just a bunch of _"file_get_contents"_ and _"file_put_contents"_ which by the way some are lacking checks to see if the file is writable and accessible. Can you elaborate on why you decided to write this instead of using something that was already available? [1] https://github.com/search?l=PHP&amp;q=ini&amp;type=Repositories
&gt; Even in Wordpress with Varnish, you still need admin panel access. Security is a key issue that people overlook, not a key issue that doesn't exit. WhiteHouse.gov is written in Drupal. Try to open the admin panel. I'm not saying "log in", I'm just saying open the admin panel page. Plus, yes, people overlook the issue, so they won't jump ship to some new platform that offers to solve a problem they overlook. Developers don't choose WordPress, Drupal and so on because they like them as a platform. It's not because they think a CMS crammed chock full of plugins is an awesome idea. They do it because clients say "I want WordPress and Drupal, and 20-30 plugins from the millions of plugins they have". Talking about security headers and encryption does absolutely nothing to sway those clients to Airship. Nothing.
You're /u/sarciszewski -- Why are you posting under two separate accounts? All you do is spam paragonie.com * https://www.reddit.com/user/sarciszewski/submitted/ * https://www.reddit.com/user/CiPHPer/submitted/
https://www.reddit.com/r/PHP/comments/4piv4i/phpfig_drama_continues_as_the_group_publicly/d4lpoei?context=1 The new account is to reduce the amount of noise the moderators get flooded with because of misbehaving bots. They're aware of my decision and the reasoning for it.
Exactly. :)
&gt; Drupal does come with brute force protection, and modules can extend use it as well. **Default login form is blocked after 5 failed login attempts from an IP.** This goes for password reset URLs as well. These tokens are not created and stored with a CRPRNG, but an HMAC from current password and last login time with a private key. Okay, so 5 attempts per IP address, and most servers get an entire `/64` of IPv6 space (most residences get a `/48`). That's pretty much useless. What Airship does: * Matches username OR IP subnet * Subnets are adjustable based on Cabin configuration (default: `/32` for IPv4, `/48` for IPv6) * Progressive rate-limiting. First you get slowed down by 0.25 seconds, then 0.5 seconds, then 1 second, then 2 seconds, then 4 seconds, ... up to the configured max (default: 30 seconds). This strikes a balance between "preventing brute force attacks" and "not allowing targeted DoS if you know someone's username". And to be clear: that comparison table was explicitly "out-of-the-box". There's a plugin for almost everything. &gt; 2FA is available as a module But not out of the box, so it doesn't count. &gt; Drupal 6 has md5 without salt, but 7 and 8 uses far better password hashing Um, check the table again. Drupal got a yellow box for SHA512Crypt, salted MD5 was a WordPress thing.
&gt; Talking about security headers and encryption does absolutely nothing to sway those clients to Airship. Nothing. It sounds like you think I'm trying to take food off of other peoples' plates here. Please understand that isn't the case at all. I'm trying to strike new ground. If anything, having a secure alternative gives the other CMSes incentives to improve their own security offerings. As for these clients for whom better security does "absolutely nothing to sway" them: Great. That's their choice. They've already made up their minds; why bother them with facts? Very few business people will ever jump on version 1 of any product (unless, of course, they see a lot of potential in it). I'm not interested in stealing clients away. (If that was our goal, we would've put more into the appearance than the crypto!) My goals are simply and plainly stated in the blog post: &gt; Despite its [overwhelming popularity](https://w3techs.com/technologies/details/pl-php/all/all), the PHP programming language has historically had a bad reputation in the information security industry. At Paragon Initiative Enterprises, we want to improve the security and usability of the tools people already use. &gt; &gt; With CMS Airship, we hope to establish the platinum standard for PHP security. The gold standard just does everything that is required. The platinum standard does everything that it can. &gt; &gt; In computer security, *Attacks only get better, they never get worse*. **Today's platinum standard should be tomorrow's gold standard.** Working together, we hope to greatly improve the state of security in PHP applications for everyone's benefit. &gt; &gt; Until tomorrow comes, the bar has been set. Our work has just begun. Let's make security ubiquitous, on-by-default, and as simple as possible. Most of these discussions are an uphill battle on both fronts: * Against infosec people, who hate PHP. * Against PHP people, who think security is a non-issue not worthy of emphasis. Why would I subject myself to that for a short-term gain? I'm in it for the long haul. I'm going to build PHP software that cannot be penetrated without attacking the language or OS. I'm going to make boring cryptography a first-class feature of the language and ensure every tool you use utilizes it carefully, and I'm going to make it simple while I do so. If all goes my way, PHP software will enjoy the lowest rate of incidence of in-the-wild exploits per line of code compared to software written in any other language some day. That's my vision. I won't be chased off of it because some people want Drupal and WordPress and won't be swayed off towards a fresh product that, in their mind, hasn't stood the test of time yet. If they'll ever come around, it won't be today.
I know it's not pretty, but a friend who does UI/UX professionally told me he thinks it has good usability. That's a win in my book.
&gt; Some feedback: Please compare with a modern CMS, pretty sure it can tick all the same boxes. Minimum PHP version, is this a self imposed limitation for the sake of security? OctoberCMS actually fares worse: 1. It added CSRF protection recently, but didn't enable it by default. 2. It hard-codes a [16-byte encryption key](https://github.com/octobercms/october/blob/51446f6a27b5680ba062c5afba71f95c6fda7c46/config/app.php#L84). For background: 16 bytes is just enough for mcrypt to use it without throwing an error, which means the risk for *accidentally making all of your encrypted data decryptable with a known key* is added just by using OctoberCMS. Airship generates keys on first run. From the kernel's CSPRNG. &gt; Also code footprint? This only matters if the features are the same, more features requires more code. That's an informal measurement of "low cost to audit thoroughly". When I factor in strict typing (with return types), and the fact that I've run Airship's core through static analyzers, it's actually even lower.
How do the auto-updates work when deploying to a read only file system, which i'd say is a pretty common thing nowadays.
They don't, unless you run the updates as a privileged user and/or locally then upload them.
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/bohwaz] [Anti-bruteforce policy of Paragon Airship: what every login website should do](https://np.reddit.com/r/bohwaz/comments/4q7p9t/antibruteforce_policy_of_paragon_airship_what/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
You're advocating to keep the status quo because its the status quo, and you're making assumptions that don't at all hold for companies that have someone choose the technologies they want to employ and maintain. Not everybody is using a CMS just for a blog. &gt;Talking about security headers and encryption does absolutely nothing to sway those clients to Airship. Nothing. It does to developers that care about security, it seems like you're saying CMS's are only used for blogs and not for companies that are maintained inhouse. &gt;Plus, yes, people overlook the issue, so they won't jump ship to some new platform that offers to solve a problem they overlook. Then good on Paragon for identifying the issue and building something that fixes it. Ignoring an issue doesn't make it go away. &gt;Developers don't choose WordPress, Drupal and so on because they like them as a platform. Actually, they do. The reason those technologies exist is because a lot of developers helped to make it that way. For the end-developer, sure, not everyone likes it, but it makes money. However, why should new systems not be made just because there's other popular ones? &gt;WhiteHouse.gov is written in Drupal. Try to open the admin panel. I'm not saying "log in", I'm just saying open the admin panel page. You can't get to an admin panel without logging in on any decent CMS, and such a high profile website can afford to do some magic to secure that area from the internet, something not everyone can do. Thats not the only part of securing a website, though.
Might wanna get things more pretty and ready to go for your future show cases. But good work though, Its nice to see new systems that solve some important problems.
Well in the comparison it says `Drupal doesn't have built-in login brute-force protection`. I only said Drupal does come with a built-in protection. It is not really that effective I agree with that. - 50 login attempts from a given IP (supports reverse proxies, etc) per hour. - 5 attempts per user. Both above conditions will apply (5 failed login attempts from different IPs will still block the account). There is no UI, but you can further tighten this up by modifying your settings file (no need of plugins). I'm not saying there is nothing on Drupal's end to improve: - eBay-style user lock-out protection. - Progressive rate limiting (like CMS Airship). My point was the the comparison was a bit misleading. I am sure CMS Airship has gotten most of the things right (I'm fond of your blog posts and have read most of them), but the comparison is a bit unfair for other players. 
&gt; I only said Drupal does come with a built-in protection. You're right. In the interest of fairness, I will update the chart. :) EDIT: Done. You've earned Drupal an upgrade from red to yellow in one of its boxes. Hopefully Drupal 9 will get more green. :)
I'm a bot, *bleep*, *bloop*. Someone has linked to this thread from another place on reddit: - [/r/lolphp] ["Raising the security bar for Php." -- "Oh, I was just careless today"](https://np.reddit.com/r/lolphp/comments/4q7yzf/raising_the_security_bar_for_php_oh_i_was_just/) [](#footer)*^(If you follow any of the above links, please respect the rules of reddit and don't vote in the other threads.) ^\([Info](/r/TotesMessenger) ^/ ^[Contact](/message/compose?to=/r/TotesMessenger))* [](#bot)
FYI there is https://github.com/piwik/component-ini which supports reading and writing INI files with an OO API.
PHP 5.3 is very outdated. Even PHP 5.6 is outdated. Check out Jeffrey Way's newer PHP tutorials on Laracasts, they'll teach you modern PHP programming (5.6 - 7.0).
Definitely try [Concrete5](http://www.concrete5.org/)!
Jesus christ I just entered 1998. You can tell a designer hasn't been near that thing. No offence OP, I'm sure your code is awesome, but I can't imagine many people are going to get past page 1. People expect as much effort to be put into presentation.
very
The TL;DR of the article is: &gt; The PHP Community is who YOU decide it is. Make it a community that works for you. So it is who I decide it is, it is who you decide it is, it is who they decide it is, etc.
Serious question: when would you ever want to match against a subnet? Isn't that just asking for trouble pretty much all the time? (With "trouble" being defined as "user experience problems".) How does progressively increasing the delay help? If it helps, why have a maximum? Why not just enforce a delay between attempts for all users? Make it 1500ms and brute force attacks become effectively impossible.
It's always good to see more people contributing to open source, or given one of your comments here, trying to learn PHP. If I might make a few suggestions in regards to the accessibility of the library, and code style: * You should definitely look into following what is now pretty much _the_ set of coding standard rules for open source PHP: [PSR-2](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md). It is not a requirement by any means, but it will make it easier for people to contribute, and do so in a consistent manner. * You should look into using some more modern PHP tools, like composer. Get autoloading in (i.e. so that `require`ing files is abstracted away, and so you don't get collisions with other people's work). * You should try add some unit tests. Many people simply won't use third-party open-source code without tests. * You could also add an automated build (for something like this it would be very straightforward), using Travis CI. If you wanted to go further, after you've done all of the above, use something like CodeClimate. There are quite a few things to go at there if you want to bring your PHP up to more modern conventions. I took a brief look through the code, and one other thing that stuck out at me was the inconsistency in the comments style. You also have some area of the code that could definitely be refactored as you're repeating yourself a fair bit when you could just make one more variable and remove a few blocks of code.
Poor Laravel! What's wrong with it?
And PHP 7.0 kicks so much ass it would be self-harm to try not learning it right now.
shots fired
Thanks for your critical and thorough reply. I'll certainly look at that coding pattern. Much appreciated. 
This. If I could, I would have raised the minimum version requirement of my code to 7.0 right away.
This would make it easy to deny users from logging in. In general, it would be more suitable to log failed attempts and then based on number of failed attempts, say, in last 10 seconds, to make decision if the login request should be processed (say, you can count logins from the same IP the request is coming, same IP block and same user ID and give different limits on them).
 i think its totally okay to learn the basics of php, 90% of the stuff still applies, and there are only few REALLY USEFULL features you are missing out on, like traits or generators. But to get a basic knowledge about what the language is about it will do its job and any code you produce will still work in newer versions php. if you have a choice then obviously it would be better to start learning php 7 now.
Laracasts is great. Worth looking at and trying a subscription to learn up to date PHP from a great teacher
Thats great news. Looking forward to trying it out. However, I am concerned with the stability of some extensions, especially memcached and igbinary. These are the main reason which keep me from migrating our production system to PHP 7. According to your [status page](http://blog.remirepo.net/pages/PECL-extensions-RPM-status), these are not stable yet. Will they be stable for the release?
Sure, you don't like the guy. Still no need to try and diminish his hard work and behaving like a wanker.
And passing so far!
Reading through the thread, and all the examples of his 'bad' behaviour, I can only wonder how some of the complainants mange to cope with the world. They seem incredibly fragile of anyone that challenges them. Yes some of it was a bit heated, but there was nothing in there that would make me so angry I feel the need to kick them out of FIG.
Hi, I have completed adding all the 16 state holidays for Germany into the master branch. Please have a look. It's targeted for the 1.50 release. 
Honesty it depends what kind of work you are planning on doing. If you are creating apps for yourself that you have complete control over then PHP 7 is definitely where you should begin, and ignore everything that came before it. Nonetheless, a lot of places, and projects are still mainly using code that is based on or compatible with PHP 5.3 or at least PHP 5.4 which is not too different and I can't think of any major forwards incompatibilities. Like others have said though, PHP 5.3 itself is no longer supported and you shouldn't be deploying it.
http://sabre.io/dav/authentication/ &gt;You might be confused by the digesta1 field. This field actually contains the hashed password. The password is stored in the following format: md5('username:realm:password'); Ugh... 
If the tutorial is really good, feel free to read through it, you probably won't encounter any stuff that is deprecated or outdated for the first 100 hours of learning anyway.
Your argument goes both ways. Requiring a large majority for a "good" proposal may prevent its ratification due to unqualified voter base. But equally, requiring a small majority for a "bad" proposal may *cause* its ratification due to the same unqualified voter base. The problem with simple majorities is that you effectively end up making decisions based on thermal noise. You avoid this by adding a potential barrier.
Good catch. Please, open an issue https://github.com/fruux/sabre-dav/ :-).
That is the CalDAV/WebDAV protocol requiring this weak sauce, I believe. Not saying it is the only way (I'm not familiar with the *DAV protocols all that much). (i.e., [this guy](https://github.com/dupondje/PHP-Push-2/blob/master/include/caldav-client-v2.php) uses the same method)
Can this make it in for PHP 7.1?
There's no other way to securely store Digest hashes unfortunately. It's either plain text, or the A1 part of the hash.
PHP 7.1 is not in feature freeze yet, so it's highly likely as far as I know.
It seems a bit close to the release of 7.1 to me, I hope it makes it in though. 7.1 is shaping up to be another great release!
PHP versions are only actively supported for 2 years? Yikes. That's not a very appealing idea..
&gt;not what I would do
&gt; Jesus christ I just entered 1998. You can tell a designer hasn't been near that thing. Then send one? https://github.com/paragonie/airship
Thanks. Will fix immediately. :)
Missed my point a bit, but thanks nonetheless.
i wholeheartedly agree, thats why i did not understand why literarlly everyone else said that you need to start with php 5.6 or php 7 ... i dont think this is important at all for "learning php" 
It's what happens when idiots look at Rails, think it's good, and then somehow manage to make it worse while copying it to a terrible language.
There are a few things that one should note about PHP 5.3. And the first one is the fact that it's dead. It won't get any security updates, nor bug fixes, or whatever. @5.3, you'll still be using the old array syntax (array(...)), you won't be using the unpacking operator (...), you won't have any of the goodies from 7.0 (there are A LOT!), along with a few others. A lot of packages/libraries do not support 5.3 anymore, so he won't be able to use those either. If he's starting just now, I think he'd do a lot of good to start on 7.0. There is just no reason to learn on 5.3.
You *are* a fan of timing attacks, eh?
&gt; You're advocating to keep the status quo because its the status quo Not at all. I'm just saying Airship will do absolutely nothing to improve the status quo. &gt; Then good on Paragon for identifying the issue and building something that fixes it. Ignoring an issue doesn't make it go away. The issue is not fixed if no one is interested in Airship. And I don't see anything compelling here for the kind of folks who go for WordPress and Drupal. 
This sounds pretty good :) i guess with some StackOverflow and some Google im able to realize those things :) Thanks!
Yeah, I didn't even mention the security perspective...
Okay, understood. The word "never" is a sticking point. :)
Have you considered your services may be more useful in a larger company where there are designers, testers and so on? You always push security very hard, but in the real world, you need to wear many hats in order to build a product that makes sense. Selling naked "security" is simply not what the world wants from a product. You'll get a few pats on the back, but you'll never see success this way. I'm a developer, designer, manager and what not, I wear those hats every day at work. But even then I'm completely worthless without the rest of my team. It's a very big mistake to think that because security is so important to you, that this is what the rest of the world is solely focusing on, at the cost of ignoring everything else. It's a very narrow point of view.
We should all open source it.
&gt; The issue is not fixed if no one is interested in Airship. And I don't see anything compelling here for the kind of folks who go for WordPress and Drupal. What specific things would, in your mind, be compelling for the kind of folks who go for WordPress and Drupal?
&gt; Have you considered your services may be more useful in a larger company where there are designers, testers and so on? Yes, that's why we offer security consulting services. &gt; You always push security very hard, but in the real world, you need to wear many hats in order to build a product that makes sense. Selling naked "security" is simply not what the world wants from a product. You'll get a few pats on the back, but you'll never see success this way. Once our revenue stream is stable, we plan to start hiring designers. Most of their time will be funneled into Airship and anything we build atop it. As someone else pointed out, the v1 themes for the popular CMSes sucked too. &gt; It's a very big mistake to think that because security is so important to you, that this is what the rest of the world is solely focusing on, at the cost of ignoring everything else. It's a very narrow point of view. Well, that would be a huge mistake, but that's not one I'm making. :)
i personally prefer the old array syntax ... i think it makes code easier to read - especially for beginners.
&gt; Use isset() instead. Why not go all out and just use `array_key_exists()`? :P
Because shorter :-P Programmers are lazy, you know  they prefer justifying their laziness than adding a single byte to their source :-D
https://github.com/paragonie/airship/commit/e0afb0cdc348c160d112af32d46ab48f2bfba86a :)
Well, that goes for personal preference, but that's a tiny point that I made. The two things that weight more for me are the facts that 5.3 is considered unsafe and is incompatible with some up-to-date libraries. It's also almost impossible to find ppas for 5.3 to install under debian/ubuntu, repos for rhel/centos, and binaries for windows (standalone, outside those WAMP distros).
Congratulations to Matthew Weier O'Phinney and the whole team! Personally, I am happy to read this bit in the release announcement: &gt; A focus on de-coupling packages, to allow re-use in a greater number of contexts. In some cases, this has meant the creation of new packages that either split concerns, or provide integration between multiple components. This is something [Aura](http://auraphp.com) has concentrated on for a long time now; it's nice to see others taking the same approach.
i think thats because a lot of people don't make the distinction between "follow a tutorial that was made for version ..." and " use a php runtime of version ..." 
yes but only his course uses php 5.3 ... if he "follows" the course on a php 5.6 installation - it is no problem at all, his local version does not matter as the likelyness he hits a deprecated method is slim
it does, it was introduced with 5.3 exactly
You *can* use it (I use it). I don't know if you *should*.
Heck even some of the laravel components you can use outside of Laravel ;) De-coupling is awesome.
You can use Laravel for pretty much any PHP project. Its a MVC 'style' framework just like all the others. Reasons to use Laravel instead of the others are its realtivly easy to get up and running quickly, It has a solid core library with excellent documentation and it has a very large user base so if you get stuck help is easy to find. I've used it for everything from Blogs, Custom CMS systems, Ecommerce systems and REST API's
Why not? 
Nice, that's good to know. I am primarily doing an eCommerce project right now (everything myself, ughh) and I am still not quite sure what to use for a platform.. Prestashop has been the one that I'm leaning towards more lately, maybe Magento though once I get to look into it a little more. I digress... One of the requirements for the project is an admin panel for employee accounts to be able to fill orders from a graphical web interface instead of DOS based POS, and I see people recommending a free admin panel template combined with laravel. I just am not too sure how well those would jive being put into another eCommerce platform.
It depends entirely on the nature of your project whether or not it's a good idea to use laravel.
Sorry, I feel like a pest asking haha, but can you expand on that a little? What are some common uses, and what uses would you want to avoid using Laravel for?
5.3 was when they implemented namespaces which is, in my opinion, the biggest shift in php in recent history and the most important concept to understand. That said, unless you have a specific reason to do so, using javascript for both front and back end is the current popular trend, and as much as I like PHP lowers the bar to entry for full stack development. 
This is not meant for deep debugging, just to enhance error messages and make them more useful.
Usually they leave out the 'correct' part after pretty and fast, though.
It won't, anymore, since 3.2: https://github.com/symfony/symfony-docs/commit/d59027304606d5f1eeabf57df7ccf9152b2c8a6d Thank you for pointing that out!
Yup agreed that it goes both ways. It's a broken system, very hard to solve. Who defines what barriers allow one to vote? And who can guarantee that would not exclude people whose contribution would be positive, nor let people influence votes for the wrong reason? FYI on the case of php I think it works quite well for the most part.
* What Laravel is? Here is a good definition [1] * Use cases? Anything you can think of, it is a framework [2] * You don't know if you should use it... That's up to you, read more about it, read more about how frameworks, libraries and package managers can make your work easier, once you understand you will be able to answer your own question, otherwise you will be left with mixed answers from people with different backgrounds and use cases, what is useful for one person might not be useful for another. * Apologies if this isnt the right place to be asking this [3] EDIT: Added link to Laravel's subreddit. [1] https://en.wikipedia.org/wiki/Laravel [2] https://en.wikipedia.org/wiki/Software_framework [3] https://www.reddit.com/r/laravel/
Symfony packages have not been decoupled to the same extent, yet. Apart from that, yep, it is pretty much personal preference.
Why are you even here?
That's true. It can be partly mitigated by setting separate limits by subnet (say, /24 for IPv4 and /64 for IPv6). In Airship, I believe it is only count by subnets (not by a single IP at all). But it is also good to remember that rate-limiting should not be the primary measure (to guard passwords from being guessed), proper passwords/passphrases does a lot better job at it.
Cross post from /r/lolphp and I'm bored. If the comment is so irrelevant, why do you bother replying to it?
The solution to your boredom is to go into a community and shit on the thing they enjoy? You're a swell person.
All [Symfony components](http://symfony.com/components) are decoupled. The parts that are coupled are bundles, which are all framework specific like the SecurityBundle or TwigBundle (which adapts twig for Symfony use).
Don't want to argue if v5.3 is outdated or not. It's just there are enormous amounts of learning materials targeted at modern PHP, some of them bigger and better then Jeffrey's, so why even consider learning something obsolete? 
2 years is pretty good for anything short of an OS these days. And given that PHP is historically very (too?) good about avoiding BC breaks, there's little reason to be running an older version. It's not like you have to use the new features.
I never said it's not decoupled enough; it's just not completely decoupled. Symfony components are still a subtree split of a single repository. As such, their maintenance and release cycle is not independent. This is what was achieved with ZF 2.5 and is the main reason why ZF3 is now truly just a collection of components.
I never said they're not decoupled, read above.
I'll just leave this here: https://laravel.com/docs/5.1/artisan Searching for "artisan framework" will always return Laravel's component, due to relevance. Poorly chosen name you got there.
can you recommend some? Jeffrey is highly regarded as an instructor so I felt inclined to go with his tutorial.
They are decoupled in a sense, but things could be improved. All Symfony components have a release cycle dependent on each other because at the end of the day they are just subtree split of a monolithic repository. What /u/stefanotorresi is trying to say is that in order to release Symfony 3.0, all Symfony components must be tagged as 3.0. In ZF3 you can have ZF 3.0 which uses version 2.1 of component1, version 6.2 of component2, etc. If you look at Zend framework 3 [repository](https://github.com/zendframework/zendframework/tree/release-3.0.0) you will see that consists only of a composer.json; no code. &amp;nbsp; Symfony way has a few disadvantages. To name a few: - You can't add a feature in a component if you are not ready to tag all components. - Because you tag everything, you will also release a new version of stable components which had nothing changed. - Issues from all the components are in the same place From a user perspective both look decoupled, but from a maintainer perspective I could say that only ZF3 is decoupled.
http://www.phptherightway.com/ Speaking of Jeffrey, subscribe to his screencasts at laracasts.com, there are quite a few series for beginners -- e.g. [this][1] and [this][2]. [nikic's blog][3] -- mostly internals stuff, but read it rather sooner than later. Lastly, if a tutorial uses mysql/mysqli instead of PDO - just close and forget about it - either it is obsolete or incompetent. [1]: https://laracasts.com/series/object-oriented-bootcamp-in-php [2]: https://laracasts.com/series/design-patterns-in-php [3]: http://nikic.github.io/
On a help desk system I worked on that supported Markdown in responses we used Markdown -&gt; HTML Purifier.
I tend to agree with you but this is currently a feature of the package so backward compatibility must be preserved. And it's not a big deal to support it, and after all users are free to use that option if they really want to.
Thanks to you (and everyone else) for the suggestion. What would not be caught by `htmlentities($htmlInput)` (with unsafe HTML input) that requires HTMLPurifier to be used?
No plans atm. Owen Yamauchi wrote a book on "Hack &amp; HHVM" (O'Reilly) though it's aimed at usage, not internals. HHVM is a complete rewrite (I ported no small portion of the runtime library functions myself, actually). The Hack thpechecker is another piece of software on top of that for doing static analysis of code written in HackLang. Interestingly, PHP 7 borrowed a number of performance improvements from HHVM's design, while HHVM has copied/modified parts of the PHP soutce tree. So there are bits of each others' DNA on both sides.
No, but I was able to buy a lovely ham sandwhich. Nobody writes tech books to strike it rich.
*happy dance*
* Use htmlentities when you don't want HTML. * Use HTMLPurifier when you do want HTML.
I had a feeling this would be among the first responses before I even posted the question... So am I to assume the default installation is as good as it gets? Basically I want a PHP framework to load some basic views and act as an API endpoint for AJAX calls (pretty standard). I'm pretty sure Laravel and CodeIgniter are both capable of this, which would make them, at least in some sense, competitors. If CI3 can provide the same API endpoint results in 25 - 50% less time, then I'd be inclined to go with CI3...
I've used PHP since 4.3. PHP 5.3 is the probably the most significant change to PHP. It introduced namespace. For learning purposes, PHP 5.3 is still relevance. $array = []; or $array = array(); 
A couple things out of the box. First, Laravel has sessions turned on out of the box whereas I don't think CodeIgniter does. Secondly, run php artisan optimize --force. Third, use php artisan config:cache.
Almost all of them *can* be used outside of Laravel, the problem is they pull in half of Laravel as dependencies (though this is probably much better with 5 vs 4).
Wish they asked snake_case vs camelCase for variables...
Just when I thought it couldn't get any worse. :O
The way I've used the CommonMark library so far is to disable the HTML block when parsing so it gets escaped. I see two options, allow HTML input as it's trusted or escape it (disabling the HTML block parser) as it's untrusted. This has worked for my use case.
It depends on the context. In HTML body context htmlentites should be practically fine, but for example in attribute context htmlentities($htmlInput) may not be enough (depending on quoting style and if the attribute is quoted at all). See http://phpsecurity.readthedocs.io/en/latest/Cross-Site-Scripting-(XSS).html for more information.
Sure but in Markdown we are talking about HTML body context.
Well done for getting this out to the world Dave! I look forward to playing around with Opulence when I get the chance. I think the framework shows a lot of promise, and will become a worthy competitor for Laravel and Yii, which is what I've been using for a while now. The positive criticism from the majority of Redditors in this post is proof (to me at least) that the PHP world has room for more frameworks. When I read your post my initial thought was that the PHP community represented here will respond with "oh, great, yet another PHP framework", but I couldn't have been more wrong about that thought after reading the comments. I am thrilled for you man! I'll be following along closely and hope to make a worthy contribution to Opulence.
Pretty much in the same situation. The problem is the project is huge, was started when ZF1 was the only choice, has consumed several years of manpower and is not even finished. The final sprint is planned for October (oh the irony). It's in production for a year now though. I don't see any chance for migration as nobody will pay that money, we will have to maintain the thing ourselves. But if there are good ideas out there I'd love to hear them.
We have a similar issue regarding manpower. There's not enough of us and there's the age-old story of pressure for new stuff. We have around 35% test coverage but that means 1000s of lines of uncovered mapper code using Zend_Db. If there's enough demand for a community driven security releases fork I would hope that could be a possibility. 
It's not really the point of your post I know but your `is_iterable` definition is a bit lengthy; this would suffice: function is_iterable($value) { return is_array($value) || $value instanceof Traversable; } You do not need to check if the value is an object before using instanceof.
I'd still want an ELI5 on all that.
Why though? Again, your framework won't be your bottleneck, so removing that from the equation, we can look at what they both actually offer. Laravel is a modern framework giving you all the benefits of the latests and greatest. CodeIgniter is still _around_ and that's its only redeeming quality. Basically what I'm saying is everything CodeIgniter does, Laravel can probably do better. If you are REALLY hung up on performance, look at micro frameworks (Lumen, Silex, Slim). But still, you shouldn't optimise for performance from the get-go if that's not your primary business concern (think stock trading). **edit** btw if your business concern _is_ performance, PHP might not be the answer. 
Nowadays I'm in the Symfony world but I worked on ZF1 applications from around 2008 up until last year. I took some time to learn but it was worth it and I liked it despite its quicks. I used Doctrine 1 &amp; 2 though, not Zend_Db. Didn't like ZF2 much, with all the array configuration madness. As for transition if its EOL is problematic start planning a migration path, your application will not stopped working tomorrow because ZF is not maintained anymore.
~~`PHP Fatal error: instanceof expects an object instance, constant given in php shell code on line 2` in 5.6~~ Silly me, you're right. I should have checked other variations too. Thanks for the tip! :)
sounds like the last sticker data capturing scam that I didn't receive any stickers for :(
&gt; Will they be stable for the release? I hope so. 
After learning the PDO's abilities to handle objects, I am thinking of writing an exemplary DataMapper-based ORM, providing very basic functionality only, just to demonstrate the principle. Just because PDO is asking to be used for it. The minimalism is essential, because for the every mature lib you just can't dig to the bottom to see how it works *in general*. Hovever, I am very short of time, and it seems I'll never even start. So the question is, may be someone already did or seen something like this: a DM-based ORM with only basic CRUD methods. It should take no more than 100 lines of code or so.
Doesn't look like a scam, still not giving them my info though. Better safe than sorry :D
I really appreciate the kind words! Thanks.
Of course it is acceptable, but like everything it has trade-offs. Zend Framework used subtree splitting, then the team realised that it was hindering the development of individual components which needed a shorter release cycle than others.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
That's exactly what the blog post says
Already done, now it doesn't crap out because of memory limitations anymore, but it still crawls to a halt and uses 100% CPU.
Unlikely that it's a hardware issue, everything else is just running fine, I've been using this machine for a couple of months now. Even other IDEs from the same company run just fine (Rubymine). It's just PhpStorm showing this horrible performance :(
I use eloquent a lot, there aren't a lot of dependencies.
I am actually using gulp. But I just killed the gulp process, restarted PhpStorm and it's already sluggish again, like windows switching takes 2-3 seconds etc... which means in a couple of minutes or so it'll grind to a complete halt again :( It's actually not the first time I tried using PhpStorm. A year ago I had the same problem on another machine, with PhpStorm 8 or 9 at the time I think. Really weird, when it seems to work fine for so many people.
Thanks, I'll see how the performance is under Windows as a comparison and then try to contact their support about it.
well you could use something like Slim or Silex and get 90% more speed... fwiw
They made their beds...
I use a script in all my projects that lets travis generate the HTML doc (with both apigen and phpdoc) and publish it automatically to gh-pages. This has forced me to write better doc because on every push now everything is up-to-date.
I use PHPStorm every day with M1 and M2 shops with zero issues on CPU usage. And I'm even running a VM via vagrant that's taking a large chunk of CPU and Mem itself. I also work on several Symfony projects and an occasional WP (shudder) project with PS. For full comparison, I'm doing all of this on an MBP/i7/3.1GHz/16GB Mem/250GB SSD/OSX 10.11.5 I think perhaps you should reach out to JetBrains to help identify your issue. You could try pinging Gary Hockin (@GeeH on twitter), the developer advocate, to see if he can get you some immediate help.
you can send signals to processes, for instance ctrl-C to cancel a script sends a signal to that process to stop. This RFC is about catching those signals and executing some logic when they occur, e.g.: cleanup any files or resources in use by the script before exiting.
besides OSX being a complete shit distro, did you check youre using sun java? but wouldnt be surprised if your cpu is the bottleneck, had the 'pleasure' to work with 2 topend macbooks(2014/15), never again. always cpu problems and complete shit heat disposal Edit: Oh dang, the sea is salty today
PHPStorm kept crashing on my Windows machine. Then I changed the shortcut to `phpstorm64.exe` and it worked like a charm ever since.
Hey Gav! It's been a while! Will look at Stack for sure. Yeah, the main problem is the database access layer. Lines of code in the mappers namespace: covered 4416 / total 10705
I have several projects that are located on a remote NFS mount on our main dev server (used by 6-10 people at any given time). It tends to slow down when it automatically synchronizes the project files. I've long since disabled the auto synchronization (only allowed at start-up) and that has significantly helped performance in my situation.
What's your issue with ticks on 7? I use signals heavily on some php 7 processes I have and found no issues 
Yeah that's why we're all moving to Magento 2 that uses fancy new... Oh. 
Magento 2 uses ZF1 and ZF2, lol. I believe they documented somewhere that you're not supposed to use the ZF1 code directly.
linux kernels, because LXC
I have a mid 2011 MBP 15" with 16gb of RAM and I've never had problems with PHP Storm with one exception, if I'm out of RAM and start swapping. For me, I just need to keep my chrome tabs under control and I limit vagrant to 4gb of ram and it runs perfectly. Your system is newer it sound like? So, it really sounds like it's a local config issue with your setup. Seriously, reach out to their support, I'm sure they can help. 
Try Craft... http://buildwithcraft.com 
Inspections would be my first guess. And actually shutting them off in the settings and not just when you open the file. Uncheck everything. Have you seen if there is a phtml plugin? It might be causing a hiccup trying to figure out what to do with it. Same goes with Magento. Maybe having a plugin that knows exactly what to do might improve performance. &gt; when opening some files Do you mean from the built-in explorer or are you just directly opening files with PhpStorm? Have you set up your project? You can't use the same workflow that you would with Sublime. You're not crazy though. **Something** is amiss. I'm running it on a brand new MacBook Pro as well with no issues. Large Symfony projects.
What are some of the best image libraries you have used? I'm working on a project using the built-in gd2 library. But i'd love to find some really good options for dropping fancy fonts on top of a static library of images that'll serve as backgrounds. Thanks
Are your files on your local hard drive or is it trying to read them over a (slow) network?
Same thing for ZF for some of the components try to get the forms working stand alone, it's a bit of a pain ;) They just aren't required by default only when using them for something.
&gt; I'm currently in the process of migrating a PHP 4 application to 5.3 I'm really really sorry for you
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
You should right click on your vendor, node_mofules, bower_components, and any other folder containing third party code, then hover over mark directory as, then select excluded. Disable plugins you don't need. Increase its running memory. Update java and php storm.
Thanks, I'll give them a try.
Jube = June + 20 days; isn't that obvious? ;-D EDIT: fixed
Might want to try reinstalling? Another possibility is that your project contains a lot of files and a lot of warnings? That makes mine run slower.
Different strokes, I'd anticipate. For me, I learned PHP using vim... Then moved to Eclipse + some plug-ins for a bit. I anticipate the experience in Eclipse has improved. But I can't ignore how much more productive I am with PHPStorm... It's integration with Vagrant, Xdebug, Git, and Jira. It's likely that this same experience can be accomplished in other IDEs/editors, but it just works so seamlessly. I've used PHPStorm now for probably 3-4 years, and it really does make writing PHP code simpler and enjoyable. I believe the reason why it shines is because it's tailored to PHP and the ecosystem around it. Eclipse has always felt like a Java IDE (which I realize IntelliJ is that too) with a bunch of plug-ins crammed into it. PHPStorm doesn't feel that way when you use it.
Great - that implementation would win over anything that can be done external to the library, like we're currently having to do.
It takes some time to change, after all it's a software you use several hours every day. You have to relearn a lot of things, even simple things like duplicating a line. But in the long run it's worth it. The "cult" doesn't exist for nothing ;)
Taylor is slowly adapting decoupling... in another year its just going to be symfony 4.0
Ah, well that makes sense. Props to everyone who made it happen!
Talking of which... when do you need to duplicate a line...?
I would be careful, Taylor has said that lumen is being transitioned to a framework designed to purely build APIs. If you're using views/templating it might not be the best choice.
I ran it too and I had some issues. When you run the command you HAVE to run it on the server itself, because it stores the full paths of the files for bootstraping/loading views etc. So, if you're using a virtual machine first ssh into that machine before running the commands.
Here's a neat introduction... https://www.sitepoint.com/generators-in-php
It looks to have gotten worse with ZF3. https://docs.zendframework.com/zend-db/
Seems like youre advocating a [Humpty Dumpty approach](https://en.wikipedia.org/wiki/Humpty_Dumpty#In_Through_the_Looking-Glass) to the concept of community here.
I haven't seen .phtml files in use in many, many years. Is that a Magento thing? 
Yes this. 
Yes, but in my experience community support is often better and quicker, then corporate customer support, so I didn't bother. And it wasn't my goal to ruin their reputation - I've used both Rubymine and IntelliJ in the past with great success, which is why I now wanted to make PhpStorm my mein IDE for PHP development.
Donno if you can do this in PHP Storm, but in Netbeans you can enable a memory heap graph that you can see if the IDE is GC thrashing. Which is a common cause of NB slow down. How much ram did you give it? Also what Java version are you running?
Oh man, I completely forgot about Phalcon. Thanks for the reminder!
This would probably fit better over at /r/PHPhelp
I started programming 20 years ago using emacs. Everyone thought I was weird because they all used vi. You couldn't beat it though for debugging... gdb right inside emacs. All the vi guys didn't even know what gdb was but who debugged back then :-/ I eventually moved over to eclipse and they all thought I was weird because they were all using vim or something else by then. I spent some time with the ZendStudio as well. They had some nice built in debugging abilities that eclipse didn't have at the time but has now. I even used Aptana as well which was nice at one point. ZendStudio eventually built their stuff on top of eclipse so I made my way back to regular eclipse instead of ZendStudio eventually. I've always had eclipse on every single machine I owned though since I started using it until I got a new MacBook Pro about 6 months ago. I don't have eclipse installed anymore. I only have PhpStorm now. There isn't anything that eclipse does better, based on my workflow, than PhpStorm does at this point though. EDIT: One thing I forgot to add is that PhpStorm has a very useful `Data Source` feature that allows you to write sql in your code and it will auto complete the tables and columns for you. It will also let you run the query and have you fill in the values for it as well if you are using prepared statements for example. I haven't seen anything like that in eclipse. There are dozens of other little things like that as well that are very useful once you start using them.
thanks, i dont see any case where i'd use this but cool thing. Is this like a shortcut to not build an array and have to return it, or something more useful ? 
Just skip through some posts here. It's a common discussion. And everything has been said multiple times, from every angle. 
Many thanks!
They're a shortcut to iterators. So anything you'd need an iterator for ([here are some examples](http://php.net/manual/en/spl.iterators.php)) you could use a generator for. They are also a stepping-stone to native async/await functionality. So folks like [Icicle](https://github.com/icicleio) and [AMPHP](https://github.com/amphp) have built incredible async PHP abstractions on top of generators (by implementing co-routines).
Thanks man :) Sorry for the shameless plug, but if you're ever bored, feel free to give the game a try: https://www.pakyra.com/. It's all PHP on the backend, including the single-player AI. You have to place 5 chips in a row to score a point. You need to score 2 points to win. You can only place a chip if you have the board cell's card in your hand. Also 2's are wild, so if you have a 2 in your hand you can place a chip in any cell that doesn't already have a chip. Mmm, chips... /shameless-plug
https://imagine.readthedocs.io/en/latest/usage/drawing.html
I'm being that guy, please bear with me. At a glance this seems a bit over-engineered. The rate limiting concept is quite simple, you use fast storage (redis or memcached), log access to a resource with some unique key, read it back next time, and apply the threshold algo. Now is it really necessary to implement all these OOP classes, interfaces, and storage adapters for a concept as simple as this one? I'm a little bit fatigued by the growing offering of complex "modern" OOP solutions. At some point writing state-of-the-art OOP code has become the goal for many PHP library authors, while it should be just a means to an end.
There are a lot of jobs out there for Php developers. It is being used a lot in industry. Yes it has it's faults, but then every language has it's faults. Personally, I prefer Python, but Php is what pays the bills.
Check your version of Java too, it may need an update. 
It's certainly not dead. It has a foothold is many place, can do many things and is pretty approachable for new programmers. However, sure, php devs don't get taken seriously. Although, that's true of all devs. Each group laughs at each other for different reasons. C developers are laugh at Java developers who laugh at JavaScript developers who laugh at PHP developers who laugh at C developers. In the end, what counts is results. "What's with the hate" is going to vary from person to person, problem to problem and configuration to configuration. The most important thing is just to realize that there's a right tool for the job. If you do a lot of the same kind of work, maybe it's fine to use PHP because that addresses your needs for it. If you're concerned about the hate, read about what else people are using and why (rather than just why they bash PHP). Erlang is on my to-learn list because it seems to offer some awesome fault-tolerance concepts. NodeJS is a favorite of mine because I prefer JavaScript and because it's nice using the same language on client and server side. C#.NET is nice because compiled language offer compile-time checks, it's quite powerful, it's quite fast and it has a good IDE. There are arguments for each of the alternatives. Understand why they exist.
Thanks, I've done that and excluded all the cache &amp; build folders from indexing and also applied the changes suggested [here](https://www.reddit.com/r/PHP/comments/4qf1vi/is_anyone_here_using_phpstorm_is_it_just_me_is/d4t0jal) and it's much better now, the IDE doesn't run out of memory anymore and so far the UI isn't that sluggish anymore, though CPU usage is still pretty high when editing. But it is actually usable now, so I guess it was really just the big codebase needing some performance tweaks.
Very cool, I've never thought of using token bucket for anything other than rate limiting at a bandwidth level. Nice work!
Place your cake php on api.domain.com and your angular app on domain.com. Remove all views from cake and just let the front end be the front end. Make API calls, render your views, and route within angular. 
&gt; Type hinting on the other hand... Hah, you should see it try guess javascript types. You can practically feel it giving up in disgust and throwing the kitchen sink at the autocomplete.
I did. I always run artisan commands in the VM and made doubly sure I did so here. The file it's producing is segfaulting. It's 16,598 lines and 566,854 bytes. Is it possibly too large based on some PHP or OPCache configuration? (e.g. a 512kb limit set somewhere?) [My OPCache settings](http://imgur.com/1aAB2PY) EDIT: Disabling OPCache solved the problem, but that's just robbing Peter to pay Paul. 
Not using APC - using OPCache.
Ah, this months PHP self-loathing. 
If your angular app is in `/var/www/angular/web`, and your backend is in `/var/www/cake/web`, your virtual host would point at the angulars web directory, and in that vHost you would add an alias `/api` that points to your backend web directory.
Disable/reduce antialiasing on editor fonts. You'd be surprised how much harder retina resolutions can be on some things.
More like Java. AbstractSimpletonProxyFactoryBean.
Besides it's Xdebug and Autocompletion features, I've never really liked PHPStorm personally and found myself disabling more things than I was keeping enabled. Besides the lack of great xdebug clients, I've enjoyed my experience with Sublime Text or Vim much more pleasing and efficient not waiting for my editor to respond to my command
[http://kosinix.github.io/grafika/editor/text.html](http://kosinix.github.io/grafika/editor/text.html)
I've been using many versions of PhpStorm and it has mostly worked well with Apples JVM. They seem to have fixed the performance issues with Oracle now though because as of PhpStorm 10 I don't have those problems anymore, but I don't think your machine is the problem. Try using an EAP version? 
I'm willing to bet it's a plugin. I installed some git ignore plugin a while ago and it brought everything to a crawl. You may want to temporarily disable all plugins and re-enable them one by one until you find the culprit.
You might want to try over at /r/phphelp for this one.
Came across this. Looks cute, but I'm a bit baffled by the heavy Docker dependency. Why introduce such a learning curve in front of an app? Wonder if the author will chime in.
Using -XX vmargs is oftenly discouraged since they are experimental jvm options that are subject to change in the future. They might improve things, but they also might make it worse, since it's experimental. I'd advise that you test it one by one to see if they really do make a change.
[removed]
&gt; Why introduce such a learning curve in front of an app? `docker-compose up -d` - this is very hard indeed. p.s. it would be nice if developer will add all important stuff like default path to compose file into `.env` file: COMPOSE_FILE=etc/docker/docker-compose.yml And then if you use docker-compose 1.6+ everything will be filled in from `.env` file (if no env variable defined). IMHO every backend developer should know at least what is docker and how to run docker containers.
&gt; Magento &gt; Performance .....
Just looking at that readme, it seems like it's heavy by using MySQL instead of SQLite and it falls a little short by not giving a better use report. I like Google's shortener which shows data about the people using it. Browser, platform, location, referrer, etc.
&gt; Object Oriented Programming is an expensive disaster which must end I can tell from the title that the article will present a balanced, professional and objective opinion. ;-) The author's comparison of OOP with functional languages already demonstrates he's a bit out of touch, as in the last decade most OOP languages have been adopting features from functional languages and vice versa. The features are quite complementary, not mutually exclusive. The author is correct that Alan Kay's OOP is not what we refer to OOP today, instead it's what Carl Hewitt has formalized as the Actor Model. But I'm not sure how naming things changes the status quo. There are successful Actor Model implementations both on top of a functional language base (Erlang), and OOP base (Java's AKKA, .NET's Orlando). Functional/OOP are successful paradigms that we use to organize our code at a lower level, *within* an actor, and actors are how we can have relatively standalone, possibly distributed units of functionality communicate within and across threads, processes and networks.
Sorry if you mis-understood my post, I agree there isn't any point for all of this on such a small project. On larger projects with multiple team members, TDD, Frameworks, Version Control etc etc make sense, but for something so trival there just isn't a need for all this apart from trying to fit in with the 'hipsters' basically saying look how cool I am using all these techniques 
If you like working with documented pieces of code, steer clear of ZF...
this was obviously click-bait... i fell for it.
No, you should learn where you can. If you become a dev, your editor may let you set your version and will warn you which features won't work. Just learn where you can.
It is so nice. At one place I worked, I was able to set up a fantastic workflow with JIRA and BitBucket. If you use the JIRA issue name as a title in bitbucket, they are linked, and PHP Storm odes most of this for you.
It was a suggestion to help you avoid comments like &gt; Is the demo site's design some kind of in joke that I missed? as being the most upvoted on your post. To be honest it looked like you cooked up the css yourself. I'm not sure what you did but the Pure webpage looks nice as is. I think your demo site would benefit from "less is more" design and stick to a plain old Pure looking website. The changes you made with colors and padding make it look less than ideal. I say this as someone who also cannot design for crap :)
I had a hard time just reading it for 10 mins, not because of the content but the "layout". They should split the huge article up into more readable chunks.
I'm the author and I want to clarify a few things! First things first, my whole workflow is based on docker, I enjoy how quickly I can set up new environments with different requirements and versions. That's just all there is to it, this isn't a requirement for this particular project! Second, this is a side project - sure I could have made it with a less heavy framework, it is after all a simple little thing :) But the goal for me was to learn Symfony and I needed a URL shortener!
-XX options are nonstandard, meaning these are Sun-specific flags. They're not experimental, with the exception of AggressiveOpts.
Two handy features related to it (since it's built around their 'tasks' functionality), when you switch tickets, you can have the IDE switch contexts. It will close any open files, and create a context for that ticket so that if we switch away and back to it, it'll know exactly what files you had open and where you were in those files. If you also use the time tracking in Jira, PHPStorm can also automatically do that related to the tasks. You can even post it directly to the ticket from the IDE, if you like. I think a lot of people comparing IDEs probably don't give a damn about these kind of features, but as a whole, they really start saving you time and let you focus on your work.
I used to feel the same way. Little story with my experience with JetBrains. I do some fairly large SQL queries assembled in a WITH clause. Some of these are well over 1k lines long, but are made up of many smaller queries. Not entirely unlike having a class with many methods. I created a bug report for PHPStorm requesting that the navigation panel list these smaller queries out, like it does with methods. I honestly didn't expect anything to come of it. I don't hear much about other folks writing large SQL like that. It's been about 2 or 3 months later, and this is now a new feature in PHPStorm. Their folks hopped all over that, and it works great. Whether folks like it or hate it, JetBrains is definitely dedicated to put the effort into their product. Just wanted to give a public thank you to those folks.
&gt; Activerecord is an antipattern Since we're talking about a tutorial written by Jeffrey Way, you might want to check some of the merchandize he has on his site : https://laracasts.com/shop/items/i-heart-active-record-shirt ;-)
Publisher Pulsar https://github.com/jamset/publisher-pulsar ReactPHP and ZMQ based module allowing to provide independent processes simultaneous activity [, to coordinate set of independent processes]. I.e. to not exceed API RPS (QPS) limits (i.e. Google Analytics [10 QPS per IP](https://developers.google.com/analytics/devguides/config/mgmt/v3/limits-quotas))
Not sure what you see, works for me on the other RFCs. EDIT: _now_ Levi has added it (also have a look at the revision history...)
You are right. I'm obviously not smart enough to realize you had to delete a vote first to edit it
The worst legacy project I run on my 2013 macbook pro under PHPStorm is over 4GB of spaghetti and binaries. I usually run 3 vagrant VMs, PHPStorm with 4 projects and Rubymine with 3. Filesystem shared with VMs over NFS. I can't be bothered to halt unused VMs or close projects I don't need to touch that day. That's because it works flawlessly. You're an idiot for using one broken workflow to confirm your bias against Apple.
[removed]
A couple of optimization path, most not Laravel specific: - Cache the routes, metadata, the container and the views - Optimize the autoloader - Exclude dev/tests code from your production code (ex don't include your test-suite) - Install your package without dev dependencies before optimizing the autoloader - Look for Opcache - Upgrade to PHP7 Other possible optimizations: - Optimize your queries: check that when fetching entities your are avoiding easy loading (unless is not critical or matter little performance wise); you might even want to completely bypass the ORM in some situations - You can use another DB for some features, ex. for fast search an ElasticSearch or Algoria - Use a cache DB (Redis, memcached, ...) - Use an HTTP cache layer (Varnish) And then you have to consider your application architecture: API-centric, a big fat DB... lots of possibilities. There is always a lot that can be done, but the app response time may not be critical. You know even if it takes 20ms for your server to give the response, if your client takes 2s to download the content because the response is very big, it's not that useful... so you also have to consider your front-end which is yet another world. Laravel, Symfony or other, there is no framework that is inherently slow.
It was moved into the "In voting phase" on the RFC wiki. Seems like the RFC author just forgot to update the actual RFC with the voting widget. 
Even in an API application, you might need views/templates to send emails for example :)
The fact that you cannot find literally any blame for yourself goes to show a lot about your character.
thx nice
Right, he only announced and added voting widget one hour later ;-)
Most subreddit css is complete garbage. I always disable through RES if I can.
The /r/php CSS even hide's Reddit Gold's built in "Show this subreddit's theme". The lengths people will go to force bad design on people is amazing.
or just run a standard Linux virtual environment and cut all the Docker overhead crap that's there just so people can say 'hey I use docker im really cool'
I've updated to docs to indicate docker is optional. You're not required to use it, if you want to set up a vagrant or xampp or whatever else you use, please do so! I personally love docker (for development), I've set it up once and all I need to do is add a docker-compose.yml file. If I need elasticsearch, redis or anything else add all - I just need to add it to the docker-compose file and I'm done. No hassle with configuration or installing it, no conflicts with other projects I have running. Docker is worth taking a look at, just my two cents! 
idk whats worse, lying for the sake of elitism or not being able to fix bad hardware with the worst possible soldering as confirmed by 1bil google results.
This is why people hate PHP.
Doesen't that do the same thing as the checkbox in the given subredit sidebar though? 
Wow, this looks really interesting!
Order of operations fail.
Nobody is reading this thread anymore. It's been a day and your comment is burried. I don't make stuff up for haters who wouldn't bulge anyway.
Yeah, PHP truly is a really bad language for designing subreddits. Good thing we still have css
Nullify or falsify? Or maybe throw an error or maybe 0.
I doubt it was intentionally done. Whoever did the theme probably found a pre-made subreddit css theme and modified it a bit.
PHPStorm is fine here. It autocompletes instantly (which is why I really like it). Actually, its performance, compared to Netbeans and Eclipse is what sold it to me. Everything happens when I click. I don't have IDE freezes while it searches for information.
&gt; Doesen't that do the same thing as the checkbox in the given subredit sidebar though? Yes. I'm referring to OP's comment: &gt; Why did you hide the "use subreddit style" button? I'm offering solutions to those of us who have to deal with subreddit themes that hide the little checkbox.
I had to submit this after seeing a colleague consistently use this pattern for objects and arrays: return $result :? false; return $result['stuff'] :? false;
A wiki is pretty much my next project i guess. This seems like a not to hard project to keep on progressing in PHP for me :)
Very good article, most people always forget about the null object pattern, yet it is, combined with decent exception handling, probably your best friend in many cases! Thanks for sharing.
Seems like good advice. Exceptions make the code so much cleaner and easier to work with than returning false. This is especially true when you get several functions deep in the call stack and you get a false return that needs to bubble all the way back up to the top. It's also fun defining custom exceptions so you can have different catch blocks for different exception types.
I don't necessarily agree; that was precisely the point of my comment. While it *may* constitute technical debt, it just as likely doesn't, and it should rarely be considered "major". Continuing to use, say, Zend_Route, or Zend_Http_Client, after the original devs have EOL'd it is no different from continuing to use the homegrown router or http client originally developed some former employee. In both cases the original devs are gone, and its your problem now. Framework code isn't (or at least shouldn't be) a black box. It's just code, and by its very nature as framework code, there will be some amount of unavoidable coupling with your application. Framework code typically solves common, well-understood, problems, and should be easy to read and grok. This isn't to say that framework migrations are always a bad idea. I moved a fairly large, actively-developed project from ZF1-&gt;ZF2 a few years ago, and never regretted it. However, my motivation wasn't that I considered ZF1 technical debt, but that ZF2 had specific code (EventManager was a big one) that had utility for future development. EDIT: Please don't misunderstand me. Replacing code with better code is a good thing. My point is only that the fact that some framework code you've adopted has been EOLed by the original developers, by itself, shouldn't be cause for consternation. 
I'm just saying JSON APIs change nothing here. For the record, I convert notices and warnings to exceptions in my projects. This way what to do with a notice is not up for a debate.
I can only speak for ZF2 and Symfony2. I really liked some of ZF2's components, ACL eg. I think Symfony 2 is better in the framework department, things like configuration, service container, the whole MVC-esque part (controllers and all of that) is just much better in Symfony 2. In ZF2, the MVC component (which I guess is the framework part) is kinda simplistic, configuration isn't as good (mostly PHP based which makes it all very verbose and inflexible). There is a lot I like about ZF2 but in the end I'll always grab Symfony 2. Haven't really touched v3 of either of them yet. 
By the way, in the end they're just frameworks and it doesn't really matter since your application's business logic should be seperate from the framework anyways and in case of Symfony exposed to the framework as a bundle and in ZF2's case exposed as a module. I.e. the framework parts of both projects are just HTTP layers. 
Didn't we agree display_errors should be off in production no matter if your code is crap or clean? Then your JSON argument is irrelevant. The only argument remains that notices are 99.9% a result of a bug, and ignoring them would lead to silent failures, security issues and data corruption. Which should be enough of a reason to pay attention.
&gt; That's BS, sorry to be blunt. Well I guess that settles it then. Although... a mistake I've seen made more than once is when a configuration file intended for a dev/staging environment accidentally finds itself in production. What's one of the most common differences between a production and dev/staging configuration? You guessed it, error handling/reporting. And sure, there are probably countless other things - you mentioned a few - that could go wrong in production that could lead to a developer's loss of sleep, but if I'm going to get a call/text after hours because of a production issue, it really shouldn't be because I was comfortable pushing notice/warning prone code production under the assumption that such notices/warnings would never be seen by the user.
You could've sent them this to save them some work: preg_replace('@\?:\s*false\b@i', '?: null', $code); :P
Yes. Don't be an asshole.
Reminds me that I need to go back and redo all those functions where I thought 'eh, I'll just return false and put some proper error checking in later when I'm less busy...' :(
&gt;CRAP ohyou.jpg
https://github.com/tastejs/awesome-app-ideas
Showing/Hiding errors is entirely the wrong approach. Use set_error_handler to throw all notices/warnings/errors as `ErrorExceptions`. You can then handle exceptions differently in dev/production and get a nice stack trace for everything. 
It was a bit clunky the first couple days I used it, though I think that may have been because of all sorts of indexing of files happening in the background. After a few days, it ran like butter. I've been using it for the past few months (on Windows) and it is probably the most useful software I've ever used for code. So glad I was able to get it at my job!
This description is very awkward to read.
The company can't afford to hire devs at market rate, especially in NYC. (forgot to mention that one.) We're also doing music things that are particularly idiosyncratic so it is almost easier to teach code than to explain how our business works in music-land.
Or you're really good at molding it.
Well I can't help trying to put myself in these poor fellows' place. It's like I'll be asked to do accounting or public relations in my company. It will not only make me fail with my own project deadlines, but will cause a terrible effect on the results. I may lose a lot of money as an accountant or do some fatal mistakes in marketing. The idea sounds highly peculiar to me. As of the salary - you can always hire an overseas programmer. In many countries the estimation is five times less or even more than that.
As with everything; it depends. 
"some have even programmed before, just in other languages such as Java, C" Lol you have nothing to worry about, if you can program in C or Java then PHP will be a breeze. For the others I would jump straight in with a practical project, show them how to program a CRUD application as thats more than likely what your internal applications will be doing
We use the Atlassian stack at work. Jira release notes will give you a list of all the tickets closed within a version. Bamboo will show you which tickets and commits are included in a given release... They are fairly gross lists, and need to be fettled a bit in order to give to customers, but for a technical log of changes they do a reasonable job. I am also a huge fan of interactive rebasing git commits to squash commit logs which do not convey any context. That reduces the size of the commit log and makes it far easier to reason about as a document of the things that have changed. 
I too am a fan of interactive rebasing, but we're also really trying to focus on keeping one commit per logical unit of work. Too many times (we're all guilty of this) we've spent a little while working on something, squashed it down to a single "Add new feature" commit, which produces a massive diff that is impossible to review. Yes its nice that there's a single entry in the git log, but for all other purposes its pretty much useless. We're using GitLab and GitLab issues, but that doesn't have a list of tickets closed in a given release option. Question for you - are your Jira tickets purely things raised by management and users (e.g. "drop down is broken", "image not displaying") or do they also include developer orientated things (e.g. "Refactor UserService class", "Add tests for User model")?
Going through the commits and then write a change log. Takes time yes!
There's puss coming out of a gaping hole in my chest. Should I just cover it up with a shirt and never look at it? 
&gt; But what if one feature is implemented as a series of commits (as it should be IMO)? Then you use a branch &gt; So I don't think a git log generated changelog would ever be suitable to pass to management. That's why I said, tag the commits. You can later filter, group and display them by tag. In any other case you are doing double work, since you most probably use version control already and you're already writing commit messages.
I work with a 10+ year-old codebase where the original developers somehow let warnings accumulate... It's just depressing.
[removed]
When I started using PHPStorm it was slow and nothing helped, disabling inspections and things like that. I had pretty old laptop. It was intel i-3 cpu with 4gb ram. The hard drive was probably not the best condition. Then I got a new laptop with SSD, intel i-5 cpu, haven't had any problems since. Hope that helps
&gt; I too am a fan of interactive rebasing, but we're also really trying to focus on keeping one commit per logical unit of work. Too many times (we're all guilty of this) we've spent a little while working on something, squashed it down to a single "Add new feature" commit, which produces a massive diff that is impossible to review. Yes its nice that there's a single entry in the git log, but for all other purposes its pretty much useless. The trick is to make sure you're squashing to a commit which represents a logical unit of work. "Fixed bugs" commits are punished by removing toenails with rusty pliers :) But often in the act of working on a feature (we use a feature branching strategy) results in a lot of "WIP", and "Going on holidays and putting this here incase someone else needs to do it" as well as merge commits and other noise which make the log completely useless when trying to find out exactly why something was changed. Log for context, content of the commit for actually what changed. I find this to be immensely useful as a guide: http://chris.beams.io/posts/git-commit/. The interactive rebase to squash will almost always result in an edit of the final actual commit which will contain a well crafted message indicating why changes were made, as well as links back to items in issue trackers, links to failing builds that something may have fixed, etc. &gt; Question for you - are your Jira tickets purely things raised by management and users (e.g. "drop down is broken", "image not displaying") or do they also include developer orientated things (e.g. "Refactor UserService class", "Add tests for User model")? Both. Sort of. We don't do anything unless it can be mapped back to actual business value. There is no work done just because people think it'd be good to do. If you can't attribute value to it (and can't get the business to agree to the work being carried out), it doesn't get done. We divide our backlog into features (stories), defects, and tasks. Bigger items are then subtasked. Tasks will often identify developer related things such as investigative work or prep work for upcoming changes or technical debt. Technical debt and refactoring is preferably done as part of a feature and would go in as a sub task, e.g. In order to add the new single sign on functionality we need to refactor the auth system to accommodate it. Because there are technical tickets, the release notes need some smoothing over once generated by Jira because user facing notes are probably not going to contain the intricacies of how you integrated some OAuth library or what have you. One other advantage is when looking in the other direction., From a closed ticket to the commit(s) and pull request(s) which made it happen. Jira gives you that too assuming you link things up properly (usually by including the Jira ticket number in the commit message). 
And the nice thing about exceptions is if you hit one, your code stops executing, rather than continuing having hit an error condition. Often once you hit an error your code wasn't going to work properly beyond that.
Commit messages are good reference for updating a changelog, but they're not a changelog. There's a lot of noise in them, and a changelog should be succinct and understandable to users, not just core product developers.
You can kill the noise easily by tagging, you're tagging your changelog messages anyways With simple tags you can filter exactly the things you need. For the CEO you can filter for [Feature], for HR you can filter [Feature] and [Bugfix], for developers you can filter [Bugfix] and [API], designers can filter for [Layout] etc. What I'm saying is that you're basically writing two changelogs if you use version control _and_ some other changelog mechanism. Every info that's in a changelog is already in the commit messages, just in a different format. I'd always go for commit-message-based changelog systems, but of course, it's just a suggestion.
They can look up the ticket and view the changes. Small scale changes are usually picked by osmosis. We have a code review process that everyone is involved with which does a great job of keeping everyone across changes. Daily meetings are also good for high level communication. Larger architectural changes need technical documentation.
There is no way to migrate *easily*. So, - either migrate *properly*, implementing **prepared statements**, which will require manual rewriting of each query - or just leave your code as is. It's no use to run old shit under PHP7 anyway. And in 5.6 `error_reporting(E_ALL &amp; ~E_DEPRECATED);` is your friend Anything else will be useless waste of time.
OMFJCG
Good to hear, thanks. As we're only using GitLab issues which doesn't have the nice "release notes" functionality you mention, I'm leaning towards the following, at least to begin with: - Keep a changelog in the root of the repository - The changelog is written for the benefit of the users. - Just before release someone will go through all the commits that have been merged in since last release and update the changelog in a single commit with a simple, human readable list of changes, new features and fixed that can be passed to management and users. - Smaller technical changes should be communicated to other developers casually (a Slack message, daily stand up) etc. - Larger technical changes should be documented properly, with a link to the docs distributed across developers. - Developers should be looking at every merge request and commit that is merged to stay aware of what is going on anyway. Does that sound like a good starting point?
But you should really use PDO if you are not using mysqli !
Amazing - exactly what I was looking for. Thanks! And yes, this is definitely a temporary fix, just to allow us to upgrade and start moving away from 5.3isms immediately.
&gt; It's no use to run an old shit under PHP7 anyway. I'm sorry but I disagree. PHP 7 gives you a lot of lovely new goodies, and I want to start using them.
Good place to start. Do it for a couple of weeks then get everyone's feedback. You want to strike a balance between adequate communication and a minimum of book keeping. If you can leverage tooling to do some of this for you it will pay dividends because almost without exception developers suck at doing work they see as "admin". Good luck. 
To use them "goodies" you have to be well prepared. A code from 200x won't run even with mysql ext faked - there will be a lot of other e_deprecated or even fatal errors. 
[Oldie but goldie](https://www.sitepoint.com/migrate-from-the-mysql-extension-to-pdo/)
Have you considered using http://changehub.io? It works by writing the changelog based you your PR descriptions with http://keepachangelog.com/ format. And works automatically with git.
https://yourls.org/
I know, I did my research but I didn't like it and wanted to make my own.
[Tale Jade](https://github.com/Talesoft/tale-jade), a PHP templating language based on [Node.js Jade](http://jade-lang.com/), written from scratch. It supports almost all features of the official Node.js Jade (Only `&amp;attributes` doesn't work as expected right now) and it also brings in a bunch of new, PHP-related features as well as some that I implemented just because I could. Notice that the official Node.js Jade has been renamed to Pug because Jade is already taken, Tale Jade will be renamed to another, own name soon (and then become its completely own templating language with a great load of new features, not just a Jade clone). Tale Jade is not a simple port, I only took the specs of the language and implemented a completely own lexer, parser and compiler for it, utilizing PHP-specific features in every way. The final target is to reach the same functionality level that Twig provides, but giving the developer not only the pure PHP-abstraction, but also complete HTML abstraction (Which Twig lacks completely) There are some implementations for existing frameworks like Laravel and CakePHP (Can be found in the [README](https://github.com/Talesoft/tale-jade/blob/master/README.md), at the bottom). I've even started a [JadeBundle for Symfony](https://github.com/Talesoft/tale-symfony-jadebundle), it works, but I didn't fully release it yet. I'm looking for developers helping out right now, so if you're interested, contact me.
Try to fix
Actually, that helps a lot. :)
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
We have a weekly milestone with features/bugs/etc. On Monday, someone goes through last weeks milestone to see what issues have been closed and generates a changelog from that. We have a small team though (3 devs) so it's easy to keep track of what happens during one week.
Hi Austin, This looks great and I want to use it, I have an existing laravel 5.2 install, and I'd like to add this in as my blog, in your documentation it just has instructions for a clean install or download, is there anyway to add it in composer.json as a requirement and let composer install it without messing with my current install? Thanks! Really looking forward to using it!
Thanks for the reply, I guess I'll just use it for another project :) Thanks! 
&gt; and will make everyone forget about all the php-fig drama for a minute Damnit, thanks for reminding me! &gt;:|
My first impression is that creating an account is done without SSL. Not good.
I would argue to use Null Objects over nulls, for some of the same reasons as why you shouldn't return false. If you return null, you have to do some of the same checks, which clutters up the code. Returning Null Objects means no checking is necessary, but you do have to at least consider what to do with Null Objects... but, I would argue that in some form or fashion, you're going to have to handle no return values somehow, so Null Objects are acceptable. Great article, and even though it was written long ago, I think it is written well enough to be timeless. 