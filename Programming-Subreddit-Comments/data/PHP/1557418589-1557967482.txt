God! He must manage actual teams!! These are all the ones I voted no for, except short tags (get rid of them!).
Can you give exactly of how this will make code reviews more of a nightmare?
PhpMD is dead for long time. Use PhpStan or Psalm.
Really enjoyed it. Could you, however, provide some concrete code example? I would really like some context to what you was talking about, after listening to the episode. I found the packaged you talked about (the Google timezone client) on GitHub but it did not seem to provide the structure you mentioned?
What do you mean there isn't a message body? I wrote a message together with the title. Do you not see it? I see it both while logged in and incognito.
Hey, thanks! My colleague Ruben hasn't worked on the package since unfortunately, but I'll send him a reminder! I appreciate the comment :)
The 90s called and want their website design back
I see it now, but yesterday there were no original-post messages anywhere on this subreddit.
Perhaps I am not understanding the question. &amp;#x200B; I thought that having the phar would contain the dependencies for phpunit inside the phar and avoid project level dependency conflicts. If the test case is a newer version of testcase, would we not just get a new version of the phpunit phar to match?
I'm still not sure if I like it or hate it ...
It will take you quite a while (months) to learn all the ins and outs of unit testing. Looking at some more complex projects like dbal can give you some ideas. That said, it's *very* useful. I guarantee you you'll find multiple bugs in even your most solid code the first time you write tests for it.
The website seems a bit light on details (How does it work?). &amp;#x200B; See also [s](https://synk.io)nyk.io ...
It's O(n), I wouldn't recommend doing that.
Array merging is linear by definition
But arrays in PHP aren't really arrays so that wouldn't necessarily apply. Unfortunately I think /u/the_alias_of_andrea is right and it is O(n), I don't think it has to be though and there are definitely cases where it doesn't matter. If your operations are guaranteed to be on smaller collections it wouldn't really matter. And it's still faster then array_merge
&gt;at what stages of development should I be doing it Simply put. E-v-e-r-y-t-i-m-e
&gt; God! He must manage actual teams!! Oh my god here he goes again.
Damn are you stuck in a loop?
Maybe don't hire incompetent people?
Or, yknow, *help* them become better developers?
PHPmd is stable, while PhpStan is not even version 1 yet (still in dev). Haven't used Psalm, but will check it out.
I wrote you PM on twitter; I am interested to try something and maybe write something about it to have some use-case for you
Awesome work!
It's not like writing recursive use of array_merge in functional fold style is a good idea either.
Not really. It seems that Symfony4 + ApiPlatform stack with a fully grown project brings to much complexity for xdebug. It's just painfully slow. I'm still open to suggestions and alternatives though.
Use this all the time in JS. Glad to have it in PHP.
Thanks. I used Gmail's SMTP servers and it worked.
You should try to unit test as much of your code as possible. Sometimes though, in tight deadlines, it can be hard to write tests for every method. Think of unit testing as a "bug safety net."
I would go even a step further and start by writing tests. I have tried this out for a few weeks now to first translate my scenarios into tests and then write the actual intended code. This forced me to think ahead in a way more predictable way. Sure, there will be times where you notice you have to change your tests as things "panned out differently", but even then you normally still have better code in the end, as you are forced into certain principles (single responsibility etc) from the get go.
[removed]
[removed]
These 3 articles are fairly recent (PHP 7) and good IMHO https://nikic.github.io/2017/04/14/PHP-7-Virtual-machine.html https://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html https://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html Note that it's all nickic. So basically, everything on that blog is good. News around these parts is they're nickic for JetBrains now on PHP stuff.
[removed]
Yeah, I don't agree with making every class final but testing against interfaces is ideal and makes testing loads easier.
[removed]
[removed]
I have used Aerys, which is not on your list, to run a websocket server and its been working great. I have toyed around with Swoole and its seems to be the way to go if you want high performance. But it requires you to install it as an extension.
[removed]
It doesnâ€™t matter what the version number really says in the case of a code checking tool. PHPMD doesnâ€™t even support list deconstructions which makes it useless in any newer codebase. I will not even mention that number of rules PHPMD supports is an order of magnitude smaller than what PhpStan offers. I donâ€™t wanna cause a flame war, I was a user of PHPMD too, but its days are over. If you want to talk about such tools join us at static-analysis channel on Symfony Slack - there are authors of both tools there willing to explain and help write custom rules.
but [https://amphp.org/amp/](https://amphp.org/amp/) and [https://amphp.org/aerys/](https://amphp.org/aerys/) have different functionalities, right?
I'm liking swoole. The performance is bonkers. Shame about the awful documentation.
This post was removed because you have a new account and we get a lot of spam from newly created accounts. If you have any questions or think your post should be reinstated, please send a message to the mods. *I am a bot, and this action was performed automatically. Please [contact the moderators of this subreddit](/message/compose/?to=/r/PHP) if you have any questions or concerns.*
What this article taught me is just how much I &lt;3 all of my `.gitlab-ci.yml`s!!
Ratchet is trash because they don't support wamp v2and have no plans to support it. This is what I last used with great results. https://github.com/voryx/Thruway
Unit testing are automated tests that ensure that the public interface of the units of your softwareâ€”usually classes in PHPâ€”behave correctly and consistently. For example, if I had a class: class Calculator { public function add(int $x, int $y) { return $x + $y; } } a unit test would do something like this: function testAdditionWorks() { $calc = new Caclulator(); if ($calc-&gt;add(3,7) !== 10) { throw new TestFailException("Cacluator::add() test failed"); } } Normally you would use a testing framework like PHPUnit instead of writing a bespoke function like that, but the end result is the same: you test to see if your class' public methods produce expected outputs when given expected inputs. Ideally you want to test every public method of every class. You run those tests every time the software is changed, in order to make sure that you didn't break something or change your class' public interface. For me, unit testing offers several advantages: * I know that changes I make aren't going to cause regressions. * It allows me to think small. Because unit tests test only designed to test one method on one class, when I write my code I concentrate on just solving these tiny problems. I don't write a big bundle of code, run it, and hope that all the changes I made worked. I write a test write a small (~10 lines) method to satisfy the test, then test it. * It discourages coupling. It's hard to test classes that rely too heavily on other objects' behavior, so I tend to write code that doesn't rely heavily on other objects' behavior. I try to write tests first for all of my code, and then write code to satisfy those tests. In most cases it greatly speeds up my development time, since I am coding "closer" to the problem. Sometimes it is hard to unit test, especially with things that have lots of side effects or must deal with the world outside of a class. For instance, it's much more difficult to unit test things that deal with databases or make API calls.
I dare you to do this with Google Pay. It's a substantially harder beast!
He is referring to the fact that this rfc does not work for arrays with strings as a key. So this wouldn't work: `$my_array = ['id'=&gt;55,'name'=&gt;'John'];` `$another = [ ...$my_array, 'phone'=&gt;'888-555-1234' ];`
Jenkins is pretty easy to setup and free.
I didn't have much luck with AMPHP. My use-case was we wanted to fire off a bunch HTTP request asynchronously. With a bit of rearchitecting we ended up just using Guzzle Async promises.
would you happen to be using it with Laravel at any point. I am struggling to get perspective on downsides and whether packages run into issues with swoole's requirements.
That's a bit harsh, not everyone needs WAMP. I've been using Ratchet for quite a while now, and I love it a lot. TIL of Thruway though, thanks for making me aware of it :)
He's referring to two things: - Spread operator with non-numerical keys - Using the spread operator with array destructuring
Can you explain some other examples or architecture / what other types of projects one would use this to build, I read phreaxt site breofly and it talked about async network of client and servers. Iâ€™m still learning backend wouldnâ€™t say Iâ€™m new but still in the beginner realms
Are you asking about guzzle async or something else?
Yeah generally about what tools you guys are comparing but yeah about guzzle async too
I use Swoole for one of my own projects, speed is absolutely crazy.. Documentation is a bit lacking but it's not too difficult to figure out. http://git.karbowiak.dk/karbowiak/Eon in case there is anyone interested ðŸ™‚
Just do: $some = $coughie + $melk; Or: $sum = 2.1; Lel
$coffee = "2.00"; $milk = "0.10"; $total = $coffee + $milk;
Not exactly the same, it serves a different purpose, but I have to mention exakat as a great static analysis tool. The report is spits out is excellent, gives an incredible amount of insight into projects.
But in the select option there are more than only milk
phpmd has enough open bugs. And has it's problems with new features and anonymous classes. And since the website is down, there is not much documentation. I've currently seen that phpcs has a code-complexity-option. So a combination of phpcs and phpstan can cover a good part of the functionality
I've mainly used symfony and laravel, whats the difference between them and swoole?
This question is more appropriate for /r/phphelp, as this isn't a support subreddit. When you post it over there, try and give more information about what you're trying to achieve and whst you've already tried.
Why the hell...... would you use WAMP as an abbreviation for Web Application Messaging Protocol when 90% of webdevelopers will think of the WAMP stack...
You should probably google first so you don't collect -1s, this is a trigger happy subreddit :) Symfony and Laravel are frameworks, as you know, to create APIs / websites etc. Swoole is a PHP extension, primarily targeted for command-line use, to create various servers (web socket servers, http, various services that sit in background etc.) It exposes features such as coroutines (lightweight threads), asynchronous file I/O, asynchronous Redis/MySQL communication etc. While the two you mentioned are frameworks that are usually accessed by using PHP-FPM, swoole can be used to replace PHP-FPM and boot up Laravel - yielding significant speed ups but there are various gotchas that the programmer needs to be aware of. That's the short explanation, check what google says about the rest.
I've used all of the mentioned (I also used icicle.io), and I tried to create my own. The problem is in the execution model between Ratchet+Amp compared to Swoole - it's not just Swoole's performance, it's all the other tools it exposes - the swoole table, the OS's event loop, async file I/O, async MySQL/Redis, the way it handles connections and so on. Codewise, it's all PHP in the end but Swoole is on a different level (performance and feature-wise) - which is what's expected from something exposed as an extension opposed to something written in PHP. The only bad thing about swoole is the documentation, but that's being improved. Having written this, swoole blows the mentioned two away.
Fuck yeah spread it
There should be destructuring support in parameter lists too: [https://3v4l.org/XcDNR](https://3v4l.org/XcDNR) &amp;#x200B; It allows you to specify what a map should contain in the signature
The whole thing might be a bit too much information for you yet, but this example on the decorator design pattern is pretty much the exact problem you're trying to solve: &amp;#x200B; [https://github.com/kamranahmedse/design-patterns-for-humans#-decorator](https://github.com/kamranahmedse/design-patterns-for-humans#-decorator)
At my company we are using swoole + zend expressive (to avoid global application state) and its running very well.
How does this exactly work and how will it affect / improve my code? Im curious
Nice one :) love to see the community doing this! hopefully will be under the [PHP-FIG](http://www.php-fig.org/)
in PHP avoid to do math with floats :)
There has been talk about named parameters in the past. Here's hoping they will be added one day!
Pro tip: Actually say what the project is or what it does in your README.md
Lol no, fuck vim
[removed]
&gt; async file I/O, async MySQL/Redis, the way it handles connections and so on. That is in the amphp libraries too, though.
Asynchronous programming typically means you want to do multiple things at once rather than in serial (one at a time). So e.g. if you wanted to fire multiple http requests, to cut down overall execution time of a script you could use guzzle async. The drawback is you don't know in what order they will finish or when, so to overcome this guzzle ships with a nice 'promise' api so you can do things similar to JS-land then, Promise.all() and await. Async is generally useful mostly for high I/O operations where the majority of the execution time for something is waiting for an external action to return something. So rather than letting that 'block' the whole script, doing it async means your processor can 'loop' over a set of operations and check whether they've finished yet or not, and carry out predefined actions on those that have finished, without requiring multiple threads/processes.
A text editor cannot be an IDE even if you install a 1000 and 1 plugin. IDE is not just a text processor.
[removed]
Been there, done that. No.
[removed]
[removed]
even if with lsp?
It's a PHP parser written in PHP, which several projects use under the hood. This will mean that they will support short closures when 7.4 is released
That would make sense, but it doesn't really do much yet. Idea is that it'll be a framework for my own stuff, but work comes in the way :P
[removed]
What do you think it has to provide which is not available/possible via plugins?
Async file I/O is not possible with AMP, as PHP doesn't expose too many file system operation functions that can be played with. All of PHP's built in file-related functions are synchronous. &amp;#x200B; I didn't know about MySQL though, I checked it after your post and yes, they re-created entire MySQL client in PHP (no PDO, no mysqli). &amp;#x200B; Still, you've got the issue of a program written in C (swoole) and something written in PHP (AMP) - there's just more control that you've got when dabbling with C/extensions, and it'll work faster. &amp;#x200B; Regardless, good catch, AMP supports async MySQL / Redis. +1
[removed]
ngx\_pagespeed seems very interesting: [https://www.ngxpagespeed.com/](https://www.ngxpagespeed.com/) &amp;#x200B; Haven't had the chance to run it on production yet
Czech parties &amp; orgies here http://ogurl.co/cB9l
Yeah, Iâ€™m a die-hard vim user but nothing beats PhpStorm
What are his arguments for not using Guzzle?
[removed]
Why vim?
[This](https://github.com/amphp/file) is the file component... haven't actually tested it, though. But I had a look in the Parallel Driver, and they're spawning an (amphp) worker - so it will be async, but depending on how swoole implements this it can of course be faster. There's also support for postgres, beanstalk, streams &amp; sockets in various amphp libraries. I get your point about a C-extension, though - that certainly has speed benefits (and it's own drawbacks, too, of course).
[removed]
I'm not. I have a minor abstraction layer for symfony, but I'm using Swoole for only a small portion of my overall code that is performance critical, and leaving the rest to PHP-FPM.
For doing maths in PHP especially if it involves fixed precision calculation which money certainly is then we have the bcmath library for this. So you'd do
Oh God....
Does not matter - those have completely different design principles behind them.
Thinking of using something different than PHPStorm makes me sick. I can't tell how many ways this IDE is better than any other. It saved my ass with the history so many times that worth the price...
Amp provides primitives for writing asynchronous code; event loop, promise, coroutine, etc. Aerys is built using Amp.
If only uploading to ftp server wasn't broken. I'd love it. 8 years waiting for it to be fixed is a joke.
You can even https://www.jetbrains.com/help/phpstorm/using-product-as-the-vim-editor.html
PhpStorm just seems to "get" PHP more than any other editor I've used. I can ctrl-click something and there's a 99% chance it will find the source (or usages) even with stringly-typed services. Throw in some phpdoc to help it and it's just a great experience. ...I swear I'm not a shill.
It's working for me just fine. Or do you have a particular issue associated with your workflow?
PhpStorm's LocalHistory pays for its $100/year in saved otherwise-lost time usually within the first 2 months of me purchasing it. That alone is worth the subscription price, if you ask me. I also lean on it heavily for code completion (not the idiotic vim variety), XDebug support, and git merge conflict resolution. But just yesterday, a fellow dev who kept telling me "I have *FIFTEEN YEARS* of PHP experience. I'm definitely a senior dev", yesterday told me that he had no idea what xdebug was. How the fork?!
Full XDebug support. You noobs will never understand how I can 10X your asses with legacy code.
Cool
Well when editing some minor stuff with a quick SSH session having some IDE power in vim is probably nice. Have to set it up some time.
I &lt;3 amp.
It doesn't support v2 which adds a of functionality and most packages like Autobahn need it.
I didn't come up with it. The protocol is called wamp which I agree is confusing because of the wamp stack.
It's a known issue, marked as major I think, on the jetbrains bug tracker. It gets stuck in the collection phase.
This article is about SCRUM, and not necessarily everyone who works with PHP works with Scrum but I like this community (subreddit) and thought you might be interested.
What
Of all of the features that PhpStorm has that are hard or impossible to replicate in vim, it's strange that both of you talk about local history, an equivalent of which has been part of a default vim installation for nearly a decade Â¯\\\_(ãƒ„)\_/Â¯
Whoever made their mobile site needs to be fired, instantly.
Ahhh ok
Great answer! the first few times you write a unit test you think "what am i doing this for? i know that 3+7=10!" - but this misses the point that you now cannot break your method by accident when refactoring/rewriting. Also, if you write tests first (test driven development) it makes much more sense, and you start thinking of your code in terms of inputs and outputs rather than big blobs of logic
All I hear is "I've been doing the same for FIFTEEN YEARS and it still sorta worked, why should I learn anything new".
Let me disagree. If you're thinking of unit testing like a lot of people do: testing individual methods with tons of mocks. It will come back and bite you hard the day you have to refactor something. If the unit you're considering is the interface of what you are making (input / output for an API, public interfaces for a library or framework, your webapp) then you'll love your test suite. Especially the day you have to make big changes: your users don't care that your DataObjectSerializerGeneratorFactoryFactoryImplTheRealOneVersionThree works. They want to receive a perfectly formatted email when another user send form X. The best is when all your specs are checked by your tests. That's when you can "easily" write them before any code. This also mean you have specifications so a contract between the "client" and you.
Gonna get a lot of flak here for saying this, but once you learn about testing, try not to architect your application in a complex way simply because it's easier to test. Many people initially reach for things like dependency injection and lots of interfaces because they're easier to test. If these techniques genuinely make your application easier to develop, refactor, etc. then go ahead. But many times simply `use`ing a class with a static method is easier to read and maintain
The thing that would beat phpstorm, is phpstorm detangled from java.
I'm not a big fan of Vim-IDE-out-of-the-box. One of the big strength of Vim to me is: you can configure it depending on your precise needs / workflows. What you can't really do with something like PHPStorm. That's why it's better to begin with the basic install of Vim and add what your **really** need. I wrote an article where I explain every plugin you might need to build your own PHP IDE: [https://thevaluable.dev/vim-php-ide/](https://thevaluable.dev/vim-php-ide/) If you want to know why I switched from years with PHPStorm to Vim, here's the story Hope it can help!
PHP storm + IDEAvim plugin.
It's what I thought. Except that the local history in Vim is even more powerful than the one from PHPStorm. It basically save every undo you can do in a file. You can even search through them with [mundo](https://github.com/simnalamburt/vim-mundo)
Pull the values of the selected options from your select box into an array. Then iterate over all elements of the array and sum up the items. $items = ['2.00' =&gt; 'milk', '0.10' =&gt; 'coffee', '0.50' =&gt; 'apple']; $sum = 0; foreach ($items as $price =&gt; $item) { $sum += (float)$price; } // $sum is now accurate here But as others have mentioned, doing math against floats is not usually a good idea. Use bcmath or some library for dealing with money. Also the above code snippet assumes you know how HTML forms work and how to create a basic function that will receive a POST request from a form.
&gt;and why would I ever want to reverse it &gt;I don't know
Been doing PHP development professionally for 8 years. I had no idea what a binary tree was. Lack of formal education, I guess.
Exactly! Like this instant refactoring: https://github.com/rectorphp/rector/pull/1410
Thanks!
Already merged in php-parser: https://github.com/nikic/PHP-Parser/pull/609 ðŸ¥³
While I agree that Phpstorm has some cool features, I still use vim because I like to have some free RAM left. &amp;#x200B; Also, with the right plugins, you get very close to a full ide experience. But to each their own I guess :)
Does it save it after close tho?
They're useful for if you want to maintain a sorted collection while adding and removing elements. Because PHP fires up a separate process for each request and then tears down, it just doesn't seem to come up much. This sort of thing would pop up more in JS, since there we have a feedback loop with the user.
Magic methods: How to create unexpected bugs, prevent static analysis, and confuse future developers. &amp;#x200B; There are good uses of magic methods, but in general, my recommendation to all beginner devs: Avoid magic methods, write explicit methods when possible.
Why would anyone willingly inflict this upon himself is beyond me. I am not saying that they shouldn't, it's everyone's free choice - I just don't understand why, when there is PhpStorm.
That's actually something that vim does have a pretty decent plugin for actually
very cool, thanks for that. yeah, this was a post-google comment but still wanted to see if anyone can put it in other terms. so, you'd use swoole in place of php-fpm? anyway yes i'll dig further on my own - thanks again
Good explanation, nothing more needs said. Our use-case is we need to collect data from 3 remote APIs and package them into a response for users of our own API. Rather than waiting on them to finish in synchronous manner we use guzzle async promise like /u/stfcfanhazz described. So if API 1 &amp; 2 take two seconds each, and API 3 takes three seconds, the total synchronous operation would have taken seven seconds. Since we are no running in parallel, we are now as fast as the slowest HTTP connection, cutting time spent down to three seconds. Under the hood I am not exactly sure how it works. Somewhere a long the line cURL is creating multiple processes I believe
Another point of view: [#NoEstimates (Allen Holub)](https://www.youtube.com/watch?v=QVBlnCTu9Ms)
Nice! You're doing some neat stuff over there
Agree... Magic methods should not be in your everyday toolbox, but you should definitely know how they work. You may need to use it rarely, but you may come across them in someone else's code more often.
What do you mean reverse it? Do you me traverse?
As a Vim user, that's how I feel about PHPStorm. Every time I've tried an IDE, PHPStorm included, it's made me want to set fire to it, it's so screamingly annoying. It's usually painfully slow to start up, and the UI is horribly over-burdened. Especially since I discovered PHPActor, there really isn't anything I don't have in Neovim that I like from PHPStorm. I've got very good completion and refactoring tools, I can navigate around as well as in any IDE, and the FZF and Ripgrep based search I use these days is extremely fast and efficient.
I'm using SFTP &amp; I don't have any problems. Are we talking bulk upload or on save deployment? If bulk, I've been using scp/rsync, worst case scenario filezilla.
Me do converse?
I get that it's capable, but at some point you've gotta learn all that, figure out what works best, tinker tinker tinker. I'd rather invest that time in the application I'm building. Don't get me wrong, I AM a tinkerer . . . but not with my livelihood.
Haha I didnt see that, thanks.
Did my last 3 projects on Swoole, it's amazing. The co-routine model is awesome and it overrides the default pdo, redis and mongodb extensions to be async, you get it's benefits without any extra effort. IMHO Swoole is the best solution for async programming in PHP.
Thanks for your atical, I will read it, and just to find if there are some tips I need.
That work together ribbon on mobile is way, way too big.
me too, I use windows os, the Win 7 os, it is too old, and when run normal IDE, the os sometimes blocked. I like vim, it is very light and fast, I do not need to wait for response after pressing any key.
Thanks for sharing. There is so much tools and information out there. It's nice to get an overview.
yeah, the undo history is saved.
As I'm reading your conversion from PhpStorm to VIM, I'm at the part of you not being a touch typist. Being proficient at keyboard short cuts work just as well as VIM in PhpStorm. In fact, I can tell how much effort people put into being proficient with ANYTHING they come across by how much they user their mouse. Watching a co-worker highlight some text to copy and using his mouse with 80% of the operation drives me crazy. It's such a simple process (to me). I would guess I can do some where between 70-80% of what is needed to be done without the need of my mouse in PhpStorm.
Thanks for reporting that. I'll try and fix it asap
Horizontally flip it.
all IDE feature is based on command line tools, if you are family with these command, you do not need IDE, you can run this command with neovim or vim8 's job api.
You mean taking the left nodes and switching it with the right nodes?
But to me closed source software is not something I would spend one second with, so there's that.
Perfect explanation, thank you so much. That really helped me understand a good use case for something like this. Thanks again!
Same feeling. I live in the terminal, and writing code anywhere else is painful to me. I just want to fill my screen with nothing but code, and thatâ€™s what I do. Iâ€™ve curated a list of plugins that make my life easier without adding stuff that gets in my way. People will think Iâ€™m crazy, and Iâ€™ll think theyâ€™re crazy. At the end of the day though, I donâ€™t care what tools they use. Itâ€™s not a religion.
no
who uploads their code via FTP these days? Honest question. Why not put it in a repo, and then deploy on your server?
&gt; Or do you have a particular issue associated with your workflow? Yeah, they FTP their code up ;)
I'm assuming you don't drive a modern car, never fly on an airplane, use any site other than reddit, etc...?
&gt; I just want to fill my screen with nothing but code, you can do this with an IDE just FYI
You could attempt to use it against PHP-FPM but it's not the same thing, you have to write an adapter for swoole to bootstrap laravel, whereas with PHP-FPM you don't. Here's the project which is an adapter between swoole and laravel: [https://github.com/swooletw/laravel-swoole](https://github.com/swooletw/laravel-swoole). You'd use swoole for tasks such as worker pools where you have some long tasks that need to be completed (accept request, generate pdf or do some long calculation) or for websocket servers, gaming servers - basically anything that's supposed to run for an indefinite amount of time and do some work unrelated to replying to HTTP. You could also create an entire application and spin it as a server, just like the project I linked - you don't even need nginx in that scenario. However, even though swoole is fast, it's fast for a reason - and speed isn't always the secret sauce, stability is. It's not as trivial to create PHP-FPM replacement. It's definitely fun to use and I've been a user of swoole for about 6 months now, however I wouldn't run my HTTP stack behind it - PHP-FPM with nginx is doing that job quite well, it's stable, it's tested and it's easy to scale.
Unlike some of the stupid puzzle-type questions, or the questions where you pretty much have to already know the answer (detect loops in a linked list in O(1) space...), I don't think you can claim this is a question to make the interviewer feel smart. Does reversing a tree have a use? Almost certainly not; get the same result by just traversing the original tree in the other direction. But if you can't figure out how to _do_ it - and it's really fucking simple - then you will clearly struggle with basic data structures and algorithms. Being a PHP sub, maybe your work is more focused on configuring a bunch of admin modules, designing a good OO structure etc. But believe it or not, that's not the only thing computers are used for - fuck, it's not the only thing PHP is used for!
Thing is i already tried action="", no action but always after 5/6 seconds the page auto refresh.
I bet you wanted to type this question in *your browser's address bar*
Better yet, use Deployer. It's worth it for the symlink deploys alone.
yes
Thank you did that, make sense I use async in JavaScript but havenâ€™t been able to take advantage of it in any real way
have you used the proper PHPStorm standalone IDE? or are you talking about the PHPStorm plugin for Intellij?
i'm with you, but i still have clients who want to control their own server (usually packaged with godaddy or something) and only provide me with a ftp login
A few applications of binary trees: - [Huffman coding](https://en.wikipedia.org/wiki/Huffman_coding) (which is used by compression algorithms) - [Nested set hierarchies](https://en.wikipedia.org/wiki/Nested_set_model) - [Advanced Access Content System](https://en.wikipedia.org/wiki/Advanced_Access_Content_System) (the encryption system for Blu-Ray discs) - MySQL uses [B-Trees](https://dev.mysql.com/doc/refman/5.5/en/index-btree-hash.html) for some indexes Of those use cases only one is really relevant for PHP devs (or, really, most any dev imho lol)
There is nothing stopping you from running grunt, gulp, webpack, or whatever other compression on your JavaScript and css files in a php environment. Donâ€™t run them on the php code, though. If you really want to compress the html output, you could do so with a clever use of `ob_start()`, `ob_get_clean()`, then removing all multiple spaces and carriage returns. You could even add the compression function to the `ob_start()` function.
Other developers in the office use intellj (not phpstorm). I am the only one who uses vim. They don't use xdebug, neither do they need git merge conflict function. Code completion yea, but it doesn't help when you don't get how the bugs play around.
my team, because some of them don't do it locally. and because they want to modify the files in `vendor/`, don't ask me why.
good to hear that I know you use Facebook too
Downvotes?
Ugh... black &amp; low contrast. My eyes would never forgive me.
what?
really, it's personal preference get the job done and make sure you don't get a heart attack
It's indeed very powerful. Personally I added this to my vimrc many years ago and :ClearUndo is stuck in my fingers now (I type it way too often and sometimes without noticing) function! &lt;SID&gt;ForgetUndo() let old_undolevels = &amp;undolevels set undolevels=-1 exe "normal a \&lt;BS&gt;\&lt;Esc&gt;" let &amp;undolevels = old_undolevels unlet old_undolevels endfunction command -nargs=0 ClearUndo call &lt;SID&gt;ForgetUndo()
out-of-the-box? No, FYI
Vim is just for micro edits at the command line, I use it quite often. Trying to fudge it into an IDE seems a waste of time.
As developers, we strive for efficiencies across the board: \- response times \- query times \- performance tuning \- etc Yet, most won't try to figure out the most efficient way to use their tools? That's not a "personal preference".
Vim __is not__ an IDE. Vim is a text editor. If you're looking for IDE functionality, then use an IDE. Don't modify a text editor to do things something else already does well... Maddening.
Probably some settings changed by your web/mail host.
lol no. Vim is incredibly powerful and very easy to learn. But using Vim this way is just dumb.
&gt; Vim is just for micro edits at the command line What shit are you smoking? Seriously.
Thank you !
&gt; I fell victim to the meme that Vim is hard to close! Literally you.
Thank you!
For those not in the know, PHPMD stands for PHP Mess Detector: https://github.com/phpmd/phpmd
I tried going down this road a while back. Installed NeoVIM and put in place a bunch of plug ins. Some of these plugins, at that time at least, were not trivial to install. It's been a year or more since this effort, so I don't recall which ones gave me issues. Might come back and visit this all again before too long. A bigger problem for me was not being able to find a good plug in for dealing with database issues. I end up writing some pretty involved SQL that I eventually put into my PHP code. PHPStorm has a great database console for doing just that. Heck, even Eclipse and Netbeans handles this pretty well. They can all fall back to JDBC support to me send my queries to many kinds of databases. The other issue I had was the amount of stuff that you need to memorize to be truly proficient at VIM. I'm able to use VIM quite a bit for one off edits on a server for both code and configs. When using it as a primary tool, I had trouble justifying the time and mental space being devoted to it rather than the software I'm trying to develop. I realize that can be resolved over time, but I haven't found myself with that kind of time yet. As much as I rely on PHPStorm for the many things it provides, there is still a desire for something a bit more streamlined. Maybe it's having to run on the JVM, or being unable to use it from a CLI. Whatever the case may be, I can fully appreciate the desire developers have to try and get something like VIM to work like an IDE. I wish the folks putting this effort into VIM the best of luck with it!
that's definitely a preference and vim can be the most efficient tool alive for some developers. Try to challenge this idea.
It's Nixihost and their tech support SWEARS it isn't them. Anyone know of good hosting alternatives?
What do you mean? All the Jet Brains IDEs are built on IntelliJ IDEA which is written in Java.
Are you using authenticated smtp with username the same as the from address?
You should anyway use a service like Sendgrid, Sparkpost etc. Most of them are very cheap, if not free. Your error mainly happens with Gmail I assume? Itâ€™s because the smtp user you use is different than the email address you specified as the sending address.
Holy shit, I thought you were kidding... Being hyperbolic or whatever. Nope, that site is an abomination that must be launched into the sun. How does that even happen? Holy shit!
Not the help subreddit, and this is even more towards basic mailing set ups than PHP related stuff.
Thanks. All I could think was "Dr. PHP, M.D."
I'm using PHP Mail, which worked fine up until March.
Can you send me your ticket number? This is just a configuration issue with your site/script. cPanel forums actually have a decent thread about fixing it here: https://forums.cpanel.net/threads/email-sent-as-username-hostname.601655/
This issue presents itself when mail is sent to Exchange, Google, Outlook, almost any client/server that I can think of. PM me an address, happy to shoot you a test.
Gotcha! Apologies for missing that. I'll move/repost over there.
I don't get why spacevim gets all the hype when, in the end, it is just a mega-giant config file... You just download it and you customize it, but you will always have a bloated config, 2000 plugins, slow startup time, etc...
Please do a https://www.mail-tester.com and share results
I use vim 100% of the time and while I concur that vim is an awesomely powerful tool I can't say that it's been easy to learn, the learning curve was big and it took me a couple of months to become proficient at using it and I'm still learning about vim.
Say you need an autocomplete, and the db gets slow with "WHERE foo LIKE 'searc%'". You can create an array in a php script (that always runs, as a daemon) with all the combinations of your search, where the keys are your search and values the search results. Then, as your data grows, you run out of memory, so you turn it in a tree structure (maybe not binary, but same idea). It will be slower to access, but much faster than the db, and use way less ram than your first array. Since you want to search fast, you traverse the tree instead of looping and searching all values. That's kind of the idea, but there 10001 ways to skin this cat, so chances are you wont ever use it. ( Just replicate a database multiple times on your local machine for example, would solve the same problem without needed special algorithm)
That plugin is one of the best there is but it's nowhere near the full feature set of vim.
I see you've never actually tried an IDE, definitely not PhpStorm, because in fact you can, out of the box. Also, there's literally a key combo for distraction free mode. You'd know that if you pulled your head out of your pompous ass. So, FYI. You're absolutely, 100% wrong.
It's worth noting that B-Trees are similar to binary trees, but not the same. In a B-Tree, each node can have several values (databases typically store hundreds of values in a node), and can have several child nodes, one for each space between its value. Where binary trees can get very deep, very quickly, B-Trees optimize to stay very shallow, while preserving the ability to quickly access elements in sequence that binary trees have. To add to these great examples above, another variant of binary trees are quad-trees, which are used in games to sort assets by distance, to make sure the most important assets are loaded first. Simply put, rather than splitting on just one key, they split on two keys... often the X and Y coordinates of an object, though of course there could be different keys if your application doesn't have a concept left/right, north/south, etc.
No. PHPMD is not dead. Just resting.
PhpStorm is more integrated. I used to use IntelliJ because I wrote Java and Ruby along side PHP and liked having the ability to quickly switch. Now that I am 99% PHP, PhpStorm is a far better experience and it is more up to date than the plugin releases. If I still need to udpate some java or ruby I'll open IntelliJ separately.
How much ram do you have that 500mb is causing issue...? My browsers use more ram than PhpStorm...
bullshit, a key combo means it's not out-of-the-box low lives
Wrong. Out of the box means the functionality is built in. By your logic VIM literally does nothing out of the box.
I define my own out-of-the-box definition. Try your best to challenge this. Vim does that by default. :)
Nor own an iPhone or Android phone... let alone use any popular apps/games... only read on paperback
To be able to open, close, edit, save, and move within a document takes `vimtutor`, so probably 10-15 minutes. Maybe 2 days if your a slow learner. But I'll totally agree that mastering Vim is an uphill battle. I'm still barely proficient, sometimes.
I agree too. &amp;#x200B; If you're thinking of using them to avoid writing too much code (for example, getters and setters), you should consider having tools which will generate the code instead. This way, you don't have to type every method by hand but it will be a lot easier to work with.
Coming from sublime text I noticed my habits of new Windows do not play nice with phpstorm and ram usage. Also can't help but notice Java houses a lot of that usage. 1.9GB of just the Java framework to run phpstorm.
Actually you didn't compare test tools. you comparing third party testing companies. All they are doing are using some testing tools in the background with an api and an webui.
But you can't search out of the box, hell you can't even quit "out of the box" No code completion out of the box. Vim doesn't even have a feature to let you type out-of-the-box
Pining for the fjords.
fill screen with nothing but code
This is what people fail to understand, most of the IDE utils come from or have an equivalent command line tool that vim can plug into natively most of the time, if not it is valid to install a plugin that closes that gap - deoplete with a php source give me autocompletion similar to what an IDE has, ctags gives me navigation, phpcs on save for .php files gives me code styling, it's really simple tbh and learning vim for the modal editing alone is a huge boost in productivity and allows you to use the mouse less.
I have a keyboard shortcut ^u which uploads the current open file to the project's remote server. Using. FTP or SFTP. I do use Acrosync to rsync local to remote, but I like the control of simply uploading a single file with a single keypress combo, in a single app. Trouble is, about 1 in 10 times, this will truncate the remote file to 0 bytes and hang Phpstorm while it does some kind of "collection" forcing me to kill Phpstorm.
Something must be wonky... My PhpStorm 2019.1 with an empty PHP project uses 440MB. Switching to my old work project with 7000+ PHP files uses 657MB
Hahahaha downvoted for an answer. Nobody else bothered. Typical PHP community
PINING FOR THE FJORDS? ðŸ˜¡
You are using exim?
It doesn't come up a ton in PHP dev (at least not the type of dev most PHP devs do) but it's useful to know on some level. That said most of the time when these come up on job interviews it's mostly a question about knowing how recursion works and what trees actually are.
i mean if you're using the PHPStorm plugin for IntelliJ, you'll probably have a worse time than using the standalone PHPStorm IDE app. just from people on my team who use the plugin, they have issues more often than the standalone app
enable debug to see what is going on, don't go blindly about things.
PHP code rarely stops silently. You should go look at your logs and search for an error which will explain what's going wrong. &amp;#x200B; It could be a time or memory limit reached or something. The fact that the echo solves the issue is strange. If I had to guess, I would say that it's something else you do when you add the echo that change the environment. Maybe the deployment of the modification delete corrupt caches and hide the issue when you try to find it...
ReactPHP. Its runs on plain php without any special things at all. Code Quality is A+++. Community is not so big but full of great people. &amp;#x200B; Its super simple to use. You use symfony at the moment? Wrap that with ReactPHP, remove your php-fpm and your shit will run times faster... Its very simple to wrap all the things if you got a clean request/respone infrastructure in place. Also you will get the Async capabilities in your framework/environment of your choice. 100% compatible with 15 year old legacy code. Why do i want to install something if it just works?
I think you're looking for `cat myfile.php` &gt; fill screen with nothing but code vim does not do this out of the box
Its totally possible. ReactPHP (with exposed eventloop) does now have a (in dev? not sure...) ext-eio adapter and a spawner.. [https://github.com/reactphp/filesystem](https://github.com/reactphp/filesystem) &amp;#x200B; Also i wonder how swoole makes PDO work. Maybe workers? :P
I go in the standard controller. return no response at all. and echo a json\_encoded array. After that there is an mandatory exit because the framework would fuck up the ajax!
Do you know the coastline paradox? That is what youre doing when you estimate. &amp;#x200B; Best tip: Get clients who pays the unknown bills.
&gt; fill screen with nothing but code fill screen with nothing but code
Ahh you're twelve. I see now.
Nice to see articles about trees, i love it, thanks man :) I made my own lib to handle trees, and I also made a special modifier to reverse the tree, just like you explain... https://github.com/drupol/phptree/blob/master/src/Modifier/Reverse.php If you plan to test PhpTree, let me know what you think of it :)
I use [Laravel Resources Controller](https://laravel.com/docs/5.8/controllers#resource-controllers) to serve my data, so it helps me better shape my REST urls because it forces me to adopt a unified convention across my routes (and I am not tempted to use keywords like "save" when I could just use \`/book\` in POST instead of \`/book/save\` in GET). Overall I cannot do any REST API without Laravel, so clean, it releases my time for business oriented improvements.
But what about reversing the tree? Is there a practical use case for that?
Hes the librarian of the [php.net](https://php.net) comment section. A piece of art, history and documentation at the same time.
Estimation is not meant to be a time estimate. Story points are used for complexity, risk and size of the requirement. The work time has nothing to do with it. Also, we don't have clients.
Do you have more info on optimization by ob things like the compression? This sounds hacky but good?
this is garbage...
Yes i did not read long after i see that its only story points. But i wanted to comment the title for future generations.
But I agree with your point. If it is estimated in time, then its definitely not a good approach!
How do you define dead? It's a working product - what do you want it to improve upon?
Spent quite a while experimenting with ReactPHP, PHP-PM, and RoadRunner. Here's what my comparison matrix looked like during evaluation: feature | PHP-PM | ReactPHP | Roadrunner ---|---|---|--- One process per request handler | Y | N | Y Pure PHP | Y | Y | N | Directly serve HTTP | Y | Y | Y Directly serve HTTPS | ? | ? | Y HTTP2 Push | ? | ? | Y (`http2-push` header) Supported/active maint. | ? | decent | 1-2 people HTTP logging | Y | DIY? | ? Dynamic worker pool size | N | n/a? | N? Logging from workers | meh | OK (stderr) | OK (stderr) (may be a bit out of date at this point) Long story short, I ended up sticking with PHP-FPM, but got PHP-PM up and running in a pretty stable state after quite a bit of tedious infrastructure work. While it was &gt;20x faster locally (since optimizations are off in dev mode), it ended up only being negligibly faster in production on some requests, and sometimes no faster at all. And plenty of new, hard-to-diagnose and harder-to-repair errors. Part of that was due to the nature of the requests my application processed, and a fair bit due to having a bunch pretty carefully-tuned stuff that minimizes a lot of the benefits that are offered. It also screws up some metrics (like tracking peak memory usage per request), but ultimately added a lot of stability risk for relatively little gain. DI tools commonly producing a lot of unintentional shared state across requests just breaks too much, and working around that is tedious and removes a lot of the performance gains. Also, Doctrine _really_ doesn't want to play nice in that environment. With pure PDO and a guarantee that requests wouldn't share connections in a weird way that breaks transactions, it probably would be better. I do have a couple of small tools that use a ReactPHP server, but not the main application. Still, I found and fixed some weird edge case bugs over the course of evaluating them so it's not like it was a complete loss.
It wasn't my server, so I didn't have access to the logs on my own. I did get a log file from the client though and found the issue. It was a Deflate error in zlib. There was a php warning later in the page that was causing Deflate to fail and not produce the full page or show any errors.
You can look at e.g. [Hashids](https://github.com/ivanakimov/hashids.php) for a solution implementing technique described above
The thing it is supposed to find messes in keeps having new versions, maybe.
No way. It has its own internal git-like repo for every keystroke change that I can rollback to even if the file or entire directory is completely deleted?!?
Depends on the problem your trying to solve. Look for solutions to your problems, not problems for possible solutions you think might be cool right now.
Not Real Developers.
The main one is passing technical interviews at companies that don't have good technical interviews. Obviously it's also useful in certain algorithms, but if you're asking what those are then interviewing is the main use case.
&gt; It's worth noting that B-Trees are similar to binary trees, but not the same. tl;dr: B-Trees stands for "Balanced" not "Binary" &gt; quad-trees, which are used in games to sort assets by distance Also oct-trees for games with more height variance.
Ah the one true GPL copyleft hipster who's still left alive!
Not Real Developers.
I do routinely as a team lead.
Obviously, Not A Real Dev.
That's the point though, mess detection has absolutely NOTHING to do with versions and whatnot. It's pretty much a set thing that has several different rulesets (something one can manage) and doesn't need to be changed at all. There really haven't been any new criteria to "find mess"
Have you seen the issue list on github? You can use the current version of course, but it will never change again. I'm not going to convince you it needs a maintainer. Sorry to waste your time. Just use it and be well.
php
As I mentioned in my original comment it wasn't my server and it was not giving an error message. I was not going "blindly about things". All I had access to was FTP so I couldn't read the server logs. I finally got the client to give me a log file and tracked down the issue. The server zlib was screwing up during a Deflate and was stopping the render before the php warning could be displayed. It was also cutting off the render far above where the actual issue was.
Quit reading because of that.
low lives. Dev or not, need low lives' opinions? Obviously not.
https://phpmd.org is not responding, github says it's orphaned. does anyone have more info on what's going on?
I didn't know about this myself, but there's an article about it at https://advancedweb.hu/2017/09/12/vim-using-undo-branches/ and it looks pretty comprehensive.
Lol love this
r/lolphp
Php storm only takes that much, but I suppose you're not thinking about Java, it is the only application I have that needs it. So in my instance an empty new PHP Storm takes ~500MB+1.9GB
Just enable gzip on the server, it will zip the html output if the client browser asks for it ( most do ) Rest, mimift the CSS/JS and optimise your images in your favorite image editor. That should get you 98% where you want to be, without any magic tricks
Here: In a Java program, the memory footprint is predominantly made up of the runtime environment in the form of Java Virtual Machine (JVM) itself that is loaded indirectly when a Java application launches.
Its amazing how the weather changes over 20 years.. I stop viewing this sub for a couple years and I don't even know the place anymore. Its like stepping into a PhpStorm struggle session now. It used to be the Vim loonies, haha! Meanwhile I still ST2 and just pretend I don't care..
Right, so in terms of this article that we're commenting on, what possible use is there to reverse the tree.
Yeah I had to reload it several times to be sure it wasnt my connection or Phone that was the issue.
&gt; Obviously it's also useful in certain algorithms Obviously? I can't think of a single one where the order of the branches matters, but you are still able to move them without penalty. If it did, you would use a different data structure with weighted branches or something of that sort, which is completely different. Because you can't guarantee the order branches are visited, otherwise.
Lol yeah itâ€™s like using nano for those quick changes...
Thank you so much for the explanation! (again). That's great. I think I have understand the point. This way I could never have already-generated Short URLs. &amp;#x200B; I will try to implement this someway. Or as @SobakPL said, maybe I could use that library, Hashids. Thanks again. Very helpful!
No love for vscode?
Thank you! I will take a look at it. I think I will implement this.
Use the more active [PHPStan](https://github.com/phpstan/phpstan)
Obviously in the sense that nobody would ask the question if there was *no* use case. Thatâ€™s not to imply the use cases are themselves obvious.
No, phpmail function.
yeah I'm fine with stan, phan and psalm just surprised about the fact md is no more :/
Why would you want to do this with PHP???
Yes, per file. It's configurable, like everything in Vim. It's a tree, too. Which means that if you undo your changes, then begin to do some changes again, it will create a new branch. This is really cool.
Why not?
That is true. At one point I was using a LOT of shortcuts, you can basically do everything in PHPStorm with them. But here's the thing: the editor of PHPStorm itself is not optimized for keyboard only. In Vim, you have two modes: one for writing (insert mode), one for moving around (normal mode). When you are in the normal mode, you can move by words, reach a character on your line, moving by the number of line you want up and down, only with keystrokes. There is this IdeaVim plugin in PHPStorm which can give you a this way of editing. However, you will never have the versatility of the Vim config, you won't be able to share your config easily via Git, and so on and so forth.
I guess he was thinking of real trees..
Found an condescending interviewer!
You can with heavy configuration. But its will be PhpStorm again, its will just look like Vim ðŸ˜…
It's broken? I use it every day (SFTP)
Oh, so reversing just means swapping the right and left side. I always thought it meant reversing the order so that the largest number is now at the top. What is that called then?
It doesn't matter whether there are appropriate applications for the problem solving abilities this demonstrates, an interview is a *terrible* place to try and gauge them based on questions like this. I've generally found you get a much more accurate impression of someone's ability by having a good, in depth conversation with them, talking over past projects and probing them for details.
For last 4 years better job is done by php-cs-fixer and PHP Code Sniffer. Both are still actively maintained and developed.
&gt; If the test case is a newer version of testcase, would we not just need to download a new version of the phpunit phar to match? (possibly an annoyance) Exactly. What's the advantage of this annoyance?
I took the liberty of examining that project, and discovered that the only reason that the web site was working in the first place was that it had been nailed there.
Understanding classical data structures beyond basic arrays can make your code way faster, and will usually improve your understanding of what the machine is doing to make your code go. B-trees are a classic data structure. Many, many coding interviewers will expect you to understand b-trees and how/when to use them.
Pretty much anything you would need to build a binary tree for exists as a module somewhere.
Cool!! Thanks for explaining man :)
Really? You should type war and peace in Vim?? Vim is okay if you are doing rapid development and changing files a little bit on the server before commiting the rough changes back to your git repository. I am smoking something? A weak weird argument by you and your loser compadres. Phpstorm is very nice and should be preferred to Vim in almost all regards.
Can PHP Storm handle other languages?
There is also now psalm, which is great ! https://github.com/vimeo/psalm
Nobody mentioned it afaik but does it support debugging and breakpoints? If not that's a hard no for me
Vim is _literally_ developed to type war and peace and not doing "rapid development and changing files a little bit." You _clearly_ not only don't understand what Vim is, but you clearly don't understand how to use it, either. Anyone who does wouldn't be making any of these claims which is why my "compadres" are downvoting you. Not because I said something they agree with, but because you said something they disagree with. Mainly that Vim is just for micro edits. It's an outrageously stupid statement.
PHPStorm is one JetBrains IDEs. They're basically all identical. Chances are, that whatever language you're seeking - JetBrains has an IDE for it. PHPStorm itself, though? Certainly. Javascript, HTML, CSS, most CSS preprocessors, Typescript, and some other sub-types of JS. Some HTML preprocessors too. And if not, there's 90% chance there's a plugin for that. you can use your PHPStorm for Java, C#, Go, even Flutter and Kotlin if you so desire.
can you list issue or feature you want, maybe we can discuss vie email. wsdjeg@outlook.com
no, spacevim is not normal vimrc, IT do not enable this language layer by default. if you use spacevim as php IDE, you can enable php layer. for Python user they can enable Python layer too.
yeah, IDE hide the major logic of this command. but people should understand these command.
 i donot use vscode. since I do not find anything that vscode can but Vim can not
of cause IT support. you can check out my video on YouTube. debug in spacevim
Check for data with special chars in it.
gitftp in that case.
Modifying packages in vendor? Not good. So you guys just never upgrade your vendors? Brutal.
I'd still use something Sublime or Atom over VIM. The only time I'm dropping into a editor with the shell is when I am modifying config files or on a server, and even then its NANO, not VIM.
Are you using the bundled JRE? https://confluence.jetbrains.com/display/IDEADEV/JetBrains+Runtime+Environment PhpStorm is also my only java application Here is my before PhpStorm: https://imgur.com/iYwji3y And here is after PhpStorm has loaded that large PHP project I mentioned: https://imgur.com/I4nCmnA I have it sorted by committed memory, you can see no enormous java run time hogging ram
&gt; gitftp very cool, thanks
Agreed, for the most part, but just like the classic FizzBuzz, at some point you need to find out if they can actually write some code. I've interviewed people who are bright, engaging, have an excellent repertoire of past projects, and yet still can't actually write code. And I don't know how to say this without sounding patronising, but I really do mean it - this is a _really_ easy question to answer. If I were interviewing for a job where data structure knowledge were relevant and someone couldn't answer this question (I don't care about off-by-ones or missing semicolons etc) then they are 100% incapable of doing that job. Let me put it another way: I've never used Laravel. You are interviewing for someone to jump in as lead dev at a Laravel shop, so in the interview they ask "How would you create a new Laravel project?" Easy, right? Totally reasonable for the job - in fact WAY too easy for the job, right? Well I wouldn't know how to do it without reading the docs. But anyone who's ever used Laravel before is shaking their heads going "who is this noob? You literally type these three words: xxx xxxxx xxxxx". Does it make the question unfair because I don't know how to do it? Nope - it means I shouldn't get the job. I just don't understand the domain. For the record, btw, I have never given a whiteboard coding test (or any coding test) as part of an interview, so I'm not defending myself here.
Are you a poorly programmed Russian bot?
But what if I want three or more words so I can generate fancy looking urls?
This was something I spent about fifteen minutes on this morning. Raise a GitHub issue and I'll code something ðŸ˜
https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/
Focus on what matters, donâ€™t be nit-picky but point out things you think could potentially cause errors or confusion in the future. I try to use a rule that if I plan to leave feedback on a piece of code Iâ€™ve already thought about a potential way to refactor to make it better and offer actionable feedback instead of just calling something bad. Respect other peopleâ€™s coding styles as long as they are inline with company guidelines.
/u/Atulin has a more comprehensive answer, but personally I just use it for PHP/HTML/CSS/JS. Iâ€™m still using vim for many other languages
Realize you have no clue what this person is writing and hit accept. Do read through for style and security issues.
And act like vim, which is quite an important distinction ;)
You can use vim with the native OS GUI (GVim), it doesn't have to be in a shell. That said, it makes a lot more sense to use vim than nano because you get "nano" if you stay in vim's insert mode, but nano doesn't have even half of vim's features.
step 1: code up tree printing function with branch names "right" and "left". step 2: swap order of lines referencing "right" and "left". step 3: tree now prints reversed.
Vim has 4 modes ;)
- Are there any obvious logic errors in the code? - Looking at the requirements, are all cases fully implemented? - Is the code readable and maintainable? - Are the new automated tests sufficient for the new code? Do existing automated tests need to be rewritten to account for changes in the code? - Does the new code conform to existing style guidelines? Ref: https://www.atlassian.com/agile/software-development/code-reviews
No. Please don't do this. Pull in someone who does have a clue and learn from them.
The biggest difference between shortcuts in vim and other editors is composition vs straight memorization. You have to memorize weird shortcuts that don't make a lot of sense with Sublime, Atom, PHP Storm, etc. With vim, however, you only need to memorize a few fundamentals and you can start composing actions together. Example: to delete a method body in phpstorm, you need to `alt`+`shift`+`{` or something weird (I don't recall). However, for vim it's `di{` - `delete` `inside` `{`. This works with anything that has a matching symbol: `'`, `"`, `(`, `[`, you get my point. In any intellij editor, how would you "delete everything inside the quotation marks"? With vim it's `di"`. I can also delete from my cursor position until the next quotation marks with `dt"` - is this even possible in intellij without doing something like ctrl/cmd+right arrow? Delete the current line and the line below: `dj`. Delete the current line and 3 below: `d3j`. Delete the current line and 5 above: `d5k`. How can I do these in intellij without spamming "delete line" 5x or selecting all 5 lines and hitting delete or backspace? The point here is that everything I mentioned here is done by learning fundamentals and composing them together, whereas, if the action I'm giving as an example exists in intellij, you have to memorize an entirely new shortcut for it. This issue is actually what kept me from switching to phpstorm from sublime. I was going to remap the shortcuts to sublime shortcuts, but then I'd have issues whenever people told me the default shortcut they were talking about. It became not worth it.
Really cool but what would some potential use cases be for this?
Call it twice and join the two?
Here, I've submitted my first PR: * [Added a more random array plucker. #1](https://github.com/samuelwilliams/PhraseGenerator/pull/1/files) Right now, I'm writing 100% unit test code coverage.
Go with the one that the creator of php uses and had talks about: https://github.com/phan/phan
for those who recommending psalm and others: these don't measure cyclomatic/npath complexity.
Random username generator (e.g. default name until changed; Xbox love) Use it to name bots in a game Name your next project Give your SO a new nickname
We upgrade the vendor for sure. But every time after upgrading, we have to modify the same thing about for the same bug.
There's a lot of varied answers in here, but PM me if you want to video chat / screenshare sometime and I can walk you through some outside in style testing that should really help clarify the whole ordeal. Alternatively, check out [Growing Object Oriented Software Guided by Tests](https://smile.amazon.com/Growing-Object-Oriented-Software-Guided-Tests/dp/0321503627?sa-no-redirect=1), or if you're into Laravel, [Test Driven Laravel](http://www.testdrivenlaravel.com/) which is a great testing resource that is specifically tailored to Laravel (but you could learn a ton while still using a different framework). It's basically a video form of the book I mentioned using Laravel for the example instead of Java and C#.
I truly appreciate that offer. Iâ€™m still new to the more standard practices of php development, such as using frameworks and composer. I feel as though Iâ€™m not quite ready for unit testing, but I posted here to get a general idea of what it is and how I should go about it.
I was inspired by the Symfony Maker Bundle which generates names for controllers such as "VictoriousGnome". I was thinking along the lines of passwords or even user handles.
You're ready for testing, you just don't realize it yet. If you haven't used a framework yet, I'd suggest the testing framework CodeCeption instead. You can fallback to phpunit with it, and get a lot more testing utilities than having to wire up your own. Honestly, PM me if you want that. I'm more than happy to give you a couple hours screen time to get you started testing.
Naming Ubuntu releases
which one provides cyclomatic/npath complexity figures? :/
https://www.reddit.com/r/PHP/comments/bmzj5r/is_phpmd_dead/en31fj3
https://www.reddit.com/r/PHP/comments/bmzj5r/is_phpmd_dead/en31fj3
Unsurprisingly a conspiracy theorist also!
So a reddit username generator for Russian trolls then? ;)
You might be interested in - http://verraes.net/2013/10/pre-merge-code-reviews/ - http://verraes.net/2016/04/code-reviews-and-blame-culture/
Both rules are overcomed long time ago by cognitive complexity. See: https://www.tomasvotruba.cz/blog/2018/05/21/is-your-code-readable-by-humans-cognitive-complexity-tells-you/
&gt;Random username generator (e.g. default name until changed; Xbox love) Pretty sure this is how I got my username on the Zone, "InsolentCashew"
this is something mostly sonar pushing which is not the best tool for analyzing PHP
Need to ensure uniqueness though.
Pronounceable and memorable unique URLS. Lots of services use these. Like Gfycat. Instead of hosting your gif at [gfycat.com/eF9s8eEne](https://gfycat.com/eF9s8eEne) you get something like: &amp;#x200B; [https://gfycat.com/briefbelatedappaloosa](https://gfycat.com/briefbelatedappaloosa)
You can't really use repositories to completely decouple the Client from the Model with Eloquent. The moment you return your model from the repository, you introduce coupling. Only discipline helps to refrain from using the returned models. Anyhow, still a better way then reimplementing all Eloquent methods in the repository. Repositories in Laravel especially are mosly there to DRY Data Access Logic, not really for decoupling IMO.
Yeah there is some coupling I don't question that, but isn't it quite useful to be able to modify or even entirely swap the data access logic without even touching the controller?
Very nice.. What level of education are you aiming at? Primary, Secondary, university? I know from my time working in the Registrar's office of a large university there are things here that are very much missing.. Namely: * course schedule generation (this is a big deal that needs to balance the desires of professors and needs of students keeping in mind program requirements) * speaking of program requirements... How do you define a bachelor program? How can students measure their progress against it? Great start and it looks great.
It's not sonar, it's psychology and cognitive overload. How the human brain see the code.
phpcs has CyclomaticComplexity and NestingLevel
Cool. I'll make sure to check out the repository from time to time. Found the way you talked about an API implementation really intersting. :-)
It really depends on what your use-case is. There are lots of frameworks with varying benefits.
I enjoyed working with CodeIgniter and CakePhp. didn t really like Zend. Also, WordPress. it s a CMS but I ve used it as a framework with great success for some projects.
Sounds great :)
It's just the type of training he wants to give me. He said how Guzzle is similar to using Postman (is that accurate?) so he asked me to use something similar to PHPUnit instead.
Laravel doesnâ€™t really change anything, it provides a base MVC with a lot of added functionality that you donâ€™t need to use... you can write fairly standard php outside of routing and eloquent. Eloquent is the biggest opinionated feature so yeah I guess if you donâ€™t like that then itâ€™s probably over kill. That being said if you really want to avoid big frameworks just use vanilla PHP alongside composer to pull in packages to handle the parts you donâ€™t want to writ
Not that fond of wordpress but I have unly used it as a CMS. Might try it as more of a framework!
Well yeah, I was more looking for recommendations. As I mentioned in my post I know there are good frameworks depending on what I want. Thanks though!
Check out symfony. It's just a whole bunch of helper classes with some nice wiring tying it all together.
Replacing `&lt;?PHP echo $i; ?&gt;` with `&lt;?= $i ?&gt;` will make things a lot more readable. (not an answer to your problem, but writing clean code makes looking for problems easier)
Maybe take a look at Zend Expressive and learn about middlewares, thaen you basically compose everything your self and pick and choose how you want to do it :) &amp;#x200B; Also symfony, if you take a look at index.php and src/Kernel.php you will see pretty fast how straight forward it is :)
Okey! Thanks
Will do, thanks!
But what do you want? There are hundreds of frameworks and microframeworks all with their own good points and bad points. Any recommendation I or someone else gives would be no more useful than a google search for â€œbest PHP frameworkâ€ without knowing what youâ€™re looking for.
well, I explained in my post what i wanted. Hence why the comments are different that what i would get from a Google search. &gt; Does anyone have any tips on a framework that dosen't change things up much but provides some good functions to use so i don't have to write them myself everytime i build a new APP. This is what i'm looking for, might be poorly worded on my part, sorry if that's the case. Not a native speaker.
Slim, Laravel are a few names one could drop
In short think libraries not frameworks. A (well designed) framework can be viewed as a bunch of libraries composed/glued together. A framework gives ease while libraries gives flexibility. Which is better depends on the person and the project. I'm with you in that I much prefer the freedom and flexibility of using small, purpose made libs for common tasks and vanilla code for the domain specific parts. &amp;#x200B; The 3 basic libraries I almost always need for a typical project that needs a a web api and a persistence layer are: \- A DI container: I use my own ([https://github.com/pwm/sfw-container](https://github.com/pwm/sfw-container)) but there are many others \- Routing: I use my own ([https://github.com/pwm/sfw-router](https://github.com/pwm/sfw-router)) but there are many others \- DB layer: I use Doctrine DBAL ([https://github.com/doctrine/dbal](https://github.com/doctrine/dbal)) but there are many others &amp;#x200B; These will solve the common problems of routing (url to endpoint mapping), composing your app (injecting dependencies) and persisting data into a DB. Depending on the project there can be many other functionalities that you should use libraries for (notifications, work queues, 3rd party client libs, etc...) as well as for the testing/static analysis aspect.
Will check out slim, but as stated. I don't really like Laravel. &gt; I've done some work with Laravel but don't really like it.
I used to code everything myself and even create my own framework. It had routing, a own templating engine with it's own syntax and i tried to create an ORM (which was the hardest part and i realized how much pain coding such a thing can be). However as my requirements rose to higher levels, i figured i should use frameworks that can deal with common pains, such as routing, database calls, entitys, dependency injection, templating etc. Lucky enough, the new company i started working required me to use Symfony and i got to learn all the awesome stuff it will do for you. Routing, DI, templating, http response parsing, automatic database migrations, doctrine integration and big community support were all a big plus that will deal with so much for you. &amp;#x200B; Anyways, i do not regret trying to create my own framework, as it helped me a lot to understand php on a deeper level and also what tasks you are confronted with when creating bigger applications. But now, it is time to move on. Maybe i will present my framework on this sub one day
Awesome explanation! thanks! I haven't really thought of it in that way, but I definitly agree.
I've had the thought's of making my own library since then i can have things how i want them without having to type it out each time. 1 Thing/Reason that i don't want to use any big name frameworks is because i want to make things in vanilla otherwise i feel as if "I'm not making it" and that i can't really code if i just use a framework since i don't understand everything that it's doing. Symphony has been recommended and i'll check it out :)
Codeigniter v3 is very straight forward and very lean and mean.
Check out Symfony and perhaps Silex (IIRC, using Symfony libraries). Symfony is used by a lot of PHP frameworks/libraries - you pick what you need. Check out Silex, even if you're not planning on using it directly.
For now this aims at primary and secondary schools. College or university has a bit different class section, marking system. But most of the features can be implemented in univeristy I think. Unfortunately the features you mentioned are not implemented yet. Besides I can not spend much time sadly because I don't get any earnings from this. I'll try to implement the features in near future. Thanks for your feedback. You can contribute, share to make the software better!
I see a lot of people here using Laravel or Symfony. However, I've never really enjoyed using neither one of them. I find myself getting hung up on how they are set up and how they want me to register for example my events, services and so on. For **years** I went nowhere with my hobby projects due the fact that I never settled down with one of the existing frameworks out there. I finally found a solution that works **really** well for me. Now I have my own "skeleton" (call it framework if you will) that bundles together components in the way I like. Some components I write myself, for example an "EventDispatcher" component, others come from mainly Symfony, Zend and The PHP league. &amp;#x200B; If you, or any other of you find this compelling I **highly** recommend making an attempt to do it yourself this way. I've learned so much from doing this and I've never been so close to finally completing a large hobby project. Wiring up my own "skeleton" / "framework" has taught me **how** Symfony, Laravel and Zend Framework actually works, it has taught me how many of the common components work, and by that I do not mean "how to use them" but actually how they work on a code-level. It has motivated me to really make an effort into making my code better and reusable. I've found many of The PHP League's packages to be easiest to dissect due to the high quality of code and (seemingly to me) effort into make stuff "simple".
How you describe the "Im not making it" part is exactly how I felt before. Funny! Please read my response to the thread, I do really think "my solution" would fit you, if you made an attempt for it!
I find SonarQube the easiest to configure and having the most useful rules, which are really deep and clever. I agree that Cognitive Complexity is better. I prefer php-cs-fixer over PHP Code Sniffer. PHPStan and Psalm are very good too. While SonarQube rule profiles can be exported to be shared all the other tools can be used more easily for open-source / libraries since all config lives in the respective project.
Something less heavy could be Slim/Slow or just piece together some useful dependencies such as: FastRoute or FlightPHP for routing Zend-diactoros is good for PSR7 request response implementation Some ORM such as Doctrine or Eloquent A templating library you like Finally for depency injection I like https://github.com/thephpleague/container Obviously these are my personal preference but you get your own small framework up and running pretty quickly by piecing these together if you'd rather not use a big framework. :)
Try disabling `xdebug.remote_connect_back` (you want it to connect to host.docker.internal either way) and set the `xdebug.remote_log` property to find out where XDebug is trying to connect to.
Is xdebug enabled? Not sure how your underlying container works, but in some cases it's not enough to install the extension, you also have to enable it... Docker exec into the container and check with *php - m* for enabled modules
I have gone into the container and installed xdebug via `apt-get install php-xdebug` manually. So if I run `php -m` I see xdebug there.
How can I read those logs? Is `remote_log` referring to my host machine? (I'm on Windows 10)
I used to feel like you. I don't anymore. I have no idea of your coding "level", so I won't talk about it. --- &gt; 1 Thing/Reason that i don't want to use any big name frameworks is because i want to make things in vanilla otherwise i feel as if "I'm not making it" and that i can't really code if i just use a framework since i don't understand everything that it's doing. *You might be working completely solo in which case it's less true, but still. Replace company by client and what follows should mostly still work* Your company doesn't pay you to write good code. They pay you to create a software product that : 1. create added value by following a spec 2. is maintainable and modifiable, even without you, to align to future requirements. 3. write "good" code (can be very subjective) In that order. For 1, the code used doesn't matter. Throw enough monkey and money at it, it will somehow happens, even in the now dead kohana framework. For 2, your custom solution creates a bus factor, and raises maintenance costs for the company. If you use symfony, any guy knowing it will hit the ground running, having to learn only the specifics of this project business rules. And even like that it's often not that easy. If you use a custom solution (except in very specific ultra specialised project) it doesn't look good. If you leave your job/are replaced, 75+% chances the next dev will curse your custom stack. Does it means he doesn't know how to code vanilla php ? No. Only that he'll thinks he shouldn't have to learn a new stack yet again when, while it might not be exactly the way *you* wanted it, any of the big framework would have worked too. I also hope there is very good public and up to date docs for your packages. For 3, the company doesn't really care tbh. It's mostly for dev happiness and a byproduct of maintainable code. --- &gt; i feel as if "I'm not making it" and that i can't really code if i just use a framework since i don't understand everything that it's doing I used to think like that when i started. But it's IMO a short sighted view of the world, and really, it was also a way to justify not having to learn. Abstractions are not by default the ennemy. I don't have the hubris to think I can do a better multipurpose framewok/collection of library than the sum of the last 20 years of php devs. If I don't understand why a framework do something a certain way, they aren't stupid, it's usually that I don't have a problem they already dealt with. You don't want to use a framework/library you don't understand. But PHP might be also considered a framework/library based on C. Do you know how PHP integrates in C under the hood ? Then are you a real dev if you don't code in C ? Do you know the http/ssl protocole rfc's by heart ? How apache/nginx are coded ? How all the browsers really work ? Do you use your own linux kernel on your servers ? Hell, roll your own crypto, it will be safer, because you'll understand how it works, right ? (**DON'T**) I'm obviously taking the piss. It isn't limited to software engineering.
It wants a file path, which can be in a mounted volume in your docker container so you can access it from windows.
I set it like this: `xdebug.remote_log = /app/xdebug.log`, but the file xdebug.log isn't appearing in my mounted /app folder
You cray
Talk about stuff you wanted to be hear when you were a junior.
What about when you run PHP command line in the container with xdebug enabled? It doesn't get created? Are you sure your PHP configuration is being used?
I too tried doing something, doing a generic DDD library on top of a microservice message queue. Too large, sadly didn't finish. Symfony components (not the framework) is my alternative, and any library that integrates with composer. Not a popular opinion but Drupal 8 is a good alternative too. Deep learning curve, but Entity and Fields API + user access role API + Symfony components is a nice skeleton for a project. Their theme suggestion approach and mostly procedural hooks are some of the cons but you'll get used to it, and also Blocks without proper organization is kinda messy.
I understand what you're saying, and i AGREE. To explain why think/said what i think/said: Currently i'm learning a lot with programing. So i want to learn how things are done and how it works before useing a framework that does everything, because if i don't understand i feel like i can't utlizise the framework to it's fullest potentional. &gt; For 1, the code used doesn't matter. Throw enough monkey and money at it, it will somehow happens, even in the now dead kohana framework. 100% True! Though i want to make good code so that I know what i'm doing and aren't just someone copy pasting stuff from google to get things to work. I have worked at a company that required me to use Laravel, so i used it, didn't like it, but i got some stuff done even though i didn't really understand what i did, and i HATED that feeling. Just made me feel like a "wannabe programmer" that dosen't really know what i'm doing. And since i'm so early into my career (Just 20, still learning loads) i want to learn things correctly so i get a good base for my career.
I'm actually not sure if the `99-php-ini-overrides.ini` is being used and I'm not sure how to confirm that. After doing the change you suggested on your first comment, I get this when turning on the debugger in VSCode: &lt;- launchResponse Response { seq: 0, type: 'response', request_seq: 2, command: 'launch', success: true }
Slim is great. It is what I use for basically everything these days. It is really fantastic when combined with PHP-DI and Doctrine.
I'm not familiar with VSCode, is there a break at first line option so you know the connection is working? Then it might be path mappings (xdebug knows the file as /app/file.php, your local filesystem would probably be something like C:\\Path\\file.php. You need path mappings to translate them)
I was also someone who wrote most of the stuff myself. I did take a test with laravel and build "a common" app with it (lots of crud and stuff). For me, it was way too much magic for my taste. Then i took a look at symfony, build also "a common" app with it. What can i say, i am amazed. My productivity went up massivly. There is not much magic involved (the DIC comes to mind, but the code for it is not that complicated). Comparing ORMs, for me Doctrine &gt;&gt;&gt; Eloquent. TL;DR: build a basic app with symfony and you will love it. Their documentation is excellent, their slack is super helpful
check &gt;/etc/php/${PHP\_VERSION}/fpm/conf.d/99-overrides.ini is it mounted correctly?
Symfony is a really high quality framework that gives you a lot of control over how you use it. You can use it as a "highly opinionated" framework and do things the Symfony way, or you can just use Symfony components as standalone libraries/helpers and use them in the way that best matches your own preferences. It's really flexible and full of good stuff.
I thought silex was dropped in favor of the latest Symfony?
Yes, the file appears there within the container and has the proper contents.
I added this to `launch.json`: `"stopOnEntry": true,`. It didn't break again.
Symfony! It forces you to write clean code and you will learn a lot when reading internal code. It took ideas from Java and Spring FW but added gazillion other features on top. Use PHPStorm with Symfony plugin; it will help you with autocomplete in Twig files, options in form classes and very rare cases when you need to reference service by name. Skip the security section, just install FOSUserBundle and let it handle stuff for you; it is not worth reinventing the wheel. To fasten learning, install phpstan and set it to *max-level*.
Alright, the check php -i if your settings get applied like in the config. If they are you have a problem on your host. host.docker.internal is only valid since 18.03. Check your docker-engline version. Also restart your container every time you change the config.
Ha! You're right! From `php -i`: `xdebug.remote_enable =&gt; Off =&gt; Off` and the other settings aren't overridden either. Why isn't my `99-overrides.ini` taking effect?
&gt; has the most useful rules, which are really deep and clever Psalm: yes. sonar-php only has some cosmetic, no-brainer rules and afaik it cannot be extended anymore
which other (than sonar) tools has cognitive complexity metrics?
When frameworks were first mentioned to me, I thought "why would I want to learn this, I'll never make anything that complicated?", which has remained mostly true. Since then, I've learned only a little Laravel, again, enough to make my little projects work, more or less. Why? It's a common point of reference. If I need or want someone to review my code, it's comparitively easy for them to download the repo, check the routes and immediately know where to start looking. Same, even more so, if I find an opensource project I want to use or contribute to. If it's Laravel based, I can pretty quickly clone it, deploy it, and start mucking around in it. If it's a home grown project, that's a whole other story. If you're lucky it's all procedural and you just load that pages code into an editor. If you're not, then you have to learn everything the previous dev did, in the way they did it. Frameworks really put everyone at the same point of reference. It's like sheet music for musicians. A good musician can listen to another one playing and reproduce it. But if you're not able to hear it being played, the best and only way to transmit that knowledge reliably from musician to musician to musician is through sheet music. Imagine if every musician created their own method of notating this? (The musician analogy is kind of lifted from Wayne Kramer, I take no credit.)
I am out of the loop :) &amp;#x200B; &gt; Symfony 4 feels like using Silex From [https://symfony.com/blog/the-end-of-silex](https://symfony.com/blog/the-end-of-silex) &amp;#x200B; Which means that Symfony 4 allows you to stay truly minimal even easier than before, which is a good thing IMO.
You mentioned Slim/Slow. I use Slim a lot, but haven't heard of slow. Google isn't very helpful in this... Can you give a link?
have a look at the file rights (ls -alh /etc/php/${PHP\_VERSION}/fpm/conf.d/99-overrides.ini) should be at lease readable for everyone
I feel the same way where sometimes it just seems silly to not really know whatâ€™s happening behind the scenes or just shrug and say â€œwell it works so...â€ but also I donâ€™t want to re-invent the wheel or keep writing the same code over and over. Many frameworks are also overkill for most projects. I like to start small and simple as building out your features already complicates things enough. If your app/website/SAAS/whatever happens to get super popular, well then you can probably rewrite it with something else that makes more sense. Most of the time a simple skeleton of code to kick start the project is all thatâ€™s needed. When I started a personal project many years ago (https://trackreel.com) I needed something that was setup for basic MVC, had built in ability for user registration (why do all the frameworks need extra modules and installation steps for something that almost every site needs?) , was safe and secure and not over complicated. I found all of that and more in https://github.com/panique/huge/ It is considered â€œsoft end of lifeâ€ meaning there will not be any new features added but it is maintained for security and bug fixes and vendors/3rd party libraries are kept up to date. For me it provides what I need. I still need to write functions in my controllers and almost raw sql queries in my models (there are functions to open database connections and such but the query itself is raw; none of this query-&gt;join(inner)-&gt;table(users)-&gt;secondTable(playlists)-&gt;key(id)-&gt;foreignKey(playlist_id) craziness). I still had to build a few features I wanted to have but were not implemented out of the box, but in doing so I kept my own fork of it up to date and now have a good base I am comfortable working with. It also helps that the only project I currently use it for is my own project, something I donâ€™t plan on really ever having anyone else work on. Perhaps this is a halfway solution, where you have something solid to start with, something you donâ€™t have to worry about user passwords or security. But something you can make your own and feel good about. Some of the other comments about future devs not needing to have a learning curve or cursing you for using your own framework are still valid, BUT I do feel that this is pretty straightforward (due to its inherent simplicity) and what I would call â€œvanilla phpâ€. There are no super magic functions called in arbitrary ways, all the code is readable and can be found where youâ€™d expect it to be found. There is always a learning curve but I think itâ€™s minimal with a solution like this. But hey, we all have our own opinions, our own preferences, and this works for me while it might not work for someone else. Iâ€™d love to hear others opinions on this approach!
I have coded a CMS / framework / Twig++ template language which is optimized (RAD, ORM, MVC) for creating web applications: &amp;#x200B; [https://php-ucms.com/features/](https://php-ucms.com/features/) &amp;#x200B; It is not suitable for PHP beginners!! But it's perfect for anyone who has ever worked with Twig. I guarantee that everyone who takes the time to read through the features, as well as the whole technical documentation, will find a lot of things that are really new and make your life as developer easier. Unfortunately I can not make it available for free at the moment, the development costs my company had were just to high, please do not scold me for that. But it will be open source in the future. Please have a look at it.
I understand the feeling, but it's not a productive/efficient mindset if left alone like so. &gt; because if i don't understand i feel like i can't utlizise the framework to it's fullest potentional. There is a difference between knowing how to use your tools and knowing how they are made/work under the hood. Ever used a hammer ? You don't need much to know how to nail things. But do you know how the length/shape/weight of your current hammer was chosen by an engineer somewhere ? Or how to make the calculations ? I don't. The best thing you can do for any tool is RTFMN front to back, even if you won't be able to write code without reopening it. Why ? Because that way, when you'll have a problem to solve, you'll remember you've read something somewhere on that doc page about it. Hell, I even RTFMN of tools I don't use, just to get an idea of what is possible. And more often than not a few months later, it gives me insight, even if I don't use that library, because I'll have some vernacular or way to think about the problem that helps. The deep understanding comes from experience and practice. --- &gt; And since i'm so early into my career (Just 20, still learning loads) i want to learn things correctly so i get a good base for my career. The best thing you can do this early in your carrer is diversify the project types, tools AND LANGUAGES. The best thing that happened to me was having to create a parser/lexer in [Clojure](https://learnxinyminutes.com/docs/clojure/) (lisp, functionnal programing) for uni. I never coded anything else in Clojure since, but it expanded my horizon and allowed me to solve problems in ways I wouldn't have without. You'll also lean a lot by doing projects in competiting tools. Do a project in Symfony, another in Laravel and you'll know more than if you do both in one. You will have your comfort/work picks though, and that's okay. But don't be too complacent, or you get irrelevant if your stack become irrelevant itself. My dad had 20+ database architects/engineers working for him. None of my dev friends has a colleague fitting that job title. --- Another carrer advice, your social skills often have as much or more bearing to your promotion than your programming skills... I'm not telling you to become that dev who spend 80% of his time sucking up to higher ups that everyone else hates, but at least be competent at explaining a problem in non technical terms. Trying to explain your work to your mom and dad is a good training exercise \^\^ --- &gt; i didn't really understand what i did, and i HATED that feeling &gt; someone copy pasting stuff from google to get things to work It will never completely go away, unless you do the very same kind of project over and over again. Practice your googlefu, and be prepare to learn your whole carrer. Half-jokingly, do you know the difference between an engineer and a technician ? The engineer is taught to be adaptable to what you throw at him, while the technician is specialized to a specific set of tools and processes. Which is why, while the engineer is often paid more, you should always listen to the technician, as he as more than two weeks and a book of experience...
is it 2006 all over again?
Ok it's hard too match but i guess some useful rules from MD are not in SQ. I would not say that SQ is only cosmetic tough. * [BooleanArgumentFlag](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.CleanCode.BooleanArgumentFlag.html) \- i can have no boolean arguments? * [ElseExpression](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.CleanCode.ElseExpression.html) \- i cannot find in SQ, which checks for nesting depth (not cosmetic) but allows else in general * [DepthOfInheritance](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.Design.DepthOfInheritance.html) \- i cannot find in SQ, good but i can't imagine having that problem often. * [NumberOfChildren](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.Design.NumberOfChildren.html) \- i cannot find in SQ, same as above probably encountered more often All of the "too many" Lines/Methods/Members per Class/Method rules should be in SQ. Also [ExitExpression](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.Design.ExitExpression.html), [DevelopmentCodeFragment](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.Design.DevelopmentCodeFragment.html) for commented out code. Even [CouplingBetweenObjects](http://apigen.juzna.cz/doc/phpmd/phpmd/class-PHPMD.Rule.Design.CouplingBetweenObjects.html) is there: [https://rules.sonarsource.com/php/RSPEC-1200](https://rules.sonarsource.com/php/RSPEC-1200) Any well explained rule is "well duh"... so i don't know how we settle that. All i can is describe how i felt when i removed MD from Jenkins to go solely with SQ at work - it helped more. It's open source rules are extendable. You need to know a little Java tough [https://github.com/SonarSource/sonar-php](https://github.com/SonarSource/sonar-php) So maybe we should start a mapping list of rules and find out which ones are missing from SQ?
Any cognitive-informatic university program
I absolute love the effort you put into this and appreciate it loads! as mentioned i'm still early into programming and i've tried different frameworks and language (PHP, javascript (Node.js) Python, C#) though PHP stuck for me as i enjoy webdev way more than any other. I still don't know alot about programming if i put it like so, i can do things in PHP. and i've done some semi-complex APP's in PHP. But there is LOADS i have no clue about. I've tried learning OOP but i just can't see any way it would be better for me than procedrual. But mostly it's because i don't fully understand OOP. I took 2 courses in gymnasium (Swedish thing, inbetween high school &amp; collage) on webdev but i didn't learn much as those were "basic" courses and by then i already knew js, html &amp; css, almost everything i know is self though but i don't know that much. Either way, enough of my rambling, i appreciate your effort and i will keep everything in mind! Thanks loads for your tips! Didn't think i'd get these awesome tips from this kind of a post haha
Hey, Exanero, just a quick heads-up: **alot** is actually spelled **a lot**. You can remember it by **it is one lot, 'a lot'**. Have a nice day! ^^^^The ^^^^parent ^^^^commenter ^^^^can ^^^^reply ^^^^with ^^^^'delete' ^^^^to ^^^^delete ^^^^this ^^^^comment.
I have solved the "PHP's white screen of death" problem some years ago: &amp;#x200B; [https://stackoverflow.com/questions/1475297/phps-white-screen-of-death/18208549#18208549](https://stackoverflow.com/questions/1475297/phps-white-screen-of-death/18208549#18208549)
This is what I have: `-rwxr-xr-x` and no matter how much I use `chmod` on that file, it wont change?
good bot (even though i knew it just forget about it all the time)
Sorry I meant Silex my phone just autocorrected, apologies for this.
Alright. Rights seem ok. Check php -i which files get loaded. if 99-overrides.ini is in there, something else overrides your ini. I had another look on your docker-compose file and it seems like, that you can set xdebug-configs from there too: environment: - XDEBUG\_CONFIG=remote\_host=host.docker.internal Maybe the default values override the settings from your .ini Try to convert your ini values to environment values and test again.
Then I'd have some doubts that your config is actually being loaded. You could try running PHP in the CLI, like: `php -dxdebug.remote_enable=1 -dxdebug.remote_autostart=On -dxdebug.idekey=VSCODE -dxdebug.remote_host=host.docker.internal file.php`
&gt; I've tried learning OOP but i just can't see any way it would be better for me than procedrual. But mostly it's because i don't fully understand OOP. In which case, do some more projects. Object orientation literally clicked for me 6 months after my java classes in the shower ...
I can't see the `99-overrides.ini` at all in `php -i` ! I could try setting those values in the env variable though.
Mind putting short description with your post?
Is this a joke? A revolutionary joke?
looks like dockerio moved the php-fpm files to **phpdocker**/**php-fpm**/ try changing - ./php-fpm/php-ini-overrides.ini:/etc/php/${PHP_VERSION}/fpm/conf.d/99-overrides.ini to - ./php-fpm/php-ini-overrides.ini:/phpdocker/php-fpm//99-overrides.ini
Actually `99-overrides.ini` is getting loaded, but running `php -i` doesn't help as this shows the info loaded in PHP CLI, not FPM. I did a `phpinfo()` call in `/app` and there it shows that the `99-overrides.ini` file is loaded.
I understand wanting to understand everything that you build. But as you progress in your career, so much of development involve working in teams and understanding other people's code and contributing efficiently. Especially if you are working on a software that will be several years old. You can't be always looking to develop something new. I suggest trying a different approach. Pick a mature framework and work with it. Learn it's nuances and quirks. Peek under the hood and try to understand how they are implemented. These skills are more helpful than building everything from scratch according to what you like
Looks good!
It works with this command! I did `php -dxdebug.remote_enable=1 -dxdebug.remote_autostart=On -dxdebug.idekey=VSCODE -dxdebug.remote_host=host.docker.internal /app/public/index.php` ... That's where my Laravel app lives. How do I get this to work without this command though?
&gt;I still don't know alot about programming if i put it like so, i can do things in PHP. and i've done some semi-complex APP's in PHP. But there is LOADS i have no clue about. I've tried learning OOP but i just can't see any way it would be better for me than procedrual. But mostly it's because i don't fully understand OOP. That alone is a good reason to start using a framework. Let's say you are using the framework to save file upload. A good framework has really good abstraction and interfaces where you can switch between saving locally on the server or into an S3 bucket. Observe and take a look on how the framework implemented this and you can see and notice the OOP pattern and why it is good.
&gt;That's all you have to do to add a new feature to your application. And that's why development time is reduced dramatically. Show me any other system that is so simple. ```php // controller /** * @Route("pdf-example/Hello.pdf", methods={"GET", "HEAD"}, name="pdf_example") */ public function anyNameIWant(SomeXml2PdfGeneratorService $pdfGenerator): PdfResponse { $xml = $this-&gt;renderView('example.twig'); $pdf = pdfGenerator-&gt;convertXml2Pdf($xml); return new PdfResponse($pdf, 'hello.pdf'); } ``` ```php // reusable response class for all PDF files class PdfResponse extends Response { public function __construct($content, $filename) { parent::__construct($content); $this-&gt;headers-&gt;set('Content-Type', 'application/pdf'); // other headers } } ``` But sure, your solution is better :)
Still no PHPStorm support ðŸ˜­
You will need to figure out why your ini file is not being loaded. Should it automatically load everything in the `conf.d` ?
Wow I need to try this Zymfony stuff. Does anyone know how to convert an existing ZF1 project to Composer ?
Unpopular opinion here. CodeIgniter, it gives you freedom.
Will give it look!
I built the entire codebase from the ground up and plan the projects for engineers, pretty sure I have a passing understanding of what the person is writing, though I may have to ask about specific portions of the code to get a better grip...
You can add any git repo to your composer.json
Frameworks are an acquired taste like beer, wine, and liquor. You could start with something simple like SlimPHP or CodeIgniter before moving into a more kitchen sink framework like Laravel or Symphony. I've been using CakePHP for about 8 years now and really like it, but at first I thought it was a hindrance to productivity. That's just called learning curve and over time you acquire that taste, and realize productivity and code structure gains. My only recommendation is when you do find a framework you like is to NOT become a zealot about it. I use X so X is best just makes you look provincial.
Symfony is a framework, but itâ€™s also a collection of independent components. Since youâ€™re used to make all your components yourself, Iâ€™d suggest to take a look at each Symfony component and adopt the ones you like.
Feel free to take a look at my framework. It's designed to be able to integrate other libraries pretty easily through robust configuration and a simple delegate interface that constructs classes. The bootstrap package (a meta package for many others) provides a lot of functionality out of the box. Docs are not 100% complete, but there's a fair amount there: [https://hiraeth.dev/docs/](https://hiraeth.dev/docs/)
Yeah but the project I (sadly) inherited has an outdated version of ZF1, without any composer.json whatsoever. I don't even know exactly what version of ZF, Doctrine, or any other stuff is installed. I need to convert all of that to a functionnal composer.json installation in order to use Zymfony :/
as some said, it depends on the situation/project. for me it made sense to use wp because the client was very used to the backend
I've always been partial to [Flight](https://github.com/mikecao/flight). The database toolkit from the same author (mikecao) is also really nice: [Sparrow](https://github.com/mikecao/sparrow).
The `fn()` syntax for arrow functions has actually grown on me during all of the discussion. Fast code reading relies on the brain detecting patterns without having to actually consciously parse. So it will likely make scanning and understanding code that little bit simpler. It's the same reason `xx xxxxxx xxxxxxx xxxxxx xxxxxxx` means very little, but the in following format is much more recognisably an if/else. xx xxxxxx xxxxxxx xxxx xxxxxx xxxxxxx I only hope we get multi-statement bodies sooner rather than later, before I see that awful `array_slice()` hack start showing up in production code.
1.) There exists no "SomeXml2PdfGeneratorService" because nobody except me has coded such a logic wrapper for the FPDF (tFPDF) class yet. And without such a wrapper you have to use pure PHP code which is super complicated and hard/impossible to maintain. So I would say that the AwesomePdfGenerator class of the UCMS is revolutionary - along with many other features :) &amp;#x200B; Or can you provide a link to a alternate class? MPDF does not count, because it converts HTML Code to PDF, which is not pixel accurate. &amp;#x200B; 2.) A big disadvantage of symfony are these @route tags, that is bad design, really! Why? Because you spread your business logic over many .php files. You also mix business logic and PHP code. This is just as bad as mixing HTML code and PHP code. &amp;#x200B; I know symfony also allow to define routes in a different way where you need to write a lot of php code. Thats also a bad solution because it is complicated. &amp;#x200B; UCMS introduce a new structure, a site tree, which is saved in an .ini file (or .json, or MySQL database). You can think of it like the tree view in your windows explorer. Each node in the tree is a URL of your website. The big advantage here is that you can maintain the whole business logic in a simple textfile. Advanced developers will love it to modify the business logic super easy, and beginners can use a admin GUI to modify the business logic. Maybe I should add some screenshots of the admin panel to the ucms website. &amp;#x200B; With this new structure, you can manage your website super easy, same like files and folders in windows explorer. In UCMS you have a real treeview where each node has a url, a owner a group, access permissions and more. The urls of all sites can also displayed as a treeview. And you can use the tree to generate navigations in your templates, in a very cool, super simple way. But you have to read the whole website to understand this... &amp;#x200B; Such things are almost impossible with symfony. Or, maybe possibe \*somehow\* but super complicated. &amp;#x200B; Look at Example 2 at this page: &amp;#x200B; [https://php-ucms.com/docs/Controllers/CustomControllers/](https://php-ucms.com/docs/Controllers/CustomControllers/) &amp;#x200B; Also read this to understand the site tree: [https://php-ucms.com/docs/Models/Site/](https://php-ucms.com/docs/Models/Site/) [https://php-ucms.com/docs/Adapters/Sites/](https://php-ucms.com/docs/Adapters/Sites/) &amp;#x200B; Thanks to this site tree structure you can create a Generic Controller and reuse it for every page where no POST data need to be processed. This works because each site (tree node) has a controller and a template property. In that way you can reuse a controller but render a different template. &amp;#x200B; Please read the features page and the docs completely. I guarantee you will find new and alternative solutions for many things. UCMS tries to simplify your life as a developer...
The new Twig++ is a completely new JavaScript-like programming language with turing completeness. &amp;#x200B; From the total number of people who have ever lived (\~100 billion) less than 100 people ever created such a powerful programming language. Nobody created such a language for templates. If nobody ever did it before, it must be revolutionary. &amp;#x200B; A simple case of deductive logic :)
Have you tried using the PHPStorm language server plugin with Psalm? There's some [guidelines on the Psalm repk](https://github.com/vimeo/psalm/blob/master/docs/language_server.md).
Oh cool, didn't know about it
The [documentation](https://framework.zend.com/manual/2.1/en/migration/zf1_zf2_parallel.html) for running Zend 1 alongside Zend 2 might help you out, as it explains how to pull in ZF1 components through Composer. There is a `zendframework/zendframework1` package.
&gt;Please read the features page and the docs completely. I guarantee you will find new and alternative solutions for many things. UCMS tries to simplify your life as a developer... Oh trust me, I read the docs before my first comment. &amp;#x200B; &gt;I know symfony also allow to define routes in a different way No, you don't know Symfony at all. My dummy example is less than 1% of what Symfony offers. &amp;#x200B; &gt;A big disadvantage of symfony are these @route tags, that is bad design, really! Why? Because you spread your business logic over many .php files No, it means my route is **only** in one file, you have seen it. I have no idea where you came up with multiple files idea. Your "framework" example requires 2 files. &amp;#x200B; &gt; The big advantage here is that you can maintain the whole business logic in a simple textfile Symfony has compiled container. I am not going to explain why it is so bad-ass, but there is absolutely no way **any** dynamic solution can beat it: [https://blog.blackfire.io/php-7-performance-improvements-packed-arrays.html](https://blog.blackfire.io/php-7-performance-improvements-packed-arrays.html) ; speed improvements are literally part of language. &amp;#x200B; &gt; There exists no "SomeXml2PdfGeneratorService" because nobody except me has coded such a logic wrapper Another revolutionary joke? I mean, you can't be serious, right? &amp;#x200B; &gt; **Advanced developers** will love it I don't think it means what you think it means. &amp;#x200B; &gt;Look at Example 2 at this page: You can't be serious. Right? &amp;#x200B; &amp;#x200B; You know, the funniest thing here is what you call ORM (which it isn't). Someone called you to look for Dunning-Kruger effect and you still failed to understand it. &amp;#x200B; Sorry dude, but this is really bad. I mean, really, really bad. I get that it is cool to try to invent something noone else did, been at that road long-time ago, until I started working with Symfony. Just 2 weeks later I figured there are **far** better developers than me. And also understood why my custom FW was a piece of shit when compared to real FW. &amp;#x200B; So I got bitch-slapped but I didn't get offended. Instead, I dedicated 2-3 months of extensive learning of Symfony (version 2 at that moment). The more I learnt, the more I figured how wrong I was. &amp;#x200B; 7 years later and I still don't know everything. My own Dunning-Kruger has been cured; all I need was the slap of reality.
You missed the point. Like... 100% missed the point, which ironically, makes it revolutionary.
https://www.patreon.com/posts/are-you-on-zend-26564268
&gt;https://php-ucms.com/docs/Adapters/Sites/ &amp;#x200B; Oh my fucking godly spaghetti monster; you **literally** re-invented [brain-fuck language](https://en.wikipedia.org/wiki/Brainfuck) :) &amp;#x200B; \`\`\`twig {%- set invoice = customer.getInvoice( arguments.invoice\_id ) \-%} &amp;#x200B; {%- addtag xml2pdf as function( xml ) { return new \\Ucms\\Lib\\AwesomePdfGenerator\\PDF( xml ).getContent() } \-%} &amp;#x200B; {%- context 'Views.AppName.Customer.Invoice.Pdf' -%} {%- xml2pdf -%} {%- autoescape 'xml' -%} &amp;#x200B; &lt;?xml version="1.0" encoding="UTF-8" standalone="yes" ?&gt; &amp;#x200B; &lt;pdf orientation = "portrait" unit = "mm" size = "A4" title = "Invoice" \&gt; &lt;addfont family = "Ubuntu Light" regular-font = "Ubuntu-L.ttf" /&gt; &amp;#x200B; &lt;body&gt; &amp;#x200B; &lt;p&gt; {%- translate -%}Invoice {{ invoice.formatInvoiceId() }}{%- endtranslate -%} &lt;/p&gt; &amp;#x200B; &lt;/body&gt; &amp;#x200B; &lt;/pdf&gt; {%- endautoescape -%} {%- endxml2pdf -%} {%- endcontext -%} &amp;#x200B; {%- header 'Content-Type: application/pdf' -%} {%- header 'Content-Disposition: inline; filename="Invoice ' \~ invoice.formatInvoiceId() \~ '.pdf"' -%} \`\`\`
&gt;CodeIgniter, it gives you freedom. Because Symfony puts you in handcuffs and forces you into weird sexual acts? &amp;#x200B; Asking for a friend :)
As someone who works in an environment that code reviews heavily and am regularly on both ends of the review process on a daily basis, the best advice I can give you is to \*by default, use an an inquisitive tone\* instead of a declarative/imperative tone. Ex: &amp;#x200B; BAD: "This will throw if the entity cannot be saved." BETTER: "What happens if the entity cannot be saved here? Won't it throw an exception that isn't caught?" &amp;#x200B; It seems silly to do this especially if you \*know\* in the example above that it will throw, but asking instead makes the author a lot more receptive to the critique. I can't explain it other than we all have very fragile egos when it comes to our code whether we like to admit it or not. &amp;#x200B; Also if someone submits genuinely bad code it's ok to give an honest, harsh critique, but I've found that if you attempt to preface with something positive, it's better received. If you can't think of anything positive, you can always go with something generic like "I like where you're going with this, but there are some serious problems that we need to address." or something to that effect.
Here you go: * https://github.com/phpexpertsinc/docker-php-stack/blob/master/laravel-debug/xdebug.conf * https://github.com/phpexpertsinc/docker-php-stack/blob/master/laravel-debug/Dockerfile Or you could just use my Laravel Quickstart (`cp -avf laravel_quickstart/docker laravel_quickstart/bin .` and you're done.) https://github.com/phpexpertsinc/laravel_quickstart See the full 3 minute installation demo: https://vimeo.com/254289186
You know this is my biggest fear, coming off as berating and putting them down.
I started with Code Igniter myself. It enforces a barebones MVC approach and provides some helpers (if you want them). Its ORM is as close to SQL as you can get while still being an ORM. I eventually found myself coding in features that were missing from CI2 and thats when I started doing more with a kitchen sink framework like CakePHP.
&gt;Oh trust me, I read the docs before my first comment. I trust my apache log files, and it tells me that nobody read the docs completely until now. &amp;#x200B; &gt;No, you don't know Symfony at all. My dummy example is less than 1% of what Symfony offers. I know that Symfony offers a lot. But tags in a controller are just bad design, period. &amp;#x200B; &gt;No, it means my route is **only** in one file, you have seen it. I have no idea where you came up with multiple files idea. Your "framework" example requires 2 files. Most web applications consists of many controllers/templates, and not only one. If you use tags in these controllers, it is impossible to centrally manage the application. Even more, you have to monitor all the controllers for changes. This have a processing cost and slows down your application. &amp;#x200B; &gt;Symfony has compiled container.... UCMS caches the whole site tree structure. How this is done depends on the cache adapter (APCU, File, ...). Only one file needs to be monitored for changes: sites.ini In that way the kernel boots super fast. &amp;#x200B; &gt;Another revolutionary joke? I mean, you can't be serious, right? I mean it very damn serious! Fact is, you can not provide a solution which is able to create pixel accurate pdf files in such a simple way (even with symfony). So who is serious and who is not? &amp;#x200B; &gt;You know, the funniest thing here is what you call ORM (which it isn't). Read: [https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it/1279678#1279678](https://stackoverflow.com/questions/1279613/what-is-an-orm-and-where-can-i-learn-more-about-it/1279678#1279678) &amp;#x200B; This is exactly what you can see in the examples. Why do you believe that it is not ORM? &amp;#x200B; I am programming PHP since the beginning, which means more than 20 years. Twig++ is real and revolutionary, no matter how many haters have voted me down!
You can also create a template that only contains the xml part. In that case the rest must be done in the controller. I have created different pdf examples to show all possible solutions, and not only one. Benefit of this solution is that it will work with a generic controller which has only a renderFile() statement. &amp;#x200B; This example also explains that it is possible to add a xml2pdf tag and to use header tags. &amp;#x200B; Following your logic, HTML + JavaScript would be spaghetti code :) &amp;#x200B; The truth is, JavaScript has made HTML more dynamic. And the script-ability of Twig++ makes templates more dynamic. This is an evolutionary process. &amp;#x200B; You take the blue pillâ€”the story ends, you wake up in your bed and believe whatever you want to believe. You take the red pillâ€”you stay in Wonderland, and I show you how deep the rabbit hole goes. Remember: all I'm offering is the truth. Nothing more.
&gt;I trust my apache log files, and it tells me that nobody read the docs completely until now. Your logs are lying, I **really** read the docs. Not every page, but more than enough. &amp;#x200B; &gt;I know that Symfony offers a lot. But tags in a controller are just bad design, period. What tags? The topic was about routing, it has **nothing** to do with tags. **Literally** nothing. &amp;#x200B; &gt;If you use tags in these controllers, Please stop using words you don't understand. &amp;#x200B; &gt;This have a processing cost and slows down your application Symfony has fastest router in PHP: [https://symfony.com/blog/new-in-symfony-4-1-fastest-php-router](https://symfony.com/blog/new-in-symfony-4-1-fastest-php-router) &amp;#x200B; It is even faster than one made by one of gods themselves; Nikita Popov. Read the article. Then learn why it is so. &amp;#x200B; &gt;UCMS caches the whole site tree structure. How this is done depends on the cache adapter (APCU, File, ... No, no, no... **any** parsing requires CPU cycles. Compiled container doesn't. Google for that, it is simple concept used for long time; pretty sure Symfony didn't invent it, only improved it (like validation, adapter pattern etc). &amp;#x200B; &gt;I am programming PHP since the beginning, which means more than 20 years Michael Jordan trained basketball for about 9-10 years before he joined NBA. According to your logic, everyone who trains basketball for 9-10 years will become NBA player. But that's not the case, right? &amp;#x200B; Most people suck at their job, years of doing things right of wrong only means they are doing things right or wrong; time is **100%** **irrelevant**. If they are bad, they are bad; my car mechanic has 25+ years experience and he fucked-up my brakes. Yep; totally wasted money on my side. &amp;#x200B; The moment you mentioned years of using something, irrelevant of what, is a good signal you are not good in that job and only use same excuse my mechanic did. Get over it. &amp;#x200B; &gt;Twig++ is real and revolutionary, no matter how many haters have voted me down! Maybe because... I don't know... there is a possibility there are people who know better? Listen... I know the feeling, and honestly, the idea does sound cool. &amp;#x200B; But 15 years ago, not now. &amp;#x200B; Now we have static analysis tools, real DI frameworks that can work just like Java (i.e. no FPM). I have apps that run under 20ms under Swoole; real-life apps, I don't make websites. &amp;#x200B; We have fucking-**amazing** ORM called Doctrine. Yes, real ORM with identity-map pattern, something real apps can't work without it unless having tons of shitty code. &amp;#x200B; Do you honestly think you are better than them? Think for a second, then reply.
I am a German native speaker. &amp;#x200B; Just the fact that the new Twig++ template language is parsed by a single regular expression is revolutionary! From the total number of people who have ever lived (\~100 billion) only one did that: Me :)
&gt;In that case the rest must be done in the controller &amp;#x200B; So... my controller has 3 lines, 100% can pass static analysis. &amp;#x200B; Your code has about 20-30 lines, 0% chance of static analysis... but somehow it is better? &amp;#x200B; &gt;You take the blue pillâ€”the story ends, you wake up in your bed and believe whatever you want to believe. You take the red pillâ€”you stay in Wonderland, and I show you how deep the rabbit hole goes. Remember: all I'm offering is the truth. Nothing more. &amp;#x200B; Oh man, I love you. I kid you not, you are now my number-one reddit user!
Iâ€™ve used cakePHP a number of times for fairly large projects. Itâ€™s pretty good for rapid development.
Yes, it is revolutionary. You know why; because it is wrong! And there is very good reason why noone uses machines for translations; they are still bad at it. &amp;#x200B; Making google-based translations in Symfony is only 2 PHP files (about 60 lines combined in strict files and all PSR stuff). And those translations are cached into static PHP arrays (so no performance problems ever). &amp;#x200B; But it is shit, it makes no sense. My solution is DB based and admin can use RMB to edit them: [https://imgur.com/a/QEoHLTz](https://imgur.com/a/QEoHLTz) Ignore the colors, I am using some buggy Linux app. But admin can edit label, placeholder (when applicable) and tooltip with a simple RMB, edit those values that are saved to DB with 0% influence on performance, no matter the rules (like params). &amp;#x200B; Oh... did I forget to say that except from including my bundle, programmer doesn't make a **single** change it code? &amp;#x200B; That is because of service-decorators, but let me guess: you made better, revolutionary version of it? :)
\*in _rector_
&gt;Do you honestly think you are better than them? Think for a second, then reply. &amp;#x200B; This is not a competition. UCMS does not try to be better, UCMS tries to be minimalistic. UCMS tries to be an alternate. Many people don't like Doctrine because they loose control on how tables are created. Instead of trying to introduce new logic layers for all possible things, UCMS tries to give the programmer control. &amp;#x200B; &gt;Symfony has fastest router in PHP: [https://symfony.com/blog/new-in-symfony-4-1-fastest-php-router](https://symfony.com/blog/new-in-symfony-4-1-fastest-php-router) &amp;#x200B; I have seen that URL some months ago. Believe me, this is not the best solution. My old cms had a solution like that. The problem there is that you need a regural expression for each part of the application. What you can see there will be able to route everything that belongs to a blog. But what if you your website also has a shop, a customer dashboard, and many other things? You will need many more regular exprerssions. And you must be able to understand regular expressions. &amp;#x200B; The new router technology made by me works completely different. The UCMS creates a tree structure from the urls. When a url is requested the router tries to walk through this tree to a endpoint. The router will capture all variables on this way. The router can jump over missing nodes if this was defined. The router can look ahead and look behind. No regular expressions are needed for this. &amp;#x200B; `url = 'blog/{{list&gt;slug:alpha}}/{{list&lt;slug:unsafe}}/{{[page_keyword]&gt;page_no@page}}/{{page_keyword&lt;page_no:digit=1}}/'` &amp;#x200B; `ucms.getUrl('blog')` results in `/en/blog/` &amp;#x200B; `ucms.getUrl('blog', {list: 'tags', slug: 'leet stuff', page_no: 1337})` results in `/en/blog/tags/leet%20stuff/page/1337/` &amp;#x200B; now I trace it: &amp;#x200B; +-------+------------+----------------------------------+--------------------------------+-------------------+--------------+--------------+-----------+-----------+ | Level | Filename | Pattern | Regex | Match | Predecessor | Keys | Successor | Endpoints | +-------+------------+----------------------------------+--------------------------------+-------------------+--------------+--------------+-----------+-----------+ | 0 | blog | blog | - | MATCH (FPS---) | * | - | * | - | | 1 | tags | {{list&gt;slug:alpha}} | /^(?P&lt;list&gt;[[:alpha:]]++)$/ | MATCH (FPS---) | * | list | slug | - | | 2 | leet stuff | {{list&lt;slug:unsafe}} | /^(?P&lt;slug&gt;.+?)$/ | MATCH (FPS---) | list | slug | * | - | | 3 | page | {{[page_keyword]&gt;page_no@page}} | /^(?:page)$/ | MATCH (FPS---) | slug | page_keyword | page_no | - | | 4 | 1337 | {{page_keyword&lt;page_no:digit=1}} | /^(?P&lt;page_no&gt;[[:digit:]]++)$/ | MATCH (FPSE-R) | page_keyword | page_no | * | blog | +-------+------------+----------------------------------+--------------------------------+-------------------+--------------+--------------+-----------+-----------+ &amp;#x200B; &gt;No, no, no... **any** parsing requires CPU cycles. reading the tree structure from cache (APCU) takes less than 1ms on a average server &amp;#x200B; &gt;Maybe because... I don't know... You don't know twig? But this was the headline of this post. It's the most important part of my work. It is even more important than the UCMS itself. &amp;#x200B; &gt; I have apps that run under 20ms UCMS is able to do this on a raspberry pi without compiled php templates, only with cache &amp;#x200B; &gt;Not every page, but more than enough. I was correct ;) &amp;#x200B; I do not want hurt your feelings, but if you really don't know Twig and template inheritance you are missing a very important part of knowledge about web application development. I recommend you to learn this, the old twig also has this template inheritance. After you learned it, you will have an "Aha effect". &amp;#x200B; You see, a better router, a better template language, a better PDF Generator... maybe you should think about to choose the red pill :)
In computer programming .po and .mo (gettext) files are a de facto standard. UCMS uses the gettext logic and has 2 adapters, one adapter uses the php gettext functions and is good in production mode, the other adapter is self developed and good for development because it can also read .po files. Both use caching. &amp;#x200B; You can create any other adapter you like. Just create a "DatabaseTranslationAdapter", define it in "bios.ini" and you can read messages from the database. &amp;#x200B; The revolutionary part is that you can apply database logic (select, insert, update, delete) to .po and .mo files (also to many other files). That my solution supports the translation context (msgctxt property) is also revolutionary. Twig++ has a context tag for this. The old Twig does not have this. But you do not know Twig, that is the problem. The possibility to define adapters for each part of an application is also new and revolutionary. &amp;#x200B; UCMS has a much more detailed and more powerful GUI to edit translations. I will try to add screenshots to the website as soon as possible. Futre blog posts will also explain all details more. &amp;#x200B; I answered to an other user and told him a trick how to create almost perfect translations. &amp;#x200B; Again, I do not want hurt your feelings, but I believe you are not an expert for this gettext stuff (which really needs a lot of experience). &amp;#x200B; Most people here at reddit do not have 20 years of experience like me. They are pissed off because my truth destroy their worldview. But then just take the blue pill. And you will never find out how deep the rabbit hole goes...
I applaud you, you had far more patience with this loon than i did.
I was thinking it would be nice to just use &amp;is_object, but then I remembered that strings are callable, so it could reduce this to just 'is_object'.
Bitch about code style, even if it's 95% correct to PSR style, harp on the 5% that isn't. Don't bother looking for potential bugs, those are job security. Welcome to the industry.
Take a look at [Siler](https://github.com/leocavalcante/siler) I was thinking exactly what you are thinking when I start developing it. Just a set functions that powers up the vanilla PHP.
As others said; you are a loon. And this is not even funny anymore, I really think you should talk with someone.
&gt;Again, I do not want hurt your feelings, but I believe you are not an expert for this gettext stuff (which really needs a lot of experience). &gt; &gt;Most people here at reddit do not have 20 years of experience like me. They are pissed off because my truth destroy their worldview. But then just take the blue pill. And you will never find out how deep the rabbit hole goes... &amp;#x200B; Dude, you need help. I am not a doctor so please visit psychotherapist for just 1 session and tell them what you told us. &amp;#x200B; I won't reply anymore because it is not just that you are bad programmer, it is that you need help from specialist and do not deserve mockery for that.
Im talking about the standalone.
I'm not sure I understand. Could you give me a code example?
Haha.. amusing to think someone would name a framework as 'Slow'... the jokes would just write themselves.
Elaborate
Can you elaborate on that last part?
Just detect the url, run a switch statement and include a database constants file based on the URL contents
Until they implement multi-statement bodies, new arrow functions are pretty useless. I don't want to mix and match different syntax when I use Laravel collections or request when method and the like. The original intent behind this feature was to make PHP closures work like they supposed to by automatically capturing parent lexical scope. Albeit saving a few keystrokes on function keyword is nice, it was never the main objective for me. We should get rid of the old closure syntax for good, multi-statement bodies included.
Do you mean something along the lines of: SITE 1: mydomain.com?site=1 SITE 2: mydomain.com?site=2 because that would'nt really work the way my site is setup, i use the URL a lot for other things. and the problem with using site1.mydomain.com OR mydomain.com/site1 is that they if the folder "site1" is empty/only has a $conn then it will not work since the index.php and all the other files are in the base fodler "../"
No sorry not using GET parameters, if you PM me Iâ€™ll happily walk you through it
You can use your apache/Nginx to set rules up to point multiple sub domains to the same root folder. Up to you how you implement the connection stuff but I definitely would not have a switch statement in one conn file
Sure, it's possible! Do you use Nginx? You could point all subdomains to the same codebase, and pass the subdomain as fastcgi_param to PHP. You'll be able to catch that in PHP: server { listen 443 ssl http2; server_name ~^(?&lt;domain&gt;[a-z0-9-]+).mydomain.com; } location / { try_files $uri $uri/ /index.php?$query_string; } location ~ \.php$ { include fastcgi_params; fastcgi_param MY_SUBDOMAIN $domain; } Then, in PHP, you'd be able to: $domain = $_SERVER['MY_SUBDOMAIN']; Now you could create a hash of the domain, figure out a password for that domain, and connect to that There's but one issue: defining the password, and database name, lies purely within code. If you've completely secured your database, still, at your own risk. Gotta run now, but I'll come back in a bit
awesome, had no clue i could do this. Another awesome redditor is currently helping me out in PM aswell. Man i love this community.
Other explained how to do it but I would strongly recommend not to use this approach at all. The reason is simple; if you have 1000 databases and in your code you add another column, you need to run 1000 DB migrations. Instead, use something like this: [Doctrine filters](https://www.doctrine-project.org/projects/doctrine-orm/en/2.6/reference/filters.html) or take an idea and adapt to your DB class if you are not using Doctrine.
Thanks for your input, though I've already thought about this and the scale at which the app is gonna be then it's no problem. Because the databases WILL NOT change unless I make a change the code and I'll on send updates live 2 times each year (specific conditions I know) and if so I'll remake the databases anyways! Thanks for the tip though. Would've been an easy thing to miss.
Thanks for your input, though I've already thought about this and the scale at which the app is gonna be then it's no problem. Because the databases WILL NOT change unless I make a change the code and I'll on send updates live 2 times each year (specific conditions I know) and if so I'll remake the databases anyways! Thanks for the tip though. Would've been an easy thing to miss.
To help you with research, this is usually called "multi tenancy".
Thanks for your input, though I've already thought about this and the scale at which the app is gonna be then it's no problem. Because the databases WILL NOT change unless I make a change the code and I'll on send updates live 2 times each year (specific conditions I know) and if so I'll remake the databases anyways! Thanks for the tip though. Would've been an easy thing to miss.
Awesome, iv'e gotten my answers but this is good to know!
First of all, only the index.php should be in the base folder, all other files should be outside your webroot. Having them publicly accessible could lead to security issues. Ideally, the index.php only includes the config, router and autoloader and such, and has limited or no business logic. A very common way to solve your problem is to have a few different index.php files that include different configs, and have your webserver load the right index.php for each site.
Definitely, Cheers.
The RFC that was accepted only allows for a single statement, so the following is invalid: fn($x) =&gt; { $y = $x * 8; $z = $y + 8; return $x + $y + $z; } However as the JetBrain's article mentions, you could use `array_slice()` to express it like this: fn($x) =&gt; array_slice([ $y = $x * 8, $z = $y + 8, $x + $y + $z ], -1)[0]; And it would correctly return `42`. The RFC suggests that multi-statement bodies would be a possible future expansion of it and gives the following reasoning for not including them at this stage: &gt;This feature is omitted in this RFC, because the value-proposition of this syntax is much smaller: Once you have multiple statements, the relative overhead of the conventional closure syntax becomes small. &gt;An advantage of supporting this syntax is that it is possible to use a single closure syntax for all purposes (excluding cases that need to control binding behavior), rather than having to mix two different syntaxes depending on whether they use a single expression or multiple statements. I'm not familiar with the PHP internals, so I'm not sure if multi-statement bodies would be significantly harder to implement, or whether it was just intended to reduce the amount of possible opposition to it's introduction, but I'm not sure I really buy the argument that supporting it has no worthwhile value. Being able to use a consistent, concise, but recognisable syntax is in itself a benefit and the implicit binding of external scope can help reduce visual noise.
ever heard of HTTP_HOST?
Given you are "not a PRO" then you should definitely choose this approach, as multi-tenancy is a vert special case and not a default setup for such an application. Most people here are helping you to shoot yourself in the foot, this is the only one who's get it right
&gt; A very common way to solve your problem is to have a few different index.php files that include different configs, and have your webserver load the right index.php for each site. You're joking, right?
We run a multi-tenant application, running at around 300 tables per database, spread out across 5 different database servers, 20 application servers, with them being able to run on different versions if we desire so as well. If your migrations are part of the code base, or a specific version, it's no biggie. We run docker, and running migrations (even if there's no migration present) is part of the Docker container startup script.
I have -- you're right. However, before switching to Nginx, we ran Apache, and there was an issue with our setup (the guy who set it all up left as soon as I came on board) where HTTP_HOST would be either not set, or empty.
And the OP is a noob who is not even familiar with $_SERVER variable. Surely their situation is the same as yours.
This is impossible for the virtual host. Without HTTP_HOST a visitor will be unable to reach the web server.
The OP is a noob who's willing to learn. He's sure that there's a way, he just needs help figuring out what it's called, and is looking for examples. OP is alright in my book. You learn by doing, and failing.
Again -- absolutely right, if not for the simple fact that the web server config (which I tried to find just now, but couldn't) was completely messed up, and didn't make _any_ sense whatsoever. I was going to say, HTTP_HOST is sort-of client input, but so would the fastcgi_param be, it's just feels a bit more safe. But, we have a mapping in front of ours. If the subdomain does not exist, just redirect to our main website. We also support different TLD's, and can run the same container/database config for different subdomains, all because we, in Nginx, decide what the SUBDOMAIN param should be, rather than rely on HTTP_HOST.
A perfect example of a pompous sentence that makes not a slightest sense. You are the usual write-only redditor who never read the question but only come to show off your own solution, giving n thought to the question actually asked. Learning is one thing but shooting yourself in the foot is another. You have no idea whether the OP needs this multi-tenant stuff, but offer it nevertheless just because your situation. Learning is OK but you don't learn math starting from calculus. Teach him how to create a regular multi-user application and only then, if it's really necessary, show to a multi-tenant.
Safe in *which sense*? For a comparison? Are you that paranoid? &gt; If the subdomain does not exist, just redirect to our main website. This is done by a single line in the web-server's config. Your solution is non-flexible as it requires editing of the web-serer's config every time a user is added. Sometimes it's plausible but obviously not as a default solution
&gt;You'll never, ever, have an oopsie with customer data accidentally being shared as everyone is physically separate &amp;#x200B; The example from Doctrine's site will also never allow oopsies but you get simpler maintenance. I think it is better solution for OP who himself said he is beginner.
Sorry I mistook your solution. Well, I would say that HTTP_HOST is still plausible but yours is OK too
No worries -- you're absolutely right, in every way. It's exactly because I myself am in this situation, I see no issues, merely exciting things to be won over. OP is new to this, and I should have taken a step, two steps, back, to figure out what he really wants/needs. Thanks colshrapnel :).
I am looking to get into PHP, I know some basics, I am JS dev and I would like to expand into PHP as well. I am not looking for free tutorials, or udemy only, I would pay for a good tutorial, such as Todd Motto tutorials for JS and JS frameworks. Please leave a suggestion if you have one. Thanks!
Laracasts personally for me - Jeffery way covers a lot of great stuff not just limited to PHP either
This one look nice an clean : https://phpapprentice.com
+1 on this.
Worth a read: https://phptherightway.com/
Yes but he mainly has 1 course regarding PhP +1 regarding PhP OOP do you think it is enough? I know he is a guru in Laravel but besides that, are you sure?
Say you have a side menu on your site, each menu item has the properties "parent &amp; label", so you create a tree with it. When you render it, instead of looping 10001 times, you bud a tree structure, and just loop that once to render it. But say your menu is super long, and is actually a list of car pieces, ordered alphabetically in the menu, (again, each with one parent), well, if you want to A-Z and Z-A order them, you either re-build your tree or just reverse it. &amp;#x200B; So usually you reverse it, since you need it the other way around, so you can access the data faster. Ps: you might want to look into balancing the tree also, and things like that. Most useful mainly to speed up access (so fro one side you might do 10 checks, and the other only 3. If most the time you do the 10, reverse it, and most the time you do 3)
Symfonycasts.com
Here's mine: https://ilovephp.jondh.me.uk/ I don't know about "best", but I think it is pretty good. `:-)`
I'm in your shoes. Making my own mini framework, have an actual good (to my standards) orm/query builder and a handful of libraries that make tasks easy. The upaide for me is I'm not a professional. I am a contractor full time and code for fun and learning.
[removed]
For OOP: [https://developer.hyvor.com/tutorials/php/oop-intro](https://developer.hyvor.com/tutorials/php/oop-intro)
Try Beachcasts https://www.youtube.com/channel/UCsOSGYawy8MG9Mh8NKgRHZQ
agreed. definitely this one. [https://laracasts.com/](https://laracasts.com/)
Whats your problem? I explained in detail why the symfony router is old technology from point of view of the ucms. I also provided you an example of a better router. &amp;#x200B; It's also exactly as I predicted, read the symfony blog post, you will find this: &gt;The remaining routes need to be checked using a regular expression. Actually, we may need several of them, because PCRE doesnâ€™t allow infinitely long regular expressions, nor does it allow matching with the [Unicode modifier](https://secure.php.net/manual/en/reference.pcre.pattern.modifiers.php)alternatively *on* and *off* in the same regex &amp;#x200B; And this is not the only problem. Additional problems of the symfony router: 1.) The language code is statically defined in the URL. 2.) The urls can not be translated 3.) It's complicated 4.) Almost impossible do define skippable key value pairs 5.) You can not render the routes as a treeview 6.) No debug trace &amp;#x200B; I could write much more reasons... but instead I just say watch this UCMS magic: [https://imgur.com/MB5C9BS](https://imgur.com/MB5C9BS)
I wrote: &gt;Twig++ is real and revolutionary, no matter how many haters have voted me down! &amp;#x200B; You answered: &gt;Maybe because... I don't know... there is a possibility there are people who know better? &gt; &gt;Listen... I know the feeling, and honestly, the idea does sound cool. &amp;#x200B; You do not know the Twig Template language at all, but you comment this topic. &amp;#x200B; The same is true for your comments about I10n stuff, watch: [https://imgur.com/vRWuAjj](https://imgur.com/vRWuAjj) &lt;-- revolutionary
Payment processors often have special card numbers you can use for testing that each generate a different response. Usually though they only work in some kind of testing environment or with a test mode being on, so you might need a sep environment of your site to ready payments all the way through If you want some browser test that runs on your live site, they best option you might have is to have your own code recognize special testing cards on the live site to route through the test payment account instead of the real one Any closer to live and you're doing refunds of real charges I think
As a general rule of thumb it's not practical to write tests that use production third-party APIs for services that cost money, and it's one area where you have to compromise, by doing one of the below: * Use the developer sandbox for your testing environment * Mock out the whole payment gateway library * Mock out the request to and response from the payment gateway It's just too risky otherwise - you run the risk of getting sloppy and one day having a delivery van turn up with some stuff you didn't order. Most modern frameworks have some means of passing through different configuration values in different environments, such as DotEnv, so you can use that to specify the sandbox for your staging environment and the production gateway for your production environment.
Or traverse it backwards? If you know which branch is the correct "forward" you know which is correct "backward" too. I am more than a little familiar with trees which means I'm also familiar that the order of branches in the internal structure are irrelevant. Hence, the example described is not useful in any algorithm where traversal order matters.
What's wrong with the official documentation though?
To be fair, they said â€œcommonâ€ not â€œgoodâ€.
I can explain. Can you tell the difference between a dictionary and a novel? Would you read a dictionary *through*? Same here. A reference manual is not a walk-though tutorial. They serve different purposes.
[https://symfonycasts.com/](https://symfonycasts.com/) is solid!
MMTUTS on YouTube are the best for deep understanding of php and not a framework. He has learned me the basics and the more advanced stuff. https://www.youtube.com/user/TheCharmefis
So instead of traversing the tree in reverse order (right to left), you would do the reverse operation on the tree, probably also making a copy of the tree in case it is used elsewhere, just to then be able to traverse it from left to right. That's akin to reversing an array just so you don't have to do i--.
Some specific tutorials - [PDO database driver comprehensive tutorial with examples](https://phpdelusions.net/pdo) - [Error reporting in PHP](https://phpdelusions.net/articles/error_reporting) - [Operators precedence](https://phpdelusions.net/articles/or_die)
Have you looked at the possibility of using separate schemas instead of separate databases? MySQL and MariaDB don't support this, but Postgres does and some others may too. Essentially a Postgres database can have multiple schemas inside it, each of which contains its own tables. The default schema is normally `public`, but you can choose different ones. That approach would allow a multi-tenant application to have separate schemas within the same database for each tenant.
Dictionary is more like API reference in that analogy, but I get the idea. It's just PHP doc seemed pretty well written to me and also more brief which makes it good for learning if you had programming experience with other languages. Actually this thread made me want to check out that laracasts tutorial series, probably I'll learn something new.
I agree, it is well written, and some parts are better to be read from there than from any tutorial, such as arrays, strings, security etc. But the problem is, the whole manual is HUGE. And a beginner just doesn't know where to look. A tutorial, on the other hand, is much shorter and it guides you through.
Look at high quality repos with 100% test code coverage and scores of As on code grading services, like Scrutinizer and CodeClimate. Examples: * https://github.com/phpexpertsinc/RESTSpeaker * https://github.com/phpexpertsinc/DataTypeValidator * https://github.com/phpexpertsinc/CSVSpeaker * https://github.com/phpexpertsinc/WorkdayPlanner etc.
The comments! STAY AWAY FROM THE COMMENTS on php.net!! And especially if the comment is more than, say, 7 years old, any where on the Internet, it's full of shit, most likely. Even DANGEROUS! Especially on w3schools and php.net!
&gt;w3schools I try to avoid that whole website
If you already know programming, I'd recommend Derek Banas. If not, thenewboston
Ah interesting I'd not seen that array slice hack. Completely hate it, it's so unreadable. Just use a normal closure! I also am happy to keep the original closure syntax separate because the way variable scopes work are completely different due to the implicit inheritance of all defined variables from the caller's scope in these new shorthand arrow functions.
I've been following along with this. It's my favorite PHP tutorial so far -- thanks for writing it!
&gt;Especially the day you have to make big changes Let me just say: Then your tests are not good. Following TDD your tests should always be green, even if you change your code. That being said, if your test is too tight coupled with your code. There is potential that you have to rewrite your test - which should not be the case. And testing your "most basic" units - there shouldn't be a lot of mock usage. I see a lot of people simple mocking the hell out of dependencies just to "insert" them in to you to-test-method. But doing so will open your code to more problems. *For example*: Lets say you are using simple `ValueObjects` or other model-like formats. Why mock them? Just create a new instance, give it some data and you're good to go. **If** you mock them, you will force behavior on them that might change (especially for foreign dependencies/libraries). You want to test **your** code, not theirs. You will also need to take advantage of all kind of tests (not just unit tests). Functional, Integration, End-to-End and so on.
Lovely, glad you like it. There's a Reddit channel associated with it, feel free to post there if you have any queries.
Not a Real Dev. Yet. Just *please* don't become one of those "I have 15 years experience" guys who can't code themselves out of a box!
Haha! I love how it started with Symfony and ended up at Zend Expressive! This junior guy is having trouble with *Laravel*... do you really think he'll be able to, proficiently and sanely, slap something together with a microframework?? He may not even know what middleware is...
Silex died over a year ago. https://symfony.com/blog/the-end-of-silex
Seconded. Used to be KNP university. Incredibly good structure to all of their courses.
You're probably looking for an -unframework-. like FlourishLib. http://flourishlib.com/
Codeception.
Iâ€™d offer a counterpoint... I have experience with Laravel (work) but I prefer Symfony for my own projects. His tutorials arenâ€™t bad, but IMO Symfonycasts (used to be KNP university) are just put together better. Easier to follow and really well thought out. Itâ€™s also worth mentioning that I prefer Symfonyâ€™s approach to just about everything over Laravelâ€™s, so Iâ€™m definitely biased.
I'm a big fan of Derek Banas' fast overviews on YouTube.
He asked for PHP, not a framework.
FYI, https://laracasts.com/skills/php
I would argue that symfony /zf is easier than laravel, because it's easier to see the flow of data, how everything connects, there is no magic ðŸ˜Š
There is more love in this tutorial than knowledge. It looks like a tutorial from 2009 not 2019, featuring spaghetti bowl of SQL/PHP/HTML stirred together with some bad and outdated practices. Try Laracasts, they teach a much more modern and useful PHP.
https://phpdelusions.net/
The answer is always â€œYesâ€
Yes. Never trust that anyone or anything has protected your server other than yourself.
Wanna second this and tack on Traversy Media. Big fan of his work.
These look more like small utility classes than actual projects though.
The Net Ninja (youtube channel) has a solid course, doing it myself right now.
**Opinions follow.** It's not a simple yes/no question. It's more about how using a service like this changes how you manage (and think about managing) your server(s). For me, it was a push to get every app I host to be in a state where it could be deployed from a Git repo and database migrations. It was a push to make sure the important stuff was being backed-up off-site. It also made things like getting a new server going, or getting an existing server updated, a lot easier. I use Forge, and it does a great job of configuring the server in such a way that I don't have to install anything else to run my Laravel, async PHP, NodeJS, and WordPress apps. Furthermore, I have "recipes" set up to run repeated tasks, on the servers, when I need to. Lastly, it can simplify processes like creating new databases (and database users, with limited permissions) and installing SSH public keys. What I'm trying to say is that there are still things to "worry" about doing, but they're completely different (and IMHO, much less severe) than if I was spinning up new DO droplets by myself, for every app. I've found it to be well worth the money.
Or someone you hire.
Is chrome autocomplete showing everyone your real mobile number?
https://github.com/phpexpertsinc/CSVSpeaker/blob/master/src/CSVReader.php What is the meaning of those parameters in private constructor ?
Hi, thank you for the detailed answer. Ok, so maybe things have been mixed in this entire thread so let me clarify some things. I'm sad because of PHPMD became orphaned because it offered some useful metrics which isn't available (just like you said) in any other tools. Many others recommended Psalm/PHPStan/Phan/Sonar but each tool is different and yes, Sonar is the one which at least offers some metrics on complexity (as it turned out PHPCS have this too). Don't get me wrong, I have no problem with Sonar, I'm using it, but not because its features, but because it provides a UI for historical data on 'overall' code quality. And this is where I have mixed feelings about Sonar. It has a tons of pretty lame rules (like 'do not use short open tags', and many formatting rules). The static analyzers mentioned above offering a myriad of more useful rules and Sonar simply couldn't keep up with them. This is why I've wrote a UI for Psalm so I can track its reports on a similar interface what Sonar offers, but with more useful metrics.
So you won't tell me?
Best PHP Tutorials online: [https://www.freelancetoindia.com/php-web-development/](https://www.freelancetoindia.com/php-web-development/)
www.codecourse.com
This has nothing to do with PHP and is just an advert for your services. This doesnâ€™t belong here and you clearly havenâ€™t read the rules. Respectfully, bugger off.
I think the most important is making clear for both the interviewer and the interviewee that the goal is to improve the code quality. We're not saying you're bad at your job. We're talking can we build a V2 of the code that would be more robust and more maintainable 6 months down the line. If the atmosphere is positive, code reviews will become something you want to do more often. It's important to agree together about the V1 MVP (minimum viable product) of the code.
This talk will interest you: https://www.youtube.com/watch?v=ZsHMHukIlJY If you're short on time: start at 16:00 until 23:00
Good points, well said.
Thanks! To be honest I'm always nervous when I just posted something on Reddit, and I see I've got a new notification. My first reaction is "oh no, I hope no one is angry". So I'm glad to read your comment!
Laravel is powerfull . I have a question if not php then which is the best web dev language out there ? I mean for backend only
I don't think one language is per definition better than another. It's a matter of how much time you're willing to spend to get good at whatever language or framework
The OOP playlist is a feckn shame. It gives you anything but a *deep understanding*. Simply because **it is written by not a programmer and never teaches you how to program**. As long as the the guy just mindlessly recounts some existing tutorials, it is just bearable, however not too brilliant. A bloody **ten minute** video on such a rocket science topic as "Inserting database results into array in PHP". Notably, he never mentions a function that *already exists* in PHP for the task. Simply because he has no idea it exists. But when he starts to write his own code... It's just a continuous facepalm. His "How To Query A Database Using PDO PHP" He knows no OOP (a class user should never extend a DBH class. A user is not a database), he have no idea what a proper error reporting is and how much it is important for the development, he don't even understands such complete basics as using just a single connection throughout the script execution, connecting every time a query have to be run. the code he writes is a horrible Frankenstein: public function getAllUsers() { $stmt = $this-&gt;connect()-&gt;query("SELECT * FROM users"); while ($row = $stmt-&gt;fetch()) { echo $row['uid']; } }
So to be a successful developer should i learn multiple languages ?
Nice little helper, good work
It gives you more flexibility, and should always be a goal, but Iâ€™d say the most important thing is to be really good at at least one of them.
&gt; Symfony and Laravel. Sure there's also Zend, Yii, Cake, Code Igniter etc. â€” but if you want to know what modern PHP development looks like, you're good with one of these two. To put Zend in the Leagues with the rest of the mentioned... some people truly have no idea what they are talking about when it comes to frameworks.... Luckily the rest of the post made up for this BS line :) PHP truly has evolved and it's getting better and better as of late. Hopefully the people's mindset will come along and stop thinking about frameworks and rather think about components soon. Because the playing field changes so much if we stop looking at the frameworks as a whole..
Thank you
What do you suggest . What else than php? Node js ? Django?
Definitely your next step should be JavaScript.
I already know php and its laravel framework . I also know js , jquery and vue.js What else should i focus on to be relevant in the web dev world and earn money with it
Look at job postings in your area and see what theyâ€™re asking for.
\*PHP Function\* -&gt; its a laravel function. Why are 99% of the titles here incorrect?
Can you elaborate a little more? I've worked on a few legacy Zend projects but never dove deep into it.
I saw the function and closed the tab.
If there wasn't PHP, probably people would be hardstuck on Java/C# because of the enterprise-level of technology available, from which PHP has been copying a lot lately, which is great. Nowadays with Go, Rust, NodeJS I honestly don't know. Prior to those though it surely would've been Java/C#.
No matter which framework, all of them are evolving... Zend Framework 1 is bullshit. Laravel turned out to be the much much better ZF1. I've always called Laravel to be ZF1 on Speed. ZF2, ZF3/Expressive are much different. They are pretty much just like Symfony. Core concepts are very similar. PSRs have brough things much closer together as well. Personally I usually start with an expressive skeleton and then mix-match components from both symfony and zend and other 3rd parties as I see fit. And that's the true power of the current PHP ecosystem. It doesn't matter which framework you're using because you can mix the components pretty easily together (for the most parts).
wow. this is a shameless one
&gt; Laravel turned out to be the much much better ZF1 Well, that's what happens when you build a framework when you have tools like Composer and Packagist available, namespaces, PSR7 etc.
Yet another "how to add an SQL injection to your site" tutorial. Honestly, the amount number trash in the area of "PHP video tutorials" is appalling.
View the source code before you write. It has nothing to do with Laravel atm.
So what exactly was BS about that one line? Genuinely asking
&gt; No matter which framework, all of them are evolving... Zend Framework 1 is bullshit. Laravel turned out to be the much much better ZF1. I've always said that Laravel managed to do what ZF1 always wanted. They've simply done it far better. ZF1 first release: March 2006. Laravel first release: June 2011. ZF1 was great when it first came out and was state-of-the-art. Obviously our whole ecosystem has evolved quite a bit since then.
The only thing I found out there is a 30-minutes intro which is 5 years old. Surely you are not serious recommending *that*?
To be a successful developer, you need to be able to DO things, not to cram language syntax in your head. You need to build something, something that works and brings value. That's what developers do, they don't go around preaching what languages they know - no one cares about that, people just care if you're capable of turning ideas into reality. Judging by your questions, I'm assuming you just started with development. Focus on creating working software, not on what's "the best".
I'm absolutely recommending that. Why would "5 years old" matter to a PHP beginner?
Your question is very vague and it's pretty much impossible to answer without more information. What's the context of this question? Where have you seen this? What problem are you trying to solve?
It does matter more than you think. I just checked his PHP and mysql video which is 5 years old. It turns out, his PHP code is 20 years old. His code looks as though it's still 1999 and PHP3 around. A spaghetti bowl with PHP, HTML, SQL errors stirred together in a mess. He is responsible, with all his 1.5m views, for all the shit people are still taking PHP for. I was utterly surprised to find he is using prepared statements. This is the only good thing in the whole tutorial. He doesn't respect HTTP standards, the separation of concerns, the proper error reporting. Literally, take any tutorial from 1990-x and you won't find any difference, save for the prepared statements.
Payment processors have test cards / keys usually (Stripe for example) or a sandboxed API (Paypal). You can also use something like [Wiremock](http://wiremock.org/) to mock your payment processor responses but it can take some time to get right.
No idea what you mean. Is this on a URL? If so, it's for passing values to a PHP program via the URL. Eg, [www.somesite.com/somescript.php?x=](https://www.somesite.com/somescript.php?x=1)123 will pass a variable x. So the script can retrieve it via the value of $\_GET\["x"\].
&gt; DataValidator::validate() will return \`true\` on success or throw // an \`InvalidDataTypeException\` that contains an array of errors Why does everybody keep making the (IMO) same mistake. It's a validator. It's expected to receive invalid data. Stop abusing exceptions...
Nice article. Maybe you could have pointed out Linux foundation is investing in PHP and bought Zend framework ? Like you did with jet brains. It's not much, but I don't know I'm still amazed that such foundation chose PHP. It's really great for the future considering how the language is evolving. https://framework.zend.com/
Thanks it think this was helpful
Good suggestion, I added it!
Because you're pretty much comparing ZF1 to current Laravel and Symfony which is utter bullshit. Depending on your point of view, Zend and Symfony are top tier league with Laravel coming below this. Mayor reasons being the differences in design and the "ease of creating 'bad software' with Laravel static chaos", but that's a different discussion.
Completely agree. I didn't mean to disrespect ZF1 saying this. If anything I'm a laravel hater xD
IMHO the best language purely for its merits as a language would be Ruby. It's known to be a bit slow and sometimes finicky, but the syntax is lovely. Then there are some ruby-likes like Crystal and Elixir which are more high performance but not widely used.
Nowhere did I mention ZF1, but I'm sorry if I offended your opinion. I hope people can see that the point of the blog post is not to compare frameworks.
&gt;but the syntax is lovely thats something I rarely read when ruby is mentioned
That was an interesting read, I work alot with WordPress but Iâ€™m looking to broaden my skills with PHP over the next few months
No PHP support yet, but I wonder (1) how long it will be, and (2) what the effect will be on Packagist if/when it appears.
It's a great talk, I actually shamelessly stole the idea of replacing characters with `x` to demonstrate the power of proper formatting from one of Kevlin Henney's books.
As much as I like PHP I'm not sure if they survive the fight against JS &amp; others. Especially the missing async functionality and the huge usage of JS in the frontend makes it difficult for PHP...Yet frameworks &amp; community are great! If I would have to choose to learn a new language for backend-dev it wouldn't be PHP these days.
PHP still has so much stuff thats not fixable, these new features dont cut it. PHP has no "new" features, but just copies features from other languages. No feature in PHP is not available and with a better implementation in some other language.
Your SSL certificate expired.
If you really do know all that then youâ€™re golden
Fully agree, exceptions are for exceptional situations. Some `ValidationResponse` or even an `Either` would be more appropriate here.
He's just promoting his own libraries.
if `'is_object'` were a custom function I think it wouldn't be supported by refactoring in phpstorm. But that seems to depend a little on the context.
I liked the look of Sparrow until I saw that it didn't use prepared statements
Good article!
Exactly, I use a bicycle, travel by train, cook my own vegan food, use as much free software as I can and have a very old phone.
When doing extended analysis on code, it takes something like 3 Gb, and I used to have only 4 Gb....
I hope one day you'll see the light my brother. May the Gods of free software be ever in your favor.
Thanks!
yes, but Space Vim is just a config file plus some plugins which enable another config file not in vim syntax. It overrides some defaults and for me is just something to avoid, because you have no control over it. Using vim as a Php ide is easy as install 3/4 plugins: - Coc.vim - stanangeloff/php.vim - 'swekaj/php-foldexpr.vim
So this could just be `array_filter($meetups, 'is_object')` And I was saying it doesn't make sense to typehint a class before doing an is_object check since you'll get an error at the time the closure is called if the item isn't an instance of that class. But I get it's just some example code.
ðŸ˜¡
Everything you can nearly think off... PHPStorm has a key or button to do it. I've mention the history because it's the most noticeable feature that saves my ass off. But, lets talk about others as well. * Changelists (Having a control of everything you've touched without pain) * Issue management (You can check in into your favorite Bug Tracker and join with your IDE and using changelists as a Issue tracking system) * Structure of a class. If you have long 4000 lines of code classes... you're gonna need this. * DocBlock inspection from any part of the code with CTRL-Over the word mouse. Or CTRL-Q to get that doc info. * Vagrant support. * Inspections support for example PHPCS or whatever you've got it. * Synchronization with remote SFTP/FTP servers with DIFF. * Auto-completion with snipets. * Debugging. * GUI to manage TODO's
I didn't mean "why would anybody want to learn about binary trees", I meant "why use PHP for that???" I mean, this is what **C** was invented for.
I need that
Because **[C](https://en.wikipedia.org/wiki/C_%28programming_language%29)**.
&gt; travel by train Steam engine?
Look for aharabara/habarnam. It is still in early development, but I would be happy to see somebody using it. Also, take a look at aharabara/Programming_challanges, filled "5/", where you can find Todo app from screenshot. P.S. You need ncurses to be installed, so search for install.sh in programming_challengea
Nice, I'll take a look
There was the thought in the r/webdev of this thread suggesting that this might be taking a shot at NPM with all the negative news surrounding it recently. I personally like packagist, so I likely wouldn't move existing packages from it should PHP packages be supported. What I could see happening is new PHP packages being set up through GitHub package registry. I also wonder if it's private package support may make things yet more convenient for pulling in private packages via SSH or other means. All this will have to be wait and see, but I'm always happy up have more options.
ðŸ¤ª
I'd love to play around with something like this. Learning ncurses has been on my to do list for a couple months, and having a PHP library to look at would make that a lot simpler for me.
No, Steam is proprietary software. We use a herd of GNUs.
I don't use a lot of ncurses functionalities, but you could take a look at `aharabara/habarnam`. ðŸ˜
CakePHP is modern too :) Nice article, very well written!
I once occupied myself with the same question but then realized that I am using Twig in every project which I would care about formatting for. The main issue for me was PHP leaving spaces after processing the PHP tag, so it produces untidy output. So for one time I stuck with putting PHP control structures strictly to the left without any padding. It solved the problem but looked quite ugly so I gave up. For the rest, I think it is mostly agreed upon to use alternative control structures and one-liners, like &lt;?php foreach($news as $row): ?&gt; &lt;tr&gt; &lt;td&gt;&lt;?= $row['title'] ?&gt;&lt;/td&gt; &lt;/tr&gt; &lt;?php endforeach ?&gt; but again, I don't really care as I am not using it anymore.
I'm working on an OctoberCMS project, and for some reason their backend templates are all php (even though they have twig in the frontend, go figure). This is my conclusion too. Some of my coworkers do &lt;?php foreach($things as $thing) { $this-&gt;someMethod(); if ($thing-&gt;value === true) { { ?&gt; &lt;div&gt;&lt;?= $this-&gt;field ?&gt;&lt;/div&gt; &lt;? } $this-&gt;otherMethod(); } ?&gt; I don't like it at all. I feel like it makes more sense to have php encapsulated in it's own tags when in a template.
I don't think there is a standard, but the most common practice is using the alternative syntax for control structures. So, instead of the &lt;?php foreach ($subnav as $link) { ?&gt; &lt;li&gt;&lt;?=$link?&gt;&lt;/li&gt; &lt;?php } ?&gt; which is taken from the stackoverflow link, you'll have &lt;?php foreach ($subnav as $link): ?&gt; &lt;li&gt;&lt;?=$link?&gt;&lt;/li&gt; &lt;?php endforeach; ?&gt; cs-fixer has a setting `no_alternative_syntax =&gt; false` for that.
&gt;Spoiler: some things still suck today, just like almost every programming language has its quirks. I'm afraid I have to disagree with this. I'm not saying PHP is a bad language, a bad language wouldn't have such a massive community around it and wouldn't be host to as many innovations as PHP has. That said, PHP definitely has more quirks than most languages. I've been programming in C# for the last 3 years and it's been a very eye-opening experience coming back to PHP just over the last few days. I much prefer the frameworks, but the language itself is really frustrating. It's simpler and more intuitive in some ways and I appreciate that but when you come from Ruby, C#, Python or even JavaScript; you feel like you spend more of your time looking up stuff than you should have to and I fear PHP will always be lagging behind in that respect.
My preferences include: - When wrapping markup don't use curly braces to surround the body of a control structure, always use the explicit `endif`/`endforeach`/etc. syntax - In single line statements, e.g. echoing a variable, omit the final (only) semicolon - Code blocks that span more than one line should start on a newline following the opening `&lt;?php` tag, be indented one level, and have a line break preceding the closing `?&gt;` tag, which should be on the same level as the opening tag - Code blocks at the start of the file (that precede any markup) don't need to be indented Here's an example: http://sandbox.onlinephpfunctions.com/code/e3bd67c1ee06ebd68252d05be69c2996a7374e97
Great article. From my very personal experience, a lot of the hate I hear about when discussing PHP, come by comparing PHP to other languages on a per-feature basis ; language X is faster, language Y is more beautiful, language Z has this feature that PHP doesn't... But I personally find that PHP, although it's not the leader in anything (that I know of), is very good as an amalgam. It does very little superbly (although even that is becoming debatable) but it does pretty much everything decently. And by that I mean, decently enough to warrant consideration. Not to mention it's incredibly easy to set up and get running for beginners. Unless PHP takes a serious turn for the worse in the next 2-3 years, when I teach my kids the bases of programming, you can be sure I'll show them PHP, second maybe only to JS, and only because JS is a complement to HTML. In a world where the important thing is not necessarily to write the code equivalent of poetry, but to get things done, I'll bet my money PHP is here to stay for a good while still.
Node and python would be my picks for you
Great article! I'm excited for 7.4 :) I have always told myself, because I don't have friends, that coding in PHP is like maintaining a car. If you treat it well and keep it in check, you'll have a pretty decent car that runs smoothly. If not, you might end up with a pile of poop.
It's totally fine to directly link to your own package: https://github.com/aharabara/habarnam Ncurses is definitely fun to play with, and I think you're doing a good job overall with the wrapper. Looking through packagist, I see a couple other (abandoned) attempts at wrappers: - https://github.com/ck99/kurses - https://github.com/wapmorgan/NcursesObjects - https://github.com/vsychov/php_ncurses The main issue with using ncurses is that the extension is basically abandoned and requires patching to be able to use it with PHP7+. I wouldn't recommend relying on it too heavily.
Depends on if composer plays ball or not I would imagine. I wonder what the scope for accidental / deliberate name conflicts is.
Personally, I'm a fan of [Kevin Skoglund](https://www.lynda.com/Kevin-Skoglund/104-1.html). His [PHP Essential Training](https://www.lynda.com/PHP-tutorials/PHP-Essential-Training/592510-2.html) along with 'PHP with MySQL Beyond the Basics' (not found on lynda anymore) should be good enough for beginners. He has courses on oop too. &amp;#x200B; Btw, I'm writing my own book on PHP for some time.
tbh package name is horrible it is difficult to pronounce/type/memorize, just my 5 cents : )
it wont work nearly everywhere else where there isnt a routing with syntactical ordered routes.
I have 2 solutions for this issue. 1) There is a patch for this extension on php bug reporter, which I use to build extension (see install.sh in the root directory) 2) I want to try to use FFIMe to generate bindinga for ncurses, so it will not require extension itself, but I did try it yet and it is only for php7.4
Which one does ?
They really do need to create a full break of legacy support given all the quirks it has from those days. Do security updates on PHP 8 and dev out breaking changes for PHP Next or whatever they want to brand it as.
ðŸ˜‚ name literally translated as "I dont know". I really struggled to give a name to this thing. I hope a day will come and comunity will decide how it should be named
I think there will always be a place for PHP. A lot of the older developers found a thousand ways around the async issues, and if I am not mistaken, I do think there are implementations of PHP now that resolve this issue internally. When I first learned PHP, it did not even actually support OOP. With procedural programming and such and the way the ecosystem was back then, it was absolutely amazing when xmlhttprequest became something PHP developers could start utilizing - knowing JS and HTML and CSS and SQL has always been something that a serious PHP developer has had in their "deck", so to speak. That is why I do not see any issues for PHP moving forward. The primary "problems" PHP has are things that have always been "wrong" with the language. It still managed to survive and thrive against tons of competitors. PHP is kind if a stalwart now and there are increasingly competitive alternatives that natively "fix" a lot of the inherent problems PHP has. But, like I said, developers have long circumvented the limitstions of PHP and it has also come a long way as a language.
Since when are we limited to a single language? I've had projects where they used PHP, JavaScript, C, Bash, and Python. It seems like it's a new popular opinion that JavaScript replaces everything, but it simply doesn't. Consider OOP in PHP vs JavaScript. PHP wins. JavaScript's OOP is so limited, it should be laughed at. Consider PHP's plethora of functions for strings, arrays, filesystem, etc. JavaScript doesn't come close, unless you're adding packages. All serious devs should know PHP because it's super easy to learn. If you're dev tool belt doesn't include PHP, I think you're at a serious disadvantage.
It will work anywhere where there is a `$_SERVER['REQUEST_URI']` variable set. That is not Laravel specific, but PHP specific.
# [Wordpress/Php] Image Hosting Script/Theme for sharing images (easy to setup) &amp;#x200B; This Wordpress theme dedicated to photo/image lovers. Now you can upload &amp; share your beautiful moments with the help of this free wordpress theme, which is actually an "Image Hosting Script". Script Made fully in Php/Wordpress. &amp;#x200B; \[Note- No plugin would be required!\] &amp;#x200B; \--- &amp;#x200B; **Requirements:-** &amp;#x200B; * Compatibility : Wordpress Any version Php upto version 7.0 MySQL any version &amp;#x200B; * Hosting : Any Wordpress hosting OR Any Shared hosting with cPanel/WebMin/Plesk/DirectAdmin control panel OR Any VPS/Dedicatred sever with Apache/Nginx web server installed + MySQL database management system installed &amp;#x200B; \--- &amp;#x200B; **Features:-** &amp;#x200B; * Multiple file uploading supported : At a time 25 file images could be uploaded * URL Uploading supported * User can choose the image/upload type : Normal content or Adult content * Thumbnail (of width : 300px) would be generated automatically * "Click to continue to Images(s)" functionality available in Options/Settings * Only Registered Users can Like an Image/Post &amp; make a Comment * Image/Post Views counter * Custom Sign up page where an user can choose his own Password * Custom Sign in page * "Contact us" Form would forward message to admin email * After successfully uploading image(s), user can share it with three available formats(Direct URL,BBCode,HTML). * Back to Top - javascript button * Unregistered users can upload too etc &amp;#x200B; &amp;#x200B; Notice:- Maximum allowed individual image size : 10MB Allowed image extension : "jpg", "jpeg", "jpe", "png", "bmp", "gif", "ico", "tif", "tiff", "svg" &amp;#x200B; \--- **Wordpress default features modified:-** &amp;#x200B; * Enable Any one can register option * New registered user's role : Editor * Registered users can view only his/her posts and comments * Post link format set to [MySiteName.com/post-name](https://MySiteName.com/post-name) ; where 'post-name' would be unique random (12 characters long) * Direct Image link format set to [MySiteName.com/files/image-name.format](https://MySiteName.com/files/image-name.format) ; where 'image-name' would be unique random (16 characters long) * Regular Users would not be able to change URL of an post &amp; image And many more... &amp;#x200B; \--- &amp;#x200B; **How to install &amp; run the script?** &amp;#x200B; \*\*Theme Download URL :\*\* [https://github.com/mediabots/Wordpress-Php-Image-Hosting-Script/archive/master.zip](https://github.com/mediabots/Wordpress-Php-Image-Hosting-Script/archive/master.zip) &amp;#x200B; If you have cPnael access then with the help of this Video Tutorial: [https://](https://youtu.be/5sqUNSU6e_A)[youtube.com/watch?v=5sqUNSU6e\_A](https://youtube.com/watch?v=5sqUNSU6e_A) , you can install Wordpress (through softaculous application). After that WATCH DEMO VIDEO OF THIS PAGE. &amp;#x200B; if you have a VPS or Dedicated server/box then use my [https://github.com/mediabots/ubuntu\_-\_lamp-kubuntu\_desktop-wordpress-ssl](https://github.com/mediabots/ubuntu_-_lamp-kubuntu_desktop-wordpress-ssl) to automatically install Wordpress \[Watch Demo Video inside of the link\]. After that WATCH DEMO VIDEO OF THIS PAGE. &amp;#x200B; \--- &amp;#x200B; **Demo Video** &amp;#x200B; [http://www.youtube.com/watch?v=FnxkgjyFhrA](http://www.youtube.com/watch?feature=player_embedded&amp;v=FnxkgjyFhrA) &amp;#x200B; \--- &amp;#x200B; **Live Demo site** &amp;#x200B; [https://psd2wp.net/](https://psd2wp.net/) &amp;#x200B; \-- &amp;#x200B; Hope you guys would like it.If you are a developer, you are welcome to contribute in this project. Feel free to ask any questionDon't forget to share your thoughts &amp;#x200B; Best Regards
&gt; Consider OOP in PHP vs JavaScript. PHP wins. JavaScript's OOP is so limited, it should be laughed at. +1 for the OOP aspect. Are there alternatives to PHP for writing enterprise web applications except for Java? But yet a lot of 'new' companies set on Javascript using a bunch of microservices.
PHPMD did
C#? The direction Microsoft is going with .NET Core is great and the Blazor preview is impressive. Scala is used heavily by Twilio and others. Python is also perfectly capable, used extensively by Google and Dropbox for example.
&gt; But I get it's just some example code. Indeed :) the point is else, sorry to confuse you. &gt; So this could just be `array_filter($meetups, 'is_object')` It could. It's just more WTF to see function as a string. I personally assume all strings are strings.
Nice tooling section! Don't forget tool that no other language has (expect Google for C) - Rector for instant upgrades ;)
Agreed about JavaScript's OOP. One should *not* try to write OO JavaScript. It's just not that kind of language. JavaScript should be written around the concept of composable functions and plain-old-objects as much as possible, IMO. But you have to be joking about PHP's functions for strings, arrays, etc. PHP's built-in `array` is literally one of the worst parts of the entire language (it might be the worst part of *any* currently popular language). I do NOT think that all devs need to know PHP, **especially** not devs who are not specifically looking for backend work. I just don't see what PHP brings to the table.
[EDIT]: Replied to the wrong comment...
I'm betting you meant to the comment above mine.
Agreed. Too bad for your downvotes. You'll never fix the built-in `array`. You'll never see the standard array and string functions fixed to be actually useful. PHP has committed to verbatim copying Java's OOP model, which sucks. But, yeah, sure- short closure syntax will make everything better.
Darn... yes
&gt; I'm not saying PHP is a bad language, a bad language wouldn't have such a massive community around it and wouldn't be host to as many innovations as PHP has. Then, I'll say it: PHP is a bad language. * It doesn't have a good type system at all. * The built-in array thing is *horrible*. * It has **no** other built-in containers and doesn't have generics, so you can't even make your own. * Features are incomplete (type-hinting) * The array functions are all eager, making them useless and forcing us to use crappy `foreach` loops where we shouldn't have to. * It borrows tons of bad things from Java (must implement interface at definition). * There's no concept of immutable/const variables I could go on... So, I'd say a bad language absolutely can have a big community. It's about what is "easiest" to learn, and PHP and JavaScript are always touted as easy languages for beginners.
Got you fam.
&gt; Since when are we limited to a single language? I've had projects where they used PHP, JavaScript, C, Bash, and Python. It seems like it's a new popular opinion that JavaScript replaces everything, but it simply doesn't. I don't think it's so much that we're "limited" to a certain language as that using a single language makes it easier/cheaper to find developers and tools and makes it easier/safer when those pieces have to send data between each other. It also makes it easier to reasonable upgrades, security, etc. Outside of web development it's really common to just write software in one language because that makes a lot of things easier. In web development, a lot of people walked a path where they learned HTML, CSS, JavaScript, PHP, SQL, etc. and are just so used to not just the *option* of using different languages but the norm of it. So, for a lot of developers I think they went a little overboard with NodeJS because it was the first time they were experiencing what many developers consider a normal development experience of staying within one set of constraints until you voluntarily decide that the many costs of marrying the constraints of two languages are worth some benefit that you get. &gt; Consider OOP in PHP vs JavaScript. PHP wins. JavaScript's OOP is so limited, it should be laughed at. Is there an objective basis you say that on? Most competent JS developers today treat TypeScript as a dev tool or library, so between the two I've found its type and OOP handling to be a lot more ergonomic than PHP. Things noted in OP that PHP added like anonymous classes or type hints are things people in the JS community haven't really had to worry about in quite some time. &gt; Consider PHP's plethora of functions for strings, arrays, filesystem, etc. JavaScript doesn't come close, unless you're adding packages. That's not necessarily a good thing though which is why there is a huge split over which languages choose to do that. In my experiences, languages with comprehensive core libraries like PHP or Python show a lot more baggage because not only does that bog down the core team with things that they don't need to be doing or deciding for everybody, but it also creates tons more legacy decisions that the language has to remain compatible with. In a language with a smaller core library where its trivial to get a package or library, you still get all of the capabilities with trivial effort. But the language itself can be developed in a more agile way. It also becomes easier to learn the core language and can help unify the culture/style of the language since before you reach for a library there's often a really clear way that everybody will do something rather than a bigger language that comes standard with a ton of ways to solve the same problem. It's fine to prefer one or the other, but it's certainly not a clear win.
Assuming by enterprise you just mean large, technically demanding professional projects, I'd say there are several great options and it really depends on what kind of constraints you have.
While I agree with your first sentence, being a polyglot is important (don't just be an X language Dev, be a Developer who knows X language), The rest is kinda debatable. While JavaScript Proper's object model isn't great, if you add a layer like TypeScript over it, it becomes more Robust then PHP's Object Model. You get things like a fully fleshed out type system and proper async await. Throw in something like ts-node and you don't even have to transpile your code. You can just run your TypeScript. PHP's X functions are very archaic coming from a language with Scalar objects. You can work around this in PHP by implementing things like laravels collection object, but at the end of the day working with primitives in PHP just isn't as nice as working with them in languages like Java/JavaScript. I think knowing a lot of tools is always going to be useful, and I don't think PHP should get the flack it does, but lets not throw stones when one lives in a glass house.
I've never really used it in production. Just for prototyping.
&gt;But you have to be joking about PHP's functions for strings, arrays, etc. PHP's built-in array is literally one of the worst parts of the entire language (it might be the worst part of any currently popular language). &amp;#x200B; You've said this a few times in this comment section, but haven't expanded on the \_why\_. What makes it terrible? [If I pointed you at Ds, would that help you see that there's more options?](https://www.php.net/manual/en/book.ds.php)
One reason people upgrade to new PHP versions so quickly is because there are only minor BC breaks. I'm afraid that would change drastically with big BC breaks. Additionally, supporting libraries for multiple non-compatible PHP versions would be a huge pain in the butt.
I think the main thing PHP has going for it is that its userbase is primarily all using it for web applications so it can be extremely optimized toward that end. PHP is able to contain what many other general purpose languages would consider absurdly specific core functions built in to the language because of that and even things people take for granted like how easy it is to integrate it with Apache or how easy it is to find a hosting provider that supports it are things that other languages will struggle at by being general purpose. Because C, C#, Python, etc. are designed to run in so many situations, they just can't so easily make tradeoffs to favor one use case. And that's the danger JavaScript might run into. Not only is it run on the client and server side, but it's also being used for mobile apps and desktop apps and as a compile target and so it's definitely facing the pressures of being a jack-of-all-trades and master of none. &gt; In a world where the important thing is not necessarily to write the code equivalent of poetry I think most people who argue this are doing so because "code poetry" is often easier and more satisfying to maintain and therefore perhaps cheaper to maintain. Then again, while choosing the right language will help you write "code poetry" more easily, the limiting factor is often being a code poet. :)
But Ruby is absolutely hateful to set up from a server perspective. PHP, NodeJS, or even some random Java/JVM servlet are easier to set up.
Python, Ruby, C#/F# with .NET, JVM languages like Scala, Kotlin and Clojure, Elixir/Erlang, Golang, etc..
That's why you have an LTS version that gets security updates. Legacy code can update safely enough to that version. After that you need to perform migration updates to update further. People would have a few years to update their code bases before security updates stopped.
When you say that it signals to the audience that you are very new at this. There is a name for this, the Dunning-Kruger effect, where lack of experience makes you hugely overestimate your own competence, serious experience to under-estimate it, and full experience to accurately estimate it. You are at the beginning of this [chart](https://www.optimalpbs.co.uk/wp-content/uploads/2019/02/dunning-kruger-effect.png) in saying you already know PHP and Laravel and JavaScript and Vue and JQuery and are now ready to learn another language and framework. This indicates you know too little yet to appreciate the gaps in your knowledge. Which is why you're being downvoted (not by me). Instead of moving onto the next thing, find out about design patterns, functional programming, state management, continuous integration, etc, and how they apply to PHP and JavaScript, and you will begin to realise what you have still to learn. Build things that apply these paradigms. Become competent enough to work professionally in one or both of those languages. Then, maybe, move on to the next one.
Entity would be persisted, a DTO, or data transfer object would not.
PHP is very popular and one of the main languages on the web. So I guess everything that is used so often is getting hate. I mean in a few years everyone will hate Python2 and Node6 (or any other version of it). I started to program cause of PHP (PHP4) and I liked even today.
Unlike the front end, on the back end you can use almost anything. So, you'll need a lot more details/constraints to choose the best language. For example, IIRC OkCupid's backend was originally written in C. Rust is a (fast growing) baby but has some impressive frameworks in the making and used in live projects. Erlang is used by Ericsson to route 40% of all 4G traffic and was used for Call of Duty's servers. Google uses Python and Go in some of its server-side projects. Java and .NET find home in a lot of large organizations that already have other dependencies that use those. And there are many others... Ruby, NodeJS, etc. These all have extremely different benefits and drawbacks that will make them better suited to different projects or teams. You could use any of them and more, but what will take you $10k and a month in one might take you $0 and an hour in the other.
I learned the term "persistence model" from [Mehdi Khalili](http://www.mehdi-khalili.com/orm-anti-patterns-part-4-persistence-domain-model), which models the data as it is at the database; those are the models that get persisted. The "domain model" is the in-memory model that should represent the business domain, not the persistence structures. (I adopted the term "persistence model" for the [Atlas ORM](http://atlasphp.io) based on exactly that differentiation.)
I've heard the term Persistence Model used to describe models saved in a DB, and Domain model used to describe in memory models. Sometimes Data Transfer object refers to an model that's saved in an external system like a REST API. Typically domain models are built around higher level concepts, so they're not just in-memory version of a Persistence model or DTO. You'll find these terms thrown around in literature about enterprise architecture.
Fyi for people who aren't aware, this isn't so needed for PHP as it is for Javascript and other pre-compiled distributions. For every package that exists in packagist, and so is installable through composer, the source that is tagged as a release on github _is_ the version that gets installed by composer. For Javascript, and other languages, most of the time the version that is tagged as a release on github, is _NOT_ the version that is installed. Instead the code is precompiled to a particular format, and it's that version that is installed by the package manager. For Javascript in particular, this has led to some trojans or malware being installed as the bad code can be slipped in to the release, no matter what was tagged as the release. Theoretically, having the distributed version on Github could eliminate this loophole, as you could have builds only come directly from the source, rather than having no direct connection.
When I worked a lot with yii and laravel for years I was wondering why people say that PHP is shit. In my eyes it was fast, easy and all the code was very clear. Now I work in a small company which makes websites on wordpress and it's really awful. So there is nothing wrong with php. It's all about environment, legacy and your skills.
1. realize that php is not a template language since 15 years. 2. use a better template engine
So for example, let's take an Address. Suppose I have an Address model - but it isn't persisted to the database, we just build it out of data from our shipping address form so we can interact with it in an OOP way. This would be a DTO?
when ``` &lt;a href="{getLink}"&gt;Doesnt works&lt;/a&gt; ``` reults in: ``` &lt;a href="index.php?requestId=kekedikek4343&amp;hash=thiswontworkrandomly&amp;time=53343"&gt;Doesnt works&lt;/a&gt; ``` you cant expect that all software out there has static urls which are long living. Mostly because there are random parameters in it. Manually i had the full control over my if statement. Now its just ekko with is_active which wont work.
Probably my missunderstood is a lack of documentation in which usecases this will work.
Agreed. But can't, not without abandoning OctoberCMS completely, which is pretty much a non-starter at this point, or at least won['t happen any time soon. In the meantime, however, what are some good practices to keep our admittedly fundamentally-bad templates less bad?
It's not about knowing particular syntax and APIs, that's easy, it's about sharpening your sense of representing problems and data in the right way and seeing the strengths and weaknesses in each approach. One fun way to do that is to pick a non-multi-paradigm language from a paradigm you don't have a lot of experience with and learn it. As you learn it, it'll force you to see new ways to look at things and see weaknesses in your old way of looking at things and that can really help you grow as a developer even if you ultimately discard that language. Another fun way is to try to keep implementing the levels you're sitting on top of. Using apache? Write a server. Using an HTTP library? Handle the requests manually. Using MySQL? Write a database server. The point isn't to be as good as what you were using because you probably won't be, but just to understand the security, performance, etc. better by knowing what's going on under the hood. And I think that gets into another thing... one huge gap a lot of web developers have is a strong background in security. Web applications are inherently open to the public and therefore there is huge value is learning why and how to be absolutely paranoid to all of the attacks out there as you code. Having a stronger security/hacking background will make you a much more valuable web developer.
Ds doesn't have anything to do with my comment about `array` being horrible. Now, I *did* say in one of my other comments that PHP doesn't have any other data structures, which if we count PECL extensions like Ds, wouldn't be totally true. I'm skeptical if PECL extensions should count, though... But as for why `array` and its corresponding standard functions are horrible, it boils down to a couple of points: Your "array" will sometimes magically turn into a dictionary: $arr = [0, 1, 2, 3, 4]; var_dump($arr[1]); $evens = array_filter( $arr, function ($el) { return $el % 2 === 0; } ); var_dump($evens[1]); // OOPS! The array functions are all eager, which means extra computation if you use them. E.g., You have an array with 1000 elements, you'd like to filter out the elements that meet some condition (let's say it takes out half of them), then you want to map the elements left into some other kind of object based on their data. If you use `array_map(array_filter(...))` you'll do 1500 loop iterations, whereas you *should* only do 1000. Oh, and if you accidentally do `array_filter(array_map(...))` you'll do 2000 iterations. But wait! If you don't want your array to magically turn into a dictionary, you have to actually do `array_values(array_map(array_filter(...)))`, which is 2000 iterations. It's a relatively small cost, so I still use them, but it's overhead that shouldn't be there. They can't be type hinted. The fact that keys can only be ints or strings, and that string and ints are VERY easily implicitly casted back and forth can cause difficult-to-debug bugs. The fact that I can do this: $x = []; $x[1.4] = 'Foo'; var_dump($x[1] === 'Foo'); // true The fact that I can do this: $x = []; $x['1'] = 3; $x[1] = 6; var_dump($x['1']); // 6 I'm sure I can go through my own code and find more things that have caused me grief with PHP's array...
Major security leak (SQL injection, please don't use this _anywhere_, ever) $con = _connect(); $fname = $_POST["fname"]; $lname = $_POST["lname"]; $email = $_POST["email"]; $mobile = $_POST["mobile"]; $address = $_POST["address"]; $message = $_POST["message"]; $chk = mysqli_fetch_assoc(mysqli_query($con, "SELECT email,mobile x FROM post WHERE email ='$email' AND mobile='$mobile' "))['x']; as for the client-side validation, you can remove basically every single line of javascript in it and use HTML5 validation https://www.w3schools.com/tags/att_input_pattern.asp Instead of putting together the POST data manually, you can just use FormData. This is (maybe) nice for learning (while I don't think it's healthy to learn how to wreck a company in a few simple steps), but please, never ever upload this on any productive webserver running PHP.
&gt; this might be taking a shot at NPM with all the negative news surrounding it recently. It could also be taking a shot at NPM for the technical inadequacies in the JS package distribution.
Ah I see now. No, this package won't work for you.
Dear sir this is basic fundamentals and basic page design with validation and this community have so many experts and some of new in this community we share this for new users for learning perpose and for understanding . So please support us and coprate ðŸ™‚ðŸ™‚ðŸ™‚
One of basic things any new web developer should learn is how to build secure applications. It should become part of their dna and thereâ€™s really not a single excuse to teach people bad practices like this. So please change the page or take it down.
This is simple elements try to read and understand titles
https://youtu.be/gG62zay3kck
https://youtu.be/Cq48D7qlDK4
Wonder if we need a distinct reporting reason for this kind of half pathetic, half harmful naive spam. At the moment I report it as spam, but sometimes tempted to report as abusive content because it hurts my feelings so much
I understand you, but please try to understand, too. You're _endangering_ people with this. You're telling them "This is how it's done" when it's exactly what you _shouldn't_ do. Your security leak there can, in the wrong hands, lead to actual, real data loss or even worse. Try to realize that. Have a look at this: https://stackoverflow.com/questions/60174/how-can-i-prevent-sql-injection-in-php Work it into your example/guide and secure it. That should be the absolute minimum. In any other case, you're not helping anyone, you're misguiding people and lead them to implementing security holes.
still doesn't justify misguiding people with bad security practises. Every time dev works with a database in PHP, PDO or prepared statements should be used, this is just pure laziness putting that code out on the internet if you expect people to learn from it.
99% of such tutorials are so worthless, better to get good book and learn the basics of language.
Yes, I'm not a big fan of string functions either, I'd like to see that syntax `&amp;is_object` for using function references. I believe it has been proposed at one point.
&gt; This is simple elements try to read and understand titles No, this is blogspam. You spam your site to as many subreddits as you can to drive traffic to your site
Thanks for yours positive support
Async is hardly a deal breaker. Most applications simply have no use for it. Those that do can (and should) simply use another language. I'm not sure why languages are treated like all-in, lifelong investments for some developers. They're tools to be picked up and put down as different needs arise. PHP is a great, all-around workhorse. If you have no need to use something specifically different, it's a solid base for your average app or service. That's really all there is worth saying about the subject. Not sure why every other thread on this sub needs to be an existential crisis about whether PHP is good or bad, alive or dead, worthwhile or a waste of time, etc.
Thanks man i like your advice
And how is github registry eliminating this loophole? By looking at examples, it's just a normal "npm publish", there is nothing different here, it's just a different repository that happens to be connected to github repos. You can still publish malware or trojans there just like to standard npm repo. The same way you can add a malicious .exe to a github release. &amp;#x200B; * [https://github.com/features/package-registry](https://github.com/features/package-registry) * [https://help.github.com/en/articles/configuring-npm-for-use-with-github-package-registry#publishing-a-package](https://help.github.com/en/articles/configuring-npm-for-use-with-github-package-registry#publishing-a-package) &amp;#x200B; I'm not defending npm or have anything against Github Registry, it's just don't see how it solves the problem of languages with pre-compiled packages.
Recursive queries are as fast or faster then nested set hierarchies according to Wikipedia, so... Stop using legacy MySQL ;)
I am seeing some shortcut PHP tags, they are deprecated in PHP 7 and will be removed in PHP 8, so keep that in mind.
Yet the funny thing about JS concurrency in general is that it still pretty horrible compared to Golang, Elixir/Erlang, etc. Yet PHP is lacking so badly when it comes to concurrency, people used to PHP think JS/Node is great in that respect.
Shit, good catch
&gt;While JavaScript Proper's object model isn't great, if you add a layer like TypeScript over it, it becomes more Robust then PHP's Object Model But even if that was true (I dunno), then you're comparing apples and oranges. You can't just compare language X + framework Y with just language Z.
Only the short opening tag &lt;? is deprecated. &lt;?= which is a shortcut for &lt;?php echo it's ok to use
Doesn't something like [https://amphp.org](https://amphp.org) suit your async fancy?
&gt; must implement interface at definition This is an unpopular opinion here, but having to explicitly implement an interface totally defeats the purpose of interfaces. Anything that matches the *behavior* of the interface should satisfy it. Things like that infamous Taylor Otwell gist with the Decorator class *should* work
That's **the** killer feature of Go, IMO. I love the way Go does interfaces. I don't like a lot of the rest of Go, though... The next best thing is the way Swift and Rust let you implement an interface outside of the definition. It's explicit, but you can at least declare that a class you didn't write conforms to some interface that you know it already does.
Is it possible to not be locked into the request-based architecture with async PHP (like Swoole)?
Analysis&gt; tests, don't validate a wrong analysis because the tests work well.
In most ORMs, "entities" represent persisted data. "Model" is a more generic term for any useful object structure. IMO these should be defined as interfaces. "Data Transfer Object" (DTO) is an object with only properties that is simply used to pass data around. "Business Object" is a model that is allowed to have domain logic inside of it. "Data Access Object" (DAO) is an entity that can handle its own persistence. The lines between these things get blurry depending on language, framework, and personal preference. I usually keep both model interfaces and DTOs in a "models" directory, and ORM objects in an "entities" directory.
What that suppose to do?
To aid mobile users, I'll link small subreddits not yet linked in the comments /r/phphelp: Post specific problems or questions you have about PHP or your code. Hopefully someone will be able to help you out! If you got something out of here, please contribute back and help others :) --- ^I ^am ^a ^bot ^| [^Mail ^BotOwner](http://reddit.com/message/compose/?to=DarkMio&amp;subject=SmallSubBot%20Report) ^| ^To ^aid ^mobile ^users, ^I'll ^link ^small ^subreddits ^not ^yet ^linked ^in ^the ^comments ^| ^[Code](https://github.com/DarkMio/Massdrop-Reddit-Bot) ^| [^Ban](https://www.reddit.com/message/compose/?to=SmallSubBot&amp;subject=SmallSubBot%20Report&amp;message=ban%20/r/Subreddit) ^- [^Help](https://www.reddit.com/r/MassdropBot/wiki/index#wiki_banning_a_bot)
Honestly, I've been working with CakePHP since v1. They hugely improved everything in Cake 3, and now I'd say it's way 'better' then Laravel in many aspects. For example, Eloquent lacks behind the Cake ORM.
Hi. Please use r/phphelp for this :) Also, your links arenâ€™t working. Using a gist might be better. You might be having issues because your vendor directory is somehow in a different directory than your composer file. Good luck.
&gt; One reason people upgrade to new PHP versions so quickly https://w3techs.com/technologies/details/pl-php/all/all Quick upgrades? Where exactly? * Version 5 67.1% * Version 7 32.3% * Version 4 0.6% * Version 3 less than 0.1% Version 7 came out 3 December 2015. That is 3 years and half ago. And yet we still have a reported 67% stuck in version 5. Some in almost 10 year old versions. Part of the reason why some people never bother to upgrade, is because PHP has been making old ( and bad ) habits a code breaking feature. Most end users never want to pay to have their code upgrade to a newer version "because it works just fine right now". And "its too expensive with no benefits" ( a lot end users do not see security issue fixes as benefits until their database gets stolen ). PHP 5.6 is end of life. PHP 7.0 is already end of life. https://www.php.net/supported-versions.php And yet, we got probably 70% or more still stuck in those and older! versions. Lets face it, people simply do NOT upgrade fast to newer versions. Its most the more IT focused companies and developers that upgrade. Most people that run wordpress or a old custom website, tend to not upgrade because it "just works". I understand the desire to keep compatible with old code but a lot of old code is already broken in 5.5/5.6/7.0. So why not clean out the language ones and for all, fix the old crud that people complain about, fix the naming and strange behavior and call it version 8.0.
&gt; That's the killer feature of Go, IMO. I love the way Go does interfaces. &gt; I don't like a lot of the rest of Go, though... I know the feeling. Sometimes Go makes my eyes bleed the way you need to write code. I love GO and i hate GO. The sign of a popular language **lol** Swift is way better and cleaner. But unfortunately, the way Apple is holding Swift, it just will never be popular in a lot of areas / outside of the Apple eco system. Big dislike on that. The reality is, there are actually not a lot of beginner friendly languages. Most have a big introduction step, require too much junk in the trunk ( setting up tools, setup files, etc ), require too much compile times or are just slow/memory hungry. Julia looked interesting but is again focused too much on a specific field. Crystal is nice but development is so slow, you can paint your house a 1000 times and watch it dry before the major features ever get into the code ( Windows support, MT, etc ).
People compare PHP by what they see in WordPress. And yea, if they see 15 year old coding practices with horrible coded plugins, its not hard to link this to the language, when its actually the developers.
If you know it should be posted in /r/phphelp, why post it here and not there? You're far more likely to get useful help there.
An address would likely be modelled as a [value object](https://kacper.gunia.me/ddd-building-blocks-in-php-value-object/), rather than a DTO. A value object has no other identity than the value it stores, so two Address objects containing the same address should be considered equal, which is what you'd expect. Whereas if you persist the same address to a database twice, you'd typically end up with two records identified by two different IDs. A value object is also typically immutable (changing anything should result in a new object being returned) and may also provide some form of validation, for example you might have a method for verifying a postal code, depending on location and requirements.
Because here is a huge community, [https://www.reddit.com/r/PHPhelp/comments/boaa8o/why\_my\_autoloader\_is\_not\_finding\_some\_packages\_i/](https://www.reddit.com/r/PHPhelp/comments/boaa8o/why_my_autoloader_is_not_finding_some_packages_i/)
 [https://www.reddit.com/r/PHPhelp/comments/boaa8o/why\_my\_autoloader\_is\_not\_finding\_some\_packages\_i/](https://www.reddit.com/r/PHPhelp/comments/boaa8o/why_my_autoloader_is_not_finding_some_packages_i/) here it is
The statistic you linked is heavily skewed because it includes hosted platforms. It's a security problem for sure, I'm not going to deny that. But almost all major PHP frameworks drop support for older PHP versions once they are unsupported. A more relevant statistic for those writing modern PHP frameworks is [the one from packagist](https://blog.packagist.com/php-versions-stats-2018-2-edition/).
array_reverse
&gt; PHP has no "new" features, but just copies features from other languages. Ok, then let's tell everyone to stop what they're doing and remove every OOP feature or derivative in every language because they're all copying concepts introduced by Simula some 50 years ago. Let's go back to using functions. Wait, functions were introduced in another language so they'll have to be removed as well. I hope you now understand how stupid of a remark that was. All languages borrow features from all languages, it's essential and beneficial for the evolution of all languages that are out there which are being actively developed and maintained.
Yes, there is a large community here, but as the sidebar states (and as you seem to know from your title), this isn't a support community. The community over on /r/phphelp is smaller, but the people who are subscribed over there (including myself) are all interested in helping people out.
As someone who's working on his first Ruby project (I'm experienced in PHP), I'm genuinely curious why you think Ruby's syntax isn't so good? I personally found it quite nice, at least so far.
&gt; But Ruby is absolutely hateful to set up from a server perspective. Fully agree with this, setting it up on a VPS for a project of mine was.. Interesting to put it mildly.
It has plain if(isAInt()) type functions. It also has asserts for when you want to enforce it. Ala laravel's validator.
It's also worth continually restating what code reviews are about. They are about learning, and about code quality, and about picking up easily missed mistakes that we are ALL guilty of making. Because sometimes we forget the human. It happens. Sometimes it sounds like we are berating even when we try very hard not to sound like that. People need to know that code review isn't performance review, and this point needs to be continually reinforced
Here's the difference between Value Objects and [**Data Transfer Objects (DTOs)**](https://github.com/phpexpertsinc/SimpleDTO): 1. **All DTOs are Value Objects**. 2. Value Objects are NOT immutable: Any slapstick dev can, and will, modify a VO this way to Sundance, usually fucking things up in the process. In a bad state, It's called "an invalid state object." It's like when your app accidentally modifies an address VO so that the street name and city differ from what they're supposed to be, or a saved entity without an id. 3. All Model Entities are Value Objects plus Identity. The difference is that pesky property called "ID". Even if two entity instances share the same exact same data for every other field, their id properties will be unique, thus they are not true Value Objects. 4. DTOs are immutable: Once created, they don't change. This is hugely important for long-term maintainability, esp with a team of junior devs. See the SimpleDTO README on why. 5. VOs, and especially model entities, have a huge habit of adding business logic to themselves, while DTOs expressly prohibit this sort of shenanigans. Thus VOs, and by definition entity models, inherently violate the Single Responsibility Principle. DTOs do not. I use DTOs all the time in API development. Basically, every response and request should be two different DTOs.
Not when you can specify the repository in your composer.json
The documentation and online resources for Cake are really awful though. I personally prefer Eloquent to the Cake ORM by a large margin as well. I've worked with both frameworks, both are powerful but for rapid development and ease of use, I go with Laravel.
[removed]
Yes
Three years is not a long time. Iâ€™ve been at my current job about that long, and Iâ€™m nowhere near done clearing out the technical debt my predecessor saddled me with. We are going to be stuck with an obsolete platform running on an obsolete OS for at least another couple of years.
Can you do recursive queries in mysql now?
no
Postman and Guzzle are 2 completely separate things, Guzzle is a package for PHP which makes it easier to make http requests and Postman is an GUI client to make http requests. I've used Guzzle a bunch of times in multiple projects to create api connections and whatnot. ( also, projects like Codeception require Guzzle in their composer.json ;) )
You miss the point. Other languages have a design, and the language evolves around that core. PHP on the other hand has no design, and no purpose. It copies ad-hoc features from other languages and implements them poorly, and without any regard for consistency. Im not talkin about bigger concepts like OOP but rather language features. PS. Ill code in pure functions and day over OOP.
Take a look at Timber. I didn't look back
They are perfectly in time. its only the start phase to get the first moneyz in. A next big messenger wont be free!
That's another thing - you won't find any mocks in my code. Either the class is used directly or it has an interface to which I create proper fake/spy implementation, quite often with anonymous classes. I sometimes \*have to\* use mocks when dealing with existing projects, but that's just an intermediate step before solving the problem properly.
It looks like you've copied snippets from all over and pasted them together, particularly in the index.php file - your indentation, and use of braces appears completely random? Regardless of whether this is the case, settle on one style and apply it throughout the project to aid readability by future developers (which could also include you, 6 months down the line). It doesn't have to be PSR-1/2, it just has to be internally consistent. Remove commented out code - leaving it there clutters the view, and again, makes reading it through harder. You're not losing anything, this is what source control is for - you have the original un-commented code in the history. You're validating file extension, and size, but you should also be validating mime type - as it stands, I can upload any file with a .jpg extension, and there's even odds that it'll either run in the browser or on the server depending on how things are configured. file.php.jpg or file.js.gif would be uploaded, it may be run on access, depending on how the files are served up on the other end. The URL slurping portion of the code is potentially vulnerable to having unfriendly content passed to it using file:// or php:// &amp;#x200B; TL:DR; Nobody should be using this in a public facing environment until its been reviewed fully from a security perspective, which is difficult to do because of the formatting (or lack thereof)
I always close websites if they don't display the prices..
How is this different from services like Laravel Envoy or Heroku?
No documentation, no prices, no thanks.
&gt;Is it possible to not be locked into the request-based architecture with async PHP (like Swoole)? &amp;#x200B; Yes, I am using [it](https://github.com/k911/swoole-bundle). The speed diff is amazing but your code must not do any memoization. I don't know how good support other frameworks have but Symfony works great, just few minor issues here and there. It all started with my issue [https://github.com/symfony/symfony/issues/23984](https://github.com/symfony/symfony/issues/23984) and their team made far, **far** better solution than I ever expected. &amp;#x200B; Another good solution is [Roadrunner](https://github.com/spiral/roadrunner). It is simpler to install and offers way of restarting it on any file change.
1. You're maybe getting confused with old Java world terminology, where what are widely considered DTOs were for a while referred to as "value objects", but this is separate to the more general concept of a value object, as defined in Patterns of Enterprise Application Architecture, used in DDD and most often meant when referring to it in PHP. 2. If a value object isn't immutable it's not a very good value object. The point of a value object is that two value objects with the same value are equal. If the state of the object can be mutated after an equality check, you violate this contract. I'm not sure I really understand why you say "Any slapstick dev can, and will, modify a VO this way to Sundance, usually fucking things up in the process", the same is true of _any_ object, it's the responsibility of the implementer to ensure the object can't be mutated. 3. Mostly correct, although it's weird to say that an model entity is a value object with an identity. At that point it's not a value object at all, it's just an object, with an identity. A User model doesn't represent a single value, with or without identity. 4. There's no particular rule that says DTOs must be immutable, the most basic definition of the pattern is an anemic store for multiple disparate pieces of data with no identity of it's own. The only logic on it should be getters or setters, whether they provide for immutability is really up to the implementer, but the definition from PEAA allows for mutation. 5. You've taken the zealot's definition of the Single Responsibilty Principle, which leads to hellishly over-asbtracted code. DTOs are often criticised as an anti-pattern _because_ they end up being anaemic data stores when used outside their original context for transferring data remotely between different systems. There is a very big difference between a value object having business logic related to itself (an EmailAddress object being able to validate that the stored value is valid email address _doesn't_ violate the single responsibility principle) and something like a model entity that can save itself to the database, perform validation and retrieve other models from a datastore. The concept of a DTO, as it is most widely used, is an object that has no identity of it's own but may be composed of multiple values, value objects and objects with their own identities. The only logic should be getters and setters that either mutate it's own state, or return a new DTO, but perform no other operations on the data. It's a pattern for composing a group of disparate data together when you are passing it between different layers of an application or different processes in a wider system, without having to pass all of that data in separate calls. It's most useful when communicating over networks, or between processes, threads and coroutines, but you often see the same basic implementation used to return compound data from a single method. Martin Fowler has [a good write-up](https://martinfowler.com/bliki/LocalDTO.html) about the history of the term and it's use in non-remote contexts. That's not to say DTOs aren't regularly used for passing data locally (I've done it myself), just that it's not always the right tool for the job and adds a layer of abstraction that often isn't appropriate.
Fewer features and an opaque billing plan?
Good call. So the difference between this and Envoyer is that with Amezmo you get the equivalent of a $5 dollar droplet from DO. Prices arenâ€™t listed because I havenâ€™t had time to make the page, but you can use coupon code FRIEND which will give you access to the dashboard.
What I meant was - this is a question that the website maybe should answer? I only see six bullet points, no docs and no billing plan.
Thank you very much your review &amp; your time. Specially for taking a look on it. &amp;#x200B; All the best
We use both phpmd and phpstan. Both provide different code quality features.
I've used lots of this services. From forge to heroku passing through elastic beanstalk. In my opinion... well... the answer for me is YES without quotes. I don't like Forge at all. The easiest for me to handle without any knowledge is heroku. But the problem is that for understand lots of features you must have knowledge. Elastic beanstalk is a nightmare to configure but as an iron anvil after that.
&gt; I know how to write js scripts in PHP. Erm... Ok PHP will essentially just be your API and react will consume that API. They would be separate applications I guess.
PHP will be your server side code while javascript will be for client side. If it helps at all, I'd recommend having a look at the Laravel framework, it integrates nicely with Vuejs out of the box but can easily be configured to use react if that's what you're comfortable with. If you do suss out Laravel be sure to check out [Laracasts.com](https://Laracasts.com) for learning resources!
&gt; PHP on the other hand has no design, and no purpose. No purpose? Its purpose is to create web apps, and it's *very* specialized towards that purpose. And while some of its design elements are questionable, you simply cannot state it has no design. That's just false. &gt; It copies ad-hoc features from other languages and implements them poorly, and without any regard for consistency. Im not talkin about bigger concepts like OOP but rather language features. Consistency has been very good in more recent versions (PHP 7+), I don't know what you're talking about. PHP's inconsistency comes from the old baggage of old functions and features which are kept because of backwards compatibility. Not from new features. And if you don't like the way new features are implemented that's your business. You think traits are bad? Null coalescing operator? Return type declarations? Exemplify. &gt; PS. Ill code in pure functions and day over OOP. You can't be serious. How exactly do you hope to maintain a codebase which spans millions of lines when everything is a function? I can understand that some of you are against OOP but it's simply one of the best approaches in large codebases, because humans understand 'objects' naturally. Coding procedurally makes large apps much harder to maintain.
I agree with you, the bullet points that are there aren't even very well written, a few things are repeated.
&gt;how PHP and modern JS frameworks works together Might be an unpopular opinion, but they don't. &gt;do I need PHP only for creating APIs Yes. It seems people are unwilling to break from a single code base that renders everything, but these always end up with PHP rendering a template, that boots a js framework, that makes a bunch of ajax requests ... and now you have a bunch of SPA's mixed with server side code instead of one clean client. Just embrace client/api and your life will get simpler.
Hah, so I'm guessing apparently he's unsure of what he's trying to teach me. Maybe I'll learn Guzzle on my own then.
What is the negative news recently?
Laravwyttjomel uses vnue.js as
Use Laravel for api with react on the front end
Laravel uses vue.js as default front-end framework of choice, but you could plug reacts anytime with ease
Laravel uses vue.js as default front-end framework of choice, but you could plug reacts anytime with ease
Yes, in this case PHP is only needed for providing the API. Like any API it just needs to process requests and return relevant data. Your JS framework is responsible for sending those requests and then doing something with the data which is returned. So if you want to display a list of blog posts in your app it will go something like this: 1. JS framework sends a request to whenever your PHP application is hosted e.g. [https://app.com/api/posts](https://app.com/api/posts) 2. PHP code on the server handles this request. It fetches the posts from Mysql and outputs them as JSON 3. JS framework parses the JSON response and lists out the posts The JS framework doesn't care which language the API is written in. It can be PHP or it can be something else, the only thing that the JS framework cares about is that when it requests [https://app.com/api/posts](https://app.com/api/posts) it gets back a list of posts.
Depends what you're developing...
I also have mixed feelings about Swift. I hate that you have to choose between reference or value semantics when you define a class/struct. That's a decision that should be left to the caller. I also don't really care for exceptions. Plus is has some cruft for ObjC interop. But Kotlin is very similar to Swift, if you want to have something similar to Swift that's not an Apple language. My current favorite is Rust. It's not perfect, but it's better than everything else I've tried. I don't believe there is any such thing as a beginner friendly language. Sure, you can hand someone Python or JavaScript or PHP and they can kind of get something running nice and quick. But then you have to teach them to avoid the myriad bugs they will write from using them.
Agree with this in regards to tone; ask questions rather than state facts: BAD: "This function only ever returns false" BETTER: "Doesn't this only ever return false? Is that intentional?" Ask the programmer what was intended, as their view of the logic might be different to yours. If there's an issue with the logic rather than the code that's a separate discussion and I've always found it helpful to discuss those separately to whether the code follows the logic. If you're reviewing a junior's code, always provide an example of how something could be improved, or at least how it breaks. So in this case: ``` public function handler() { foreach ($this-&gt;things as $thing) { if ($thing === "test"){ return true; } return false; } } ``` You could provide a possible test example which would fail: ``` $this-&gt;things = [ "one", "test", "two" ]; ``` To better explain to them why it's broken.
is it weird that i like to sleep to his voice? &amp;#x200B; hes like my personal ASMR
nothing more sketch then a website with only 2 pages.
If an Email Entity can both load and save itself to/from a database -and- validate whether it's a valid email, etc., those are two very different responsibilities.
And for gem? Maven? nuget? these are not issues
Same. Then I inherited a 5.6 project and it was littered with &lt;?php &lt;?= and &lt;?. I also added docker integration for local dev and I realized all the short tags were being used when I switched it on and everything broke because the image's base php.ini didn't enable short tags on the server.
You can still do a JAM stack with PHP. The â€œAâ€ doesnâ€™t have to be Node.
TBH, is you know JS well enough, then you can make the backend API code just in JS (nodejs &amp; stuff).
That's cruel
&gt;If an Email Entity can both load and save itself to/from a database -and- validate whether it's a valid email, etc., those are two very different responsibilities. I agree, as I thought I made clear in the previous response "There is a very big difference between a value object [...] and something like a model entity that can save itself to the database, perform validation and retrieve other models from a datastore". A value object shouldn't be able to store itself anywhere, but it should absolutely contain business logic. Persistence isn't business logic, it is an implementation detail. &gt;If VOs are also immutable and can and should contain business logic, and same w/ DTOs, then I really struggle with how DTOs are different than VOs... VOs are immutable and should contain basic business logic like validation. DTOs don't have to be immutable, and should never contain business logic, only methods for accessing and mutating the data. &gt;DTOs in PHP are a form of read-only Struct. Thus, they should be devoid of business logic, just like structs should be. VOs are more like read-write structs. The problem I'm trying to point out is that these are definitions you have made up and they don't correlate to the definitions of the terms as they are widely used. Even Wikipedia article has a fairly shortly summary of both (although I'd highly recommend reading PEAA, the DDD book or Martin Fowler's site for me): &gt;a [value object](https://en.wikipedia.org/wiki/Value_object) is a small object that represents a simple entity whose equality is not based on identity. [...] Value objects should be immutable: this is required for the implicit contract that two value objects created equal, should remain equal. &gt;A [data transfer object](https://en.wikipedia.org/wiki/Data_transfer_object) is an object that carries data between processes. The motivation for its use is that communication between processes is usually done resorting to remote interfaces (e.g., web services), where each call is an expensive operation. [...] The difference between data transfer objects and business objects or data access objects is that a DTO does not have any behavior except for storage, retrieval, serialization and deserialization of its own data (mutators, accessors, parsers and serializers). [...] This pattern is often incorrectly used outside of remote interfaces. This has triggered a response from its author where he reiterates that the whole purpose of DTOs is to shift data in expensive remote calls.
**Value object** In computer science, a value object is a small object that represents a simple entity whose equality is not based on identity: i.e. two value objects are equal when they have the same value, not necessarily being the same object.Examples of value objects are objects representing an amount of money or a date range. Being small, one can have multiple copies of the same value object that represent the same entity: it is often simpler to create a new object rather than rely on a single instance and use references to it.Value objects should be immutable: this is required for the implicit contract that two value objects created equal, should remain equal. *** **Data transfer object** A data transfer object (DTO) is an object that carries data between processes. The motivation for its use is that communication between processes is usually done resorting to remote interfaces (e.g., web services), where each call is an expensive operation. Because the majority of the cost of each call is related to the round-trip time between the client and the server, one way of reducing the number of calls is to use an object (the DTO) that aggregates the data that would have been transferred by the several calls, but that is served by one call only.The difference between data transfer objects and business objects or data access objects is that a DTO does not have any behavior except for storage, retrieval, serialization and deserialization of its own data (mutators, accessors, parsers and serializers). In other words, DTOs are simple objects that should not contain any business logic but may contain serialization and deserialization mechanisms for transferring data over the wire.This pattern is often incorrectly used outside of remote interfaces. *** ^[ [^PM](https://www.reddit.com/message/compose?to=kittens_from_space) ^| [^Exclude ^me](https://reddit.com/message/compose?to=WikiTextBot&amp;message=Excludeme&amp;subject=Excludeme) ^| [^Exclude ^from ^subreddit](https://np.reddit.com/r/PHP/about/banned) ^| [^FAQ ^/ ^Information](https://np.reddit.com/r/WikiTextBot/wiki/index) ^| [^Source](https://github.com/kittenswolf/WikiTextBot) ^] ^Downvote ^to ^remove ^| ^v0.28
Or yourself.
Cli that uses caps should probably be a red flag
The way I do it in my `Validator` class is by having an `isValid` method that returns true or false, and a `getValidationMessages` method. That way you can check if it's valid semantically without using `is_null` or `empty` or something of the sort
Some of the code formatting I saw on the site also made me a little wary.
Yeah Nah there's a lot of red flags on this site
I think you're both seeing TypeScript incorrectly. TypeScript is a different language than JavaScript that "transpiles" to JavaScript. It should not be seen, IMO, as a framework or as a "layer over JavaScript" (despite being a superset of JS).
&gt; You can't be serious. How exactly do you hope to maintain a codebase which spans millions of lines when everything is a function? &gt; I can understand that some of you are against OOP but it's simply one of the best approaches in large codebases, because humans understand 'objects' naturally. &gt; Coding procedurally makes large apps much harder to maintain. He can be serious (depending on what he means by OOP). OOP, in the Java sense, makes million-line codebases a NIGHTMARE to refactor. Deep inheritance hierarchies with interfaces-at-definition are very brittle to add features to. Mutable state makes debugging and unit testing very difficult and tedious. It also makes concurrency/parallelism very difficult and bug-prone. Pure functions with "dumb" structs and interfaces that can be implemented after the fact make for much more flexible and maintainable code in a lot of people's opinions. Also, he did not advocate for coding procedurally. I'm *guessing* he would advocate for *functional* programming, which is a very different approach. PHP is busy copying Java's OOP while Java is trying to add in functional features.
That means you object has a state which I think is suboptimal in this situation.
They don't have to break backwards compatibility to create sane APIs. Yes, the old APIs should be deprecated-- but we're still basically left with the same inconsistent mess we had before: with inconsistent error handling, inconsistent return types, inconsistent names, inconsistent parameters, and more. Only now we have: namespaces, strict type hinting/returns, PHP errors as throwables, and 64-bit integers. Yay(?)
So when are you supose to use this? Is it a cost saver or just another application in the stack?
Never. The php built-in web server is not fit for production.
I am triggered by the fact that when you go to "Features" it is not highlighted, "Home" stays highlighted... Such a small thing but it slaps you in the face because it is at the top of the page.
It was clearly just for the sake of the example.
I'd like to hear pros and cons of this approach against containerization solutions like Docker. Both ran on hyper-visors, right? Are they just lightweight? What I miss from having a Docker image?
Tried on mobile, it's even worse?
Yes. If you're a person who likes something a little more hands-on than, say, Heroku, but don't want to provision everything from scratch by working directly with DigitalOcean to spin up a new Droplet, Forge is GREAT. While there are some nice automations to help keep your dependencies up to date and such, eventually a Forge-provisioned host will likely become too outdated at the core-OS level for Forge to be able to continue to manage it. I've had this happen on most of my Forge hosts I'm managing. LetsEncrypt is supported by Forge, now, but trying to get it working on most of my older Forge hosts usually takes SSH/sudo in order to get it going. I think in at least one case I gave up. In short, I have a few hosts with old unsupported versions of PHP and old-enough versions of the OS that it would require doing some massive work to upgrade the host. It would be much easier to just roll a new host at that point. This would be much less of an issue if Forge allowed you to move sites to other servers. It would be \*awesome\* if I could spin up a new Droplet with the newest OS using Forge and have the configurations for older sites on older server transferred to the new server.
A huge red flag is location in the [Coding Guide](https://micro-framework.readthedocs.io/en/latest/contributing/coding.html) in the documentation. Confusing service location for dependency injection and saying that static methods are better. &gt;Avoid using dependency injection for all parts of the framework, internally. Dependency injection is a resource-intensive mechanism: &gt; * it needs to identify the element to instantiate ; &gt; * then to proceed to its instantiation ; &gt; * to finally assign it to a member of a class
You'd have to overload core PHP functions in place if you don't break backwards compatibility unless you update function names as well. In some places that might be tolerable if not desired in others it would create a nightmare. If it were an easy fix it would have been fixed already.
Cons to this application: It's insecure and horribly inefficient. Pros to this application:
If you don't want to manage your server. You can try out Amezmo. The idea is to automate away all server provisioning and security to allow you to just focus on code, but with the capability of instrumenting your server, should you need libraries, or other tasks to run for your deployments.
Why is that?
Looks very cool! What kind of features are you looking to add? It would definitely help others contribute if you open those as issues on the github tracker.
A (non-exhaustive) list of reasons not to use the built-in PHP server: - It's single threaded. This issue is twofold because A) You cannot serve more than one user at a time. B) It's easy to DDOS. - There's no request/application logging. With Apache/Nginx as a web server you have built in, highly efficient logging. Doing this you have to write your own logging for *everything*. - It's slower to serve than nginx because it's not optimized to be used in production. It might even be slower than Apache. - It doesn't support HTTP/2 or even HTTP/1.1 - No support for any extensibility features like security, caching, rewrites, etc. - It will automatically directory traverse if an index is missing all the way up to the highest accessible root. - The documentation itself [explicitly warns not to use it in production.](https://php.net/manual/en/features.commandline.webserver.php)
Oh god, no! It was clearly just an example, man! LOL! I'm talking about this unikernel approach, not about the PHP's built-in server ðŸ¤¦â€â™‚ï¸
With namespaces and methods on primitive methods? Not really. It' _shouldn't_ just be a copy of functions to namespaces, or a rename of functions to methods. The APIs should be much better: ideally taking the best things from other languages like Rust/Ruby/Javascript/Java. Having a concept of immutability or structs (copy-by-value object-like things with typed properties) could help a lot with the API, too. I'm not really convinced this standard is the best practice going forward: $pdo = new PDO( 'mysql:host=127.0.0.1;port=3306;dbname=mysql;charset=utf8', 'user', 'password', array(PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION), );
So how exactly do you propose serving PHP without using PHP's built-in server in a unikernel approach, where you don't have access to php-fpm, cgi-bin or mod_php methods, all of which require a running linux kernel at the very least?
Swoole, Amp, ReactPHP, Kraken... please, come to 2019.
Swoole is a separate application that requires a unix kernel. AMP has barely been touched in 2 years and hasn't had a passing build in 3 months. Kraken hasn't been touched in 2+ years. React might work? But still shares most of the issues listed above.
What exactly do you mean by "requires a unix kernel"? Isn't just a matter of packing PHP with the Swoole extension? There are Nginx and Node.js already, for example, they don't use the "unix kernel"?
The Swoole documentation states that it only runs on Linux, FreeBSD or MacOSX - unfortunately I can't really tell you why, because for some reason the prerequisites documentation has been half replaced with lorem ipsum and a request to pay to read the rest.
You can't just replace that example with one of the SAPIs that are normally used because they're all single-threaded and require multiple processes. The unikernel needs a single process which would require multithreading in order to support concurrent requests. This leaves you with the built-in web server or ReactPHP.
&gt;Swoole is an open source, production ready async programming framework for PHP. And yet you have to pay to read the documentation. What on Earth? However, the AMP http-server master branch build does seem to be passing, had a release four onths ago and is being actively developed.
That just means you're letting the end-developer create and/or make (via changing properties after instantiation) inconsistent and/or invalid objects. This is a representative of a terrible design architecture. Since you think this is good, I doubly urge you to enforce immutable DTOs in your projects. It'll really help, nay force, you to get rid of bad habits.
Gentle reminder that not everyone things that re-implementing a web-server in PHP (or as a PHP extension) in favour of php-fpm is a good idea for security reasons
What about Swoole?
Almost 3 months ago, I posted my PHP framework here in the community. &amp;#x200B; Yes, at that moment it was far from usable, I received a lot of great feedback and some useful recommendations, today my framework has evolved and grown to a point that it doesn't look anything like the original version I posted here. &amp;#x200B; I applied composer, namespaces, phpdocs, design patterns, improved the code structure and added more utilities. &amp;#x200B; I'm in a state that I want to pulish it to have a perfectly usable framework before launching the 1.0 version. I would like to hear the opinion of the experienced people one last time. So any feedback or criticism is highly appreciated. I'm also willing to answer questions about the development like an AMA. &amp;#x200B; Greetings :)
Congratulations
Pull the index file from the root and put it in public
It's so small, it doesn't have a single test!
My first look gave me a "Christ, this brings me back. I should f**k around with basic again and make an RNG game. That is to say I like it because it hits my member-berry/nostalgia.
Man.. I'm torn. There has clearly been a lot of work on this project. It completely grates against my own accepted style, but it's clearly thought through. Like the test suite: AcceptanceTester $I and $I-&gt;click ( "#bt-init-cache" ); I hate it, but it's preference.
You could do this relatively easily with a WordPress website and some plugins
Iâ€™ve been using FullCalendar a lot lately, which is a really flexible JavaScript library. The backend I use is PHP and SQL for a database - you can use whatever database you want. They have a reasonably-priced resources plugin as well. I know you said you were looking for PHP but if you know JavaScript this works really well with PHP via AJAX.
Just find another job
What part of that made you feel this was a reasonable response? (Real question - I'm too engulfed to see the forest through the trees etc..)
Iâ€™m just trying to be funny. Honestly, I read what you wrote and I donâ€™t understand what you are asking exactly
Why not use Google Calendar? G Suite is free for educational organizations.
Are you using any frameworks already, or is this standalone?
Itâ€™s sort of difficult to understand whatâ€™s veinte asked here. I think it depends on how much time you have available and the prioritization of your tasks. If you have the time, then do it the full scale method. If not, do the quick patch and return to it later. Also, it depends on your bosses expectations. Lots to consider.
Okay - so I guess I didn't actually ask a question here. I'm asking which approach you might take given the limited context I've given. The time-frame has unfortunately shrank. Looking at a few weeks. A few weeks, of course is still vague, but given a promise of a resolution I can buy time. I guess I was just trying out my options in written word, but I know the approach I want will take a couple months and I'm already against the wire at a couple weeks. All soft/vague time lines. Thanks for reading and any input given.
Nice work, man!
Don't rewrite everything; do incremental changes. For example, just add tests for what you currently touch. Everything else would wait. At least, that's what I would do.
You're never going to grow being a sole developer. It's how people become extremely mediocre "15 year senior dev" with extremely huge egos.
The unprofessional hobbyists need to stop playing with things they don't even remotely understand. This post is one of those things best left to the professionals. You should never run PHP as a "unikernel" in this way. It will lead to disaster, the first time you have more than 5 active users, probably.
It has zero tests. Stay the fuck away. Also, it doesn't state -why- or how it compares. A single advantage that it offers, etc. If I look for Laravel devs, I can instantly find people who know it. That is a huge bonus.
https://github.com/phpMv/ubiquity/blob/master/src/Ubiquity/translation/TranslatorManager.php HOLY FUCK!! Static class alert!! "Not knowing what DI is" alert!! **Defending static classes over DI** alert!! Abandon ship! Abandon ship!
https://github.com/phpMv/ubiquity/blob/master/src/tests/acceptance/DiCest.php In 2019, don't people realize that if they use their own special little styles that they will be judged as noobs? Obviously not the people I work with!! Oh how they griped and griped when I enforced php-cs-fixer. Can't fight the bot, and I throw up my hands in mock resignation.
I would split \System into a new repo and pull in with composer to allow easier framework upgrades. But I see you have zero dependencies so it might have been a conscious decision to avoid that. If so, think about how your users will update the system directory for new features / bug fixes.
+1 for Symfony Console
Thereâ€™s nothing wrong with being pragmatic. If people asked for stuff and it never got done and nobody is still screaming for it, itâ€™s just not that big of a deal. While most of my fun personal projects have 95%+ test coverage, my main work project has hovered around 50% for the last year or so (not incredible, not horrible, and importantly itâ€™s not falling over time). Chasing numbers like that is an exercise in futility when there are business goals that need to be hit to keep the people that sign your paycheck happy. And unless something is super stable or incredibly well-defined, you can end up making it harder to make some future changes. That said, apply PHPStan or similar tools as liberally as possible. Hard to give any advice specific to your situation, other than to remember that work projects are done to achieve a specific goal, and itâ€™s exceedingly rare that goal is making the developer feel good about the codebase. Give yourself some leeway to make improvements, but remember that people wonâ€™t be happy if you take months to refactor stuff while shipping nothing.
Well, in the beginning I used it to write Snake game. Would you like a cli game engine?ðŸ˜Ž
"Im not good at linux so i need serverless" \*learns hours of hours of serverless stuff not realizing they dont need it and doing all the things wrong\*
Hi, so if you look at the dashboard, you can see the pricing plan is $10 per month. The difference between Envoyer and Amezmo is that Amezmo provides a provisioned server for you. At the equivalent of a $5 droplet, it actually comes out less than what Envoyer charges it seems. But they have a great product too. Itâ€™s just that we are different.
 I have a form, details getting from customer and calculate the grand total, here how can i pass my grand total value to ccavenue payment gateway page and getting payment form customer? code : https://www.pastiebin.com/5cdbae859bb64
 I have a form, details getting from customer and calculate the grand total, here how can i pass my grand total value to ccavenue payment gateway page and getting payment form customer? code : https://www.pastiebin.com/5cdbae859bb64
 I have a form, details getting from customer and calculate the grand total, here how can i pass my grand total value to ccavenue payment gateway page and getting payment form customer? code : [https://www.pastiebin.com/5cdbae859bb64 1](https://www.pastiebin.com/5cdbae859bb64)
Yep.
&gt;I applied &lt;...&gt; design patterns They used coding and algorithms!
Don't rewrite everything; do incremental changes. And use code quality tooling (phpstan/phpmd).
What sort of tests do you have? If the some tests are just unit tests, it might be worth having a look at creating some functional tests before starting any sort of new development. In terms of modularising a monolithic project, it's hard to say where to start without seeing the code base... but here goes. 1. Identify what features/services/components have been done better by somebody else. These will be good candidates to refactor out of your application; the advantage of which will be to make those components somebody else's problem. For example: say you developed a component that handles sending emails - this can probably be replaced by [SwiftMailer](https://github.com/swiftmailer/swiftmailer) or [PHPMailer](https://github.com/PHPMailer/PHPMailer). The size of you monolith has reduced by exactly one email component. Have a look at some of the components that make up Symfony, Lavarel, or Zend frameworks for some inspiration. 2. Anything that you are going to modularise, write some extra tests and maybe see if you can solidify your API by using interfaces within your monolith. E.g. instead of `function set(Kabobulator $thing) {}` use `function set(KabobulatorInterface $thing) {}`. 3. Set reasonable and achievable goals as well as a timeline. You can't refactor overnight, and the bugs you introduce may not get detected for some time. So make a plan well ahead of refactoring and inform your end-users of changes to the system before they happen. 4. Have a solid and tested rollback strategy in place. Prove to yourself that you can rollback a change quickly without impacting the business. Do this before you introduce a new feature (read: bug). I hope these ramblings have helped. Good luck!
Nice one!
Make side projects and add them to composer.json
You should post this on r/phphelp. This is not the place for this.
I know that this is a minimal framework, but why don't you use some ORM? I think it's so much easy and better to have one. &amp;#x200B; But it looks nice, I will have a try tonight
One trick pony?
Because you don't always need a datastore. When you include an ORM in a minimal framework you automatically force users of your framework to use that specific ORM. Or have a large chunk of code unused in your codebase.
Because you don't always need a datastore. When you include an ORM in a minimal framework you automatically force users of your framework to use that specific ORM. Or have a large chunk of code unused in your codebase.
Because you don't always need a datastore. When you include an ORM in a minimal framework you automatically force users of your framework to use that specific ORM. Or have a large chunk of code unused in your codebase.
Yeah, I understand that and I know that this is a lock, a big one and that people don't need a DB always or an ORM, but using a Query Builder without an ORM, this is what I think it's strange...
A few thoughts, feel free to ignore them: - I like the name - PSR-2 is an extension of PSR-1, so if you comply to PSR-2 you automatically comply to PSR-1 - You comply to PSR-4 and yet your `composer.json` contains a number of files that are to be autoloaded in a non-PSR-4 way. And you have a PSR-4 compliant entry for every folder it seems. If you opt for a `Wolff` namespace you could refer that namespace to `system`. - Why would you explicitly mention compliance with PSR-1, -2 and -4 and introduce your own interface for caching? There are two PSR's for caching available - As mentioned before by tomeh_84; the approach you took will not allow for simple upgrading of projects using your framework. By using `composer create-project` any reference to your package is gone. You could split the code up into two repositories; one that will contain the file structure - listen to gripejones and consider to introduce a `public` folder - that can be used with `composer create-project` and one that will contain all the core code. This way the codebase of projects based on your framework will only contain custom logic and configuration. Additionally this will allow users of the framework to upgrade to newer versions much easier. - Why do you have a query builder and a database abstraction in a minimal framework? With all the microservices nowadays I find myself creating more and more projects that don't perform any data retrieval or persistence other than via http clients. Other than that argument existing abstractions/ORMs - like Doctrine or Propel - are much more versatile and battle tested. - You have put in a substantial effort in writing the docs - very nice - but I personally favor the approach of taking a problem and solving it. Let's take the database; all possibilities are explained, but I don't know how to get an instance of the database or how to configure that database. - Read up on interfaces; if I wish to not use your template engine/format by another one this will be difficult. If you specify a proper interface and allow for configuration/injection you would be able to offer adapters to other template engines. All in all I think it is a good effort, but I feel you are somewhere between a minimal framework and a full fledged framework with just a limited amount of files. If you actually want to make your framework minimal, look at some PSRs - by using PSR-7 and PSR-17 the choice of implementation is up to the user, same goes for caching - PSR-6 or PSR-16, the controller/request handling - PSR-15. It will not only reduce your own code, but will also make your framework very flexible. You can use the `suggest` option in Composer to suggest implementations. If you are really opposed to the whole PSR thing you could also offer your own interface for these functionalities and have a similar flexibility.
Yes, there is currently a system branch with only the core files required to run. I haven't updated it yet, but I will do it for the 1.0 version :)
If someone is, that's *his* problem. Post away.
I'm aware of the tests, in the last few days I have been working on them and soon I'll post them.
Not you bro, I obviously meant the other guy who seems extremely opinionated. You're alright :)
wtfs per minute obviously, 3 wtfs per minute = ok, but 4 you leave the building and the PR is closed.
Congrats. I know that had to be a lot of work.
tests can't fail if there are no tests https://media.giphy.com/media/d3mlE7uhX8KFgEmY/giphy.gif
tests can't fail if there are no tests https://i.imgur.com/QDYNC3m.gif
I really like how Laravel Zero has you run composer for everything, but provides an easy-to-call wrapper to both do that and setup all the wiring for you.
Wide open to anything!
I don't think that's a fair assessment. Growth might be stunted, but I feel like I've grown leaps and bounds over the years, but I have to work harder it at without having someone to give me a code-review. My code-reviews look a lot like what's happening now. I haven't touched the project in years, and now I have to get back into it.
Nice tool, though I'm looking at this and I can't help but wonder if we let the metrics become our reality. You can't measure "architecture" via automated tools. It's nonsense. Maybe 10% of architecture is checkable this way (dependency graphs) and the other 90% is about what the intent of the architecture is, what the goal of the app is, how it'll evolve in time etc. Still, nice tool though!
Amp is passing, just somehow phpdbg has a problem on 7.3+, but that's not an amp bug but a php-src bug. It isn't touched a lot because ... uh, it's quite stable and we want to avoid feature creep in the core repo. the other amphp repos are getting love though...
why are 90% of the commit messages "wip"
because version control is hard
More like Redundant.
In my experience the main thing people have against PHP is that the last time they actively used it was with PHP3 or PHP4 at most, at the same time as they are comparing that with modern javascript/java/C#.
[https://github.com/phpMv/ubiquity/tree/master/src/tests](https://github.com/phpMv/ubiquity/tree/master/src/tests)
 public static function diBootstrap($controller, $options = ["defer"=&gt;true,"gc"=&gt;true]) { $jquery = new \Ajax\php\ubiquity\JsUtils ( $options, $controller ); $jquery-&gt;bootstrap ( new \Ajax\Bootstrap () ); $jquery-&gt;setAjaxLoader ( "&lt;div class=\"ui active centered inline text loader\"&gt;Loading&lt;/div&gt;" ); return $jquery; } this gave me cancer
A new version is in the works which already supports your type of URLs. Plus you can write your own URL provider so that if you are using a custom solution it will work. I'll let you know when I release this version.
Says "don't avoid dependencies". Recommends a dependency for basic configuration. Sorry, I just...
I personally would start by implementing exactly what was asked for against the existing code base. Get that out of the way so you can deliver on time. After that, maybe take some time doing your copy/paste into a new project just to see what problems you run into. What seems easy at first might prove to be unexpectedly difficult. The urge to refactor everything often results in failure. Lots and lots of horror stories out there. Once your time is up then you might consider continuing the refactor process on your own time or possibly as part of training time. If successful then you will have something to offer the next time changes are needed. If not, you will at least learn quite a bit.
[removed]
&gt; Also, it doesn't state -why- or how it compares I think the main aim is speed. [The GitHub page](https://github.com/phpMv/ubiquity/) links to http://www.phpbenchmarks.com/en/comparator/framework.
For readability: A few thoughts, feel free to ignore them: - I like the name - PSR-2 is an extension of PSR-1, so if you comply to PSR-2 you automatically comply to PSR-1 - You comply to PSR-4 and yet your `composer.json` contains a number of files that are to be autoloaded in a non-PSR-4 way. And you have a PSR-4 compliant entry for every folder it seems. If you opt for a `Wolff` namespace you could refer that namespace to `system`. - Why would you explicitly mention compliance with PSR-1, -2 and -4 and introduce your own interface for caching? There are two PSR&amp;#39;s for caching available - As mentioned before by tomeh_84; the approach you took will not allow for simple upgrading of projects using your framework. By using `composer create-project` any reference to your package is gone. You could split the code up into two repositories; one that will contain the file structure - listen to gripejones and consider to introduce a `public` folder - that can be used with `composer create-project` and one that will contain all the core code. This way the codebase of projects based on your framework will only contain custom logic and configuration. Additionally this will allow users of the framework to upgrade to newer versions much easier. - Why do you have a query builder and a database abstraction in a minimal framework? With all the microservices nowadays I find myself creating more and more projects that don&amp;#39;t perform any data retrieval or persistence other than via http clients. Other than that argument existing abstractions/ORMs - like Doctrine or Propel - are much more versatile and battle tested. - You have put in a substantial effort in writing the docs - very nice - but I personally favor the approach of taking a problem and solving it. Let&amp;#39;s take the database; all possibilities are explained, but I don&amp;#39;t know how to get an instance of the database or how to configure that database. - Read up on interfaces; if I wish to not use your template engine/format by another one this will be difficult. If you specify a proper interface and allow for configuration/injection you would be able to offer adapters to other template engines.
 [https://twitter.com/noplanstomerge/status/1108396686337036289](https://twitter.com/noplanstomerge/status/1108396686337036289)
Using LSP with PHPStorm and psalm results in exceptions due to psalm sending a â€œ-1â€ position when thereâ€™s a multi line return statement. Thereâ€™s an open issue for it but itâ€™s been buried. Various other exceptions get thrown by the lsp plugin but I havenâ€™t been using it enough lately to add issues to it.
No scriptability makes this a non-starter. At the very least JSON output should be supported, but it seems that feature request was closed unceremoniously. That kind of attitude is a hard No for me.
[Yes](https://dev.mysql.com/doc/refman/8.0/en/with.html#common-table-expressions-syntax)
Cancer killed a colleague of mine yesterday, you stupid fuck!
It looks nice, but i'm scared of the results if i'm using it in my project...
Time is precious, so apply it to something that is going to be valued. If the gaps in testing carry a high amount of risk for the product or its dependents, deal with those as a priority. Then, simply supply what is requested.
Fork it. Make it. Contribute.
Please post this to /r/phphelp
Donâ€™t know if thatâ€™s a rhetorical question, but mainly for saving down during early development without caring about commit messages. Usually these should be squashed though
There seems to be something off with you DNS config, I can't access your domain from Mexico : [http://hakr.ws/s/b6roh.png](http://hakr.ws/s/b6roh.png)
This guide assumes that you have a basic understanding of PHP and programming concepts, and that you have access to a server capable of running PHP. Although there are other ways to scrape a web page with PHP, this guide will focus on the Simple HTML DOM Parser. I have chosen to use this library because this is the library that I have experience with and it is easy to use with great documentation. **Installing the Library** The first thing you need to do is download the scraping library from SourceForge. You can do this by going to http://simplehtmldom.sourceforge.net/ and clicking on "Download latest version from SourceForge". Once you have downloaded the library from SourceForge, unzip the compressed folder. Then move the "simple_html_dom.php" file to the folder that you will be building the web scraper in. **Writing the Scraping Code** Now that you have the library installed you can begin writing your scraping code. &lt;?php # This imports and gives us access to the scraping library include('simple_html_dom.php'); ?&gt;; Now that you have access to the scraping library, you can use the file_get_html function to create a DOM object from a url. &lt;?php # This imports and gives us access to the scraping library include('simple_html_dom.php'); # Create HTML DOM object from url $html = file_get_html('https://google.com'); ?&gt;; You can then pull specific elements from this DOM object by calling the find method and passing in the tag name of the element you would like to grab. You can also pass an index if you would like to grab only a single instance of a particular tag. If you want to grab an array of tags, you refrain from passing an index. # Create HTML DOM object from url $html = file_get_html('https://google.com'); # Gets the 0th title element from the DOM object and echos it to the webpage echo $html-&gt;find('title',0); # If we don't pass an index we can get an array of all the anchor elements from the DOM object $array_of_anchors = $html-&gt;find('a'); # We can echo all of the anchor elements from the array above by using a simple for loop for( $i = 0; $i &lt; sizeof($list_of_anchors); $i++ ){ # echo each anchor by using the $i iterator to pull the anchor in each index position echo $list_of_anchors[$i]; } In addition to selecting elements based on their tag name, you can select elements based on class or ID. $html = file_get_html('https://google.com'); $array_of_hidden_divs = $html-&gt;find('div[class="hidden"]'); $array_of_thumbnails = $html-&gt;find('img[id="thumbnail"]'); The find method returns a DOM object. This means that we can call the find method on itself to grab child elements. $html = file_get_html('https://google.com'); $ul = $html-&gt;find('ul',0); $array_of_li = $ul-&gt;find('li'); # This is the same as above, but in a single line $array_of_li = $html-&gt;find('ul',0)-&gt;find('li'); You can extract certain data such as the text of an element, or the hyperlink reference of an anchor tag, or the source of an image. $html = file_get_html('https://google.com'); $button_text = $html-&gt;find('button',0)-&gt;plaintext; $anchor_href = $html-&gt;find('a',0)-&gt;href; $image_source = $html-&gt;find('img',0)-&gt;src; I hope this helps you accomplish your PHP Web Scraping needs. Feel free to ask questions if you need any clarification. I highly recommend reading the documentation on the sourceforge website.
&gt; If your performance issues are being caused by high concurrent visitors, then increasing the number of cores is likely to be a better solution. If you have a lot of concurrent users more cores would probably reduce blocking on long running queries but if you have a level of traffic that would justify looking into this you're probably better off looking at things like load balancing, redis, or caching (full or partial page caching). Tuning to this level is largely a hold over from pre-cloud days when scaling out was difficult and you had to make as best use of the hardware as you could because your app wasn't moving anywhere or getting and help outside of that thing. Modern web apps probably shouldn't agonize over hardware characteristics or whether they're being absolutely 100% efficient within the application (unless there's a particularly heavy hitting operation). It usually pays better dividends to just have several cores operating at a reasonable speed and then horizontally scaling new application servers out from there as needed. If that's overkill then your website's probably not high traffic enough to really worry about this stuff.
Another gem from their "coding guide": &amp;#x200B; &gt;Ubiquity coding standards are based on the [PSR-1](https://www.php-fig.org/psr/psr-1/) , [PSR-2](https://www.php-fig.org/psr/psr-2/) and [PSR-4](https://www.php-fig.org/psr/psr-4/) standards, so you may already know most of them. &gt; &gt;... &gt; &gt;***Use Tabs, not spaces;*** &gt; &gt;***Use brace always on the same line;*** &amp;#x200B; Did they even read PSR-2?
I mean even a vague description of what the commit did would be better right? like "fix function x" or "add x class"
wait what? He said DON'T AVOID DEPENDENCIES - as in don't be afraid to use them. Are you stupid?
Not if it's built properly. That is to be used with ANY orm. Then you can just plug in your own ORM that you like and go on your way.
There's nothing (or rather too much) to describe. At first you do just rapid prototyping, nothing is set in stone and you move things around quite a bit. Hard to put it into words as it is not A -&gt; B change but rather A -&gt; C -&gt; D -&gt; fuck -&gt; C -&gt; B
I don't think people are going to be like "Hey, we need 20% traits", some things are useful - most of it is just nice to know because.. we all love metrics! Don't we? ðŸ˜„
&gt; This guide assumes that you have a basic understanding of PHP and programming concepts Perhaps that should be a requirement for writing a guide as well
I'll take "feature branches" for $100 Alex.
I am confused what why this tool has "instant" in its tagline. Doesn't it have any or really short run times compared to other tools?
I guess it depends on what other people are reacting to but the biggest thing for me is the idea that someone is actively working off master instead of merging commits into it as they complete whatever it is they're working on. Any commit that can be considered "WIP" at the code level should go into a either a private user branch or a feature branch. Once complete you can merge all the work in at once. Otherwise you run the risk of people (ignorant of what you happened to be doing in the moment) assuming one of the main branches like `master` represents the a reliable state of the software. For example, if you're implementi There are exceptions for just personal stuff where you're the only consumer but pushing half-written code to a main branch (and the default branch at that) seems like a bad idea. If it's not half-written code then it's by definition not really "WIP" in any meaningful sense.
No I'm not stupid. I'm saying he says "you should use more dependencies" and then picks as an example the most useless dependency in existence. This proving that no, you shouldn't liberally use dependencies. If you've reached the point where using dotenv library seems like a great idea, you're using too many dependencies.
A commit message of `WIP` still doesn't describe anything. If all you're doing is prototyping or scaffolding then having a commit message of `Initial Scaffolding` is a decent commit message. Just saying `WIP` doesn't tell me what the last change was once the commits come into master. Especially when you're trying to figure out which files have been updated and when but each one shows a previous commit of just `WIP` regardless.
Ouch, that almost stings. I guess that's the price for trying to help people out!
We love metrics because they claim to be a fast and efficient way of delivering information that is actually quite hard and complicated for a machine to obtain in an automated way. So basically we love good news, even if they're a lie.
phpstan and friends works well for me...
&gt; For Javascript in particular, this has led to some trojans or malware being installed as the bad code can be slipped in to the release, no matter what was tagged as the release. This is actually an issue for most languages (I mean repos can be compromised and bad commits can get through) and is why there are repo management platforms like Pulp or Artifactory. Managing the code you pull down is part of the deployment process. Even if you aren't worried about malware making sure you can freeze libraries at a particular version and then bump them en masse when you want has value to developers.
&gt; And how is github registry eliminating this loophole? fwiw I think they're saying that a _distributed_ package repository eliminates this issue. For example, you can do something similar in a self-hosted gitlab instance (or Artifactory, etc) and then have host-based controls for making sure the code you pull down to your local network is coming from where you think it's coming from.
It should sting. I'd love to see the price paid if you'd interview with this piece of (uhm....) code... Good luck.
Looks to me like you are trying to help yourself out by promoting your YouTube channel.
Sourceforge? Global functions? No namespaces? No composer package? No thanks.
Hear, hear.
You are free to reinvent the wheel if you want but I'm pretty busy getting shit done.
what are you going to do when some stupid fuck kills another one of your colleagues?
"Oh no I have to reinvent the wheel!" About a dependency that's basically... this: &lt;?php $_ENV += [ 'MY_SETTINGS' =&gt; 123, 'HERE' =&gt; 123, ]; Honestly this is dumber than the NPM "leftpad" meltdown fiasco.
my project is to big, it crashes even with 32gb ram after 45 min, should probably have a simple way to make it scan only a folder, or set of files or something
Thank you for introducing me to a new podcast!
What font is used in the terminal screenshot?
I also use my private repos to recover from "fuck"
This reminds me of those site speed tests. The kind of test that will knock you down 10pts just because you didnâ€™t compress a tiny css file or combine two small JavaScript files into one. Itâ€™s good in theory, but Iâ€™ve had clients say â€œwe have to be above 90%â€ even though their site is just fine.
Theyâ€™re too busy complaining.
Yeah.. don't avoid dependencies.. so here is a dependency you should check out.. is English not your first language?
Don't let the spoiled github hipsters get to you. Nice job on the tutorial man, I get that this is more of a beginner friendly tut, and that's fine, there are people who are probably interested in this, in this sub. I've used Simple HTML DOM countless times in the past and it does the job, however, nowadays I prefer using [https://code.google.com/archive/p/ganon/](https://code.google.com/archive/p/ganon/), where Simple HTML DOM fails - Ganon won't. :)
You should stick to lurking if you're going to lash out like an emotional child.
&gt; Don't let the spoiled github hipsters get to you. Hmm... So people who attempt to write clean, well architected code are hipsters now huh? The idea here is that PHP's reputation of being a bad language is still haunting us to this day and code like in that video isn't really helping our case.
Guy tries to help a way he can, everybody starts bashing him. Code in that video obviously isn't at an expert's level and there is no need to act all proud and smart, point the guy in the right direction, give advice, instead of attacking him straight on. Show some respect, nobody was born knowing everything. &amp;#x200B; When I said "spoiled github hipsters", I was referring to a group of people who can't see past their nose and judge a book by it's cover.
Let me spell it out for you: - "Don't avoid dependencies!" - Immediately demonstrates he uses too many dependencies and the previous is a bad advice. ... Get it? It's like someone saying "don't listen to people who tell you not to eat at McDonald's!" and they are 500 pounds.
Just because it doesn't use all the latest codememes, wait, I mean best practices, does not mean it doesn't work.
No need for composer, namespaces and other "good architecture" for such a small script; over-engineering is bad design.
[Version \`3.0.0\`](https://github.com/laravelista/Ekko/releases/tag/3.0.0) is here and it will work with your application URL structure I am sure. Let me know what you think of it.
I never mentioned any dependencies he/she used. Why don't you take a moment to actually read and comprehend.
Thank you to everyone who has provided some advice. My plan is to implement the feature in place as a way to buy time as I move it out of the monolith. Luckily I wrote this during a time I was being very academic so the patterns lend themselves to being manipulated without heavy rewrites and most of my tests are higher level (Acceptance/Integration) so changes to the smaller units doesn't cause red.
Did you read the code?
Yep, and saw the wrong variable name list_of_anchors instead of array_of
Yes, and closing php tags, and a semicolon outside of the php tags that if anyone found and copied this code for their script, they would be dealing with output errors if they needed to set header for redirects or any other reason. I will never discourage someone from learning, I just get irritated when they try to promote their blog or channel as a teaching resource when they clearly donâ€™t know what they are doing themselves